<!DOCTYPE html><html><head><title>Help for package sfhotspot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sfhotspot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoplot.hspt_c'><p>Plot map of hotspot classifications</p></a></li>
<li><a href='#autoplot.hspt_d'><p>Plot map of changes in grid counts</p></a></li>
<li><a href='#autoplot.hspt_k'><p>Plot map of kernel-density values</p></a></li>
<li><a href='#autoplot.hspt_n'><p>Plot map of grid counts</p></a></li>
<li><a href='#hotspot_change'><p>Identify change in hotspots over time</p></a></li>
<li><a href='#hotspot_classify'><p>Classify hot-spots</p></a></li>
<li><a href='#hotspot_classify_params'><p>Control the parameters used to classify hotspots</p></a></li>
<li><a href='#hotspot_count'><p>Count points in cells in a two-dimensional grid</p></a></li>
<li><a href='#hotspot_dual_kde'><p>Estimate the relationship between the kernel density of two layers of points</p></a></li>
<li><a href='#hotspot_gistar'><p>Identify significant spatial clusters of points</p></a></li>
<li><a href='#hotspot_grid'><p>Create either a rectangular or hexagonal two-dimensional grid</p></a></li>
<li><a href='#hotspot_kde'><p>Estimate two-dimensional kernel density of points</p></a></li>
<li><a href='#memphis_population'><p>Populations of census blocks in Memphis in 2020</p></a></li>
<li><a href='#memphis_robberies'><p>Personal robberies in Memphis in 2019</p></a></li>
<li><a href='#memphis_robberies_jan'><p>Personal robberies in Memphis in January 2019</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Hot-Spot Analysis with Simple Features</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Identify and understand clusters of points (typically representing 
    the locations of places or events) stored in simple-features (SF) objects.
    This is useful for analysing, for example, hot-spots of crime events. The 
    package emphasises producing results from point SF data in a single step 
    using reasonable default values for all other arguments, to aid rapid data 
    analysis by users who are starting out. Functions available include kernel
    density estimation (for details, see Yip (2020) 
    &lt;<a href="https://doi.org/10.22224%2Fgistbok%2F2020.1.12">doi:10.22224/gistbok/2020.1.12</a>&gt;), analysis of spatial association (Getis
    and Ord (1992) &lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.1992.tb00261.x">doi:10.1111/j.1538-4632.1992.tb00261.x</a>&gt;) and hot-spot
    classification (Chainey (2020) ISBN:158948584X).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://pkgs.lesscrime.info/sfhotspot/">http://pkgs.lesscrime.info/sfhotspot/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mpjashby/sfhotspot/issues">https://github.com/mpjashby/sfhotspot/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, rlang, sf, SpatialKDE, spdep, tibble</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), lubridate, knitr, rmarkdown, ggspatial</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-18 16:07:31 UTC; mattashby</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Ashby <a href="https://orcid.org/0000-0003-4201-9239"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Ashby &lt;matthew.ashby@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-19 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoplot.hspt_c'>Plot map of hotspot classifications</h2><span id='topic+autoplot.hspt_c'></span>

<h3>Description</h3>

<p>Plot the output produced by <code><a href="#topic+hotspot_classify">hotspot_classify</a></code> with reasonable
default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hspt_c'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.hspt_c_+3A_object">object</code></td>
<td>
<p>An object with the class <code>hspt_c</code>, e.g. as produced by
<code><a href="#topic+hotspot_classify">hotspot_classify</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.hspt_c_+3A_...">...</code></td>
<td>
<p>Currently ignored, but may be used for further options in future.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>
<p>This function returns a <code>ggplot</code> object, meaning you can further control
the appearance of the plot by adding calls to further <code>ggplot2</code>
functions.
</p>

<hr>
<h2 id='autoplot.hspt_d'>Plot map of changes in grid counts</h2><span id='topic+autoplot.hspt_d'></span><span id='topic+autolayer.hspt_d'></span>

<h3>Description</h3>

<p>Plot the output produced by <code><a href="#topic+hotspot_change">hotspot_change</a></code> with reasonable
default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hspt_d'
autoplot(object, ...)

## S3 method for class 'hspt_d'
autolayer(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.hspt_d_+3A_object">object</code></td>
<td>
<p>An object with the class <code>hspt_d</code>, e.g. as produced by
<code><a href="#topic+hotspot_change">hotspot_change</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.hspt_d_+3A_...">...</code></td>
<td>
<p>Currently ignored, but may be used for further options in future.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object.
</p>
<p>This function returns a <code>ggplot</code> object, meaning you can further control
the appearance of the plot by adding calls to further <code>ggplot2</code>
functions.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>autolayer(hspt_d)</code>: Create a ggplot layer of change in grid counts
</p>
</li></ul>

<hr>
<h2 id='autoplot.hspt_k'>Plot map of kernel-density values</h2><span id='topic+autoplot.hspt_k'></span><span id='topic+autolayer.hspt_k'></span>

<h3>Description</h3>

<p>Plot the output produced by <code><a href="#topic+hotspot_kde">hotspot_kde</a></code> with reasonable
default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hspt_k'
autoplot(object, ...)

## S3 method for class 'hspt_k'
autolayer(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.hspt_k_+3A_object">object</code></td>
<td>
<p>An object with the class <code>hspt_k</code>, e.g. as produced by
<code><a href="#topic+hotspot_kde">hotspot_kde</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.hspt_k_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="ggplot2.html#topic+geom_sf">geom_sf</a></code>, e.g.
<code>alpha</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object or layer that can be used as
part of a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> stack.
</p>
<p><code>autoplot</code> returns a <code>ggplot</code> object, meaning you can further
control the appearance of the plot by adding calls to further <code>ggplot2</code>
functions.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>autolayer(hspt_k)</code>: Create a ggplot layer of kernel-density values
</p>
</li></ul>

<hr>
<h2 id='autoplot.hspt_n'>Plot map of grid counts</h2><span id='topic+autoplot.hspt_n'></span><span id='topic+autolayer.hspt_n'></span>

<h3>Description</h3>

<p>Plot the output produced by <code><a href="#topic+hotspot_count">hotspot_count</a></code> with reasonable
default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hspt_n'
autoplot(object, ...)

## S3 method for class 'hspt_n'
autolayer(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.hspt_n_+3A_object">object</code></td>
<td>
<p>An object with the class <code>hspt_n</code>, e.g. as produced by
<code><a href="#topic+hotspot_count">hotspot_count</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.hspt_n_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="ggplot2.html#topic+geom_sf">geom_sf</a></code>, e.g.
<code>alpha</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object or layer that can be used as
part of a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> stack.
</p>
<p><code>autoplot</code> returns a <code>ggplot</code> object, meaning you can further
control the appearance of the plot by adding calls to further <code>ggplot2</code>
functions.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>autolayer(hspt_n)</code>: Create a ggplot layer of grid counts
</p>
</li></ul>

<hr>
<h2 id='hotspot_change'>Identify change in hotspots over time</h2><span id='topic+hotspot_change'></span>

<h3>Description</h3>

<p>Identify change in the number of points (typically representing events)
between two periods (before and after a specified date) or in two groups
(e.g. on weekdays or at weekends).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot_change(
  data,
  time = NULL,
  boundary = NULL,
  groups = NULL,
  cell_size = NULL,
  grid_type = "rect",
  grid = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_change_+3A_data">data</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing points.</p>
</td></tr>
<tr><td><code id="hotspot_change_+3A_time">time</code></td>
<td>
<p>Name of the column in <code>data</code> containing <code>Date</code> or
<code>POSIXt</code> values representing the date associated with each point.
Ignored if <code>groups</code> is not <code>NULL</code>. If this argument is
<code>NULL</code> and <code>data</code> contains a single column of <code>Date</code> or
<code>POSIXt</code> values, that column will be used automatically.</p>
</td></tr>
<tr><td><code id="hotspot_change_+3A_boundary">boundary</code></td>
<td>
<p>A single <code>Date</code> or <code>POSIXt</code> value representing the
point after which points should be treated as having occurred in the second
time period. See 'Details'.</p>
</td></tr>
<tr><td><code id="hotspot_change_+3A_groups">groups</code></td>
<td>
<p>Name of a column in <code>data</code> containing exactly two unique
non-missing values, which will be used to identify whether each row should
be counted in the first (before) or second (after) groups. Which groups to
use will be determined by calling <code>sort(unique(groups))</code>. If
<code>groups</code> is not a factor, a message will be printed confirming which
value has been used for which group. See 'Details'.</p>
</td></tr>
<tr><td><code id="hotspot_change_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> value specifying the size of each equally
spaced grid cell, using the same units (metres, degrees, etc.) as used in
the <code>sf</code> data frame given in the <code>data</code> argument. Ignored if
<code>grid</code> is not <code>NULL</code>. If this argument and <code>grid</code> are
<code>NULL</code> (the default), the cell size will be calculated automatically
(see Details).</p>
</td></tr>
<tr><td><code id="hotspot_change_+3A_grid_type">grid_type</code></td>
<td>
<p><code>character</code> specifying whether the grid should be made
up of squares (<code>"rect"</code>, the default) or hexagons (<code>"hex"</code>).
Ignored if <code>grid</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hotspot_change_+3A_grid">grid</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing points containing
polygons, which will be used as the grid for which counts are made.</p>
</td></tr>
<tr><td><code id="hotspot_change_+3A_quiet">quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, messages reporting the values of any
parameters set automatically will be suppressed. The default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a regular two-dimensional grid of cells (unless a
custom grid is specified with <code>grid</code>) and calculates the difference
between the number of points in each grid cell:
</p>

<ul>
<li><p> before and after a set point in time, if <code>boundary</code> is specified,
</p>
</li>
<li><p> between two groups of points, if a column of grouping values is specified
with <code>groups</code>,
</p>
</li>
<li><p> before and after the mid-point of the dates/times present in the data, if
both <code>boundary</code> and <code>groups</code> are <code>NULL</code> (the default).
</p>
</li></ul>

<p>If both <code>boundary</code> and <code>groups</code> are not <code>NULL</code>, the value of
<code>boundary</code> will be ignored.
</p>


<h4>Coverage of the output data</h4>

<p>The grid produced by this function covers the convex hull of the input data
layer. This means the result may include zero counts for cells that are
outside the area for which data were provided, which could be misleading. To
handle this, consider cropping the output layer to the area for which data
are available. For example, if you only have crime data for a particular
district, crop the output dataset to the district boundary using
<code><a href="sf.html#topic+st_intersection">st_intersection</a></code>.
</p>



<h4>Automatic cell-size selection</h4>

<p>If no cell size is given then the cell size will be set so that there are 50
cells on the shorter side of the grid. If the <code>data</code> SF object is
projected in metres or feet, the number of cells will be adjusted upwards so
that the cell size is a multiple of 100.
</p>



<h3>Value</h3>

<p>An <code><a href="sf.html#topic+sf">sf</a></code> tibble of regular grid cells with
corresponding hot-spot classifications for each cell. This can be plotted
using <code><a href="#topic+autoplot">autoplot</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hotspot_dual_kde">hotspot_dual_kde()</a></code> for comparing the density of two layers, which
will often be more useful than comparing counts if the point locations
represent and underlying continuous distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compare counts from the first half of the period covered by the data to
# counts from the second half

hotspot_change(memphis_robberies)


# Create a grouping variable, then compare counts across values of that
# variable

memphis_robberies$weekend &lt;-
  weekdays(memphis_robberies$date) %in% c("Saturday", "Sunday")
hotspot_change(memphis_robberies, groups = weekend)


</code></pre>

<hr>
<h2 id='hotspot_classify'>Classify hot-spots</h2><span id='topic+hotspot_classify'></span>

<h3>Description</h3>

<p>Classify cells in a grid based on changes in the clustering of points
(typically representing events) in a two-dimensional regular grid over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot_classify(
  data,
  time = NULL,
  period = NULL,
  start = NULL,
  cell_size = NULL,
  grid_type = "rect",
  grid = NULL,
  collapse = FALSE,
  params = hotspot_classify_params(),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_classify_+3A_data">data</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing points.</p>
</td></tr>
<tr><td><code id="hotspot_classify_+3A_time">time</code></td>
<td>
<p>Name of the column in <code>data</code> containing <code>Date</code> or
<code>POSIXt</code> values representing the date associated with each point. If
this argument is <code>NULL</code> and <code>data</code> contains a single column of
<code>Date</code> or <code>POSIXt</code> values, that column will be used
automatically.</p>
</td></tr>
<tr><td><code id="hotspot_classify_+3A_period">period</code></td>
<td>
<p>A character value containing a number followed by a unit of
time, e.g. for example, &quot;12 months&quot; or &quot;3.5 days&quot;, where the unit of time
is one of second, minute, hour, day, week, month, quarter or year (or their
plural forms).</p>
</td></tr>
<tr><td><code id="hotspot_classify_+3A_start">start</code></td>
<td>
<p>A <code>Date</code> or <code>POSIXt</code> value specifying when the first
temporal period should start. If <code>NULL</code> (the default), the first
period will start at the beginning of the earliest date found in the data
(if <code>period</code> is specified in days, weeks, months, quarters or years)
or at the earliest time found in the data otherwise.</p>
</td></tr>
<tr><td><code id="hotspot_classify_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> value specifying the size of each equally
spaced grid cell, using the same units (metres, degrees, etc.) as used in
the <code>sf</code> data frame given in the <code>data</code> argument. Ignored if
<code>grid</code> is not <code>NULL</code>. If this argument and <code>grid</code> are
<code>NULL</code> (the default), the cell size will be calculated automatically
(see Details).</p>
</td></tr>
<tr><td><code id="hotspot_classify_+3A_grid_type">grid_type</code></td>
<td>
<p><code>character</code> specifying whether the grid should be made
up of squares (<code>"rect"</code>, the default) or hexagons (<code>"hex"</code>).
Ignored if <code>grid</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hotspot_classify_+3A_grid">grid</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing points containing
polygons, which will be used as the grid for which counts are made.</p>
</td></tr>
<tr><td><code id="hotspot_classify_+3A_collapse">collapse</code></td>
<td>
<p>If the range of dates in the data is not a multiple of
<code>period</code>, the final period will be shorter than the others. In that
case, should this shorter period be collapsed into the penultimate period?</p>
</td></tr>
<tr><td><code id="hotspot_classify_+3A_params">params</code></td>
<td>
<p>A list of optional parameters that can affect the output. The
list can be produced most easily using the
<code><a href="#topic+hotspot_classify_params">hotspot_classify_params</a></code> helper function.</p>
</td></tr>
<tr><td><code id="hotspot_classify_+3A_quiet">quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, messages reporting the values of any
parameters set automatically will be suppressed. The default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="sf.html#topic+sf">sf</a></code> tibble of regular grid cells with
corresponding hot-spot classifications for each cell. This can be plotted
using <code><a href="#topic+autoplot">autoplot</a></code>.
</p>
<p>Hot-spots are spatial areas that contain more points than would be expected
by chance; cold-spots are areas that contain fewer points than would be
expected. Whether an area is a hot-spot can vary over time. This function
creates a space-time cube, determines whether an area is a hot-spot for each
of several consecutive time periods and uses that to classify areas according
to whether they are persistent, intermittent, emerging or former hot- or
cold-spots.
</p>


<h4>Hot and cold spots</h4>

<p>Hot- and cold-spots are identified by calculating the Getis-Ord
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(gi-star) or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
<code class="reqn">Z</code>-score statistic for each cell in a regular grid for each time period.
Cells are classified as follows, using the parameters provided in the
<code>params</code> argument:
</p>

<ul>
<li> <p><em>Persistent hot-/cold-spots</em> are cells that have been hot-/cold-spots
consistently over time. Formally: if the <em>p</em>-value is less than
<code>critical_p</code> for at least <code>persistent_prop</code> proportion of time periods.
</p>
</li>
<li> <p><em>Emerging hot-/cold-spots</em> are cells that have become hot-/cold-spots
recently but were not previously. Formally: if the <em>p</em>-value is less
than <code>critical_p</code> for at least <code>hotspot_prop</code> of time periods defined as
recent by <code>recent_prop</code> but the <em>p</em>-value was <em>not</em> less than
<code>critical_p</code> for at least <code>hotspot_prop</code> of time periods defined as
non-recent by <code>1 - recent_prop</code>.
</p>
</li>
<li> <p><em>Former hot-/cold-spots</em> are cells that used to be hot-/cold-spots but have
not been more recently. Formally: if the <em>p</em>-value was less than
<code>critical_p</code> for at least <code>hotspot_prop</code> of time periods defined as
non-recent by <code>1 - recent_prop</code> but the <em>p</em>-value was <em>not</em> less than
<code>critical_p</code> for for at least <code>hotspot_prop</code> of time periods defined as
recent by <code>recent_prop</code>.
</p>
</li>
<li> <p><em>Intermittent hot-/cold-spots</em> are cells that have been hot-/cold-spots,
but not as frequently as persistent hotspots and not only during
recent/non-recent periods. Formally: if the <em>p</em>-value is less than
<code>critical_p</code> for at least <code>hotspot_prop</code> of time periods but the cell is
not an emerging or former hotspot.
</p>
</li>
<li> <p><em>No pattern</em> if none of the above categories apply.
</p>
</li></ul>




<h4>Coverage of the output data</h4>

<p>The grid produced by this function covers the convex hull of the input data
layer. This means the result may include
<i>G</i><sub><i>i</i></sub><sup>*</sup> or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
values for cells that are outside the area for which data were provided,
which could be misleading. To handle this, consider cropping the output layer
to the area for which data are available. For example, if you only have crime
data for a particular district, crop the output dataset to the district
boundary using <code><a href="sf.html#topic+st_intersection">st_intersection</a></code>.
</p>



<h4>Automatic cell-size selection</h4>

<p>If no cell size is given then the cell size will be set so that there are 50
cells on the shorter side of the grid. If the <code>data</code> SF object is projected
in metres or feet, the number of cells will be adjusted upwards so that the
cell size is a multiple of 100.
</p>



<h3>References</h3>

<p>Chainey, S. (2020). <em>Understanding Crime: Analyzing the Geography of
Crime</em>. Redlands, CA: ESRI.
</p>

<hr>
<h2 id='hotspot_classify_params'>Control the parameters used to classify hotspots</h2><span id='topic+hotspot_classify_params'></span>

<h3>Description</h3>

<p>This function allows specification of parameters that affect the output from
<code><a href="#topic+hotspot_classify">hotspot_classify</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot_classify_params(
  hotspot_prop = 0.1,
  persistent_prop = 0.8,
  recent_prop = 0.2,
  critical_p = 0.05,
  nb_dist = NULL,
  include_self = TRUE,
  p_adjust_method = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_classify_params_+3A_hotspot_prop">hotspot_prop</code></td>
<td>
<p>A single numeric value specifying the minimum proportion
of periods for which a cell must contain significant clusters of points
before the cell can be classified as a hot or cold spot of any type.</p>
</td></tr>
<tr><td><code id="hotspot_classify_params_+3A_persistent_prop">persistent_prop</code></td>
<td>
<p>A single numeric value specifying the minimum
proportion of periods for which a cell must contain significant clusters of
points before the cell can be classified as a persistent hot or cold spot.</p>
</td></tr>
<tr><td><code id="hotspot_classify_params_+3A_recent_prop">recent_prop</code></td>
<td>
<p>A single numeric value specifying the proportion of
periods that should be treated as being recent in the classification of
emerging and former hotspots.</p>
</td></tr>
<tr><td><code id="hotspot_classify_params_+3A_critical_p">critical_p</code></td>
<td>
<p>A threshold <em>p</em>-value below which values should be
treated as being statistically significant.</p>
</td></tr>
<tr><td><code id="hotspot_classify_params_+3A_nb_dist">nb_dist</code></td>
<td>
<p>The distance around a cell that contains the neighbours of
that cell, which are used in calculating the statistic. If this argument is
<code>NULL</code> (the default), <code>nb_dist</code> is set as <code>cell_size *
  sqrt(2)</code> so that only the cells immediately adjacent to each cell are
treated as being its neighbours.</p>
</td></tr>
<tr><td><code id="hotspot_classify_params_+3A_include_self">include_self</code></td>
<td>
<p>Should points in a given cell be counted as well as
counts in neighbouring cells when calculating the values of
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(if <code>include_self = TRUE</code>, the default) or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(if <code>include_self = FALSE</code>) values? You are unlikely to want to change
the default value.</p>
</td></tr>
<tr><td><code id="hotspot_classify_params_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p>The method to be used to adjust <em>p</em>-values for
multiple comparisons. <code>NULL</code> (the default) uses the default method
used by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>, but any of the character values in
<code>stats::p.adjust.methods</code> may be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that can be used as the input to the <code>params</code> argument to
<code><a href="#topic+hotspot_classify">hotspot_classify</a></code>.
</p>

<hr>
<h2 id='hotspot_count'>Count points in cells in a two-dimensional grid</h2><span id='topic+hotspot_count'></span>

<h3>Description</h3>

<p>Count points in cells in a two-dimensional grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot_count(
  data,
  cell_size = NULL,
  grid_type = "rect",
  grid = NULL,
  weights = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_count_+3A_data">data</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing points.</p>
</td></tr>
<tr><td><code id="hotspot_count_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> value specifying the size of each equally
spaced grid cell, using the same units (metres, degrees, etc.) as used in
the <code>sf</code> data frame given in the <code>data</code> argument. Ignored if
<code>grid</code> is not <code>NULL</code>. If this argument and <code>grid</code> are
<code>NULL</code> (the default), the cell size will be calculated automatically
(see Details).</p>
</td></tr>
<tr><td><code id="hotspot_count_+3A_grid_type">grid_type</code></td>
<td>
<p><code>character</code> specifying whether the grid should be made
up of squares (<code>"rect"</code>, the default) or hexagons (<code>"hex"</code>).
Ignored if <code>grid</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hotspot_count_+3A_grid">grid</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing polygons, which will
be used as the grid for which counts are made.</p>
</td></tr>
<tr><td><code id="hotspot_count_+3A_weights">weights</code></td>
<td>
<p><code>NULL</code> or the name of a column in <code>data</code> to be used
as weights for weighted counts.</p>
</td></tr>
<tr><td><code id="hotspot_count_+3A_quiet">quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, messages reporting the values of any
parameters set automatically will be suppressed. The default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function counts the number of points in each cell in a regular grid. If
a column name in <code>data</code> is supplied with the <code>weights</code> argument,
weighted counts will also be produced.
</p>


<h4>Automatic cell-size selection</h4>

<p>If <code>grid</code> is <code>NULL</code> and no cell size is given, the cell size will be set so
that there are 50 cells on the shorter side of the grid. If the <code>data</code> SF
object is projected in metres or feet, the number of cells will be adjusted
upwards so that the cell size is a multiple of 100.
</p>



<h3>Value</h3>

<p>An <code><a href="sf.html#topic+sf">sf</a></code> tibble of regular grid cells with
corresponding point counts for each cell. This can be plotted using
<code><a href="#topic+autoplot">autoplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Set cell size automatically

hotspot_count(memphis_robberies_jan)


# Transform data to UTM zone 15N so that cell_size and bandwidth can be set
# in metres
library(sf)
memphis_robberies_utm &lt;- st_transform(memphis_robberies_jan, 32615)

# Manually set grid-cell size in metres, since the `memphis_robberies_utm`
# dataset uses a co-ordinate reference system (UTM zone 15 north) that is
# specified in metres

hotspot_count(memphis_robberies_utm, cell_size = 200)


</code></pre>

<hr>
<h2 id='hotspot_dual_kde'>Estimate the relationship between the kernel density of two layers of points</h2><span id='topic+hotspot_dual_kde'></span>

<h3>Description</h3>

<p>Estimate the relationship between the kernel density of two layers of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot_dual_kde(
  x,
  y,
  cell_size = NULL,
  grid_type = "rect",
  bandwidth = NULL,
  bandwidth_adjust = 1,
  method = "ratio",
  grid = NULL,
  weights = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_dual_kde_+3A_x">x</code>, <code id="hotspot_dual_kde_+3A_y">y</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frames containing points.</p>
</td></tr>
<tr><td><code id="hotspot_dual_kde_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> value specifying the size of each equally
spaced grid cell, using the same units (metres, degrees, etc.) as used in
the <code>sf</code> data frame given in the <code>x</code> argument. Ignored if
<code>grid</code> is not <code>NULL</code>. If this argument and <code>grid</code> are
<code>NULL</code> (the default), the cell size will be calculated automatically
(see Details).</p>
</td></tr>
<tr><td><code id="hotspot_dual_kde_+3A_grid_type">grid_type</code></td>
<td>
<p><code>character</code> specifying whether the grid should be made
up of squares (<code>"rect"</code>, the default) or hexagons (<code>"hex"</code>).
Ignored if <code>grid</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hotspot_dual_kde_+3A_bandwidth">bandwidth</code></td>
<td>
<p>either a single <code>numeric</code> value specifying the
bandwidth to be used in calculating the kernel density estimates, or a list
of exactly 2 such values. If this argument is <code>NULL</code> (the default),
the bandwidth for both <code>x</code> and <code>y</code> will be determined
automatically using the result of <code><a href="MASS.html#topic+bandwidth.nrd">bandwidth.nrd</a></code> called
on the co-ordinates of the points in <code>x</code>. If this argument is
<code>list(NULL, NULL)</code>, separate bandwidths will be determined
automatically for <code>x</code> and <code>y</code> based on each layer.</p>
</td></tr>
<tr><td><code id="hotspot_dual_kde_+3A_bandwidth_adjust">bandwidth_adjust</code></td>
<td>
<p>single positive <code>numeric</code> value by which the
value of <code>bandwidth</code> for both <code>x</code> and <code>y</code> will be
multiplied, or a list of two such values. Useful for setting the bandwidth
relative to the default.</p>
</td></tr>
<tr><td><code id="hotspot_dual_kde_+3A_method">method</code></td>
<td>
<p><code>character</code> specifying the method by which the densities,
<code>d()</code>, of <code>x</code> and <code>y</code> will be related:
</p>

<dl>
<dt><code>ratio</code></dt><dd><p>(the default) calculates the density of <code>x</code>
divided by the density of <code>y</code>, i.e. <code>d(x) / d(y)</code>.</p>
</dd>
<dt><code>log</code></dt><dd><p>calculates the natural logarithm of the density of
<code>x</code> divided by the density of <code>y</code>, i.e.
<code>log(d(x) / d(y))</code>.</p>
</dd>
<dt><code>diff</code></dt><dd><p>calculates the difference between the density of
<code>x</code> and the density of <code>y</code>, i.e. <code>d(x) - d(y)</code>.</p>
</dd>
<dt><code>sum</code></dt><dd><p>calculates the sum of the density of <code>x</code> and the
density of <code>y</code>, i.e. <code>d(x) + d(y)</code>.</p>
</dd>
</dl>

<p>The result of this calculation will be returned in the <code>kde</code> column of
the return value.</p>
</td></tr>
<tr><td><code id="hotspot_dual_kde_+3A_grid">grid</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing polygons, which will
be used as the grid for which densities are estimated.</p>
</td></tr>
<tr><td><code id="hotspot_dual_kde_+3A_weights">weights</code></td>
<td>
<p><code>NULL</code> (the default) or a vector of length two giving
either <code>NULL</code> or the name of a column in each of <code>x</code> and
<code>y</code> to be used as weights for weighted counts and KDE values.</p>
</td></tr>
<tr><td><code id="hotspot_dual_kde_+3A_quiet">quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, messages reporting the values of any
parameters set automatically will be suppressed. The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hotspot_dual_kde_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="SpatialKDE.html#topic+kde">kde</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="sf.html#topic+sf">sf</a></code> tibble of grid cells with corresponding point
counts and dual kernel density estimates for each cell. This can be plotted
using <code><a href="#topic+autoplot">autoplot</a></code>.
</p>
<p>This function creates a regular two-dimensional grid of cells (unless a
custom grid is specified with <code>grid</code>), calculates the density of points
in each cell for each of <code>x</code> and <code>y</code> using functions from the
<code>SpatialKDE</code> package, then produces a value representing a relation
between the two densities. The count of points in each cell is also returned.
</p>
<p>Dual kernel density values can be useful for understanding the relationship
between the distributions of two sets of point locations. For example:
</p>

<ul>
<li><p> The ratio between two densities representing the locations of burglaries
and the locations of houses can show the distribution of the risk
(incidence rate) of burglaries. The logged ratio may be useful to show
relationships where one set of points has an extremely skewed
distribution.
</p>
</li>
<li><p> The difference between two densities can show the change in distributions
between two points in time.
</p>
</li>
<li><p> The sum of two densities can be used to estimate the total density of two
types of point, e.g. the locations of occurrences of two diseases.
</p>
</li></ul>



<h4>Coverage of the output data</h4>

<p>The grid produced by this function covers the convex hull of the points in
<code>x</code>. This means the result may include KDE values for cells that are
outside the area for which data were provided, which could be misleading. To
handle this, consider cropping the output layer to the area for which data
are available. For example, if you only have crime data for a particular
district, crop the output dataset to the district boundary using
<code><a href="sf.html#topic+st_intersection">st_intersection</a></code>.
</p>



<h4>Automatic cell-size selection</h4>

<p>If no cell size is given then the cell size will be set so that there are 50
cells on the shorter side of the grid. If the <code>x</code> SF object is projected
in metres or feet, the number of cells will be adjusted upwards so that the
cell size is a multiple of 100.
</p>



<h3>References</h3>

<p>Yin, P. (2020). Kernels and Density Estimation. <em>The Geographic
Information Science &amp; Technology Body of Knowledge</em> (1st Quarter 2020
Edition), John P. Wilson (ed.).
doi:<a href="https://doi.org/10.22224/gistbok/2020.1.12">doi:10.22224/gistbok/2020.1.12</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See also the examples for `hotspot_kde()` for examples of how to specify
# `cell_size`, `bandwidth`, etc.

library(sf)

# Transform data to UTM zone 15N so that cell_size and bandwidth can be set
# in metres
memphis_robberies_utm &lt;- st_transform(memphis_robberies, 32615)
memphis_population_utm &lt;- st_transform(memphis_population, 32615)

# Calculate burglary risk based on residential population. `weights` is set
# to `c(NULL, population)` so that the robberies layer is not weighted and
# the population layer is weighted according to the number of residents in
# each census block.

hotspot_dual_kde(
  memphis_robberies_utm,
  memphis_population_utm,
  bandwidth = list(NULL, NULL),
  weights = c(NULL, population)
)


</code></pre>

<hr>
<h2 id='hotspot_gistar'>Identify significant spatial clusters of points</h2><span id='topic+hotspot_gistar'></span>

<h3>Description</h3>

<p>Identify hotspot and coldspot locations, that is cells in a regular grid in
which there are more/fewer points than would be expected if the points were
distributed randomly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot_gistar(
  data,
  cell_size = NULL,
  grid_type = "rect",
  kde = TRUE,
  bandwidth = NULL,
  bandwidth_adjust = 1,
  grid = NULL,
  weights = NULL,
  nb_dist = NULL,
  include_self = TRUE,
  p_adjust_method = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_gistar_+3A_data">data</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing points.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> value specifying the size of each equally
spaced grid cell, using the same units (metres, degrees, etc.) as used in
the <code>sf</code> data frame given in the <code>data</code> argument. Ignored if
<code>grid</code> is not <code>NULL</code>. If this argument and <code>grid</code> are
<code>NULL</code> (the default), the cell size will be calculated automatically
(see Details).</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_grid_type">grid_type</code></td>
<td>
<p><code>character</code> specifying whether the grid should be made
up of squares (<code>"rect"</code>, the default) or hexagons (<code>"hex"</code>).
Ignored if <code>grid</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_kde">kde</code></td>
<td>
<p><code>TRUE</code> (the default) or <code>FALSE</code> indicating whether
kernel density estimates (KDE) should be produced for each grid cell.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_bandwidth">bandwidth</code></td>
<td>
<p><code>numeric</code> value specifying the bandwidth to be used in
calculating the kernel density estimates. If this argument is <code>NULL</code>
(the default), the bandwidth will be specified automatically using the mean
result of <code><a href="MASS.html#topic+bandwidth.nrd">bandwidth.nrd</a></code> called on the <code>x</code> and
<code>y</code> co-ordinates separately.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_bandwidth_adjust">bandwidth_adjust</code></td>
<td>
<p>single positive <code>numeric</code> value by which the
value of <code>bandwidth</code> is multiplied. Useful for setting the bandwidth
relative to the default.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_grid">grid</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing polygons, which will
be used as the grid for which counts are made.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_weights">weights</code></td>
<td>
<p><code>NULL</code> or the name of a column in <code>data</code> to be used
as weights for weighted counts and KDE values.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_nb_dist">nb_dist</code></td>
<td>
<p>The distance around a cell that contains the neighbours of
that cell, which are used in calculating the statistic. If this argument is
<code>NULL</code> (the default), <code>nb_dist</code> is set as <code>cell_size *
  sqrt(2)</code> so that only the cells immediately adjacent to each cell are
treated as being its neighbours.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_include_self">include_self</code></td>
<td>
<p>Should points in a given cell be counted as well as
counts in neighbouring cells when calculating the values of
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(if <code>include_self = TRUE</code>, the default) or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(if <code>include_self = FALSE</code>) values? You are unlikely to want to change
the default value.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p>The method to be used to adjust <em>p</em>-values for
multiple comparisons. <code>NULL</code> (the default) uses the default method
used by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>, but any of the character values in
<code>stats::p.adjust.methods</code> may be specified.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_quiet">quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, messages reporting the values of any
parameters set automatically will be suppressed. The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hotspot_gistar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="SpatialKDE.html#topic+kde">kde</a></code> or
ignored if <code>kde = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the Getis-Ord
<i>G</i><sub><i>i</i></sub><sup>*</sup>
(gi-star) or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
<code class="reqn">Z</code>-score statistic for identifying clusters of point locations. The
underlying implementation uses the <code><a href="spdep.html#topic+localG">localG</a></code> function to
calculate the <code class="reqn">Z</code> scores and then <code><a href="spdep.html#topic+p.adjustSP">p.adjustSP</a></code>
function to adjust the corresponding <code class="reqn">p</code>-values for multiple comparison.
The function also returns counts of points in each cell and (by default but
optionally) kernel density estimates using the <code><a href="SpatialKDE.html#topic+kde">kde</a></code>
function.
</p>


<h4>Coverage of the output data</h4>

<p>The grid produced by this function covers the convex hull of the input data
layer. This means the result may include
<i>G</i><sub><i>i</i></sub><sup>*</sup> or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
values for cells that are outside the area for which data were provided,
which could be misleading. To handle this, consider cropping the output layer
to the area for which data are available. For example, if you only have crime
data for a particular district, crop the output dataset to the district
boundary using <code><a href="sf.html#topic+st_intersection">st_intersection</a></code>.
</p>



<h4>Automatic cell-size selection</h4>

<p>If no cell size is given then the cell size will be set so that there are 50
cells on the shorter side of the grid. If the <code>data</code> SF object is projected
in metres or feet, the number of cells will be adjusted upwards so that the
cell size is a multiple of 100.
</p>



<h3>Value</h3>

<p>An <code><a href="sf.html#topic+sf">sf</a></code> tibble of regular grid cells with
corresponding point counts,
<i>G</i><sub><i>i</i></sub><sup>*</sup> or
<i>G</i><sub><i>i</i></sub><sup>*</sup>
values and (optionally) kernel density estimates for each cell. Values
greater than zero indicate more points than would be expected for randomly
distributed points and values less than zero indicate fewer points.
Critical values of
<i>G</i><sub><i>i</i></sub><sup>*</sup> and
<i>G</i><sub><i>i</i></sub><sup>*</sup>
are given in the manual page for <code><a href="spdep.html#topic+localG">localG</a></code>.
</p>
<p>The output from this function can be plotted in the same way as for other
SF objects, for which see <code>vignette("sf5", package = "sf")</code>.
</p>


<h3>References</h3>

<p>Getis, A. &amp; Ord, J. K. (1992). The Analysis of Spatial Association by Use of
Distance Statistics. <em>Geographical Analysis</em>, 24(3), 189-206.
doi:<a href="https://doi.org/10.1111/j.1538-4632.1992.tb00261.x">doi:10.1111/j.1538-4632.1992.tb00261.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

# Transform data to UTM zone 15N so that cell_size and bandwidth can be set
# in metres
memphis_robberies_utm &lt;- st_transform(memphis_robberies_jan, 32615)

# Automatically set grid-cell size, bandwidth and neighbour distance

hotspot_gistar(memphis_robberies_utm)


# Manually set grid-cell size in metres, since the `memphis_robberies`
# dataset uses a co-ordinate reference system (UTM zone 15 north) that is
# specified in metres

hotspot_gistar(memphis_robberies_utm, cell_size = 200)


# Automatically set grid-cell size and bandwidth for lon/lat data, since it
# is not intuitive to set these values manually in decimal degrees. To do
# this it is necessary to not calculate KDEs due to a limitation in the
# underlying function.

hotspot_gistar(memphis_robberies, kde = FALSE)


</code></pre>

<hr>
<h2 id='hotspot_grid'>Create either a rectangular or hexagonal two-dimensional grid</h2><span id='topic+hotspot_grid'></span>

<h3>Description</h3>

<p>Create either a rectangular or hexagonal two-dimensional grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot_grid(data, cell_size = NULL, grid_type = "rect", quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_grid_+3A_data">data</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame.</p>
</td></tr>
<tr><td><code id="hotspot_grid_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> value specifying the size of each equally
spaced grid cell, using the same units (metres, degrees, etc.) as used in
the <code>sf</code> data frame given in the <code>data</code> argument. If this
argument is <code>NULL</code> (the default), the cell size will be calculated
automatically (see Details).</p>
</td></tr>
<tr><td><code id="hotspot_grid_+3A_grid_type">grid_type</code></td>
<td>
<p><code>character</code> specifying whether the grid should be made
up of squares (<code>"rect"</code>, the default) or hexagons (<code>"hex"</code>).</p>
</td></tr>
<tr><td><code id="hotspot_grid_+3A_quiet">quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, messages reporting the values of any
parameters set automatically will be suppressed. The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hotspot_grid_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>link[sf]{st_make_grid}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simple features tibble containing polygons representing grid cells.
</p>
<p>The grid will be based on the convex hull of <code>data</code>, expanded by a
buffer of <code>cell_size / 2</code> to ensure all the points in <code>data</code> fall
within the resulting grid.
</p>

<hr>
<h2 id='hotspot_kde'>Estimate two-dimensional kernel density of points</h2><span id='topic+hotspot_kde'></span>

<h3>Description</h3>

<p>Estimate two-dimensional kernel density of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotspot_kde(
  data,
  cell_size = NULL,
  grid_type = "rect",
  bandwidth = NULL,
  bandwidth_adjust = 1,
  grid = NULL,
  weights = NULL,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hotspot_kde_+3A_data">data</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing points.</p>
</td></tr>
<tr><td><code id="hotspot_kde_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> value specifying the size of each equally
spaced grid cell, using the same units (metres, degrees, etc.) as used in
the <code>sf</code> data frame given in the <code>data</code> argument. Ignored if
<code>grid</code> is not <code>NULL</code>. If this argument and <code>grid</code> are
<code>NULL</code> (the default), the cell size will be calculated automatically
(see Details).</p>
</td></tr>
<tr><td><code id="hotspot_kde_+3A_grid_type">grid_type</code></td>
<td>
<p><code>character</code> specifying whether the grid should be made
up of squares (<code>"rect"</code>, the default) or hexagons (<code>"hex"</code>).
Ignored if <code>grid</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hotspot_kde_+3A_bandwidth">bandwidth</code></td>
<td>
<p><code>numeric</code> value specifying the bandwidth to be used in
calculating the kernel density estimates. If this argument is <code>NULL</code>
(the default), the bandwidth will be determined automatically using the
result of <code><a href="MASS.html#topic+bandwidth.nrd">bandwidth.nrd</a></code> called on the co-ordinates of
<code>data</code>.</p>
</td></tr>
<tr><td><code id="hotspot_kde_+3A_bandwidth_adjust">bandwidth_adjust</code></td>
<td>
<p>single positive <code>numeric</code> value by which the
value of <code>bandwidth</code> is multiplied. Useful for setting the bandwidth
relative to the default.</p>
</td></tr>
<tr><td><code id="hotspot_kde_+3A_grid">grid</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> data frame containing polygons, which will
be used as the grid for which densities are estimated.</p>
</td></tr>
<tr><td><code id="hotspot_kde_+3A_weights">weights</code></td>
<td>
<p><code>NULL</code> or the name of a column in <code>data</code> to be used
as weights for weighted counts and KDE values.</p>
</td></tr>
<tr><td><code id="hotspot_kde_+3A_quiet">quiet</code></td>
<td>
<p>if set to <code>TRUE</code>, messages reporting the values of any
parameters set automatically will be suppressed. The default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hotspot_kde_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="SpatialKDE.html#topic+kde">kde</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a regular two-dimensional grid of cells (unless a
custom grid is specified with <code>grid</code>) and calculates the density of
points in each cell on that grid using functions from the <code>SpatialKDE</code>
package. The count of points in each cell is also returned.
</p>


<h4>Coverage of the output data</h4>

<p>The grid produced by this function covers the convex hull of the input data
layer. This means the result may include KDE values for cells that are
outside the area for which data were provided, which could be misleading. To
handle this, consider cropping the output layer to the area for which data
are available. For example, if you only have crime data for a particular
district, crop the output dataset to the district boundary using
<code><a href="sf.html#topic+st_intersection">st_intersection</a></code>.
</p>



<h4>Automatic cell-size selection</h4>

<p>If no cell size is given then the cell size will be set so that there are 50
cells on the shorter side of the grid. If the <code>data</code> SF object is projected
in metres or feet, the number of cells will be adjusted upwards so that the
cell size is a multiple of 100.
</p>



<h3>Value</h3>

<p>An <code><a href="sf.html#topic+sf">sf</a></code> tibble of grid cells with corresponding point
counts and kernel density estimates for each cell. This can be plotted
using <code><a href="#topic+autoplot">autoplot</a></code>.
</p>


<h3>References</h3>

<p>Yin, P. (2020). Kernels and Density Estimation. <em>The Geographic
Information Science &amp; Technology Body of Knowledge</em> (1st Quarter 2020
Edition), John P. Wilson (ed.).
doi:<a href="https://doi.org/10.22224/gistbok/2020.1.12">doi:10.22224/gistbok/2020.1.12</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

# Transform data to UTM zone 15N so that cell_size and bandwidth can be set
# in metres
memphis_robberies_utm &lt;- st_transform(memphis_robberies_jan, 32615)

# Automatically set grid-cell size, bandwidth and neighbour distance

hotspot_kde(memphis_robberies_utm)


# Manually set grid-cell size and bandwidth in metres, since the
# `memphis_robberies_utm` dataset uses a co-ordinate reference system (UTM
# zone 15 north) that is specified in metres

hotspot_kde(memphis_robberies_utm, cell_size = 200, bandwidth = 1000)


</code></pre>

<hr>
<h2 id='memphis_population'>Populations of census blocks in Memphis in 2020</h2><span id='topic+memphis_population'></span>

<h3>Description</h3>

<p>A dataset containing records of populations associated with the centroids of
census blocks in Memphis, Tennessee, in 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memphis_population
</code></pre>


<h3>Format</h3>

<p>A simple-features tibble with 10,393 rows and three variables:
</p>

<dl>
<dt>geoid</dt><dd><p>the census GEOID for each block</p>
</dd>
<dt>population</dt><dd><p>the number of people residing in each block</p>
</dd>
<dt>geometry</dt><dd><p>the co-ordinates of the centroid of each block, stored in
simple-features point format</p>
</dd>
</dl>



<h3>Source</h3>

<p>US Census Bureau. Census 2020, Redistricting Data summary file.
<a href="https://www.census.gov/programs-surveys/decennial-census/about/rdo/summary-files.html">https://www.census.gov/programs-surveys/decennial-census/about/rdo/summary-files.html</a>
</p>

<hr>
<h2 id='memphis_robberies'>Personal robberies in Memphis in 2019</h2><span id='topic+memphis_robberies'></span>

<h3>Description</h3>

<p>A dataset containing records of personal robberies recorded by police in
Memphis, Tennessee, in 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memphis_robberies
</code></pre>


<h3>Format</h3>

<p>A simple-features tibble with 2,245 rows and four variables:
</p>

<dl>
<dt>uid</dt><dd><p>a unique identifier for each robbery</p>
</dd>
<dt>offense_type</dt><dd><p>the type of crime (always 'personal robbery')</p>
</dd>
<dt>date</dt><dd><p>the date and time at which the crime occurred</p>
</dd>
<dt>geometry</dt><dd><p>the co-ordinates at which the crime occurred, stored in
simple-features point format</p>
</dd>
</dl>



<h3>Source</h3>

<p>Crime Open Database, <a href="https://osf.io/zyaqn/">https://osf.io/zyaqn/</a>
</p>

<hr>
<h2 id='memphis_robberies_jan'>Personal robberies in Memphis in January 2019</h2><span id='topic+memphis_robberies_jan'></span>

<h3>Description</h3>

<p>A dataset containing records of personal robberies recorded by police in
Memphis, Tennessee, in January 2019. This dataset is too small for some types
of analysis but is included for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memphis_robberies_jan
</code></pre>


<h3>Format</h3>

<p>A simple-features tibble with 206 rows and four variables:
</p>

<dl>
<dt>uid</dt><dd><p>a unique identifier for each robbery</p>
</dd>
<dt>offense_type</dt><dd><p>the type of crime (always 'personal robbery')</p>
</dd>
<dt>date</dt><dd><p>the date and time at which the crime occurred</p>
</dd>
<dt>geometry</dt><dd><p>the co-ordinates at which the crime occurred, stored in
simple-features point format</p>
</dd>
</dl>



<h3>Source</h3>

<p>Crime Open Database, <a href="https://osf.io/zyaqn/">https://osf.io/zyaqn/</a>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+autoplot'></span><span id='topic+autolayer'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autolayer">autolayer</a></code>, <code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
