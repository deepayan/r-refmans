<!DOCTYPE html><html lang="en"><head><title>Help for package onion</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {onion}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#onion-package'>
<p>Octonions and Quaternions</p></a></li>
<li><a href='#adjoint'><p>The adjoint map</p></a></li>
<li><a href='#Arith'><p>Methods for Function Arith in package Onion</p></a></li>
<li><a href='#biggest'><p>Returns the biggest type of a set of onions</p></a></li>
<li><a href='#bind'><p>Binding of onionmats</p></a></li>
<li><a href='#bunny'><p>The Stanford Bunny</p></a></li>
<li><a href='#c'><p>Concatenation</p></a></li>
<li><a href='#Compare-methods'><p>Methods for compare S4 group</p></a></li>
<li><a href='#Complex'><p>Complex functionality for onions</p></a></li>
<li><a href='#condense'><p>Condense an onionic vector into a short form</p></a></li>
<li><a href='#cumsum'><p>Cumulative sums and products of onions</p></a></li>
<li><a href='#dot-class'><p>Class &ldquo;dot&rdquo;</p></a></li>
<li><a href='#drop'><p>Drop zero imaginary parts of an onionic vector</p></a></li>
<li><a href='#Extract'><p>Extract or Replace Parts of onions or glubs</p></a></li>
<li><a href='#length'><p>Length of an octonionic vector</p></a></li>
<li><a href='#Logic'><p>Logical operations on onions</p></a></li>
<li><a href='#Math'><p>Various logarithmic and circular functions for onions</p></a></li>
<li><a href='#names'><p>Names of an onionic vector</p></a></li>
<li><a href='#O1'><p>Unit onions</p></a></li>
<li><a href='#onion'>
<p>Basic onion functions</p></a></li>
<li><a href='#onion-class'><p>Class &ldquo;onion&rdquo;</p></a></li>
<li><a href='#onionmat'><p>Onionic matrices</p></a></li>
<li><a href='#orthogonal'><p>Orthogonal matrix equivalents</p></a></li>
<li><a href='#p3d'><p>Three dimensional plotting</p></a></li>
<li><a href='#plot'><p>Plot onions</p></a></li>
<li><a href='#prods'><p>Various products of two onions</p></a></li>
<li><a href='#rep'><p>Replicate elements of onionic vectors</p></a></li>
<li><a href='#roct'><p>Random onionic vectors</p></a></li>
<li><a href='#rotate'><p>Rotates 3D vectors using quaternions</p></a></li>
<li><a href='#round'><p>Rounding of onions</p></a></li>
<li><a href='#seq'><p>seq method for onions</p></a></li>
<li><a href='#show'><p>Print method for onions</p></a></li>
<li><a href='#sum'><p>Various summary statistics for onions</p></a></li>
<li><a href='#threeform'><p>Various non-field diagnostics</p></a></li>
<li><a href='#zapsmall'><p>Concatenation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.5-3</td>
</tr>
<tr>
<td>Title:</td>
<td>Octonions and Quaternions</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Quaternions and Octonions are four- and eight- dimensional
  extensions of the complex numbers.  They are normed division
  algebras over the real numbers and find applications in spatial
  rotations (quaternions), and string theory and relativity
  (octonions).  The quaternions are noncommutative and the octonions
  nonassociative.  See the package vignette for more details.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat,knitr,rmarkdown,covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>emulator, Matrix, freealg (&ge; 1.0-4), mathjaxr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/onion">https://github.com/RobinHankin/onion</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/onion/issues">https://github.com/RobinHankin/onion/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-29 10:01:31 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-29 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='onion-package'>
Octonions and Quaternions
</h2><span id='topic+onion-package'></span>

<h3>Description</h3>


<p>  Quaternions and Octonions are four- and eight- dimensional
  extensions of the complex numbers.  They are normed division
  algebras over the real numbers and find applications in spatial
  rotations (quaternions), and string theory and relativity
  (octonions).  The quaternions are noncommutative and the octonions
  nonassociative.  See the package vignette for more details.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> onion</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Octonions and Quaternions</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> 
  Quaternions and Octonions are four- and eight- dimensional
  extensions of the complex numbers.  They are normed division
  algebras over the real numbers and find applications in spatial
  rotations (quaternions), and string theory and relativity
  (octonions).  The quaternions are noncommutative and the octonions
  nonassociative.  See the package vignette for more details.</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods, R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> testthat,knitr,rmarkdown,covr</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> emulator, Matrix, freealg (&gt;= 1.0-4), mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/onion</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/onion/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
adjoint                 The adjoint map
Arith                   Methods for Function Arith in package Onion
biggest                 Returns the biggest type of a set of onions
bind                    Binding of onionmats
bunny                   The Stanford Bunny
c                       Concatenation
Compare-methods         Methods for compare S4 group
condense                Condense an onionic vector into a short form
cumsum                  Cumulative sums and products of onions
dot-class               Class "dot"
drop                    Drop zero imaginary parts of an onionic vector
i                       Extract or Replace Parts of onions or glubs
length                  Length of an octonionic vector
log                     Various logarithmic and circular functions for
                        onions
logic.onion             Logical operations on onions
names.onion             Names of an onionic vector
O1                      Unit onions
onion                   Basic onion functions
onion-class             Class "onion"
onion-package           Octonions and Quaternions
onionmat                Onionic matrices
orthogonal              Orthogonal matrix equivalents
p3d                     Three dimensional plotting
plot                    Plot onions
prods                   Various products of two onions
Re                      Complex functionality for onions
rep                     Replicate elements of onionic vectors
roct                    Random onionic vectors
rotate                  Rotates 3D vectors using quaternions
round                   Rounding of onions
seq                     seq method for onions
show                    Print method for onions
sum                     Various summary statistics for onions
threeform               Various non-field diagnostics
zapsmall                Concatenation
</pre>
<p>There are precisely four normed division algebras over the reals: the
reals themselves, the complex numbers, the quaternions, and the
octonions.  The <span class="rlang"><b>R</b></span> system is well equipped to deal with the first two:
the <span class="pkg">onion</span> package provides some functionality for the third and
fourth.  
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>

<p>R. K. S. Hankin 2006. &ldquo;Normed division algebras in R:
introducing the onion package&rdquo;.  <em>R News</em>, Volume 6, number 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rquat(10)   # random quaternions

Ok + (Oi + Ojl)/(Oj-Oil)  # basic octonions

x &lt;- roct(10)
y &lt;- roct(10)
z &lt;- roct(10)

x*(y*z) - (x*y)*z   # nonassociative!


</code></pre>

<hr>
<h2 id='adjoint'>The adjoint map</h2><span id='topic+adjoint'></span><span id='topic+ad'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The adjoint \(\mathrm{ad}_X\) of \(X\) is a map from a
Lie group \(G\) to the endomorphism group of \(G\) defined
by
</p>
\[\mathrm{ad}_X(Y)=\left[X,Y\right]\]


<h3>Usage</h3>

<pre><code class='language-R'>ad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjoint_+3A_x">x</code></td>
<td>
<p>Object nominally of class <code>onion</code> but other classes
accepted where they make sense</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here for completeness really.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rquat()
y &lt;- rquat()

f &lt;- ad(x)
f(y)

f(f(y)) # [x,[x,y]]

</code></pre>

<hr>
<h2 id='Arith'>Methods for Function Arith in package Onion</h2><span id='topic+Arith'></span><span id='topic+Arith-methods'></span><span id='topic+Arith+2Conion+2Cmissing-method'></span><span id='topic+Arith+2Conion+2CANY-method'></span><span id='topic+Arith+2CANY+2Conion-method'></span><span id='topic+Arith+2Conion+2Conion-method'></span><span id='topic+Arith+2Conion+2Cnumeric-method'></span><span id='topic+onion_negative'></span><span id='topic+onion_inverse'></span><span id='topic+onion_arith_onion'></span><span id='topic+onion_arith_numeric'></span><span id='topic+numeric_arith_onion'></span><span id='topic+harmonize_oo'></span><span id='topic+harmonize_on'></span><span id='topic+onion_plus_onion'></span><span id='topic+onion_plus_numeric'></span><span id='topic+onion_prod_onion'></span><span id='topic+octonion_prod_octonion'></span><span id='topic+quaternion_prod_quaternion'></span><span id='topic+onion_prod_numeric'></span><span id='topic+onion_power_singleinteger'></span><span id='topic+onion_power_numeric'></span>

<h3>Description</h3>

<p>Methods for Arithmetic functions for onions: <code>+</code>,
<code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onion_negative(z)
onion_inverse(z)
onion_arith_onion(e1,e2)
onion_arith_numeric(e1,e2)
numeric_arith_onion(e1,e2)
harmonize_oo(a,b)
harmonize_on(a,b)
onion_plus_onion(a,b)
onion_plus_numeric(a,b)
onion_prod_onion(e1,e2)
octonion_prod_octonion(o1,o2)
quaternion_prod_quaternion(q1,q2)
onion_prod_numeric(a,b)
onion_power_singleinteger(o,n)
onion_power_numeric(o,p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Arith_+3A_z">z</code>, <code id="Arith_+3A_e1">e1</code>, <code id="Arith_+3A_e2">e2</code>, <code id="Arith_+3A_a">a</code>, <code id="Arith_+3A_b">b</code>, <code id="Arith_+3A_o">o</code>, <code id="Arith_+3A_o1">o1</code>, <code id="Arith_+3A_o2">o2</code>, <code id="Arith_+3A_n">n</code>, <code id="Arith_+3A_q1">q1</code>, <code id="Arith_+3A_q2">q2</code>, <code id="Arith_+3A_p">p</code></td>
<td>
<p>onions or numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package implements the <code>Arith</code> group of <code>S4</code> generics so
that idiom like <code>A + B*C</code> works as expected with onions.
</p>
<p>Functions like <code>onion_inverse()</code> and <code>onion_plus_onion()</code>
are low-level helper functions.  The only really interesting operation
is multiplication; functions <code>octonion_prod_octonion()</code> and
<code>quaternion_prod_quaternion()</code> dispatch to C.
</p>
<p>Names are implemented and the rules are inherited (via
<code>harmonize_oo()</code> and <code>harmonize_on()</code>) from <code>rbind()</code>.
</p>


<h3>Value</h3>

<p>generally return an onion</p>


<h3>Note</h3>

<p>Previous versions of the package included the option to use native <span class="rlang"><b>R</b></span>
rather than the faster compiled C code used here.  But this
was very slow and is now discontinued.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rquat()
b &lt;- rquat()
a
Re(a)
j(a) &lt;- 0.2
a*b
b*a  # quaternions are noncommutative


x &lt;- as.octonion(matrix(rnorm(40),nrow=8))
y &lt;- roct()
z &lt;- roct()


x*(y*z) - (x*y)*z  # octonions are nonassociative [use associator()]






</code></pre>

<hr>
<h2 id='biggest'>Returns the biggest type of a set of onions</h2><span id='topic+biggest'></span>

<h3>Description</h3>

<p>Returns the biggest type of a set of onions; useful for
&ldquo;promoting&rdquo; a set of onions to the most general type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biggest(...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biggest_+3A_...">...</code></td>
<td>
<p>Onionic vectors</p>
</td></tr></table>


<h3>Details</h3>

<p>If any argument passed to <code>biggest()</code> is an octonion, then return
the string &ldquo;octonion&rdquo;.  Failing that, if any argument is a quaternion,
return the string &ldquo;quaternion&rdquo;,  and failing that, return
&ldquo;scalar&rdquo;.
</p>


<h3>Value</h3>

<p>Character string representing the type</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>biggest(O1,rquat(100),1:4)
</code></pre>

<hr>
<h2 id='bind'>Binding of onionmats</h2><span id='topic+bind'></span><span id='topic+rbind'></span><span id='topic+cbind'></span><span id='topic+bind_onion'></span><span id='topic+bind_onion_matrix'></span><span id='topic+bind_onion_onion'></span><span id='topic+bind_onion_onionmat'></span><span id='topic+bind_onionmat_onion'></span><span id='topic+bind_onionmat_onionmat'></span><span id='topic+rbind2+2Conion+2Conion-method'></span><span id='topic+cbind2+2Conion+2Conion-method'></span><span id='topic+rbind2+2Conionmat+2Conionmat-method'></span><span id='topic+cbind2+2Conionmat+2Conionmat-method'></span><span id='topic+rbind2+2Conion+2Conionmat-method'></span><span id='topic+cbind2+2Conion+2Conionmat-method'></span><span id='topic+rbind2+2Conionmat+2Conion-method'></span><span id='topic+cbind2+2Conionmat+2Conion-method'></span><span id='topic+rbind2+2Conion+2Cnumeric-method'></span><span id='topic+cbind2+2Conion+2Cnumeric-method'></span><span id='topic+rbind2+2Cnumeric+2Conion-method'></span><span id='topic+cbind2+2Cnumeric+2Conion-method'></span><span id='topic+rbind2+2Conionmat+2Cnumeric-method'></span><span id='topic+cbind2+2Conionmat+2Cnumeric-method'></span><span id='topic+rbind2+2Cnumeric+2Conionmat-method'></span><span id='topic+cbind2+2Cnumeric+2Conionmat-method'></span><span id='topic+rbind2+2Conion+2Cmatrix-method'></span><span id='topic+cbind2+2Conion+2Cmatrix-method'></span><span id='topic+rbind2+2Cmatrix+2Conion-method'></span><span id='topic+cbind2+2Cmatrix+2Conion-method'></span><span id='topic+rbind2+2Conionmat+2Cmatrix-method'></span><span id='topic+cbind2+2Conionmat+2Cmatrix-method'></span><span id='topic+rbind2+2Cmatrix+2Conionmat-method'></span><span id='topic+cbind2+2Cmatrix+2Conionmat-method'></span>

<h3>Description</h3>

<p>Methods for <code>rbind()</code> and <code>cbind()</code> of onionmats.  These are
implemented by specifying methods for <code>rbind2()</code> and
<code>cbind2()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_onion(x,bind,...)
bind_onion_onion(x,y,bind,...)
bind_onion_onionmat(x,y,bind,...)
bind_onionmat_onion(x,y,bind,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_+3A_x">x</code>, <code id="bind_+3A_y">y</code></td>
<td>
<p>Onions or onionmats</p>
</td></tr>
<tr><td><code id="bind_+3A_bind">bind</code></td>
<td>
<p>Either <code>rbind</code> or <code>cbind</code> as appropriate</p>
</td></tr>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return onionmats</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rbind(rquat(3),rquat(3))

cbind(diag(5),roct(1))


cbind(matrix(Oil,4,2),matrix(roct(12),4,3))

</code></pre>

<hr>
<h2 id='bunny'>The Stanford Bunny</h2><span id='topic+bunny'></span>

<h3>Description</h3>

<p>A set of 3D points in the shape of a rabbit (the Stanford Bunny)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bunny)</code></pre>


<h3>Format</h3>

<p>A three column matrix with 35947 rows.  Each row is the Cartesian
coordinates of a point on the
surface of the bunny.
</p>


<h3>Value</h3>

<p>as for format</p>


<h3>Source</h3>

<p><a href="https://graphics.stanford.edu/data/3Dscanrep/">https://graphics.stanford.edu/data/3Dscanrep/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bunny)
p3d(rotate(bunny,Hk))
</code></pre>

<hr>
<h2 id='c'>Concatenation</h2><span id='topic+c'></span><span id='topic+c.onion'></span><span id='topic+concatenate.onion'></span><span id='topic+c_onionpair'></span><span id='topic+c+2Conion-method'></span>

<h3>Description</h3>

<p>Combines its arguments to form a single onion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_onionpair(x,y)
## S4 method for signature 'onion'
c(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_+3A_x">x</code>, <code id="c_+3A_y">y</code>, <code id="c_+3A_...">...</code></td>
<td>
<p>onions</p>
</td></tr></table>


<h3>Details</h3>

<p>Returns an onion of the same type as its arguments.  Names are
inherited from the behaviour of <code>cbind()</code>, not <code>c()</code>.
</p>


<h3>Value</h3>

<p>An onion</p>


<h3>Note</h3>

<p>The method is not perfect; it will not, for example, coerce its
arguments to the <code>biggest()</code> type, so <code>c(rquat(),roct())</code>
will fail.  You will have to coerce the arguments by hand.
</p>
<p>Dispatch is based on the class of the first argument, so
<code>c(1,rquat())</code> will return a list (not an onion), and
<code>c(rquat(),1)</code> will fail.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- roct(3)
b &lt;- seq_onion(from=Oil,to=Oj,len=6)
c(a,b)

c(rquat(3),H1,H0,Him)
</code></pre>

<hr>
<h2 id='Compare-methods'>Methods for compare S4 group</h2><span id='topic+Compare-methods'></span><span id='topic+Compare+2Conion+2Conion-method'></span><span id='topic+Compare+2Conion+2Cnumeric-method'></span><span id='topic+Compare+2Cnumeric+2Conion-method'></span><span id='topic+Compare+2Conionmat+2Conionmat-method'></span><span id='topic+Compare+2Conionmat+2CANY-method'></span><span id='topic+Compare+2CANY+2Conionmat-method'></span><span id='topic+onion_compare'></span><span id='topic+onionmat_equal_onionmat'></span><span id='topic+onionmat_equal_single'></span><span id='topic+onionmat_compare_onionmat'></span><span id='topic+onionmat_compare_single'></span><span id='topic+single_compare_onionmat'></span>

<h3>Description</h3>

<p>Methods for comparison (equal to, greater than, etc) of
onions.  Only equality makes sense.</p>


<h3>Value</h3>

<p>Return a boolean</p>


<h3>Examples</h3>

<pre><code class='language-R'># roct() &gt; 0 # meaningless and returns an error



x &lt;- as.octonion(matrix(sample(0:1,800,TRUE,p=c(9,1)),nrow=8))
y &lt;- as.octonion(matrix(sample(0:1,800,TRUE,p=c(9,1)),nrow=8))
x==y

matrix(as.quaternion(100+1:12),3,4) == 102



  </code></pre>

<hr>
<h2 id='Complex'>Complex functionality for onions</h2><span id='topic+Re'></span><span id='topic+Im'></span><span id='topic+Re+3C-'></span><span id='topic+Im+3C-'></span><span id='topic+Mod'></span><span id='topic+Conj'></span><span id='topic+Norm'></span><span id='topic+Norm.onion'></span><span id='topic+Mod+2Conion-method'></span><span id='topic+Conj+2Conion-method'></span><span id='topic+Re+2Conion-method'></span><span id='topic+Im+2Conion-method'></span><span id='topic+Re+3C-+2Conion-method'></span><span id='topic+Im+3C-+2Conion-method'></span><span id='topic+Norm+2Conion-method'></span><span id='topic+Mod+2Conionmat-method'></span><span id='topic+Conj+2Conionmat-method'></span><span id='topic+Re+2Conionmat-method'></span><span id='topic+Im+2Conionmat-method'></span><span id='topic+Re+3C-+2Conionmat-method'></span><span id='topic+Im+3C-+2Conionmat-method'></span><span id='topic+Norm+2Conionmat-method'></span><span id='topic+onion_complex'></span><span id='topic+onion_imag'></span><span id='topic+onion_mod'></span><span id='topic+onion_re'></span><span id='topic+onion_abs'></span><span id='topic+sign+2Conion-method'></span><span id='topic+onion_conjugate'></span>

<h3>Description</h3>

<p>Functionality in the Complex group.
</p>
<p>The <dfn>norm</dfn> <code>Norm(O)</code> of onion <code class="reqn">O</code> is the product of
<code class="reqn">O</code> with its conjugate: <code class="reqn">|O|=OO^*</code> but a more efficient
numerical method is used (see <code>dotprod()</code>).
</p>
<p>The <dfn>Mod</dfn> <code>Mod(O)</code> of onion <code class="reqn">O</code> is the square root of its
norm.
</p>
<p>The <dfn>sign</dfn> of onion <code class="reqn">O</code> is the onion with the same direction
as <code class="reqn">O</code> but with unit Norm: <code>sign(O)=O/Mod(O)</code>.
</p>
<p>Function <code>Im()</code> sets the real component of its argument to zero
and returns that; <code>Conj()</code> flips the sign of its argument's
non-real components.  Function <code>Re()</code> returns the real component
(first row) of its argument as a numeric vector.  If <code>x</code> is an
onion, then <code>x == Re(x) + Im(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onion'
Re(z)
## S4 method for signature 'onion'
Im(z)
Re(z) &lt;- value
Im(x) &lt;- value
## S4 method for signature 'onion'
Conj(z)
## S4 method for signature 'onion'
Mod(z)
onion_abs(x)
onion_conjugate(z)
## S4 method for signature 'onion'
sign(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Complex_+3A_x">x</code>, <code id="Complex_+3A_z">z</code></td>
<td>
<p>Object of class onion or glub</p>
</td></tr>
<tr><td><code id="Complex_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All functions documented here return a numeric vector or matrix of the
same dimensions as their argument, apart from functions <code>Im()</code>
and <code>Conj()</code>, which return an object of the same class as its
argument.
</p>


<h3>Note</h3>

<p>If <code>x</code> is a numeric vector and <code>y</code> an onion, one might
expect typing <code>x[1] &lt;- y</code> to result in <code>x</code> being a onion.
This is impossible, according to John Chambers.
</p>
<p>Extract and set methods for components such as <code>i,j,k</code> are
documented at <code>Extract.Rd</code>
</p>
<p>Compare <code>clifford::Conj()</code>, which is more complicated.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Extract">Extract</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- rquat()
Re(a)
Re(a) &lt;- j(a)

Im(a)

b &lt;- romat()

A &lt;- romat()
Im(A) &lt;- Im(A)*10

</code></pre>

<hr>
<h2 id='condense'>Condense an onionic vector into a short form</h2><span id='topic+condense'></span><span id='topic+condense.onion'></span>

<h3>Description</h3>

<p>Condense an onion into a string vector showing whether the
elements are positive, zero or negative. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condense(x,as.vector=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="condense_+3A_x">x</code></td>
<td>
<p>An onionic vector</p>
</td></tr>
<tr><td><code id="condense_+3A_as.vector">as.vector</code></td>
<td>
<p>Boolean, indicating whether to return a vector or
matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>as.vector</code> is <code>TRUE</code>, return a string vector of the same
length as <code>x</code> whose elements are length 4 or 8 strings for
quaternions or octonions respectively.  If <code>FALSE</code>, return a
matrix with these columns.
</p>
<p>The characters are &ldquo;<code>+</code>&rdquo; for a positive, &ldquo;<code>-</code>&rdquo;
for a negative, and &ldquo;<code>0</code>&rdquo; for a zero, element.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>condense(roct(3))
condense(roct(3),as.vector=TRUE)
</code></pre>

<hr>
<h2 id='cumsum'>Cumulative sums and products of onions</h2><span id='topic+cumsum'></span><span id='topic+onion_cumsum'></span><span id='topic+onion_cumprod'></span>

<h3>Description</h3>

<p>Cumulative sums and products of onions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onion_cumsum(x)
onion_cumprod(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumsum_+3A_x">x</code></td>
<td>
<p>onion</p>
</td></tr></table>


<h3>Value</h3>

<p>An onion</p>


<h3>Note</h3>

<p>The octonions are nonassociative but <code>cumprod()</code> operates
left-associatively, as in <code>((a[1]*a[2])*a[3])*a[4]</code> etc. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cumsum(as.quaternion(matrix(runif(20),4,5)))
cumsum(roct(5))

cumprod(rquat(7))
</code></pre>

<hr>
<h2 id='dot-class'>Class &ldquo;dot&rdquo;</h2><span id='topic+dot'></span><span id='topic+.'></span><span id='topic+dot-class'></span><span id='topic+extract'></span><span id='topic+jacobi'></span><span id='topic+dot_error'></span><span id='topic++5B.dot'></span><span id='topic++5B+2Cdot-method'></span><span id='topic++5B+2Cdot+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2CANY+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cmatrix+2Cmatrix-method'></span><span id='topic++5B+2Cdot+2Cfunction+2Cfunction-method'></span><span id='topic++5B+2Cdot+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdot+2Cfunction+2Cfunction+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmatrix+2Cmatrix+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The dot object is defined so that idiom like <code>.[x,y]</code> returns the
commutator, that is, <code>xy-yx</code> or the Lie bracket \([x,y]\).  It
would have been nice to use <code>[x,y]</code> (that is, without the dot) but
although this is syntactically consistent, it cannot be done in R.
</p>
<p>The &ldquo;meat&rdquo; of the package is:
</p>
<pre>
setClass("dot", slots = c(ignore='numeric'))
`.` &lt;- new("dot")
setMethod("[",signature(x="dot",i="ANY",j="ANY"),function(x,i,j,drop){i*j-j*i})
</pre>
<p>The package code includes other bits and pieces such as informative
error messages for idiom such as <code>.[]</code>.  The package defines a
matrix method for the dot object.  This is because &ldquo;<code>*</code>&rdquo;
returns (incorrectly, in my view) the elementwise product, not the
matrix product.
</p>
<p>The Jacobi identity, satisfied by any associative algebra, is
</p>
\[
  \left[x,\left[y,z\right]\right]+
  \left[y,\left[z,x\right]\right]+
  \left[z,\left[x,y\right]\right]=0
\]
<p>Function <code>ad()</code> returns the adjoint operator.  The <code>adjoint</code>
vignette provides details and examples of the adjoint operator.
</p>
<p>The dot object is generated by running script <code>inst/dot.Rmd</code>, which
includes some further discussion and technical documentation, and
creates file <code>dot.rda</code> which resides in the <code>data/</code> directory.
</p>


<h3>Value</h3>

<p>Always returns an object of the same class as <code>xy</code></p>


<h3>Slots</h3>


<dl>
<dt><code>ignore</code>:</dt><dd><p>Object of class <code>"numeric"</code>, just a
formal placeholder</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "ANY", j = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "ANY", j = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "function", j = "function")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "matrix", j = "matrix")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "missing", j = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "missing", j = "missing")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjoint">adjoint</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rquat()
y &lt;- rquat()
z &lt;- rquat()
.[x,y]


.[x,.[y,z]] + .[y,.[z,x]] + .[z,.[x,y]]  # Jacobi, expanded

</code></pre>

<hr>
<h2 id='drop'>Drop zero imaginary parts of an onionic vector</h2><span id='topic+drop'></span><span id='topic+drop.onion'></span><span id='topic+drop+2Conion-method'></span><span id='topic+drop+2Conionmat-method'></span>

<h3>Description</h3>

<p>If an onion has zero imaginary part, drop it</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onion'
drop(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_+3A_x">x</code></td>
<td>
<p>onion</p>
</td></tr></table>


<h3>Details</h3>

<p>Generally, &ldquo;drop&rdquo; means coercion of an object to a less general
type without loss of information.  In many contexts, function
<code>drop()</code> means to lose redundant information.  This is not done
by default (doing so would result in unexpected coercions).
</p>
<p>Methods are given for <code>onion</code> and <code>onionmat</code> objects.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rsoct()
a
a-Im(a)
drop(a-Im(a))
</code></pre>

<hr>
<h2 id='Extract'>Extract or Replace Parts of onions or glubs</h2><span id='topic+i'></span><span id='topic+j'></span><span id='topic+k'></span><span id='topic+l'></span><span id='topic+il'></span><span id='topic+jl'></span><span id='topic+kl'></span><span id='topic+i+3C-'></span><span id='topic+j+3C-'></span><span id='topic+k+3C-'></span><span id='topic+l+3C-'></span><span id='topic+il+3C-'></span><span id='topic+jl+3C-'></span><span id='topic+kl+3C-'></span><span id='topic+i.octonion'></span><span id='topic+j.octonion'></span><span id='topic+k.octonion'></span><span id='topic+l.octonion'></span><span id='topic+il.octonion'></span><span id='topic+jl.octonion'></span><span id='topic+kl.octonion'></span><span id='topic+i.quaternion'></span><span id='topic+j.quaternion'></span><span id='topic+k.quaternion'></span><span id='topic+i+3C-.octonion'></span><span id='topic+j+3C-.octonion'></span><span id='topic+k+3C-.octonion'></span><span id='topic+l+3C-.octonion'></span><span id='topic+il+3C-.octonion'></span><span id='topic+jl+3C-.octonion'></span><span id='topic+kl+3C-.octonion'></span><span id='topic+Re+3C-.quaternion'></span><span id='topic+Im+3C-.quaternion'></span><span id='topic+i+3C-.quaternion'></span><span id='topic+j+3C-.quaternion'></span><span id='topic+k+3C-.quaternion'></span><span id='topic++5B.onion'></span><span id='topic++5B+3C-.onion'></span><span id='topic++5B+2Conion-method'></span><span id='topic++5B+2Conion+2Cindex+2CANY-method'></span><span id='topic++5B+2Conion+2Cindex+2Cmissing-method'></span><span id='topic++5B+3C-+2Conion-method'></span><span id='topic++5B+2Conion+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Conion+2CANY+2CANY-method'></span><span id='topic+i+2Conion-method'></span><span id='topic+j+2Conion-method'></span><span id='topic+k+2Conion-method'></span><span id='topic+l+2Conion-method'></span><span id='topic+l+2Coctonion-method'></span><span id='topic+il+2Coctonion-method'></span><span id='topic+jl+2Coctonion-method'></span><span id='topic+kl+2Coctonion-method'></span><span id='topic+i+2Conionmat-method'></span><span id='topic+j+2Conionmat-method'></span><span id='topic+k+2Conionmat-method'></span><span id='topic+l+2Conionmat-method'></span><span id='topic+i+3C-+2Conion-method'></span><span id='topic+j+3C-+2Conion-method'></span><span id='topic+k+3C-+2Conion-method'></span><span id='topic+l+3C-+2Coctonion-method'></span><span id='topic+il+3C-+2Coctonion-method'></span><span id='topic+jl+3C-+2Coctonion-method'></span><span id='topic+kl+3C-+2Coctonion-method'></span><span id='topic+il+2Conionmat-method'></span><span id='topic+jl+2Conionmat-method'></span><span id='topic+kl+2Conionmat-method'></span><span id='topic+i+3C-+2Conionmat-method'></span><span id='topic+j+3C-+2Conionmat-method'></span><span id='topic+k+3C-+2Conionmat-method'></span><span id='topic+l+3C-+2Conionmat-method'></span><span id='topic+il+3C-+2Conionmat-method'></span><span id='topic+jl+3C-+2Conionmat-method'></span><span id='topic+kl+3C-+2Conionmat-method'></span><span id='topic++5B+2Conionmat+2CANY+2CANY-method'></span><span id='topic++5B+2Conionmat+2Cindex+2Cindex-method'></span><span id='topic++5B+2Conionmat+2Cindex+2Cmissing-method'></span><span id='topic++5B+2Conionmat+2Cmatrix+2Cmissing-method'></span><span id='topic++5B+2Conionmat+2Cmissing+2Cindex-method'></span><span id='topic++5B+2Conionmat+2Cmissing+2Cmissing-method'></span><span id='topic++5B+3C-+2Conion+2Cindex+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Conion+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Conion+2Cindex+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Conion+2Cindex+2Cmissing+2Conion-method'></span><span id='topic++5B+3C-+2Conion+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Conion+2Cmissing+2Cmissing+2Conion-method'></span><span id='topic++5B+3C-+2Conionmat+2CANY+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Conionmat+2CANY+2Cmissing+2Conion-method'></span><span id='topic++5B+3C-+2Conionmat+2Cindex+2Cindex+2Cnumeric-method'></span><span id='topic++5B+3C-+2Conionmat+2Cindex+2Cindex+2Conion-method'></span><span id='topic++5B+3C-+2Conionmat+2Cindex+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Conionmat+2Cindex+2Cmissing+2Conion-method'></span><span id='topic++5B+3C-+2Conionmat+2Cmissing+2Cindex+2Cnumeric-method'></span><span id='topic++5B+3C-+2Conionmat+2Cmissing+2Cindex+2Conion-method'></span><span id='topic++5B+2Conion+2Cindex+2CANY+2CANY-method'></span><span id='topic++5B+2Conion+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+2Conionmat+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Conionmat+2Cindex+2Cindex+2CANY-method'></span><span id='topic++5B+2Conionmat+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+2Conionmat+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Conionmat+2Cmatrix+2Cmissing+2CANY-method'></span><span id='topic++5B+2Conionmat+2Cmissing+2Cindex+2CANY-method'></span><span id='topic++5B+2Conionmat+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B'></span><span id='topic++5B+3C-'></span>

<h3>Description</h3>

<p>Methods for <code>"["</code> and  <code>"[&lt;-"</code>, i.e., extraction or
subsetting of onions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onion'
i(z)
## S4 method for signature 'onion'
j(z)
## S4 method for signature 'onion'
k(z)
## S4 method for signature 'octonion'
l(z)
## S4 method for signature 'octonion'
il(z)
## S4 method for signature 'octonion'
jl(z)
## S4 method for signature 'octonion'
kl(z)
## S4 method for signature 'onionmat'
i(z)
## S4 method for signature 'onionmat'
j(z)
## S4 method for signature 'onionmat'
k(z)
## S4 method for signature 'onionmat'
il(z)
## S4 method for signature 'onionmat'
jl(z)
## S4 method for signature 'onionmat'
kl(z)
i(x) &lt;- value
j(x) &lt;- value
k(x) &lt;- value
l(x) &lt;- value
il(x) &lt;- value
jl(x) &lt;- value
kl(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extract_+3A_x">x</code>, <code id="Extract_+3A_z">z</code></td>
<td>
<p>Object of class onion</p>
</td></tr>
<tr><td><code id="Extract_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extraction and methods return an onion or onionmat.
Replacement methods return an object of the same class as <code>x</code>.  
</p>


<h3>Note</h3>

<p>If <code>x</code> is a numeric vector and <code>y</code> a onion, one might expect
typing <code>x[1] &lt;- y</code> to result in <code>x</code> being a onion.  This is
impossible, according to John Chambers.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- roct(9)
il(a)
Re(a) &lt;- 1:9

j(a) &lt;- l(a)
a
</code></pre>

<hr>
<h2 id='length'>Length of an octonionic vector</h2><span id='topic+length'></span><span id='topic+length.onion'></span><span id='topic+length+3C-'></span><span id='topic+length+3C-.onion'></span><span id='topic+length+2Conion-method'></span><span id='topic+length+3C-+2Conion-method'></span>

<h3>Description</h3>

<p>Get or set the length of onions</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onion'
length(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="length_+3A_x">x</code></td>
<td>
<p>An onion</p>
</td></tr></table>


<h3>Details</h3>

<p>Operates on the columns of the matrix as expected.</p>


<h3>Value</h3>

<p>integer</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- roct(5)
length(a)

</code></pre>

<hr>
<h2 id='Logic'>Logical operations on onions</h2><span id='topic+logic.onion'></span><span id='topic+onion_logic'></span><span id='topic+Logic+2Conion-method'></span><span id='topic+Logic+2CANY+2Conion-method'></span><span id='topic+Logic+2Conion+2CANY-method'></span><span id='topic+Logic+2Conion+2Cmissing-method'></span>

<h3>Description</h3>

<p>Logical operations on onions are not supported</p>


<h3>Usage</h3>

<pre><code class='language-R'>onion_logic(e1,e2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Logic_+3A_e1">e1</code>, <code id="Logic_+3A_e2">e2</code></td>
<td>
<p>onions</p>
</td></tr></table>


<h3>Value</h3>

<p>none</p>


<h3>Note</h3>

<p>Carrying out logical operations in this group will report an error.
Negation, &ldquo;<code>!</code>&rdquo;, is not part of this group.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'># roct() &amp; roct()   # reports an error
</code></pre>

<hr>
<h2 id='Math'>Various logarithmic and circular functions for onions</h2><span id='topic+log'></span><span id='topic+exp'></span><span id='topic+cosh'></span><span id='topic+sinh'></span><span id='topic+acos'></span><span id='topic+acosh'></span><span id='topic+asin'></span><span id='topic+asinh'></span><span id='topic+atan'></span><span id='topic+atanh'></span><span id='topic+cos'></span><span id='topic+sin'></span><span id='topic+tan'></span><span id='topic+tanh'></span><span id='topic+onion_log'></span><span id='topic+onion_sign'></span><span id='topic+onion_sqrt'></span><span id='topic+onion_exp'></span><span id='topic+onion_cosh'></span><span id='topic+onion_sinh'></span><span id='topic+onion_acos'></span><span id='topic+onion_acosh'></span><span id='topic+onion_asin'></span><span id='topic+onion_asinh'></span><span id='topic+onion_atan'></span><span id='topic+onion_atanh'></span><span id='topic+onion_cos'></span><span id='topic+onion_sin'></span><span id='topic+onion_tan'></span><span id='topic+onion_tanh'></span><span id='topic+abs+2Conion-method'></span><span id='topic+log+2Conion-method'></span><span id='topic+exp+2Conion-method'></span><span id='topic+cosh+2Conion-method'></span><span id='topic+sinh+2Conion-method'></span><span id='topic+acos+2Conion-method'></span><span id='topic+acosh+2Conion-method'></span><span id='topic+asin+2Conion-method'></span><span id='topic+asinh+2Conion-method'></span><span id='topic+atan+2Conion-method'></span><span id='topic+atanh+2Conion-method'></span><span id='topic+cos+2Conion-method'></span><span id='topic+sin+2Conion-method'></span><span id='topic+tan+2Conion-method'></span><span id='topic+tanh+2Conion-method'></span><span id='topic+sqrt'></span>

<h3>Description</h3>

<p>Various elementary functions for onions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onion_log(x,base=exp(1))
onion_exp(x)
onion_sign(x)
onion_sqrt(x)
onion_cosh(x)
onion_sinh(x)
onion_acos(x)
onion_acosh(x)
onion_asin(x)
onion_asinh(x)
onion_atan(x)
onion_atanh(x)
onion_cos(x)
onion_sin(x)
onion_tan(x)
onion_tanh(x)
onion_cos(x)
onion_sin(x)
onion_tan(x)
onion_tanh(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Math_+3A_x">x</code></td>
<td>
<p>Object of class onion</p>
</td></tr>
<tr><td><code id="Math_+3A_base">base</code></td>
<td>
<p>In function <code>log()</code>, the base of the logarithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Standard math stuff.  I am not convinced that the trig functions
(<code>sin()</code> etc) have any value. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- roct()
exp(x+x) - exp(x)*exp(x) # zero to numerical precision

jj &lt;- exp(log(x)/2)      # use sqrt() here
jj*jj-x                  #  also small


y &lt;- roct()
exp(x+y) - exp(x)*exp(y) # some rules do not operate for onions



max(Mod(c(sin(asin(x))-x,asin(sin(x))-x)))   # zero to numerical precision



</code></pre>

<hr>
<h2 id='names'>Names of an onionic vector</h2><span id='topic+names.onion'></span><span id='topic+names.onion+3C-'></span><span id='topic+names+3C-'></span><span id='topic+names+3C-.onion'></span><span id='topic+names+2Conion-method'></span><span id='topic+names+3C-+2Conion-method'></span><span id='topic+names+2Conionmat-method'></span><span id='topic+names+3C-+2Conionmat-method'></span><span id='topic+rownames'></span><span id='topic+rownames+2Conionmat-method'></span><span id='topic+rownames+3C-+2Conionmat-method'></span><span id='topic+colnames'></span><span id='topic+colnames+2Conion-method'></span><span id='topic+colnames+2Conionmat-method'></span><span id='topic+colnames+3C-+2Conionmat-method'></span><span id='topic+dim'></span><span id='topic+dim+3C-'></span><span id='topic+dim+2Conionmat-method'></span><span id='topic+dim+3C-+2Conionmat-method'></span><span id='topic+dimnames+2Conionmat-method'></span><span id='topic+dimnames+3C-+2Conionmat-method'></span><span id='topic+dimnames+3C-+2Conionmat+2CANY-method'></span><span id='topic+nrow+2Conionmat-method'></span><span id='topic+ncol+2Conionmat-method'></span>

<h3>Description</h3>

<p>Functions to get or set the names of an onion</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onion'
names(x)
## S4 method for signature 'onionmat'
rownames(x)
## S4 method for signature 'onionmat'
colnames(x)
## S4 method for signature 'onionmat'
dimnames(x)
## S4 method for signature 'onionmat'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names_+3A_x">x</code></td>
<td>
<p>onion</p>
</td></tr></table>


<h3>Details</h3>

<p>Names attributes refers to colnames of the internal matrix, which
are retrieved or set using <code>colnames()</code> or <code>colnames&lt;-()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- roct(5)
names(a) &lt;- letters[1:5]

b &lt;- romat()
dimnames(b) &lt;- list(month = month.abb[1:5], location=names(islands)[1:6])

</code></pre>

<hr>
<h2 id='O1'>Unit onions</h2><span id='topic+H0'></span><span id='topic+H1'></span><span id='topic+Hi'></span><span id='topic+Hj'></span><span id='topic+Hk'></span><span id='topic+Hall'></span><span id='topic+Him'></span><span id='topic+O0'></span><span id='topic+O1'></span><span id='topic+Oi'></span><span id='topic+Oj'></span><span id='topic+Ok'></span><span id='topic+Ol'></span><span id='topic+Oil'></span><span id='topic+Ojl'></span><span id='topic+Okl'></span><span id='topic+Oim'></span><span id='topic+Oall'></span>

<h3>Description</h3>

<p>Each of the eight unit quaternions and octonions 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H1
Hi
Hj
Hk
H0
Him
Hall
O1
Oi
Oj
Ok
Ol
Oil
Ojl
O0
Oim
Oall
</code></pre>


<h3>Format</h3>

<p>Each one is an onionic vector of length one.</p>


<h3>Details</h3>

<p>Try <code>Hi</code> (=<code>quaternion(i=1)</code>) to get the pattern for the first
four.  The next ones are the zero quaternion, the pure imaginary
quaternion with all components 1, and the quaternion with all components
1.  The ones beginning with &ldquo;O&rdquo; follow a similar pattern.
</p>
<p>These are just variables that may be overwritten and thus resemble
<code>T</code> and <code>F</code> whose value may be changed.  
</p>


<h3>Value</h3>

<p>A length-one onion, either a quaternion or an octonion</p>


<h3>Examples</h3>

<pre><code class='language-R'>Oall
seq_onion(from=O1,to=Oil,len=6)

stopifnot(Hj*Hk ==  Hi)
stopifnot(Okl*Oil == -Oj )  # See tests/test_aaa.R for the full set

</code></pre>

<hr>
<h2 id='onion'>
Basic onion functions
</h2><span id='topic+onion'></span><span id='topic+octonion'></span><span id='topic+Octonion'></span><span id='topic+quaternion'></span><span id='topic+Quaternion'></span><span id='topic+is.onion'></span><span id='topic+is.octonion'></span><span id='topic+as.octonion'></span><span id='topic+is.quaternion'></span><span id='topic+as.quaternion'></span><span id='topic+as.onion'></span><span id='topic+quaternion_to_octonion'></span><span id='topic+octonion_to_quaternion'></span><span id='topic+as.matrix'></span><span id='topic+as.matrix+2Conion-method'></span><span id='topic+as.numeric+2Conion-method'></span><span id='topic+type'></span>

<h3>Description</h3>

<p>Construct, coerce to, test for, and print onions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>octonion(length.out = NULL, Re = 0, i = 0, j = 0, 
    k = 0, l = 0, il = 0, jl = 0, kl = 0)
as.octonion(x, single = FALSE)
is.octonion(x)
quaternion(length.out = NULL,Re = 0, i = 0, j = 0, k = 0)
as.quaternion(x, single = FALSE)
is.quaternion(x)
is.onion(x)
as.onion(x,type,single=FALSE)
quaternion_to_octonion(from)
octonion_to_quaternion(from)
## S4 method for signature 'onion'
as.matrix(x)
## S4 method for signature 'onion'
as.numeric(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="onion_+3A_length.out">length.out</code></td>
<td>
<p>In functions <code>quaternion()</code> and
<code>octonion()</code>, the length of the onionic vector returned</p>
</td></tr>
<tr><td><code id="onion_+3A_re">Re</code></td>
<td>
<p>The real part of the onionic vector returned</p>
</td></tr>
<tr><td><code id="onion_+3A_i">i</code>, <code id="onion_+3A_j">j</code>, <code id="onion_+3A_k">k</code></td>
<td>
<p>In functions <code>quaternion()</code> and <code>octonion()</code>,
component <code class="reqn">i,j,k</code> respectively of the returned onion</p>
</td></tr>
<tr><td><code id="onion_+3A_l">l</code>, <code id="onion_+3A_il">il</code>, <code id="onion_+3A_jl">jl</code>, <code id="onion_+3A_kl">kl</code></td>
<td>
<p>In function <code>octonion()</code>, component
<code class="reqn">l,il,jl,kl</code> respectively of the returned octonion</p>
</td></tr> 
<tr><td><code id="onion_+3A_x">x</code>, <code id="onion_+3A_from">from</code></td>
<td>
<p>Onion to be tested or printed</p>
</td></tr>
<tr><td><code id="onion_+3A_single">single</code></td>
<td>
<p>In functions <code>as.octonion()</code> and
<code>as.quaternion()</code>, Boolean  with
default <code>FALSE</code> meaning to interpret <code>x</code> as a vector of
reals to be coerced into an onion  with zero imaginary
part; and <code>TRUE</code> meaning to interpret <code>x</code> as a length 4
(or length 8) vector and return the corresponding single onion.</p>
</td></tr>
<tr><td><code id="onion_+3A_type">type</code></td>
<td>
<p>In function <code>as.onion()</code> a string either
&ldquo;<code>quaternion</code>&rdquo; or &ldquo;<code>octonion</code>&rdquo; denoting the
algebra to be forced into</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>quaternion()</code> and <code>octonion()</code> use standard
recycling where possible; <code>rbind()</code> is used.
</p>
<p>Functions <code>as.quaternion()</code> and <code>as.octonion()</code> coerce to
quaternions and octonions respectively.  If given a complex vector,
the real and imaginary components are interpreted
as <code>Re</code> and <code>i</code> respectively.
</p>
<p>The output of <code>type()</code> is accepted as the <code>type</code> argument of
function <code>as.onion()</code>; thus <code>as.onion(out,type=type(x))</code> works as
expected.
</p>


<h3>Value</h3>

<p>Generally return onions</p>


<h3>Note</h3>

<p>An <dfn>onion</dfn> is any algebra (over the reals) created by an iterated
Cayley-Dickson process.  Examples include quaternions, octonions, and
sedenions.  There does not appear to be a standard generic term for
such objects (I have seen n-ion, anion and others.  But &ldquo;onion&rdquo;
is pronouncable and a bona fide English word).
</p>
<p>Creating further onions&mdash;such as the sedenions&mdash;is intended to be
straightforward.
</p>
<p>There is a nice example of the onion package in use in the
<code>permutations</code> package, under <code>cayley.Rd</code>.  This also shows
the quaternion group Q8, but from a different perspective.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- octonion(Re=1,il=1:3)
x
kl(x) &lt;- 100
x

as.quaternion(diag(4))


# Cayley table for the quaternion group Q8:
a &lt;- c(H1,-H1,Hi,-Hi,Hj,-Hj,Hk,-Hk)
names(a) &lt;- c("+1","-1","+i","-i","+j","-j","+k","-k")

f &lt;- Vectorize(function(x,y){names(a)[a==a[x]*a[y]]})
X &lt;- noquote(outer(1:8,1:8, f))
rownames(X) &lt;- names(a)
colnames(X) &lt;- names(a)
X

</code></pre>

<hr>
<h2 id='onion-class'>Class &ldquo;onion&rdquo;</h2><span id='topic+onion-class'></span><span id='topic+quaternion-class'></span><span id='topic+octonion-class'></span><span id='topic+onionmat-class'></span><span id='topic+index-class'></span>

<h3>Description</h3>

<p>The formal S4 class for onion and onionmat objects</p>


<h3>Objects from the Class</h3>

<p>Class <dfn>onion</dfn> is a virtual S4 class extending classes
<dfn>quaternion</dfn> and <dfn>octonion</dfn>.  In package documentation,
&ldquo;<dfn>onion</dfn>&rdquo; means an <span class="rlang"><b>R</b></span> object that behaves as a vector of
quaternions or octonions, stored as a four- or eight- row numeric
matrix.
</p>
<p>Class <dfn>onionmat</dfn> is the S4 class for matrices whose
elements are quaternions or octonions.  An onionmat is stored as a
two-element list, the first being an onion and the second an integer
matrix which holds structural matrix attributes such as dimensions and
dimnames.  Most standard arithmetic <span class="rlang"><b>R</b></span> idiom for matrices should work
for onionmats.
</p>
<p>Class <dfn>index</dfn> is taken from the excellent <span class="pkg">Matrix</span> package and
is a <code>setClassUnion()</code> of classes <code>numeric</code>, <code>logical</code>,
and <code>character</code>, which mean that it is an arity-one matrix index.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.octonion(1:8,single=TRUE)
as.quaternion(matrix(runif(20),nrow=4))

H &lt;- matrix(rquat(21),3,7)
dimnames(H) &lt;- list(foo=letters[1:3],bar=state.abb[1:7])

i(H) &lt;- 0.1

I &lt;- matrix(rquat(14),7,2)
dimnames(I) &lt;- list(foo=state.abb[1:7],baz=LETTERS[1:2])
H %*% I

</code></pre>

<hr>
<h2 id='onionmat'>Onionic matrices</h2><span id='topic+onionmat'></span><span id='topic+as.onionmat'></span><span id='topic+newonionmat'></span><span id='topic+onionmat_prod_onionmat'></span><span id='topic+onionmat_neg'></span><span id='topic+onionmat_inv'></span><span id='topic+onionmat_unary'></span><span id='topic+onionmat_power_onionmat'></span><span id='topic+onionmat_prod_single'></span><span id='topic+single_prod_onionmat'></span><span id='topic+onionmat_power_single'></span><span id='topic+onionmat_plus_onionmat'></span><span id='topic+onionmat_plus_single'></span><span id='topic+onionmat_plus_matrix'></span><span id='topic+matrix_plus_onionmat'></span><span id='topic+onionmat_power_matrix'></span><span id='topic+onionmat_prod_matrix'></span><span id='topic+single_power_onionmat'></span><span id='topic+Ops.onionmat'></span><span id='topic+getM'></span><span id='topic+getd'></span><span id='topic+herm_onion_mat'></span><span id='topic+matrix+2Conion-method'></span><span id='topic+ncol-methods'></span><span id='topic+ncol+2CANY-method'></span><span id='topic+ncol.onionmat'></span><span id='topic+nrow-methods'></span><span id='topic+nrow+2CANY-method'></span><span id='topic+nrow.onionmat'></span><span id='topic+onionmatprod'></span><span id='topic+rownames-methods'></span><span id='topic+rownames+2CANY-method'></span><span id='topic+rownames.onionmat'></span><span id='topic+rownames+3C--methods'></span><span id='topic+rownames+3C-+2CANY-method'></span><span id='topic+rownames+3C-.onionmat'></span><span id='topic+diag.onion'></span><span id='topic+diag'></span><span id='topic+diag.onionmat'></span><span id='topic+diag+2Conionmat-method'></span><span id='topic+diag+2Conion-method'></span><span id='topic+diag+3C-.onionmat'></span><span id='topic+diag+3C-+2Conionmat-method'></span><span id='topic+t+2Conionmat-method'></span><span id='topic+t+2Conion-method'></span><span id='topic+t.onionmat'></span><span id='topic+t.onion'></span><span id='topic++25+2A+25'></span><span id='topic++25+2A+25+2Conionmat+2Conionmat-method'></span><span id='topic++25+2A+25+2Conionmat+2Conion-method'></span><span id='topic++25+2A+25+2Cnumeric+2Conion-method'></span><span id='topic++25+2A+25+2Cnumeric+2Conionmat-method'></span><span id='topic++25+2A+25+2Conion+2Conionmat-method'></span><span id='topic++25+2A+25+2Conionmat+2Cnumeric-method'></span><span id='topic++5B.onionmat'></span><span id='topic++5B+3C-.onionmat'></span><span id='topic+nrow'></span><span id='topic+ncol'></span><span id='topic+colnames+3C-'></span><span id='topic+rownames+3C-'></span><span id='topic+as.octonionmat'></span><span id='topic+as.quaternionmat'></span><span id='topic+ht'></span><span id='topic+ht+2Conionmat-method'></span><span id='topic+ht+2Conion-method'></span><span id='topic+cprod'></span><span id='topic+cprod+2Conionmat+2Conionmat-method'></span><span id='topic+cprod+2CANY+2Conionmat-method'></span><span id='topic+cprod+2Conionmat+2CANY-method'></span><span id='topic+cprod+2Conionmat+2Cmissing-method'></span><span id='topic+cprod+2CANY+2CANY-method'></span><span id='topic+cprod+2CANY+2Cmissing-method'></span><span id='topic+cprod+2Conion+2Cmissing-method'></span><span id='topic+cprod+2Conion+2Conion-method'></span><span id='topic+cprod+2Conion+2Conionmat-method'></span><span id='topic+cprod+2Conionmat+2Conion-method'></span><span id='topic+tcprod'></span><span id='topic+tcprod+2Conionmat+2Conionmat-method'></span><span id='topic+tcprod+2CANY+2Conionmat-method'></span><span id='topic+tcprod+2Conionmat+2CANY-method'></span><span id='topic+tcprod+2Conionmat+2Cmissing-method'></span><span id='topic+tcprod+2CANY+2CANY-method'></span><span id='topic+tcprod+2CANY+2Cmissing-method'></span><span id='topic+tcprod+2Conion+2Cmissing-method'></span><span id='topic+tcprod+2Conion+2Conion-method'></span><span id='topic+tcprod+2Conion+2Conionmat-method'></span><span id='topic+tcprod+2Conionmat+2Conion-method'></span><span id='topic++2B+2Conion+2Cmissing-method'></span><span id='topic+-+2Conion+2Cmissing-method'></span><span id='topic++2B+2Conionmat+2Cmissing-method'></span><span id='topic+-+2Conionmat+2Cmissing-method'></span><span id='topic+om_cprod'></span><span id='topic+om_tcprod'></span><span id='topic+om_ht'></span><span id='topic+om_prod'></span><span id='topic+onionmat_complex'></span><span id='topic+onionmat_conjugate'></span><span id='topic+onionmat_imag'></span><span id='topic+onionmat_re'></span><span id='topic+onionmat_mod'></span><span id='topic+single_arith_onionmat'></span><span id='topic+onionmat_arith_onionmat'></span><span id='topic+onionmat_arith_onion'></span><span id='topic+onionmat_arith_single'></span><span id='topic+onionmat_inverse'></span><span id='topic+onionmat_negative'></span><span id='topic+numeric_arith_onionmat'></span><span id='topic+onion_arith_onionmat'></span><span id='topic+onion_arith_single'></span><span id='topic+matrix_arith_onionmat'></span><span id='topic+onionmat_arith_matrix'></span><span id='topic+onionmat_matrixprod_onionmat'></span><span id='topic+onionmat_matrixprod_onion'></span><span id='topic+onionmat_matrixprod_numeric'></span><span id='topic+numeric_matrixprod_onionmat'></span><span id='topic+onion_matrixprod_onionmat'></span><span id='topic+is.onionmat'></span><span id='topic+matrix_arith_onion'></span><span id='topic+onion_arith_matrix'></span><span id='topic+matrix_plus_onion'></span><span id='topic+matrix_prod_onion'></span><span id='topic+onion_power_matrix'></span>

<h3>Description</h3>

<p>Simple functionality for quaternionic and octonionic matrices,
intended for use in the <code>jordan</code> package.  Use idiom like
<code>matrix(Him,4,5)</code> or <code>matrix(roct(6),2,3)</code> to create an
<code>onionmat</code> object, a matrix of onions.
</p>
<p>The package is intended to match base <span class="rlang"><b>R</b></span>'s matrix functionality in the
sense that standard <span class="rlang"><b>R</b></span> idiom just goes through for onionic matrices.
Determinants are not well-defined for quaternionic or octonionic
matrices, and matrix inverses are not implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newonionmat(d, M)
onionmat(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
as.onionmat(x)
is.onionmat(x)
onionmat_negative(e1)
onionmat_inverse(e1)
onionmat_prod_onionmat(e1,e2)
onionmat_power_onionmat(...)
onionmat_prod_single(x,y)
onionmat_power_single(e1,e2)
onionmat_plus_onionmat(e1,e2)
matrix_arith_onion(e1,e2)
onion_arith_matrix(e1,e2)
matrix_plus_onion(e1,e2)
matrix_prod_onion(e1,e2)
## S4 method for signature 'onionmat,onionmat'
cprod(x,y)
## S4 method for signature 'onionmat,missing'
cprod(x,y)
## S4 method for signature 'onionmat,ANY'
cprod(x,y)
## S4 method for signature 'ANY,ANY'
cprod(x,y)
## S4 method for signature 'onion,missing'
cprod(x,y)
## S4 method for signature 'onion,onion'
cprod(x,y)
## S4 method for signature 'onion,onionmat'
cprod(x,y)
## S4 method for signature 'onionmat,onion'
cprod(x,y)
## S4 method for signature 'onionmat,onionmat'
tcprod(x,y)
## S4 method for signature 'onionmat,missing'
tcprod(x,y)
## S4 method for signature 'onionmat,ANY'
tcprod(x,y)
## S4 method for signature 'ANY,ANY'
tcprod(x,y)
## S4 method for signature 'onion,missing'
cprod(x,y)
## S4 method for signature 'onion,onion'
cprod(x,y)
## S4 method for signature 'onion,onionmat'
cprod(x,y)
## S4 method for signature 'onionmat,onion'
cprod(x,y)
## S4 method for signature 'onionmat'
t(x)
## S4 method for signature 'onion'
t(x)
## S4 method for signature 'onionmat'
ht(x)
## S4 method for signature 'onion'
ht(x)
nrow(x)
ncol(x)
herm_onion_mat(real_diagonal, onions)
onionmat_complex(z)
onionmat_conjugate(z)
onionmat_imag(z)
onionmat_re(z)
onionmat_mod(z)
onionmat_matrixprod_onionmat(x,y)
onion_matrixprod_onionmat(x,y)
onionmat_matrixprod_numeric(x,y)
onionmat_matrixprod_onion(x,y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="onionmat_+3A_d">d</code>, <code id="onionmat_+3A_m">M</code></td>
<td>
<p>data and matrix index</p>
</td></tr>
<tr><td><code id="onionmat_+3A_x">x</code>, <code id="onionmat_+3A_y">y</code>, <code id="onionmat_+3A_z">z</code>, <code id="onionmat_+3A_e1">e1</code>, <code id="onionmat_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>onionmat</code></p>
</td></tr>
<tr><td><code id="onionmat_+3A_data">data</code>, <code id="onionmat_+3A_nrow">nrow</code>, <code id="onionmat_+3A_ncol">ncol</code>, <code id="onionmat_+3A_byrow">byrow</code>, <code id="onionmat_+3A_dimnames">dimnames</code></td>
<td>
<p>In function
<code>onionmat()</code>, as for <code>matrix()</code></p>
</td></tr>
<tr><td><code id="onionmat_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="onionmat_+3A_real_diagonal">real_diagonal</code>, <code id="onionmat_+3A_onions">onions</code></td>
<td>
<p>In function <code>herm_onion_mat()</code>, on-
and  off- diagonal elements of an Hermitian matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>onionmat</code> is a two-element list, the first of
which is an onion, and the second an index matrix of integers used for
tracking attributes such as dimensions and dimnames.  This device
makes the extraction and replacement methods easy.  Use <code>getM()</code>
to access the index matrix and <code>getd()</code> to access the onionic
vector.
</p>
<p>The S4 method for <code>matrix()</code> simply dispatches to
<code>onionmat()</code>, which is a drop-in replacement for <code>matrix()</code>.
</p>
<p>Function <code>drop()</code> has a method for <code>onionmat</code> objects.
</p>
<p>Function <code>newonionmat()</code> is lower-level: it also creates onionmat
objects, but takes two arguments: an onion and a matrix; the matrix
argument can be used to specify additional attributes via
<code>attr()</code>, but this ability is not currently used in the package.
</p>
<p>Functions such as <code>onionmat_plus_onionmat()</code> are low-level helper
functions, not really designed for the end-user.
</p>
<p>Vignette <code>onionmat</code> shows some use-cases.
</p>
<p>The print method for <code>onionmat</code> objects is sensitive to option
<code>show_onionmats_in_place</code>.  If <code>TRUE</code>, it prints the matrix
elements in-place, using <code>onion_to_string()</code>.  It works best when
option <code>show_onions_compactly</code> is effective.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
matrix(rquat(28),4,7)

M &lt;- onionmat(rquat(10),2,5)
cprod(M) 

Re(M)
Re(M) &lt;- 0.3

romat() %*% rquat(6)

a &lt;- rsomat()
a            # default
options("show_onionmats_in_place" = TRUE)
a
options("show_onionmats_in_place" = FALSE) # restore default


</code></pre>

<hr>
<h2 id='orthogonal'>Orthogonal matrix equivalents</h2><span id='topic+orthogonal'></span><span id='topic+as.orthogonal'></span><span id='topic+is_orthogonal'></span><span id='topic+matrix2quaternion'></span>

<h3>Description</h3>

<p>Convert a quaternion to and from an equivalent orthogonal matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2quaternion(M)
as.orthogonal(Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthogonal_+3A_m">M</code></td>
<td>
<p>A three-by-three orthogonal matrix</p>
</td></tr>
<tr><td><code id="orthogonal_+3A_q">Q</code></td>
<td>
<p>A vector of quaternions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>matrix2quaternion()</code> returns a quaternion.
</p>
<p>Function <code>as.orthogonal()</code> returns either a <code class="reqn">3\times 3</code>
matrix or a <code class="reqn">3\times3\times n</code> array of orthogonal matrices
</p>


<h3>Note</h3>

<p>Function <code>matrix2quaternion()</code> is low-level; use
<code>as.quaternion()</code> to convert arrays.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotate">rotate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.orthogonal(rquat(1))

o &lt;- function(w){diag(3)-2*outer(w,w)/sum(w^2)}  # Householder
matrix2quaternion(o(1:3))   # Booorrrriiinnnggg
matrix2quaternion(o(1:3) %*% o(3:1))

Q &lt;- rquat(7)
Q &lt;- Q/abs(Q)
as.quaternion(as.orthogonal(Q))   # +/- Q


A &lt;- replicate(7,o(rnorm(3)) %*% o(rnorm(3)))
max(abs(as.orthogonal(as.quaternion(A))-A))

</code></pre>

<hr>
<h2 id='p3d'>Three dimensional plotting</h2><span id='topic+p3d'></span>

<h3>Description</h3>

<p>Three dimensional plotting of points.  Produces a nice-looking 3D
scatterplot with greying out of further points giving a visual depth cue
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p3d(x, y, z, xlim = NULL, ylim = NULL, zlim = NULL, d0 = 0.2, h = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p3d_+3A_x">x</code>, <code id="p3d_+3A_y">y</code>, <code id="p3d_+3A_z">z</code></td>
<td>
<p>vector of <code class="reqn">x,y,z</code> coordinates to be plotted.  If
<code>x</code> is a matrix, interpret the rows as 3D Cartesian coordinates</p>
</td></tr>
<tr><td><code id="p3d_+3A_xlim">xlim</code>, <code id="p3d_+3A_ylim">ylim</code>, <code id="p3d_+3A_zlim">zlim</code></td>
<td>
<p>Limits of plot in the <code class="reqn">x,y,z</code> directions,
with default <code>NULL</code> meaning to use <code>range()</code></p>
</td></tr>
<tr><td><code id="p3d_+3A_d0">d0</code></td>
<td>
<p>E-folding distance for graying out (depths are standardized
to be between 0 and 1)</p>
</td></tr>
<tr><td><code id="p3d_+3A_h">h</code></td>
<td>
<p>The hue for the points, with default value of 1 corresponding
to red. If <code>NULL</code>, produce black points greying to white</p>
</td></tr>
<tr><td><code id="p3d_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>persp()</code> and
<code>points()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value returned is that given by function <code>trans3d()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+bunny">bunny</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bunny)
p3d(bunny,theta=3,phi=104,box=FALSE)
</code></pre>

<hr>
<h2 id='plot'>Plot onions</h2><span id='topic+plot'></span><span id='topic+plot.onion'></span><span id='topic+plot+2Conion-method'></span>

<h3>Description</h3>

<p>Plotting method for onionic vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onion'
plot(x,y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code>, <code id="plot_+3A_y">y</code></td>
<td>
<p>Onions</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>plot.default()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is <code>plot(Re(x), Mod(Im(x)), ...)</code>, and thus
behaves similarly to <code>plot()</code> when called with a complex vector.
</p>


<h3>Value</h3>

<p>Called for its side-effect of plotting a diagram</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(roct(30))
</code></pre>

<hr>
<h2 id='prods'>Various products of two onions</h2><span id='topic+prods'></span><span id='topic++25+3C+2A+3E+25'></span><span id='topic++25+3E+2A+3C+25'></span><span id='topic++25+3C.+3E+25'></span><span id='topic++25+3E.+3C+25'></span><span id='topic++25.+25'></span><span id='topic++25+3C+2A+3E+25.onion'></span><span id='topic++25+3E+2A+3C+25.onion'></span><span id='topic++25+3C.+3E+25.onion'></span><span id='topic++25+3E.+3C+25.onion'></span><span id='topic+onion_g_even'></span><span id='topic+onion_g_odd'></span><span id='topic+onion_e_even'></span><span id='topic+onion_e_odd'></span><span id='topic+g_even.onion'></span><span id='topic+g_odd.onion'></span><span id='topic+e_even.onion'></span><span id='topic+e_odd.onion'></span><span id='topic+dotprod'></span>

<h3>Description</h3>

<p>Returns various inner and outer products of two onionic vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %&lt;*&gt;% y
x %&gt;*&lt;% y
x %&lt;.&gt;% y
x %&gt;.&lt;% y
x %.% y
onion_g_even(x,y)
onion_g_odd (x,y)
onion_e_even(x,y)
onion_e_odd (x,y)
dotprod(x,y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prods_+3A_x">x</code>, <code id="prods_+3A_y">y</code></td>
<td>
<p>onions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This page documents an attempt at a consistent notation for onionic
products.  The default product for onions (viz &ldquo;<code>*</code>&rdquo;) is
sometimes known as the &ldquo;Grassman product&rdquo;.  There is another
product known as the Euclidean product defined by <code class="reqn">E(p,q)=p'q</code>
where <code class="reqn">x'</code> is the conjugate of <code class="reqn">x</code>.
</p>
<p>Each of these products separates into an &ldquo;even&rdquo; and an
&ldquo;odd&rdquo; part, here denoted by functions <code>g_even()</code> and
<code>g_odd()</code> for the Grassman product, and <code>e_even()</code> and
<code>e_odd()</code> for the Euclidean product.  These are defined as
follows:
</p>

<ul>
<li> <p><code>g_even(x,y)=(xy+yx)/2</code>
</p>
</li>
<li> <p><code>g_odd(x,y)=(xy-yx)/2</code>
</p>
</li>
<li> <p><code>e_even(x,y)=(x'y+y'x)/2</code> 
</p>
</li>
<li> <p><code>e_odd(x,y)=(x'y-y'x)/2</code>
</p>
</li></ul>

<p>These functions have an equivalent binary operator.
</p>
<p>The Grassman operators have a &ldquo;<code>*</code>&rdquo;; they are
&ldquo;<code>%&lt;*&gt;%</code>&rdquo; for the even Grassman product and
&ldquo;<code>%&gt;*&lt;%</code>&rdquo; for the odd product.
</p>
<p>The Euclidean operators have a &ldquo;<code>.</code>&rdquo;; they are
&ldquo;<code>%&lt;.&gt;%</code>&rdquo; for the even Euclidean product and
&ldquo;<code>%&gt;.&lt;%</code>&rdquo; for the odd product.
</p>
<p>Function <code>dotprod()</code> returns the Euclidean even product of two
onionic vectors.  That is, if <code>x</code> and <code>y</code> are eight-element
vectors of the components of two onions, return <code>sum(x*y)</code>.
</p>
<p>Note that the returned value is a numeric vector (compare
<code>%&lt;.&gt;%</code>, <code>e.even()</code>, which return onionic vectors with zero
imaginary part).
</p>
<p>There is no binary operator for the ordinary Euclidean product (it seems
to be rarely needed in practice).  For <code>Conj(x)*x</code>, <code>Norm(x)</code>
is much more efficient and accurate.
</p>
<p>Function <code>prod()</code> is documented at <code>Summary.Rd</code>.
</p>


<h3>Note</h3>

<p>Frankly if you find yourself using these operators you might be
better off using the <span class="pkg">clifford</span> package, which has an extensive
and consistent suite of product operators.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>Oj %&lt;.&gt;% Oall
</code></pre>

<hr>
<h2 id='rep'>Replicate elements of onionic vectors</h2><span id='topic+rep'></span><span id='topic+rep.onion'></span><span id='topic+rep+2Conion-method'></span>

<h3>Description</h3>

<p>Replicate elements of onionic vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onion'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rep_+3A_x">x</code></td>
<td>
<p>Onionic vector</p>
</td></tr>
<tr><td><code id="rep_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>seq.default()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- roct(3)
rep(a,2) + a[1]
rep(a,each=2)
rep(a,length.out=5)
</code></pre>

<hr>
<h2 id='roct'>Random onionic vectors</h2><span id='topic+rquat'></span><span id='topic+roct'></span><span id='topic+romat'></span><span id='topic+rsquat'></span><span id='topic+rsoct'></span><span id='topic+rsomat'></span><span id='topic+ronionmat'></span>

<h3>Description</h3>

<p>Random quaternion or octonion vectors and matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rquat(n=5)
roct(n=5)
rsquat(n=11,s=12)
rsoct(n=11,s=12)
romat(type="quaternion", nrow=5, ncol=6, ...)
rsomat(type="quaternion", nrow=5, ncol=6, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roct_+3A_n">n</code></td>
<td>
<p>Length of random vector returned</p>
</td></tr>
<tr><td><code id="roct_+3A_nrow">nrow</code>, <code id="roct_+3A_ncol">ncol</code>, <code id="roct_+3A_...">...</code></td>
<td>
<p>Further arguments specifying properties of the
returned matrix</p>
</td></tr>
<tr><td><code id="roct_+3A_s">s</code></td>
<td>
<p>In the sparse functions <code>rsquat()</code> and <code>rsoct()</code>,
an integer specifying the level of sparsity, with higher values
meaning to return sparser onions</p>
</td></tr>
<tr><td><code id="roct_+3A_type">type</code></td>
<td>
<p>string specifying type of elements</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>rquat()</code> returns a quaternionic vector, <code>roct()</code>
returns an octonionic vector, and <code>romat()</code> a quaternionic
matrix.
</p>
<p>Functions <code>rquat()</code> and <code>roct()</code> give a quick &ldquo;get
you going&rdquo; random onion to play with.  Function <code>romat()</code> gives a
simple onionmat, although arguably <code>matrix(roct(4),2,2)</code> is as
convenient.
</p>
<p>The &ldquo;sparse&rdquo; functions <code>rsquat()</code> and <code>rsoct()</code> and
<code>rsomat()</code> return onions that have many zero entries; non-zero
entries are small integers.  They showcase the print method for the
case when <code>show_onions_compactly</code> is set.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>K. Shoemake 1992. &ldquo;Uniform random rotations&rdquo;. 
In D. Kirk, editor, <em>Graphics Gems III</em> pages 129-130. Academic,
New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rquat(3)
roct(3)
plot(roct(30))

romat()


rsquat()
rsoct()

</code></pre>

<hr>
<h2 id='rotate'>Rotates 3D vectors using quaternions</h2><span id='topic+rotate'></span>

<h3>Description</h3>

<p>Rotates a three-column matrix whose rows are vectors in 3D space,
using quaternions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate(x, H)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_+3A_x">x</code></td>
<td>
<p>A matrix of three columns whose rows are points in 3D space</p>
</td></tr>
<tr><td><code id="rotate_+3A_h">H</code></td>
<td>
<p>A quaternion.  Does not need to have unit modulus</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of the same size as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+orthogonal">orthogonal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bunny)
par(mfrow=c(2,2))
par(mai=rep(0,4))
p3d(rotate(bunny,Hi),box=FALSE)
p3d(rotate(bunny,H1-Hi+Hj),box=FALSE)
p3d(rotate(bunny,Hk),box=FALSE)
p3d(rotate(bunny,Hall),box=FALSE)

o &lt;- function(w){diag(3)-2*outer(w,w)/sum(w^2)}  # Householder
O &lt;- o(1:3) %*% o(3:1)

rotate(bunny,as.quaternion(O))
bunny %*% t(O)    # should be the same; note transpose

</code></pre>

<hr>
<h2 id='round'>Rounding of onions</h2><span id='topic+round'></span><span id='topic+round+2Conion-method'></span><span id='topic+round+2Conionmat-method'></span>

<h3>Description</h3>

<p>Round elements of an onion</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S4 method for signature 'onion'
round(x,digits=0)
   ## S4 method for signature 'onionmat'
round(x,digits=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="round_+3A_x">x</code></td>
<td>
<p>Object of class <code>onion</code></p>
</td></tr>
<tr><td><code id="round_+3A_digits">digits</code></td>
<td>
<p>number of digits to round to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>onion</code>s, coerce to a matrix, round, then coerce back to an
<code>onion</code>.  For <code>onionmat</code>s, coerce to an <code>onion</code>, round,
then coerce back to an <code>onionmat</code>.
</p>


<h3>Value</h3>

<p>Return an onion</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
round(rquat()*100)
round(rquat()*100,3)
</code></pre>

<hr>
<h2 id='seq'>seq method for onions</h2><span id='topic+seq'></span><span id='topic+seq.onion'></span><span id='topic+seq_onion'></span><span id='topic+seq+2Conion-method'></span><span id='topic+slerp'></span><span id='topic+SLERP'></span>

<h3>Description</h3>

<p>Rough equivalent of <code>seq()</code> for onions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_onion(from=1,to=1,by=((to-from)/(length.out-1)),length.out=NULL,slerp=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_+3A_from">from</code></td>
<td>
<p>Onion for start of sequence</p>
</td></tr>
<tr><td><code id="seq_+3A_to">to</code></td>
<td>
<p>Onion for end of sequence</p>
</td></tr>
<tr><td><code id="seq_+3A_by">by</code></td>
<td>
<p>Onion for interval</p>
</td></tr>
<tr><td><code id="seq_+3A_length.out">length.out</code></td>
<td>
<p>Length of vector returned</p>
</td></tr>
<tr><td><code id="seq_+3A_slerp">slerp</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to use linear
interpolation and <code>TRUE</code> meaning to use spherical linear
interpolation (useful for animating 3D rotation)</p>
</td></tr>
<tr><td><code id="seq_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq(from=O1,to=Oil,length.out=6)
seq(from=H1,to=(Hi+Hj)/2,len=10,slerp=TRUE)
</code></pre>

<hr>
<h2 id='show'>Print method for onions</h2><span id='topic+show'></span><span id='topic+print'></span><span id='topic+print.quaternion'></span><span id='topic+print.octonion'></span><span id='topic+print.onion'></span><span id='topic+print.onionmat'></span><span id='topic+print+2Conion-method'></span><span id='topic+onion_show'></span><span id='topic+show+2Conion-method'></span><span id='topic+onionmat_show'></span><span id='topic+onion_to_string_lowlevel'></span><span id='topic+onion_to_string'></span><span id='topic+comp_names'></span>

<h3>Description</h3>

<p>Show methods for onions</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onion'
show(object)
onion_show(x,
     comp = getOption("show_onions_compactly"),
     h    = getOption("show_onions_horizontally")
)
comp_names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show_+3A_x">x</code>, <code id="show_+3A_object">object</code></td>
<td>
<p>Onions</p>
</td></tr>
<tr><td><code id="show_+3A_comp">comp</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to print onions
compactly and any other value to print in matrix form</p>
</td></tr> 
<tr><td><code id="show_+3A_h">h</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to print by columns and any
other value  meaning to print horizontally</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default behaviour is to print by rows.  To print by columns, set
option <code>show_onions_horizontally</code> to <code>TRUE</code>:
</p>
<p><code>options("show_onions_horizontally" = TRUE)</code>
</p>
<p>Any non-<code>TRUE</code> value (including <code>NULL</code> and its being unset)
will restore the default.
</p>
<p>Similarly, to show onions compactly,  set option
<code>show_onions_compactly</code> to <code>TRUE</code>:
</p>
<p><code>options("show_onions_compactly" = TRUE)</code>
</p>
<p>This option works best for simple onions with integer entries (or at
least values with few decimal places), and especially if there are
many zero entries.
</p>
<p>Function <code>onion_show()</code> is a helper function, not really intended
for the end-user.
</p>
<p>The &ldquo;names&rdquo; of the components of an onion (viz <code>Re</code>,
<code>i</code>, <code>j</code>, <code>k</code> for quaternions and <code>Re</code>, <code>i</code>,
<code>j</code>, <code>k</code>, <code>l</code>,<code>il</code>,<code>jl</code>,<code>kl</code> for
octonions) are given by function <code>comp_names()</code> which takes
either a character string or an onion.
</p>


<h3>Note</h3>

<p>The print method for <code>onionmat</code> objects is also sensitive to
these options.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- roct(15)
x  #default

options("show_onions_horizontally" = TRUE)
roct(4) 

options("show_onions_horizontally" = FALSE)  # restore default

options("show_onions_compactly" = TRUE)
x &lt;- as.quaternion(matrix(sample(c(0,0,0,-1,1),80,replace=TRUE),4,20))
options("show_onions_compactly" = FALSE) # restore default

</code></pre>

<hr>
<h2 id='sum'>Various summary statistics for onions</h2><span id='topic+sum'></span><span id='topic+min'></span><span id='topic+max'></span><span id='topic+prod'></span><span id='topic+range'></span><span id='topic+Summary+2Conion-method'></span><span id='topic+sum+2Conion-method'></span><span id='topic+sum+2Cquaternion-method'></span><span id='topic+sum+2Coctonion-method'></span><span id='topic+sum+2Conionmat-method'></span><span id='topic+prod+2Cquaternion-method'></span><span id='topic+prod+2Coctonion-method'></span><span id='topic+str_onion'></span><span id='topic+str+2Conion-method'></span><span id='topic+onion_allsum'></span><span id='topic+onionmat_allsum'></span><span id='topic+quaternion_allprod'></span>

<h3>Description</h3>

<p>Various summary statistics for onions</p>


<h3>Usage</h3>

<pre><code class='language-R'>onion_allsum(x)
## S4 method for signature 'onion'
sum(x)
## S4 method for signature 'quaternion'
prod(x)
## S4 method for signature 'octonion'
sum(x)
## S4 method for signature 'onionmat'
sum(x)
## S4 method for signature 'octonion'
prod(x)
## S4 method for signature 'onion'
str(object, ...)
str_onion(object, vec.len = 4, ...)
onion_allsum(x)
onionmat_allsum(x)
quaternion_allprod(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum_+3A_x">x</code>, <code id="sum_+3A_object">object</code>, <code id="sum_+3A_...">...</code></td>
<td>
<p>Objects of class <code>onion</code></p>
</td></tr>
<tr><td><code id="sum_+3A_vec.len">vec.len</code></td>
<td>
<p>number of elements to display</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a <code>onion</code> object, return the sum or product accordingly</p>


<h3>Value</h3>

<p>Return an onion</p>


<h3>Note</h3>

<p>Function <code>str()</code> uses functionality from <code>condense()</code>.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sum(roct())
str(roct())
</code></pre>

<hr>
<h2 id='threeform'>Various non-field diagnostics</h2><span id='topic+threeform'></span><span id='topic+associator'></span><span id='topic+commutator'></span>

<h3>Description</h3>

<p>Diagnostics of non-field behaviour: threeform, associator, commutator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threeform(x1, x2, x3)
associator(x1, x2, x3)
commutator(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threeform_+3A_x1">x1</code>, <code id="threeform_+3A_x2">x2</code>, <code id="threeform_+3A_x3">x3</code></td>
<td>
<p>onionic vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The threeform is defined as <code>Re(x1 * (Conj(x2) * x3) - x3
    * (Conj(x2) * x1))/2</code>;
</p>
<p>the associator is <code>(x1 * x2) * x3 - x1 * (x2 * x3)</code>;
</p>
<p>the commutator is <code>x1 * x2 - x2 * x1</code>.
</p>


<h3>Value</h3>

<p>Returns an octonionic vector</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+dot">dot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- roct(7) ; y &lt;- roct(7) ; z &lt;- roct(7)
associator(x,y,z)
</code></pre>

<hr>
<h2 id='zapsmall'>Concatenation</h2><span id='topic+zapsmall'></span><span id='topic+zap'></span><span id='topic+zapsmall+2Conion-method'></span><span id='topic+zapsmall+2Conionmat-method'></span>

<h3>Description</h3>

<p>Zapping small components to zero</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'onion'
zapsmall(x,digits=getOption("digits"))
## S4 method for signature 'onionmat'
zapsmall(x,digits=getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zapsmall_+3A_x">x</code></td>
<td>
<p>An onion or onionmat</p>
</td></tr>
<tr><td><code id="zapsmall_+3A_digits">digits</code></td>
<td>
<p>integer indicating the precision to be used as in <code>base::zapsmall()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>base::zapsmall()</code> to zap small elements to zero.
</p>


<h3>Value</h3>

<p>An onion</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
zapsmall(as.octonion(0.01^(1:8),single=TRUE))


a &lt;- roct(7)
x &lt;- a^1/a
x
zapsmall(x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
