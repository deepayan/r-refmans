<!DOCTYPE html><html lang="en"><head><title>Help for package lme4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lme4}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lme4-package'><p>Linear, generalized linear, and nonlinear mixed models</p></a></li>
<li><a href='#allFit'><p>Refit a fitted model with all available optimizers</p></a></li>
<li><a href='#Arabidopsis'>
<p>Arabidopsis clipping/fertilization data</p></a></li>
<li><a href='#bootMer'><p>Model-based (Semi-)Parametric Bootstrap for Mixed Models</p></a></li>
<li><a href='#cake'><p>Breakage Angle of Chocolate Cakes</p></a></li>
<li><a href='#cbpp'><p>Contagious bovine pleuropneumonia</p></a></li>
<li><a href='#checkConv'>
<p>Extended Convergence Checking</p></a></li>
<li><a href='#confint.merMod'><p>Compute Confidence Intervals for Parameters of a [ng]lmer Fit</p></a></li>
<li><a href='#convergence'><p>Assessing Convergence for Fitted Models</p></a></li>
<li><a href='#devcomp'><p>Extract the deviance component list</p></a></li>
<li><a href='#devfun2'><p>Deviance Function in Terms of Standard Deviations/Correlations</p></a></li>
<li><a href='#drop1.merMod'><p>Drop all possible single fixed-effect terms from a mixed effect model</p></a></li>
<li><a href='#dummy'><p>Dummy variables (experimental)</p></a></li>
<li><a href='#Dyestuff'><p>Yield of dyestuff by batch</p></a></li>
<li><a href='#expandDoubleVerts'><p>Expand terms with <code>'||'</code> notation into separate <code>'|'</code> terms</p></a></li>
<li><a href='#factorize'><p>Attempt to convert grouping variables to factors</p></a></li>
<li><a href='#findbars'><p>Determine random-effects expressions from a formula</p></a></li>
<li><a href='#fixef'><p>Extract fixed-effects estimates</p></a></li>
<li><a href='#fortify'><p>add information to data based on a fitted model</p></a></li>
<li><a href='#getME'><p>Extract or Get Generalized Components from a Fitted Mixed Effects Model</p></a></li>
<li><a href='#GHrule'><p>Univariate Gauss-Hermite quadrature rule</p></a></li>
<li><a href='#glmer'><p>Fitting Generalized Linear Mixed-Effects Models</p></a></li>
<li><a href='#glmer.nb'><p>Fitting Negative Binomial GLMMs</p></a></li>
<li><a href='#glmerLaplaceHandle'><p>Handle for <code>glmerLaplace</code></p></a></li>
<li><a href='#glmFamily'><p>Generator object for the <code>glmFamily</code> class</p></a></li>
<li><a href='#glmFamily-class'><p>Class <code>"glmFamily"</code> - a reference class for <code>family</code></p></a></li>
<li><a href='#golden-class'><p>Class <code>"golden"</code> and Generator for Golden Search Optimizer Class</p></a></li>
<li><a href='#GQdk'><p>Sparse Gaussian / Gauss-Hermite Quadrature grid</p></a></li>
<li><a href='#grouseticks'>
<p>Data on red grouse ticks from Elston et al. 2001</p></a></li>
<li><a href='#hatvalues.merMod'><p>Diagonal elements of the hat matrix</p></a></li>
<li><a href='#influence.merMod'><p>Influence Diagnostics for Mixed-Effects Models</p></a></li>
<li><a href='#InstEval'><p>University Lecture/Instructor Evaluations by Students at ETH</p></a></li>
<li><a href='#isNested'><p>Is f1 nested within f2?</p></a></li>
<li><a href='#isREML'><p>Check characteristics of models</p></a></li>
<li><a href='#isSingular'><p>Test Fitted Model for (Near) Singularity</p></a></li>
<li><a href='#lme4_testlevel'><p>Detect testing level for lme4 examples and tests</p></a></li>
<li><a href='#lmer'><p>Fit Linear Mixed-Effects Models</p></a></li>
<li><a href='#lmerControl'><p>Control of Mixed Model Fitting</p></a></li>
<li><a href='#lmList'><p>Fit List of lm or glm Objects with a Common Model</p></a></li>
<li><a href='#lmList4-class'><p>Class &quot;lmList4&quot; of 'lm' Objects on Common Model</p></a></li>
<li><a href='#lmResp'><p>Generator objects for the response classes</p></a></li>
<li><a href='#lmResp-class'><p>Reference Classes for Response Modules, <code>"(lm|glm|nls|lmer)Resp"</code></p></a></li>
<li><a href='#merMod-class'><p>Class &quot;merMod&quot; of Fitted Mixed-Effect Models</p></a></li>
<li><a href='#merPredD'><p>Generator object for the <code>merPredD</code> class</p></a></li>
<li><a href='#merPredD-class'><p>Class <code>"merPredD"</code> - a Dense Predictor Reference Class</p></a></li>
<li><a href='#mkMerMod'><p>Create a 'merMod' Object</p></a></li>
<li><a href='#mkRespMod'><p>Create an lmerResp, glmResp or nlsResp instance</p></a></li>
<li><a href='#mkReTrms'><p>Make Random Effect Terms: Create Z, Lambda, Lind, etc.</p></a></li>
<li><a href='#mkSimulateTemplate'><p>Make templates suitable for guiding mixed model simulations</p></a></li>
<li><a href='#mkVarCorr'><p>Make Variance and Correlation Matrices from <code>theta</code></p></a></li>
<li><a href='#modular'><p>Modular Functions for Mixed Model Fits</p></a></li>
<li><a href='#namedList'><p>Self-naming list function</p></a></li>
<li><a href='#NelderMead'><p>Nelder-Mead Optimization of Parameters, Possibly (Box) Constrained</p></a></li>
<li><a href='#NelderMead-class'><p>Class <code>"NelderMead"</code> of Nelder-Mead optimizers and its Generator</p></a></li>
<li><a href='#ngrps'><p>Number of Levels of a Factor or a &quot;merMod&quot; Model</p></a></li>
<li><a href='#nlformula'><p>Manipulate a Nonlinear Model Formula</p></a></li>
<li><a href='#nlmer'><p>Fitting Nonlinear Mixed-Effects Models</p></a></li>
<li><a href='#nloptwrap'><p>Wrappers for additional optimizers</p></a></li>
<li><a href='#nobars'><p>Omit terms separated by vertical bars in a formula</p></a></li>
<li><a href='#Pastes'><p>Paste strength by batch and cask</p></a></li>
<li><a href='#Penicillin'><p>Variation in penicillin testing</p></a></li>
<li><a href='#plot.merMod'><p>Diagnostic Plots for 'merMod' Fits</p></a></li>
<li><a href='#plots.thpr'><p>Mixed-Effects Profile Plots (Regular / Density / Pairs)</p></a></li>
<li><a href='#predict.merMod'><p>Predictions from a model at new data values</p></a></li>
<li><a href='#profile-methods'><p>Profile method for merMod objects</p></a></li>
<li><a href='#prt-utilities'><p>Print and Summary Method Utilities for Mixed Effects</p></a></li>
<li><a href='#pvalues'><p>Getting p-values for fitted models</p></a></li>
<li><a href='#ranef'><p>Extract the modes of the random effects</p></a></li>
<li><a href='#refit'><p>Refit a (merMod) Model with a Different Response</p></a></li>
<li><a href='#refitML'><p>Refit a Model by Maximum Likelihood Criterion</p></a></li>
<li><a href='#rePCA'><p>PCA of random-effects covariance matrix</p></a></li>
<li><a href='#rePos'><p>Generator object for the rePos (random-effects positions) class</p></a></li>
<li><a href='#rePos-class'><p>Class <code>"rePos"</code></p></a></li>
<li><a href='#residuals.merMod'><p>residuals of merMod objects</p></a></li>
<li><a href='#sigma'><p>Extract Residual Standard Deviation 'Sigma'</p></a></li>
<li><a href='#simulate.formula'><p>A <code>simulate</code> Method for <code>formula</code> objects that dispatches based on the Left-Hand Side</p></a></li>
<li><a href='#simulate.merMod'><p>Simulate Responses From <code>merMod</code> Object</p></a></li>
<li><a href='#sleepstudy'><p>Reaction times in a sleep deprivation study</p></a></li>
<li><a href='#subbars'><p>&quot;Sub[stitute] Bars&quot;</p></a></li>
<li><a href='#troubleshooting'><p>Troubleshooting</p></a></li>
<li><a href='#VarCorr'><p>Extract Variance and Correlation Components</p></a></li>
<li><a href='#vcconv'><p>Convert between representations of (co-)variance structures</p></a></li>
<li><a href='#vcov.merMod'><p>Covariance matrix of estimated parameters</p></a></li>
<li><a href='#VerbAgg'><p>Verbal Aggression item responses</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.1-36</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear Mixed-Effects Models using 'Eigen' and S4</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit linear and generalized linear mixed-effects models.
    The models and their components are represented using S4 classes and
    methods.  The core computational algorithms are implemented using the
    'Eigen' C++ library for numerical linear algebra and 'RcppEigen' "glue".</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), Matrix, methods, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.10.5), RcppEigen (&ge; 0.3.3.9.4), Matrix (&ge;
1.2-3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grid, splines, utils, parallel, MASS, lattice, boot,
nlme (&ge; 3.1-123), minqa (&ge; 1.1.15), nloptr (&ge; 1.0.4),
reformulas (&ge; 0.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, MEMSS, testthat (&ge; 0.8.1), ggplot2,
mlmRev, optimx (&ge; 2013.8.6), gamm4, pbkrtest, HSAUR3,
numDeriv, car, dfoptim, mgcv, statmod, rr2, semEff, tibble,
merDeriv</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lme4/lme4/">https://github.com/lme4/lme4/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lme4/lme4/issues">https://github.com/lme4/lme4/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 22:13:57 UTC; bolker</td>
</tr>
<tr>
<td>Author:</td>
<td>Douglas Bates <a href="https://orcid.org/0000-0001-8316-9503"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Ben Bolker <a href="https://orcid.org/0000-0002-2127-0443"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Steven Walker <a href="https://orcid.org/0000-0002-4394-9078"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Rune Haubo Bojesen Christensen
    <a href="https://orcid.org/0000-0002-4494-3399"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Henrik Singmann <a href="https://orcid.org/0000-0002-4842-3657"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Bin Dai [ctb],
  Fabian Scheipl <a href="https://orcid.org/0000-0001-8172-3603"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Gabor Grothendieck [ctb],
  Peter Green <a href="https://orcid.org/0000-0002-0238-9852"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  John Fox [ctb],
  Alexander Bauer [ctb],
  Pavel N. Krivitsky
    <a href="https://orcid.org/0000-0002-9101-3362"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb, cph]
    (shared copyright on simulate.formula),
  Emi Tanaka <a href="https://orcid.org/0000-0002-1455-259X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Mikael Jagan <a href="https://orcid.org/0000-0002-3542-2938"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Bolker &lt;bbolker+lme4@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-11 15:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='lme4-package'>Linear, generalized linear, and nonlinear mixed models</h2><span id='topic+lme4'></span><span id='topic+lme4-package'></span>

<h3>Description</h3>

<p><code>lme4</code> provides functions for fitting and analyzing
mixed models: linear (<code><a href="#topic+lmer">lmer</a></code>), generalized linear
(<code><a href="#topic+glmer">glmer</a></code>) and nonlinear (<code><a href="#topic+nlmer">nlmer</a></code>.)
</p>


<h3>Differences between <span class="pkg">nlme</span> and <span class="pkg">lme4</span></h3>

<p><span class="pkg">lme4</span> covers approximately the same ground as the earlier
<span class="pkg">nlme</span> package.  The most important differences are:
</p>

<ul>
<li> <p><span class="pkg">lme4</span> uses modern, efficient linear algebra methods
as implemented in the <code>Eigen</code> package, and uses reference
classes to avoid undue copying of large objects; it is therefore likely
to be faster and more memory-efficient than <span class="pkg">nlme</span>.
</p>
</li>
<li> <p><span class="pkg">lme4</span> includes generalized linear mixed model (GLMM)
capabilities, via the <code><a href="#topic+glmer">glmer</a></code> function.
</p>
</li>
<li> <p><span class="pkg">lme4</span> does <em>not</em> currently implement <span class="pkg">nlme</span>'s
features for modeling heteroscedasticity and
correlation of residuals.
</p>
</li>
<li> <p><span class="pkg">lme4</span> does not currently offer the same flexibility
as <span class="pkg">nlme</span> for composing complex variance-covariance structures,
but it does implement crossed random effects in a way that
is both easier for the user and much faster.
</p>
</li>
<li> <p><span class="pkg">lme4</span> offers built-in facilities for likelihood
profiling and parametric bootstrapping.
</p>
</li>
<li> <p><span class="pkg">lme4</span> is designed to be more modular than <span class="pkg">nlme</span>,
making it easier for downstream package developers and end-users
to re-use its components for extensions of the basic mixed model
framework. It also allows more flexibility for specifying
different functions for optimizing over the random-effects
variance-covariance parameters.
</p>
</li>
<li> <p><span class="pkg">lme4</span> is not (yet) as well-documented as <span class="pkg">nlme</span>.
</p>
</li></ul>



<h3>Differences between current (1.0.+) and previous versions of
<span class="pkg">lme4</span></h3>


<ul>
<li> <p><code>[gn]lmer</code> now produces objects of class <code><a href="#topic+merMod-class">merMod</a></code>
rather than class <code>mer</code> as before
</p>
</li>
<li><p> the new version uses a combination of S3 and reference classes
(see <code><a href="methods.html#topic+ReferenceClasses">ReferenceClasses</a></code>, <code><a href="#topic+merPredD-class">merPredD-class</a></code>, and
<code><a href="#topic+lmResp-class">lmResp-class</a></code>) as well as S4 classes; partly for this reason
it is more interoperable with <span class="pkg">nlme</span>
</p>
</li>
<li><p> The internal structure of [gn]lmer is now more modular, allowing
finer control of the different steps of argument checking; construction
of design matrices and data structures; parameter estimation; and construction
of the final <code>merMod</code> object (see <code><a href="#topic+modular">modular</a></code>)
</p>
</li>
<li><p> profiling and parametric bootstrapping are new in
the current version
</p>
</li>
<li><p> the new version of <span class="pkg">lme4</span> does <em>not</em> provide
an <code>mcmcsamp</code> (post-hoc MCMC sampling) method, because this
was deemed to be unreliable.  Alternatives for computing p-values
include parametric bootstrapping (<code><a href="#topic+bootMer">bootMer</a></code>) or methods
implemented in the <span class="pkg">pbkrtest</span> package and leveraged by the
<span class="pkg">lmerTest</span> package and the <code>Anova</code> function in the <span class="pkg">car</span> package
(see <code><a href="#topic+pvalues">pvalues</a></code> for more details).
</p>
</li></ul>



<h3>Caveats and trouble-shooting</h3>


<ul>
<li><p> Some users who have previously installed versions of the
RcppEigen and minqa packages may encounter segmentation faults (!!);
the solution is to make sure to re-install these packages before
installing <span class="pkg">lme4</span>.  (Because the problem is not with the
explicit <em>version</em> of the packages, but with running
packages that were built with different versions of <span class="pkg">Rcpp</span>
in conjunction with each other, simply making sure you have
the latest version, or using <code>update.packages</code>, will
not necessarily solve the problem; you must actually re-install
the packages. The problem is most likely with <span class="pkg">minqa</span>.)
</p>
</li></ul>


<hr>
<h2 id='allFit'>Refit a fitted model with all available optimizers</h2><span id='topic+allFit'></span>

<h3>Description</h3>

<p>Attempt to re-fit a [g]lmer model with a range of optimizers.
The default is to use all known optimizers for R that satisfy the
requirements (i.e. they do not require functions and allow
box constraints: see &lsquo;optimizer&rsquo; in <code><a href="#topic+lmerControl">lmerControl</a></code>).
These optimizers fall in four categories; (i) built-in
(minqa::bobyqa, lme4::Nelder_Mead, nlminbwrap), (ii) wrapped via optimx
(most of optimx's optimizers that allow box constraints require
an explicit gradient function to be specified; the two provided
here are the base R functions that can be accessed via optimx),
(iii) wrapped via nloptr (see examples for the list of options),
(iv) &lsquo;dfoptim::nmkb&rsquo; (via the (unexported) <code>nmkbw</code> wrapper:
this appears as &lsquo;nmkbw&rsquo; in <code>meth.tab</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allFit(object, meth.tab = NULL, data=NULL,
       verbose = TRUE,
       show.meth.tab = FALSE,
       maxfun = 1e5,
       parallel = c("no", "multicore", "snow"),
       ncpus = getOption("allFit.ncpus", 1L), cl = NULL,
       catch.errs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allFit_+3A_object">object</code></td>
<td>
<p>a fitted model</p>
</td></tr>
<tr><td><code id="allFit_+3A_meth.tab">meth.tab</code></td>
<td>
<p>a matrix (or data.frame) with columns
</p>

<dl>
<dt>method</dt><dd><p>the name of a specific optimization method to pass
to the optimizer (leave blank for built-in optimizers)</p>
</dd>
<dt>optimizer</dt><dd><p>the <code>optimizer</code> function to use</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="allFit_+3A_data">data</code></td>
<td>
<p>data to be included with result (for later debugging etc.)</p>
</td></tr>
<tr><td><code id="allFit_+3A_verbose">verbose</code></td>
<td>
<p>logical: report progress in detail?</p>
</td></tr>
<tr><td><code id="allFit_+3A_show.meth.tab">show.meth.tab</code></td>
<td>
<p>logical: return table of methods?</p>
</td></tr>
<tr><td><code id="allFit_+3A_maxfun">maxfun</code></td>
<td>
<p>passed as part of <code>optCtrl</code> to set the maximum
number of function evaluations: this is <em>automatically</em>
converted to the correct specification (e.g. <code>maxfun</code>,
<code>maxfeval</code>, <code>maxit</code>, etc.) for each optimizer</p>
</td></tr>
<tr><td><code id="allFit_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any).
If missing, the
default is taken from the option <code>"boot.parallel"</code> (and if that
is not set, <code>"no"</code>).</p>
</td></tr>
<tr><td><code id="allFit_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation:
typically one would choose this to be the number of available CPUs.
Use <code>options(allFit.ncpus=X)</code> to set the default value to <code>X</code>
for the duration of an R session.</p>
</td></tr>
<tr><td><code id="allFit_+3A_cl">cl</code></td>
<td>
<p>An optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use if
<code>parallel = "snow"</code>.  If not supplied, a cluster on the
local machine is created for the duration of the <code>boot</code> call.</p>
</td></tr>
<tr><td><code id="allFit_+3A_catch.errs">catch.errs</code></td>
<td>
<p>(logical) Wrap model fits in <code>tryCatch</code> clause
to skip over errors? (<code>catch.errs=FALSE</code> is probably only
useful for debugging)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Needs packages <code>optimx</code>, and <code>dfoptim</code> to use all optimizers
</p>
</li>
<li><p> If you are using <code>parallel="snow"</code> (e.g. when running in
parallel on Windows), you will need to set up a cluster yourself and run
<code>clusterEvalQ(cl,library("lme4"))</code> before calling
<code>allFit</code> to make sure that the
<code>lme4</code> package is loaded on all of the workers
</p>
</li>
<li><p> Control arguments in <code>control$optCtrl</code> that are unused by a particular optimizer will be <em>silently</em> ignored (in particular, the <code>maxfun</code> specification is only respected by <code>bobyqa</code>, <code>Nelder_Mead</code>, and <code>nmkbw</code>)
</p>
</li>
<li><p> Because <code>allFit</code> works by calling <code>update</code>, it may be fragile if the original model call contains references to variables, especially if they were originally defined in other environments or no longer exist when <code>allFit</code> is called.
</p>
</li></ul>



<h3>Value</h3>

<p>an object of type <code>allFit</code>, which is a list of fitted <code>merMod</code> objects (unless <code>show.meth.tab</code> is
specified, in which case a data frame of methods is returned). The
<code>summary</code> method for this class
extracts tables with a variety of useful information
about the different fits (see examples).
</p>


<h3>See Also</h3>

<p><code>slice</code>,<code>slice2D</code> from the <a href="https://CRAN.R-project.org/package=bbmle"><span class="pkg">bbmle</span></a> package</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
library(lme4)
  gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
             data = cbpp, family = binomial)
  ## show available methods
  allFit(show.meth.tab=TRUE) 
  gm_all &lt;- allFit(gm1)
  ss &lt;- summary(gm_all)
  ss$which.OK            ## logical vector: which optimizers worked?
  ## the other components only contain values for the optimizers that worked
  ss$llik                ## vector of log-likelihoods
  ss$fixef               ## table of fixed effects
  ss$sdcor               ## table of random effect SDs and correlations
  ss$theta               ## table of random effects parameters, Cholesky scale
} 
## Not run: 
  ## Parallel examples for Windows
  nc &lt;- detectCores()-1
  optCls &lt;- makeCluster(nc, type = "SOCK")
  clusterEvalQ(optCls,library("lme4"))
  ### not necessary here because using a built-in
  ## data set, but in general you should clusterExport() your data
  clusterExport(optCls, "cbpp")
  system.time(af1 &lt;- allFit(m0, parallel = 'snow', 
                          ncpus = nc, cl=optCls))
  stopCluster(optCls)

## End(Not run) 
</code></pre>

<hr>
<h2 id='Arabidopsis'>
Arabidopsis clipping/fertilization data
</h2><span id='topic+Arabidopsis'></span>

<h3>Description</h3>

<p>Data on genetic variation in responses to fertilization
and simulated herbivory in <em>Arabidopsis</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Arabidopsis")</code></pre>


<h3>Format</h3>

<p>A data frame with 625 observations on the following 8 variables.
</p>

<dl>
<dt><code>reg</code></dt><dd><p>region: a factor with 3 levels <code>NL</code>
(Netherlands), <code>SP</code> (Spain), <code>SW</code> (Sweden)</p>
</dd>
<dt><code>popu</code></dt><dd><p>population: a factor with the form <code>n.R</code>
representing a population in region <code>R</code></p>
</dd>
<dt><code>gen</code></dt><dd><p>genotype: a factor with 24 (numeric-valued) levels</p>
</dd>
<dt><code>rack</code></dt><dd><p>a nuisance factor with 2 levels, one for
each of two greenhouse racks</p>
</dd>
<dt><code>nutrient</code></dt><dd><p>fertilization treatment/nutrient level (1,
minimal nutrients or 8, added nutrients)</p>
</dd>
<dt><code>amd</code></dt><dd><p>simulated herbivory or &quot;clipping&quot; (apical meristem
damage): <code>unclipped</code> (baseline) or <code>clipped</code></p>
</dd>
<dt><code>status</code></dt><dd><p>a nuisance factor for germination method
(<code>Normal</code>, <code>Petri.Plate</code>, or <code>Transplant</code>)</p>
</dd>
<dt><code>total.fruits</code></dt><dd><p>total fruit set per plant (integer)</p>
</dd>
</dl>



<h3>Source</h3>

<p>From Josh Banta
</p>


<h3>References</h3>

<p>Joshua A. Banta, Martin H. H Stevens, and Massimo Pigliucci (2010)
A comprehensive test of the 'limiting resources' framework applied to
plant tolerance to apical meristem damage.
<em>Oikos</em> <b>119</b>(2), 359&ndash;369;
<a href="https://doi.org/10.1111/j.1600-0706.2009.17726.x">doi:10.1111/j.1600-0706.2009.17726.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Arabidopsis)
summary(Arabidopsis[,"total.fruits"])
table(gsub("[0-9].","",levels(Arabidopsis[,"popu"])))
library(lattice)
stripplot(log(total.fruits+1) ~ amd|nutrient, data = Arabidopsis,
          groups = gen,
          strip=strip.custom(strip.names=c(TRUE,TRUE)),
          type=c('p','a'), ## points and panel-average value --
          ## see ?panel.xyplot
          scales=list(x=list(rot=90)),
          main="Panel: nutrient, Color: genotype")
</code></pre>

<hr>
<h2 id='bootMer'>Model-based (Semi-)Parametric Bootstrap for Mixed Models</h2><span id='topic+bootMer'></span>

<h3>Description</h3>

<p>Perform model-based (Semi-)parametric bootstrap for mixed
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootMer(x, FUN, nsim = 1, seed = NULL, use.u = FALSE, re.form=NA,
	type = c("parametric", "semiparametric"),
	verbose = FALSE, .progress = "none", PBargs = list(),
	parallel = c("no", "multicore", "snow"),
	ncpus = getOption("boot.ncpus", 1L), cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootMer_+3A_x">x</code></td>
<td>
<p>a fitted <code>merMod</code> object: see
<code><a href="#topic+lmer">lmer</a></code>, <code><a href="#topic+glmer">glmer</a></code>, etc.</p>
</td></tr>
<tr><td><code id="bootMer_+3A_fun">FUN</code></td>
<td>
<p>a function taking a fitted
<code>merMod</code> object as input and returning the
<em>statistic</em> of interest, which must be a (possibly named)
numeric vector.</p>
</td></tr>
<tr><td><code id="bootMer_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations, positive integer; the
bootstrap <code class="reqn">B</code> (or <code class="reqn">R</code>).</p>
</td></tr>
<tr><td><code id="bootMer_+3A_seed">seed</code></td>
<td>
<p>optional argument to <code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="bootMer_+3A_use.u">use.u</code></td>
<td>
<p>logical, indicating whether the spherical
random effects should be simulated / bootstrapped as
well.  If <code>TRUE</code>, they are not changed, and all
inference is conditional on these values. If
<code>FALSE</code>, new normal deviates are drawn (see
Details).</p>
</td></tr>
<tr><td><code id="bootMer_+3A_re.form">re.form</code></td>
<td>
<p>formula, <code>NA</code> (equivalent to <code>use.u=FALSE</code>),
or <code>NULL</code> (equivalent to <code>use.u=TRUE</code>):
alternative to <code>use.u</code> for
specifying which random effects to incorporate.
See <code><a href="#topic+simulate.merMod">simulate.merMod</a></code> for details.</p>
</td></tr>
<tr><td><code id="bootMer_+3A_type">type</code></td>
<td>
<p>character string specifying the type of
bootstrap, <code>"parametric"</code> or
<code>"semiparametric"</code>; partial matching is allowed.</p>
</td></tr>
<tr><td><code id="bootMer_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if progress should
print output</p>
</td></tr>
<tr><td><code id="bootMer_+3A_.progress">.progress</code></td>
<td>
<p>character string - type of progress bar
to display.  Default is <code>"none"</code>; the function will
look for a relevant <code>*ProgressBar</code> function, so
<code>"txt"</code> will work in general; <code>"tk"</code> is
available if the <span class="pkg">tcltk</span> package is loaded; or
<code>"win"</code> on Windows systems. Progress bars are
disabled (with a message) for parallel operation.</p>
</td></tr>
<tr><td><code id="bootMer_+3A_pbargs">PBargs</code></td>
<td>
<p>a list of additional arguments to the
progress bar function (the package authors like
<code>list(style=3)</code>).</p>
</td></tr>
<tr><td><code id="bootMer_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any).
If missing, the
default is taken from the option <code>"boot.parallel"</code> (and if that
is not set, <code>"no"</code>).</p>
</td></tr>
<tr><td><code id="bootMer_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation:
typically one would choose this to be the number of available CPUs.</p>
</td></tr>
<tr><td><code id="bootMer_+3A_cl">cl</code></td>
<td>
<p>An optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use if
<code>parallel = "snow"</code>.  If not supplied, a cluster on the
local machine is created for the duration of the <code>boot</code> call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The semi-parametric variant is only partially implemented, and
we only provide a method for <code><a href="#topic+lmer">lmer</a></code> and
<code><a href="#topic+glmer">glmer</a></code> results.
</p>
<p>Information about warning and error messages incurred during the
bootstrap returns can be retrieved via the attributes
</p>

<dl>
<dt>bootFail</dt><dd><p>number of failures (errors)</p>
</dd>
<dt>boot.fail.msgs</dt><dd><p>error messages</p>
</dd>
<dt>boot.all.msgs</dt><dd><p>messages, warnings, and error messages</p>
</dd>
</dl>

<p>e.g. <code>attr("boot.fail.msgs")</code> to retrieve error messages
</p>
<p>The working name for bootMer() was
&ldquo;simulestimate()&rdquo;, as it is an extension of <code>simulate</code>
(see <a href="#topic+simulate.merMod">simulate.merMod</a>), but we want to emphasize its potential
for valid inference.
</p>

<ul>
<li><p> If <code>use.u</code> is <code>FALSE</code> and <code>type</code> is
<code>"parametric"</code>, each simulation generates new values of both
the &ldquo;<em>spherical</em>&rdquo; random effects <code class="reqn">u</code> and the
i.i.d. errors <code class="reqn">\epsilon</code>, using <code><a href="stats.html#topic+rnorm">rnorm</a>()</code>
with parameters corresponding to the fitted model <code>x</code>.
</p>
</li>
<li><p> If <code>use.u</code> is <code>TRUE</code> and <code>type=="parametric"</code>,
only the i.i.d. errors (or, for GLMMs, response values drawn from
the appropriate distributions) are resampled, with the values of
<code class="reqn">u</code> staying fixed at their estimated values.
</p>
</li>
<li><p> If <code>use.u</code> is <code>TRUE</code> and <code>type=="semiparametric"</code>,
the i.i.d. errors are sampled from the distribution of (response)
residuals.  (For GLMMs, the resulting
sample will no longer have the same properties as the original
sample, and the method may not make sense; a warning is generated.)
The semiparametric bootstrap is currently an experimental feature,
and therefore may not be stable.
</p>
</li>
<li><p> The case where <code>use.u</code> is <code>FALSE</code> and
<code>type=="semiparametric"</code> is not implemented; Morris (2002)
suggests that resampling from the estimated values of <code class="reqn">u</code> is not
good practice.
</p>
</li></ul>
 


<h3>Value</h3>

<p>an object of S3 <code><a href="base.html#topic+class">class</a></code> <code>"boot"</code>,
compatible with <a href="https://CRAN.R-project.org/package=boot"><span class="pkg">boot</span></a> package's
<code><a href="boot.html#topic+boot">boot</a>()</code> result. (See Details for information on how
to retrieve information about errors during bootstrapping.)
</p>


<h3>Note</h3>

<p>If you are using <code>parallel="snow"</code>, you will need to run
<code>clusterEvalQ(cl,library("lme4"))</code> before calling
<code>bootMer</code> to make sure that the
<code>lme4</code> package is loaded on all of the workers; you may
additionally need to use <code><a href="parallel.html#topic+clusterExport">clusterExport</a></code>
if you are using a summary function that calls any objects
from the environment.
</p>


<h3>References</h3>

<p>Davison, A.C. and Hinkley, D.V. (1997)
<em>Bootstrap Methods and Their Application</em>.
Cambridge University Press.
</p>
<p>Morris, J. S. (2002).
The BLUPs Are Not &lsquo;best&rsquo; When It Comes to Bootstrapping.
<em>Statistics &amp; Probability Letters</em> <b>56</b>(4): 425&ndash;430.
doi:10.1016/S0167-7152(02)00041-X.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+confint.merMod">confint.merMod</a></code>,
for a more specific approach to bootstrap confidence
intervals on parameters.
</p>
</li>
<li> <p><code><a href="#topic+refit">refit</a>()</code>, or <code><a href="pbkrtest.html#topic+PBmodcomp">PBmodcomp</a>()</code>
from the <a href="https://CRAN.R-project.org/package=pbkrtest"><span class="pkg">pbkrtest</span></a> package, for parametric bootstrap comparison
of models.
</p>
</li>
<li> <p><code><a href="boot.html#topic+boot">boot</a>()</code>, and then
<code><a href="boot.html#topic+boot.ci">boot.ci</a></code>, from the <span class="pkg">boot</span> package.
</p>
</li>
<li> <p><code><a href="#topic+profile-methods">profile-methods</a></code>, for likelihood-based inference,
including confidence intervals.
</p>
</li>
<li> <p><code><a href="#topic+pvalues">pvalues</a></code>,
for more general approaches to inference and p-value computation
in mixed models.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
fm01ML &lt;- lmer(Yield ~ 1|Batch, Dyestuff, REML = FALSE)
## see ?"profile-methods"
mySumm &lt;- function(.) { s &lt;- sigma(.)
    c(beta =getME(., "beta"), sigma = s, sig01 = unname(s * getME(., "theta"))) }
(t0 &lt;- mySumm(fm01ML)) # just three parameters
## alternatively:
mySumm2 &lt;- function(.) {
    c(beta=fixef(.),sigma=sigma(.), sig01=sqrt(unlist(VarCorr(.))))
}

set.seed(101)
## 3.8s (on a 5600 MIPS 64bit fast(year 2009) desktop "AMD Phenom(tm) II X4 925"):
system.time( boo01 &lt;- bootMer(fm01ML, mySumm, nsim = 100) )

## to "look" at it
if (requireNamespace("boot")) {
    boo01
    ## note large estimated bias for sig01
    ## (~30% low, decreases _slightly_ for nsim = 1000)

    ## extract the bootstrapped values as a data frame ...
    head(as.data.frame(boo01))

    ## ------ Bootstrap-based confidence intervals ------------

    ## warnings about "Some ... intervals may be unstable" go away
    ##   for larger bootstrap samples, e.g. nsim=500

    ## intercept
    (bCI.1 &lt;- boot::boot.ci(boo01, index=1, type=c("norm", "basic", "perc")))# beta

    ## Residual standard deviation - original scale:
    (bCI.2  &lt;- boot::boot.ci(boo01, index=2, type=c("norm", "basic", "perc")))
    ## Residual SD - transform to log scale:
    (bCI.2L &lt;- boot::boot.ci(boo01, index=2, type=c("norm", "basic", "perc"),
                       h = log, hdot = function(.) 1/., hinv = exp))

    ## Among-batch variance:
    (bCI.3 &lt;- boot::boot.ci(boo01, index=3, type=c("norm", "basic", "perc"))) # sig01

    
    confint(boo01)
    confint(boo01,type="norm")
    confint(boo01,type="basic")

    ## Graphical examination:
    plot(boo01,index=3)

    ## Check stored values from a longer (1000-replicate) run:
    (load(system.file("testdata","boo01L.RData", package="lme4")))# "boo01L"
    plot(boo01L, index=3)
    mean(boo01L$t[,"sig01"]==0) ## note point mass at zero!
} 
} 
</code></pre>

<hr>
<h2 id='cake'>Breakage Angle of Chocolate Cakes</h2><span id='topic+cake'></span>

<h3>Description</h3>

<p>Data on the breakage angle of chocolate cakes made with
three different recipes and baked at six different
temperatures.  This is a split-plot design with the
recipes being whole-units and the different temperatures
being applied to sub-units (within replicates). The
experimental notes suggest that the replicate numbering
represents temporal ordering.
</p>


<h3>Format</h3>

<p>A data frame with 270 observations on the following 5 variables.
</p>

<dl>
<dt><code>replicate</code></dt><dd><p>a factor with levels <code>1</code> to <code>15</code></p>
</dd>
<dt><code>recipe</code></dt><dd><p>a factor with levels <code>A</code>, <code>B</code> and <code>C</code></p>
</dd>
<dt><code>temperature</code></dt><dd><p>an ordered factor with levels <code>175</code>
&lt; <code>185</code> &lt; <code>195</code> &lt; <code>205</code> &lt; <code>215</code> &lt; <code>225</code></p>
</dd>
<dt><code>angle</code></dt><dd><p>a numeric vector giving the angle at which the
cake broke.</p>
</dd>
<dt><code>temp</code></dt><dd><p>numeric value of the baking temperature (degrees F).</p>
</dd>
</dl>


<h3>Details</h3>

<p>The <code>replicate</code> factor is nested within the
<code>recipe</code> factor, and <code>temperature</code> is nested
within <code>replicate</code>.
</p>


<h3>Source</h3>

<p>Original data were presented in Cook (1938), and reported
in Cochran and Cox (1957, p. 300).  Also cited in Lee,
Nelder and Pawitan (2006).
</p>


<h3>References</h3>

<p>Cook, F. E. (1938) <em>Chocolate cake, I. Optimum
baking temperature</em>. Master's Thesis, Iowa State College.
</p>
<p>Cochran, W. G., and Cox, G. M. (1957) <em>Experimental
designs</em>, 2nd Ed.  New York, John Wiley &amp; Sons.
</p>
<p>Lee, Y., Nelder, J. A., and Pawitan, Y. (2006)
<em>Generalized linear models with random effects.
Unified analysis via H-likelihood</em>. Boca Raton, Chapman
and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(cake)
## 'temp' is continuous, 'temperature' an ordered factor with 6 levels

(fm1 &lt;- lmer(angle ~ recipe * temperature + (1|recipe:replicate), cake, REML= FALSE))
(fm2 &lt;- lmer(angle ~ recipe + temperature + (1|recipe:replicate), cake, REML= FALSE))
(fm3 &lt;- lmer(angle ~ recipe + temp        + (1|recipe:replicate), cake, REML= FALSE))

## and now "choose" :
anova(fm3, fm2, fm1)
</code></pre>

<hr>
<h2 id='cbpp'>Contagious bovine pleuropneumonia</h2><span id='topic+cbpp'></span>

<h3>Description</h3>

<p>Contagious bovine pleuropneumonia (CBPP) is a major
disease of cattle in Africa, caused by a mycoplasma.
This dataset describes the serological incidence of CBPP
in zebu cattle during a follow-up survey implemented in
15 commercial herds located in the Boji district of
Ethiopia.  The goal of the survey was to study the
within-herd spread of CBPP in newly infected herds. Blood
samples were quarterly collected from all animals of
these herds to determine their CBPP status.  These data
were used to compute the serological incidence of CBPP
(new cases occurring during a given time period).  Some
data are missing (lost to follow-up).
</p>


<h3>Format</h3>

<p>A data frame with 56 observations on the following 4 variables.
</p>

<dl>
<dt><code>herd</code></dt><dd><p>A factor identifying the herd (1 to 15).</p>
</dd>
<dt><code>incidence</code></dt><dd><p>The number of new serological cases for a
given herd and time period.</p>
</dd>
<dt><code>size</code></dt><dd><p>A numeric vector describing herd size at the
beginning of a given time period.</p>
</dd>
<dt><code>period</code></dt><dd><p>A factor with levels <code>1</code> to <code>4</code>.</p>
</dd>
</dl>


<h3>Details</h3>

<p>Serological status was determined using a competitive
enzyme-linked immuno-sorbent assay (cELISA).
</p>


<h3>Source</h3>

<p>Lesnoff, M., Laval, G., Bonnet, P., Abdicho, S.,
Workalemahu, A., Kifle, D., Peyraud, A., Lancelot, R.,
Thiaucourt, F. (2004) Within-herd spread of contagious
bovine pleuropneumonia in Ethiopian highlands.
<em>Preventive Veterinary Medicine</em> <b>64</b>, 27&ndash;40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## response as a matrix
(m1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
             family = binomial, data = cbpp))
## response as a vector of probabilities and usage of argument "weights"
m1p &lt;- glmer(incidence / size ~ period + (1 | herd), weights = size,
             family = binomial, data = cbpp)
## Confirm that these are equivalent:
stopifnot(all.equal(fixef(m1), fixef(m1p), tolerance = 1e-5),
          all.equal(ranef(m1), ranef(m1p), tolerance = 1e-5))

## GLMM with individual-level variability (accounting for overdispersion)
cbpp$obs &lt;- 1:nrow(cbpp)
(m2 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd) +  (1|obs),
              family = binomial, data = cbpp))
</code></pre>

<hr>
<h2 id='checkConv'>
Extended Convergence Checking
</h2><span id='topic+checkConv'></span>

<h3>Description</h3>

<p>Primarily internal code for checking optimization convergence,
see <a href="#topic+convergence">convergence</a> for a more detailed discussion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkConv(derivs, coefs, ctrl, lbound, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkConv_+3A_derivs">derivs</code></td>
<td>
<p>typically the &quot;derivs&quot; attribute of <code>optimizeLmer()</code>; with
&quot;gradients&quot; and possibly &quot;Hessian&quot; component</p>
</td></tr>
<tr><td><code id="checkConv_+3A_coefs">coefs</code></td>
<td>
<p> current coefficient estimates</p>
</td></tr>
<tr><td><code id="checkConv_+3A_ctrl">ctrl</code></td>
<td>
<p>list of lists, each with <code>action</code> character strings specifying
what should happen when a check triggers, and <code>tol</code> numerical tolerances,
as is the result of <code><a href="#topic+lmerControl">lmerControl</a>()$checkConv</code>.</p>
</td></tr>
<tr><td><code id="checkConv_+3A_lbound">lbound</code></td>
<td>
<p>vector of lower bounds <em>for random-effects parameters only</em>
(length is taken to determine number of RE parameters)</p>
</td></tr>
<tr><td><code id="checkConv_+3A_debug">debug</code></td>
<td>
<p>enable debugging output, useful if some checks are on 
&quot;ignore&quot;, but would &quot;trigger&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A result list containing
</p>
<table role = "presentation">
<tr><td><code>code</code></td>
<td>
<p>The return code for the check</p>
</td></tr>
<tr><td><code>messages</code></td>
<td>
<p>A character vector of warnings and messages generated by the check</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+convergence">convergence</a></code>
</p>

<hr>
<h2 id='confint.merMod'>Compute Confidence Intervals for Parameters of a [ng]lmer Fit</h2><span id='topic+confint.merMod'></span><span id='topic+confint.thpr'></span>

<h3>Description</h3>

<p>Compute confidence intervals on the parameters of a <code>*lmer()</code>
model fit (of class<code>"<a href="#topic+merMod-class">merMod</a>"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
confint(object, parm, level = 0.95,
	method = c("profile", "Wald", "boot"), zeta,
	nsim = 500,
        boot.type = c("perc","basic","norm"),
        FUN = NULL, quiet = FALSE,
	oldNames = TRUE, ...)
## S3 method for class 'thpr'
confint(object, parm, level = 0.95,
        zeta, non.mono.tol=1e-2,
	...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.merMod_+3A_object">object</code></td>
<td>
<p>a fitted [ng]lmer model or profile</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_parm">parm</code></td>
<td>
<p>parameters for which intervals are sought. Specified by an
integer vector of positions, <code><a href="base.html#topic+character">character</a></code> vector of
parameter names, or (unless doing parametric bootstrapping with a
user-specified bootstrap function) <code>"theta_"</code> or <code>"beta_"</code>
to specify variance-covariance or fixed effects parameters only: see the
<code>which</code> parameter of <code><a href="#topic+profile.merMod">profile</a></code>.</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_level">level</code></td>
<td>
<p>confidence level <code class="reqn">&lt; 1</code>, typically above 0.90.</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_method">method</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string determining the method
for computing the confidence intervals.</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_zeta">zeta</code></td>
<td>
<p>(for <code>method = "profile"</code> only:) likelihood cutoff
(if not specified, as by default, computed from <code>level</code>).</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations for parametric bootstrap intervals.</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_fun">FUN</code></td>
<td>
<p>bootstrap function; if <code>NULL</code>, an internal function
that returns the fixed-effect parameters as well as the
random-effect parameters on the standard deviation/correlation scale
will be used. See <code><a href="#topic+bootMer">bootMer</a></code> for details.</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_boot.type">boot.type</code></td>
<td>
<p>bootstrap confidence interval type, as described
in <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>. (Methods &lsquo;stud&rsquo; and &lsquo;bca&rsquo;
are unavailable because they require additional components to be
calculated.)</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_quiet">quiet</code></td>
<td>
<p>(logical) suppress messages about computationally intensive profiling?</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_oldnames">oldNames</code></td>
<td>
<p>(logical) use old-style names for variance-covariance
parameters, e.g. <code>".sig01"</code>, rather than newer (more informative) names such as
<code>"sd_(Intercept)|Subject"</code>? (See <code>signames</code> argument to
<code><a href="stats.html#topic+profile">profile</a></code>).</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_non.mono.tol">non.mono.tol</code></td>
<td>
<p>tolerance for detecting a non-monotonic profile
and warning/falling back to linear interpolation</p>
</td></tr>
<tr><td><code id="confint.merMod_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to
<code><a href="#topic+profile.merMod">profile.merMod</a></code> or <code><a href="#topic+bootMer">bootMer</a></code>, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the <code>method</code> specified, <code>confint()</code> computes
confidence intervals by
</p>

<dl>
<dt><code>"profile"</code>:</dt><dd><p>computing a
likelihood profile and finding the appropriate cutoffs
based on the likelihood ratio test;</p>
</dd>
<dt><code>"Wald"</code>:</dt><dd><p>approximating
the confidence intervals (of fixed-effect parameters
only; all variance-covariance parameters
CIs will be returned as <code>NA</code>)
based on the estimated local curvature of the
likelihood surface;</p>
</dd>
<dt><code>"boot"</code>:</dt><dd><p>performing parametric
bootstrapping with confidence intervals computed from the
bootstrap distribution according to <code>boot.type</code> (see
<code><a href="#topic+bootMer">bootMer</a></code>, <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>).</p>
</dd>
</dl>



<h3>Value</h3>

<p>a numeric table (<code><a href="base.html#topic+matrix">matrix</a></code> with column and row names) of
confidence intervals; the confidence intervals are computed on the
standard deviation scale.
</p>


<h3>Note</h3>

<p>The default method <code>"profile"</code> amounts to </p>
<pre>
    confint(profile(object, which=parm, signames=oldNames, ...),
            level, zeta)</pre>
<p>where the <code><a href="stats.html#topic+profile">profile</a></code> method <code><a href="#topic+profile.merMod">profile.merMod</a></code>
does almost all the computations.  Therefore it is typically
advisable to store the <a href="#topic+profile.merMod">profile(.)</a> result, say
in <code>pp</code>, and then use <code>confint(pp, level=*)</code> e.g., for
different levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() || lme4_testlevel() &gt;= 3) {
fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
fm1W &lt;- confint(fm1, method="Wald")# very fast, but not useful for "sigmas" = var-cov pars
fm1W
(fm2 &lt;- lmer(Reaction ~ Days + (Days || Subject), sleepstudy))
(CI2 &lt;- confint(fm2, maxpts = 8)) # method = "profile"; 8: to be much faster

if (lme4_testlevel() &gt;= 3) {
  system.time(fm1P &lt;- confint(fm1, method="profile", ## &lt;- default
                              oldNames = FALSE))
  ## --&gt; ~ 2.2 seconds (2022)
  set.seed(123) # (reproducibility when using bootstrap)
  system.time(fm1B &lt;- confint(fm1, method="boot", oldNames=FALSE,
                              .progress="txt", PBargs= list(style=3)))
  ## --&gt; ~ 6.2 seconds (2022) and warning, messages
} else {
    load(system.file("testdata","confint_ex.rda",package="lme4"))
}
fm1P
fm1B
} ## if interactive &amp;&amp; testlevel&gt;=3
</code></pre>

<hr>
<h2 id='convergence'>Assessing Convergence for Fitted Models</h2><span id='topic+convergence'></span>

<h3>Description</h3>

<p><code>[g]lmer</code> fits may produce convergence warnings;
these do <strong>not</strong> necessarily mean the fit is incorrect (see
&ldquo;Theoretical details&rdquo; below). The following steps are recommended
assessing and resolving convergence warnings
(also see examples below):
</p>

<ul>
<li><p> double-check the model specification and the data
</p>
</li>
<li><p> adjust stopping (convergence) tolerances for the nonlinear optimizer,
using the <code>optCtrl</code> argument to <code>[g]lmerControl</code>
(see &ldquo;Convergence controls&rdquo; below)
</p>
</li>
<li><p> center and scale continuous predictor variables (e.g. with <code><a href="base.html#topic+scale">scale</a></code>)
</p>
</li>
<li><p> double-check the Hessian calculation with the more expensive
Richardson extrapolation method (see examples)
</p>
</li>
<li><p> restart the fit from the reported optimum, or from a point
perturbed slightly away from the reported optimum
</p>
</li>
<li><p> use <code><a href="#topic+allFit">allFit</a></code> to try the fit with all available optimizers (e.g. several different implementations
of BOBYQA and Nelder-Mead, L-BFGS-B from <code>optim</code>, <code>nlminb</code>,
...).  While this will of course be slow for large fits, we consider
it the gold standard; if all optimizers converge to values that
are practically equivalent, then we would consider the convergence
warnings to be false positives.
</p>
</li></ul>
 


<h3>Details</h3>



<h4>Convergence controls</h4>


<ul>
<li><p> the controls for the <code>nloptwrap</code> optimizer (the default
for <code>lmer</code>) are
</p>

<dl>
<dt>ftol_abs</dt><dd><p>(default 1e-6) stop on small change in deviance</p>
</dd>
<dt>ftol_rel</dt><dd><p>(default 0) stop on small relative change in deviance</p>
</dd>
<dt>xtol_abs</dt><dd><p>(default 1e-6) stop on small change of parameter values</p>
</dd>
<dt>xtol_rel</dt><dd><p>(default 0) stop on small relative change of
parameter values</p>
</dd>
<dt>maxeval</dt><dd><p>(default 1000) maximum number of function evaluations</p>
</dd>
</dl>

<p>Changing <code>ftol_abs</code> and <code>xtol_abs</code> to stricter values
(e.g. 1e-8) is a good first step for resolving convergence
problems, at the cost of slowing down model fits.
</p>
</li>
<li><p> the controls for <code>minqa::bobyqa</code> (default for
<code>glmer</code> first-stage optimization) are
</p>

<dl>
<dt>rhobeg</dt><dd><p>(default 2e-3) initial radius of the trust region</p>
</dd>
<dt>rhoend</dt><dd><p>(default 2e-7) final radius of the trust region</p>
</dd>
<dt>maxfun</dt><dd><p>(default 10000) maximum number of function evaluations</p>
</dd>
</dl>

<p><code>rhoend</code>, which describes the scale of parameter uncertainty
on convergence, is approximately analogous to <code>xtol_abs</code>.
</p>
</li>
<li><p> the controls for <code>Nelder_Mead</code> (default for
<code>glmer</code> second-stage optimization) are
</p>

<dl>
<dt>FtolAbs</dt><dd><p>(default 1e-5) stop on small change in deviance</p>
</dd>
<dt>FtolRel</dt><dd><p>(default 1e-15) stop on small relative change in deviance</p>
</dd>
<dt>XtolRel</dt><dd><p>(default 1e-7) stop on small change of parameter
values</p>
</dd>
<dt>maxfun</dt><dd><p>(default 10000) maximum number of function evaluations</p>
</dd>
</dl>
 
</li></ul>
 
 


<h4>Theoretical issues</h4>

<p><span class="pkg">lme4</span> uses general-purpose nonlinear optimizers
(e.g. Nelder-Mead or Powell's BOBYQA method) to estimate the
variance-covariance matrices of the random effects.  Assessing
the convergence of such algorithms reliably is difficult.  For
example, evaluating the
<a href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions">Karush-Kuhn-Tucker conditions</a> (convergence criteria which
reduce in simple cases to showing that
the gradient is zero and the Hessian is positive definite) is
challenging because of the difficulty of evaluating the gradient and
Hessian.
</p>
<p>We (the <code>lme4</code> authors and maintainers) are still in the process
of finding the best strategies for testing convergence.  Some of the
relevant issues are
</p>

<ul>
<li><p> the gradient and Hessian are the basic ingredients of
KKT-style testing, but (at least for now) <code>lme4</code> estimates
them by finite-difference approximations which are sometimes
unreliable.
</p>
</li>
<li><p> The Hessian computation in particular represents
a difficult tradeoff between computational expense and
accuracy.  At present the Hessian computations used
for convergence checking (and for estimating standard errors
of fixed-effect parameters for GLMMs) follow the <a href="https://CRAN.R-project.org/package=ordinal"><span class="pkg">ordinal</span></a> package
in using a naive but computationally cheap centered finite difference
computation (with a fixed step size of <code class="reqn">10^{-4}</code>).  A more
reliable but more expensive approach is to use
<a href="https://en.wikipedia.org/wiki/Richardson_extrapolation">Richardson extrapolation</a>,
as implemented in the <a href="https://CRAN.R-project.org/package=numDeriv"><span class="pkg">numDeriv</span></a> package.
</p>
</li>
<li><p> it is important to scale the estimated gradient at
the estimate appropriately; two reasonable approaches are
</p>

<ol>
<li><p> scale gradients by the inverse Cholesky factor of the
Hessian, equivalent to scaling gradients by the
estimated Wald standard error
of the estimated parameters.  <code>lme4</code> uses this
approach; it requires the Hessian to be estimated (although the Hessian is
required <a href="https://github.com/lme4/lme4/issues/47">for
reliable estimation of the fixed-effect standard errors for GLMMs</a>
in any case).
</p>
</li>
<li><p> use unscaled gradients on the random-effects parameters,
since these are essentially already unitless (for LMMs they are scaled
relative to the residual variance; for GLMMs they are scaled
relative to the sampling variance of the conditional distribution);
for GLMMs, scale fixed-effect gradients by the standard deviations
of the corresponding input variable
</p>
</li></ol>

</li>
<li><p> Exploratory analyses suggest that (1) the naive estimation
of the Hessian may fail for large data sets (number of observations
greater than approximately
<code class="reqn">10^{5}</code>); (2) the magnitude of the scaled
gradient increases with sample size, so that warnings will occur
even for apparently well-behaved fits with large data sets.
</p>
</li></ul>
 
 


<h3>See Also</h3>

<p><code><a href="#topic+lmerControl">lmerControl</a></code>, <code><a href="#topic+isSingular">isSingular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)

## 1. decrease stopping tolerances
strict_tol &lt;- lmerControl(optCtrl=list(xtol_abs=1e-8, ftol_abs=1e-8))
if (all(fm1@optinfo$optimizer=="nloptwrap")) {
    fm1.tol &lt;- update(fm1, control=strict_tol)
}

## 2. center and scale predictors:
ss.CS &lt;- transform(sleepstudy, Days=scale(Days))
fm1.CS &lt;- update(fm1, data=ss.CS)

## 3. recompute gradient and Hessian with Richardson extrapolation
devfun &lt;- update(fm1, devFunOnly=TRUE)
if (isLMM(fm1)) {
    pars &lt;- getME(fm1,"theta")
} else {
    ## GLMM: requires both random and fixed parameters
    pars &lt;- getME(fm1, c("theta","fixef"))
}
if (require("numDeriv")) {
    cat("hess:\n"); print(hess &lt;- hessian(devfun, unlist(pars)))
    cat("grad:\n"); print(grad &lt;- grad(devfun, unlist(pars)))
    cat("scaled gradient:\n")
    print(scgrad &lt;- solve(chol(hess), grad))
}
## compare with internal calculations:
fm1@optinfo$derivs

## compute reciprocal condition number of Hessian
H &lt;- fm1@optinfo$derivs$Hessian
Matrix::rcond(H)

## 4. restart the fit from the original value (or
## a slightly perturbed value):
fm1.restart &lt;- update(fm1, start=pars)
set.seed(101)
pars_x &lt;- runif(length(pars),pars/1.01,pars*1.01)
fm1.restart2 &lt;- update(fm1, start=pars_x,
                       control=strict_tol)

## 5. try all available optimizers

  fm1.all &lt;- allFit(fm1)
  ss &lt;- summary(fm1.all)
  ss$ fixef               ## fixed effects
  ss$ llik                ## log-likelihoods
  ss$ sdcor               ## SDs and correlations
  ss$ theta               ## Cholesky factors
  ss$ which.OK            ## which fits worked

} 
</code></pre>

<hr>
<h2 id='devcomp'>Extract the deviance component list</h2><span id='topic+devcomp'></span>

<h3>Description</h3>

<p>Return the deviance component list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  devcomp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="devcomp_+3A_x">x</code></td>
<td>
<p>a fitted model of class <code><a href="#topic+merMod-class">merMod</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fitted model of class <code><a href="#topic+merMod-class">merMod</a></code> has a
<code>devcomp</code> slot as described in the value section.
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table role = "presentation">
<tr><td><code>dims</code></td>
<td>
<p>a named integer vector of various dimensions</p>
</td></tr>
<tr><td><code>cmp</code></td>
<td>
<p>a named numeric vector of components of the deviance</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is deprecated, use <code><a href="#topic+getME">getME</a>(., "devcomp")</code>

</p>

<hr>
<h2 id='devfun2'>Deviance Function in Terms of Standard Deviations/Correlations</h2><span id='topic+devfun2'></span>

<h3>Description</h3>

<p>The deviance is profiled with respect to the fixed-effects
parameters but not with respect to sigma; that is, the
function takes parameters for the variance-covariance parameters
and for the residual standard deviation.  The random-effects
variance-covariance parameters are on the standard deviation/correlation
scale, not the theta (Cholesky factor) scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>devfun2(fm, useSc = if(isLMM(fm)) TRUE else NA,
        transfuns = list(from.chol = Cv_to_Sv,
                           to.chol = Sv_to_Cv,
                             to.sd = identity), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="devfun2_+3A_fm">fm</code></td>
<td>
<p>a fitted model inheriting from  class <code>"<a href="#topic+merMod-class">merMod</a>"</code>.</p>
</td></tr>
<tr><td><code id="devfun2_+3A_usesc">useSc</code></td>
<td>
<p>(<code><a href="base.html#topic+logical">logical</a></code>) indicating whether a scale parameter
has been in the model or should be used.</p>
</td></tr>
<tr><td><code id="devfun2_+3A_transfuns">transfuns</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of <code><a href="base.html#topic+function">function</a></code>s
for converting parameters to and from the Cholesky-factor scale
</p>
</td></tr>
<tr><td><code id="devfun2_+3A_...">...</code></td>
<td>

<p>arguments passed to the internal <code>profnames</code> function
(<code>signames=TRUE</code> to use old-style <code>.sigxx names</code>,
<code>FALSE</code> uses (sd_cor|xx);
also <code>prefix=c("sd","cor")</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function that takes a vector of standard deviations and
correlations and returns the deviance (or REML criterion).  The
function has additional attributes
</p>

<dl>
<dt>optimum</dt><dd><p>a named vector giving the parameter values
at the optimum</p>
</dd>
<dt>basedev</dt><dd><p>the deviance at the optimum, (i.e., <em>not</em> the
REML criterion).</p>
</dd>
<dt>thopt</dt><dd><p>the optimal variance-covariance parameters on the
&ldquo;theta&rdquo; (Cholesky factor) scale</p>
</dd>
<dt>stderr</dt><dd><p>standard errors of fixed effect parameters</p>
</dd>
</dl>



<h3>Note</h3>

<p>Even if the original model was fitted using <code>REML=TRUE</code> as by default
with <code><a href="#topic+lmer">lmer</a>()</code>, this returns the deviance, i.e., the objective
function for maximum (log) likelihood (ML).
</p>
<p>For the REML objective function, use <code><a href="#topic+getME">getME</a>(fm, "devfun")</code>
instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lmer(Reaction~Days+(Days|Subject),sleepstudy)
dd &lt;- devfun2(m1, useSc=TRUE)
pp &lt;- attr(dd,"optimum")
## extract variance-covariance and residual std dev parameters
sigpars &lt;- pp[grepl("^\\.sig",names(pp))]
all.equal(unname(dd(sigpars)),deviance(refitML(m1)))
</code></pre>

<hr>
<h2 id='drop1.merMod'>Drop all possible single fixed-effect terms from a mixed effect model</h2><span id='topic+drop1.merMod'></span>

<h3>Description</h3>

<p>Drop allowable single terms from the model: see <code><a href="stats.html#topic+drop1">drop1</a></code>
for details of how the appropriate scope for dropping terms
is determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
drop1(object, scope, scale = 0,
      test = c("none", "Chisq", "user"),
      k = 2, trace = FALSE, sumFun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop1.merMod_+3A_object">object</code></td>
<td>
<p>a fitted <code>merMod</code> object.</p>
</td></tr>
<tr><td><code id="drop1.merMod_+3A_scope">scope</code></td>
<td>
<p>a formula giving the terms to be considered for adding or
dropping.</p>
</td></tr>
<tr><td><code id="drop1.merMod_+3A_scale">scale</code></td>
<td>
<p>Currently ignored (included for S3 method compatibility)</p>
</td></tr>
<tr><td><code id="drop1.merMod_+3A_test">test</code></td>
<td>
<p>should the results include a test statistic relative to the
original model?
The <code class="reqn">\chi^2</code> test is a likelihood-ratio test,
which is approximate due to finite-size effects.
</p>
</td></tr>
<tr><td><code id="drop1.merMod_+3A_k">k</code></td>
<td>
<p>the penalty constant in AIC</p>
</td></tr>
<tr><td><code id="drop1.merMod_+3A_trace">trace</code></td>
<td>
<p>print tracing information?</p>
</td></tr>
<tr><td><code id="drop1.merMod_+3A_sumfun">sumFun</code></td>
<td>
<p>a summary <code><a href="base.html#topic+function">function</a></code> to be used when
<code>test=="user"</code>.  It must allow arguments <code>scale</code> and
<code>k</code>, but these may be ignored (e.g. swallowed by <code>...</code>,
see the examples).
The first two arguments must be <code>object</code>, the full model fit,
and <code>objectDrop</code>, a reduced model.  If <code>objectDrop</code> is missing,
<code>sumFun(*)</code> should return a vector with the appropriate
length and names (the actual contents are ignored).
</p>
</td></tr>
<tr><td><code id="drop1.merMod_+3A_...">...</code></td>
<td>
<p>other arguments (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>drop1</code> relies on being able to find the appropriate information
within the environment of the formula of the original model.  If the
formula is created in an environment that does not contain the data,
or other variables passed to the original model (for example, if
a separate function is called to define the formula), then
<code>drop1</code> will fail.  A workaround (see example below) is to
manually specify an appropriate environment for the formula.
</p>


<h3>Value</h3>

<p>An object of class <code>anova</code> summarizing the differences in fit
between the models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
## likelihood ratio tests
drop1(fm1,test="Chisq")
## use Kenward-Roger corrected F test, or parametric bootstrap,
## to test the significance of each dropped predictor
if (require(pbkrtest) &amp;&amp; packageVersion("pbkrtest")&gt;="0.3.8") {
   KRSumFun &lt;- function(object, objectDrop, ...) {
      krnames &lt;- c("ndf","ddf","Fstat","p.value","F.scaling")
      r &lt;- if (missing(objectDrop)) {
          setNames(rep(NA,length(krnames)),krnames)
      } else {
         krtest &lt;- KRmodcomp(object,objectDrop)
         unlist(krtest$stats[krnames])
      }
      attr(r,"method") &lt;- c("Kenward-Roger via pbkrtest package")
      r
   }
   drop1(fm1, test="user", sumFun=KRSumFun)

   if(lme4:::testLevel() &gt;= 3) { ## takes about 16 sec
     nsim &lt;- 100
     PBSumFun &lt;- function(object, objectDrop, ...) {
	pbnames &lt;- c("stat","p.value")
	r &lt;- if (missing(objectDrop)) {
	    setNames(rep(NA,length(pbnames)),pbnames)
	} else {
	   pbtest &lt;- PBmodcomp(object,objectDrop,nsim=nsim)
	   unlist(pbtest$test[2,pbnames])
	}
	attr(r,"method") &lt;- c("Parametric bootstrap via pbkrtest package")
	r
     }
     system.time(drop1(fm1, test="user", sumFun=PBSumFun))
   }
}
## workaround for creating a formula in a separate environment
createFormula &lt;- function(resp, fixed, rand) {  
    f &lt;- reformulate(c(fixed,rand),response=resp)
    ## use the parent (createModel) environment, not the
    ## environment of this function (which does not contain 'data')
    environment(f) &lt;- parent.frame()
    f
}
createModel &lt;- function(data) {
    mf.final &lt;- createFormula("Reaction", "Days", "(Days|Subject)")
    lmer(mf.final, data=data)
}
drop1(createModel(data=sleepstudy))
</code></pre>

<hr>
<h2 id='dummy'>Dummy variables (experimental)</h2><span id='topic+dummy'></span>

<h3>Description</h3>

<p>Largely a wrapper for <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> that
accepts a factor, <code>f</code>, and returns a dummy
matrix with <code>nlevels(f)-1</code> columns (the first
column is dropped by default).  Useful whenever one wishes to avoid
the behaviour of <code>model.matrix</code> of always returning
an <code>nlevels(f)</code>-column matrix, either by the
addition of an intercept column, or by keeping one
column for all levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dummy(f, levelsToKeep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dummy_+3A_f">f</code></td>
<td>
<p>An object coercible to <code><a href="base.html#topic+factor">factor</a></code>.</p>
</td></tr>
<tr><td><code id="dummy_+3A_levelstokeep">levelsToKeep</code></td>
<td>
<p>An optional character vector giving the subset of
<code>levels(f)</code> to be converted to dummy variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> with dummy variables as columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Orthodont,package="nlme")
lmer(distance ~ age + (age|Subject) +
     (0+dummy(Sex, "Female")|Subject), data = Orthodont)
</code></pre>

<hr>
<h2 id='Dyestuff'>Yield of dyestuff by batch</h2><span id='topic+Dyestuff'></span><span id='topic+Dyestuff2'></span>

<h3>Description</h3>

<p>The <code>Dyestuff</code> data frame provides the yield of
dyestuff (Naphthalene Black 12B) from 5 different
preparations from each of 6 different batchs of an
intermediate product (H-acid).  The <code>Dyestuff2</code> data
were generated data in the same structure but with a
large residual variance relative to the batch variance.
</p>


<h3>Format</h3>

<p>Data frames, each with 30 observations on the following 2 variables.
</p>

<dl>
<dt><code>Batch</code></dt><dd><p>a factor indicating the batch of the
intermediate product from which the preparation was created.</p>
</dd>
<dt><code>Yield</code></dt><dd><p>the yield of dyestuff from the preparation
(grams of standard color).</p>
</dd>
</dl>


<h3>Details</h3>

<p>The <code>Dyestuff</code> data are described in Davies and
Goldsmith (1972) as coming from &ldquo;an investigation
to find out how much the variation from batch to batch in
the quality of an intermediate product (H-acid)
contributes to the variation in the yield of the dyestuff
(Naphthalene Black 12B) made from it.  In the experiment
six samples of the intermediate, representing different
batches of works manufacture, were obtained, and five
preparations of the dyestuff were made in the laboratory
from each sample. The equivalent yield of each
preparation as grams of standard colour was determined by
dye-trial.&rdquo;
</p>
<p>The <code>Dyestuff2</code> data are described in Box and Tiao
(1973) as illustrating &ldquo; the case where
between-batches mean square is less than the
within-batches mean square.  These data had to be
constructed for although examples of this sort
undoubtably occur in practice, they seem to be rarely
published.&rdquo;
</p>


<h3>Source</h3>

<p>O.L. Davies and P.L. Goldsmith (eds), <em>Statistical
Methods in Research and Production, 4th ed.</em>, Oliver and
Boyd, (1972), section 6.4
</p>
<p>G.E.P. Box and G.C. Tiao, <em>Bayesian Inference in
Statistical Analysis</em>, Addison-Wesley, (1973), section
5.1.2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(lattice)
str(Dyestuff)
dotplot(reorder(Batch, Yield) ~ Yield, Dyestuff,
        ylab = "Batch", jitter.y = TRUE, aspect = 0.3,
        type = c("p", "a"))
dotplot(reorder(Batch, Yield) ~ Yield, Dyestuff2,
        ylab = "Batch", jitter.y = TRUE, aspect = 0.3,
        type = c("p", "a"))
(fm1 &lt;- lmer(Yield ~ 1|Batch, Dyestuff))
(fm2 &lt;- lmer(Yield ~ 1|Batch, Dyestuff2))
</code></pre>

<hr>
<h2 id='expandDoubleVerts'>Expand terms with <code>'||'</code> notation into separate <code>'|'</code> terms</h2><span id='topic+expandDoubleVerts'></span><span id='topic++7C+7C'></span>

<h3>Description</h3>

<p>From the right hand side of a formula for a mixed-effects model,
expand terms with the double vertical bar operator
into separate, independent random effect terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expandDoubleVerts(term)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandDoubleVerts_+3A_term">term</code></td>
<td>
<p>a mixed-model formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified term
</p>


<h3>Note</h3>

<p>Because <code>||</code> works at the level of formula parsing, it
has no way of knowing whether a variable is a factor. It
just takes the terms within a random-effects term and literally splits them
into the intercept and separate no-intercept terms,
e.g. <code>(1+x+y|f)</code> would be split into <code>(1|f) + (0+x|f) + (0+y|f)</code>.
However, <code>||</code> will fail to break up factors into separate terms;
the <code><a href="#topic+dummy">dummy</a></code> function can be useful in this case, although
it is not as convenient as <code>||</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+dummy">dummy</a></code>.
</p>
<p>Other utilities: <code><a href="#topic+mkRespMod">mkRespMod</a></code>,
<code><a href="#topic+mkReTrms">mkReTrms</a></code>, <code><a href="#topic+nlformula">nlformula</a></code>,
<code><a href="#topic+nobars">nobars</a></code>, <code><a href="#topic+subbars">subbars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- ~ x + (x || g)
  expandDoubleVerts(m)
  set.seed(101)
  dd &lt;- expand.grid(f=factor(letters[1:3]),g=factor(1:200),rep=1:3)
  dd$y &lt;- simulate(~f + (1|g) + (0+dummy(f,"b")|g) + (0+dummy(f,"c")|g),
          newdata=dd,
          newparams=list(beta=rep(0,3),
                         theta=c(1,2,1),
                         sigma=1),
          family=gaussian)[[1]]
  m1 &lt;- lmer(y~f+(f|g),data=dd)
  VarCorr(m1)
  m2 &lt;- lmer(y~f+(1|g) + (0+dummy(f,"b")|g) + (0+dummy(f,"c")|g),
               data=dd)
  VarCorr(m2)
</code></pre>

<hr>
<h2 id='factorize'>Attempt to convert grouping variables to factors</h2><span id='topic+factorize'></span>

<h3>Description</h3>

<p>If variables within a data frame are not factors, try to
convert them.  Not intended for end-user use; this is
a utility function that needs to be exported, for technical reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorize(x,frloc,char.only=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="factorize_+3A_x">x</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="factorize_+3A_frloc">frloc</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="factorize_+3A_char.only">char.only</code></td>
<td>
<p>(logical) convert only <code>character</code> variables to factors?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a copy of the data frame with factors converted
</p>

<hr>
<h2 id='findbars'>Determine random-effects expressions from a formula</h2><span id='topic+findbars'></span>

<h3>Description</h3>

<p>From the right hand side of a formula for a mixed-effects
model, determine the pairs of expressions that are
separated by the vertical bar operator.  Also expand the
slash operator in grouping factor expressions and expand
terms with the double vertical bar operator into separate,
independent random effect terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  findbars(term)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findbars_+3A_term">term</code></td>
<td>
<p>a mixed-model formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pairs of expressions that were separated by vertical bars
</p>


<h3>Note</h3>

<p>This function is called recursively on individual terms
in the model, which is why the argument is called
<code>term</code> and not a name like <code>form</code>, indicating a
formula.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>
<p>Other utilities: <code><a href="#topic+mkRespMod">mkRespMod</a></code>,
<code><a href="#topic+mkReTrms">mkReTrms</a></code>, <code><a href="#topic+nlformula">nlformula</a></code>,
<code><a href="#topic+nobars">nobars</a></code>, <code><a href="#topic+subbars">subbars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findbars(f1 &lt;- Reaction ~ Days + (Days | Subject))
## =&gt; list( Days | Subject )
## These two are equivalent:% tests in ../inst/tests/test-doubleVertNotation.R
findbars(y ~ Days + (1 | Subject) + (0 + Days | Subject))
findbars(y ~ Days + (Days || Subject))
## =&gt; list of length 2:  list ( 1 | Subject ,  0 + Days | Subject)
findbars(~ 1 + (1 | batch / cask))
## =&gt; list of length 2:  list ( 1 | cask:batch ,  1 | batch)

</code></pre>

<hr>
<h2 id='fixef'>Extract fixed-effects estimates</h2><span id='topic+fixed.effects'></span><span id='topic+fixef'></span><span id='topic+fixef.merMod'></span>

<h3>Description</h3>

<p>Extract the fixed-effects estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'merMod'
 fixef(object, add.dropped=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixef_+3A_object">object</code></td>
<td>
<p>any fitted model object from which fixed
effects estimates can be extracted.</p>
</td></tr>
<tr><td><code id="fixef_+3A_add.dropped">add.dropped</code></td>
<td>
<p>for models with rank-deficient design
matrix, reconstitute the full-length parameter vector by
adding <code>NA</code> values in appropriate locations?</p>
</td></tr>
<tr><td><code id="fixef_+3A_...">...</code></td>
<td>
<p>optional additional arguments. Currently
none are used in any methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract the estimates of the fixed-effects parameters
from a fitted model.
</p>


<h3>Value</h3>

<p>a named, numeric vector of fixed-effects estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fixef(lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy))
fm2 &lt;- lmer(Reaction ~ Days + Days2 + (1|Subject),
            data=transform(sleepstudy,Days2=Days))
fixef(fm2,add.dropped=TRUE)
## first two parameters are the same ...
stopifnot(all.equal(fixef(fm2,add.dropped=TRUE)[1:2],
                    fixef(fm2)))
</code></pre>

<hr>
<h2 id='fortify'>add information to data based on a fitted model</h2><span id='topic+fortify'></span><span id='topic+fortify.merMod'></span><span id='topic+getData'></span><span id='topic+getData.merMod'></span>

<h3>Description</h3>

<p><code>fortify</code> adds information to data based on a fitted model;
<code>getData</code> retrieves data as specified in the <code>data</code>
argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fortify.merMod(model, data = getData(model),
    ...)
## S3 method for class 'merMod'
getData(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fortify_+3A_model">model</code></td>
<td>
<p>fitted model</p>
</td></tr>
<tr><td><code id="fortify_+3A_object">object</code></td>
<td>
<p>fitted model</p>
</td></tr>
<tr><td><code id="fortify_+3A_data">data</code></td>
<td>
<p>original data set, if needed</p>
</td></tr>
<tr><td><code id="fortify_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>fortify</code> is defined in the
<a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> package, q.v. for more details.
<code>fortify</code> is <em>not</em> defined here,
and <code>fortify.merMod</code> is defined as a function
rather than an S3 method, to avoid (1) inducing
a dependency on <span class="pkg">ggplot2</span> or (2) masking
methods from <span class="pkg">ggplot2</span>.
This feature is both experimental and semi-deprecated,
as the help page for <code>fortify</code> itself says:
&ldquo;Rather than using this function, I now recommend using the
<code>broom</code> package, which implements a much wider range of
methods. <code>fortify</code> may be deprecated in the future.&rdquo;
The <code>broom.mixed</code> package is recommended for mixed models
in general.

</p>
</li>
<li>
<p><code>getData</code> is a bare-bones implementation; it relies on
a <code>data</code> argument having been specified and the data being
available in the environment of the formula. Unlike the functions
in the <code>nlme</code> package, it does not do anything special with
<code>na.action</code> or <code>subset</code>.

</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>  fm1 &lt;- lmer(Reaction~Days+(1|Subject),sleepstudy)
  names(fortify.merMod(fm1))
</code></pre>

<hr>
<h2 id='getME'>Extract or Get Generalized Components from a Fitted Mixed Effects Model</h2><span id='topic+getL'></span><span id='topic+getL+2CmerMod-method'></span><span id='topic+getME'></span><span id='topic+getME.merMod'></span>

<h3>Description</h3>

<p>Extract (or &ldquo;get&rdquo;) &ldquo;components&rdquo; &ndash; in a
generalized sense &ndash; from a fitted mixed-effects model,
i.e., (in this version of the package) from an object of
class <code>"<a href="#topic+merMod-class">merMod</a>"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getME(object, name, ...)

## S3 method for class 'merMod'
getME(object,
      name = c("X", "Z", "Zt", "Ztlist", "mmList", "y", "mu", "u", "b",
               "Gp", "Tp", "L", "Lambda", "Lambdat", "Lind", "Tlist",
               "A", "RX", "RZX", "sigma", "flist",
               "fixef", "beta", "theta", "ST", "REML", "is_REML",
               "n_rtrms", "n_rfacs", "N", "n", "p", "q",
               "p_i", "l_i", "q_i", "k", "m_i", "m",
               "cnms", "devcomp", "offset", "lower", "devfun", "glmer.nb.theta"),
      ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getME_+3A_object">object</code></td>
<td>
<p>a fitted mixed-effects model of class
<code>"<a href="#topic+merMod-class">merMod</a>"</code>, i.e., typically the result of
<code><a href="#topic+lmer">lmer</a>()</code>, <code><a href="#topic+glmer">glmer</a>()</code> or <code><a href="#topic+nlmer">nlmer</a>()</code>.</p>
</td></tr>
<tr><td><code id="getME_+3A_name">name</code></td>
<td>
<p>a character vector specifying the name(s) of
the &ldquo;component&rdquo;.  If <code>length(name) &gt; 1</code> or if <code>name
    = "ALL"</code>, a named <code><a href="base.html#topic+list">list</a></code> of components will be returned.  Possible values are:<br />
</p>

<dl>
<dt><code>"X"</code>:</dt><dd><p>fixed-effects model matrix</p>
</dd>
<dt><code>"Z"</code>:</dt><dd><p>random-effects model matrix</p>
</dd>
<dt><code>"Zt"</code>:</dt><dd><p>transpose
of random-effects model matrix.  Note that the structure
of <code>Zt</code> has changed since <code>lme4.0</code>; to get a
backward-compatible structure, use
<code>do.call(Matrix::rBind,getME(.,"Ztlist"))</code></p>
</dd>
<dt><code>"Ztlist"</code>:</dt><dd><p>list of components of the transpose of the
random-effects model matrix, separated by individual
variance component</p>
</dd>
<dt><code>"mmList"</code>:</dt><dd><p>list of raw model matrices associated with random
effects terms</p>
</dd>
<dt><code>"y"</code>:</dt><dd><p>response vector</p>
</dd>
<dt><code>"mu"</code>:</dt><dd><p>conditional mean of the response</p>
</dd>
<dt><code>"u"</code>:</dt><dd><p>conditional mode of the &ldquo;spherical&rdquo;
random effects variable</p>
</dd>
<dt><code>"b"</code>:</dt><dd><p>conditional mode of the
random effects variable</p>
</dd>
<dt><code>"Gp"</code>:</dt><dd><p>groups pointer vector.
A pointer to the beginning of each group of random
effects corresponding to the random-effects terms,
beginning with 0 and including a final element giving the
total number of random effects</p>
</dd>
<dt><code>"Tp"</code>:</dt><dd><p>theta pointer vector.  A pointer to the beginning of the theta
sub-vectors corresponding to the random-effects terms,
beginning with 0 and including a final element giving the
number of thetas.</p>
</dd>
<dt><code>"L"</code>:</dt><dd><p>sparse Cholesky factor of the penalized random-effects model.</p>
</dd>
<dt><code>"Lambda"</code>:</dt><dd><p>relative covariance factor <code class="reqn">\Lambda</code> of the random effects.</p>
</dd>
<dt><code>"Lambdat"</code>:</dt><dd><p>transpose <code class="reqn">\Lambda'</code> of <code class="reqn">\Lambda</code> above.</p>
</dd>
<dt><code>"Lind"</code>:</dt><dd><p>index vector for inserting elements of
<code class="reqn">\theta</code> into the nonzeros of <code class="reqn">\Lambda</code>.</p>
</dd>
<dt><code>"Tlist"</code>:</dt><dd><p>vector of template matrices from which the blocks of
<code class="reqn">\Lambda</code> are generated.</p>
</dd>
<dt><code>"A"</code>:</dt><dd><p>Scaled sparse model matrix (class
<code>"<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>"</code>) for
the unit, orthogonal random effects, <code class="reqn">U</code>, equal to
<code>getME(.,"Zt") %*% getME(.,"Lambdat")</code></p>
</dd>
<dt><code>"RX"</code>:</dt><dd><p>Cholesky factor for the fixed-effects parameters</p>
</dd>
<dt><code>"RZX"</code>:</dt><dd><p>cross-term in the full Cholesky factor</p>
</dd>
<dt><code>"sigma"</code>:</dt><dd><p>residual standard error; note that <code>sigma(object)</code> is preferred.</p>
</dd>
<dt><code>"flist"</code>:</dt><dd><p>a list of the grouping variables (factors)
involved in the random effect terms</p>
</dd>
<dt><code>"fixef"</code>:</dt><dd><p>fixed-effects parameter estimates</p>
</dd>
<dt><code>"beta"</code>:</dt><dd><p>fixed-effects parameter estimates (identical
to the result of <code><a href="#topic+fixef">fixef</a></code>, but without names)</p>
</dd>
<dt><code>"theta"</code>:</dt><dd><p>random-effects parameter estimates: these
are parameterized as the relative Cholesky factors of
each random effect term</p>
</dd>
<dt><code>"ST"</code>:</dt><dd><p>A list of S and T factors in the TSST' Cholesky
factorization of the relative variance matrices of the random
effects associated with each random-effects term.  The unit lower
triangular matrix, <code class="reqn">T</code>, and the diagonal matrix, <code class="reqn">S</code>, for
each term are stored as a single matrix with diagonal elements
from <code class="reqn">S</code> and off-diagonal elements from <code class="reqn">T</code>.</p>
</dd>
<dt><code>"n_rtrms"</code>:</dt><dd><p>number of random-effects terms</p>
</dd>
<dt><code>"n_rfacs"</code>:</dt><dd><p>number of distinct random-effects grouping factors</p>
</dd>
<dt><code>"N"</code>:</dt><dd><p>number of rows of <code>X</code></p>
</dd>
<dt><code>"n"</code>:</dt><dd><p>length of the response vector, <code>y</code></p>
</dd>
<dt><code>"p"</code>:</dt><dd><p>number of columns of the fixed effects model matrix, <code>X</code></p>
</dd>
<dt><code>"q"</code>:</dt><dd><p>number of columns of the random effects model matrix, <code>Z</code></p>
</dd>
<dt><code>"p_i"</code>:</dt><dd><p>numbers of columns of the raw model matrices, <code>mmList</code></p>
</dd>
<dt><code>"l_i"</code>:</dt><dd><p>numbers of levels of the grouping factors</p>
</dd>
<dt><code>"q_i"</code>:</dt><dd><p>numbers of columns of the term-wise model matrices, <code>ZtList</code></p>
</dd>
<dt><code>"k"</code>:</dt><dd><p>number of random effects terms</p>
</dd>
<dt><code>"m_i"</code>:</dt><dd><p>numbers of covariance parameters in each term</p>
</dd>
<dt><code>"m"</code>:</dt><dd><p>total number of covariance parameters, i.e., the
same as <code>dims@nth</code> below.</p>
</dd>
<dt><code>"cnms"</code>:</dt><dd><p>the &ldquo;component names&rdquo;, a <code><a href="base.html#topic+list">list</a></code>.</p>
</dd>
<dt><code>"REML"</code>:</dt><dd><p><code>0</code> indicates the model was fitted by maximum
likelihood, any other positive integer indicates fitting by
restricted maximum likelihood</p>
</dd>
<dt><code>"is_REML"</code>:</dt><dd><p>same as the result of <code><a href="#topic+isREML">isREML</a>(.)</code></p>
</dd>
<dt><code>"devcomp"</code>:</dt><dd><p>a list consisting of a named numeric vector,
<code>cmp</code>, and a named integer vector, <code>dims</code>, describing
the fitted model.  The elements of <code>cmp</code> are:<br />
</p>

<dl>
<dt>ldL2</dt><dd><p>twice the log determinant of <code>L</code></p>
</dd>
<dt>ldRX2</dt><dd><p>twice the log determinant of <code>RX</code></p>
</dd>
<dt>wrss</dt><dd><p>weighted residual sum of squares</p>
</dd>
<dt>ussq</dt><dd><p>squared length of <code>u</code></p>
</dd>
<dt>pwrss</dt><dd><p>penalized weighted residual sum of squares,
&ldquo;wrss + ussq&rdquo;</p>
</dd>
<dt>drsum</dt><dd><p>sum of residual deviance (GLMMs only)</p>
</dd>
<dt>REML</dt><dd><p>REML criterion at optimum (LMMs fit
by REML only)</p>
</dd>
<dt>dev</dt><dd><p>deviance criterion at optimum
(models fit by ML only)</p>
</dd>
<dt>sigmaML</dt><dd><p>ML estimate of residual standard deviation</p>
</dd>
<dt>sigmaREML</dt><dd><p>REML estimate of residual standard deviation</p>
</dd>
<dt>tolPwrss</dt><dd><p>tolerance for declaring convergence in the
penalized iteratively weighted residual sum-of-squares (GLMMs only)</p>
</dd>
</dl>
<p> The elements of <code>dims</code> are:<br />
</p>

<dl>
<dt>N</dt><dd><p>number of rows of <code>X</code></p>
</dd>
<dt>n</dt><dd><p>length of <code>y</code></p>
</dd>
<dt>p</dt><dd><p>number of columns of <code>X</code></p>
</dd>
<dt>nmp</dt><dd><p><code>n-p</code></p>
</dd>
<dt>nth</dt><dd><p>length of <code>theta</code></p>
</dd>
<dt>q</dt><dd><p>number of columns of <code>Z</code></p>
</dd>
<dt>nAGQ</dt><dd><p>see <code><a href="#topic+glmer">glmer</a></code></p>
</dd>
<dt>compDev</dt><dd><p>see <code><a href="#topic+glmerControl">glmerControl</a></code></p>
</dd>
<dt>useSc</dt><dd><p><code>TRUE</code> if model has a scale parameter</p>
</dd>
<dt>reTrms</dt><dd><p>number of random effects terms</p>
</dd>
<dt>REML</dt><dd><p><code>0</code> indicates the model was fitted by maximum
likelihood, any other positive integer indicates fitting by
restricted maximum likelihood</p>
</dd>
<dt>GLMM</dt><dd><p><code>TRUE</code> if a GLMM</p>
</dd>
<dt>NLMM</dt><dd><p><code>TRUE</code> if an NLMM</p>
</dd>
</dl>

</dd>
<dt><code>"offset"</code>:</dt><dd><p>model offset</p>
</dd>
<dt><code>"lower"</code>:</dt><dd><p>lower bounds on random-effects model
parameters (i.e, &quot;theta&quot; parameters). In order to constrain
random effects covariance matrices to be semi-positive-definite,
this vector is equal to 0 for elements of
the <code>theta</code> vector corresponding to diagonal elements of
the Cholesky factor, <code>-Inf</code>
otherwise. (<code>getME(.,"lower")==0</code> can be used as a test to
identify diagonal elements, as in <code>isSingular</code>.)
</p>
</dd>
<dt><code>"devfun"</code>:</dt><dd><p>deviance function (so far only available for LMMs)</p>
</dd>
<dt><code>"glmer.nb.theta"</code>:</dt><dd><p>negative binomial <code class="reqn">\theta</code> parameter,
only for <code><a href="#topic+glmer.nb">glmer.nb</a></code>.</p>
</dd>

<dt><code>"ALL"</code>:</dt><dd><p>get all of the above as a <code><a href="base.html#topic+list">list</a></code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="getME_+3A_...">...</code></td>
<td>
<p>currently unused in <span class="pkg">lme4</span>, potentially further
arguments in methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal is to provide &ldquo;everything a user may
want&rdquo; from a fitted <code>"merMod"</code> object <em>as far</em>
as it is not available by methods, such as
<code><a href="#topic+fixef">fixef</a></code>, <code><a href="#topic+ranef">ranef</a></code>,
<code><a href="stats.html#topic+vcov">vcov</a></code>, etc.
</p>


<h3>Value</h3>

<p>Unspecified, as very much depending on the <code><a href="base.html#topic+name">name</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+getCall">getCall</a>()</code>.  More standard methods for <code>"merMod"</code>
objects, such as <code><a href="#topic+ranef">ranef</a></code>, <code><a href="#topic+fixef">fixef</a></code>,
<code><a href="stats.html#topic+vcov">vcov</a></code>, etc.: see <code>methods(class="merMod")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## shows many methods you should consider *before* using getME():
methods(class = "merMod")

(fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy))
Z &lt;- getME(fm1, "Z")
stopifnot(is(Z, "CsparseMatrix"),
          c(180,36) == dim(Z),
	  all.equal(fixef(fm1), b1 &lt;- getME(fm1, "beta"),
		    check.attributes=FALSE, tolerance = 0))

## A way to get *all* getME()s :
## internal consistency check ensuring that all work:
parts &lt;- getME(fm1, "ALL")
str(parts, max=2)
stopifnot(identical(Z,  parts $ Z),
          identical(b1, parts $ beta))
</code></pre>

<hr>
<h2 id='GHrule'>Univariate Gauss-Hermite quadrature rule</h2><span id='topic+GHrule'></span>

<h3>Description</h3>

<p>Create a univariate Gauss-Hermite quadrature rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  GHrule(ord, asMatrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GHrule_+3A_ord">ord</code></td>
<td>
<p>scalar integer between 1 and 100 - the order,
or number of nodes and weights, in the rule.  When the
function being multiplied by the standard normal density
is a polynomial of order <code class="reqn">2k-1</code> the rule of order <code class="reqn">k</code>
integrates the product exactly.</p>
</td></tr>
<tr><td><code id="GHrule_+3A_asmatrix">asMatrix</code></td>
<td>
<p>logical scalar - should the result be
returned as a matrix.  If <code>FALSE</code> a data frame is
returned.  Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version of Gauss-Hermite quadrature provides the node positions
and weights for a scalar integral of a function multiplied by the
standard normal density.
</p>
<p>Originally based on package <a href="https://CRAN.R-project.org/package=SparseGrid"><span class="pkg">SparseGrid</span></a>'s hidden <code>GQN()</code>,
then on <a href="https://CRAN.R-project.org/package=fastGHQuad"><span class="pkg">fastGHQuad</span></a>'s <code>gaussHermiteData(.)</code>.
</p>


<h3>Value</h3>

<p>a matrix (or data frame, is <code>asMatrix</code> is false) with <code>ord</code>
rows and three columns which are <code>z</code> the node positions, <code>w</code>
the weights and <code>ldnorm</code>, the logarithm of the normal density
evaluated at the nodes.
</p>


<h3>References</h3>

<p>Qing Liu and Donald A. Pierce (1994).
A Note on Gauss-Hermite Quadrature. <em>Biometrika</em> <b>81</b>(3), 624&ndash;629.
<a href="https://doi.org/10.2307/2337136">doi:10.2307/2337136</a>
</p>


<h3>See Also</h3>

<p>a different interface is available via <code><a href="#topic+GQdk">GQdk</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(r5  &lt;- GHrule( 5, asMatrix=FALSE))
(r12 &lt;- GHrule(12, asMatrix=FALSE))

## second, fourth, sixth, eighth and tenth central moments of the
## standard Gaussian N(0,1) density:
ps &lt;- seq(2, 10, by = 2)
cbind(p = ps, "E[X^p]" = with(r5,  sapply(ps, function(p) sum(w * z^p)))) # p=10 is wrong for 5-rule
p &lt;- 1:15
GQ12 &lt;- with(r12, sapply(p, function(p) sum(w * z^p)))
cbind(p = p, "E[X^p]" = zapsmall(GQ12))
## standard R numerical integration can do it too:
intL &lt;- lapply(p, function(p) integrate(function(x) x^p * dnorm(x),
                                        -Inf, Inf, rel.tol=1e-11))
integR &lt;- sapply(intL, `[[`, "value")
cbind(p, "E[X^p]" = integR)# no zapsmall() needed here
all.equal(GQ12, integR, tol=0)# =&gt; shows small difference
stopifnot(all.equal(GQ12, integR, tol = 1e-10))
(xactMom &lt;- cumprod(seq(1,13, by=2)))
stopifnot(all.equal(xactMom, GQ12[2*(1:7)], tol=1e-14))
## mean relative errors :
mean(abs(GQ12  [2*(1:7)] / xactMom - 1)) # 3.17e-16
mean(abs(integR[2*(1:7)] / xactMom - 1)) # 9.52e-17 {even better}
</code></pre>

<hr>
<h2 id='glmer'>Fitting Generalized Linear Mixed-Effects Models</h2><span id='topic+glmer'></span>

<h3>Description</h3>

<p>Fit a generalized linear mixed-effects model (GLMM).  Both fixed
effects and random effects are specified via the model <code>formula</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmer(formula, data = NULL, family = gaussian
    , control = glmerControl()
    , start = NULL
    , verbose = 0L
    , nAGQ = 1L
    , subset, weights, na.action, offset, contrasts = NULL
    , mustart, etastart
    , devFunOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmer_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object describing both the
fixed-effects and random-effects part of the model, with the response
on the left of a <code>~</code> operator and the terms, separated by
<code>+</code> operators, on the right.  Random-effects terms are
distinguished by vertical bars (<code>"|"</code>) separating expressions
for design matrices from grouping factors.</p>
</td></tr>
<tr><td><code id="glmer_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>formula</code>.  By default the variables are taken from the
environment from which <code>lmer</code> is called.  While <code>data</code> is
optional, the package authors <em>strongly</em> recommend its use,
especially when later applying methods such as <code>update</code> and
<code>drop1</code> to the fitted model (<em>such methods are not
guaranteed to work properly if <code>data</code> is omitted</em>).  If
<code>data</code> is omitted, variables will be taken from the environment
of <code>formula</code> (if specified as a formula) or from the parent
frame (if specified as a character vector).</p>
</td></tr>
<tr><td><code id="glmer_+3A_family">family</code></td>
<td>
<p>a GLM family, see <code><a href="stats.html#topic+glm">glm</a></code> and
<code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
<tr><td><code id="glmer_+3A_control">control</code></td>
<td>
<p>a list (of correct class, resulting from
<code><a href="#topic+lmerControl">lmerControl</a>()</code> or <code><a href="#topic+glmerControl">glmerControl</a>()</code>
respectively) containing control parameters, including the nonlinear
optimizer to be used and parameters to be passed through to the
nonlinear optimizer, see the <code>*lmerControl</code> documentation for
details.</p>
</td></tr>
<tr><td><code id="glmer_+3A_start">start</code></td>
<td>
<p>a named list of starting values for the parameters in the
model, or a numeric vector.  A numeric <code>start</code> argument will be
used as the starting value of <code>theta</code>.  If <code>start</code> is a
list, the <code>theta</code> element (a numeric vector) is used as the
starting value for the first optimization step (default=1 for
diagonal elements and 0 for off-diagonal elements of the lower
Cholesky factor); the fitted value of <code>theta</code> from the first
step, plus <code>start[["fixef"]]</code>, are used as starting values for
the second optimization step.  If <code>start</code> has both <code>fixef</code>
and <code>theta</code> elements, the first optimization step is skipped.
For more details or finer control of optimization, see
<code><a href="#topic+modular">modular</a></code>.</p>
</td></tr>
<tr><td><code id="glmer_+3A_verbose">verbose</code></td>
<td>
<p>integer scalar.  If <code>&gt; 0</code> verbose output is
generated during the optimization of the parameter estimates.  If
<code>&gt; 1</code> verbose output is generated during the individual
penalized iteratively reweighted least squares (PIRLS) steps.</p>
</td></tr>
<tr><td><code id="glmer_+3A_nagq">nAGQ</code></td>
<td>
<p>integer scalar - the number of points per axis for
evaluating the adaptive Gauss-Hermite approximation to the
log-likelihood.  Defaults to 1, corresponding to the Laplace
approximation.  Values greater than 1 produce greater accuracy in
the evaluation of the log-likelihood at the expense of speed.  A
value of zero uses a faster but less exact form of parameter
estimation for GLMMs by optimizing the random effects and the
fixed-effects coefficients in the penalized iteratively reweighted
least squares step. (See Details.)</p>
</td></tr>
<tr><td><code id="glmer_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows
of <code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a character vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="glmer_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric
vector.</p>
</td></tr>
<tr><td><code id="glmer_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.omit</code>,
inherited from the &lsquo;factory fresh&rsquo; value of
<code>getOption("na.action")</code>) strips any observations with any
missing values in any variables.</p>
</td></tr>
<tr><td><code id="glmer_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="glmer_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list.  See the <code>contrasts.arg</code> of
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="glmer_+3A_mustart">mustart</code></td>
<td>
<p>optional starting values on the scale of the
conditional mean, as in <code><a href="stats.html#topic+glm">glm</a></code>; see there for
details.</p>
</td></tr>
<tr><td><code id="glmer_+3A_etastart">etastart</code></td>
<td>
<p>optional starting values on the scale of the unbounded
predictor as in <code><a href="stats.html#topic+glm">glm</a></code>; see there for details.</p>
</td></tr>
<tr><td><code id="glmer_+3A_devfunonly">devFunOnly</code></td>
<td>
<p>logical - return only the deviance evaluation
function. Note that because the deviance function operates on
variables stored in its environment, it may not return
<em>exactly</em> the same values on subsequent calls (but the results
should always be within machine tolerance).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit a generalized linear mixed model, which incorporates both
fixed-effects parameters and random effects in a linear predictor, via
maximum likelihood.  The linear predictor is related to the
conditional mean of the response through the inverse link function
defined in the GLM <code>family</code>.
</p>
<p>The expression for the likelihood of a mixed-effects model is an
integral over the random effects space.  For a linear mixed-effects
model (LMM), as fit by <code><a href="#topic+lmer">lmer</a></code>, this integral can be
evaluated exactly.  For a GLMM the integral must be approximated.  The
most reliable approximation for GLMMs
is adaptive Gauss-Hermite quadrature,
at present implemented only for models with
a single scalar random effect.  The
<code>nAGQ</code> argument controls the number of nodes in the quadrature
formula.  A model with a single, scalar random-effects term could
reasonably use up to 25 quadrature points per scalar integral.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+merMod-class">merMod</a></code> (more specifically,
an object of <em>subclass</em> <code>glmerMod</code>) for which many
methods are available (e.g. <code>methods(class="merMod")</code>)
</p>


<h3>Note</h3>

<p>In earlier version of the <span class="pkg">lme4</span> package, a <code>method</code> argument was
used.  Its functionality has been replaced by the <code>nAGQ</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmer">lmer</a></code> (for details on formulas and
parameterization); <code><a href="stats.html#topic+glm">glm</a></code> for Generalized Linear
Models (<em>without</em> random effects).
<code><a href="#topic+nlmer">nlmer</a></code> for nonlinear mixed-effects models.
</p>
<p><code><a href="#topic+glmer.nb">glmer.nb</a></code> to fit negative binomial GLMMs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generalized linear mixed model
library(lattice)
xyplot(incidence/size ~ period|herd, cbpp, type=c('g','p','l'),
       layout=c(3,5), index.cond = function(x,y)max(y))
(gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
              data = cbpp, family = binomial))
## using nAGQ=0 only gets close to the optimum
(gm1a &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
               cbpp, binomial, nAGQ = 0))
## using  nAGQ = 9  provides a better evaluation of the deviance
## Currently the internal calculations use the sum of deviance residuals,
## which is not directly comparable with the nAGQ=0 or nAGQ=1 result.
## 'verbose = 1' monitors iteratin a bit; (verbose = 2 does more):
(gm1a &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
               cbpp, binomial, verbose = 1, nAGQ = 9))

## GLMM with individual-level variability (accounting for overdispersion)
## For this data set the model is the same as one allowing for a period:herd
## interaction, which the plot indicates could be needed.
cbpp$obs &lt;- 1:nrow(cbpp)
(gm2 &lt;- glmer(cbind(incidence, size - incidence) ~ period +
    (1 | herd) +  (1|obs),
              family = binomial, data = cbpp))
anova(gm1,gm2)

## glmer and glm log-likelihoods are consistent
gm1Devfun &lt;- update(gm1,devFunOnly=TRUE)
gm0 &lt;- glm(cbind(incidence, size - incidence) ~ period,
           family = binomial, data = cbpp)
## evaluate GLMM deviance at RE variance=theta=0, beta=(GLM coeffs)
gm1Dev0 &lt;- gm1Devfun(c(0,coef(gm0)))
## compare
stopifnot(all.equal(gm1Dev0,c(-2*logLik(gm0))))
## the toenail oncholysis data from Backer et al 1998
## these data are notoriously difficult to fit
## Not run: 
if (require("HSAUR3")) {
    gm2 &lt;- glmer(outcome~treatment*visit+(1|patientID),
                 data=toenail,
                 family=binomial,nAGQ=20)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='glmer.nb'>Fitting Negative Binomial GLMMs</h2><span id='topic+glmer.nb'></span><span id='topic+negative.binomial'></span>

<h3>Description</h3>

<p>Fits a generalized linear mixed-effects model (GLMM) for the negative
binomial family, building on <code><a href="#topic+glmer">glmer</a></code>, and initializing via
<code><a href="MASS.html#topic+theta.ml">theta.ml</a></code> from <span class="pkg">MASS</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmer.nb(..., interval = log(th) + c(-3, 3),
         tol = 5e-5, verbose = FALSE, nb.control = NULL,
         initCtrl = list(limit = 20, eps = 2*tol, trace = verbose,
                         theta = NULL))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmer.nb_+3A_...">...</code></td>
<td>
<p>arguments as for <code>glmer(.)</code> such as <code>formula</code>,
<code>data</code>, <code>control</code>, etc, but <em>not</em> <code>family</code>!</p>
</td></tr>
<tr><td><code id="glmer.nb_+3A_interval">interval</code></td>
<td>
<p>interval in which to start the optimization.  The
default is symmetric on log scale around the initially estimated theta.</p>
</td></tr>
<tr><td><code id="glmer.nb_+3A_tol">tol</code></td>
<td>
<p>tolerance for the optimization via <code><a href="stats.html#topic+optimize">optimize</a></code>.</p>
</td></tr>
<tr><td><code id="glmer.nb_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating how much
progress information should be printed during the optimization.  Use
<code>verbose = 2</code> (or larger) to enable <code>verbose=TRUE</code> in the
<code><a href="#topic+glmer">glmer</a>()</code> calls.</p>
</td></tr>
<tr><td><code id="glmer.nb_+3A_nb.control">nb.control</code></td>
<td>
<p>optional <code><a href="base.html#topic+list">list</a></code>, like the output of <code><a href="#topic+glmerControl">glmerControl</a>()</code>,
used in <code><a href="#topic+refit">refit</a>(*, control = control.nb)</code> during the
optimization (<code>control</code>, if included in <code>...</code>,
will be used in the initial-stage <code>glmer(...,family=poisson)</code>
fit, and passed on to the later optimization stages as well)</p>
</td></tr>
<tr><td><code id="glmer.nb_+3A_initctrl">initCtrl</code></td>
<td>
<p>(<em><b>experimental</b>, do not rely on this</em>:) a
<code><a href="base.html#topic+list">list</a></code> with named components as in the default, passed to
<code><a href="MASS.html#topic+theta.ml">theta.ml</a></code> (package <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a>) for the initial
value of the negative binomial parameter <code>theta</code>.
May also include a <code>theta</code> component, in which case the
initial estimation step is skipped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>glmerMod</code>, for which many
methods are available (e.g. <code>methods(class="glmerMod")</code>), see
<code><a href="#topic+glmer">glmer</a></code>.
</p>


<h3>Note</h3>

<p>For historical reasons, the shape parameter of the negative
binomial and the random effects parameters in our (G)LMM models are
both called <code>theta</code> (<code class="reqn">\theta</code>), but are unrelated here.
</p>
<p>The negative binomial <code class="reqn">\theta</code> can be extracted from a fit
<code>g &lt;- glmer.nb()</code> by <code><a href="#topic+getME">getME</a>(g, "glmer.nb.theta")</code>.
</p>
<p>Parts of <code>glmer.nb()</code> are still experimental and methods are
still missing or suboptimal.  In particular, there is no inference
available for the dispersion parameter <code class="reqn">\theta</code>, yet.
</p>
<p>To fit a negative binomial model with <em>known</em> overdispersion
parameter (e.g. as part of a model comparison exercise, use
<code>glmer</code> with the <code><a href="MASS.html#topic+negative.binomial">negative.binomial</a></code> family from the
<code>MASS</code> package, e.g.
<code>glmer(...,family=MASS::negative.binomial(theta=1.75))</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmer">glmer</a></code>; from package <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a>,
<code><a href="MASS.html#topic+negative.binomial">negative.binomial</a></code> (which we re-export currently) and
<code><a href="MASS.html#topic+theta.ml">theta.ml</a></code>, the latter for initialization of
optimization.
</p>
<p>The &lsquo;Details&rsquo; of <code><a href="stats.html#topic+pnbinom">pnbinom</a></code> for the definition of
the negative binomial distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
dd &lt;- expand.grid(f1 = factor(1:3),
                  f2 = LETTERS[1:2], g=1:9, rep=1:15,
          KEEP.OUT.ATTRS=FALSE)
summary(mu &lt;- 5*(-4 + with(dd, as.integer(f1) + 4*as.numeric(f2))))
dd$y &lt;- rnbinom(nrow(dd), mu = mu, size = 0.5)
str(dd)
require("MASS")## and use its glm.nb() - as indeed we have zero random effect:
## Not run: 
m.glm &lt;- glm.nb(y ~ f1*f2, data=dd, trace=TRUE)
summary(m.glm)
m.nb &lt;- glmer.nb(y ~ f1*f2 + (1|g), data=dd, verbose=TRUE)
m.nb
## The neg.binomial theta parameter:
getME(m.nb, "glmer.nb.theta")
LL &lt;- logLik(m.nb)
## mixed model has 1 additional parameter (RE variance)
stopifnot(attr(LL,"df")==attr(logLik(m.glm),"df")+1)
plot(m.nb, resid(.) ~ g)# works, as long as data 'dd' is found

## End(Not run)
</code></pre>

<hr>
<h2 id='glmerLaplaceHandle'>Handle for <code>glmerLaplace</code></h2><span id='topic+glmerLaplaceHandle'></span>

<h3>Description</h3>

<p>Handle for calling the <code>glmerLaplace</code> <code>C++</code> function.  Not
intended for routine use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmerLaplaceHandle(pp, resp, nAGQ, tol, maxit, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmerLaplaceHandle_+3A_pp">pp</code></td>
<td>
<p><code><a href="#topic+merPredD">merPredD</a></code> object</p>
</td></tr>
<tr><td><code id="glmerLaplaceHandle_+3A_resp">resp</code></td>
<td>
<p><code><a href="#topic+lmResp">lmResp</a></code> object</p>
</td></tr>
<tr><td><code id="glmerLaplaceHandle_+3A_nagq">nAGQ</code></td>
<td>
<p>see <code><a href="#topic+glmer">glmer</a></code></p>
</td></tr>
<tr><td><code id="glmerLaplaceHandle_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="glmerLaplaceHandle_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of pwrss iterations</p>
</td></tr>
<tr><td><code id="glmerLaplaceHandle_+3A_verbose">verbose</code></td>
<td>
<p>display optimizer progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the objective function
</p>

<hr>
<h2 id='glmFamily'>Generator object for the <code><a href="#topic+glmFamily-class">glmFamily</a></code> class</h2><span id='topic+glmFamily'></span>

<h3>Description</h3>

<p>The generator object for the
<code><a href="#topic+glmFamily-class">glmFamily</a></code> reference class. Such an
object is primarily used through its <code>new</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  glmFamily(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glmFamily_+3A_...">...</code></td>
<td>
<p>Named argument (see Note below)</p>
</td></tr>
</table>


<h3>Methods</h3>

 <dl>
<dt><code>new(family=family)</code></dt><dd><p>Create a new
<code><a href="#topic+glmFamily-class">glmFamily</a></code> object</p>
</dd> </dl>



<h3>Note</h3>

<p>Arguments to the <code>new</code> method must be named
arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmFamily-class">glmFamily</a></code>
</p>

<hr>
<h2 id='glmFamily-class'>Class <code>"glmFamily"</code> - a reference class for <code><a href="stats.html#topic+family">family</a></code></h2><span id='topic+glmFamily-class'></span>

<h3>Description</h3>

<p>This class is a wrapper class for <code><a href="stats.html#topic+family">family</a></code>
objects specifying a distibution family and link function
for a generalized linear model (<code><a href="stats.html#topic+glm">glm</a></code>).  The
reference class contains an external pointer to a C++
object representing the class.  For common families and
link functions the functions in the family are
implemented in compiled code so they can be accessed from
other compiled code and for a speed boost.
</p>


<h3>Extends</h3>

<p>All reference classes extend and inherit methods from
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Note</h3>

<p>Objects from this reference class correspond to objects
in a C++ class.  Methods are invoked on the C++ class
using the external pointer in the <code>Ptr</code> field.  When
saving such an object the external pointer is converted
to a null pointer, which is why there is a redundant
field <code>ptr</code> that is an active-binding function
returning the external pointer.  If the <code>Ptr</code> field
is a null pointer, the external pointer is regenerated
for the stored <code>family</code> field.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+family">family</a></code>, <code><a href="#topic+glmFamily">glmFamily</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(glmFamily$new(family=poisson()))
</code></pre>

<hr>
<h2 id='golden-class'>Class <code>"golden"</code> and Generator for Golden Search Optimizer Class</h2><span id='topic+golden-class'></span><span id='topic+golden'></span>

<h3>Description</h3>

<p><code>"golden"</code> is a reference class for a golden search scalar optimizer,
for a parameter within an interval.
</p>
<p><code>golden()</code> is the generator for the <code>"golden"</code>
class.  The optimizer uses reverse communications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>golden(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="golden-class_+3A_...">...</code></td>
<td>
<p>(partly optional) arguments passed to
<code><a href="methods.html#topic+new">new</a>()</code> must be named arguments.  <code>lower</code> and
<code>upper</code> are the bounds for the scalar parameter; they must be
finite.</p>
</td></tr>
</table>


<h3>Extends</h3>

<p>All reference classes extend and inherit methods from
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("golden")

golden(lower= -100, upper= 1e100)
</code></pre>

<hr>
<h2 id='GQdk'>Sparse Gaussian / Gauss-Hermite Quadrature grid</h2><span id='topic+GQdk'></span><span id='topic+GQN'></span>

<h3>Description</h3>

<p>Generate the sparse multidimensional Gaussian quadrature grids.
</p>
<p>Currently unused.  See <code><a href="#topic+GHrule">GHrule</a>()</code> for the version
currently in use in package <span class="pkg">lme4</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  GQdk(d = 1L, k = 1L)
  GQN
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GQdk_+3A_d">d</code></td>
<td>
<p>integer scalar - the dimension of the function
to be integrated with respect to the standard
<code>d</code>-dimensional Gaussian density.</p>
</td></tr>
<tr><td><code id="GQdk_+3A_k">k</code></td>
<td>
<p>integer scalar - the order of the grid.  A grid
of order <code>k</code> provides an exact result for a
polynomial of total order of <code>2k - 1</code> or less.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>GQdk()</code> returns a matrix with <code>d + 1</code> columns.  The first
column is the weights and the remaining <code>d</code> columns are the
node coordinates.
</p>
<p><code>GQN</code> is a <code><a href="base.html#topic+list">list</a></code> of lists, containing the
non-redundant quadrature nodes and weights for integration of a scalar
function of a <code>d</code>-dimensional argument with respect to the density
function of the <code>d</code>-dimensional Gaussian density function.
<br />
The outer list is indexed by the dimension, <code>d</code>, in the
range of 1 to 20.  The inner list is indexed by <code>k</code>,
the order of the quadrature.
</p>


<h3>Note</h3>

<p><code>GQN</code> contains only the non-redundant nodes.  To regenerate
the whole array of nodes, all possible permutations of
axes and all possible combinations of <code class="reqn">\pm 1</code>
must be applied to the axes.  This entire array of nodes is exactly
what <code><a href="#topic+GQdk">GQdk</a>()</code> reproduces.
</p>
<p>The number of nodes gets very large very quickly with
increasing <code>d</code> and <code>k</code>.  See the charts at
<a href="http://www.sparse-grids.de">http://www.sparse-grids.de</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GQdk(2,5) # 53 x 3

GQN[[3]][[5]] # a 14 x 4 matrix
</code></pre>

<hr>
<h2 id='grouseticks'>
Data on red grouse ticks from Elston et al. 2001
</h2><span id='topic+grouseticks'></span><span id='topic+grouseticks_agg'></span>

<h3>Description</h3>

<p>Number of ticks on the heads of red grouse chicks
sampled in the field (<code>grouseticks</code>)
and an aggregated version (<code>grouseticks_agg</code>); see original source for more details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(grouseticks)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>INDEX</code></dt><dd><p>(factor) chick number (observation level)</p>
</dd>
<dt><code>TICKS</code></dt><dd><p>number of ticks sampled</p>
</dd>
<dt><code>BROOD</code></dt><dd><p>(factor) brood number</p>
</dd>
<dt><code>HEIGHT</code></dt><dd><p>height above sea level (meters)</p>
</dd>
<dt><code>YEAR</code></dt><dd><p>year (-1900)</p>
</dd>
<dt><code>LOCATION</code></dt><dd><p>(factor) geographic location code</p>
</dd>
<dt><code>cHEIGHT</code></dt><dd><p>centered height, derived from <code>HEIGHT</code></p>
</dd>
<dt><code>meanTICKS</code></dt><dd><p>mean number of ticks by brood</p>
</dd>
<dt><code>varTICKS</code></dt><dd><p>variance of number of ticks by brood</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>grouseticks_agg</code> is just a brood-level
aggregation of the data</p>


<h3>Source</h3>

<p>Robert Moss, via David Elston
</p>


<h3>References</h3>

<p>Elston, D. A., R. Moss, T. Boulinier, C. Arrowsmith, and
X. Lambin. 2001. &quot;Analysis of Aggregation, a Worked Example: Numbers of
Ticks on Red Grouse Chicks.&quot; Parasitology 122 (05):
563-569. <a href="https://doi.org/10.1017/S0031182001007740">doi:10.1017/S0031182001007740</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
data(grouseticks)
## Figure 1a from Elston et al
par(las=1,bty="l")
tvec &lt;- c(0,1,2,5,20,40,80)
pvec &lt;- c(4,1,3)
with(grouseticks_agg,plot(1+meanTICKS~HEIGHT,
                  pch=pvec[factor(YEAR)],
                  log="y",axes=FALSE,
                  xlab="Altitude (m)",
                  ylab="Brood mean ticks"))
axis(side=1)
axis(side=2,at=tvec+1,label=tvec)
box()
abline(v=405,lty=2)
## Figure 1b
with(grouseticks_agg,plot(varTICKS~meanTICKS,
                  pch=4,
                  xlab="Brood mean ticks",
                  ylab="Within-brood variance"))
curve(1*x,from=0,to=70,add=TRUE)
## Model fitting
form &lt;- TICKS~YEAR+HEIGHT+(1|BROOD)+(1|INDEX)+(1|LOCATION)
(full_mod1  &lt;- glmer(form, family="poisson",data=grouseticks))
}
</code></pre>

<hr>
<h2 id='hatvalues.merMod'>Diagonal elements of the hat matrix</h2><span id='topic+hatvalues.merMod'></span>

<h3>Description</h3>

<p>Returns the values on the diagonal of the hat matrix, which is the
matrix that transforms the response vector (minus any offset) into the
fitted values (minus any offset).  Note that this method should only
be used for linear mixed models.  It is not clear if the hat matrix
concept even makes sense for generalized linear mixed models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'merMod'
 hatvalues(model, fullHatMatrix = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hatvalues.merMod_+3A_model">model</code></td>
<td>
<p>An object of class <code><a href="#topic+merMod">merMod</a></code>.</p>
</td></tr>
<tr><td><code id="hatvalues.merMod_+3A_fullhatmatrix">fullHatMatrix</code></td>
<td>
<p>Return full hat matrix (not just diagonal values)?</p>
</td></tr>
<tr><td><code id="hatvalues.merMod_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The diagonal elements of the hat matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
hatvalues(m)
</code></pre>

<hr>
<h2 id='influence.merMod'>Influence Diagnostics for Mixed-Effects Models</h2><span id='topic+influence.merMod'></span><span id='topic+dfbeta.influence.merMod'></span><span id='topic+dfbetas.influence.merMod'></span><span id='topic+cooks.distance.influence.merMod'></span><span id='topic+cooks.distance.merMod'></span>

<h3>Description</h3>

<p>These functions compute deletion influence diagnostics for linear
(fit by <code><a href="#topic+lmer">lmer</a></code>) and generalized linear mixed-effects models
(fit by <code><a href="#topic+glmer">glmer</a></code>).  The main functions are methods for
the <code><a href="stats.html#topic+influence">influence</a></code> generic function.  Other functions are
provided for computing <code><a href="stats.html#topic+dfbeta">dfbeta</a></code>, <code><a href="stats.html#topic+dfbetas">dfbetas</a></code>,
<code><a href="stats.html#topic+cooks.distance">cooks.distance</a></code>, and influence on variance-covariance
components based on the objects computed by <code>influence.merMod</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
influence(model, groups, data, maxfun = 1000,
          do.coef = TRUE, ncores = getOption("mc.cores",1), start, ...)
## S3 method for class 'influence.merMod'
cooks.distance(model, ...)
## S3 method for class 'influence.merMod'
dfbeta(model, which = c("fixed", "var.cov"), ...)
## S3 method for class 'influence.merMod'
dfbetas(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="influence.merMod_+3A_model">model</code></td>
<td>
<p>in the case of <code>influence.merMod</code>, a model of class <code>"merMod"</code>;
in the case of <code>cooks.distance</code>, <code>dfbeta</code>, or <code>dfbetas</code>,
an object returned by <code>influence.merMod</code></p>
</td></tr>
<tr><td><code id="influence.merMod_+3A_groups">groups</code></td>
<td>
<p>a character vector containing the name of a grouping factor or names of grouping factors; if more than one name
is supplied, then groups are defined by all combinations of levels of the grouping factors that appear in
the data. If omitted, then each individual row of the data matrix is treated as a &quot;group&quot; to be deleted in turn.</p>
</td></tr>
<tr><td><code id="influence.merMod_+3A_data">data</code></td>
<td>
<p>an optional data frame with the data to which <code>model</code>
was fit; <code>influence.merMod</code> can usually retrieve the data used to
fit the model, unless it can't be found in the current environment, so it's usually unnecessary to supply this argument.</p>
</td></tr>
<tr><td><code id="influence.merMod_+3A_maxfun">maxfun</code></td>
<td>
<p>The maximum number of function evaluations (for <code>influence.merMod</code>)
to perform after deleting each group; the defaults are large enough so that the iterations will typically continue to convergence.
Setting to <code>maxfun=20</code> for an <code>lmer</code> model or <code>100</code> for a <code>glmer</code> model will typically produce a faster reasonable approximation.
An even smaller value can be used if interest is only in influence on the fixed effects.</p>
</td></tr>
<tr><td><code id="influence.merMod_+3A_which">which</code></td>
<td>
<p>if <code>"fixed.effects"</code> (the default), return influence
on the fixed effects; if <code>"var.cov"</code>, return influence on the
variance-covariance components.</p>
</td></tr>
<tr><td><code id="influence.merMod_+3A_do.coef">do.coef</code></td>
<td>
<p>if <code>FALSE</code>, skip potentially time-consuming
computations, returning just a list containing hat values.</p>
</td></tr>
<tr><td><code id="influence.merMod_+3A_ncores">ncores</code></td>
<td>
<p>number of computational cores to use if run in parallel;
directly passed to <code><a href="parallel.html#topic+makeCluster">makeCluster</a>()</code> from <span class="rlang"><b>R</b></span>'s
<span class="pkg">parallel</span> package.</p>
</td></tr>
<tr><td><code id="influence.merMod_+3A_start">start</code></td>
<td>
<p>starting value for new fits (set to optimal values from
original fit by default)</p>
</td></tr>
<tr><td><code id="influence.merMod_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>influence.merMod</code> start with the estimated variance-covariance components from <code>model</code> and then refit
the model omitting each group in turn, not necessarily iterating to completion. For example, <code>maxfun=20</code> takes up to 20 function evaluations
step away from the ML or REML solution for the full data, which usually provides decent approximations to the fully iterated estimates.
</p>
<p>The other functions are methods for the <code><a href="stats.html#topic+dfbeta">dfbeta</a></code>, <code><a href="stats.html#topic+dfbetas">dfbetas</a></code>, and <code><a href="stats.html#topic+cooks.distance">cooks.distance</a></code> generics, to be applied to the
<code>"influence.merMod"</code> object produced by the <code>influence</code> function; the <code>dfbeta</code> methods can also return
influence on the variance-covariance components.
</p>


<h3>Value</h3>

<p><code>influence.merMod</code> returns objects of class
<code>"influence.merMod"</code>, which contain the following elements:
</p>

<dl>
<dt><code>"fixed.effects"</code></dt><dd><p>the estimated fixed effects for the model.</p>
</dd>
<dt><code>"fixed.effects[-groups]"</code></dt><dd><p>a matrix with columns corresponding to the fixed-effects coefficients and rows corresponding to groups, giving the
estimated fixed effects with each group deleted in turn; <em>groups</em> is formed from the name(s) of the grouping factor(s).</p>
</dd>
<dt><code>"var.cov.comps"</code></dt><dd><p>the estimated variance-covariance parameters for the model.</p>
</dd>
<dt><code>"var.cov.comps[-groups]"</code></dt><dd><p>a matrix with the estimated covariance parameters (in columns) with each group deleted in turn.</p>
</dd>
<dt><code>"vcov"</code></dt><dd><p>The estimated covariance matrix of the fixed-effects coefficients.</p>
</dd>
<dt><code>"vcov[-groups]"</code></dt><dd><p>a list each of whose elements is the estimated covariance matrix of the fixed-effects coefficients with one group deleted.</p>
</dd>
<dt><code>"groups"</code></dt><dd><p>a character vector giving the names of the grouping factors.</p>
</dd>
<dt><code>"deleted"</code></dt><dd><p>the possibly composite grouping factor, each of whose elements is deleted in turn.</p>
</dd>
<dt><code>"converged"</code></dt><dd><p>for <code>influence.merMod</code>, a logical vector indicating whether the computation converged for each group.</p>
</dd>
<dt><code>"function.evals"</code></dt><dd><p>for <code>influence.merMod</code>, a vector of the number of function evaluations performed for each group.</p>
</dd>
</dl>

<p>For plotting <code>"influence.merMod"</code> objects, see <code><a href="car.html#topic+infIndexPlot">infIndexPlot</a></code>.
</p>


<h3>Author(s)</h3>

<p>J. Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+infIndexPlot">infIndexPlot</a></code>, <code><a href="stats.html#topic+influence.measures">influence.measures</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
  inf_fm1 &lt;- influence(fm1, "Subject")
  if (require("car")) {
    infIndexPlot(inf_fm1)
  }
  dfbeta(inf_fm1)
  dfbetas(inf_fm1)
  gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
               data = cbpp, family = binomial)
  inf_gm1 &lt;- influence(gm1, "herd", maxfun=100)
  gm1.11 &lt;- update(gm1, subset = herd != 11) # check deleting herd 11
  if (require("car")) {
    infIndexPlot(inf_gm1)
    compareCoefs(gm1, gm1.11)
  }
  if(packageVersion("car") &gt;= "3.0.10") {
    dfbeta(inf_gm1)
    dfbetas(inf_gm1)
  }
 } 
</code></pre>

<hr>
<h2 id='InstEval'>University Lecture/Instructor Evaluations by Students at ETH</h2><span id='topic+InstEval'></span>

<h3>Description</h3>

<p>University lecture evaluations by students at ETH Zurich,
anonymized for privacy protection.  This is an
interesting &ldquo;medium&rdquo; sized example of a
<em>partially</em> nested mixed effect model.
</p>


<h3>Format</h3>

<p>A data frame with 73421 observations on the following 7 variables.
</p>

<dl>
<dt><code>s</code></dt><dd><p>a factor with levels <code>1:2972</code> denoting
individual students.</p>
</dd>
<dt><code>d</code></dt><dd><p>a factor with 1128 levels from <code>1:2160</code>, denoting
individual professors or lecturers.</p>
</dd>
<dt><code>studage</code></dt><dd><p>an ordered factor with levels <code>2</code> &lt;
<code>4</code> &lt; <code>6</code> &lt; <code>8</code>, denoting student's &ldquo;age&rdquo;
measured in the <em>semester</em> number the student has been enrolled.</p>
</dd>
<dt><code>lectage</code></dt><dd><p>an ordered factor with 6 levels, <code>1</code> &lt;
<code>2</code> &lt; ... &lt; <code>6</code>, measuring how many semesters back the
lecture rated had taken place.</p>
</dd>
<dt><code>service</code></dt><dd><p>a binary factor with levels <code>0</code> and
<code>1</code>; a lecture is a &ldquo;service&rdquo;, if held for a
different department than the lecturer's main one.</p>
</dd>
<dt><code>dept</code></dt><dd><p>a factor with 14 levels from <code>1:15</code>, using a
random code for the department of the lecture.</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector of <em>ratings</em> of lectures by
the students, using the discrete scale <code>1:5</code>, with meanings
of &lsquo;poor&rsquo; to &lsquo;very good&rsquo;.</p>
</dd>
</dl>

<p>Each observation is one student's rating for a specific lecture
(of one lecturer, during one semester in the past).</p>


<h3>Details</h3>

<p>The main goal of the survey is to find &ldquo;the best
liked prof&rdquo;, according to the lectures given.
Statistical analysis of such data has been the basis for
a (student) jury selecting the final winners.
</p>
<p>The present data set has been anonymized and slightly
simplified on purpose.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(InstEval)

head(InstEval, 16)
xtabs(~ service + dept, InstEval)
</code></pre>

<hr>
<h2 id='isNested'>Is f1 nested within f2?</h2><span id='topic+isNested'></span>

<h3>Description</h3>

<p>Does every level of f1 occur in conjunction with exactly
one level of f2? The function is based on converting a
triplet sparse matrix to a compressed column-oriented
form in which the nesting can be quickly evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isNested(f1, f2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isNested_+3A_f1">f1</code></td>
<td>
<p>factor 1</p>
</td></tr>
<tr><td><code id="isNested_+3A_f2">f2</code></td>
<td>
<p>factor 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if factor 1 is nested within factor 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(Pastes, isNested(cask, batch))   ## =&gt; FALSE
with(Pastes, isNested(sample, batch))  ## =&gt; TRUE
</code></pre>

<hr>
<h2 id='isREML'>Check characteristics of models</h2><span id='topic+isGLMM'></span><span id='topic+isLMM'></span><span id='topic+isNLMM'></span><span id='topic+isREML'></span><span id='topic+isGLMM.merMod'></span><span id='topic+isLMM.merMod'></span><span id='topic+isNLMM.merMod'></span><span id='topic+isREML.merMod'></span>

<h3>Description</h3>

<p>Check characteristics of models: whether a model fit
corresponds to a linear (LMM), generalized linear (GLMM),
or nonlinear (NLMM) mixed model, and whether a linear
mixed model has been fitted by REML or not
(<code>isREML(x)</code> is always <code>FALSE</code> for GLMMs and
NLMMs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isREML(x, ...)

  isLMM(x, ...)

  isNLMM(x, ...)

  isGLMM(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isREML_+3A_x">x</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="isREML_+3A_...">...</code></td>
<td>
<p>additional, optional arguments.  (None are
used in the merMod methods)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are generic functions.  At present the only methods
are for mixed-effects models of class
<code><a href="#topic+merMod-class">merMod</a></code>.
</p>


<h3>Value</h3>

<p>a logical value
</p>


<h3>See Also</h3>

<p>getME
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
              data = cbpp, family = binomial)
nm1 &lt;- nlmer(circumference ~ SSlogis(age, Asym, xmid, scal) ~ Asym|Tree,
             Orange, start = c(Asym = 200, xmid = 725, scal = 350))

isLMM(fm1)
isGLMM(gm1)
## check all :
is.MM &lt;- function(x) c(LMM = isLMM(x), GLMM= isGLMM(x), NLMM= isNLMM(x))
stopifnot(cbind(is.MM(fm1), is.MM(gm1), is.MM(nm1))
	  == diag(rep(TRUE,3)))
</code></pre>

<hr>
<h2 id='isSingular'>Test Fitted Model for (Near) Singularity</h2><span id='topic+isSingular'></span>

<h3>Description</h3>

<p>Evaluates whether a fitted mixed model is (almost / near) singular, i.e.,
the parameters are on the boundary of the feasible
parameter space: variances of one or more linear combinations of effects
are (close to) zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSingular(x, tol = 1e-4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isSingular_+3A_x">x</code></td>
<td>
<p>a fitted <code>merMod</code> object (result of <code>lmer</code> or <code>glmer</code>).</p>
</td></tr>
<tr><td><code id="isSingular_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance for detecting singularity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Complex mixed-effect models (i.e., those with a
large number of variance-covariance parameters) frequently result in
<em>singular</em> fits, i.e. estimated variance-covariance matrices with
less than full rank. Less technically, this means that some
&quot;dimensions&quot; of the variance-covariance matrix have been estimated as
exactly zero. For scalar random effects such as intercept-only models,
or 2-dimensional random effects such as intercept+slope models,
singularity is relatively easy to detect because it leads to
random-effect variance estimates of (nearly) zero, or estimates of
correlations that are (almost) exactly -1 or 1. However, for more
complex models (variance-covariance matrices of dimension &gt;=3)
singularity can be hard to detect; models can often be singular
without any of their individual variances being close to zero
or correlations being close to +/-1.
</p>
<p>This function performs a simple test to determine whether any of the
random effects covariance matrices of a fitted model are singular.
The <code><a href="#topic+rePCA">rePCA</a></code> method provides more detail about the
singularity pattern, showing the standard deviations
of orthogonal variance components and the mapping from
variance terms in the model to orthogonal components
(i.e., eigenvector/rotation matrices).
</p>
<p>While singular models are statistically well defined (it is
theoretically sensible for the true maximum likelihood estimate
to correspond to a singular fit), there are real concerns
that (1) singular fits correspond to overfitted models that may
have poor power; (2) chances of numerical problems and mis-convergence
are higher for singular models (e.g. it may be computationally
difficult to compute profile confidence intervals for such
models); (3) standard inferential procedures such as Wald statistics
and likelihood ratio tests may be inappropriate.
</p>
<p>There is not yet consensus about how to deal with singularity, or
more generally to choose which random-effects specification (from
a range of choices of varying complexity) to use.  Some proposals
include:
</p>

<ul>
<li><p> avoid fitting overly complex models in the first place,
i.e. design experiments/restrict models <em>a priori</em> such that the
variance-covariance matrices can be estimated precisely enough
to avoid singularity (Matuschek et al 2017)
</p>
</li>
<li><p> use some form of model selection to choose a model that
balances predictive accuracy and overfitting/type I error
(Bates et al 2015, Matuschek et al 2017)
</p>
</li>
<li> <p>&ldquo;keep it maximal&rdquo;, i.e. fit the most complex
model consistent with the experimental design, removing only
terms required to allow a non-singular fit (Barr et al. 2013),
or removing further terms based on p-values or AIC
</p>
</li>
<li><p> use a partially Bayesian method
that produces maximum <em>a posteriori</em> (MAP)
estimates using <em>regularizing</em> priors to force
the estimated random-effects variance-covariance matrices
away from singularity (Chung et al 2013, <a href="https://CRAN.R-project.org/package=blme"><span class="pkg">blme</span></a> package)
</p>
</li>
<li><p> use a fully Bayesian method that both regularizes the
model via informative priors and gives estimates
and credible intervals for all parameters that average
over the uncertainty in the random effects parameters
(Gelman and Hill 2006, McElreath 2015;
<a href="https://CRAN.R-project.org/package=MCMCglmm"><span class="pkg">MCMCglmm</span></a>, <a href="https://CRAN.R-project.org/package=rstanarm"><span class="pkg">rstanarm</span></a> and <a href="https://CRAN.R-project.org/package=brms"><span class="pkg">brms</span></a> packages)
</p>
</li></ul>



<h3>Value</h3>

<p>a logical value
</p>


<h3>References</h3>

<p>Dale J. Barr, Roger Levy, Christoph Scheepers, and Harry J. Tily (2013).
Random effects structure for confirmatory hypothesis testing: Keep it maximal;
<em>Journal of Memory and Language</em> <b>68</b>(3), 255&ndash;278.
</p>
<p>Douglas Bates, Reinhold Kliegl, Shravan Vasishth, and Harald Baayen (2015).
<em>Parsimonious Mixed Models</em>; preprint (<a href="https://arxiv.org/abs/1506.04967">https://arxiv.org/abs/1506.04967</a>).
</p>
<p>Yeojin Chung, Sophia Rabe-Hesketh, Vincent Dorie, Andrew Gelman, and Jingchen Liu (2013).
A nondegenerate penalized likelihood estimator for variance parameters in multilevel models;
<em>Psychometrika</em> <b>78</b>, 685&ndash;709; <a href="https://doi.org/10.1007/S11336-013-9328-2">doi:10.1007/S11336-013-9328-2</a>.
</p>
<p>Andrew Gelman and Jennifer Hill (2006).
<em>Data Analysis Using Regression and Multilevel/Hierarchical Models</em>.
Cambridge University Press.
</p>
<p>Hannes Matuschek, Reinhold Kliegl, Shravan Vasishth, Harald Baayen, and Douglas Bates (2017).
Balancing type I error and power in linear mixed models.
<em>Journal of Memory and Language</em> <b>94</b>, 305315.
</p>
<p>Richard McElreath (2015)
<em>Statistical Rethinking: A Bayesian Course with Examples in R and Stan</em>.
Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getME">getME</a></code>, <code><a href="#topic+rePCA">rePCA</a></code></p>

<hr>
<h2 id='lme4_testlevel'>Detect testing level for lme4 examples and tests</h2><span id='topic+lme4_testlevel'></span>

<h3>Description</h3>

<p>Reads the environment variable <code>LME4_TEST_LEVEL</code> to determine
which tests and examples to run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lme4_testlevel()
</code></pre>


<h3>Value</h3>

<p>a numeric value: 1 for standard/'light' testing, larger values for
more testing. Defaults to 1 if the environment variable is not set.
</p>

<hr>
<h2 id='lmer'>Fit Linear Mixed-Effects Models</h2><span id='topic+lmer'></span>

<h3>Description</h3>

<p>Fit a linear mixed-effects model (LMM) to data, via REML or maximum
likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmer(formula, data = NULL, REML = TRUE, control = lmerControl(),
     start = NULL, verbose = 0L, subset, weights, na.action,
     offset, contrasts = NULL, devFunOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmer_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object describing both the
fixed-effects and random-effects part of the model, with the
response on the left of a <code>~</code> operator and the terms, separated
by <code>+</code> operators, on the right.  Random-effects terms are
distinguished by vertical bars (<code>|</code>) separating expressions
for design matrices from grouping factors.  Two vertical bars
(<code>||</code>) can be used to specify multiple uncorrelated random
effects for the same grouping variable. 
(Because of the way it is implemented, the <code>||</code>-syntax <em>works
only for design matrices containing numeric (continuous) predictors</em>;
to fit models with independent categorical effects, see <code><a href="#topic+dummy">dummy</a></code>
or the <code>lmer_alt</code> function from the <a href="https://CRAN.R-project.org/package=afex"><span class="pkg">afex</span></a> package.)
</p>
</td></tr>
<tr><td><code id="lmer_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>formula</code>.  By default the variables are taken from the
environment from which <code>lmer</code> is called. While <code>data</code> is
optional, the package authors <em>strongly</em> recommend its use,
especially when later applying methods such as <code>update</code> and
<code>drop1</code> to the fitted model (<em>such methods are not
guaranteed to work properly if <code>data</code> is omitted</em>). If
<code>data</code> is omitted, variables will be taken from the environment
of <code>formula</code> (if specified as a formula) or from the parent
frame (if specified as a character vector).</p>
</td></tr>
<tr><td><code id="lmer_+3A_reml">REML</code></td>
<td>
<p>logical scalar - Should the estimates be chosen to
optimize the REML criterion (as opposed to the log-likelihood)?</p>
</td></tr>
<tr><td><code id="lmer_+3A_control">control</code></td>
<td>
<p>a list (of correct class, resulting from
<code><a href="#topic+lmerControl">lmerControl</a>()</code> or <code><a href="#topic+glmerControl">glmerControl</a>()</code>
respectively) containing control parameters, including the nonlinear
optimizer to be used and parameters to be passed through to the
nonlinear optimizer, see the <code>*lmerControl</code> documentation for
details.</p>
</td></tr>
<tr><td><code id="lmer_+3A_start">start</code></td>
<td>
<p>a named <code><a href="base.html#topic+list">list</a></code> of starting values for the
parameters in the model.  For <code>lmer</code> this can be a numeric
vector or a list with one component named <code>"theta"</code>.</p>
</td></tr>
<tr><td><code id="lmer_+3A_verbose">verbose</code></td>
<td>
<p>integer scalar.  If <code>&gt; 0</code> verbose output is
generated during the optimization of the parameter estimates.  If
<code>&gt; 1</code> verbose output is generated during the individual
penalized iteratively reweighted least squares (PIRLS) steps.</p>
</td></tr>
<tr><td><code id="lmer_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows
of <code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a character vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="lmer_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.
Prior <code>weights</code> are <em>not</em> normalized or standardized in
any way.  In particular, the diagonal of the residual covariance
matrix is the squared residual standard deviation parameter
<code><a href="#topic+sigma">sigma</a></code> times the vector of inverse <code>weights</code>.
Therefore, if the <code>weights</code> have relatively large magnitudes,
then in order to compensate, the <code><a href="#topic+sigma">sigma</a></code> parameter will
also need to have a relatively large magnitude.</p>
</td></tr>
<tr><td><code id="lmer_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.omit</code>,
inherited from the 'factory fresh' value of
<code>getOption("na.action")</code>) strips any observations with any
missing values in any variables.</p>
</td></tr>
<tr><td><code id="lmer_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See
<code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="lmer_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="lmer_+3A_devfunonly">devFunOnly</code></td>
<td>
<p>logical - return only the deviance evaluation
function. Note that because the deviance function operates on
variables stored in its environment, it may not return
<em>exactly</em> the same values on subsequent calls (but the results
should always be within machine tolerance).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>If the <code>formula</code> argument is specified as a character
vector, the function will attempt to coerce it to a formula.
However, this is not recommended (users who want to construct
formulas by pasting together components are advised to use
<code><a href="stats.html#topic+as.formula">as.formula</a></code> or <code><a href="stats.html#topic+reformulate">reformulate</a></code>); model fits
will work but subsequent methods such as <code><a href="stats.html#topic+drop1">drop1</a></code>,
<code><a href="stats.html#topic+update">update</a></code> may fail.
</p>
</li>
<li><p>When handling perfectly collinear predictor variables
(i.e. design matrices of less than full rank),
<code>[gn]lmer</code> is not quite as sophisticated
as some simpler modeling frameworks such as
<code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+glm">glm</a></code>. While it does
automatically drop collinear variables (with a message
rather than a warning), it does not automatically fill
in <code>NA</code> values for the dropped coefficients;
these can be added via
<code>fixef(fitted.model,add.dropped=TRUE)</code>.
This information can also be retrieved via
<code>attr(getME(fitted.model,"X"),"col.dropped")</code>.

</p>
</li>
<li><p>the deviance function returned when <code>devFunOnly</code> is
<code>TRUE</code> takes a single numeric vector argument, representing
the <code>theta</code> vector.  This vector defines the scaled
variance-covariance matrices of the random effects, in the
Cholesky parameterization.  For models with only simple
(intercept-only) random effects, <code>theta</code> is a vector of the
standard deviations of the random effects.  For more complex or
multiple random effects, running <code>getME(.,"theta")</code> to
retrieve the <code>theta</code> vector for a fitted model and examining
the names of the vector is probably the easiest way to determine
the correspondence between the elements of the <code>theta</code> vector
and elements of the lower triangles of the Cholesky factors of the
random effects.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code><a href="#topic+merMod-class">merMod</a></code> (more specifically,
an object of <em>subclass</em> <code>lmerMod</code>), for which many methods
are available (e.g. <code>methods(class="merMod")</code>)
</p>


<h3>Note</h3>

<p>In earlier version of the <span class="pkg">lme4</span> package, a <code>method</code> argument was
used.  Its functionality has been replaced by the <code>REML</code> argument.
</p>
<p>Also, <code>lmer(.)</code> allowed a <code>family</code> argument (to effectively
switch to <code>glmer(.)</code>).  This has been deprecated in summer 2013,
and been disabled in spring 2019.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code> for linear models;
<code><a href="#topic+glmer">glmer</a></code> for generalized linear; and
<code><a href="#topic+nlmer">nlmer</a></code> for nonlinear mixed models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## linear mixed models - reference values from older code
(fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy))
summary(fm1)# (with its own print method; see class?merMod % ./merMod-class.Rd

str(terms(fm1))
stopifnot(identical(terms(fm1, fixed.only=FALSE),
                    terms(model.frame(fm1))))
attr(terms(fm1, FALSE), "dataClasses") # fixed.only=FALSE needed for dataCl.

## Maximum Likelihood (ML), and "monitor" iterations via 'verbose':
fm1_ML &lt;- update(fm1, REML=FALSE, verbose = 1)
(fm2 &lt;- lmer(Reaction ~ Days + (Days || Subject), sleepstudy))
anova(fm1, fm2)
sm2 &lt;- summary(fm2)
print(fm2, digits=7, ranef.comp="Var") # the print.merMod()         method
print(sm2, digits=3, corr=FALSE)       # the print.summary.merMod() method

## Fit sex-specific variances by constructing numeric dummy variables
## for sex and sex:age; in this case the estimated variance differences
## between groups in both intercept and slope are zero ...
data(Orthodont,package="nlme")
Orthodont$nsex &lt;- as.numeric(Orthodont$Sex=="Male")
Orthodont$nsexage &lt;- with(Orthodont, nsex*age)
lmer(distance ~ age + (age|Subject) + (0+nsex|Subject) +
     (0 + nsexage|Subject), data=Orthodont)
</code></pre>

<hr>
<h2 id='lmerControl'>Control of Mixed Model Fitting</h2><span id='topic+glmerControl'></span><span id='topic+lmerControl'></span><span id='topic+nlmerControl'></span><span id='topic+.makeCC'></span>

<h3>Description</h3>

<p>Construct control structures for mixed model fitting.  All arguments
have defaults, and can be grouped into
</p>

<ul>
<li><p> general control parameters, most importantly <code>optimizer</code>,
further <code>restart_edge</code>, etc;
</p>
</li>
<li><p> model- or data-checking specifications, in short
&ldquo;checking options&rdquo;, such as <code>check.nobs.vs.rankZ</code>, or
<code>check.rankX</code> (currently not for <code>nlmerControl</code>);
</p>
</li>
<li><p> all the parameters to be passed to the optimizer, e.g.,
maximal number of iterations, passed via the <code>optCtrl</code> list
argument.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>lmerControl(optimizer = "nloptwrap",
				    
    restart_edge = TRUE,
    boundary.tol = 1e-5,
    calc.derivs = TRUE,
    use.last.params = FALSE,
    sparseX = FALSE,
    standardize.X = FALSE,
    ## input checking options
    check.nobs.vs.rankZ = "ignore",
    check.nobs.vs.nlev = "stop",
    check.nlev.gtreq.5 = "ignore",
    check.nlev.gtr.1 = "stop",
    check.nobs.vs.nRE= "stop",
    check.rankX = c("message+drop.cols", "silent.drop.cols", "warn+drop.cols",
                    "stop.deficient", "ignore"),
    check.scaleX = c("warning","stop","silent.rescale",
                     "message+rescale","warn+rescale","ignore"),
    check.formula.LHS = "stop",
    ## convergence checking options
    check.conv.grad     = .makeCC("warning", tol = 2e-3, relTol = NULL),
    check.conv.singular = .makeCC(action = "message", tol = formals(isSingular)$tol),
    check.conv.hess     = .makeCC(action = "warning", tol = 1e-6),
    ## optimizer args
    optCtrl = list(),
    mod.type = "lmer"
)

glmerControl(optimizer = c("bobyqa", "Nelder_Mead"),
    restart_edge = FALSE,
    boundary.tol = 1e-5,
    calc.derivs = TRUE,
    use.last.params = FALSE,
    sparseX = FALSE,
    standardize.X = FALSE,
    ## input checking options
    check.nobs.vs.rankZ = "ignore",
    check.nobs.vs.nlev = "stop",
    check.nlev.gtreq.5 = "ignore",
    check.nlev.gtr.1 = "stop",
    check.nobs.vs.nRE= "stop",
    check.rankX = c("message+drop.cols", "silent.drop.cols", "warn+drop.cols",
                    "stop.deficient", "ignore"),
    check.scaleX = c("warning","stop","silent.rescale",
                     "message+rescale","warn+rescale","ignore"),
    check.formula.LHS = "stop",
    ## convergence checking options
    check.conv.grad     = .makeCC("warning", tol = 2e-3, relTol = NULL),
    check.conv.singular = .makeCC(action = "message", tol = formals(isSingular)$tol),
    check.conv.hess     = .makeCC(action = "warning", tol = 1e-6),
    ## optimizer args
    optCtrl = list(),
    mod.type = "glmer",
    tolPwrss = 1e-7,
    compDev = TRUE,
    nAGQ0initStep = TRUE,
    check.response.not.const = "stop"
 )

nlmerControl(optimizer = "Nelder_Mead", tolPwrss = 1e-10,
             optCtrl = list())

.makeCC(action, tol, relTol, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmerControl_+3A_optimizer">optimizer</code></td>
<td>
<p>character - name of optimizing function(s).  A
<code><a href="base.html#topic+character">character</a></code> vector or list of functions: length 1 for
<code>lmer</code> or <code>glmer</code>, possibly length 2 for <code>glmer</code>).
Built-in optimizers are <code>"<a href="#topic+Nelder_Mead">Nelder_Mead</a>"</code>,
<code>"<a href="minqa.html#topic+bobyqa">bobyqa</a>"</code> (from the <a href="https://CRAN.R-project.org/package=minqa"><span class="pkg">minqa</span></a> package),
<code>"<a href="#topic+nlminbwrap">nlminbwrap</a>"</code> (using base <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+nlminb">nlminb</a></code>) and the
default for <code>lmerControl()</code>, <code>"<a href="#topic+nloptwrap">nloptwrap</a>"</code>.  Any
minimizing function that allows box constraints can be used provided
that it
</p>

<dl>
<dt>(1)</dt><dd><p>takes input parameters <code>fn</code> (function to be
optimized), <code>par</code> (starting parameter values), <code>lower</code>
and <code>upper</code> (parameter bounds)
and <code>control</code> (control parameters, passed
through from the <code>control</code> argument) and</p>
</dd>
<dt>(2)</dt><dd><p>returns a list with (at least) elements <code>par</code>
(best-fit parameters), <code>fval</code> (best-fit function value),
<code>conv</code> (convergence code, equal to zero for
successful convergence) and (optionally) <code>message</code>
(informational message, or explanation of convergence failure).</p>
</dd>
</dl>

<p>Special provisions are made for <code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>,
<code><a href="#topic+Nelder_Mead">Nelder_Mead</a></code>, and optimizers wrapped in the
<a href="https://CRAN.R-project.org/package=optimx"><span class="pkg">optimx</span></a> package; to use the <span class="pkg">optimx</span> optimizers (including
<code>L-BFGS-B</code> from base <code><a href="stats.html#topic+optim">optim</a></code> and
<code><a href="stats.html#topic+nlminb">nlminb</a></code>), pass the <code>method</code> argument to
<code>optim</code> in the <code>optCtrl</code> argument (you may
need to load the <span class="pkg">optimx</span> package manually using
<code><a href="base.html#topic+library">library</a>(optimx)</code>).
</p>
<p>For <code>glmer</code>, if <code>length(optimizer)==2</code>, the first element
will be used for the preliminary (random effects parameters only)
optimization, while the second will be used for the final (random
effects plus fixed effect parameters) phase.  See
<code><a href="#topic+modular">modular</a></code> for more information on these two phases.
</p>
<p>If <code>optimizer</code> is <code>NULL</code> (at present for <code>lmer</code> only),
all of the model structures will be set up, but no optimization will
be done (e.g. parameters will all be returned as <code>NA</code>).
</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_calc.derivs">calc.derivs</code></td>
<td>
<p>logical - compute gradient and Hessian of nonlinear
optimization solution?</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_use.last.params">use.last.params</code></td>
<td>
<p>logical - should the last value of the
parameters evaluated (<code>TRUE</code>), rather than the value of the
parameters corresponding to the minimum deviance, be returned?
This is a &quot;backward bug-compatibility&quot; option; use <code>TRUE</code>
only when trying to match previous results.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_sparsex">sparseX</code></td>
<td>
<p>logical - should a sparse model matrix be
used for the fixed-effects terms?
Currently inactive.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_restart_edge">restart_edge</code></td>
<td>
<p>logical - should the optimizer
attempt a restart when it finds a solution at the
boundary (i.e. zero random-effect variances or perfect
+/-1 correlations)?  (Currently only implemented for
<code>lmerControl</code>.)</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_boundary.tol">boundary.tol</code></td>
<td>
<p>numeric - within what distance of
a boundary should the boundary be checked for a better fit?
(Set to zero to disable boundary checking.)</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_tolpwrss">tolPwrss</code></td>
<td>
<p>numeric scalar - the tolerance for declaring
convergence in the penalized iteratively weighted residual
sum-of-squares step.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_compdev">compDev</code></td>
<td>
<p>logical scalar - should compiled code be
used for the deviance evaluation during the optimization
of the parameter estimates?</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_nagq0initstep">nAGQ0initStep</code></td>
<td>
<p>Run an initial optimization phase with
<code>nAGQ = 0</code>. While the initial optimization usually
provides a good starting point for subsequent fitting
(thus increasing overall computational speed),
setting this option to <code>FALSE</code> can be useful in cases
where the initial phase results in bad fixed-effect estimates
(seen most often in binomial models with <code>link="cloglog"</code>
and offsets).</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.nlev.gtreq.5">check.nlev.gtreq.5</code></td>
<td>
<p>character - rules for
checking whether all random effects have &gt;= 5 levels.
See <code>action</code>.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.nlev.gtr.1">check.nlev.gtr.1</code></td>
<td>
<p>character - rules for checking
whether all random effects have &gt; 1 level. See <code>action</code>.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.nobs.vs.rankz">check.nobs.vs.rankZ</code></td>
<td>
<p>character - rules for
checking whether the number of observations is greater
than (or greater than or equal to) the rank of the random
effects design matrix (Z), usually necessary for
identifiable variances.  As for <code>action</code>, with
the addition of <code>"warningSmall"</code> and <code>"stopSmall"</code>, which run
the test only if the dimensions of <code>Z</code> are &lt; 1e6.
<code>nobs &gt; rank(Z)</code> will be tested for LMMs and GLMMs with
estimated scale parameters; <code>nobs &gt;= rank(Z)</code> will be tested
for GLMMs with fixed scale parameter.
The rank test is done using the
<code>method="qr"</code> option of the <code><a href="Matrix.html#topic+rankMatrix">rankMatrix</a></code>
function.
</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.nobs.vs.nlev">check.nobs.vs.nlev</code></td>
<td>
<p> character - rules for checking whether the
number of observations is less than (or less than or equal to) the
number of levels of every grouping factor, usually necessary for
identifiable variances.  As for <code>action</code>.
<code>nobs&lt;nlevels</code> will be tested for LMMs and GLMMs with estimated
scale parameters; <code>nobs&lt;=nlevels</code> will be tested for GLMMs with
fixed scale parameter.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.nobs.vs.nre">check.nobs.vs.nRE</code></td>
<td>
<p>character - rules for
checking whether the number of observations is greater
than (or greater than or equal to) the number of random-effects
levels for each term, usually necessary for identifiable variances.
As for <code>check.nobs.vs.nlev</code>.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.conv.grad">check.conv.grad</code></td>
<td>
<p>rules for checking the gradient of the deviance
function for convergence.  A list as returned
by <code>.makeCC</code>, or a character string with only the action.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.conv.singular">check.conv.singular</code></td>
<td>
<p>rules for checking for a singular fit,
i.e. one where some parameters are on the boundary of the feasible
space (for example, random effects variances equal to 0 or
correlations between random effects equal to +/- 1.0);
as for <code>check.conv.grad</code> above.  The default is to use
<code><a href="#topic+isSingular">isSingular</a>(.., tol = *)</code>'s default.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.conv.hess">check.conv.hess</code></td>
<td>
<p>rules for checking the Hessian of the deviance
function for convergence.; as for <code>check.conv.grad</code>
above.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.rankx">check.rankX</code></td>
<td>
<p>character - specifying if <code><a href="Matrix.html#topic+rankMatrix">rankMatrix</a>(X)</code>
should be compared with <code>ncol(X)</code> and if columns from the design
matrix should possibly be dropped to ensure that it has full rank.
Sometimes needed to make the model identifiable.  The options can be
abbreviated; the three <code>"*.drop.cols"</code> options all do drop
columns, <code>"stop.deficient"</code> gives an error when the rank is
smaller than the number of columns where <code>"ignore"</code> does no
rank computation, and will typically lead to less easily
understandable errors, later.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.scalex">check.scaleX</code></td>
<td>
<p>character - check for problematic scaling of
columns of fixed-effect model matrix, e.g. parameters measured on
very different scales.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.formula.lhs">check.formula.LHS</code></td>
<td>
<p> check whether specified formula has
a left-hand side. Primarily for internal use within
<code>simulate.merMod</code>;
<em>use at your own risk</em> as it may allow the generation
of unstable <code>merMod</code> objects</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_check.response.not.const">check.response.not.const</code></td>
<td>
<p>character - check that the
response is not constant.</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_optctrl">optCtrl</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of additional arguments to be
passed to the nonlinear optimizer (see <code><a href="#topic+Nelder_Mead">Nelder_Mead</a></code>,
<code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>).  In particular, both
<code>Nelder_Mead</code> and <code>bobyqa</code> use <code>maxfun</code> to
specify the maximum number of function evaluations they
will try before giving up - in contrast to
<code><a href="stats.html#topic+optim">optim</a></code> and <code>optimx</code>-wrapped optimizers,
which use <code>maxit</code>. (Also see <code><a href="#topic+convergence">convergence</a></code>
for details of stopping tolerances for different optimizers.)
</p>
<p><em>Note:</em> All of <code><a href="#topic+lmer">lmer</a>()</code>, <code><a href="#topic+glmer">glmer</a>()</code> and
<code><a href="#topic+nlmer">nlmer</a>()</code> have an optional integer argument <code>verbose</code>
which you should raise (to a positive value) in order to get diagnostic
console output about the optimization progress.
</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_action">action</code></td>
<td>
<p>character - generic choices for the severity level
of any test, with possible values </p>

<dl>
<dt>&quot;ignore&quot;:</dt><dd><p>skip the test.</p>
</dd>
<dt>&quot;warning&quot;:</dt><dd><p>warn if test fails.</p>
</dd>
<dt>&quot;message&quot;:</dt><dd><p>print a message if test fails.</p>
</dd>
<dt>&quot;stop&quot;:</dt><dd><p>throw an error if test fails.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="lmerControl_+3A_tol">tol</code></td>
<td>
<p>(numeric) tolerance for checking the gradient, scaled
relative to the curvature (i.e., testing the gradient on a scale
defined by its Wald standard deviation)</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_reltol">relTol</code></td>
<td>
<p>(numeric) tolerance for the gradient, scaled
relative to the magnitude of the estimated coefficient</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_mod.type">mod.type</code></td>
<td>
<p>model type (for internal use)</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_standardize.x">standardize.X</code></td>
<td>
<p>scale columns of X matrix? (not yet implemented)</p>
</td></tr>
<tr><td><code id="lmerControl_+3A_...">...</code></td>
<td>
<p>other elements to include in check specification</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that (only!) the pre-fitting &ldquo;checking options&rdquo;
(i.e., all those starting with <code>"check."</code> but <em>not</em>
including the convergence checks (<code>"check.conv.*"</code>) or
rank-checking (<code>"check.rank*"</code>) options)
may also be set globally via <code><a href="base.html#topic+options">options</a></code>.
In that case, <code>(g)lmerControl</code> will use them rather than the
default values, but will <em>not</em> override values that are passed as
explicit arguments.
</p>
<p>For example, <code>options(lmerControl=list(check.nobs.vs.rankZ = "ignore"))</code>
will suppress warnings that the number of observations is less than
the rank of the random effects model matrix <code>Z</code>.
</p>


<h3>Value</h3>

<p>The <code>*Control</code> functions return a list (inheriting from class
<code>"merControl"</code>) containing
</p>

<ol>
<li><p> general control parameters, such as <code>optimizer</code>, <code>restart_edge</code>;
</p>
</li>
<li><p> (currently not for <code>nlmerControl</code>:)
<code>"checkControl"</code>, a <code><a href="base.html#topic+list">list</a></code> of data-checking
specifications, e.g., <code>check.nobs.vs.rankZ</code>;
</p>
</li>
<li><p> parameters to be passed to the optimizer, i.e., the <code>optCtrl</code>
list, which may contain <code>maxiter</code>.
</p>
</li></ol>

<p><code>.makeCC</code> returns a list containing the check specification
(action, tolerance, and optionally relative tolerance).
</p>


<h3>See Also</h3>

<p><a href="#topic+convergence">convergence</a> and <code><a href="#topic+allFit">allFit</a>()</code> which fits
for a couple of optimizers;
<code><a href="#topic+nloptwrap">nloptwrap</a></code> for the <code>lmerControl()</code> default optimizer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(lmerControl())
str(glmerControl())
## fit with default algorithm [nloptr version of BOBYQA] ...
fm0 &lt;- lmer(Reaction ~ Days +   ( 1 | Subject), sleepstudy)
fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
## or with "bobyqa" (default 2013 - 2019-02) ...
fm1_bobyqa &lt;- update(fm1, control = lmerControl(optimizer="bobyqa"))
## or with "Nelder_Mead" (the default till 2013) ...
fm1_NMead &lt;- update(fm1, control = lmerControl(optimizer="Nelder_Mead"))
## or with the nlminb function used in older (&lt;1.0) versions of lme4;
## this will usually replicate older results
if (require(optimx)) {
    fm1_nlminb &lt;- update(fm1,
                         control = lmerControl(optimizer= "optimx",
                                               optCtrl  = list(method="nlminb")))
    ## The other option here is method="L-BFGS-B".
}

## Or we can wrap base::optim():
optimwrap &lt;- function(fn,par,lower,upper,control=list(),
                      ...) {
    if (is.null(control$method)) stop("must specify method in optCtrl")
    method &lt;- control$method
    control$method &lt;- NULL
    ## "Brent" requires finite upper values (lower bound will always
    ##  be zero in this case)
    if (method=="Brent") upper &lt;- pmin(1e4,upper)
    res &lt;- optim(par=par, fn=fn, lower=lower,upper=upper,
                 control=control,method=method,...)
    with(res, list(par  = par,
                   fval = value,
                   feval= counts[1],
                   conv = convergence,
                   message = message))
}
fm0_brent &lt;- update(fm0,
                    control = lmerControl(optimizer = "optimwrap",
                                          optCtrl = list(method="Brent")))

## You can also use functions (in addition to the lmerControl() default "NLOPT_BOBYQA")
## from the 'nloptr' package, see also  '?nloptwrap' :
if (require(nloptr)) {
    fm1_nloptr_NM &lt;- update(fm1, control=lmerControl(optimizer="nloptwrap",
                                      optCtrl=list(algorithm="NLOPT_LN_NELDERMEAD")))
    fm1_nloptr_COBYLA &lt;- update(fm1, control=lmerControl(optimizer="nloptwrap",
                                      optCtrl=list(algorithm="NLOPT_LN_COBYLA",
                                                   xtol_rel=1e-6,
                                                   xtol_abs=1e-10,
                                                   ftol_abs=1e-10)))
}
## other algorithm options include NLOPT_LN_SBPLX
</code></pre>

<hr>
<h2 id='lmList'>Fit List of lm or glm Objects with a Common Model</h2><span id='topic+lmList'></span><span id='topic+plot.lmList'></span>

<h3>Description</h3>

<p>Fit a list of <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> objects with a
common model for different subgroups of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmList(formula, data, family, subset, weights, na.action,
       offset, pool = !isGLM || .hasScale(family2char(family)),
       warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmList_+3A_formula">formula</code></td>
<td>
<p>a linear <code><a href="stats.html#topic+formula">formula</a></code> object of the form
<code>y ~ x1+...+xn | g</code>.  In the formula object, <code>y</code>
represents the response, <code>x1,...,xn</code> the covariates,
and <code>g</code> the grouping factor specifying the
partitioning of the data according to which different
<code>lm</code> fits should be performed.</p>
</td></tr>
<tr><td><code id="lmList_+3A_family">family</code></td>
<td>
<p>an optional <code><a href="stats.html#topic+family">family</a></code> specification for a
generalized linear model (<code><a href="stats.html#topic+glm">glm</a></code>).</p>
</td></tr>
<tr><td><code id="lmList_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the
variables named in <code>formula</code>.  By default the
variables are taken from the environment from which
<code>lmer</code> is called.  See Details.</p>
</td></tr>
<tr><td><code id="lmList_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the
subset of the rows of <code>data</code> that should be used in
the fit.  This can be a logical vector, or a numeric
vector indicating which observation numbers are to be
included, or a character vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="lmList_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior
weights&rsquo; to be used in the fitting process.  Should be
<code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="lmList_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should
happen when the data contain <code>NA</code>s.  The default
action (<code>na.omit</code>, inherited from the &lsquo;factory
fresh&rsquo; value of <code>getOption("na.action")</code>) strips any
observations with any missing values in any variables.</p>
</td></tr>
<tr><td><code id="lmList_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a
priori</em> known component to be included in the linear
predictor during fitting.  This should be <code>NULL</code> or a
numeric vector of length equal to the number of cases.
One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be included in
the formula instead or as well, and if more than one is
specified their sum is used.  See
<code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="lmList_+3A_pool">pool</code></td>
<td>
<p>logical scalar indicating if the variance estimate should
pool the residual sums of squares.  By default true if the model has
a scale parameter (which includes all linear, <code><a href="#topic+lmer">lmer</a>()</code>, ones).</p>
</td></tr>
<tr><td><code id="lmList_+3A_warn">warn</code></td>
<td>
<p>indicating if errors in the single fits should signal a
&ldquo;summary&rdquo; <code><a href="base.html#topic+warning">warning</a></code>.</p>
</td></tr>
<tr><td><code id="lmList_+3A_...">...</code></td>
<td>
<p>additional, optional arguments to be passed to
the model function or family evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> While <code>data</code> is optional, the package authors
<em>strongly</em> recommend its use, especially when later applying
methods such as <code>update</code> and <code>drop1</code> to the fitted model
(<em>such methods are not guaranteed to work properly if
<code>data</code> is omitted</em>).  If <code>data</code> is omitted, variables will
be taken from the environment of <code>formula</code> (if specified as a
formula) or from the parent frame (if specified as a character vector).
</p>
</li>
<li><p> Since <span class="pkg">lme4</span> version 1.1-16, if there are errors (see
<code><a href="base.html#topic+stop">stop</a></code>) in the single (<code>lm()</code> or <code>glm()</code>)
fits, they are summarized to a warning message which is returned as
attribute <code>"warnMessage"</code> and signalled as <code><a href="base.html#topic+warning">warning</a>()</code>
when the <code>warn</code> argument is true.
</p>
<p>In previous <span class="pkg">lme4</span> versions, a general (different) warning had
been signalled in this case.
</p>
</li></ul>



<h3>Value</h3>

<p>an object of <code><a href="base.html#topic+class">class</a></code> <code><a href="#topic+lmList4-class">lmList4</a></code> (see
there, notably for the <code><a href="utils.html#topic+methods">methods</a></code> defined).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList4-class">lmList4</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm.plm  &lt;- lmList(Reaction ~ Days | Subject, sleepstudy)
coef(fm.plm)
fm.2  &lt;- update(fm.plm, pool = FALSE)
## coefficients are the same, "pooled or unpooled":
stopifnot( all.equal(coef(fm.2), coef(fm.plm)) )

(ci &lt;- confint(fm.plm)) # print and rather *see* :
plot(ci)                # how widely they vary for the individuals
</code></pre>

<hr>
<h2 id='lmList4-class'>Class &quot;lmList4&quot; of 'lm' Objects on Common Model</h2><span id='topic+lmList4-class'></span><span id='topic+show+2ClmList4-method'></span>

<h3>Description</h3>

<p>Class <code>"lmList4"</code> is an S4 class with basically a
<code><a href="base.html#topic+list">list</a></code> of objects of class <code><a href="stats.html#topic+lm">lm</a></code> with a common
model (but different data); see <code><a href="#topic+lmList">lmList</a>()</code> which returns
these.
</p>
<p>Package <span class="pkg">nlme</span>'s <code><a href="nlme.html#topic+lmList">lmList</a>()</code> returns objects of
S3 class <code>"lmList"</code> and provides methods for them, on which our
methods partly build.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("lmList4", ...)</code> or, more commonly, by a call to
<code><a href="#topic+lmList">lmList</a>()</code>.
</p>


<h3>Methods</h3>

<p>A dozen <code><a href="utils.html#topic+methods">methods</a></code> are provided.  Currently, S4
methods for <code><a href="methods.html#topic+show">show</a></code>, coercion (<code><a href="methods.html#topic+as">as</a>(.,.)</code>) and
others inherited via <code>"list"</code>,  and S3 methods for
<code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>,
<code><a href="#topic+fixef">fixef</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="graphics.html#topic+pairs">pairs</a></code>, <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>,
<code><a href="base.html#topic+print">print</a></code>, <code><a href="stats.html#topic+qqnorm">qqnorm</a></code>, <code><a href="#topic+ranef">ranef</a></code>,
<code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="#topic+sigma">sigma</a></code>, <code><a href="base.html#topic+summary">summary</a></code>,
and <code><a href="stats.html#topic+update">update</a></code>.
</p>

<dl>
<dt>sigma(object)</dt><dd><p>returns the standard deviation
<code class="reqn">\hat{\sigma}</code> (of the errors in the linear models), assuming a
<em>common</em> variance <code class="reqn">\sigma^2</code> by pooling (even when
<code>pool = FALSE</code> was used in the fit).</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.2.0") {
  (mm &lt;- methods(class = "lmList4"))
  ## The S3 ("not S4") ones :
  mm[!attr(mm,"info")[,"isS4"]]
}
## For more examples:  example(lmList)  i.e., ?lmList
</code></pre>

<hr>
<h2 id='lmResp'>Generator objects for the response classes</h2><span id='topic+glmResp'></span><span id='topic+lmerResp'></span><span id='topic+lmResp'></span><span id='topic+nlsResp'></span>

<h3>Description</h3>

<p>The generator objects for the
<code><a href="#topic+lmResp-class">lmResp</a></code>,
<code><a href="#topic+lmerResp-class">lmerResp</a></code>,
<code><a href="#topic+glmResp-class">glmResp</a></code> and
<code><a href="#topic+nlsResp-class">nlsResp</a></code> reference classes. Such
objects are primarily used through their <code>new</code>
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lmResp(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmResp_+3A_...">...</code></td>
<td>
<p>List of arguments (see Note).</p>
</td></tr>
</table>


<h3>Methods</h3>

 <dl>
<dt><code>new(y=y)</code>:</dt><dd><p>Create a new
<code><a href="#topic+lmResp-class">lmResp</a></code> or
<code><a href="#topic+lmerResp-class">lmerResp</a></code> object.</p>
</dd>
<dt><code>new(family=family, y=y)</code>:</dt><dd><p>Create a new
<code><a href="#topic+glmResp-class">glmResp</a></code> object.</p>
</dd>
<dt><code>new(y=y, nlmod=nlmod, nlenv=nlenv,
	pnames=pnames, gam=gam)</code>:</dt><dd><p>Create a new
<code><a href="#topic+nlsResp-class">nlsResp</a></code> object.</p>
</dd> </dl>



<h3>Note</h3>

<p>Arguments to the <code>new</code> methods must be named
arguments.
</p>

<dl>
<dt>y</dt><dd><p> the numeric response vector</p>
</dd>
<dt>family</dt><dd><p> a <code><a href="stats.html#topic+family">family</a></code> object</p>
</dd>
<dt>nlmod</dt><dd><p> the nonlinear model function</p>
</dd>
<dt>nlenv</dt><dd><p> an environment holding data objects for evaluation of
<code>nlmod</code></p>
</dd> 
<dt>pnames</dt><dd><p> a character vector of parameter names</p>
</dd>
<dt>gam</dt><dd><p> a numeric vector - the initial linear predictor</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+lmResp-class">lmResp</a></code>,
<code><a href="#topic+lmerResp-class">lmerResp</a></code>,
<code><a href="#topic+glmResp-class">glmResp</a></code>,
<code><a href="#topic+nlsResp-class">nlsResp</a></code>
</p>

<hr>
<h2 id='lmResp-class'>Reference Classes for Response Modules, <code>"(lm|glm|nls|lmer)Resp"</code></h2><span id='topic+glmResp-class'></span><span id='topic+lmerResp-class'></span><span id='topic+lmResp-class'></span><span id='topic+nlsResp-class'></span>

<h3>Description</h3>

<p>Reference classes for response modules, including linear
models, <code>"lmResp"</code>, generalized linear models,
<code>"glmResp"</code>, nonlinear models, <code>"nlsResp"</code> and
linear mixed-effects models, <code>"lmerResp"</code>. Each
reference class is associated with a C++ class of the
same name.  As is customary, the generator object for
each class has the same name as the class.
</p>


<h3>Extends</h3>

<p>All reference classes extend and inherit methods from
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.  Furthermore,
<code>"glmResp"</code>, <code>"nlsResp"</code> and <code>"lmerResp"</code>
all extend the <code>"lmResp"</code> class.
</p>


<h3>Note</h3>

<p>Objects from these reference classes correspond to
objects in C++ classes.  Methods are invoked on the C++
classes using the external pointer in the <code>ptr</code>
field.  When saving such an object the external pointer
is converted to a null pointer, which is why there are
redundant fields containing enough information as R
objects to be able to regenerate the C++ object.  The
convention is that a field whose name begins with an
upper-case letter is an R object and the corresponding
field whose name begins with the lower-case letter is a
method.  Access to the external pointer should be through
the method, not through the field.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmer">lmer</a></code>, <code><a href="#topic+glmer">glmer</a></code>,
<code><a href="#topic+nlmer">nlmer</a></code>, <code><a href="#topic+merMod-class">merMod</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("lmResp")
str(lmResp$new(y=1:4))
showClass("glmResp")
str(glmResp$new(family=poisson(), y=1:4))
showClass("nlsResp")
showClass("lmerResp")
str(lmerResp$new(y=1:4))
</code></pre>

<hr>
<h2 id='merMod-class'>Class &quot;merMod&quot; of Fitted Mixed-Effect Models</h2><span id='topic+anova.merMod'></span><span id='topic+as.function.merMod'></span><span id='topic+coef.merMod'></span><span id='topic+deviance.merMod'></span><span id='topic+df.residual.merMod'></span><span id='topic+extractAIC.merMod'></span><span id='topic+family.merMod'></span><span id='topic+fitted.merMod'></span><span id='topic+formula.merMod'></span><span id='topic+glmerMod-class'></span><span id='topic+lmerMod-class'></span><span id='topic+logLik.merMod'></span><span id='topic+merMod'></span><span id='topic+merMod-class'></span><span id='topic+model.frame.merMod'></span><span id='topic+model.matrix.merMod'></span><span id='topic+ngrps.merMod'></span><span id='topic+nobs.merMod'></span><span id='topic+nobs'></span><span id='topic+nlmerMod-class'></span><span id='topic+print.merMod'></span><span id='topic+print.summary.merMod'></span><span id='topic+show+2CmerMod-method'></span><span id='topic+show.merMod'></span><span id='topic+show.summary.merMod'></span><span id='topic+summary.merMod'></span><span id='topic+summary.summary.merMod'></span><span id='topic+terms.merMod'></span><span id='topic+update.merMod'></span><span id='topic+weights.merMod'></span><span id='topic+REMLcrit'></span>

<h3>Description</h3>

<p>A mixed-effects model is represented as a
<code><a href="#topic+merPredD-class">merPredD</a></code> object and a response
module of a class that inherits from class
<code><a href="#topic+lmResp-class">lmResp</a></code>.  A model with a
<code><a href="#topic+lmerResp-class">lmerResp</a></code> response has class <code>lmerMod</code>; a
<code><a href="#topic+glmResp-class">glmResp</a></code> response has class <code>glmerMod</code>; and a
<code><a href="#topic+nlsResp-class">nlsResp</a></code> response has class <code>nlmerMod</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
anova(object, ..., refit = TRUE, model.names=NULL)
## S3 method for class 'merMod'
as.function(x, ...)
## S3 method for class 'merMod'
coef(object, ...)
## S3 method for class 'merMod'
deviance(object, REML = NULL, ...)
REMLcrit(object)
## S3 method for class 'merMod'
extractAIC(fit, scale = 0, k = 2, ...)
## S3 method for class 'merMod'
family(object, ...)
## S3 method for class 'merMod'
formula(x, fixed.only = FALSE, random.only = FALSE, ...)
## S3 method for class 'merMod'
fitted(object, ...)
## S3 method for class 'merMod'
logLik(object, REML = NULL, ...)
## S3 method for class 'merMod'
nobs(object, ...)
## S3 method for class 'merMod'
ngrps(object, ...)
## S3 method for class 'merMod'
terms(x, fixed.only = TRUE, random.only = FALSE, ...)
## S3 method for class 'merMod'
model.frame(formula, fixed.only = FALSE, ...)
## S3 method for class 'merMod'
model.matrix(object, type = c("fixed", "random", "randomListRaw"), ...)
## S3 method for class 'merMod'
print(x, digits = max(3, getOption("digits") - 3),
      correlation = NULL, symbolic.cor = FALSE,
      signif.stars = getOption("show.signif.stars"), 
      ranef.comp = "Std.Dev.",
      ranef.corr = any(ranef.comp == "Std.Dev."), ...)

## S3 method for class 'merMod'
summary(object, correlation = , use.hessian = NULL, ...)
## S3 method for class 'summary.merMod'
print(x, digits = max(3, getOption("digits") - 3),
      correlation = NULL, symbolic.cor = FALSE,
      signif.stars = getOption("show.signif.stars"),
      ranef.comp = c("Variance", "Std.Dev."),
      ranef.corr = any(ranef.comp == "Std.Dev."), show.resids = TRUE, ...)
## S3 method for class 'merMod'
update(object, formula., ..., evaluate = TRUE)
## S3 method for class 'merMod'
weights(object, type = c("prior", "working"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merMod-class_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+merMod-class">merMod</a></code>, i.e.,
as resulting from <code><a href="#topic+lmer">lmer</a>()</code>, or <code><a href="#topic+glmer">glmer</a>()</code>,
etc.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>merMod</code> or <code>summary.merMod</code>,
respectively, the latter resulting from <code>summary(&lt;merMod&gt;)</code>.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_fit">fit</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+merMod-class">merMod</a></code>.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_formula">formula</code></td>
<td>
<p>in the case of <code>model.frame</code>, a
<code><a href="#topic+merMod-class">merMod</a></code> object.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_refit">refit</code></td>
<td>
<p>logical indicating if objects of class <code>lmerMod</code> should be
refitted with ML before comparing models. The default is
<code>TRUE</code> to prevent the common mistake of inappropriately
comparing REML-fitted models with different fixed effects,
whose likelihoods are not directly comparable.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_model.names">model.names</code></td>
<td>
<p>character vectors of model names to be used in the
anova table.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_scale">scale</code></td>
<td>
<p>Not currently used (see <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>).</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_k">k</code></td>
<td>
<p>see <code><a href="stats.html#topic+extractAIC">extractAIC</a></code>.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_reml">REML</code></td>
<td>
<p>Logical. If <code>TRUE</code>, return the restricted log-likelihood
rather than the log-likelihood.  If <code>NULL</code> (the default),
set <code>REML</code> to <code>isREML(object)</code> (see <code><a href="#topic+isREML">isREML</a></code>).</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_fixed.only">fixed.only</code></td>
<td>
<p>logical indicating if only the fixed effects
components (terms or formula elements) are sought.  If false, all
components, including random ones, are returned.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_random.only">random.only</code></td>
<td>
<p>complement of <code>fixed.only</code>; indicates
whether random components only are sought. (Trying to specify
<code>fixed.only</code> and <code>random.only</code> at the same time
will produce an error.)</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_correlation">correlation</code></td>
<td>
<p>(logical)
for <code>summary.merMod</code>, indicates whether the correlation matrix
should be computed and stored along with the covariance;
for <code>print.summary.merMod</code>, indicates whether the correlation
matrix of the fixed-effects parameters should be printed.  In the
latter case, when <code>NULL</code> (the default), the correlation matrix
is printed when it has been computed by <code>summary(.)</code>, and when
<code class="reqn">p &lt;= 12</code>, and the cutoff <code>12</code> may be modified by
<code>options(lme4.summary.cor.max = &lt;n&gt;)</code>
</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_use.hessian">use.hessian</code></td>
<td>
<p>(logical) indicates whether to use the
finite-difference Hessian of the deviance function to compute
standard errors of the fixed effects; see <code><a href="#topic+vcov.merMod">vcov.merMod</a></code>
for details
</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_digits">digits</code></td>
<td>
<p>number of significant digits for printing</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>should a symbolic encoding of the fixed-effects correlation
matrix be printed?  If so, the <code><a href="stats.html#topic+symnum">symnum</a></code> function is used.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_signif.stars">signif.stars</code></td>
<td>
<p>(logical) should significance stars be used?</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_ranef.comp">ranef.comp</code></td>
<td>
<p>character vector of length one or two, indicating
if random-effects parameters should be reported on the variance and/or
standard deviation scale.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_show.resids">show.resids</code></td>
<td>
<p>should the quantiles of the scaled residuals be printed?</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_formula.">formula.</code></td>
<td>
<p>see <code><a href="stats.html#topic+update.formula">update.formula</a></code>.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_evaluate">evaluate</code></td>
<td>
<p>see <code><a href="stats.html#topic+update">update</a></code>.</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_type">type</code></td>
<td>
<p>For </p>

<dl>
<dt><code>weights()</code>, </dt><dd><p>type of weights to be returned; either <code>"prior"</code> for
the initially supplied weights or <code>"working"</code> for the weights
at the final iteration of the penalized iteratively reweighted least
squares algorithm (PIRLS).</p>
</dd>
<dt><code>model.matrix()</code>, </dt><dd><p>type of model matrix to
return: one of <code>"fixed"</code> giving the fixed effects model matrix,
<code>"random"</code> giving the random effects model matrix, or
<code>"randomListRaw"</code> giving a list of the raw random effects model
matrices associated with each random effects term.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="merMod-class_+3A_ranef.corr">ranef.corr</code></td>
<td>
<p>(logical) print correlations (rather than covariances) of
random effects?</p>
</td></tr>
<tr><td><code id="merMod-class_+3A_...">...</code></td>
<td>
<p>potentially further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects of class <code>merMod</code> are created by calls to
<code><a href="#topic+lmer">lmer</a></code>, <code><a href="#topic+glmer">glmer</a></code> or <code><a href="#topic+nlmer">nlmer</a></code>.
</p>


<h3>S3 methods</h3>

<p>The following S3 methods with arguments given above exist (this list is currently not complete):
</p>


<dl>
<dt><code>anova</code>:</dt><dd><p>returns the sequential decomposition of the contributions of
fixed-effects terms or, for multiple arguments, model comparison statistics.
For objects of class <code>lmerMod</code> the default behavior is to refit the models
with ML if fitted with <code>REML = TRUE</code>, this can be controlled via the
<code>refit</code> argument. See also <code><a href="stats.html#topic+anova">anova</a></code>.</p>
</dd>
<dt><code>as.function</code>:</dt><dd><p>returns the deviance function, the same as
<code><a href="#topic+lmer">lmer</a>(*, devFunOnly=TRUE)</code>, and <code><a href="#topic+mkLmerDevfun">mkLmerDevfun</a>()</code>
or <code><a href="#topic+mkGlmerDevfun">mkGlmerDevfun</a>()</code>, respectively.</p>
</dd>
<dt><code>coef</code>:</dt><dd><p>Computes the sum of the random and fixed effects
coefficients for each explanatory variable for each level of each
grouping factor.</p>
</dd>
<dt><code>extractAIC</code>:</dt><dd><p>Computes the (generalized) Akaike An
Information Criterion. If <code>isREML(fit)</code>, then <code>fit</code> is
refitted using maximum likelihood.</p>
</dd>
<dt><code>family</code>:</dt><dd><p><code><a href="stats.html#topic+family">family</a></code> of fitted
GLMM. (<em>Warning:</em> this accessor may not work properly with
customized families/link functions.)</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Fitted values, given the conditional modes of
the random effects.  For more flexible access to fitted values, use
<code><a href="#topic+predict.merMod">predict.merMod</a></code>.</p>
</dd>
<dt><code>logLik</code>:</dt><dd><p>Log-likelihood at the fitted value of the
parameters.  Note that for GLMMs, the returned value is only
proportional to the log probability density (or distribution) of the
response variable.  See <code><a href="stats.html#topic+logLik">logLik</a></code>. </p>
</dd>
<dt><code>model.frame</code>:</dt><dd><p>returns the <code>frame</code> slot of <code><a href="#topic+merMod-class">merMod</a></code>.</p>
</dd>
<dt><code>model.matrix</code>:</dt><dd><p>returns the fixed effects model matrix.</p>
</dd>
<dt><code>nobs</code>, <code>ngrps</code>:</dt><dd><p>Number of observations and vector of
the numbers of levels in each grouping factor.  See <code><a href="#topic+ngrps">ngrps</a></code>.</p>
</dd>
<dt><code>summary</code>:</dt><dd><p>Computes and returns a list of summary statistics of the
fitted model, the amount of output can be controlled via the <code>print</code> method,
see also <code><a href="base.html#topic+summary">summary</a></code>.</p>
</dd>
<dt><code>print.summary</code>:</dt><dd><p>Controls the output for the summary
method.</p>
</dd>
<dt><code>update</code>:</dt><dd><p>See <code><a href="stats.html#topic+update">update</a></code>.</p>
</dd>
</dl>



<h3>Deviance and log-likelihood of GLMMs</h3>

<p>One must be careful when defining the deviance of a GLM.  For example,
should the deviance be defined as minus twice the log-likelihood or
does it involve subtracting the deviance for a saturated model?  To
distinguish these two possibilities we refer to absolute deviance
(minus twice the log-likelihood) and relative deviance (relative to a
saturated model, e.g. Section 2.3.1 in McCullagh and Nelder 1989).
</p>
<p>With GLMMs however, there is an additional complication involving the
distinction between the likelihood and the conditional likelihood.
The latter is the likelihood obtained by conditioning on the estimates
of the conditional modes of the spherical random effects coefficients,
whereas the likelihood itself (i.e. the unconditional likelihood)
involves integrating out these coefficients.  The following table
summarizes how to extract the various types of deviance for a
<code>glmerMod</code> object:
</p>

<table>
<tr>
 <td style="text-align: left;">
             </td><td style="text-align: right;"> conditional              </td><td style="text-align: right;"> unconditional </td>
</tr>
<tr>
 <td style="text-align: left;">
    relative </td><td style="text-align: right;"> <code>deviance(object)</code>  </td><td style="text-align: right;"> NA in <code>lme4</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    absolute </td><td style="text-align: right;"> <code>object@resp$aic()</code> </td><td style="text-align: right;"> <code>-2*logLik(object)</code>
  </td>
</tr>

</table>

<p>This table requires two caveats:
</p>

<ul>
<li><p> If the link function involves a scale parameter
(e.g. <code>Gamma</code>) then <code>object@resp$aic() - 2 * getME(object,
    "devcomp")$dims["useSc"]</code> is required for the absolute-conditional
case.
</p>
</li>
<li><p> If adaptive Gauss-Hermite quadrature is used, then
<code>logLik(object)</code> is currently only proportional to the
absolute-unconditional log-likelihood.
</p>
</li></ul>

<p>For more information about this topic see the <code>misc/logLikGLMM</code>
directory in the package source.
</p>
































<h3>Slots</h3>


<dl>
<dt><code>resp</code>:</dt><dd><p>A reference class object for an <span class="pkg">lme4</span>
response module (<code><a href="#topic+lmResp-class">lmResp-class</a></code>).</p>
</dd>
<dt><code>Gp</code>:</dt><dd><p>See <code><a href="#topic+getME">getME</a></code>.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The matched call.</p>
</dd>
<dt><code>frame</code>:</dt><dd><p>The model frame containing all of the variables
required to parse the model formula.</p>
</dd>
<dt><code>flist</code>:</dt><dd><p>See <code><a href="#topic+getME">getME</a></code>.</p>
</dd>
<dt><code>cnms</code>:</dt><dd><p>See <code><a href="#topic+getME">getME</a></code>.</p>
</dd>
<dt><code>lower</code>:</dt><dd><p>See <code><a href="#topic+getME">getME</a></code>.</p>
</dd>
<dt><code>theta</code>:</dt><dd><p>Covariance parameter vector.</p>
</dd>
<dt><code>beta</code>:</dt><dd><p>Fixed effects coefficients.</p>
</dd>
<dt><code>u</code>:</dt><dd><p>Conditional model of spherical random effects
coefficients.</p>
</dd>
<dt><code>devcomp</code>:</dt><dd><p>See <code><a href="#topic+getME">getME</a></code>.</p>
</dd>
<dt><code>pp</code>:</dt><dd><p>A reference class object for an <span class="pkg">lme4</span>
predictor module (<code><a href="#topic+merPredD-class">merPredD-class</a></code>).</p>
</dd>
<dt><code>optinfo</code>:</dt><dd><p>List containing information about the
nonlinear optimization.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+lmer">lmer</a></code>, <code><a href="#topic+glmer">glmer</a></code>,
<code><a href="#topic+nlmer">nlmer</a></code>, <code><a href="#topic+merPredD-class">merPredD</a></code>,
<code><a href="#topic+lmerResp-class">lmerResp</a></code>,
<code><a href="#topic+glmResp-class">glmResp</a></code>,
<code><a href="#topic+nlsResp-class">nlsResp</a></code>
</p>
<p>Other methods for <code>merMod</code> objects documented elsewhere include:
<code><a href="#topic+fortify.merMod">fortify.merMod</a></code>, <code><a href="#topic+drop1.merMod">drop1.merMod</a></code>,
<code><a href="#topic+isLMM.merMod">isLMM.merMod</a></code>, <code><a href="#topic+isGLMM.merMod">isGLMM.merMod</a></code>,
<code><a href="#topic+isNLMM.merMod">isNLMM.merMod</a></code>, <code><a href="#topic+isREML.merMod">isREML.merMod</a></code>,
<code><a href="#topic+plot.merMod">plot.merMod</a></code>, <code><a href="#topic+predict.merMod">predict.merMod</a></code>,
<code><a href="#topic+profile.merMod">profile.merMod</a></code>, <code><a href="#topic+ranef.merMod">ranef.merMod</a></code>,
<code><a href="#topic+refit.merMod">refit.merMod</a></code>, <code><a href="#topic+refitML.merMod">refitML.merMod</a></code>,
<code><a href="#topic+residuals.merMod">residuals.merMod</a></code>, <code><a href="#topic+sigma.merMod">sigma.merMod</a></code>,
<code><a href="#topic+simulate.merMod">simulate.merMod</a></code>, <code><a href="#topic+summary.merMod">summary.merMod</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("merMod")
methods(class="merMod")## over 30  (S3) methods available

m1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
print(m1, ranef.corr = TRUE)   ## print correlations of REs
print(m1, ranef.corr = FALSE)  ## print covariances of REs

</code></pre>

<hr>
<h2 id='merPredD'>Generator object for the <code><a href="#topic+merPredD-class">merPredD</a></code> class</h2><span id='topic+merPredD'></span>

<h3>Description</h3>

<p>The generator object for the
<code><a href="#topic+merPredD-class">merPredD</a></code> reference class. Such an
object is primarily used through its <code>new</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merPredD(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merPredD_+3A_...">...</code></td>
<td>
<p>List of arguments (see Note).</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>merPredD(...)</code> is a short form of <code>new("merPredD", ...)</code>
to create a new <code><a href="#topic+merPredD-class">merPredD</a></code> object and the
<code>...</code> must be named arguments, <code>(X, Zt, Lambdat, Lind,
    theta,n)</code>:
</p>

<dl>
<dt><code>X</code>:</dt><dd><p>dense model matrix for the fixed-effects parameters, to be
stored in the <code>X</code> field.</p>
</dd>
<dt><code>Zt</code>:</dt><dd><p>transpose of the sparse model matrix for the random
effects.  It is stored in the <code>Zt</code> field.</p>
</dd>
<dt><code>Lambdat</code>:</dt><dd><p>transpose of the sparse lower triangular relative
variance factor (stored in the <code>Lambdat</code> field).</p>
</dd>
<dt><code>Lind</code>:</dt><dd><p>integer vector of the same length as the <code>x</code> slot in the
<code>Lambdat</code> field.  Its elements should be in the range 1 to
the length of the <code>theta</code> field.</p>
</dd>
<dt><code>theta</code>:</dt><dd><p>numeric vector of variance component parameters (stored
in the <code>theta</code> field).</p>
</dd>
<dt><code>n</code>:</dt><dd><p>sample size, usually <code>nrow(X)</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The class definition, <code><a href="#topic+merPredD-class">merPredD</a></code>, also for examples.
</p>

<hr>
<h2 id='merPredD-class'>Class <code>"merPredD"</code> - a Dense Predictor Reference Class</h2><span id='topic+merPredD-class'></span>

<h3>Description</h3>

<p>A reference class (see mother class definition
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code> for a mixed-effects model predictor
module with a dense model matrix for the fixed-effects parameters.
The reference class is associated with a C++ class of the same name.
As is customary, the generator object, <code><a href="#topic+merPredD">merPredD</a></code>, for the
class has the same name as the class.
</p>


<h3>Note</h3>

<p>Objects from this reference class correspond to objects in a C++
class.  Methods are invoked on the C++ class object using the external
pointer in the <code>Ptr</code> field.  When saving such an object the
external pointer is converted to a null pointer, which is why there
are redundant fields containing enough information as <span class="rlang"><b>R</b></span> objects to be
able to regenerate the C++ object.  The convention is that a field
whose name begins with an upper-case letter is an <span class="rlang"><b>R</b></span> object and the
corresponding field, whose name begins with the lower-case letter is a
method.  References to the external pointer should be through the
method, not directly through the <code>Ptr</code> field.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmer">lmer</a></code>, <code><a href="#topic+glmer">glmer</a></code>,
<code><a href="#topic+nlmer">nlmer</a></code>, <code><a href="#topic+merPredD">merPredD</a></code>,
<code><a href="#topic+merMod-class">merMod</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("merPredD")
pp &lt;- slot(lmer(Yield ~ 1|Batch, Dyestuff), "pp")
stopifnot(is(pp, "merPredD"))
str(pp) # an overview of all fields and methods' names.
</code></pre>

<hr>
<h2 id='mkMerMod'>Create a 'merMod' Object</h2><span id='topic+mkMerMod'></span>

<h3>Description</h3>

<p>Create an object of (a subclass of) class <code><a href="#topic+merMod-class">merMod</a></code>
from the environment of the objective function and the value returned
by the optimizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mkMerMod(rho, opt, reTrms, fr, mc, lme4conv = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkMerMod_+3A_rho">rho</code></td>
<td>
<p>the environment of the objective function</p>
</td></tr>
<tr><td><code id="mkMerMod_+3A_opt">opt</code></td>
<td>
<p>the optimization result returned by the optimizer
(a <code><a href="base.html#topic+list">list</a></code>: see <code><a href="#topic+lmerControl">lmerControl</a></code> for required elements)</p>
</td></tr>
<tr><td><code id="mkMerMod_+3A_retrms">reTrms</code></td>
<td>
<p>random effects structure from the calling function
(see <code><a href="#topic+mkReTrms">mkReTrms</a></code> for required elements)</p>
</td></tr>
<tr><td><code id="mkMerMod_+3A_fr">fr</code></td>
<td>
<p>model frame (see <code><a href="stats.html#topic+model.frame">model.frame</a></code>)</p>
</td></tr>
<tr><td><code id="mkMerMod_+3A_mc">mc</code></td>
<td>
<p>matched call from the calling function</p>
</td></tr>
<tr><td><code id="mkMerMod_+3A_lme4conv">lme4conv</code></td>
<td>
<p>lme4-specific convergence information
(results of <code>checkConv</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object from a class that inherits from <code><a href="#topic+merMod-class">merMod</a></code>.
</p>

<hr>
<h2 id='mkRespMod'>Create an lmerResp, glmResp or nlsResp instance</h2><span id='topic+mkRespMod'></span>

<h3>Description</h3>

<p>Create an lmerResp, glmResp or nlsResp instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mkRespMod(fr, REML = NULL, family = NULL, nlenv = NULL,
    nlmod = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkRespMod_+3A_fr">fr</code></td>
<td>
<p>a model frame</p>
</td></tr>
<tr><td><code id="mkRespMod_+3A_reml">REML</code></td>
<td>
<p>logical scalar, value of REML for an lmerResp
instance</p>
</td></tr>
<tr><td><code id="mkRespMod_+3A_family">family</code></td>
<td>
<p>the optional glm family (glmResp only)</p>
</td></tr>
<tr><td><code id="mkRespMod_+3A_nlenv">nlenv</code></td>
<td>
<p>the nonlinear model evaluation environment
(nlsResp only)</p>
</td></tr>
<tr><td><code id="mkRespMod_+3A_nlmod">nlmod</code></td>
<td>
<p>the nonlinear model function (nlsResp only)</p>
</td></tr>
<tr><td><code id="mkRespMod_+3A_...">...</code></td>
<td>
<p>where to look for response information if
<code>fr</code> is missing.  Can contain a model response,
<code>y</code>, offset, <code>offset</code>, and weights,
<code>weights</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an lmerResp or glmResp or nlsResp instance
</p>


<h3>See Also</h3>

<p>Other utilities: <code><a href="#topic+findbars">findbars</a></code>,
<code><a href="#topic+mkReTrms">mkReTrms</a></code>, <code><a href="#topic+nlformula">nlformula</a></code>,
<code><a href="#topic+nobars">nobars</a></code>, <code><a href="#topic+subbars">subbars</a></code>
</p>

<hr>
<h2 id='mkReTrms'>Make Random Effect Terms: Create Z, Lambda, Lind, etc.</h2><span id='topic+mkReTrms'></span><span id='topic+mkNewReTrms'></span>

<h3>Description</h3>

<p>From the result of <code><a href="#topic+findbars">findbars</a></code> applied to a model formula
and the evaluation frame <code>fr</code>, create the model matrix
<code>Zt</code>, etc, associated with the random-effects terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mkReTrms(bars, fr, drop.unused.levels=TRUE,
                     reorder.terms=TRUE,
                     reorder.vars=FALSE)
  mkNewReTrms(object, newdata, re.form=NULL,
                     na.action=na.pass,
                     allow.new.levels=FALSE,
                     sparse = max(lengths(orig.random.levs)) &gt; 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkReTrms_+3A_bars">bars</code></td>
<td>
<p>a list of parsed random-effects terms</p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_fr">fr</code></td>
<td>
<p>a model frame in which to evaluate these terms</p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>(logical) drop unused factor levels?</p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_reorder.terms">reorder.terms</code></td>
<td>
<p>arrange random effects terms in decreasing order
of number of groups (factor levels)?</p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_reorder.vars">reorder.vars</code></td>
<td>
<p>arrange columns of individual random effects terms
in alphabetical order?</p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_object">object</code></td>
<td>
<p>a fitted <code>merMod</code> object</p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_newdata">newdata</code></td>
<td>
<p>data frame for which to create
new RE terms object</p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_re.form">re.form</code></td>
<td>
<p>(formula, <code>NULL</code>, or <code>NA</code>) specify which random effects to condition on when predicting.  If <code>NULL</code>,
include all random effects; if <code>NA</code> or <code>~0</code>,
include no random effects</p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done
with missing values for fixed effects in <code>newdata</code></p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_allow.new.levels">allow.new.levels</code></td>
<td>
<p>(logical) if new levels (or NA values) in
<code>newdata</code> are allowed. If FALSE (default), such new values in
<code>newdata</code> will trigger an error; if TRUE, then the prediction
will use the unconditional (population-level) values for data with
previously unobserved levels (or NAs)</p>
</td></tr>
<tr><td><code id="mkReTrms_+3A_sparse">sparse</code></td>
<td>
<p>generate sparse contrast matrices?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table role = "presentation">
<tr><td><code>Zt</code></td>
<td>
<p>transpose of the sparse model matrix for the random effects</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>initial values of the covariance parameters</p>
</td></tr>
<tr><td><code>Lind</code></td>
<td>
<p>an integer vector of indices determining the mapping of
the elements of the <code>theta</code> vector to the <code>"x"</code> slot of
<code>Lambdat</code></p>
</td></tr>
<tr><td><code>Gp</code></td>
<td>
<p>a vector indexing the association of
elements of the conditional mode vector
with random-effect terms; if <code>nb</code> is the vector of numbers
of conditional modes per term (i.e. number of groups times number
of effects per group), <code>Gp</code> is <code>c(0,cumsum(nb))</code>
(and conversely <code>nb</code> is <code>diff(Gp)</code>)</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower bounds on the covariance parameters</p>
</td></tr>
<tr><td><code>Lambdat</code></td>
<td>
<p>transpose of the sparse relative covariance factor</p>
</td></tr>
<tr><td><code>flist</code></td>
<td>
<p>list of grouping factors used in the
random-effects terms</p>
</td></tr>
<tr><td><code>cnms</code></td>
<td>
<p>a list of column names
of the random effects according to the grouping factors</p>
</td></tr>
<tr><td><code>Ztlist</code></td>
<td>
<p>list of components of the transpose of the
random-effects model matrix, separated by random-effects term</p>
</td></tr>
<tr><td><code>nl</code></td>
<td>
<p>names of the terms (in the same order as <code>Zt</code>,
i.e. reflecting the <code>reorder.terms</code> argument)</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>mkNewReTrms</code> is used in the context of prediction, to
generate a new &quot;random effects terms&quot; object from an already fitted
model</p>


<h3>See Also</h3>

<p>Other utilities: <code><a href="#topic+findbars">findbars</a></code>,
<code><a href="#topic+mkRespMod">mkRespMod</a></code>, <code><a href="#topic+nlformula">nlformula</a></code>,
<code><a href="#topic+nobars">nobars</a></code>, <code><a href="#topic+subbars">subbars</a></code>.
<code><a href="#topic+getME">getME</a></code> can retrieve these components
from a fitted model, although their values and/or forms
may be slightly different in the final fitted model from
their original values as returned from <code>mkReTrms</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Pixel", package="nlme")
mform &lt;- pixel ~ day + I(day^2) + (day | Dog) + (1 | Side/Dog)
(bar.f &lt;- findbars(mform)) # list with 3 terms
mf &lt;- model.frame(subbars(mform),data=Pixel)
rt &lt;- mkReTrms(bar.f,mf)
names(rt)
</code></pre>

<hr>
<h2 id='mkSimulateTemplate'>Make templates suitable for guiding mixed model simulations</h2><span id='topic+mkParsTemplate'></span><span id='topic+mkDataTemplate'></span>

<h3>Description</h3>

<p>Make data and parameter templates suitable for guiding mixed model
simulations, by specifying a model formula and other information
(EXPERIMENTAL).  Most useful for simulating balanced designs and for 
getting started on unbalanced simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkParsTemplate(formula, data)
mkDataTemplate(formula, data, nGrps = 2, nPerGrp = 1, rfunc = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkSimulateTemplate_+3A_formula">formula</code></td>
<td>
<p>A mixed model formula (see <code><a href="#topic+lmer">lmer</a></code>).</p>
</td></tr>
<tr><td><code id="mkSimulateTemplate_+3A_data">data</code></td>
<td>
<p>A data frame containing the names in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="mkSimulateTemplate_+3A_ngrps">nGrps</code></td>
<td>
<p>Number of levels of a grouping factor.</p>
</td></tr>
<tr><td><code id="mkSimulateTemplate_+3A_npergrp">nPerGrp</code></td>
<td>
<p>Number of observations per level.</p>
</td></tr>
<tr><td><code id="mkSimulateTemplate_+3A_rfunc">rfunc</code></td>
<td>
<p>Function for generating covariate data (e.g. <code><a href="stats.html#topic+rnorm">rnorm</a></code>.</p>
</td></tr>
<tr><td><code id="mkSimulateTemplate_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>rfunc</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>These functions are designed to be used with <code><a href="#topic+simulate.merMod">simulate.merMod</a></code>.
</p>

<hr>
<h2 id='mkVarCorr'>Make Variance and Correlation Matrices from <code>theta</code></h2><span id='topic+mkVarCorr'></span>

<h3>Description</h3>

<p>Make variance and correlation matrices from <code>theta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkVarCorr(sc, cnms, nc, theta, nms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkVarCorr_+3A_sc">sc</code></td>
<td>
<p>scale factor (residual standard deviation).</p>
</td></tr>
<tr><td><code id="mkVarCorr_+3A_cnms">cnms</code></td>
<td>
<p>component names.</p>
</td></tr>
<tr><td><code id="mkVarCorr_+3A_nc">nc</code></td>
<td>
<p>numeric vector: number of terms in each RE component.</p>
</td></tr>
<tr><td><code id="mkVarCorr_+3A_theta">theta</code></td>
<td>
<p>theta vector (lower-triangle of Cholesky factors).</p>
</td></tr>
<tr><td><code id="mkVarCorr_+3A_nms">nms</code></td>
<td>
<p>component names (FIXME: nms/cnms redundant:
nms=names(cnms)?)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VarCorr">VarCorr</a></code>
</p>

<hr>
<h2 id='modular'>Modular Functions for Mixed Model Fits</h2><span id='topic+glFormula'></span><span id='topic+lFormula'></span><span id='topic+mkGlmerDevfun'></span><span id='topic+mkLmerDevfun'></span><span id='topic+modular'></span><span id='topic+optimizeGlmer'></span><span id='topic+optimizeLmer'></span><span id='topic+updateGlmerDevfun'></span>

<h3>Description</h3>

<p>Modular functions for mixed model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lFormula(formula, data = NULL, REML = TRUE,
    subset, weights, na.action, offset, contrasts = NULL,
    control = lmerControl(), ...)

mkLmerDevfun(fr, X, reTrms, REML = TRUE, start = NULL,
    verbose = 0, control = lmerControl(), ...)

optimizeLmer(devfun,
             optimizer    = formals(lmerControl)$optimizer,
             restart_edge = formals(lmerControl)$restart_edge,
             boundary.tol = formals(lmerControl)$boundary.tol,
             start = NULL, verbose = 0L,
             control = list(), ...)

glFormula(formula, data = NULL, family = gaussian,
    subset, weights, na.action, offset, contrasts = NULL,
    start, mustart, etastart, control = glmerControl(), ...)

mkGlmerDevfun(fr, X, reTrms, family, nAGQ = 1L,
              verbose = 0L, maxit = 100L, control = glmerControl(), ...)

optimizeGlmer(devfun,
    optimizer = if(stage == 1) "bobyqa" else "Nelder_Mead",
    restart_edge = FALSE,
    boundary.tol = formals(glmerControl)$boundary.tol,
    verbose = 0L, control = list(),
    nAGQ = 1L, stage = 1, start = NULL, ...)

updateGlmerDevfun(devfun, reTrms, nAGQ = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modular_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object
describing both the fixed-effects and random-effects parts
of the model, with the response on the left of a <code>~</code>
operator and the terms, separated by <code>+</code> operators,
on the right.  Random-effects terms are distinguished by
vertical bars (<code>"|"</code>) separating expressions for
design matrices from grouping factors.</p>
</td></tr>
<tr><td><code id="modular_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the
variables named in <code>formula</code>.  By default the
variables are taken from the environment from which
<code>lmer</code> is called. While <code>data</code> is optional, the
package authors <em>strongly</em> recommend its use,
especially when later applying methods such as
<code>update</code> and <code>drop1</code> to the fitted model
(<em>such methods are not guaranteed to work properly
if <code>data</code> is omitted</em>). If <code>data</code> is omitted,
variables will be taken from the environment of
<code>formula</code> (if specified as a formula) or from the
parent frame (if specified as a character vector).</p>
</td></tr>
<tr><td><code id="modular_+3A_reml">REML</code></td>
<td>
<p>(logical) indicating to fit <b>re</b>stricted maximum
likelihood model.</p>
</td></tr>
<tr><td><code id="modular_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the
subset of the rows of <code>data</code> that should be used in
the fit. This can be a logical vector, or a numeric
vector indicating which observation numbers are to be
included, or a character vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="modular_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="modular_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should
happen when the data contain <code>NA</code>s.  The default
action (<code>na.omit</code>, inherited from the 'factory
fresh' value of <code>getOption("na.action")</code>) strips any
observations with any missing values in any variables.</p>
</td></tr>
<tr><td><code id="modular_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting.  This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if
more than one is specified their sum is used.  See
<code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="modular_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional <code><a href="base.html#topic+list">list</a></code>.  See the
<code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="modular_+3A_control">control</code></td>
<td>
<p>a list giving
</p>

<dl>
<dt>for <code>[g]lFormula</code>:</dt><dd><p>all
options for running the model, see <code><a href="#topic+lmerControl">lmerControl</a></code>;</p>
</dd>
<dt>for <code>mkLmerDevfun,mkGlmerDevfun</code>:</dt><dd><p>options
for the inner optimization step;</p>
</dd>
<dt>for <code>optimizeLmer</code> and <code>optimizeGlmer</code>:</dt><dd><p>control
parameters for nonlinear optimizer (typically inherited from the
... argument to <code><a href="#topic+lmerControl">lmerControl</a></code>).</p>
</dd>

</dl>

</td></tr>
<tr><td><code id="modular_+3A_fr">fr</code></td>
<td>
<p>A model frame containing the variables needed to create an
<code><a href="#topic+lmerResp">lmerResp</a></code> or <code><a href="#topic+glmResp">glmResp</a></code> instance.</p>
</td></tr>
<tr><td><code id="modular_+3A_x">X</code></td>
<td>
<p>fixed-effects design matrix</p>
</td></tr>
<tr><td><code id="modular_+3A_retrms">reTrms</code></td>
<td>
<p>information on random effects structure (see
<code><a href="#topic+mkReTrms">mkReTrms</a></code>).</p>
</td></tr>
<tr><td><code id="modular_+3A_start">start</code></td>
<td>
<p>starting values (see <code><a href="#topic+lmer">lmer</a></code>;
for <code>glFormula</code>, should be just a numeric vector of
fixed-effect coefficients)</p>
</td></tr>
<tr><td><code id="modular_+3A_verbose">verbose</code></td>
<td>
<p>print output?</p>
</td></tr>
<tr><td><code id="modular_+3A_maxit">maxit</code></td>
<td>
<p>maximal number of Pwrss update iterations.</p>
</td></tr>
<tr><td><code id="modular_+3A_devfun">devfun</code></td>
<td>
<p>a deviance function, as generated by <code><a href="#topic+mkLmerDevfun">mkLmerDevfun</a></code></p>
</td></tr>
<tr><td><code id="modular_+3A_nagq">nAGQ</code></td>
<td>
<p>number of Gauss-Hermite quadrature points</p>
</td></tr>
<tr><td><code id="modular_+3A_stage">stage</code></td>
<td>
<p>optimization stage (1: nAGQ=0, optimize over theta only;
2: nAGQ possibly &gt;0, optimize over theta and beta)</p>
</td></tr>
<tr><td><code id="modular_+3A_optimizer">optimizer</code></td>
<td>
<p>character - name of optimizing
function(s).  A character vector or list of functions:
length 1 for <code>lmer</code> or <code>glmer</code>, possibly length
2 for <code>glmer</code>.  The built-in optimizers are
<code>"<a href="#topic+Nelder_Mead">Nelder_Mead</a>"</code> and <code>"<a href="minqa.html#topic+bobyqa">bobyqa</a>"</code>
(from the <a href="https://CRAN.R-project.org/package=minqa"><span class="pkg">minqa</span></a> package).  Any minimizing function
that allows box constraints can be used provided that it
</p>

<ol>
<li><p>takes input parameters <code>fn</code> (function to be
optimized), <code>par</code> (starting parameter values),
<code>lower</code> (lower bounds) and <code>control</code> (control
parameters, passed through from the <code>control</code>
argument) and
</p>
</li>
<li><p>returns a list with (at least) elements
<code>par</code> (best-fit parameters), <code>fval</code> (best-fit
function value), <code>conv</code> (convergence code) and
(optionally) <code>message</code> (informational message, or
explanation of convergence failure).
</p>
</li></ol>

<p>Special provisions are made for <code><a href="minqa.html#topic+bobyqa">bobyqa</a></code>,
<code><a href="#topic+Nelder_Mead">Nelder_Mead</a></code>, and optimizers wrapped in the
<a href="https://CRAN.R-project.org/package=optimx"><span class="pkg">optimx</span></a> package; to use <span class="pkg">optimx</span> optimizers
(including <code>L-BFGS-B</code> from base <code><a href="stats.html#topic+optim">optim</a></code>
and <code><a href="stats.html#topic+nlminb">nlminb</a></code>), pass the <code>method</code>
argument to <code>optim</code> in the <code>control</code> argument.
</p>
<p>For <code>glmer</code>, if <code>length(optimizer)==2</code>, the
first element will be used for the preliminary (random
effects parameters only) optimization, while the second
will be used for the final (random effects plus fixed
effect parameters) phase. See <code><a href="#topic+modular">modular</a></code> for
more information on these two phases.
</p>
</td></tr>
<tr><td><code id="modular_+3A_restart_edge">restart_edge</code></td>
<td>
<p>see <code><a href="#topic+lmerControl">lmerControl</a></code></p>
</td></tr>
<tr><td><code id="modular_+3A_boundary.tol">boundary.tol</code></td>
<td>
<p>see <code><a href="#topic+lmerControl">lmerControl</a></code></p>
</td></tr>
<tr><td><code id="modular_+3A_family">family</code></td>
<td>
<p>a GLM family; see <code><a href="stats.html#topic+glm">glm</a></code>
and <code><a href="stats.html#topic+family">family</a></code>.</p>
</td></tr>
<tr><td><code id="modular_+3A_mustart">mustart</code></td>
<td>
<p>optional starting values on the scale of
the conditional mean; see <code><a href="stats.html#topic+glm">glm</a></code> for details.</p>
</td></tr>
<tr><td><code id="modular_+3A_etastart">etastart</code></td>
<td>
<p>optional starting values on the scale of
the unbounded predictor; see <code><a href="stats.html#topic+glm">glm</a></code> for details.</p>
</td></tr>
<tr><td><code id="modular_+3A_...">...</code></td>
<td>
<p>other potential arguments; for <code>optimizeLmer</code> and
<code>optimizeGlmer</code>, these are passed to internal function
<code>optwrap</code>, which has relevant parameters <code>calc.derivs</code>
and <code>use.last.params</code> (see <code><a href="#topic+lmerControl">lmerControl</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions make up the internal components of an [gn]lmer fit.
</p>

<ul>
<li> <p><code>[g]lFormula</code> takes the arguments that would normally be
passed to <code>[g]lmer</code>, checking for errors and processing the
formula and data input to create a list of objects required to fit a
mixed model.
</p>
</li>
<li> <p><code>mk(Gl|L)merDevfun</code> takes the output of the previous
step (minus the <code>formula</code> component) and creates a
deviance function
</p>
</li>
<li> <p><code>optimize(Gl|L)mer</code> takes a
deviance function and optimizes over <code>theta</code> (or
over <code>theta</code> and <code>beta</code>, if <code>stage</code> is set
to 2 for <code>optimizeGlmer</code>
</p>
</li>
<li> <p><code>updateGlmerDevfun</code> takes the first stage of a GLMM
optimization (with <code>nAGQ=0</code>, optimizing over <code>theta</code> only)
and produces a second-stage deviance function
</p>
</li>
<li> <p><code><a href="#topic+mkMerMod">mkMerMod</a></code> takes the <em>environment</em> of a
deviance function, the results of an optimization, a list of
random-effect terms, a model frame, and a model all and produces a
<code>[g]lmerMod</code> object.
</p>
</li></ul>



<h3>Value</h3>

<p><code>lFormula</code> and <code>glFormula</code> return a list containing
components:
</p>

<dl>
<dt>fr</dt><dd><p>model frame</p>
</dd>
<dt>X</dt><dd><p>fixed-effect design matrix</p>
</dd>
<dt>reTrms</dt><dd><p>list containing information on random effects structure:
result of <code><a href="#topic+mkReTrms">mkReTrms</a></code></p>
</dd>
<dt>REML</dt><dd><p>(lFormula only): logical indicating if restricted maximum
likelihood was used (Copy of argument.)</p>
</dd>
</dl>

<p><code>mkLmerDevfun</code> and <code>mkGlmerDevfun</code> return a function to
calculate deviance (or restricted deviance) as a function of the
theta (random-effect) parameters.  <code>updateGlmerDevfun</code>
returns a function to calculate the deviance as a function of a
concatenation of theta and beta (fixed-effect) parameters. These
deviance functions have an environment containing objects required
for their evaluation. CAUTION: The <code><a href="base.html#topic+environment">environment</a></code> of
functions returned by <code>mk(Gl|L)merDevfun</code> contains reference
class objects (see <code><a href="methods.html#topic+ReferenceClasses">ReferenceClasses</a></code>,
<code><a href="#topic+merPredD-class">merPredD-class</a></code>, <code><a href="#topic+lmResp-class">lmResp-class</a></code>), which
behave in ways that may surprise many users. For example, if the
output of <code>mk(Gl|L)merDevfun</code> is naively copied, then
modifications to the original will also appear in the copy (and
vice versa). To avoid this behavior one must make a deep copy (see
<code><a href="methods.html#topic+ReferenceClasses">ReferenceClasses</a></code> for details).
</p>
<p><code>optimizeLmer</code> and <code>optimizeGlmer</code> return the results of an
optimization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Fitting a linear mixed model in 4 modularized steps

## 1.  Parse the data and formula:
lmod &lt;- lFormula(Reaction ~ Days + (Days|Subject), sleepstudy)
names(lmod)
## 2.  Create the deviance function to be optimized:
(devfun &lt;- do.call(mkLmerDevfun, lmod))
ls(environment(devfun)) # the environment of 'devfun' contains objects
                        # required for its evaluation
## 3.  Optimize the deviance function:
opt &lt;- optimizeLmer(devfun)
opt[1:3]
## 4.  Package up the results:
mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr)


### Same model in one line
lmer(Reaction ~ Days + (Days|Subject), sleepstudy)


### Fitting a generalized linear mixed model in six modularized steps

## 1.  Parse the data and formula:
glmod &lt;- glFormula(cbind(incidence, size - incidence) ~ period + (1 | herd),
                   data = cbpp, family = binomial)
    #.... see what've got :
str(glmod, max=1, give.attr=FALSE)
## 2.  Create the deviance function for optimizing over theta:
(devfun &lt;- do.call(mkGlmerDevfun, glmod))
ls(environment(devfun)) # the environment of devfun contains lots of info
## 3.  Optimize over theta using a rough approximation (i.e. nAGQ = 0):
(opt &lt;- optimizeGlmer(devfun))
## 4.  Update the deviance function for optimizing over theta and beta:
(devfun &lt;- updateGlmerDevfun(devfun, glmod$reTrms))
## 5.  Optimize over theta and beta:
opt &lt;- optimizeGlmer(devfun, stage=2)
str(opt, max=1) # seeing what we'got
## 6.  Package up the results:
(fMod &lt;- mkMerMod(environment(devfun), opt, glmod$reTrms, fr = glmod$fr))

### Same model in one line
fM &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
            data = cbpp, family = binomial)
all.equal(fMod, fM, check.attributes=FALSE, tolerance = 1e-12)
        # ----  --  even tolerance = 0  may work
</code></pre>

<hr>
<h2 id='namedList'>Self-naming list function</h2><span id='topic+namedList'></span>

<h3>Description</h3>

<p>this function takes a list of arguments and combines them
into a list; any <em>unnamed</em> arguments are automatically named
to match their symbols.  The <code>tibble::lst()</code> function offers
similarly functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>namedList(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="namedList_+3A_...">...</code></td>
<td>
<p>comma-separated arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1
b &lt;- 2
c &lt;- 3
str(namedList(a, b, d = c))
</code></pre>

<hr>
<h2 id='NelderMead'>Nelder-Mead Optimization of Parameters, Possibly (Box) Constrained</h2><span id='topic+Nelder_Mead'></span>

<h3>Description</h3>

<p>Nelder-Mead optimization of parameters, allowing
optimization subject to box constraints (contrary to the default,
<code>method = "Nelder-Mead"</code>, in <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+optim">optim</a>()</code>), and
using reverse communications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nelder_Mead(fn, par, lower = rep.int(-Inf, n), upper = rep.int(Inf, n),
            control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NelderMead_+3A_fn">fn</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> of a single numeric vector argument
returning a numeric scalar.</p>
</td></tr>
<tr><td><code id="NelderMead_+3A_par">par</code></td>
<td>
<p>numeric vector of starting values for the parameters.</p>
</td></tr>
<tr><td><code id="NelderMead_+3A_lower">lower</code></td>
<td>
<p>numeric vector of lower bounds (elements may be <code>-Inf</code>).</p>
</td></tr>
<tr><td><code id="NelderMead_+3A_upper">upper</code></td>
<td>
<p>numeric vector of upper bounds (elements may be <code>Inf</code>).</p>
</td></tr>
<tr><td><code id="NelderMead_+3A_control">control</code></td>
<td>
<p>a named list of control settings. Possible settings are
</p>

<dl>
<dt>iprint</dt><dd><p>numeric scalar - frequency of printing evaluation information.
Defaults to 0 indicating no printing.</p>
</dd>
<dt>maxfun</dt><dd><p>numeric scalar - maximum number of function
evaluations allowed (default:10000).</p>
</dd>
<dt>FtolAbs</dt><dd><p>numeric scalar - absolute tolerance on
change in function values (default: 1e-5)</p>
</dd>
<dt>FtolRel</dt><dd><p>numeric scalar - relative tolerance on
change in function values (default:1e-15)</p>
</dd>
<dt>XtolRel</dt><dd><p>numeric scalar - relative tolerance on
change in parameter values (default: 1e-7)</p>
</dd>
<dt>MinfMax</dt><dd><p>numeric scalar - maximum value of the
minimum (default: .Machine$double.xmin)</p>
</dd>
<dt>xst</dt><dd><p>numeric vector of initial step sizes to
establish the simplex - all elements must be non-zero
(default: rep(0.02,length(par)))</p>
</dd>
<dt>xt</dt><dd><p>numeric vector of tolerances on the parameters (default: xst*5e-4)</p>
</dd>
<dt>verbose</dt><dd><p>numeric value: 0=no printing,
1=print every 20 evaluations, 2=print every 10
evalutions, 3=print every evaluation.  Sets
&lsquo;iprint&rsquo;, if specified, but does not override it.</p>
</dd>
<dt>warnOnly</dt><dd><p>a logical indicating if non-convergence (codes
-1,-2,-3) should not <code><a href="base.html#topic+stop">stop</a>(.)</code>, but rather only call
<code><a href="base.html#topic+warning">warning</a></code> and return a result which might inspected.
Defaults to <code>FALSE</code>, i.e., stop on non-convergence.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table role = "presentation">
<tr><td><code>fval</code></td>
<td>
<p>numeric scalar - the minimum function value achieved</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>numeric vector - the value of <code>x</code> providing the minimum</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>integer valued scalar, if not <code>0</code>, an error code:
</p>

<dl>
<dt>-4</dt><dd><p><code>nm_evals</code>: maximum evaluations reached</p>
</dd>
<dt>-3</dt><dd><p><code>nm_forced</code>: ?</p>
</dd>
<dt>-2</dt><dd><p><code>nm_nofeasible</code>: cannot generate a feasible simplex</p>
</dd>
<dt>-1</dt><dd><p><code>nm_x0notfeasible</code>: initial x is not feasible (?)</p>
</dd>
<dt>0</dt><dd><p>successful convergence</p>
</dd>
</dl>

</td></tr>
<tr><td><code>message</code></td>
<td>
<p>a string specifying the kind of convergence.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the <code><a href="base.html#topic+list">list</a></code> of control settings after
substituting for defaults.</p>
</td></tr>
<tr><td><code>feval</code></td>
<td>
<p>the number of function evaluations.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The <code><a href="#topic+NelderMead-class">NelderMead</a></code> class definition and generator
function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fr &lt;- function(x) {   ## Rosenbrock Banana function
    x1 &lt;- x[1]
    x2 &lt;- x[2]
    100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
p0 &lt;- c(-1.2, 1)

oo  &lt;- optim(p0, fr) ## also uses Nelder-Mead by default
o.  &lt;- Nelder_Mead(fr, p0)
o.1 &lt;- Nelder_Mead(fr, p0, control=list(verbose=1))# -&gt; some iteration output
stopifnot(identical(o.[1:4], o.1[1:4]),
          all.equal(o.$par, oo$par, tolerance=1e-3))# diff: 0.0003865

o.2 &lt;- Nelder_Mead(fr, p0, control=list(verbose=3, XtolRel=1e-15, FtolAbs= 1e-14))
all.equal(o.2[-5],o.1[-5], tolerance=1e-15)# TRUE, unexpectedly
</code></pre>

<hr>
<h2 id='NelderMead-class'>Class <code>"NelderMead"</code> of Nelder-Mead optimizers and its Generator</h2><span id='topic+NelderMead'></span><span id='topic+NelderMead-class'></span>

<h3>Description</h3>

<p>Class <code>"NelderMead"</code> is a reference class for a Nelder-Mead
simplex optimizer allowing box constraints on the parameters and using
reverse communication.
</p>
<p>The <code>NelderMead()</code> function conveniently generates such objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NelderMead(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NelderMead-class_+3A_...">...</code></td>
<td>
<p>Argument list (see Note below).</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>NelderMead$new(lower, upper, xst, x0, xt)</code></dt><dd><p>Create a
new <code><a href="#topic+NelderMead-class">NelderMead</a></code> object</p>
</dd>
</dl>



<h3>Extends</h3>

<p>All reference classes extend and inherit methods from
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Note</h3>

<p>This is the default optimizer for the second stage of
<code><a href="#topic+glmer">glmer</a></code> and <code><a href="#topic+nlmer">nlmer</a></code> fits.  We
found that it was more reliable and often faster than
more sophisticated optimizers.
</p>
<p>Arguments to <code>NelderMead()</code> and the <code><a href="methods.html#topic+new">new</a></code> method must
be named arguments:
</p>

<dl>
<dt>lower</dt><dd><p>numeric vector of lower bounds - elements may be <code>-Inf</code>.</p>
</dd>
<dt>upper</dt><dd><p>numeric vector of upper bounds - elements may be <code>Inf</code>.</p>
</dd>
<dt>xst</dt><dd><p>numeric vector of initial step sizes to establish the
simplex - all elements must be non-zero.</p>
</dd>
<dt>x0</dt><dd><p>numeric vector of starting values for the parameters.</p>
</dd>
<dt>xt</dt><dd><p>numeric vector of tolerances on the parameters.</p>
</dd>
</dl>



<h3>References</h3>

<p>Based on code in the NLopt collection.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Nelder_Mead">Nelder_Mead</a></code>, the typical &ldquo;constructor&rdquo;.
Further, <code><a href="#topic+glmer">glmer</a></code>, <code><a href="#topic+nlmer">nlmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("NelderMead")
</code></pre>

<hr>
<h2 id='ngrps'>Number of Levels of a Factor or a &quot;merMod&quot; Model</h2><span id='topic+ngrps'></span>

<h3>Description</h3>

<p>Returns the number of levels of a <code><a href="base.html#topic+factor">factor</a></code> or a set of
factors, currently e.g., for each of the grouping factors of
<code><a href="#topic+lmer">lmer</a>()</code>, <code><a href="#topic+glmer">glmer</a>()</code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngrps(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ngrps_+3A_object">object</code></td>
<td>
<p>an <code>R</code> object, see Details.</p>
</td></tr>
<tr><td><code id="ngrps_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently there are methods for objects of class
<code><a href="#topic+merMod-class">merMod</a></code>, i.e., the result of <code><a href="#topic+lmer">lmer</a>()</code> etc,
and <code><a href="base.html#topic+factor">factor</a></code> objects.
</p>


<h3>Value</h3>

<p>The number of levels (of a factor) or vector of number of levels for
each &ldquo;grouping factor&rdquo; of a
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ngrps(factor(seq(1,10,2)))
ngrps(lmer(Reaction ~ 1|Subject, sleepstudy))

## A named vector if there's more than one grouping factor :
ngrps(lmer(strength ~ (1|batch/cask), Pastes))
## cask:batch      batch
##         30         10

methods(ngrps) # -&gt; "factor" and "merMod"
</code></pre>

<hr>
<h2 id='nlformula'>Manipulate a Nonlinear Model Formula</h2><span id='topic+nlformula'></span>

<h3>Description</h3>

<p>Check and manipulate the formula for a nonlinear model, such as
specified in <code><a href="#topic+nlmer">nlmer</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nlformula(mc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlformula_+3A_mc">mc</code></td>
<td>
<p>matched call from the calling function, typically
<code><a href="#topic+nlmer">nlmer</a>()</code>.  Should have arguments named
</p>

<dl>
<dt>formula:</dt><dd><p>a formula of the form <code>resp ~ nlmod ~ meform</code>
where <code>resp</code> is an expression for the response,
<code>nlmod</code> is the nonlinear model expression and
<code>meform</code> is the mixed-effects model formula.
<code>resp</code> can be omitted when, e.g., optimizing a design.</p>
</dd>
<dt>data:</dt><dd><p>a data frame in which to evaluate the model function</p>
</dd>
<dt>start:</dt><dd><p>either a numeric vector containing initial estimates
for the nonlinear model parameters or a list with components
</p>

<dl>
<dt><code>nlpars</code>:</dt><dd><p>the initial estimates of the nonlinear
model parameters</p>
</dd>
<dt><code>theta</code>:</dt><dd><p>the initial estimates of the variance
component parameters</p>
</dd> 
</dl>

</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The model formula for a nonlinear mixed-effects model is
of the form <code>resp ~ nlmod ~ mixed</code> where
<code>resp</code> is an expression (usually just a name) for
the response, <code>nlmod</code> is the call to the nonlinear
model function, and <code>mixed</code> is the mixed-effects
formula defining the linear predictor for the parameter
matrix.  If the formula is to be used for optimizing
designs, the <code>resp</code> part can be omitted.
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table role = "presentation">
<tr><td><code>"respMod"</code></td>
<td>
<p>a response module of class <code>"<a href="#topic+nlsResp-class">nlsResp</a>"</code></p>
</td></tr> 
<tr><td><code>"frame"</code></td>
<td>
<p>the model frame, including a terms attribute</p>
</td></tr>
<tr><td><code>"X"</code></td>
<td>
<p>the fixed-effects model matrix</p>
</td></tr>
<tr><td><code>"reTrms"</code></td>
<td>
<p>the random-effects terms object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other utilities: <code><a href="#topic+findbars">findbars</a></code>,
<code><a href="#topic+mkRespMod">mkRespMod</a></code>, <code><a href="#topic+mkReTrms">mkReTrms</a></code>,
<code><a href="#topic+nobars">nobars</a></code>, <code><a href="#topic+subbars">subbars</a></code>
</p>

<hr>
<h2 id='nlmer'>Fitting Nonlinear Mixed-Effects Models</h2><span id='topic+nlmer'></span>

<h3>Description</h3>

<p>Fit a nonlinear mixed-effects model (NLMM) to data, via maximum
likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlmer(formula, data = NULL, control = nlmerControl(),
      start = NULL, verbose = 0L, nAGQ = 1L, subset, weights, na.action,
      offset, contrasts = NULL, devFunOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlmer_+3A_formula">formula</code></td>
<td>
<p>a three-part &ldquo;nonlinear mixed model&rdquo; formula, of
the form <code>resp ~ Nonlin(...) ~ fixed + random</code>, where the third
part is similar to the RHS formula of, e.g., <code><a href="#topic+lmer">lmer</a></code>.

Currently, the <code>Nonlin(..)</code> formula part must not only return a
numeric vector, but also must have a <code>"gradient"</code> attribute, a
<code><a href="base.html#topic+matrix">matrix</a></code>.  The functions <code><a href="stats.html#topic+SSbiexp">SSbiexp</a></code>,
<code><a href="stats.html#topic+SSlogis">SSlogis</a></code>, etc, see <code><a href="stats.html#topic+selfStart">selfStart</a></code>, provide
this (and more).  Alternatively, you can use <code><a href="stats.html#topic+deriv">deriv</a>()</code>
to automatically produce such functions or expressions.</p>
</td></tr>
<tr><td><code id="nlmer_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>formula</code>.  By default the variables are taken from the
environment from which <code>lmer</code> is called.  While <code>data</code> is
optional, the package authors <em>strongly</em> recommend its use,
especially when later applying methods such as <code><a href="stats.html#topic+update">update</a></code>
and <code><a href="stats.html#topic+drop1">drop1</a></code> to the fitted model (<em>such methods are
not guaranteed to work properly if <code>data</code> is omitted</em>).  If
<code>data</code> is omitted, variables will be taken from the environment
of <code>formula</code> (if specified as a formula) or from the parent
frame (if specified as a character vector).</p>
</td></tr>
<tr><td><code id="nlmer_+3A_control">control</code></td>
<td>
<p>a list (of correct class, resulting from
<code><a href="#topic+lmerControl">lmerControl</a>()</code> or <code><a href="#topic+glmerControl">glmerControl</a>()</code>
respectively) containing control parameters, including the nonlinear
optimizer to be used and parameters to be passed through to the
nonlinear optimizer, see the <code>*lmerControl</code> documentation for
details.</p>
</td></tr>
<tr><td><code id="nlmer_+3A_start">start</code></td>
<td>
<p>starting estimates for the nonlinear model parameters, as
a named numeric vector or as a list with components
</p>

<dl>
<dt>nlpars</dt><dd><p>required numeric vector of starting values for the
nonlinear model parameters</p>
</dd>
<dt>theta</dt><dd><p>optional numeric vector of starting values for the
covariance parameters</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="nlmer_+3A_verbose">verbose</code></td>
<td>
<p>integer scalar.  If <code>&gt; 0</code> verbose output is
generated during the optimization of the parameter estimates.  If
<code>&gt; 1</code> verbose output is generated during the individual PIRLS steps
(PIRLS aka PRSS, e.g. in the C++ sources).</p>
</td></tr>
<tr><td><code id="nlmer_+3A_nagq">nAGQ</code></td>
<td>
<p>integer scalar - the number of points per axis for
evaluating the adaptive Gauss-Hermite approximation to the
log-likelihood.  Defaults to 1, corresponding to the Laplace
approximation.  Values greater than 1 produce greater accuracy in
the evaluation of the log-likelihood at the expense of speed.  A
value of zero uses a faster but less exact form of parameter
estimation for GLMMs by optimizing the random effects and the
fixed-effects coefficients in the penalized iteratively reweighted
least squares (PIRLS) step.</p>
</td></tr>
<tr><td><code id="nlmer_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows
of <code>data</code> that should be used in the fit.  This can be a
logical vector, or a numeric vector indicating which observation
numbers are to be included, or a character vector of the row names
to be included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="nlmer_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="nlmer_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.omit</code>,
inherited from the &lsquo;factory fresh&rsquo; value of
<code><a href="base.html#topic+getOption">getOption</a>("na.action")</code>) strips any observations with
any missing values in any variables.</p>
</td></tr>
<tr><td><code id="nlmer_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.
This should be <code>NULL</code> or a numeric vector of length equal to
the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be
included in the formula instead or as well, and if more than one is
specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="nlmer_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional <code><a href="base.html#topic+list">list</a></code>.  See the
<code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="nlmer_+3A_devfunonly">devFunOnly</code></td>
<td>
<p>logical - return only the deviance evaluation
function.  Note that because the deviance function operates on
variables stored in its environment, it may not return
<em>exactly</em> the same values on subsequent calls (but the results
should always be within machine tolerance).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit nonlinear mixed-effects models, such as those used in
population pharmacokinetics.
</p>


<h3>Note</h3>

<p>Adaptive Gauss-Hermite quadrature (<code>nAGQ &gt; 1</code>) is not
currently implemented for <code>nlmer</code>.  Several other
methods, such as simulation or prediction with new data,
are unimplemented or very lightly tested.
</p>
<p>A <code>method</code> argument was used in earlier versions of the <span class="pkg">lme4</span>
package.  Its functionality has been replaced by the <code>nAGQ</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## nonlinear mixed models --- 3-part formulas ---
## 1. basic nonlinear fit. Use stats::SSlogis for its
## implementation of the 3-parameter logistic curve.
## "SS" stands for "self-starting logistic", but the
## "self-starting" part is not currently used by nlmer ... 'start' is
## necessary
startvec &lt;- c(Asym = 200, xmid = 725, scal = 350)
(nm1 &lt;- nlmer(circumference ~ SSlogis(age, Asym, xmid, scal) ~ Asym|Tree,
             Orange, start = startvec))
## 2. re-run with "quick and dirty" PIRLS step
(nm1a &lt;- update(nm1, nAGQ = 0L))

## 3. Fit the same model with a user-built function:
## a. Define formula
nform &lt;- ~Asym/(1+exp((xmid-input)/scal))
## b. Use deriv() to construct function:
nfun &lt;- deriv(nform,namevec=c("Asym","xmid","scal"),
              function.arg=c("input","Asym","xmid","scal"))
nm1b &lt;- update(nm1,circumference ~ nfun(age, Asym, xmid, scal)  ~ Asym | Tree)

## 4. User-built function without using deriv():
##    derivatives could be computed more efficiently
##    by pre-computing components, but these are essentially
##    the gradients as one would derive them by hand
nfun2 &lt;- function(input, Asym, xmid, scal) {
    value &lt;- Asym/(1+exp((xmid-input)/scal))
    grad &lt;- cbind(Asym=1/(1+exp((xmid-input)/scal)),
              xmid=-Asym/(1+exp((xmid-input)/scal))^2*1/scal*
                    exp((xmid-input)/scal),
              scal=-Asym/(1+exp((xmid-input)/scal))^2*
                     -(xmid-input)/scal^2*exp((xmid-input)/scal))
    attr(value,"gradient") &lt;- grad
    value
}
stopifnot(all.equal(attr(nfun(2,1,3,4),"gradient"),
                    attr(nfun(2,1,3,4),"gradient")))
nm1c &lt;- update(nm1,circumference ~ nfun2(age, Asym, xmid, scal)  ~ Asym | Tree)
</code></pre>

<hr>
<h2 id='nloptwrap'>Wrappers for additional optimizers</h2><span id='topic+nloptwrap'></span><span id='topic+nlminbwrap'></span>

<h3>Description</h3>

<p>Wrappers to allow use of alternative optimizers, from the <code>NLopt</code>
library (via <a href="https://CRAN.R-project.org/package=nloptr"><span class="pkg">nloptr</span></a>) or elsewhere, for the nonlinear optimization stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nloptwrap (par, fn, lower, upper, control = list(), ...)
nlminbwrap(par, fn, lower, upper, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nloptwrap_+3A_par">par</code></td>
<td>
<p>starting parameter vector</p>
</td></tr>
<tr><td><code id="nloptwrap_+3A_fn">fn</code></td>
<td>
<p>objective function</p>
</td></tr>
<tr><td><code id="nloptwrap_+3A_lower">lower</code>, <code id="nloptwrap_+3A_upper">upper</code></td>
<td>
<p>numeric vector of lower and upper bounds.</p>
</td></tr>
<tr><td><code id="nloptwrap_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> of control parameters, corresponding to
<code>optCtrl = *</code>, e.g., in <code><a href="#topic+lmerControl">lmerControl</a>()</code>.  For
<code>nloptwrap</code>, see <code>defaultControl</code> in &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="nloptwrap_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to objective function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using alternative optimizers is an important trouble-shooting
tool for mixed models.  These wrappers provide convenient access to
the optimizers provided by Steven Johnson's <code>NLopt</code> library
(via the <a href="https://CRAN.R-project.org/package=nloptr"><span class="pkg">nloptr</span></a> R package), and to the <code><a href="stats.html#topic+nlminb">nlminb</a></code>
optimizer from base R.  <code>nlminb</code> is also available via the
<a href="https://CRAN.R-project.org/package=optimx"><span class="pkg">optimx</span></a> package; this wrapper provides access to <code>nlminb()</code>
without the need to install/link the package, and without the additional
post-fitting checks that are implemented by <a href="https://CRAN.R-project.org/package=optimx"><span class="pkg">optimx</span></a> (see examples
below).
</p>
<p>One important difference between the <a href="https://CRAN.R-project.org/package=nloptr"><span class="pkg">nloptr</span></a>-provided
implementation of BOBYQA and the <a href="https://CRAN.R-project.org/package=minqa"><span class="pkg">minqa</span></a>-provided version
accessible via <code>optimizer="bobyqa"</code> is that it provides simpler
access to optimization tolerances.  <code><a href="minqa.html#topic+bobyqa">bobyqa</a></code> provides
only the <code>rhoend</code> parameter (&ldquo;[t]he smallest value of the
trust region radius that is allowed&rdquo;), while <span class="pkg">nloptr</span> provides a more
standard set of tolerances for relative or absolute change in the
objective function or the parameter values (<code>ftol_rel</code>,
<code>ftol_abs</code>, <code>xtol_rel</code>, <code>xtol_abs</code>).
</p>
<p>The default (empty) <code>control</code> list corresponds to the following settings:
</p>

<dl>
<dt><code>nlminbwrap</code>:</dt><dd><p><code>control</code> exactly corresponds to
<code><a href="stats.html#topic+nlminb">nlminb</a>()</code>'s defaults, see there.</p>
</dd>
<dt><code>nloptwrap</code>:</dt><dd><p><code>environment(nloptwrap)$defaultControl</code>
contains the defaults, notably <code>algorithm = "NLOPT_LN_BOBYQA"</code>.
</p>
<p><code>nloptr::nloptr.print.options()</code> shows and explains the many
possible algorithm and options.</p>
</dd>
</dl>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>estimated parameters</p>
</td></tr>
<tr><td><code>fval</code></td>
<td>
<p>objective function value at minimum</p>
</td></tr>
<tr><td><code>feval</code></td>
<td>
<p>number of function evaluations</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>convergence code (0 if no error)</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>convergence message</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Grothendieck (<code>nlminbwrap</code>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lme4)
ls.str(environment(nloptwrap)) # 'defaultControl' algorithm "NLOPT_LN_BOBYQA"
## Note that  'optimizer =  "nloptwrap"' is now the default for lmer() :
fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
## tighten tolerances
fm1B &lt;- update(fm1, control= lmerControl(optCtrl = list(xtol_abs=1e-8, ftol_abs=1e-8)))
## run for longer (no effect in this case)
fm1C &lt;- update(fm1,control = lmerControl(optCtrl = list(maxeval=10000)))

  logLik(fm1B) - logLik(fm1)  ## small difference in log likelihood
c(logLik(fm1C) - logLik(fm1)) ## no difference in LL
## Nelder-Mead
fm1_nloptr_NM &lt;- update(fm1, control=
                  lmerControl(optimizer = "nloptwrap",
                              optCtrl = list(algorithm = "NLOPT_LN_NELDERMEAD")))
## other nlOpt algorithm options include NLOPT_LN_COBYLA, NLOPT_LN_SBPLX, see
if(interactive())
  nloptr::nloptr.print.options()

fm1_nlminb &lt;- update(fm1, control=lmerControl(optimizer = "nlminbwrap"))
if (require(optimx)) { ## the 'optimx'-based nlminb :
  fm1_nlminb2 &lt;- update(fm1, control=
                lmerControl(optimizer = "optimx",
                            optCtrl = list(method="nlminb", kkt=FALSE)))
  cat("Likelihood difference (typically zero):  ",
      c(logLik(fm1_nlminb) - logLik(fm1_nlminb2)), "\n")
}


</code></pre>

<hr>
<h2 id='nobars'>Omit terms separated by vertical bars in a formula</h2><span id='topic+nobars'></span>

<h3>Description</h3>

<p>Remove the random-effects terms from a mixed-effects
formula, thereby producing the fixed-effects formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nobars(term)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobars_+3A_term">term</code></td>
<td>
<p>the right-hand side of a mixed-model formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the fixed-effects part of the formula
</p>


<h3>Note</h3>

<p>This function is called recursively on individual terms
in the model, which is why the argument is called
<code>term</code> and not a name like <code>form</code>, indicating a
formula.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>
<p>Other utilities: <code><a href="#topic+findbars">findbars</a></code>,
<code><a href="#topic+mkRespMod">mkRespMod</a></code>, <code><a href="#topic+mkReTrms">mkReTrms</a></code>,
<code><a href="#topic+nlformula">nlformula</a></code>, <code><a href="#topic+subbars">subbars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nobars(Reaction ~ Days + (Days|Subject)) ## =&gt; Reaction ~ Days
</code></pre>

<hr>
<h2 id='Pastes'>Paste strength by batch and cask</h2><span id='topic+Pastes'></span>

<h3>Description</h3>

<p>Strength of a chemical paste product; its quality
depending on the delivery batch, and the cask within the
delivery.
</p>


<h3>Format</h3>

<p>A data frame with 60 observations on the following 4 variables.
</p>

<dl>
<dt><code>strength</code></dt><dd><p>paste strength.</p>
</dd>
<dt><code>batch</code></dt><dd><p>delivery batch from which the sample was
sample.  A factor with 10 levels: &lsquo;A&rsquo; to &lsquo;J&rsquo;.</p>
</dd>
<dt><code>cask</code></dt><dd><p>cask within the delivery batch from which the
sample was chosen.  A factor with 3 levels: &lsquo;a&rsquo; to
&lsquo;c&rsquo;.</p>
</dd>
<dt><code>sample</code></dt><dd><p>the sample of paste whose strength was assayed,
two assays per sample. A factor with 30 levels: &lsquo;A:a&rsquo; to
&lsquo;J:c&rsquo;.</p>
</dd>
</dl>


<h3>Details</h3>

<p>The data are described in Davies and Goldsmith (1972) as
coming from &ldquo; deliveries of a chemical paste
product contained in casks where, in addition to sampling
and testing errors, there are variations in quality
between deliveries ... As a routine, three casks
selected at random from each delivery were sampled and
the samples were kept for reference. ... Ten of the
delivery batches were sampled at random and two
analytical tests carried out on each of the 30 samples&rdquo;.
</p>


<h3>Source</h3>

<p>O.L. Davies and P.L. Goldsmith (eds), <em>Statistical
Methods in Research and Production, 4th ed.</em>, Oliver and
Boyd, (1972), section 6.5
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(Pastes)
require(lattice)
dotplot(cask ~ strength | reorder(batch, strength), Pastes,
        strip = FALSE, strip.left = TRUE, layout = c(1, 10),
        ylab = "Cask within batch",
        xlab = "Paste strength", jitter.y = TRUE)
## Modifying the factors to enhance the plot
Pastes &lt;- within(Pastes, batch &lt;- reorder(batch, strength))
Pastes &lt;- within(Pastes, sample &lt;- reorder(reorder(sample, strength),
          as.numeric(batch)))
dotplot(sample ~ strength | batch, Pastes,
        strip = FALSE, strip.left = TRUE, layout = c(1, 10),
        scales = list(y = list(relation = "free")),
        ylab = "Sample within batch",
        xlab = "Paste strength", jitter.y = TRUE)
## Four equivalent models differing only in specification
(fm1 &lt;- lmer(strength ~ (1|batch) + (1|sample), Pastes))
(fm2 &lt;- lmer(strength ~ (1|batch/cask), Pastes))
(fm3 &lt;- lmer(strength ~ (1|batch) + (1|batch:cask), Pastes))
(fm4 &lt;- lmer(strength ~ (1|batch/sample), Pastes))
## fm4 results in redundant labels on the sample:batch interaction
head(ranef(fm4)[[1]])
## compare to fm1
head(ranef(fm1)[[1]])
## This model is different and NOT appropriate for these data
(fm5 &lt;- lmer(strength ~ (1|batch) + (1|cask), Pastes))

L &lt;- getME(fm1, "L")
Matrix::image(L, sub = "Structure of random effects interaction in pastes model")
</code></pre>

<hr>
<h2 id='Penicillin'>Variation in penicillin testing</h2><span id='topic+Penicillin'></span>

<h3>Description</h3>

<p>Six samples of penicillin were tested using the <em>B.
subtilis</em> plate method on each of 24 plates.  The
response is the diameter (mm) of the zone of inhibition
of growth of the organism.
</p>


<h3>Format</h3>

<p>A data frame with 144 observations on the following 3 variables.
</p>

<dl>
<dt><code>diameter</code></dt><dd><p>diameter (mm) of the zone of inhibition of
the growth of the organism.</p>
</dd>
<dt><code>plate</code></dt><dd><p>assay plate.  A factor with levels &lsquo;a&rsquo; to
&lsquo;x&rsquo;.</p>
</dd>
<dt><code>sample</code></dt><dd><p>penicillin sample.  A factor with levels
&lsquo;A&rsquo; to &lsquo;F&rsquo;.</p>
</dd>
</dl>


<h3>Details</h3>

<p>The data are described in Davies and Goldsmith (1972) as
coming from an investigation to &ldquo;assess the
variability between samples of penicillin by the <em>B.
subtilis</em> method.  In this test method a bulk-inoculated
nutrient agar medium is poured into a Petri dish of
approximately 90 mm. diameter, known as a plate.  When
the medium has set, six small hollow cylinders or pots
(about 4 mm. in diameter) are cemented onto the surface
at equally spaced intervals.  A few drops of the
penicillin solutions to be compared are placed in the
respective cylinders, and the whole plate is placed in an
incubator for a given time.  Penicillin diffuses from the
pots into the agar, and this produces a clear circular
zone of inhibition of growth of the organisms, which can
be readily measured.  The diameter of the zone is related
in a known way to the concentration of penicillin in the
solution.&rdquo;
</p>


<h3>Source</h3>

<p>O.L. Davies and P.L. Goldsmith (eds), <em>Statistical
Methods in Research and Production, 4th ed.</em>, Oliver and
Boyd, (1972), section 6.6
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(Penicillin)
require(lattice)
dotplot(reorder(plate, diameter) ~ diameter, Penicillin, groups = sample,
        ylab = "Plate", xlab = "Diameter of growth inhibition zone (mm)",
        type = c("p", "a"), auto.key = list(columns = 3, lines = TRUE,
        title = "Penicillin sample"))
(fm1 &lt;- lmer(diameter ~ (1|plate) + (1|sample), Penicillin))

L &lt;- getME(fm1, "L")
Matrix::image(L, main = "L",
              sub = "Penicillin: Structure of random effects interaction")
</code></pre>

<hr>
<h2 id='plot.merMod'>Diagnostic Plots for 'merMod' Fits</h2><span id='topic+plot.merMod'></span><span id='topic+qqmath.merMod'></span>

<h3>Description</h3>

<p>diagnostic plots for merMod fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
plot(x,
     form = resid(., type = "pearson") ~ fitted(.), abline,
     id = NULL, idLabels = NULL, grid, ...)
## S3 method for class 'merMod'
qqmath(x, data = NULL, id = NULL, idLabels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.merMod_+3A_x">x</code></td>
<td>
<p>a fitted [ng]lmer model</p>
</td></tr>
<tr><td><code id="plot.merMod_+3A_form">form</code></td>
<td>
<p>an optional formula specifying the desired
type of plot. Any variable present in the original data
frame used to obtain <code>x</code> can be referenced. In
addition, <code>x</code> itself can be referenced in the
formula using the symbol <code>"."</code>. Conditional
expressions on the right of a <code>|</code> operator can be
used to define separate panels in a lattice display.
Default is <code>resid(., type = "pearson") ~ fitted(.)</code>,
corresponding to a plot of the standardized residuals
versus fitted values.</p>
</td></tr>
<tr><td><code id="plot.merMod_+3A_abline">abline</code></td>
<td>
<p>an optional numeric value, or numeric
vector of length two. If given as a single value, a
horizontal line will be added to the plot at that
coordinate; else, if given as a vector, its values are
used as the intercept and slope for a line added to the
plot. If missing, no lines are added to the plot.</p>
</td></tr>
<tr><td><code id="plot.merMod_+3A_id">id</code></td>
<td>
<p>an optional numeric value, or one-sided
formula. If given as a value, it is used as a
significance level for a two-sided outlier test for the
standardized, or normalized residuals. Observations with
absolute standardized (normalized) residuals greater than
the <code class="reqn">1-value/2</code> quantile of the standard normal
distribution are identified in the plot using
<code>idLabels</code>. If given as a one-sided formula, its
right hand side must evaluate to a logical, integer, or
character vector which is used to identify observations
in the plot. If missing, no observations are identified.</p>
</td></tr>
<tr><td><code id="plot.merMod_+3A_idlabels">idLabels</code></td>
<td>
<p>an optional vector, or one-sided formula.
If given as a vector, it is converted to character and
used to label the observations identified according to
<code>id</code>. If given as a vector, it is converted to
character and used to label the observations identified
according to <code>id</code>. If given as a one-sided formula,
its right hand side must evaluate to a vector which is
converted to character and used to label the identified
observations. Default is the interaction of all the
grouping variables in the data frame.  The special
formula <code>idLabels=~.obs</code> will label the observations
according to observation number.</p>
</td></tr>
<tr><td><code id="plot.merMod_+3A_data">data</code></td>
<td>
<p>ignored: required for S3 method compatibility</p>
</td></tr>
<tr><td><code id="plot.merMod_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether
a grid should be added to plot. Default depends on the
type of lattice plot used: if <code>xyplot</code> defaults to
<code>TRUE</code>, else defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.merMod_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the lattice
plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diagnostic plots for the linear mixed-effects fit are
obtained. The <code>form</code> argument gives considerable
flexibility in the type of plot specification. A
conditioning expression (on the right side of a <code>|</code>
operator) always implies that different panels are used
for each level of the conditioning factor, according to a
lattice display. If <code>form</code> is a one-sided formula,
histograms of the variable on the right hand side of the
formula, before a <code>|</code> operator, are displayed (the
lattice function <code>histogram</code> is used). If
<code>form</code> is two-sided and both its left and right hand
side variables are numeric, scatter plots are displayed
(the lattice function <code>xyplot</code> is used). Finally, if
<code>form</code> is two-sided and its left had side variable
is a factor, box-plots of the right hand side variable by
the levels of the left hand side variable are displayed
(the lattice function <code>bwplot</code> is used).
</p>
<p><code>qqmath</code> produces a Q-Q plot of the residuals
(see <code><a href="#topic+qqmath.ranef.mer">qqmath.ranef.mer</a></code> for Q-Q plots of the
conditional mode values).
</p>


<h3>Author(s)</h3>

<p>original version in <a href="https://CRAN.R-project.org/package=nlme"><span class="pkg">nlme</span></a> package by Jose Pinheiro
and Douglas Bates.
</p>


<h3>See Also</h3>

<p><code>influencePlot</code> in the <code>car</code> package</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Orthodont,package="nlme")
fm1 &lt;- lmer(distance ~ age + (age|Subject), data=Orthodont)
## standardized residuals versus fitted values by gender
plot(fm1, resid(., scaled=TRUE) ~ fitted(.) | Sex, abline = 0)
## box-plots of residuals by Subject
plot(fm1, Subject ~ resid(., scaled=TRUE))
## observed versus fitted values by Subject
plot(fm1, distance ~ fitted(.) | Subject, abline = c(0,1))
## residuals by age, separated by Subject
plot(fm1, resid(., scaled=TRUE) ~ age | Sex, abline = 0)
## scale-location plot, with red smoothed line
scale_loc_plot &lt;- function(m, line.col = "red", line.lty = 1,
                           line.lwd = 2) {
  plot(fm1, sqrt(abs(resid(.))) ~ fitted(.),
       type = c("p", "smooth"),
       par.settings = list(plot.line =
                             list(alpha=1, col = line.col,
                                  lty = line.lty, lwd = line.lwd)))
}
scale_loc_plot(fm1)
## Q-Q plot
lattice::qqmath(fm1, id=0.05)
ggp.there &lt;- "package:ggplot2" %in% search()
if (ggp.there || require("ggplot2")) {
    ## we can create the same plots using ggplot2 and the fortify() function
    fm1F &lt;- fortify.merMod(fm1)
    ggplot(fm1F, aes(.fitted, .resid)) + geom_point(colour="blue") +
           facet_grid(. ~ Sex) + geom_hline(yintercept=0)
    ## note: Subjects are ordered by mean distance
    ggplot(fm1F, aes(Subject,.resid)) + geom_boxplot() + coord_flip()
    ggplot(fm1F, aes(.fitted,distance)) + geom_point(colour="blue") +
        facet_wrap(~Subject) +geom_abline(intercept=0,slope=1)
    ggplot(fm1F, aes(age,.resid)) + geom_point(colour="blue") + facet_grid(.~Sex) +
        geom_hline(yintercept=0)+ geom_line(aes(group=Subject),alpha=0.4) +
        geom_smooth(method="loess")
    ## (warnings about loess are due to having only 4 unique x values)
    if(!ggp.there) detach("package:ggplot2")
}
</code></pre>

<hr>
<h2 id='plots.thpr'>Mixed-Effects Profile Plots (Regular / Density / Pairs)</h2><span id='topic+xyplot.thpr'></span><span id='topic+densityplot.thpr'></span><span id='topic+splom.thpr'></span>

<h3>Description</h3>

<p>Xyplot, Densityplot, and Pairs plot methods for a mixed-effects model
profile.
</p>
<p><code>xyplot()</code> draws &ldquo;zeta diagrams&rdquo;, also visualizing
confidence intervals and their asymmetry.
</p>
<p><code>densityplot()</code> draws the profile densities.
</p>
<p><code>splom()</code> draws profile pairs plots.  Contours are for the
marginal two-dimensional regions (i.e. using df = 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'thpr'
xyplot(x, data = NULL,
       levels = sqrt(qchisq(pmax.int(0, pmin.int(1, conf)), df = 1)),
       conf = c(50, 80, 90, 95, 99)/100,
       absVal = FALSE, scales=NULL,
       which = 1:nptot, ...)

## S3 method for class 'thpr'
densityplot(x, data, npts = 201, upper = 0.999, ...)

## S3 method for class 'thpr'
splom(x, data,
      levels = sqrt(qchisq(pmax.int(0, pmin.int(1, conf)), 2)),
      conf = c(50, 80, 90, 95, 99)/100,  which = 1:nptot,
      draw.lower = TRUE, draw.upper = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plots.thpr_+3A_x">x</code></td>
<td>
<p>a mixed-effects profile, i.e., of class <code>"thpr"</code>,
typically resulting from <code><a href="stats.html#topic+profile">profile</a>(fm)</code> where <code>fm</code>
is a fitted model from <code><a href="#topic+lmer">lmer</a></code> (or its generalizations).</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_data">data</code></td>
<td>
<p>unused - only for compatibility with generic.</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_npts">npts</code></td>
<td>
<p>the number of points to use for the <code>densityplot()</code>.</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_upper">upper</code></td>
<td>
<p>a number in <code class="reqn">(0,1)</code> to specify upper (and lower)
boundaries as <code>+/- qnorm(upper)</code>.</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_levels">levels</code></td>
<td>
<p>the contour levels to be shown; usually
derived from <code>conf</code>.</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_conf">conf</code></td>
<td>
<p>numeric vector of confidence levels to be
shown as contours.</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_absval">absVal</code></td>
<td>
<p>logical indicating if <code><a href="base.html#topic+abs">abs</a>(.)</code>olute values
should be plotted, often preferred for confidence interval
visualization.</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_scales">scales</code></td>
<td>
<p>plotting options to be passed to <code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_which">which</code></td>
<td>
<p>integer or character vector indicating which parameters
to profile: default is all parameters (see
<code><a href="#topic+profile-methods">profile-methods</a></code>
for details).</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_draw.lower">draw.lower</code></td>
<td>
<p>(logical) draw lower-triangle (zeta scale) panels?</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_draw.upper">draw.upper</code></td>
<td>
<p>(logical) draw upper-triangle (standard dev/cor scale) panels?</p>
</td></tr>
<tr><td><code id="plots.thpr_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="lattice.html#topic+densityplot">densityplot</a></code>, or <code><a href="lattice.html#topic+splom">splom</a></code> from package
<a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>xyplot:</dt><dd><p>a density plot, a <code>"trellis"</code> object (<span class="pkg">lattice</span> package)
which when <code><a href="base.html#topic+print">print</a>()</code>ed produces plots on the current
graphic device.</p>
</dd>
<dt>densityplot:</dt><dd><p>a density plot, a <code>"trellis"</code> object, see above.</p>
</dd>
<dt>splom:</dt><dd><p>a pairs plot, aka <b>s</b>catter<b>plo</b>t
<b>m</b>atrix, a <code>"trellis"</code> object, see above.</p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+profile-methods">profile</a></code>, notably for an
example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see   example("profile.merMod")
</code></pre>

<hr>
<h2 id='predict.merMod'>Predictions from a model at new data values</h2><span id='topic+predict.merMod'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+predict">predict</a></code> method for <code><a href="#topic+merMod-class">merMod</a></code>
objects, i.e. results of <code><a href="#topic+lmer">lmer</a>()</code>, <code><a href="#topic+glmer">glmer</a>()</code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
predict(object, newdata = NULL, newparams = NULL,
    re.form = NULL,
    random.only=FALSE, terms = NULL,
    type = c("link", "response"), allow.new.levels = FALSE,
    na.action = na.pass,
    se.fit = FALSE,
    ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.merMod_+3A_object">object</code></td>
<td>
<p>a fitted model object</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_newdata">newdata</code></td>
<td>
<p>data frame for which to evaluate
predictions.</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_newparams">newparams</code></td>
<td>
<p>new parameters to use in evaluating predictions,
specified as in the <code>start</code> parameter for <code><a href="#topic+lmer">lmer</a></code>
or <code><a href="#topic+glmer">glmer</a></code> &ndash; a list with components <code>theta</code> and/or
(for GLMMs) <code>beta</code>.</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_re.form">re.form</code></td>
<td>
<p>(formula, <code>NULL</code>, or <code>NA</code>) specify which random effects to condition on when predicting.  If <code>NULL</code>,
include all random effects; if <code>NA</code> or <code>~0</code>,
include no random effects.</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_random.only">random.only</code></td>
<td>
<p>(logical) ignore fixed effects, making predictions
only using random effects?</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_terms">terms</code></td>
<td>
<p>a <code><a href="stats.html#topic+terms">terms</a></code> object - unused at present.</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_type">type</code></td>
<td>
<p>character string - either <code>"link"</code>, the default, or
<code>"response"</code> indicating the type of prediction object returned.</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_allow.new.levels">allow.new.levels</code></td>
<td>
<p>logical if new levels (or NA values) in
<code>newdata</code> are allowed. If FALSE (default), such new values in
<code>newdata</code> will trigger an error; if TRUE, then the prediction
will use the unconditional (population-level) values for data with
previously unobserved levels (or NAs).</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_na.action">na.action</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> determining what should be done
with missing values for fixed effects in <code>newdata</code>.
The default is to predict <code>NA</code>: see <code><a href="stats.html#topic+na.pass">na.pass</a></code>.</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_se.fit">se.fit</code></td>
<td>
<p>(Experimental) A logical value indicating whether the standard errors should be included or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="predict.merMod_+3A_...">...</code></td>
<td>
<p>optional additional parameters.  None are used at present.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> If any random effects are included in <code>re.form</code>
(i.e. it is not <code>~0</code> or <code>NA</code>),
<code>newdata</code> <em>must</em> contain columns
corresponding to all of the grouping variables and
random effects used in the original model, even if not all
are used in prediction; however, they can be safely set to <code>NA</code>
in this case.
</p>
</li>
<li><p> There is no option for computing standard errors of
predictions because it is difficult to define an
efficient method that incorporates uncertainty in the
variance parameters; we recommend <code><a href="#topic+bootMer">bootMer</a></code>
for this task.
</p>
</li></ul>



<h3>Value</h3>

<p>a numeric vector of predicted values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 |herd), cbpp, binomial))
str(p0 &lt;- predict(gm1))            # fitted values
str(p1 &lt;- predict(gm1,re.form=NA))  # fitted values, unconditional (level-0)
newdata &lt;- with(cbpp, expand.grid(period=unique(period), herd=unique(herd)))
str(p2 &lt;- predict(gm1,newdata))    # new data, all RE
str(p3 &lt;- predict(gm1,newdata,re.form=NA)) # new data, level-0
str(p4 &lt;- predict(gm1,newdata,re.form= ~(1|herd))) # explicitly specify RE
stopifnot(identical(p2, p4))
 
</code></pre>

<hr>
<h2 id='profile-methods'>Profile method for merMod objects</h2><span id='topic+as.data.frame.thpr'></span><span id='topic+log.thpr'></span><span id='topic+logProf'></span><span id='topic+varianceProf'></span><span id='topic+profile-methods'></span><span id='topic+profile.merMod'></span>

<h3>Description</h3>

<p>Methods for <code><a href="stats.html#topic+profile">profile</a></code>() of [ng]<code><a href="#topic+lmer">lmer</a></code> fitted
models.
</p>
<p>The <code>log()</code> method and the more flexible <code>logProf()</code>
utility transform a <code>lmer</code> profile into one where logarithms of standard deviations
are used, while <code>varianceProf</code> converts from the
standard-deviation to the variance scale; see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
profile(fitted, which = NULL, alphamax = 0.01,
	maxpts = 100, delta = NULL,
    delta.cutoff = 1/8, verbose = 0, devtol = 1e-09,
    devmatchtol = 1e-5,
    maxmult = 10, startmethod = "prev", optimizer = NULL,
    control=NULL, signames = TRUE,
    parallel = c("no", "multicore", "snow"),
    ncpus = getOption("profile.ncpus", 1L), cl = NULL,
    prof.scale = c("sdcor","varcov"),
    ...)
## S3 method for class 'thpr'
 as.data.frame(x, ...)
## S3 method for class 'thpr'
log(x, base = exp(1))
logProf(x, base = exp(1), ranef = TRUE,
           sigIni = if(ranef) "sig" else "sigma")
varianceProf(x, ranef = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile-methods_+3A_fitted">fitted</code></td>
<td>
<p>a fitted model, e.g., the result of <code><a href="#topic+lmer">lmer</a>(..)</code>.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_which">which</code></td>
<td>
<p>NULL value,
integer or character vector indicating which parameters
to profile: default (NULL) is all parameters.  For integer, i.e., indexing,
the parameters are ordered as follows:
</p>

<dl>
<dt>(1)</dt><dd><p>random effects (theta) parameters; these are ordered as
in <code>getME(.,"theta")</code>, i.e., as the lower triangle of a
matrix with standard deviations on the diagonal and correlations
off the diagonal.</p>
</dd>
<dt>(2)</dt><dd><p>residual standard deviation (or scale parameter for GLMMs
where appropriate).</p>
</dd>
<dt>(3)</dt><dd><p>fixed effect (beta) parameters.</p>
</dd>
</dl>

<p>Alternatively, <code>which</code> may be a character, containing
<code>"beta_"</code> or <code>"theta_"</code> denoting the fixed or random
effects parameters, respectively, or also containing parameter
names, such as <code>".sigma"</code> or <code>"(Intercept)"</code>.
</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_alphamax">alphamax</code></td>
<td>
<p>a number in <code class="reqn">(0,1)</code>, such that <code>1 - alphamax</code>
is the maximum alpha value for likelihood ratio confidence
regions; used to establish the range of values to be profiled.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_maxpts">maxpts</code></td>
<td>
<p>maximum number of points (in each direction, for each
parameter) to evaluate in attempting to construct the profile.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_delta">delta</code></td>
<td>
<p>stepping scale for deciding on next point to profile.
The code uses the local derivative of the profile at the current
step to establish a change in the focal parameter that will lead
to a step of <code>delta</code> on the square-root-deviance scale.
If <code>NULL</code>, the <code>delta.cutoff</code> parameter will be used
to determine the stepping scale.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_delta.cutoff">delta.cutoff</code></td>
<td>
<p>stepping scale (see <code>delta</code>)
expressed as a fraction of the
target maximum value of the profile on the square-root-deviance
scale.  Thus a <code>delta.cutoff</code> setting of <code>1/n</code> will
lead to a profile with approximately <code>2*n</code> calculated points
for each parameter (i.e., <code>n</code> points in each direction,
below and above the estimate for each parameter).</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_verbose">verbose</code></td>
<td>
<p>level of output from internal calculations.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_devtol">devtol</code></td>
<td>
<p>tolerance for fitted deviances less than
baseline (supposedly minimum) deviance.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_devmatchtol">devmatchtol</code></td>
<td>
<p>tolerance for match between original deviance
computation and value returned from auxiliary deviance function</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_maxmult">maxmult</code></td>
<td>
<p>maximum multiplier of the original step size allowed,
defaults to 10.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_startmethod">startmethod</code></td>
<td>
<p>method for picking starting conditions for
optimization (STUB).</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_optimizer">optimizer</code></td>
<td>
<p>(character or function) optimizer to use (see
<code><a href="#topic+lmer">lmer</a></code> for details); default is to use the optimizer
from the original model fit.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_control">control</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of options controlling the
profiling (see <code><a href="#topic+lmerControl">lmerControl</a></code>): default is to use the
control settings from the original model fit.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_signames">signames</code></td>
<td>
<p>logical indicating if abbreviated names of the form
<code>.sigNN</code> should be used; otherwise, names are more meaningful
(but longer) of the form <code>(sd|cor)_(effects)|(group)</code>.  Note
that some code for profile transformations (e.g., <code>log()</code> or
<code><a href="#topic+varianceProf">varianceProf</a></code>) depends on <code>signames==TRUE</code>.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_...">...</code></td>
<td>
<p>potential further arguments for various methods.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>thpr</code> (i.e., output of
<code>profile</code>)</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_base">base</code></td>
<td>
<p>the base of the logarithm.  Defaults to natural
logarithms.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_ranef">ranef</code></td>
<td>
<p>logical indicating if the sigmas of the random effects
should be <code>log()</code> transformed as well.  If false, only
<code class="reqn">\sigma</code> (standard deviation of errors) is transformed.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_sigini">sigIni</code></td>
<td>
<p>character string specifying the initial part of the
sigma parameters to be log transformed.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any).
If missing, the
default is taken from the option <code>"profile.parallel"</code> (and if that
is not set, <code>"no"</code>).</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation:
typically one would choose this to be the number of available CPUs.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_cl">cl</code></td>
<td>
<p>An optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster for use if
<code>parallel = "snow"</code>.  If not supplied, a cluster on the
local machine is created for the duration of the <code>profile</code>
call.</p>
</td></tr>
<tr><td><code id="profile-methods_+3A_prof.scale">prof.scale</code></td>
<td>
<p>whether to profile on the standard
deviation-correlation scale (<code>"sdcor"</code>) or on
the variance-covariance scale (<code>"varcov"</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="base.html#topic+log">log</a></code> method and the more flexible <code>logProf()</code>
function transform the profile into one where <code class="reqn">\log(\sigma)</code> is
used instead of <code class="reqn">\sigma</code>.
By default all sigmas including the standard deviations of the random
effects are transformed i.e., the methods return a profile with all
of the <code>.sigNN</code>
parameters replaced by <code>.lsigNN</code>.  If <code>ranef</code> is false, only
<code>".sigma"</code>, the standard deviation of the errors, is transformed
(as it should never be zero, whereas random effect standard
deviations (<code>.sigNN</code>) can be reasonably be zero).
<br />
The forward and backward splines for the log-transformed parameters
are recalculated.
Note that correlation parameters are not handled sensibly at present
(i.e., they are logged rather than taking a more applicable
transformation such as an arc-hyperbolic tangent,
<code>atanh(x)</code>=<code class="reqn">\log((1+x)/(1-x))/2</code>).
</p>
<p>The <code>varianceProf</code> function works similarly, including
non-sensibility for correlation parameters, by squaring all
parameter values, changing the names by appending <code>sq</code>
appropriately (e.g. <code>.sigNN</code> to <code>.sigsqNN</code>).
Setting <code>prof.scale="varcov"</code> in the original
<code>profile()</code> call is a more computationally
intensive, but more correct, way to compute confidence
intervals for covariance parameters.
</p>
<p>Methods for function <code><a href="stats.html#topic+profile">profile</a></code> (package
<span class="pkg">stats</span>), here for profiling (fitted) mixed effect models.
</p>


<h3>Value</h3>

<p><code>profile(&lt;merMod&gt;)</code> returns an object of S3 class
<code>"thpr"</code>, 
which is <code><a href="base.html#topic+data.frame">data.frame</a></code>-like.
Notable methods for such a profile object
<code><a href="stats.html#topic+confint">confint</a>()</code>, which returns the
confidence intervals based on the profile,
and three plotting methods
(which require the <span class="pkg">lattice</span> package),
<code><a href="#topic+xyplot.thpr">xyplot</a></code>, <code>densityplot</code>, and
<code>splom</code>.
</p>
<p>In addition, the
<code><a href="base.html#topic+log">log</a>()</code> (see above) and <code><a href="base.html#topic+as.data.frame">as.data.frame</a>()</code>
methods can transform <code>"thpr"</code> objects in useful ways.
</p>


<h3>See Also</h3>

<p>The plotting methods <code><a href="#topic+xyplot.thpr">xyplot</a></code> etc, for class
<code>"thpr"</code>.
</p>
<p>For (more expensive) alternative confidence intervals:
<code><a href="#topic+bootMer">bootMer</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm01ML &lt;- lmer(Yield ~ 1|Batch, Dyestuff, REML = FALSE)
system.time(
  tpr  &lt;- profile(fm01ML, optimizer="Nelder_Mead", which="beta_")
)## fast; as only *one* beta parameter is profiled over -&gt; 0.09s (2022)

## full profiling (default which means 'all') needs longer:
system.time( tpr  &lt;- profile(fm01ML, signames=FALSE))
## ~ 0.26s (2022) + possible warning about convergence
(confint(tpr) -&gt; CIpr)
# too much precision (etc). but just FYI:
 trgt &lt;- array(c(12.19854, 38.22998, 1486.451,
                 84.06305, 67.6577,  1568.548), dim = 3:2)
 stopifnot(all.equal(trgt, unname(CIpr), tol = .0001)) # had 3.1e-7

if (interactive()) {
 library("lattice")
 xyplot(tpr)
 xyplot(tpr, absVal=TRUE) # easier to see conf.int.s (and check symmetry)
 xyplot(tpr, conf = c(0.95, 0.99), # (instead of all five 50, 80,...)
        main = "95% and 99% profile() intervals")
 xyplot(logProf(tpr, ranef=FALSE),
        main = expression("lmer profile()s"~~ log(sigma)*" (only log)"))
 densityplot(tpr, main="densityplot( profile(lmer(..)) )")
 densityplot(varianceProf(tpr), main=" varianceProf( profile(lmer(..)) )")
 splom(tpr)
 splom(logProf(tpr, ranef=FALSE))
 doMore &lt;- lme4:::testLevel() &gt; 2 
 if(doMore) { ## not typically, for time constraint reasons
   ## Batch and residual variance only
   system.time(tpr2 &lt;- profile(fm01ML, which=1:2)) # , optimizer="Nelder_Mead" gives warning
   print( xyplot(tpr2) )
   print( xyplot(log(tpr2)) )# log(sigma) is better
   print( xyplot(logProf(tpr2, ranef=FALSE)) )

   ## GLMM example
   gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
               data = cbpp, family = binomial)
   ## running ~ 10 seconds on a modern machine {-&gt; "verbose" while you wait}:
   print( system.time(pr4 &lt;- profile(gm1, verbose=TRUE)) )
   print( xyplot(pr4, layout=c(5,1), as.table=TRUE) )
   print( xyplot(log(pr4), absVal=TRUE) ) # log(sigma_1)
   print( splom(pr4) )
   print( system.time( # quicker: only sig01 and one fixed effect
       pr2 &lt;- profile(gm1, which=c("theta_", "period2"))))
   print( confint(pr2) )
   ## delta..: higher underlying resolution, only for 'sigma_1':
   print( system.time(
       pr4.hr &lt;- profile(gm1, which="theta_", delta.cutoff=1/16)))
   print( xyplot(pr4.hr) )
 }
} # only if interactive()
</code></pre>

<hr>
<h2 id='prt-utilities'>Print and Summary Method Utilities for Mixed Effects</h2><span id='topic+.prt.methTit'></span><span id='topic+.prt.VC'></span><span id='topic+.prt.aictab'></span><span id='topic+.prt.call'></span><span id='topic+.prt.family'></span><span id='topic+.prt.grps'></span><span id='topic+.prt.resids'></span><span id='topic+.prt.warn'></span><span id='topic+formatVC'></span><span id='topic+llikAIC'></span><span id='topic+methTitle'></span>

<h3>Description</h3>

<p>The <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code> methods (including the
<code>print</code> for the <code>summary()</code> result) in <span class="pkg">lme4</span> are
modular, using about ten small utility functions.  Other packages,
building on <span class="pkg">lme4</span> can use the same utilities for ease of
programming and consistency of output.
</p>
<p>Notably see the Examples.
</p>
<p><code>llikAIC()</code> extracts the  log likelihood, AIC, and related
statics from a Fitted LMM.
</p>
<p><code>formatVC()</code> &ldquo;format()&rdquo;s the <code><a href="#topic+VarCorr">VarCorr</a></code> matrix of the
random effects &ndash; for <code><a href="base.html#topic+print">print</a>()</code>ing and
<code><a href="methods.html#topic+show">show</a>()</code>ing; it is also the &ldquo;workhorse&rdquo; of
<code>.prt.VC()</code>, and returns a <code><a href="base.html#topic+character">character</a></code> matrix.
</p>
<p><code>.prt.*()</code> all use <code><a href="base.html#topic+cat">cat</a></code> and <code><a href="base.html#topic+print">print</a></code> to
produce output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikAIC(object, devianceFUN = devCrit, chkREML = TRUE,
        devcomp = object@devcomp)

methTitle(dims)

.prt.methTit(mtit, class)
.prt.family (famL)
.prt.resids (resids, digits, title = "Scaled residuals:", ...)
.prt.call   (call, long = TRUE)
.prt.aictab (aictab, digits = 1)
.prt.grps   (ngrps, nobs)
.prt.warn   (optinfo, summary = FALSE, ...)

.prt.VC (varcor, digits, comp = "Std.Dev.", corr = any(comp == "Std.Dev."),
         formatter = format, ...)
formatVC(varcor, digits = max(3, getOption("digits") - 2),
         comp = "Std.Dev.", corr = any(comp == "Std.Dev."),
         formatter = format,
         useScale = attr(varcor, "useSc"), ...)
</code></pre>


<h3>Arguments</h3>


<table role = "presentation">
<tr><td><code id="prt-utilities_+3A_object">object</code></td>
<td>
<p>a LMM model fit</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_deviancefun">devianceFUN</code></td>
<td>
<p>the function to be used for computing the deviance;
should not be changed for <span class="pkg">lme4</span> created objects.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_chkreml">chkREML</code></td>
<td>
<p>optional logical indicating if <code>object</code> maybe a REML
fit.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_devcomp">devcomp</code></td>
<td>
<p>for <span class="pkg">lme4</span> always the equivalent of
<code>object@devcomp</code>; here a <code><a href="base.html#topic+list">list</a></code></p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_dims">dims</code></td>
<td>
<p>for <span class="pkg">lme4</span> always the equivalent of
<code>object@devcomp$dims</code>, a named vector or list with components
<code>"GLMM"</code>, <code>"NLMM"</code>, <code>"REML"</code>, and <code>"nAGQ"</code> of
which the first two are <code><a href="base.html#topic+logical">logical</a></code> scalars, and the latter
two typically are <code>FALSE</code> or <code><a href="base.html#topic+numeric">numeric</a></code>.</p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_mtit">mtit</code></td>
<td>
<p>the result of <code>methTitle(object)</code></p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_class">class</code></td>
<td>
<p>typically <code><a href="base.html#topic+class">class</a>(object)</code>.</p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_faml">famL</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with components <code>family</code> and
<code>link</code>, each a <code><a href="base.html#topic+character">character</a></code> string; note that standard
<span class="rlang"><b>R</b></span> <code><a href="stats.html#topic+family">family</a></code> objects can be used directly, as well.</p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_resids">resids</code></td>
<td>
<p>numeric vector of model <code><a href="stats.html#topic+residuals">residuals</a></code>.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_digits">digits</code></td>
<td>
<p>non-negative integer of (significant) digits to print minimally.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_title">title</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_...">...</code></td>
<td>
<p>optional arguments passed on, e.g., to <code><a href="stats.html#topic+residuals">residuals</a>()</code>.</p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_call">call</code></td>
<td>
<p>the <code><a href="base.html#topic+call">call</a></code> of the model fit; e.g., available
via (generic) function <code><a href="stats.html#topic+getCall">getCall</a>()</code>.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_long">long</code></td>
<td>
<p>logical indicating if the output may be long, e.g.,
printing the <code>control</code> part of the call if there is one.</p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_aictab">aictab</code></td>
<td>
<p>typically the <code>AICtab</code> component of the result of
<code>llikAIC()</code>.</p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_varcor">varcor</code></td>
<td>
<p>typically the result of <code><a href="#topic+VarCorr">VarCorr</a>()</code>.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_comp">comp</code></td>
<td>
<p>optional <code><a href="base.html#topic+character">character</a></code> vector of length 1 or 2,
containing <code>"Std.Dev."</code> and/or <code>"Variance"</code>, indicating the
columns to use.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_corr">corr</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if correlations or
covariances should be used for vector random effects.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_formatter">formatter</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> used for formatting the numbers.</p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_ngrps">ngrps</code></td>
<td>
<p>integer (vector), typically the result of
<code><a href="#topic+ngrps">ngrps</a>(object)</code>.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_nobs">nobs</code></td>
<td>
<p>integer; the number of observations, e.g., the result
of <code><a href="#topic+nobs">nobs</a></code>.</p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_optinfo">optinfo</code></td>
<td>
<p>typically <code>object @ optinfo</code>, the optimization
infos, including warnings if there were.</p>
</td></tr>
<tr><td><code id="prt-utilities_+3A_summary">summary</code></td>
<td>
<p>logical</p>
</td></tr>

<tr><td><code id="prt-utilities_+3A_usescale">useScale</code></td>
<td>
<p>(logical) whether the parent model estimates a scale parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>llikAIC()</code> returns a <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table role = "presentation">
<tr><td><code>logLik</code></td>
<td>
<p>which is <code><a href="stats.html#topic+logLik">logLik</a>(object)</code>, and</p>
</td></tr>
<tr><td><code>AICtab</code></td>
<td>
<p> a &ldquo;table&rdquo; of <code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+BIC">BIC</a></code>,
<code><a href="stats.html#topic+logLik">logLik</a></code>, deviance and <code><a href="stats.html#topic+df.residual">df.residual</a>()</code> values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a few "lme4 standard" models ------------------------------
fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
fmM &lt;- update(fm1, REML=FALSE) # -&gt; Maximum Likelihood
fmQ &lt;- update(fm1, . ~ Days + (Days | Subject))

gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
             data = cbpp, family = binomial)
gmA &lt;- update(gm1, nAGQ = 5)


(lA1 &lt;- llikAIC(fm1))
(lAM &lt;- llikAIC(fmM))
(lAg &lt;- llikAIC(gmA))

(m1 &lt;- methTitle(fm1 @ devcomp $ dims))
(mM &lt;- methTitle(fmM @ devcomp $ dims))
(mG &lt;- methTitle(gm1 @ devcomp $ dims))
(mA &lt;- methTitle(gmA @ devcomp $ dims))

.prt.methTit(m1, class(fm1))
.prt.methTit(mA, class(gmA))

.prt.family(gaussian())
.prt.family(binomial())
.prt.family( poisson())

.prt.resids(residuals(fm1), digits = 4)
.prt.resids(residuals(fmM), digits = 2)

.prt.call(getCall(fm1))
.prt.call(getCall(gm1))

.prt.aictab ( lA1 $ AICtab ) # REML
.prt.aictab ( lAM $ AICtab ) # ML --&gt; AIC, BIC, ...

V1 &lt;- VarCorr(fm1)
m &lt;- formatVC(V1)
stopifnot(is.matrix(m), is.character(m), ncol(m) == 4)
print(m, quote = FALSE) ## prints all but the first line of .prt.VC() below:
.prt.VC( V1, digits = 4)
## Random effects:
##  Groups   Name        Std.Dev. Corr
##  Subject  (Intercept) 24.740
##           Days         5.922   0.07
##  Residual             25.592
p1 &lt;- capture.output(V1)
p2 &lt;- capture.output( print(m, quote=FALSE) )
pX &lt;- capture.output( .prt.VC(V1, digits = max(3, getOption("digits")-2)) )
stopifnot(identical(p1, p2),
          identical(p1, pX[-1])) # [-1] : dropping 1st line

(Vq &lt;- VarCorr(fmQ)) # default print()
print(Vq, comp = c("Std.Dev.", "Variance"))
print(Vq, comp = c("Std.Dev.", "Variance"), corr=FALSE)
print(Vq, comp = "Variance")

.prt.grps(ngrps = ngrps(fm1),
          nobs  = nobs (fm1))
## --&gt; Number of obs: 180, groups:  Subject, 18

.prt.warn(fm1 @ optinfo) # nothing .. had no warnings
.prt.warn(fmQ @ optinfo) # (ditto)
</code></pre>

<hr>
<h2 id='pvalues'>Getting p-values for fitted models</h2><span id='topic+mcmcsamp'></span><span id='topic+pvalues'></span>

<h3>Description</h3>

<p>One of the most frequently asked questions about
<code>lme4</code> is &quot;how do I calculate p-values for estimated
parameters?&quot; Previous versions of <code>lme4</code> provided
the <code>mcmcsamp</code> function, which efficiently generated
a Markov chain Monte Carlo sample from the posterior
distribution of the parameters, assuming flat (scaled
likelihood) priors. Due to difficulty in constructing a
version of <code>mcmcsamp</code> that was reliable even in
cases where the estimated random effect variances were
near zero (e.g.
<a href="https://stat.ethz.ch/pipermail/r-sig-mixed-models/2009q4/003115.html">https://stat.ethz.ch/pipermail/r-sig-mixed-models/2009q4/003115.html</a>),
<code>mcmcsamp</code> has been withdrawn (or more precisely,
not updated to work with <code>lme4</code> versions &gt;=1.0.0).
</p>
<p>Many users, including users of the <code>aovlmer.fnc</code> function from
the <code>languageR</code> package which relies on <code>mcmcsamp</code>, will be
deeply disappointed by this lacuna. Users who need p-values have a
variety of options. In the list below, the methods marked <code>MC</code>
provide explicit model comparisons; <code>CI</code> denotes confidence
intervals; and <code>P</code> denotes parameter-level or sequential tests of
all effects in a model. The starred (*) suggestions provide
finite-size corrections (important when the number of groups is &lt;50);
those marked (+) support GLMMs as well as LMMs.
</p>

<ul>
<li><p> likelihood ratio tests via <code>anova</code> or <code>drop1</code> (MC,+) 
</p>
</li>
<li><p>profile confidence intervals via <code><a href="#topic+profile.merMod">profile.merMod</a></code> and
<code><a href="#topic+confint.merMod">confint.merMod</a></code> (CI,+)

</p>
</li>
<li><p>parametric bootstrap confidence intervals and model comparisons via
<code><a href="#topic+bootMer">bootMer</a></code> (or <code>PBmodcomp</code> in the
<code>pbkrtest</code> package) (MC/CI,*,+)

</p>
</li>
<li><p>for random effects, simulation tests via the <code>RLRsim</code> package
(MC,*)

</p>
</li>
<li><p>for fixed effects, F tests via Kenward-Roger
approximation using <code>KRmodcomp</code> from the
<code>pbkrtest</code> package (MC,*)

</p>
</li>
<li><p><code>car::Anova</code> and
<code>lmerTest::anova</code> provide wrappers for
Kenward-Roger-corrected tests using <code>pbkrtest</code>:
<code>lmerTest::anova</code> also provides t tests via the
Satterthwaite approximation (P,*)

</p>
</li>
<li><p><code>afex::mixed</code> is another wrapper for
<code>pbkrtest</code> and <code>anova</code> providing
&quot;Type 3&quot; tests of all effects (P,*,+)

</p>
</li></ul>

<p><code>arm::sim</code>, or <code><a href="#topic+bootMer">bootMer</a></code>, can be used
to compute confidence intervals on predictions.
</p>
<p>For <code>glmer</code> models, the <code>summary</code> output provides p-values
based on asymptotic Wald tests (P); while this is standard practice
for generalized linear models, these tests make assumptions both about
the shape of the log-likelihood surface and about the accuracy of
a chi-squared approximation to differences in log-likelihoods.
</p>
<p>When all else fails, don't forget to keep p-values in
perspective:
<a href="https://phdcomics.com/comics/archive.php?comicid=905">https://phdcomics.com/comics/archive.php?comicid=905</a>
</p>

<hr>
<h2 id='ranef'>Extract the modes of the random effects</h2><span id='topic+ranef'></span><span id='topic+ranef.merMod'></span><span id='topic+dotplot.ranef.mer'></span><span id='topic+qqmath.ranef.mer'></span><span id='topic+as.data.frame.ranef.mer'></span>

<h3>Description</h3>

<p>A generic function to extract the conditional modes of
the random effects from a fitted model object.  For
linear mixed models the conditional modes of the random
effects are also the conditional means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
 ranef(object, condVar = TRUE,
      drop = FALSE, whichel = names(ans), postVar = FALSE, ...)
## S3 method for class 'ranef.mer'
 dotplot(x, data, main = TRUE, transf = I, level = 0.95, ...)
## S3 method for class 'ranef.mer'
 qqmath(x, data, main = TRUE, level = 0.95, ...)
## S3 method for class 'ranef.mer'
 as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranef_+3A_object">object</code></td>
<td>
<p>an object of a class of fitted models with
random effects, typically a
<code><a href="#topic+merMod-class">merMod</a></code> object.</p>
</td></tr>
<tr><td><code id="ranef_+3A_condvar">condVar</code></td>
<td>
<p>a logical argument indicating if
the conditional variance-covariance matrices of the random effects
should be added as an attribute.</p>
</td></tr>
<tr><td><code id="ranef_+3A_drop">drop</code></td>
<td>
<p>should components of the return value that would be data frames
with a single column, usually a column called
&lsquo;<code>(Intercept)</code>&rsquo;, be returned as named
vectors instead?</p>
</td></tr>
<tr><td><code id="ranef_+3A_whichel">whichel</code></td>
<td>
<p>character vector of names of
grouping factors for which the random effects should be
returned.</p>
</td></tr>
<tr><td><code id="ranef_+3A_postvar">postVar</code></td>
<td>
<p>a (deprecated) synonym for <code>condVar</code></p>
</td></tr>
<tr><td><code id="ranef_+3A_x">x</code></td>
<td>
<p>a random-effects object (of class <code>ranef.mer</code>)
produced by <code>ranef</code></p>
</td></tr>
<tr><td><code id="ranef_+3A_main">main</code></td>
<td>
<p>include a main title, indicating the grouping factor,
on each sub-plot?</p>
</td></tr>
<tr><td><code id="ranef_+3A_transf">transf</code></td>
<td>
<p>transformation for random effects: for example,
<code>exp</code> for plotting parameters from a (generalized)
logistic regression on the odds rather than log-odds scale</p>
</td></tr>
<tr><td><code id="ranef_+3A_data">data</code></td>
<td>
<p>This argument is required by the <code>dotplot</code>
and <code>qqmath</code> generic methods, but is not actually used.</p>
</td></tr>
<tr><td><code id="ranef_+3A_level">level</code></td>
<td>
<p>confidence level for confidence intervals</p>
</td></tr>
<tr><td><code id="ranef_+3A_...">...</code></td>
<td>
<p>some methods for these generic functions
require additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If grouping factor i has k levels and j random effects
per level the ith component of the list returned by
<code>ranef</code> is a data frame with k rows and j columns.
If <code>condVar</code> is <code>TRUE</code> the <code>"postVar"</code>
attribute is an array of dimension j by j by k (or a list
of such arrays).  The kth
face of this array is a positive definite symmetric j by
j matrix.  If there is only one grouping factor in the
model the variance-covariance matrix for the entire
random effects vector, conditional on the estimates of
the model parameters and on the data, will be block
diagonal; this j by j matrix is the kth diagonal
block.  With multiple grouping factors the faces of the
<code>"postVar"</code> attributes are still the diagonal blocks
of this conditional variance-covariance matrix but the
matrix itself is no longer block diagonal.
</p>


<h3>Value</h3>


<ul>
<li>
<p>From <code>ranef</code>:
An object of class <code>ranef.mer</code> composed of
a list of data frames, one for each grouping factor for
the random effects.  The number of rows in the data frame
is the number of levels of the grouping factor.  The
number of columns is the dimension of the random effect
associated with each level of the factor.
</p>
<p>If <code>condVar</code> is <code>TRUE</code> each of the data frames
has an attribute called <code>"postVar"</code>.
</p>

<ul>
<li><p> If there is
a single random-effects term for a given grouping factor,
this attribute is a
three-dimensional array with symmetric faces; each face
contains the variance-covariance matrix for a particular
level of the grouping factor.
</p>
</li>
<li><p> If there is more than one random-effects term for
a given grouping factor (e.g. <code>(1|f) + (0+x|f)</code>),
this attribute is a list of arrays as described above,
one for each term.
</p>
</li></ul>

<p>(The name
of this attribute is a historical artifact,
and may be changed to <code>condVar</code> at some point in the future.)
</p>
<p>When <code>drop</code> is <code>TRUE</code> any components that would
be data frames of a single column are converted to named
numeric vectors.

</p>
</li>
<li>
<p>From <code>as.data.frame</code>:
</p>
<p>This function converts the random effects to a &quot;long format&quot;
data frame with columns
</p>

<dl>
<dt>grpvar</dt><dd><p>grouping variable</p>
</dd>
<dt>term</dt><dd><p>random-effects term, e.g. &ldquo;(Intercept)&rdquo; or
&ldquo;Days&rdquo;</p>
</dd>
<dt>grp</dt><dd><p>level of the grouping variable (e.g., which Subject)</p>
</dd>
<dt>condval</dt><dd><p>value of the conditional mean</p>
</dd>
<dt>condsd</dt><dd><p>conditional standard deviation</p>
</dd>
</dl>

 
</li></ul>
 


<h3>Note</h3>

<p>To produce a (list of) &ldquo;caterpillar plots&rdquo; of the random
effects apply <code><a href="lattice.html#topic+xyplot">dotplot</a></code> to
the result of a call to <code>ranef</code> with <code>condVar =
    TRUE</code>; <code><a href="lattice.html#topic+xyplot">qqmath</a></code> will generate
a list of Q-Q plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lattice) ## for dotplot, qqmath
fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
fm2 &lt;- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy)
fm3 &lt;- lmer(diameter ~ (1|plate) + (1|sample), Penicillin)
ranef(fm1)
str(rr1 &lt;- ranef(fm1))
dotplot(rr1)  ## default
qqmath(rr1)
## specify free scales in order to make Day effects more visible
dotplot(rr1,scales = list(x = list(relation = 'free')))[["Subject"]]
## plot options: ... can specify appearance of vertical lines with
## lty.v, col.line.v, lwd.v, etc..
dotplot(rr1, lty = 3, lty.v = 2, col.line.v = "purple",
        col = "red", col.line.h = "gray")
ranef(fm2)
op &lt;- options(digits = 4)
ranef(fm3, drop = TRUE)
options(op)
## as.data.frame() provides RE's and conditional standard deviations:
str(dd &lt;- as.data.frame(rr1))
if (require(ggplot2)) {
    ggplot(dd, aes(y=grp,x=condval)) +
        geom_point() + facet_wrap(~term,scales="free_x") +
        geom_errorbarh(aes(xmin=condval -2*condsd,
                           xmax=condval +2*condsd), height=0)
}
</code></pre>

<hr>
<h2 id='refit'>Refit a (merMod) Model with a Different Response</h2><span id='topic+refit'></span><span id='topic+refit.merMod'></span>

<h3>Description</h3>

<p>Refit a model, possibly after modifying the response vector.  This
makes use of the model representation and directly goes to the
optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit(object, newresp, ...)

## S3 method for class 'merMod'
refit(object, newresp = NULL, newweights = NULL,
      rename.response = FALSE,
      maxit = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refit_+3A_object">object</code></td>
<td>
<p>a fitted model, usually of class
<code><a href="#topic+lmerMod-class">lmerMod</a></code>, to be refit with a new response.</p>
</td></tr>
<tr><td><code id="refit_+3A_newresp">newresp</code></td>
<td>
<p>an (optional) numeric vector providing the new
response, of the same length as the original response (see
<code>Details</code> for information on NA handling).  May also be a data
frame with a single numeric column, e.g. as produced by
<code>simulate(object)</code>.</p>
</td></tr>
<tr><td><code id="refit_+3A_newweights">newweights</code></td>
<td>
<p>an (optional) numeric vector of new weights</p>
</td></tr>
<tr><td><code id="refit_+3A_rename.response">rename.response</code></td>
<td>
<p>when refitting the model, should the name of
the response variable in the formula and model frame be replaced with
the name of <code>newresp</code>?</p>
</td></tr>
<tr><td><code id="refit_+3A_maxit">maxit</code></td>
<td>
<p>scalar integer, currently only for GLMMs: the maximal
number of Pwrss update iterations.</p>
</td></tr>
<tr><td><code id="refit_+3A_...">...</code></td>
<td>
<p>optional additional parameters.  For the <code>merMod</code>
method, <code>control</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Refit a model, possibly after modifying the response vector.  This
could be done using <code><a href="stats.html#topic+update">update</a>()</code>, but the <code>refit()</code>
approach should be faster because it bypasses the creation of the
model representation and goes directly to the optimization step.
</p>
<p>Setting <code>rename.response = TRUE</code> may be necessary if one
wants to do further operations (such as <code>update</code>) on the fitted
model.  However, the refitted model will still be slightly different
from the equivalent model fitted via <code>update</code>; in particular, the
<code>terms</code> component is not updated to reflect the new response
variable, if it has a different name from the original.
</p>
<p>If <code>newresp</code> has an <code>na.action</code> attribute, then it is
assumed that NA values have already been removed from the numeric
vector; this allows the results of <code><a href="stats.html#topic+simulate">simulate</a>(object)</code> to
be used even if the original response vector contained NA values.
Otherwise, the length of <code>newresp</code> must be the same as the
<em>original</em> length of the response.
</p>


<h3>Value</h3>

<p>an object like <code>x</code>, but fit to a different response vector <code class="reqn">Y</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update.merMod">update.merMod</a></code> for more flexible and extensive model
refitting;
<code><a href="#topic+refitML">refitML</a></code> for refitting a REML fitted model with maximum
likelihood (&lsquo;ML&rsquo;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Ex. 1: using refit() to fit each column in a matrix of responses -------
set.seed(101)
Y &lt;- matrix(rnorm(1000),ncol=10)
## combine first column of responses with predictor variables
d &lt;- data.frame(y=Y[,1],x=rnorm(100),f=rep(1:10,10))
## (use check.conv.grad="ignore" to disable convergence checks because we
##  are using a fake example)
## fit first response
fit1 &lt;- lmer(y ~ x+(1|f), data = d,
             control= lmerControl(check.conv.grad="ignore",
                                  check.conv.hess="ignore"))
## combine fit to first response with fits to remaining responses
res &lt;- c(fit1, lapply(as.data.frame(Y[,-1]), refit, object=fit1))

## Ex. 2: refitting simulated data using data that contain NA values ------
sleepstudyNA &lt;- sleepstudy
sleepstudyNA$Reaction[1:3] &lt;- NA
fm0 &lt;- lmer(Reaction ~ Days + (1|Subject), sleepstudyNA)
## the special case of refitting with a single simulation works ...
ss0 &lt;- refit(fm0, simulate(fm0))
## ... but if simulating multiple responses (for efficiency),
## need to use na.action=na.exclude in order to have proper length of data
fm1 &lt;- lmer(Reaction ~ Days + (1|Subject), sleepstudyNA, na.action=na.exclude)
ss &lt;- simulate(fm1, 5)
res2 &lt;- refit(fm1, ss[[5]])
</code></pre>

<hr>
<h2 id='refitML'>Refit a Model by Maximum Likelihood Criterion</h2><span id='topic+refitML'></span><span id='topic+refitML.merMod'></span>

<h3>Description</h3>

<p>Refit a (<code>merMod</code>) model using the maximum likelihood criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refitML(x, ...)
## S3 method for class 'merMod'
 refitML(x, optimizer = "bobyqa", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refitML_+3A_x">x</code></td>
<td>
<p>a fitted model, usually of class
<code>"<a href="#topic+lmerMod-class">lmerMod</a>"</code>, to be refit according to the maximum
likelihood criterion.</p>
</td></tr>
<tr><td><code id="refitML_+3A_...">...</code></td>
<td>
<p>optional additional parameters.  None are used
at present.</p>
</td></tr>
<tr><td><code id="refitML_+3A_optimizer">optimizer</code></td>
<td>
<p>a string indicating the optimizer to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily used to get a maximum likelihood fit of a
linear mixed-effects model for an <code><a href="stats.html#topic+anova">anova</a></code> comparison.
</p>


<h3>Value</h3>

<p>an object like <code>x</code> but fit by maximum likelihood
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+refit">refit</a></code> and <code><a href="#topic+update.merMod">update.merMod</a></code> for more
extensive refitting.
</p>

<hr>
<h2 id='rePCA'>PCA of random-effects covariance matrix</h2><span id='topic+rePCA'></span>

<h3>Description</h3>

<p>PCA of random-effects variance-covariance estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rePCA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rePCA_+3A_x">x</code></td>
<td>
<p>a <code>merMod</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform a Principal Components Analysis (PCA) of the random-effects
variance-covariance estimates from a fitted mixed-effects model.
This allows the user to detect and diagnose overfitting problems
in the random effects model (see Bates et al. 2015 for details).
</p>


<h3>Value</h3>

<p>a <code>prcomplist</code> object
</p>


<h3>Author(s)</h3>

<p>Douglas Bates
</p>


<h3>References</h3>


<ul>
<li><p> Douglas Bates, Reinhold Kliegl, Shravan Vasishth, and Harald Baayen.
Parsimonious Mixed Models. arXiv:1506.04967 [stat], June 2015. arXiv:
1506.04967.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+isSingular">isSingular</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  fm1 &lt;- lmer(Reaction~Days+(Days|Subject), sleepstudy)
  rePCA(fm1)
</code></pre>

<hr>
<h2 id='rePos'>Generator object for the rePos (random-effects positions) class</h2><span id='topic+rePos'></span>

<h3>Description</h3>

<p>The generator object for the <code><a href="#topic+rePos-class">rePos</a></code>
class used to determine the positions and orders of
random effects associated with particular random-effects
terms in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rePos(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rePos_+3A_...">...</code></td>
<td>
<p>Argument list (see Note).</p>
</td></tr>
</table>


<h3>Methods</h3>

 <dl>
<dt><code>new(mer=mer)</code></dt><dd><p>Create a new
<code><a href="#topic+rePos-class">rePos</a></code> object.</p>
</dd> </dl>



<h3>Note</h3>

<p>Arguments to the <code>new</code> methods must be named
arguments. <code>mer</code>, an object of class
<code>"<a href="#topic+merMod-class">merMod</a>"</code>, is the only
required/expected argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rePos-class">rePos</a></code>
</p>

<hr>
<h2 id='rePos-class'>Class <code>"rePos"</code></h2><span id='topic+rePos-class'></span>

<h3>Description</h3>

<p>A reference class for determining the positions in the
random-effects vector that correspond to particular
random-effects terms in the model formula
</p>


<h3>Extends</h3>

<p>All reference classes extend and inherit methods from
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("rePos")
</code></pre>

<hr>
<h2 id='residuals.merMod'>residuals of merMod objects</h2><span id='topic+residuals.glmResp'></span><span id='topic+residuals.lmResp'></span><span id='topic+residuals.merMod'></span>

<h3>Description</h3>

<p>residuals of merMod objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'merMod'
 residuals(object,
    type = if (isGLMM(object)) "deviance" else "response",
    scaled = FALSE, ...)

  ## S3 method for class 'lmResp'
 residuals(object,
    type = c("working", "response", "deviance", "pearson", "partial"),
    ...)

  ## S3 method for class 'glmResp'
 residuals(object,
    type = c("deviance", "pearson", "working", "response", "partial"),
    ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.merMod_+3A_object">object</code></td>
<td>
<p>a fitted [g]lmer (<code>merMod</code>) object</p>
</td></tr>
<tr><td><code id="residuals.merMod_+3A_type">type</code></td>
<td>
<p>type of residuals</p>
</td></tr>
<tr><td><code id="residuals.merMod_+3A_scaled">scaled</code></td>
<td>
<p>scale residuals by residual standard
deviation (=scale parameter)?</p>
</td></tr>
<tr><td><code id="residuals.merMod_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored: for method
compatibility)</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li><p> The default residual type varies between
<code>lmerMod</code> and <code>glmerMod</code> objects: they try to
mimic <code><a href="stats.html#topic+residuals.lm">residuals.lm</a></code> and
<code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code> respectively. In particular,
the default <code>type</code> is <code>"response"</code>, i.e.
(observed-fitted) for <code>lmerMod</code> objects vs.
<code>"deviance"</code> for <code>glmerMod</code> objects.
<code>type="partial"</code> is not yet implemented for either
type. </p>
</li>
<li><p> Note that the meaning of <code>"pearson"</code>
residuals differs between <code><a href="stats.html#topic+residuals.lm">residuals.lm</a></code> and
<code><a href="nlme.html#topic+residuals.lme">residuals.lme</a></code>.  The former returns values
scaled by the square root of user-specified weights (if
any), but <em>not</em> by the residual standard deviation,
while the latter returns values scaled by the estimated
standard deviation (which will include the effects of any
variance structure specified in the <code>weights</code>
argument).  To replicate <code>lme</code> behaviour, use
<code>type="pearson"</code>, <code>scaled=TRUE</code>. </p>
</li></ul>


<hr>
<h2 id='sigma'>Extract Residual Standard Deviation 'Sigma'</h2><span id='topic+sigma'></span><span id='topic+sigma.merMod'></span>

<h3>Description</h3>

<p>Extract the estimated standard deviation of the errors, the
&ldquo;residual standard deviation&rdquo; (also misnamed the
&ldquo;residual standard error&rdquo;), from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma_+3A_object">object</code></td>
<td>
<p>a fitted model.</p>
</td></tr>
<tr><td><code id="sigma_+3A_...">...</code></td>
<td>
<p>additional, optional arguments, passed from or to
methods. (None currently in our two methods.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <span class="pkg">lme4</span> provides methods for mixed-effects models of class
<code><a href="#topic+merMod-class">merMod</a></code> and lists of linear models, <code><a href="#topic+lmList4-class">lmList4</a></code>.
</p>


<h3>Value</h3>

<p>Typically a number, the estimated standard deviation of the
errors (&ldquo;residual standard deviation&rdquo;) for Gaussian
models, and - less interpretably - the square root of the residual
deviance per degree of freedom in more general models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>methods(sigma)# from R 3.3.0 on, shows methods from pkgs 'stats' *and* 'lme4'
</code></pre>

<hr>
<h2 id='simulate.formula'>A <code>simulate</code> Method for <code>formula</code> objects that dispatches based on the Left-Hand Side</h2><span id='topic+simulate.formula'></span>

<h3>Description</h3>

<p>This method evaluates the left-hand side (LHS) of the given formula and
dispatches it to an appropriate method based on the result by
setting an nonce class name on the formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
simulate(object, nsim = 1 , seed = NULL, ...,
basis, newdata, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.formula_+3A_object">object</code></td>
<td>
<p>a one- or two-sided <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.formula_+3A_nsim">nsim</code>, <code id="simulate.formula_+3A_seed">seed</code></td>
<td>
<p>number of realisations to simulate and the random
seed to use; see <code><a href="stats.html#topic+simulate">simulate</a></code></p>
</td></tr>
<tr><td><code id="simulate.formula_+3A_...">...</code></td>
<td>
<p>additional arguments to methods</p>
</td></tr>
<tr><td><code id="simulate.formula_+3A_basis">basis</code></td>
<td>
<p>if given, overrides the LHS of the formula for the
purposes of dispatching</p>
</td></tr>
<tr><td><code id="simulate.formula_+3A_newdata">newdata</code>, <code id="simulate.formula_+3A_data">data</code></td>
<td>
<p>if passed, the <code>object</code>'s LHS is evaluated in
this environment; at most one of the two may be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dispatching works as follows:
</p>

<ol>
<li><p> If <code>basis</code> is not passed, and the formula has an LHS the
expression on the LHS of the formula in the <code>object</code> is
evaluated in the environment <code>newdata</code> or <code>data</code> (if given), in
any case enclosed by the environment of <code>object</code>. Otherwise,
<code>basis</code> is used.
</p>
</li>
<li><p> The result is set as an attribute <code>".Basis"</code> on <code>object</code>. If
there is no <code>basis</code> or LHS, it is not set.
</p>
</li>
<li><p> The class vector of <code>object</code> has <code>c("formula_lhs_<var>CLASS</var>",
   "formula_lhs")</code> prepended to it, where <var>CLASS</var> is the class
of the LHS value or <code>basis</code>. If LHS or <code>basis</code> has multiple
classes, they are all prepended; if there is no LHS or <code>basis</code>,
<code>c("formula_lhs_", "formula_lhs")</code> is.
</p>
</li>
<li> <p><code><a href="stats.html#topic+simulate">simulate</a></code> generic is evaluated on the new <code>object</code>, with all
arguments passed on, excluding <code>basis</code>; if <code>newdata</code> or <code>data</code>
are missing, they too are not passed on. The evaluation takes
place in the parent's environment.
</p>
</li></ol>

<p>A &quot;method&quot; to receive a formula whose LHS evaluates to <var>CLASS</var>
can therefore be implemented by a function
<code>simulate.formula_lhs_<var>CLASS</var>()</code>. This function can expect a
<code><a href="stats.html#topic+formula">formula</a></code> object, with additional attribute <code>.Basis</code> giving the
evaluated LHS (so that it does not need to be evaluated again).
</p>

<hr>
<h2 id='simulate.merMod'>Simulate Responses From <code><a href="#topic+merMod-class">merMod</a></code> Object</h2><span id='topic+simulate.merMod'></span><span id='topic+.simulateFun'></span>

<h3>Description</h3>

<p>Simulate responses from a <code>"merMod"</code> fitted model object, i.e.,
from the model represented by it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
simulate(object, nsim = 1, seed = NULL,
	 use.u = FALSE, re.form = NA,
	 newdata=NULL, newparams=NULL, family=NULL,
	 allow.new.levels = FALSE, na.action = na.pass, ...)

.simulateFun(object, nsim = 1, seed = NULL, use.u = FALSE,
             re.form = NA,
             newdata=NULL, newparams=NULL,
             formula=NULL, family=NULL, weights=NULL, offset=NULL,
             allow.new.levels = FALSE, na.action = na.pass,
             cond.sim = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.merMod_+3A_object">object</code></td>
<td>
<p>(for <code>simulate.merMod</code>) a fitted model object or
(for <code>simulate.formula</code>) a (one-sided) mixed model formula, as
described for <code><a href="#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_nsim">nsim</code></td>
<td>
<p>positive integer scalar - the number of responses to simulate.</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_seed">seed</code></td>
<td>
<p>an optional seed to be used in <code><a href="base.html#topic+set.seed">set.seed</a></code>
immediately before the simulation so as to generate a reproducible sample.</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_use.u">use.u</code></td>
<td>
<p>(logical) if <code>TRUE</code>, generate a simulation
conditional on the current random-effects estimates; if <code>FALSE</code>
generate new Normally distributed random-effects values. (Redundant
with <code>re.form</code>, which is preferred: <code>TRUE</code> corresponds to
<code>re.form = NULL</code> (condition on all random effects), while
<code>FALSE</code> corresponds to <code>re.form = ~0</code> (condition on none
of the random effects).)</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_re.form">re.form</code></td>
<td>
<p>formula for random effects to condition on.  If
<code>NULL</code>, condition on all random effects; if <code>NA</code> or <code>~0</code>,
condition on no random effects.  See Details.</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_newdata">newdata</code></td>
<td>
<p>data frame for which to evaluate predictions.</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_newparams">newparams</code></td>
<td>
<p>new parameters to use in evaluating predictions,
specified as in the <code>start</code> parameter for <code><a href="#topic+lmer">lmer</a></code> or
<code><a href="#topic+glmer">glmer</a></code> &ndash; a list with components <code>theta</code> and
<code>beta</code> and (for LMMs or GLMMs that estimate a scale parameter)
<code>sigma</code></p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_formula">formula</code></td>
<td>
<p>a (one-sided) mixed model formula, as described for
<code><a href="#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_family">family</code></td>
<td>
<p>a GLM family, as in <code><a href="#topic+glmer">glmer</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_weights">weights</code></td>
<td>
<p>prior weights, as in <code><a href="#topic+lmer">lmer</a></code> or
<code><a href="#topic+glmer">glmer</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_offset">offset</code></td>
<td>
<p>offset, as in <code><a href="#topic+glmer">glmer</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_allow.new.levels">allow.new.levels</code></td>
<td>
<p>(logical) if FALSE (default), then any new
levels (or <code>NA</code> values) detected in <code>newdata</code> will trigger an
error; if TRUE, then the prediction will use the unconditional
(population-level) values for data with previously unobserved levels
(or <code>NA</code>s).</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_na.action">na.action</code></td>
<td>
<p>what to do with <code>NA</code> values in new data: see
<code><a href="stats.html#topic+na.fail">na.fail</a></code></p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_cond.sim">cond.sim</code></td>
<td>
<p>(experimental) simulate the conditional
distribution?  if <code>FALSE</code>, simulate only random effects; do not
simulate from the conditional distribution, rather return the
predicted group-level values</p>
</td></tr>
<tr><td><code id="simulate.merMod_+3A_...">...</code></td>
<td>
<p>optional additional arguments (none are used in
<code>.simulateFormula</code>)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>ordinarily <code>simulate</code> is used to generate new
values from an existing, fitted model (<code>merMod</code> object):
however, if <code>formula</code>, <code>newdata</code>, and <code>newparams</code> are
specified, <code>simulate</code> generates the appropriate model
structure to simulate from. <code>formula</code> must be a
<em>one-sided</em> formula (i.e. with an empty left-hand side);
in general, if <code>f</code> is a two-sided
formula, <code>f[-2]</code> can be used to drop the LHS.
</p>
</li>
<li><p>The <code>re.form</code> argument allows the user to specify how the
random effects are incorporated in the simulation.  All of the
random effects terms included in <code>re.form</code> will be
<em>conditioned on</em> - that is, the conditional modes of those
random effects will be included in the deterministic part of the
simulation. (If new levels are used (and <code>allow.new.levels</code>
is <code>TRUE</code>), the conditional modes for these levels will be
set to the population mode, i.e. values of zero will be used for
the random effects.)  Conversely, the random effect terms that are
<em>not</em> included in <code>re.form</code> will be <em>simulated
from</em> - that is, new values will be chosen for each group based on
the estimated random-effects variances.
</p>
<p>The default behaviour (using <code>re.form=NA</code>) is to condition on
none of the random effects, simulating new values for all of the
random effects.
</p>

</li>
<li><p>For Gaussian fits, <code>sigma</code> specifies the residual
standard deviation; for Gamma fits, it specifies the shape
parameter (the rate parameter for each observation i
is calculated as shape/mean(i)).  For negative binomial fits,
the overdispersion parameter is specified via the family,
e.g. <code>simulate(..., family=negative.binomial(theta=1.5))</code>.

</p>
</li>
<li><p>For binomial models, <code>simulate.formula</code> looks for the
binomial size first in the <code>weights</code> argument (if it's supplied),
second from the left-hand side of the formula (if the formula has been
specified in success/failure form), and defaults to 1 if neither of
those have been supplied.
Simulated responses will be given as proportions, unless the supplied
formula has a matrix-valued left-hand side, in which case they will be
given in matrix form. If a left-hand side is given, variables in that
expression must be available in <code>newdata</code>.

</p>
</li>
<li><p>For negative binomial models, use the <code>negative.binomial</code>
family (from the <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a> package)
and specify the overdispersion parameter via the
<code>theta</code> (sic) parameter of the family function, e.g.
<code>simulate(...,family=negative.binomial(theta=1))</code> to simulate
from a geometric distribution (negative binomial with
overdispersion parameter 1).

</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bootMer">bootMer</a></code> for &ldquo;simulestimate&rdquo;, i.e., where each
simulation is followed by refitting the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## test whether fitted models are consistent with the
##  observed number of zeros in CBPP data set:
gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
             data = cbpp, family = binomial)
gg &lt;- simulate(gm1,1000)
zeros &lt;- sapply(gg,function(x) sum(x[,"incidence"]==0))
plot(table(zeros))
abline(v=sum(cbpp$incidence==0),col=2)
##
## simulate from a non-fitted model; in this case we are just
## replicating the previous model, but starting from scratch
params &lt;- list(theta=0.5,beta=c(2,-1,-2,-3))
simdat &lt;- with(cbpp,expand.grid(herd=levels(herd),period=factor(1:4)))
simdat$size &lt;- 15
simdat$incidence &lt;- sample(0:1,size=nrow(simdat),replace=TRUE)
form &lt;- formula(gm1)[-2]  ## RHS of equation only
simulate(form,newdata=simdat,family=binomial,
    newparams=params)
## simulate from negative binomial distribution instead
simulate(form,newdata=simdat,family=negative.binomial(theta=2.5),
    newparams=params)
</code></pre>

<hr>
<h2 id='sleepstudy'>Reaction times in a sleep deprivation study</h2><span id='topic+sleepstudy'></span>

<h3>Description</h3>

<p>The average reaction time per day (in milliseconds) for subjects in a sleep
deprivation study.
</p>
<p>Days 0-1 were adaptation and training (T1/T2), day 2 was baseline (B);
sleep deprivation started after day 2.
</p>


<h3>Format</h3>

<p>A data frame with 180 observations on the following 3 variables.
</p>

<dl>
<dt><code>Reaction</code></dt><dd><p>Average reaction time (ms)</p>
</dd>
<dt><code>Days</code></dt><dd><p>Number of days of sleep deprivation</p>
</dd>
<dt><code>Subject</code></dt><dd><p>Subject number on which the observation was made.</p>
</dd>
</dl>


<h3>Details</h3>

<p>These data are from the study described in Belenky et al.
(2003), for the most sleep-deprived group (3 hours time-in-bed)
and for the first 10 days of the study, up to the recovery period.
The original study analyzed speed (1/(reaction time)) and treated
day as a categorical rather than a continuous predictor.
</p>


<h3>References</h3>

<p>Gregory Belenky, Nancy J. Wesensten, David R. Thorne,
Maria L. Thomas, Helen C. Sing, Daniel P. Redmond,
Michael B. Russo and Thomas J. Balkin (2003) Patterns of
performance degradation and restoration during sleep
restriction and subsequent recovery: a sleep
dose-response study. <em>Journal of Sleep Research</em>
<b>12</b>, 1&ndash;12.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(sleepstudy)
require(lattice)
xyplot(Reaction ~ Days | Subject, sleepstudy, type = c("g","p","r"),
       index = function(x,y) coef(lm(y ~ x))[1],
       xlab = "Days of sleep deprivation",
       ylab = "Average reaction time (ms)", aspect = "xy")
(fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy, subset=Days&gt;=2))
## independent model
(fm2 &lt;- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy, subset=Days&gt;=2))
</code></pre>

<hr>
<h2 id='subbars'>&quot;Sub[stitute] Bars&quot;</h2><span id='topic+subbars'></span>

<h3>Description</h3>

<p>Substitute the '+' function for the '|' function in a mixed-model
formula, recursively (hence the argument name <code>term</code>).  This
provides a formula suitable for the current <code><a href="stats.html#topic+model.frame">model.frame</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  subbars(term)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subbars_+3A_term">term</code></td>
<td>
<p>a mixed-model formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the formula with all | operators replaced by +
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>
<p>Other utilities: <code><a href="#topic+findbars">findbars</a></code>, <code><a href="#topic+nobars">nobars</a></code>,
<code><a href="#topic+mkRespMod">mkRespMod</a></code>, <code><a href="#topic+mkReTrms">mkReTrms</a></code>,
<code><a href="#topic+nlformula">nlformula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subbars(Reaction ~ Days + (Days|Subject)) ## =&gt; Reaction ~ Days + (Days + Subject)
</code></pre>

<hr>
<h2 id='troubleshooting'>Troubleshooting</h2><span id='topic+troubleshooting'></span>

<h3>Description</h3>

<p>This page attempts to summarize some of the common problems with
fitting <code>[gn]lmer</code> models and how to troubleshoot them.
</p>
<p>Most of the symptoms/diagnoses/workarounds listed below are due to
various issues in the actual mixed model fitting process. You may
run into problems due to multicollinearity or variables that are
incorrectly typed (e.g. a variable is accidentally coded as character
or factor rather than numeric). These problems can often be isolated
by trying a <code>lm</code> or <code>glm</code> fit or attempting to construct the
design matrix via <code>model.matrix()</code> (in each case with the random
effects in your model excluded). If these tests fail then the problem
is likely not specifically an <code>lme4</code> issue.
</p>

<ul>
<li> <p><code>failure to converge in (xxxx) evaluations</code> The
optimizer hit its maximum limit of function evaluations.  To
increase this, use the <code>optControl</code> argument of
<code>[g]lmerControl</code> &ndash; for <code>Nelder_Mead</code> and <code>bobyqa</code>
the relevant parameter is <code>maxfun</code>; for <code>optim</code> and
<code>optimx</code>-wrapped optimizers, including
<code>nlminbwrap</code>, it's <code>maxit</code>; for
<code>nloptwrap</code>, it's <code>maxeval</code>.
</p>
</li>
<li> <p><code>Model failed to converge with max|grad| ...</code> The scaled
gradient at the fitted (RE)ML estimates
is worryingly large. Try
</p>

<ul>
<li><p> refitting the parameters starting at the current
estimates: getting consistent results (with no warning)
suggests a false positive
</p>
</li>
<li><p> switching optimizers: getting consistent
results suggests there is not really a problem; getting a similar
log-likelihood with different parameter estimates suggests that
the parameters are poorly determined (possibly the result of
a misspecified or overfitted model)
</p>
</li>
<li><p> compute values of the deviance in the neighbourhood of the estimated
parameters to double-check that <code>lme4</code> has really found a
local optimum.
</p>
</li></ul>

</li>
<li> <p><code>Hessian is numerically singular: parameters are not
      uniquely determined</code>
The Hessian (inverse curvature matrix) at the maximum likelihood or REML
estimates has a very large eigenvalue, indicating that (within numerical
tolerances) the surface is completely flat in some direction.
The model may be misspecified, or extremely badly scaled (see
<code>"Model is nearly unidentifiable"</code>).
</p>
</li>
<li> <p><code>Model is nearly unidentifiable ... Rescale variables?</code>
The Hessian (inverse curvature matrix) at the maximum likelihood or REML
estimates has a large eigenvalue, indicating that the surface is
nearly flat in some direction. Consider centering and/or scaling
continuous predictor variables.
</p>
</li>
<li> <p><code>Contrasts can be applied only to factors with 2 or more levels</code>
One or more of the categorical predictors in the model has fewer than two
levels. This may be due to user error when converting these predictors to 
factors prior to modeling, or it may result from some factor levels being
eliminated due to <code>NA</code>s in other predictors. Double-check the number
of data points in each factor level to see which one is the culprit:
<code>lapply(na.omit(df[,vars]), table)</code> (where <code>df</code> is the 
<code>data.frame</code> and <code>vars</code> are the column names of your predictor
variables).
</p>
</li></ul>


<hr>
<h2 id='VarCorr'>Extract Variance and Correlation Components</h2><span id='topic+VarCorr'></span><span id='topic+VarCorr.merMod'></span><span id='topic+as.data.frame.VarCorr.merMod'></span><span id='topic+print.VarCorr.merMod'></span>

<h3>Description</h3>

<p>This function calculates the estimated variances,
standard deviations, and correlations between the
random-effects terms in a mixed-effects model, of class
<code><a href="#topic+merMod-class">merMod</a></code> (linear, generalized or
nonlinear).  The within-group error variance and standard
deviation are also calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
VarCorr(x, sigma=1, ...)

## S3 method for class 'VarCorr.merMod'
as.data.frame(x, row.names = NULL,
    optional = FALSE, order = c("cov.last", "lower.tri"), ...)
## S3 method for class 'VarCorr.merMod'
print(x, digits = max(3, getOption("digits") - 2),
    comp = "Std.Dev.", corr = any(comp == "Std.Dev."),
    formatter = format, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VarCorr_+3A_x">x</code></td>
<td>
<p>for <code>VarCorr</code>: a fitted model object, usually an object inheriting from
class <code><a href="#topic+merMod-class">merMod</a></code>. For <code>as.data.frame</code>, a
<code>VarCorr.merMod</code> object returned from <code>VarCorr</code>.</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_sigma">sigma</code></td>
<td>
<p>an optional numeric value used as a multiplier for the
standard deviations.</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_digits">digits</code></td>
<td>
<p>an optional integer value specifying the number of digits</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_order">order</code></td>
<td>
<p>arrange data frame with variances/standard deviations
first and covariances/correlations last for each random effects
term (<code>"cov.last"</code>), or in the order of the lower triangle of the
variance-covariance matrix (<code>"lower.tri"</code>)?</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_row.names">row.names</code>, <code id="VarCorr_+3A_optional">optional</code></td>
<td>
<p>Ignored: necessary for the
<code>as.data.frame</code> method.</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_...">...</code></td>
<td>
<p>Ignored for the <code>as.data.frame</code> method; passed to
other <code><a href="base.html#topic+print">print</a>()</code> methods for the <code>print()</code> method.</p>
</td></tr>

<tr><td><code id="VarCorr_+3A_comp">comp</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> vector, specifying the components
to be printed; simply passed to <code><a href="#topic+formatVC">formatVC</a>()</code>.</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_formatter">formatter</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> for formatting the numbers;
simply passed to <code><a href="#topic+formatVC">formatVC</a>()</code>.</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_corr">corr</code></td>
<td>
<p>(logical) print correlations (rather than covariances) of
random effects?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method for <code>VarCorr.merMod</code> objects
has optional arguments <code>digits</code> (specify digits of
precision for printing) and <code>comp</code>: the latter is
a character vector with any combination of <code>"Variance"</code>
and <code>"Std.Dev."</code>, to specify whether variances,
standard deviations, or both should be printed.
</p>


<h3>Value</h3>

<p>An object of class <code>VarCorr.merMod</code>. The internal
structure of the object is
a list of matrices, one for each random effects grouping
term.  For each grouping term, the standard deviations and
correlation matrices for each grouping term are stored as
attributes <code>"stddev"</code> and <code>"correlation"</code>,
respectively, of the variance-covariance matrix, and the
residual standard deviation is stored as attribute
<code>"sc"</code> (for <code>glmer</code> fits, this attribute stores
the scale parameter of the model).
</p>
<p>The <code>as.data.frame</code> method produces a combined data frame with one
row for each variance or covariance parameter (and a row for the
residual error term where applicable) and the following columns:
</p>

<dl>
<dt>grp</dt><dd><p>grouping factor</p>
</dd>
<dt>var1</dt><dd><p>first variable</p>
</dd>
<dt>var2</dt><dd><p>second variable (<code>NA</code> for variance parameters)</p>
</dd>
<dt>vcov</dt><dd><p>variances or covariances</p>
</dd>
<dt>sdcor</dt><dd><p>standard deviations or correlations</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>This is modeled after <code><a href="nlme.html#topic+VarCorr">VarCorr</a></code> from
package <a href="https://CRAN.R-project.org/package=nlme"><span class="pkg">nlme</span></a>, by Jose Pinheiro and Douglas Bates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmer">lmer</a></code>, <code><a href="#topic+nlmer">nlmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Orthodont, package="nlme")
fm1 &lt;- lmer(distance ~ age + (age|Subject), data = Orthodont)
print(vc &lt;- VarCorr(fm1))  ## default print method: standard dev and corr
## both variance and std.dev.
print(vc,comp=c("Variance","Std.Dev."), digits=2)
## variance only
print(vc, comp=c("Variance"))
## standard deviations only, but covariances rather than correlations
print(vc, corr = FALSE)
as.data.frame(vc)
as.data.frame(vc, order="lower.tri")
</code></pre>

<hr>
<h2 id='vcconv'>Convert between representations of (co-)variance structures</h2><span id='topic+vcconv'></span><span id='topic+mlist2vec'></span><span id='topic+vec2mlist'></span><span id='topic+vec2STlist'></span><span id='topic+sdcor2cov'></span><span id='topic+cov2sdcor'></span><span id='topic+Vv_to_Cv'></span><span id='topic+Sv_to_Cv'></span><span id='topic+Cv_to_Vv'></span><span id='topic+Cv_to_Sv'></span>

<h3>Description</h3>

<p>Convert between representations of (co-)variance structures
(EXPERIMENTAL).  See source code for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mlist2vec(L)
  vec2mlist(v, n = NULL, symm = TRUE)
  vec2STlist(v, n = NULL)
  sdcor2cov(m)
  cov2sdcor(V)
  Vv_to_Cv(v, n = NULL, s = 1)
  Sv_to_Cv(v, n = NULL, s = 1)
  Cv_to_Vv(v, n = NULL, s = 1)
  Cv_to_Sv(v, n = NULL, s = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcconv_+3A_l">L</code></td>
<td>
<p>List of symmetric, upper-triangular, or lower-triangular
square matrices.</p>
</td></tr>
<tr><td><code id="vcconv_+3A_v">v</code></td>
<td>
<p>Concatenated vector containing the elements of the
lower-triangle (including the diagonal) of a symmetric or triangular
matrix.</p>
</td></tr>
<tr><td><code id="vcconv_+3A_n">n</code></td>
<td>
<p>Number of rows (and columns) of the resulting matrix.</p>
</td></tr>
<tr><td><code id="vcconv_+3A_symm">symm</code></td>
<td>
<p>Return symmetric matrix if <code>TRUE</code> or lower-triangular
if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vcconv_+3A_m">m</code></td>
<td>
<p>Standard deviation-correlation matrix.</p>
</td></tr>
<tr><td><code id="vcconv_+3A_v">V</code></td>
<td>
<p>Covariance matrix.</p>
</td></tr>
<tr><td><code id="vcconv_+3A_s">s</code></td>
<td>
<p>Scale parameter.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>mlist2vec</code></dt><dd><p>Convert list of matrices to concatenated
vector of lower triangles with an attribute that gives the
dimension of each matrix in the original list. This attribute may
be used to reconstruct the matrices.  Returns a concatenation of
the elements in one triangle of each matrix. An attribute
<code>"clen"</code> gives the dimension of each matrix.</p>
</dd>
<dt><code>vec2mlist</code></dt><dd><p>Convert concatenated vector to list of matrices (lower
triangle or symmetric). These matrices could represent Cholesky
factors, covariance matrices, or correlation matrices (with
standard deviations on the diagonal).</p>
</dd>
<dt><code>vec2STlist</code></dt><dd><p>Convert concatenated vector to list of ST
matrices.</p>
</dd>
<dt><code>sdcor2cov</code></dt><dd><p>Standard deviation-correlation matrix to
covariance matrix convert 'sdcor' format (std dev on diagonal,
cor on off-diag) to and from variance-covariance matrix.</p>
</dd>
<dt><code>cov2sdcor</code></dt><dd><p>Covariance matrix to standard
deviation-correlation matrix (i.e. standard deviations on the
diagonal and correlations off the diagonal).</p>
</dd>
<dt><code>Vv_to_Cv</code></dt><dd><p>Variance-covariance to relative covariance
factor. Returns a vector of elements from the lower triangle of a
relative covariance factor.</p>
</dd>
<dt><code>Sv_to_Cv</code></dt><dd><p>Standard-deviation-correlation to relative covariance
factor. Returns a vector of elements from the lower triangle of a
relative covariance factor.</p>
</dd>
<dt><code>Cv_to_Vv</code></dt><dd><p>Relative covariance factor to
variance-covariance. From unscaled Cholesky vector to (possibly
scaled) variance-covariance vector. Returns a vector of elements
from the lower triangle of a variance-covariance matrix.</p>
</dd>
<dt><code>Cv_to_Sv</code></dt><dd><p>Relative covariance factor to
standard-deviation-correlation.  From unscaled Chol to sd-cor
vector. Returns a vector of elements from the lower triangle of a
standard-deviation-correlation matrix.</p>
</dd>
</dl>



<h3>Value</h3>

<p>(Co-)variance structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec2mlist(1:6)
mlist2vec(vec2mlist(1:6)) # approximate inverse
</code></pre>

<hr>
<h2 id='vcov.merMod'>Covariance matrix of estimated parameters</h2><span id='topic+vcov.merMod'></span><span id='topic+vcov.summary.merMod'></span>

<h3>Description</h3>

<p>Compute the variance-covariance matrix of estimated paramers.
Optionally also computes correlations, or the full (joint)
covariance matrix of the fixed-effect coefficients and the conditional
modes of the random effects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merMod'
vcov(object, correlation = TRUE, sigm = sigma(object),
    use.hessian = NULL, full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.merMod_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+merMod-class">merMod</a></code>, i.e.,
as resulting from <code><a href="#topic+lmer">lmer</a>()</code>, or <code><a href="#topic+glmer">glmer</a>()</code>,
etc.</p>
</td></tr>
<tr><td><code id="vcov.merMod_+3A_correlation">correlation</code></td>
<td>
<p>(logical)
indicates whether the correlation matrix as well as
the variance-covariance matrix is desired
</p>
</td></tr>
<tr><td><code id="vcov.merMod_+3A_sigm">sigm</code></td>
<td>
<p>the residual standard error; by default <code><a href="#topic+sigma">sigma</a>(object)</code>.</p>
</td></tr>
<tr><td><code id="vcov.merMod_+3A_use.hessian">use.hessian</code></td>
<td>
<p>(logical) indicates whether to use the
finite-difference Hessian of the deviance function to compute
standard errors of the fixed effects. See <em>Details</em>.
</p>
</td></tr>
<tr><td><code id="vcov.merMod_+3A_full">full</code></td>
<td>
<p>return the 'full' covariance matrix, i.e. the joint
covariance matrix of the conditional distribution of conditional
modes (as in <code>getME(., "b")</code>) and fixed-effect
parameters. (<code>correlation</code> and <code>use.hessian</code> are
<em>ignored</em> in this case.)
</p>
<p>Note that this option may be slow for models with large numbers of
random-effect levels!
</p>
</td></tr>
<tr><td><code id="vcov.merMod_+3A_...">...</code></td>
<td>
<p>extra arguments for method compatibility (ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>use.hessian = FALSE</code>, the code estimates the
covariance matrix based on internal information about the inverse of
the model matrix (see <code><a href="#topic+getME">getME</a>(.,"RX")</code>). This is exact for
linear mixed models, but approximate for GLMMs.
The default is to use the Hessian whenever the
fixed effect parameters are arguments to the deviance
function (i.e. for GLMMs with <code>nAGQ&gt;0</code>), and to use
<code><a href="#topic+getME">getME</a>(.,"RX")</code> whenever the fixed effect parameters are
profiled out (i.e. for GLMMs with <code>nAGQ==0</code> or LMMs).
</p>
<p><code>use.hessian=FALSE</code> is backward-compatible with older versions
of <code>lme4</code>, but may give less accurate SE estimates when the
estimates of the fixed-effect (see <code><a href="#topic+getME">getME</a>(.,"beta")</code>)
and random-effect (see <code><a href="#topic+getME">getME</a>(.,"theta")</code>) parameters
are correlated.
</p>
<p>However, <code>use.hessian=TRUE</code> is not always more accurate: for some
numerically unstable fits, the approximation using <code>RX</code> is
actually more reliable (because the Hessian has to be computed by
a finite difference approximation, which is also error-prone): see
e.g. <a href="https://github.com/lme4/lme4/issues/720">https://github.com/lme4/lme4/issues/720</a>
</p>


<h3>Value</h3>

<p>a covariance matrix (sparse when <code>full=TRUE</code>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
             data = cbpp, family = binomial)
(v1 &lt;- vcov(fm1))
v2 &lt;- vcov(fm1, correlation = TRUE)
# extract the hidden 'correlation' entry in @factors
as(v2, "corMatrix")
v3 &lt;- vcov(gm1)
v3X &lt;- vcov(gm1, use.hessian  = FALSE)
all.equal(v3, v3X)
## full correlatiom matrix
cv &lt;- vcov(fm1, full = TRUE)
image(cv, xlab = "", ylab = "",
      scales = list(y = list(labels = rownames(cv)),
                    at = seq(nrow(cv)),
                    x = list(labels = NULL)))
</code></pre>

<hr>
<h2 id='VerbAgg'>Verbal Aggression item responses</h2><span id='topic+VerbAgg'></span>

<h3>Description</h3>

<p>These are the item responses to a questionaire on verbal
aggression.  These data are used throughout De Boeck and
Wilson (2004) to illustrate various forms of item
response models.
</p>


<h3>Format</h3>

<p>A data frame with 7584 observations on the following 13 variables.
</p>

<dl>
<dt><code>Anger</code></dt><dd><p>the subject's Trait Anger score as measured on
the State-Trait Anger Expression Inventory (STAXI)</p>
</dd>
<dt><code>Gender</code></dt><dd><p>the subject's gender - a factor with levels
<code>M</code> and <code>F</code></p>
</dd>
<dt><code>item</code></dt><dd><p>the item on the questionaire, as a factor</p>
</dd>
<dt><code>resp</code></dt><dd><p>the subject's response to the item - an ordered
factor with levels <code>no</code> &lt; <code>perhaps</code> &lt; <code>yes</code></p>
</dd>
<dt><code>id</code></dt><dd><p>the subject identifier, as a factor</p>
</dd>
<dt><code>btype</code></dt><dd><p>behavior type - a factor with levels
<code>curse</code>, <code>scold</code> and <code>shout</code></p>
</dd>
<dt><code>situ</code></dt><dd><p>situation type - a factor with levels
<code>other</code> and <code>self</code> indicating other-to-blame and self-to-blame</p>
</dd>
<dt><code>mode</code></dt><dd><p>behavior mode - a factor with levels <code>want</code>
and <code>do</code></p>
</dd>
<dt><code>r2</code></dt><dd><p>dichotomous version of the response - a factor with
levels <code>N</code> and <code>Y</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Data originally from the UC Berkeley BEAR Center; original link is
available at
<a href="https://web.archive.org/web/20221128003829/https://old.bear.berkeley.edu/page/materials-explanatory-item-response-models">https://web.archive.org/web/20221128003829/https://old.bear.berkeley.edu/page/materials-explanatory-item-response-models</a>,
but the data are no longer accessible there.
</p>


<h3>References</h3>

<p>De Boeck and Wilson (2004), <em>Explanatory Item
Response Models</em>, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(VerbAgg)
## Show how  r2 := h(resp) is defined:
with(VerbAgg, stopifnot( identical(r2, {
     r &lt;- factor(resp, ordered=FALSE); levels(r) &lt;- c("N","Y","Y"); r})))

xtabs(~ item + resp, VerbAgg)
xtabs(~ btype + resp, VerbAgg)
round(100 * ftable(prop.table(xtabs(~ situ + mode + resp, VerbAgg), 1:2), 1))
person &lt;- unique(subset(VerbAgg, select = c(id, Gender, Anger)))
require(lattice)
densityplot(~ Anger, person, groups = Gender, auto.key = list(columns = 2),
            xlab = "Trait Anger score (STAXI)")

if(lme4:::testLevel() &gt;= 3) { ## takes about 15 sec
    print(fmVA &lt;- glmer(r2 ~ (Anger + Gender + btype + situ)^2 +
 		   (1|id) + (1|item), family = binomial, data =
		   VerbAgg), corr=FALSE)
} ## testLevel() &gt;= 3
if (interactive()) {
## much faster but less accurate
    print(fmVA0 &lt;- glmer(r2 ~ (Anger + Gender + btype + situ)^2 +
                             (1|id) + (1|item), family = binomial,
                         data = VerbAgg, nAGQ=0L), corr=FALSE)
} ## interactive()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
