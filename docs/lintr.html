<!DOCTYPE html><html lang="en-US"><head><title>Help for package lintr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lintr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lintr-package'><p>Lintr</p></a></li>
<li><a href='#absolute_path_linter'><p>Absolute path linter</p></a></li>
<li><a href='#all_linters'><p>Create a linter configuration based on all available linters</p></a></li>
<li><a href='#all_undesirable_functions'><p>Default undesirable functions and operators</p></a></li>
<li><a href='#any_duplicated_linter'><p>Require usage of <code>anyDuplicated(x) &gt; 0</code> over <code>any(duplicated(x))</code></p></a></li>
<li><a href='#any_is_na_linter'><p>Require usage of <code>anyNA(x)</code> over <code>any(is.na(x))</code></p></a></li>
<li><a href='#assignment_linter'><p>Assignment linter</p></a></li>
<li><a href='#available_linters'><p>Get Linter metadata from a package</p></a></li>
<li><a href='#backport_linter'><p>Backport linter</p></a></li>
<li><a href='#best_practices_linters'><p>Best practices linters</p></a></li>
<li><a href='#boolean_arithmetic_linter'><p>Require usage of boolean operators over equivalent arithmetic</p></a></li>
<li><a href='#brace_linter'><p>Brace linter</p></a></li>
<li><a href='#checkstyle_output'><p>Checkstyle Report for lint results</p></a></li>
<li><a href='#class_equals_linter'><p>Block comparison of class with <code>==</code></p></a></li>
<li><a href='#clear_cache'><p>Clear the lintr cache</p></a></li>
<li><a href='#commas_linter'><p>Commas linter</p></a></li>
<li><a href='#commented_code_linter'><p>Commented code linter</p></a></li>
<li><a href='#common_mistakes_linters'><p>Common mistake linters</p></a></li>
<li><a href='#comparison_negation_linter'><p>Block usages like !(x == y) where a direct relational operator is appropriate</p></a></li>
<li><a href='#condition_call_linter'><p>Recommend usage of <code>call. = FALSE</code> in conditions</p></a></li>
<li><a href='#condition_message_linter'><p>Block usage of <code>paste()</code> and <code>paste0()</code> with messaging functions using <code>...</code></p></a></li>
<li><a href='#configurable_linters'><p>Configurable linters</p></a></li>
<li><a href='#conjunct_test_linter'><p>Force <code>&amp;&amp;</code> conditions to be written separately where appropriate</p></a></li>
<li><a href='#consecutive_assertion_linter'><p>Force consecutive calls to assertions into just one when possible</p></a></li>
<li><a href='#consecutive_mutate_linter'><p>Require consecutive calls to mutate() to be combined when possible</p></a></li>
<li><a href='#consistency_linters'><p>Consistency linters</p></a></li>
<li><a href='#correctness_linters'><p>Correctness linters</p></a></li>
<li><a href='#cyclocomp_linter'><p>Cyclomatic complexity linter</p></a></li>
<li><a href='#default_linters'><p>Default linters</p></a></li>
<li><a href='#default_settings'><p>Default lintr settings</p></a></li>
<li><a href='#deprecated_linters'><p>Deprecated linters</p></a></li>
<li><a href='#duplicate_argument_linter'><p>Duplicate argument linter</p></a></li>
<li><a href='#efficiency_linters'><p>Efficiency linters</p></a></li>
<li><a href='#empty_assignment_linter'><p>Block assignment of <code>{}</code></p></a></li>
<li><a href='#equals_na_linter'><p>Equality check with NA linter</p></a></li>
<li><a href='#exclude'><p>Exclude lines or files from linting</p></a></li>
<li><a href='#executing_linters'><p>Code executing linters</p></a></li>
<li><a href='#expect_comparison_linter'><p>Require usage of <code>expect_gt(x, y)</code> over <code>expect_true(x &gt; y)</code> (and similar)</p></a></li>
<li><a href='#expect_identical_linter'><p>Require usage of <code>expect_identical(x, y)</code> where appropriate</p></a></li>
<li><a href='#expect_length_linter'><p>Require usage of <code>expect_length(x, n)</code> over <code>expect_equal(length(x), n)</code></p></a></li>
<li><a href='#expect_lint'><p>Lint expectation</p></a></li>
<li><a href='#expect_lint_free'><p>Test that the package is lint free</p></a></li>
<li><a href='#expect_named_linter'><p>Require usage of <code>expect_named(x, n)</code> over <code>expect_equal(names(x), n)</code></p></a></li>
<li><a href='#expect_not_linter'><p>Require usage of <code>expect_false(x)</code> over <code>expect_true(!x)</code></p></a></li>
<li><a href='#expect_null_linter'><p>Require usage of <code>expect_null</code> for checking <code>NULL</code></p></a></li>
<li><a href='#expect_s3_class_linter'><p>Require usage of <code>expect_s3_class()</code></p></a></li>
<li><a href='#expect_s4_class_linter'><p>Require usage of <code>expect_s4_class(x, k)</code> over <code>expect_true(is(x, k))</code></p></a></li>
<li><a href='#expect_true_false_linter'><p>Require usage of <code>expect_true(x)</code> over <code>expect_equal(x, TRUE)</code></p></a></li>
<li><a href='#expect_type_linter'><p>Require usage of <code>expect_type(x, type)</code> over <code>expect_equal(typeof(x), type)</code></p></a></li>
<li><a href='#fixed_regex_linter'><p>Require usage of <code>fixed=TRUE</code> in regular expressions where appropriate</p></a></li>
<li><a href='#for_loop_index_linter'><p>Block usage of for loops directly overwriting the indexing variable</p></a></li>
<li><a href='#function_argument_linter'><p>Function argument linter</p></a></li>
<li><a href='#function_left_parentheses_linter'><p>Function left parentheses linter</p></a></li>
<li><a href='#function_return_linter'><p>Lint common mistakes/style issues cropping up from return statements</p></a></li>
<li><a href='#get_r_string'><p>Extract text from <code>STR_CONST</code> nodes</p></a></li>
<li><a href='#get_source_expressions'><p>Parsed sourced file from a filename</p></a></li>
<li><a href='#ids_with_token'><p>Get parsed IDs by token</p></a></li>
<li><a href='#if_not_else_linter'><p>Block statements like if (!A) x else y</p></a></li>
<li><a href='#if_switch_linter'><p>Require usage of switch() over repeated if/else blocks</p></a></li>
<li><a href='#ifelse_censor_linter'><p>Block usage of <code>ifelse()</code> where <code>pmin()</code> or <code>pmax()</code> is more appropriate</p></a></li>
<li><a href='#implicit_assignment_linter'><p>Avoid implicit assignment in function calls</p></a></li>
<li><a href='#implicit_integer_linter'><p>Implicit integer linter</p></a></li>
<li><a href='#indentation_linter'><p>Check that indentation is consistent</p></a></li>
<li><a href='#infix_spaces_linter'><p>Infix spaces linter</p></a></li>
<li><a href='#inner_combine_linter'><p>Require <code>c()</code> to be applied before relatively expensive vectorized functions</p></a></li>
<li><a href='#is_lint_level'><p>Is this an expression- or a file-level source object?</p></a></li>
<li><a href='#is_numeric_linter'><p>Redirect <code>is.numeric(x) || is.integer(x)</code> to just use <code>is.numeric(x)</code></p></a></li>
<li><a href='#keyword_quote_linter'><p>Block unnecessary quoting in calls</p></a></li>
<li><a href='#length_levels_linter'><p>Require usage of nlevels over length(levels(.))</p></a></li>
<li><a href='#length_test_linter'><p>Check for a common mistake where length is applied in the wrong place</p></a></li>
<li><a href='#lengths_linter'><p>Require usage of <code>lengths()</code> where possible</p></a></li>
<li><a href='#library_call_linter'><p>Library call linter</p></a></li>
<li><a href='#line_length_linter'><p>Line length linter</p></a></li>
<li><a href='#lint'><p>Lint a file, directory, or package</p></a></li>
<li><a href='#lint-s3'><p>Create a <code>lint</code> object</p></a></li>
<li><a href='#Linter'><p>Create a <code>linter</code> closure</p></a></li>
<li><a href='#linters'><p>Available linters</p></a></li>
<li><a href='#linters_with_defaults'><p>Create a linter configuration based on defaults</p></a></li>
<li><a href='#linters_with_tags'><p>Create a tag-based linter configuration</p></a></li>
<li><a href='#lintr-deprecated'><p>Deprecated functions in lintr</p></a></li>
<li><a href='#list_comparison_linter'><p>Block usage of comparison operators with known-list() functions like lapply</p></a></li>
<li><a href='#literal_coercion_linter'><p>Require usage of correctly-typed literals over literal coercions</p></a></li>
<li><a href='#make_linter_from_xpath'><p>Create a linter from an XPath</p></a></li>
<li><a href='#matrix_apply_linter'><p>Require usage of <code>colSums(x)</code> or <code>rowSums(x)</code> over <code>apply(x, ., sum)</code></p></a></li>
<li><a href='#missing_argument_linter'><p>Missing argument linter</p></a></li>
<li><a href='#missing_package_linter'><p>Missing package linter</p></a></li>
<li><a href='#modify_defaults'><p>Modify lintr defaults</p></a></li>
<li><a href='#namespace_linter'><p>Namespace linter</p></a></li>
<li><a href='#nested_ifelse_linter'><p>Block usage of nested <code>ifelse()</code> calls</p></a></li>
<li><a href='#nested_pipe_linter'><p>Block usage of pipes nested inside other calls</p></a></li>
<li><a href='#nonportable_path_linter'><p>Non-portable path linter</p></a></li>
<li><a href='#normalize_exclusions'><p>Normalize lint exclusions</p></a></li>
<li><a href='#nrow_subset_linter'><p>Block usage of <code>nrow(subset(x, .))</code></p></a></li>
<li><a href='#numeric_leading_zero_linter'><p>Require usage of a leading zero in all fractional numerics</p></a></li>
<li><a href='#nzchar_linter'><p>Require usage of nzchar where appropriate</p></a></li>
<li><a href='#object_length_linter'><p>Object length linter</p></a></li>
<li><a href='#object_name_linter'><p>Object name linter</p></a></li>
<li><a href='#object_overwrite_linter'><p>Block assigning any variables whose name clashes with a <code>base</code> R function</p></a></li>
<li><a href='#object_usage_linter'><p>Object usage linter</p></a></li>
<li><a href='#one_call_pipe_linter'><p>Block single-call magrittr pipes</p></a></li>
<li><a href='#outer_negation_linter'><p>Require usage of <code>!any(x)</code> over <code>all(!x)</code>, <code>!all(x)</code> over <code>any(!x)</code></p></a></li>
<li><a href='#package_development_linters'><p>Package development linters</p></a></li>
<li><a href='#package_hooks_linter'><p>Package hooks linter</p></a></li>
<li><a href='#paren_body_linter'><p>Parenthesis before body linter</p></a></li>
<li><a href='#parse_exclusions'><p>read a source file and parse all the excluded lines from it</p></a></li>
<li><a href='#paste_linter'><p>Raise lints for several common poor usages of <code>paste()</code></p></a></li>
<li><a href='#pipe_call_linter'><p>Pipe call linter</p></a></li>
<li><a href='#pipe_consistency_linter'><p>Pipe consistency linter</p></a></li>
<li><a href='#pipe_continuation_linter'><p>Pipe continuation linter</p></a></li>
<li><a href='#pipe_return_linter'><p>Block usage of return() in magrittr pipelines</p></a></li>
<li><a href='#pkg_testthat_linters'><p>Testthat linters</p></a></li>
<li><a href='#print_linter'><p>Block usage of print() for logging</p></a></li>
<li><a href='#quotes_linter'><p>Character string quote linter</p></a></li>
<li><a href='#read_settings'><p>Read lintr settings</p></a></li>
<li><a href='#readability_linters'><p>Readability linters</p></a></li>
<li><a href='#redundant_equals_linter'><p>Block usage of <code>==</code>, <code>!=</code> on logical vectors</p></a></li>
<li><a href='#redundant_ifelse_linter'><p>Prevent <code>ifelse()</code> from being used to produce <code>TRUE</code>/<code>FALSE</code> or <code>1</code>/<code>0</code></p></a></li>
<li><a href='#regex_linters'><p>Regular expression linters</p></a></li>
<li><a href='#regex_subset_linter'><p>Require usage of direct methods for subsetting strings via regex</p></a></li>
<li><a href='#rep_len_linter'><p>Require usage of rep_len(x, n) over rep(x, length.out = n)</p></a></li>
<li><a href='#repeat_linter'><p>Repeat linter</p></a></li>
<li><a href='#return_linter'><p>Return linter</p></a></li>
<li><a href='#robustness_linters'><p>Robustness linters</p></a></li>
<li><a href='#routine_registration_linter'><p>Identify unregistered native routines</p></a></li>
<li><a href='#sample_int_linter'><p>Require usage of sample.int(n, m, ...) over sample(1:n, m, ...)</p></a></li>
<li><a href='#sarif_output'><p>SARIF Report for lint results</p></a></li>
<li><a href='#scalar_in_linter'><p>Block usage like x %in% &quot;a&quot;</p></a></li>
<li><a href='#semicolon_linter'><p>Semicolon linter</p></a></li>
<li><a href='#seq_linter'><p>Sequence linter</p></a></li>
<li><a href='#sort_linter'><p>Check for common mistakes around sorting vectors</p></a></li>
<li><a href='#spaces_inside_linter'><p>Spaces inside linter</p></a></li>
<li><a href='#spaces_left_parentheses_linter'><p>Spaces before parentheses linter</p></a></li>
<li><a href='#sprintf_linter'><p>Require correct <code>sprintf()</code> calls</p></a></li>
<li><a href='#stopifnot_all_linter'><p>Block usage of all() within stopifnot()</p></a></li>
<li><a href='#string_boundary_linter'><p>Require usage of <code>startsWith()</code> and <code>endsWith()</code> over <code>grepl()</code>/<code>substr()</code> versions</p></a></li>
<li><a href='#strings_as_factors_linter'><p>Identify cases where <code>stringsAsFactors</code> should be supplied explicitly</p></a></li>
<li><a href='#style_linters'><p>Style linters</p></a></li>
<li><a href='#system_file_linter'><p>Block usage of <code>file.path()</code> with <code>system.file()</code></p></a></li>
<li><a href='#T_and_F_symbol_linter'><p><code>T</code> and <code>F</code> symbol linter</p></a></li>
<li><a href='#terminal_close_linter'><p>Prohibit close() from terminating a function definition</p></a></li>
<li><a href='#tidy_design_linters'><p>Tidyverse design linters</p></a></li>
<li><a href='#todo_comment_linter'><p>TODO comment linter</p></a></li>
<li><a href='#trailing_blank_lines_linter'><p>Trailing blank lines linter</p></a></li>
<li><a href='#trailing_whitespace_linter'><p>Trailing whitespace linter</p></a></li>
<li><a href='#undesirable_function_linter'><p>Undesirable function linter</p></a></li>
<li><a href='#undesirable_operator_linter'><p>Undesirable operator linter</p></a></li>
<li><a href='#unnecessary_concatenation_linter'><p>Unneeded concatenation linter</p></a></li>
<li><a href='#unnecessary_lambda_linter'><p>Block usage of anonymous functions in iteration functions when unnecessary</p></a></li>
<li><a href='#unnecessary_nesting_linter'><p>Block instances of unnecessary nesting</p></a></li>
<li><a href='#unnecessary_placeholder_linter'><p>Block usage of pipeline placeholders if unnecessary</p></a></li>
<li><a href='#unreachable_code_linter'><p>Block unreachable code and comments following return statements</p></a></li>
<li><a href='#unused_import_linter'><p>Check that imported packages are actually used</p></a></li>
<li><a href='#use_lintr'><p>Use lintr in your project</p></a></li>
<li><a href='#vector_logic_linter'><p>Enforce usage of scalar logical operators in conditional statements</p></a></li>
<li><a href='#which_grepl_linter'><p>Require usage of grep over which(grepl(.))</p></a></li>
<li><a href='#whitespace_linter'><p>Whitespace linter</p></a></li>
<li><a href='#xml_nodes_to_lints'><p>Convert an XML node or nodeset into a Lint</p></a></li>
<li><a href='#xp_call_name'><p>Get the name of the function matched by an XPath</p></a></li>
<li><a href='#yoda_test_linter'><p>Block obvious &quot;yoda tests&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A 'Linter' for R Code</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Checks adherence to a given style, syntax errors and possible
    semantic issues.  Supports on the fly checking of R code edited with
    'RStudio IDE', 'Emacs', 'Vim', 'Sublime Text', 'Atom' and 'Visual
    Studio Code'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lintr.r-lib.org">https://lintr.r-lib.org</a>, <a href="https://github.com/r-lib/lintr">https://github.com/r-lib/lintr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/lintr/issues">https://github.com/r-lib/lintr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>backports (&ge; 1.4.0), cli (&ge; 3.4.0), codetools, digest, glue,
knitr, rex, stats, utils, xml2 (&ge; 1.0.0), xmlparsedata (&ge;
1.0.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, cyclocomp, jsonlite, patrick (&ge; 0.2.0), rlang,
rmarkdown, rstudioapi (&ge; 0.2), testthat (&ge; 3.2.1), tibble,
tufte, withr (&ge; 2.5.0)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>data.table</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/Needs/development:</td>
<td>pkgload, cli, testthat, patrick</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'make_linter_from_xpath.R' 'xp_utils.R' 'utils.R' 'AAA.R'
'T_and_F_symbol_linter.R' 'absolute_path_linter.R' 'actions.R'
'addins.R' 'any_duplicated_linter.R' 'any_is_na_linter.R'
'assignment_linter.R' 'backport_linter.R'
'boolean_arithmetic_linter.R' 'brace_linter.R' 'cache.R'
'class_equals_linter.R' 'commas_linter.R'
'commented_code_linter.R' 'comparison_negation_linter.R'
'condition_call_linter.R' 'condition_message_linter.R'
'conjunct_test_linter.R' 'consecutive_assertion_linter.R'
'consecutive_mutate_linter.R' 'cyclocomp_linter.R'
'declared_functions.R' 'deprecated.R'
'duplicate_argument_linter.R' 'empty_assignment_linter.R'
'equals_na_linter.R' 'exclude.R' 'expect_comparison_linter.R'
'expect_identical_linter.R' 'expect_length_linter.R'
'expect_lint.R' 'expect_named_linter.R' 'expect_not_linter.R'
'expect_null_linter.R' 'expect_s3_class_linter.R'
'expect_s4_class_linter.R' 'expect_true_false_linter.R'
'expect_type_linter.R' 'extract.R' 'fixed_regex_linter.R'
'for_loop_index_linter.R' 'function_argument_linter.R'
'function_left_parentheses_linter.R' 'function_return_linter.R'
'get_source_expressions.R' 'ids_with_token.R'
'if_not_else_linter.R' 'if_switch_linter.R'
'ifelse_censor_linter.R' 'implicit_assignment_linter.R'
'implicit_integer_linter.R' 'indentation_linter.R'
'infix_spaces_linter.R' 'inner_combine_linter.R'
'is_lint_level.R' 'is_numeric_linter.R'
'keyword_quote_linter.R' 'length_levels_linter.R'
'length_test_linter.R' 'lengths_linter.R'
'library_call_linter.R' 'line_length_linter.R' 'lint.R'
'linter_tag_docs.R' 'linter_tags.R' 'lintr-deprecated.R'
'lintr-package.R' 'list_comparison_linter.R'
'literal_coercion_linter.R' 'make_linter_from_regex.R'
'matrix_apply_linter.R' 'methods.R' 'missing_argument_linter.R'
'missing_package_linter.R' 'namespace.R' 'namespace_linter.R'
'nested_ifelse_linter.R' 'nested_pipe_linter.R'
'nonportable_path_linter.R' 'shared_constants.R'
'nrow_subset_linter.R' 'numeric_leading_zero_linter.R'
'nzchar_linter.R' 'object_length_linter.R'
'object_name_linter.R' 'object_overwrite_linter.R'
'object_usage_linter.R' 'one_call_pipe_linter.R'
'outer_negation_linter.R' 'package_hooks_linter.R'
'paren_body_linter.R' 'paste_linter.R' 'path_utils.R'
'pipe_call_linter.R' 'pipe_consistency_linter.R'
'pipe_continuation_linter.R' 'pipe_return_linter.R'
'print_linter.R' 'quotes_linter.R' 'redundant_equals_linter.R'
'redundant_ifelse_linter.R' 'regex_subset_linter.R'
'rep_len_linter.R' 'repeat_linter.R' 'return_linter.R'
'routine_registration_linter.R' 'sample_int_linter.R'
'scalar_in_linter.R' 'semicolon_linter.R' 'seq_linter.R'
'settings.R' 'settings_utils.R' 'sort_linter.R'
'source_utils.R' 'spaces_inside_linter.R'
'spaces_left_parentheses_linter.R' 'sprintf_linter.R'
'stopifnot_all_linter.R' 'string_boundary_linter.R'
'strings_as_factors_linter.R' 'system_file_linter.R'
'terminal_close_linter.R' 'todo_comment_linter.R'
'trailing_blank_lines_linter.R' 'trailing_whitespace_linter.R'
'tree_utils.R' 'undesirable_function_linter.R'
'undesirable_operator_linter.R'
'unnecessary_concatenation_linter.R'
'unnecessary_lambda_linter.R' 'unnecessary_nesting_linter.R'
'unnecessary_placeholder_linter.R' 'unreachable_code_linter.R'
'unused_import_linter.R' 'use_lintr.R' 'vector_logic_linter.R'
'which_grepl_linter.R' 'whitespace_linter.R' 'with.R'
'with_id.R' 'xml_nodes_to_lints.R' 'xml_utils.R'
'yoda_test_linter.R' 'zzz.R'</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-12 00:10:30 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Jim Hester [aut],
  Florent Angly [aut] (fangly),
  Russ Hyde [aut],
  Michael Chirico [aut, cre],
  Kun Ren [aut],
  Alexander Rosenstock [aut] (AshesITR),
  Indrajeet Patil <a href="https://orcid.org/0000-0003-1995-6531"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (Twitter: @patilindrajeets)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Chirico &lt;michaelchirico4@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-12 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lintr-package'>Lintr</h2><span id='topic+lintr'></span><span id='topic+lintr-package'></span>

<h3>Description</h3>

<p>Checks adherence to a given style, syntax errors, and possible semantic issues.
Supports on the fly checking of R code edited with Emacs, Vim, and Sublime Text.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Chirico <a href="mailto:michaelchirico4@gmail.com">michaelchirico4@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jim Hester
</p>
</li>
<li><p> Florent Angly (fangly)
</p>
</li>
<li><p> Russ Hyde
</p>
</li>
<li><p> Kun Ren
</p>
</li>
<li><p> Alexander Rosenstock (AshesITR)
</p>
</li>
<li><p> Indrajeet Patil <a href="mailto:patilindrajeet.science@gmail.com">patilindrajeet.science@gmail.com</a> (<a href="https://orcid.org/0000-0003-1995-6531">ORCID</a>) (@patilindrajeets)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+lint">lint()</a></code>, <code><a href="#topic+lint_package">lint_package()</a></code>, <code><a href="#topic+lint_dir">lint_dir()</a></code>, <a href="#topic+linters">linters</a>
</p>

<hr>
<h2 id='absolute_path_linter'>Absolute path linter</h2><span id='topic+absolute_path_linter'></span>

<h3>Description</h3>

<p>Check that no absolute paths are used (e.g. &quot;/var&quot;, &quot;C:\System&quot;, &quot;~/docs&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absolute_path_linter(lax = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="absolute_path_linter_+3A_lax">lax</code></td>
<td>
<p>Less stringent linting, leading to fewer false positives.
If <code>TRUE</code>, only lint path strings, which
</p>

<ul>
<li><p> contain at least two path elements, with one having at least two characters and
</p>
</li>
<li><p> contain only alphanumeric chars (including UTF-8), spaces, and win32-allowed punctuation
</p>
</li></ul>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><code><a href="#topic+nonportable_path_linter">nonportable_path_linter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'R"--[/blah/file.txt]--"',
  linters = absolute_path_linter()
)

# okay
lint(
  text = 'R"(./blah)"',
  linters = absolute_path_linter()
)

</code></pre>

<hr>
<h2 id='all_linters'>Create a linter configuration based on all available linters</h2><span id='topic+all_linters'></span>

<h3>Description</h3>

<p>Create a linter configuration based on all available linters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_linters(..., packages = "lintr")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_linters_+3A_...">...</code></td>
<td>
<p>Arguments of elements to change. If unnamed, the argument is automatically named.
If the named argument already exists in the list of linters, it is replaced by the new element.
If it does not exist, it is added. If the value is <code>NULL</code>, the linter is removed.</p>
</td></tr>
<tr><td><code id="all_linters_+3A_packages">packages</code></td>
<td>
<p>A character vector of packages to search for linters.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters_with_defaults">linters_with_defaults</a> for basing off lintr's set of default linters.
</p>
</li>
<li> <p><a href="#topic+linters_with_tags">linters_with_tags</a> for basing off tags attached to linters, possibly across multiple packages.
</p>
</li>
<li> <p><a href="#topic+available_linters">available_linters</a> to get a data frame of available linters.
</p>
</li>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>names(all_linters())

</code></pre>

<hr>
<h2 id='all_undesirable_functions'>Default undesirable functions and operators</h2><span id='topic+all_undesirable_functions'></span><span id='topic+default_undesirable_functions'></span><span id='topic+all_undesirable_operators'></span><span id='topic+default_undesirable_operators'></span>

<h3>Description</h3>

<p>Lists of function names and operators for <code><a href="#topic+undesirable_function_linter">undesirable_function_linter()</a></code> and <code><a href="#topic+undesirable_operator_linter">undesirable_operator_linter()</a></code>.
There is a list for the default elements and another that contains all available elements.
Use <code><a href="#topic+modify_defaults">modify_defaults()</a></code> to produce a custom list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_undesirable_functions

default_undesirable_functions

all_undesirable_operators

default_undesirable_operators
</code></pre>


<h3>Format</h3>

<p>A named list of character strings.
</p>


<h3>Details</h3>

<p>The following functions are sometimes regarded as undesirable:
</p>

<ul>
<li> <p><code><a href="base.html#topic+.libPaths">.libPaths()</a></code> As an alternative, use <code><a href="withr.html#topic+with_libpaths">withr::with_libpaths()</a></code> for a temporary change instead of permanently modifying the library location.
</p>
</li>
<li> <p><code><a href="base.html#topic+attach">attach()</a></code> As an alternative, use roxygen2's @importFrom statement in packages, or <code>::</code> in scripts. <code><a href="base.html#topic+attach">attach()</a></code> modifies the global search path.
</p>
</li>
<li> <p><code><a href="base.html#topic+browser">browser()</a></code> As an alternative, remove this likely leftover from debugging. It pauses execution when run.
</p>
</li>
<li> <p><code><a href="base.html#topic+debug">debug()</a></code> As an alternative, remove this likely leftover from debugging. It traps a function and causes execution to pause when that function is run.
</p>
</li>
<li> <p><code><a href="utils.html#topic+debugcall">debugcall()</a></code> As an alternative, remove this likely leftover from debugging. It traps a function and causes execution to pause when that function is run.
</p>
</li>
<li> <p><code><a href="base.html#topic+debugonce">debugonce()</a></code> As an alternative, remove this likely leftover from debugging. It traps a function and causes execution to pause when that function is run.
</p>
</li>
<li> <p><code><a href="base.html#topic+detach">detach()</a></code> As an alternative, avoid modifying the global search path. Detaching environments from the search path is rarely necessary in production code.
</p>
</li>
<li> <p><code><a href="base.html#topic+library">library()</a></code> As an alternative, use roxygen2's @importFrom statement in packages and <code>::</code> in scripts, instead of modifying the global search path.
</p>
</li>
<li> <p><code><a href="base.html#topic+mapply">mapply()</a></code> As an alternative, use <code><a href="base.html#topic+Map">Map()</a></code> to guarantee a list is returned and simplify accordingly.
</p>
</li>
<li> <p><code><a href="base.html#topic+options">options()</a></code> As an alternative, use <code><a href="withr.html#topic+with_options">withr::with_options()</a></code> for a temporary change instead of permanently modifying the session options.
</p>
</li>
<li> <p><code><a href="graphics.html#topic+par">par()</a></code> As an alternative, use <code><a href="withr.html#topic+with_par">withr::with_par()</a></code> for a temporary change instead of permanently modifying the graphics device parameters.
</p>
</li>
<li> <p><code><a href="base.html#topic+require">require()</a></code> As an alternative, use roxygen2's @importFrom statement in packages and <code><a href="base.html#topic+library">library()</a></code> or <code>::</code> in scripts, instead of modifying the global search path.
</p>
</li>
<li> <p><code><a href="base.html#topic+sapply">sapply()</a></code> As an alternative, use <code><a href="base.html#topic+vapply">vapply()</a></code> with an appropriate <code>FUN.VALUE=</code> argument to obtain type-stable simplification.
</p>
</li>
<li> <p><code><a href="base.html#topic+setwd">setwd()</a></code> As an alternative, use <code><a href="withr.html#topic+with_dir">withr::with_dir()</a></code> for a temporary change instead of modifying the global working directory.
</p>
</li>
<li> <p><code><a href="base.html#topic+sink">sink()</a></code> As an alternative, use <code><a href="withr.html#topic+with_sink">withr::with_sink()</a></code> for a temporary redirection instead of permanently redirecting output.
</p>
</li>
<li> <p><code><a href="base.html#topic+source">source()</a></code> As an alternative, manage dependencies through packages. <code><a href="base.html#topic+source">source()</a></code> loads code into the global environment unless <code>local = TRUE</code> is used, which can cause hard-to-predict behavior.
</p>
</li>
<li> <p><code><a href="base.html#topic+structure">structure()</a></code> As an alternative, Use <code>class&lt;-</code>, <code>names&lt;-</code>, and <code>attr&lt;-</code> to set attributes.
</p>
</li>
<li> <p><code><a href="base.html#topic+Sys.setenv">Sys.setenv()</a></code> As an alternative, use <code><a href="withr.html#topic+with_envvar">withr::with_envvar()</a></code> for a temporary change instead of permanently modifying global environment variables.
</p>
</li>
<li> <p><code><a href="base.html#topic+Sys.setlocale">Sys.setlocale()</a></code> As an alternative, use <code><a href="withr.html#topic+with_locale">withr::with_locale()</a></code> for a temporary change instead of permanently modifying the session locale.
</p>
</li>
<li> <p><code><a href="base.html#topic+trace">trace()</a></code> As an alternative, remove this likely leftover from debugging. It traps a function and causes execution of arbitrary code when that function is run.
</p>
</li>
<li> <p><code><a href="base.html#topic+undebug">undebug()</a></code> As an alternative, remove this likely leftover from debugging. It is only useful for interactive debugging with <code><a href="base.html#topic+debug">debug()</a></code>.
</p>
</li>
<li> <p><code><a href="base.html#topic+untrace">untrace()</a></code> As an alternative, remove this likely leftover from debugging. It is only useful for interactive debugging with <code><a href="base.html#topic+trace">trace()</a></code>.
</p>
</li></ul>

<p>The following operators are sometimes regarded as undesirable:
</p>

<ul>
<li> <p><code><a href="base.html#topic+assignOps">&lt;&lt;-</a></code>. It assigns outside the current environment in a way that can be hard to reason about. Prefer fully-encapsulated functions wherever possible, or, if necessary, assign to a specific environment with <code><a href="base.html#topic+assign">assign()</a></code>. Recall that you can create an environment at the desired scope with <code><a href="base.html#topic+new.env">new.env()</a></code>.
</p>
</li>
<li> <p><code><a href="base.html#topic+ns-dblcolon">:::</a></code>. It accesses non-exported functions inside packages. Code relying on these is likely to break in future versions of the package because the functions are not part of the public interface and may be changed or removed by the maintainers without notice. Use public functions via <code>::</code> instead.
</p>
</li>
<li> <p><code><a href="base.html#topic+assignOps">&lt;&lt;-</a></code>. It assigns outside the current environment in a way that can be hard to reason about. Prefer fully-encapsulated functions wherever possible, or, if necessary, assign to a specific environment with <code><a href="base.html#topic+assign">assign()</a></code>. Recall that you can create an environment at the desired scope with <code><a href="base.html#topic+new.env">new.env()</a></code>.
</p>
</li></ul>


<hr>
<h2 id='any_duplicated_linter'>Require usage of <code>anyDuplicated(x) &gt; 0</code> over <code>any(duplicated(x))</code></h2><span id='topic+any_duplicated_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+anyDuplicated">anyDuplicated()</a></code> exists as a replacement for <code>any(duplicated(.))</code>, which is
more efficient for simple objects, and is at worst equally efficient.
Therefore, it should be used in all situations instead of the latter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_duplicated_linter()
</code></pre>


<h3>Details</h3>

<p>Also match usage like <code>length(unique(x$col)) == nrow(x)</code>, which can
be replaced by <code>anyDuplicated(x$col) == 0L</code>.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+efficiency_linters">efficiency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "any(duplicated(x), na.rm = TRUE)",
  linters = any_duplicated_linter()
)

lint(
  text = "length(unique(x)) == length(x)",
  linters = any_duplicated_linter()
)

# okay
lint(
  text = "anyDuplicated(x)",
  linters = any_duplicated_linter()
)

lint(
  text = "anyDuplicated(x) == 0L",
  linters = any_duplicated_linter()
)

</code></pre>

<hr>
<h2 id='any_is_na_linter'>Require usage of <code>anyNA(x)</code> over <code>any(is.na(x))</code></h2><span id='topic+any_is_na_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+anyNA">anyNA()</a></code> exists as a replacement for <code>any(is.na(x))</code> which is more efficient
for simple objects, and is at worst equally efficient.
Therefore, it should be used in all situations instead of the latter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_is_na_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+efficiency_linters">efficiency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "any(is.na(x), na.rm = TRUE)",
  linters = any_is_na_linter()
)

lint(
  text = "any(is.na(foo(x)))",
  linters = any_is_na_linter()
)

# okay
lint(
  text = "anyNA(x)",
  linters = any_is_na_linter()
)

lint(
  text = "anyNA(foo(x))",
  linters = any_is_na_linter()
)

lint(
  text = "any(!is.na(x), na.rm = TRUE)",
  linters = any_is_na_linter()
)

</code></pre>

<hr>
<h2 id='assignment_linter'>Assignment linter</h2><span id='topic+assignment_linter'></span>

<h3>Description</h3>

<p>Check that the specified operator is used for assignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignment_linter(
  operator = c("&lt;-", "&lt;&lt;-"),
  allow_cascading_assign = TRUE,
  allow_right_assign = FALSE,
  allow_trailing = TRUE,
  allow_pipe_assign = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assignment_linter_+3A_operator">operator</code></td>
<td>
<p>Character vector of valid assignment operators. Defaults to allowing <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;&lt;-&#8288;</code>; other valid
options are <code>=</code>, <code style="white-space: pre;">&#8288;-&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;-&gt;&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;%&lt;&gt;%&#8288;</code>; use <code>"any"</code> to denote &quot;allow all operators&quot;, in which case this linter only
considers <code>allow_trailing</code> for generating lints.</p>
</td></tr>
<tr><td><code id="assignment_linter_+3A_allow_cascading_assign">allow_cascading_assign</code></td>
<td>
<p>(Deprecated) Logical, default <code>TRUE</code>.
If <code>FALSE</code>, <code><a href="base.html#topic+assignOps">&lt;&lt;-</a></code> and <code style="white-space: pre;">&#8288;-&gt;&gt;&#8288;</code> are not allowed.</p>
</td></tr>
<tr><td><code id="assignment_linter_+3A_allow_right_assign">allow_right_assign</code></td>
<td>
<p>(Deprecated) Logical, default <code>FALSE</code>. If <code>TRUE</code>, <code style="white-space: pre;">&#8288;-&gt;&#8288;</code> and <code style="white-space: pre;">&#8288;-&gt;&gt;&#8288;</code> are allowed.</p>
</td></tr>
<tr><td><code id="assignment_linter_+3A_allow_trailing">allow_trailing</code></td>
<td>
<p>Logical, default <code>TRUE</code>. If <code>FALSE</code> then assignments aren't allowed at end of lines.</p>
</td></tr>
<tr><td><code id="assignment_linter_+3A_allow_pipe_assign">allow_pipe_assign</code></td>
<td>
<p>(Deprecated) Logical, default <code>FALSE</code>. If <code>TRUE</code>, magrittr's <code style="white-space: pre;">&#8288;%&lt;&gt;%&#8288;</code> assignment is allowed.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#assignment-1">https://style.tidyverse.org/syntax.html#assignment-1</a>
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/pipes.html#assignment-2">https://style.tidyverse.org/pipes.html#assignment-2</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x = mean(x)",
  linters = assignment_linter()
)

code_lines &lt;- "1 -&gt; x\n2 -&gt;&gt; y"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = assignment_linter()
)

lint(
  text = "x %&lt;&gt;% as.character()",
  linters = assignment_linter()
)

lint(
  text = "x &lt;- 1",
  linters = assignment_linter(operator = "=")
)

# okay
lint(
  text = "x &lt;- mean(x)",
  linters = assignment_linter()
)

code_lines &lt;- "x &lt;- 1\ny &lt;&lt;- 2"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = assignment_linter()
)

# customizing using arguments
code_lines &lt;- "1 -&gt; x\n2 -&gt;&gt; y"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = assignment_linter(allow_right_assign = TRUE)
)

lint(
  text = "x &lt;&lt;- 1",
  linters = assignment_linter(allow_cascading_assign = FALSE)
)

writeLines("foo(bar = \n 1)")
lint(
  text = "foo(bar = \n 1)",
  linters = assignment_linter(allow_trailing = FALSE)
)

lint(
  text = "x %&lt;&gt;% as.character()",
  linters = assignment_linter(allow_pipe_assign = TRUE)
)

lint(
  text = "x = 1",
  linters = assignment_linter(operator = "=")
)

</code></pre>

<hr>
<h2 id='available_linters'>Get Linter metadata from a package</h2><span id='topic+available_linters'></span><span id='topic+available_tags'></span>

<h3>Description</h3>

<p><code>available_linters()</code> obtains a tagged list of all Linters available in a package.
</p>
<p><code>available_tags()</code> searches for available tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_linters(packages = "lintr", tags = NULL, exclude_tags = "deprecated")

available_tags(packages = "lintr")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="available_linters_+3A_packages">packages</code></td>
<td>
<p>A character vector of packages to search for linters.</p>
</td></tr>
<tr><td><code id="available_linters_+3A_tags">tags</code></td>
<td>
<p>Optional character vector of tags to search. Only linters with at least one matching tag will be
returned. If <code>tags</code> is <code>NULL</code>, all linters will be returned. See <code>available_tags("lintr")</code> to find out what
tags are already used by lintr.</p>
</td></tr>
<tr><td><code id="available_linters_+3A_exclude_tags">exclude_tags</code></td>
<td>
<p>Tags to exclude from the results. Linters with at least one matching tag will not be returned.
If <code>exclude_tags</code> is <code>NULL</code>, no linters will be excluded. Note that <code>tags</code> takes priority, meaning that any
tag found in both <code>tags</code> and <code>exclude_tags</code> will be included, not excluded. Note that linters with tag <code>"defunct"</code>
(which do not work and can no longer be run) cannot be queried directly. See <a href="#topic+lintr-deprecated">lintr-deprecated</a> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>available_linters</code> returns a data frame with columns 'linter', 'package' and 'tags':
</p>

<dl>
<dt>linter</dt><dd><p>A character column naming the function associated with the linter.</p>
</dd>
<dt>package</dt><dd><p>A character column containing the name of the package providing the linter.</p>
</dd>
<dt>tags</dt><dd><p>A list column containing tags associated with the linter.</p>
</dd>
</dl>

<p><code>available_tags</code> returns a character vector of linter tags used by the packages.
</p>


<h3>Package Authors</h3>

<p>To implement <code>available_linters()</code> for your package, include a file <code>inst/lintr/linters.csv</code> in your
package.
The CSV file must contain the columns 'linter' and 'tags', and be UTF-8 encoded.
Additional columns will be silently ignored if present and the columns are identified by name.
Each row describes a linter by
</p>

<ol>
<li><p> its function name (e.g. <code>"assignment_linter"</code>) in the column 'linter'.
</p>
</li>
<li><p> space-separated tags associated with the linter (e.g. <code>"style consistency default"</code>) in the column 'tags'.
</p>
</li></ol>

<p>Tags should be snake_case.
</p>
<p>See <code>available_tags("lintr")</code> to find out what tags are already used by lintr.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><code><a href="#topic+available_tags">available_tags()</a></code> to retrieve the set of valid tags.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>lintr_linters &lt;- available_linters()

# If the package doesn't exist or isn't installed, an empty data frame will be returned
available_linters("does-not-exist")

lintr_linters2 &lt;- available_linters(c("lintr", "does-not-exist"))
identical(lintr_linters, lintr_linters2)
available_tags()
</code></pre>

<hr>
<h2 id='backport_linter'>Backport linter</h2><span id='topic+backport_linter'></span>

<h3>Description</h3>

<p>Check for usage of unavailable functions. Not reliable for testing r-devel dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backport_linter(r_version = getRversion(), except = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backport_linter_+3A_r_version">r_version</code></td>
<td>
<p>Minimum R version to test for compatibility</p>
</td></tr>
<tr><td><code id="backport_linter_+3A_except">except</code></td>
<td>
<p>Character vector of functions to be excluded from linting.
Use this to list explicitly defined backports, e.g. those imported from the <code>{backports}</code> package or manually
defined in your package.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "trimws(x)",
  linters = backport_linter("3.0.0")
)

lint(
  text = "str2lang(x)",
  linters = backport_linter("3.2.0")
)

# okay
lint(
  text = "trimws(x)",
  linters = backport_linter("3.6.0")
)

lint(
  text = "str2lang(x)",
  linters = backport_linter("4.0.0")
)

lint(
  text = "str2lang(x)",
  linters = backport_linter("3.2.0", except = "str2lang")
)

</code></pre>

<hr>
<h2 id='best_practices_linters'>Best practices linters</h2><span id='topic+best_practices_linters'></span>

<h3>Description</h3>

<p>Linters checking the use of coding best practices, such as explicit typing of numeric constants.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'best_practices':
</p>

<ul>
<li><p><code><a href="#topic+absolute_path_linter">absolute_path_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+any_duplicated_linter">any_duplicated_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+any_is_na_linter">any_is_na_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+boolean_arithmetic_linter">boolean_arithmetic_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+class_equals_linter">class_equals_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+commented_code_linter">commented_code_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+condition_call_linter">condition_call_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+condition_message_linter">condition_message_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+conjunct_test_linter">conjunct_test_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+cyclocomp_linter">cyclocomp_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+empty_assignment_linter">empty_assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_comparison_linter">expect_comparison_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_length_linter">expect_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_named_linter">expect_named_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_not_linter">expect_not_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_null_linter">expect_null_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_s3_class_linter">expect_s3_class_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_s4_class_linter">expect_s4_class_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_true_false_linter">expect_true_false_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_type_linter">expect_type_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+fixed_regex_linter">fixed_regex_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+for_loop_index_linter">for_loop_index_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+function_argument_linter">function_argument_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+function_return_linter">function_return_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+if_switch_linter">if_switch_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+ifelse_censor_linter">ifelse_censor_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+implicit_assignment_linter">implicit_assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+implicit_integer_linter">implicit_integer_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+is_numeric_linter">is_numeric_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+length_levels_linter">length_levels_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+lengths_linter">lengths_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+library_call_linter">library_call_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+list_comparison_linter">list_comparison_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+literal_coercion_linter">literal_coercion_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nonportable_path_linter">nonportable_path_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nrow_subset_linter">nrow_subset_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nzchar_linter">nzchar_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_overwrite_linter">object_overwrite_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+outer_negation_linter">outer_negation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+paste_linter">paste_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_return_linter">pipe_return_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+print_linter">print_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+redundant_equals_linter">redundant_equals_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+redundant_ifelse_linter">redundant_ifelse_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+regex_subset_linter">regex_subset_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+rep_len_linter">rep_len_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+routine_registration_linter">routine_registration_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+scalar_in_linter">scalar_in_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+seq_linter">seq_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+sort_linter">sort_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+stopifnot_all_linter">stopifnot_all_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+system_file_linter">system_file_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+T_and_F_symbol_linter">T_and_F_symbol_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+terminal_close_linter">terminal_close_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+undesirable_function_linter">undesirable_function_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+undesirable_operator_linter">undesirable_operator_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_lambda_linter">unnecessary_lambda_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_nesting_linter">unnecessary_nesting_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_placeholder_linter">unnecessary_placeholder_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unreachable_code_linter">unreachable_code_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unused_import_linter">unused_import_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+vector_logic_linter">vector_logic_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+yoda_test_linter">yoda_test_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='boolean_arithmetic_linter'>Require usage of boolean operators over equivalent arithmetic</h2><span id='topic+boolean_arithmetic_linter'></span>

<h3>Description</h3>

<p><code>length(which(x == y)) == 0</code> is the same as <code>!any(x == y)</code>, but the latter
is more readable and more efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boolean_arithmetic_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "length(which(x == y)) == 0L",
  linters = boolean_arithmetic_linter()
)

lint(
  text = "sum(grepl(pattern, x)) == 0",
  linters = boolean_arithmetic_linter()
)

# okay
lint(
  text = "!any(x == y)",
  linters = boolean_arithmetic_linter()
)

lint(
  text = "!any(grepl(pattern, x))",
  linters = boolean_arithmetic_linter()
)

</code></pre>

<hr>
<h2 id='brace_linter'>Brace linter</h2><span id='topic+brace_linter'></span>

<h3>Description</h3>

<p>Perform various style checks related to placement and spacing of curly braces:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brace_linter(allow_single_line = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brace_linter_+3A_allow_single_line">allow_single_line</code></td>
<td>
<p>if <code>TRUE</code>, allow an open and closed curly pair on the same line.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Opening curly braces are never on their own line and are always followed by a newline.
</p>
</li>
<li><p> Opening curly braces have a space before them.
</p>
</li>
<li><p> Closing curly braces are on their own line unless they are followed by an <code style="white-space: pre;">&#8288;else&#8288;</code>.
</p>
</li>
<li><p> Closing curly braces in <code>if</code> conditions are on the same line as the corresponding <code style="white-space: pre;">&#8288;else&#8288;</code>.
</p>
</li>
<li><p> Either both or neither branch in <code>if</code>/<code style="white-space: pre;">&#8288;else&#8288;</code> use curly braces, i.e., either both branches use <code>{...}</code> or neither
does.
</p>
</li>
<li><p> Functions spanning multiple lines use curly braces.
</p>
</li></ul>



<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#indenting">https://style.tidyverse.org/syntax.html#indenting</a>
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#if-statements">https://style.tidyverse.org/syntax.html#if-statements</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "f &lt;- function() { 1 }",
  linters = brace_linter()
)

writeLines("if (TRUE) {\n return(1) }")
lint(
  text = "if (TRUE) {\n return(1) }",
  linters = brace_linter()
)

# okay
writeLines("f &lt;- function() {\n  1\n}")
lint(
  text = "f &lt;- function() {\n  1\n}",
  linters = brace_linter()
)

writeLines("if (TRUE) { \n return(1) \n}")
lint(
  text = "if (TRUE) { \n return(1) \n}",
  linters = brace_linter()
)

# customizing using arguments
writeLines("if (TRUE) { return(1) }")
lint(
  text = "if (TRUE) { return(1) }",
  linters = brace_linter(allow_single_line = TRUE)
)
</code></pre>

<hr>
<h2 id='checkstyle_output'>Checkstyle Report for lint results</h2><span id='topic+checkstyle_output'></span>

<h3>Description</h3>

<p>Generate a report of the linting results using the <a href="https://checkstyle.sourceforge.io">Checkstyle</a> XML format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkstyle_output(lints, filename = "lintr_results.xml")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkstyle_output_+3A_lints">lints</code></td>
<td>
<p>the linting results.</p>
</td></tr>
<tr><td><code id="checkstyle_output_+3A_filename">filename</code></td>
<td>
<p>the name of the output report</p>
</td></tr>
</table>

<hr>
<h2 id='class_equals_linter'>Block comparison of class with <code>==</code></h2><span id='topic+class_equals_linter'></span>

<h3>Description</h3>

<p>Usage like <code>class(x) == "character"</code> is prone to error since class in R
is in general a vector. The correct version for S3 classes is <code><a href="base.html#topic+inherits">inherits()</a></code>:
<code>inherits(x, "character")</code>. Often, class <code>k</code> will have an <code>is.</code> equivalent,
for example <code><a href="base.html#topic+is.character">is.character()</a></code> or <code><a href="base.html#topic+is.data.frame">is.data.frame()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class_equals_linter()
</code></pre>


<h3>Details</h3>

<p>Similar reasoning applies for <code>class(x) %in% "character"</code>.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'is_lm &lt;- class(x) == "lm"',
  linters = class_equals_linter()
)

lint(
  text = 'if ("lm" %in% class(x)) is_lm &lt;- TRUE',
  linters = class_equals_linter()
)

# okay
lint(
  text = 'is_lm &lt;- inherits(x, "lm")',
  linters = class_equals_linter()
)

lint(
  text = 'if (inherits(x, "lm")) is_lm &lt;- TRUE',
  linters = class_equals_linter()
)

</code></pre>

<hr>
<h2 id='clear_cache'>Clear the lintr cache</h2><span id='topic+clear_cache'></span>

<h3>Description</h3>

<p>Clear the lintr cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_cache(file = NULL, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clear_cache_+3A_file">file</code></td>
<td>
<p>filename whose cache to clear. If you pass <code>NULL</code>, it will delete all of the caches.</p>
</td></tr>
<tr><td><code id="clear_cache_+3A_path">path</code></td>
<td>
<p>directory to store caches. Reads option 'lintr.cache_directory' as the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>0 for success, 1 for failure, invisibly.
</p>

<hr>
<h2 id='commas_linter'>Commas linter</h2><span id='topic+commas_linter'></span>

<h3>Description</h3>

<p>Check that all commas are followed by spaces, but do not have spaces before them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commas_linter(allow_trailing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="commas_linter_+3A_allow_trailing">allow_trailing</code></td>
<td>
<p>If <code>TRUE</code>, the linter allows a comma to be followed
directly by a closing bracket without a space.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#commas">https://style.tidyverse.org/syntax.html#commas</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "switch(op , x = foo, y = bar)",
  linters = commas_linter()
)

lint(
  text = "mean(x,trim = 0.2,na.rm = TRUE)",
  linters = commas_linter()
)

lint(
  text = "x[ ,, drop=TRUE]",
  linters = commas_linter()
)

lint(
  text = "x[1,]",
  linters = commas_linter()
)

# okay
lint(
  text = "switch(op, x = foo, y = bar)",
  linters = commas_linter()
)

lint(
  text = "switch(op, x = , y = bar)",
  linters = commas_linter()
)

lint(
  text = "mean(x, trim = 0.2, na.rm = TRUE)",
  linters = commas_linter()
)

lint(
  text = "a[1, , 2, , 3]",
  linters = commas_linter()
)

lint(
  text = "x[1,]",
  linters = commas_linter(allow_trailing = TRUE)
)

</code></pre>

<hr>
<h2 id='commented_code_linter'>Commented code linter</h2><span id='topic+commented_code_linter'></span>

<h3>Description</h3>

<p>Check that there is no commented code outside roxygen blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commented_code_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "# x &lt;- 1",
  linters = commented_code_linter()
)

lint(
  text = "x &lt;- f() # g()",
  linters = commented_code_linter()
)

lint(
  text = "x + y # + z[1, 2]",
  linters = commented_code_linter()
)

# okay
lint(
  text = "x &lt;- 1; x &lt;- f(); x + y",
  linters = commented_code_linter()
)

lint(
  text = "#' x &lt;- 1",
  linters = commented_code_linter()
)

</code></pre>

<hr>
<h2 id='common_mistakes_linters'>Common mistake linters</h2><span id='topic+common_mistakes_linters'></span>

<h3>Description</h3>

<p>Linters highlighting common mistakes, such as duplicate arguments.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'common_mistakes':
</p>

<ul>
<li><p><code><a href="#topic+duplicate_argument_linter">duplicate_argument_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+equals_na_linter">equals_na_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+length_test_linter">length_test_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+list_comparison_linter">list_comparison_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+missing_argument_linter">missing_argument_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+missing_package_linter">missing_package_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_return_linter">pipe_return_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+redundant_equals_linter">redundant_equals_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+sprintf_linter">sprintf_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unused_import_linter">unused_import_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+vector_logic_linter">vector_logic_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='comparison_negation_linter'>Block usages like !(x == y) where a direct relational operator is appropriate</h2><span id='topic+comparison_negation_linter'></span>

<h3>Description</h3>

<p><code>!(x == y)</code> is more readably expressed as <code>x != y</code>. The same is true of
other negations of simple comparisons like <code>!(x &gt; y)</code> and <code>!(x &lt;= y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparison_negation_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "!x == 2",
  linters = comparison_negation_linter()
)

lint(
  text = "!(x &gt; 2)",
  linters = comparison_negation_linter()
)

# okay
lint(
  text = "!(x == 2 &amp; y &gt; 2)",
  linters = comparison_negation_linter()
)

lint(
  text = "!(x &amp; y)",
  linters = comparison_negation_linter()
)

lint(
  text = "x != 2",
  linters = comparison_negation_linter()
)

</code></pre>

<hr>
<h2 id='condition_call_linter'>Recommend usage of <code>call. = FALSE</code> in conditions</h2><span id='topic+condition_call_linter'></span>

<h3>Description</h3>

<p>This linter, with the default <code>display_call = FALSE</code>, enforces the
recommendation of the tidyverse design guide regarding displaying error
calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition_call_linter(display_call = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="condition_call_linter_+3A_display_call">display_call</code></td>
<td>
<p>Logical specifying expected behavior regarding <code>call.</code>
argument in conditions.
</p>

<ul>
<li> <p><code>NA</code> forces providing <code style="white-space: pre;">&#8288;call. =&#8288;</code> but ignores its value (this can be used in
cases where you expect a mix of <code>call. = FALSE</code> and <code>call. = TRUE</code>)
</p>
</li>
<li> <p><code>TRUE</code> lints <code>call. = FALSE</code>
</p>
</li>
<li> <p><code>FALSE</code> forces <code>call. = FALSE</code> (lints <code>call. = TRUE</code> or missing <code style="white-space: pre;">&#8288;call. =&#8288;</code> value)
</p>
</li></ul>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+style_linters">style</a>, <a href="#topic+tidy_design_linters">tidy_design</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://design.tidyverse.org/err-call.html">https://design.tidyverse.org/err-call.html</a>&gt;
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "stop('test')",
  linters = condition_call_linter()
)

lint(
  text = "stop('test', call. = TRUE)",
  linters = condition_call_linter()
)

lint(
  text = "stop('test', call. = FALSE)",
  linters = condition_call_linter(display_call = TRUE)
)

lint(
  text = "stop('this is a', 'test', call. = FALSE)",
  linters = condition_call_linter(display_call = TRUE)
)

# okay
lint(
  text = "stop('test', call. = FALSE)",
  linters = condition_call_linter()
)

lint(
  text = "stop('this is a', 'test', call. = FALSE)",
  linters = condition_call_linter()
)

lint(
  text = "stop('test', call. = TRUE)",
  linters = condition_call_linter(display_call = TRUE)
)

</code></pre>

<hr>
<h2 id='condition_message_linter'>Block usage of <code>paste()</code> and <code>paste0()</code> with messaging functions using <code>...</code></h2><span id='topic+condition_message_linter'></span>

<h3>Description</h3>

<p>This linter discourages combining condition functions like <code><a href="base.html#topic+stop">stop()</a></code> with string concatenation
functions <code><a href="base.html#topic+paste">paste()</a></code> and <code><a href="base.html#topic+paste0">paste0()</a></code>. This is because
</p>

<ul>
<li> <p><code>stop(paste0(...))</code> is redundant as it is exactly equivalent to <code>stop(...)</code>
</p>
</li>
<li> <p><code>stop(paste(...))</code> is similarly equivalent to <code>stop(...)</code> with separators (see examples)
</p>
</li></ul>

<p>The same applies to the other default condition functions as well, i.e., <code><a href="base.html#topic+warning">warning()</a></code>, <code><a href="base.html#topic+message">message()</a></code>,
and <code><a href="base.html#topic+packageStartupMessage">packageStartupMessage()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition_message_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'stop(paste("a string", "another"))',
  linters = condition_message_linter()
)

lint(
  text = 'warning(paste0("a string", " another"))',
  linters = condition_message_linter()
)

# okay
lint(
  text = 'stop("a string", " another")',
  linters = condition_message_linter()
)

lint(
  text = 'warning("a string", " another")',
  linters = condition_message_linter()
)

lint(
  text = 'warning(paste("a string", "another", sep = "-"))',
  linters = condition_message_linter()
)

</code></pre>

<hr>
<h2 id='configurable_linters'>Configurable linters</h2><span id='topic+configurable_linters'></span>

<h3>Description</h3>

<p>Generic linters which support custom configuration to your needs.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'configurable':
</p>

<ul>
<li><p><code><a href="#topic+absolute_path_linter">absolute_path_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+assignment_linter">assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+backport_linter">backport_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+brace_linter">brace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+commas_linter">commas_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+condition_call_linter">condition_call_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+conjunct_test_linter">conjunct_test_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+consecutive_mutate_linter">consecutive_mutate_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+cyclocomp_linter">cyclocomp_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+duplicate_argument_linter">duplicate_argument_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+fixed_regex_linter">fixed_regex_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+if_not_else_linter">if_not_else_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+if_switch_linter">if_switch_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+implicit_assignment_linter">implicit_assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+implicit_integer_linter">implicit_integer_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+indentation_linter">indentation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+infix_spaces_linter">infix_spaces_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+library_call_linter">library_call_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+line_length_linter">line_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+missing_argument_linter">missing_argument_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+namespace_linter">namespace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nested_pipe_linter">nested_pipe_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nonportable_path_linter">nonportable_path_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_length_linter">object_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_name_linter">object_name_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_overwrite_linter">object_overwrite_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_usage_linter">object_usage_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+paste_linter">paste_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_consistency_linter">pipe_consistency_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+quotes_linter">quotes_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+redundant_ifelse_linter">redundant_ifelse_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+return_linter">return_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+scalar_in_linter">scalar_in_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+semicolon_linter">semicolon_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+string_boundary_linter">string_boundary_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+todo_comment_linter">todo_comment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+trailing_whitespace_linter">trailing_whitespace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+undesirable_function_linter">undesirable_function_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+undesirable_operator_linter">undesirable_operator_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_concatenation_linter">unnecessary_concatenation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_lambda_linter">unnecessary_lambda_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_nesting_linter">unnecessary_nesting_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unreachable_code_linter">unreachable_code_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unused_import_linter">unused_import_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='conjunct_test_linter'>Force <code>&amp;&amp;</code> conditions to be written separately where appropriate</h2><span id='topic+conjunct_test_linter'></span>

<h3>Description</h3>

<p>For readability of test outputs, testing only one thing per call to
<code><a href="testthat.html#topic+logical-expectations">testthat::expect_true()</a></code> is preferable, i.e.,
<code style="white-space: pre;">&#8288;expect_true(A); expect_true(B)&#8288;</code> is better than <code>expect_true(A &amp;&amp; B)</code>, and
<code style="white-space: pre;">&#8288;expect_false(A); expect_false(B)&#8288;</code> is better than <code>expect_false(A || B)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conjunct_test_linter(
  allow_named_stopifnot = TRUE,
  allow_filter = c("never", "not_dplyr", "always")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conjunct_test_linter_+3A_allow_named_stopifnot">allow_named_stopifnot</code></td>
<td>
<p>Logical, <code>TRUE</code> by default. If <code>FALSE</code>, &quot;named&quot; calls to <code>stopifnot()</code>,
available since R 4.0.0 to provide helpful messages for test failures, are also linted.</p>
</td></tr>
<tr><td><code id="conjunct_test_linter_+3A_allow_filter">allow_filter</code></td>
<td>
<p>Character naming the method for linting calls to <code>filter()</code>. The default, <code>"never"</code>, means
<code>filter()</code> and <code>dplyr::filter()</code> calls are linted; <code>"not_dplyr"</code> means only <code>dplyr::filter()</code> calls are linted;
and <code>"always"</code> means no calls to <code>filter()</code> are linted. Calls like <code>stats::filter()</code> are never linted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar reasoning applies to <code>&amp;&amp;</code> usage inside <code><a href="base.html#topic+stopifnot">stopifnot()</a></code> and <code>assertthat::assert_that()</code> calls.
</p>
<p>Relatedly, <code>dplyr::filter(DF, A &amp; B)</code> is the same as <code>dplyr::filter(DF, A, B)</code>, but the latter will be more readable
/ easier to format for long conditions. Note that this linter assumes usages of <code>filter()</code> are <code>dplyr::filter()</code>;
if you're using another function named <code>filter()</code>, e.g. <code><a href="stats.html#topic+filter">stats::filter()</a></code>, please namespace-qualify it to avoid
false positives. You can omit linting <code>filter()</code> expressions altogether via <code>allow_filter = TRUE</code>.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "expect_true(x &amp;&amp; y)",
  linters = conjunct_test_linter()
)

lint(
  text = "expect_false(x || (y &amp;&amp; z))",
  linters = conjunct_test_linter()
)

lint(
  text = "stopifnot('x must be a logical scalar' = length(x) == 1 &amp;&amp; is.logical(x) &amp;&amp; !is.na(x))",
  linters = conjunct_test_linter(allow_named_stopifnot = FALSE)
)

lint(
  text = "dplyr::filter(mtcars, mpg &gt; 20 &amp; vs == 0)",
  linters = conjunct_test_linter()
)

lint(
  text = "filter(mtcars, mpg &gt; 20 &amp; vs == 0)",
  linters = conjunct_test_linter()
)

# okay
lint(
  text = "expect_true(x || (y &amp;&amp; z))",
  linters = conjunct_test_linter()
)

lint(
  text = 'stopifnot("x must be a logical scalar" = length(x) == 1 &amp;&amp; is.logical(x) &amp;&amp; !is.na(x))',
  linters = conjunct_test_linter(allow_named_stopifnot = TRUE)
)

lint(
  text = "dplyr::filter(mtcars, mpg &gt; 20 &amp; vs == 0)",
  linters = conjunct_test_linter(allow_filter = "always")
)

lint(
  text = "filter(mtcars, mpg &gt; 20 &amp; vs == 0)",
  linters = conjunct_test_linter(allow_filter = "not_dplyr")
)

lint(
  text = "stats::filter(mtcars$cyl, mtcars$mpg &gt; 20 &amp; mtcars$vs == 0)",
  linters = conjunct_test_linter()
)

</code></pre>

<hr>
<h2 id='consecutive_assertion_linter'>Force consecutive calls to assertions into just one when possible</h2><span id='topic+consecutive_assertion_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+stopifnot">stopifnot()</a></code> accepts any number of tests, so sequences like
<code style="white-space: pre;">&#8288;stopifnot(x); stopifnot(y)&#8288;</code> are redundant. Ditto for tests using
<code>assertthat::assert_that()</code> without specifying <code style="white-space: pre;">&#8288;msg=&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consecutive_assertion_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "stopifnot(x); stopifnot(y)",
  linters = consecutive_assertion_linter()
)

lint(
  text = "assert_that(x); assert_that(y)",
  linters = consecutive_assertion_linter()
)

# okay
lint(
  text = "stopifnot(x, y)",
  linters = consecutive_assertion_linter()
)

lint(
  text = 'assert_that(x, msg = "Bad x!"); assert_that(y)',
  linters = consecutive_assertion_linter()
)

</code></pre>

<hr>
<h2 id='consecutive_mutate_linter'>Require consecutive calls to mutate() to be combined when possible</h2><span id='topic+consecutive_mutate_linter'></span>

<h3>Description</h3>

<p><code>dplyr::mutate()</code> accepts any number of columns, so sequences like
<code>DF %&gt;% dplyr::mutate(..1) %&gt;% dplyr::mutate(..2)</code> are redundant &ndash;
they can always be expressed with a single call to <code>dplyr::mutate()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consecutive_mutate_linter(invalid_backends = "dbplyr")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consecutive_mutate_linter_+3A_invalid_backends">invalid_backends</code></td>
<td>
<p>Character vector of packages providing dplyr backends
which may not be compatible with combining <code>mutate()</code> calls in all cases.
Defaults to <code>"dbplyr"</code> since not all SQL backends can handle re-using
a variable defined in the same <code>mutate()</code> expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An exception is for some SQL back-ends, where the translation logic may not be
as sophisticated as that in the default <code>dplyr</code>, for example in
<code>DF %&gt;% mutate(a = a + 1) %&gt;% mutate(b = a - 2)</code>.
</p>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x %&gt;% mutate(a = 1) %&gt;% mutate(b = 2)",
  linters = consecutive_mutate_linter()
)

# okay
lint(
  text = "x %&gt;% mutate(a = 1, b = 2)",
  linters = consecutive_mutate_linter()
)

code &lt;- "library(dbplyr)\nx %&gt;% mutate(a = 1) %&gt;% mutate(a = a + 1)"
writeLines(code)
lint(
  text = code,
  linters = consecutive_mutate_linter()
)

</code></pre>

<hr>
<h2 id='consistency_linters'>Consistency linters</h2><span id='topic+consistency_linters'></span>

<h3>Description</h3>

<p>Linters checking enforcing a consistent alternative if there are multiple syntactically valid ways to write
something.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'consistency':
</p>

<ul>
<li><p><code><a href="#topic+assignment_linter">assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+class_equals_linter">class_equals_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+comparison_negation_linter">comparison_negation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+condition_message_linter">condition_message_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+consecutive_assertion_linter">consecutive_assertion_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+consecutive_mutate_linter">consecutive_mutate_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+function_argument_linter">function_argument_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+if_not_else_linter">if_not_else_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+if_switch_linter">if_switch_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+implicit_integer_linter">implicit_integer_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+inner_combine_linter">inner_combine_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+is_numeric_linter">is_numeric_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+keyword_quote_linter">keyword_quote_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+length_levels_linter">length_levels_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+literal_coercion_linter">literal_coercion_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nested_pipe_linter">nested_pipe_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nrow_subset_linter">nrow_subset_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+numeric_leading_zero_linter">numeric_leading_zero_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nzchar_linter">nzchar_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_name_linter">object_name_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+paste_linter">paste_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+print_linter">print_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+quotes_linter">quotes_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+redundant_ifelse_linter">redundant_ifelse_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+rep_len_linter">rep_len_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+scalar_in_linter">scalar_in_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+seq_linter">seq_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+system_file_linter">system_file_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+T_and_F_symbol_linter">T_and_F_symbol_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_nesting_linter">unnecessary_nesting_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+which_grepl_linter">which_grepl_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+whitespace_linter">whitespace_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='correctness_linters'>Correctness linters</h2><span id='topic+correctness_linters'></span>

<h3>Description</h3>

<p>Linters highlighting possible programming mistakes, such as unused variables.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'correctness':
</p>

<ul>
<li><p><code><a href="#topic+duplicate_argument_linter">duplicate_argument_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+equals_na_linter">equals_na_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+missing_argument_linter">missing_argument_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+namespace_linter">namespace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_usage_linter">object_usage_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+package_hooks_linter">package_hooks_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+sprintf_linter">sprintf_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='cyclocomp_linter'>Cyclomatic complexity linter</h2><span id='topic+cyclocomp_linter'></span>

<h3>Description</h3>

<p>Check for overly complicated expressions. See <code>cyclocomp()</code> function from <code>{cyclocomp}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyclocomp_linter(complexity_limit = 15L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cyclocomp_linter_+3A_complexity_limit">complexity_limit</code></td>
<td>
<p>Maximum cyclomatic complexity, default <code>15</code>. Expressions more complex
than this are linted.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# will produce lints
lint(
  text = "if (TRUE) 1 else 2",
  linters = cyclocomp_linter(complexity_limit = 1L)
)

# okay
lint(
  text = "if (TRUE) 1 else 2",
  linters = cyclocomp_linter(complexity_limit = 2L)
)

</code></pre>

<hr>
<h2 id='default_linters'>Default linters</h2><span id='topic+default_linters'></span>

<h3>Description</h3>

<p>List of default linters for <code><a href="#topic+lint">lint()</a></code>. Use
<code><a href="#topic+linters_with_defaults">linters_with_defaults()</a></code> to customize it. Most of the default linters
are based on <a href="https://style.tidyverse.org/">the tidyverse style guide</a>.
</p>
<p>The set of default linters is as follows (any parameterized linters, e.g., <code>line_length_linter</code> use their default
argument(s), see <code style="white-space: pre;">&#8288;?&lt;linter_name&gt;&#8288;</code> for details):
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_linters
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 25.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'default':
</p>

<ul>
<li><p><code><a href="#topic+assignment_linter">assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+brace_linter">brace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+commas_linter">commas_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+commented_code_linter">commented_code_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+equals_na_linter">equals_na_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+function_left_parentheses_linter">function_left_parentheses_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+indentation_linter">indentation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+infix_spaces_linter">infix_spaces_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+line_length_linter">line_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_length_linter">object_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_name_linter">object_name_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_usage_linter">object_usage_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+paren_body_linter">paren_body_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_continuation_linter">pipe_continuation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+quotes_linter">quotes_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+return_linter">return_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+semicolon_linter">semicolon_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+seq_linter">seq_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+spaces_inside_linter">spaces_inside_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+spaces_left_parentheses_linter">spaces_left_parentheses_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+T_and_F_symbol_linter">T_and_F_symbol_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+trailing_blank_lines_linter">trailing_blank_lines_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+trailing_whitespace_linter">trailing_whitespace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+vector_logic_linter">vector_logic_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+whitespace_linter">whitespace_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='default_settings'>Default lintr settings</h2><span id='topic+default_settings'></span><span id='topic+settings'></span><span id='topic+config'></span><span id='topic+lintr-config'></span><span id='topic+lintr-settings'></span><span id='topic+.lintr'></span>

<h3>Description</h3>

<p>The default settings consist of
</p>

<ul>
<li> <p><code>linters</code>: a list of default linters (see <code><a href="#topic+default_linters">default_linters()</a></code>)
</p>
</li>
<li> <p><code>encoding</code>: the character encoding assumed for the file
</p>
</li>
<li> <p><code>exclude</code>: pattern used to exclude a line of code
</p>
</li>
<li> <p><code>exclude_start</code>, <code>exclude_end</code>: patterns used to mark start and end of the code block to exclude
</p>
</li>
<li> <p><code>exclude_linter</code>, <code>exclude_linter_sep</code>: patterns used to exclude linters
</p>
</li>
<li> <p><code>exclusions</code>: a list of exclusions, see <code><a href="#topic+exclude">exclude()</a></code> for a complete description of valid values.
</p>
</li>
<li> <p><code>cache_directory</code>: location of cache directory
</p>
</li>
<li> <p><code>comment_token</code>: a GitHub token character
</p>
</li>
<li> <p><code>error_on_lint</code>: decides if error should be produced when any lints are found
</p>
</li></ul>

<p>There are no settings without defaults, i.e., this list describes every valid setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_settings
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 12.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_settings">read_settings()</a></code>, <a href="#topic+default_linters">default_linters</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># available settings
names(default_settings)

# linters included by default
names(default_settings$linters)

# default values for a few of the other settings
default_settings[c(
  "encoding",
  "exclude",
  "exclude_start",
  "exclude_end",
  "exclude_linter",
  "exclude_linter_sep",
  "exclusions",
  "error_on_lint"
)]

</code></pre>

<hr>
<h2 id='deprecated_linters'>Deprecated linters</h2><span id='topic+deprecated_linters'></span>

<h3>Description</h3>

<p>Linters that are deprecated and provided for backwards compatibility only.
These linters will be excluded from <code><a href="#topic+linters_with_tags">linters_with_tags()</a></code> by default.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'deprecated':
</p>

<ul>
<li><p><code><a href="#topic+consecutive_stopifnot_linter">consecutive_stopifnot_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+extraction_operator_linter">extraction_operator_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+no_tab_linter">no_tab_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+single_quotes_linter">single_quotes_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_nested_if_linter">unnecessary_nested_if_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unneeded_concatenation_linter">unneeded_concatenation_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='duplicate_argument_linter'>Duplicate argument linter</h2><span id='topic+duplicate_argument_linter'></span>

<h3>Description</h3>

<p>Check for duplicate arguments in function calls. Some cases are run-time errors
(e.g. <code>mean(x = 1:5, x = 2:3)</code>), otherwise this linter is used to discourage
explicitly providing duplicate names to objects (e.g. <code>c(a = 1, a = 2)</code>).
Duplicate-named objects are hard to work with programmatically and
should typically be avoided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicate_argument_linter(except = c("mutate", "transmute"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="duplicate_argument_linter_+3A_except">except</code></td>
<td>
<p>A character vector of function names as exceptions. Defaults to
functions that allow sequential updates to variables, currently <code>dplyr::mutate()</code>
and <code>dplyr::transmute()</code>.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+common_mistakes_linters">common_mistakes</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+correctness_linters">correctness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "list(x = 1, x = 2)",
  linters = duplicate_argument_linter()
)

lint(
  text = "fun(arg = 1, arg = 2)",
  linters = duplicate_argument_linter()
)

# okay
lint(
  text = "list(x = 1, x = 2)",
  linters = duplicate_argument_linter(except = "list")
)

lint(
  text = "df %&gt;% dplyr::mutate(x = a + b, x = x + d)",
  linters = duplicate_argument_linter()
)

</code></pre>

<hr>
<h2 id='efficiency_linters'>Efficiency linters</h2><span id='topic+efficiency_linters'></span>

<h3>Description</h3>

<p>Linters highlighting code efficiency problems, such as unnecessary function calls.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'efficiency':
</p>

<ul>
<li><p><code><a href="#topic+any_duplicated_linter">any_duplicated_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+any_is_na_linter">any_is_na_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+boolean_arithmetic_linter">boolean_arithmetic_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+consecutive_mutate_linter">consecutive_mutate_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+fixed_regex_linter">fixed_regex_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+if_switch_linter">if_switch_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+ifelse_censor_linter">ifelse_censor_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+inner_combine_linter">inner_combine_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+length_test_linter">length_test_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+lengths_linter">lengths_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+literal_coercion_linter">literal_coercion_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+matrix_apply_linter">matrix_apply_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nested_ifelse_linter">nested_ifelse_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nrow_subset_linter">nrow_subset_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nzchar_linter">nzchar_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+outer_negation_linter">outer_negation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+redundant_equals_linter">redundant_equals_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+redundant_ifelse_linter">redundant_ifelse_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+regex_subset_linter">regex_subset_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+routine_registration_linter">routine_registration_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+sample_int_linter">sample_int_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+scalar_in_linter">scalar_in_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+seq_linter">seq_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+sort_linter">sort_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+string_boundary_linter">string_boundary_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_concatenation_linter">unnecessary_concatenation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_lambda_linter">unnecessary_lambda_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+vector_logic_linter">vector_logic_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+which_grepl_linter">which_grepl_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='empty_assignment_linter'>Block assignment of <code>{}</code></h2><span id='topic+empty_assignment_linter'></span>

<h3>Description</h3>

<p>Assignment of <code>{}</code> is the same as assignment of <code>NULL</code>; use the latter
for clarity. Closely related: <code><a href="#topic+unnecessary_concatenation_linter">unnecessary_concatenation_linter()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_assignment_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x &lt;- {}",
  linters = empty_assignment_linter()
)

writeLines("x = {\n}")
lint(
  text = "x = {\n}",
  linters = empty_assignment_linter()
)

# okay
lint(
  text = "x &lt;- { 3 + 4 }",
  linters = empty_assignment_linter()
)

lint(
  text = "x &lt;- NULL",
  linters = empty_assignment_linter()
)

</code></pre>

<hr>
<h2 id='equals_na_linter'>Equality check with NA linter</h2><span id='topic+equals_na_linter'></span>

<h3>Description</h3>

<p>Check for <code>x == NA</code>, <code>x != NA</code> and <code>x %in% NA</code>. Such usage is almost surely incorrect &ndash;
checks for missing values should be done with <code><a href="base.html#topic+is.na">is.na()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equals_na_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+common_mistakes_linters">common_mistakes</a>, <a href="#topic+correctness_linters">correctness</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x == NA",
  linters = equals_na_linter()
)

lint(
  text = "x != NA",
  linters = equals_na_linter()
)

lint(
  text = "x %in% NA",
  linters = equals_na_linter()
)

# okay
lint(
  text = "is.na(x)",
  linters = equals_na_linter()
)

lint(
  text = "!is.na(x)",
  linters = equals_na_linter()
)

</code></pre>

<hr>
<h2 id='exclude'>Exclude lines or files from linting</h2><span id='topic+exclude'></span>

<h3>Description</h3>

<p>Exclude lines or files from linting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclude(lints, exclusions = settings$exclusions, linter_names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exclude_+3A_lints">lints</code></td>
<td>
<p>that need to be filtered.</p>
</td></tr>
<tr><td><code id="exclude_+3A_exclusions">exclusions</code></td>
<td>
<p>manually specified exclusions</p>
</td></tr>
<tr><td><code id="exclude_+3A_linter_names">linter_names</code></td>
<td>
<p>character vector of names of the active linters, used for parsing inline exclusions.</p>
</td></tr>
<tr><td><code id="exclude_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+parse_exclusions">parse_exclusions()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exclusions can be specified in three different ways.
</p>

<ol>
<li><p> Single line in the source file. default: <code style="white-space: pre;">&#8288;# nolint&#8288;</code>, possibly followed by a listing of linters to exclude.
If the listing is missing, all linters are excluded on that line. The default listing format is
<code style="white-space: pre;">&#8288;# nolint: linter_name, linter2_name.&#8288;</code>. There may not be anything between the colon and the line exclusion tag
and the listing must be terminated with a full stop (<code>.</code>) for the linter list to be respected.
</p>
</li>
<li><p> Line range in the source file. default: <code style="white-space: pre;">&#8288;# nolint start&#8288;</code>, <code style="white-space: pre;">&#8288;# nolint end&#8288;</code>. <code style="white-space: pre;">&#8288;# nolint start&#8288;</code> accepts linter
lists in the same form as <code style="white-space: pre;">&#8288;# nolint&#8288;</code>.
</p>
</li>
<li><p> Exclusions parameter, a list with named and/or unnamed entries.
Outer elements have the following characteristics:
</p>

<ol>
<li><p> Unnamed elements specify filenames or directories.
</p>
</li>
<li><p> Named elements are a vector or list of line numbers, with <code>Inf</code> indicating 'all lines'.
The name gives a path relative to the config.
</p>

<ol>
<li><p> Unnamed elements denote exclusion of all linters in the given path or directory.
</p>
</li>
<li><p> Named elements, where the name specifies a linter, denote exclusion for that linter.
For convenience, a vector can be used in place of a list whenever it would not introduce ambiguity, e.g.
a character vector of files to exclude or a vector of lines to exclude.
</p>
</li></ol>

</li></ol>

</li></ol>


<hr>
<h2 id='executing_linters'>Code executing linters</h2><span id='topic+executing_linters'></span>

<h3>Description</h3>

<p>Linters that evaluate parts of the linted code, such as loading referenced packages.
These linters should not be used with untrusted code, and may need dependencies of the linted package or project to
be available in order to function correctly. For package authors, note that this includes loading the package itself,
e.g. with <code>pkgload::load_all()</code> or installing and attaching the package.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'executing':
</p>

<ul>
<li><p><code><a href="#topic+namespace_linter">namespace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_length_linter">object_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_name_linter">object_name_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_overwrite_linter">object_overwrite_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_usage_linter">object_usage_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unused_import_linter">unused_import_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='expect_comparison_linter'>Require usage of <code>expect_gt(x, y)</code> over <code>expect_true(x &gt; y)</code> (and similar)</h2><span id='topic+expect_comparison_linter'></span>

<h3>Description</h3>

<p><code><a href="testthat.html#topic+comparison-expectations">testthat::expect_gt()</a></code>, <code><a href="testthat.html#topic+comparison-expectations">testthat::expect_gte()</a></code>, <code><a href="testthat.html#topic+comparison-expectations">testthat::expect_lt()</a></code>,
<code><a href="testthat.html#topic+comparison-expectations">testthat::expect_lte()</a></code>, and <code><a href="testthat.html#topic+equality-expectations">testthat::expect_equal()</a></code> exist specifically
for testing comparisons between two objects. <code><a href="testthat.html#topic+logical-expectations">testthat::expect_true()</a></code> can
also be used for such tests, but it is better to use the tailored function
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_comparison_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "expect_true(x &gt; y)",
  linters = expect_comparison_linter()
)

lint(
  text = "expect_true(x &lt;= y)",
  linters = expect_comparison_linter()
)

lint(
  text = "expect_true(x == (y == 2))",
  linters = expect_comparison_linter()
)

# okay
lint(
  text = "expect_gt(x, y)",
  linters = expect_comparison_linter()
)

lint(
  text = "expect_lte(x, y)",
  linters = expect_comparison_linter()
)

lint(
  text = "expect_identical(x, y == 2)",
  linters = expect_comparison_linter()
)

lint(
  text = "expect_true(x &lt; y | x &gt; y^2)",
  linters = expect_comparison_linter()
)

</code></pre>

<hr>
<h2 id='expect_identical_linter'>Require usage of <code>expect_identical(x, y)</code> where appropriate</h2><span id='topic+expect_identical_linter'></span>

<h3>Description</h3>

<p>This linter enforces the usage of <code><a href="testthat.html#topic+equality-expectations">testthat::expect_identical()</a></code> as the
default expectation for comparisons in a testthat suite. <code>expect_true(identical(x, y))</code>
is an equivalent but unadvised method of the same test. Further,
<code><a href="testthat.html#topic+equality-expectations">testthat::expect_equal()</a></code> should only be used when <code>expect_identical()</code>
is inappropriate, i.e., when <code>x</code> and <code>y</code> need only be <em>numerically
equivalent</em> instead of fully identical (in which case, provide the
<code style="white-space: pre;">&#8288;tolerance=&#8288;</code> argument to <code>expect_equal()</code> explicitly). This also applies
when it's inconvenient to check full equality (e.g., names can be ignored,
in which case <code>ignore_attr = "names"</code> should be supplied to
<code>expect_equal()</code> (or, for 2nd edition, <code>check.attributes = FALSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_identical_linter()
</code></pre>


<h3>Exceptions</h3>

<p>The linter allows <code>expect_equal()</code> in three circumstances:
</p>

<ol>
<li><p> A named argument is set (e.g. <code>ignore_attr</code> or <code>tolerance</code>)
</p>
</li>
<li><p> Comparison is made to an explicit decimal, e.g.
<code>expect_equal(x, 1.0)</code> (implicitly setting <code>tolerance</code>)
</p>
</li>
<li> <p><code>...</code> is passed (wrapper functions which might set
arguments such as <code>ignore_attr</code> or <code>tolerance</code>)
</p>
</li></ol>



<h3>Tags</h3>

<p><a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "expect_equal(x, y)",
  linters = expect_identical_linter()
)

lint(
  text = "expect_true(identical(x, y))",
  linters = expect_identical_linter()
)

# okay
lint(
  text = "expect_identical(x, y)",
  linters = expect_identical_linter()
)

lint(
  text = "expect_equal(x, y, check.attributes = FALSE)",
  linters = expect_identical_linter()
)

lint(
  text = "expect_equal(x, y, tolerance = 1e-6)",
  linters = expect_identical_linter()
)

</code></pre>

<hr>
<h2 id='expect_length_linter'>Require usage of <code>expect_length(x, n)</code> over <code>expect_equal(length(x), n)</code></h2><span id='topic+expect_length_linter'></span>

<h3>Description</h3>

<p><code><a href="testthat.html#topic+expect_length">testthat::expect_length()</a></code> exists specifically for testing the <code><a href="base.html#topic+length">length()</a></code> of
an object. <code><a href="testthat.html#topic+equality-expectations">testthat::expect_equal()</a></code> can also be used for such tests,
but it is better to use the tailored function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_length_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "expect_equal(length(x), 2L)",
  linters = expect_length_linter()
)

# okay
lint(
  text = "expect_length(x, 2L)",
  linters = expect_length_linter()
)

</code></pre>

<hr>
<h2 id='expect_lint'>Lint expectation</h2><span id='topic+expect_lint'></span><span id='topic+expect_no_lint'></span>

<h3>Description</h3>

<p>These are expectation functions to test specified linters on sample code in the <code>testthat</code> testing framework.
</p>

<ul>
<li> <p><code>expect_lint</code> asserts that specified lints are generated.
</p>
</li>
<li> <p><code>expect_no_lint</code> asserts that no lints are generated.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>expect_lint(content, checks, ..., file = NULL, language = "en")

expect_no_lint(content, ..., file = NULL, language = "en")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expect_lint_+3A_content">content</code></td>
<td>
<p>a character vector for the file content to be linted, each vector element representing a line of
text.</p>
</td></tr>
<tr><td><code id="expect_lint_+3A_checks">checks</code></td>
<td>
<p>checks to be performed:
</p>

<dl>
<dt>NULL</dt><dd><p>check that no lints are returned.</p>
</dd>
<dt>single string or regex object</dt><dd><p>check that the single lint returned has a matching message.</p>
</dd>
<dt>named list</dt><dd><p>check that the single lint returned has fields that match. Accepted fields are the same as those
taken by <code><a href="#topic+Lint">Lint()</a></code>.</p>
</dd>
<dt>list of named lists</dt><dd><p>for each of the multiple lints returned, check that it matches the checks in the
corresponding named list (as described in the point above).</p>
</dd>
</dl>

<p>Named vectors are also accepted instead of named lists, but this is a compatibility feature that
is not recommended for new code.</p>
</td></tr>
<tr><td><code id="expect_lint_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+lint">lint()</a></code>, e.g. the linters or cache to use.</p>
</td></tr>
<tr><td><code id="expect_lint_+3A_file">file</code></td>
<td>
<p>if not <code>NULL</code>, read content from the specified file rather than from <code>content</code>.</p>
</td></tr>
<tr><td><code id="expect_lint_+3A_language">language</code></td>
<td>
<p>temporarily override Rs <code>LANGUAGE</code> envvar, controlling localization of base R error messages.
This makes testing them reproducible on all systems irrespective of their native R language setting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no expected lint
expect_no_lint("a", trailing_blank_lines_linter())

# one expected lint
expect_lint("a\n", "trailing blank", trailing_blank_lines_linter())
expect_lint("a\n", list(message = "trailing blank", line_number = 2), trailing_blank_lines_linter())

# several expected lints
expect_lint("a\n\n", list("trailing blank", "trailing blank"), trailing_blank_lines_linter())
expect_lint(
  "a\n\n",
  list(
    list(message = "trailing blank", line_number = 2),
    list(message = "trailing blank", line_number = 3)
  ),
  trailing_blank_lines_linter()
)
</code></pre>

<hr>
<h2 id='expect_lint_free'>Test that the package is lint free</h2><span id='topic+expect_lint_free'></span>

<h3>Description</h3>

<p>This function is a thin wrapper around lint_package that simply tests there are no
lints in the package. It can be used to ensure that your tests fail if the package
contains lints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_lint_free(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expect_lint_free_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+lint_package">lint_package()</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='expect_named_linter'>Require usage of <code>expect_named(x, n)</code> over <code>expect_equal(names(x), n)</code></h2><span id='topic+expect_named_linter'></span>

<h3>Description</h3>

<p><code><a href="testthat.html#topic+expect_named">testthat::expect_named()</a></code> exists specifically for testing the <code><a href="base.html#topic+names">names()</a></code> of
an object. <code><a href="testthat.html#topic+equality-expectations">testthat::expect_equal()</a></code> can also be used for such tests,
but it is better to use the tailored function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_named_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'expect_equal(names(x), "a")',
  linters = expect_named_linter()
)

# okay
lint(
  text = 'expect_named(x, "a")',
  linters = expect_named_linter()
)

lint(
  text = 'expect_equal(colnames(x), "a")',
  linters = expect_named_linter()
)

lint(
  text = 'expect_equal(dimnames(x), "a")',
  linters = expect_named_linter()
)

</code></pre>

<hr>
<h2 id='expect_not_linter'>Require usage of <code>expect_false(x)</code> over <code>expect_true(!x)</code></h2><span id='topic+expect_not_linter'></span>

<h3>Description</h3>

<p><code><a href="testthat.html#topic+logical-expectations">testthat::expect_false()</a></code> exists specifically for testing that an output is
<code>FALSE</code>. <code><a href="testthat.html#topic+logical-expectations">testthat::expect_true()</a></code> can also be used for such tests by
negating the output, but it is better to use the tailored function instead.
The reverse is also true &ndash; use <code>expect_false(A)</code> instead of
<code>expect_true(!A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_not_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "expect_true(!x)",
  linters = expect_not_linter()
)

# okay
lint(
  text = "expect_false(x)",
  linters = expect_not_linter()
)

</code></pre>

<hr>
<h2 id='expect_null_linter'>Require usage of <code>expect_null</code> for checking <code>NULL</code></h2><span id='topic+expect_null_linter'></span>

<h3>Description</h3>

<p>Require usage of <code>expect_null(x)</code> over <code>expect_equal(x, NULL)</code> and similar
usages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_null_linter()
</code></pre>


<h3>Details</h3>

<p><code><a href="testthat.html#topic+expect_null">testthat::expect_null()</a></code> exists specifically for testing for <code>NULL</code> objects.
<code><a href="testthat.html#topic+equality-expectations">testthat::expect_equal()</a></code>, <code><a href="testthat.html#topic+equality-expectations">testthat::expect_identical()</a></code>, and
<code><a href="testthat.html#topic+logical-expectations">testthat::expect_true()</a></code> can also be used for such tests,
but it is better to use the tailored function instead.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "expect_equal(x, NULL)",
  linters = expect_null_linter()
)

lint(
  text = "expect_identical(x, NULL)",
  linters = expect_null_linter()
)

lint(
  text = "expect_true(is.null(x))",
  linters = expect_null_linter()
)


# okay
lint(
  text = "expect_null(x)",
  linters = expect_null_linter()
)

</code></pre>

<hr>
<h2 id='expect_s3_class_linter'>Require usage of <code>expect_s3_class()</code></h2><span id='topic+expect_s3_class_linter'></span>

<h3>Description</h3>

<p><code><a href="testthat.html#topic+inheritance-expectations">testthat::expect_s3_class()</a></code> exists specifically for testing the class
of S3 objects. <code><a href="testthat.html#topic+equality-expectations">testthat::expect_equal()</a></code>, <code><a href="testthat.html#topic+equality-expectations">testthat::expect_identical()</a></code>,
and <code><a href="testthat.html#topic+logical-expectations">testthat::expect_true()</a></code> can also be used for such tests,
but it is better to use the tailored function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_s3_class_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><code><a href="#topic+expect_s4_class_linter">expect_s4_class_linter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'expect_equal(class(x), "data.frame")',
  linters = expect_s3_class_linter()
)

lint(
  text = 'expect_equal(class(x), "numeric")',
  linters = expect_s3_class_linter()
)

# okay
lint(
  text = 'expect_s3_class(x, "data.frame")',
  linters = expect_s3_class_linter()
)

lint(
  text = 'expect_type(x, "double")',
  linters = expect_s3_class_linter()
)

</code></pre>

<hr>
<h2 id='expect_s4_class_linter'>Require usage of <code>expect_s4_class(x, k)</code> over <code>expect_true(is(x, k))</code></h2><span id='topic+expect_s4_class_linter'></span>

<h3>Description</h3>

<p><code><a href="testthat.html#topic+inheritance-expectations">testthat::expect_s4_class()</a></code> exists specifically for testing the class
of S4 objects. <code><a href="testthat.html#topic+logical-expectations">testthat::expect_true()</a></code> can also be used for such tests,
but it is better to use the tailored function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_s4_class_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><code><a href="#topic+expect_s3_class_linter">expect_s3_class_linter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'expect_true(is(x, "Matrix"))',
  linters = expect_s4_class_linter()
)

# okay
lint(
  text = 'expect_s4_class(x, "Matrix")',
  linters = expect_s4_class_linter()
)

</code></pre>

<hr>
<h2 id='expect_true_false_linter'>Require usage of <code>expect_true(x)</code> over <code>expect_equal(x, TRUE)</code></h2><span id='topic+expect_true_false_linter'></span>

<h3>Description</h3>

<p><code><a href="testthat.html#topic+logical-expectations">testthat::expect_true()</a></code> and <code><a href="testthat.html#topic+logical-expectations">testthat::expect_false()</a></code> exist specifically
for testing the <code>TRUE</code>/<code>FALSE</code> value of an object.
<code><a href="testthat.html#topic+equality-expectations">testthat::expect_equal()</a></code> and <code><a href="testthat.html#topic+equality-expectations">testthat::expect_identical()</a></code> can also be
used for such tests, but it is better to use the tailored function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_true_false_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "expect_equal(x, TRUE)",
  linters = expect_true_false_linter()
)

lint(
  text = "expect_equal(x, FALSE)",
  linters = expect_true_false_linter()
)

# okay
lint(
  text = "expect_true(x)",
  linters = expect_true_false_linter()
)

lint(
  text = "expect_false(x)",
  linters = expect_true_false_linter()
)

</code></pre>

<hr>
<h2 id='expect_type_linter'>Require usage of <code>expect_type(x, type)</code> over <code>expect_equal(typeof(x), type)</code></h2><span id='topic+expect_type_linter'></span>

<h3>Description</h3>

<p><code><a href="testthat.html#topic+inheritance-expectations">testthat::expect_type()</a></code> exists specifically for testing the storage type
of objects. <code><a href="testthat.html#topic+equality-expectations">testthat::expect_equal()</a></code>, <code><a href="testthat.html#topic+equality-expectations">testthat::expect_identical()</a></code>, and
<code><a href="testthat.html#topic+logical-expectations">testthat::expect_true()</a></code> can also be used for such tests,
but it is better to use the tailored function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_type_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'expect_equal(typeof(x), "double")',
  linters = expect_type_linter()
)

lint(
  text = 'expect_identical(typeof(x), "double")',
  linters = expect_type_linter()
)

# okay
lint(
  text = 'expect_type(x, "double")',
  linters = expect_type_linter()
)

</code></pre>

<hr>
<h2 id='fixed_regex_linter'>Require usage of <code>fixed=TRUE</code> in regular expressions where appropriate</h2><span id='topic+fixed_regex_linter'></span>

<h3>Description</h3>

<p>Invoking a regular expression engine is overkill for cases when the search
pattern only involves static patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed_regex_linter(allow_unescaped = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixed_regex_linter_+3A_allow_unescaped">allow_unescaped</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, only patterns that
require regex escapes (e.g. <code>"\\$"</code> or <code>"[$]"</code>) will be linted. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NB: for <code>stringr</code> functions, that means wrapping the pattern in <code>stringr::fixed()</code>.
</p>
<p>NB: this linter is likely not able to distinguish every possible case when
a fixed regular expression is preferable, rather it seeks to identify
likely cases. It should <em>never</em> report false positives, however; please
report false positives as an error.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+regex_linters">regex</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code_lines &lt;- 'gsub("\\\\.", "", x)'
writeLines(code_lines)
lint(
  text = code_lines,
  linters = fixed_regex_linter()
)

lint(
  text = 'grepl("a[*]b", x)',
  linters = fixed_regex_linter()
)

lint(
  text = 'grepl("a[*]b", x)',
  linters = fixed_regex_linter(allow_unescaped = TRUE)
)

code_lines &lt;- 'stringr::str_subset(x, "\\\\$")'
writeLines(code_lines)
lint(
  text = code_lines,
  linters = fixed_regex_linter()
)

lint(
  text = 'grepl("Munich", address)',
  linters = fixed_regex_linter()
)

# okay
code_lines &lt;- 'gsub("\\\\.", "", x, fixed = TRUE)'
writeLines(code_lines)
lint(
  text = code_lines,
  linters = fixed_regex_linter()
)

lint(
  text = 'grepl("a*b", x, fixed = TRUE)',
  linters = fixed_regex_linter()
)

lint(
  text = 'stringr::str_subset(x, stringr::fixed("$"))',
  linters = fixed_regex_linter()
)

lint(
  text = 'grepl("Munich", address, fixed = TRUE)',
  linters = fixed_regex_linter()
)

lint(
  text = 'grepl("Munich", address)',
  linters = fixed_regex_linter(allow_unescaped = TRUE)
)

</code></pre>

<hr>
<h2 id='for_loop_index_linter'>Block usage of for loops directly overwriting the indexing variable</h2><span id='topic+for_loop_index_linter'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;for (x in x)&#8288;</code> is a poor choice of indexing variable. This overwrites
<code>x</code> in the calling scope and is confusing to read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>for_loop_index_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "for (x in x) { TRUE }",
  linters = for_loop_index_linter()
)

lint(
  text = "for (x in foo(x, y)) { TRUE }",
  linters = for_loop_index_linter()
)

# okay
lint(
  text = "for (xi in x) { TRUE }",
  linters = for_loop_index_linter()
)

lint(
  text = "for (col in DF$col) { TRUE }",
  linters = for_loop_index_linter()
)

</code></pre>

<hr>
<h2 id='function_argument_linter'>Function argument linter</h2><span id='topic+function_argument_linter'></span>

<h3>Description</h3>

<p>Check that arguments with defaults come last in all function declarations,
as per the tidyverse design guide.
</p>
<p>Changing the argument order can be a breaking change. An alternative to changing the argument order
is to instead set the default for such arguments to <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_argument_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://design.tidyverse.org/required-no-defaults.html">https://design.tidyverse.org/required-no-defaults.html</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "function(y = 1, z = 2, x) {}",
  linters = function_argument_linter()
)

lint(
  text = "function(x, y, z = 1, ..., w) {}",
  linters = function_argument_linter()
)

# okay
lint(
  text = "function(x, y = 1, z = 2) {}",
  linters = function_argument_linter()
)

lint(
  text = "function(x, y, w, z = 1, ...) {}",
  linters = function_argument_linter()
)

lint(
  text = "function(y = 1, z = 2, x = NULL) {}",
  linters = function_argument_linter()
)

lint(
  text = "function(x, y, z = 1, ..., w = NULL) {}",
  linters = function_argument_linter()
)

</code></pre>

<hr>
<h2 id='function_left_parentheses_linter'>Function left parentheses linter</h2><span id='topic+function_left_parentheses_linter'></span>

<h3>Description</h3>

<p>Check that all left parentheses in a function call do not have spaces before them
(e.g. <code>mean  (1:3)</code>). Although this is syntactically valid, it makes the code
difficult to read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_left_parentheses_linter()
</code></pre>


<h3>Details</h3>

<p>Exceptions are made for control flow functions (<code>if</code>, <code>for</code>, etc.).
</p>


<h3>Tags</h3>

<p><a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#parentheses">https://style.tidyverse.org/syntax.html#parentheses</a>
</p>
</li>
<li> <p><code><a href="#topic+spaces_left_parentheses_linter">spaces_left_parentheses_linter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "mean (x)",
  linters = function_left_parentheses_linter()
)

lint(
  text = "stats::sd(c (x, y, z))",
  linters = function_left_parentheses_linter()
)

# okay
lint(
  text = "mean(x)",
  linters = function_left_parentheses_linter()
)

lint(
  text = "stats::sd(c(x, y, z))",
  linters = function_left_parentheses_linter()
)

lint(
  text = "foo &lt;- function(x) (x + 1)",
  linters = function_left_parentheses_linter()
)

</code></pre>

<hr>
<h2 id='function_return_linter'>Lint common mistakes/style issues cropping up from return statements</h2><span id='topic+function_return_linter'></span>

<h3>Description</h3>

<p><code>return(x &lt;- ...)</code> is either distracting (because <code>x</code> is ignored), or
confusing (because assigning to <code>x</code> has some side effect that is muddled
by the dual-purpose expression).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_return_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "foo &lt;- function(x) return(y &lt;- x + 1)",
  linters = function_return_linter()
)

lint(
  text = "foo &lt;- function(x) return(x &lt;&lt;- x + 1)",
  linters = function_return_linter()
)

writeLines("e &lt;- new.env() \nfoo &lt;- function(x) return(e$val &lt;- x + 1)")
lint(
  text = "e &lt;- new.env() \nfoo &lt;- function(x) return(e$val &lt;- x + 1)",
  linters = function_return_linter()
)

# okay
lint(
  text = "foo &lt;- function(x) return(x + 1)",
  linters = function_return_linter()
)

code_lines &lt;- "
foo &lt;- function(x) {
  x &lt;&lt;- x + 1
  return(x)
}
"
lint(
  text = code_lines,
  linters = function_return_linter()
)

code_lines &lt;- "
e &lt;- new.env()
foo &lt;- function(x) {
  e$val &lt;- x + 1
  return(e$val)
}
"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = function_return_linter()
)

</code></pre>

<hr>
<h2 id='get_r_string'>Extract text from <code>STR_CONST</code> nodes</h2><span id='topic+get_r_string'></span>

<h3>Description</h3>

<p>Convert <code>STR_CONST</code> <code>text()</code> values into R strings. This is useful to account for arbitrary
character literals, e.g. <code>R"------[hello]------"</code>, which is parsed in R as <code>"hello"</code>.
It is quite cumbersome to write XPaths allowing for strings like this, so whenever your
linter logic requires testing a <code>STR_CONST</code> node's value, use this function.
NB: this is also properly vectorized on <code>s</code>, and accepts a variety of inputs. Empty inputs
will become <code>NA</code> outputs, which helps ensure that <code>length(get_r_string(s)) == length(s)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_r_string(s, xpath = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_r_string_+3A_s">s</code></td>
<td>
<p>An input string or strings. If <code>s</code> is an <code>xml_node</code> or <code>xml_nodeset</code> and <code>xpath</code> is <code>NULL</code>,
extract its string value with <code><a href="xml2.html#topic+xml_text">xml2::xml_text()</a></code>. If <code>s</code> is an <code>xml_node</code> or <code>xml_nodeset</code>
and <code>xpath</code> is specified, it is extracted with <code><a href="xml2.html#topic+xml_find_all">xml2::xml_find_chr()</a></code>.</p>
</td></tr>
<tr><td><code id="get_r_string_+3A_xpath">xpath</code></td>
<td>
<p>An XPath, passed on to <code><a href="xml2.html#topic+xml_find_all">xml2::xml_find_chr()</a></code> after wrapping with <code>string()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
writeLines("c('a', 'b')", tmp)
expr_as_xml &lt;- get_source_expressions(tmp)$expressions[[1L]]$xml_parsed_content
writeLines(as.character(expr_as_xml))
get_r_string(expr_as_xml, "expr[2]")
get_r_string(expr_as_xml, "expr[3]")
unlink(tmp)

# more importantly, extract raw strings correctly
tmp_raw &lt;- tempfile()
writeLines("c(R'(a\\b)', R'--[a\\\"\'\"\\b]--')", tmp_raw)
expr_as_xml_raw &lt;- get_source_expressions(tmp_raw)$expressions[[1L]]$xml_parsed_content
writeLines(as.character(expr_as_xml_raw))
get_r_string(expr_as_xml_raw, "expr[2]")
get_r_string(expr_as_xml_raw, "expr[3]")
unlink(tmp_raw)

</code></pre>

<hr>
<h2 id='get_source_expressions'>Parsed sourced file from a filename</h2><span id='topic+get_source_expressions'></span>

<h3>Description</h3>

<p>This object is given as input to each linter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_source_expressions(filename, lines = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_source_expressions_+3A_filename">filename</code></td>
<td>
<p>the file to be parsed.</p>
</td></tr>
<tr><td><code id="get_source_expressions_+3A_lines">lines</code></td>
<td>
<p>a character vector of lines.
If <code>NULL</code>, then <code>filename</code> will be read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file is read using the <code>encoding</code> setting.
This setting is found by taking the first valid result from the following locations
</p>

<ol>
<li><p> The <code>encoding</code> key from the usual lintr configuration settings.
</p>
</li>
<li><p> The <code>Encoding</code> field from a Package <code>DESCRIPTION</code> file in a parent directory.
</p>
</li>
<li><p> The <code>Encoding</code> field from an R Project <code>.Rproj</code> file in a parent directory.
</p>
</li>
<li> <p><code>"UTF-8"</code> as a fallback.
</p>
</li></ol>



<h3>Value</h3>

<p>A <code>list</code> with three components:
</p>

<dl>
<dt>expressions</dt><dd><p>a <code>list</code> of
<code>n+1</code> objects. The first <code>n</code> elements correspond to each expression in
<code>filename</code>, and consist of a list of 8 elements:
</p>

<ul>
<li><p><code>filename</code> (<code>character</code>) the name of the file.
</p>
</li>
<li><p><code>line</code> (<code>integer</code>) the line in the file where this expression begins.
</p>
</li>
<li><p><code>column</code> (<code>integer</code>) the column in the file where this expression begins.
</p>
</li>
<li><p><code>lines</code> (named <code>character</code>) vector of all lines spanned by this
expression, named with the corresponding line numbers.
</p>
</li>
<li><p><code>parsed_content</code> (<code>data.frame</code>) as given by <code><a href="utils.html#topic+getParseData">utils::getParseData()</a></code> for this expression.
</p>
</li>
<li><p><code>xml_parsed_content</code> (<code>xml_document</code>) the XML parse tree of this expression as given by
<code><a href="xmlparsedata.html#topic+xml_parse_data">xmlparsedata::xml_parse_data()</a></code>.
</p>
</li>
<li><p><code>content</code> (<code>character</code>) the same as <code>lines</code> as a single string (not split across lines).
</p>
</li>
<li><p><code>xml_find_function_calls(function_names)</code> (<code>function</code>) a function that returns all <code>SYMBOL_FUNCTION_CALL</code>
XML nodes from <code>xml_parsed_content</code> with specified function names.
</p>
</li></ul>

<p>The final element of <code>expressions</code> is a list corresponding to the full file
consisting of 7 elements:
</p>

<ul>
<li><p><code>filename</code> (<code>character</code>) the name of this file.
</p>
</li>
<li><p><code>file_lines</code> (<code>character</code>) the <code><a href="base.html#topic+readLines">readLines()</a></code> output for this file.
</p>
</li>
<li><p><code>content</code> (<code>character</code>) for .R files, the same as <code>file_lines</code>;
for .Rmd or .qmd scripts, this is the extracted R source code (as text).
</p>
</li>
<li><p><code>full_parsed_content</code> (<code>data.frame</code>) as given by
<code><a href="utils.html#topic+getParseData">utils::getParseData()</a></code> for the full content.
</p>
</li>
<li><p><code>full_xml_parsed_content</code> (<code>xml_document</code>) the XML parse tree of all
expressions as given by <code><a href="xmlparsedata.html#topic+xml_parse_data">xmlparsedata::xml_parse_data()</a></code>.
</p>
</li>
<li><p><code>terminal_newline</code> (<code>logical</code>) records whether <code>filename</code> has a terminal
newline (as determined by <code><a href="base.html#topic+readLines">readLines()</a></code> producing a corresponding warning).
</p>
</li>
<li><p><code>xml_find_function_calls(function_names)</code> (<code>function</code>) a function that returns all <code>SYMBOL_FUNCTION_CALL</code>
XML nodes from <code>full_xml_parsed_content</code> with specified function names.
</p>
</li></ul>

</dd>
<dt>error</dt><dd><p>A <code>Lint</code> object describing any parsing error.</p>
</dd>
<dt>lines</dt><dd><p>The <code><a href="base.html#topic+readLines">readLines()</a></code> output for this file.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
writeLines(c("x &lt;- 1", "y &lt;- x + 1"), tmp)
get_source_expressions(tmp)
unlink(tmp)
</code></pre>

<hr>
<h2 id='ids_with_token'>Get parsed IDs by token</h2><span id='topic+ids_with_token'></span><span id='topic+with_id'></span>

<h3>Description</h3>

<p>Gets the source IDs (row indices) corresponding to given token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ids_with_token(source_expression, value, fun = `==`, source_file = NULL)

with_id(source_expression, id, source_file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ids_with_token_+3A_source_expression">source_expression</code></td>
<td>
<p>A list of source expressions, the result of a call to <code><a href="#topic+get_source_expressions">get_source_expressions()</a></code>,
for the desired filename.</p>
</td></tr>
<tr><td><code id="ids_with_token_+3A_value">value</code></td>
<td>
<p>Character. String corresponding to the token to search for.
For example:
</p>

<ul>
<li><p> &quot;SYMBOL&quot;
</p>
</li>
<li><p> &quot;FUNCTION&quot;
</p>
</li>
<li><p> &quot;EQ_FORMALS&quot;
</p>
</li>
<li><p> &quot;$&quot;
</p>
</li>
<li><p> &quot;(&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="ids_with_token_+3A_fun">fun</code></td>
<td>
<p>For additional flexibility, a function to search for in
the <code>token</code> column of <code>parsed_content</code>. Typically <code>==</code> or <code>%in%</code>.</p>
</td></tr>
<tr><td><code id="ids_with_token_+3A_source_file">source_file</code></td>
<td>
<p>(DEPRECATED) Same as <code>source_expression</code>. Will be removed.</p>
</td></tr>
<tr><td><code id="ids_with_token_+3A_id">id</code></td>
<td>
<p>Integer. The index corresponding to the desired row
of <code>parsed_content</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ids_with_token</code>: The indices of the <code>parsed_content</code> data frame
entry of the list of source expressions. Indices correspond to the
<em>rows</em> where <code>fun</code> evaluates to <code>TRUE</code> for the <code>value</code> in the <em>token</em> column.
</p>
<p><code>with_id</code>: A data frame corresponding to the row(s) specified in <code>id</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>with_id()</code>: Return the row of the <code>parsed_content</code> entry of the <code style="white-space: pre;">&#8288;[get_source_expressions]()&#8288;</code> object. Typically used in
conjunction with <code>ids_with_token</code> to iterate over rows containing desired tokens.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
writeLines(c("x &lt;- 1", "y &lt;- x + 1"), tmp)
source_exprs &lt;- get_source_expressions(tmp)
ids_with_token(source_exprs$expressions[[1L]], value = "SYMBOL")
with_id(source_exprs$expressions[[1L]], 2L)
unlink(tmp)

</code></pre>

<hr>
<h2 id='if_not_else_linter'>Block statements like if (!A) x else y</h2><span id='topic+if_not_else_linter'></span>

<h3>Description</h3>

<p><code>if (!A) x else y</code> is the same as <code>if (A) y else x</code>, but the latter is
easier to reason about in the <code style="white-space: pre;">&#8288;else&#8288;</code> case. The former requires
double negation that can be avoided by switching the statement order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_not_else_linter(exceptions = c("is.null", "is.na", "missing"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="if_not_else_linter_+3A_exceptions">exceptions</code></td>
<td>
<p>Character vector of calls to exclude from linting.
By default, <code><a href="base.html#topic+is.null">is.null()</a></code>, <code><a href="base.html#topic+is.na">is.na()</a></code>, and <code><a href="base.html#topic+missing">missing()</a></code> are excluded
given the common idiom <code>!is.na(x)</code> as &quot;x is present&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This only applies in the simple <code style="white-space: pre;">&#8288;if/else&#8288;</code> case. Statements like
<code>if (!A) x else if (B) y else z</code> don't always have a simpler or
more readable form.
</p>
<p>It also applies to <code><a href="base.html#topic+ifelse">ifelse()</a></code> and the package equivalents
<code>dplyr::if_else()</code> and <code>data.table::fifelse()</code>.
</p>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "if (!A) x else y",
  linters = if_not_else_linter()
)

lint(
  text = "if (!A) x else if (!B) y else z",
  linters = if_not_else_linter()
)

lint(
  text = "ifelse(!is_treatment, x, y)",
  linters = if_not_else_linter()
)

lint(
  text = "if (!is.null(x)) x else 2",
  linters = if_not_else_linter(exceptions = character())
)

# okay
lint(
  text = "if (A) x else y",
  linters = if_not_else_linter()
)

lint(
  text = "if (!A) x else if (B) z else y",
  linters = if_not_else_linter()
)

lint(
  text = "ifelse(is_treatment, y, x)",
  linters = if_not_else_linter()
)

lint(
  text = "if (!is.null(x)) x else 2",
  linters = if_not_else_linter()
)

</code></pre>

<hr>
<h2 id='if_switch_linter'>Require usage of switch() over repeated if/else blocks</h2><span id='topic+if_switch_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+switch">switch()</a></code> statements in R are used to delegate behavior based
on the value of some input scalar string, e.g.
<code>switch(x, a = 1, b = 3, c = 7, d = 8)</code> will be one of
<code>1</code>, <code>3</code>, <code>7</code>, or <code>8</code>, depending on the value of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_switch_linter(max_branch_lines = 0L, max_branch_expressions = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="if_switch_linter_+3A_max_branch_lines">max_branch_lines</code>, <code id="if_switch_linter_+3A_max_branch_expressions">max_branch_expressions</code></td>
<td>
<p>Integer, default 0 indicates &quot;no maximum&quot;.
If set any <code>if</code>/<code style="white-space: pre;">&#8288;else if&#8288;</code>/.../<code style="white-space: pre;">&#8288;else&#8288;</code> chain where any branch occupies more than
this number of lines (resp. expressions) will not be linted. The conjugate
applies to <code>switch()</code> statements &ndash; if these parameters are set, any <code>switch()</code>
statement with any overly-complicated branches will be linted. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can also be accomplished by repeated <code>if</code>/<code style="white-space: pre;">&#8288;else&#8288;</code> statements like
so: <code>if (x == "a") 1 else if (x == "b") 2 else if (x == "c") 7 else 8</code>
(implicitly, the last <code style="white-space: pre;">&#8288;else&#8288;</code> assumes x only takes 4 possible values),
but this is more cluttered and slower (note that <code>switch()</code> takes the same
time to evaluate regardless of the value of <code>x</code>, and is faster even
when <code>x</code> takes the first value (here <code>a</code>), and that the <code>if</code>/<code style="white-space: pre;">&#8288;else&#8288;</code>
approach is roughly linear in the number of conditions that need to
be evaluated, here up to 3 times).
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "if (x == 'a') 1 else if (x == 'b') 2 else 3",
  linters = if_switch_linter()
)

code &lt;- paste(
  "if (x == 'a') {",
  "  1",
  "} else if (x == 'b') {",
  "  2",
  "} else if (x == 'c') {",
  "  y &lt;- x",
  "  z &lt;- sqrt(match(y, letters))",
  "  z",
  "}",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = if_switch_linter()
)

code &lt;- paste(
  "if (x == 'a') {",
  "  1",
  "} else if (x == 'b') {",
  "  2",
  "} else if (x == 'c') {",
  "  y &lt;- x",
  "  z &lt;- sqrt(",
  "    match(y, letters)",
  "  )",
  "  z",
  "}",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = if_switch_linter()
)

code &lt;- paste(
  "switch(x,",
  "  a = {",
  "    1",
  "    2",
  "    3",
  "  },",
  "  b = {",
  "    1",
  "    2",
  "  }",
  ")",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = if_switch_linter(max_branch_lines = 2L)
)

# okay
lint(
  text = "switch(x, a = 1, b = 2, 3)",
  linters = if_switch_linter()
)

# switch() version not as clear
lint(
  text = "if (x == 'a') 1 else if (x == 'b' &amp; y == 2) 2 else 3",
  linters = if_switch_linter()
)

code &lt;- paste(
  "if (x == 'a') {",
  "  1",
  "} else if (x == 'b') {",
  "  2",
  "} else if (x == 'c') {",
  "  y &lt;- x",
  "  z &lt;- sqrt(match(y, letters))",
  "  z",
  "}",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = if_switch_linter(max_branch_lines = 2L)
)

code &lt;- paste(
  "if (x == 'a') {",
  "  1",
  "} else if (x == 'b') {",
  "  2",
  "} else if (x == 'c') {",
  "  y &lt;- x",
  "  z &lt;- sqrt(",
  "    match(y, letters)",
  "  )",
  "  z",
  "}",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = if_switch_linter(max_branch_expressions = 2L)
)

code &lt;- paste(
  "switch(x,",
  "  a = {",
  "    1",
  "    2",
  "    3",
  "  },",
  "  b = {",
  "    1",
  "    2",
  "  }",
  ")",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = if_switch_linter(max_branch_lines = 3L)
)

</code></pre>

<hr>
<h2 id='ifelse_censor_linter'>Block usage of <code>ifelse()</code> where <code>pmin()</code> or <code>pmax()</code> is more appropriate</h2><span id='topic+ifelse_censor_linter'></span>

<h3>Description</h3>

<p><code>ifelse(x &gt; M, M, x)</code> is the same as <code>pmin(x, M)</code>, but harder
to read and requires several passes over the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifelse_censor_linter()
</code></pre>


<h3>Details</h3>

<p>The same goes for other similar ways to censor a vector, e.g.
<code>ifelse(x &lt;= M, x, M)</code> is <code>pmin(x, M)</code>,
<code>ifelse(x &lt; m, m, x)</code> is <code>pmax(x, m)</code>, and
<code>ifelse(x &gt;= m, x, m)</code> is <code>pmax(x, m)</code>.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+efficiency_linters">efficiency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "ifelse(5:1 &lt; pi, 5:1, pi)",
  linters = ifelse_censor_linter()
)

lint(
  text = "ifelse(x &gt; 0, x, 0)",
  linters = ifelse_censor_linter()
)

# okay
lint(
  text = "pmin(5:1, pi)",
  linters = ifelse_censor_linter()
)

lint(
  text = "pmax(x, 0)",
  linters = ifelse_censor_linter()
)

</code></pre>

<hr>
<h2 id='implicit_assignment_linter'>Avoid implicit assignment in function calls</h2><span id='topic+implicit_assignment_linter'></span>

<h3>Description</h3>

<p>Assigning inside function calls makes the code difficult to read, and should
be avoided, except for functions that capture side-effects (e.g. <code><a href="utils.html#topic+capture.output">capture.output()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>implicit_assignment_linter(
  except = c("bquote", "expression", "expr", "quo", "quos", "quote"),
  allow_lazy = FALSE,
  allow_scoped = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="implicit_assignment_linter_+3A_except">except</code></td>
<td>
<p>A character vector of functions to be excluded from linting.</p>
</td></tr>
<tr><td><code id="implicit_assignment_linter_+3A_allow_lazy">allow_lazy</code></td>
<td>
<p>logical, default <code>FALSE</code>. If <code>TRUE</code>, assignments that only
trigger conditionally (e.g. in the RHS of <code>&amp;&amp;</code> or <code>||</code> expressions) are skipped.</p>
</td></tr>
<tr><td><code id="implicit_assignment_linter_+3A_allow_scoped">allow_scoped</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, &quot;scoped assignments&quot;,
where the object is assigned in the statement beginning a branch and used only
within that branch, are skipped.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#assignment">https://style.tidyverse.org/syntax.html#assignment</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "if (x &lt;- 1L) TRUE",
  linters = implicit_assignment_linter()
)

lint(
  text = "mean(x &lt;- 1:4)",
  linters = implicit_assignment_linter()
)

# okay
lines &lt;- "x &lt;- 1L\nif (x) TRUE"
writeLines(lines)
lint(
  text = lines,
  linters = implicit_assignment_linter()
)

lines &lt;- "x &lt;- 1:4\nmean(x)"
writeLines(lines)
lint(
  text = lines,
  linters = implicit_assignment_linter()
)

lint(
  text = "A &amp;&amp; (B &lt;- foo(A))",
  linters = implicit_assignment_linter(allow_lazy = TRUE)
)

lines &lt;- c(
  "if (any(idx &lt;- x &lt; 0)) {",
  "  stop('negative elements: ', toString(which(idx)))",
  "}"
)
writeLines(lines)
lint(
  text = lines,
  linters = implicit_assignment_linter(allow_scoped = TRUE)
)

</code></pre>

<hr>
<h2 id='implicit_integer_linter'>Implicit integer linter</h2><span id='topic+implicit_integer_linter'></span>

<h3>Description</h3>

<p>Check that integers are explicitly typed using the form <code>1L</code> instead of <code>1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>implicit_integer_linter(allow_colon = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="implicit_integer_linter_+3A_allow_colon">allow_colon</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, expressions involving <code>:</code>
won't throw a lint regardless of whether the inputs are implicitly integers.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x &lt;- 1",
  linters = implicit_integer_linter()
)

lint(
  text = "x[2]",
  linters = implicit_integer_linter()
)

lint(
  text = "1:10",
  linters = implicit_integer_linter()
)

# okay
lint(
  text = "x &lt;- 1.0",
  linters = implicit_integer_linter()
)

lint(
  text = "x &lt;- 1L",
  linters = implicit_integer_linter()
)

lint(
  text = "x[2L]",
  linters = implicit_integer_linter()
)

lint(
  text = "1:10",
  linters = implicit_integer_linter(allow_colon = TRUE)
)

</code></pre>

<hr>
<h2 id='indentation_linter'>Check that indentation is consistent</h2><span id='topic+indentation_linter'></span>

<h3>Description</h3>

<p>Check that indentation is consistent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indentation_linter(
  indent = 2L,
  hanging_indent_style = c("tidy", "always", "never"),
  assignment_as_infix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indentation_linter_+3A_indent">indent</code></td>
<td>
<p>Number of spaces, that a code block should be indented by relative to its parent code block.
Used for multi-line code blocks (<code>{ ... }</code>), function calls (<code>( ... )</code>) and extractions (<code style="white-space: pre;">&#8288;[ ... ]&#8288;</code>, <code style="white-space: pre;">&#8288;[[ ... ]]&#8288;</code>).
Defaults to 2.</p>
</td></tr>
<tr><td><code id="indentation_linter_+3A_hanging_indent_style">hanging_indent_style</code></td>
<td>
<p>Indentation style for multi-line function calls with arguments in their first line.
Defaults to tidyverse style, i.e. a block indent is used if the function call terminates with <code style="white-space: pre;">&#8288;)&#8288;</code> on a separate
line and a hanging indent if not.
Note that function multi-line function calls without arguments on their first line will always be expected to have
block-indented arguments.
If <code>hanging_indent_style</code> is <code>"tidy"</code>, multi-line function definitions are expected to be double-indented if the
first line of the function definition contains no arguments and the closing parenthesis is not on its own line.
</p>
<div class="sourceCode r"><pre># complies to any style
map(
  x,
  f,
  additional_arg = 42
)

# complies to "tidy" and "never"
map(x, f,
  additional_arg = 42
)

# complies to "always"
map(x, f,
    additional_arg = 42
)

# complies to "tidy" and "always"
map(x, f,
    additional_arg = 42)

# complies to "never"
map(x, f,
  additional_arg = 42)

# complies to "tidy"
function(
    a,
    b) {
  # body
}
</pre></div></td></tr>
<tr><td><code id="indentation_linter_+3A_assignment_as_infix">assignment_as_infix</code></td>
<td>
<p>Treat <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> as a regular (i.e. left-associative) infix operator?
This means, that infix operators on the right hand side of an assignment do not trigger a second level of
indentation:
</p>
<div class="sourceCode r"><pre># complies to any style
variable &lt;- a %+%
  b %+%
  c

# complies to assignment_as_infix = TRUE
variable &lt;-
  a %+%
  b %+%
  c

# complies to assignment_as_infix = FALSE
variable &lt;-
  a %+%
    b %+%
    c
</pre></div></td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#indenting">https://style.tidyverse.org/syntax.html#indenting</a>
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/functions.html#long-lines-1">https://style.tidyverse.org/functions.html#long-lines-1</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code_lines &lt;- "if (TRUE) {\n1 + 1\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = indentation_linter()
)

code_lines &lt;- "if (TRUE) {\n    1 + 1\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = indentation_linter()
)

code_lines &lt;- "map(x, f,\n  additional_arg = 42\n)"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = indentation_linter(hanging_indent_style = "always")
)

code_lines &lt;- "map(x, f,\n    additional_arg = 42)"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = indentation_linter(hanging_indent_style = "never")
)

# okay
code_lines &lt;- "map(x, f,\n  additional_arg = 42\n)"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = indentation_linter()
)

code_lines &lt;- "if (TRUE) {\n    1 + 1\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = indentation_linter(indent = 4)
)

</code></pre>

<hr>
<h2 id='infix_spaces_linter'>Infix spaces linter</h2><span id='topic+infix_spaces_linter'></span>

<h3>Description</h3>

<p>Check that infix operators are surrounded by spaces. Enforces the corresponding Tidyverse style guide rule;
see <a href="https://style.tidyverse.org/syntax.html#infix-operators">https://style.tidyverse.org/syntax.html#infix-operators</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infix_spaces_linter(exclude_operators = NULL, allow_multiple_spaces = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infix_spaces_linter_+3A_exclude_operators">exclude_operators</code></td>
<td>
<p>Character vector of operators to exclude from consideration for linting.
Default is to include the following &quot;low-precedence&quot; operators:
<code>+</code>, <code>-</code>, <code>~</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>!=</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>|</code>, <code>||</code>, <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>, <code style="white-space: pre;">&#8288;:=&#8288;</code>, <code style="white-space: pre;">&#8288;&lt;&lt;-&#8288;</code>, <code style="white-space: pre;">&#8288;-&gt;&#8288;</code>, <code style="white-space: pre;">&#8288;-&gt;&gt;&#8288;</code>,
<code>=</code>, <code>/</code>, <code>*</code>, and any infix operator (exclude infixes by passing <code>"%%"</code>). Note that <code>"="</code> here includes
three different operators, from the parser's point of view. To lint only some of these, pass the
corresponding parse tags (i.e., some of <code>"EQ_ASSIGN"</code>, <code>"EQ_SUB"</code>, and <code>"EQ_FORMALS"</code>; see
<code><a href="utils.html#topic+getParseData">utils::getParseData()</a></code>).</p>
</td></tr>
<tr><td><code id="infix_spaces_linter_+3A_allow_multiple_spaces">allow_multiple_spaces</code></td>
<td>
<p>Logical, default <code>TRUE</code>. If <code>FALSE</code>, usage like <code>x  =  2</code> will also be linted;
excluded by default because such usage can sometimes be used for better code alignment, as is allowed
by the style guide.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#infix-operators">https://style.tidyverse.org/syntax.html#infix-operators</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x&lt;-1L",
  linters = infix_spaces_linter()
)

lint(
  text = "1:4 %&gt;%sum()",
  linters = infix_spaces_linter()
)

# okay
lint(
  text = "x &lt;- 1L",
  linters = infix_spaces_linter()
)

lint(
  text = "1:4 %&gt;% sum()",
  linters = infix_spaces_linter()
)

code_lines &lt;- "
ab     &lt;- 1L
abcdef &lt;- 2L
"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = infix_spaces_linter(allow_multiple_spaces = TRUE)
)

lint(
  text = "a||b",
  linters = infix_spaces_linter(exclude_operators = "||")
)

lint(
  text = "sum(1:10, na.rm=TRUE)",
  linters = infix_spaces_linter(exclude_operators = "EQ_SUB")
)

</code></pre>

<hr>
<h2 id='inner_combine_linter'>Require <code>c()</code> to be applied before relatively expensive vectorized functions</h2><span id='topic+inner_combine_linter'></span>

<h3>Description</h3>

<p><code>as.Date(c(a, b))</code> is logically equivalent to <code>c(as.Date(a), as.Date(b))</code>.
The same equivalence holds for several other vectorized functions like
<code><a href="base.html#topic+as.POSIXct">as.POSIXct()</a></code> and math functions like <code><a href="base.html#topic+sin">sin()</a></code>. The former is to be
preferred so that the most expensive part of the operation (<code><a href="base.html#topic+as.Date">as.Date()</a></code>)
is applied only once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_combine_linter()
</code></pre>


<h3>Details</h3>

<p>Note that <code><a href="base.html#topic+strptime">strptime()</a></code> has one idiosyncrasy to be aware of, namely that
auto-detected <code style="white-space: pre;">&#8288;format=&#8288;</code> is set by the first matching input, which means
that a case like <code>c(as.POSIXct("2024-01-01"), as.POSIXct("2024-01-01 01:02:03"))</code>
gives different results to <code>as.POSIXct(c("2024-01-01", "2024-01-01 01:02:03"))</code>.
This false positive is rare; a workaround where possible is to use
consistent formatting, i.e., <code>"2024-01-01 00:00:00"</code> in the example.
</p>


<h3>Tags</h3>

<p><a href="#topic+consistency_linters">consistency</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "c(log10(x), log10(y), log10(z))",
  linters = inner_combine_linter()
)

# okay
lint(
  text = "log10(c(x, y, z))",
  linters = inner_combine_linter()
)

lint(
  text = "c(log(x, base = 10), log10(x, base = 2))",
  linters = inner_combine_linter()
)

</code></pre>

<hr>
<h2 id='is_lint_level'>Is this an expression- or a file-level source object?</h2><span id='topic+is_lint_level'></span>

<h3>Description</h3>

<p>Helper for determining whether the current <code>source_expression</code> contains
all expressions in the current file, or just a single expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_lint_level(source_expression, level = c("expression", "file"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_lint_level_+3A_source_expression">source_expression</code></td>
<td>
<p>A parsed expression object, i.e., an element
of the object returned by <code><a href="#topic+get_source_expressions">get_source_expressions()</a></code>.</p>
</td></tr>
<tr><td><code id="is_lint_level_+3A_level">level</code></td>
<td>
<p>Which level of expression is being tested? <code>"expression"</code>
means an individual expression, while <code>"file"</code> means all expressions
in the current file are available.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
writeLines(c("x &lt;- 1", "y &lt;- x + 1"), tmp)
source_exprs &lt;- get_source_expressions(tmp)
is_lint_level(source_exprs$expressions[[1L]], level = "expression")
is_lint_level(source_exprs$expressions[[1L]], level = "file")
is_lint_level(source_exprs$expressions[[3L]], level = "expression")
is_lint_level(source_exprs$expressions[[3L]], level = "file")
unlink(tmp)

</code></pre>

<hr>
<h2 id='is_numeric_linter'>Redirect <code>is.numeric(x) || is.integer(x)</code> to just use <code>is.numeric(x)</code></h2><span id='topic+is_numeric_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+is.numeric">is.numeric()</a></code> returns <code>TRUE</code> when <code>typeof(x)</code> is <code>double</code> or <code>integer</code> &ndash;
testing <code>is.numeric(x) || is.integer(x)</code> is thus redundant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_numeric_linter()
</code></pre>


<h3>Details</h3>

<p>NB: This linter plays well with <code><a href="#topic+class_equals_linter">class_equals_linter()</a></code>, which can help
avoid further <code>is.numeric()</code> equivalents like
<code>any(class(x) == c("numeric", "integer"))</code>.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "is.numeric(y) || is.integer(y)",
  linters = is_numeric_linter()
)

lint(
  text = 'class(z) %in% c("numeric", "integer")',
  linters = is_numeric_linter()
)

# okay
lint(
  text = "is.numeric(y) || is.factor(y)",
  linters = is_numeric_linter()
)

lint(
  text = 'class(z) %in% c("numeric", "integer", "factor")',
  linters = is_numeric_linter()
)

</code></pre>

<hr>
<h2 id='keyword_quote_linter'>Block unnecessary quoting in calls</h2><span id='topic+keyword_quote_linter'></span>

<h3>Description</h3>

<p>Any valid symbol can be used as a keyword argument to an R function call.
Sometimes, it is necessary to quote (or backtick) an argument that is
not an otherwise valid symbol (e.g. creating a vector whose names have
spaces); besides this edge case, quoting should not be done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyword_quote_linter()
</code></pre>


<h3>Details</h3>

<p>The most common source of violation for this is creating named vectors,
lists, or data.frame-alikes, but it can be observed in other calls as well.
</p>
<p>Similar reasoning applies to extractions with <code>$</code> or <code>@</code>.
</p>


<h3>Tags</h3>

<p><a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'data.frame("a" = 1)',
  linters = keyword_quote_linter()
)

lint(
  text = "data.frame(`a` = 1)",
  linters = keyword_quote_linter()
)

lint(
  text = 'my_list$"key"',
  linters = keyword_quote_linter()
)

lint(
  text = 's4obj@"key"',
  linters = keyword_quote_linter()
)

# okay
lint(
  text = "data.frame(`a b` = 1)",
  linters = keyword_quote_linter()
)

lint(
  text = "my_list$`a b`",
  linters = keyword_quote_linter()
)

</code></pre>

<hr>
<h2 id='length_levels_linter'>Require usage of nlevels over length(levels(.))</h2><span id='topic+length_levels_linter'></span>

<h3>Description</h3>

<p><code>length(levels(x))</code> is the same as <code>nlevels(x)</code>, but harder to read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>length_levels_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "length(levels(x))",
  linters = length_levels_linter()
)

# okay
lint(
  text = "length(c(levels(x), levels(y)))",
  linters = length_levels_linter()
)

</code></pre>

<hr>
<h2 id='length_test_linter'>Check for a common mistake where length is applied in the wrong place</h2><span id='topic+length_test_linter'></span>

<h3>Description</h3>

<p>Usage like <code>length(x == 0)</code> is a mistake. If you intended to check <code>x</code> is empty,
use <code>length(x) == 0</code>. Other mistakes are possible, but running <code>length()</code> on the
outcome of a logical comparison is never the best choice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>length_test_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "length(x == 0)",
  linters = length_test_linter()
)

# okay
lint(
  text = "length(x) &gt; 0",
  linters = length_test_linter()
)
</code></pre>

<hr>
<h2 id='lengths_linter'>Require usage of <code>lengths()</code> where possible</h2><span id='topic+lengths_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+lengths">lengths()</a></code> is a function that was added to base R in version 3.2.0 to
get the length of each element of a list. It is equivalent to
<code>sapply(x, length)</code>, but faster and more readable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lengths_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "sapply(x, length)",
  linters = lengths_linter()
)

lint(
  text = "vapply(x, length, integer(1L))",
  linters = lengths_linter()
)

lint(
  text = "purrr::map_int(x, length)",
  linters = lengths_linter()
)

# okay
lint(
  text = "lengths(x)",
  linters = lengths_linter()
)

</code></pre>

<hr>
<h2 id='library_call_linter'>Library call linter</h2><span id='topic+library_call_linter'></span>

<h3>Description</h3>

<p>This linter covers several rules related to <code><a href="base.html#topic+library">library()</a></code> calls:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>library_call_linter(allow_preamble = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="library_call_linter_+3A_allow_preamble">allow_preamble</code></td>
<td>
<p>Logical, default <code>TRUE</code>. If <code>FALSE</code>,
no code is allowed to precede the first <code>library()</code> call,
otherwise some setup code is allowed, but all <code>library()</code>
calls must follow consecutively after the first one.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Enforce such calls to all be at the top of the script.
</p>
</li>
<li><p> Block usage of argument <code>character.only</code>, in particular
for loading packages in a loop.
</p>
</li>
<li><p> Block consecutive calls to <code>suppressMessages(library(.))</code>
in favor of using <code><a href="base.html#topic+suppressMessages">suppressMessages()</a></code> only once to suppress
messages from all <code>library()</code> calls. Ditto <code><a href="base.html#topic+suppressPackageStartupMessages">suppressPackageStartupMessages()</a></code>.
</p>
</li></ul>



<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints

code &lt;- "library(dplyr)\nprint('test')\nlibrary(tidyr)"
writeLines(code)
lint(
  text = code,
  linters = library_call_linter()
)

lint(
  text = "library('dplyr', character.only = TRUE)",
  linters = library_call_linter()
)

code &lt;- paste(
  "pkg &lt;- c('dplyr', 'tibble')",
  "sapply(pkg, library, character.only = TRUE)",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = library_call_linter()
)

code &lt;- "suppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))"
writeLines(code)
lint(
  text = code,
  linters = library_call_linter()
)

# okay
code &lt;- "library(dplyr)\nprint('test')"
writeLines(code)
lint(
  text = code,
  linters = library_call_linter()
)

code &lt;- "# comment\nlibrary(dplyr)"
lint(
  text = code,
  linters = library_call_linter()
)

code &lt;- paste(
  "foo &lt;- function(pkg) {",
  "  sapply(pkg, library, character.only = TRUE)",
  "}",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = library_call_linter()
)

code &lt;- "suppressMessages({\n  library(dplyr)\n  library(tidyr)\n})"
writeLines(code)
lint(
  text = code,
  linters = library_call_linter()
)

</code></pre>

<hr>
<h2 id='line_length_linter'>Line length linter</h2><span id='topic+line_length_linter'></span>

<h3>Description</h3>

<p>Check that the line length of both comments and code is less than <code>length</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_length_linter(length = 80L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="line_length_linter_+3A_length">length</code></td>
<td>
<p>maximum line length allowed. Default is 80L (Hollerith limit).</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#long-lines">https://style.tidyverse.org/syntax.html#long-lines</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = strrep("x", 23L),
  linters = line_length_linter(length = 20L)
)

# okay
lint(
  text = strrep("x", 21L),
  linters = line_length_linter(length = 40L)
)

</code></pre>

<hr>
<h2 id='lint'>Lint a file, directory, or package</h2><span id='topic+lint'></span><span id='topic+lint_dir'></span><span id='topic+lint_package'></span>

<h3>Description</h3>


<ul>
<li> <p><code>lint()</code> lints a single file.
</p>
</li>
<li> <p><code>lint_dir()</code> lints all files in a directory.
</p>
</li>
<li> <p><code>lint_package()</code> lints all likely locations for R files in a package, i.e.
<code style="white-space: pre;">&#8288;R/&#8288;</code>, <code style="white-space: pre;">&#8288;tests/&#8288;</code>, <code style="white-space: pre;">&#8288;inst/&#8288;</code>, <code style="white-space: pre;">&#8288;vignettes/&#8288;</code>, <code style="white-space: pre;">&#8288;data-raw/&#8288;</code>, <code style="white-space: pre;">&#8288;demo/&#8288;</code>, and <code style="white-space: pre;">&#8288;exec/&#8288;</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>lint(
  filename,
  linters = NULL,
  ...,
  cache = FALSE,
  parse_settings = TRUE,
  text = NULL
)

lint_dir(
  path = ".",
  ...,
  relative_path = TRUE,
  exclusions = list("renv", "packrat"),
  pattern = "(?i)[.](r|rmd|qmd|rnw|rhtml|rrst|rtex|rtxt)$",
  parse_settings = TRUE,
  show_progress = NULL
)

lint_package(
  path = ".",
  ...,
  relative_path = TRUE,
  exclusions = list("R/RcppExports.R"),
  parse_settings = TRUE,
  show_progress = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lint_+3A_filename">filename</code></td>
<td>
<p>Either the filename for a file to lint, or a character string of inline R code for linting.
The latter (inline data) applies whenever <code>filename</code> has a newline character (\n).</p>
</td></tr>
<tr><td><code id="lint_+3A_linters">linters</code></td>
<td>
<p>A named list of linter functions to apply. See <a href="#topic+linters">linters</a> for a full list of default and available
linters.</p>
</td></tr>
<tr><td><code id="lint_+3A_...">...</code></td>
<td>
<p>Provide additional arguments to be passed to:
</p>

<ul>
<li> <p><code><a href="#topic+exclude">exclude()</a></code> (in case of <code>lint()</code>; e.g. <code>lints</code> or <code>exclusions</code>)
</p>
</li>
<li> <p><code><a href="#topic+lint">lint()</a></code> (in case of <code>lint_dir()</code> and <code>lint_package()</code>; e.g. <code>linters</code> or <code>cache</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="lint_+3A_cache">cache</code></td>
<td>
<p>When logical, toggle caching of lint results. If passed a character string, store the cache in this
directory.</p>
</td></tr>
<tr><td><code id="lint_+3A_parse_settings">parse_settings</code></td>
<td>
<p>Logical, default <code>TRUE</code>. Whether to try and parse the <a href="#topic+read_settings">settings</a>. Otherwise,
the <code><a href="#topic+default_settings">default_settings()</a></code> are used.</p>
</td></tr>
<tr><td><code id="lint_+3A_text">text</code></td>
<td>
<p>Optional argument for supplying a string or lines directly, e.g. if the file is already in memory or
linting is being done ad hoc.</p>
</td></tr>
<tr><td><code id="lint_+3A_path">path</code></td>
<td>
<p>For the base directory of the project (for <code>lint_dir()</code>) or
package (for <code>lint_package()</code>).</p>
</td></tr>
<tr><td><code id="lint_+3A_relative_path">relative_path</code></td>
<td>
<p>if <code>TRUE</code>, file paths are printed using their path relative to the base directory.
If <code>FALSE</code>, use the full absolute path.</p>
</td></tr>
<tr><td><code id="lint_+3A_exclusions">exclusions</code></td>
<td>
<p>exclusions for <code><a href="#topic+exclude">exclude()</a></code>, relative to the package path.</p>
</td></tr>
<tr><td><code id="lint_+3A_pattern">pattern</code></td>
<td>
<p>pattern for files, by default it will take files with any of the extensions
.R, .Rmd, .qmd, .Rnw, .Rhtml, .Rrst, .Rtex, .Rtxt allowing for lowercase r (.r, ...).</p>
</td></tr>
<tr><td><code id="lint_+3A_show_progress">show_progress</code></td>
<td>
<p>Logical controlling whether to show linting progress with a simple text
progress bar <em>via</em> <code><a href="utils.html#topic+txtProgressBar">utils::txtProgressBar()</a></code>. The default behavior is to show progress in
<code><a href="base.html#topic+interactive">interactive()</a></code> sessions not running a testthat suite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read <code>vignette("lintr")</code> to learn how to configure which linters are run
by default.
Note that if files contain unparseable encoding problems, only the encoding problem will be linted to avoid
unintelligible error messages from other linters.
</p>


<h3>Value</h3>

<p>An object of class <code>c("lints", "list")</code>, each element of which is a <code>"list"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># linting inline-code
lint("a = 123\n")
lint(text = "a = 123")

# linting a file
f &lt;- tempfile()
writeLines("a=1", f)
lint(f)
unlink(f)

if (FALSE) {
  lint_dir()

  lint_dir(
    linters = list(semicolon_linter()),
    exclusions = list(
      "inst/doc/creating_linters.R" = 1,
      "inst/example/bad.R",
      "renv"
    )
  )
}
if (FALSE) {
  lint_package()

  lint_package(
    linters = linters_with_defaults(semicolon_linter = semicolon_linter()),
    exclusions = list("inst/doc/creating_linters.R" = 1, "inst/example/bad.R")
  )
}
</code></pre>

<hr>
<h2 id='lint-s3'>Create a <code>lint</code> object</h2><span id='topic+lint-s3'></span><span id='topic+Lint'></span>

<h3>Description</h3>

<p>Create a <code>lint</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lint(
  filename,
  line_number = 1L,
  column_number = 1L,
  type = c("style", "warning", "error"),
  message = "",
  line = "",
  ranges = NULL,
  linter = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lint-s3_+3A_filename">filename</code></td>
<td>
<p>path to the source file that was linted.</p>
</td></tr>
<tr><td><code id="lint-s3_+3A_line_number">line_number</code></td>
<td>
<p>line number where the lint occurred.</p>
</td></tr>
<tr><td><code id="lint-s3_+3A_column_number">column_number</code></td>
<td>
<p>column number where the lint occurred.</p>
</td></tr>
<tr><td><code id="lint-s3_+3A_type">type</code></td>
<td>
<p>type of lint.</p>
</td></tr>
<tr><td><code id="lint-s3_+3A_message">message</code></td>
<td>
<p>message used to describe the lint error</p>
</td></tr>
<tr><td><code id="lint-s3_+3A_line">line</code></td>
<td>
<p>code source where the lint occurred</p>
</td></tr>
<tr><td><code id="lint-s3_+3A_ranges">ranges</code></td>
<td>
<p>a list of ranges on the line that should be emphasized.</p>
</td></tr>
<tr><td><code id="lint-s3_+3A_linter">linter</code></td>
<td>
<p>deprecated. No longer used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>c("lint", "list")</code>.
</p>

<hr>
<h2 id='Linter'>Create a <code>linter</code> closure</h2><span id='topic+Linter'></span>

<h3>Description</h3>

<p>Create a <code>linter</code> closure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Linter(
  fun,
  name = linter_auto_name(),
  linter_level = c(NA_character_, "file", "expression")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Linter_+3A_fun">fun</code></td>
<td>
<p>A function that takes a source file and returns <code>lint</code> objects.</p>
</td></tr>
<tr><td><code id="Linter_+3A_name">name</code></td>
<td>
<p>Default name of the Linter.
Lints produced by the linter will be labelled with <code>name</code> by default.</p>
</td></tr>
<tr><td><code id="Linter_+3A_linter_level">linter_level</code></td>
<td>
<p>Which level of expression is the linter working with?
<code>"expression"</code> means an individual expression in <code>xml_parsed_content</code>, while <code>"file"</code> means all expressions
in the current file are available in <code>full_xml_parsed_content</code>.
<code>NA</code> means the linter will be run with both, expression-level and file-level source expressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same function with its class set to 'linter'.
</p>

<hr>
<h2 id='linters'>Available linters</h2><span id='topic+linters'></span>

<h3>Description</h3>

<p>A variety of linters are available in <span class="pkg">lintr</span>. The most popular ones are readily
accessible through <code><a href="#topic+default_linters">default_linters()</a></code>.
</p>
<p>Within a <code><a href="#topic+lint">lint()</a></code> function call, the linters in use are initialized with the provided
arguments and fed with the source file (provided by <code><a href="#topic+get_source_expressions">get_source_expressions()</a></code>).
</p>
<p>A data frame of all available linters can be retrieved using <code><a href="#topic+available_linters">available_linters()</a></code>.
Documentation for linters is structured into tags to allow for easier discovery;
see also <code><a href="#topic+available_tags">available_tags()</a></code>.
</p>


<h3>Tags</h3>

<p>The following tags exist:
</p>

<ul>
<li><p><a href="#topic+best_practices_linters">best_practices</a> (63 linters)
</p>
</li>
<li><p><a href="#topic+common_mistakes_linters">common_mistakes</a> (11 linters)
</p>
</li>
<li><p><a href="#topic+configurable_linters">configurable</a> (44 linters)
</p>
</li>
<li><p><a href="#topic+consistency_linters">consistency</a> (32 linters)
</p>
</li>
<li><p><a href="#topic+correctness_linters">correctness</a> (7 linters)
</p>
</li>
<li><p><a href="#topic+default_linters">default</a> (25 linters)
</p>
</li>
<li><p><a href="#topic+deprecated_linters">deprecated</a> (6 linters)
</p>
</li>
<li><p><a href="#topic+efficiency_linters">efficiency</a> (29 linters)
</p>
</li>
<li><p><a href="#topic+executing_linters">executing</a> (6 linters)
</p>
</li>
<li><p><a href="#topic+package_development_linters">package_development</a> (14 linters)
</p>
</li>
<li><p><a href="#topic+pkg_testthat_linters">pkg_testthat</a> (12 linters)
</p>
</li>
<li><p><a href="#topic+readability_linters">readability</a> (64 linters)
</p>
</li>
<li><p><a href="#topic+regex_linters">regex</a> (4 linters)
</p>
</li>
<li><p><a href="#topic+robustness_linters">robustness</a> (17 linters)
</p>
</li>
<li><p><a href="#topic+style_linters">style</a> (40 linters)
</p>
</li>
<li><p><a href="#topic+tidy_design_linters">tidy_design</a> (1 linters)
</p>
</li></ul>



<h3>Linters</h3>

<p>The following linters exist:
</p>

<ul>
<li><p><code><a href="#topic+absolute_path_linter">absolute_path_linter</a></code> (tags: best_practices, configurable, robustness)
</p>
</li>
<li><p><code><a href="#topic+any_duplicated_linter">any_duplicated_linter</a></code> (tags: best_practices, efficiency)
</p>
</li>
<li><p><code><a href="#topic+any_is_na_linter">any_is_na_linter</a></code> (tags: best_practices, efficiency)
</p>
</li>
<li><p><code><a href="#topic+assignment_linter">assignment_linter</a></code> (tags: configurable, consistency, default, style)
</p>
</li>
<li><p><code><a href="#topic+backport_linter">backport_linter</a></code> (tags: configurable, package_development, robustness)
</p>
</li>
<li><p><code><a href="#topic+boolean_arithmetic_linter">boolean_arithmetic_linter</a></code> (tags: best_practices, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+brace_linter">brace_linter</a></code> (tags: configurable, default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+class_equals_linter">class_equals_linter</a></code> (tags: best_practices, consistency, robustness)
</p>
</li>
<li><p><code><a href="#topic+commas_linter">commas_linter</a></code> (tags: configurable, default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+commented_code_linter">commented_code_linter</a></code> (tags: best_practices, default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+comparison_negation_linter">comparison_negation_linter</a></code> (tags: consistency, readability)
</p>
</li>
<li><p><code><a href="#topic+condition_call_linter">condition_call_linter</a></code> (tags: best_practices, configurable, style, tidy_design)
</p>
</li>
<li><p><code><a href="#topic+condition_message_linter">condition_message_linter</a></code> (tags: best_practices, consistency)
</p>
</li>
<li><p><code><a href="#topic+conjunct_test_linter">conjunct_test_linter</a></code> (tags: best_practices, configurable, package_development, pkg_testthat, readability)
</p>
</li>
<li><p><code><a href="#topic+consecutive_assertion_linter">consecutive_assertion_linter</a></code> (tags: consistency, readability, style)
</p>
</li>
<li><p><code><a href="#topic+consecutive_mutate_linter">consecutive_mutate_linter</a></code> (tags: configurable, consistency, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+cyclocomp_linter">cyclocomp_linter</a></code> (tags: best_practices, configurable, readability, style)
</p>
</li>
<li><p><code><a href="#topic+duplicate_argument_linter">duplicate_argument_linter</a></code> (tags: common_mistakes, configurable, correctness)
</p>
</li>
<li><p><code><a href="#topic+empty_assignment_linter">empty_assignment_linter</a></code> (tags: best_practices, readability)
</p>
</li>
<li><p><code><a href="#topic+equals_na_linter">equals_na_linter</a></code> (tags: common_mistakes, correctness, default, robustness)
</p>
</li>
<li><p><code><a href="#topic+expect_comparison_linter">expect_comparison_linter</a></code> (tags: best_practices, package_development, pkg_testthat)
</p>
</li>
<li><p><code><a href="#topic+expect_identical_linter">expect_identical_linter</a></code> (tags: package_development, pkg_testthat)
</p>
</li>
<li><p><code><a href="#topic+expect_length_linter">expect_length_linter</a></code> (tags: best_practices, package_development, pkg_testthat, readability)
</p>
</li>
<li><p><code><a href="#topic+expect_named_linter">expect_named_linter</a></code> (tags: best_practices, package_development, pkg_testthat, readability)
</p>
</li>
<li><p><code><a href="#topic+expect_not_linter">expect_not_linter</a></code> (tags: best_practices, package_development, pkg_testthat, readability)
</p>
</li>
<li><p><code><a href="#topic+expect_null_linter">expect_null_linter</a></code> (tags: best_practices, package_development, pkg_testthat)
</p>
</li>
<li><p><code><a href="#topic+expect_s3_class_linter">expect_s3_class_linter</a></code> (tags: best_practices, package_development, pkg_testthat)
</p>
</li>
<li><p><code><a href="#topic+expect_s4_class_linter">expect_s4_class_linter</a></code> (tags: best_practices, package_development, pkg_testthat)
</p>
</li>
<li><p><code><a href="#topic+expect_true_false_linter">expect_true_false_linter</a></code> (tags: best_practices, package_development, pkg_testthat, readability)
</p>
</li>
<li><p><code><a href="#topic+expect_type_linter">expect_type_linter</a></code> (tags: best_practices, package_development, pkg_testthat)
</p>
</li>
<li><p><code><a href="#topic+fixed_regex_linter">fixed_regex_linter</a></code> (tags: best_practices, configurable, efficiency, readability, regex)
</p>
</li>
<li><p><code><a href="#topic+for_loop_index_linter">for_loop_index_linter</a></code> (tags: best_practices, readability, robustness)
</p>
</li>
<li><p><code><a href="#topic+function_argument_linter">function_argument_linter</a></code> (tags: best_practices, consistency, style)
</p>
</li>
<li><p><code><a href="#topic+function_left_parentheses_linter">function_left_parentheses_linter</a></code> (tags: default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+function_return_linter">function_return_linter</a></code> (tags: best_practices, readability)
</p>
</li>
<li><p><code><a href="#topic+if_not_else_linter">if_not_else_linter</a></code> (tags: configurable, consistency, readability)
</p>
</li>
<li><p><code><a href="#topic+if_switch_linter">if_switch_linter</a></code> (tags: best_practices, configurable, consistency, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+ifelse_censor_linter">ifelse_censor_linter</a></code> (tags: best_practices, efficiency)
</p>
</li>
<li><p><code><a href="#topic+implicit_assignment_linter">implicit_assignment_linter</a></code> (tags: best_practices, configurable, readability, style)
</p>
</li>
<li><p><code><a href="#topic+implicit_integer_linter">implicit_integer_linter</a></code> (tags: best_practices, configurable, consistency, style)
</p>
</li>
<li><p><code><a href="#topic+indentation_linter">indentation_linter</a></code> (tags: configurable, default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+infix_spaces_linter">infix_spaces_linter</a></code> (tags: configurable, default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+inner_combine_linter">inner_combine_linter</a></code> (tags: consistency, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+is_numeric_linter">is_numeric_linter</a></code> (tags: best_practices, consistency, readability)
</p>
</li>
<li><p><code><a href="#topic+keyword_quote_linter">keyword_quote_linter</a></code> (tags: consistency, readability, style)
</p>
</li>
<li><p><code><a href="#topic+length_levels_linter">length_levels_linter</a></code> (tags: best_practices, consistency, readability)
</p>
</li>
<li><p><code><a href="#topic+length_test_linter">length_test_linter</a></code> (tags: common_mistakes, efficiency)
</p>
</li>
<li><p><code><a href="#topic+lengths_linter">lengths_linter</a></code> (tags: best_practices, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+library_call_linter">library_call_linter</a></code> (tags: best_practices, configurable, readability, style)
</p>
</li>
<li><p><code><a href="#topic+line_length_linter">line_length_linter</a></code> (tags: configurable, default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+list_comparison_linter">list_comparison_linter</a></code> (tags: best_practices, common_mistakes)
</p>
</li>
<li><p><code><a href="#topic+literal_coercion_linter">literal_coercion_linter</a></code> (tags: best_practices, consistency, efficiency)
</p>
</li>
<li><p><code><a href="#topic+matrix_apply_linter">matrix_apply_linter</a></code> (tags: efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+missing_argument_linter">missing_argument_linter</a></code> (tags: common_mistakes, configurable, correctness)
</p>
</li>
<li><p><code><a href="#topic+missing_package_linter">missing_package_linter</a></code> (tags: common_mistakes, robustness)
</p>
</li>
<li><p><code><a href="#topic+namespace_linter">namespace_linter</a></code> (tags: configurable, correctness, executing, robustness)
</p>
</li>
<li><p><code><a href="#topic+nested_ifelse_linter">nested_ifelse_linter</a></code> (tags: efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+nested_pipe_linter">nested_pipe_linter</a></code> (tags: configurable, consistency, readability)
</p>
</li>
<li><p><code><a href="#topic+nonportable_path_linter">nonportable_path_linter</a></code> (tags: best_practices, configurable, robustness)
</p>
</li>
<li><p><code><a href="#topic+nrow_subset_linter">nrow_subset_linter</a></code> (tags: best_practices, consistency, efficiency)
</p>
</li>
<li><p><code><a href="#topic+numeric_leading_zero_linter">numeric_leading_zero_linter</a></code> (tags: consistency, readability, style)
</p>
</li>
<li><p><code><a href="#topic+nzchar_linter">nzchar_linter</a></code> (tags: best_practices, consistency, efficiency)
</p>
</li>
<li><p><code><a href="#topic+object_length_linter">object_length_linter</a></code> (tags: configurable, default, executing, readability, style)
</p>
</li>
<li><p><code><a href="#topic+object_name_linter">object_name_linter</a></code> (tags: configurable, consistency, default, executing, style)
</p>
</li>
<li><p><code><a href="#topic+object_overwrite_linter">object_overwrite_linter</a></code> (tags: best_practices, configurable, executing, readability, robustness)
</p>
</li>
<li><p><code><a href="#topic+object_usage_linter">object_usage_linter</a></code> (tags: configurable, correctness, default, executing, readability, style)
</p>
</li>
<li><p><code><a href="#topic+one_call_pipe_linter">one_call_pipe_linter</a></code> (tags: readability, style)
</p>
</li>
<li><p><code><a href="#topic+outer_negation_linter">outer_negation_linter</a></code> (tags: best_practices, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+package_hooks_linter">package_hooks_linter</a></code> (tags: correctness, package_development, style)
</p>
</li>
<li><p><code><a href="#topic+paren_body_linter">paren_body_linter</a></code> (tags: default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+paste_linter">paste_linter</a></code> (tags: best_practices, configurable, consistency)
</p>
</li>
<li><p><code><a href="#topic+pipe_call_linter">pipe_call_linter</a></code> (tags: readability, style)
</p>
</li>
<li><p><code><a href="#topic+pipe_consistency_linter">pipe_consistency_linter</a></code> (tags: configurable, readability, style)
</p>
</li>
<li><p><code><a href="#topic+pipe_continuation_linter">pipe_continuation_linter</a></code> (tags: default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+pipe_return_linter">pipe_return_linter</a></code> (tags: best_practices, common_mistakes)
</p>
</li>
<li><p><code><a href="#topic+print_linter">print_linter</a></code> (tags: best_practices, consistency)
</p>
</li>
<li><p><code><a href="#topic+quotes_linter">quotes_linter</a></code> (tags: configurable, consistency, default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+redundant_equals_linter">redundant_equals_linter</a></code> (tags: best_practices, common_mistakes, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+redundant_ifelse_linter">redundant_ifelse_linter</a></code> (tags: best_practices, configurable, consistency, efficiency)
</p>
</li>
<li><p><code><a href="#topic+regex_subset_linter">regex_subset_linter</a></code> (tags: best_practices, efficiency, regex)
</p>
</li>
<li><p><code><a href="#topic+rep_len_linter">rep_len_linter</a></code> (tags: best_practices, consistency, readability)
</p>
</li>
<li><p><code><a href="#topic+repeat_linter">repeat_linter</a></code> (tags: readability, style)
</p>
</li>
<li><p><code><a href="#topic+return_linter">return_linter</a></code> (tags: configurable, default, style)
</p>
</li>
<li><p><code><a href="#topic+routine_registration_linter">routine_registration_linter</a></code> (tags: best_practices, efficiency, robustness)
</p>
</li>
<li><p><code><a href="#topic+sample_int_linter">sample_int_linter</a></code> (tags: efficiency, readability, robustness)
</p>
</li>
<li><p><code><a href="#topic+scalar_in_linter">scalar_in_linter</a></code> (tags: best_practices, configurable, consistency, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+semicolon_linter">semicolon_linter</a></code> (tags: configurable, default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+seq_linter">seq_linter</a></code> (tags: best_practices, consistency, default, efficiency, robustness)
</p>
</li>
<li><p><code><a href="#topic+sort_linter">sort_linter</a></code> (tags: best_practices, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+spaces_inside_linter">spaces_inside_linter</a></code> (tags: default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+spaces_left_parentheses_linter">spaces_left_parentheses_linter</a></code> (tags: default, readability, style)
</p>
</li>
<li><p><code><a href="#topic+sprintf_linter">sprintf_linter</a></code> (tags: common_mistakes, correctness)
</p>
</li>
<li><p><code><a href="#topic+stopifnot_all_linter">stopifnot_all_linter</a></code> (tags: best_practices, readability)
</p>
</li>
<li><p><code><a href="#topic+string_boundary_linter">string_boundary_linter</a></code> (tags: configurable, efficiency, readability, regex)
</p>
</li>
<li><p><code><a href="#topic+strings_as_factors_linter">strings_as_factors_linter</a></code> (tags: robustness)
</p>
</li>
<li><p><code><a href="#topic+system_file_linter">system_file_linter</a></code> (tags: best_practices, consistency, readability)
</p>
</li>
<li><p><code><a href="#topic+T_and_F_symbol_linter">T_and_F_symbol_linter</a></code> (tags: best_practices, consistency, default, readability, robustness, style)
</p>
</li>
<li><p><code><a href="#topic+terminal_close_linter">terminal_close_linter</a></code> (tags: best_practices, robustness)
</p>
</li>
<li><p><code><a href="#topic+todo_comment_linter">todo_comment_linter</a></code> (tags: configurable, style)
</p>
</li>
<li><p><code><a href="#topic+trailing_blank_lines_linter">trailing_blank_lines_linter</a></code> (tags: default, style)
</p>
</li>
<li><p><code><a href="#topic+trailing_whitespace_linter">trailing_whitespace_linter</a></code> (tags: configurable, default, style)
</p>
</li>
<li><p><code><a href="#topic+undesirable_function_linter">undesirable_function_linter</a></code> (tags: best_practices, configurable, robustness, style)
</p>
</li>
<li><p><code><a href="#topic+undesirable_operator_linter">undesirable_operator_linter</a></code> (tags: best_practices, configurable, robustness, style)
</p>
</li>
<li><p><code><a href="#topic+unnecessary_concatenation_linter">unnecessary_concatenation_linter</a></code> (tags: configurable, efficiency, readability, style)
</p>
</li>
<li><p><code><a href="#topic+unnecessary_lambda_linter">unnecessary_lambda_linter</a></code> (tags: best_practices, configurable, efficiency, readability)
</p>
</li>
<li><p><code><a href="#topic+unnecessary_nesting_linter">unnecessary_nesting_linter</a></code> (tags: best_practices, configurable, consistency, readability)
</p>
</li>
<li><p><code><a href="#topic+unnecessary_placeholder_linter">unnecessary_placeholder_linter</a></code> (tags: best_practices, readability)
</p>
</li>
<li><p><code><a href="#topic+unreachable_code_linter">unreachable_code_linter</a></code> (tags: best_practices, configurable, readability)
</p>
</li>
<li><p><code><a href="#topic+unused_import_linter">unused_import_linter</a></code> (tags: best_practices, common_mistakes, configurable, executing)
</p>
</li>
<li><p><code><a href="#topic+vector_logic_linter">vector_logic_linter</a></code> (tags: best_practices, common_mistakes, default, efficiency)
</p>
</li>
<li><p><code><a href="#topic+which_grepl_linter">which_grepl_linter</a></code> (tags: consistency, efficiency, readability, regex)
</p>
</li>
<li><p><code><a href="#topic+whitespace_linter">whitespace_linter</a></code> (tags: consistency, default, style)
</p>
</li>
<li><p><code><a href="#topic+yoda_test_linter">yoda_test_linter</a></code> (tags: best_practices, package_development, pkg_testthat, readability)
</p>
</li></ul>


<hr>
<h2 id='linters_with_defaults'>Create a linter configuration based on defaults</h2><span id='topic+linters_with_defaults'></span>

<h3>Description</h3>

<p>Make a new list based on <span class="pkg">lintr</span>'s default linters.
The result of this function is meant to be passed to the <code>linters</code> argument of <code>lint()</code>,
or to be put in your configuration file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linters_with_defaults(..., defaults = default_linters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linters_with_defaults_+3A_...">...</code></td>
<td>
<p>Arguments of elements to change. If unnamed, the argument is automatically named.
If the named argument already exists in the list of linters, it is replaced by the new element.
If it does not exist, it is added. If the value is <code>NULL</code>, the linter is removed.</p>
</td></tr>
<tr><td><code id="linters_with_defaults_+3A_defaults">defaults</code></td>
<td>
<p>Default list of linters to modify. Must be named.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters_with_tags">linters_with_tags</a> for basing off tags attached to linters, possibly across multiple packages.
</p>
</li>
<li> <p><a href="#topic+all_linters">all_linters</a> for basing off all available linters in lintr.
</p>
</li>
<li> <p><a href="#topic+available_linters">available_linters</a> to get a data frame of available linters.
</p>
</li>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># When using interactively you will usually pass the result onto `lint` or `lint_package()`
f &lt;- tempfile()
writeLines("my_slightly_long_variable_name &lt;- 2.3", f)
lint(f, linters = linters_with_defaults(line_length_linter = line_length_linter(120L)))
unlink(f)

# the default linter list with a different line length cutoff
my_linters &lt;- linters_with_defaults(line_length_linter = line_length_linter(120L))

# omit the argument name if you are just using different arguments
my_linters &lt;- linters_with_defaults(defaults = my_linters, object_name_linter("camelCase"))

# remove assignment checks (with NULL), add absolute path checks
my_linters &lt;- linters_with_defaults(
  defaults = my_linters,
  assignment_linter = NULL,
  absolute_path_linter()
)

# checking the included linters
names(my_linters)

</code></pre>

<hr>
<h2 id='linters_with_tags'>Create a tag-based linter configuration</h2><span id='topic+linters_with_tags'></span>

<h3>Description</h3>

<p>Make a new list based on all linters provided by <code>packages</code> and tagged with <code>tags</code>.
The result of this function is meant to be passed to the <code>linters</code> argument of <code>lint()</code>,
or to be put in your configuration file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linters_with_tags(tags, ..., packages = "lintr", exclude_tags = "deprecated")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linters_with_tags_+3A_tags">tags</code></td>
<td>
<p>Optional character vector of tags to search. Only linters with at least one matching tag will be
returned. If <code>tags</code> is <code>NULL</code>, all linters will be returned. See <code>available_tags("lintr")</code> to find out what
tags are already used by lintr.</p>
</td></tr>
<tr><td><code id="linters_with_tags_+3A_...">...</code></td>
<td>
<p>Arguments of elements to change. If unnamed, the argument is automatically named.
If the named argument already exists in the list of linters, it is replaced by the new element.
If it does not exist, it is added. If the value is <code>NULL</code>, the linter is removed.</p>
</td></tr>
<tr><td><code id="linters_with_tags_+3A_packages">packages</code></td>
<td>
<p>A character vector of packages to search for linters.</p>
</td></tr>
<tr><td><code id="linters_with_tags_+3A_exclude_tags">exclude_tags</code></td>
<td>
<p>Tags to exclude from the results. Linters with at least one matching tag will not be returned.
If <code>exclude_tags</code> is <code>NULL</code>, no linters will be excluded. Note that <code>tags</code> takes priority, meaning that any
tag found in both <code>tags</code> and <code>exclude_tags</code> will be included, not excluded. Note that linters with tag <code>"defunct"</code>
(which do not work and can no longer be run) cannot be queried directly. See <a href="#topic+lintr-deprecated">lintr-deprecated</a> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified list of linters.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters_with_defaults">linters_with_defaults</a> for basing off lintr's set of default linters.
</p>
</li>
<li> <p><a href="#topic+all_linters">all_linters</a> for basing off all available linters in lintr.
</p>
</li>
<li> <p><a href="#topic+available_linters">available_linters</a> to get a data frame of available linters.
</p>
</li>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `linters_with_defaults()` and `linters_with_tags("default")` are the same:
all.equal(linters_with_defaults(), linters_with_tags("default"))

# Get all linters useful for package development
linters &lt;- linters_with_tags(tags = c("package_development", "style"))
names(linters)

# Get all linters tagged as "default" from lintr and mypkg
if (FALSE) {
  linters_with_tags("default", packages = c("lintr", "mypkg"))
}
</code></pre>

<hr>
<h2 id='lintr-deprecated'>Deprecated functions in lintr</h2><span id='topic+lintr-deprecated'></span><span id='topic+closed_curly_linter'></span><span id='topic+open_curly_linter'></span><span id='topic+paren_brace_linter'></span><span id='topic+semicolon_terminator_linter'></span><span id='topic+unneeded_concatenation_linter'></span><span id='topic+single_quotes_linter'></span><span id='topic+consecutive_stopifnot_linter'></span><span id='topic+no_tab_linter'></span><span id='topic+extraction_operator_linter'></span><span id='topic+unnecessary_nested_if_linter'></span><span id='topic+with_defaults'></span>

<h3>Description</h3>

<p>These functions have been deprecated from lintr.
</p>

<ul>
<li> <p><code>open_curly_linter()</code> (use <code><a href="#topic+brace_linter">brace_linter()</a></code>)
</p>
</li>
<li> <p><code>closed_curly_linter()</code> (use <code>brace_linter()</code>)
</p>
</li>
<li> <p><code>paren_brace_linter()</code> (use <code>brace_linter()</code>)
</p>
</li>
<li> <p><code>semicolon_terminator_linter()</code> (use <code><a href="#topic+semicolon_linter">semicolon_linter()</a></code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>closed_curly_linter(allow_single_line = FALSE)

open_curly_linter(allow_single_line = FALSE)

paren_brace_linter()

semicolon_terminator_linter(semicolon = c("compound", "trailing"))

unneeded_concatenation_linter(allow_single_expression = TRUE)

single_quotes_linter()

consecutive_stopifnot_linter()

no_tab_linter()

extraction_operator_linter()

unnecessary_nested_if_linter()

with_defaults(..., default = default_linters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lintr-deprecated_+3A_allow_single_line">allow_single_line</code>, <code id="lintr-deprecated_+3A_semicolon">semicolon</code></td>
<td>
<p>Irrelevant parameters to defunct linters.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+consistency_linters">consistency</a>, <a href="#topic+deprecated_linters">deprecated</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='list_comparison_linter'>Block usage of comparison operators with known-list() functions like lapply</h2><span id='topic+list_comparison_linter'></span>

<h3>Description</h3>

<p>Usage like <code>lapply(x, sum) &gt; 10</code> is awkward because the list must first
be coerced to a vector for comparison. A function like <code><a href="base.html#topic+vapply">vapply()</a></code>
should be preferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_comparison_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+common_mistakes_linters">common_mistakes</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "lapply(x, sum) &gt; 10",
  linters = list_comparison_linter()
)

# okay
lint(
  text = "unlist(lapply(x, sum)) &gt; 10",
  linters = list_comparison_linter()
)

</code></pre>

<hr>
<h2 id='literal_coercion_linter'>Require usage of correctly-typed literals over literal coercions</h2><span id='topic+literal_coercion_linter'></span>

<h3>Description</h3>

<p><code>as.integer(1)</code> (or <code>rlang::int(1)</code>) is the same as <code>1L</code> but the latter is
more concise and gets typed correctly at compilation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>literal_coercion_linter()
</code></pre>


<h3>Details</h3>

<p>The same applies to missing sentinels like <code>NA</code> &ndash; typically, it is not
necessary to specify the storage type of <code>NA</code>, but when it is, prefer
using the typed version (e.g. <code>NA_real_</code>) instead of a coercion
(like <code>as.numeric(NA)</code>).
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+efficiency_linters">efficiency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "int(1)",
  linters = literal_coercion_linter()
)

lint(
  text = "as.character(NA)",
  linters = literal_coercion_linter()
)

lint(
  text = "rlang::lgl(1L)",
  linters = literal_coercion_linter()
)

# okay
lint(
  text = "1L",
  linters = literal_coercion_linter()
)

lint(
  text = "NA_character_",
  linters = literal_coercion_linter()
)

lint(
  text = "TRUE",
  linters = literal_coercion_linter()
)

</code></pre>

<hr>
<h2 id='make_linter_from_xpath'>Create a linter from an XPath</h2><span id='topic+make_linter_from_xpath'></span><span id='topic+make_linter_from_function_xpath'></span>

<h3>Description</h3>

<p>Create a linter from an XPath
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_linter_from_xpath(
  xpath,
  lint_message,
  type = c("warning", "style", "error"),
  level = c("expression", "file")
)

make_linter_from_function_xpath(
  function_names,
  xpath,
  lint_message,
  type = c("warning", "style", "error"),
  level = c("expression", "file")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_linter_from_xpath_+3A_xpath">xpath</code></td>
<td>
<p>Character string, an XPath identifying R code to lint.
For <code>make_linter_from_function_xpath()</code>, the XPath is relative to the <code>parent::expr</code> of the
<code>SYMBOL_FUNCTION_CALL</code> nodes of the selected functions.
See <code><a href="xmlparsedata.html#topic+xml_parse_data">xmlparsedata::xml_parse_data()</a></code> and <code><a href="#topic+get_source_expressions">get_source_expressions()</a></code>.</p>
</td></tr>
<tr><td><code id="make_linter_from_xpath_+3A_lint_message">lint_message</code></td>
<td>
<p>The message to be included as the <code>message</code>
to the <code>Lint</code> object. If <code>lint_message</code> is a character vector the same length as <code>xml</code>,
the <code>i</code>-th lint will be given the <code>i</code>-th message.</p>
</td></tr>
<tr><td><code id="make_linter_from_xpath_+3A_type">type</code></td>
<td>
<p>type of lint.</p>
</td></tr>
<tr><td><code id="make_linter_from_xpath_+3A_level">level</code></td>
<td>
<p>Which level of expression is being tested? <code>"expression"</code>
means an individual expression, while <code>"file"</code> means all expressions
in the current file are available.</p>
</td></tr>
<tr><td><code id="make_linter_from_xpath_+3A_function_names">function_names</code></td>
<td>
<p>Character vector, names of functions whose calls to examine..</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>number_linter &lt;- make_linter_from_xpath("//NUM_CONST", "This is a number.")
lint(text = "1 + 2", linters = number_linter())
</code></pre>

<hr>
<h2 id='matrix_apply_linter'>Require usage of <code>colSums(x)</code> or <code>rowSums(x)</code> over <code>apply(x, ., sum)</code></h2><span id='topic+matrix_apply_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+colSums">colSums()</a></code> and <code><a href="base.html#topic+rowSums">rowSums()</a></code> are clearer and more performant alternatives to
<code>apply(x, 2, sum)</code> and <code>apply(x, 1, sum)</code> respectively in the case of 2D
arrays, or matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_apply_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "apply(x, 1, sum)",
  linters = matrix_apply_linter()
)

lint(
  text = "apply(x, 2, sum)",
  linters = matrix_apply_linter()
)

lint(
  text = "apply(x, 2, sum, na.rm = TRUE)",
  linters = matrix_apply_linter()
)

lint(
  text = "apply(x, 2:4, sum)",
  linters = matrix_apply_linter()
)

</code></pre>

<hr>
<h2 id='missing_argument_linter'>Missing argument linter</h2><span id='topic+missing_argument_linter'></span>

<h3>Description</h3>

<p>Check for missing arguments in function calls (e.g. <code>stats::median(1:10, )</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_argument_linter(
  except = c("alist", "quote", "switch"),
  allow_trailing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missing_argument_linter_+3A_except">except</code></td>
<td>
<p>a character vector of function names as exceptions.</p>
</td></tr>
<tr><td><code id="missing_argument_linter_+3A_allow_trailing">allow_trailing</code></td>
<td>
<p>always allow trailing empty arguments?</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+common_mistakes_linters">common_mistakes</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+correctness_linters">correctness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'tibble(x = "a", )',
  linters = missing_argument_linter()
)

# okay
lint(
  text = 'tibble(x = "a")',
  linters = missing_argument_linter()
)

lint(
  text = 'tibble(x = "a", )',
  linters = missing_argument_linter(except = "tibble")
)

lint(
  text = 'tibble(x = "a", )',
  linters = missing_argument_linter(allow_trailing = TRUE)
)

</code></pre>

<hr>
<h2 id='missing_package_linter'>Missing package linter</h2><span id='topic+missing_package_linter'></span>

<h3>Description</h3>

<p>Check for missing packages in <code>library()</code>, <code>require()</code>, <code>loadNamespace()</code>, and <code>requireNamespace()</code> calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_package_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+common_mistakes_linters">common_mistakes</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "library(xyzxyz)",
  linters = missing_package_linter()
)

# okay
lint(
  text = "library(stats)",
  linters = missing_package_linter()
)

</code></pre>

<hr>
<h2 id='modify_defaults'>Modify lintr defaults</h2><span id='topic+modify_defaults'></span>

<h3>Description</h3>

<p>Modify a list of defaults by name, allowing for replacement, deletion and addition of new elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_defaults(defaults, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_defaults_+3A_defaults">defaults</code></td>
<td>
<p>named list of elements to modify.</p>
</td></tr>
<tr><td><code id="modify_defaults_+3A_...">...</code></td>
<td>
<p>arguments of elements to change. If unnamed, the argument is automatically named.
If the named argument already exists in <code>defaults</code>, it is replaced by the new element.
If it does not exist, it is added. If the value is <code>NULL</code>, the element is removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified list of elements, sorted by name. To achieve this sort in a platform-independent way, two
transformations are applied to the names: (1) replace <code style="white-space: pre;">&#8288;_&#8288;</code> with <code>0</code> and (2) convert <code><a href="base.html#topic+tolower">tolower()</a></code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters_with_defaults">linters_with_defaults</a> for basing off lintr's set of default linters.
</p>
</li>
<li> <p><a href="#topic+all_linters">all_linters</a> for basing off all available linters in lintr.
</p>
</li>
<li> <p><a href="#topic+linters_with_tags">linters_with_tags</a> for basing off tags attached to linters, possibly across multiple packages.
</p>
</li>
<li> <p><a href="#topic+available_linters">available_linters</a> to get a data frame of available linters.
</p>
</li>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># custom list of undesirable functions:
#    remove `sapply` (using `NULL`)
#    add `cat` (with an accompanying message),
#    add `print` (unnamed, i.e. with no accompanying message)
#    add `source` (as taken from `all_undesirable_functions`)
my_undesirable_functions &lt;- modify_defaults(
  defaults = default_undesirable_functions,
  sapply = NULL, "cat" = "No cat allowed", "print", all_undesirable_functions[["source"]]
)

# list names of functions specified as undesirable
names(my_undesirable_functions)
</code></pre>

<hr>
<h2 id='namespace_linter'>Namespace linter</h2><span id='topic+namespace_linter'></span>

<h3>Description</h3>

<p>Check for missing packages and symbols in namespace calls.
Note that using <code>check_exports=TRUE</code> or <code>check_nonexports=TRUE</code> will load packages used in user code so it could
potentially change the global state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>namespace_linter(check_exports = TRUE, check_nonexports = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="namespace_linter_+3A_check_exports">check_exports</code></td>
<td>
<p>Check if <code>symbol</code> is exported from <code>namespace</code> in <code>namespace::symbol</code> calls.</p>
</td></tr>
<tr><td><code id="namespace_linter_+3A_check_nonexports">check_nonexports</code></td>
<td>
<p>Check if <code>symbol</code> exists in <code>namespace</code> in <code>namespace:::symbol</code> calls.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+correctness_linters">correctness</a>, <a href="#topic+executing_linters">executing</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "xyzxyz::sd(c(1, 2, 3))",
  linters = namespace_linter()
)

lint(
  text = "stats::ssd(c(1, 2, 3))",
  linters = namespace_linter()
)

# okay
lint(
  text = "stats::sd(c(1, 2, 3))",
  linters = namespace_linter()
)

lint(
  text = "stats::ssd(c(1, 2, 3))",
  linters = namespace_linter(check_exports = FALSE)
)

lint(
  text = "stats:::ssd(c(1, 2, 3))",
  linters = namespace_linter(check_nonexports = FALSE)
)

</code></pre>

<hr>
<h2 id='nested_ifelse_linter'>Block usage of nested <code>ifelse()</code> calls</h2><span id='topic+nested_ifelse_linter'></span>

<h3>Description</h3>

<p>Calling <code><a href="base.html#topic+ifelse">ifelse()</a></code> in nested calls is problematic for two main reasons:
</p>

<ol>
<li><p> It can be hard to read &ndash; mapping the code to the expected output
for such code can be a messy task/require a lot of mental bandwidth,
especially for code that nests more than once
</p>
</li>
<li><p> It is inefficient &ndash; <code>ifelse()</code> can evaluate <em>all</em> of its arguments at
both yes and no (see <a href="https://stackoverflow.com/q/16275149">https://stackoverflow.com/q/16275149</a>); this issue
is exacerbated for nested calls
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>nested_ifelse_linter()
</code></pre>


<h3>Details</h3>

<p>Users can instead rely on a more readable alternative modeled after SQL
CASE WHEN statements.
</p>
<p>Let's say this is our original code:
</p>
<div class="sourceCode r"><pre>ifelse(
  x == "a",
  2L,
  ifelse(x == "b", 3L, 1L)
)
</pre></div>
<p>Here are a few ways to avoid nesting and make the code more readable:
</p>

<ul>
<li><p> Use <code>data.table::fcase()</code>
</p>
<div class="sourceCode r"><pre>data.table::fcase(
  x == "a", 2L,
  x == "b", 3L,
  default = 1L
)
</pre></div>
</li>
<li><p> Use <code>dplyr::case_match()</code>
</p>
<div class="sourceCode r"><pre>dplyr::case_match(
  x,
  "a" ~ 2L,
  "b" ~ 3L,
  .default = 1L
)
</pre></div>
</li>
<li><p> Use a look-up-and-merge approach (build a mapping table between values
and outputs and merge this to the input)
</p>
<div class="sourceCode r"><pre>default &lt;- 1L
values &lt;- data.frame(
  a = 2L,
  b = 3L
)
found_value &lt;- values[[x]]
ifelse(is.null(found_value), default, found_value)
</pre></div>
</li></ul>



<h3>Tags</h3>

<p><a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'ifelse(x == "a", 1L, ifelse(x == "b", 2L, 3L))',
  linters = nested_ifelse_linter()
)

# okay
lint(
  text = 'dplyr::case_when(x == "a" ~ 1L, x == "b" ~ 2L, TRUE ~ 3L)',
  linters = nested_ifelse_linter()
)

lint(
  text = 'data.table::fcase(x == "a", 1L, x == "b", 2L, default = 3L)',
  linters = nested_ifelse_linter()
)

</code></pre>

<hr>
<h2 id='nested_pipe_linter'>Block usage of pipes nested inside other calls</h2><span id='topic+nested_pipe_linter'></span>

<h3>Description</h3>

<p>Nesting pipes harms readability; extract sub-steps to separate variables,
append further pipeline steps, or otherwise refactor such usage away.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_pipe_linter(
  allow_inline = TRUE,
  allow_outer_calls = c("try", "tryCatch", "withCallingHandlers")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested_pipe_linter_+3A_allow_inline">allow_inline</code></td>
<td>
<p>Logical, default <code>TRUE</code>, in which case only &quot;inner&quot;
pipelines which span more than one line are linted. If <code>FALSE</code>, even
&quot;inner&quot; pipelines that fit in one line are linted.</p>
</td></tr>
<tr><td><code id="nested_pipe_linter_+3A_allow_outer_calls">allow_outer_calls</code></td>
<td>
<p>Character vector dictating which &quot;outer&quot;
calls to exempt from the requirement to unnest (see examples). Defaults
to <code><a href="base.html#topic+try">try()</a></code>, <code><a href="base.html#topic+tryCatch">tryCatch()</a></code>, and <code><a href="base.html#topic+withCallingHandlers">withCallingHandlers()</a></code>.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code &lt;- "df1 %&gt;%\n  inner_join(df2 %&gt;%\n    select(a, b)\n  )"
writeLines(code)
lint(
  text = code,
  linters = nested_pipe_linter()
)

lint(
  text = "df1 %&gt;% inner_join(df2 %&gt;% select(a, b))",
  linters = nested_pipe_linter(allow_inline = FALSE)
)

lint(
  text = "tryCatch(x %&gt;% filter(grp == 'a'), error = identity)",
  linters = nested_pipe_linter(allow_outer_calls = character())
)

# okay
lint(
  text = "df1 %&gt;% inner_join(df2 %&gt;% select(a, b))",
  linters = nested_pipe_linter()
)

code &lt;- "df1 %&gt;%\n  inner_join(df2 %&gt;%\n    select(a, b)\n  )"
writeLines(code)
lint(
  text = code,
  linters = nested_pipe_linter(allow_outer_calls = "inner_join")
)

lint(
  text = "tryCatch(x %&gt;% filter(grp == 'a'), error = identity)",
  linters = nested_pipe_linter()
)

</code></pre>

<hr>
<h2 id='nonportable_path_linter'>Non-portable path linter</h2><span id='topic+nonportable_path_linter'></span>

<h3>Description</h3>

<p>Check that <code><a href="base.html#topic+file.path">file.path()</a></code> is used to construct safe and portable paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonportable_path_linter(lax = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nonportable_path_linter_+3A_lax">lax</code></td>
<td>
<p>Less stringent linting, leading to fewer false positives.
If <code>TRUE</code>, only lint path strings, which
</p>

<ul>
<li><p> contain at least two path elements, with one having at least two characters and
</p>
</li>
<li><p> contain only alphanumeric chars (including UTF-8), spaces, and win32-allowed punctuation
</p>
</li></ul>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><code><a href="#topic+absolute_path_linter">absolute_path_linter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "'abcdefg/hijklmnop/qrst/uv/wxyz'",
  linters = nonportable_path_linter()
)

# okay
lint(
  text = "file.path('abcdefg', 'hijklmnop', 'qrst', 'uv', 'wxyz')",
  linters = nonportable_path_linter()
)

</code></pre>

<hr>
<h2 id='normalize_exclusions'>Normalize lint exclusions</h2><span id='topic+normalize_exclusions'></span>

<h3>Description</h3>

<p>Normalize lint exclusions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_exclusions(x, normalize_path = TRUE, root = getwd(), pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_exclusions_+3A_x">x</code></td>
<td>
<p>Exclusion specification
</p>

<ul>
<li><p> A character vector of filenames or directories relative to <code>root</code>
</p>
</li>
<li><p> A named list of integers specifying lines to be excluded per file
</p>
</li>
<li><p> A named list of named lists specifying linters and lines to be excluded for the linters per file.
</p>
</li></ul>
</td></tr>
<tr><td><code id="normalize_exclusions_+3A_normalize_path">normalize_path</code></td>
<td>
<p>Should the names of the returned exclusion list be normalized paths?
If no, they will be relative to <code>root</code>.</p>
</td></tr>
<tr><td><code id="normalize_exclusions_+3A_root">root</code></td>
<td>
<p>Base directory for relative filename resolution.</p>
</td></tr>
<tr><td><code id="normalize_exclusions_+3A_pattern">pattern</code></td>
<td>
<p>If non-NULL, only exclude files in excluded directories if they match
<code>pattern</code>. Passed to <a href="base.html#topic+list.files">list.files</a> if a directory is excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of file exclusions.
The names of the list specify the filenames to be excluded.
</p>
<p>Each file exclusion is a possibly named list containing line numbers to exclude, or the sentinel <code>Inf</code> for
completely excluded files. If the an entry is named, the exclusions only take effect for the linter with the same
name.
</p>
<p>If <code>normalize_path</code> is <code>TRUE</code>, file names will be normalized relative to <code>root</code>.
Otherwise the paths are left as provided (relative to <code>root</code> or absolute).
</p>

<hr>
<h2 id='nrow_subset_linter'>Block usage of <code>nrow(subset(x, .))</code></h2><span id='topic+nrow_subset_linter'></span>

<h3>Description</h3>

<p>Using <code>nrow(subset(x, condition))</code> to count the instances where <code>condition</code>
applies inefficiently requires doing a full subset of <code>x</code> just to
count the number of rows in the resulting subset.
There are a number of equivalent expressions that don't require the full
subset, e.g. <code>with(x, sum(condition))</code> (or, more generically,
<code>with(x, sum(condition, na.rm = TRUE))</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrow_subset_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+efficiency_linters">efficiency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "nrow(subset(x, is_treatment))",
  linters = nrow_subset_linter()
)

lint(
  text = "nrow(filter(x, is_treatment))",
  linters = nrow_subset_linter()
)

lint(
  text = "x %&gt;% filter(x, is_treatment) %&gt;% nrow()",
  linters = nrow_subset_linter()
)

# okay
lint(
  text = "with(x, sum(is_treatment, na.rm = TRUE))",
  linters = nrow_subset_linter()
)

</code></pre>

<hr>
<h2 id='numeric_leading_zero_linter'>Require usage of a leading zero in all fractional numerics</h2><span id='topic+numeric_leading_zero_linter'></span>

<h3>Description</h3>

<p>While .1 and 0.1 mean the same thing, the latter is easier to read due
to the small size of the '.' glyph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numeric_leading_zero_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x &lt;- .1",
  linters = numeric_leading_zero_linter()
)

lint(
  text = "x &lt;- -.1",
  linters = numeric_leading_zero_linter()
)

# okay
lint(
  text = "x &lt;- 0.1",
  linters = numeric_leading_zero_linter()
)

lint(
  text = "x &lt;- -0.1",
  linters = numeric_leading_zero_linter()
)

</code></pre>

<hr>
<h2 id='nzchar_linter'>Require usage of nzchar where appropriate</h2><span id='topic+nzchar_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+nzchar">nzchar()</a></code> efficiently determines which of a vector of strings are empty
(i.e., are <code>""</code>). It should in most cases be used instead of
constructions like <code>string == ""</code> or <code>nchar(string) == 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nzchar_linter()
</code></pre>


<h3>Details</h3>

<p>One crucial difference is in the default handling of <code>NA_character_</code>, i.e.,
missing strings. <code>nzchar(NA_character_)</code> is <code>TRUE</code>, while <code>NA_character_ == ""</code>
and <code>nchar(NA_character_) == 0</code> are both <code>NA</code>. Therefore, for strict
compatibility, use <code>nzchar(x, keepNA = TRUE)</code>. If the input is known to be
complete (no missing entries), this argument can be dropped for conciseness.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+efficiency_linters">efficiency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x[x == '']",
  linters = nzchar_linter()
)

lint(
  text = "x[nchar(x) &gt; 0]",
  linters = nzchar_linter()
)

# okay
lint(
  text = "x[!nzchar(x, keepNA = TRUE)]",
  linters = nzchar_linter()
)

lint(
  text = "x[nzchar(x, keepNA = TRUE)]",
  linters = nzchar_linter()
)

</code></pre>

<hr>
<h2 id='object_length_linter'>Object length linter</h2><span id='topic+object_length_linter'></span>

<h3>Description</h3>

<p>Check that object names are not too long.
The length of an object name is defined as the length in characters, after removing extraneous parts:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_length_linter(length = 30L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="object_length_linter_+3A_length">length</code></td>
<td>
<p>maximum variable name length allowed.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> generic prefixes for implementations of S3 generics, e.g. <code>as.data.frame.my_class</code> has length 8.
</p>
</li>
<li><p> leading <code>.</code>, e.g. <code>.my_hidden_function</code> has length 18.
</p>
</li>
<li><p> &quot;%%&quot; for infix operators, e.g. <code style="white-space: pre;">&#8288;%my_op%&#8288;</code> has length 5.
</p>
</li>
<li><p> trailing <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> for assignment functions, e.g. <code style="white-space: pre;">&#8288;my_attr&lt;-&#8288;</code> has length 7.
</p>
</li></ul>

<p>Note that this behavior relies in part on having packages in your Imports available;
see the detailed note in <code><a href="#topic+object_name_linter">object_name_linter()</a></code> for more details.
</p>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+executing_linters">executing</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "very_very_long_variable_name &lt;- 1L",
  linters = object_length_linter(length = 10L)
)

# okay
lint(
  text = "very_very_long_variable_name &lt;- 1L",
  linters = object_length_linter(length = 30L)
)

lint(
  text = "var &lt;- 1L",
  linters = object_length_linter(length = 10L)
)

</code></pre>

<hr>
<h2 id='object_name_linter'>Object name linter</h2><span id='topic+object_name_linter'></span>

<h3>Description</h3>

<p>Check that object names conform to a naming style.
The default naming styles are &quot;snake_case&quot; and &quot;symbols&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_name_linter(styles = c("snake_case", "symbols"), regexes = character())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="object_name_linter_+3A_styles">styles</code></td>
<td>
<p>A subset of
&lsquo;symbols&rsquo;, &lsquo;CamelCase&rsquo;, &lsquo;camelCase&rsquo;, &lsquo;snake_case&rsquo;, &lsquo;SNAKE_CASE&rsquo;, &lsquo;dotted.case&rsquo;, &lsquo;lowercase&rsquo;, &lsquo;UPPERCASE&rsquo;. A name should
match at least one of these styles. The <code>"symbols"</code> style refers to
names containing <em>only</em> non-alphanumeric characters; e.g., defining <code style="white-space: pre;">&#8288;%+%&#8288;</code>
from ggplot2 or <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> from magrittr would not generate lint markers,
whereas <code style="white-space: pre;">&#8288;%m+%&#8288;</code> from lubridate (containing both alphanumeric <em>and</em>
non-alphanumeric characters) would.</p>
</td></tr>
<tr><td><code id="object_name_linter_+3A_regexes">regexes</code></td>
<td>
<p>A (possibly named) character vector specifying a custom naming convention.
If named, the names will be used in the lint message. Otherwise, the regexes enclosed by <code>/</code> will be used in the
lint message.
Note that specifying <code>regexes</code> overrides the default <code>styles</code>. So if you want to combine <code>regexes</code> and <code>styles</code>,
both need to be explicitly specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quotes (<code style="white-space: pre;">&#8288;`"'&#8288;</code>) and specials (<code style="white-space: pre;">&#8288;%&#8288;</code> and trailing <code style="white-space: pre;">&#8288;&lt;-&#8288;</code>) are not considered part of the object name.
</p>
<p>Note when used in a package, in order to ignore objects imported
from other namespaces, this linter will attempt <code><a href="base.html#topic+getNamespaceExports">getNamespaceExports()</a></code>
whenever an <code>import(PKG)</code> or <code>importFrom(PKG, ...)</code> statement is found
in your NAMESPACE file. If <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code> fails (e.g., the package
is not yet installed), the linter won't be able to ignore some usages
that would otherwise be allowed.
</p>
<p>Suppose, for example, you have <code>import(upstream)</code> in your NAMESPACE,
which makes available its exported S3 generic function
<code>a_really_quite_long_function_name</code> that you then extend in your package
by defining a corresponding method for your class <code>my_class</code>.
Then, if <code>upstream</code> is not installed when this linter runs, a lint
will be thrown on this object (even though you don't &quot;own&quot; its full name).
</p>
<p>The best way to get lintr to work correctly is to install the package so
that it's available in the session where this linter is running.
</p>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+executing_linters">executing</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "my_var &lt;- 1L",
  linters = object_name_linter(styles = "CamelCase")
)

lint(
  text = "xYz &lt;- 1L",
  linters = object_name_linter(styles = c("UPPERCASE", "lowercase"))
)

lint(
  text = "MyVar &lt;- 1L",
  linters = object_name_linter(styles = "dotted.case")
)

lint(
  text = "asd &lt;- 1L",
  linters = object_name_linter(regexes = c(my_style = "F$", "f$"))
)

# okay
lint(
  text = "my_var &lt;- 1L",
  linters = object_name_linter(styles = "snake_case")
)

lint(
  text = "xyz &lt;- 1L",
  linters = object_name_linter(styles = "lowercase")
)

lint(
  text = "my.var &lt;- 1L; myvar &lt;- 2L",
  linters = object_name_linter(styles = c("dotted.case", "lowercase"))
)

lint(
  text = "asdf &lt;- 1L; asdF &lt;- 1L",
  linters = object_name_linter(regexes = c(my_style = "F$", "f$"))
)

</code></pre>

<hr>
<h2 id='object_overwrite_linter'>Block assigning any variables whose name clashes with a <code>base</code> R function</h2><span id='topic+object_overwrite_linter'></span>

<h3>Description</h3>

<p>Re-using existing names creates a risk of subtle error best avoided.
Avoiding this practice also encourages using better, more descriptive names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_overwrite_linter(
  packages = c("base", "stats", "utils", "tools", "methods", "graphics", "grDevices"),
  allow_names = character()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="object_overwrite_linter_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to search for names that should
be avoided. Defaults to the most common default packages: base, stats,
utils, tools, methods, graphics, and grDevices.</p>
</td></tr>
<tr><td><code id="object_overwrite_linter_+3A_allow_names">allow_names</code></td>
<td>
<p>Character vector of object names to ignore, i.e., which
are allowed to collide with exports from <code>packages</code>.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+executing_linters">executing</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#object-names">https://style.tidyverse.org/syntax.html#object-names</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code &lt;- "function(x) {\n  data &lt;- x\n  data\n}"
writeLines(code)
lint(
  text = code,
  linters = object_overwrite_linter()
)

code &lt;- "function(x) {\n  lint &lt;- 'fun'\n  lint\n}"
writeLines(code)
lint(
  text = code,
  linters = object_overwrite_linter(packages = "lintr")
)

# okay
code &lt;- "function(x) {\n  data('mtcars')\n}"
writeLines(code)
lint(
  text = code,
  linters = object_overwrite_linter()
)

code &lt;- "function(x) {\n  data &lt;- x\n  data\n}"
writeLines(code)
lint(
  text = code,
  linters = object_overwrite_linter(packages = "base")
)

# names in function signatures are ignored
lint(
  text = "function(data) data &lt;- subset(data, x &gt; 0)",
  linters = object_overwrite_linter()
)

</code></pre>

<hr>
<h2 id='object_usage_linter'>Object usage linter</h2><span id='topic+object_usage_linter'></span>

<h3>Description</h3>

<p>Check that closures have the proper usage using <code><a href="codetools.html#topic+checkUsage">codetools::checkUsage()</a></code>.
Note that this runs <code><a href="base.html#topic+eval">base::eval()</a></code> on the code, so <strong>do not use with untrusted code</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_usage_linter(interpret_glue = TRUE, skip_with = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="object_usage_linter_+3A_interpret_glue">interpret_glue</code></td>
<td>
<p>If <code>TRUE</code>, interpret <code><a href="glue.html#topic+glue">glue::glue()</a></code> calls to avoid false positives caused by local variables
which are only used in a glue expression.</p>
</td></tr>
<tr><td><code id="object_usage_linter_+3A_skip_with">skip_with</code></td>
<td>
<p>A logical. If <code>TRUE</code> (default), code in <code>with()</code> expressions
will be skipped. This argument will be passed to <code>skipWith</code> argument of
<code>codetools::checkUsage()</code>.</p>
</td></tr>
</table>


<h3>Linters</h3>

<p>The following linters are tagged with 'package_development':
</p>

<ul>
<li><p><code><a href="#topic+backport_linter">backport_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+conjunct_test_linter">conjunct_test_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_comparison_linter">expect_comparison_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_identical_linter">expect_identical_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_length_linter">expect_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_named_linter">expect_named_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_not_linter">expect_not_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_null_linter">expect_null_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_s3_class_linter">expect_s3_class_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_s4_class_linter">expect_s4_class_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_true_false_linter">expect_true_false_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_type_linter">expect_type_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+package_hooks_linter">package_hooks_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+yoda_test_linter">yoda_test_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "foo &lt;- function() { x &lt;- 1 }",
  linters = object_usage_linter()
)

# okay
lint(
  text = "foo &lt;- function(x) { x &lt;- 1 }",
  linters = object_usage_linter()
)

lint(
  text = "foo &lt;- function() { x &lt;- 1; return(x) }",
  linters = object_usage_linter()
)
</code></pre>

<hr>
<h2 id='one_call_pipe_linter'>Block single-call magrittr pipes</h2><span id='topic+one_call_pipe_linter'></span>

<h3>Description</h3>

<p>Prefer using a plain call instead of a pipe with only one call,
i.e. <code>1:10 %&gt;% sum()</code> should instead be <code>sum(1:10)</code>. Note that
calls in the first <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> argument count. <code>rowSums(x) %&gt;% max()</code> is OK
because there are two total calls (<code>rowSums()</code> and <code>max()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_call_pipe_linter()
</code></pre>


<h3>Details</h3>

<p>Note also that un-&quot;called&quot; steps are <em>not</em> counted, since they should
be calls (see <code><a href="#topic+pipe_call_linter">pipe_call_linter()</a></code>).
</p>


<h3>Tags</h3>

<p><a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/pipes.html#short-pipes">https://style.tidyverse.org/pipes.html#short-pipes</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "(1:10) %&gt;% sum()",
  linters = one_call_pipe_linter()
)

lint(
  text = "DT %&gt;% .[grp == 'a', sum(v)]",
  linters = one_call_pipe_linter()
)

# okay
lint(
  text = "rowSums(x) %&gt;% mean()",
  linters = one_call_pipe_linter()
)

lint(
  text = "DT[src == 'a', .N, by = grp] %&gt;% .[N &gt; 10]",
  linters = one_call_pipe_linter()
)

# assignment pipe is exempted
lint(
  text = "DF %&lt;&gt;% mutate(a = 2)",
  linters = one_call_pipe_linter()
)

</code></pre>

<hr>
<h2 id='outer_negation_linter'>Require usage of <code>!any(x)</code> over <code>all(!x)</code>, <code>!all(x)</code> over <code>any(!x)</code></h2><span id='topic+outer_negation_linter'></span>

<h3>Description</h3>

<p><code>any(!x)</code> is logically equivalent to <code>!all(x)</code>; ditto for the equivalence of
<code>all(!x)</code> and <code>!any(x)</code>. Negating after aggregation only requires inverting
one logical value, and is typically more readable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outer_negation_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "all(!x)",
  linters = outer_negation_linter()
)

lint(
  text = "any(!x)",
  linters = outer_negation_linter()
)

# okay
lint(
  text = "!any(x)",
  linters = outer_negation_linter()
)

lint(
  text = "!all(x)",
  linters = outer_negation_linter()
)

</code></pre>

<hr>
<h2 id='package_development_linters'>Package development linters</h2><span id='topic+package_development_linters'></span>

<h3>Description</h3>

<p>Linters useful to package developers, for example for writing consistent tests.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'package_development':
</p>

<ul>
<li><p><code><a href="#topic+backport_linter">backport_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+conjunct_test_linter">conjunct_test_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_comparison_linter">expect_comparison_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_identical_linter">expect_identical_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_length_linter">expect_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_named_linter">expect_named_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_not_linter">expect_not_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_null_linter">expect_null_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_s3_class_linter">expect_s3_class_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_s4_class_linter">expect_s4_class_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_true_false_linter">expect_true_false_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_type_linter">expect_type_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+package_hooks_linter">package_hooks_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+yoda_test_linter">yoda_test_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='package_hooks_linter'>Package hooks linter</h2><span id='topic+package_hooks_linter'></span>

<h3>Description</h3>

<p>Check various common &quot;gotchas&quot; in <code><a href="base.html#topic+.onLoad">.onLoad()</a></code>, <code><a href="base.html#topic+.onAttach">.onAttach()</a></code>, <code><a href="base.html#topic+.Last.lib">.Last.lib()</a></code>, and <code><a href="base.html#topic+.onDetach">.onDetach()</a></code>
namespace hooks that will cause <code style="white-space: pre;">&#8288;R CMD check&#8288;</code> issues. See Writing R Extensions for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>package_hooks_linter()
</code></pre>


<h3>Details</h3>


<ol>
<li> <p><code>.onLoad()</code> shouldn't call <code><a href="base.html#topic+cat">cat()</a></code>, <code><a href="base.html#topic+message">message()</a></code>, <code><a href="base.html#topic+print">print()</a></code>, <code><a href="base.html#topic+writeLines">writeLines()</a></code>, <code><a href="base.html#topic+packageStartupMessage">packageStartupMessage()</a></code>,
<code><a href="base.html#topic+require">require()</a></code>, <code><a href="base.html#topic+library">library()</a></code>, or <code><a href="utils.html#topic+installed.packages">installed.packages()</a></code>.
</p>
</li>
<li> <p><code>.onAttach()</code> shouldn't call <code>cat()</code>, <code>message()</code>, <code>print()</code>, <code>writeLines()</code>, <code><a href="base.html#topic+library.dynam">library.dynam()</a></code>,
<code>require()</code>, <code>library()</code>, or <code>installed.packages()</code>.
</p>
</li>
<li> <p><code>.Last.lib()</code> and <code>.onDetach()</code> shouldn't call <code><a href="base.html#topic+library.dynam.unload">library.dynam.unload()</a></code>.
</p>
</li>
<li> <p><code>.onLoad()</code> and <code>.onAttach()</code> should take two arguments, with names matching <code style="white-space: pre;">&#8288;^lib&#8288;</code> and <code style="white-space: pre;">&#8288;^pkg&#8288;</code>;
<code>.Last.lib()</code> and <code>.onDetach()</code> should take one argument with name matching <code style="white-space: pre;">&#8288;^lib&#8288;</code>.
</p>
</li></ol>



<h3>Tags</h3>

<p><a href="#topic+correctness_linters">correctness</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = ".onLoad &lt;- function(lib, ...) { }",
  linters = package_hooks_linter()
)

lint(
  text = ".onAttach &lt;- function(lib, pkg) { require(foo) }",
  linters = package_hooks_linter()
)

lint(
  text = ".onDetach &lt;- function(pkg) { }",
  linters = package_hooks_linter()
)

# okay
lint(
  text = ".onLoad &lt;- function(lib, pkg) { }",
  linters = package_hooks_linter()
)

lint(
  text = '.onAttach &lt;- function(lib, pkg) { loadNamespace("foo") }',
  linters = package_hooks_linter()
)

lint(
  text = ".onDetach &lt;- function(lib) { }",
  linters = package_hooks_linter()
)

</code></pre>

<hr>
<h2 id='paren_body_linter'>Parenthesis before body linter</h2><span id='topic+paren_body_linter'></span>

<h3>Description</h3>

<p>Check that there is a space between right parenthesis and a body expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paren_body_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#parentheses">https://style.tidyverse.org/syntax.html#parentheses</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "function(x)x + 1",
  linters = paren_body_linter()
)

# okay
lint(
  text = "function(x) x + 1",
  linters = paren_body_linter()
)

</code></pre>

<hr>
<h2 id='parse_exclusions'>read a source file and parse all the excluded lines from it</h2><span id='topic+parse_exclusions'></span>

<h3>Description</h3>

<p>read a source file and parse all the excluded lines from it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_exclusions(
  file,
  exclude = settings$exclude,
  exclude_next = settings$exclude_next,
  exclude_start = settings$exclude_start,
  exclude_end = settings$exclude_end,
  exclude_linter = settings$exclude_linter,
  exclude_linter_sep = settings$exclude_linter_sep,
  lines = NULL,
  linter_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_exclusions_+3A_file">file</code></td>
<td>
<p>R source file</p>
</td></tr>
<tr><td><code id="parse_exclusions_+3A_exclude">exclude</code></td>
<td>
<p>Regular expression used to mark lines to exclude.</p>
</td></tr>
<tr><td><code id="parse_exclusions_+3A_exclude_next">exclude_next</code></td>
<td>
<p>Regular expression used to mark lines immediately preceding excluded lines.</p>
</td></tr>
<tr><td><code id="parse_exclusions_+3A_exclude_start">exclude_start</code></td>
<td>
<p>Regular expression used to mark the start of an excluded range.</p>
</td></tr>
<tr><td><code id="parse_exclusions_+3A_exclude_end">exclude_end</code></td>
<td>
<p>Regular expression used to mark the end of an excluded range.</p>
</td></tr>
<tr><td><code id="parse_exclusions_+3A_exclude_linter">exclude_linter</code></td>
<td>
<p>Regular expression used to capture a list of to-be-excluded linters immediately following a
<code>exclude</code> or <code>exclude_start</code> marker.</p>
</td></tr>
<tr><td><code id="parse_exclusions_+3A_exclude_linter_sep">exclude_linter_sep</code></td>
<td>
<p>Regular expression used to split a linter list into individual linter names for exclusion.</p>
</td></tr>
<tr><td><code id="parse_exclusions_+3A_lines">lines</code></td>
<td>
<p>A character vector of the content lines of <code>file</code>.</p>
</td></tr>
<tr><td><code id="parse_exclusions_+3A_linter_names">linter_names</code></td>
<td>
<p>Names of active linters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A possibly named list of excluded lines, possibly for specific linters.
</p>

<hr>
<h2 id='paste_linter'>Raise lints for several common poor usages of <code>paste()</code></h2><span id='topic+paste_linter'></span>

<h3>Description</h3>

<p>The following issues are linted by default by this linter
(see arguments for which can be de-activated optionally):
</p>

<ol>
<li><p> Block usage of <code><a href="base.html#topic+paste">paste()</a></code> with <code>sep = ""</code>. <code><a href="base.html#topic+paste0">paste0()</a></code> is a faster, more concise alternative.
</p>
</li>
<li><p> Block usage of <code>paste()</code> or <code>paste0()</code> with <code>collapse = ", "</code>. <code><a href="base.html#topic+toString">toString()</a></code> is a direct
wrapper for this, and alternatives like <code><a href="glue.html#topic+glue_collapse">glue::glue_collapse()</a></code> might give better messages for humans.
</p>
</li>
<li><p> Block usage of <code>paste0()</code> that supplies <code style="white-space: pre;">&#8288;sep=&#8288;</code> &ndash; this is not a formal argument to <code>paste0</code>, and
is likely to be a mistake.
</p>
</li>
<li><p> Block usage of <code>paste()</code> / <code>paste0()</code> combined with <code><a href="base.html#topic+rep">rep()</a></code> that could be replaced by
<code><a href="base.html#topic+strrep">strrep()</a></code>. <code>strrep()</code> can handle the task of building a block of repeated strings
(e.g. often used to build &quot;horizontal lines&quot; for messages). This is both more readable and
skips the (likely small) overhead of putting two strings into the global string cache when only one is needed.
</p>
<p>Only target scalar usages &ndash; <code>strrep</code> can handle more complicated cases (e.g. <code>strrep(letters, 26:1)</code>,
but those aren't as easily translated from a <code>paste(collapse=)</code> call.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>paste_linter(
  allow_empty_sep = FALSE,
  allow_to_string = FALSE,
  allow_file_path = c("double_slash", "always", "never")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paste_linter_+3A_allow_empty_sep">allow_empty_sep</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, usage of
<code>paste()</code> with <code>sep = ""</code> is not linted.</p>
</td></tr>
<tr><td><code id="paste_linter_+3A_allow_to_string">allow_to_string</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, usage of
<code>paste()</code> and <code>paste0()</code> with <code>collapse = ", "</code> is not linted.</p>
</td></tr>
<tr><td><code id="paste_linter_+3A_allow_file_path">allow_file_path</code></td>
<td>
<p>String, one of <code>"never"</code>, <code>"double_slash"</code>, or <code>"always"</code>; <code>"double_slash"</code> by default.
If <code>"never"</code>, usage of <code>paste()</code> and <code>paste0()</code> to construct file paths is not linted. If <code>"double_slash"</code>,
strings containing consecutive forward slashes will not lint. The main use case here is for URLs &ndash; &quot;paths&quot; like
<code>"https://"</code> will not induce lints, since constructing them with <code>file.path()</code> might be deemed unnatural.
Lastly, if <code>"always"</code>, strings with consecutive forward slashes will also lint. Note that <code>"//"</code> is never linted
when it comes at the beginning or end of the input, to avoid requiring empty inputs like
<code>file.path("", ...)</code> or <code>file.path(..., "")</code>.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'paste("a", "b", sep = "")',
  linters = paste_linter()
)

lint(
  text = 'paste(c("a", "b"), collapse = ", ")',
  linters = paste_linter()
)

lint(
  text = 'paste0(c("a", "b"), sep = " ")',
  linters = paste_linter()
)

lint(
  text = 'paste0(rep("*", 10L), collapse = "")',
  linters = paste_linter()
)

lint(
  text = 'paste0("http://site.com/", path)',
  linters = paste_linter(allow_file_path = "never")
)

lint(
  text = 'paste0(x, collapse = "")',
  linters = paste_linter()
)

# okay
lint(
  text = 'paste0("a", "b")',
  linters = paste_linter()
)

lint(
  text = 'paste("a", "b", sep = "")',
  linters = paste_linter(allow_empty_sep = TRUE)
)

lint(
  text = 'toString(c("a", "b"))',
  linters = paste_linter()
)

lint(
  text = 'paste(c("a", "b"), collapse = ", ")',
  linters = paste_linter(allow_to_string = TRUE)
)

lint(
  text = 'paste(c("a", "b"))',
  linters = paste_linter()
)

lint(
  text = 'strrep("*", 10L)',
  linters = paste_linter()
)

lint(
  text = 'paste0(year, "/", month, "/", day)',
  linters = paste_linter(allow_file_path = "always")
)

lint(
  text = 'paste0("http://site.com/", path)',
  linters = paste_linter()
)

lint(
  text = 'paste(x, collapse = "")',
  linters = paste_linter()
)

</code></pre>

<hr>
<h2 id='pipe_call_linter'>Pipe call linter</h2><span id='topic+pipe_call_linter'></span>

<h3>Description</h3>

<p>Force explicit calls in magrittr pipes, e.g., <code>1:3 %&gt;% sum()</code> instead of <code>1:3 %&gt;% sum</code>.
Note that native pipe always requires a function call, i.e. <code style="white-space: pre;">&#8288;1:3 |&gt; sum&#8288;</code> will produce an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_call_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "1:3 %&gt;% mean %&gt;% as.character",
  linters = pipe_call_linter()
)

# okay
lint(
  text = "1:3 %&gt;% mean() %&gt;% as.character()",
  linters = pipe_call_linter()
)

</code></pre>

<hr>
<h2 id='pipe_consistency_linter'>Pipe consistency linter</h2><span id='topic+pipe_consistency_linter'></span>

<h3>Description</h3>

<p>Check that pipe operators are used consistently by file, or optionally
specify one valid pipe operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_consistency_linter(pipe = c("auto", "%&gt;%", "|&gt;"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pipe_consistency_linter_+3A_pipe">pipe</code></td>
<td>
<p>Which pipe operator is valid (either <code>"%&gt;%"</code> or <code>"|&gt;"</code>). By default
(<code>"auto"</code>), the linter has no preference but will check that each file uses
only one type of pipe operator.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "1:3 |&gt; mean() %&gt;% as.character()",
  linters = pipe_consistency_linter()
)

lint(
  text = "1:3 %&gt;% mean() %&gt;% as.character()",
  linters = pipe_consistency_linter("|&gt;")
)

# okay
lint(
  text = "1:3 %&gt;% mean() %&gt;% as.character()",
  linters = pipe_consistency_linter()
)

lint(
  text = "1:3 |&gt; mean() |&gt; as.character()",
  linters = pipe_consistency_linter()
)
</code></pre>

<hr>
<h2 id='pipe_continuation_linter'>Pipe continuation linter</h2><span id='topic+pipe_continuation_linter'></span>

<h3>Description</h3>

<p>Check that each step in a pipeline is on a new line, or the entire pipe fits on one line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_continuation_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/pipes.html#long-lines-2">https://style.tidyverse.org/pipes.html#long-lines-2</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code_lines &lt;- "1:3 %&gt;%\n mean() %&gt;% as.character()"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = pipe_continuation_linter()
)

code_lines &lt;- "1:3 |&gt; mean() |&gt;\n as.character()"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = pipe_continuation_linter()
)

# okay
lint(
  text = "1:3 %&gt;% mean() %&gt;% as.character()",
  linters = pipe_continuation_linter()
)

code_lines &lt;- "1:3 %&gt;%\n mean() %&gt;%\n as.character()"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = pipe_continuation_linter()
)

lint(
  text = "1:3 |&gt; mean() |&gt; as.character()",
  linters = pipe_continuation_linter()
)

code_lines &lt;- "1:3 |&gt;\n mean() |&gt;\n as.character()"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = pipe_continuation_linter()
)

</code></pre>

<hr>
<h2 id='pipe_return_linter'>Block usage of return() in magrittr pipelines</h2><span id='topic+pipe_return_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+return">return()</a></code> inside a magrittr pipeline does not actually execute <code>return()</code>
like you'd expect: <code style="white-space: pre;">&#8288;\(x) { x %&gt;% return(); FALSE }&#8288;</code> will return <code>FALSE</code>!
It will technically work &quot;as expected&quot; if this is the final statement
in the function body, but such usage is misleading. Instead, assign
the pipe outcome to a variable and return that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_return_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+common_mistakes_linters">common_mistakes</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "function(x) x %&gt;% return()",
  linters = pipe_return_linter()
)

# okay
code &lt;- "function(x) {\n  y &lt;- sum(x)\n  return(y)\n}"
writeLines(code)
lint(
  text = code,
  linters = pipe_return_linter()
)

</code></pre>

<hr>
<h2 id='pkg_testthat_linters'>Testthat linters</h2><span id='topic+pkg_testthat_linters'></span>

<h3>Description</h3>

<p>Linters encouraging best practices within testthat suites.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'pkg_testthat':
</p>

<ul>
<li><p><code><a href="#topic+conjunct_test_linter">conjunct_test_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_comparison_linter">expect_comparison_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_identical_linter">expect_identical_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_length_linter">expect_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_named_linter">expect_named_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_not_linter">expect_not_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_null_linter">expect_null_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_s3_class_linter">expect_s3_class_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_s4_class_linter">expect_s4_class_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_true_false_linter">expect_true_false_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_type_linter">expect_type_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+yoda_test_linter">yoda_test_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://testthat.r-lib.org">https://testthat.r-lib.org</a>
</p>
</li>
<li> <p><a href="https://r-pkgs.org/testing-basics.html">https://r-pkgs.org/testing-basics.html</a>
</p>
</li></ul>


<hr>
<h2 id='print_linter'>Block usage of print() for logging</h2><span id='topic+print_linter'></span>

<h3>Description</h3>

<p>The default print method for character vectors is appropriate for interactively inspecting objects,
not for logging messages. Thus checked-in usage like <code>print(paste('Data has', nrow(DF), 'rows.'))</code>
is better served by using <code><a href="base.html#topic+cat">cat()</a></code>, e.g. <code>cat(sprintf('Data has %d rows.\n', nrow(DF)))</code> (noting that
using <code>cat()</code> entails supplying your own line returns, and that <code><a href="glue.html#topic+glue">glue::glue()</a></code> might be preferable
to <code><a href="base.html#topic+sprintf">sprintf()</a></code> for constructing templated strings). Lastly, note that <code><a href="base.html#topic+message">message()</a></code> differs slightly
from <code>cat()</code> in that it prints to <code>stderr</code> by default, not <code>stdout</code>, but is still a good option
to consider for logging purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "print('a')",
  linters = print_linter()
)

lint(
  text = "print(paste(x, 'y'))",
  linters = print_linter()
)

# okay
lint(
  text = "print(x)",
  linters = print_linter()
)

</code></pre>

<hr>
<h2 id='quotes_linter'>Character string quote linter</h2><span id='topic+quotes_linter'></span>

<h3>Description</h3>

<p>Check that the desired quote delimiter is used for string constants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quotes_linter(delimiter = c("\"", "'"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quotes_linter_+3A_delimiter">delimiter</code></td>
<td>
<p>Which quote delimiter to accept. Defaults to the tidyverse
default of <code style="white-space: pre;">&#8288;"&#8288;</code> (double-quoted strings).</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#character-vectors">https://style.tidyverse.org/syntax.html#character-vectors</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "c('a', 'b')",
  linters = quotes_linter()
)

# okay
lint(
  text = 'c("a", "b")',
  linters = quotes_linter()
)

code_lines &lt;- "paste0(x, '\"this is fine\"')"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = quotes_linter()
)

# okay
lint(
  text = "c('a', 'b')",
  linters = quotes_linter(delimiter = "'")
)

</code></pre>

<hr>
<h2 id='read_settings'>Read lintr settings</h2><span id='topic+read_settings'></span>

<h3>Description</h3>

<p>Lintr searches for settings for a given source file in the following order:
</p>

<ol>
<li><p> options defined as <code>linter.setting</code>.
</p>
</li>
<li> <p><code>linter_file</code> in the same directory
</p>
</li>
<li> <p><code>linter_file</code> in the project directory
</p>
</li>
<li> <p><code>linter_file</code> in the user home directory
</p>
</li>
<li> <p><code><a href="#topic+default_settings">default_settings()</a></code>
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>read_settings(filename, call = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_settings_+3A_filename">filename</code></td>
<td>
<p>Source file to be linted.</p>
</td></tr>
<tr><td><code id="read_settings_+3A_call">call</code></td>
<td>
<p>Passed to malformed to ensure linear trace.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default linter_file name is <code>.lintr</code> but it can be changed with option <code>lintr.linter_file</code>
or the environment variable <code>R_LINTR_LINTER_FILE</code>
This file is a DCF file, see <code><a href="base.html#topic+dcf">base::read.dcf()</a></code> for details.
Here is an example of a <code>.lintr</code> file:
</p>
<div class="sourceCode"><pre>linters: linters_with_defaults(
    any_duplicated_linter(),
    any_is_na_linter(),
    backport_linter("oldrel-4", except = c("R_user_dir", "str2lang")),
    line_length_linter(120L),
    missing_argument_linter(),
    unnecessary_concatenation_linter(allow_single_expression = FALSE),
    yoda_test_linter()
  )
exclusions: list(
    "inst/doc/creating_linters.R" = 1,
    "inst/example/bad.R",
    "tests/testthat/default_linter_testcode.R",
    "tests/testthat/dummy_packages"
  )
</pre></div>
<p>Experimentally, we also support keeping the config in a plain R file. By default we look for
a file named <code>.lintr.R</code> (in the same directories where we search for <code>.lintr</code>).
We are still deciding the future of config support in lintr, so user feedback is welcome.
The advantage of R is that it maps more closely to how the configs are actually stored,
whereas the DCF approach requires somewhat awkward formatting of parseable R code within
valid DCF key-value pairs. The main disadvantage of the R file is it might be <em>too</em> flexible,
with users tempted to write configs with side effects causing hard-to-detect bugs or
like YAML could work, but require new dependencies and are harder to parse
both programmatically and visually.
Here is an example of a <code>.lintr.R</code> file:
</p>
<div class="sourceCode r"><pre>linters &lt;- linters_with_defaults(
    any_duplicated_linter(),
    any_is_na_linter(),
    backport_linter("oldrel-4", except = c("R_user_dir", "str2lang")),
    line_length_linter(120L),
    missing_argument_linter(),
    unnecessary_concatenation_linter(allow_single_expression = FALSE),
    yoda_test_linter()
  )
exclusions &lt;- list(
    "inst/doc/creating_linters.R" = 1,
    "inst/example/bad.R",
    "tests/testthat/default_linter_testcode.R",
    "tests/testthat/dummy_packages"
  )
</pre></div>

<hr>
<h2 id='readability_linters'>Readability linters</h2><span id='topic+readability_linters'></span>

<h3>Description</h3>

<p>Linters highlighting readability issues, such as missing whitespace.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'readability':
</p>

<ul>
<li><p><code><a href="#topic+boolean_arithmetic_linter">boolean_arithmetic_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+brace_linter">brace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+commas_linter">commas_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+commented_code_linter">commented_code_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+comparison_negation_linter">comparison_negation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+conjunct_test_linter">conjunct_test_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+consecutive_assertion_linter">consecutive_assertion_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+consecutive_mutate_linter">consecutive_mutate_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+cyclocomp_linter">cyclocomp_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+empty_assignment_linter">empty_assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_length_linter">expect_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_named_linter">expect_named_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_not_linter">expect_not_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+expect_true_false_linter">expect_true_false_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+fixed_regex_linter">fixed_regex_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+for_loop_index_linter">for_loop_index_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+function_left_parentheses_linter">function_left_parentheses_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+function_return_linter">function_return_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+if_not_else_linter">if_not_else_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+if_switch_linter">if_switch_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+implicit_assignment_linter">implicit_assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+indentation_linter">indentation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+infix_spaces_linter">infix_spaces_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+inner_combine_linter">inner_combine_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+is_numeric_linter">is_numeric_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+keyword_quote_linter">keyword_quote_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+length_levels_linter">length_levels_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+lengths_linter">lengths_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+library_call_linter">library_call_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+line_length_linter">line_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+matrix_apply_linter">matrix_apply_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nested_ifelse_linter">nested_ifelse_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nested_pipe_linter">nested_pipe_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+numeric_leading_zero_linter">numeric_leading_zero_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_length_linter">object_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_overwrite_linter">object_overwrite_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_usage_linter">object_usage_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+one_call_pipe_linter">one_call_pipe_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+outer_negation_linter">outer_negation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+paren_body_linter">paren_body_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_call_linter">pipe_call_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_consistency_linter">pipe_consistency_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_continuation_linter">pipe_continuation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+quotes_linter">quotes_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+redundant_equals_linter">redundant_equals_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+rep_len_linter">rep_len_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+repeat_linter">repeat_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+sample_int_linter">sample_int_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+scalar_in_linter">scalar_in_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+semicolon_linter">semicolon_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+sort_linter">sort_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+spaces_inside_linter">spaces_inside_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+spaces_left_parentheses_linter">spaces_left_parentheses_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+stopifnot_all_linter">stopifnot_all_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+string_boundary_linter">string_boundary_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+system_file_linter">system_file_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+T_and_F_symbol_linter">T_and_F_symbol_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_concatenation_linter">unnecessary_concatenation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_lambda_linter">unnecessary_lambda_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_nesting_linter">unnecessary_nesting_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_placeholder_linter">unnecessary_placeholder_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unreachable_code_linter">unreachable_code_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+which_grepl_linter">which_grepl_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+yoda_test_linter">yoda_test_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='redundant_equals_linter'>Block usage of <code>==</code>, <code>!=</code> on logical vectors</h2><span id='topic+redundant_equals_linter'></span>

<h3>Description</h3>

<p>Testing <code>x == TRUE</code> is redundant if <code>x</code> is a logical vector. Wherever this is
used to improve readability, the solution should instead be to improve the
naming of the object to better indicate that its contents are logical. This
can be done using prefixes (is, has, can, etc.). For example, <code>is_child</code>,
<code>has_parent_supervision</code>, <code>can_watch_horror_movie</code> clarify their logical
nature, while <code>child</code>, <code>parent_supervision</code>, <code>watch_horror_movie</code> don't.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redundant_equals_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+common_mistakes_linters">common_mistakes</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><code><a href="#topic+outer_negation_linter">outer_negation_linter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "if (any(x == TRUE)) 1",
  linters = redundant_equals_linter()
)

lint(
  text = "if (any(x != FALSE)) 0",
  linters = redundant_equals_linter()
)

lint(
  text = "dt[is_tall == FALSE, y]",
  linters = redundant_equals_linter()
)

# okay
lint(
  text = "if (any(x)) 1",
  linters = redundant_equals_linter()
)

lint(
  text = "if (!all(x)) 0",
  linters = redundant_equals_linter()
)

# in `{data.table}` semantics, `dt[x]` is a join, `dt[(x)]` is a subset
lint(
  text = "dt[(!is_tall), y]",
  linters = redundant_equals_linter()
)

</code></pre>

<hr>
<h2 id='redundant_ifelse_linter'>Prevent <code>ifelse()</code> from being used to produce <code>TRUE</code>/<code>FALSE</code> or <code>1</code>/<code>0</code></h2><span id='topic+redundant_ifelse_linter'></span>

<h3>Description</h3>

<p>Expressions like <code>ifelse(x, TRUE, FALSE)</code> and <code>ifelse(x, FALSE, TRUE)</code> are
redundant; just <code>x</code> or <code>!x</code> suffice in R code where logical vectors are a
core data structure. <code>ifelse(x, 1, 0)</code> is also <code>as.numeric(x)</code>, but even
this should be needed only rarely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redundant_ifelse_linter(allow10 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redundant_ifelse_linter_+3A_allow10">allow10</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, usage like
<code>ifelse(x, 1, 0)</code> is allowed, i.e., only usage like
<code>ifelse(x, TRUE, FALSE)</code> is linted.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+efficiency_linters">efficiency</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "ifelse(x &gt;= 2.5, TRUE, FALSE)",
  linters = redundant_ifelse_linter()
)

lint(
  text = "ifelse(x &lt; 2.5, 1L, 0L)",
  linters = redundant_ifelse_linter()
)

# okay
lint(
  text = "x &gt;= 2.5",
  linters = redundant_ifelse_linter()
)

# Note that this is just to show the strict equivalent of the example above;
# converting to integer is often unnecessary and the logical vector itself
# should suffice.
lint(
  text = "as.integer(x &lt; 2.5)",
  linters = redundant_ifelse_linter()
)

lint(
  text = "ifelse(x &lt; 2.5, 1L, 0L)",
  linters = redundant_ifelse_linter(allow10 = TRUE)
)

</code></pre>

<hr>
<h2 id='regex_linters'>Regular expression linters</h2><span id='topic+regex_linters'></span>

<h3>Description</h3>

<p>Linters that examine the usage of regular expressions and functions executing them in user code.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'regex':
</p>

<ul>
<li><p><code><a href="#topic+fixed_regex_linter">fixed_regex_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+regex_subset_linter">regex_subset_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+string_boundary_linter">string_boundary_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+which_grepl_linter">which_grepl_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='regex_subset_linter'>Require usage of direct methods for subsetting strings via regex</h2><span id='topic+regex_subset_linter'></span>

<h3>Description</h3>

<p>Using <code>value = TRUE</code> in <code><a href="base.html#topic+grep">grep()</a></code> returns the subset of the input that matches
the pattern, e.g. <code>grep("[a-m]", letters, value = TRUE)</code> will return the
first 13 elements (<code>a</code> through <code>m</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regex_subset_linter()
</code></pre>


<h3>Details</h3>

<p><code>letters[grep("[a-m]", letters)]</code> and <code>letters[grepl("[a-m]", letters)]</code>
both return the same thing, but more circuitously and more verbosely.
</p>
<p>The <code>stringr</code> package also provides an even more readable alternative,
namely <code>str_subset()</code>, which should be preferred to versions using
<code>str_detect()</code> and <code>str_which()</code>.
</p>


<h3>Exceptions</h3>

<p>Note that <code>x[grep(pattern, x)]</code> and <code>grep(pattern, x, value = TRUE)</code>
are not <em>completely</em> interchangeable when <code>x</code> is not character
(most commonly, when <code>x</code> is a factor), because the output of the
latter will be a character vector while the former remains a factor.
It still may be preferable to refactor such code, as it may be faster
to match the pattern on <code>levels(x)</code> and use that to subset instead.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+regex_linters">regex</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x[grep(pattern, x)]",
  linters = regex_subset_linter()
)

lint(
  text = "x[stringr::str_which(x, pattern)]",
  linters = regex_subset_linter()
)

# okay
lint(
  text = "grep(pattern, x, value = TRUE)",
  linters = regex_subset_linter()
)

lint(
  text = "stringr::str_subset(x, pattern)",
  linters = regex_subset_linter()
)

</code></pre>

<hr>
<h2 id='rep_len_linter'>Require usage of rep_len(x, n) over rep(x, length.out = n)</h2><span id='topic+rep_len_linter'></span>

<h3>Description</h3>

<p><code>rep(x, length.out = n)</code> calls <code>rep_len(x, n)</code> &quot;under the hood&quot;. The latter
is thus more direct and equally readable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_len_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "rep(1:3, length.out = 10)",
  linters = rep_len_linter()
)

# okay
lint(
  text = "rep_len(1:3, 10)",
  linters = rep_len_linter()
)

lint(
  text = "rep(1:3, each = 2L, length.out = 10L)",
  linters = rep_len_linter()
)

</code></pre>

<hr>
<h2 id='repeat_linter'>Repeat linter</h2><span id='topic+repeat_linter'></span>

<h3>Description</h3>

<p>Check that <code style="white-space: pre;">&#8288;while (TRUE)&#8288;</code> is not used for infinite loops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeat_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "while (TRUE) { }",
  linters = repeat_linter()
)


# okay
lint(
  text = "repeat { }",
  linters = repeat_linter()
)

</code></pre>

<hr>
<h2 id='return_linter'>Return linter</h2><span id='topic+return_linter'></span>

<h3>Description</h3>

<p>This linter checks functions' <code><a href="base.html#topic+return">return()</a></code> expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_linter(
  return_style = c("implicit", "explicit"),
  allow_implicit_else = TRUE,
  return_functions = NULL,
  except = NULL,
  except_regex = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="return_linter_+3A_return_style">return_style</code></td>
<td>
<p>Character string naming the return style. <code>"implicit"</code>,
the default, enforces the Tidyverse guide recommendation to leave terminal
returns implicit. <code>"explicit"</code> style requires that <code>return()</code> always be
explicitly supplied.</p>
</td></tr>
<tr><td><code id="return_linter_+3A_allow_implicit_else">allow_implicit_else</code></td>
<td>
<p>Logical, default <code>TRUE</code>. If <code>FALSE</code>, functions with a terminal
<code>if</code> clause must always have an <code style="white-space: pre;">&#8288;else&#8288;</code> clause, making the <code>NULL</code> alternative explicit
if necessary. Similarly, functions with terminal <code><a href="base.html#topic+switch">switch()</a></code> statements must have an
explicit default case.</p>
</td></tr>
<tr><td><code id="return_linter_+3A_return_functions">return_functions</code></td>
<td>
<p>Character vector of functions that are accepted as terminal calls
when <code>return_style = "explicit"</code>. These are in addition to exit functions
from base that are always allowed: <code><a href="base.html#topic+stop">stop()</a></code>, <code><a href="base.html#topic+q">q()</a></code>, <code><a href="base.html#topic+quit">quit()</a></code>, <code><a href="base.html#topic+invokeRestart">invokeRestart()</a></code>,
<code>tryInvokeRestart()</code>, <code><a href="base.html#topic+UseMethod">UseMethod()</a></code>, <code><a href="base.html#topic+NextMethod">NextMethod()</a></code>, <code><a href="base.html#topic+standardGeneric">standardGeneric()</a></code>,
<code><a href="methods.html#topic+callNextMethod">callNextMethod()</a></code>, <code><a href="base.html#topic+.C">.C()</a></code>, <code><a href="base.html#topic+.Call">.Call()</a></code>, <code><a href="base.html#topic+.External">.External()</a></code>, and <code><a href="base.html#topic+.Fortran">.Fortran()</a></code>.</p>
</td></tr>
<tr><td><code id="return_linter_+3A_except">except</code>, <code id="return_linter_+3A_except_regex">except_regex</code></td>
<td>
<p>Character vector of functions that are not checked when
<code>return_style = "explicit"</code>. These are in addition to namespace hook functions
that are never checked: <code>.onLoad()</code>, <code>.onUnload()</code>, <code>.onAttach()</code>, <code>.onDetach()</code>,
<code>.Last.lib()</code>, <code>.First()</code> and <code>.Last()</code>. <code>except</code> matches function names exactly,
while <code>except_regex</code> does exclusion by pattern matching with <code><a href="rex.html#topic+re_matches">rex::re_matches()</a></code>.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/functions.html?q=return#return">https://style.tidyverse.org/functions.html?q=return#return</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code &lt;- "function(x) {\n  return(x + 1)\n}"
writeLines(code)
lint(
  text = code,
  linters = return_linter()
)

code &lt;- "function(x) {\n  x + 1\n}"
writeLines(code)
lint(
  text = code,
  linters = return_linter(return_style = "explicit")
)

code &lt;- "function(x) {\n  if (x &gt; 0) 2\n}"
writeLines(code)
lint(
  text = code,
  linters = return_linter(allow_implicit_else = FALSE)
)

# okay
code &lt;- "function(x) {\n  x + 1\n}"
writeLines(code)
lint(
  text = code,
  linters = return_linter()
)

code &lt;- "function(x) {\n  return(x + 1)\n}"
writeLines(code)
lint(
  text = code,
  linters = return_linter(return_style = "explicit")
)

code &lt;- "function(x) {\n  if (x &gt; 0) 2 else NULL\n}"
writeLines(code)
lint(
  text = code,
  linters = return_linter(allow_implicit_else = FALSE)
)

</code></pre>

<hr>
<h2 id='robustness_linters'>Robustness linters</h2><span id='topic+robustness_linters'></span>

<h3>Description</h3>

<p>Linters highlighting code robustness issues, such as possibly wrong edge case behavior.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'robustness':
</p>

<ul>
<li><p><code><a href="#topic+absolute_path_linter">absolute_path_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+backport_linter">backport_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+class_equals_linter">class_equals_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+equals_na_linter">equals_na_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+for_loop_index_linter">for_loop_index_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+missing_package_linter">missing_package_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+namespace_linter">namespace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+nonportable_path_linter">nonportable_path_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_overwrite_linter">object_overwrite_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+routine_registration_linter">routine_registration_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+sample_int_linter">sample_int_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+seq_linter">seq_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+strings_as_factors_linter">strings_as_factors_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+T_and_F_symbol_linter">T_and_F_symbol_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+terminal_close_linter">terminal_close_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+undesirable_function_linter">undesirable_function_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+undesirable_operator_linter">undesirable_operator_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='routine_registration_linter'>Identify unregistered native routines</h2><span id='topic+routine_registration_linter'></span>

<h3>Description</h3>

<p>It is preferable to register routines for efficiency and safety.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>routine_registration_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Registering-native-routines">https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Registering-native-routines</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = '.Call("cpp_routine", PACKAGE = "mypkg")',
  linters = routine_registration_linter()
)

lint(
  text = '.Fortran("f_routine", PACKAGE = "mypkg")',
  linters = routine_registration_linter()
)

# okay
lint(
  text = ".Call(cpp_routine)",
  linters = routine_registration_linter()
)

lint(
  text = ".Fortran(f_routine)",
  linters = routine_registration_linter()
)

</code></pre>

<hr>
<h2 id='sample_int_linter'>Require usage of sample.int(n, m, ...) over sample(1:n, m, ...)</h2><span id='topic+sample_int_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+sample.int">sample.int()</a></code> is preferable to <code>sample()</code> for the case of sampling numbers
between 1 and <code>n</code>. <code>sample</code> calls <code>sample.int()</code> &quot;under the hood&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_int_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "sample(1:10, 2)",
  linters = sample_int_linter()
)

lint(
  text = "sample(seq(4), 2)",
  linters = sample_int_linter()
)

lint(
  text = "sample(seq_len(8), 2)",
  linters = sample_int_linter()
)

# okay
lint(
  text = "sample(seq(1, 5, by = 2), 2)",
  linters = sample_int_linter()
)

lint(
  text = "sample(letters, 2)",
  linters = sample_int_linter()
)

</code></pre>

<hr>
<h2 id='sarif_output'>SARIF Report for lint results</h2><span id='topic+sarif_output'></span>

<h3>Description</h3>

<p>Generate a report of the linting results using the <a href="https://sarifweb.azurewebsites.net/">SARIF</a> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarif_output(lints, filename = "lintr_results.sarif")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sarif_output_+3A_lints">lints</code></td>
<td>
<p>the linting results.</p>
</td></tr>
<tr><td><code id="sarif_output_+3A_filename">filename</code></td>
<td>
<p>the name of the output report</p>
</td></tr>
</table>

<hr>
<h2 id='scalar_in_linter'>Block usage like x %in% &quot;a&quot;</h2><span id='topic+scalar_in_linter'></span>

<h3>Description</h3>

<p><code>vector %in% set</code> is appropriate for matching a vector to a set, but if
that set has size 1, <code>==</code> is more appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalar_in_linter(in_operators = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scalar_in_linter_+3A_in_operators">in_operators</code></td>
<td>
<p>Character vector of additional infix operators that behave like the <code>%in%</code> operator,
e.g. <code>{data.table}</code>'s <code style="white-space: pre;">&#8288;%chin%&#8288;</code> operator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scalar %in% vector</code> is OK, because the alternative (<code>any(vector == scalar)</code>)
is more circuitous &amp; potentially less clear.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x %in% 1L",
  linters = scalar_in_linter()
)

lint(
  text = "x %chin% 'a'",
  linters = scalar_in_linter(in_operators = "%chin%")
)

# okay
lint(
  text = "x %in% 1:10",
  linters = scalar_in_linter()
)

</code></pre>

<hr>
<h2 id='semicolon_linter'>Semicolon linter</h2><span id='topic+semicolon_linter'></span>

<h3>Description</h3>

<p>Check that no semicolons terminate expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semicolon_linter(allow_compound = FALSE, allow_trailing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semicolon_linter_+3A_allow_compound">allow_compound</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, &quot;compound&quot;
semicolons (e.g. as in <code style="white-space: pre;">&#8288;x; y&#8288;</code>, i.e., on the same line of code) are allowed.</p>
</td></tr>
<tr><td><code id="semicolon_linter_+3A_allow_trailing">allow_trailing</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, &quot;trailing&quot;
semicolons (i.e., those that terminate lines of code) are allowed.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#semicolons">https://style.tidyverse.org/syntax.html#semicolons</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "a &lt;- 1;",
  linters = semicolon_linter()
)

lint(
  text = "a &lt;- 1; b &lt;- 1",
  linters = semicolon_linter()
)

lint(
  text = "function() { a &lt;- 1; b &lt;- 1 }",
  linters = semicolon_linter()
)

# okay
lint(
  text = "a &lt;- 1",
  linters = semicolon_linter()
)

lint(
  text = "a &lt;- 1;",
  linters = semicolon_linter(allow_trailing = TRUE)
)

code_lines &lt;- "a &lt;- 1\nb &lt;- 1"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = semicolon_linter()
)

lint(
  text = "a &lt;- 1; b &lt;- 1",
  linters = semicolon_linter(allow_compound = TRUE)
)

code_lines &lt;- "function() { \n  a &lt;- 1\n  b &lt;- 1\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = semicolon_linter()
)

</code></pre>

<hr>
<h2 id='seq_linter'>Sequence linter</h2><span id='topic+seq_linter'></span>

<h3>Description</h3>

<p>This linter checks for <code>1:length(...)</code>, <code>1:nrow(...)</code>, <code>1:ncol(...)</code>,
<code>1:NROW(...)</code> and <code>1:NCOL(...)</code> expressions in base-R, or their usage in
conjunction with <code>seq()</code> (e.g., <code>seq(length(...))</code>, <code>seq(nrow(...))</code>, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_linter()
</code></pre>


<h3>Details</h3>

<p>Additionally, it checks for <code>1:n()</code> (from <code>{dplyr}</code>) and <code>1:.N</code> (from <code>{data.table}</code>).
</p>
<p>These often cause bugs when the right-hand side is zero.
Instead, it is safer to use <code><a href="base.html#topic+seq">base::seq_len()</a></code> (to create a sequence of a specified <em>length</em>) or
<code><a href="base.html#topic+seq">base::seq_along()</a></code> (to create a sequence <em>along</em> an object).
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "seq(length(x))",
  linters = seq_linter()
)

lint(
  text = "1:nrow(x)",
  linters = seq_linter()
)

lint(
  text = "dplyr::mutate(x, .id = 1:n())",
  linters = seq_linter()
)

# okay
lint(
  text = "seq_along(x)",
  linters = seq_linter()
)

lint(
  text = "seq_len(nrow(x))",
  linters = seq_linter()
)

lint(
  text = "dplyr::mutate(x, .id = seq_len(n()))",
  linters = seq_linter()
)

</code></pre>

<hr>
<h2 id='sort_linter'>Check for common mistakes around sorting vectors</h2><span id='topic+sort_linter'></span>

<h3>Description</h3>

<p>This linter checks for some common mistakes when using <code><a href="base.html#topic+order">order()</a></code> or <code><a href="base.html#topic+sort">sort()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_linter()
</code></pre>


<h3>Details</h3>

<p>First, it requires usage of <code>sort()</code> over <code>.[order(.)]</code>.
</p>
<p><code><a href="base.html#topic+sort">sort()</a></code> is the dedicated option to sort a list or vector. It is more legible
and around twice as fast as <code>.[order(.)]</code>, with the gap in performance
growing with the vector size.
</p>
<p>Second, it requires usage of <code><a href="base.html#topic+is.unsorted">is.unsorted()</a></code> over equivalents using <code>sort()</code>.
</p>
<p>The base function <code>is.unsorted()</code> exists to test the sortedness of a vector.
Prefer it to inefficient and less-readable equivalents like
<code>x != sort(x)</code>. The same goes for checking <code>x == sort(x)</code> &ndash; use
<code>!is.unsorted(x)</code> instead.
</p>
<p>Moreover, use of <code>x == sort(x)</code> can be risky because <code><a href="base.html#topic+sort">sort()</a></code> drops missing
elements by default, meaning <code>==</code> might end up trying to compare vectors
of differing lengths.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x[order(x)]",
  linters = sort_linter()
)

lint(
  text = "x[order(x, decreasing = TRUE)]",
  linters = sort_linter()
)

lint(
  text = "sort(x) == x",
  linters = sort_linter()
)

# okay
lint(
  text = "x[sample(order(x))]",
  linters = sort_linter()
)

lint(
  text = "y[order(x)]",
  linters = sort_linter()
)

lint(
  text = "sort(x, decreasing = TRUE) == x",
  linters = sort_linter()
)

# If you are sorting several objects based on the order of one of them, such
# as:
x &lt;- sample(1:26)
y &lt;- letters
newx &lt;- x[order(x)]
newy &lt;- y[order(x)]
# This will be flagged by the linter. However, in this very specific case,
# it would be clearer and more efficient to run order() once and assign it
# to an object, rather than mix and match order() and sort()
index &lt;- order(x)
newx &lt;- x[index]
newy &lt;- y[index]

</code></pre>

<hr>
<h2 id='spaces_inside_linter'>Spaces inside linter</h2><span id='topic+spaces_inside_linter'></span>

<h3>Description</h3>

<p>Check that parentheses and square brackets do not have spaces directly
inside them, i.e., directly following an opening delimiter or directly
preceding a closing delimiter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spaces_inside_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#parentheses">https://style.tidyverse.org/syntax.html#parentheses</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "c( TRUE, FALSE )",
  linters = spaces_inside_linter()
)

lint(
  text = "x[ 1L ]",
  linters = spaces_inside_linter()
)

# okay
lint(
  text = "c(TRUE, FALSE)",
  linters = spaces_inside_linter()
)

lint(
  text = "x[1L]",
  linters = spaces_inside_linter()
)

</code></pre>

<hr>
<h2 id='spaces_left_parentheses_linter'>Spaces before parentheses linter</h2><span id='topic+spaces_left_parentheses_linter'></span>

<h3>Description</h3>

<p>Check that all left parentheses have a space before them unless they are in a function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spaces_left_parentheses_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#parentheses">https://style.tidyverse.org/syntax.html#parentheses</a>
</p>
</li>
<li> <p><code><a href="#topic+function_left_parentheses_linter">function_left_parentheses_linter()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "if(TRUE) x else y",
  linters = spaces_left_parentheses_linter()
)

# okay
lint(
  text = "if (TRUE) x else y",
  linters = spaces_left_parentheses_linter()
)

</code></pre>

<hr>
<h2 id='sprintf_linter'>Require correct <code>sprintf()</code> calls</h2><span id='topic+sprintf_linter'></span>

<h3>Description</h3>

<p>Check for an inconsistent number of arguments or arguments with incompatible types (for literal arguments) in
<code><a href="base.html#topic+sprintf">sprintf()</a></code> calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sprintf_linter()
</code></pre>


<h3>Details</h3>

<p><code><a href="base.html#topic+gettextf">gettextf()</a></code> calls are also included, since <code>gettextf()</code> is a thin wrapper around <code>sprintf()</code>.
</p>


<h3>Tags</h3>

<p><a href="#topic+common_mistakes_linters">common_mistakes</a>, <a href="#topic+correctness_linters">correctness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'sprintf("hello %s %s %d", x, y)',
  linters = sprintf_linter()
)

# okay
lint(
  text = 'sprintf("hello %s %s %d", x, y, z)',
  linters = sprintf_linter()
)

lint(
  text = 'sprintf("hello %s %s %d", x, y, ...)',
  linters = sprintf_linter()
)

</code></pre>

<hr>
<h2 id='stopifnot_all_linter'>Block usage of all() within stopifnot()</h2><span id='topic+stopifnot_all_linter'></span>

<h3>Description</h3>

<p><code>stopifnot(A)</code> actually checks <code>all(A)</code> &quot;under the hood&quot; if <code>A</code> is a vector,
and produces a better error message than <code>stopifnot(all(A))</code> does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopifnot_all_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "stopifnot(all(x &gt; 0))",
  linters = stopifnot_all_linter()
)

lint(
  text = "stopifnot(y &gt; 3, all(x &lt; 0))",
  linters = stopifnot_all_linter()
)

# okay
lint(
  text = "stopifnot(is.null(x) || all(x &gt; 0))",
  linters = stopifnot_all_linter()
)

lint(
  text = "assert_that(all(x &gt; 0))",
  linters = stopifnot_all_linter()
)

</code></pre>

<hr>
<h2 id='string_boundary_linter'>Require usage of <code>startsWith()</code> and <code>endsWith()</code> over <code>grepl()</code>/<code>substr()</code> versions</h2><span id='topic+string_boundary_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+startsWith">startsWith()</a></code> is used to detect fixed initial substrings; it is more
readable and more efficient than equivalents using <code><a href="base.html#topic+grepl">grepl()</a></code> or <code><a href="base.html#topic+substr">substr()</a></code>.
c.f. <code>startsWith(x, "abc")</code>, <code>grepl("^abc", x)</code>,
<code>substr(x, 1L, 3L) == "abc"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_boundary_linter(allow_grepl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="string_boundary_linter_+3A_allow_grepl">allow_grepl</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, usages with <code>grepl()</code>
are ignored. Some authors may prefer the conciseness offered by <code>grepl()</code> whereby
<code>NA</code> input maps to <code>FALSE</code> output, which doesn't have a direct equivalent
with <code>startsWith()</code> or <code>endsWith()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ditto for using <code><a href="base.html#topic+endsWith">endsWith()</a></code> to detect fixed terminal substrings.
</p>
<p>Note that there is a difference in behavior between how <code>grepl()</code> and <code>startsWith()</code>
(and <code>endsWith()</code>) handle missing values. In particular, for <code>grepl()</code>, <code>NA</code> inputs
are considered <code>FALSE</code>, while for <code>startsWith()</code>, <code>NA</code> inputs have <code>NA</code> outputs.
That means the strict equivalent of <code>grepl("^abc", x)</code> is
<code>!is.na(x) &amp; startsWith(x, "abc")</code>.
</p>
<p>We lint <code>grepl()</code> usages by default because the <code>!is.na()</code> version is more explicit
with respect to <code>NA</code> handling &ndash; though documented, the way <code>grepl()</code> handles
missing inputs may be surprising to some users.
</p>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+regex_linters">regex</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'grepl("^a", x)',
  linters = string_boundary_linter()
)

lint(
  text = 'grepl("z$", x)',
  linters = string_boundary_linter()
)

# okay
lint(
  text = 'startsWith(x, "a")',
  linters = string_boundary_linter()
)

lint(
  text = 'endsWith(x, "z")',
  linters = string_boundary_linter()
)

# If missing values are present, the suggested alternative wouldn't be strictly
# equivalent, so this linter can also be turned off in such cases.
lint(
  text = 'grepl("z$", x)',
  linters = string_boundary_linter(allow_grepl = TRUE)
)

</code></pre>

<hr>
<h2 id='strings_as_factors_linter'>Identify cases where <code>stringsAsFactors</code> should be supplied explicitly</h2><span id='topic+strings_as_factors_linter'></span>

<h3>Description</h3>

<p>Designed for code bases written for versions of R before 4.0 seeking to upgrade to R &gt;= 4.0, where
one of the biggest pain points will surely be the flipping of the
default value of <code>stringsAsFactors</code> from <code>TRUE</code> to <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strings_as_factors_linter()
</code></pre>


<h3>Details</h3>

<p>It's not always possible to tell statically whether the change will break
existing code because R is dynamically typed &ndash; e.g. in <code>data.frame(x)</code>
if <code>x</code> is a string, this code will be affected, but if <code>x</code> is a number,
this code will be unaffected. However, in <code>data.frame(x = "a")</code>, the
output will unambiguously be affected. We can instead supply
<code>stringsAsFactors = TRUE</code>, which will make this code backwards-compatible.
</p>
<p>See <a href="https://developer.r-project.org/Blog/public/2020/02/16/stringsasfactors/">https://developer.r-project.org/Blog/public/2020/02/16/stringsasfactors/</a>.
</p>


<h3>Tags</h3>

<p><a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'data.frame(x = "a")',
  linters = strings_as_factors_linter()
)

# okay
lint(
  text = 'data.frame(x = "a", stringsAsFactors = TRUE)',
  linters = strings_as_factors_linter()
)

lint(
  text = 'data.frame(x = "a", stringsAsFactors = FALSE)',
  linters = strings_as_factors_linter()
)

lint(
  text = "data.frame(x = 1.2)",
  linters = strings_as_factors_linter()
)

</code></pre>

<hr>
<h2 id='style_linters'>Style linters</h2><span id='topic+style_linters'></span>

<h3>Description</h3>

<p>Linters highlighting code style issues.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'style':
</p>

<ul>
<li><p><code><a href="#topic+assignment_linter">assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+brace_linter">brace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+commas_linter">commas_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+commented_code_linter">commented_code_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+condition_call_linter">condition_call_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+consecutive_assertion_linter">consecutive_assertion_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+cyclocomp_linter">cyclocomp_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+function_argument_linter">function_argument_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+function_left_parentheses_linter">function_left_parentheses_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+implicit_assignment_linter">implicit_assignment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+implicit_integer_linter">implicit_integer_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+indentation_linter">indentation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+infix_spaces_linter">infix_spaces_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+keyword_quote_linter">keyword_quote_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+library_call_linter">library_call_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+line_length_linter">line_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+numeric_leading_zero_linter">numeric_leading_zero_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_length_linter">object_length_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_name_linter">object_name_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+object_usage_linter">object_usage_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+one_call_pipe_linter">one_call_pipe_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+package_hooks_linter">package_hooks_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+paren_body_linter">paren_body_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_call_linter">pipe_call_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_consistency_linter">pipe_consistency_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+pipe_continuation_linter">pipe_continuation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+quotes_linter">quotes_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+repeat_linter">repeat_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+return_linter">return_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+semicolon_linter">semicolon_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+spaces_inside_linter">spaces_inside_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+spaces_left_parentheses_linter">spaces_left_parentheses_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+T_and_F_symbol_linter">T_and_F_symbol_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+todo_comment_linter">todo_comment_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+trailing_blank_lines_linter">trailing_blank_lines_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+trailing_whitespace_linter">trailing_whitespace_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+undesirable_function_linter">undesirable_function_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+undesirable_operator_linter">undesirable_operator_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+unnecessary_concatenation_linter">unnecessary_concatenation_linter</a></code>
</p>
</li>
<li><p><code><a href="#topic+whitespace_linter">whitespace_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>

<hr>
<h2 id='system_file_linter'>Block usage of <code>file.path()</code> with <code>system.file()</code></h2><span id='topic+system_file_linter'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+system.file">system.file()</a></code> has a <code>...</code> argument which, internally, is passed to
<code><a href="base.html#topic+file.path">file.path()</a></code>, so including it in user code is repetitive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>system_file_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = 'system.file(file.path("path", "to", "data"), package = "foo")',
  linters = system_file_linter()
)

lint(
  text = 'file.path(system.file(package = "foo"), "path", "to", "data")',
  linters = system_file_linter()
)

# okay
lint(
  text = 'system.file("path", "to", "data", package = "foo")',
  linters = system_file_linter()
)

</code></pre>

<hr>
<h2 id='T_and_F_symbol_linter'><code>T</code> and <code>F</code> symbol linter</h2><span id='topic+T_and_F_symbol_linter'></span>

<h3>Description</h3>

<p>Although they can be synonyms, avoid the symbols <code>T</code> and <code>F</code>, and use <code>TRUE</code> and <code>FALSE</code>, respectively, instead.
<code>T</code> and <code>F</code> are not reserved keywords and can be assigned to any other values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T_and_F_symbol_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+robustness_linters">robustness</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#logical-vectors">https://style.tidyverse.org/syntax.html#logical-vectors</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x &lt;- T; y &lt;- F",
  linters = T_and_F_symbol_linter()
)

lint(
  text = "T = 1.2; F = 2.4",
  linters = T_and_F_symbol_linter()
)

# okay
lint(
  text = "x &lt;- c(TRUE, FALSE)",
  linters = T_and_F_symbol_linter()
)

lint(
  text = "t = 1.2; f = 2.4",
  linters = T_and_F_symbol_linter()
)

</code></pre>

<hr>
<h2 id='terminal_close_linter'>Prohibit close() from terminating a function definition</h2><span id='topic+terminal_close_linter'></span>

<h3>Description</h3>

<p>Functions that end in <code>close(x)</code> are almost always better written by using
<code>on.exit(close(x))</code> close to where <code>x</code> is defined and/or opened.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terminal_close_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+robustness_linters">robustness</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code &lt;- paste(
  "f &lt;- function(fl) {",
  "  conn &lt;- file(fl, open = 'r')",
  "  readLines(conn)",
  "  close(conn)",
  "}",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = terminal_close_linter()
)

# okay
code &lt;- paste(
  "f &lt;- function(fl) {",
  "  conn &lt;- file(fl, open = 'r')",
  "  on.exit(close(conn))",
  "  readLines(conn)",
  "}",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = terminal_close_linter()
)

</code></pre>

<hr>
<h2 id='tidy_design_linters'>Tidyverse design linters</h2><span id='topic+tidy_design_linters'></span>

<h3>Description</h3>

<p>Linters based on guidelines described in the 'Tidy design principles' book.
</p>


<h3>Linters</h3>

<p>The following linters are tagged with 'tidy_design':
</p>

<ul>
<li><p><code><a href="#topic+condition_call_linter">condition_call_linter</a></code>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://design.tidyverse.org/">https://design.tidyverse.org/</a>
</p>
</li></ul>


<hr>
<h2 id='todo_comment_linter'>TODO comment linter</h2><span id='topic+todo_comment_linter'></span>

<h3>Description</h3>

<p>Check that the source contains no TODO comments (case-insensitive).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>todo_comment_linter(todo = c("todo", "fixme"), except_regex = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="todo_comment_linter_+3A_todo">todo</code></td>
<td>
<p>Vector of case-insensitive strings that identify TODO comments.</p>
</td></tr>
<tr><td><code id="todo_comment_linter_+3A_except_regex">except_regex</code></td>
<td>
<p>Vector of case-sensitive regular expressions that identify
<em>valid</em> TODO comments.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x + y # TOODOO",
  linters = todo_comment_linter(todo = "toodoo")
)

lint(
  text = "pi &lt;- 1.0 # FIIXMEE",
  linters = todo_comment_linter(todo = "fiixmee")
)

lint(
  text = "x &lt;- TRUE # TOODOO(#1234): Fix this hack.",
  linters = todo_comment_linter()
)

# okay
lint(
  text = "x + y # my informative comment",
  linters = todo_comment_linter()
)

lint(
  text = "pi &lt;- 3.14",
  linters = todo_comment_linter()
)

lint(
  text = "x &lt;- TRUE",
  linters = todo_comment_linter()
)

lint(
  text = "x &lt;- TRUE # TODO(#1234): Fix this hack.",
  linters = todo_comment_linter(except_regex = "TODO\\(#[0-9]+\\):")
)

</code></pre>

<hr>
<h2 id='trailing_blank_lines_linter'>Trailing blank lines linter</h2><span id='topic+trailing_blank_lines_linter'></span>

<h3>Description</h3>

<p>Check that there are no trailing blank lines in source code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trailing_blank_lines_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+default_linters">default</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
f &lt;- tempfile()
cat("x &lt;- 1\n\n", file = f)
writeLines(readChar(f, file.size(f)))
lint(
  filename = f,
  linters = trailing_blank_lines_linter()
)
unlink(f)

# okay
cat("x &lt;- 1\n", file = f)
writeLines(readChar(f, file.size(f)))
lint(
  filename = f,
  linters = trailing_blank_lines_linter()
)
unlink(f)

</code></pre>

<hr>
<h2 id='trailing_whitespace_linter'>Trailing whitespace linter</h2><span id='topic+trailing_whitespace_linter'></span>

<h3>Description</h3>

<p>Check that there are no space characters at the end of source lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trailing_whitespace_linter(allow_empty_lines = FALSE, allow_in_strings = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trailing_whitespace_linter_+3A_allow_empty_lines">allow_empty_lines</code></td>
<td>
<p>Suppress lints for lines that contain only whitespace.</p>
</td></tr>
<tr><td><code id="trailing_whitespace_linter_+3A_allow_in_strings">allow_in_strings</code></td>
<td>
<p>Suppress lints for trailing whitespace in string constants.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x &lt;- 1.2  ",
  linters = trailing_whitespace_linter()
)

code_lines &lt;- "a &lt;- TRUE\n \nb &lt;- FALSE"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = trailing_whitespace_linter()
)

# okay
lint(
  text = "x &lt;- 1.2",
  linters = trailing_whitespace_linter()
)

lint(
  text = "x &lt;- 1.2  # comment about this assignment",
  linters = trailing_whitespace_linter()
)

code_lines &lt;- "a &lt;- TRUE\n \nb &lt;- FALSE"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = trailing_whitespace_linter(allow_empty_lines = TRUE)
)

</code></pre>

<hr>
<h2 id='undesirable_function_linter'>Undesirable function linter</h2><span id='topic+undesirable_function_linter'></span>

<h3>Description</h3>

<p>Report the use of undesirable functions and suggest an alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undesirable_function_linter(
  fun = default_undesirable_functions,
  symbol_is_undesirable = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="undesirable_function_linter_+3A_fun">fun</code></td>
<td>
<p>Named character vector. <code>names(fun)</code> correspond to undesirable functions,
while the values give a description of why the function is undesirable.
If <code>NA</code>, no additional information is given in the lint message. Defaults to
<a href="#topic+default_undesirable_functions">default_undesirable_functions</a>. To make small customizations to this list,
use <code><a href="#topic+modify_defaults">modify_defaults()</a></code>.</p>
</td></tr>
<tr><td><code id="undesirable_function_linter_+3A_symbol_is_undesirable">symbol_is_undesirable</code></td>
<td>
<p>Whether to consider the use of an undesirable function
name as a symbol undesirable or not.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+robustness_linters">robustness</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># defaults for which functions are considered undesirable
names(default_undesirable_functions)

# will produce lints
lint(
  text = "sapply(x, mean)",
  linters = undesirable_function_linter()
)

lint(
  text = "log10(x)",
  linters = undesirable_function_linter(fun = c("log10" = NA))
)

lint(
  text = "log10(x)",
  linters = undesirable_function_linter(fun = c("log10" = "use log()"))
)

lint(
  text = 'dir &lt;- "path/to/a/directory"',
  linters = undesirable_function_linter(fun = c("dir" = NA))
)

# okay
lint(
  text = "vapply(x, mean, FUN.VALUE = numeric(1))",
  linters = undesirable_function_linter()
)

lint(
  text = "log(x, base = 10)",
  linters = undesirable_function_linter(fun = c("log10" = "use log()"))
)

lint(
  text = 'dir &lt;- "path/to/a/directory"',
  linters = undesirable_function_linter(fun = c("dir" = NA), symbol_is_undesirable = FALSE)
)

</code></pre>

<hr>
<h2 id='undesirable_operator_linter'>Undesirable operator linter</h2><span id='topic+undesirable_operator_linter'></span>

<h3>Description</h3>

<p>Report the use of undesirable operators, e.g. <code><a href="base.html#topic+ns-dblcolon">:::</a></code> or
<code><a href="base.html#topic+assignOps">&lt;&lt;-</a></code> and suggest an alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undesirable_operator_linter(op = default_undesirable_operators)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="undesirable_operator_linter_+3A_op">op</code></td>
<td>
<p>Named character vector. <code>names(op)</code> correspond to undesirable operators,
while the values give a description of why the operator is undesirable.
If <code>NA</code>, no additional information is given in the lint message. Defaults to
<a href="#topic+default_undesirable_operators">default_undesirable_operators</a>. To make small customizations to this list,
use <code><a href="#topic+modify_defaults">modify_defaults()</a></code>.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+robustness_linters">robustness</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># defaults for which functions are considered undesirable
names(default_undesirable_operators)

# will produce lints
lint(
  text = "a &lt;&lt;- log(10)",
  linters = undesirable_operator_linter()
)

lint(
  text = "mtcars$wt",
  linters = undesirable_operator_linter(op = c("$" = "As an alternative, use the `[[` accessor."))
)

# okay
lint(
  text = "a &lt;- log(10)",
  linters = undesirable_operator_linter()
)
lint(
  text = 'mtcars[["wt"]]',
  linters = undesirable_operator_linter(op = c("$" = NA))
)

lint(
  text = 'mtcars[["wt"]]',
  linters = undesirable_operator_linter(op = c("$" = "As an alternative, use the `[[` accessor."))
)

</code></pre>

<hr>
<h2 id='unnecessary_concatenation_linter'>Unneeded concatenation linter</h2><span id='topic+unnecessary_concatenation_linter'></span>

<h3>Description</h3>

<p>Check that the <code><a href="base.html#topic+c">c()</a></code> function is not used without arguments nor with a single constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnecessary_concatenation_linter(allow_single_expression = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unnecessary_concatenation_linter_+3A_allow_single_expression">allow_single_expression</code></td>
<td>
<p>Logical, default <code>TRUE</code>. If <code>FALSE</code>, one-expression
usages of <code>c()</code> are always linted, e.g. <code>c(x)</code> and <code>c(matrix(...))</code>. In some such
cases, <code>c()</code> is being used for its side-effect of stripping non-name attributes;
it is usually preferable to use the more readable <code><a href="base.html#topic+as.vector">as.vector()</a></code> instead.
<code><a href="base.html#topic+as.vector">as.vector()</a></code> is not always preferable, for example with environments
(especially, <code>R6</code> objects), in which case <code>list()</code> is the better alternative.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+configurable_linters">configurable</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x &lt;- c()",
  linters = unnecessary_concatenation_linter()
)

lint(
  text = "x &lt;- c(TRUE)",
  linters = unnecessary_concatenation_linter()
)

lint(
  text = "x &lt;- c(1.5 + 2.5)",
  linters = unnecessary_concatenation_linter(allow_single_expression = FALSE)
)

# okay
lint(
  text = "x &lt;- NULL",
  linters = unnecessary_concatenation_linter()
)

# In case the intent here was to seed a vector of known size
lint(
  text = "x &lt;- integer(4L)",
  linters = unnecessary_concatenation_linter()
)

lint(
  text = "x &lt;- TRUE",
  linters = unnecessary_concatenation_linter()
)

lint(
  text = "x &lt;- c(1.5 + 2.5)",
  linters = unnecessary_concatenation_linter(allow_single_expression = TRUE)
)

</code></pre>

<hr>
<h2 id='unnecessary_lambda_linter'>Block usage of anonymous functions in iteration functions when unnecessary</h2><span id='topic+unnecessary_lambda_linter'></span>

<h3>Description</h3>

<p>Using an anonymous function in, e.g., <code><a href="base.html#topic+lapply">lapply()</a></code> is not always necessary,
e.g. <code>lapply(DF, sum)</code> is the same as <code>lapply(DF, function(x) sum(x))</code> and
the former is more readable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnecessary_lambda_linter(allow_comparison = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unnecessary_lambda_linter_+3A_allow_comparison">allow_comparison</code></td>
<td>
<p>Logical, default <code>FALSE</code>. If <code>TRUE</code>, lambdas like
<code>function(x) foo(x) == 2</code>, where <code>foo</code> can be extracted to the &quot;mapping&quot;
function and <code>==</code> vectorized instead of called repeatedly, are linted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cases like <code style="white-space: pre;">&#8288;lapply(x, \(xi) grep("ptn", xi))&#8288;</code> are excluded because, though
the anonymous function <em>can</em> be avoided, doing so is not always more
readable.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "lapply(list(1:3, 2:4), function(xi) sum(xi))",
  linters = unnecessary_lambda_linter()
)

lint(
  text = "sapply(x, function(xi) xi == 2)",
  linters = unnecessary_lambda_linter()
)

lint(
  text = "sapply(x, function(xi) sum(xi) &gt; 0)",
  linters = unnecessary_lambda_linter()
)

# okay
lint(
  text = "lapply(list(1:3, 2:4), sum)",
  linters = unnecessary_lambda_linter()
)

lint(
  text = 'lapply(x, function(xi) grep("ptn", xi))',
  linters = unnecessary_lambda_linter()
)

lint(
  text = "lapply(x, function(xi) data.frame(col = xi))",
  linters = unnecessary_lambda_linter()
)

lint(
  text = "sapply(x, function(xi) xi == 2)",
  linters = unnecessary_lambda_linter(allow_comparison = TRUE)
)

lint(
  text = "sapply(x, function(xi) sum(xi) &gt; 0)",
  linters = unnecessary_lambda_linter(allow_comparison = TRUE)
)

lint(
  text = "sapply(x, function(xi) sum(abs(xi)) &gt; 10)",
  linters = unnecessary_lambda_linter()
)

lint(
  text = "sapply(x, sum) &gt; 0",
  linters = unnecessary_lambda_linter()
)

</code></pre>

<hr>
<h2 id='unnecessary_nesting_linter'>Block instances of unnecessary nesting</h2><span id='topic+unnecessary_nesting_linter'></span>

<h3>Description</h3>

<p>Excessive nesting harms readability. Use helper functions or early returns
to reduce nesting wherever possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnecessary_nesting_linter(
  allow_assignment = TRUE,
  allow_functions = c("switch", "try", "tryCatch", "withCallingHandlers", "quote",
    "expression", "bquote", "substitute", "with_parameters_test_that", "reactive",
    "observe", "observeEvent", "renderCachedPlot", "renderDataTable", "renderImage",
    "renderPlot", "renderPrint", "renderTable", "renderText", "renderUI"),
  branch_exit_calls = character()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unnecessary_nesting_linter_+3A_allow_assignment">allow_assignment</code></td>
<td>
<p>Logical, default <code>TRUE</code>, in which case
braced expressions consisting only of a single assignment are skipped.
if <code>FALSE</code>, all braced expressions with only one child expression are linted.
The <code>TRUE</code> case facilitates interaction with <code><a href="#topic+implicit_assignment_linter">implicit_assignment_linter()</a></code>
for certain cases where an implicit assignment is necessary, so a braced
assignment is used to further distinguish the assignment. See examples.</p>
</td></tr>
<tr><td><code id="unnecessary_nesting_linter_+3A_allow_functions">allow_functions</code></td>
<td>
<p>Character vector of functions which always allow
one-child braced expressions. <code>testthat::test_that()</code> is always allowed because
testthat requires a braced expression in its <code>code</code> argument. The other defaults
similarly compute on expressions in a way which is worth highlighting by
em-bracing them, even if there is only one expression, while <code><a href="base.html#topic+switch">switch()</a></code> is allowed
for its use as a control flow analogous to <code>if</code>/<code style="white-space: pre;">&#8288;else&#8288;</code>.]</p>
</td></tr>
<tr><td><code id="unnecessary_nesting_linter_+3A_branch_exit_calls">branch_exit_calls</code></td>
<td>
<p>Character vector of functions which are considered
as &quot;exiting&quot; a branch for the purpose of recommending removing nesting in a branch
<em>lacking</em> an exit call when the other branch terminates with one. Calls which
always interrupt or quit the current call or R session,
e.g. <code><a href="base.html#topic+stop">stop()</a></code> and <code><a href="base.html#topic+q">q()</a></code>, are always included.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+consistency_linters">consistency</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+cyclocomp_linter">cyclocomp_linter()</a></code> for another linter that penalizes overly complex code.
</p>
</li>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code &lt;- "if (A) {\n  stop('A is bad!')\n} else {\n  do_good()\n}"
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter()
)

code &lt;- "tryCatch(\n  {\n    foo()\n  },\n  error = identity\n)"
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter()
)

code &lt;- "expect_warning(\n  {\n    x &lt;- foo()\n  },\n  'warned'\n)"
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter(allow_assignment = FALSE)
)

code &lt;- "if (x) { \n  if (y) { \n   return(1L) \n  } \n}"
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter()
)

lint(
  text = "my_quote({x})",
  linters = unnecessary_nesting_linter()
)

code &lt;- paste(
  "if (A) {",
  "  stop('A is bad because a.')",
  "} else {",
  "  warning('!A requires caution.')",
  "}",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter()
)

# okay
code &lt;- "if (A) {\n  stop('A is bad because a.')\n} else {\n  stop('!A is bad too.')\n}"
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter()
)

code &lt;- "capture.output({\n  foo()\n})"
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter()
)

code &lt;- "expect_warning(\n  {\n    x &lt;- foo()\n  },\n  'warned'\n)"
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter()
)

code &lt;- "if (x &amp;&amp; y) { \n  return(1L) \n}"
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter()
)

code &lt;- "if (x) { \n  y &lt;- x + 1L\n  if (y) { \n   return(1L) \n  } \n}"
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter()
)

lint(
  text = "my_quote({x})",
  linters = unnecessary_nesting_linter(allow_functions = "my_quote")
)

code &lt;- paste(
  "if (A) {",
  "  stop('A is bad because a.')",
  "} else {",
  "  warning('!A requires caution.')",
  "}",
  sep = "\n"
)
writeLines(code)
lint(
  text = code,
  linters = unnecessary_nesting_linter(branch_exit_calls = c("stop", "warning"))
)

</code></pre>

<hr>
<h2 id='unnecessary_placeholder_linter'>Block usage of pipeline placeholders if unnecessary</h2><span id='topic+unnecessary_placeholder_linter'></span>

<h3>Description</h3>

<p>The argument placeholder <code>.</code> in magrittr pipelines is unnecessary if
passed as the first positional argument; using it can cause confusion
and impacts readability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnecessary_placeholder_linter()
</code></pre>


<h3>Details</h3>

<p>This is true for forward (<code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>), assignment (<code style="white-space: pre;">&#8288;%&lt;&gt;%&#8288;</code>), and tee (<code style="white-space: pre;">&#8288;%T&gt;%&#8288;</code>) operators.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "x %&gt;% sum(., na.rm = TRUE)",
  linters = unnecessary_placeholder_linter()
)

# okay
lint(
  text = "x %&gt;% sum(na.rm = TRUE)",
  linters = unnecessary_placeholder_linter()
)

lint(
  text = "x %&gt;% lm(data = ., y ~ z)",
  linters = unnecessary_placeholder_linter()
)

lint(
  text = "x %&gt;% outer(., .)",
  linters = unnecessary_placeholder_linter()
)

</code></pre>

<hr>
<h2 id='unreachable_code_linter'>Block unreachable code and comments following return statements</h2><span id='topic+unreachable_code_linter'></span>

<h3>Description</h3>

<p>Code after e.g. a <code><a href="base.html#topic+return">return()</a></code> or <code><a href="base.html#topic+stop">stop()</a></code>
or in deterministically false conditional loops like <code style="white-space: pre;">&#8288;if (FALSE)&#8288;</code> can't be reached;
typically this is vestigial code left after refactoring or sandboxing code, which
is fine for exploration, but shouldn't ultimately be checked in. Comments
meant for posterity should be placed <em>before</em> the final <code>return()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unreachable_code_linter(
  allow_comment_regex = getOption("covr.exclude_end", "# nocov end")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unreachable_code_linter_+3A_allow_comment_regex">allow_comment_regex</code></td>
<td>
<p>Character vector of regular expressions which identify
comments to exclude when finding unreachable terminal comments. By default, this
includes the default &quot;skip region&quot; end marker for <code>{covr}</code>
(option &quot;covr.exclude_end&quot;, or <code>"# nocov end"</code> if unset).
The end marker for <code>{lintr}</code> (<code>settings$exclude_end</code>) is always included.
Note that the regexes should include the initial comment character <code style="white-space: pre;">&#8288;#&#8288;</code>.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code_lines &lt;- "f &lt;- function() {\n  return(1 + 1)\n  2 + 2\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unreachable_code_linter()
)

code_lines &lt;- "if (FALSE) {\n 2 + 2\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unreachable_code_linter()
)

code_lines &lt;- "while (FALSE) {\n 2 + 2\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unreachable_code_linter()
)

code_lines &lt;- "f &lt;- function() {\n  return(1)\n  # end skip\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unreachable_code_linter()
)

# okay
code_lines &lt;- "f &lt;- function() {\n  return(1 + 1)\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unreachable_code_linter()
)

code_lines &lt;- "if (foo) {\n 2 + 2\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unreachable_code_linter()
)

code_lines &lt;- "while (foo) {\n 2 + 2\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unreachable_code_linter()
)

code_lines &lt;- "f &lt;- function() {\n  return(1)\n  # end skip\n}"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unreachable_code_linter(allow_comment_regex = "# end skip")
)

</code></pre>

<hr>
<h2 id='unused_import_linter'>Check that imported packages are actually used</h2><span id='topic+unused_import_linter'></span>

<h3>Description</h3>

<p>Check that imported packages are actually used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unused_import_linter(
  allow_ns_usage = FALSE,
  except_packages = c("bit64", "data.table", "tidyverse"),
  interpret_glue = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unused_import_linter_+3A_allow_ns_usage">allow_ns_usage</code></td>
<td>
<p>Suppress lints for packages only used via namespace.
This is <code>FALSE</code> by default because <code>pkg::fun()</code> doesn't require <code>library(pkg)</code>.
You can use <a href="base.html#topic+requireNamespace">requireNamespace(&quot;pkg&quot;)</a> to ensure a package is
installed without attaching it.</p>
</td></tr>
<tr><td><code id="unused_import_linter_+3A_except_packages">except_packages</code></td>
<td>
<p>Character vector of packages that are ignored.
These are usually attached for their side effects.</p>
</td></tr>
<tr><td><code id="unused_import_linter_+3A_interpret_glue">interpret_glue</code></td>
<td>
<p>If <code>TRUE</code>, interpret <code><a href="glue.html#topic+glue">glue::glue()</a></code> calls to avoid false positives caused by local variables
which are only used in a glue expression.</p>
</td></tr>
</table>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+common_mistakes_linters">common_mistakes</a>, <a href="#topic+configurable_linters">configurable</a>, <a href="#topic+executing_linters">executing</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
code_lines &lt;- "library(dplyr)\n1 + 1"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unused_import_linter()
)

code_lines &lt;- "library(dplyr)\ndplyr::tibble(a = 1)"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unused_import_linter()
)

# okay
code_lines &lt;- "library(dplyr)\ntibble(a = 1)"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unused_import_linter()
)

code_lines &lt;- "library(dplyr)\ndplyr::tibble(a = 1)"
writeLines(code_lines)
lint(
  text = code_lines,
  linters = unused_import_linter(allow_ns_usage = TRUE)
)

</code></pre>

<hr>
<h2 id='use_lintr'>Use lintr in your project</h2><span id='topic+use_lintr'></span>

<h3>Description</h3>

<p>Create a minimal lintr config file as a starting point for customization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_lintr(path = ".", type = c("tidyverse", "full"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_lintr_+3A_path">path</code></td>
<td>
<p>Path to project root, where a <code>.lintr</code> file should be created.
If the <code>.lintr</code> file already exists, an error will be thrown.</p>
</td></tr>
<tr><td><code id="use_lintr_+3A_type">type</code></td>
<td>
<p>What kind of configuration to create?
</p>

<ul>
<li> <p><code>tidyverse</code> creates a minimal lintr config, based on the default linters (<code><a href="#topic+linters_with_defaults">linters_with_defaults()</a></code>).
These are suitable for following <a href="https://style.tidyverse.org/">the tidyverse style guide</a>.
</p>
</li>
<li> <p><code>full</code> creates a lintr config using all available linters via <code><a href="#topic+all_linters">all_linters()</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to the generated configuration, invisibly.
</p>


<h3>See Also</h3>

<p><code>vignette("lintr")</code> for detailed introduction to using and configuring lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (FALSE) {
  # use the default set of linters
  lintr::use_lintr()
  # or try all linters
  lintr::use_lintr(type = "full")

  # then
  lintr::lint_dir()
}
</code></pre>

<hr>
<h2 id='vector_logic_linter'>Enforce usage of scalar logical operators in conditional statements</h2><span id='topic+vector_logic_linter'></span>

<h3>Description</h3>

<p>Usage of <code>&amp;</code> in conditional statements is error-prone and inefficient.
<code>condition</code> in <code>if (condition) expr</code> must always be of length 1, in which
case <code>&amp;&amp;</code> is to be preferred. Ditto for <code>|</code> vs. <code>||</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_logic_linter()
</code></pre>


<h3>Details</h3>

<p>This linter covers inputs to <code style="white-space: pre;">&#8288;if()&#8288;</code> and <code style="white-space: pre;">&#8288;while()&#8288;</code> conditions and to
<code><a href="testthat.html#topic+logical-expectations">testthat::expect_true()</a></code> and <code><a href="testthat.html#topic+logical-expectations">testthat::expect_false()</a></code>.
</p>
<p>Note that because <code>&amp;</code> and <code>|</code> are generics, it is possible that
<code>&amp;&amp;</code> / <code>||</code> are not perfect substitutes because <code>&amp;</code> is doing
method dispatch in an incompatible way.
</p>
<p>Moreover, be wary of code that may have side effects, most commonly
assignments. Consider <code>if ((a &lt;- foo(x)) | (b &lt;- bar(y))) { ... }</code>
vs. <code>if ((a &lt;- foo(x)) || (b &lt;- bar(y))) { ... }</code>. Because <code>||</code> exits
early, if <code>a</code> is <code>TRUE</code>,  the second condition will never be evaluated
and <code>b</code> will not be assigned. Such usage is not allowed by the Tidyverse
style guide, and the code can easily be refactored by pulling the
assignment outside the condition, so using <code>||</code> is still preferable.
</p>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+common_mistakes_linters">common_mistakes</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+efficiency_linters">efficiency</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>
</li>
<li> <p><a href="https://style.tidyverse.org/syntax.html#if-statements">https://style.tidyverse.org/syntax.html#if-statements</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "if (TRUE &amp; FALSE) 1",
  linters = vector_logic_linter()
)

lint(
  text = "if (TRUE &amp;&amp; (TRUE | FALSE)) 4",
  linters = vector_logic_linter()
)

lint(
  text = "filter(x, A &amp;&amp; B)",
  linters = vector_logic_linter()
)

# okay
lint(
  text = "if (TRUE &amp;&amp; FALSE) 1",
  linters = vector_logic_linter()
)

lint(
  text = "if (TRUE &amp;&amp; (TRUE || FALSE)) 4",
  linters = vector_logic_linter()
)

lint(
  text = "filter(x, A &amp; B)",
  linters = vector_logic_linter()
)

</code></pre>

<hr>
<h2 id='which_grepl_linter'>Require usage of grep over which(grepl(.))</h2><span id='topic+which_grepl_linter'></span>

<h3>Description</h3>

<p><code>which(grepl(pattern, x))</code> is the same as <code>grep(pattern, x)</code>, but harder
to read and requires two passes over the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_grepl_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+consistency_linters">consistency</a>, <a href="#topic+efficiency_linters">efficiency</a>, <a href="#topic+readability_linters">readability</a>, <a href="#topic+regex_linters">regex</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "which(grepl('^a', x))",
  linters = which_grepl_linter()
)

# okay
lint(
  text = "which(grepl('^a', x) | grepl('^b', x))",
  linters = which_grepl_linter()
)

</code></pre>

<hr>
<h2 id='whitespace_linter'>Whitespace linter</h2><span id='topic+whitespace_linter'></span>

<h3>Description</h3>

<p>Check that the correct character is used for indentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whitespace_linter()
</code></pre>


<h3>Details</h3>

<p>Currently, only supports linting in the presence of tabs.
</p>
<p>Much ink has been spilled on this topic, and we encourage you to check
out references for more information.
</p>


<h3>Tags</h3>

<p><a href="#topic+consistency_linters">consistency</a>, <a href="#topic+default_linters">default</a>, <a href="#topic+style_linters">style</a>
</p>


<h3>References</h3>


<ul>
<li><p> https://www.jwz.org/doc/tabs-vs-spaces.html
</p>
</li>
<li><p> https://blog.codinghorror.com/death-to-the-space-infidels/
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "\tx",
  linters = whitespace_linter()
)

# okay
lint(
  text = "  x",
  linters = whitespace_linter()
)

</code></pre>

<hr>
<h2 id='xml_nodes_to_lints'>Convert an XML node or nodeset into a Lint</h2><span id='topic+xml_nodes_to_lints'></span>

<h3>Description</h3>

<p>Convenience function for converting nodes matched by XPath-based
linter logic into a <code><a href="#topic+Lint">Lint()</a></code> object to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_nodes_to_lints(
  xml,
  source_expression,
  lint_message,
  type = c("style", "warning", "error"),
  column_number_xpath = range_start_xpath,
  range_start_xpath = "number(./@col1)",
  range_end_xpath = "number(./@col2)"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xml_nodes_to_lints_+3A_xml">xml</code></td>
<td>
<p>An <code>xml_node</code> object (to generate one <code>Lint</code>) or an
<code>xml_nodeset</code> object (to generate several <code>Lint</code>s), e.g. as returned by
<code><a href="xml2.html#topic+xml_find_all">xml2::xml_find_all()</a></code> or <code><a href="xml2.html#topic+xml_find_all">xml2::xml_find_first()</a></code> or a
list of <code>xml_node</code> objects.</p>
</td></tr>
<tr><td><code id="xml_nodes_to_lints_+3A_source_expression">source_expression</code></td>
<td>
<p>A source expression object, e.g. as
returned typically by <code><a href="#topic+lint">lint()</a></code>, or more generally
by <code><a href="#topic+get_source_expressions">get_source_expressions()</a></code>.</p>
</td></tr>
<tr><td><code id="xml_nodes_to_lints_+3A_lint_message">lint_message</code></td>
<td>
<p>The message to be included as the <code>message</code>
to the <code>Lint</code> object. If <code>lint_message</code> is a character vector the same length as <code>xml</code>,
the <code>i</code>-th lint will be given the <code>i</code>-th message.</p>
</td></tr>
<tr><td><code id="xml_nodes_to_lints_+3A_type">type</code></td>
<td>
<p>type of lint.</p>
</td></tr>
<tr><td><code id="xml_nodes_to_lints_+3A_column_number_xpath">column_number_xpath</code></td>
<td>
<p>XPath expression to return the column number location of the lint.
Defaults to the start of the range matched by <code>range_start_xpath</code>. See details for more information.</p>
</td></tr>
<tr><td><code id="xml_nodes_to_lints_+3A_range_start_xpath">range_start_xpath</code></td>
<td>
<p>XPath expression to return the range start location of the lint.
Defaults to the start of the expression matched by <code>xml</code>. See details for more information.</p>
</td></tr>
<tr><td><code id="xml_nodes_to_lints_+3A_range_end_xpath">range_end_xpath</code></td>
<td>
<p>XPath expression to return the range end location of the lint.
Defaults to the end of the expression matched by <code>xml</code>. See details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The location XPaths, <code>column_number_xpath</code>, <code>range_start_xpath</code> and <code>range_end_xpath</code> are evaluated using
<code><a href="xml2.html#topic+xml_find_all">xml2::xml_find_num()</a></code> and will usually be of the form <code>"number(./relative/xpath)"</code>.
Note that the location line number cannot be changed and lints spanning multiple lines will ignore <code>range_end_xpath</code>.
<code>column_number_xpath</code> and <code>range_start_xpath</code> are assumed to always refer to locations on the starting line of the
<code>xml</code> node.
</p>


<h3>Value</h3>

<p>For <code>xml_node</code>s, a <code>lint</code>. For <code>xml_nodeset</code>s, <code>lints</code> (a list of <code>lint</code>s).
</p>

<hr>
<h2 id='xp_call_name'>Get the name of the function matched by an XPath</h2><span id='topic+xp_call_name'></span>

<h3>Description</h3>

<p>Often, it is more helpful to tailor the <code>message</code> of a lint to record
which function was matched by the lint logic. This function encapsulates
the logic to pull out the matched call in common situations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xp_call_name(expr, depth = 1L, condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xp_call_name_+3A_expr">expr</code></td>
<td>
<p>An <code>xml_node</code> or <code>xml_nodeset</code>, e.g. from <code><a href="xml2.html#topic+xml_find_all">xml2::xml_find_all()</a></code>.</p>
</td></tr>
<tr><td><code id="xp_call_name_+3A_depth">depth</code></td>
<td>
<p>Integer, default <code>1L</code>. How deep in the AST represented by <code>expr</code>
should we look to find the call? By default, we assume <code>expr</code> is matched
to an <code style="white-space: pre;">&#8288;&lt;expr&gt;&#8288;</code> node under which the corresponding <code style="white-space: pre;">&#8288;&lt;SYMBOL_FUNCTION_CALL&gt;&#8288;</code>
node is found directly. <code>depth = 0L</code> means <code>expr</code> is matched directly
to the <code>SYMBOL_FUNCTION_CALL</code>; <code>depth &gt; 1L</code> means <code>depth</code> total <code style="white-space: pre;">&#8288;&lt;expr&gt;&#8288;</code>
nodes must be traversed before finding the call.</p>
</td></tr>
<tr><td><code id="xp_call_name_+3A_condition">condition</code></td>
<td>
<p>An additional (XPath condition on the <code>SYMBOL_FUNCTION_CALL</code>
required for a match. The default (<code>NULL</code>) is no condition. See examples.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>xml_from_code &lt;- function(str) {
  xml2::read_xml(xmlparsedata::xml_parse_data(parse(text = str, keep.source = TRUE)))
}
xml &lt;- xml_from_code("sum(1:10)")
xp_call_name(xml, depth = 2L)

xp_call_name(xml2::xml_find_first(xml, "expr"))

xml &lt;- xml_from_code(c("sum(1:10)", "sd(1:10)"))
xp_call_name(xml, depth = 2L, condition = "text() = 'sum'")

</code></pre>

<hr>
<h2 id='yoda_test_linter'>Block obvious &quot;yoda tests&quot;</h2><span id='topic+yoda_test_linter'></span>

<h3>Description</h3>

<p>Yoda tests use <code style="white-space: pre;">&#8288;(expected, actual)&#8288;</code> instead of the more common <code style="white-space: pre;">&#8288;(actual, expected)&#8288;</code>.
This is not always possible to detect statically; this linter focuses on
the simple case of testing an expression against a literal value, e.g.
<code style="white-space: pre;">&#8288;(1L, foo(x))&#8288;</code> should be <code style="white-space: pre;">&#8288;(foo(x), 1L)&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yoda_test_linter()
</code></pre>


<h3>Tags</h3>

<p><a href="#topic+best_practices_linters">best_practices</a>, <a href="#topic+package_development_linters">package_development</a>, <a href="#topic+pkg_testthat_linters">pkg_testthat</a>, <a href="#topic+readability_linters">readability</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+linters">linters</a> for a complete list of linters available in lintr.
<a href="https://en.wikipedia.org/wiki/Yoda_conditions">https://en.wikipedia.org/wiki/Yoda_conditions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will produce lints
lint(
  text = "expect_equal(2, x)",
  linters = yoda_test_linter()
)

lint(
  text = 'expect_identical("a", x)',
  linters = yoda_test_linter()
)

# okay
lint(
  text = "expect_equal(x, 2)",
  linters = yoda_test_linter()
)

lint(
  text = 'expect_identical(x, "a")',
  linters = yoda_test_linter()
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
