<!DOCTYPE html><html lang="en"><head><title>Help for package SNSequate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SNSequate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SNSequate-package'><p>Standard and Nonstandard Statistical Models and Methods for Test</p>
Equating</a></li>
<li><a href='#ACTmKB'><p>Scores on two 40-items ACT mathematics test forms</p></a></li>
<li><a href='#bandwidth'><p>Automatic selection of the bandwidth parameter <code>h</code></p></a></li>
<li><a href='#BB.smooth'><p>Pre-smoothing using beta4 models.</p></a></li>
<li><a href='#BNP.eq'><p>Bayesian non-parametric model for test equating</p></a></li>
<li><a href='#BNP.eq.predict'><p>Prediction step for Bayesian non-parametric model for test equating</p></a></li>
<li><a href='#CBdata'><p>Observed (raw) score values for two different tests</p></a></li>
<li><a href='#discrete.smooth'><p>Pre-smoothing using discrete kernels.</p></a></li>
<li><a href='#eqp.eq'><p>The equipercentile method of equating</p></a></li>
<li><a href='#gof'><p>Functions to assess model fitting.</p></a></li>
<li><a href='#irt.eq'><p> IRT methods for Test Equating</p></a></li>
<li><a href='#irt.link'><p>IRT parameter linking methods</p></a></li>
<li><a href='#KB36'><p>Data on two 36-items test forms</p></a></li>
<li><a href='#KB36_t'><p>Data on two 36-items test forms</p></a></li>
<li><a href='#KB36.1PL'><p>Difficulty parameter estimates for KB36 data under a 1PL model</p></a></li>
<li><a href='#ker.eq'><p>The Kernel method of test equating</p></a></li>
<li><a href='#le.eq'><p>Local equating methods</p></a></li>
<li><a href='#lin.eq'><p>The linear method of equating</p></a></li>
<li><a href='#loglin.smooth'><p>Pre-smoothing using log-linear models.</p></a></li>
<li><a href='#Math20EG'><p>Scores on two 20-items mathematics tests.</p></a></li>
<li><a href='#Math20SG'><p>Bivariate score frequencies on two 20-items mathematics tests.</p></a></li>
<li><a href='#mea.eq'><p>The mean method of equating</p></a></li>
<li><a href='#PREp'><p>Percent relative error</p></a></li>
<li><a href='#rowBlockSum'><p>Take a matrix and sum blocks of rows</p></a></li>
<li><a href='#SEED'><p>Standard error of equating difference</p></a></li>
<li><a href='#SEPA'><p>A sample of observed score values for two different forms of the SEPA test.</p></a></li>
<li><a href='#sim_unimodal'>
<p>Simulate test scores.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.3-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Standard and Nonstandard Statistical Models and Methods for Test
Equating</td>
</tr>
<tr>
<td>Author:</td>
<td>Jorge Gonzalez [cre, aut],
  Daniel Leon Acuna [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jorge Gonzalez &lt;jorge.gonzalez@mat.uc.cl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), magic, stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>Ake, equate, moments, methods, emdbook, plyr, statmod, knitr,
progress</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions to perform various models and
    methods for test equating (Kolen and Brennan, 2014 
    &lt;<a href="https://doi.org/10.1007%2F978-1-4939-0317-7">doi:10.1007/978-1-4939-0317-7</a>&gt; ; Gonzalez and Wiberg, 2017 
    &lt;<a href="https://doi.org/10.1007%2F978-3-319-51824-4">doi:10.1007/978-3-319-51824-4</a>&gt; ; von Davier et. al, 2004 
    &lt;<a href="https://doi.org/10.1007%2Fb97446">doi:10.1007/b97446</a>&gt;). It currently implements the traditional mean, linear 
    and equipercentile equating methods. Both IRT observed-score and true-score 
    equating are also supported, as well as the mean-mean, mean-sigma, Haebara 
    and Stocking-Lord IRT linking methods. It also supports newest methods such 
    that local equating, kernel equating (using Gaussian, logistic, 
    Epanechnikov, uniform and adaptive kernels) with presmoothing, and IRT 
    parameter linking methods based on asymmetric item characteristic functions. 
    Functions to obtain both standard error of equating (SEE) and standard error 
    of equating differences between two equating functions (SEED) are also 
    implemented for the kernel method of equating.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.mat.uc.cl/~jorge.gonzalez/">https://www.mat.uc.cl/~jorge.gonzalez/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-22 21:02:17 UTC; jorgegonzalez</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-22 23:00:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='SNSequate-package'>Standard and Nonstandard Statistical Models and Methods for Test
Equating
</h2><span id='topic+SNSequate-package'></span><span id='topic+SNSequate'></span>

<h3>Description</h3>

<p>The package contains functions to perform various models and 
methods for test equating. It currently implements the traditional 
mean, linear and equipercentile equating methods. Both IRT observed-score 
and true-score equating are also supported, as well as the mean-mean, 
mean-sigma, Haebara and Stocking-Lord IRT linking methods. 
It also supports newest methods such that local equating, kernel 
equating (using Gaussian, logistic, Epanechnikov, uniform and adaptive 
kernels) with presmoothing, and IRT parameter linking methods based on 
asymmetric item characteristic functions. Functions to obtain both 
standard error of equating (SEE) and standard error of equating differences 
between two equating functions (SEED) are also implemented for the kernel method of 
equating.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SNSequate</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-13</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jorge Gonzalez
</p>
<p>Maintainer: Jorge Gonzalez &lt;jorge.gonzalez@mat.uc.cl&gt;
</p>


<h3>References</h3>

<p>Estay, G. (2012). <em>Characteristic Curves Scale Transformation Methods Using 
Asymmetric ICCs for IRT Equating</em>. Unpublished MSc. Thesis. Pontificia Universidad 
Catolica de Chile.
</p>
<p>Gonzalez, J. (2013). Statistical Models and Inference for the True Equating Transformation in the 
Context of Local Equating. <em>Journal of Educational Measurement, 50(3),</em> 315-320.
</p>
<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Gonzalez, J. and Wiberg, M. (2017). Applying test equating methods using R. Springer.
</p>
<p>Holland, P. and Thayer, D. (1989). The kernel method of equating score distributions. 
(Technical Report No 89-84). Princeton, NJ: Educational Testing Service.
</p>
<p>Holland, P., King, B. and Thayer, D. (1989). The standard error of equating for the kernel method 
of equating score distributions (Tech. Rep. No. 89-83). Princeton, NJ: Educational Testing Service. 
</p>
<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>
<p>Lord, F. (1980). <em>Applications of Item Response Theory to Practical Testing Problems</em>. 
Lawrence Erlbaum Associates, Hillsdale, NJ.
</p>
<p>Lord, F. and Wingersky, M. (1984). Comparison of IRT True-Score and Equipercentile Observed-Score Equatings. 
<em>Applied Psychological Measurement,8(4),</em> 453&ndash;461.
</p>
<p>van der Linden, W. (2011). Local Observed-Score Equating. In A. von Davier (Ed.) 
<em>Statistical Models for Test Equating, Scaling, and Linking</em>. New York, NY: Springer-Verlag.
</p>
<p>van der Linden, W. (2013). Some Conceptual Issues in Observed-Score Equating. 
<em>Journal of Educational Measurement, 50(3),</em> 249-285.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>

<hr>
<h2 id='ACTmKB'>Scores on two 40-items ACT mathematics test forms
</h2><span id='topic+ACTmKB'></span>

<h3>Description</h3>

<p>The data set contains raw sample frequencies of number-right scores for two 
multiple choice 40-items mathematics tests forms. Form <code>X</code> 
was administered to 4329 examinees and form <code>Y</code> to 4152 examinees. This data has 
been described and analized by Kolen and Brennan (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ACTmKB)</code></pre>


<h3>Format</h3>

<p>A 41x2 matrix containing raw sample frequencies (raws) for two tests (columns). 
</p>


<h3>Source</h3>

<p>The data come with the distribution of the RAGE-RGEQUATE software which is freely available 
at <a href="https://education.uiowa.edu/casma/computer-programs">https://education.uiowa.edu/casma/computer-programs</a>
</p>


<h3>References</h3>

<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ACTmKB)
## maybe str(ACTmKB) ; plot(ACTmKB) ...
</code></pre>

<hr>
<h2 id='bandwidth'>Automatic selection of the bandwidth parameter <code>h</code></h2><span id='topic+bandwidth'></span><span id='topic+bandwidth.default'></span>

<h3>Description</h3>

<p>This functions implements the minimization of the combined penalty function
described by Holland and Thayer (1989); Von Davier et al, (2004). It returns 
the optimal value of <code>h</code> for kernel continuization, according to the above 
mentioned criteria. Different types of kernels (others than the gaussian) are accepted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidth(scores, kert, degree, design, Kp = 1, scores2, degreeXA, degreeYA, 
J, K, L, wx, wy, w, r=NULL) 
</code></pre>


<h3>Arguments</h3>

<p>      	Note that depending on the specified equating design, not all arguments are necessary
as detailed below.
</p>
<table role = "presentation">
<tr><td><code id="bandwidth_+3A_scores">scores</code></td>
<td>
<p>	If the &quot;EG&quot; design is specified, a vector containing the raw sample frequencies 
coming from one group taking the test.
</p>
<p>If the &quot;SG&quot; design is specified, a matrix containing the (joint) bivariate sample 
frequencies for <code class="reqn">X</code> (raws) and <code class="reqn">Y</code> (columns).
</p>
<p>If the &quot;CB&quot; design is specified, a two column matrix containing the observed scores 
of the sample taking test <code class="reqn">X</code> first, followed by test <code class="reqn">Y</code>. The <code>scores2</code> 
argument is then used for the scores of the sample taking test Y first followed by test 
<code class="reqn">X</code>.
</p>
<p>If either the &quot;NEAT_CB&quot; or &quot;NEAT_PSE&quot; design is selected, a two column matrix containing 
the observed scores on	test <code class="reqn">X</code> (first column) and the observed scores on the anchor 
test <code class="reqn">A</code> (second column). The <code>scores2</code> argument is then used for the observed 
scores on test <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_kert">kert</code></td>
<td>
<p>		A character string giving the type of kernel to be used for continuization. 
Current options include &quot;<code>gauss</code>&quot;, &quot;<code>logis</code>&quot;, and &quot;<code>uniform</code>&quot; 
for the gaussian, logistic and uniform kernels, respectively</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_degree">degree</code></td>
<td>
<p>	Either a number or vector indicating the number of power moments to be fitted to the 
marginal distributions, or the number or cross moments to be fitted to the joint 
distributions, respectively. For the &quot;EG&quot; design it will be a number (see Details).</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_design">design</code></td>
<td>
<p>	A character string indicating the equating design (one of &quot;EG&quot;, &quot;SG&quot;, &quot;CB&quot;, &quot;NEAT_CE&quot;, 
&quot;NEAT_PSE&quot;)</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_kp">Kp</code></td>
<td>
<p>		A number which acts as a weight for the second term in the combined penalization function used 
to obtain <code>h</code> (see details).</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_scores2">scores2</code></td>
<td>
<p>	Only used for the &quot;CB&quot;, &quot;NEAT_CE&quot; and &quot;NEAT_PSE&quot; designs. See the description of
<code>scores</code>.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_degreexa">degreeXA</code></td>
<td>
<p>	A vector indicating the	number of power moments to be fitted to the marginal distributions 
<code class="reqn">X</code> and <code class="reqn">A</code>, and the number or cross moments to be fitted to the joint 
distribution <code class="reqn">(X,A)</code>	(see details). Only used for the &quot;NEAT_CE&quot; and &quot;NEAT_PSE&quot; designs.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_degreeya">degreeYA</code></td>
<td>
<p>	Only used for the &quot;NEAT_CE&quot; and &quot;NEAT_PSE&quot; designs (see the description for
<code>degreeXA</code>)</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_j">J</code></td>
<td>
<p>		The number of possible <code class="reqn">X</code> scores. Only needed for &quot;CB&quot;, &quot;NEAT_CB&quot; and &quot;NEAT_PSE&quot; designs</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_k">K</code></td>
<td>
<p>		The number of possible <code class="reqn">Y</code> scores. Only needed for &quot;CB&quot;, &quot;NEAT_CB&quot; and &quot;NEAT_PSE&quot; designs</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_l">L</code></td>
<td>
<p>		The number of possible <code class="reqn">A</code> scores. Needed for &quot;NEAT_CB&quot; and &quot;NEAT_PSE&quot; designs</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_wx">wx</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_X\leq 1</code> indicating the weight put on the data 
that is not subject to order effects. Only used for the &quot;CB&quot; design.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_wy">wy</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_Y\leq 1</code> indicating the weight put on the data 
that is not subject to order effects. Only used for the &quot;CB&quot; design.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_w">w</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w\leq 1</code> indicating the weight given to 
population <code class="reqn">P</code>. Only used for the &quot;NEAT&quot; design.</p>
</td></tr>
<tr><td><code id="bandwidth_+3A_r">r</code></td>
<td>
<p>		Score probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>	To automatically select <code>h</code>, the function minimizes 
</p>
<p style="text-align: center;"><code class="reqn">PEN_1(h)+K\times PEN_2(h)</code>
</p>

<p>where <code class="reqn">PEN_1(h)=\sum_j(\hat{r}_j-\hat{f}_h(x_j))^2</code>, and 
<code class="reqn">PEN_2(h)=\sum_jA_j(1-B_j)</code>. The terms <code class="reqn">A</code> and <code class="reqn">B</code> 
are such that <code class="reqn">PEN_2</code> acts as a smoothness penalty term that avoids rapid 
fluctuations in the approximated density (see Chapter 10 in Von Davier, 2011 for more details). The 
<code class="reqn">K</code> term corresponds to the <code>Kp</code> argument of the <code>bandwidth</code> function. The 
<code class="reqn">\hat{r}</code> values are assumed to be estimated by polynomial loglinear models of specific
<code>degree</code>, which come from a call to <code><a href="#topic+loglin.smooth">loglin.smooth</a></code>.
</p>


<h3>Value</h3>

<p>		A number which is the optimal value of <code>h</code>.</p>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a>
</p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>
<p>A. von Davier (Ed.) (2011). <em>Statistical Models for Equating, Scaling, and Linking. New York: Springer</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglin.smooth">loglin.smooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example: The "Standard" column and firsts two rows of Table 10.1 in 
#Chapter 10 of Von Davier 2011

data(Math20EG)

hx.logis&lt;-bandwidth(scores=Math20EG[,1],kert="logis",degree=2,design="EG")$h
hx.unif&lt;-bandwidth(scores=Math20EG[,1],kert="unif",degree=2,design="EG")$h 
hx.gauss&lt;-bandwidth(scores=Math20EG[,1],kert="gauss",degree=2,design="EG")$h

hy.logis&lt;-bandwidth(scores=Math20EG[,2],kert="logis",degree=3,design="EG")$h
hy.unif&lt;-bandwidth(scores=Math20EG[,2],kert="unif",degree=3,design="EG")$h 
hy.gauss&lt;-bandwidth(scores=Math20EG[,2],kert="gauss",degree=3,design="EG")$h

partialTable10.1&lt;-rbind(c(hx.logis,hx.unif,hx.gauss),
				c(hy.logis,hy.unif,hy.gauss))

dimnames(partialTable10.1)&lt;-list(c("h.x","h.y"),c("Logistic","Uniform","Gaussian"))
partialTable10.1

</code></pre>

<hr>
<h2 id='BB.smooth'>Pre-smoothing using beta4 models.</h2><span id='topic+BB.smooth'></span><span id='topic+BB.smooth.default'></span>

<h3>Description</h3>

<p>This function fits beta models to score data and provides estimates of 
the (vector of) score probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BB.smooth(x,nparm=4,rel)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BB.smooth_+3A_x">x</code></td>
<td>
<p>	Data.</p>
</td></tr>
<tr><td><code id="BB.smooth_+3A_nparm">nparm</code></td>
<td>
<p>	parameters.</p>
</td></tr>
<tr><td><code id="BB.smooth_+3A_rel">rel</code></td>
<td>
<p>	reliability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits beta models as described in XXXX, and XXXXX. 
</p>
<p>Particular cases of this general equation for each of the equating designs can be found in 
Von Davier et al (2004) (e.g., Equations (7.1) and (7.2) for the &quot;EG&quot; design, Equation (8.1) for the &quot;SG&quot; design, 
Equations (9,1) and (9.2) for the &quot;CB&quot; design).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>prob.est</code></td>
<td>
<p>The estimated score probabilities</p>
</td></tr>
<tr><td><code>freq.est</code></td>
<td>
<p>The estimated score frequencies</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The parameters estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Holland, P. and Thayer, D. (1987). Notes on the use of loglinear models for fitting 
discrete probability distributions. Research Report 87-31, Princeton NJ: Educational 
Testing Service.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>
<p>[1]	Moses, T. &quot;Paper SA06_05 Using PROC GENMOD for Loglinear Smoothing Tim Moses and Alina A. von Davier, Educational Testing Service, Princeton, NJ&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+ker.eq">ker.eq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data("SEPA", package = "SNSequate")
  
  # create score frequency distributions using freqtab from package equate
  library(equate)
  
  SEPAx&lt;-freqtab(x=SEPA$xscores,scales=0:50)
  SEPAy&lt;-freqtab(x=SEPA$yscores,scales=0:50)
  
  beta4nx&lt;-BB.smooth(SEPAx,nparm=4,rel=0) 
  beta4ny&lt;-BB.smooth(SEPAy,nparm=4,rel=0) 
  
  plot(0:50,as.matrix(SEPAx)/sum(as.matrix(SEPAx)),type="b",pch=0, 
       ylim=c(0,0.06),ylab="Relative Frequency",xlab="Scores")
</code></pre>

<hr>
<h2 id='BNP.eq'>Bayesian non-parametric model for test equating</h2><span id='topic+BNP.eq'></span>

<h3>Description</h3>

<p>This function implements the Bayesian nonparametric approach for test equating 
as described in Gonzalez, Barrientos and Quintana (2015) &lt;<a href="https://doi.org/10.1016/j.csda.2015.03.012">doi:10.1016/j.csda.2015.03.012</a>&gt;. 
The main idea consists of introducing covariate dependent Bayesian nonparametric models for a collection of 
covariate-dependent equating transformations
</p>
<p><code class="reqn"> \left\{ \boldsymbol{\varphi}_{\boldsymbol{z}_f, \boldsymbol{z}_t} (\cdot): 
           \boldsymbol{z}_f, \boldsymbol{z}_t \in \mathcal{L}
       \right\} 
  </code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BNP.eq(scores_x, scores_y, range_scores = NULL, design = "EG",
  covariates = NULL, prior = NULL, mcmc = NULL, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BNP.eq_+3A_scores_x">scores_x</code></td>
<td>
<p>Vector.  Scores of form X.</p>
</td></tr>
<tr><td><code id="BNP.eq_+3A_scores_y">scores_y</code></td>
<td>
<p>Vector.  Scores of form Y.</p>
</td></tr>
<tr><td><code id="BNP.eq_+3A_range_scores">range_scores</code></td>
<td>
<p>Vector of length 2.  Represent the minimum and maximum scores in the test.</p>
</td></tr>
<tr><td><code id="BNP.eq_+3A_design">design</code></td>
<td>
<p>Character.  Only supports 'EG' design now.</p>
</td></tr>
<tr><td><code id="BNP.eq_+3A_covariates">covariates</code></td>
<td>
<p>Data.frame.  A data frame with factors, containing covariates 
for test X and Y, stacked in that order.</p>
</td></tr>
<tr><td><code id="BNP.eq_+3A_prior">prior</code></td>
<td>
<p>List.  Prior information for BNP model. 
For more information see DPpackage.</p>
</td></tr>
<tr><td><code id="BNP.eq_+3A_mcmc">mcmc</code></td>
<td>
<p>List.  MCMC information for BNP model. 
For more information see DPpackage.</p>
</td></tr>
<tr><td><code id="BNP.eq_+3A_normalize">normalize</code></td>
<td>
<p>Logical.  Whether normalize or not the 
response variable. This is due to Berstein's polynomials. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayesian nonparametric (BNP) approach starts by focusing on spaces of distribution 
functions, so that uncertainty is expressed on F itself. The prior distribution p(F) is 
defined on the space F of all distribution functions defined on X . If X is an infinite 
set then F is infinite-dimensional, and the corresponding prior model p(F) on F is termed 
nonparametric. The prior probability model is also referred to as a random probability 
measure (RPM), and it essentially corresponds to a distribution on the space of all 
distributions on the set X . Thus Bayesian nonparametric models are probability models 
defined on a function space.
</p>


<h3>Value</h3>

<p>A 'BNP.eq' object, which is list containing the following items:
</p>
<p>Y Response variable.
</p>
<p>X Design Matrix.
</p>
<p>fit DPpackage object. Fitted model with raw samples.
</p>
<p>max_score Maximum score of test.
</p>
<p>patterns A matrix describing the different patterns formed
from the factors in the covariables.
</p>
<p>patterns_freq The normalized frequency of each pattern.
</p>


<h3>Author(s)</h3>

<p>Daniel Leon <a href="mailto:dnacuna@uc.cl">dnacuna@uc.cl</a>, Felipe Barrientos <a href="mailto:afb26@stat.duke.edu">afb26@stat.duke.edu</a>.
</p>


<h3>References</h3>

<p>Gonzalez, J., Barrientos, A., and Quintana, F. (2015). Bayesian Nonparametric Estimation of Test Equating Functions with Covariates. <em>Computational Statistics and Data Analysis, 89,</em> 222-244. 
</p>

<hr>
<h2 id='BNP.eq.predict'>Prediction step for Bayesian non-parametric model for test equating</h2><span id='topic+BNP.eq.predict'></span>

<h3>Description</h3>

<p>This function implements the prediction step in the Bayesian non-parametric model for test equating
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BNP.eq.predict(model, from = NULL, into = NULL, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BNP.eq.predict_+3A_model">model</code></td>
<td>
<p>A 'BNP.eq' object.</p>
</td></tr>
<tr><td><code id="BNP.eq.predict_+3A_from">from</code></td>
<td>
<p>Numeric. A vector of indices indicating from which patterns equating should be performed.
The covariates involved are integrated out.</p>
</td></tr>
<tr><td><code id="BNP.eq.predict_+3A_into">into</code></td>
<td>
<p>Numeric. A vector of indices indicating into which patterns equating should be performed.
The covariates involved are integrated out.</p>
</td></tr>
<tr><td><code id="BNP.eq.predict_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Level of significance for credible bands.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions of the score probability distributions are obtained under the Bayesian nonparametric 
model and are used to compute the equating function.   
</p>


<h3>Value</h3>

<p>A 'BNP.eq.predict' object, which is a list containing the following items:
</p>
<p>pdf A list of PDF's.
</p>
<p>cdf A list of CDF's.
</p>
<p>equ Numeric. Equated values.
</p>
<p>grid Numeric. Grid used to evaluate pdf's and cdf's.
</p>


<h3>Author(s)</h3>

<p>Daniel Leon <a href="mailto:dnacuna@uc.cl">dnacuna@uc.cl</a>, Felipe Barrientos <a href="mailto:afb26@stat.duke.edu">afb26@stat.duke.edu</a>.
</p>


<h3>References</h3>

<p>Gonzalez, J., Barrientos, A., and Quintana, F. (2015). Bayesian Nonparametric Estimation of Test Equating Functions with Covariates. <em>Computational Statistics and Data Analysis, 89,</em> 222-244.
</p>

<hr>
<h2 id='CBdata'>Observed (raw) score values for two different tests
</h2><span id='topic+CBdata'></span>

<h3>Description</h3>

<p>The data set is from a small field study from an international testing program. 
It contains the observed scores for two tests <code class="reqn">X</code> (with 75 items) and <code class="reqn">Y</code> (with 76 items) 
administered to two independent, random samples of examinees from a single population <code class="reqn">P</code>. 
For more details, see Chapter 9 in Von Davier et al, (2004) from where the data were obtained. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CBdata)</code></pre>


<h3>Format</h3>

<p>A list with elements containing the observed scores of the sample taking test X first,
followed by test Y (datX1Y2), and the scores of the sample taking test Y first followed by 
test X (datX2Y1).
</p>


<h3>References</h3>

<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CBdata)
## maybe str(CBdata) ; ...
</code></pre>

<hr>
<h2 id='discrete.smooth'>Pre-smoothing using discrete kernels.</h2><span id='topic+discrete.smooth'></span><span id='topic+discrete.smooth.default'></span>

<h3>Description</h3>

<p>This function fits discrete kernels to score data and provides estimates of 
the (vector of) score probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.smooth(scores,kert,h,x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrete.smooth_+3A_scores">scores</code></td>
<td>
<p>	Data.</p>
</td></tr>
<tr><td><code id="discrete.smooth_+3A_kert">kert</code></td>
<td>
<p>	kernel type.</p>
</td></tr>
<tr><td><code id="discrete.smooth_+3A_h">h</code></td>
<td>
<p>	bandwidth.</p>
</td></tr>
<tr><td><code id="discrete.smooth_+3A_x">x</code></td>
<td>
<p> The points of the grid at which the density is to be estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits discrete kernels as described in XXXX, and XXXXX. 
</p>
<p>Particular cases of this general equation for each of the equating designs can be found in 
Von Davier et al (2004) (e.g., Equations (7.1) and (7.2) for the &quot;EG&quot; design, Equation (8.1) for the &quot;SG&quot; design, 
Equations (9,1) and (9.2) for the &quot;CB&quot; design).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>prob.est</code></td>
<td>
<p>The estimated score probabilities</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Holland, P. and Thayer, D. (1987). Notes on the use of loglinear models for fitting 
discrete probability distributions. Research Report 87-31, Princeton NJ: Educational 
Testing Service.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>
<p>[1]	Moses, T. &quot;Paper SA06_05 Using PROC GENMOD for Loglinear Smoothing Tim Moses and Alina A. von Davier, Educational Testing Service, Princeton, NJ&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+ker.eq">ker.eq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data("SEPA", package = "SNSequate")
  
  # create score frequency distributions using freqtab from package equate
  library(equate)
  
  SEPAx&lt;-freqtab(x=SEPA$xscores,scales=0:50)
  SEPAy&lt;-freqtab(x=SEPA$yscores,scales=0:50)
  
  psxB&lt;-discrete.smooth(scores=rep(0:50,SEPAx),kert="bino",h=0.25,x=0:50)
  psxT&lt;-discrete.smooth(scores=rep(0:50,SEPAx),kert="triang",h=0.25,x=0:50)
  psxD&lt;-discrete.smooth(scores=rep(0:50,SEPAx),kert="dirDU",h=0.0,x=0:50)

  plot(0:50,as.matrix(SEPAx)/sum(as.matrix(SEPAx)),lwd=2.0,xlab="Scores", 
  ylab="Relative    Frequency",type="h")
  points(0:50,psxB$prob.est,type="b",pch=0)
  points(0:50,psxT$prob.est,type="b",pch=1)

</code></pre>

<hr>
<h2 id='eqp.eq'>The equipercentile method of equating</h2><span id='topic+eqp.eq'></span><span id='topic+eqp.eq.default'></span>

<h3>Description</h3>

<p>This function implements the equipercentile method of test equating  as described in Kolen and Brennan (2004). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqp.eq(sx, sy, X, Ky = max(sy))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eqp.eq_+3A_sx">sx</code></td>
<td>
<p>		A vector containing the observed scores on test <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="eqp.eq_+3A_sy">sy</code></td>
<td>
<p>		A vector containing the observed scores on test <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code id="eqp.eq_+3A_x">X</code></td>
<td>
<p>		Either an integer or vector containing the values on the scale 
to be equated.</p>
</td></tr>
<tr><td><code id="eqp.eq_+3A_ky">Ky</code></td>
<td>
<p>		The total number of items in test form <code class="reqn">Y</code> to which form 
<code class="reqn">X</code> scores will be equated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the equipercentile method of equating as described in Kolen and Brennan (2004). Given observed scores
<code>sx</code> and <code>sy</code>, the functions calculates 
</p>
<p style="text-align: center;"><code class="reqn">\varphi(x)=G^{-1}(F(x))</code>
</p>

<p>where <code class="reqn">F</code> and <code class="reqn">G</code> are the cdf of scores on test forms <code class="reqn">X</code> and <code class="reqn">Y</code>, 
respectively.
</p>


<h3>Value</h3>

<p>A two column matrix with the values of <code class="reqn">\varphi()</code> (second column) for each scale value <code>x</code> (first column)</p>


<h3>Author(s)</h3>

<p>Jorge Gonzalez  &lt;jorge.gonzalez@mat.uc.cl&gt;</p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mea.eq">mea.eq</a></code>, <code><a href="#topic+lin.eq">lin.eq</a></code>, <code><a href="#topic+ker.eq">ker.eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from Kolen and Brennan (2004), pages 41-42:
### (scores distributions have been transformed to vectors of scores)

sx&lt;-c(0,0,1,1,1,2,2,3,3,4)
sy&lt;-c(0,1,1,2,2,3,3,3,4,4)
x&lt;-2
eqp.eq(sx,sy,2)

# Whole scale range (Table 2.3 in KB)
eqp.eq(sx,sy,0:4)

</code></pre>

<hr>
<h2 id='gof'>Functions to assess model fitting.</h2><span id='topic+gof'></span>

<h3>Description</h3>

<p>This function contains various measures to assess the model's goodness of fit. </p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(obs, fit, methods=c("FT"), p.out=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gof_+3A_obs">obs</code></td>
<td>
<p>		A vector containing the observed values.</p>
</td></tr>
<tr><td><code id="gof_+3A_fit">fit</code></td>
<td>
<p>		A vector containing the fitted values.</p>
</td></tr>
<tr><td><code id="gof_+3A_methods">methods</code></td>
<td>
<p>		A character vector containing one or many of the following methods:
</p>

<dl>
<dt>&quot;FT&quot;</dt><dd><p>Freeman-Tukey Residuals. This is the default test.</p>
</dd>
<dt>&quot;Chisq&quot;</dt><dd><p>Pearson's Chi-squared test.</p>
</dd>
<dt>&quot;KL&quot;</dt><dd><p>Symmetrised Kullback-Leibler divergence.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="gof_+3A_p.out">p.out</code></td>
<td>
<p>  Boolean. Decides whether or not to display plots (on corresponding methods).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Leon Acuna. <a href="mailto:dnacuna@uc.cl">dnacuna@uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>
<p>Johnson, D. H., and Sinanovic, S. (2000). Symmetrizing the Kullback-Leibler distance (Technical 
report). <em>IEEE Transactions on Information Theory</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Math20EG)
mod &lt;- ker.eq(scores=Math20EG,kert="gauss",degree=c(2,3),design="EG")

gof(Math20EG[,1], mod$rj*mod$nx, method=c("FT", "KL"))

</code></pre>

<hr>
<h2 id='irt.eq'> IRT methods for Test Equating </h2><span id='topic+irt.eq'></span><span id='topic+irt.eq.default'></span>

<h3>Description</h3>

<p> Implements methods to perform Test Equating over IRT models. </p>


<h3>Usage</h3>

<pre><code class='language-R'>irt.eq(n_items, param_x, param_y, theta_points=NULL, weights=NULL, n_points=10, w=1, 
      A=NULL, B=NULL, link=NULL, method_link=NULL, common=NULL,  method="TS", D=1.7)
</code></pre>


<h3>Arguments</h3>

  
<table role = "presentation">
<tr><td><code id="irt.eq_+3A_n_items">n_items</code></td>
<td>
<p> Number of items of the test </p>
</td></tr>
<tr><td><code id="irt.eq_+3A_param_x">param_x</code></td>
<td>
<p> Estimated parameters for IRT model on test X. This list must have the following structure:
list(a, b, c), where each parameter is a vector with the respective estimate for each subject. If you    want to perform other models (i.e. Rasch), replace according with a vector of zeros. 
</p>
</td></tr>
<tr><td><code id="irt.eq_+3A_param_y">param_y</code></td>
<td>
<p> Estimated parameters for IRT model on test Y. This list must have the following structure:
list(a, b, c), where each parameter is a vector with the respective estimate for each subject. If you    want to perform other models (i.e. Rasch), replace according with a vector of zeros. 
</p>
</td></tr>
<tr><td><code id="irt.eq_+3A_method">method</code></td>
<td>
<p> A string, either &quot;TS&quot; or &quot;OS&quot;. Each one stands for &quot;True Score Equating&quot; and &quot;Observed score equating&quot;. Notice that OS requires the additional arguments &quot;theta_points&quot; and &quot;weigths&quot;.  </p>
</td></tr>
<tr><td><code id="irt.eq_+3A_theta_points">theta_points</code></td>
<td>
<p> For &quot;OS&quot; only. Points over a grid of possible values of  <code class="reqn">\theta</code> to integrate out the ability term. </p>
</td></tr>
<tr><td><code id="irt.eq_+3A_weights">weights</code></td>
<td>
<p> For &quot;OS&quot; only. Weigths for integrate out the ability term. If is NULL, the method assumes the distribution of ability is characterized by a finite number of abilities (Kolen and Brennan 2013, pg 199).</p>
</td></tr>
<tr><td><code id="irt.eq_+3A_n_points">n_points</code></td>
<td>
<p> In case theta_ponints is not provided, is the length of the grid for the gaussian quadrature.  </p>
</td></tr>
<tr><td><code id="irt.eq_+3A_a">A</code>, <code id="irt.eq_+3A_b">B</code></td>
<td>
<p> Scaling parameters. In the case they are not provided, they will be calculated depending on the next described inputs.</p>
</td></tr>
<tr><td><code id="irt.eq_+3A_link">link</code></td>
<td>
<p> An <a href="#topic+irt.link">irt.link</a> object.  </p>
</td></tr>
<tr><td><code id="irt.eq_+3A_method_link">method_link</code></td>
<td>
<p> Method used to estimate A and B. Default is &quot;mean/sigma&quot;. Others are &quot;mean/mean&quot;, &quot;Haebara&quot; and &quot;Stocklord&quot;. For more information see <a href="#topic+irt.link">irt.link</a> </p>
</td></tr>
<tr><td><code id="irt.eq_+3A_common">common</code></td>
<td>
<p> Common items to estimate A and B. Default asume all items are common.  </p>
</td></tr>
<tr><td><code id="irt.eq_+3A_w">w</code></td>
<td>
<p> Weight of the synthetic population.  </p>
</td></tr>
<tr><td><code id="irt.eq_+3A_d">D</code></td>
<td>
<p> Sclaing constant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements two methods to perform Test Equating over Item Response Theory models (Kolen and Brennan 2013). 
</p>
<p>&quot;True Score Equating&quot; relate number-correct scores on Form X and Form Y. Assumes that the true score associated with each <code class="reqn">\theta</code> is equivalent to the true score on another form associated with that <code class="reqn">\theta</code>.
</p>
<p>&quot;Observed Score Equating&quot; uses the IRT model to produce an estimated distribution of observed number-correct scores on each form. Using the compound binomial distribution (Lord and Wingersky 1984) to find the conditional distributions <code class="reqn">f(x\mid\theta)</code>, and then integrate out the <code class="reqn">\theta</code> parameter. Afterwards, an Equipercentile Equating process is done over the estimated distributions. 
</p>


<h3>Value</h3>

	
<p>An object of the clas <code>irt.eq</code> is returned. Depending on the method used, the outputs are:
</p>

<dl>
<dt>True Score Equating</dt><dd><p> A list(n_items, theta_equivalent, tau_y) containing the number of items, the theta equivalent values on Form X to Form Y and the equivalent scores.</p>
</dd>
<dt>Observed Score Equating</dt><dd><p>A list(n_items, f_hat, g_hat, e_Y_x) containing the number of items, the estimated distributions and the equated values.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Daniel Acuna Leon. <a href="mailto:dnacuna@uc.cl">dnacuna@uc.cl</a></p>


<h3>References</h3>

<p>Kolen, M. J., and Brennan, R. L. (2014). <em>Test Equating, Scaling, and Linking: Methods and Practices, Third Edition</em>. Springer Science &amp; Business Media.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+irt.link">irt.link</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KB36_t)
dfo &lt;- KB36_t

param_x &lt;- list(a=dfo[,3],b=dfo[,4],c=dfo[,5])
param_y &lt;- list(a=dfo[,7],b=dfo[,8],c=dfo[,9])

theta_points=c(-5.2086,-4.163,-3.1175,-2.072,-1.0269,0.0184,
               1.0635,2.109,3.1546,4.2001)
weights=c(0.000101,0.00276,0.03021,0.142,0.3149,0.3158,
         0.1542,0.03596,0.003925,0.000186)


irt.eq(36, param_x, param_y, method="TS", A=1, B=0)
irt.eq(36, param_x, param_y, theta_points, weights, method="OS", A=1, B=0)
</code></pre>

<hr>
<h2 id='irt.link'>IRT parameter linking methods</h2><span id='topic+irt.link'></span><span id='topic+irt.link.default'></span>

<h3>Description</h3>

<p>The function implements parameter linking methods to transform IRT scales. Mean-mean, 
mean-sigma, Haebara, and Stocking and Lord methods are available (see details). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irt.link(parm, common, model, icc, D)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irt.link_+3A_parm">parm</code></td>
<td>
<p>		A 6 column matrix containing item parameter estimates from an IRT model. The
first three columns contains the parameters for the form <code>Y</code> fit, and the 
last three those of form <code>X</code>. The order for item paramters in the matrix
is discrimination, difficulty, and guessing. See details.</p>
</td></tr>
<tr><td><code id="irt.link_+3A_common">common</code></td>
<td>
<p>	A vector indicating the position where common items are located</p>
</td></tr>
<tr><td><code id="irt.link_+3A_model">model</code></td>
<td>
<p>		A character string indicating the underlying IRT model: &quot;1PL&quot;, &quot;2PL&quot;, &quot;3PL&quot;.</p>
</td></tr>
<tr><td><code id="irt.link_+3A_icc">icc</code></td>
<td>
<p>		A character string indicating the type of <code>icc</code> used in the characteristic
curve methods (see details). Available options are &quot;logistic&quot; and &quot;cloglog&quot;.</p>
</td></tr>
<tr><td><code id="irt.link_+3A_d">D</code></td>
<td>
<p>		A number indicating the value of the constant <code>D</code> 
(see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implments various methods of IRT parameter linking (a.k.a, scale transformation 
methods). It calculates the linking constants <code>A</code> and <code>B</code> to tranform parameter estimates. 
When assuming a 1PL model, the matrix <code>parm</code> should contain a column of ones and a column of zeroes 
in the places where discrimination and guessing parameters are located, respectively. 
</p>
<p>The characteristic curve methods (Haebara and Stocking and Lord) rely on the item characteristic curve 
<code class="reqn">p_{ij}</code>assumed for the probability of a correct answer
</p>
<p style="text-align: center;"><code class="reqn">p_{ij}=P(Y_{ij}=1\mid\theta_i)=c_j+(1-c_j)\frac{\exp[Da_j(\theta_i-\beta_j)]}{1+\exp[Da_j(\theta_i-\beta_j)]}</code>
</p>

<p>Besides the traditional logistic model, the <code>irt.link()</code> function allows the use of an asymetric 
cloglog ICC. See the help for <code>KB36.1PL</code> data set, where some details on how to fit a 1PL model with
cloglog link in <code>lmer</code> are given.
</p>
<p>For more details on characteristic curve methods see Kolen and Brennan (2004).
</p>


<h3>Value</h3>

<p>A list with the constants <code>A</code> and <code>B</code> calculated using the four different methods</p>


<h3>Note</h3>

<p>Currently, the cloglog ICC is only implmented for the 1PL model. A 1PL model with asymetric cloglog 
link can be fitted in R using the <code>lmer()</code> function in package <code>lme4</code>
</p>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>
<p>Estay, G. (2012). <em>Characteristic Curves Scale Transformation Methods Using 
Asymmetric ICCs for IRT Equating</em>. Unpublished MSc. Thesis. Pontificia Universidad 
Catolica de Chile
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mea.eq">mea.eq</a></code>, <code><a href="#topic+lin.eq">lin.eq</a></code>, <code><a href="#topic+ker.eq">ker.eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example. KB, Table 6.6
data(KB36)
parm.x = KB36$KBformX_par
parm.y = KB36$KBformY_par	
comitems = seq(3,36,3)
parm = as.data.frame(cbind(parm.y, parm.x))

# Table 6.6 KB
irt.link(parm,comitems,model="3PL",icc="logistic",D=1.7)


# Same data but assuming a 1PL model. The parameter estimates are load from 
# the KB36.1PL data set. See the help for KB36.1PL data for details on how these
# estimates were obtained using \code{lmer()} (see also Table 6.13 in KB)
 
data(KB36.1PL)

#preparing the input data matrices for irt.link() function
b.log.y&lt;-KB36.1PL$b.logistic[,2]
b.log.x&lt;-KB36.1PL$b.logistic[,1]
b.clog.y&lt;-KB36.1PL$b.cloglog[,2]
b.clog.x&lt;-KB36.1PL$b.cloglog[,1]

parm2 = as.data.frame(cbind(1,b.log.y,0, 1,b.log.x, 0))
parm3 = as.data.frame(cbind(1,b.clog.y,0, 1,b.clog.x,0))

#vector indicating common items
comitems = seq(3,36,3)

#Calculating the B constant under the logistic-link model
irt.link(parm2,comitems,model="1PL",icc="logistic",D=1.7)

#Calculating the B constant under the cloglog-link model
irt.link(parm3,comitems,model="1PL",icc="cloglog",D=1.7)
</code></pre>

<hr>
<h2 id='KB36'>Data on two 36-items test forms</h2><span id='topic+KB36'></span>

<h3>Description</h3>

<p>The data set contains both response patterns and item parameters estimates following a 3PL model 
for two 36-items tests forms. Form <code>X</code> was administered to 1655 examinees and form <code>Y</code> 
to 1638 examinees. Also, 12 out of the 36 items are common between both test forms (items 3, 6, 9, 
12, 15, 18, 21, 24, 27, 30, 33, 36). This data has been described and analized by Kolen and Brennan (2004).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(KB36)</code></pre>


<h3>Format</h3>

<p>A list with four elements containing binary data matrices of responses (<code>KBformX</code> and 
<code>KBformY</code>) and the corresponding parameter estimates which result from a 3PL fit to both data
matrices (<code>KBformX_par</code> and <code>KBformY_par</code>).
</p>


<h3>Source</h3>

<p>The data come with the distribution of the CIPE software which is freely available 
at <a href="https://education.uiowa.edu/casma/computer-programs">https://education.uiowa.edu/casma/computer-programs</a>. 
The list of item parameters estimates can be found in Table 6.5 of Kolen and Brennan (2004).
</p>


<h3>References</h3>

<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KB36)
## maybe str(KB36) ; plot(KB36) ...
</code></pre>

<hr>
<h2 id='KB36_t'>Data on two 36-items test forms</h2><span id='topic+KB36_t'></span>

<h3>Description</h3>

<p>The data set contains item parameters estimates following a 3PL model for two 36-items tests forms, 
rescaled using mean-sigma method's A and B using all common items except item 27. This data has been described and analized by Kolen and Brennan (2004), Table 6.8.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(KB36_t)</code></pre>


<h3>Format</h3>

<p>A dataframe where each column represent item parameter estimates of forms <code>X</code> and <code>Y</code>, with their respective p-values.
</p>


<h3>References</h3>

<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>See Also</h3>

<p>KB36</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KB36_t)
</code></pre>

<hr>
<h2 id='KB36.1PL'>Difficulty parameter estimates for KB36 data under a 1PL model</h2><span id='topic+KB36.1PL'></span>

<h3>Description</h3>

<p>This data set contains the estimated item difficuty parameters for the 
<code>KB36</code> data, assuming a 1PL model. Two sets of parameters estimates for test forms 
<code>X</code> and <code>Y</code> are available: one that results from a fit assuming the traditional 
logistic link, and one which comes from the fit using a cloglog (asymmetric) link. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(KB36.1PL)</code></pre>


<h3>Format</h3>

<p>A list of 2 elements containing item (difficulty) parameters estimates for test 
forms <code>X</code> and <code>Y</code> under the logistic-link model (<code>b.logistic</code>), and under 
the cloglog-link model (<code>b.cloglog</code>)
</p>


<h3>Details</h3>

<p>This data set is used to illustrate the characteristic curve methods (Haebara and 
Stocking-Lord) which can use an asymmetric cloglog ICC for the calculations, as 
described in Estay (2012).
</p>
<p>A 1PL model using both logistic and cloglog link can be fitted using the <code>lmer()</code> 
function in the <code>lme4</code> R package (see De Boeck et. al, 2011 for details). 
</p>


<h3>Source</h3>

<p>The item parameter estimates for the 1PL model with logistic link are also shown in
Table 6.13 of Kolen and Brennan (2004).
</p>


<h3>References</h3>

<p>De Boeck, P., Bakker, M., Zwitser, R., Nivard, M., Hofman, A.,Tuerlinckx, F., Partchev, I. 
(2011). The Estimation of Item Response Models with the <code>lmer</code> Function from the 
<span class="pkg">lme4</span> Package in <code>R</code>. <em>Journal of Statistical Software, 39(12),</em> 1-28.
</p>
<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>
<p>Estay, G. (2012). <em>Characteristic Curves Scale Transformation Methods Using 
Asymmetric ICCs for IRT Equating</em>. Unpublished MSc. Thesis. Pontificia Universidad 
Catolica de Chile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KB36.1PL)
## maybe str(KB36.1PL) ; plot(KB36.1PL) ...
</code></pre>

<hr>
<h2 id='ker.eq'>The Kernel method of test equating</h2><span id='topic+ker.eq'></span><span id='topic+ker.eq.default'></span>

<h3>Description</h3>

<p>This function implements the kernel method of test equating  as described in Holland and Thayer (1989), 
and Von Davier et al. (2004). Nonstandard kernels others than the gaussian are available. Associated standard error 
of equating are also provided. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ker.eq(scores, kert, hx = NULL, hy = NULL, degree, design, Kp = 1, scores2, 
degreeXA, degreeYA, J, K, L, wx, wy, w, gapsX, gapsY, gapsA, lumpX, lumpY, 
lumpA, alpha, h.adap,r=NULL,s=NULL)
</code></pre>


<h3>Arguments</h3>

  
<p>		Note that depending on the specified equating design, not all arguments are necessary 
as detailed below. 
</p>
<table role = "presentation">
<tr><td><code id="ker.eq_+3A_scores">scores</code></td>
<td>
<p>	If the &quot;EG&quot; design is specified, a two column matrix containing the raw sample frequencies 
coming from the two groups of scores to be equated. It is assumed that the data in the first 
and second columns come from tests <code class="reqn">X</code> and <code class="reqn">Y</code>, respectively.
</p>
<p>If the &quot;SG&quot; design is specified, a matrix containing the (joint) bivariate sample 
frequencies for <code class="reqn">X</code> (raws) and <code class="reqn">Y</code> (columns).
</p>
<p>If the &quot;CB&quot; design is specified, a two column matrix containing the observed scores 
of the sample taking test <code class="reqn">X</code> first, followed by test <code class="reqn">Y</code>. The <code>scores2</code> 
argument is then used for the scores of the sample taking test Y first followed by test 
<code class="reqn">X</code>.
</p>
<p>If either the &quot;NEAT_CB&quot; or &quot;NEAT_PSE&quot; design is selected, a two column matrix containing 
the observed scores on	test <code class="reqn">X</code> (first column) and the observed scores on the anchor 
test <code class="reqn">A</code> (second column). The <code>scores2</code> argument is then used for the observed 
scores on test <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_kert">kert</code></td>
<td>
<p>		A character string giving the type of kernel to be used for continuization. 
Current options include &quot;<code>gauss</code>&quot;, &quot;<code>logis</code>&quot;, &quot;<code>uniform</code>&quot;, &quot;<code>epan</code>&quot; and &quot;<code>adap</code>&quot; 
for the gaussian, logistic, uniform, Epanechnikov and Adaptative kernels, respectively</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_hx">hx</code></td>
<td>
<p>		An integer indicating the value of the bandwidth parameter to be used for kernel continuization 
of <code class="reqn">F(x)</code>. If not provided (Default), this value is automatically calculated (see 
details).</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_hy">hy</code></td>
<td>
<p>		An integer indicating the value of the bandwidth parameter to be used for kernel continuization 
of <code class="reqn">G(y)</code>. If not provided (Default), this value is automatically calculated (see 
details).</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_degree">degree</code></td>
<td>
<p>	A vector indicating the number of power moments to be fitted to the marginal distributions 
(&quot;EG&quot; design), and/or the number or cross moments to be fitted to the joint distributions 
(see Details).</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_design">design</code></td>
<td>
<p>	A character string indicating the equating design (one of &quot;EG&quot;, &quot;SG&quot;, &quot;CB&quot;, &quot;NEAT_CE&quot;, 
&quot;NEAT_PSE&quot;)</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_kp">Kp</code></td>
<td>
<p>		A number which acts as a weight for the second term in the combined penalization function used 
to obtain <code>h</code> (see details).</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_scores2">scores2</code></td>
<td>
<p>	Only used for the &quot;CB&quot;, &quot;NEAT_CE&quot; and &quot;NEAT_PSE&quot; designs. See the description of
<code>scores</code>.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_degreexa">degreeXA</code></td>
<td>
<p>	A vector indicating the	number of power moments to be fitted to the marginal distributions 
<code class="reqn">X</code> and <code class="reqn">A</code>, and the number or cross moments to be fitted to the joint 
distribution <code class="reqn">(X,A)</code>	(see details). Only used for the &quot;NEAT_CE&quot; and &quot;NEAT_PSE&quot; designs.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_degreeya">degreeYA</code></td>
<td>
<p>	Only used for the &quot;NEAT_CE&quot; and &quot;NEAT_PSE&quot; designs (see the description for
<code>degreeXA</code>)</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_j">J</code></td>
<td>
<p>		The number of possible <code class="reqn">X</code> scores. Only needed for &quot;CB&quot;, &quot;NEAT_CB&quot; and &quot;NEAT_PSE&quot; designs</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_k">K</code></td>
<td>
<p>		The number of possible <code class="reqn">Y</code> scores. Only needed for &quot;CB&quot;, &quot;NEAT_CB&quot; and &quot;NEAT_PSE&quot; designs</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_l">L</code></td>
<td>
<p>		The number of possible <code class="reqn">A</code> scores. Needed for &quot;NEAT_CB&quot; and &quot;NEAT_PSE&quot; designs</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_wx">wx</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_X\leq 1</code> indicating the weight put on the data 
that is not subject to order effects. Only used for the &quot;CB&quot; design.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_wy">wy</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_Y\leq 1</code> indicating the weight put on the data 
that is not subject to order effects. Only used for the &quot;CB&quot; design.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_w">w</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w\leq 1</code> indicating the weight given to 
population <code class="reqn">P</code>. Only used for the &quot;NEAT&quot; design.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_gapsx">gapsX</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt><dd><p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">J</code> to smooth &quot;gaps&quot;, usually ocurring at regular intervals due to scores rounded to integer values and other methodological factors. </p>
</dd>
<dt><code>degree</code></dt><dd><p>An integer indicating the maximum degree of the moments fitted by the log-linear model.</p>
</dd>
</dl>

<p>Only used for the &quot;NEAT&quot; design.
</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_gapsy">gapsY</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt><dd><p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">K</code>.</p>
</dd>
<dt><code>degree</code></dt><dd><p>An integer indicating the maximum degree of the moments fitted.</p>
</dd>
</dl>

<p>Only used for the &quot;NEAT&quot; design.
</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_gapsa">gapsA</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt><dd><p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">L</code>. </p>
</dd>
<dt><code>degree</code></dt><dd><p>An integer indicating the maximum degree of the moments fitted.</p>
</dd>
</dl>

<p>Only used for the &quot;NEAT&quot; design.
</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_lumpx">lumpX</code></td>
<td>
<p>An integer to represent the index where an artificial &quot;lump&quot; is created in the marginal distribution of frecuencies for <code class="reqn">X</code> due to recording of negative rounded formulas or any other methodological artifact.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_lumpy">lumpY</code></td>
<td>
<p>An integer to represent the index where an artificial &quot;lump&quot; is created in the marginal distribution of frecuencies for <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_lumpa">lumpA</code></td>
<td>
<p>An integer to represent the index where an artificial &quot;lump&quot; is created in the marginal distribution of frecuencies for <code class="reqn">A</code>.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_alpha">alpha</code></td>
<td>
<p>Only for Adaptative Kernel. Sensitivity parameter.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_h.adap">h.adap</code></td>
<td>
<p>Only for Adaptative Kernel. A list(hx, hy) containing bandwidths for Adaptative kernel for each Form.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_r">r</code></td>
<td>
<p>Score probabilities for <code class="reqn">X</code> scores.</p>
</td></tr>
<tr><td><code id="ker.eq_+3A_s">s</code></td>
<td>
<p>Score probabilities for <code class="reqn">Y</code> scores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function that implements the kernel method of test equating as described in Von Davier et al.
(2004). Given test scores <code class="reqn">X</code> and <code class="reqn">Y</code>, the functions calculates 
</p>
<p style="text-align: center;"><code class="reqn">\hat{e}_Y(x)=G_{h_{Y}}^{-1}(F_{h_{X}}(x;\hat{r}),\hat{s})</code>
</p>

<p>where <code class="reqn">\hat{r}</code> and <code class="reqn">\hat{s}</code> are estimated score probabilities obtained via loglinear
smoothing (see <code><a href="#topic+loglin.smooth">loglin.smooth</a></code>). The value of <code class="reqn">h_X</code> and <code class="reqn">h_Y</code> can either be specified 
by the user or left unspecified (default) in which case they are automatically calculated. For instance, one can
specifies large values of <code class="reqn">h_X</code> and <code class="reqn">h_Y</code>, so that the <code class="reqn">\hat{e}_Y(x)</code> tends to the 
linear equating function (see Theorem 4.5 in Von Davier et al, 2004 for more details). 
</p>


<h3>Value</h3>

<p>	An object of class <code>ker.eq</code> representing the kernel equating process. Generic functions such as 
<code>print</code>, and <code>summary</code> have methods to show the results of the equating. The results include 
summary statistics, equated values, standard errors of equating, and others.  
</p>
<p>The function <code><a href="#topic+SEED">SEED</a></code> can be used to obtain standard error of equating differences (SEED) of two 
objects of class <code>ker.eq</code>. The function <code><a href="#topic+PREp">PREp</a></code> can be used on a <code>ker.eq</code> object to 
obtain the percentage relative error measure (see Von Davier et al, 2004). 
</p>
<table role = "presentation">
<tr><td><code>Scores</code></td>
<td>
<p>The possible values of <code class="reqn">x_j</code> and <code class="reqn">y_k</code></p>
</td></tr>
<tr><td><code>eqYx</code></td>
<td>
<p>The equated values of test <code class="reqn">X</code> in test <code class="reqn">Y</code> scale</p>
</td></tr>
<tr><td><code>eqXy</code></td>
<td>
<p>The equated values of test <code class="reqn">Y</code> in test <code class="reqn">X</code> scale</p>
</td></tr>
<tr><td><code>SEEYx</code></td>
<td>
<p>The standard error of equating for equating <code class="reqn">X</code> to <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>SEEXy</code></td>
<td>
<p>The standard error of equating for equating <code class="reqn">Y</code> to <code class="reqn">X</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Holland, P. and Thayer, D. (1989). The kernel method of equating score distributions. 
(Technical Report No 89-84). Princeton, NJ: Educational Testing Service.
</p>
<p>Holland, P., King, B. and Thayer, D. (1989). The standard error of equating for the kernel method 
of equating score distributions (Tech. Rep. No. 89-83). Princeton, NJ: Educational Testing Service. 
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglin.smooth">loglin.smooth</a></code>, <code><a href="#topic+SEED">SEED</a></code>, <code><a href="#topic+PREp">PREp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Kernel equating under the "EG" design
data(Math20EG)
mod&lt;-ker.eq(scores=Math20EG,kert="gauss",hx=NULL,hy=NULL,degree=c(2,3),design="EG") 

summary(mod)

#Reproducing Table 7.6 in Von Davier et al, (2004)

scores&lt;-0:20
SEEXy&lt;-mod$SEEXy
SEEYx&lt;-mod$SEEYx

Table7.6&lt;-cbind(scores,SEEXy,SEEYx)
Table7.6

#Other nonstandard kernels. Table 10.3 in Von Davier (2011).

mod.logis&lt;-ker.eq(scores=Math20EG,kert="logis",hx=NULL,hy=NULL,degree=c(2,3),design="EG") 
mod.unif&lt;-ker.eq(scores=Math20EG,kert="unif",hx=NULL,hy=NULL,degree=c(2,3),design="EG") 
mod.gauss&lt;-ker.eq(scores=Math20EG,kert="gauss",hx=NULL,hy=NULL,degree=c(2,3),design="EG") 

XtoY&lt;-cbind(mod.logis$eqYx,mod.unif$eqYx,mod.gauss$eqYx)
YtoX&lt;-cbind(mod.logis$eqXy,mod.unif$eqXy,mod.gauss$eqXy)

Table10.3&lt;-cbind(XtoY,YtoX)
Table10.3

## Examples using Adaptive and Epanechnikov kernels
x_sim = c(1,2,3,4,5,6,7,8,9,10,11,10,9,8,7,6,5,4,3,2,1)
prob_sim = x_sim/sum(x_sim)
set.seed(1)
sim = rmultinom(1, p = prob_sim, size = 1000)

x_asimD = c(1,7,13,18,22,24,25,24,20,18,16,15,13,9,5,3,2.5,1.5,1.5,1,1)
probas_asimD = x_asimD/sum(x_asimD)
set.seed(1)
asim = rmultinom(1, p = probas_asimD, size = 1000)

scores = cbind(asim,sim)

mod.adap  = ker.eq(scores,degree=c(2,2),design="EG",kert="adap")
mod.epan  = ker.eq(scores,degree=c(2,2),design="EG",kert="epan")
</code></pre>

<hr>
<h2 id='le.eq'>Local equating methods</h2><span id='topic+le.eq'></span><span id='topic+le.eq.default'></span>

<h3>Description</h3>

<p>This function implements the local method of equating as descibed in van der Linden (2011). </p>


<h3>Usage</h3>

<pre><code class='language-R'>le.eq(S.X, It.X, It.Y, Theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="le.eq_+3A_s.x">S.X</code></td>
<td>
<p>		A vector containing the observed scores of the sample taking test <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="le.eq_+3A_it.x">It.X</code></td>
<td>
<p>		A matrix of item parameter estimates coming from an IRT model for test form <code class="reqn">X</code> 
(difficulty, discrimation and guessing parameters are located in the first, second and 
third column, respectively).</p>
</td></tr>
<tr><td><code id="le.eq_+3A_it.y">It.Y</code></td>
<td>
<p>		A matrix of item parameter estimates coming from an IRT model for test form <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="le.eq_+3A_theta">Theta</code></td>
<td>
<p>		Either a number or vector of values representing the value of <code>theta</code> where to 
condition on (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the local equating method as described in van der Linden (2011). Based on 
Lord (1980) principle of equity, local equating methods utilizes the conditional on abilities distributions 
of scores to obtain the transformation <code class="reqn">\varphi</code>. The method leads to a family of transformations 
of the form
</p>
<p style="text-align: center;"><code class="reqn">\varphi(x;\theta)=G_{Y\mid\theta}^{-1}(F_{X\mid\theta}(x)),\quad \theta\in\mathcal{R}</code>
</p>

<p>The conditional distributions of <code class="reqn">X</code> and <code class="reqn">Y</code> are obtained using the algorithm described by 
Lord and Wingersky (1984). Among other possibilities, a value for <code class="reqn">\theta</code> can be a EAP, ML or MAP estimation of it, for and underlying 
IRT model (for example, using the <code>ltm</code> R package (Rizopoulos, 2006)). 
</p>


<h3>Value</h3>

<p>A list containing the observed scores to be equated, the corresponding ability estimates where to condition on, and the equated values</p>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Lord, F. (1980). <em>Applications of Item Response Theory to Practical Testing Problems</em>. 
Lawrence Erlbaum Associates, Hillsdale, NJ.
</p>
<p>Lord, F. and Wingersky, M. (1984). Comparison of IRT True-Score and Equipercentile Observed-Score Equatings. 
<em>Applied Psychological Measurement,8(4),</em> 453&ndash;461.
</p>
<p>Rizopoulos, D. (2006). ltm: An R package for latent variable modeling and item response theory analyses. 
<em>Journal of Statistical Software, 17(5),</em> 1&ndash;25.
</p>
<p>van der Linden, W. (2011). Local Observed-Score Equating. In A. von Davier (Ed.) 
<em>Statistical Models for Test Equating, Scaling, and Linking</em>. New York, NY: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mea.eq">mea.eq</a></code>, <code><a href="#topic+eqp.eq">eqp.eq</a></code>, <code><a href="#topic+lin.eq">lin.eq</a></code> <code><a href="#topic+ker.eq">ker.eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Artificial data for two 5-items tests forms. Both forms are assumed
## being fitted by a 3PL model.

## Create (artificial) item parameters matrices for test form X and Y
ai&lt;-c(1,0.8,1.2,1.1,0.9)
bi&lt;-c(-2,-1,0,1,2)
ci&lt;-c(0.1,0.15,0.05,0.1,0.2)
itx&lt;-rbind(bi,ai,ci)
ai&lt;-c(0.5,1.4,1.2,0.8,1)
bi&lt;-c(-1,-0.5,1,1.5,0)
ci&lt;-c(0.1,0.2,0.1,0.15,0.1)
ity&lt;-rbind(bi,ai,ci)

#Two individuals with different ability (1 and 2) obtain the same score 2.
#Their corresponding equated scores values are:
le.eq(c(2,2),itx,ity,c(1,2))

</code></pre>

<hr>
<h2 id='lin.eq'>The linear method of equating</h2><span id='topic+lin.eq'></span><span id='topic+lin.eq.default'></span>

<h3>Description</h3>

<p>This function implements the linear method of test equating  as described in Kolen and Brennan (2004). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin.eq(sx, sy, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lin.eq_+3A_sx">sx</code></td>
<td>
<p>		A vector containing the observed scores of the sample taking test <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="lin.eq_+3A_sy">sy</code></td>
<td>
<p>		A vector containing the observed scores of the sample taking test <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="lin.eq_+3A_scale">scale</code></td>
<td>
<p>		Either an integer or vector containing the values on the scale to be equated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the linear method of equating as described in Kolen and Brennan (2004). Given observed scores
<code class="reqn">sx</code> and <code class="reqn">sy</code>, the functions calculates 
</p>
<p style="text-align: center;"><code class="reqn">\varphi(x;\mu_x,\mu_y,\sigma_x,\sigma_y)=\frac{\sigma_x}{\sigma_y}(x-\mu_x)+\mu_y</code>
</p>

<p>where <code class="reqn">\mu_x,\mu_y,\sigma_x,\sigma_y</code> are the score means and standard deviations on test <code class="reqn">X</code> and <code class="reqn">Y</code>, 
respectively.
</p>


<h3>Value</h3>

<p>A two column matrix with the values of <code class="reqn">\varphi()</code> (second column) for each scale value <code>x</code> (first column)</p>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mea.eq">mea.eq</a></code>, <code><a href="#topic+eqp.eq">eqp.eq</a></code>, <code><a href="#topic+ker.eq">ker.eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Artificial data for two two 100 item tests forms and 5 individuals in each group
x1&lt;-c(67,70,77,79,65,74)
y1&lt;-c(77,75,73,89,68,80)

#Score means and sd
mean(x1); mean(y1)
sd(x1); sd(y1)

#An equivalent form y1 score of 72 on form x1
lin.eq(x1,y1,72)

#Equivalent form y1 score for the whole scale range
lin.eq(x1,y1,0:100)

#A plot comparing mean, linear and identity equating
plot(0:100,0:100, type='l', xlim=c(-20,100),ylim=c(0,100),lwd=2.0,lty=1,
ylab="Form Y raw score",xlab="Form X raw score")
abline(a=5,b=1,lwd=2,lty=2)
abline(a=mean(y1)-(sd(y1)/sd(x1))*mean(x1),b=sd(y1)/sd(x1),,lwd=2,lty=3)
arrows(72, 0, 72, 77,length = 0.15,code=2,angle=20)
arrows(72, 77, -20, 77,length = 0.15,code=2,angle=20)
abline(v=0,lty=2)
legend("bottomright",lty=c(1,2,3), c("Identity","Mean","Linear"),lwd=c(2,2,2))

</code></pre>

<hr>
<h2 id='loglin.smooth'>Pre-smoothing using log-linear models.</h2><span id='topic+loglin.smooth'></span><span id='topic+loglin.smooth.default'></span>

<h3>Description</h3>

<p>This function fits log-linear models to score data and provides estimates of 
the (vector of) score probabilities as well as the <code>C</code> matrix decomposition of their 
covariance matrix, according to the specified equating design (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglin.smooth(scores, degree, design, scores2, degreeXA, degreeYA, 
J, K, L, wx, wy, w, gapsX, gapsY, gapsA, lumpX, lumpY, lumpA,...)</code></pre>


<h3>Arguments</h3>

<p>		Note that depending on the specified equating design, not all arguments are necessary 
as detailed below. 
</p>
<table role = "presentation">
<tr><td><code id="loglin.smooth_+3A_scores">scores</code></td>
<td>
<p>	If the &quot;EG&quot; design is specified, a vector containing the raw sample frequencies 
coming from one group taking the test.
</p>
<p>If the &quot;SG&quot; design is specified, a matrix containing the (joint) bivariate sample 
frequencies for <code class="reqn">X</code> (raws) and <code class="reqn">Y</code> (columns).
</p>
<p>If the &quot;CB&quot; design is specified, a two column matrix containing the observed scores 
of the sample taking test <code class="reqn">X</code> first, followed by test <code class="reqn">Y</code>. The <code>scores2</code> 
argument is then used for the scores of the sample taking test Y first followed by test 
<code class="reqn">X</code>.
</p>
<p>If either the &quot;NEAT_CB&quot; or &quot;NEAT_PSE&quot; design is selected, a two column matrix containing 
the observed scores on	test <code class="reqn">X</code> (first column) and the observed scores on the anchor 
test <code class="reqn">A</code> (second column). The <code>scores2</code> argument is then used for the observed 
scores on test <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_degree">degree</code></td>
<td>
<p>	Either a number or vector indicating the number of power moments to be fitted to the 
marginal distributions, or the number or cross moments to be fitted to the joint 
distributions, respectively. For the &quot;EG&quot; design it will be a number (see Details).</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_design">design</code></td>
<td>
<p>	A character string indicating the equating design (one of &quot;EG&quot;, &quot;SG&quot;, &quot;CB&quot;, &quot;NEAT_CE&quot;, 
&quot;NEAT_PSE&quot;)</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_scores2">scores2</code></td>
<td>
<p>       Only used for the &quot;CB&quot;, &quot;NEAT_CE&quot; and &quot;NEAT_PSE&quot; designs. See the description of
<code>scores</code>.</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_degreexa">degreeXA</code></td>
<td>
<p>  A vector indicating the	number of power moments to be fitted to the marginal distributions <code class="reqn">X</code> and <code class="reqn">A</code>,
and the number or cross moments to be fitted to the joint distribution <code class="reqn">(X,A)</code>
(see details). Only used for the &quot;NEAT_CE&quot; and &quot;NEAT_PSE&quot; designs.</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_degreeya">degreeYA</code></td>
<td>
<p>	Only used for the &quot;NEAT_CE&quot; and &quot;NEAT_PSE&quot; designs (see the description for
<code>degreeXA</code>)</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_j">J</code></td>
<td>
<p>		The number of possible <code class="reqn">X</code> scores. Only needed for &quot;CB&quot;, &quot;NEAT_CB&quot; and &quot;NEAT_PSE&quot; designs</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_k">K</code></td>
<td>
<p>		The number of possible <code class="reqn">Y</code> scores. Only needed for &quot;CB&quot;, &quot;NEAT_CB&quot; and &quot;NEAT_PSE&quot; designs</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_l">L</code></td>
<td>
<p>		The number of possible <code class="reqn">A</code> scores. Needed for &quot;NEAT_CB&quot; and &quot;NEAT_PSE&quot; designs</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_wx">wx</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_X\leq 1</code> indicating the weight put on the 
data that is not subject to order effects. Only used for the &quot;CB&quot; design.</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_wy">wy</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w_Y\leq 1</code> indicating the weight put on the 
data that is not subject to order effects. Only used for the &quot;CB&quot; design.</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_w">w</code></td>
<td>
<p>		A number that satisfies <code class="reqn">0\leq w\leq 1</code> indicating the weight given to 
population <code class="reqn">P</code>. Only used for the &quot;NEAT&quot; design.</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_gapsx">gapsX</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt><dd><p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">J</code> to smooth &quot;gaps&quot;, usually ocurring at regular intervals due to scores rounded to integer values and other methodological factors. </p>
</dd>
<dt><code>degree</code></dt><dd><p>An integer indicating the maximum degree of the moments fitted by the log-linear model.</p>
</dd>
</dl>

<p>Only used for the &quot;NEAT&quot; design.
</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_gapsy">gapsY</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt><dd><p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">K</code>.</p>
</dd>
<dt><code>degree</code></dt><dd><p>An integer indicating the maximum degree of the moments fitted.</p>
</dd>
</dl>

<p>Only used for the &quot;NEAT&quot; design.
</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_gapsa">gapsA</code></td>
<td>
<p> A <em>list</em> object containing:
</p>

<dl>
<dt><code>index</code></dt><dd><p>A vector of indices between <code class="reqn">0</code> and <code class="reqn">L</code>. </p>
</dd>
<dt><code>degree</code></dt><dd><p>An integer indicating the maximum degree of the moments fitted.</p>
</dd>
</dl>

<p>Only used for the &quot;NEAT&quot; design.
</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_lumpx">lumpX</code></td>
<td>
<p>An integer to represent the index where an artificial &quot;lump&quot; is created in the marginal distribution of frecuencies for <code class="reqn">X</code> due to recording of negative rounded formulas or any other methodological artifact.</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_lumpy">lumpY</code></td>
<td>
<p>An integer to represent the index where an artificial &quot;lump&quot; is created in the marginal distribution of frecuencies for <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_lumpa">lumpA</code></td>
<td>
<p>An integer to represent the index where an artificial &quot;lump&quot; is created in the marginal distribution of frecuencies for <code class="reqn">A</code>.</p>
</td></tr>
<tr><td><code id="loglin.smooth_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits loglinear models as described in Holland and Thayer (1987), and Von Davier 
et al. (2004). The following general equation can be used to represent the models according to 
the different designs used, in which the vector <code class="reqn">o</code> (or matrix) of (marginal or bivariate) 
score probabilities satisfies the log-linear model: 
</p>
<p style="text-align: center;"><code class="reqn">\log(o_{gh})=\alpha_m+Z_m(z_g)+W_m(w_h)+ZW_m(z_g,w_h)</code>
</p>

<p>where <code class="reqn">Z_m(z_g)=\sum_{i=1}^{T_{Zm}}\beta_{zmi}(z_g)^i</code>, 
<code class="reqn">W_m(w_h)=\sum_{i=1}^{T_{Wm}}\beta_{Wmi}(w_h)^i</code>, and, 
<code class="reqn">ZW_m(z_g,w_h)=\sum_{i=1}^{I_{Zm}}\sum_{i'=1}^{I_{Wm}}\beta_{ZWmii'}(z_g)^i(w_h)^{i'}</code>.
</p>
<p>The symbols will vary according to the different equating designs specified. Possible values are: 
<code class="reqn">o=p_{(12)}, p_{(21)}, p, q</code>; <code class="reqn">Z=X, Y</code>; <code class="reqn">W=Y, A</code>; 
<code class="reqn">z=x, y</code>; <code class="reqn">w=y, a</code>; <code class="reqn">m=(12), (21), P, Q</code>; <code class="reqn">g=j, k</code>; 
<code class="reqn">h=l, k</code>.
</p>
<p>Particular cases of this general equation for each of the equating designs can be found in 
Von Davier et al (2004) (e.g., Equations (7.1) and (7.2) for the &quot;EG&quot; design, Equation (8.1) for the &quot;SG&quot; design, 
Equations (9,1) and (9.2) for the &quot;CB&quot; design).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sp.est</code></td>
<td>
<p>The estimated score probabilities</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>The C matrix which is so that <code class="reqn">\Sigma=CC^t</code></p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Holland, P. and Thayer, D. (1987). Notes on the use of loglinear models for fitting 
discrete probability distributions. Research Report 87-31, Princeton NJ: Educational 
Testing Service.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>
<p>[1]	Moses, T. &quot;Paper SA06_05 Using PROC GENMOD for Loglinear Smoothing Tim Moses and Alina A. von Davier, Educational Testing Service, Princeton, NJ&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+ker.eq">ker.eq</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#Table 7.4 from Von Davier et al. (2004)
data(Math20EG)
rj&lt;-loglin.smooth(scores=Math20EG[,1],degree=2,design="EG")$sp.est
sk&lt;-loglin.smooth(scores=Math20EG[,2],degree=3,design="EG")$sp.est
score&lt;-0:20
Table7.4&lt;-cbind(score,rj,sk)
Table7.4

## Example taken from [1]
score &lt;- 0:20
freq &lt;- c(10, 2, 5, 8, 7, 9, 8, 7, 8, 5, 5, 4, 3, 0, 2, 0, 1, 0, 2, 1, 0)
ldata &lt;- data.frame(score, freq)

plot(ldata, pch=16, main="Data w Lump at 0")
m1 = loglin.smooth(scores=ldata$freq,kert="gauss",degree=c(3),design="EG")
m2 = loglin.smooth(scores=ldata$freq,kert="gauss",degree=c(3),design="EG",lumpX=0)
Ns = sum(ldata$freq)
points(m1$sp.est*Ns, col=2, pch=16)
points(m2$sp.est*Ns, col=3, pch=16) # Preserves the lump
</code></pre>

<hr>
<h2 id='Math20EG'>Scores on two 20-items mathematics tests.
</h2><span id='topic+Math20EG'></span>

<h3>Description</h3>

<p>The data set contains raw sample frequencies of number-right scores for two parallel 
20-items mathematics tests given to two samples from a national population of 
examinees. This data has been described and analized by Holland and Thayer (1989); 
Von Davier et al, (2004) (see also Von Davier, 2011 where other applications using 
these data set are shown).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Math20EG)</code></pre>


<h3>Format</h3>

<p>A 21x2 matrix containing raw sample frequencies (raws) for two parallel tests (columns) 
</p>


<h3>References</h3>

<p>Holland, P. and Thayer, D. (1989). The kernel method of equating score distributions. 
(Technical Report No 89-84). Princeton, NJ: Educational Testing Service.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Math20EG)
## maybe str(Math20EG) ; ...
</code></pre>

<hr>
<h2 id='Math20SG'>Bivariate score frequencies on two 20-items mathematics tests.
</h2><span id='topic+Math20SG'></span>

<h3>Description</h3>

<p>The data set contains the bivariate sample frequencies of number-right scores 
for two parallel 20-items mathematics tests given to a sample from a national population of 
examinees. This data has been described and analized by Holland and Thayer (1989); 
Von Davier et al, (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Math20SG)</code></pre>


<h3>Format</h3>

<p>A 21x21 matrix containing the bivariate sample frequencies for <code class="reqn">X</code> (raws) and <code class="reqn">Y</code> 
(columns) 
</p>


<h3>References</h3>

<p>Holland, P. and Thayer, D. (1989). The kernel method of equating score distributions. 
(Technical Report No 89-84). Princeton, NJ: Educational Testing Service.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Math20SG)
## maybe str(Math20SG) ; ...
</code></pre>

<hr>
<h2 id='mea.eq'>The mean method of equating</h2><span id='topic+mea.eq'></span><span id='topic+mea.eq.default'></span>

<h3>Description</h3>

<p>This function implements the mean method of test equating  as described in Kolen and Brennan (2004). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mea.eq(sx, sy, scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mea.eq_+3A_sx">sx</code></td>
<td>
<p>		A vector containing the observed scores of the sample taking test <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="mea.eq_+3A_sy">sy</code></td>
<td>
<p>		A vector containing the observed scores of the sample taking test <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="mea.eq_+3A_scale">scale</code></td>
<td>
<p>		Either an integer or vector containing the values on the scale to be equated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the mean method of equating as described in Kolen and Brennan (2004). Given observed scores
<code class="reqn">sx</code> and <code class="reqn">sy</code>, the functions calculates 
</p>
<p style="text-align: center;"><code class="reqn">\varphi(x;\mu_x,\mu_y)=x-\mu_x+\mu_y</code>
</p>

<p>where <code class="reqn">\mu_x</code> and <code class="reqn">\mu_y</code> are the score means on test <code class="reqn">X</code> and <code class="reqn">Y</code>, respectively.
</p>


<h3>Value</h3>

<p>A two column matrix with the values of <code class="reqn">\varphi()</code> (second column) for each scale value <code>x</code> (first column)</p>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a></p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Kolen, M., and Brennan, R. (2004). <em>Test Equating, Scaling and Linking</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lin.eq">lin.eq</a></code>, <code><a href="#topic+eqp.eq">eqp.eq</a></code>, <code><a href="#topic+ker.eq">ker.eq</a></code>, <code><a href="#topic+le.eq">le.eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Artificial data for two two 100 item tests forms and 5 individuals in each group
x1&lt;-c(67,70,77,79,65,74)
y1&lt;-c(77,75,73,89,68,80)

#Score means
mean(x1); mean(y1)

#An equivalent form y1 score of 72 on form x1
mea.eq(x1,y1,72)

#Equivalent form y1 score for the whole scale range
mea.eq(x1,y1,0:100)
</code></pre>

<hr>
<h2 id='PREp'>Percent relative error</h2><span id='topic+PREp'></span><span id='topic+PREp.default'></span>

<h3>Description</h3>

<p>This function calculates the percent relative error as described in Von Davier et al. (2004). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PREp(eq, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PREp_+3A_eq">eq</code></td>
<td>
<p>	An object of class <code>ker.eq</code> previously obtained using <code><a href="#topic+ker.eq">ker.eq</a></code>.
</p>
</td></tr>
<tr><td><code id="PREp_+3A_p">p</code></td>
<td>
<p>	The number of moments to be calculated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PREp (when equating form <code>X</code> to <code>Y</code>) is calculated as 
</p>
<p style="text-align: center;"><code class="reqn">\mbox{PREp}=100\frac{\mu_p(e_Y(X))-\mu_p(Y)}{\mu_p(Y)}</code>
</p>

<p>where <code class="reqn">\mu_p(Y)=\sum_k(y_k)^ps_k</code> and 
<code class="reqn">\mu_p(e_Y(X))=\sum_j(e_Y(x_j))^pr_j</code>. Similar formulas can be found 
when equating from <code>Y</code> to <code>X</code>.
</p>


<h3>Value</h3>

<p> A matrix containing the PREp for both <code>X</code> to <code>Y</code> (first column) and <code>Y</code> to <code>X</code> 
(second column) cases.
</p>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a>
</p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ker.eq">ker.eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example: Table 7.5 in Von Davier et al. (2004)

data(Math20EG)
mod.gauss&lt;-ker.eq(scores=Math20EG,kert="gauss", hx = NULL, hy = NULL,degree=c(2, 3),design="EG")
PREp(mod.gauss,10)

</code></pre>

<hr>
<h2 id='rowBlockSum'>Take a matrix and sum blocks of rows</h2><span id='topic+rowBlockSum'></span>

<h3>Description</h3>

<p> This function implements a method to sum blocks of rows in a matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowBlockSum(mat, blocksize, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowBlockSum_+3A_mat">mat</code></td>
<td>
<p>Input matrix</p>
</td></tr>
<tr><td><code id="rowBlockSum_+3A_blocksize">blocksize</code></td>
<td>
<p>Size of the row blocks</p>
</td></tr>
<tr><td><code id="rowBlockSum_+3A_w">w</code></td>
<td>
<p>(Optional) Vector for weighted sum</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original data set contains very long column headers. This function
does a keyword search over the headers to find those column headers that
match a particular keyword, e.g., mean, median, etc.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Daniel Acuna Leon. <a href="mailto:dnacuna@uc.cl">dnacuna@uc.cl</a></p>

<hr>
<h2 id='SEED'>Standard error of equating difference
</h2><span id='topic+SEED'></span><span id='topic+SEED.default'></span>

<h3>Description</h3>

<p>This function calculates the standard error of equating diference (SEED) as described in 
Von Davier et al. (2004). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEED(eq1, eq2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEED_+3A_eq1">eq1</code></td>
<td>
<p>	An object of class <code>ker.eq</code> which contains one of the two estimated equated functions to be used 
for the SEED.</p>
</td></tr>
<tr><td><code id="SEED_+3A_eq2">eq2</code></td>
<td>
<p>	An object of class <code>ker.eq</code> which contains one of the two estimated equated functions to be used 
for the SEED.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SEED can be used as a measure to choose whether to support or not a certain equating function on another 
another one. For instance, when <code class="reqn">h_X</code> and <code class="reqn">h_Y</code> tends to infinity, then the (gaussian kernel) 
<code class="reqn">\hat{e}_Y(x)</code> equating function tends to the linear equating function 
(see Theorem 4.5 in Von Davier et al, 2004 for more details). Thus, one can calculate the measure
</p>
<p style="text-align: center;"><code class="reqn">SEED_Y(x)=\sqrt{Var(\hat{e}_Y(x)-\widehat{Lin}_Y(x))}</code>
</p>

<p>to decide between <code class="reqn">\hat{e}_Y(x)</code> and <code class="reqn">\widehat{Lin}_Y(x)</code>.
</p>


<h3>Value</h3>

<p>A two column matrix with the values of <code>SEEYx</code> for each <code>x</code> in the first column and the values of 
<code>SEEXy</code> for each <code>y</code> in the second column</p>


<h3>Author(s)</h3>

<p>Jorge Gonzalez <a href="mailto:jorge.gonzalez@mat.uc.cl">jorge.gonzalez@mat.uc.cl</a>
</p>


<h3>References</h3>

<p>Gonzalez, J. (2014). SNSequate: Standard and Nonstandard Statistical Models and Methods for Test 
Equating. <em>Journal of Statistical Software, 59(7),</em> 1-30.
</p>
<p>Von Davier, A., Holland, P., and Thayer, D. (2004). <em>The Kernel Method of Test Equating</em>. 
New York, NY: Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ker.eq">ker.eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example: Figure7.7 in Von Davier et al, (2004)
data(Math20EG)

mod.gauss&lt;-ker.eq(scores=Math20EG,kert="gauss", hx = NULL, hy = NULL,degree=c(2, 3),design="EG")
mod.linear&lt;-ker.eq(scores=Math20EG,kert="gauss", hx = 20, hy = 20,degree=c(2, 3),design="EG")

Rx&lt;-mod.gauss$eqYx-mod.linear$eqYx
seed&lt;-SEED(mod.gauss,mod.linear)$SEEDYx

plot(0:20,Rx,ylim=c(-0.8,0.8),pch=15)
abline(h=0)
points(0:20,2*seed,pch=0)
points(0:20,-2*seed,pch=0)

#Example Figure 10.4 in Von Davier (2011)
mod.unif&lt;-ker.eq(scores=Math20EG,kert="unif", hx = NULL, hy = NULL,degree=c(2, 3),design="EG")
mod.logis&lt;-ker.eq(scores=Math20EG,kert="logis", hx = NULL, hy = NULL,degree=c(2, 3),design="EG")

Rx1&lt;-mod.logis$eqYx-mod.gauss$eqYx
Rx2&lt;-mod.unif$eqYx-mod.gauss$eqYx

seed1&lt;-SEED(mod.logis,mod.gauss)$SEEDYx
seed2&lt;-SEED(mod.unif,mod.gauss)$SEEDYx

plot(0:20,Rx1,ylim=c(-0.2,0.2),pch=15,main="LK vs GK",ylab="",xlab="Scores")
abline(h=0)
points(0:20,2*seed1,pch=0)
points(0:20,-2*seed1,pch=0)

plot(0:20,Rx2,ylim=c(-0.2,0.2),pch=15,main="UK vs GK",ylab="",xlab="Scores")
abline(h=0)
points(0:20,2*seed2,pch=0)
points(0:20,-2*seed2,pch=0)

</code></pre>

<hr>
<h2 id='SEPA'>A sample of observed score values for two different forms of the SEPA test. 
</h2><span id='topic+SEPA'></span>

<h3>Description</h3>

<p>The data set is from a private national evaluation system called SEPA. It
contains two test forms X and Y both composed of 50 items.
The SEPA data is a list containing two samples with 1,458 test takers who
took test form X and 2,619 test takers who took test form Y. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SEPA)</code></pre>


<h3>Format</h3>

<p>A list with elements containing the observed scores in test forms X and Y.
</p>


<h3>References</h3>

<p>Gonzalez, J. and Wiberg, M. (2017). <em>Applying test equating methods using R</em>. Springer. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SEPA)
## maybe str(SEPA) ; ...
</code></pre>

<hr>
<h2 id='sim_unimodal'>
Simulate test scores.
</h2><span id='topic+sim_unimodal'></span>

<h3>Description</h3>

<p>Simulate test scores from a negative-hypergeometric (beta-binomial) distribution, according to
Keats &amp; Lord (1962).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_unimodal(n, x_mean, x_var, N_item, seed = NULL, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_unimodal_+3A_n">n</code></td>
<td>

<p>Size of the resulting sample.
</p>
</td></tr>
<tr><td><code id="sim_unimodal_+3A_x_mean">x_mean</code></td>
<td>

<p>Mean of the target distribution.
</p>
</td></tr>
<tr><td><code id="sim_unimodal_+3A_x_var">x_var</code></td>
<td>

<p>Variance of the target distribution.
</p>
</td></tr>
<tr><td><code id="sim_unimodal_+3A_n_item">N_item</code></td>
<td>

<p>Number of items in the test.
</p>
</td></tr>
<tr><td><code id="sim_unimodal_+3A_seed">seed</code></td>
<td>

<p>Optional. Seed for the random number generator.
</p>
</td></tr>
<tr><td><code id="sim_unimodal_+3A_name">name</code></td>
<td>

<p>Optional. Generate X and Y scores from the data according 5 of the proposed distributions 
in Keats &amp; Lord (1967). Overrides any other previous parameter input set.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulate test scores from a negative-hypergeometric (beta-binomial) distribution, according to
Keats &amp; Lord (1962).
</p>


<h3>Value</h3>

<p>Simulated values.
</p>


<h3>Author(s)</h3>

<p>Daniel Leon Acuna, <a href="mailto:dnacuna@uc.cl">dnacuna@uc.cl</a>
</p>


<h3>References</h3>

<p>Keats, J. A., &amp; Lord, F. M. (1962). A theoretical distribution for mental test scores. Psychometrika, 27(1), 59-72.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim_unimodal(2354, 27.06, 8.19^2, 40)  # GANA
sim_unimodal(name="TQS8")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
