<!DOCTYPE html><html><head><title>Help for package dismo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dismo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acaule'><p>Solanum acaule data</p></a></li>
<li><a href='#Anguilla data'><p>Anguilla australis distribution data</p></a></li>
<li><a href='#bioclim'><p>Bioclim</p></a></li>
<li><a href='#biovars'><p>bioclimatic variables</p></a></li>
<li><a href='#boxplot'>
<p>Box plot of model evaluation data</p></a></li>
<li><a href='#calc.deviance'><p>Calculate deviance</p></a></li>
<li><a href='#circleHull'><p>Circle hull model</p></a></li>
<li><a href='#CirclesRange'><p>Circles range</p></a></li>
<li><a href='#Convex Hull'><p>Convex hull model</p></a></li>
<li><a href='#dcEvaluate'><p>Evaluate by distance class</p></a></li>
<li><a href='#density'><p>density</p></a></li>
<li><a href='#dismo-package'>
<p>Species distribution modeling</p></a></li>
<li><a href='#DistModel'><p>Class &quot;DistModel&quot;</p></a></li>
<li><a href='#domain'>
<p>Domain</p></a></li>
<li><a href='#ecocrop'><p>Ecocrop model</p></a></li>
<li><a href='#ecolim'><p>Ecolim model</p></a></li>
<li><a href='#evaluate'><p> Model evaluation</p></a></li>
<li><a href='#evaluateROCR'>
<p>Model testing with the ROCR package</p></a></li>
<li><a href='#Evaluation plots'>
<p>Plot model evaluation data</p></a></li>
<li><a href='#gbif'>
<p>Data from GBIF</p></a></li>
<li><a href='#gbm.fixed'><p>gbm fixed</p></a></li>
<li><a href='#gbm.holdout'><p>gbm holdout</p></a></li>
<li><a href='#gbm.interactions'><p>gbm interactions</p></a></li>
<li><a href='#gbm.perspec'>
<p>gbm perspective plot</p></a></li>
<li><a href='#gbm.plot'><p>gbm plot</p></a></li>
<li><a href='#gbm.plot.fits'><p>gbm plot fitted values</p></a></li>
<li><a href='#gbm.simplify'><p>gbm simplify</p></a></li>
<li><a href='#gbm.step'>
<p>gbm step</p></a></li>
<li><a href='#geocode'><p>Georeferencing with Google</p></a></li>
<li><a href='#Geographic Distance'><p>Geographic distance model</p></a></li>
<li><a href='#gmap'><p>Get a Google map</p></a></li>
<li><a href='#gridSample'><p>Stratified regular sample on a grid</p></a></li>
<li><a href='#InvDistW'><p>Inverse-distance weighted model</p></a></li>
<li><a href='#kfold'>
<p>k-fold partitioning</p></a></li>
<li><a href='#mahal'>
<p>Mahalanobis model</p></a></li>
<li><a href='#maxent'><p>Maxent</p></a></li>
<li><a href='#mess'><p>Multivariate environmental similarity surfaces (MESS)</p></a></li>
<li><a href='#ModelEvaluation'><p>Class &quot;ModelEvaluation&quot;</p></a></li>
<li><a href='#nicheEquivalency'><p>Niche equivalency</p></a></li>
<li><a href='#nicheOverlap'><p>Niche overlap</p></a></li>
<li><a href='#pairs'>
<p>Pair plots</p></a></li>
<li><a href='#plot'>
<p>Plot predictor values</p></a></li>
<li><a href='#pointValues'>
<p>point values</p></a></li>
<li><a href='#predict'><p>Distribution model predictions</p></a></li>
<li><a href='#prepareData'>
<p>Prepare data for model fitting</p></a></li>
<li><a href='#pwdSample'><p>Pair-wise distance sampling</p></a></li>
<li><a href='#Random null model'><p>Random null model</p></a></li>
<li><a href='#randomPoints'>
<p>Random points</p></a></li>
<li><a href='#rectHull'><p>Rectangular hull model</p></a></li>
<li><a href='#response'><p>response plots</p></a></li>
<li><a href='#ssb'><p>Spatial sorting bias</p></a></li>
<li><a href='#threshold'><p> Find a threshold</p></a></li>
<li><a href='#voronoi'>
<p>Voronoi polygons</p></a></li>
<li><a href='#Voronoi Hull'><p>Voronoi hull model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Species Distribution Modeling</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for species distribution modeling, that is, predicting the environmental similarity of any site to that of the locations of known occurrences of a species.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-14</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-20</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, methods, terra (&ge; 1.5-34)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.3), raster (&ge; 3.5-21), sp (&ge; 1.4-5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rJava (&ge; 0.9-7), XML, ROCR, deldir, gstat, randomForest,
kernlab, jsonlite, gbm (&ge; 2.1.1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 8)</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert J. Hijmans, Steven Phillips, John Leathwick and Jane Elith</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert J. Hijmans &lt;r.hijmans@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rspatial.org/raster/sdm/">https://rspatial.org/raster/sdm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rspatial/dismo/issues/">https://github.com/rspatial/dismo/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-20 15:55:45 UTC; rhijm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-21 23:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='acaule'>Solanum acaule data</h2><span id='topic+acaule'></span>

<h3>Description</h3>

<p>Distribution data for Solanum acaule (a plant species that occurs in the high Andes of Peru and Bolivia). 
Downloaded from GBIF with the <code><a href="#topic+gbif">gbif</a></code> function. For use in the 'species distribution modeling' vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(acaule)
</code></pre>


<h3>References</h3>

<p><a href="https://www.gbif.org">https://www.gbif.org</a>
</p>

<hr>
<h2 id='Anguilla+20data'>Anguilla australis distribution data</h2><span id='topic+Anguilla_train'></span><span id='topic+Anguilla_test'></span><span id='topic+Anguilla_grids'></span>

<h3>Description</h3>

<p>A number of sites with presence or absence of the short-finned eel (Anguilla australis) in New Zealand, and environmental data at these sites; and gridded data of the environmental variables for the study area. 
</p>

<table>
<tr>
 <td style="text-align: left;">  
type  </td><td style="text-align: left;"> variable name </td><td style="text-align: left;"> values </td><td style="text-align: left;"> mean and range </td>
</tr>
<tr>
 <td style="text-align: left;">
Reach </td><td style="text-align: left;"> LocSed </td><td style="text-align: left;"> weighted average of proportional cover of bed sediment </td><td style="text-align: left;"> 1=mud, 2=sand, 3=fine gravel; 4=coarse gravel; 5=cobble; 
6=boulder; 7=bedrock; 3.77, 1 to 7 </td>
</tr>
<tr>
 <td style="text-align: left;">
Segment </td><td style="text-align: left;"> SegSumT </td><td style="text-align: left;"> Summer air temperature (degrees C) </td><td style="text-align: left;"> 16.3, 8.9 to 19.8 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> SegTSeas </td><td style="text-align: left;">  Winter air temperature (degrees C), normalised with respect to SegJanT </td><td style="text-align: left;">  0.36, -4.2 to 4.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> SegLowFlow </td><td style="text-align: left;"> segment low flow (m3/sec), fourth root transformed </td><td style="text-align: left;"> 1.092, 1.0 to 4.09 </td>
</tr>
<tr>
 <td style="text-align: left;">
Downstream </td><td style="text-align: left;"> DSDist </td><td style="text-align: left;"> distance to coast (km) </td><td style="text-align: left;">  74, 0.03 to 433.4 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> DSDam </td><td style="text-align: left;"> presence of known downstream obstructions, mostly dams </td><td style="text-align: left;"> 0.18, 0 or 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> DSMaxSlope </td><td style="text-align: left;">  maximum downstream slope (degrees) </td><td style="text-align: left;">  3.1, 0 to 29.7 </td>
</tr>
<tr>
 <td style="text-align: left;">
Upstream 
/ catchment </td><td style="text-align: left;"> USAvgT </td><td style="text-align: left;">  average temperature in catchment (deg C) compared to segment, normalised with respect to SegJanT </td><td style="text-align: left;">  -0.38, -7.7 to 2.2 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> USRainDays </td><td style="text-align: left;"> days/month with rain greater than 25 mm </td><td style="text-align: left;"> 1.22, 0.21 to 3.30 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> USSlope </td><td style="text-align: left;"> average slope in the upstream catchment (degrees) </td><td style="text-align: left;"> 14.3, 0 to 41.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> USNative </td><td style="text-align: left;">  area with indigenous forest (proportion) </td><td style="text-align: left;">  0.57, 0 to 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td><td style="text-align: left;"> Fishing method </td><td style="text-align: left;">  fishing method in five classes: electric, net, spot, trap &amp; mixture </td><td style="text-align: left;"> NA </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>data(Anguilla_train)
data(Anguilla_test)
data(Anguilla_grids)
</code></pre>


<h3>Author(s)</h3>

<p>John R. Leathwick and Jane Elith
</p>


<h3>References</h3>

<p>Elith, J., J.R. Leathwick and T. Hastie, 2009. A working guide to boosted regression trees. Journal of Animal Ecology 77: 802-81
</p>

<hr>
<h2 id='bioclim'>Bioclim</h2><span id='topic+bioclim'></span><span id='topic+bioclim+2CRaster+2Cmatrix-method'></span><span id='topic+bioclim+2CRaster+2CSpatialPoints-method'></span><span id='topic+bioclim+2CRaster+2Cdata.frame-method'></span><span id='topic+bioclim+2CSpatialGridDataFrame+2Cmatrix-method'></span><span id='topic+bioclim+2CSpatialGridDataFrame+2CSpatialPoints-method'></span><span id='topic+bioclim+2Cmatrix+2Cmissing-method'></span><span id='topic+bioclim+2Cdata.frame+2Cmissing-method'></span><span id='topic+Bioclim-class'></span>

<h3>Description</h3>

<p>The Bioclim algorithm has been extensively used for species distribution modeling. Bioclim is the classic 'climate-envelope-model'. Although it generally does not perform as good as some other modeling methods (Elith et al. 2006) and is unsuited for predicting climate change effects (Hijmans and Graham, 2006). It is still used, however, among other reasons because the algorithm is easy to understand and thus useful in teaching species distribution modeling. 
</p>
<p>The BIOCLIM algorithm computes the similarity of a location by comparing the values of environmental variables at any location to a percentile distribution of the values at known locations of occurrence ('training sites'). The closer to the 50th percentile (the median), the more suitable the location is. The tails of the distribution are not distinguished, that is, 10 percentile is treated as equivalent to 90 percentile. 
</p>
<p>In this R implementation, percentile scores are between 0 and 1, but predicted values larger than 0.5 are subtracted from 1. Then, the minimum percentile score across all the environmental variables is computed (i.e. this is like Liebig's law of the minimum, except that high values can also be limiting factors). The final value is subtracted from 1 and multiplied with 2 so that the results are between 0 and 1. The reason for this transformation is that the results become more like that of other distribution modeling methods and are thus easier to interpret. The value 1 will rarely be observed as it would require a location that has the median value of the training data for all the variables considered. The value 0 is very common as it is assigned to all cells with a value of an environmental variable that is outside the percentile distribution (the range of the training data) for at least one of the variables. 
</p>
<p>In the <a href="#topic+predict">predict</a> function, you can choose to ignore one of the tails of the distribution (e.g, to make low rainfall a limiting factor, but not high rainfall),
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bioclim(x, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bioclim_+3A_x">x</code></td>
<td>
<p> Raster* object or matrix</p>
</td></tr>
<tr><td><code id="bioclim_+3A_p">p</code></td>
<td>
<p> two column matrix or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="bioclim_+3A_...">...</code></td>
<td>
<p> Additional arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'Bioclim' (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>References</h3>

<p>Nix, H.A., 1986. A biogeographic analysis of Australian elapid snakes. In: Atlas of Elapid Snakes of Australia. (Ed.) R. Longmore, pp. 4-15. Australian Flora and Fauna Series Number 7. Australian Government Publishing Service: Canberra.
</p>
<p>Booth, T.H., H.A. Nix, J.R. Busby and M.F. Hutchinson, 2014. BIOCLIM: the first species distribution modelling package, its early applications and relevance to most current MAXENT studies. Diversity and Distributions 20: 1-9
</p>
<p>Elith, J., C.H. Graham, R.P. Anderson, M. Dudik, S. Ferrier, A. Guisan, R.J. Hijmans, F. Huettmann, J. Leathwick, A. Lehmann, J. Li, L.G. Lohmann, B. Loiselle, 
G. Manion, C. Moritz, M. Nakamura, Y. Nakazawa, J. McC. Overton, A.T. Peterson, S. Phillips, K. Richardson, R. Scachetti-Pereira, R. Schapire, J. Soberon, 
S. Williams, M. Wisz and N. Zimmerman, 2006. 
Novel methods improve prediction of species' distributions from occurrence data. Ecography 29: 129-151. <a href="https://doi.org/10.1111/j.2006.0906-7590.04596.x">doi:10.1111/j.2006.0906-7590.04596.x</a>
</p>
<p>Hijmans R.J., and C.H. Graham, 2006. Testing the ability of climate envelope models to predict the effect of climate change on species distributions. Global change biology 12: 2272-2281. <a href="https://doi.org/10.1111/j.1365-2486.2006.01256.x">doi:10.1111/j.1365-2486.2006.01256.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a>, <a href="#topic+maxent">maxent</a>, <a href="#topic+domain">domain</a>, <a href="#topic+mahal">mahal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logo &lt;- stack(system.file("external/rlogo.grd", package="raster"))
#presence data
pts &lt;- matrix(c(48.243420, 48.243420, 47.985820, 52.880230, 49.531423, 46.182616, 54.168232, 
  69.624263, 83.792291, 85.337894, 74.261072, 83.792291, 95.126713, 84.565092, 66.275456, 41.803408,
  25.832176, 3.936132, 18.876962, 17.331359,7.048974, 13.648543, 26.093446, 28.544714, 39.104026, 
  44.572240, 51.171810, 56.262906, 46.269272, 38.161230, 30.618865, 21.945145, 34.390047, 59.656971,
  69.839163, 73.233228, 63.239594, 45.892154, 43.252326, 28.356155) , ncol=2)
bc &lt;- bioclim(logo, pts)

#or
v &lt;- extract(logo, pts)
bc &lt;- bioclim(v)
p1 &lt;- predict(logo, bc)
p2 &lt;- predict(logo, bc, tails=c('both', 'low', 'high'))

#or
#sp &lt;- SpatialPoints(pts)
#bc &lt;- bioclim(logo, pts)
</code></pre>

<hr>
<h2 id='biovars'>bioclimatic variables</h2><span id='topic+biovars'></span><span id='topic+biovars+2Cmatrix+2Cmatrix+2Cmatrix-method'></span><span id='topic+biovars+2CRaster+2CRaster+2CRaster-method'></span><span id='topic+biovars+2Cvector+2Cvector+2Cvector-method'></span>

<h3>Description</h3>

<p>Function to create 'bioclimatic variables' from monthly climate data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biovars(prec, tmin, tmax, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biovars_+3A_prec">prec</code></td>
<td>
<p>vector, matrix, or RasterStack/Brick of precipitation data</p>
</td></tr>
<tr><td><code id="biovars_+3A_tmin">tmin</code></td>
<td>
<p>vector, matrix, or RasterStack/Brick of minimum temperature data</p>
</td></tr>
<tr><td><code id="biovars_+3A_tmax">tmax</code></td>
<td>
<p>vector, matrix, or RasterStack/Brick of maximum temperature data</p>
</td></tr>
<tr><td><code id="biovars_+3A_...">...</code></td>
<td>
<p> Additional arguments </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data is normaly monthly. I.e. there should be 12 values (layers) for each variable, but the function should also work for e.g. weekly data (with some changes in the meaning of the output variables. E.g. #8 would then not be for a quater (3 months), but for a 3 week period). 
</p>


<h3>Value</h3>

<p>Depending on the class of the input data, an object of class 'vector', 'matrix' or 'RasterBrick' with 19 variables (columns, layers)
</p>
<p>bio1 = Mean annual temperature
</p>
<p>bio2 = Mean diurnal range (mean of max temp - min temp)
</p>
<p>bio3 = Isothermality (bio2/bio7) (* 100)
</p>
<p>bio4 = Temperature seasonality (standard deviation *100)
</p>
<p>bio5 = Max temperature of warmest month
</p>
<p>bio6 = Min temperature of coldest month
</p>
<p>bio7 = Temperature annual range (bio5-bio6)
</p>
<p>bio8 = Mean temperature of the wettest quarter
</p>
<p>bio9 = Mean temperature of driest quarter 
</p>
<p>bio10 = Mean temperature of warmest quarter
</p>
<p>bio11 = Mean temperature of coldest quarter
</p>
<p>bio12 = Total (annual) precipitation
</p>
<p>bio13 = Precipitation of wettest month
</p>
<p>bio14 = Precipitation of driest month
</p>
<p>bio15 = Precipitation seasonality (coefficient of variation)
</p>
<p>bio16 = Precipitation of wettest quarter
</p>
<p>bio17 = Precipitation of driest quarter
</p>
<p>bio18 = Precipitation of warmest quarter
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmin &lt;- c(10,12,14,16,18,20,22,21,19,17,15,12)
tmax &lt;- tmin + 5
prec &lt;- c(0,2,10,30,80,160,80,20,40,60,20,0)
biovars(prec, tmin, tmax)

tmn = tmx = prc = brick(nrow=1, ncol=1)
tmn &lt;- setValues(tmn, t(matrix(c(10,12,14,16,18,20,22,21,19,17,15,12))))
tmx &lt;- tmn + 5
prc &lt;- setValues(prc, t(matrix(c(0,2,10,30,80,160,80,20,40,60,20,0))))
b &lt;- biovars(prc, tmn, tmx)
as.matrix(b)
</code></pre>

<hr>
<h2 id='boxplot'>
Box plot of model evaluation data 
</h2><span id='topic+boxplot+2CModelEvaluation-method'></span>

<h3>Description</h3>

<p>Make a box plot of model evaluation data, i.e., the model predictions for known presence and absence points.
</p>


<h3>Details</h3>

<p>Arguments:
</p>
<p><code>x</code> Object of class ModelEvaluation
<code>...</code> Additional arguments that can be passed to <a href="graphics.html#topic+boxplot">boxplot</a>
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a> </code>
</p>

<hr>
<h2 id='calc.deviance'>Calculate deviance</h2><span id='topic+calc.deviance'></span>

<h3>Description</h3>

<p>Function to calculate deviance given two vectors of observed and predicted values.
Requires a family argument which is set to binomial by default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.deviance(obs, pred, weights = rep(1,length(obs)), 
                family="binomial", calc.mean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.deviance_+3A_obs">obs</code></td>
<td>
<p>a vector with observed values</p>
</td></tr>
<tr><td><code id="calc.deviance_+3A_pred">pred</code></td>
<td>
<p>a vector with predicted values that correspond the the values in obs</p>
</td></tr>
<tr><td><code id="calc.deviance_+3A_weights">weights</code></td>
<td>
<p>a vector of weight values</p>
</td></tr>
<tr><td><code id="calc.deviance_+3A_family">family</code></td>
<td>
<p>One of &quot;binomial&quot;, &quot;bernoulli&quot;, &quot;poisson&quot;, &quot;laplace&quot;, or &quot;gaussian&quot;</p>
</td></tr>
<tr><td><code id="calc.deviance_+3A_calc.mean">calc.mean</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the mean deviance is returned</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John R. Leathwick and Jane Elith
</p>

<hr>
<h2 id='circleHull'>Circle hull model</h2><span id='topic+circleHull'></span><span id='topic+circleHull+2CSpatialPoints-method'></span><span id='topic+circleHull+2Cmatrix-method'></span><span id='topic+circleHull+2Cdata.frame-method'></span><span id='topic+CircleHull-class'></span>

<h3>Description</h3>

<p>The Circle hull model predicts that a species is present at sites inside the smallest circle that can contain a set of training points, and absent outside that circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circleHull(p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleHull_+3A_p">p</code></td>
<td>
<p>point locations (presence). Two column matrix, data.frame or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="circleHull_+3A_...">...</code></td>
<td>
<p> Additional arguments. See details </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'CircleHull' (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circles">circles</a>, <a href="#topic+convHull">convHull</a>, <a href="#topic+rectHull">rectHull</a>, <a href="#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/rlogo.grd", package="raster"))
#presence data
pts &lt;- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66, 
 74, 50, 48, 28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)
train &lt;- pts[1:12, ]
test &lt;- pts[13:20, ]
				 
ch &lt;- circleHull(train)
predict(ch, test)

plot(r)
plot(ch, border='red', lwd=2, add=TRUE)
points(train, col='red', pch=20, cex=2)
points(test, col='black', pch=20, cex=2)

pr &lt;- predict(ch, r, progress='')
plot(pr)
points(test, col='black', pch=20, cex=2)
points(train, col='red', pch=20, cex=2)

# to get the polygons:
p &lt;- polygons(ch)
p
</code></pre>

<hr>
<h2 id='CirclesRange'>Circles range</h2><span id='topic+circles'></span><span id='topic+circles+2CSpatialPoints-method'></span><span id='topic+circles+2Cmatrix-method'></span><span id='topic+circles+2Cdata.frame-method'></span><span id='topic+CirclesRange-class'></span>

<h3>Description</h3>

<p>The Circles Range model predicts that a species is present at sites within a certain distance from a training point, and absent further away.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
circles(p, d, lonlat, n=360, r=6378137, dissolve=TRUE, ...)

## S4 method for signature 'SpatialPoints'
circles(p, d, lonlat, n=360, r=6378137, dissolve=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CirclesRange_+3A_p">p</code></td>
<td>
<p>point locations (presence). Two column matrix, data.frame or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="CirclesRange_+3A_d">d</code></td>
<td>
<p>numeric. The radius of each circle in meters. A single number or a vector with elements corresponding to rows in <code>p</code>. If missing the diameter is computed from the mean inter-point distance</p>
</td></tr>
<tr><td><code id="CirclesRange_+3A_lonlat">lonlat</code></td>
<td>
<p>logical. Are these longitude/latitude data? If missing this is taken from the <code>p</code> if it is a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="CirclesRange_+3A_n">n</code></td>
<td>
<p>integer. How many vertices in the circle? Default is 360</p>
</td></tr>
<tr><td><code id="CirclesRange_+3A_r">r</code></td>
<td>
<p>numeric. Radius of the earth. Only relevant for longitude/latitude data. Default is 6378137 m</p>
</td></tr>
<tr><td><code id="CirclesRange_+3A_dissolve">dissolve</code></td>
<td>
<p>logical. Dissolve overlapping circles. Setting this to <code>FALSE</code> may be useful for plotting overlapping circles</p>
</td></tr> 
<tr><td><code id="CirclesRange_+3A_...">...</code></td>
<td>
<p>additional arguments, none implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'CirclesRange' (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a>, <a href="#topic+geoDist">geoDist</a>, <a href="#topic+convHull">convHull</a>,  <a href="#topic+maxent">maxent</a>, <a href="#topic+domain">domain</a>, 
<a href="#topic+mahal">mahal</a>, <a href="#topic+convHull">convHull</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/rlogo.grd", package="raster"))
#presence data
pts &lt;- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66,
 74, 50, 48, 28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)
train &lt;- pts[1:12, ]
test &lt;- pts[13:20, ]
				 
cc &lt;- circles(train, lonlat=FALSE)
predict(cc, test)

plot(r)
plot(cc, border='red', lwd=2, add=TRUE)
points(train, col='red', pch=20, cex=2)
points(test, col='black', pch=20, cex=2)

pr &lt;- predict(cc, r, progress='')
plot(r, legend=FALSE)
plot(pr, add=TRUE, col='blue')
points(test, col='black', pch=20, cex=2)
points(train, col='red', pch=20, cex=2)


# to get the polygons:
p &lt;- polygons(cc)
p

# to compute the Circular Area Range of a species (see Hijmans and Spooner, 2001)
pts &lt;- train*10
ca100 &lt;- polygons(circles(pts, d=100, lonlat=FALSE))
ca150 &lt;- polygons(circles(pts, d=150, lonlat=FALSE))
sum(area(ca150)) / (pi*150^2)
sum(area(ca100)) / (pi*100^2)
par(mfrow=c(1,2))
plot(ca100); points(pts)
plot(ca150); points(pts)



</code></pre>

<hr>
<h2 id='Convex+20Hull'>Convex hull model</h2><span id='topic+convHull'></span><span id='topic+convHull+2CSpatialPoints-method'></span><span id='topic+convHull+2Cmatrix-method'></span><span id='topic+convHull+2Cdata.frame-method'></span><span id='topic+ConvexHull-class'></span>

<h3>Description</h3>

<p>The Convex hull model predicts that a species is present at sites inside the convex hull of a set of training points, and absent outside that hull.
I.e. this is the spatial convex hull, not an environmental hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convHull(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Convex+2B20Hull_+3A_x">x</code></td>
<td>
<p>point locations (presence). Two column matrix, data.frame or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="Convex+2B20Hull_+3A_...">...</code></td>
<td>
<p> Additional arguments. See details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can supply an argument n (&gt;= 1) to get n convex hulls around subsets of the points. You can also set n=1:x, to get a set of overlapping polygons consisting of 1 to x parts. I.e. the first polygon has 1 part, the second has 2 parts, and x has x parts.
</p>


<h3>Value</h3>

<p>An object of class 'ConvexHull' (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a>, <a href="#topic+geoDist">geoDist</a>, <a href="#topic+maxent">maxent</a>, <a href="#topic+domain">domain</a>, <a href="#topic+mahal">mahal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/rlogo.grd", package="raster"))
#presence data
pts &lt;- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66, 
 74, 50, 48, 28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)
train &lt;- pts[1:12, ]
test &lt;- pts[13:20, ]
				 
ch &lt;- convHull(train)
predict(ch, test)

plot(r)
plot(ch, border='red', lwd=2, add=TRUE)
points(train, col='red', pch=20, cex=2)
points(test, col='black', pch=20, cex=2)

pr &lt;- predict(ch, r, progress='')
plot(pr)
points(test, col='black', pch=20, cex=2)
points(train, col='red', pch=20, cex=2)

# to get the polygons:
p &lt;- polygons(ch)
p
</code></pre>

<hr>
<h2 id='dcEvaluate'>Evaluate by distance class</h2><span id='topic+dcEvaluate'></span>

<h3>Description</h3>

<p>Evaluate a model for intervals of distances to the nearest point in a reference dataset for presence data and a sample of the absence data selected to have a low spatial sorting bias (obtained with pwdSample). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcEvaluate(p, a, reference, lonlat=TRUE, binsize=15, predp, preda, model, 
               predictors, fun=predict) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcEvaluate_+3A_p">p</code></td>
<td>
<p>two column matrix (x, y) or (longitude/latitude) or SpatialPoints object, for point locations</p>
</td></tr>
<tr><td><code id="dcEvaluate_+3A_a">a</code></td>
<td>
<p>two column matrix (x, y) or (longitude/latitude) or SpatialPoints object, for point locations</p>
</td></tr>
<tr><td><code id="dcEvaluate_+3A_reference">reference</code></td>
<td>
<p>as above for reference point locations to which distances are computed</p>
</td></tr>
<tr><td><code id="dcEvaluate_+3A_lonlat">lonlat</code></td>
<td>
<p> Logical. Use <code>TRUE</code> if the coordinates are spherical (in degrees), and use <code>FALSE</code> if they are planar </p>
</td></tr>
<tr><td><code id="dcEvaluate_+3A_binsize">binsize</code></td>
<td>
<p>postive integer. How many presence points in each distance bin?</p>
</td></tr>
<tr><td><code id="dcEvaluate_+3A_predp">predp</code></td>
<td>
<p>p </p>
</td></tr> 
<tr><td><code id="dcEvaluate_+3A_preda">preda</code></td>
<td>
<p>a </p>
</td></tr>   
<tr><td><code id="dcEvaluate_+3A_model">model</code></td>
<td>
<p>m </p>
</td></tr>   
<tr><td><code id="dcEvaluate_+3A_predictors">predictors</code></td>
<td>
<p>pr </p>
</td></tr>   
<tr><td><code id="dcEvaluate_+3A_fun">fun</code></td>
<td>
<p>function </p>
</td></tr>   
</table>


<h3>Value</h3>

<p>list with Evaluation objects
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pwdSample">pwdSample</a></code>, <code><a href="#topic+ssb">ssb</a></code></p>

<hr>
<h2 id='density'>density</h2><span id='topic+density'></span><span id='topic+density+2CDistModel-method'></span><span id='topic+density+2CModelEvaluation-method'></span>

<h3>Description</h3>

<p>Create a density plots of presence and absence data
</p>


<h3>Value</h3>

<p>A density plot. Presence data are in red, and absence data (if available) are in blue.
</p>


<h3>Methods</h3>


<p><code>density(x, ...)</code>
</p>

<table>
<tr>
 <td style="text-align: right;">  
 </td><td style="text-align: left;">  <code>x</code>  </td><td style="text-align: left;"> Object of class 'ModelEvaluation' or of a class that inherits from 'DistModel, (such as 'MaxEnt', 'Bioclim') </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;">  <code>...</code>  </td><td style="text-align: left;"> Additional arguments that can be passed to plot</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>




<h3>Author(s)</h3>

<p>Robert J. Hijmans</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a> </code>
</p>

<hr>
<h2 id='dismo-package'>
Species distribution modeling
</h2><span id='topic+dismo-package'></span><span id='topic+dismo'></span>

<h3>Description</h3>

<p>This package implements a few species distribution models, including an R link to the 'maxent' model, and native implementations of Bioclim and Domain. It also provides a number of functions that can assist in using Boosted Regresssion Trees.
</p>
<p>A good place to start is the vignette, which you can access by typing <code>vignette('sdm', 'dismo')</code>
</p>
<p>In addition there are a number of functions, such sampling background points, k-fold sampling, and for model evaluation (AUC) that are useful for these and for other species distribution modeling methods available in R (e.g. GLM, GAM, and RandomForest).
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans, Steven Phillips, John Leathwick and Jane Elith
</p>

<hr>
<h2 id='DistModel'>Class &quot;DistModel&quot;</h2><span id='topic+DistModel-class'></span>

<h3>Description</h3>

<p>Parent class for a number of distribution models defined in the dismo package (those created by <code><a href="#topic+bioclim">bioclim</a>, <a href="#topic+domain">domain</a>, <a href="#topic+maxent">maxent</a> and <a href="#topic+mahal">mahal</a></code>). This is a virtual Class, no objects may be direclty created from it. </p>


<h3>Slots</h3>


<dl>
<dt><code>presence</code>:</dt><dd><p>presence data used</p>
</dd>
<dt><code>absence</code>:</dt><dd><p>absence or background data used</p>
</dd>
<dt><code>hasabsence</code>:</dt><dd><p>Logical indicating whether there is any absence data</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>

<hr>
<h2 id='domain'>
Domain
</h2><span id='topic+domain'></span><span id='topic+domain+2CRaster+2CSpatialPoints-method'></span><span id='topic+domain+2CRaster+2Cmatrix-method'></span><span id='topic+domain+2CRaster+2Cdata.frame-method'></span><span id='topic+domain+2Cmatrix+2Cmissing-method'></span><span id='topic+domain+2Cdata.frame+2Cmissing-method'></span><span id='topic+Domain-class'></span>

<h3>Description</h3>

<p>The Domain algorithm (Carpenter et al. 1993) that has been extensively used for species distribution modeling. It is included here for that reason but please note that it generally does not perform very well in model comparison (Elith et al. 2006, Hijmans and Graham, 2006). The Domain algorithm computes the Gower distance between environmental variables at any location and those at any of the known locations of occurrence ('training sites'). For each variable the minimum distance between a site and any of the training points is taken. To integrate over environmental variables, the maximum distance to any of the variables is used. This distance is subtracted from one, and (in this R implementation) values below zero are truncated so that the scores are between 0 (low) and 1 (high).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domain(x, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain_+3A_x">x</code></td>
<td>
<p> Raster* object or matrix</p>
</td></tr>
<tr><td><code id="domain_+3A_p">p</code></td>
<td>
<p> two column matrix or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="domain_+3A_...">...</code></td>
<td>
<p> Additional arguments </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'Domain' (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>References</h3>

<p>Carpenter G., A.N. Gillison and J. Winter, 1993. Domain: a flexible modelling procedure for  mapping potential distributions of plants and animals. Biodiversity Conservation 2:667-680.
</p>
<p>Elith, J., C.H. Graham, R.P. Anderson, M. Dudik, S. Ferrier, A. Guisan, R.J. Hijmans, F. Huettmann, J. Leathwick, A. Lehmann, J. Li, L.G. Lohmann, B. Loiselle, 
G. Manion, C. Moritz, M. Nakamura, Y. Nakazawa, J. McC. Overton, A.T. Peterson, S. Phillips, K. Richardson, R. Scachetti-Pereira, R. Schapire, J. Soberon, 
S. Williams, M. Wisz and N. Zimmerman, 2006. 
Novel methods improve prediction of species' distributions from occurrence data. Ecography 29: 129-151. <a href="https://doi.org/10.1111/j.2006.0906-7590.04596.x">doi:10.1111/j.2006.0906-7590.04596.x</a>
</p>
<p>Hijmans R.J., and C.H. Graham, 2006. Testing the ability of climate envelope models to predict the effect of climate change on species distributions. Global change biology 12: 2272-2281. <a href="https://doi.org/10.1111/j.1365-2486.2006.01256.x">doi:10.1111/j.1365-2486.2006.01256.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a>, <a href="#topic+maxent">maxent</a>, <a href="#topic+bioclim">bioclim</a>, <a href="#topic+mahal">mahal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logo &lt;- stack(system.file("external/rlogo.grd", package="raster"))
#presence data
pts &lt;- matrix(c(48.243420, 48.243420, 47.985820, 52.880230, 49.531423, 46.182616, 54.168232, 
  69.624263, 83.792291, 85.337894, 74.261072, 83.792291, 95.126713, 84.565092, 66.275456, 
  41.803408, 25.832176, 3.936132, 18.876962, 17.331359,7.048974, 13.648543, 26.093446, 
  28.544714, 39.104026, 44.572240, 51.171810, 56.262906, 46.269272, 38.161230, 30.618865,
  21.945145, 34.390047, 59.656971, 69.839163, 73.233228, 63.239594, 45.892154, 43.252326,
  28.356155), ncol=2)
d &lt;- domain(logo, pts)
p &lt;- predict(d, logo)
</code></pre>

<hr>
<h2 id='ecocrop'>Ecocrop model</h2><span id='topic+ecocrop'></span><span id='topic+getCrop'></span><span id='topic+ECOcrops'></span><span id='topic+ECOCROP-class'></span><span id='topic+ECOCROPcrop-class'></span><span id='topic+plot+2CECOCROP+2Cmissing-method'></span><span id='topic+plot+2CECOCROPcrop+2Cmissing-method'></span>

<h3>Description</h3>

<p>Very simple mechanistic model for plants. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecocrop(crop, tmin, tavg, prec, rainfed=TRUE, ...) 
getCrop(name)
data(ECOcrops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecocrop_+3A_crop">crop</code></td>
<td>
<p>An object of class 'ECOCROP', or the name of a crop as in getCrop</p>
</td></tr>
<tr><td><code id="ecocrop_+3A_tmin">tmin</code></td>
<td>
<p>Vector of monthly minimum temperature (degrees C)</p>
</td></tr>
<tr><td><code id="ecocrop_+3A_tavg">tavg</code></td>
<td>
<p>Vector of monthly average temperature (degrees C)</p>
</td></tr>
<tr><td><code id="ecocrop_+3A_prec">prec</code></td>
<td>
<p>Vector of monthly precipitation (mm)</p>
</td></tr>
<tr><td><code id="ecocrop_+3A_rainfed">rainfed</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the crop is assumed to be irrigated</p>
</td></tr>
<tr><td><code id="ecocrop_+3A_...">...</code></td>
<td>
<p>Additinal arguments</p>
</td></tr>
<tr><td><code id="ecocrop_+3A_name">name</code></td>
<td>
<p>Name of a crop (character). If missing a data.frame with all crop names is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class ECOCROP
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ecocrop('potato', 5:16, 15:26, runif(12)*100)
getCrop('Acacia brachystachya Benth.')
crop &lt;- getCrop('Hot pepper')
ecocrop(crop, 5:16, 15:26, rainfed=FALSE)

# with spatial data
tmin = tavg = prec = brick(nrow=1, ncol=1)
tmin &lt;- setValues(tmin, t(matrix(5:16)))
tavg &lt;- tmin + 5
prec &lt;- setValues(prec, t(matrix(15:26)))
crop &lt;- getCrop('Hot pepper')
ecocrop(crop, tmin, tavg, prec, rainfed = FALSE)
</code></pre>

<hr>
<h2 id='ecolim'>Ecolim model</h2><span id='topic+ecolim'></span><span id='topic+ecolim+2Cmatrix+2Cmatrix-method'></span><span id='topic+EcoLim-class'></span><span id='topic+predict+2CEcoLim-method'></span><span id='topic+plot+2CEcoLim+2CANY-method'></span>

<h3>Description</h3>

<p>Simple generic limiting factor based model, in the tradition of the PLANTGRO model (Hackett, 1991)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,matrix'
ecolim(x, y, extrapolate=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecolim_+3A_x">x</code></td>
<td>
<p>numeric matrix with driver variables (each column has values for the variables). Values have to be in ascending order</p>
</td></tr>
<tr><td><code id="ecolim_+3A_y">y</code></td>
<td>
<p>numeric matrix with responses (between 0 and 1), one column for each column in <code>x</code></p>
</td></tr>
<tr><td><code id="ecolim_+3A_extrapolate">extrapolate</code></td>
<td>
<p>logical. Should the model extrapolate beyond the extremes of x? If <code>TRUE</code> the value of <code>y</code> at the closest data extreme in <code>x</code> is used, else <code>NA</code> is returned for such records</p>
</td></tr> 
<tr><td><code id="ecolim_+3A_...">...</code></td>
<td>
<p>Additional arguments. None implemented</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>References</h3>

<p>Hackett, C., 1991. PLANTGRO, a software package for coarse prediction of plant growth. CSIRO, Melbourne, Australia
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get predictor variables
fnames &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''), 
              pattern='grd', full.names=TRUE ) 
env &lt;- stack(fnames)

bio1 &lt;- c(200,250,400,450)
bio12 &lt;- c(0,1000, 3000, 4000)
r1 &lt;- c(0, 1, 1, 0)
r2 &lt;- c(0, 0, 1, 1)
x &lt;- cbind(bio1, bio12)
y &lt;- cbind(r1, r2)

e &lt;- ecolim(x, y) 
plot(e, lwd=2, col='red')
p &lt;- predict(e, env)
plot(p)

# no extrapolation:
ef &lt;- ecolim(x, y, extrapolate=FALSE) 
pf &lt;- predict(ef, env)
plot(pf)


occurence &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
occ &lt;- read.table(occurence, header=TRUE, sep=',')[,-1]
fold &lt;- kfold(occ, k=5)
occtest &lt;- occ[fold == 1, ]
occtrain &lt;- occ[fold != 1, ]
bg &lt;- randomPoints(env, 1000)


## Not run: 
# An approach to optimize the values based on
# some known presences and (here random) absences
# for the same species as in the maxent example

# intial parameters
v &lt;- c(200, 250, 400, 450, 0, 1000, 3000, 4000)

# function to be minimized
f &lt;- function(p) {
	x[] &lt;- p
	# numbers must go up
	if ( any(x[-1,] &lt; x[-nrow(x), ]) ) return(Inf)
	e &lt;- ecolim(x, y) 
	# we are minimizing, hence 1-AUC
	1-evaluate(e, p=occtrain, a=bg, x=env)@auc
}

# patience...
set.seed(0)
z &lt;- optim(v, f)

x[] &lt;- z$par
eco &lt;- ecolim(x, y) 
evaluate(eco, p=occtest, a=bg, x=env)

set.seed(0)
pwd &lt;- pwdSample(occtest,bg,occtrain)
ptest &lt;- occtest[!is.na(pwd),]
atest &lt;- bg[na.omit(pwd),]
evaluate(eco, p=ptest, a=atest, x=env)

p2 &lt;- predict(eco, env)
plot(p2)

## End(Not run)
</code></pre>

<hr>
<h2 id='evaluate'> Model evaluation </h2><span id='topic+evaluate'></span>

<h3>Description</h3>

 
<p>Evaluation of models with presence/absence data. Given a vector of presence and a vector of absence values (or a model and presence and absence points and predictors), confusion matrices are computed (for varying thresholds), and model evaluation statistics are computed for each confusion matrix / threshold. See the description of class <code><a href="#topic+ModelEvaluation-class">ModelEvaluation-class</a></code> for more info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(p, a, model, x, tr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_+3A_p">p</code></td>
<td>
<p>presence points (x and y coordinates or SpatialPoints* object). 
</p>
<p>Or, if <code>x</code> is missing, values at presence points
</p>
<p>Or, a matrix with values to compute predictions for</p>
</td></tr>
<tr><td><code id="evaluate_+3A_a">a</code></td>
<td>
<p>absence points (x and y coordinates or SpatialPoints* object). 
</p>
<p>Or, if <code>x</code> is missing, values at presence points.
</p>
<p>Or, a matrix with values to compute predictions for</p>
</td></tr>
<tr><td><code id="evaluate_+3A_model">model</code></td>
<td>
<p>any fitted model, including objects inheriting from 'DistModel'; not used when <code>x</code> is missing (and both a and p are vectors)</p>
</td></tr>
<tr><td><code id="evaluate_+3A_x">x</code></td>
<td>
<p>Optional. Predictor variables (object of class Raster*). If present, <code>p</code> and <code>a</code> are interpreted as (spatial) points </p>
</td></tr>
<tr><td><code id="evaluate_+3A_tr">tr</code></td>
<td>
<p>Optional. a vector of threshold values to use for computing the confusion matrices</p>
</td></tr>
<tr><td><code id="evaluate_+3A_...">...</code></td>
<td>
<p>Additional arguments for the predict function</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>An object of <code><a href="#topic+ModelEvaluation-class">ModelEvaluation-class</a></code>
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>References</h3>

<p>Fielding, A.H. and J.F. Bell, 1997. A review of methods for the assessment of prediction errors in conservation presence/absence models. Environmental Conservation 24:38-49
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+threshold">threshold</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## See ?maxent for an example with real data.
# this is a contrived example:
# p has the predicted values for 50 known cases (locations) 
# with presence of the phenomenon (species)
p &lt;- rnorm(50, mean=0.7, sd=0.3)
# a has the predicted values for 50 background locations (or absence)
a &lt;- rnorm(50, mean=0.4, sd=0.4)
e &lt;- evaluate(p=p, a=a)

threshold(e)

plot(e, 'ROC')
plot(e, 'TPR')
boxplot(e)
density(e)

str(e)
</code></pre>

<hr>
<h2 id='evaluateROCR'>
Model testing with the ROCR package
</h2><span id='topic+evaluateROCR'></span>

<h3>Description</h3>

<p>Preparing data for model testing with the ROCR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateROCR(model, p, a, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateROCR_+3A_model">model</code></td>
<td>
<p>any fitted model, including objects inheriting from 'DistModel'</p>
</td></tr>
<tr><td><code id="evaluateROCR_+3A_p">p</code></td>
<td>
<p>presence points (x and y coordinates or SpatialPoints* object). 
</p>
<p>Or, if <code>x</code> is missing, values at presence points
</p>
<p>Or, a matrix with values to compute predictions for</p>
</td></tr>
<tr><td><code id="evaluateROCR_+3A_a">a</code></td>
<td>
<p>absence points (x and y coordinates or SpatialPoints* object). 
</p>
<p>Or, if <code>x</code> is missing, values at presence points.
</p>
<p>Or, a matrix with values to compute predictions for</p>
</td></tr>
<tr><td><code id="evaluateROCR_+3A_x">x</code></td>
<td>
<p>optional. predictor variables, if present, <code>p</code> and <code>a</code> are considered </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;prediction&quot; (defined in the ROCR package)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>

<hr>
<h2 id='Evaluation+20plots'>
Plot model evaluation data 
</h2><span id='topic+plot+2CModelEvaluation+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Make a ROC curve, or a plot of a threshold dependent measure against threshold values
</p>


<h3>Methods</h3>

<p>usage:  <code>plot(x, y, ...)</code>
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>x</code>  </td><td style="text-align: left;">  Object of class ModelEvaluation  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>y</code>  </td><td style="text-align: left;">  Character. Either 'ROC' or a threshold dependent measure such as 'kappa', 'TPR' </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>...</code>  </td><td style="text-align: left;">  Additional arguments that can be passed to <a href="base.html#topic+plot">plot</a> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelEvaluation-class">ModelEvaluation-class</a>, <a href="#topic+density">density</a>, <a href="#topic+pairs">pairs</a>, <a href="base.html#topic+plot">plot</a> </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># p = the predicted value for 50 known cases (locations) with presence of the phenomenon (species)
p = rnorm(50, mean=0.7, sd=0.3)
# b = the predicted value for 50 known cases (locations) with absence of the phenomenon (species)
a = rnorm(50, mean=0.4, sd=0.4)
e = evaluate(p=p, a=a)
plot(e, 'ROC')
plot(e, 'kappa')
plot(e, 'FPR')
plot(e, 'prevalence')
</code></pre>

<hr>
<h2 id='gbif'>
Data from GBIF
</h2><span id='topic+gbif'></span>

<h3>Description</h3>

<p>This function downloads species occurence records from the Global Biodiversity Information Facility (<a href="https://www.gbif.org">GBIF</a>) data portal. You can download either a single species (if you append a '*' to the species name) or a subspecies of comparable level. You can download the data for an entire genus by using <code>species='*'</code>. Before using this function, please first check the GBIF <a href="https://www.gbif.org/terms">data use agreement</a> and see the note below about how to cite these data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbif(genus, species="", ext=NULL, args=NULL, geo=TRUE, sp=FALSE, 
   removeZeros=FALSE, download=TRUE, ntries=5, nrecs=300, start=1, end=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbif_+3A_genus">genus</code></td>
<td>
<p>character. genus name</p>
</td></tr>
<tr><td><code id="gbif_+3A_species">species</code></td>
<td>
<p>character. species name. Use '*' to download the entire genus. Append '*' to the species name to get all naming variants (e.g. with and witout species author name) and sub-taxa </p>
</td></tr>
<tr><td><code id="gbif_+3A_ext">ext</code></td>
<td>
<p>Extent object to limit the geographic extent of the records. An extent can be created using functions like <code>drawExtent</code> and <code>extent</code></p>
</td></tr>
<tr><td><code id="gbif_+3A_args">args</code></td>
<td>
<p>character. Additional arguments to refine the query. See query parameters in https://www.gbif.org/developer/occurrence for more details</p>
</td></tr>
<tr><td><code id="gbif_+3A_geo">geo</code></td>
<td>
<p>logical. If <code>TRUE</code>, only records that have a georeference (longitude and latitude values) will be downloaded</p>
</td></tr>
<tr><td><code id="gbif_+3A_sp">sp</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>geo</code> will be set to <code>TRUE</code> and a <a href="sp.html#topic+SpatialPoints">SpatialPoints</a>DataFrame will be returned</p>
</td></tr>
<tr><td><code id="gbif_+3A_removezeros">removeZeros</code></td>
<td>
<p>logical. If <code>TRUE</code>, all records that have a latitude OR longitude of zero will be removed if <code>geo==TRUE</code>, or set to <code>NA</code> if <code>geo==FALSE</code>. If <code>FALSE</code>, only records that have a latitude AND longitude that are zero will be removed or set to <code>NA</code></p>
</td></tr>
<tr><td><code id="gbif_+3A_download">download</code></td>
<td>
<p>logical. If <code>TRUE</code>, records will be downloaded, else only the number of records will be shown</p>
</td></tr>
<tr><td><code id="gbif_+3A_ntries">ntries</code></td>
<td>
<p>integer. How many times should the function attempt to download the data, if an invalid response is returned (perhaps because the GBIF server is very busy)</p>
</td></tr>
<tr><td><code id="gbif_+3A_nrecs">nrecs</code></td>
<td>
<p>integer. How many records to download in a single request (max is 300)?</p>
</td></tr>
<tr><td><code id="gbif_+3A_start">start</code></td>
<td>
<p>integer. Record number from which to start requesting data</p>
</td></tr>
<tr><td><code id="gbif_+3A_end">end</code></td>
<td>
<p>integer. Last record to request</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame 
</p>


<h3>Note</h3>

<p>Under the terms of the GBIF data user agreement, users who download data agree to cite a DOI. Citation rewards data-publishing institutions and individuals and provides support for sharing open data [<a href="https://docs.ropensci.org/rgbif/articles/gbif_citations.html">1</a>][<a href="https://www.gbif.org/citation-guidelines">2</a>]. You can get a DOI for the data you downloaded by creating a <a href="https://www.gbif.org/derived-dataset/about">&quot;derived&quot; dataset</a>. For this to work, you need to keep the &quot;datasetKey&quot; variable in your dataset.
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>References</h3>

<p><a href="https://www.gbif.org/occurrence">https://www.gbif.org/occurrence</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

gbif('solanum', download=FALSE)
gbif('solanum', 'acaule', download=FALSE)

gbif('Batrachoseps', '' , down=FALSE)
gbif('Batrachoseps', 'luciae', down=FALSE)
g &lt;- gbif('Batrachoseps', 'luciae', geo=TRUE)
plot(g$lon, g$lat)

gs &lt;- gbif('Batrachoseps', 'luciae', sp=TRUE)
plot(gs)

## End(Not run)
</code></pre>

<hr>
<h2 id='gbm.fixed'>gbm fixed </h2><span id='topic+gbm.fixed'></span>

<h3>Description</h3>

<p>Calculates a gradient boosting (gbm) object with a fixed number of trees.  The optimal number of trees can be identified using gbm.step or some other procedure.
Mostly used as a utility function, e.g., when being called by gbm.simplify. It takes as input a dataset and arguments selecting x and y variables, learning rate and tree complexity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm.fixed(data, gbm.x, gbm.y, tree.complexity = 1, site.weights = rep(1, nrow(data)),
 verbose = TRUE, learning.rate = 0.001, n.trees = 2000, bag.fraction = 0.5, 
 family = "bernoulli", keep.data = FALSE, var.monotone = rep(0, length(gbm.x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbm.fixed_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_gbm.x">gbm.x</code></td>
<td>
<p>indices of the predictors in the input dataframe</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_gbm.y">gbm.y</code></td>
<td>
<p>index of the response in the input dataframe</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_tree.complexity">tree.complexity</code></td>
<td>
<p>the tree depth - sometimes referred to as interaction depth</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_site.weights">site.weights</code></td>
<td>
<p>by default set equal</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_verbose">verbose</code></td>
<td>
<p>to control reporting</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_learning.rate">learning.rate</code></td>
<td>
<p>controls speed of the gradient descent</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_n.trees">n.trees</code></td>
<td>
<p>default number of trees</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_bag.fraction">bag.fraction</code></td>
<td>
<p>varies random sample size for each new tree</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_family">family</code></td>
<td>
<p>can be any of &quot;bernoulli&quot;, &quot;poisson&quot;, &quot;gaussian&quot;, or &quot;laplace&quot;</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_keep.data">keep.data</code></td>
<td>
<p>Logical. If <code>TRUE</code>, original data is kept</p>
</td></tr>
<tr><td><code id="gbm.fixed_+3A_var.monotone">var.monotone</code></td>
<td>
<p>constrain to positive (1) or negative monontone (-1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class gbm
</p>


<h3>Author(s)</h3>

<p>John R. Leathwick and Jane Elith
</p>


<h3>References</h3>

<p>Elith, J., J.R. Leathwick and T. Hastie, 2009. A working guide to boosted regression trees. Journal of Animal Ecology 77: 802-81
</p>

<hr>
<h2 id='gbm.holdout'>gbm holdout</h2><span id='topic+gbm.holdout'></span>

<h3>Description</h3>

<p>Calculates a gradient boosting (gbm) object in which model complexity is 
determined using a training set with predictions made to a withheld set.
An initial set of trees is fitted, and then trees are progressively added
testing performance along the way, using gbm.perf until the optimal
number of trees is identified.
</p>
<p>As any structured ordering of the data should be avoided, a copy of the data set is 
BY DEFAULT randomly reordered each time the function is run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm.holdout(data, gbm.x, gbm.y, learning.rate = 0.001, tree.complexity = 1, 
 family = "bernoulli", n.trees = 200, add.trees = n.trees, max.trees = 20000, 
 verbose = TRUE, train.fraction = 0.8, permute = TRUE, prev.stratify = TRUE,
 var.monotone = rep(0, length(gbm.x)), site.weights = rep(1, nrow(data)), 
 refit = TRUE, keep.data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbm.holdout_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_gbm.x">gbm.x</code></td>
<td>
<p>indices of the predictors in the input dataframe</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_gbm.y">gbm.y</code></td>
<td>
<p>index of the response in the input dataframe</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_learning.rate">learning.rate</code></td>
<td>
<p>typically varied between 0.1 and 0.001</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_tree.complexity">tree.complexity</code></td>
<td>
<p>sometimes called interaction depth</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_family">family</code></td>
<td>
<p>&quot;bernoulli&quot;,&quot;poisson&quot;, etc. as for gbm</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_n.trees">n.trees</code></td>
<td>
<p>initial number of trees</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_add.trees">add.trees</code></td>
<td>
<p>number of trees to add at each increment</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_max.trees">max.trees</code></td>
<td>
<p>maximum number of trees to fit</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_verbose">verbose</code></td>
<td>
<p>controls degree of screen reporting</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_train.fraction">train.fraction</code></td>
<td>
<p>proportion of data to use for training</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_permute">permute</code></td>
<td>
<p>reorder data to start with</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_prev.stratify">prev.stratify</code></td>
<td>
<p>stratify selection for presence/absence data</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_var.monotone">var.monotone</code></td>
<td>
<p>allows constraining of response to monotone </p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_site.weights">site.weights</code></td>
<td>
<p>set equal to 1 by default</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_refit">refit</code></td>
<td>
<p>refit the model with the full data but id'd no of trees</p>
</td></tr>
<tr><td><code id="gbm.holdout_+3A_keep.data">keep.data</code></td>
<td>
<p>keep copy of the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gbm object
</p>


<h3>Author(s)</h3>

<p>John R. Leathwick and Jane Elith
</p>


<h3>References</h3>

<p>Elith, J., J.R. Leathwick and T. Hastie, 2009. A working guide to boosted regression trees. Journal of Animal Ecology 77: 802-81
</p>

<hr>
<h2 id='gbm.interactions'>gbm interactions</h2><span id='topic+gbm.interactions'></span>

<h3>Description</h3>

<p>Tests whether interactions have been detected and modelled, and reports the relative strength of these. 
Results can be visualised with gbm.perspec
</p>
<p>The function assesses the magnitude of 2nd order interaction effects in gbm models fitted with interaction depths greater than 1. This is achieved by:
</p>
<p>1. forming predictions on the linear scale for each predictor pair;
</p>
<p>2. fitting a linear model that relates these predictions to the predictor pair, with the the predictors fitted as factors;
</p>
<p>3. calculating the mean value of the residuals, the magnitude of which increases with the strength of any interaction effect;
</p>
<p>4. results are stored in an array;
</p>
<p>5. finally, the n most important interactions are identified, where n is 25
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm.interactions(gbm.object, use.weights=FALSE, mask.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbm.interactions_+3A_gbm.object">gbm.object</code></td>
<td>
<p>A gbm object</p>
</td></tr>
<tr><td><code id="gbm.interactions_+3A_use.weights">use.weights</code></td>
<td>
<p>Logical. If <code>TRUE</code>, weights are used for samples </p>
</td></tr>
<tr><td><code id="gbm.interactions_+3A_mask.object">mask.object</code></td>
<td>
<p>a gbm object describing sample intensity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class gbm
</p>

<hr>
<h2 id='gbm.perspec'>
gbm perspective plot
</h2><span id='topic+gbm.perspec'></span>

<h3>Description</h3>

<p>Takes a gbm boosted regression tree object produced by gbm.step and
plots a perspective plot showing predicted values for two predictors as specified by number using x and y.
Values for all other variables are set at their mean by default but values can be specified by giving a list consisting of the variable name
and its desired value, e.g., c(name1 = 12.2, name2 = 57.6)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm.perspec(gbm.object, x = 1, y = 2, pred.means = NULL, x.label = NULL, x.range = NULL,
 y.label = NULL, z.label = "fitted value", y.range = NULL, z.range = NULL, 
 leg.coords = NULL, ticktype = "detailed", theta = 55, phi = 40, smooth = "none",
 mask = FALSE, perspective = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbm.perspec_+3A_gbm.object">gbm.object</code></td>
<td>
<p>object of class gbm</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_x">x</code></td>
<td>
<p>the first variable to be plotted</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_y">y</code></td>
<td>
<p>the second variable to be plotted</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_pred.means">pred.means</code></td>
<td>
<p>allows specification of values for other variables</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_x.label">x.label</code></td>
<td>
<p>allows manual specification of the x label</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_x.range">x.range</code></td>
<td>
<p>manual range specification for the x variable</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_y.label">y.label</code></td>
<td>
<p>and y label</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_z.label">z.label</code></td>
<td>
<p>default z label</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_y.range">y.range</code></td>
<td>
<p>and the y</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_z.range">z.range</code></td>
<td>
<p>allows control of the vertical axis</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_leg.coords">leg.coords</code></td>
<td>
<p>can specify coords (x, y) for legend</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_ticktype">ticktype</code></td>
<td>
<p>specifiy detailed types - otherwise &quot;simple&quot;</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_theta">theta</code></td>
<td>
<p>rotation </p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_phi">phi</code></td>
<td>
<p>and elevation </p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_smooth">smooth</code></td>
<td>
<p>controls smoothing of the predicted surface</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_mask">mask</code></td>
<td>
<p>controls masking using a sample intensity model</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_perspective">perspective</code></td>
<td>
<p>controls whether a contour or perspective plot is drawn</p>
</td></tr>
<tr><td><code id="gbm.perspec_+3A_...">...</code></td>
<td>
<p>allows the passing of additional arguments to plotting routine useful options include shade, ltheta, lphi for controlling illumination and cex for controlling text size - cex.axis and cex.lab have no effect</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John R. Leathwick and Jane Elith
</p>


<h3>References</h3>

<p>Elith, J., J.R. Leathwick and T. Hastie, 2009. A working guide to boosted regression trees. Journal of Animal Ecology 77: 802-81
</p>

<hr>
<h2 id='gbm.plot'>gbm plot</h2><span id='topic+gbm.plot'></span>

<h3>Description</h3>

<p>Function to plot gbm response variables, with the option of adding a smooth representation of the response if requested additional options in this version allow for plotting on a common scale. Note hat fitted functions are centered by subtracting their mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm.plot(gbm.object, variable.no=0, smooth=FALSE, rug=TRUE, n.plots=length(pred.names),
  common.scale=TRUE, write.title=TRUE, y.label="fitted function", x.label=NULL, 
  show.contrib=TRUE, plot.layout=c(3, 4), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbm.plot_+3A_gbm.object">gbm.object</code></td>
<td>
<p>a gbm object - could be one from gbm.step</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_variable.no">variable.no</code></td>
<td>
<p>the var to plot - if zero then plots all</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_smooth">smooth</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a smoothed version of the fitted function is added</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_rug">rug</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a rug of deciles is plotted</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_n.plots">n.plots</code></td>
<td>
<p>plot the first n most important preds</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_common.scale">common.scale</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a common scale is used on the y axis</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_write.title">write.title</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plot gets a title</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_y.label">y.label</code></td>
<td>
<p>the default y-axis label</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_x.label">x.label</code></td>
<td>
<p>the default x-axis label</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_show.contrib">show.contrib</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the contribution is shown on the x axis</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_plot.layout">plot.layout</code></td>
<td>
<p>define the default layout for graphs on the page</p>
</td></tr>
<tr><td><code id="gbm.plot_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the plotting useful options include cex.axis, cex.lab, etc.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John R. Leathwick and Jane Elith
</p>


<h3>References</h3>

<p>Elith, J., J.R. Leathwick and T. Hastie, 2009. A working guide to boosted regression trees. Journal of Animal Ecology 77: 802-81
</p>

<hr>
<h2 id='gbm.plot.fits'>gbm plot fitted values</h2><span id='topic+gbm.plot.fits'></span>

<h3>Description</h3>

<p>Plots the fitted values from a gbm object returned by any of the model fitting options. This can give a more reliable guide to the shape of the fitted surface than can be obtained from the individual functions, particularly when predictor variables are correlated and/or samples are unevenly distributed in environmental space. Allows masking out of absences to enable focus on sites with high predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm.plot.fits(gbm.object, v=0, mask.presence=FALSE, use.factor=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbm.plot.fits_+3A_gbm.object">gbm.object</code></td>
<td>
<p>a gbm object</p>
</td></tr>
<tr><td><code id="gbm.plot.fits_+3A_v">v</code></td>
<td>
<p>variable numbers to be plotted (if 0 then all are plotted)</p>
</td></tr>
<tr><td><code id="gbm.plot.fits_+3A_mask.presence">mask.presence</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function only plots fitted values for presences</p>
</td></tr>
<tr><td><code id="gbm.plot.fits_+3A_use.factor">use.factor</code></td>
<td>
<p>Logical. If <code>TRUE</code>, forces to use quicker printing box and whisker plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John R. Leathwick and Jane Elith
</p>


<h3>References</h3>

<p>Elith, J., J.R. Leathwick and T. Hastie, 2009. A working guide to boosted regression trees. Journal of Animal Ecology 77: 802-81
</p>

<hr>
<h2 id='gbm.simplify'>gbm simplify</h2><span id='topic+gbm.simplify'></span>

<h3>Description</h3>

<p>The function takes an inital cross-validated model as produced by gbm.step 
and then assesses the potential to remove predictors using k-fold cross validation. 
This done for each fold, removing the lowest contributing predictor, 
and repeating this process for a set number of steps. 
After the removal of each predictor, the change in predictive deviance 
is computed relative to that obtained when using all predictors. 
The function returns a list containing the mean change in deviance and its standard error 
as a function of the number of variables removed. 
Having completed the cross validation, it then identifies the sequence 
of variable to remove when using the full data set, testing this 
up to the number of steps used in the cross-validation phase of the analysis 
with results reported to the screen. 
</p>
<p>The function returns a table containing the order in which variables are to be removed 
and some vectors, each of which specifies the predictor column numbers 
in the original dataframe  - the latter can be used as an argument to gbm.step
e.g., gbm.step(data = data, gbm.x = simplify.object$pred.list[[4]]...
would implement a new analysis with the original predictor set, minus its
four lowest contributing predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm.simplify(gbm.object, n.folds = 10, n.drops = "auto", alpha = 1, prev.stratify = TRUE, 
   eval.data = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbm.simplify_+3A_gbm.object">gbm.object</code></td>
<td>
<p>a gbm object describing sample intensity </p>
</td></tr>
<tr><td><code id="gbm.simplify_+3A_n.folds">n.folds</code></td>
<td>
<p>number of times to repeat the analysis</p>
</td></tr>
<tr><td><code id="gbm.simplify_+3A_n.drops">n.drops</code></td>
<td>
<p>can be automatic or an integer specifying the number of drops to check</p>
</td></tr>
<tr><td><code id="gbm.simplify_+3A_alpha">alpha</code></td>
<td>
<p>controls stopping when n.drops = &quot;auto&quot;</p>
</td></tr>
<tr><td><code id="gbm.simplify_+3A_prev.stratify">prev.stratify</code></td>
<td>
<p>use prevalence stratification in selecting evaluation data</p>
</td></tr>
<tr><td><code id="gbm.simplify_+3A_eval.data">eval.data</code></td>
<td>
<p>an independent evaluation data set - leave here for now</p>
</td></tr>
<tr><td><code id="gbm.simplify_+3A_plot">plot</code></td>
<td>
<p>plot results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with these elements: 
deviance.summary, deviance.matrix, drop.count, final.drops, pred.list, and gbm.call = gbm.call))
</p>


<h3>Author(s)</h3>

<p>John R. Leathwick and Jane Elith
</p>


<h3>References</h3>

<p>Elith, J., J.R. Leathwick and T. Hastie, 2009. A working guide to boosted regression trees. Journal of Animal Ecology 77: 802-81
</p>

<hr>
<h2 id='gbm.step'>
gbm step
</h2><span id='topic+gbm.step'></span>

<h3>Description</h3>

<p>Function to assess the optimal number of boosting trees using k-fold cross validation. This is an implementation of the cross-validation procedure described on page 215 of Hastie et al (2001).
</p>
<p>The data is divided into 10 subsets, with stratification by prevalence if required for presence/absence data. The function then fits a gbm model of increasing complexity along the sequence from <code>n.trees</code> to <code>n.trees + (n.steps * step.size)</code>, calculating the residual deviance at each step along the way. After each fold processed, the function calculates the average holdout residual deviance and its standard error and then identifies the optimal number of trees as that at which the holdout deviance is minimised. It fits a model with this number of trees, returning it as a gbm model along with additional information from the cross-validation selection process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm.step(data, gbm.x, gbm.y, offset = NULL, fold.vector = NULL, tree.complexity = 1,
 learning.rate = 0.01, bag.fraction = 0.75, site.weights = rep(1, nrow(data)), 
 var.monotone = rep(0, length(gbm.x)), n.folds = 10, prev.stratify = TRUE, 
 family = "bernoulli", n.trees = 50, step.size = n.trees, max.trees = 10000,
 tolerance.method = "auto", tolerance = 0.001, plot.main = TRUE, plot.folds = FALSE,
 verbose = TRUE, silent = FALSE, keep.fold.models = FALSE, keep.fold.vector = FALSE, 
 keep.fold.fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbm.step_+3A_data">data</code></td>
<td>
<p>input data.frame</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_gbm.x">gbm.x</code></td>
<td>
<p>indices or names of predictor variables in <code>data</code></p>
</td></tr>
<tr><td><code id="gbm.step_+3A_gbm.y">gbm.y</code></td>
<td>
<p>index or name of response variable in <code>data</code></p>
</td></tr>
<tr><td><code id="gbm.step_+3A_offset">offset</code></td>
<td>
<p>offset</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_fold.vector">fold.vector</code></td>
<td>
<p>a fold vector to be read in for cross validation with offsets</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_tree.complexity">tree.complexity</code></td>
<td>
<p>sets the complexity of individual trees</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_learning.rate">learning.rate</code></td>
<td>
<p>sets the weight applied to inidivudal trees</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_bag.fraction">bag.fraction</code></td>
<td>
<p>sets the proportion of observations used in selecting variables</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_site.weights">site.weights</code></td>
<td>
<p>allows varying weighting for sites</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_var.monotone">var.monotone</code></td>
<td>
<p>restricts responses to individual predictors to monotone</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_n.folds">n.folds</code></td>
<td>
<p>number of folds</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_prev.stratify">prev.stratify</code></td>
<td>
<p>prevalence stratify the folds - only for presence/absence data</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_family">family</code></td>
<td>
<p>family - bernoulli (=binomial), poisson, laplace or gaussian</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_n.trees">n.trees</code></td>
<td>
<p>number of initial trees to fit</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_step.size">step.size</code></td>
<td>
<p>numbers of trees to add at each cycle</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_max.trees">max.trees</code></td>
<td>
<p>max number of trees to fit before stopping</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_tolerance.method">tolerance.method</code></td>
<td>
<p>method to use in deciding to stop - &quot;fixed&quot; or &quot;auto&quot;</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance value to use - if method == fixed is absolute, if auto is multiplier * total mean deviance</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_plot.main">plot.main</code></td>
<td>
<p>Logical. plot hold-out deviance curve</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_plot.folds">plot.folds</code></td>
<td>
<p>Logical. plot the individual folds as well</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_verbose">verbose</code></td>
<td>
<p>Logical. control amount of screen reporting</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_silent">silent</code></td>
<td>
<p>Logical. to allow running with no output for simplifying model)</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_keep.fold.models">keep.fold.models</code></td>
<td>
<p>Logical. keep the fold models from cross valiation</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_keep.fold.vector">keep.fold.vector</code></td>
<td>
<p>Logical. allows the vector defining fold membership to be kept</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_keep.fold.fit">keep.fold.fit</code></td>
<td>
<p>Logical. allows the predicted values for observations from cross-validation to be kept</p>
</td></tr>
<tr><td><code id="gbm.step_+3A_...">...</code></td>
<td>
<p>Logical. allows for any additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of S3 class gbm
</p>


<h3>Note</h3>

<p>This and other boosted regression trees (BRT) functions in the dismo package do not work if you use only one predictor. There is an easy work around: make a dummy variable with a constant value and then fit a model with two predictors, the one of interest and the dummy variable, which will be ignored by the model fitting as it has no useful information.
</p>


<h3>Author(s)</h3>

<p>John R. Leathwick and Jane Elith
</p>


<h3>References</h3>

<p>Hastie, T., R. Tibshirani, and J.H. Friedman, 2001. The Elements of Statistical Learning: Data Mining, Inference, and Prediction. Springer-Verlag, New York
Elith, J., J.R. Leathwick and T. Hastie, 2009. A working guide to boosted regression trees. Journal of Animal Ecology 77: 802-81
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Anguilla_train)
# reduce data set to speed things up a bit
Anguilla_train = Anguilla_train[1:200,]
angaus.tc5.lr01 &lt;- gbm.step(data=Anguilla_train, gbm.x = 3:14, gbm.y = 2, family = "bernoulli",
       tree.complexity = 5, learning.rate = 0.01, bag.fraction = 0.5)
</code></pre>

<hr>
<h2 id='geocode'>Georeferencing with Google</h2><span id='topic+geocode'></span>

<h3>Description</h3>

<p>A wrapper around the Google geocoding web-service. It returns 0 to n matches. It is important to be as precise as possible, e.g. always include the country in the locality description. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocode(x, oneRecord=FALSE, extent=NULL, progress='', geocode_key, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geocode_+3A_x">x</code></td>
<td>
<p>A vector of locality descriptions</p>
</td></tr>
<tr><td><code id="geocode_+3A_onerecord">oneRecord</code></td>
<td>
<p>Logical. If <code>TRUE</code> a single record for each item in x is returned. If the API returned multiple records, the values of this record are computed by averaging the coordinates and taking the union of all bounding boxes </p>
</td></tr>
<tr><td><code id="geocode_+3A_extent">extent</code></td>
<td>
<p>An Extent object, or an object that can be coerced to one, to bias the search towards that region</p>
</td></tr>
<tr><td><code id="geocode_+3A_progress">progress</code></td>
<td>
<p>Character. Valid values are &quot;&quot; (no progress indicator), &quot;text&quot; or &quot;window&quot;</p>
</td></tr>
<tr><td><code id="geocode_+3A_geocode_key">geocode_key</code></td>
<td>
<p>character. Your Google API key for geocoding (and billing). See  https://developers.google.com/maps/documentation/geocoding/get-api-key)</p>
</td></tr>
<tr><td><code id="geocode_+3A_...">...</code></td>
<td>
<p>additional arguments (currently none implemeted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the following fields:
</p>
<table>
<tr><td><code>originalPlace</code></td>
<td>
<p>the locality description as provided (in argument <code>x</code>)</p>
</td></tr>
<tr><td><code>interpretedPlace</code></td>
<td>
<p>the locality as interpreted by the Google API</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code>lonmin</code></td>
<td>
<p>minimum longitude of the bounding box</p>
</td></tr>
<tr><td><code>lonmax</code></td>
<td>
<p>maximum longitude of the bounding box</p>
</td></tr>
<tr><td><code>latmin</code></td>
<td>
<p>minimum latitude of the bounding box</p>
</td></tr>
<tr><td><code>latmax</code></td>
<td>
<p>maximum latitude of the bounding box</p>
</td></tr>
<tr><td><code>uncertainty</code></td>
<td>
<p>distance from <code>c(lon, lat)</code> to the farthest corner of the bounding box</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is important to compare fields <code>originalPlace</code> and <code>interpretedPlace</code> as the Google interpretation of a (perhaps vague) locality description can be very speculative</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
geocode(c('1600 Pennsylvania Ave NW, Washington DC', 'Luca, Italy', 'Kampala'))
geocode(c('San Jose', 'San Jose, Mexico'))
geocode(c('San Jose', 'San Jose, Mexico'), oneRecord=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='Geographic+20Distance'>Geographic distance model</h2><span id='topic+geoDist'></span><span id='topic+geoDist+2CSpatialPoints-method'></span><span id='topic+geoDist+2Cmatrix-method'></span><span id='topic+geoDist+2Cdata.frame-method'></span><span id='topic+GeographicDistance-class'></span>

<h3>Description</h3>

<p>The geographic distance model predicts that the likelyhood of presence is highest near places where a species has been observed. It can be used as a null-model to calibrate cross-validation scores with.
</p>
<p>The predicted values are the inverse distance to the nearest known presence point. Distances smaller than or equal to zero are set to 1 (highest score).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoDist(p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Geographic+2B20Distance_+3A_p">p</code></td>
<td>
<p>point locations (presence). Two column matrix, data.frame or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="Geographic+2B20Distance_+3A_...">...</code></td>
<td>
<p> Additional arguments. You must supply a lonlat= argument (logical), unless p is a SpatialPoints* object and has a valid CRS (coordinate reference system). 
You can also supply an additional argument 'a' for absence points (currently ignored). Argument 'a' should be of the same class as argument 'p' </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'GeographicDistance' (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a>, <a href="#topic+convHull">convHull</a>, <a href="#topic+maxent">maxent</a>, <a href="#topic+domain">domain</a>, <a href="#topic+mahal">mahal</a>, <a href="#topic+voronoiHull">voronoiHull</a>, <a href="#topic+geoIDW">geoIDW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/rlogo.grd", package="raster"))
#presence data
pts &lt;- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66, 74, 50, 48, 
        28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)
colnames(pts) &lt;- c('x', 'y')

train &lt;- pts[1:12, ]
test &lt;- pts[13:20, ]
				 
gd &lt;- geoDist(train, lonlat=FALSE)
p &lt;- predict(gd, r)

## Not run: 
plot(p)
points(test, col='black', pch=20, cex=2)
points(train, col='red', pch=20, cex=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='gmap'>Get a Google map</h2><span id='topic+gmap'></span><span id='topic+Mercator'></span>

<h3>Description</h3>

<p>Retrieve a 'Google Map' that can be used as a background for plotting points and other spatial data.
</p>
<p>The projection of the returned Raster object is &quot;Mercator&quot; (unless you use <code>lonlat=TRUE</code>), and other spatial data may need to be transformed before it can be plotted on top of the Google map. You can use the <code>Mercator</code> function to transform points from longitude/latitude to Mercator. For SpatialLines and SpatialPolygons objects, use <code>spTransform</code> in the <code>rgdal</code> package.
</p>
<p>This function uses the Google static maps web-service, and is based on functions by Markus Loecher for the <code>RgoogleMaps</code> package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmap(x, exp=1, type='terrain', filename='', style=NULL, scale=1, zoom=NULL, 
      size=c(640, 640), rgb=FALSE, lonlat=FALSE, map_key, geocode_key, ...)

Mercator(p, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmap_+3A_x">x</code></td>
<td>
<p>a textual locality description, or an Extent object (with longitude/latitude coordinates), or an object that can be coerced to one (such as a Raster* or Spatial* object), in any (known) coordinate system</p>
</td></tr>
<tr><td><code id="gmap_+3A_exp">exp</code></td>
<td>
<p>numeric. An expansion factor to enlarge (by multiplication) the extent specified by <code>x</code> </p>
</td></tr>
<tr><td><code id="gmap_+3A_type">type</code></td>
<td>
<p>character. Choose from 'roadmap', 'satellite', 'hybrid', 'terrain' </p>
</td></tr>
<tr><td><code id="gmap_+3A_filename">filename</code></td>
<td>
<p>character. Filename (optional). You can open the resulting file in a GIS program </p>
</td></tr>
<tr><td><code id="gmap_+3A_style">style</code></td>
<td>
<p>character. Additional style arguments. See <a href="https://developers.google.com/maps/documentation/maps-static/overview?csw=1#StyledMapFeatures">https://developers.google.com/maps/documentation/maps-static/overview?csw=1#StyledMapFeatures</a>.
Note that certain style features do not work in combination with (the default) <code>type='terrain'</code> </p>
</td></tr>
<tr><td><code id="gmap_+3A_scale">scale</code></td>
<td>
<p>1 or 2. Using 2 doubles the number of pixels returned (and thus gives you better image quality if you need a large image)</p>
</td></tr>
<tr><td><code id="gmap_+3A_zoom">zoom</code></td>
<td>
<p>integer between 0 (the whole world) to 21 (very small area), centered on the center of the extent</p>
</td></tr>
<tr><td><code id="gmap_+3A_size">size</code></td>
<td>
<p>vector of two integers indicating the number of columns and rows that is requested (what is returned depends on other factors as well). Maximum values are <code>c(640, 640)</code>, so you can only select a smaller area than the default. Note that the number of pixels returned can be doubled by using <code>scale=2</code></p>
</td></tr>
<tr><td><code id="gmap_+3A_rgb">rgb</code></td>
<td>
<p>logical. If <code>TRUE</code>, a RasterBrick is returned with three layers (red, green, blue). This can be plotted with <code>plotRGB</code></p>
</td></tr>
<tr><td><code id="gmap_+3A_lonlat">lonlat</code></td>
<td>
<p>logical. If <code>TRUE</code> the Raster object returned has a longitude/latitude CRS instead of Mercator</p>
</td></tr>
<tr><td><code id="gmap_+3A_map_key">map_key</code></td>
<td>
<p>character. Your Google API key for mapping (and billing). See  https://developers.google.com/maps/documentation/javascript/get-api-key)</p>
</td></tr>   
<tr><td><code id="gmap_+3A_geocode_key">geocode_key</code></td>
<td>
<p>character. Your Google API key for geocoding (and billing). Only relevant if <code>x</code> is a textual locality description. See  https://developers.google.com/maps/documentation/javascript/get-api-key)</p>
</td></tr>   
<tr><td><code id="gmap_+3A_...">...</code></td>
<td>
<p>additional parameters </p>
</td></tr>
<tr><td><code id="gmap_+3A_p">p</code></td>
<td>
<p>Points. A two-column matrix, or a SpatialPoints object</p>
</td></tr>
<tr><td><code id="gmap_+3A_inverse">inverse</code></td>
<td>
<p> Should the inverse projection be done (from Mercator to longitude/latitude?) </p>
</td></tr>  
</table>


<h3>Details</h3>

<p>If argument <code>x</code> is a textual locality description, the <code><a href="#topic+geocode">geocode</a></code> function is used to retrieve the extent that should be mapped.
</p>
<p>Change the type to 'roadmap' if the map returned says &quot;sorry we have no imagery here&quot;; or use a larger extent.
</p>
<p>The returned RasterLayer has a Mercator projection. To plot points (or lines or polygons) on top of it, these need to be transformed first.
</p>
<p>A matrix of longitude/latitude data can be transformed with the Mercator function used in the example below. 'Spatial*' objects can be transformed with <code>spTransform</code>
p &lt;- spTransform(x, &quot;+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs&quot;)
</p>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans and Sebastien Rochette, based on code by Markus Loecher, Sense Networks &lt;markus at sensenetworks.com&gt; in the RgoogleMaps package</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mymapkey = "pk-tHVbDiymfUL"
mygeokey = "Skxe99-adfKeax"

library(rgdal)

# from a maxtrix with lon/lat points
x &lt;- runif(30)*10 + 40
y &lt;- runif(30)*10 - 20
xy &lt;- cbind(x, y)
g &lt;- gmap(xy, type='hybrid', map_key=mymapkey)
plot(g, inter=TRUE)
points(Mercator(xy) , col='red', pch=20)

# or from an Extent object
e &lt;- extent( -121.9531 , -120.3897 , 35.36 , 36.61956 )
# you can also get an Extent object by clicking on the map twice after using:
# drawExtent()
r &lt;- gmap(e, map_key=mymapkey)
plot(r, interpolate=TRUE)

# transform points to Mercator for plotting on top of map:
pt &lt;- matrix(c(-121, 36), ncol=2)
ptm &lt;- Mercator(pt)
points(ptm, cex=3, pch=20, col='blue')
Mercator(ptm, inverse=TRUE)

# transform Spatial objects to Mercator for plotting on top of map
# here for points, but particularly relevant for lines and polygons
pt &lt;- data.frame(pt)
coordinates(pt) &lt;- ~X1 + X2
proj4string(pt) &lt;-"+proj=longlat +datum=WGS84 +ellps=WGS84"
ptm2 &lt;- spTransform(pt, CRS("+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 
      +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"))
points(ptm, col='red', pch='x', cex=3)



# get a map using names
g = gmap('Australia', map_key=mymapkey, geocode_key=mygeokey)
plot(g, inter=TRUE)

gs = gmap('Sydney, New South Wales, Australia', type='satellite',
                map_key=mymapkey, geocode_key=mygeokey)
plot(gs, inter=TRUE)

gs = gmap('Sydney, Australia', type='satellite', exp=3, 
				map_key=mymapkey, geocode_key=mygeokey)
plot(gs, inter=TRUE)

gs = gmap('Sydney, Australia', type='hybrid', zoom=10, scale=2,
				map_key=mymapkey, geocode_key=mygeokey)
plot(gs, inter=TRUE)

# styles:
g &lt;- gmap("Brooklyn", style="feature:road.local|element:geometry|hue:0x00ff00|saturation:100
  &amp;style=feature:landscape|element:geometry|lightness:-100", type='roadmap', 
  map_key=mymapkey, geocode_key=mygeokey)
plot(g)

## End(Not run)
</code></pre>

<hr>
<h2 id='gridSample'>Stratified regular sample on a grid</h2><span id='topic+gridSample'></span>

<h3>Description</h3>

<p>Sample points from xy, using a grid (raster) as stratification. Up to n points are sampled from each stratum (cell). For &quot;chessboard&quot; sampling (i.e. sampling from half the cells), use the argument <code>chess='black'</code>, or <code>chess='white'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridSample(xy, r, n=1, chess='') 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridSample_+3A_xy">xy</code></td>
<td>
<p>A two column matrix or data.frame with x and y coordinates (or longitude and latitude), or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="gridSample_+3A_r">r</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="gridSample_+3A_n">n</code></td>
<td>
<p>Maximum number of samples per cell</p>
</td></tr>  
<tr><td><code id="gridSample_+3A_chess">chess</code></td>
<td>
<p>Character. &rdquo;, 'black', or 'white'. If 'black' or 'white', &quot;chess-board&quot; sampling is used. I.e. only the 'white' fields, or only the 'black' fields are sampled. Cell number 1 (the upper left corner of <code>r</code>) is white.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A two column matrix with x and y coordinates (or longitude and latitude)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+pwdSample">pwdSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000, 10, 5)
y &lt;- rnorm(1000, 50, 5)
xy &lt;- cbind(x,y)
res &lt;- 5
r &lt;- raster(extent(range(xy[,1]), range(xy[,2])) + res)
res(r) &lt;- res

samp &lt;- gridSample(xy, r, n=1)
plot(xy, cex=0.1)
points(samp, pch='x', col='red')
</code></pre>

<hr>
<h2 id='InvDistW'>Inverse-distance weighted model</h2><span id='topic+geoIDW'></span><span id='topic+geoIDW+2CSpatialPoints+2CSpatialPoints-method'></span><span id='topic+geoIDW+2Cmatrix+2Cmatrix-method'></span><span id='topic+geoIDW+2Cdata.frame+2Cdata.frame-method'></span><span id='topic+InvDistWeightModel-class'></span>

<h3>Description</h3>

<p>Inverse-distance weighted predictions for presence/absence data. Computed with the gstat function from the gstat package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoIDW(p, a, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvDistW_+3A_p">p</code></td>
<td>
<p>Presence points. Two column matrix, data.frame, or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="InvDistW_+3A_a">a</code></td>
<td>
<p>Absence points. Must be of the same class as p</p>
</td></tr>
<tr><td><code id="InvDistW_+3A_...">...</code></td>
<td>
<p>Addtional arguments. None implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class InvDistWeightModel (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/rlogo.grd", package="raster"))
# presence points
p &lt;- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66, 74, 50, 48, 
      28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)

# absence points
a &lt;- matrix(c(30, 23, 5, 5, 31, 33, 91, 63, 60, 88, 93, 97, 65, 68, 85, 97, 35, 32, 29, 55,
      3, 8, 19, 71, 49, 36, 69, 41, 20, 28, 18, 9, 5, 9, 25, 71, 8, 32, 46, 60), ncol=2)

idw &lt;- geoIDW(p, a)
prd &lt;- predict(r, idw)

## Not run: 
plot(prd)
points(p)
points(a, pch='x')

## End(Not run)
</code></pre>

<hr>
<h2 id='kfold'>
k-fold partitioning
</h2><span id='topic+kfold'></span>

<h3>Description</h3>

<p>k-fold partitioning of a data set for model testing purposes. Each record in a matrix (or similar data structure) is randomly assigned to a group. Group numbers are between 1 and <code>k</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfold(x, k=5, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfold_+3A_x">x</code></td>
<td>
<p>a vector, matrix, data.frame, or Spatial object</p>
</td></tr>
<tr><td><code id="kfold_+3A_k">k</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code id="kfold_+3A_by">by</code></td>
<td>
<p>Optional argument. A vector or factor with sub-groups (e.g. species). Its length should be the same as the number of records in x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with group assignments
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#library(disdat)
#data(NSWtrain)
## a single species
#srsp1 &lt;- subset(NSWtrain, spid=='srsp1')
#kfold(srsp1, k = 5)

## all species
#k = kfold(NSWtrain, k=5, by=NSWtrain$spid)

#k[NSWtrain$spid=='srsp1']
## each group has the same number of records 
##(except for adjustments if the number of records divided by k is not an integer) 
#table(k[NSWtrain$spid=='srsp1'])
#k[NSWtrain$spid=='ousp5']

</code></pre>

<hr>
<h2 id='mahal'>
Mahalanobis model
</h2><span id='topic+mahal'></span><span id='topic+mahal+2CRaster+2CSpatialPoints-method'></span><span id='topic+mahal+2CRaster+2Cmatrix-method'></span><span id='topic+mahal+2CRaster+2Cdata.frame-method'></span><span id='topic+mahal+2Cmatrix+2Cmissing-method'></span><span id='topic+mahal+2Cdata.frame+2Cmissing-method'></span><span id='topic+Mahalanobis-class'></span>

<h3>Description</h3>

<p>Distribution model based on the Mahalanobis distance. The predictions are (1-distance). I.e. the highest possible value is 1, and there will likely be large negative numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahal(x, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahal_+3A_x">x</code></td>
<td>
<p> Raster* object or matrix</p>
</td></tr>
<tr><td><code id="mahal_+3A_p">p</code></td>
<td>
<p> two column matrix or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="mahal_+3A_...">...</code></td>
<td>
<p> Additional arguments. Currently not used </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class Mahalanobis (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a>, <a href="#topic+maxent">maxent</a>, <a href="#topic+bioclim">bioclim</a>, <a href="#topic+domain">domain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logo &lt;- stack(system.file("external/rlogo.grd", package="raster"))

#presence data
pts &lt;- matrix(c(48.243420, 48.243420, 47.985820, 52.880230, 49.531423, 46.182616, 
  54.168232, 69.624263, 83.792291, 85.337894, 74.261072, 83.792291, 95.126713, 
  84.565092, 66.275456, 41.803408, 25.832176, 3.936132, 18.876962, 17.331359, 
  7.048974, 13.648543, 26.093446, 28.544714, 39.104026, 44.572240, 51.171810, 
  56.262906, 46.269272, 38.161230, 30.618865, 21.945145, 34.390047, 59.656971, 
  69.839163, 73.233228, 63.239594, 45.892154, 43.252326, 28.356155), ncol=2)

# fit model
m &lt;- mahal(logo, pts)

# make a prediction
predict(m, logo[1])

x &lt;- predict(m, logo)

# or x &lt;- predict(logo, m) via raster::predict

# plot(x &gt; 0)
</code></pre>

<hr>
<h2 id='maxent'>Maxent</h2><span id='topic+maxent'></span><span id='topic+maxent+2Cmissing+2Cmissing-method'></span><span id='topic+maxent+2CRaster+2CANY-method'></span><span id='topic+maxent+2CSpatialGridDataFrame+2CANY-method'></span><span id='topic+maxent+2Cdata.frame+2Cvector-method'></span><span id='topic+MaxEnt-class'></span><span id='topic+MaxEntReplicates-class'></span>

<h3>Description</h3>

<p>Build a &quot;MaxEnt&quot; (Maximum Entropy) species distribution model (see references below). The function uses environmental data for locations of known presence and for a large number of 'background' locations. Environmental data can be extracted from raster files. The result is a model object that can be used to predict the suitability of other locations, for example, to predict the entire range of a species. 
</p>
<p>Background points are sampled randomly from the cells that are not <code>NA</code> in the first predictor variable, unless background points are specified with argument <code>a</code>. 
</p>
<p>This function uses the MaxEnt species distribution model software by Phillips, Dudik and Schapire.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Raster,ANY'
maxent(x, p, a=NULL, factors=NULL, removeDuplicates=TRUE, nbg=10000, ...)

## S4 method for signature 'SpatialGridDataFrame,ANY'
maxent(x, p, a=NULL, removeDuplicates=TRUE, nbg=10000, ...)

## S4 method for signature 'data.frame,vector'
maxent(x, p, args=NULL, path, ...)

## S4 method for signature 'missing,missing'
maxent(x, p, silent=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxent_+3A_x">x</code></td>
<td>
<p>Predictors. Raster* object or SpatialGridDataFrame, containing grids with predictor variables. These will be used to extract values from for the point locations. <code>x</code> can also be a data.frame, in which case each column should be a predictor variable and each row a presence or background record</p>
</td></tr>
<tr><td><code id="maxent_+3A_p">p</code></td>
<td>
<p>Occurrence data. This can be a data.frame, matrix, SpatialPoints* object, or a vector. If <code>p</code> is a data.frame or matrix it represents a set of point locations; and it must have two columns with the first being the x-coordinate (longitude) and the second the y-coordinate (latitude). Coordinates can also be specified with a SpatialPoints* object
</p>
<p>If <code>x</code> is a data.frame, <code>p</code> should be a vector with a length equal to <code>nrow(x)</code> and contain 0 (background) and 1 (presence) values, to indicate which records (rows) in data.frame <code>x</code> are presence records, and which are background records</p>
</td></tr>
<tr><td><code id="maxent_+3A_a">a</code></td>
<td>
<p>Background points. Only used if <code>p</code> is and not a vector and not missing</p>
</td></tr>
<tr><td><code id="maxent_+3A_nbg">nbg</code></td>
<td>
<p>Number of background points to use. These are sampled randomly from the cells that are not <code>NA</code> in the first predictor variable. Ignored if background points are specified with argument <code>a</code></p>
</td></tr> 
<tr><td><code id="maxent_+3A_factors">factors</code></td>
<td>
<p>character. Which (if any) variables should be considered as categorical? Either by (layer)name or by index. Only used when argument 'x' is a Raster* object because it is not needed in other cases as you can set the appropriate class to the variables in the data.frame</p>
</td></tr>
<tr><td><code id="maxent_+3A_args">args</code></td>
<td>
<p>charater. Additional argument that can be passed to MaxEnt. See the MaxEnt help for more information. The R maxent function only uses the arguments relevant to model fitting. There is no point in using args='outputformat=raw' when *fitting* the model; but you can use arguments relevant for *prediction* when using the predict function. Some other arguments do not apply at all to the R implementation. An example is 'outputfiletype', because the 'predict' function has its own 'filename' argument for that</p>
</td></tr>
<tr><td><code id="maxent_+3A_removeduplicates">removeDuplicates</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, duplicate presence points (that fall in the same grid cell) are removed</p>
</td></tr>
<tr><td><code id="maxent_+3A_path">path</code></td>
<td>
<p>character. Optional argument to set where you want the MaxEnt output files to be stored. This allows you to permanently keep these files. If not supplied the MaxEnt files will be stored in a temporary file. These are the files that are shown in a browser when typing the model name or when you use &quot;show(model)&quot;</p>
</td></tr>
<tr><td><code id="maxent_+3A_silent">silent</code></td>
<td>
<p>Boolean. If <code>TRUE</code> a message is printed</p>
</td></tr>
<tr><td><code id="maxent_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'MaxEnt' (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>). Or a 'MaxEntReplicates' object if you use 'replicates=' as part of the <code>args</code> argument. If the function is run without any arguments a boolean value is returned (<code>TRUE</code> if maxent.jar was found).
</p>


<h3>Author(s)</h3>

<p>Steven Phillips and Robert J. Hijmans</p>


<h3>References</h3>

<p><a href="https://biodiversityinformatics.amnh.org/open_source/maxent/">https://biodiversityinformatics.amnh.org/open_source/maxent/</a>
</p>
<p>Steven J. Phillips, Miroslav Dudik, Robert E. Schapire, 2004.  A maximum entropy approach to species distribution modeling. Proceedings of the Twenty-First International Conference on Machine Learning. p. 655-662.
</p>
<p>Steven J. Phillips, Robert P. Anderson, Robert E. Schapire, 2006. Maximum entropy modeling of species geographic distributions. Ecological Modelling 190:231-259. 
</p>
<p>Jane Elith, Steven J. Phillips, Trevor Hastie, Miroslav Dudik, Yung En Chee, Colin J. Yates, 2011. A statistical explanation of MaxEnt for ecologists. Diversity and Distributions 17:43-57. <a href="https://doi.org/10.1111/j.1472-4642.2010.00725.x">doi:10.1111/j.1472-4642.2010.00725.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# test if you can use maxent 
maxent()

if (maxent()) {

# get predictor variables
fnames &lt;- list.files(path=paste(system.file(package="dismo"), '/ex', sep=''), 
              pattern='grd', full.names=TRUE )
predictors &lt;- stack(fnames)
#plot(predictors)

# file with presence points
occurence &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
occ &lt;- read.table(occurence, header=TRUE, sep=',')[,-1]

# witholding a 20% sample for testing 
fold &lt;- kfold(occ, k=5)
occtest &lt;- occ[fold == 1, ]
occtrain &lt;- occ[fold != 1, ]

# fit model, biome is a categorical variable
me &lt;- maxent(predictors, occtrain, factors='biome')

# see the maxent results in a browser:
me

# use "args"
# me2 &lt;- maxent(predictors, occtrain, factors='biome', args=c("-J", "-P"))

# plot showing importance of each variable
plot(me)

# response curves
# response(me)

# predict to entire dataset
r &lt;- predict(me, predictors) 

# with some options:
# r &lt;- predict(me, predictors, args=c("outputformat=raw"), progress='text', 
#      filename='maxent_prediction.grd')

plot(r)
points(occ)

#testing
# background data
bg &lt;- randomPoints(predictors, 1000)

#simplest way to use 'evaluate'
e1 &lt;- evaluate(me, p=occtest, a=bg, x=predictors)

# alternative 1
# extract values
pvtest &lt;- data.frame(extract(predictors, occtest))
avtest &lt;- data.frame(extract(predictors, bg))

e2 &lt;- evaluate(me, p=pvtest, a=avtest)

# alternative 2 
# predict to testing points 
testp &lt;- predict(me, pvtest) 
head(testp)
testa &lt;- predict(me, avtest) 

e3 &lt;- evaluate(p=testp, a=testa)
e3
threshold(e3)

plot(e3, 'ROC')
}


</code></pre>

<hr>
<h2 id='mess'>Multivariate environmental similarity surfaces (MESS)</h2><span id='topic+mess'></span>

<h3>Description</h3>

<p>Compute multivariate environmental similarity surfaces (MESS), as described by Elith et al., 2010</p>


<h3>Usage</h3>

<pre><code class='language-R'>mess(x, v, full=FALSE, filename='', ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mess_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="mess_+3A_v">v</code></td>
<td>
<p>matrix or data.frame containing the reference values. Each column should correspond to one layer of the Raster* object</p>
</td></tr>
<tr><td><code id="mess_+3A_full">full</code></td>
<td>
<p>logical. If <code>FALSE</code> a RasterLayer with the MESS values is returned. If <code>TRUE</code>, a RasterBrick is returned with <code>n</code> layers corresponding to the layers of the input Raster object and an additional layer with the MESS values</p>
</td></tr>
<tr><td><code id="mess_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="mess_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code>writeRaster</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>v</code> can be obtained for a set of points using <code><a href="raster.html#topic+extract">extract</a></code> .
</p>


<h3>Value</h3>

<p>A RasterBrick with layers corresponding to the input layers and an additional layer with the mess values (if <code>full=TRUE</code> and <code>nlayers(x) &gt; 1</code>) or a RasterLayer with the MESS values (if <code>full=FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Jean-Pierre Rossi &lt;jean-pierre.rossi@supagro.inra.fr&gt;, Robert Hijmans, Paulo van Breugel
</p>


<h3>References</h3>

<p>Elith J., M. Kearney M., and S. Phillips, 2010. The art of modelling range-shifting species. <a href="https://doi.org/10.1111/j.2041-210X.2010.00036.x">doi:10.1111/j.2041-210X.2010.00036.x</a>Methods in Ecology and Evolution 1:330-342.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(9)
r &lt;- raster(ncol=10, nrow=10)
r1 &lt;- setValues(r, (1:ncell(r))/10 + rnorm(ncell(r)))
r2 &lt;- setValues(r, (1:ncell(r))/10 + rnorm(ncell(r)))
r3 &lt;- setValues(r, (1:ncell(r))/10 + rnorm(ncell(r)))
s &lt;- stack(r1,r2,r3)
names(s) &lt;- c('a', 'b', 'c')
xy &lt;- cbind(rep(c(10,30,50), 3), rep(c(10,30,50), each=3))
refpt &lt;- extract(s, xy)

ms &lt;- mess(s, refpt, full=TRUE)
plot(ms)


## Not run: 
filename &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
bradypus &lt;- read.table(filename, header=TRUE, sep=',')
bradypus &lt;- bradypus[,2:3]
files &lt;- list.files(path=paste(system.file(package="dismo"),'/ex', sep=''), 
   pattern='grd', full.names=TRUE )
predictors &lt;- stack(files)
predictors &lt;- dropLayer(x=predictors,i=9)
reference_points &lt;- extract(predictors, bradypus)
mss &lt;- mess(x=predictors, v=reference_points, full=TRUE)
plot(mss)

## End(Not run)

</code></pre>

<hr>
<h2 id='ModelEvaluation'>Class &quot;ModelEvaluation&quot;</h2><span id='topic+ModelEvaluation-class'></span>

<h3>Description</h3>

<p>Class to store results of model cross-validation with presence/absence (0/1) data
</p>


<h3>Slots</h3>


<dl>
<dt><code>presence</code>:</dt><dd><p>presence data used </p>
</dd>
<dt><code>absence</code>:</dt><dd><p>absence data used</p>
</dd>
<dt><code>np</code>:</dt><dd><p>number of presence points</p>
</dd>
<dt><code>na</code>:</dt><dd><p>number of absence points</p>
</dd>
<dt><code>auc</code>:</dt><dd><p>Area under the receiver operator (ROC) curve</p>
</dd>
<dt><code>pauc</code>:</dt><dd><p> p-value for the AUC (for the Wilcoxon test W statistic</p>
</dd>
<dt><code>cor</code>:</dt><dd><p> Correlation coefficient</p>
</dd>
<dt><code>pcor</code>:</dt><dd><p>p-value for correlation coefficient </p>
</dd>
<dt><code>t</code>:</dt><dd><p> vector of thresholds used to compute confusion matrices </p>
</dd>
<dt><code>confusion</code>:</dt><dd><p> confusion matrices </p>
</dd>
<dt><code>prevalence</code>:</dt><dd><p> Prevalence </p>
</dd>
<dt><code>ODP</code>:</dt><dd><p> Overall diagnostic power </p>
</dd>
<dt><code>CCR</code>:</dt><dd><p> Correct classification rate </p>
</dd>
<dt><code>TPR</code>:</dt><dd><p> True positive rate </p>
</dd>
<dt><code>TNR</code>:</dt><dd><p> True negative rate </p>
</dd>
<dt><code>FPR</code>:</dt><dd><p> False positive rate </p>
</dd>
<dt><code>FNR</code>:</dt><dd><p> False negative rate </p>
</dd>
<dt><code>PPP</code>:</dt><dd><p> Positive predictive power </p>
</dd>
<dt><code>NPP</code>:</dt><dd><p> Negative predictive power </p>
</dd>
<dt><code>MCR</code>:</dt><dd><p> Misclassification rate </p>
</dd>
<dt><code>OR</code>:</dt><dd><p> Odds-ratio </p>
</dd>
<dt><code>kappa</code>:</dt><dd><p> Cohen's kappa </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>References</h3>

<p>Fielding, A. H. &amp; J.F. Bell, 1997. A review of methods for the assessment of prediction errors in conservation presence/absence models. Environmental Conservation 24: 38-49
</p>
<p>Liu, C., M. White &amp; G. Newell, 2011. Measuring and comparing the accuracy of species distribution models with presence-absence data. Ecography 34: 232-243.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+evaluate">evaluate</a></code> 
</p>

<hr>
<h2 id='nicheEquivalency'>Niche equivalency</h2><span id='topic+nicheEquivalency'></span>

<h3>Description</h3>

<p>Compute niche equivalency for two species following Warren et al. (2009). The statistic ranges from 0 to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
nicheEquivalency(sp1, sp2, predictors, n=99, model=maxent, verbose=TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nicheEquivalency_+3A_sp1">sp1</code></td>
<td>
<p>coordinates for species 1 (matrix with (x, y) or (lon, lat), or SpatialPoints)</p>
</td></tr>
<tr><td><code id="nicheEquivalency_+3A_sp2">sp2</code></td>
<td>
<p>coordinates for species 2 (matrix with (x, y) or (lon, lat), or SpatialPoints)</p>
</td></tr>
<tr><td><code id="nicheEquivalency_+3A_predictors">predictors</code></td>
<td>
<p>Raster object with environmental variables</p>
</td></tr>
<tr><td><code id="nicheEquivalency_+3A_n">n</code></td>
<td>
<p>integer. Number of randomizations</p>
</td></tr>
<tr><td><code id="nicheEquivalency_+3A_model">model</code></td>
<td>
<p>function. modeling algorithm to me used</p>
</td></tr>
<tr><td><code id="nicheEquivalency_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> some progress indicators are printed</p>
</td></tr>
<tr><td><code id="nicheEquivalency_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric</p>


<h3>Author(s)</h3>

<p>Brian Anacker. Based on a similar function in by Christoph Heibl in the phyloclim package</p>


<h3>References</h3>

<p> Warren, D.L., R.E. Glor, M. Turelli, 2008. Environmental niche equivalency versus conservatism: quantitative approaches to niche evolution. Evolution 62:2868-2883. </p>

<hr>
<h2 id='nicheOverlap'>Niche overlap</h2><span id='topic+nicheOverlap'></span>

<h3>Description</h3>

<p>Compute niche overlap from predictions of species distributions with the 'I' or 'D' similarity statistic of Warren et al. (2009). The statistic ranges from 0 (no overlap) to 1 (the distributions are identical).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> nicheOverlap(x, y, stat='I', mask=TRUE, checkNegatives=TRUE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nicheOverlap_+3A_x">x</code></td>
<td>
<p>RasterLayer with non-negative values (predictions of the probability that a site is suitable for a species)</p>
</td></tr>
<tr><td><code id="nicheOverlap_+3A_y">y</code></td>
<td>
<p>RasterLayer with non-negative values, as above</p>
</td></tr>
<tr><td><code id="nicheOverlap_+3A_stat">stat</code></td>
<td>
<p>character either 'I' or 'D' to get the statistic with that name</p>
</td></tr>
<tr><td><code id="nicheOverlap_+3A_mask">mask</code></td>
<td>
<p>logical. If <code>TRUE</code> the function removes cells from <code>x</code> that are <code>NA</code> in <code>y</code> and vice-versa. If you are sure that such cases do not occur you can set this to <code>FALSE</code> to speed up computations</p>
</td></tr>
<tr><td><code id="nicheOverlap_+3A_checknegatives">checkNegatives</code></td>
<td>
<p>logical. If <code>TRUE</code> the function checks of any of the values in <code>x</code> and <code>y</code> are negative. If you are sure that such cases do not occur you can set this to <code>FALSE</code> to speed up computations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric</p>


<h3>Author(s)</h3>

<p>Based on SDMTools::Istat by Jeremy VanDerWal </p>


<h3>References</h3>

<p> Warren, D.L., R.E. Glor, M. Turelli, and D. Funk. 2009. Environmental niche equivalency versus conservatism: quantitative approaches to niche evolution. Evolution 62:2868-2883; Erratum: Evolution 65: 1215</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- raster(nr=18, nc=36)
r2 &lt;- raster(nr=18, nc=36)
set.seed(0)
r1[] &lt;- runif(ncell(r1))
r2[] &lt;- runif(ncell(r1))
nicheOverlap(r1, r2)
</code></pre>

<hr>
<h2 id='pairs'>
Pair plots
</h2><span id='topic+pairs'></span><span id='topic+pairs+2CDistModel-method'></span>

<h3>Description</h3>

<p>Pair plots of presence and absence (background) data.
</p>


<h3>Methods</h3>


<p><code>pairs(x, v=NULL, pa='pa', hist=TRUE, cor=TRUE)</code>
</p>

<table>
<tr>
 <td style="text-align: right;">  
 </td><td style="text-align: left;">  <code>x</code>  </td><td style="text-align: left;"> Object of class DistModel or derived from that class (such as 'MaxEnt', 'Bioclim') </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>v</code> </td><td style="text-align: left;"> numeric, to select a subset of pairs, e.g. v=1:3 to plot only the first three variables </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>pa</code> </td><td style="text-align: left;"> Character. Either 'pa', 'p', or 'a' to show presence and absence, presence, or absence data respectively</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>hist</code> </td><td style="text-align: left;"> logical. If <code>TRUE</code> a histogram of the values is shown on the diagonal</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>cor</code> </td><td style="text-align: left;"> logical. If <code>TRUE</code> the correlation coefficient is shown in the upper panels </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>
		



<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density">density</a>, <a href="#topic+plot">plot</a></code>
</p>

<hr>
<h2 id='plot'>
Plot predictor values 
</h2><span id='topic+plot+2CBioclim+2Cmissing-method'></span><span id='topic+plot+2CDistModel+2Cnumeric-method'></span><span id='topic+plot+2CMaxEnt+2Cmissing-method'></span><span id='topic+plot+2CVoronoiHull+2Cmissing-method'></span><span id='topic+plot+2CRectangularHull+2Cmissing-method'></span><span id='topic+plot+2CCircleHull+2Cmissing-method'></span><span id='topic+plot+2CCirclesRange+2Cmissing-method'></span><span id='topic+plot+2CConvexHull+2Cmissing-method'></span><span id='topic+points+2CDistModel-method'></span>

<h3>Description</h3>

<p>Plot predictor values for occurrence (presence and absence) data in a DistModel (or derived) object.
</p>


<h3>Methods</h3>

<p>usage:  <code>plot(x, y, ...)</code>
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>x</code>  </td><td style="text-align: left;">  Object of class DistModel or from a class that inherits from it </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>y</code>  </td><td style="text-align: left;">  missing </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>...</code>  </td><td style="text-align: left;">  Additional arguments that can be passed to <a href="base.html#topic+plot">plot</a> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density">density</a>, <a href="#topic+pairs">pairs</a>, <a href="base.html#topic+plot">plot</a></code>
</p>

<hr>
<h2 id='pointValues'>
point values
</h2><span id='topic+pointValues'></span>

<h3>Description</h3>

<p>Extract values from a Raster* object for point locations. This function adds a few options that can be useful in the context of species distribution modeling to <code><a href="raster.html#topic+extract">extract</a></code> function in the raster package.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointValues(x, p, a, uniquecells = TRUE, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointValues_+3A_x">x</code></td>
<td>
<p>A Raster* object</p>
</td></tr>
<tr><td><code id="pointValues_+3A_p">p</code></td>
<td>
<p>Points. Two-colum matrix or data.frame; or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="pointValues_+3A_a">a</code></td>
<td>
<p>Additional points (absences). Two-colum matrix or data.frame; or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="pointValues_+3A_uniquecells">uniquecells</code></td>
<td>
<p>Logical. If <code>TRUE</code>, each cell can be included only once (i.e. 'duplicate' points are removed) </p>
</td></tr>
<tr><td><code id="pointValues_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>TRUE</code>, cell values of NA are not returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="raster.html#topic+extract">extract</a></code></p>

<hr>
<h2 id='predict'>Distribution model predictions</h2><span id='topic+predict'></span><span id='topic+predict+2CBioclim-method'></span><span id='topic+predict+2CDomain-method'></span><span id='topic+predict+2CMahalanobis-method'></span><span id='topic+predict+2CMaxEnt-method'></span><span id='topic+predict+2CMaxEntReplicates-method'></span><span id='topic+predict+2CConvexHull-method'></span><span id='topic+predict+2CCircleHull-method'></span><span id='topic+predict+2CRectangularHull-method'></span><span id='topic+predict+2CCirclesRange-method'></span><span id='topic+predict+2CGeographicDistance-method'></span><span id='topic+predict+2CInvDistWeightModel-method'></span><span id='topic+predict+2CVoronoiHull-method'></span>

<h3>Description</h3>

<p>Make a RasterLayer with a prediction based on a model object of class the inherits from 'DistModel', including: Bioclim, Domain, MaxEnt, Mahalanobis, and GeographicDistance. Predictions with model objects that do not inherit from DistModel can be made using the similar <code><a href="raster.html#topic+predict">predict</a></code> function in the 'raster' package. 
</p>
<p>Provide a Raster* object with the independent variables. The names of the layers in the Raster* object should include those expected by the model. 
</p>


<h3>Value</h3>

<p>A RasterLayer or, (if <code>x</code> is a matrix), a vector. 
</p>


<h3>Methods</h3>


<p><code>predict(object, x, ext=NULL, filename='', progress='text', ...)</code>
</p>

<table>
<tr>
 <td style="text-align: right;">  
  </td><td style="text-align: left;">  <code>object</code>  </td><td style="text-align: left;"> A fitted model of class Bioclim, Domain, MaxEnt, ConvexHull, or Mahalanobis (classes that inherit from DistModel)</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;">  <code>x</code> </td><td style="text-align: left;"> A Raster* object or a data.frame</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;">  <code>ext</code> </td><td style="text-align: left;"> An extent object to limit the prediction to a sub-region of 'x'. Or an object that can be coerced to an Extent object by extent; such as a Raster* or Spatial* object </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;">  <code>filename</code>  </td><td style="text-align: left;"> Output filename for a new raster; if NA the result is not written to a file but returned with the RasterLayer object, in the data slot </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>progress</code> </td><td style="text-align: left;"> Character. Valid values are "" (no progress bar), "text" and "windows" (on that platform only) </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;">  <code>...</code>  </td><td style="text-align: left;"> Additional model specific arguments. And additional arguments for file writing as for writeRaster </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>For <a href="#topic+maxent">maxent</a> models, there is an additional argument <code>'args'</code> used to pass arguments (options) to the maxent software. See the help page for <code> <a href="#topic+maxent">maxent</a></code> for more information.
</p>
<p>For <a href="#topic+bioclim">bioclim</a> models, there is an additional argument <code>'tails'</code> which you can use to ignore the left or right tail of the percentile distribution for a variable. If supplied, tails should be a character vector with a length equal to the number of variables used in the model. Valid values are &quot;both&quot; (the default), &quot;low&quot; and &quot;high&quot;. For example, if you have a variable x with an observed distribution between 10 and 20 and you are predicting the bioclim value for a value 25, the default result would be zero (outside of all observed values); but if you use tail='low', the high (right) tail is ignored and the value returned will be 1.
</p>
<p>For <a href="#topic+geoDist">geoDist</a> models, there is an additional argument <code>fun</code> that allows you to use your own (inverse) distance function, and argument <code>scale=1</code> that allows you to scale the values (distances smaller than this value become one, and the others are divided by this value before computing the inverse distance).
</p>


<h3>Author(s)</h3>

<p> Robert J. Hijmans</p>


<h3>See Also</h3>

<p>For spatial predictions with GLM, GAM, BRT, randomForest, etc., see <a href="raster.html#topic+predict">predict</a> in the Raster package.
</p>
<p>To fit a model that can be used with this predict method, see <code> <a href="#topic+maxent">maxent</a>, <a href="#topic+bioclim">bioclim</a>, <a href="#topic+mahal">mahal</a>, <a href="#topic+domain">domain</a>, <a href="#topic+geoDist">geoDist</a>, <a href="#topic+convHull">convHull</a></code>
</p>
<p>Extent object: <code><a href="raster.html#topic+extent">extent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logo &lt;- stack(system.file("external/rlogo.grd", package="raster"))
pts &lt;- matrix(c(48, 48, 48, 53, 50, 46, 54, 70, 84, 85, 74, 84, 95, 85, 66, 
   42, 26, 4, 19, 17, 7, 14, 26, 29, 39, 45, 51, 56, 46, 38, 31, 22, 34, 60,
   70, 73, 63, 46, 43, 28), ncol=2)
b &lt;- bioclim(logo, pts)
# prediction for a sub-region
e &lt;- extent(30,90,20,60)
p &lt;- predict(b, logo, progress='text', ext=e)
plot(p)
</code></pre>

<hr>
<h2 id='prepareData'>
Prepare data for model fitting
</h2><span id='topic+prepareData'></span>

<h3>Description</h3>

<p>Simple helper function to prepare data for model fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareData(x, p, b, factors, xy=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareData_+3A_x">x</code></td>
<td>
<p>Raster* object</p>
</td></tr>
<tr><td><code id="prepareData_+3A_p">p</code></td>
<td>
<p>presence points</p>
</td></tr>
<tr><td><code id="prepareData_+3A_b">b</code></td>
<td>
<p>background (or absence) points</p>
</td></tr>
<tr><td><code id="prepareData_+3A_factors">factors</code></td>
<td>
<p>vectors indicating which variables are factors (using layer names or numbers)</p>
</td></tr>
<tr><td><code id="prepareData_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code>, the first two columns of the returned data.frame will be the coordinates of p and b (labeled 'x' and 'y')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with <code>nlayers(x)+1</code> columns and <code>nrow(p) + nrow(b)</code> rows. The first column, 'pb' indicates whether a record represents presence '1' or background '0' values. The other columns have the values from the Raster* object.
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>

<hr>
<h2 id='pwdSample'>Pair-wise distance sampling</h2><span id='topic+pwdSample'></span>

<h3>Description</h3>

<p>Select pairs of points from two sets (without replacement) that have a similar distance to their nearest point in another set of points. 
</p>
<p>For each point in &quot;<code>fixed</code>&quot;, a point is selected from &quot;<code>sample</code>&quot; that has a similar distance (as defined by <code>threshold</code>) to its nearest point in &quot;<code>reference</code>&quot; (note that these are likely to be different points in <code>reference</code>). The select point is either the nearest point <code>nearest=TRUE</code>, or a randomly select point <code>nearest=FALSE</code> that is within the threshold distance. If no point within the threshold distance is found in <code>sample</code>, the point in <code>fixed</code> is dropped.
</p>
<p>Hijmans (2012) proposed this sampling approach to remove 'spatial sorting bias' (<code><a href="#topic+ssb">ssb</a></code>) from evaluation data used in cross-validation of presence-only species distribution models. In that context, <code>fixed</code> are the testing-presence points, <code>sample</code> the testing-absence (or testing-background) points, and <code>reference</code> the training-presence points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwdSample(fixed, sample, reference, tr=0.33, nearest=TRUE, n=1, lonlat=TRUE, warn=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwdSample_+3A_fixed">fixed</code></td>
<td>
<p>two column matrix (x, y) or (longitude/latitude) or SpatialPoints object, for point locations for which a pair should be found in <code>sample</code> </p>
</td></tr>
<tr><td><code id="pwdSample_+3A_sample">sample</code></td>
<td>
<p>as above for point locations from which to sample to make a pair with a point from <code>fixed</code></p>
</td></tr>
<tr><td><code id="pwdSample_+3A_reference">reference</code></td>
<td>
<p>as above for reference point locations to which distances are computed</p>
</td></tr>
<tr><td><code id="pwdSample_+3A_n">n</code></td>
<td>
<p>How many pairs do you want for each point in <code>fixed</code></p>
</td></tr>
<tr><td><code id="pwdSample_+3A_tr">tr</code></td>
<td>
<p>Numeric, normally below 1. The threshold distance for a pair of points (one of <code>fixed</code> and one of <code>sample</code>) to their respective nearest points in <code>reference</code> to be considered a valid pair. The absolute difference in distance between the candidate point pairs in <code>fixed</code> and <code>reference</code> (dfr) and the distance between candidate point pairs in <code>sample</code> and <code>reference</code> (dsr) must be smaller than <code>tr</code> * dfr. I.e. if the dfr = 100 km, and tr = 0.1, dsr must be between &gt;90 and &lt;110 km to be considered a valid pair.</p>
</td></tr>
<tr><td><code id="pwdSample_+3A_nearest">nearest</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the pair with the smallest difference in distance to their nearest <code>reference</code> point is selected. If <code>FALSE</code>, a random point from the valid pairs (with a difference in distance below the threshold defined by <code>tr</code>) is selected (generally leading to higher <code><a href="#topic+ssb">ssb</a>)</code></p>
</td></tr>
<tr><td><code id="pwdSample_+3A_lonlat">lonlat</code></td>
<td>
<p> Logical. Use <code>TRUE</code> if the coordinates are spherical (in degrees), and use <code>FALSE</code> if they are planar </p>
</td></tr>
<tr><td><code id="pwdSample_+3A_warn">warn</code></td>
<td>
<p> Logical. If <code>TRUE</code> a warning is given if <code>nrow(fixed) &lt; nrow(sample)</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of nrow(fixed) and ncol(n), that indicates, for each point (row) in <code>fixed</code> which point(s) in <code>sample</code> it is paired to; or <code>NA</code> if no suitable pair was available.
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>References</h3>

<p>Hijmans, R.J., 2012. Cross-validation of species distribution models: removing spatial sorting bias and calibration with a null-model. Ecology 93: 679-688
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gridSample">gridSample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ref &lt;- matrix(c(-54.5,-38.5, 2.5, -9.5, -45.5, 1.5, 9.5, 4.5, -10.5, -10.5), ncol=2)
fix &lt;- matrix(c(-56.5, -30.5, -6.5, 14.5, -25.5, -48.5, 14.5, -2.5, 14.5,
               -11.5, -17.5, -11.5), ncol=2)
r &lt;- raster()
extent(r) &lt;- c(-110, 110, -45, 45)
r[] &lt;- 1
set.seed(0)
sam &lt;- randomPoints(r, n=50)

par(mfrow=c(1,2))
plot(sam, pch='x')
points(ref, col='red', pch=18, cex=2)
points(fix, col='blue', pch=20, cex=2)

i &lt;- pwdSample(fix, sam, ref, lonlat=TRUE)
i
sfix &lt;- fix[!is.na(i), ]
ssam &lt;- sam[i[!is.na(i)], ]
ssam

plot(sam, pch='x', cex=0)
points(ssam, pch='x')
points(ref, col='red', pch=18, cex=2)
points(sfix, col='blue', pch=20, cex=2)

# try to get 3 pairs for each point in 'fixed'
pwdSample(fix, sam, ref, lonlat=TRUE, n=3)
</code></pre>

<hr>
<h2 id='Random+20null+20model'>Random null model</h2><span id='topic+nullRandom'></span>

<h3>Description</h3>

<p>Null model based on randomization of locations as suggested by Raes and ter Steege (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullRandom(x, model, n=25, rep=25, pa=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Random+2B20null+2B20model_+3A_x">x</code></td>
<td>
<p>data.frame with environmental predictor values for collecting localities </p>
</td></tr> 
<tr><td><code id="Random+2B20null+2B20model_+3A_model">model</code></td>
<td>
<p>Model function that creates a model of class 'DistModel' </p>
</td></tr>
<tr><td><code id="Random+2B20null+2B20model_+3A_n">n</code></td>
<td>
<p>Sample size </p>
</td></tr>
<tr><td><code id="Random+2B20null+2B20model_+3A_rep">rep</code></td>
<td>
<p>Number of repetitions </p>
</td></tr>
<tr><td><code id="Random+2B20null+2B20model_+3A_pa">pa</code></td>
<td>
<p> Boolean. Prensence-only or presence/background model (e.g. Maxent) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with <code>n</code> object of class <code><a href="#topic+ModelEvaluation-class">ModelEvaluation-class</a></code>
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>References</h3>

<p>Raes, N. &amp; H. ter Steege, 2007. A null-model for significance testing of presence-only species distribution models. Ecography 30:727-736.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoDist">geoDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predictors &lt;- stack(list.files(path=paste(system.file(package="dismo"), '/ex', sep=''), 
               pattern='grd', full.names=TRUE ))
occurence &lt;- paste(system.file(package="dismo"), '/ex/bradypus.csv', sep='')
occ &lt;- read.table(occurence, header=TRUE, sep=',')[,-1]
 
x &lt;- extract(predictors, occ)
nr &lt;- nullRandom(x, bioclim, n=25, rep=25, pa=FALSE)
mean(sapply(nr, function(x)x@auc))
</code></pre>

<hr>
<h2 id='randomPoints'>
Random points
</h2><span id='topic+randomPoints'></span>

<h3>Description</h3>

<p>Generate random points that can be used to extract background values (&quot;random-absence&quot;). The points are sampled (without replacement) from the cells that are not '<code>NA</code>' in raster '<code>mask</code>'. 
</p>
<p>If the coordinate reference system (of <code>mask</code>) is longitude/latitude, sampling is weighted by the size of the cells. That is, because cells close to the equator are larger than cells closer to the poles, equatorial cells have a higher probability of being selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomPoints(mask, n, p, ext=NULL, extf=1.1, excludep=TRUE, prob=FALSE, 
             cellnumbers=FALSE, tryf=3, warn=2, lonlatCorrection=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomPoints_+3A_mask">mask</code></td>
<td>
<p>Raster* object. If the object has cell values, cells with <code>NA</code> are excluded (of the first layer of the object if there are multiple layers)</p>
</td></tr>
<tr><td><code id="randomPoints_+3A_n">n</code></td>
<td>
<p>integer. Number of points</p>
</td></tr>
<tr><td><code id="randomPoints_+3A_p">p</code></td>
<td>
<p>Presence points (if provided, random points won't be in the same cells (as defined by mask)</p>
</td></tr>
<tr><td><code id="randomPoints_+3A_ext">ext</code></td>
<td>
<p>Extent object. Can be used to restrict sampling to a spatial extent</p>
</td></tr>
<tr><td><code id="randomPoints_+3A_extf">extf</code></td>
<td>
<p>numeric. Multiplyer to adjust the size of extent 'ext'. The default increases of 1.1 increases the extent a little (5% at each side of the extent)</p>
</td></tr>
<tr><td><code id="randomPoints_+3A_excludep">excludep</code></td>
<td>
<p>logical. If <code>TRUE</code>, presence points are exluded from background</p>
</td></tr>
<tr><td><code id="randomPoints_+3A_prob">prob</code></td>
<td>
<p>logical. If <code>TRUE</code> the values in <code>mask</code> are interpreted as probability weights (and the values should be positive numbers (or NA)). NOTE:  this currently only works for rasters of a relatively modest size (that can be loaded into RAM)</p>
</td></tr>
<tr><td><code id="randomPoints_+3A_cellnumbers">cellnumbers</code></td>
<td>
<p>logical. If <code>TRUE</code>, cell numbers for <code>mask</code> are returned rather than coordinates </p>
</td></tr>
<tr><td><code id="randomPoints_+3A_tryf">tryf</code></td>
<td>
<p>numeric &gt; 1. Multiplyer used for initial sample size from which the requested sample size is extracted after removing NA points (outside of mask) </p>
</td></tr>
<tr><td><code id="randomPoints_+3A_warn">warn</code></td>
<td>
<p>integer. 2 or higher gives most warnings. 0 or lower gives no warnings if sample size <code>n</code> is not reached </p>
</td></tr>
<tr><td><code id="randomPoints_+3A_lonlatcorrection">lonlatCorrection</code></td>
<td>
<p>logical. If <code>TRUE</code> then correct for the fact that longitude/latitude is not a planar coordinate system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with coordinates, or, if <code>cellnumbers=TRUE</code>, a vector with cell numbers.
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>

<hr>
<h2 id='rectHull'>Rectangular hull model</h2><span id='topic+rectHull'></span><span id='topic+rectHull+2CSpatialPoints-method'></span><span id='topic+rectHull+2Cmatrix-method'></span><span id='topic+rectHull+2Cdata.frame-method'></span><span id='topic+RectangularHull-class'></span>

<h3>Description</h3>

<p>The Rectangular Hull model predicts that a species is present at sites inside the minimum (rotated) bounding rectangle of a set of training points, and absent outside that rectangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectHull(p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectHull_+3A_p">p</code></td>
<td>
<p>point locations (presence). Two column matrix, data.frame or SpatialPoints* object</p>
</td></tr>
<tr><td><code id="rectHull_+3A_...">...</code></td>
<td>
<p> Additional arguments. See details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can supply an argument n (&gt;= 1) to get n hulls around subset of the points. This uses k-means to form clusters. To reproduce the clusters you may need to use <code>set.seed</code>.  
</p>


<h3>Value</h3>

<p>An object of class 'RectangularHull' (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans. Using an algorithm by whuber and Bangyou on gis.stackexchange.com
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict">predict</a>, <a href="#topic+circleHull">circleHull</a>, <a href="#topic+convHull">convHull</a>, <a href="#topic+maxent">maxent</a>, <a href="#topic+domain">domain</a>, <a href="#topic+mahal">mahal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/rlogo.grd", package="raster"))
# presence data
pts &lt;- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66, 
 74, 50, 48, 28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)
train &lt;- pts[1:12, ]
test &lt;- pts[13:20, ]
				 
rh &lt;- rectHull(train)
predict(rh, test)

plot(r)
plot(rh, border='red', lwd=2, add=TRUE)
points(train, col='red', pch=20, cex=2)
points(test, col='black', pch=20, cex=2)

pr &lt;- predict(rh, r, progress='')
plot(pr)
points(test, col='black', pch=20, cex=2)
points(train, col='red', pch=20, cex=2)
</code></pre>

<hr>
<h2 id='response'>response plots</h2><span id='topic+response'></span><span id='topic+response+2CDistModel-method'></span><span id='topic+response+2CMaxEntReplicates-method'></span><span id='topic+response+2CANY-method'></span>

<h3>Description</h3>

<p>Generate 'response plots', i.e. single variable response curves for a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_+3A_x">x</code></td>
<td>
<p> Model object that inherits from 'DistModel', e.g. 'MaxEnt'. Also works for some other models (e.g. GLM) </p>
</td></tr>
<tr><td><code id="response_+3A_...">...</code></td>
<td>
<p> Additional arguments. See Details </p>
</td></tr>  
</table>


<h3>Details</h3>

  

<table>
<tr>
 <td style="text-align: right;">  
</td><td style="text-align: left;"> <code>var</code> </td><td style="text-align: left;"> Variable to be plotted (if NULL, all variables will be plotted) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>at</code>  </td><td style="text-align: left;"> Function to indicate at what level the other variables should be. E.g. median (the default), mean, min, max. Note that currently the function fails when 'mean' is used and one of the variables is a factor. Instead of a function you can also supply a single-row matrix with values for each of the variables. If NULL, partial response plots as are computed (this can take a lot of time). Partial response plots show, for each variable, the average prediction for all data points that were used to fit the model (or other data, if supplied), for 10 regularly spaced values of the variable. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>range</code> </td><td style="text-align: left;"> 'pa' (default) or 'p'. Show responses for the range of the presence data (p) or presence and absence (background) data (pa) for models that use absence data.</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>expand</code> </td><td style="text-align: left;">  percentage to expand the range of values with. Default is 10 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>rug</code> </td><td style="text-align: left;"> Logical. If <code>TRUE</code> (the default) a 'rug' of deciles is plotted on the horizontal axes) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>data</code> </td><td style="text-align: left;"> data.frame with data to use, normally this is the data used to fit the model and does not needs to be supplied as they are available from the model object</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>fun</code> </td><td style="text-align: left;">  predict function. The default is "predict"; but you may change this to e.g., function(x, y, ...) predict(x, y, type='response', ...).</td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> <code>...</code>  </td><td style="text-align: left;"> Additional graphical parameters  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Used for the side-effect of a plot
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density">density</a>, <a href="#topic+plot">plot</a>, <a href="#topic+pairs">pairs</a></code>
</p>

<hr>
<h2 id='ssb'>Spatial sorting bias</h2><span id='topic+ssb'></span>

<h3>Description</h3>

<p>Determine &quot;spatial sorting bias&quot;, or the difference between two point data sets in the average distance to the nearest point in a reference dataset. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssb(p, a, reference, lonlat=TRUE, avg=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssb_+3A_p">p</code></td>
<td>
<p>two column matrix (x, y) or (longitude/latitude) or SpatialPoints object, for point locations</p>
</td></tr>
<tr><td><code id="ssb_+3A_a">a</code></td>
<td>
<p>two column matrix (x, y) or (longitude/latitude) or SpatialPoints object, for point locations</p>
</td></tr>
<tr><td><code id="ssb_+3A_reference">reference</code></td>
<td>
<p>as above for reference point locations to which distances are computed</p>
</td></tr>
<tr><td><code id="ssb_+3A_lonlat">lonlat</code></td>
<td>
<p> Logical. Use <code>TRUE</code> if the coordinates are spherical (in degrees), and use <code>FALSE</code> if they are planar </p>
</td></tr>
<tr><td><code id="ssb_+3A_avg">avg</code></td>
<td>
<p> Logical. If <code>TRUE</code> the distances are averaged </p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with two values. 'dp': the average distance from a point in <code>p</code> to the nearest point in <code>reference</code> and 'da': the average distance from a point in <code>a</code> to the nearest point in <code>reference</code>.
Distance is in meters if <code>lonlat=TRUE</code>, and in mapunits (typically also meters) if <code>lonlat=FALSE</code>
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>References</h3>

<p>Hijmans, R.J., 2012. Cross-validation of species distribution models: removing spatial sorting bias and calibration with a null-model. Ecology 93: 679-688. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pwdSample">pwdSample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ref &lt;- matrix(c(-54.5,-38.5, 2.5, -9.5, -45.5, 1.5, 9.5, 4.5, -10.5, -10.5), ncol=2)
p &lt;- matrix(c(-56.5, -30.5, -6.5, 14.5, -25.5, -48.5, 14.5, -2.5, 14.5, 
        -11.5, -17.5, -11.5), ncol=2)
r &lt;- raster()
extent(r) &lt;- c(-110, 110, -45, 45)
r[] &lt;- 1
set.seed(0)
a &lt;- randomPoints(r, n=50)
b &lt;- ssb(p, a, ref)

# distances in km
b / 1000

# an index of spatial sorting bias (1 is no bias, near 0 is extreme bias)
b[1] / b[2]
</code></pre>

<hr>
<h2 id='threshold'> Find a threshold </h2><span id='topic+threshold'></span><span id='topic+threshold+2CModelEvaluation-method'></span>

<h3>Description</h3>

 
<p>Find a threshold (cut-off) to transform model predictions (probabilities, distances, or similar values) to a binary score (presence or absence). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ModelEvaluation'
threshold(x, stat='', sensitivity=0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_x">x</code></td>
<td>
<p>A ModelEvaluation object (see <code><a href="#topic+evaluate">evaluate</a></code></p>
</td></tr>
<tr><td><code id="threshold_+3A_stat">stat</code></td>
<td>
<p>character. To select a particular threshold (see section 'value' for possible values)</p>
</td></tr> 
<tr><td><code id="threshold_+3A_sensitivity">sensitivity</code></td>
<td>
<p>numeric between 0 and 1. For the fixed sensitivity threshold</p>
</td></tr>
<tr><td><code id="threshold_+3A_...">...</code></td>
<td>
<p>Additional arguments. None implemented</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>data.frame with the following columns:
</p>
<p>kappa: the threshold at which kappa is highest (&quot;max kappa&quot;)
</p>
<p>spec_sens: the threshold at which the sum of the sensitivity (true positive rate) and specificity (true negative rate) is highest
</p>
<p>no_omission: the highest threshold at which there is no omission 
</p>
<p>prevalence: modeled prevalence is closest to observed prevalence
</p>
<p>equal_sens_spec: equal sensitivity and specificity
</p>
<p>sensitivty: fixed (specified) sensitivity
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans and Diego Nieto-Lugilde
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## See ?maxent for an example with real data.
# this is a contrived example:
# p has the predicted values for 50 known cases (locations)
# with presence of the phenomenon (species)
p &lt;- rnorm(50, mean=0.7, sd=0.3)
# b has the predicted values for 50 background locations (or absence)
a &lt;- rnorm(50, mean=0.4, sd=0.4)
e &lt;- evaluate(p=p, a=a)

threshold(e)
</code></pre>

<hr>
<h2 id='voronoi'>
Voronoi polygons
</h2><span id='topic+voronoi'></span><span id='topic+voronoi+2CANY-method'></span>

<h3>Description</h3>

<p>Create Voronoi polygons for a set of points. (These are also known Thiessen polygons, and Nearest Neighbor polygons; and the technique used is referred to as Delauny triangulation.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
voronoi(x, ext, eps=1e-09, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoi_+3A_x">x</code></td>
<td>
<p>SpatialPoints* or two column matrix with x and y coordinates</p>
</td></tr>
<tr><td><code id="voronoi_+3A_ext">ext</code></td>
<td>
<p>Extent. Can be used to set the corners of the rectangular window enclosing the triangulation. The default is the data range plus 10 percent. See <code><a href="deldir.html#topic+deldir">deldir</a></code></p>
</td></tr>
<tr><td><code id="voronoi_+3A_eps">eps</code></td>
<td>
<p>Numerical tolerance used in triangulation. See <code><a href="deldir.html#topic+deldir">deldir</a></code></p>
</td></tr>
<tr><td><code id="voronoi_+3A_...">...</code></td>
<td>
<p>Additional arguments (none)</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>SpatialPolygonsDataFrame
</p>


<h3>Author(s)</h3>

<p>This method is based on the <code>link[deldir]{deldir}</code> function by Rolf Turner and code by Carson Farmer
</p>


<h3>Examples</h3>

<pre><code class='language-R'># points
p &lt;- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66, 74, 50, 48, 
      28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)
	  
v &lt;- voronoi(p)
v
</code></pre>

<hr>
<h2 id='Voronoi+20Hull'>Voronoi hull model</h2><span id='topic+voronoiHull'></span><span id='topic+voronoiHull+2CSpatialPoints+2CSpatialPoints-method'></span><span id='topic+voronoiHull+2Cmatrix+2Cmatrix-method'></span><span id='topic+voronoiHull+2Cdata.frame+2Cdata.frame-method'></span><span id='topic+VoronoiHull-class'></span>

<h3>Description</h3>

<p>Voronoi polygons for presence/absence data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,matrix'
voronoiHull(p, a, ext=NULL, dissolve=FALSE, crs=NA, ...)
## S4 method for signature 'data.frame,data.frame'
voronoiHull(p, a, ext=NULL, dissolve=FALSE, crs=NA, ...)
## S4 method for signature 'SpatialPoints,SpatialPoints'
voronoiHull(p, a, ext=NULL, dissolve=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Voronoi+2B20Hull_+3A_p">p</code></td>
<td>
<p>Presence points. Two column <code>matrix</code>, <code>data.frame</code>, or a <code>SpatialPoints*</code> object</p>
</td></tr>
<tr><td><code id="Voronoi+2B20Hull_+3A_a">a</code></td>
<td>
<p>Absence points. Must be of the same class as <code>p</code></p>
</td></tr>
<tr><td><code id="Voronoi+2B20Hull_+3A_ext">ext</code></td>
<td>
<p>Extent to limit or expand the area of interest</p>
</td></tr>
<tr><td><code id="Voronoi+2B20Hull_+3A_dissolve">dissolve</code></td>
<td>
<p>Boolean. Dissolve (aggregate) polygons?</p>
</td></tr>
<tr><td><code id="Voronoi+2B20Hull_+3A_crs">crs</code></td>
<td>
<p>character or CRS object. PROJ.4 notation coordinate reference system</p>
</td></tr> 
<tr><td><code id="Voronoi+2B20Hull_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+voronoi">voronoi</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A VoronoiHull object (inherits from <code><a href="#topic+DistModel-class">DistModel-class</a></code>)
</p>


<h3>Note</h3>

<p>This function is only correct when using a planar coordinate reference system (not longitude/latitude).
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convHull">convHull</a></code>, <code><a href="#topic+voronoi">voronoi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- raster(system.file("external/rlogo.grd", package="raster"))
# presence points
p &lt;- matrix(c(17, 42, 85, 70, 19, 53, 26, 84, 84, 46, 48, 85, 4, 95, 48, 54, 66, 74, 50, 48, 
      28, 73, 38, 56, 43, 29, 63, 22, 46, 45, 7, 60, 46, 34, 14, 51, 70, 31, 39, 26), ncol=2)

# absence points
a &lt;- matrix(c(30, 23, 5, 5, 31, 33, 91, 63, 60, 88, 93, 97, 65, 68, 85, 97, 35, 32, 29, 55,
      3, 8, 19, 71, 49, 36, 69, 41, 20, 28, 18, 9, 5, 9, 25, 71, 8, 32, 46, 60), ncol=2)

v &lt;- voronoiHull(p, a)
	  
x &lt;- predict(r, v)

## Not run: 
plot(x)
points(p, col='black', pch=20, cex=2)
points(a, col='red', pch=20, cex=2)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
