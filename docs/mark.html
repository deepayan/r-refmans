<!DOCTYPE html><html><head><title>Help for package mark</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mark}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_file_timestamp'><p>Add file timestamp</p></a></li>
<li><a href='#are_identical'><p>Identical extensions</p></a></li>
<li><a href='#array_extract'><p>Array extract</p></a></li>
<li><a href='#as_ordered'><p>Ordered</p></a></li>
<li><a href='#base_alpha'><p>Alpha base</p></a></li>
<li><a href='#base_n'><p>Base N conversion</p></a></li>
<li><a href='#between_more'><p>Between more</p></a></li>
<li><a href='#blank_values'><p>Blank values</p></a></li>
<li><a href='#char2fact'><p>Character to factor</p></a></li>
<li><a href='#checkOptions'><p>Check options</p></a></li>
<li><a href='#chr_split'><p>Character split</p></a></li>
<li><a href='#clipboard'><p>Write to and read from the clipboard</p></a></li>
<li><a href='#complete_cases'><p>Complete cases</p></a></li>
<li><a href='#counts'><p>Count observations by unique values</p></a></li>
<li><a href='#date_from_partial'><p>Partial dates</p></a></li>
<li><a href='#depth'><p>Depth</p></a></li>
<li><a href='#detail'><p>Details an object</p></a></li>
<li><a href='#diff_time'><p>Diff time wrappers</p></a></li>
<li><a href='#drop_levels'><p>Drop levels</p></a></li>
<li><a href='#echo'><p>echo</p></a></li>
<li><a href='#ept'><p>Parse and evaluate text</p></a></li>
<li><a href='#eval_named_chunk'><p>Evaluate a  Named Chunk</p></a></li>
<li><a href='#expand_by'><p>Expands a vector</p></a></li>
<li><a href='#fact'><p>Factor</p></a></li>
<li><a href='#fact_na'><p><code>fact</code> with <code>NA</code></p></a></li>
<li><a href='#fact_reverse'><p>Fact reverse levels</p></a></li>
<li><a href='#fact2char'><p>Factor to character</p></a></li>
<li><a href='#fct_expand_seq'><p>Factor Expand by Sequence</p></a></li>
<li><a href='#file_info'><p>File information utils</p></a></li>
<li><a href='#file_name'><p>File name</p></a></li>
<li><a href='#file_utils'><p>Open a file using windows file associations</p></a></li>
<li><a href='#fizzbuzz'><p>Fizz Buzz</p></a></li>
<li><a href='#get_dir_max_number'><p>Get recent directory by number name</p></a></li>
<li><a href='#get_dir_recent_date'><p>Get recent directory by date</p></a></li>
<li><a href='#get_recent_dir'><p>Get recent directory</p></a></li>
<li><a href='#get_recent_file'><p>Get recent file</p></a></li>
<li><a href='#get_version'><p>Get and bump version</p></a></li>
<li><a href='#glob'><p>Wildcard globbing</p></a></li>
<li><a href='#handlers'><p>Handlers</p></a></li>
<li><a href='#import'><p>Import</p></a></li>
<li><a href='#insert'><p>Insert</p></a></li>
<li><a href='#is_dir'><p>Is File/Directory</p></a></li>
<li><a href='#labels'><p>Dataframe labels</p></a></li>
<li><a href='#limit'><p>Limit</p></a></li>
<li><a href='#lines_of_r_code'><p>Lines of R code</p></a></li>
<li><a href='#list_environments'><p>List all environments and objects</p></a></li>
<li><a href='#list2df'><p>List to data.frame</p></a></li>
<li><a href='#logic_ext'><p>Logic - Extension'</p></a></li>
<li><a href='#ls_ext'><p>List Objects - extensions</p></a></li>
<li><a href='#make_sf'><p>Make system file function</p></a></li>
<li><a href='#mark'><p>mark</p></a></li>
<li><a href='#match_arg'><p>Match arguments</p></a></li>
<li><a href='#match_param'><p>Match params</p></a></li>
<li><a href='#median2'><p>Median (Q 50)</p></a></li>
<li><a href='#merge_list'><p>Merge lists</p></a></li>
<li><a href='#multi_grepl'><p>Multiple searching</p></a></li>
<li><a href='#na_assignments'><p>NA at positions</p></a></li>
<li><a href='#na_cols'><p>Selecting NA columns</p></a></li>
<li><a href='#norm_path'><p>Normalize paths</p></a></li>
<li><a href='#normalize'><p>Normalize values</p></a></li>
<li><a href='#not_available'><p>Make not available</p></a></li>
<li><a href='#note'><p>Append a note to an object</p></a></li>
<li><a href='#omit_na'><p>Omit NA values</p></a></li>
<li><a href='#package_available'><p>Check if package is available</p></a></li>
<li><a href='#percentile_rank'><p>Percentile rank</p></a></li>
<li><a href='#print_c'><p>Print as c</p></a></li>
<li><a href='#print.mark_bib_df'><p>Print bib data frame</p></a></li>
<li><a href='#print.pseudo_id'><p>Print <code>pseudo_id</code></p></a></li>
<li><a href='#process_bib_dataframe'><p>Process bib values</p></a></li>
<li><a href='#pseudo_id'><p>Create an ID for a vector</p></a></li>
<li><a href='#quiet_stop'><p>Quiet stop</p></a></li>
<li><a href='#range2'><p>Range 2</p></a></li>
<li><a href='#read_bib'><p>Read Bib file</p></a></li>
<li><a href='#recode_by'><p>Recode by</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reindex'><p>Reindex a data.frame</p></a></li>
<li><a href='#remove_na'><p>Remove NA</p></a></li>
<li><a href='#remove_null'><p>Remove NULL</p></a></li>
<li><a href='#round_by'><p>Rounding by a specific interval.</p></a></li>
<li><a href='#row_bind'><p>Row bind</p></a></li>
<li><a href='#rscript'><p>Rscript</p></a></li>
<li><a href='#save_source'><p>Save source</p></a></li>
<li><a href='#set_names0'><p>Set names</p></a></li>
<li><a href='#simpleTimeReport'><p>Time reports</p></a></li>
<li><a href='#sort_by'><p>Sort by</p></a></li>
<li><a href='#sort_names'><p>Sort by names</p></a></li>
<li><a href='#source_files'><p>Source file from directory</p></a></li>
<li><a href='#source_to_env'><p>Source to environment</p></a></li>
<li><a href='#sourcing'><p>Sourcing extensions</p></a></li>
<li><a href='#str_extract_date'><p>Extract date from string</p></a></li>
<li><a href='#str_slice'><p>String Slice</p></a></li>
<li><a href='#switch-ext'><p>Switch with a list of parameters</p></a></li>
<li><a href='#t_df'><p>Data frame transpose</p></a></li>
<li><a href='#tableNA'><p>Table NA values</p></a></li>
<li><a href='#that'><p>That</p></a></li>
<li><a href='#to_boolean'><p>To Boolean</p></a></li>
<li><a href='#to_row_names'><p>To row names</p></a></li>
<li><a href='#todos'><p>Get TODOs</p></a></li>
<li><a href='#unlist0'><p>Unlist and squash</p></a></li>
<li><a href='#use_author'><p>Add author to DESCRIPTION</p></a></li>
<li><a href='#utils-paste'><p>Paste combine</p></a></li>
<li><a href='#vap'><p>Vaps!</p></a></li>
<li><a href='#vector2df'><p>Vector to data.frame</p></a></li>
<li><a href='#with_par'><p>Temporary plotting</p></a></li>
<li><a href='#within_call'><p>Function within</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous, Analytic R Kernels</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jordan Mark Barbone &lt;jmbarbone@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Miscellaneous functions and wrappers for development in other 
    packages created, maintained by Jordan Mark Barbone.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmbarbone/mark">https://github.com/jmbarbone/mark</a>,
<a href="https://jmbarbone.github.io/mark/">https://jmbarbone.github.io/mark/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jmbarbone/mark/issues">https://github.com/jmbarbone/mark/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, fs (&ge; 1.6.2), fuj (&ge; 0.1.4), magrittr (&ge; 2.0.1),
rlang, stats (&ge; 3.6), tools (&ge; 3.6), utils (&ge; 3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench (&ge; 1.1.1), bib2df (&ge; 1.1.1), crayon (&ge; 1.3.4), covr
(&ge; 3.5.1), desc (&ge; 1.3.0), dplyr (&ge; 1.0.6), graphics (&ge;
3.6), haven, knitr (&ge; 1.30), rcmdcheck (&ge; 1.3.3), stringi (&ge;
1.5.3), spelling (&ge; 2.2), testthat (&ge; 3.0.0), tibble (&ge;
3.0.4), waldo (&ge; 0.2.5), withr (&ge; 2.3.0), xopen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-23 01:23:36 UTC; jordan</td>
</tr>
<tr>
<td>Author:</td>
<td>Jordan Mark Barbone [aut, cph, cre] (0000-0001-9788-3628)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-23 04:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_file_timestamp'>Add file timestamp</h2><span id='topic+add_file_timestamp'></span>

<h3>Description</h3>

<p>Adds a timestamp to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_file_timestamp(
  x,
  ts = Sys.time(),
  format = "%Y-%m-%d %H%M%S",
  sep = " "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_file_timestamp_+3A_x">x</code></td>
<td>
<p>A vector of files</p>
</td></tr>
<tr><td><code id="add_file_timestamp_+3A_ts">ts</code></td>
<td>
<p>A single timestamp or vector of timestamps (default: <code>Sys.time()</code>)</p>
</td></tr>
<tr><td><code id="add_file_timestamp_+3A_format">format</code></td>
<td>
<p>A format to be applied to the times; set to <code>NULL</code> to skip
formatting</p>
</td></tr>
<tr><td><code id="add_file_timestamp_+3A_sep">sep</code></td>
<td>
<p>A <code>character</code> vector of length 1 to separate the timestamp from
the file name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full name paths with the appended time stamp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file1 &lt;- tempfile(fileext = ".txt")
file2 &lt;- tempfile()

add_file_timestamp(file1)
add_file_timestamp(file2)

file.remove(file1, file2)
</code></pre>

<hr>
<h2 id='are_identical'>Identical extensions</h2><span id='topic+are_identical'></span>

<h3>Description</h3>

<p>Extensions for the use of <code>base::identical()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_identical(..., params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_identical_+3A_...">...</code></td>
<td>
<p>Vectors of values to compare, element-wise of equal length</p>
</td></tr>
<tr><td><code id="are_identical_+3A_params">params</code></td>
<td>
<p>Additional params (as a named list of arguments for
<a href="base.html#topic+identical">base::identical</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> vector of <code>TRUE</code>/<code>FALSE</code> of equal length of each <code>...</code>
vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- y &lt;- z &lt;- 1:5
y[2] &lt;- 3L
z[5] &lt;- NA_integer_

identical(x, y)        # compare entire vector
are_identical(x, y)    # element-wise
are_identical(x, y, z) # 3 or more vectors
</code></pre>

<hr>
<h2 id='array_extract'>Array extract</h2><span id='topic+array_extract'></span>

<h3>Description</h3>

<p>Extract dimensions from an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_extract(.arr, ..., default = "1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_extract_+3A_.arr">.arr</code></td>
<td>
<p>An array</p>
</td></tr>
<tr><td><code id="array_extract_+3A_...">...</code></td>
<td>
<p>A named list by array dimension number and the value</p>
</td></tr>
<tr><td><code id="array_extract_+3A_default">default</code></td>
<td>
<p>The default dimension index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value from the array <code>arr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(rep(NA, 27), dim = c(3, 3, 3))
x[1, 2, 3] &lt;- TRUE
x[1, 2, 3]
x
array_extract(x, `2` = 2, `3` = 3)
</code></pre>

<hr>
<h2 id='as_ordered'>Ordered</h2><span id='topic+as_ordered'></span><span id='topic+as_ordered.default'></span>

<h3>Description</h3>

<p>As ordered
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_ordered(x)

## Default S3 method:
as_ordered(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_ordered_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple implementation of <code>ordered</code>.  If <code>x</code> is <code>ordered</code> it is
simply returned.  If <code>x</code> is a <code>factor</code> the <code>ordered</code> class is added.
Otherwise, <code>x</code> is made into a <code>factor</code> with <code><a href="#topic+fact">fact()</a></code> and then the
<code>ordered</code> class is added. Unlike just <code>fact</code>, <code>ordered</code> will replace the <code>NA</code>
levels with <code>NA_integer_</code> to work appropriately with other functions.
</p>


<h3>Value</h3>

<p>An <code>ordered</code> vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fact">fact()</a></code>
</p>
<p>Other factors: 
<code><a href="#topic+char2fact">char2fact</a>()</code>,
<code><a href="#topic+drop_levels">drop_levels</a>()</code>,
<code><a href="#topic+fact2char">fact2char</a>()</code>,
<code><a href="#topic+fact_na">fact_na</a>()</code>,
<code><a href="#topic+fact">fact</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a", NA, "b")
x &lt;- fact(x)
str(x) # NA is 3L

y &lt;- x
class(y) &lt;- c("ordered", class(y))
max(y)
max(y, na.rm = TRUE) # returns NA -- bad

# as_ordered() removes the NA level
x &lt;- as_ordered(x)
str(x)
max(x, na.rm = TRUE) # returns b -- correct
</code></pre>

<hr>
<h2 id='base_alpha'>Alpha base</h2><span id='topic+base_alpha'></span>

<h3>Description</h3>

<p>Base 26 conversion with letters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_alpha(x, base = 26)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_alpha_+3A_x">x</code></td>
<td>
<p>A string of letters.  Non characters are removed.</p>
</td></tr>
<tr><td><code id="base_alpha_+3A_base">base</code></td>
<td>
<p>A numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>base_alpha("AB")
base_alpha("XFD")
base_alpha(c("JMB", "Jordan Mark", "XKCD"))
sum(base_alpha(c("x", "k", "c", "d")))
</code></pre>

<hr>
<h2 id='base_n'>Base N conversion</h2><span id='topic+base_n'></span>

<h3>Description</h3>

<p>Convert between base numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_n(x, from = 10, to = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_n_+3A_x">x</code></td>
<td>
<p>A vector of integers</p>
</td></tr>
<tr><td><code id="base_n_+3A_from">from</code>, <code id="base_n_+3A_to">to</code></td>
<td>
<p>An integer base to convert to and from; <code>from</code> must be an
integer from <code>1</code> to <code>10</code> and <code>to</code> can currently only be <code>10</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The A vector of integers converted from base <code>from</code> to base <code>to</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>base_n(c(24, 22, 16), from = 7)
</code></pre>

<hr>
<h2 id='between_more'>Between more</h2><span id='topic+between_more'></span>

<h3>Description</h3>

<p>Additional functionality and expansion of <code>dplyr::between</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>between_more(x, left, right, type = c("gele", "gel", "gle", "gl"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="between_more_+3A_x">x</code></td>
<td>
<p>A numeric vector of values</p>
</td></tr>
<tr><td><code id="between_more_+3A_left">left</code>, <code id="between_more_+3A_right">right</code></td>
<td>
<p>Boundary values</p>
</td></tr>
<tr><td><code id="between_more_+3A_type">type</code></td>
<td>
<p>Abbreviation for the evaluation of <code>left</code> on <code>right</code> (see
details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Type can be one of the below:
</p>

<dl>
<dt>g</dt><dd><p>is greater than (&gt;)</p>
</dd>
<dt>ge</dt><dd><p>greater than or equal to (&gt;=)</p>
</dd>
<dt>l</dt><dd><p>less than (&lt;)</p>
</dd>
<dt>ls</dt><dd><p>less than or equal to (&lt;=)</p>
</dd>
</dl>



<h3>Value</h3>

<p>A logical vector
</p>


<h3>See Also</h3>

<p><code>dplyr::case_when()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>between_more(10, 2, 10, "gl")
between_more(10, 2, 10, "gle")
between_more(1:5, c(3, 3, 2, 2, 1), 5)
</code></pre>

<hr>
<h2 id='blank_values'>Blank values</h2><span id='topic+blank_values'></span><span id='topic+is_blank'></span><span id='topic+select_blank_cols'></span><span id='topic+remove_blank_cols'></span><span id='topic+is_blank_cols'></span>

<h3>Description</h3>

<p>Detect <em>blank</em> values; select, remove columns that are entirely <em>blank</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_blank(x, na_blank = FALSE, ws = TRUE)

select_blank_cols(x, na_blank = FALSE, ws = TRUE)

remove_blank_cols(x, na_blank = FALSE, ws = TRUE)

is_blank_cols(x, names = TRUE, na_blank = FALSE, ws = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blank_values_+3A_x">x</code></td>
<td>
<p>An object, or <code>data.frame</code> for <code style="white-space: pre;">&#8288;*_cols()&#8288;</code> functions</p>
</td></tr>
<tr><td><code id="blank_values_+3A_na_blank">na_blank</code></td>
<td>
<p>Logical, if <code>TRUE</code> treats <code>NA</code> values as <em>blank</em></p>
</td></tr>
<tr><td><code id="blank_values_+3A_ws">ws</code></td>
<td>
<p>Logical, when <code>TRUE</code> treats elements that are entirely <em>whitespace</em>
as blanks</p>
</td></tr>
<tr><td><code id="blank_values_+3A_names">names</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) will return column names as names
of vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Blank</em> values are values that do not contain any text
</p>


<h3>Value</h3>


<ul>
<li> <p><code>is_blank()</code> a <code>logical</code> vector indicating <em>blank</em> elements in <code>x</code>
</p>
</li>
<li> <p><code>select_blank_cols()</code> <code>x</code> with only columns that are all <em>blank</em>
</p>
</li>
<li> <p><code>remove_blank_cols()</code> <code>x</code> without columns of only <em>blank</em>
</p>
</li>
<li> <p><code>is_blank_cols()</code> a logical vector: <code>TRUE</code> all rows of column are <em>blank</em>,
otherwise <code>FALSE</code>
</p>
</li></ul>


<hr>
<h2 id='char2fact'>Character to factor</h2><span id='topic+char2fact'></span><span id='topic+char2fact.default'></span><span id='topic+char2fact.character'></span><span id='topic+char2fact.factor'></span><span id='topic+char2fact.data.frame'></span>

<h3>Description</h3>

<p>Converts characters to factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2fact(x, n = 5)

## Default S3 method:
char2fact(x, n = 5)

## S3 method for class 'character'
char2fact(x, n = 5)

## S3 method for class 'factor'
char2fact(x, n = 5)

## S3 method for class 'data.frame'
char2fact(x, n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char2fact_+3A_x">x</code></td>
<td>
<p>A vector of characters</p>
</td></tr>
<tr><td><code id="char2fact_+3A_n">n</code></td>
<td>
<p>The limit to the number of unique values for the factor</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fact2char">fact2char()</a></code>
</p>
<p>Other factors: 
<code><a href="#topic+as_ordered">as_ordered</a>()</code>,
<code><a href="#topic+drop_levels">drop_levels</a>()</code>,
<code><a href="#topic+fact2char">fact2char</a>()</code>,
<code><a href="#topic+fact_na">fact_na</a>()</code>,
<code><a href="#topic+fact">fact</a>()</code>
</p>

<hr>
<h2 id='checkOptions'>Check options</h2><span id='topic+checkOptions'></span>

<h3>Description</h3>

<p>For each name in <code>x</code> checks the current option value and reports if there
is a difference in a <code>message</code>.  This does not change the options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkOptions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkOptions_+3A_x">x</code></td>
<td>
<p>A named list of new options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks and reports on options
</p>


<h3>Value</h3>

<p>Invisible, a list of the current options from <code>options()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- options()

x &lt;- list(width = -20, warning.length = 2, probably_not_a_real_option = 2)
checkOptions(x)
# pointless, but shows that no messages are given
identical(options(), checkOptions(options()))

options(op)
</code></pre>

<hr>
<h2 id='chr_split'>Character split</h2><span id='topic+chr_split'></span>

<h3>Description</h3>

<p>Split apart a string by each character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chr_split(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chr_split_+3A_x">x</code></td>
<td>
<p>A vector of strings to split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of length <code>nchar(x)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chr_split("split this")
</code></pre>

<hr>
<h2 id='clipboard'>Write to and read from the clipboard</h2><span id='topic+clipboard'></span><span id='topic+write_clipboard'></span><span id='topic+write_clipboard.default'></span><span id='topic+write_clipboard.data.frame'></span><span id='topic+write_clipboard.matrix'></span><span id='topic+write_clipboard.list'></span><span id='topic+read_clipboard'></span>

<h3>Description</h3>

<p>Wrappers for working with the clipboard
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_clipboard(x, ...)

## Default S3 method:
write_clipboard(x, ...)

## S3 method for class 'data.frame'
write_clipboard(x, sep = "\t", row.names = FALSE, ...)

## S3 method for class 'matrix'
write_clipboard(x, sep = "\t", ...)

## S3 method for class 'list'
write_clipboard(x, sep = "\t", ...)

read_clipboard(method = c("default", "data.frame", "tibble"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clipboard_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="clipboard_+3A_...">...</code></td>
<td>
<p>Additional arguments sent to methods or to <code><a href="utils.html#topic+write.table">utils::write.table()</a></code></p>
</td></tr>
<tr><td><code id="clipboard_+3A_sep">sep</code></td>
<td>
<p>the field separator string.  Values within each row of
<code>x</code> are separated by this string.</p>
</td></tr>
<tr><td><code id="clipboard_+3A_row.names">row.names</code></td>
<td>
<p>either a logical value indicating whether the row
names of <code>x</code> are to be written along with <code>x</code>, or a
character vector of row names to be written.</p>
</td></tr>
<tr><td><code id="clipboard_+3A_method">method</code></td>
<td>
<p>Method switch for loading the clipboard</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As these functions rely on <code><a href="utils.html#topic+clipboard">utils::readClipboard()</a></code> and
<code><a href="utils.html#topic+clipboard">utils::writeClipboard()</a></code> they are only available for Windows 10. For copying
and pasting floats, there may be some rounding that can occur.
</p>


<h3>Value</h3>

<p><code>write_clipboard()</code> None, called for side effects <code>read_clipboard()</code>
Either a vector, <code>data.frame</code>, or <code>tibble</code> depending on the <code>method</code> chosen.
Unlike <code><a href="utils.html#topic+clipboard">utils::readClipboard()</a></code>, an empty clipboard value returns <code>NA</code> rather
than <code>""</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Will only run on windows
if (Sys.info()[["sysname"]] == "Windows") {
  foo &lt;- function(x) {
    write_clipboard(x)
    y &lt;- read_clipboard()
    res &lt;- all.equal(x, y)
    if (isTRUE(res)) return("All equal")
    print(x)
    print(y)
  }
  foo(1:4)
  foo(seq(-1, 1, .02))
  foo(Sys.Date() + 1:4)

  # May have some rounding issues
  x &lt;- "0.316362437326461129"
  write_clipboard(x)
  res &lt;- as.character(read_clipboard())
  all.equal(x, res)
  x; res
}
</code></pre>

<hr>
<h2 id='complete_cases'>Complete cases</h2><span id='topic+complete_cases'></span>

<h3>Description</h3>

<p>Return completed cases of a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_cases(data, cols = NULL, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_cases_+3A_data">data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="complete_cases_+3A_cols">cols</code></td>
<td>
<p>Colnames or numbers to remove <code>NA</code> values from; <code>NULL</code> (default)
will use all columns</p>
</td></tr>
<tr><td><code id="complete_cases_+3A_invert">invert</code></td>
<td>
<p>Logical, if <code>TRUE</code> will return incomplete cases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  a = 1:5,
  b = c(1, NA, 3, 4, 5),
  c = c(1, NA, NA, 4, 5)
)

complete_cases(x)
complete_cases(x, invert = TRUE) # returns the incomplete rows
complete_cases(x, "a")
complete_cases(x, "b")
complete_cases(x, "c")
</code></pre>

<hr>
<h2 id='counts'>Count observations by unique values</h2><span id='topic+counts'></span><span id='topic+counts.data.frame'></span><span id='topic+props'></span><span id='topic+props.default'></span><span id='topic+props.data.frame'></span>

<h3>Description</h3>

<p>Variables will be return by the order in which they appear.  Even factors are
shown by their order of appearance in the vector.
</p>
<p>There are 2 methods for counting vectors.  The <code>default</code> method uses
<code>base::tabulate()</code> (the workhorse for <code>base::table()</code> with a call to
<code>pseudo_id()</code> to transform all inputs into integers.  The <code>logical</code> method
counts <code>TRUE</code>, <code>FALSE</code> and <code>NA</code> values, which is much quicker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counts(x, ...)

## S3 method for class 'data.frame'
counts(x, cols, sort = FALSE, ..., .name = "freq")

props(x, ...)

## Default S3 method:
props(x, sort = FALSE, na.rm = FALSE, ...)

## S3 method for class 'data.frame'
props(x, cols, sort = FALSE, na.rm = FALSE, ..., .name = "prop")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counts_+3A_x">x</code></td>
<td>
<p>A vector or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="counts_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="counts_+3A_cols">cols</code></td>
<td>
<p>A vector of column names or indexes</p>
</td></tr>
<tr><td><code id="counts_+3A_sort">sort</code></td>
<td>
<p>Logical, if <code>TRUE</code> will sort values (not counts) before
returning. For factors this will sort by factor levels.  This has no effect
for logical vectors, which already return in the order of <code>FALSE</code>, <code>TRUE</code>,
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="counts_+3A_.name">.name</code></td>
<td>
<p>The name of the new column</p>
</td></tr>
<tr><td><code id="counts_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code> will remove NA values from proportions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get counts or proportions of unique observations in a vector or columns in a
<code>data.frame</code>
</p>


<h3>Value</h3>

<p>A named vector of <code>integer</code>s or <code>double</code>s (for <code>counts</code>, and <code>props</code>,
respectively) or <code>data.frame</code> with columns for each column chosen and the
<code>.name</code> chosen for the summary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:5, 10, TRUE)
counts(x)
props(x)

x &lt;- quick_df(list(
  a = c("a", "c", "a", "c", "d", "b"),
  b = c("a", "a", "a", "c", "c", "b"),
  c = c("a", "a", "a", "c", "b", "b")
))

counts(x, "a")
counts(x, c("a", "b", "c"))
props(x, 2)
props(x, 1:3)

props(c(1, 1, 3, NA, 4))
props(c(1, 1, 3, NA, 4), na.rm = TRUE)
</code></pre>

<hr>
<h2 id='date_from_partial'>Partial dates</h2><span id='topic+date_from_partial'></span>

<h3>Description</h3>

<p>Derive a date vector from a partial date string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_from_partial(
  x,
  format = "ymd",
  method = c("min", "max"),
  year_replacement = NA_integer_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_from_partial_+3A_x">x</code></td>
<td>
<p>A vector of dates written as characters</p>
</td></tr>
<tr><td><code id="date_from_partial_+3A_format">format</code></td>
<td>
<p>Format order of the date (accepts only combinations of <code>'y'</code>,
<code>'m'</code>, and <code>'d'</code>)</p>
</td></tr>
<tr><td><code id="date_from_partial_+3A_method">method</code></td>
<td>
<p>Method for reporting partial dates as either the earliest
possible date (<code>"min"</code>) or the latest possible date (<code>"max"</code>); dates with
missing days will be adjusted accordingly to the month and, if needed, the
leap year</p>
</td></tr>
<tr><td><code id="date_from_partial_+3A_year_replacement">year_replacement</code></td>
<td>
<p>(Default: <code>NA_integer_</code>) If set, will use this as a
replacement for dates that contain missing years</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes a character as an argument and attempts to create a date object when
part of the date string is missing.
</p>


<h3>Value</h3>

<p>A vector of <code>Dates</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("2020-12-17", NA_character_, "", "2020-12-UN", "2020-12-UN",
       "2019-Unknown-00", "UNK-UNK-UNK", "1991-02-UN", "    ",
       "2020January20")
data.frame(
  x = x,
  min = date_from_partial(x),
  max = date_from_partial(x, method = "max"),
  year = date_from_partial(x, year_replacement = 1900)
)
</code></pre>

<hr>
<h2 id='depth'>Depth</h2><span id='topic+depth'></span><span id='topic+depth.default'></span><span id='topic+depth.list'></span>

<h3>Description</h3>

<p>Functions to extract the 'depth' of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth(x, ...)

## Default S3 method:
depth(x, ...)

## S3 method for class 'list'
depth(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="depth_+3A_...">...</code></td>
<td>
<p>Possible additional arguments passed to methods (not in use)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not count an empty lists (<code>list()</code>) as a level or <code>NULL</code>
objects.
</p>


<h3>Value</h3>

<p>A single <code>integer</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(1, 2, 3)
depth(a) # Vectors are 1L

b &lt;- list(a = 1, b = list(list(1)))
depth(b)
</code></pre>

<hr>
<h2 id='detail'>Details an object</h2><span id='topic+detail'></span><span id='topic+detail.default'></span><span id='topic+detail.data.frame'></span>

<h3>Description</h3>

<p>Provides details about an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detail(x, ...)

## Default S3 method:
detail(x, factor_n = 5L, ...)

## S3 method for class 'data.frame'
detail(x, factor_n = 5L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detail_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="detail_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="detail_+3A_factor_n">factor_n</code></td>
<td>
<p>An <code>integer</code> threshold for making factors; will convert any
character vectors with <code>factor_n</code> or less unique values into a <code>fact</code>;
setting as <code>NA</code> will ignore this</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(letters[1:4], 10, TRUE)
detail(x)

df &lt;- quick_df(list(
  x = x,
  y = round(runif(10), 2),
  z = Sys.Date() + runif(10) * 100
))

detail(df)
</code></pre>

<hr>
<h2 id='diff_time'>Diff time wrappers</h2><span id='topic+diff_time'></span><span id='topic+diff_time_days'></span><span id='topic+diff_time_weeks'></span><span id='topic+diff_time_hours'></span><span id='topic+diff_time_mins'></span><span id='topic+diff_time_secs'></span><span id='topic+diff_time_months'></span><span id='topic+diff_time_years'></span><span id='topic+diff_time_dyears'></span><span id='topic+diff_time_wyears'></span><span id='topic+diff_time_myears'></span>

<h3>Description</h3>

<p>Wrappers for computing diff times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_time(
  x,
  y,
  method = c("secs", "mins", "hours", "days", "weeks", "months", "years", "dyears",
    "wyears", "myears"),
  tzx = NULL,
  tzy = tzx
)

diff_time_days(x, y, ...)

diff_time_weeks(x, y, ...)

diff_time_hours(x, y, ...)

diff_time_mins(x, y, ...)

diff_time_secs(x, y, ...)

diff_time_months(x, y, ...)

diff_time_years(x, y, ...)

diff_time_dyears(x, y, ...)

diff_time_wyears(x, y, ...)

diff_time_myears(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_time_+3A_x">x</code>, <code id="diff_time_+3A_y">y</code></td>
<td>
<p>Vectors of times</p>
</td></tr>
<tr><td><code id="diff_time_+3A_method">method</code></td>
<td>
<p>A method to report the difference in units of time (see
<strong>Units</strong> section)</p>
</td></tr>
<tr><td><code id="diff_time_+3A_tzx">tzx</code>, <code id="diff_time_+3A_tzy">tzy</code></td>
<td>
<p>time zones (see <strong>Time zones</strong> section)</p>
</td></tr>
<tr><td><code id="diff_time_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>diff_time()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A few significant differences exist with these functions * The class
of the object returned is no longer <code>difftime</code> (but does print) with the
<code>difftime</code> method.  This makes the exporting process easier as the data
will not have to be converted back to <code>numeric</code> * <code>difftime()</code> computes the
difference of <code>time1</code> - <code>time2</code>, but the inverse feels a bit more nature:
time difference from <code>x</code> to <code>y</code> * Additional units can be used (detailed
below) * Differences can be sensitive to time zones if time zones are
passed to the <code>tz</code> parameter as a character vector
</p>


<h3>Value</h3>

<p>A <code>diff_time</code> vector, object
</p>


<h3>Units</h3>

<p>Units can be used beyond those available in
<code>base::difftime()</code>.  Some of these use assumptions in how units of time
should be standardized and can be changed in the corresponding options. Any
of these can be calculated with <code>base::difftime()</code> through using <code>units = "days"</code> but the <code>dtime</code> class will print out with these specifications into
the console for less potential confusion.
</p>

<dl>
<dt>months</dt><dd><p>Months by number of days <code>mark.days_in_month</code> (defaults: <code>30</code>)</p>
</dd>
<dt>years</dt><dd><p>Years by number of days <code>mark.days_in_year</code> (defaults: <code>365</code>)</p>
</dd>
<dt>dyears</dt><dd><p>Years by number of days <code>mark.days_in_year</code> (defaults: <code>365</code>) (same as <code>years</code>)</p>
</dd>
<dt>myears</dt><dd><p>Years by number of days in a month <code>mark.days_in_month</code> (defaults: <code>30</code>)</p>
</dd>
<dt>wyears</dt><dd><p>Years by number of weeks in a year <code>mark.weeks_in_year</code> (defaults: <code>52</code>)</p>
</dd>
</dl>



<h3>Time zones</h3>

<p>Time zones can be passed as either a numeric vector of
GMT/UTC offsets (the number of seconds from GMT) or as a character vector.
If the letter, these need to conform with values from <code>base::OlsonNames()</code>.
</p>
<p>A default timezone can be set with <code>options(mark.default_tz = .)</code>.  The
value can either be a numeric
</p>

<hr>
<h2 id='drop_levels'>Drop levels</h2><span id='topic+drop_levels'></span><span id='topic+drop_levels.data.frame'></span><span id='topic+drop_levels.fact'></span><span id='topic+drop_levels.factor'></span>

<h3>Description</h3>

<p>Drop unused levels of a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_levels(x, ...)

## S3 method for class 'data.frame'
drop_levels(x, ...)

## S3 method for class 'fact'
drop_levels(x, ...)

## S3 method for class 'factor'
drop_levels(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_levels_+3A_x">x</code></td>
<td>
<p>A <code>factor</code> or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="drop_levels_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods (not used)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="base.html#topic+droplevels">base::droplevels</a>
</p>
<p>Other factors: 
<code><a href="#topic+as_ordered">as_ordered</a>()</code>,
<code><a href="#topic+char2fact">char2fact</a>()</code>,
<code><a href="#topic+fact2char">fact2char</a>()</code>,
<code><a href="#topic+fact_na">fact_na</a>()</code>,
<code><a href="#topic+fact">fact</a>()</code>
</p>

<hr>
<h2 id='echo'>echo</h2><span id='topic+echo'></span>

<h3>Description</h3>

<p>Run expressions with logging outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>echo(exprs, to = stdout(), msg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="echo_+3A_exprs">exprs</code></td>
<td>
<p>Expressions</p>
</td></tr>
<tr><td><code id="echo_+3A_to">to</code></td>
<td>
<p>Output locations</p>
</td></tr>
<tr><td><code id="echo_+3A_msg">msg</code></td>
<td>
<p>If <code>FALSE</code> does not print results from <code>message()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>try(echo({
  1 + 1
  Sys.sleep(2)
  head(mtcars)
  message(1)
  warning(2)
  stop(3)
}))
</code></pre>

<hr>
<h2 id='ept'>Parse and evaluate text</h2><span id='topic+ept'></span>

<h3>Description</h3>

<p>A wrapper for eval(parse(text = .))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ept(x, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ept_+3A_x">x</code></td>
<td>
<p>A character string to parse</p>
</td></tr>
<tr><td><code id="ept_+3A_envir">envir</code></td>
<td>
<p>The environment in which to evaluate the code</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The evaluation of <code>x</code> after parsing
</p>

<hr>
<h2 id='eval_named_chunk'>Evaluate a  Named Chunk</h2><span id='topic+eval_named_chunk'></span>

<h3>Description</h3>

<p>Evaluate a named chunk from an Rmd file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_named_chunk(rmd_file, label_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_named_chunk_+3A_rmd_file">rmd_file</code></td>
<td>
<p>Absolute path to rmd file</p>
</td></tr>
<tr><td><code id="eval_named_chunk_+3A_label_name">label_name</code></td>
<td>
<p>Name of label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value from the evaluated code chunk
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temp_rmd &lt;- tempfile(fileext = ".rmd")

text &lt;- '
```{r not this label}
print("that is wrong")
```

```{r hello label}
text &lt;- "hello, world"
print(text)
print(TRUE)
```

```{r another label}
warning("wrong label")
```
'
## Not run: 
writeLines(text, con = temp_rmd)

eval_named_chunk(temp_rmd, "hello label")
# [1] "hello, world"
# [1] TRUE

file.remove(temp_rmd)

## End(Not run)
</code></pre>

<hr>
<h2 id='expand_by'>Expands a vector</h2><span id='topic+expand_by'></span>

<h3>Description</h3>

<p>Expands vector x by y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_by(x, y, expand = c("x", "y", "intersect", "both"), sort = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_by_+3A_x">x</code>, <code id="expand_by_+3A_y">y</code></td>
<td>
<p>Vectors</p>
</td></tr>
<tr><td><code id="expand_by_+3A_expand">expand</code></td>
<td>
<p>Character switch to expand or keep only the values that
intersect, all values in x or y, or retain all values found.</p>
</td></tr>
<tr><td><code id="expand_by_+3A_sort">sort</code></td>
<td>
<p>Logical, if <code>TRUE</code> will sort by names in output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with expanded
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- letters[c(3:2, 5, 9)]
y &lt;- letters[c(1:4, 8)]
expand_by(x, y, "x")
expand_by(x, y, "y")
expand_by(x, y, "intersect")
expand_by(x, y, "both")
</code></pre>

<hr>
<h2 id='fact'>Factor</h2><span id='topic+fact'></span><span id='topic+fact.default'></span><span id='topic+fact.character'></span><span id='topic+fact.numeric'></span><span id='topic+fact.integer'></span><span id='topic+fact.Date'></span><span id='topic+fact.POSIXt'></span><span id='topic+fact.logical'></span><span id='topic+fact.factor'></span><span id='topic+fact.fact'></span><span id='topic+fact.pseudo_id'></span><span id='topic+fact.haven_labelled'></span>

<h3>Description</h3>

<p>Quickly create a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fact(x)

## Default S3 method:
fact(x)

## S3 method for class 'character'
fact(x)

## S3 method for class 'numeric'
fact(x)

## S3 method for class 'integer'
fact(x)

## S3 method for class 'Date'
fact(x)

## S3 method for class 'POSIXt'
fact(x)

## S3 method for class 'logical'
fact(x)

## S3 method for class 'factor'
fact(x)

## S3 method for class 'fact'
fact(x)

## S3 method for class 'pseudo_id'
fact(x)

## S3 method for class 'haven_labelled'
fact(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fact_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fact()</code> can be about 5 times quicker than <code>factor()</code> or
<code>as.factor()</code> as it doesn't bother sorting the levels for non-numeric data
or have other checks or features.  It simply converts a vector to a factor
with all unique values as levels with <code>NA</code>s included.
</p>
<p><code>fact.factor()</code> will perform several checks on a factor to include <code>NA</code>
levels and to check if the levels should be reordered to conform with the
other methods.  The <code>fact.fact()</code> method simple returns <code>x</code>.
</p>


<h3>Value</h3>

<p>A vector of equal length of <code>x</code> with class <code>fact</code> and <code>factor</code>.  If
<code>x</code> was <code>ordered</code>, that class is added in between.
</p>


<h3>level orders</h3>

<p>The order of the levels may be adjusted to these rules depending on the class
of <code>x</code>:
</p>

<dl>
<dt><code>character</code></dt><dd><p>The order of appearance</p>
</dd>
<dt><code>numeric</code>/<code>integer</code>/<code>Date</code>/<code>POSIXt</code></dt><dd><p>By the numeric order</p>
</dd>
<dt><code>logical</code></dt><dd><p>As <code>TRUE</code>, <code>FALSE</code>, then <code>NA</code> if present</p>
</dd>
<dt><code>factor</code></dt><dd><p>Numeric if levels can be safely converted, otherwise as
they are</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+as_ordered">as_ordered()</a></code>
</p>
<p>Other factors: 
<code><a href="#topic+as_ordered">as_ordered</a>()</code>,
<code><a href="#topic+char2fact">char2fact</a>()</code>,
<code><a href="#topic+drop_levels">drop_levels</a>()</code>,
<code><a href="#topic+fact2char">fact2char</a>()</code>,
<code><a href="#topic+fact_na">fact_na</a>()</code>
</p>

<hr>
<h2 id='fact_na'><code>fact</code> with <code>NA</code></h2><span id='topic+fact_na'></span>

<h3>Description</h3>

<p>Included <code>NA</code> values into <code>fact()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fact_na(x, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fact_na_+3A_x">x</code></td>
<td>
<p>A <code>fact</code> or object cohered to <code>fact</code></p>
</td></tr>
<tr><td><code id="fact_na_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code> removes <code>NA</code> value from the <code>fact</code> <code>levels</code> and
<code>uniques</code> attributes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This re-formats the <code>x</code> value so that <code>NA</code>s are found immediately within the
object rather than accessed through its attributes.
</p>


<h3>Value</h3>

<p>A <code>fact</code> vector
</p>


<h3>See Also</h3>

<p>Other factors: 
<code><a href="#topic+as_ordered">as_ordered</a>()</code>,
<code><a href="#topic+char2fact">char2fact</a>()</code>,
<code><a href="#topic+drop_levels">drop_levels</a>()</code>,
<code><a href="#topic+fact2char">fact2char</a>()</code>,
<code><a href="#topic+fact">fact</a>()</code>
</p>

<hr>
<h2 id='fact_reverse'>Fact reverse levels</h2><span id='topic+fact_reverse'></span>

<h3>Description</h3>

<p>Reverse the levels of a <code>fact</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fact_reverse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fact_reverse_+3A_x">x</code></td>
<td>
<p>A <code>fact</code> object (or passed to <code><a href="#topic+fact">fact()</a></code>)</p>
</td></tr>
</table>

<hr>
<h2 id='fact2char'>Factor to character</h2><span id='topic+fact2char'></span>

<h3>Description</h3>

<p>Convert factor columns to characters in a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fact2char(data, threshold = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fact2char_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code></p>
</td></tr>
<tr><td><code id="fact2char_+3A_threshold">threshold</code></td>
<td>
<p>A threshold for the number of levels to be met/exceeded for
transforming into a character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>data.frame</code> <code>data</code> with factors converted by the rule above
</p>


<h3>See Also</h3>

<p><code><a href="#topic+char2fact">char2fact()</a></code>
</p>
<p>Other factors: 
<code><a href="#topic+as_ordered">as_ordered</a>()</code>,
<code><a href="#topic+char2fact">char2fact</a>()</code>,
<code><a href="#topic+drop_levels">drop_levels</a>()</code>,
<code><a href="#topic+fact_na">fact_na</a>()</code>,
<code><a href="#topic+fact">fact</a>()</code>
</p>

<hr>
<h2 id='fct_expand_seq'>Factor Expand by Sequence</h2><span id='topic+fct_expand_seq'></span>

<h3>Description</h3>

<p>Expands an ordered factor from one level to another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_expand_seq(
  x,
  min_lvl = min(x, na.rm = TRUE),
  max_lvl = max(x, na.rm = TRUE),
  by = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fct_expand_seq_+3A_x">x</code></td>
<td>
<p>An ordered factor</p>
</td></tr>
<tr><td><code id="fct_expand_seq_+3A_min_lvl">min_lvl</code></td>
<td>
<p>The start of the level sequence</p>
</td></tr>
<tr><td><code id="fct_expand_seq_+3A_max_lvl">max_lvl</code></td>
<td>
<p>The end of the level sequence</p>
</td></tr>
<tr><td><code id="fct_expand_seq_+3A_by">by</code></td>
<td>
<p>Integer, number of steps in between</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Defaults for <code>min_lvl</code> and <code>max_lvl</code> are the minimum and maximum
levels in the ordered vector <code>x</code>.
</p>


<h3>Value</h3>

<p>An <code>ordered</code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ordered(letters[c(5:15, 2)], levels = letters)
fct_expand_seq(x)
fct_expand_seq(x, "g", "s", 3L) # from "g" to "s" by 3
fct_expand_seq(x, "g", "t", 3L) # same as above

# from the first inherit level to the last observed
fct_expand_seq(x, min(levels(x)))
</code></pre>

<hr>
<h2 id='file_info'>File information utils</h2><span id='topic+file_info'></span><span id='topic+newest_file'></span><span id='topic+newest_dir'></span><span id='topic+oldest_file'></span><span id='topic+oldest_dir'></span><span id='topic+largest_file'></span><span id='topic+smallest_file'></span>

<h3>Description</h3>

<p>Other utility functions for dealing with files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newest_file(x)

newest_dir(x)

oldest_file(x)

oldest_dir(x)

largest_file(x)

smallest_file(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_info_+3A_x">x</code></td>
<td>
<p>A vector of file paths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A full file path
</p>

<hr>
<h2 id='file_name'>File name</h2><span id='topic+file_name'></span>

<h3>Description</h3>

<p>Basename of file without extension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_name(x, compression = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_name_+3A_x">x</code></td>
<td>
<p>character vector giving file paths.</p>
</td></tr>
<tr><td><code id="file_name_+3A_compression">compression</code></td>
<td>
<p>logical: should compression extension &lsquo;<span class="file">.gz</span>&rsquo;,
&lsquo;<span class="file">.bz2</span>&rsquo; or &lsquo;<span class="file">.xz</span>&rsquo; be removed first?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The file name of the path without the extension
</p>

<hr>
<h2 id='file_utils'>Open a file using windows file associations</h2><span id='topic+file_utils'></span><span id='topic+open_file'></span><span id='topic+file_open'></span><span id='topic+shell_exec'></span><span id='topic+list_files'></span><span id='topic+list_dirs'></span>

<h3>Description</h3>

<p>Opens the given files(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>open_file(x)

file_open(x)

shell_exec(x)

list_files(
  x = ".",
  pattern = utils::glob2rx(glob),
  glob = NULL,
  ignore_case = FALSE,
  all = FALSE,
  negate = FALSE,
  basename = FALSE
)

list_dirs(
  x = ".",
  pattern = NULL,
  ignore_case = FALSE,
  all = FALSE,
  basename = FALSE,
  negate = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_utils_+3A_x">x</code></td>
<td>
<p>A character vector of paths</p>
</td></tr>
<tr><td><code id="file_utils_+3A_pattern">pattern</code>, <code id="file_utils_+3A_glob">glob</code></td>
<td>
<p>Pattern to search for files.  <code>glob</code> is absorbed into
<code>pattern</code>, through <code><a href="utils.html#topic+glob2rx">utils::glob2rx()</a></code>.</p>
</td></tr>
<tr><td><code id="file_utils_+3A_ignore_case">ignore_case</code></td>
<td>
<p>logical. Should pattern-matching be case-insensitive?</p>
</td></tr>
<tr><td><code id="file_utils_+3A_all">all</code></td>
<td>
<p>a logical value. If FALSE, only the names of visible files are
returned (following Unix-style visibility, that is files whose name does
not start with a dot). If TRUE, all file names will be returned.</p>
</td></tr>
<tr><td><code id="file_utils_+3A_negate">negate</code></td>
<td>
<p>Logical, if <code>TRUE</code> will inversely select files that do not
match the provided pattern</p>
</td></tr>
<tr><td><code id="file_utils_+3A_basename">basename</code></td>
<td>
<p>If <code>TRUE</code> only searches pattern on the basename, otherwise on
the entire path</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>open_file</code> is an alternative to <code>shell.exec()</code> that can take take
multiple files. <code>list_files</code> and <code>list_dirs</code> are mostly wrappers for
<code><a href="fs.html#topic+dir_ls">fs::dir_ls()</a></code> with preferred defaults and pattern searching on the full file
path.
</p>
<p><code>file_open</code> is simply an alias.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>open_file()</code>, <code>shell_exec()</code>: A logical vector where <code>TRUE</code> successfully
opened, <code>FALSE</code> did not and <code>NA</code> did not try to open (file not found)
</p>
</li>
<li> <p><code>list_files()</code>, <code>list_dirs()</code>: A vector of full paths
</p>
</li></ul>


<hr>
<h2 id='fizzbuzz'>Fizz Buzz</h2><span id='topic+fizzbuzz'></span><span id='topic+fizzbuzz_lazy'></span><span id='topic+.fizzbuzz_vector'></span>

<h3>Description</h3>

<p>For when someone asked you to do something you've done before, you can argue
that the quickest way to do it is to just take the work someone else did and
utilize that.  No reason to reinvent the wheel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fizzbuzz(n, show_numbers = TRUE)

fizzbuzz_lazy(n)

.fizzbuzz_vector
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fizzbuzz_+3A_n">n</code></td>
<td>
<p>The number of numbers</p>
</td></tr>
<tr><td><code id="fizzbuzz_+3A_show_numbers">show_numbers</code></td>
<td>
<p>If <code>TRUE</code> shows no</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1000000.
</p>


<h3>Details</h3>

<p>Multiples of <code>3</code> are shown as <code>"Fizz"</code>; multiples of <code>5</code> as <code>"Buzz"</code>;
multiple of both (i.e., <code>15</code>) are <code>"FizzBuzz"</code>.
<code>fizzbuzz_lazy()</code> subsets the <code>.fizzbuzz_vector</code> object, which is a solution
with default parameters up to <code>1e6</code>
</p>


<h3>Value</h3>

<p>A <code>character</code> vector of <code style="white-space: pre;">&#8288;1, 2, Fizz, 3, Buzz&#8288;</code>, etc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fizzbuzz(15)
fizzbuzz(30, show_numbers = FALSE)
cat(fizzbuzz(30), sep = "\n")


# show them how fast your solution is:
if (package_available("bench")) {
  bench::mark(fizzbuzz(1e5), fizzbuzz_lazy(1e5))
}

</code></pre>

<hr>
<h2 id='get_dir_max_number'>Get recent directory by number name</h2><span id='topic+get_dir_max_number'></span>

<h3>Description</h3>

<p>Finds the directory where the number is the greatest.  This can be useful for
when folders are created as run IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dir_max_number(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dir_max_number_+3A_x">x</code></td>
<td>
<p>The directory to look in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A full path to a directory
</p>

<hr>
<h2 id='get_dir_recent_date'>Get recent directory by date</h2><span id='topic+get_dir_recent_date'></span>

<h3>Description</h3>

<p>Looks at the directories and assumes the date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dir_recent_date(x = ".", dt_pattern = NULL, dt_format = NULL, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dir_recent_date_+3A_x">x</code></td>
<td>
<p>A directory</p>
</td></tr>
<tr><td><code id="get_dir_recent_date_+3A_dt_pattern">dt_pattern</code></td>
<td>
<p>A pattern to be passed to filter for the directory</p>
</td></tr>
<tr><td><code id="get_dir_recent_date_+3A_dt_format">dt_format</code></td>
<td>
<p>One or more formats to try</p>
</td></tr>
<tr><td><code id="get_dir_recent_date_+3A_all">all</code></td>
<td>
<p>Logical, if <code>TRUE</code> will recursively search for directories</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A full path to a directory
</p>

<hr>
<h2 id='get_recent_dir'>Get recent directory</h2><span id='topic+get_recent_dir'></span>

<h3>Description</h3>

<p>Finds the recent subdirectory in a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_recent_dir(x = ".", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_recent_dir_+3A_x">x</code></td>
<td>
<p>The root directory</p>
</td></tr>
<tr><td><code id="get_recent_dir_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+list_dirs">list_dirs()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full path of the most recent directory
</p>

<hr>
<h2 id='get_recent_file'>Get recent file</h2><span id='topic+get_recent_file'></span>

<h3>Description</h3>

<p>A function where you can detect the most recent file from a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_recent_file(x, exclude_temp = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_recent_file_+3A_x">x</code></td>
<td>
<p>The directory in which to search the file</p>
</td></tr>
<tr><td><code id="get_recent_file_+3A_exclude_temp">exclude_temp</code></td>
<td>
<p>Logical, if <code>TRUE</code> tries to remove temp Windows files</p>
</td></tr>
<tr><td><code id="get_recent_file_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+list_files">list_files()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full name of the most recent file from the stated directory
</p>

<hr>
<h2 id='get_version'>Get and bump version</h2><span id='topic+get_version'></span><span id='topic+bump_version'></span><span id='topic+bump_date_version'></span><span id='topic+update_version'></span>

<h3>Description</h3>

<p>Will read the <code>DESCRIPTION</code> file and to get and adjust the
version
</p>
<p><code>bump_date_version()</code> will not check if the version is actually a date.  When
the current version is the same as today's date(equal by character strings)
it will append a <code>.1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_version()

bump_version(version = NULL)

bump_date_version(version = NULL)

update_version(version = NULL, date = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_version_+3A_version">version</code></td>
<td>
<p>A new version to be added; default of <code>NULL</code> will
automatically update.</p>
</td></tr>
<tr><td><code id="get_version_+3A_date">date</code></td>
<td>
<p>If <code>TRUE</code> will use a date as a version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get and bump package version for dates
</p>


<h3>Value</h3>


<ul>
<li> <p><code>get_version()</code>: A package_version
</p>
</li>
<li> <p><code>bump_version()</code>: None, called for its side-effects
</p>
</li>
<li> <p><code>bump_date_version()</code>: None, called for its side-effects
</p>
</li>
<li> <p><code>update_version()</code>: None, called for its side-effects
</p>
</li></ul>


<hr>
<h2 id='glob'>Wildcard globbing</h2><span id='topic+glob'></span>

<h3>Description</h3>

<p>Helper function for globbing character vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glob(x, pattern = NULL, value = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glob_+3A_x">x</code></td>
<td>
<p>A vector of characters</p>
</td></tr>
<tr><td><code id="glob_+3A_pattern">pattern</code></td>
<td>
<p>Wildcard globbing pattern</p>
</td></tr>
<tr><td><code id="glob_+3A_value">value</code>, <code id="glob_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>grep</code>. Note: <code>value</code> is by
default <code>TRUE</code>; when <code>NA</code>, <code>...</code> is passed to <code>grepl</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("apple", "banana", "peach", "pear", "orange")
glob(x, "*e")
glob(x, "pea*", value = FALSE)
glob(x, "*an*", value = NA)

path &lt;- system.file("R", package = "mark")
glob(list.files(path), "r*")
</code></pre>

<hr>
<h2 id='handlers'>Handlers</h2><span id='topic+handlers'></span><span id='topic+has_warning'></span><span id='topic+has_error'></span><span id='topic+has_message'></span><span id='topic+get_warning'></span><span id='topic+get_message'></span><span id='topic+get_error'></span>

<h3>Description</h3>

<p>Catch and report handlers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_warning(x, FUN, ...)

has_error(x, FUN, ...)

has_message(x, FUN, ...)

get_warning(x, FUN, ..., .null = TRUE)

get_message(x, FUN, ..., .null = TRUE)

get_error(x, FUN, ..., .null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handlers_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="handlers_+3A_fun">FUN</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="handlers_+3A_...">...</code></td>
<td>
<p>Additional params passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="handlers_+3A_.null">.null</code></td>
<td>
<p>Logical, if <code>FALSE</code> will drop <code>NULL</code> results (for <code style="white-space: pre;">&#8288;get_*()&#8288;</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used to catch whether an evaluation will
return an error or warning without raising.
</p>


<h3>Value</h3>

<p>The <code style="white-space: pre;">&#8288;has_*()&#8288;</code> functions will return <code>TRUE</code>/<code>FALSE</code> for if the handler
is found in the execution of the code. The <code style="white-space: pre;">&#8288;get_*()&#8288;</code> functions provide the
text of the message
</p>


<h3>References</h3>

<p>Function for <em>catching</em> has been adapted from
https://stackoverflow.com/a/4952908/12126576
</p>


<h3>Examples</h3>

<pre><code class='language-R'>has_warning(c(1, "no"), as.integer)
#     1    no
# FALSE  TRUE

get_warning(c(1, "no"), as.integer)

# drop NULLs
get_warning(c(1, "no"), as.integer, .null = FALSE)

foo &lt;- function(x) {
  stopifnot(x &gt; 0)
  x
}

has_error(c(1, 0, 2), foo)
#     1     0     2
# FALSE  TRUE FALSE

get_error(c(1, 0, 2), foo)

# drop NULLs
get_error(c(1, 0, 2), foo, .null = FALSE)
</code></pre>

<hr>
<h2 id='import'>Import</h2><span id='topic+import'></span>

<h3>Description</h3>

<p>Import a single function from a package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import(pkg, fun, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_+3A_pkg">pkg</code></td>
<td>
<p>String, name of the package</p>
</td></tr>
<tr><td><code id="import_+3A_fun">fun</code></td>
<td>
<p>String, fun name of the function</p>
</td></tr>
<tr><td><code id="import_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical, if TRUE and <code>fun</code> is also found in the current
environment, will overwrite assignment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assigns `add` -- test with caution
import("magrittr", "add")
</code></pre>

<hr>
<h2 id='insert'>Insert</h2><span id='topic+insert'></span>

<h3>Description</h3>

<p>Insert values at a position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert(x, positions, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="insert_+3A_positions">positions</code></td>
<td>
<p>Integer of positions of <code>x</code> to insert <code>values</code></p>
</td></tr>
<tr><td><code id="insert_+3A_values">values</code></td>
<td>
<p>A vector of values to insert into <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the intended values inserted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>insert(letters[1:5], c(2, 4), c("X", "Y"))

</code></pre>

<hr>
<h2 id='is_dir'>Is File/Directory</h2><span id='topic+is_dir'></span><span id='topic+is_file'></span>

<h3>Description</h3>

<p>Is the path a file/directory?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dir(x)

is_file(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dir_+3A_x">x</code></td>
<td>
<p>A vector of file paths</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are essentially taken from <code><a href="utils.html#topic+filetest">utils::file_test()</a></code> for <code>op = '-d'</code> and
<code>op = -f</code> but separated.
</p>


<h3>Value</h3>

<p>A <code>logical</code> vector
</p>

<hr>
<h2 id='labels'>Dataframe labels</h2><span id='topic+labels'></span><span id='topic+assign_labels'></span><span id='topic+assign_labels.default'></span><span id='topic+assign_labels.data.frame'></span><span id='topic+get_labels'></span><span id='topic+get_labels.default'></span><span id='topic+get_labels.data.frame'></span><span id='topic+view_labels'></span><span id='topic+remove_labels'></span><span id='topic+remove_labels.default'></span><span id='topic+remove_labels.data.frame'></span>

<h3>Description</h3>

<p>Assign labels to a vector or data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_labels(x, ...)

## Default S3 method:
assign_labels(x, label, ...)

## S3 method for class 'data.frame'
assign_labels(
  x,
  ...,
  .missing = c("error", "warn", "skip"),
  .ls = rlang::list2(...)
)

get_labels(x)

## Default S3 method:
get_labels(x)

## S3 method for class 'data.frame'
get_labels(x)

view_labels(x, title)

remove_labels(x, ...)

## Default S3 method:
remove_labels(x, ...)

## S3 method for class 'data.frame'
remove_labels(x, cols, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_+3A_x">x</code></td>
<td>
<p>A vector of data.frame</p>
</td></tr>
<tr><td><code id="labels_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressed separated by commas.  If assigning
to a data.frame, <code>...</code> can be replaced with a <code>data.frame</code> where the first
column is the targeted colname and the second is the desired label.</p>
</td></tr>
<tr><td><code id="labels_+3A_label">label</code></td>
<td>
<p>A single length string of a label to be assigned</p>
</td></tr>
<tr><td><code id="labels_+3A_.missing">.missing</code></td>
<td>
<p>A control setting for dealing missing columns in a list;
can be set to <code>error</code> to <code>stop()</code> the call, <code>warn</code> to provide a warning, or
<code>skip</code> to silently skip those labels.</p>
</td></tr>
<tr><td><code id="labels_+3A_.ls">.ls</code></td>
<td>
<p>A named list of columns and labels to be set if <code>...</code> is empty</p>
</td></tr>
<tr><td><code id="labels_+3A_title">title</code></td>
<td>
<p>Title for the viewer window &ndash; if not supplemented will show as
<code>paste0(as.character(substitute(x)), " - Labels")</code></p>
</td></tr>
<tr><td><code id="labels_+3A_cols">cols</code></td>
<td>
<p>A character vector of column names; if missing will remove the
label attribute across all columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When labels are assigned to a data.frame they can make viewing the object
(with <code>View()</code> inside Rstudio).  The <code>view_labels()</code> has a call to <code>View()</code>
inside and will retrieve the labels and show them in the viewer as a
data.frame.
</p>


<h3>Value</h3>

<p>A labelled vector or <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labs &lt;- assign_labels(
  iris,
  Sepal.Length = "cms",
  Sepal.Width  = "cms",
  Petal.Length = "cms",
  Petal.Width  = "cms",
  Species      = "Iris ..."
)

labs$dummy &lt;- ""
get_labels(labs) # shows label as &lt;NA&gt; for dummy column

labs0 &lt;- remove_labels(labs, c("Sepal.Length", "Sepal.Width"))
get_labels(labs0) # No labels for Sepal.Length and Sepal.Width
</code></pre>

<hr>
<h2 id='limit'>Limit</h2><span id='topic+limit'></span>

<h3>Description</h3>

<p>Limit a numeric vector by lower and upper bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limit(x, lower = min(x), upper = max(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limit_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="limit_+3A_lower">lower</code></td>
<td>
<p>A lower limit (as <code>x &lt; lower</code>)</p>
</td></tr>
<tr><td><code id="limit_+3A_upper">upper</code></td>
<td>
<p>An upper limit (as <code>x &gt; higher</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector <code>x</code> with <code>lower</code> and <code>upper</code> as the minimum, maximum
values
</p>

<hr>
<h2 id='lines_of_r_code'>Lines of R code</h2><span id='topic+lines_of_r_code'></span>

<h3>Description</h3>

<p>Find the total number of lines of R code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines_of_r_code(x = ".", skip_empty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_of_r_code_+3A_x">x</code></td>
<td>
<p>Directory to search for files</p>
</td></tr>
<tr><td><code id="lines_of_r_code_+3A_skip_empty">skip_empty</code></td>
<td>
<p>Logical, if TRUE will not count lines that are empty or
only contain a bracket or quotation mark.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tries to read each file in the directory that ends in .R or .r and sums
together.  Files that fail to read are not counted.
</p>


<h3>Value</h3>

<p>An <code>integer</code> for the number of lines in all applicable files
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lines_of_r_code(system.file())
lines_of_r_code(system.file(), skip_empty = FALSE)

</code></pre>

<hr>
<h2 id='list_environments'>List all environments and objects</h2><span id='topic+list_environments'></span><span id='topic+environments'></span><span id='topic+ls_all'></span><span id='topic+objects_all'></span>

<h3>Description</h3>

<p>Functions to list out all environments and objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>environments()

ls_all(all.names = FALSE)

objects_all(all.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_environments_+3A_all.names">all.names</code></td>
<td>
<p>a logical value.  If <code>TRUE</code>, all
object names are returned.  If <code>FALSE</code>, names which begin with a
&lsquo;<span class="samp">&#8288;.&#8288;</span>&rsquo; are omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>environments()</code> is basically a printing wrapper for <code>base::search()</code>
</p>
<p><code>ls_all()</code> and <code>objects_all()</code> can be used retrieved all objects from all
environments in the <code>search()</code> path, which may print out a large result
into the console.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>environments()</code>: Invisibly, a <code>character</code> vector of environment names
</p>
</li></ul>


<ul>
<li> <p><code>ls_all()</code>, <code>objects_all()</code>: A named list for each of the environments
the <code>search()</code> path with all the objects found in that environment
</p>
</li></ul>


<hr>
<h2 id='list2df'>List to data.frame</h2><span id='topic+list2df'></span>

<h3>Description</h3>

<p>Converts a list object into a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2df(x, name = "name", value = "value", show_NA, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2df_+3A_x">x</code></td>
<td>
<p>A (preferably) named <code>list</code> with any number of values</p>
</td></tr>
<tr><td><code id="list2df_+3A_name">name</code>, <code id="list2df_+3A_value">value</code></td>
<td>
<p>Names of the new key and value columns, respectively</p>
</td></tr>
<tr><td><code id="list2df_+3A_show_na">show_NA</code></td>
<td>
<p>Ignored; if set will trigger a warning</p>
</td></tr>
<tr><td><code id="list2df_+3A_warn">warn</code></td>
<td>
<p>Logical; if TRUE will show a warning when</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code>base::list2DF()</code>, <code>list2df()</code> tries to format the data.frame by using
the names of the list as values rather than variables.  This creates a
longer form list that may be more tidy.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> object with columns <code>"name"</code> and <code>"value"</code> for the
names of the <code>list</code> and the values in each
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = 1, b = 2:4, c = letters[10:20], "unnamed", "unnamed2")
list2df(x, "col1", "col2", warn = FALSE)

if (getRversion() &gt;= as.package_version('4.0')) {
# contrast with `base::list2DF()` and `base::as.data.frame()`
  x &lt;- list(a = 1:3, b = 2:4, c = letters[10:12])
  list2df(x, warn = FALSE)
  list2DF(x)
  as.data.frame(x)
}
</code></pre>

<hr>
<h2 id='logic_ext'>Logic - Extension'</h2><span id='topic+logic_ext'></span><span id='topic+is_true'></span><span id='topic+is_true.default'></span><span id='topic+is_true.logical'></span><span id='topic+is_false'></span><span id='topic+is_false.default'></span><span id='topic+is_false.logical'></span><span id='topic++25xor+25'></span><span id='topic+OR'></span><span id='topic+AND'></span><span id='topic+either'></span><span id='topic+is_boolean'></span><span id='topic+none'></span>

<h3>Description</h3>

<p>All functions take logical or logical-like (i.e., 1, 0, or NA as
integer or doubles) and return logical values.
</p>
<p>Extensions to the base logical operations to account for <code>NA</code> values.
</p>
<p><code><a href="base.html#topic+Logic">base::isTRUE()</a></code> and <code><a href="base.html#topic+Logic">base::isFALSE()</a></code> will only return single length <code>TRUE</code>
or <code>FALSE</code> as it checks for valid lengths in the evaluation.  When needing to
check over a vector for the presence of <code>TRUE</code> or <code>FALSE</code> and not being held
back by <code>NA</code> values, <code>is_true</code> and <code>is_false</code> will always provide a <code>TRUE</code>
<code>FALSE</code> when the vector is logical or return <code>NA</code> is the vector <code>x</code> is not
logical.
</p>
<p><code style="white-space: pre;">&#8288;%or%&#8288;</code> is just a wrapper for <code><a href="base.html#topic+Logic">base::xor()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_true(x)

## Default S3 method:
is_true(x)

## S3 method for class 'logical'
is_true(x)

is_false(x)

## Default S3 method:
is_false(x)

## S3 method for class 'logical'
is_false(x)

x %xor% y

OR(..., na.rm = FALSE)

AND(..., na.rm = FALSE)

either(x, y)

is_boolean(x)

none(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logic_ext_+3A_x">x</code>, <code id="logic_ext_+3A_y">y</code></td>
<td>
<p>A vector of logical values.  If <code>NULL</code> will generate a warning.
If not a logical value, will return <code>NA</code> equal to the vector length</p>
</td></tr>
<tr><td><code id="logic_ext_+3A_...">...</code></td>
<td>
<p>Vectors or a list of logical values</p>
</td></tr>
<tr><td><code id="logic_ext_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, if <code>TRUE</code> will ignore <code>NA</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Logical operations, extended
</p>


<h3>Value</h3>


<ul>
<li> <p><code>is_true()</code>, <code>is_false()</code>, <code>either()</code>, <code style="white-space: pre;">&#8288;%or%&#8288;</code>, <code>AND()</code>, <code>OR()</code>: A <code>logical</code>
vector, equal length of <code>x</code> (or <code>y</code> or of all <code>...</code> lengths)
</p>
</li>
<li> <p><code>is_boolean()</code>: <code>TRUE</code> or <code>FALSE</code>
</p>
</li>
<li> <p><code>none()</code>: <code>TRUE</code>, <code>FALSE</code>, or <code>NA</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(TRUE, FALSE, NA)
y &lt;- c(FALSE, FALSE, TRUE)
z &lt;- c(TRUE, NA, TRUE)
isTRUE(x)
is_true(x)
isFALSE(x)
is_false(x)
x %xor% TRUE
TRUE %xor% TRUE
TRUE %xor% FALSE
NA %xor% FALSE
OR(x, y, z)
OR(x, y, z, na.rm = TRUE)
AND(x, y, z)
AND(x, y, z, na.rm = TRUE)
either(x, FALSE)
either(TRUE, FALSE)
either(FALSE, NA)
either(TRUE, NA)
none(x)
none(x &amp; y, na.rm = TRUE)
is_boolean(x)
is_boolean(c(1L, NA_integer_, 0L))
is_boolean(c(1.01, 0, -1))
</code></pre>

<hr>
<h2 id='ls_ext'>List Objects - extensions</h2><span id='topic+ls_ext'></span><span id='topic+ls_dataframe'></span><span id='topic+ls_function'></span><span id='topic+ls_object'></span>

<h3>Description</h3>

<p>List Objects - extensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_dataframe(pattern, all.names = FALSE, envir = parent.frame())

ls_function(pattern, all.names = FALSE, envir = parent.frame())

ls_object(pattern, all.names = FALSE, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls_ext_+3A_pattern">pattern</code></td>
<td>
<p>an optional <a href="base.html#topic+regular+20expression">regular expression</a>.  Only names
matching <code>pattern</code> are returned.  <code><a href="utils.html#topic+glob2rx">glob2rx</a></code> can be
used to convert wildcard patterns to regular expressions.</p>
</td></tr>
<tr><td><code id="ls_ext_+3A_all.names">all.names</code></td>
<td>
<p>a logical value.  If <code>TRUE</code>, all
object names are returned.  If <code>FALSE</code>, names which begin with a
&lsquo;<span class="samp">&#8288;.&#8288;</span>&rsquo; are omitted.</p>
</td></tr>
<tr><td><code id="ls_ext_+3A_envir">envir</code></td>
<td>
<p>an alternative argument to <code>name</code> for specifying the
environment.  Mostly there for back compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of names
</p>

<hr>
<h2 id='make_sf'>Make system file function</h2><span id='topic+make_sf'></span>

<h3>Description</h3>

<p>Simple wrapper for package specific function for internal packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sf(package)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_sf_+3A_package">package</code></td>
<td>
<p>The name of the package</p>
</td></tr>
</table>

<hr>
<h2 id='mark'>mark</h2><span id='topic+mark'></span><span id='topic+mark-package'></span>

<h3>Description</h3>

<p>Miscellaneous, Analytic R Kernels
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jordan Mark Barbone <a href="mailto:jmbarbone@gmail.com">jmbarbone@gmail.com</a> (0000-0001-9788-3628) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jmbarbone/mark">https://github.com/jmbarbone/mark</a>
</p>
</li>
<li> <p><a href="https://jmbarbone.github.io/mark/">https://jmbarbone.github.io/mark/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jmbarbone/mark/issues">https://github.com/jmbarbone/mark/issues</a>
</p>
</li></ul>


<hr>
<h2 id='match_arg'>Match arguments</h2><span id='topic+match_arg'></span>

<h3>Description</h3>

<p>This function is essentially a clear version of <code><a href="base.html#topic+match.arg">base::match.arg()</a></code> which
produces a cleaner warning message and does not restrict the <code>table</code> param
to <code>character</code> vectors only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_arg(x, table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_arg_+3A_x">x</code></td>
<td>
<p>An argument</p>
</td></tr>
<tr><td><code id="match_arg_+3A_table">table</code></td>
<td>
<p>A table of choices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Match arguments
</p>


<h3>Value</h3>

<p>A single value from <code>x</code> matched on <code>table</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_param">match_param()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("apple", "banana", "orange")
match_arg("b", x)

# Produces error
try(match_arg("pear", x))

foo &lt;- function(x, op = c(1, 2, 3)) {
  op &lt;- match_arg(op)
  x / op
}

foo(10, 3)

# Error
try(foo(1, 0))
</code></pre>

<hr>
<h2 id='match_param'>Match params</h2><span id='topic+match_param'></span>

<h3>Description</h3>

<p>Much like <code><a href="base.html#topic+match.arg">base::match.arg()</a></code> with a few key differences:
</p>

<ul>
<li><p> Will not perform partial matching
</p>
</li>
<li><p> Will not return error messages with ugly quotation marks
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>match_param(param, choices, null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_param_+3A_param">param</code></td>
<td>
<p>The parameter</p>
</td></tr>
<tr><td><code id="match_param_+3A_choices">choices</code></td>
<td>
<p>The available choices; named lists will return the name (a
character) for when matched to the value within the list element</p>
</td></tr>
<tr><td><code id="match_param_+3A_null">null</code></td>
<td>
<p>If <code>TRUE</code> allows <code>NULL</code> to be passed a <code>param</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Param matching for an argument
</p>


<h3>Value</h3>

<p>A single value from <code>param</code> matched on <code>choices</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_arg">match_arg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fruits &lt;- function(x = c("apple", "banana", "orange")) {
  match_param(x)
}

fruits()         # apple
try(fruits("b")) # must be exact fruits("banana")

# can have multiple responses
how_much &lt;- function(x = list(too_few = 0:2, ok = 3:5, too_many = 6:10)) {
  match_param(x)
}

how_much(1)
how_much(3)
how_much(9)
</code></pre>

<hr>
<h2 id='median2'>Median (Q 50)</h2><span id='topic+median2'></span><span id='topic+q50'></span>

<h3>Description</h3>

<p>Median as the 50th quantile with an option to select quantile algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median2(x, type = 7, na.rm = FALSE)

q50(x, type = 7, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median2_+3A_x">x</code></td>
<td>
<p>numeric vector whose sample quantiles are wanted, or an
object of a class for which a method has been defined (see also
&lsquo;details&rsquo;). <code><a href="base.html#topic+NA">NA</a></code> and <code>NaN</code> values are not
allowed in numeric vectors unless <code>na.rm</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="median2_+3A_type">type</code></td>
<td>
<p>an integer between 1 and 9 selecting one of the
nine quantile algorithms detailed below to be used.</p>
</td></tr>
<tr><td><code id="median2_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if true, any <code><a href="base.html#topic+NA">NA</a></code> and <code>NaN</code>'s
are removed from <code>x</code> before the quantiles are computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>q50</code> is an alias for <code>median2</code>
</p>


<h3>Value</h3>

<p>See <code>stats::quantile()</code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">stats::quantile()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- rnorm(100)
median(x)            # 0.08979677
median2(x, type = 7) # 0.08979677 - default type is 7
median2(x, type = 3) # 0.08976065

</code></pre>

<hr>
<h2 id='merge_list'>Merge lists</h2><span id='topic+merge_list'></span>

<h3>Description</h3>

<p>Merge lists with different or intersecting names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_list(x, y, keep = c("x", "y"), null = c("ignore", "drop", "keep")[1:2])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_list_+3A_x">x</code>, <code id="merge_list_+3A_y">y</code></td>
<td>
<p>Lists to merge</p>
</td></tr>
<tr><td><code id="merge_list_+3A_keep">keep</code></td>
<td>
<p>When matching names are found, from which object should the
values be retained; <code>"x"</code> retains values from <code>x</code>, <code>"y"</code> retains values
from <code>y</code>.</p>
</td></tr>
<tr><td><code id="merge_list_+3A_null">null</code></td>
<td>
<p>Method for handling <code>NULL</code> values.  When two values are passed,
they will be applied to <code>x</code> and <code>y</code> respectively.  When a single value is
passed, it will be applied to both <code>x</code> and <code>y</code>.
</p>

<ul>
<li> <p><code>"ignore"</code>: <code>NULL</code> values are ignored.  When passes to <code>x</code>, the <code>NULL</code>
values will be retained if they are not overridden by <code>y</code>.
</p>
</li>
<li> <p><code>"drop"</code>: <code>NULL</code> values are dropped from merge and will not appear in the
output.
</p>
</li>
<li> <p><code>"keep"</code>: <code>NULL</code> values are retained in the output and can override other
values.
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = 1, b = 2,    c = NULL, d = NULL)
y &lt;- list(a = 2, b = NULL, c = 3)

# compared to:
utils::modifyList(x, y)
utils::modifyList(x, y, keep.null = TRUE)

merge_list(x, y)
merge_list(x, y, keep = "y")
merge_list(x, y, null = "drop")
</code></pre>

<hr>
<h2 id='multi_grepl'>Multiple searching</h2><span id='topic+multi_grepl'></span><span id='topic+multi_grep'></span>

<h3>Description</h3>

<p>Multiple search pattern searches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_grepl(x, patterns, ..., simplify = TRUE)

multi_grep(x, patterns, ..., simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_grepl_+3A_x">x</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+grep">base::grepl()</a></code></p>
</td></tr>
<tr><td><code id="multi_grepl_+3A_patterns">patterns</code></td>
<td>
<p>A list or vector of patterns to search across <code>x</code>; if named
value returned will be the name of the pattern &ndash; otherwise the position.
Pattern match reported will be the first in the list that is found</p>
</td></tr>
<tr><td><code id="multi_grepl_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+grep">base::grepl()</a></code></p>
</td></tr>
<tr><td><code id="multi_grepl_+3A_simplify">simplify</code></td>
<td>
<p>if <code>FALSE</code> will return a list of all matches, otherwise the
first match found</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name or position of the pattern that is matched
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("apple", "banana", "lemon")
multi_grepl(x, c("a" = "^[ab]", "b" = "lem"))
multi_grepl(x, c("a" = "^[ab]", "b" = "q"))                   # lemon not matches on either
multi_grepl(x, c("a" = "^[ab]", "b" = "e"))                   # apple matches "a" before "b"
multi_grepl(x, c("a" = "^[ab]", "b" = "e"), simplify = FALSE) # shows all matches
multi_grepl(x, c("^[ab]", "e"))                               # returned as positions
multi_grepl(x, c("^[ab]", "e"), simplify = FALSE)

</code></pre>

<hr>
<h2 id='na_assignments'>NA at positions</h2><span id='topic+na_assignments'></span><span id='topic+NA_at'></span><span id='topic+NA_if'></span><span id='topic+NA_in'></span><span id='topic+NA_out'></span>

<h3>Description</h3>

<p>Converts select elements of a vector into <code>NA</code>s
</p>
<p>This is how the end results are
</p>

<ul>
<li> <p><code>NA_at</code> and <code>NA_if</code> require a suitable index value (<code>x[y] &lt;- NA</code>)
</p>

<ul>
<li> <p><code>NA_at</code> expects <code>y</code> (or the result of function <code>y</code>) to be <code>integers</code>
</p>
</li>
<li> <p><code>NA_if</code> expects <code>y</code> (or the result of function <code>y</code>) to be <code>logical</code>
</p>
</li></ul>

</li>
<li> <p><code>NA_in</code> and <code>NA_out</code> expect some values to match on
</p>

<ul>
<li> <p><code>NA_in</code> checks <code>x[x %in% y] &lt;- NA</code>
</p>
</li>
<li> <p><code>NA_out</code> checks <code>x[x %out% y] &lt;- NA</code> (see match_ext)
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>NA_at(x, y, ...)

NA_if(x, y, ...)

NA_in(x, y, ...)

NA_out(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_assignments_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="na_assignments_+3A_y">y</code></td>
<td>
<p>Either a suitable value (see <code>Details</code>) or a function which accepts
<code>x</code> as its first parameter and can return suitable values</p>
</td></tr>
<tr><td><code id="na_assignments_+3A_...">...</code></td>
<td>
<p>Additional values passed to <code>y</code> (if <code>y</code> is a function)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert specific values to NA
</p>


<h3>Value</h3>

<p><code>x</code> with assigned <code>NA</code> values
</p>


<h3>See Also</h3>

<p>Inspired by <code><a href="dplyr.html#topic+na_if">dplyr::na_if()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>let &lt;- ordered(letters[1:5])
NA_at(let, c(1, 3, 5))   # [1] &lt;NA&gt; b    &lt;NA&gt; d    &lt;NA&gt;
NA_if(let, let &lt;= "b")   # [1] &lt;NA&gt; &lt;NA&gt; c    d    e
NA_in(let, c("a", "c"))  # [1] &lt;NA&gt; b    &lt;NA&gt; d    e
NA_out(let, c("a", "c")) # [1] a    &lt;NA&gt; c    &lt;NA&gt; &lt;NA&gt;

</code></pre>

<hr>
<h2 id='na_cols'>Selecting NA columns</h2><span id='topic+na_cols'></span><span id='topic+select_na_cols'></span><span id='topic+remove_na_cols'></span><span id='topic+is_na_cols'></span>

<h3>Description</h3>

<p>Select or remove columns that are entirely NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_na_cols(x)

remove_na_cols(x)

is_na_cols(x, names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_cols_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code></p>
</td></tr>
<tr><td><code id="na_cols_+3A_names">names</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default) will return column names as names
of vector</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>select_na_cols()</code> <code>x</code> with only columns that are all <code>NA</code>
</p>
</li>
<li> <p><code>remove_na_cols()</code> <code>x</code> without columns of only <code>NA</code>
</p>
</li>
<li> <p><code>is_na_cols()</code> a logical vector: <code>TRUE</code> all rows of column are <code>NA</code>,
otherwise <code>FALSE</code>
</p>
</li></ul>


<hr>
<h2 id='norm_path'>Normalize paths</h2><span id='topic+norm_path'></span><span id='topic+file_path'></span><span id='topic+user_file'></span>

<h3>Description</h3>

<p>Normalize and check a vector of paths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_path(x = ".", check = FALSE, remove = check)

file_path(..., check = FALSE, remove = check)

user_file(..., check = FALSE, remove = check)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_path_+3A_x">x</code></td>
<td>
<p>A character vector of paths</p>
</td></tr>
<tr><td><code id="norm_path_+3A_check">check</code></td>
<td>
<p>Logical, if TRUE will check if the path exists and output a
warning if it does not.</p>
</td></tr>
<tr><td><code id="norm_path_+3A_remove">remove</code></td>
<td>
<p>Logical, if TRUE will remove paths that are not found</p>
</td></tr>
<tr><td><code id="norm_path_+3A_...">...</code></td>
<td>
<p>Character vectors for creating a path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of full file paths
</p>

<hr>
<h2 id='normalize'>Normalize values</h2><span id='topic+normalize'></span><span id='topic+normalize.default'></span><span id='topic+normalize.data.frame'></span>

<h3>Description</h3>

<p>Normalizes values based on possible range and new bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x, ...)

## Default S3 method:
normalize(x, range = base::range(x, na.rm = TRUE), bounds = 0:1, ...)

## S3 method for class 'data.frame'
normalize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>An object that is (coercible to) <code>double</code>; <code>data.frames</code> are
transformed</p>
</td></tr>
<tr><td><code id="normalize_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="normalize_+3A_range">range</code></td>
<td>
<p>The range of possible values of <code>x</code>.  See details for more info.
Defaults to the range of non-<code>NA</code> values</p>
</td></tr>
<tr><td><code id="normalize_+3A_bounds">bounds</code></td>
<td>
<p>The new boundaries for the normalized values of <code>x</code>. Defaults
to <code>0</code> and <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters <code>range</code> and <code>bounds</code> are modified with <code><a href="base.html#topic+range">base::range()</a></code>.
The largest and smallest values are then used to determine the
minimum/maximum values and lower/upper bounds.  This allows for a vector of
more than two values to be passed.
</p>
<p>The current implementation of <code>normalize.data.frame()</code> allows for <code>list</code> of
parameters passed for each column.  However, it is probably best suited for
default values.
</p>


<h3>Value</h3>

<p><code>x</code> with transformed values where <code>range</code> values are transformed to
<code>bounds</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.23, 0.32, 0.12, 0.61, 0.26, 0.24, 0.23, 0.32, 0.29, 0.27)
data.frame(
  x  = normalize(x),
  v  = normalize(x, range = 0:2),
  b  = normalize(x, bounds = 0:10),
  vb = normalize(x, range = 0:2, bounds = 0:10)
)

# maintains matrix
mat &lt;- structure(c(0.24, 0.92, 0.05, 0.37, 0.19, 0.69, 0.43, 0.22, 0.85,
0.73, 0.89, 0.68, 0.57, 0.89, 0.61, 0.98, 0.75, 0.37, 0.24, 0.24,
0.34, 0.8, 0.25, 0.46, 0.03, 0.71, 0.79, 0.56, 0.83, 0.97), dim = c(10L, 3L))

mat
normalize(mat, bounds = -1:1)
normalize(as.data.frame(mat), bounds = -1:1)
</code></pre>

<hr>
<h2 id='not_available'>Make not available</h2><span id='topic+not_available'></span><span id='topic+set_not_available'></span><span id='topic+NA_Date_'></span><span id='topic+NA_POSIXct_'></span><span id='topic+NA_POSIXlt_'></span>

<h3>Description</h3>

<p>Create NA vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not_available(type = "logical", length = 0L)

set_not_available(type, value)

NA_Date_

NA_POSIXct_

NA_POSIXlt_
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="not_available_+3A_type">type</code></td>
<td>
<p>Type of NA (see details)</p>
</td></tr>
<tr><td><code id="not_available_+3A_length">length</code></td>
<td>
<p>Length of the vector</p>
</td></tr>
<tr><td><code id="not_available_+3A_value">value</code></td>
<td>
<p>A value to return in <code>not_available()</code></p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>Date</code> of length 1.
</p>
<p>An object of class <code>POSIXct</code> (inherits from <code>POSIXt</code>) of length 1.
</p>
<p>An object of class <code>POSIXlt</code> (inherits from <code>POSIXt</code>) of length 1.
</p>


<h3>Details</h3>

<p>If length is a text it will search for an appropriate match.
</p>


<h3>Value</h3>

<p>A vector of <code>NA</code> values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- not_available("Date", 3)
x
class(x)

</code></pre>

<hr>
<h2 id='note'>Append a note to an object</h2><span id='topic+note'></span><span id='topic+note+3C-'></span><span id='topic+set_note'></span>

<h3>Description</h3>

<p>An alternative to the <code><a href="base.html#topic+comment">base::comment()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>note(x) &lt;- value

set_note(x, value)

note(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="note_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="note_+3A_value">value</code></td>
<td>
<p>The note to attach; if <code>NULL</code> will remove the note and the class
<code>noted</code> from the object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the note is assigned to an object a new class will be added,
<code>note</code>, so that a <code>print</code> function can call an S3 method.  The print for
this can be adjusted for it's width by using the option <code>mark.note.width</code>
which defaults to the option <code>width</code> when not set.
</p>
<p>The type of object assigned to the note is not restricted, so user beware
of odd prints or additional features added to the notes fun.
</p>
<p>When assigning a note (with <code style="white-space: pre;">&#8288;note&lt;-&#8288;</code>, and its alias <code>set_note()</code>) the
<code>noted</code> class is added to the object.  This allows the <code>print.noted</code> class
to be dispatched and for the note to be printed every time the object is
called/printed and the next print method used.  However, it will not be
called when not <code>interactive()</code>
</p>


<h3>Value</h3>


<ul>
<li> <p><code style="white-space: pre;">&#8288;note&lt;-&#8288;</code>, <code>set_note()</code> will return <code>x</code> (with the <code>"note"</code> attribute
assigned)
</p>
</li>
<li> <p><code>note()</code> will retrieve the <code>"note"</code> attribute
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("x", "k", "c", "d")
comment(x) &lt;- "This is just a comment"
comment(x)

# Comment is intentionally hidden
x
note(x) &lt;- "Just some random letters"
note(x)

# Note is now present every time
x

# Assigning `NULL` will remove note (and class)
note(x) &lt;- NULL
note(x) # NULL
x       # No more note

</code></pre>

<hr>
<h2 id='omit_na'>Omit NA values</h2><span id='topic+omit_na'></span>

<h3>Description</h3>

<p>Omit NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omit_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omit_na_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> which <code>NA</code> values removes and two attributes of <code>integers</code>: <code>na</code>
which is the position of <code>NA</code> values, and <code>valid</code> for the position of
non-<code>NA</code> values; empty positions reported as <code>integer(0)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Like stats::na.omit but always provides
x &lt;- letters[1:5]
omit_na(x)
x[c(3, 5)] &lt;- NA
omit_na(x)

</code></pre>

<hr>
<h2 id='package_available'>Check if package is available</h2><span id='topic+package_available'></span>

<h3>Description</h3>

<p>A wrapped requireNamespace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>package_available(namespace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="package_available_+3A_namespace">namespace</code></td>
<td>
<p>One or more packages to to require.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>require_namespace()</code>: None, called for side effects
</p>
</li>
<li> <p><code>package_available()</code>: Visibly, <code>TRUE</code> or <code>FALSE</code>
</p>
</li></ul>


<hr>
<h2 id='percentile_rank'>Percentile rank</h2><span id='topic+percentile_rank'></span>

<h3>Description</h3>

<p>The bounds of the percentile rank are &gt; 0 and &lt; 1 (see Boundaries)
</p>
<p>A percentile rank here is the proportion of scores that are less than the
current score.
</p>
<p style="text-align: center;"><code class="reqn">PR = (c_L + 0.5 f_i) / N</code>
</p>

<p>Where
</p>
<p><code class="reqn">c_L</code> is the frequency of scores less than the score of interest
</p>
<p><code class="reqn">f_i</code> is the frequency of the score of interest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentile_rank(x, weights = times, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percentile_rank_+3A_x">x</code></td>
<td>
<p>A vector of values to rank</p>
</td></tr>
<tr><td><code id="percentile_rank_+3A_weights">weights</code>, <code id="percentile_rank_+3A_times">times</code></td>
<td>
<p>A vector of the number of times to repeat <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a percentile rank for each score in a set.
</p>


<h3>Value</h3>

<p>The percentile rank of <code>x</code> between 0 and 1 (see Boundaries)
</p>


<h3>Boundaries</h3>

<p>While the percentile rank of a score in a set must be exclusively within the
boundaries of <code>0</code> and <code>1</code>, this function may produce a percentile rank that
is exactly <code>0</code> or <code>1</code>.  This may occur when the number of values are so large
that the value within the boundaries is too small to be differentiated.
</p>
<p>Additionally, when using the <code>weights</code> parameter, if the lowest or highest
number has a value of <code>0</code>, the number will then have a theoretical <code>0</code> or
<code>1</code>, as these values are not actually within the set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>percentile_rank(0:9)
x &lt;- c(1, 2, 1, 7, 5, NA_integer_, 7, 10)
percentile_rank(x)

if (package_available("dplyr")) {
  dplyr::percent_rank(x)
}

# with times
percentile_rank(7:1, c(1, 0, 2, 2, 3, 1, 1))
</code></pre>

<hr>
<h2 id='print_c'>Print as c</h2><span id='topic+print_c'></span>

<h3>Description</h3>

<p>Prints a vector to paste into an R script
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_c(x = read_clipboard(), sorted = TRUE, null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_c_+3A_x">x</code></td>
<td>
<p>A vector (defaults to reading the clipboard)</p>
</td></tr>
<tr><td><code id="print_c_+3A_sorted">sorted</code></td>
<td>
<p>If <code>TRUE</code> (default) applies <code>sort()</code> to <code>x</code></p>
</td></tr>
<tr><td><code id="print_c_+3A_null">null</code></td>
<td>
<p>If <code>TRUE</code> (default) adds <code>NULL</code> at the end of the <code>c()</code> print</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This sorts (if set) and provides unique values for each element in <code>x</code> and
prints then as a call to <code>c</code>.  This can be useful for copying data that you
want to save as a vector in an R script.
The result is both called in <code>cat()</code> as well as copied to the clipboard.
</p>


<h3>Value</h3>

<p>Invisibly, as a <code>character</code> vector, the object printed to the console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print_c(1:10)
print_c(letters[1:3])
print_c(month.abb)

</code></pre>

<hr>
<h2 id='print.mark_bib_df'>Print bib data frame</h2><span id='topic+print.mark_bib_df'></span>

<h3>Description</h3>

<p>Print bib dataframe, or as list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mark_bib_df'
print(x, list = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mark_bib_df_+3A_x">x</code></td>
<td>
<p>The <code>mark_bib_df</code> object</p>
</td></tr>
<tr><td><code id="print.mark_bib_df_+3A_list">list</code></td>
<td>
<p>If <code>TRUE</code> will print as a list rather than the <code>data.frame</code></p>
</td></tr>
<tr><td><code id="print.mark_bib_df_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly, called for its side effects
</p>

<hr>
<h2 id='print.pseudo_id'>Print <code>pseudo_id</code></h2><span id='topic+print.pseudo_id'></span>

<h3>Description</h3>

<p>Print <code>pseudo_id</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pseudo_id'
print(x, ..., all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pseudo_id_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+pseudo_id">pseudo_id</a></p>
</td></tr>
<tr><td><code id="print.pseudo_id_+3A_...">...</code></td>
<td>
<p>Not implemented</p>
</td></tr>
<tr><td><code id="print.pseudo_id_+3A_all">all</code></td>
<td>
<p>if <code>TRUE</code> will print all uniques.  This is not recommend for many
uniques as it will crowd the console output</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.  Called for its side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pseudo_id">pseudo_id()</a></code>
</p>

<hr>
<h2 id='process_bib_dataframe'>Process bib values</h2><span id='topic+process_bib_dataframe'></span>

<h3>Description</h3>

<p>Generates a data frame of values from bibs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_bib_dataframe(categories, values, fields, keys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_bib_dataframe_+3A_categories">categories</code></td>
<td>
<p>A list of categories</p>
</td></tr>
<tr><td><code id="process_bib_dataframe_+3A_values">values</code></td>
<td>
<p>A list of values</p>
</td></tr>
<tr><td><code id="process_bib_dataframe_+3A_fields">fields</code></td>
<td>
<p>a Vector of fields</p>
</td></tr>
<tr><td><code id="process_bib_dataframe_+3A_keys">keys</code></td>
<td>
<p>a Vector of keys</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A wide <code>data.frame</code> with explicit <code>NA</code>s
</p>

<hr>
<h2 id='pseudo_id'>Create an ID for a vector</h2><span id='topic+pseudo_id'></span><span id='topic+pseudo_id.pseudo_id'></span><span id='topic+pseudo_id.default'></span><span id='topic+pseudo_id.factor'></span>

<h3>Description</h3>

<p>Transforms a vector into an integer of IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_id(x, ...)

## S3 method for class 'pseudo_id'
pseudo_id(x, ...)

## Default S3 method:
pseudo_id(x, na_last = TRUE, ...)

## S3 method for class 'factor'
pseudo_id(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_id_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="pseudo_id_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="pseudo_id_+3A_na_last">na_last</code></td>
<td>
<p><code>Logical</code> if <code>FALSE</code> will not place <code>NA</code> at the end</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>pseudo_id</code> object where the <code>integer</code> value of the vector
correspond to the position of the unique values in the attribute <code>"uniques"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
(x &lt;- sample(letters, 10, TRUE))
(pid &lt;- pseudo_id(x))
attr(pid, "uniques")[pid]

</code></pre>

<hr>
<h2 id='quiet_stop'>Quiet stop</h2><span id='topic+quiet_stop'></span>

<h3>Description</h3>

<p>Quietly calls stop
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quiet_stop()
</code></pre>


<h3>Value</h3>

<p>None, called for side effects
</p>

<hr>
<h2 id='range2'>Range 2</h2><span id='topic+range2'></span>

<h3>Description</h3>

<p>Employs <code>min()</code> and <code>max()</code>.  However, <code><a href="base.html#topic+range">base::range()</a></code>, there is no argument
for removing <code>Inf</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range2(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range2_+3A_x">x</code></td>
<td>
<p>A numeric (or character) vector (see Note in <a href="base.html#topic+Extremes">base::min</a>)</p>
</td></tr>
<tr><td><code id="range2_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical, if <code>TRUE</code> removes missing values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of length 2 of the minimum and maximum values,
respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rep(1:1e5, 100)
system.time(rep(range(x),  100))
system.time(rep(range2(x), 100))
x[sample(x, 1e5)] &lt;- NA

system.time(rep(range(x, na.rm = TRUE), 100))
system.time(rep(range2(x, na.rm = TRUE), 100))

</code></pre>

<hr>
<h2 id='read_bib'>Read Bib file</h2><span id='topic+read_bib'></span>

<h3>Description</h3>

<p>Read a bib file into a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_bib(file, skip = 0L, max_lines = NULL, encoding = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_bib_+3A_file">file</code></td>
<td>
<p>File or connection</p>
</td></tr>
<tr><td><code id="read_bib_+3A_skip">skip</code></td>
<td>
<p>The lines to skip</p>
</td></tr>
<tr><td><code id="read_bib_+3A_max_lines">max_lines</code></td>
<td>
<p>The maximum number of lines to read</p>
</td></tr>
<tr><td><code id="read_bib_+3A_encoding">encoding</code></td>
<td>
<p>Assumed encoding of file (passed to <code><a href="base.html#topic+readLines">readLines()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired and partially credited to <code>bib2df::bib2df()</code> although this has no
dependencies outside of base functions and much quicker.  This speed seems
to come from removing <code>stringr</code> functions and simplifying a few *apply
functions.
This will also include as many categories as possible from the entry.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with each row as a bib entry and each column as a
field
</p>


<h3>See Also</h3>

<p><code>?bib2df::bib2df</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "https://raw.githubusercontent.com/jmbarbone/bib-references/master/references.bib"
bibdf &lt;- read_bib(file, max_lines = 51L)

if (package_available("tibble")) {
  tibble::as_tibble(bibdf)
} else {
  head(bibdf)
}

if (package_available("bib2df") &amp; package_available("bench")) {
  file &lt;- system.file("extdata", "bib2df_testfile_3.bib", package = "bib2df")

  # Doesn't include the 'tidying' up
  foo &lt;- function(file) {
    bib &lt;- ("bib2df" %colons% "bib2df_read")(file)
    ("bib2df" %colons% "bib2df_gather")(bib)
  }


  bench::mark(
    read_bib = read_bib(file),
    bib2df = bib2df::bib2df(file),
    foo = foo(file),
    check = FALSE
  )[1:9]

}
</code></pre>

<hr>
<h2 id='recode_by'>Recode by</h2><span id='topic+recode_by'></span><span id='topic+recode_only'></span>

<h3>Description</h3>

<p>A simple implementation of recoding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_by(x, by, vals = NULL, mode = "any")

recode_only(x, by, vals = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_by_+3A_x">x</code></td>
<td>
<p>A vector to recode</p>
</td></tr>
<tr><td><code id="recode_by_+3A_by">by</code></td>
<td>
<p>A names vector (<code>new = old</code>); any non-matching values are set to
the appropriate <code>NA</code></p>
</td></tr>
<tr><td><code id="recode_by_+3A_vals">vals</code></td>
<td>
<p>An optional vector of values to use in lieu of a names in the
vector; this takes priority over <code>names(by)</code>.  This can be the same length
as <code>by</code> or a single value.</p>
</td></tr>
<tr><td><code id="recode_by_+3A_mode">mode</code></td>
<td>
<p>passed to <code>as.vector()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be comparable to <code><a href="dplyr.html#topic+recode">dplyr::recode()</a></code> expect that the values are
arranged as <code>new = old</code> rather than <code>old = new</code> and allows for a separate
vector to be passed for <code>new</code>.
</p>
<p><code>recode_only()</code> will only recode the values matches in <code>by</code>/<code>val</code>.
The <code>mode</code> is automatically set according to <code>mode(x)</code>.  This functions
more like <code><a href="base.html#topic+replace">base::replace()</a></code> but with extra features
</p>


<h3>Value</h3>

<p>A vector of values from <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+recode">dplyr::recode()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>recode_by(1:3, c(a = 1, b = 2))
recode_by(letters[1:3], c(`1` = "a", `2` = "b"))                   # will not guess mode
recode_by(letters[1:3], c(`1` = "a", `2` = "b"), mode = "integer") # make as integer
recode_by(letters[1:3], c("a", "b"), vals = 1:2)                   # or pass to vals

recode_only(letters[1:3], c("zzz" = "a"))
recode_only(letters[1:3], c(`1` = "a")) # returns as "1"
recode_only(1:3, c("a" = 1))            # coerced to NA

# Pass list for multiples
recode_only(letters[1:10], list(abc = c("a", "b", "c"), ef = c("e", "f")))

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+7C+7C+25'></span><span id='topic++25+3A+3A+3A+25'></span><span id='topic++25+3A+3A+25'></span><span id='topic++25colons+25'></span><span id='topic++25len+25'></span><span id='topic++25names+25'></span><span id='topic++25out+25'></span><span id='topic++25wi+25'></span><span id='topic++25wo+25'></span><span id='topic+any_match'></span><span id='topic+exattr'></span><span id='topic+flip'></span><span id='topic+is_linux'></span><span id='topic+is_macos'></span><span id='topic+is_windows'></span><span id='topic+set_names'></span><span id='topic+is_named'></span><span id='topic+remove_names'></span><span id='topic+muffle'></span><span id='topic+wuffle'></span><span id='topic+no_match'></span><span id='topic+quick_df'></span><span id='topic+quick_dfl'></span><span id='topic+require_namespace'></span><span id='topic+struct'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>fuj</dt><dd><p><code><a href="fuj.html#topic+colons">%:::%</a></code>, <code><a href="fuj.html#topic+colons">%::%</a></code>, <code><a href="fuj.html#topic+if_null">%||%</a></code>, <code><a href="fuj.html#topic+colons">%colons%</a></code>, <code><a href="fuj.html#topic+if_null">%len%</a></code>, <code><a href="fuj.html#topic+names">%names%</a></code>, <code><a href="fuj.html#topic+match_ext">%out%</a></code>, <code><a href="fuj.html#topic+match_ext">%wi%</a></code>, <code><a href="fuj.html#topic+match_ext">%wo%</a></code>, <code><a href="fuj.html#topic+match_ext">any_match</a></code>, <code><a href="fuj.html#topic+exattr">exattr</a></code>, <code><a href="fuj.html#topic+flip">flip</a></code>, <code><a href="fuj.html#topic+os">is_linux</a></code>, <code><a href="fuj.html#topic+os">is_macos</a></code>, <code><a href="fuj.html#topic+names">is_named</a></code>, <code><a href="fuj.html#topic+os">is_windows</a></code>, <code><a href="fuj.html#topic+muffle">muffle</a></code>, <code><a href="fuj.html#topic+match_ext">no_match</a></code>, <code><a href="fuj.html#topic+quick_df">quick_df</a></code>, <code><a href="fuj.html#topic+quick_df">quick_dfl</a></code>, <code><a href="fuj.html#topic+names">remove_names</a></code>, <code><a href="fuj.html#topic+require_namespace">require_namespace</a></code>, <code><a href="fuj.html#topic+names">set_names</a></code>, <code><a href="fuj.html#topic+struct">struct</a></code>, <code><a href="fuj.html#topic+muffle">wuffle</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reindex'>Reindex a data.frame</h2><span id='topic+reindex'></span>

<h3>Description</h3>

<p>Reindexes a data.frame with a reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reindex(
  x,
  index = NULL,
  new_index,
  expand = c("intersect", "both"),
  sort = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reindex_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="reindex_+3A_index">index</code></td>
<td>
<p>The column name or number of an index to use; if <code>NULL</code> will
assume the first column; a value of <code>row.names</code> will use <code>row.names(x)</code></p>
</td></tr>
<tr><td><code id="reindex_+3A_new_index">new_index</code></td>
<td>
<p>A column vector of the new index value</p>
</td></tr>
<tr><td><code id="reindex_+3A_expand">expand</code></td>
<td>
<p>Character switch to expand or keep only the values that
intersect (none), all values in x or index, or retain all values found.</p>
</td></tr>
<tr><td><code id="reindex_+3A_sort">sort</code></td>
<td>
<p>Logical, if <code>TRUE</code> will sort the rows in output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with rows of <code>index</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris1 &lt;- head(iris, 5)
iris1$index &lt;- 1:5
reindex(iris1, "index", seq(2, 8, 2))
reindex(iris1, "index", seq(2, 8, 2), expand = "both")

# Using letters will show changes in rownames
iris1$index &lt;- letters[1:5]
reindex(iris1, "index", letters[seq(2, 8, 2)])
reindex(iris1, "index", seq(2, 8, 2))
reindex(iris1, "index", seq(2, 8, 2), expand = "both")
</code></pre>

<hr>
<h2 id='remove_na'>Remove NA</h2><span id='topic+remove_na'></span><span id='topic+remove_na.default'></span><span id='topic+remove_na.list'></span><span id='topic+remove_na.factor'></span><span id='topic+remove_na.fact'></span>

<h3>Description</h3>

<p>Remove NAs from a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_na(x)

## Default S3 method:
remove_na(x)

## S3 method for class 'list'
remove_na(x)

## S3 method for class 'factor'
remove_na(x)

## S3 method for class 'fact'
remove_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_na_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>remove_na.factor</code> will remove <code>NA</code> values as identified by the <code>levels()</code>
or by the integer value of the level.  <code>factors</code> are recreated with all
<code>NA</code> values and, if present, the <code>NA</code> <code>level</code> removed.
</p>


<h3>Value</h3>

<p><code>x</code> without values where <code>is.na(x)</code> is <code>TRUE</code>
For factors, a new factor (<code>ordered</code> if <code>is.ordered(x)</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>remove_na(c(4, 1, 2, NA, 4, NA, 3, 2))

# removes based on levels
remove_na(fact(c("b", NA, "a", "c")))

# removes based on values
x &lt;- as_ordered(c("b", "d", "a", "c"))
x[2:3] &lt;- NA
str(remove_na(x))
</code></pre>

<hr>
<h2 id='remove_null'>Remove NULL</h2><span id='topic+remove_null'></span>

<h3>Description</h3>

<p>Remove NULL results from a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_null(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_null_+3A_x">x</code></td>
<td>
<p>A list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list <code>x</code> without <code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = letters[1:5], b = NULL, c = complex(3))
x
remove_null(x)
</code></pre>

<hr>
<h2 id='round_by'>Rounding by a specific interval.</h2><span id='topic+round_by'></span>

<h3>Description</h3>

<p>Rounds a number or vector of numbers by another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_by(x, by = 1, method = c("round", "ceiling", "floor"), include0 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_by_+3A_x">x</code></td>
<td>
<p>A number or vector to round.</p>
</td></tr>
<tr><td><code id="round_by_+3A_by">by</code></td>
<td>
<p>The number by which to round</p>
</td></tr>
<tr><td><code id="round_by_+3A_method">method</code></td>
<td>
<p>An option to explicitly specify automatic rounding, ceiling, or
floor</p>
</td></tr>
<tr><td><code id="round_by_+3A_include0">include0</code></td>
<td>
<p>If <code>FALSE</code> replaces <code>0</code> with <code>by</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>doubles</code> of the same length of <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(1, 13, by = 4/3)

cbind(
  x,
  by_1 = round_by(x, 1),
  by_2 = round_by(x, 2),
  by_3 = round_by(x, 3)
)
</code></pre>

<hr>
<h2 id='row_bind'>Row bind</h2><span id='topic+row_bind'></span>

<h3>Description</h3>

<p>Bind a list of <code>data.frames</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_bind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_bind_+3A_...">...</code></td>
<td>
<p>A list of <code>data.frames</code> to be attached to each other by row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> combining all the rows from <code>data.frame</code>s in <code>...</code>
and all the columns, as they appear. An empty <code>data.frame</code> with <code>0</code> columns
and <code>0</code> rows is returned if <code>...</code> has no length
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code> <code><a href="base.html#topic+cbind">base::rbind()</a></code>
</p>

<hr>
<h2 id='rscript'>Rscript</h2><span id='topic+rscript'></span>

<h3>Description</h3>

<p>Implements <code>Rscript</code> with <code>system2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rscript(x, ops = NULL, args = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rscript_+3A_x">x</code></td>
<td>
<p>An R file to run</p>
</td></tr>
<tr><td><code id="rscript_+3A_ops">ops</code></td>
<td>
<p>A character vector of options (<code>"--"</code> is added to each)</p>
</td></tr>
<tr><td><code id="rscript_+3A_args">args</code></td>
<td>
<p>A character vector of other arguments to pass</p>
</td></tr>
<tr><td><code id="rscript_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>system2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of the result from calling <code>Rscript</code> via
<code>system2()</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+source_to_env">source_to_env</a>
</p>

<hr>
<h2 id='save_source'>Save source</h2><span id='topic+save_source'></span>

<h3>Description</h3>

<p>Source a file and save as file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_source(env = parent.frame(), file = mark_temp("Rds"), name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_source_+3A_env">env</code></td>
<td>
<p>The parent environment</p>
</td></tr>
<tr><td><code id="save_source_+3A_file">file</code></td>
<td>
<p>The file to save the environment to</p>
</td></tr>
<tr><td><code id="save_source_+3A_name">name</code></td>
<td>
<p>An optional name for the environment (mostly cosmetic)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>source_env</code>/<code>environment</code> object, created from <code>env</code>
</p>

<hr>
<h2 id='set_names0'>Set names</h2><span id='topic+set_names0'></span><span id='topic+names_switch'></span>

<h3>Description</h3>

<p>Sets or removes names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_names0(x, nm = x)

names_switch(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_names0_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="set_names0_+3A_nm">nm</code></td>
<td>
<p>A vector of names</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>set_names0()</code>: <code>x</code> with <code>nm</code> values assigned to names (if <code>x</code> is <code>NULL</code>,
<code>NULL</code> is returned)
</p>
</li>
<li> <p><code>remove_names()</code>: <code>x</code> without names
</p>
</li>
<li> <p><code>names_switch()</code>: <code>character</code> vector of equal length <code>x</code> where names and
values are switched
</p>
</li></ul>


<hr>
<h2 id='simpleTimeReport'>Time reports</h2><span id='topic+simpleTimeReport'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
This function can be used to evaluate an expression line-by-line to capture
outputs, errors, messages, and evaluation time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleTimeReport(title = NULL, expr, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleTimeReport_+3A_title">title</code></td>
<td>
<p>The title to be printed</p>
</td></tr>
<tr><td><code id="simpleTimeReport_+3A_expr">expr</code></td>
<td>
<p>The expression to run</p>
</td></tr>
<tr><td><code id="simpleTimeReport_+3A_envir">envir</code></td>
<td>
<p>The environment from which to evaluate the <code>expr</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluate code and report on the time difference
</p>


<h3>Value</h3>

<p>A <code>reported_results</code>/<code>list</code> object containing results, outputs,
messages, warnings, and errors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simpleTimeReport("example", {
  print("1")
  Sys.sleep(1)
  warning("this is a warning")
  for (i in 1:5) {
    Sys.sleep(0.5)
  }
  sample(1e6, 1e6, TRUE)
})
</code></pre>

<hr>
<h2 id='sort_by'>Sort by</h2><span id='topic+sort_by'></span>

<h3>Description</h3>

<p>Sort an object by another object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_by(x, by, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_by_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="sort_by_+3A_by">by</code></td>
<td>
<p>Another vector</p>
</td></tr>
<tr><td><code id="sort_by_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>base::order()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The values of <code>x</code>, resorted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l3 &lt;- letters[1:3]
sort_by(l3, c(3, 2, 1))
# make a factor object with the reversed order
f &lt;- factor(l3, levels = rev(l3))
sort_by(f, l3)
sort_by(1:3, rev(l3))

</code></pre>

<hr>
<h2 id='sort_names'>Sort by names</h2><span id='topic+sort_names'></span>

<h3>Description</h3>

<p>Sort a vector by it's name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_names(x, numeric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_names_+3A_x">x</code></td>
<td>
<p>A named vector of values</p>
</td></tr>
<tr><td><code id="sort_names_+3A_numeric">numeric</code></td>
<td>
<p>If <code>TRUE</code> will try to coerce to numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> sorted by its <code>names()</code>
</p>

<hr>
<h2 id='source_files'>Source file from directory</h2><span id='topic+source_files'></span><span id='topic+source_r_dir'></span><span id='topic+source_r_file'></span>

<h3>Description</h3>

<p>Walk through files in a directory and output them.
Files are sources in order of names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source_r_dir(dir, echo = FALSE, quiet = FALSE, ...)

source_r_file(path, echo = FALSE, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="source_files_+3A_dir">dir</code></td>
<td>
<p>The location of your R scripts</p>
</td></tr>
<tr><td><code id="source_files_+3A_echo">echo</code></td>
<td>
<p>logical; if <code>TRUE</code>, each expression is printed
after parsing, before evaluation.</p>
</td></tr>
<tr><td><code id="source_files_+3A_quiet">quiet</code></td>
<td>
<p>Logical.  Whether to print out a message for each file.</p>
</td></tr>
<tr><td><code id="source_files_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+source">base::source()</a></code></p>
</td></tr>
<tr><td><code id="source_files_+3A_path">path</code></td>
<td>
<p>The location of the R file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, called for side effects
</p>

<hr>
<h2 id='source_to_env'>Source to environment</h2><span id='topic+source_to_env'></span>

<h3>Description</h3>

<p>Source an R script to an environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source_to_env(x, ops = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="source_to_env_+3A_x">x</code></td>
<td>
<p>An R script</p>
</td></tr>
<tr><td><code id="source_to_env_+3A_ops">ops</code></td>
<td>
<p>Options to be passed to <a href="#topic+rscript">rscript</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, and environment variable of the objects/results created
from <code>x</code>
</p>

<hr>
<h2 id='sourcing'>Sourcing extensions</h2><span id='topic+sourcing'></span><span id='topic+ksource'></span><span id='topic+try_source'></span><span id='topic+try_ksource'></span>

<h3>Description</h3>

<p>Functions for extending sourcing features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksource(file, ..., quiet = TRUE, cd = FALSE, env = parent.frame())

try_source(file, cd = FALSE, ...)

try_ksource(file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sourcing_+3A_file">file</code></td>
<td>
<p>An R or Rmd file.</p>
</td></tr>
<tr><td><code id="sourcing_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+source">base::source()</a></code></p>
</td></tr>
<tr><td><code id="sourcing_+3A_quiet">quiet</code></td>
<td>
<p>Logical; Determines whether to apply silence to <code><a href="knitr.html#topic+knit">knitr::purl()</a></code></p>
</td></tr>
<tr><td><code id="sourcing_+3A_cd">cd</code></td>
<td>
<p>Logical; if TRUE, the R working directory is temporarily
changed to the directory containing file for evaluating</p>
</td></tr>
<tr><td><code id="sourcing_+3A_env">env</code></td>
<td>
<p>An environment determining where the parsed expressions are
evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>try_source()</code> will output an error message rather than completely preventing
the execution.
This can be useful for when a script calls on multiple, independent files to
be sourced and a single failure shouldn't prevent the entire run to fail as
well.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>ksource()</code>: Invisibly, the result of calling <code>source()</code> on the <code>.R</code> file conversion of <code>file</code>
</p>
</li>
<li> <p><code>try_source()</code>, <code>try_ksource()</code>: attempts of <code>source()</code> and <code>ksource()</code> but converts errors to warnings
</p>
</li></ul>


<hr>
<h2 id='str_extract_date'>Extract date from string</h2><span id='topic+str_extract_date'></span><span id='topic+str_extract_datetime'></span>

<h3>Description</h3>

<p>Extract date from string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_extract_date(x, format = "%Y-%m-%d")

str_extract_datetime(x, format = "%Y-%m-%d %H%M%S")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_extract_date_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="str_extract_date_+3A_format">format</code></td>
<td>
<p>A date format to find</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Date</code> (if found) or <code>NA</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_extract_date("This is a file name 2020-02-21.csv")
str_extract_date(c("This is a file name 2020-02-21.csv",
                   "Date of 2012-06-15 here"))
str_extract_date(c("This is a file name 2020-02-21.csv", "No date"))
str_extract_date("Last saved 17 December 2019", format = "%d %B %Y")

str_extract_datetime(c("2020-02-21 235033", "2012-12-12 121212"))
str_extract_datetime("This is a file name 2020-02-21 235033.csv")

</code></pre>

<hr>
<h2 id='str_slice'>String Slice</h2><span id='topic+str_slice'></span><span id='topic+str_slice_by_word'></span>

<h3>Description</h3>

<p>Slice/split a string into multiple lines by the desired length of the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_slice(x, n = 80L)

str_slice_by_word(x, n = 80L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_slice_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="str_slice_+3A_n">n</code></td>
<td>
<p>Integer, the length of the line split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("stringi")) {
  x &lt;- stringi::stri_rand_lipsum(1)
  str_slice(x)
  str_slice_by_word(x, n = 50L)
}
</code></pre>

<hr>
<h2 id='switch-ext'>Switch with a list of parameters</h2><span id='topic+switch-ext'></span><span id='topic+switch_params'></span><span id='topic+switch_in_case'></span><span id='topic+switch_case'></span>

<h3>Description</h3>

<p><code>switch_params()</code> is a vectorized version of <code>switch</code>
<code>switch_case()</code> uses a formula syntax to return the value to the right of the
tilde (<code>~</code>) when <code>x</code> is <code>TRUE</code>
<code>switch_in_case()</code> is a special case of <code>switch_case()</code> for <code>match()</code>-ing <code>x</code>
in the values on the left to return the value on the right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_params(x, ...)

switch_in_case(x, ..., .default = NULL, .envir = parent.frame())

switch_case(..., .default = NULL, .envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switch-ext_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="switch-ext_+3A_...">...</code></td>
<td>
<p>Case evaluations (named for <code>switch_params</code>)</p>
</td></tr>
<tr><td><code id="switch-ext_+3A_.default">.default</code></td>
<td>
<p>The default value if no matches are found in <code>...</code>
(default: <code>NULL</code> produces an <code>NA</code> value derived from <code>...</code>)</p>
</td></tr>
<tr><td><code id="switch-ext_+3A_.envir">.envir</code></td>
<td>
<p>The environment in which to evaluate the LHS of <code>...</code> (default:
<code>parent.frame()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Switch with a list of params
</p>


<h3>Value</h3>

<p>A named vector of values of same length <code>x</code>; or for <code>switch_case</code>,
an unnamed vector of values matching the rhs of <code>...</code>
</p>
<p>Inspired from:
</p>

<ul>
<li><p> https://stackoverflow.com/a/32835930/12126576
</p>
</li>
<li><p> https://github.com/tidyverse/dplyr/issues/5811
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># by single
switch_params(c("j", "m", "b"), j = 10, b = 2, m = 13)


# match with TRUE
switch_case(
  1:10 == 9      ~ NA_integer_,
  1:10 %% 3 == 0 ~ 1:10,
  1:10 %% 4 == 0 ~ 11:20,
  1:10 %% 5 == 0 ~ 21:30,
  1:10 %% 2 == 0 ~ 31:40,
  .default = -1L
)

# match within a vector
switch_in_case(
  c(1, 2, 12, 4, 20, 21),
  1:10  ~ 1,
  11:20 ~ 2
)

switch_in_case(
  c("a", "b", "d", "e", "g", "j"),
  letters[1:3] ~ "a",
  letters[5:6] ~ "e"
)

use_these &lt;- c(1, 3, 2, 5)
switch_in_case(
  1:10,
  use_these ~ TRUE,
  .default = FALSE
)

ne &lt;- new.env()
ne$use_these2 &lt;- use_these
# error
try(switch_in_case(
  1:10,
  use_these2 ~ TRUE
))
switch_in_case(
  1:10,
  use_these2 ~ TRUE,
  .envir = ne
)

switch_in_case(
  seq.int(1, 60, 6),
  1:10          ~ "a",
  11:20         ~ "b",
  c(22, 24, 26) ~ "c",
  30:Inf        ~ "d"
)

# Use functions
switch_in_case(
  1:6,
  c(1, 3, 5) ~ exp,
  c(2, 4) ~ log
)
</code></pre>

<hr>
<h2 id='t_df'>Data frame transpose</h2><span id='topic+t_df'></span>

<h3>Description</h3>

<p>This transposes a data.frame with <code>t()</code> but transforms back into a data.frame
with column and row names cleaned up.  Because the data types may be mixed
and reduced to characters, this may only be useful for a visual viewing of
the data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_df(x, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_df_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="t_df_+3A_id">id</code></td>
<td>
<p>No longer used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transposes a data.frame as a data.frame
</p>


<h3>Value</h3>

<p>A transposed <code>data.frame</code> with columns (<code>"colname"</code>, <code>"row_1"</code>, ...,
for each row in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(col_a = Sys.Date() + 1:5, col_b = letters[1:5], col_c = 1:5)
t_df(x)
</code></pre>

<hr>
<h2 id='tableNA'>Table NA values</h2><span id='topic+tableNA'></span>

<h3>Description</h3>

<p>Tables out whether data are NAs are not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableNA(..., .list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tableNA_+3A_...">...</code></td>
<td>
<p>one or more objects which can be interpreted as factors
(including numbers or character strings), or a <code><a href="base.html#topic+list">list</a></code> (such
as a data frame) whose
components can be so interpreted.  (For <code>as.table</code>, arguments
passed to specific methods; for <code>as.data.frame</code>, unused.)</p>
</td></tr>
<tr><td><code id="tableNA_+3A_.list">.list</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>...</code> is a <code>list</code>, will c</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All data are checked with <code>is.na()</code> and the resulting <code>TRUE</code> or <code>FALSE</code> is
are tabulated.
</p>


<h3>Value</h3>

<p><code>table()</code> returns a <em>contingency table</em>, an object of
class <code>"table"</code>, an array of integer values.
Note that unlike S the result is always an <code><a href="base.html#topic+array">array</a></code>, a 1D
array if one factor is given.
</p>
<p><code>as.table</code> and <code>is.table</code> coerce to and test for contingency
table, respectively.
</p>
<p>The <code>as.data.frame</code> method for objects inheriting from class
<code>"table"</code> can be used to convert the array-based representation
of a contingency table to a data frame containing the classifying
factors and the corresponding entries (the latter as component
named by <code>responseName</code>).  This is the inverse of <code><a href="stats.html#topic+xtabs">xtabs</a></code>.
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tabulate">tabulate</a></code> is the underlying function and allows finer
control.
</p>
<p>Use <code><a href="stats.html#topic+ftable">ftable</a></code> for printing (and more) of
multidimensional tables.  <code><a href="base.html#topic+margin.table">margin.table</a></code>,
<code><a href="base.html#topic+prop.table">prop.table</a></code>, <code><a href="stats.html#topic+addmargins">addmargins</a></code>.
</p>
<p><code><a href="base.html#topic+addNA">addNA</a></code> for constructing factors with <code><a href="base.html#topic+NA">NA</a></code> as
a level.
</p>
<p><code><a href="stats.html#topic+xtabs">xtabs</a></code> for cross tabulation of data frames with a
formula interface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(
  a = c(1, 2, NA, 3),
  b = c("A", NA, "B", "C"),
  c = as.Date(c("2020-01-02", NA, NA, "2020-03-02"))
)
tableNA(x) # entire list
tableNA(x, .list = TRUE) # counts for each
tableNA(x[1], x[2])
tableNA(x[1], x[2], x[3]) # equivalent ot tableNA(x, .list = TRUE)
</code></pre>

<hr>
<h2 id='that'>That</h2><span id='topic+that'></span>

<h3>Description</h3>

<p>Grammatical correctness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>that(x, arr.ind = FALSE, useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="that_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> vector or array.  <code><a href="base.html#topic+NA">NA</a></code>s
are allowed and omitted (treated as if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="that_+3A_arr.ind">arr.ind</code></td>
<td>
<p>logical; should <b>arr</b>ay <b>ind</b>ices be returned
when <code>x</code> is an array?  Anything other than a single true value
is treated as false.</p>
</td></tr>
<tr><td><code id="that_+3A_usenames">useNames</code></td>
<td>
<p>logical indicating if the value of <code>arrayInd()</code>
should have (non-null) dimnames at all.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>fortunes::fortune(175)</code>.
</p>


<h3>Value</h3>

<p>see <code><a href="base.html#topic+which">base::which()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which">base::which()</a></code>
</p>

<hr>
<h2 id='to_boolean'>To Boolean</h2><span id='topic+to_boolean'></span><span id='topic+to_boolean.logical'></span><span id='topic+to_boolean.numeric'></span><span id='topic+to_boolean.character'></span><span id='topic+to_boolean.factor'></span>

<h3>Description</h3>

<p>Convert a vector to boolean/logical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_boolean(x, ...)

## S3 method for class 'logical'
to_boolean(x, ...)

## S3 method for class 'numeric'
to_boolean(x, true = 1L, false = 0L, ...)

## S3 method for class 'character'
to_boolean(x, true = NULL, false = NULL, ...)

## S3 method for class 'factor'
to_boolean(x, true = NULL, false = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_boolean_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="to_boolean_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="to_boolean_+3A_true">true</code></td>
<td>
<p>A vector of values to convert to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="to_boolean_+3A_false">false</code></td>
<td>
<p>A vector of values to convert to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> vector of equal length as <code>x</code>
</p>

<hr>
<h2 id='to_row_names'>To row names</h2><span id='topic+to_row_names'></span>

<h3>Description</h3>

<p>Converts a column to row names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_row_names(data, row_names = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_row_names_+3A_data">data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="to_row_names_+3A_row_names">row_names</code></td>
<td>
<p>The numeric position of the column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(
  a = 1:4,
  b = letters[1:4]
)

to_row_names(x)
to_row_names(x, "b")
</code></pre>

<hr>
<h2 id='todos'>Get TODOs</h2><span id='topic+todos'></span><span id='topic+fixmes'></span>

<h3>Description</h3>

<p>Search for <code style="white-space: pre;">&#8288;#`` TODO&#8288;</code> tags
</p>


<h3>Usage</h3>

<pre><code class='language-R'>todos(
  pattern = NULL,
  path = ".",
  force = getOption("mark.todos.force"),
  ext = getOption("mark.todos.ext"),
  ignore = NULL,
  ...
)

fixmes(
  pattern = NULL,
  path = ".",
  force = getOption("mark.todos.force"),
  ext = getOption("mark.todos.ext"),
  ignore = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="todos_+3A_pattern">pattern</code></td>
<td>
<p>A character string containing a regular expression to filter
for comments after tags; default <code>NULL</code> does not filter</p>
</td></tr>
<tr><td><code id="todos_+3A_path">path</code></td>
<td>
<p>Where to search for the todos.  If this is a directory, paths
matching the <code>ext</code> will be included.  If a file, <code>ext</code> is ignored.</p>
</td></tr>
<tr><td><code id="todos_+3A_force">force</code></td>
<td>
<p>If <code>TRUE</code> will force searching for files in directories that do
not contain an <code>.Rproj</code> file.  This can be controlled with the option
<code>mark.todos.force</code></p>
</td></tr>
<tr><td><code id="todos_+3A_ext">ext</code></td>
<td>
<p>A vector of file extensions to search for todos.  Ignored when
<code>path</code> is not a directory or when <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="todos_+3A_ignore">ignore</code></td>
<td>
<p>A regular expression for files to ignore.  Ignored if <code>path</code> is
not a directory or when <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="todos_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>grep</code> (Except for <code>pattern</code>, <code>x</code>,
and <code>value</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Searches for <code>TODO</code> comments in files.  Extensions with <code>md</code>, <code>Rmd</code>,
and <code>qmd</code> specifically search for a <code style="white-space: pre;">&#8288;&lt;-- TODO * --&gt;&#8288;</code> string, whereas
everything else is found with <code style="white-space: pre;">&#8288;# TODO&#8288;</code>.
</p>


<h3>Value</h3>

<p><code>NULL</code> if none are found, otherwise a <code>data.frame</code> with the line
number, file name, and TODO comment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
file &lt;- tempfile()
writeLines(c(
  "# TODO make x longer",
  "x &lt;- 1:10",
  "length(x)",
  "# TODO add another example",
  "# FIXME This is a fixme"
  ), file)
todos(path = file)
todos("example", path = file)
fixmes(path = file)
file.remove(file)

## End(Not run)
</code></pre>

<hr>
<h2 id='unlist0'>Unlist and squash</h2><span id='topic+unlist0'></span><span id='topic+squash_vec'></span>

<h3>Description</h3>

<p>Unlist without unique names; combine names for unique values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlist0(x)

squash_vec(x, sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlist0_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="unlist0_+3A_sep">sep</code></td>
<td>
<p>A separation for combining names</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+unlist0">unlist0()</a></code> is much like <code><a href="base.html#topic+unlist">unlist()</a></code> expect that name are not made to be
unique.
</p>
</li>
<li> <p><code><a href="#topic+squash_vec">squash_vec()</a></code> works differently
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+unlist0">unlist0()</a></code>: a vector with the possibility of non-unique names
</p>
</li>
<li> <p><code><a href="#topic+squash_vec">squash_vec()</a></code>: A vector of unique values and names
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(a = 1:3, b = 2, c = 2:4)
y &lt;- c(a = 1, b = 1, c = 1, d = 2, e = 3, f = 3)

# unlist0() doesn't force unique names
unlist(x)   # names: a1 a2 a3  b c1 c2 c3
unlist0(x)  # names: a a a  b c c c
unlist0(y)  # no change

# squash_vec() is like the inverse of unlist0() because it works on values
squash_vec(x)
squash_vec(y)
</code></pre>

<hr>
<h2 id='use_author'>Add author to DESCRIPTION</h2><span id='topic+use_author'></span>

<h3>Description</h3>

<p>Adds author to description
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_author(author_info = find_author())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_author_+3A_author_info">author_info</code></td>
<td>
<p>Author information as a named list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only valid for a single author.
</p>


<h3>Value</h3>

<p>None, called for side effects
</p>

<hr>
<h2 id='utils-paste'>Paste combine</h2><span id='topic+utils-paste'></span><span id='topic+paste_c'></span><span id='topic+paste_combine'></span><span id='topic+collapse0'></span>

<h3>Description</h3>

<p>Paste and combine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste_c(x, y, collate = TRUE, sep = "")

paste_combine(..., collate = TRUE, sep = "")

collapse0(..., sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utils-paste_+3A_x">x</code>, <code id="utils-paste_+3A_y">y</code>, <code id="utils-paste_+3A_...">...</code></td>
<td>
<p>Vectors to paste and/or combine</p>
</td></tr>
<tr><td><code id="utils-paste_+3A_collate">collate</code></td>
<td>
<p>Logical; <code>TRUE</code> prints out combinations in order of the first
vector elements then the next; otherwise reversed (see examples)</p>
</td></tr>
<tr><td><code id="utils-paste_+3A_sep">sep</code></td>
<td>
<p>A character string to separate terms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- letters[1:5]
y &lt;- 1:3
z &lt;- month.abb[c(1, 12)]
paste_combine(x, y)
paste_combine(x, y, z)
paste_combine(x, y, z, sep = ".")
paste_combine(x, y, sep = "_")
paste_combine(x, y, collate = FALSE)
collapse0(list(1:3, letters[1:3]), 5:7, letters[5:7])
collapse0(1:3, letters[5:7], sep = "_")
</code></pre>

<hr>
<h2 id='vap'>Vaps!</h2><span id='topic+vap'></span><span id='topic+vap_int'></span><span id='topic+vap_dbl'></span><span id='topic+vap_chr'></span><span id='topic+vap_lgl'></span><span id='topic+vap_cplx'></span><span id='topic+vap_date'></span>

<h3>Description</h3>

<p>Wrappers for vapply
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vap_int(.x, .f, ..., .nm = FALSE)

vap_dbl(.x, .f, ..., .nm = FALSE)

vap_chr(.x, .f, ..., .nm = FALSE)

vap_lgl(.x, .f, ..., .nm = FALSE)

vap_cplx(.x, .f, ..., .nm = FALSE)

vap_date(.x, .f, ..., .nm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vap_+3A_.x">.x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="vap_+3A_.f">.f</code></td>
<td>
<p>A function to apply to each element in vector <code>.x</code></p>
</td></tr>
<tr><td><code id="vap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>.f</code></p>
</td></tr>
<tr><td><code id="vap_+3A_.nm">.nm</code></td>
<td>
<p>Logical, if <code>TRUE</code> returns names of <code>.x</code> (Note: If <code>.x</code> does not
have any names, they will be set to the values)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are simply wrappers for <code><a href="base.html#topic+lapply">base::vapply()</a></code> to shorten lines.
</p>
<p>Each function is designed to use specific vector types:
</p>

<dl>
<dt>vap_int</dt><dd><p>integer</p>
</dd>
<dt>vap_dbl</dt><dd><p>double</p>
</dd>
<dt>vap_chr</dt><dd><p>character</p>
</dd>
<dt>vap_lgl</dt><dd><p>logical</p>
</dd>
<dt>vap_cplx</dt><dd><p>complex</p>
</dd>
<dt>vap_date</dt><dd><p>Date</p>
</dd>
</dl>



<h3>Value</h3>

<p>A vector of type matching the intended value in the function name.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+lapply">base::vapply()</a></code>
</p>

<hr>
<h2 id='vector2df'>Vector to data.frame</h2><span id='topic+vector2df'></span>

<h3>Description</h3>

<p>Transforms a vector (named) to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector2df(x, name = "name", value = "value", show_NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector2df_+3A_x">x</code></td>
<td>
<p>A vector of values.</p>
</td></tr>
<tr><td><code id="vector2df_+3A_name">name</code>, <code id="vector2df_+3A_value">value</code></td>
<td>
<p>Character strings for the name and value columns</p>
</td></tr>
<tr><td><code id="vector2df_+3A_show_na">show_NA</code></td>
<td>
<p>Ignored; will trigger a warning if set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with <code>name</code> (optional) and <code>value</code> columns
</p>

<hr>
<h2 id='with_par'>Temporary plotting</h2><span id='topic+with_par'></span>

<h3>Description</h3>

<p>Reset par() after running
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_par(..., ops = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_par_+3A_...">...</code></td>
<td>
<p>Code to be evaluated</p>
</td></tr>
<tr><td><code id="with_par_+3A_ops">ops</code></td>
<td>
<p>A named list to be passed to <code><a href="graphics.html#topic+par">graphics::par()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the result of <code>...</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with_par(
  plot(lm(Sepal.Length ~ Sepal.Width, data = iris)),
  plot(lm(Petal.Length ~ Petal.Width, data = iris)),
  ops = list(mfrow = c(2, 4))
)
</code></pre>

<hr>
<h2 id='within_call'>Function within</h2><span id='topic+within_call'></span><span id='topic+within_fun'></span><span id='topic+outer_call'></span><span id='topic+outer_fun'></span>

<h3>Description</h3>

<p>Returns the function call you are within
</p>


<h3>Usage</h3>

<pre><code class='language-R'>within_call()

within_fun()

outer_call(n = 0)

outer_fun(n = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="within_call_+3A_n">n</code></td>
<td>
<p>The number of calls to move out from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The string of the call/function
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
