<!DOCTYPE html><html><head><title>Help for package SPARRAfairness</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SPARRAfairness}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ab'><p>ab()</p>
Shorthand to draw a red x-y line</a></li>
<li><a href='#adjusted_fdr'><p>adjusted_fdr</p></a></li>
<li><a href='#adjusted_for'><p>adjusted_for</p></a></li>
<li><a href='#all_data'><p>All data for fairness measures</p></a></li>
<li><a href='#cal_2panel'><p>cal_2panel</p>
Draws calibration curves (with legend) with a second panel underneath showing predicted differences.</a></li>
<li><a href='#counterfactual_yhat'><p>counterfactual_yhat</p></a></li>
<li><a href='#dat2mat'><p>dat2mat</p></a></li>
<li><a href='#decomposition_matrix'><p>Decomposition matrix</p></a></li>
<li><a href='#demographic_parity'><p>demographic_parity</p></a></li>
<li><a href='#drawperson'><p>drawperson</p></a></li>
<li><a href='#drawprop'><p>drawprop</p></a></li>
<li><a href='#getcal'><p>getcal()</p></a></li>
<li><a href='#getprc'><p>getprc()</p></a></li>
<li><a href='#getroc'><p>getroc()</p>
Comprehensive plotting function for receiver-operator characteristic curve. Also calculates AUROC and standard error.</a></li>
<li><a href='#group_fairness'><p>group_fairness</p></a></li>
<li><a href='#groupmetric_2panel'><p>groupmetric_2panel</p>
Draws plots of a group fairness metric with a second panel underneath</a></li>
<li><a href='#integral'><p>integral()</p>
Quick form for trapezoidal integration over range of x</a></li>
<li><a href='#logistic'><p>Logistic</p></a></li>
<li><a href='#logit'><p>Logit</p></a></li>
<li><a href='#phs_colours'><p>phs_colours</p></a></li>
<li><a href='#plot_decomp'><p>plot_decomp</p></a></li>
<li><a href='#plot.sparraCAL'><p>Plot function for class sparraCAL</p></a></li>
<li><a href='#plot.sparraPRC'><p>Plot function for class above</p></a></li>
<li><a href='#plot.sparraROC'><p>Plot function for class sparraROC</p></a></li>
<li><a href='#prc_2panel'><p>prc_2panel</p>
Draws a PRC curve (with legend) with a second panel underneath showing precision difference.</a></li>
<li><a href='#roc_2panel'><p>roc_2panel</p>
Draws a ROC curve (with legend) with a second panel underneath showing sensitivity difference.</a></li>
<li><a href='#sim_pop_data'><p>sim_pop_data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis of Differential Behaviour of SPARRA Score Across
Demographic Groups</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Liley &lt;james.liley@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The SPARRA risk score (Scottish Patients At Risk of admission and Re-Admission) estimates yearly risk of emergency hospital admission using electronic health records on a monthly basis for most of the Scottish population. This package implements a suite of functions used to analyse the behaviour and performance of the score, focusing particularly on differential performance over demographically-defined groups. It includes useful utility functions to plot receiver-operator-characteristic, precision-recall and calibration curves, draw stock human figures, estimate counterfactual quantities without the need to re-compute risk scores, to simulate a semi-realistic dataset.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats, graphics, grDevices, matrixStats,
mvtnorm, cvAUC, ranger</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-20 08:13:46 UTC; vwbw55</td>
</tr>
<tr>
<td>Author:</td>
<td>Ioanna Thoma <a href="https://orcid.org/0000-0001-6928-2198"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Catalina Vallejos <a href="https://orcid.org/0000-0003-3638-1960"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Louis Aslett <a href="https://orcid.org/0000-0003-2211-233X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jill Ireland <a href="https://orcid.org/0009-0009-5324-6630"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Simon Rogers <a href="https://orcid.org/0000-0003-3578-4477"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  James Liley <a href="https://orcid.org/0000-0002-0049-8238"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre,
    aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-20 17:22:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='ab'>ab()
Shorthand to draw a red x-y line</h2><span id='topic+ab'></span>

<h3>Description</h3>

<p>ab()
Shorthand to draw a red x-y line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ab(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ab_+3A_...">...</code></td>
<td>
<p>passed to abline()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, draws a figure
</p>

<hr>
<h2 id='adjusted_fdr'>adjusted_fdr</h2><span id='topic+adjusted_fdr'></span>

<h3>Description</h3>

<p>Estimates false discovery rate P(target=FALSE|score&gt;cutoff,group=g) 'adjusted' for some category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjusted_fdr(
  scores,
  target,
  category,
  group1,
  group2,
  cutoffs = seq(min(scores, na.rm = TRUE), max(scores, na.rm = TRUE), length = 100),
  nboot = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjusted_fdr_+3A_scores">scores</code></td>
<td>
<p>vector of risk scores</p>
</td></tr>
<tr><td><code id="adjusted_fdr_+3A_target">target</code></td>
<td>
<p>vector of values of target (which risk score aims to predict)</p>
</td></tr>
<tr><td><code id="adjusted_fdr_+3A_category">category</code></td>
<td>
<p>vector of categories</p>
</td></tr>
<tr><td><code id="adjusted_fdr_+3A_group1">group1</code></td>
<td>
<p>indices of group 1</p>
</td></tr>
<tr><td><code id="adjusted_fdr_+3A_group2">group2</code></td>
<td>
<p>indices of group 2</p>
</td></tr>
<tr><td><code id="adjusted_fdr_+3A_cutoffs">cutoffs</code></td>
<td>
<p>score cutoffs at which to estimate metric (default 100 evenly-spaced)</p>
</td></tr>
<tr><td><code id="adjusted_fdr_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap samples for standard error</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Namely, calculates
</p>
<p>sum ( P(target=FALSE|score&gt;cutoff,category=c,group=g)P(category=c|score&lt;cutoff) )
</p>
<p>where the sum is over categories c.
</p>


<h3>Value</h3>

<p>matrix of dimension length(cutoffs)x4, with (i,2g-1)th entry the relevant fairness metric for group g at the ith cutoff value and (i,2g)th entry the approximate standard error of the (i,2g-1)th entry
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='adjusted_for'>adjusted_for</h2><span id='topic+adjusted_for'></span>

<h3>Description</h3>

<p>Estimates false omission rate P(target=TRUE|score&lt;=cutoff,group=g) 'adjusted' for some category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjusted_for(
  scores,
  target,
  category,
  group1,
  group2,
  cutoffs = seq(min(scores, na.rm = TRUE), max(scores, na.rm = TRUE), length = 100),
  nboot = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjusted_for_+3A_scores">scores</code></td>
<td>
<p>vector of risk scores</p>
</td></tr>
<tr><td><code id="adjusted_for_+3A_target">target</code></td>
<td>
<p>vector of values of target (which risk score aims to predict)</p>
</td></tr>
<tr><td><code id="adjusted_for_+3A_category">category</code></td>
<td>
<p>vector of categories</p>
</td></tr>
<tr><td><code id="adjusted_for_+3A_group1">group1</code></td>
<td>
<p>indices of group 1</p>
</td></tr>
<tr><td><code id="adjusted_for_+3A_group2">group2</code></td>
<td>
<p>indices of group 2</p>
</td></tr>
<tr><td><code id="adjusted_for_+3A_cutoffs">cutoffs</code></td>
<td>
<p>score cutoffs at which to estimate metric (default 100 evenly-spaced)</p>
</td></tr>
<tr><td><code id="adjusted_for_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap samples for standard error</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Namely, calculates
</p>
<p>sum ( P(target=TRUE|score&lt;=cutoff,category=c,group=g)P(category=c|score&lt;cutoff) )
</p>
<p>where the sum is over categories c.
</p>


<h3>Value</h3>

<p>matrix of dimension length(cutoffs)x4, with (i,2g-1)th entry the relevant fairness metric for group g at the ith cutoff value and (i,2g)th entry the approximate standard error of the (i,2g-1)th entry
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='all_data'>All data for fairness measures</h2><span id='topic+all_data'></span>

<h3>Description</h3>

<p>This object contains all data from analysis of fairness measures in SPARRA v3 and v4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_data
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1260.
</p>

<hr>
<h2 id='cal_2panel'>cal_2panel
Draws calibration curves (with legend) with a second panel underneath showing predicted differences.</h2><span id='topic+cal_2panel'></span>

<h3>Description</h3>

<p>cal_2panel
Draws calibration curves (with legend) with a second panel underneath showing predicted differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_2panel(
  cals,
  labels,
  col = 1:length(cals),
  lty = rep(1, length(col)),
  xy_lty = 2,
  xy_col = phs_colours("phs-magenta"),
  ci_col = rep(NA, length(col)),
  highlight = NULL,
  mar_scale = 1,
  yrange_lower = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cal_2panel_+3A_cals">cals</code></td>
<td>
<p>list of calibration objects, output from getcal().</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_labels">labels</code></td>
<td>
<p>labels to use in legend</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_col">col</code></td>
<td>
<p>line colours</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_lty">lty</code></td>
<td>
<p>line type, defaults to 1</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_xy_lty">xy_lty</code></td>
<td>
<p>line type for x-y line, defaults to 2 (dashed)</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_xy_col">xy_col</code></td>
<td>
<p>line colour for x-y line, defaults to phs-magenta</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_ci_col">ci_col</code></td>
<td>
<p>colours to draw confidence intervals on lower panel; NA to not draw.</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_highlight">highlight</code></td>
<td>
<p>if non-null, highlight a particular value</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_mar_scale">mar_scale</code></td>
<td>
<p>scale bottom and left margins by this amount. Also scales legend.</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_yrange_lower">yrange_lower</code></td>
<td>
<p>y range for lower plot. If NULL, generates automatically</p>
</td></tr>
<tr><td><code id="cal_2panel_+3A_...">...</code></td>
<td>
<p>other parameters passed to legend()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, draws a figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='counterfactual_yhat'>counterfactual_yhat</h2><span id='topic+counterfactual_yhat'></span>

<h3>Description</h3>

<p>Estimation of counterfactual quantities by resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counterfactual_yhat(dat, X, x = NULL, G, g, gdash, excl = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counterfactual_yhat_+3A_dat">dat</code></td>
<td>
<p>data frame containing variables in X, Yhat, G, excl. Variables in U are assumed to be colnames(dat)\(X U Yhat U G U excl)</p>
</td></tr>
<tr><td><code id="counterfactual_yhat_+3A_x">X</code></td>
<td>
<p>set of variables and values on which to 'condition'; essentially we assume that any causal pathway from G to Yhat is through X</p>
</td></tr>
<tr><td><code id="counterfactual_yhat_+3A_x">x</code></td>
<td>
<p>values of variables X on which to condition; can be null in which case we use marginal distribution of X</p>
</td></tr>
<tr><td><code id="counterfactual_yhat_+3A_g">G</code></td>
<td>
<p>grouping variable, usually a sensitive attribute</p>
</td></tr>
<tr><td><code id="counterfactual_yhat_+3A_g">g</code></td>
<td>
<p>conditioned value of g</p>
</td></tr>
<tr><td><code id="counterfactual_yhat_+3A_gdash">gdash</code></td>
<td>
<p>counterfactual value of g</p>
</td></tr>
<tr><td><code id="counterfactual_yhat_+3A_excl">excl</code></td>
<td>
<p>variable names to exclude from U</p>
</td></tr>
<tr><td><code id="counterfactual_yhat_+3A_n">n</code></td>
<td>
<p>number of samples; if NULL return all</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Counterfactual fairness is with respect to the causal graph:
</p>
<p>G &lt;&mdash;&mdash;&mdash;-U
|         /   |
|     /       |
| /           |
VV            V
X &mdash;&mdash;&ndash;&gt;  Yhat
</p>
<p>where
</p>
<p>G=group (usually sensitive attribute);  Yhat=outcome; X=set of variables
through which G can act on Yhat, U=set of background variables;
</p>
<p>We want the counterfactual Yhat_g' &lt;- G |X=x,G=g (or alternatively
Yhat_g' &lt;- G |G=g).
</p>
<p>This can be interpreted as:
<code style="white-space: pre;">&#8288;the distribution of values of Yhat amongst indivdiduals whose values of U  are distributed as though they were in group G=g (and, optionally, had  values X=x, but whose value of G is g'&#8288;</code>
</p>
<p>Essentially, comparison of the counterfactual quantity above to the
conditional Yhat|G=g isolates the difference in Yhat due to the effect of
G on Yhat through X, removing any effect due to different distributions of
U due to different values of G.
</p>
<p>To estimate Y'=Yhat_g' &lt;- G | G=g, we need to
</p>

<ol>
<li><p> Compute U'~(U|G=g)
</p>
</li>
<li><p> Compute the distribution X' as X'~(X|U~U',G=g')
</p>
</li>
<li><p> Sample Y'~(Yhat|X~X',U~U')
</p>
</li></ol>

<p>To estimate Y'=Yhat_g' &lt;- G |X=x, G=g, we need to
</p>

<ol>
<li><p> Compute U'~(U|G=g,X=x)
</p>
</li>
<li><p> Compute the distribution X' as X'~(X|U~U',G=g')
</p>
</li>
<li><p> Sample Y'~(Yhat|X~X',U~U')
</p>
</li></ol>

<p>This function approximates this samplying procedure as follows
</p>

<ol>
<li><p> Look at individuals with G=g (and optionally X=x)
</p>
</li>
<li><p> Find the values of U for these individuals
</p>
</li>
<li><p> Find a second set of individuals with the same values of U but for whom G=g'
</p>
</li>
<li><p> Return the indices of these individuals
</p>
</li></ol>

<p>The values of Yhat for these individuals constitute a sample from the
desired counterfactual.
</p>


<h3>Value</h3>

<p>indices representing sample(s) from counterfactual  Yhat_g' &lt;- G |X=x,G=g
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(23173)
N=10000

# Background variables sampler
background_U=function(n) runif(n) # U~U(0,1)

# Structural equations
struct_G=function(u,n) rbinom(n,1,prob=u) # G|U=u ~ Bern(u)
struct_X=function(u,g,n) rbinom(n,1,prob=u*(0.5 + 0.5*g)) # X|U=u,G=g ~ Bern(u(1+g)/2)
struct_Yhat=function(u,x,n) (runif(n,0,x) + runif(n,0,u))/2 # Yhat|X,N ~ (U(0,X) + U(0,U))/2

# To see that the counterfactual 'isolates' the difference in Yhat due to the 
#  causal pathway from G to Yhat through X, change the definition of struct_G to
#  
#  struct_G=function(u,n) rbinom(n,1,prob=1/2) # G|U=u ~ Bern(1/2)
#
# so the posterior of U|G=g does not depend on g. Note that, with this definition, the 
#  counterfactual Yhat_{G&lt;01}|G=1 coincides with the conditional Yhat|G=0, since
#  the counterfactual G&lt;-1 is equivalent to just conditioning on G=1.
#
# By contrast, if we change struct_G back to its original definition, but 
#  change the definition of struct_Yhat to
#  
#  struct_Yhat=function(u,x,n) (runif(n,0,1) + runif(n,0,u))/2 # Yhat|X,N ~ (U(0,1) + U(0,U))/2
#
# so Yhat depends on G only through the change in posterior of U from changing g, 
#  the counterfactual Yhat_{G&lt;01}|G=1 coincides with the conditional Yhat|G=1.


# Sample from complete causal model
U=background_U(N)
G=struct_G(U,N)
X=struct_X(U,G,N)
Yhat=struct_Yhat(U,X,N)
dat=data.frame(U,G,X,Yhat)


# True counterfactual Yhat_{G &lt;- 0}|G=1
w1=which(dat$G==1)
n1=length(w1)
UG1=dat$U[w1] # This is U|G=1
XG1=struct_X(UG1,rep(0,n1),n1)
YhatG1=struct_Yhat(UG1,XG1,n1)

# Estimated counterfactual Yhat_{G &lt;- 0}|G=1
ind_G1=counterfactual_yhat(dat,X="X",G="G",g = 1, gdash = 0)
YhatG1_resample=dat$Yhat[ind_G1]



# True counterfactual Yhat_{G &lt;- 0}|G=1,X=1
w11=which(dat$G==1 &amp; dat$X==1)
n11=length(w11)
UG1X1=dat$U[w11] # This is U|G=1,X=1
XG1X1=struct_X(UG1X1,rep(0,n11),n11)
YhatG1X1=struct_Yhat(UG1X1,XG1X1,n11)

# Estimated counterfactual Yhat_{G &lt;- 0}|G=1
ind_G1X1=counterfactual_yhat(dat,X="X",G="G",g = 1, gdash = 0,x=1)
YhatG1X1_resample=dat$Yhat[ind_G1X1]




# Compare CDFs
x=seq(0,1,length=1000)
oldpar = par(mfrow=c(1,2))

plot(0,type="n",xlim=c(0,1),ylim=c(0,1),xlab="Value",
     ylab=expression(paste("Prop. ",hat('Y')," &lt; x")))
lines(x,ecdf(dat$Yhat)(x),col="black") # Unconditional CDF of Yhat
lines(x,ecdf(dat$Yhat[which(dat$G==1)])(x),col="red") # Yhat|G=1
lines(x,ecdf(dat$Yhat[which(dat$G==0)])(x),col="blue") # Yhat|G=0

# True counterfactual Yhat_{G &lt;- 0}|G=1
lines(x,ecdf(YhatG1)(x),col="blue",lty=2) 

# Estimated counterfactual Yhat_{G &lt;- 0}|G=1
lines(x,ecdf(YhatG1_resample)(x),col="blue",lty=3) 

legend("bottomright",
       c(expression(paste(hat('Y'))),
         expression(paste(hat('Y'),"|G=1")),
         expression(paste(hat('Y'),"|G=0")),
         expression(paste(hat(Y)[G %&lt;-% 0],"|G=1 (true)")),
         expression(paste(hat(Y)[G %&lt;-% 0],"|G=1 (est.)"))),
       col=c("black","red","blue","blue","blue"),
       lty=c(1,1,1,2,3),
       cex=0.5)



plot(0,type="n",xlim=c(0,1),ylim=c(0,1),xlab="Value",
     ylab=expression(paste("Prop. ",hat('Y')," &lt; x")))
lines(x,ecdf(dat$Yhat[which(dat$X==1)])(x),col="black") # CDF of Yhat|X=1
lines(x,ecdf(dat$Yhat[which(dat$G==1 &amp; dat$X==1)])(x),col="red") # Yhat|G=1,X=1
lines(x,ecdf(dat$Yhat[which(dat$G==0 &amp; dat$X==1)])(x),col="blue") # Yhat|G=0,X=1

# True counterfactual Yhat_{G &lt;- 0}|G=1,X=1
lines(x,ecdf(YhatG1X1)(x),col="blue",lty=2) 

# Estimated counterfactual Yhat_{G &lt;- 0}|G=1,X=1
lines(x,ecdf(YhatG1X1_resample)(x),col="blue",lty=3) 

legend("bottomright",
       c(expression(paste(hat('Y|X=1'))),
         expression(paste(hat('Y'),"|G=1,X=1")),
         expression(paste(hat('Y'),"|G=0,X=1")),
         expression(paste(hat(Y)[G %&lt;-% 0],"|G=1,X=1 (true)")),
         expression(paste(hat(Y)[G %&lt;-% 0],"|G=1,X=1 (est.)"))),
       col=c("black","red","blue","blue","blue"),
       lty=c(1,1,1,2,3),
       cex=0.5)

# In both plots, the estimated counterfactual CDF closely matches the CDF of the
#  true counterfactual.

# Restore parameters
par(oldpar)

</code></pre>

<hr>
<h2 id='dat2mat'>dat2mat</h2><span id='topic+dat2mat'></span>

<h3>Description</h3>

<p>Generates matrices for decomposition of admission type which can be used in <code>plot_decomp</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat2mat(dat, score, group1, group2, nquant = 20, cats = unique(dat$reason))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dat2mat_+3A_dat">dat</code></td>
<td>
<p>data frame with population data, such as output from sim_pop_data. Must include a column <code>reason</code></p>
</td></tr>
<tr><td><code id="dat2mat_+3A_score">score</code></td>
<td>
<p>risk scores corresponding to <code>dat</code></p>
</td></tr>
<tr><td><code id="dat2mat_+3A_group1">group1</code></td>
<td>
<p>indices for group 1</p>
</td></tr>
<tr><td><code id="dat2mat_+3A_group2">group2</code></td>
<td>
<p>indices for group 2</p>
</td></tr>
<tr><td><code id="dat2mat_+3A_nquant">nquant</code></td>
<td>
<p>number of quantiles of code to use; default 20</p>
</td></tr>
<tr><td><code id="dat2mat_+3A_cats">cats</code></td>
<td>
<p>vector of strings giving names of admission categories; default the unique values in dat$reason. Can include NAs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates two matrices with the following specifications:
Each matrix corresponds to one group
Columns are named with the admission types to be plotted. Any admission
types including the string 'Died' are counted as deaths
If the matrix has N rows, these are interpreted as corresponding to N
score quantiles
The (i,j)th entry of the matrix is the number of people admitted for
reason i with a score greater than or equal to (j-1)/N and less than (j/N)
who are in that group
</p>


<h3>Value</h3>

<p>list with two objects <code>matrix1</code> and <code>matrix2</code> giving output matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='decomposition_matrix'>Decomposition matrix</h2><span id='topic+decomposition_matrix'></span>

<h3>Description</h3>

<p>Matrix giving frequency of admission types for various groups at various score thresholds. Row names are of the form vX_Y_qZ, where X is version (3 or 4), Y is cohort (e.g., all, over 65, island postcode) and Z is quantile (1-20) of score. Column names are cause of admission or cause of death.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposition_matrix
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 520 rows and 41 columns.
</p>

<hr>
<h2 id='demographic_parity'>demographic_parity</h2><span id='topic+demographic_parity'></span>

<h3>Description</h3>

<p>Estimates demographic parity for a risk score (essentially cumulative distribution function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demographic_parity(
  scores,
  group1,
  group2,
  cutoffs = seq(min(scores, na.rm = TRUE), max(scores, na.rm = TRUE), length = 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demographic_parity_+3A_scores">scores</code></td>
<td>
<p>vector of risk scores</p>
</td></tr>
<tr><td><code id="demographic_parity_+3A_group1">group1</code></td>
<td>
<p>indices of group 1</p>
</td></tr>
<tr><td><code id="demographic_parity_+3A_group2">group2</code></td>
<td>
<p>indices of group 2</p>
</td></tr>
<tr><td><code id="demographic_parity_+3A_cutoffs">cutoffs</code></td>
<td>
<p>score cutoffs at which to estimate DP (default 100 evenly-spaced)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of dimension length(cutoffs)x4, with (i,2g-1)th entry the proportion of scores in group g which are less than or equal to the ith cutoff value and (i,2g)th entry the approximate standard error of the (i,2g-1)th entry
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='drawperson'>drawperson</h2><span id='topic+drawperson'></span>

<h3>Description</h3>

<p>Draws a simple stock image of a person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawperson(
  xloc = 0,
  yloc = 0,
  scale = 1,
  headsize = 0.16,
  headangle = pi/8,
  headloc = 0.5,
  necklength = 0.1,
  shoulderwidth = 0.1,
  shouldersize = 0.05,
  armlength = 0.4,
  armangle = 7 * pi/8,
  armwidth = 0.08,
  leglength = 0.5,
  legangle = 9 * pi/10,
  legwidth = 0.15,
  torsolength = 0.4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawperson_+3A_xloc">xloc</code></td>
<td>
<p>x-axis offset from origin</p>
</td></tr>
<tr><td><code id="drawperson_+3A_yloc">yloc</code></td>
<td>
<p>y-axis offset from origin</p>
</td></tr>
<tr><td><code id="drawperson_+3A_scale">scale</code></td>
<td>
<p>scale upwards from 1x1 box</p>
</td></tr>
<tr><td><code id="drawperson_+3A_headsize">headsize</code></td>
<td>
<p>head size</p>
</td></tr>
<tr><td><code id="drawperson_+3A_headangle">headangle</code></td>
<td>
<p>half angle of neck in terms of head</p>
</td></tr>
<tr><td><code id="drawperson_+3A_headloc">headloc</code></td>
<td>
<p>location of centre of head relative to origin with scale 1</p>
</td></tr>
<tr><td><code id="drawperson_+3A_necklength">necklength</code></td>
<td>
<p>neck length</p>
</td></tr>
<tr><td><code id="drawperson_+3A_shoulderwidth">shoulderwidth</code></td>
<td>
<p>shoulder width</p>
</td></tr>
<tr><td><code id="drawperson_+3A_shouldersize">shouldersize</code></td>
<td>
<p>size radius of arc for shoulder</p>
</td></tr>
<tr><td><code id="drawperson_+3A_armlength">armlength</code></td>
<td>
<p>arm length</p>
</td></tr>
<tr><td><code id="drawperson_+3A_armangle">armangle</code></td>
<td>
<p>angle of arm from horizontal</p>
</td></tr>
<tr><td><code id="drawperson_+3A_armwidth">armwidth</code></td>
<td>
<p>width of arm</p>
</td></tr>
<tr><td><code id="drawperson_+3A_leglength">leglength</code></td>
<td>
<p>leg length</p>
</td></tr>
<tr><td><code id="drawperson_+3A_legangle">legangle</code></td>
<td>
<p>angle of leg from horizontal</p>
</td></tr>
<tr><td><code id="drawperson_+3A_legwidth">legwidth</code></td>
<td>
<p>width of leg</p>
</td></tr>
<tr><td><code id="drawperson_+3A_torsolength">torsolength</code></td>
<td>
<p>length of torso</p>
</td></tr>
<tr><td><code id="drawperson_+3A_...">...</code></td>
<td>
<p>other parameters passed to polygon()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a figure at a particular location. With defaults, has centre at origin and fits in 1x1 box.
</p>
<p>Dimensions customisable
</p>


<h3>Value</h3>

<p>invisibly returns co-ordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(0,xlim=c(-1,1),ylim=c(-1,1),type="n")
drawperson(0,0,1,col="yellow",border="red",lwd=3,lty=2)
</code></pre>

<hr>
<h2 id='drawprop'>drawprop</h2><span id='topic+drawprop'></span>

<h3>Description</h3>

<p>Illustrates a proportion as a set of people who are blue rather than red.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawprop(prop, ci, nxy = 10, col1 = "maroon", col2 = "lightblue", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawprop_+3A_prop">prop</code></td>
<td>
<p>the proportion to illustrate</p>
</td></tr>
<tr><td><code id="drawprop_+3A_ci">ci</code></td>
<td>
<p>half the 95% CI width of the proportion.</p>
</td></tr>
<tr><td><code id="drawprop_+3A_nxy">nxy</code></td>
<td>
<p>illustrate on an n x n grid</p>
</td></tr>
<tr><td><code id="drawprop_+3A_col1">col1</code></td>
<td>
<p>colour to put the 'in' proportion</p>
</td></tr>
<tr><td><code id="drawprop_+3A_col2">col2</code></td>
<td>
<p>the other colour</p>
</td></tr>
<tr><td><code id="drawprop_+3A_...">...</code></td>
<td>
<p>passed to 'plot'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Why anyone would want to think about a proportion this way is beyond the understanding of the authors, but the people have spoken.
</p>


<h3>Value</h3>

<p>No return value, draws a figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='getcal'>getcal()</h2><span id='topic+getcal'></span>

<h3>Description</h3>

<p>Produces a set of points for a calibration plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getcal(
  y,
  ypred,
  n = 10,
  kernel = FALSE,
  kernel_sd = 0.05,
  alpha = 0.05,
  c0 = 0,
  c2 = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getcal_+3A_y">y</code></td>
<td>
<p>class labels, 0/1 or logical</p>
</td></tr>
<tr><td><code id="getcal_+3A_ypred">ypred</code></td>
<td>
<p>predictions Pr(Y=1), numeric vector</p>
</td></tr>
<tr><td><code id="getcal_+3A_n">n</code></td>
<td>
<p>number of subintervals/points</p>
</td></tr>
<tr><td><code id="getcal_+3A_kernel">kernel</code></td>
<td>
<p>set to TRUE to use kernel method</p>
</td></tr>
<tr><td><code id="getcal_+3A_kernel_sd">kernel_sd</code></td>
<td>
<p>kernel width for kernel method; see above</p>
</td></tr>
<tr><td><code id="getcal_+3A_alpha">alpha</code></td>
<td>
<p>return a pointwise confidence envolope for conservative 1-alpha confidence interval</p>
</td></tr>
<tr><td><code id="getcal_+3A_c0">c0</code></td>
<td>
<p>for computing maximum bias; assume true covariance function is of the form a0+ a1x + a2x^2, with |a0|&lt;c0, |a2|&lt;c2 (c1 does not matter)</p>
</td></tr>
<tr><td><code id="getcal_+3A_c2">c2</code></td>
<td>
<p>for computing maximum bias; assume true covariance function is of the form a0+ a1x + a2x^2, with |a0|&lt;c0, |a2|&lt;c2 (c1 does not matter)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses either a binning method or a kernel method to determine height of points.
</p>
<p>In both methods, considers n equally spaced subintervals of (0,1)
</p>


<h3>Value</h3>

<p>a list with components x (expected calibration), y (observed calibration), n (number of samples in bins, if relevant), lower/upper (confidence interval on y)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='getprc'>getprc()</h2><span id='topic+getprc'></span>

<h3>Description</h3>

<p>Comprehensive plotting function for precision-recall curve. Also calculates AUPRC and standard error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getprc(y, ypred, cv = NULL, res = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getprc_+3A_y">y</code></td>
<td>
<p>class labels, 0/1 or logical</p>
</td></tr>
<tr><td><code id="getprc_+3A_ypred">ypred</code></td>
<td>
<p>predictions Pr(Y=1), numeric vector</p>
</td></tr>
<tr><td><code id="getprc_+3A_cv">cv</code></td>
<td>
<p>cross-validation fold assignments, if relevant. Changes estimate of standard error.</p>
</td></tr>
<tr><td><code id="getprc_+3A_res">res</code></td>
<td>
<p>resolution. Returns this many equally-spaced points along the curve. Set res to null to return all points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rather than returning points corresponding to every cutoff, only returns a representative sample of equally-spaced points along the curve.
</p>
<p>Does not plot anything. Object can be plotted in a default way.
</p>


<h3>Value</h3>

<p>list containing: ppv, ppv for res points in every cv fold; sens, sensitivity for res points in every cv fold; auc, areas under the curve for each fold and average (note length is 1 greater than number of CV folds); se, standard error for AUC in each fold and standard error for average auc (note length is 1 greater than number of CV folds)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='getroc'>getroc()
Comprehensive plotting function for receiver-operator characteristic curve. Also calculates AUROC and standard error.</h2><span id='topic+getroc'></span>

<h3>Description</h3>

<p>Rather than returning points corresponding to every cutoff, only returns a representative sample of equally-spaced points along the curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getroc(y, ypred, cv = NULL, res = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getroc_+3A_y">y</code></td>
<td>
<p>class labels, 0/1 or logical</p>
</td></tr>
<tr><td><code id="getroc_+3A_ypred">ypred</code></td>
<td>
<p>predictions Pr(Y=1), numeric vector</p>
</td></tr>
<tr><td><code id="getroc_+3A_cv">cv</code></td>
<td>
<p>cross-validation fold assignments, if relevant. Changes estimate of standard error.</p>
</td></tr>
<tr><td><code id="getroc_+3A_res">res</code></td>
<td>
<p>resolution. Returns this many equally-spaced points along the curve. Set res to null to return all points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SE of AUROC with no CV structure is from Hanley and McNeil 1982. SE of AUROC with CV folds is from LeDell et al 2012
</p>
<p>Does not plot anything. Object can be plotted in a default way.
</p>


<h3>Value</h3>

<p>list containing: spec, specificity for res points in every cv fold; sens, sensitivity for res points in every cv fold; auc, areas under the curve for each fold and average (note length is 1 greater than number of CV folds); se, standard error for AUC in each fold and standard error for average auc (note length is 1 greater than number of CV folds)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='group_fairness'>group_fairness</h2><span id='topic+group_fairness'></span>

<h3>Description</h3>

<p>Estimates group fairness metric according to a specification vector of the form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_fairness(
  specs,
  scores,
  target,
  group1,
  group2,
  cutoffs = seq(min(scores, na.rm = TRUE), max(scores, na.rm = TRUE), length = 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_fairness_+3A_specs">specs</code></td>
<td>
<p>specification vector; see description</p>
</td></tr>
<tr><td><code id="group_fairness_+3A_scores">scores</code></td>
<td>
<p>vector of risk scores</p>
</td></tr>
<tr><td><code id="group_fairness_+3A_target">target</code></td>
<td>
<p>vector of values of target (which risk score aims to predict)</p>
</td></tr>
<tr><td><code id="group_fairness_+3A_group1">group1</code></td>
<td>
<p>indices of group 1</p>
</td></tr>
<tr><td><code id="group_fairness_+3A_group2">group2</code></td>
<td>
<p>indices of group 2</p>
</td></tr>
<tr><td><code id="group_fairness_+3A_cutoffs">cutoffs</code></td>
<td>
<p>score cutoffs at which to estimate metric (default 100 evenly-spaced)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>c(A1,B1,C1,A2,B2,C2)
</p>
<p>encoding a probability
</p>
<p>P(A1,B1,C1|A2,B2,C2)
</p>
<p>where
</p>
<p>A1/A2 are events coded by 1:'score&gt;= cutoff'; 0: 'score&lt;cutoff' and NA: 1/TRUE
B1/B2 are events coded by 1:'target=TRUE'; 0: 'target=FALSE' and NA: 1/TRUE
C1/C2 are events coded by 1:'group=g'; and NA: 1/TRUE
</p>
<p>For example, specs=c(NA,1,NA,0,NA,1) would encode false omission rate:
</p>
<p>P(target=TRUE|score&lt;cutoff,group=g)
</p>


<h3>Value</h3>

<p>matrix of dimension length(cutoffs)x4, with (i,2g-1)th entry the relevant fairness metric for group g at the ith cutoff value and (i,2g)th entry the approximate standard error of the (i,2g-1)th entry
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='groupmetric_2panel'>groupmetric_2panel
Draws plots of a group fairness metric with a second panel underneath</h2><span id='topic+groupmetric_2panel'></span>

<h3>Description</h3>

<p>groupmetric_2panel
Draws plots of a group fairness metric with a second panel underneath
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupmetric_2panel(
  objs,
  labels,
  col = 1:length(objs),
  lty = rep(1, length(col)),
  yrange = NULL,
  ci_col = 1:length(objs),
  highlight = NULL,
  logscale = FALSE,
  mar_scale = 1,
  lpos = NULL,
  yrange_lower = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupmetric_2panel_+3A_objs">objs</code></td>
<td>
<p>list of fairness objects. Each should contain sub-objects 'x', 'y' and 'ci', which specify x and y values and half-widths of confidence intervals around y.</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_labels">labels</code></td>
<td>
<p>labels to use in legend</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_col">col</code></td>
<td>
<p>line colours</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_lty">lty</code></td>
<td>
<p>line type, defaults to 1</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_yrange">yrange</code></td>
<td>
<p>limit of y axis; defaults to 0,1</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_ci_col">ci_col</code></td>
<td>
<p>confidence envelope colours. These will be transparent.</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_highlight">highlight</code></td>
<td>
<p>if non-null, draw a point at a particular cutoff</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_logscale">logscale</code></td>
<td>
<p>if TRUE, draw with log-scale.</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_mar_scale">mar_scale</code></td>
<td>
<p>scale bottom and left margins by this amount. Also scales legend.</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_lpos">lpos</code></td>
<td>
<p>legend position</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_yrange_lower">yrange_lower</code></td>
<td>
<p>y range for lower plot. If NULL, generates automatically</p>
</td></tr>
<tr><td><code id="groupmetric_2panel_+3A_...">...</code></td>
<td>
<p>other parameters passed to legend()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, draws a figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='integral'>integral()
Quick form for trapezoidal integration over range of x</h2><span id='topic+integral'></span>

<h3>Description</h3>

<p>integral()
Quick form for trapezoidal integration over range of x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integral(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral_+3A_x">x</code></td>
<td>
<p>x co-ordinates, or nx2 matrix of points</p>
</td></tr>
<tr><td><code id="integral_+3A_y">y</code></td>
<td>
<p>y co-ordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>trapezoidal estimate of integral of the xth value of y over range of x.
</p>

<hr>
<h2 id='logistic'>Logistic</h2><span id='topic+logistic'></span>

<h3>Description</h3>

<p>Logistic function: 1/(1+exp(-x))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_+3A_x">x</code></td>
<td>
<p>argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of logistic(x)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plot
x=seq(-5,5,length=1000)
plot(x,logistic(x),type="l")
</code></pre>

<hr>
<h2 id='logit'>Logit</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Logit function: -log((1/x)-1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of logit(x); na if x is outside (0,1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plot
x=seq(0,1,length=100)
plot(x,logit(x),type="l")

# Logit and logistic are inverses
x=seq(-5,5,length=1000)
plot(x,logit(logistic(x)),type="l")
</code></pre>

<hr>
<h2 id='phs_colours'>phs_colours</h2><span id='topic+phs_colours'></span>

<h3>Description</h3>

<p>Copied from github, &quot;Public-Health-Scotland/phsstyles&quot;. Public Health Scotland
colour scheme. Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phs_colours(colourname = NULL, keep_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phs_colours_+3A_colourname">colourname</code></td>
<td>
<p>name of colour; usually something like phs-blue. If NULL returns all colours.</p>
</td></tr>
<tr><td><code id="phs_colours_+3A_keep_names">keep_names</code></td>
<td>
<p>keep names of colours in return list. Defaults to false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of colours, optionally with names.
</p>

<hr>
<h2 id='plot_decomp'>plot_decomp</h2><span id='topic+plot_decomp'></span>

<h3>Description</h3>

<p>Plots a bar graph of decomposition of FORP by cause of admission
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_decomp(
  decomp1,
  decomp2,
  threshold,
  labels,
  inc_died = TRUE,
  mar_scale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_decomp_+3A_decomp1">decomp1</code></td>
<td>
<p>matrix for first group; see specification in description</p>
</td></tr>
<tr><td><code id="plot_decomp_+3A_decomp2">decomp2</code></td>
<td>
<p>matrix for second group; see specification in description</p>
</td></tr>
<tr><td><code id="plot_decomp_+3A_threshold">threshold</code></td>
<td>
<p>score threshold to plot (between 0 and 1)</p>
</td></tr>
<tr><td><code id="plot_decomp_+3A_labels">labels</code></td>
<td>
<p>labels for group 1 and group 2</p>
</td></tr>
<tr><td><code id="plot_decomp_+3A_inc_died">inc_died</code></td>
<td>
<p>set to TRUE to include a second panel showing 'death' type admissions</p>
</td></tr>
<tr><td><code id="plot_decomp_+3A_mar_scale">mar_scale</code></td>
<td>
<p>scale margins by this amount. Also scales legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes two matrices as input with the following specifications:
Each matrix corresponds to one group
Columns are named with the admission types to be plotted. Any admission
types including the string 'Died' are counted as deaths
If the matrix has N rows, these are interpreted as corresponding to N
score quantiles
The (i,j)th entry of the matrix is the number of people admitted for
reason i with a score greater than or equal to (j-1)/N and less than (j/N)
who are in that group
</p>


<h3>Value</h3>

<p>No return value, draws a figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See vignette
</code></pre>

<hr>
<h2 id='plot.sparraCAL'>Plot function for class sparraCAL</h2><span id='topic+plot.sparraCAL'></span>

<h3>Description</h3>

<p>Plot function for class sparraCAL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparraCAL'
plot(
  x,
  cols = rep(phs_colours("phs-blue"), dim(x$sens)[1]),
  add = FALSE,
  add_xy_line = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sparraCAL_+3A_x">x</code></td>
<td>
<p>output from getcal()</p>
</td></tr>
<tr><td><code id="plot.sparraCAL_+3A_cols">cols</code></td>
<td>
<p>colour to draw lines</p>
</td></tr>
<tr><td><code id="plot.sparraCAL_+3A_add">add</code></td>
<td>
<p>set to FALSE to add to existing plot</p>
</td></tr>
<tr><td><code id="plot.sparraCAL_+3A_add_xy_line">add_xy_line</code></td>
<td>
<p>set to TRUE to draw an X-Y reference line.</p>
</td></tr>
<tr><td><code id="plot.sparraCAL_+3A_...">...</code></td>
<td>
<p>passed to lines()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, draws a figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='plot.sparraPRC'>Plot function for class above</h2><span id='topic+plot.sparraPRC'></span>

<h3>Description</h3>

<p>Plot function for class above
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparraPRC'
plot(
  x,
  addauc = FALSE,
  cols = rep(phs_colours("phs-blue"), dim(x$sens)[1]),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sparraPRC_+3A_x">x</code></td>
<td>
<p>output from getprc()</p>
</td></tr>
<tr><td><code id="plot.sparraPRC_+3A_addauc">addauc</code></td>
<td>
<p>set to TRUE to add text to the plot showing the (mean) AUC and SE.</p>
</td></tr>
<tr><td><code id="plot.sparraPRC_+3A_cols">cols</code></td>
<td>
<p>colour to draw lines</p>
</td></tr>
<tr><td><code id="plot.sparraPRC_+3A_...">...</code></td>
<td>
<p>passed to plot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, draws a figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='plot.sparraROC'>Plot function for class sparraROC</h2><span id='topic+plot.sparraROC'></span>

<h3>Description</h3>

<p>Plot function for class sparraROC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparraROC'
plot(
  x,
  addauc = FALSE,
  cols = rep(phs_colours("phs-blue"), dim(x$sens)[1]),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sparraROC_+3A_x">x</code></td>
<td>
<p>output from getroc()</p>
</td></tr>
<tr><td><code id="plot.sparraROC_+3A_addauc">addauc</code></td>
<td>
<p>set to TRUE to add text to the plot showing the (mean) AUC and SE.</p>
</td></tr>
<tr><td><code id="plot.sparraROC_+3A_cols">cols</code></td>
<td>
<p>colour to draw lines</p>
</td></tr>
<tr><td><code id="plot.sparraROC_+3A_...">...</code></td>
<td>
<p>passed to plot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, draws a figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='prc_2panel'>prc_2panel
Draws a PRC curve (with legend) with a second panel underneath showing precision difference.</h2><span id='topic+prc_2panel'></span>

<h3>Description</h3>

<p>prc_2panel
Draws a PRC curve (with legend) with a second panel underneath showing precision difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prc_2panel(
  prcs,
  labels,
  col = 1:length(prcs),
  lty = rep(1, length(col)),
  highlight = NULL,
  mar_scale = 1,
  yrange_lower = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prc_2panel_+3A_prcs">prcs</code></td>
<td>
<p>list of sparraPRC objects. If of length 1, splits into folds</p>
</td></tr>
<tr><td><code id="prc_2panel_+3A_labels">labels</code></td>
<td>
<p>labels to use in legend</p>
</td></tr>
<tr><td><code id="prc_2panel_+3A_col">col</code></td>
<td>
<p>line colours</p>
</td></tr>
<tr><td><code id="prc_2panel_+3A_lty">lty</code></td>
<td>
<p>line type, defaults to 1</p>
</td></tr>
<tr><td><code id="prc_2panel_+3A_highlight">highlight</code></td>
<td>
<p>if non-null, draw a point at a particular cutoff</p>
</td></tr>
<tr><td><code id="prc_2panel_+3A_mar_scale">mar_scale</code></td>
<td>
<p>scale bottom and left margins by this amount. Also scales legend.</p>
</td></tr>
<tr><td><code id="prc_2panel_+3A_yrange_lower">yrange_lower</code></td>
<td>
<p>y range for lower plot. If NULL, generates automatically</p>
</td></tr>
<tr><td><code id="prc_2panel_+3A_...">...</code></td>
<td>
<p>other parameters passed to legend()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, draws a figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='roc_2panel'>roc_2panel
Draws a ROC curve (with legend) with a second panel underneath showing sensitivity difference.</h2><span id='topic+roc_2panel'></span>

<h3>Description</h3>

<p>roc_2panel
Draws a ROC curve (with legend) with a second panel underneath showing sensitivity difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc_2panel(
  rocs,
  labels,
  col = 1:length(rocs),
  lty = rep(1, length(col)),
  xy_lty = 2,
  xy_col = phs_colours("phs-magenta"),
  highlight = NULL,
  mar_scale = 1,
  yrange_lower = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc_2panel_+3A_rocs">rocs</code></td>
<td>
<p>list of sparraROC objects (if one object, plots folds separately)</p>
</td></tr>
<tr><td><code id="roc_2panel_+3A_labels">labels</code></td>
<td>
<p>labels to use in legend</p>
</td></tr>
<tr><td><code id="roc_2panel_+3A_col">col</code></td>
<td>
<p>line colours</p>
</td></tr>
<tr><td><code id="roc_2panel_+3A_lty">lty</code></td>
<td>
<p>line type, defaults to 1</p>
</td></tr>
<tr><td><code id="roc_2panel_+3A_xy_lty">xy_lty</code></td>
<td>
<p>line type for x-y line, defaults to 2 (dashed)</p>
</td></tr>
<tr><td><code id="roc_2panel_+3A_xy_col">xy_col</code></td>
<td>
<p>line colour for x-y line, defaults to red</p>
</td></tr>
<tr><td><code id="roc_2panel_+3A_highlight">highlight</code></td>
<td>
<p>if non-null, add a point at this cutoff</p>
</td></tr>
<tr><td><code id="roc_2panel_+3A_mar_scale">mar_scale</code></td>
<td>
<p>scale bottom and left margins by this amount. Also scales legend.</p>
</td></tr>
<tr><td><code id="roc_2panel_+3A_yrange_lower">yrange_lower</code></td>
<td>
<p>y range for lower plot. If NULL, generates automatically</p>
</td></tr>
<tr><td><code id="roc_2panel_+3A_...">...</code></td>
<td>
<p>other parameters passed to legend()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, draws a figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette
</code></pre>

<hr>
<h2 id='sim_pop_data'>sim_pop_data</h2><span id='topic+sim_pop_data'></span>

<h3>Description</h3>

<p>Simulates population data with a reasonably realistic joint distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_pop_data(
  npop,
  coef_adjust = 4,
  offset = 1,
  vcor = NULL,
  coefs = c(2, 1, 0, 5, 3, 0, 0),
  seed = 12345,
  incl_id = TRUE,
  incl_reason = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_pop_data_+3A_npop">npop</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="sim_pop_data_+3A_coef_adjust">coef_adjust</code></td>
<td>
<p>inverse scale for all (true) coefficients (default 4): lower means that hospital admissions are more predictable from covariates.</p>
</td></tr>
<tr><td><code id="sim_pop_data_+3A_offset">offset</code></td>
<td>
<p>offset for logistic model (default 1): higher means a lower overall prevalence of admission</p>
</td></tr>
<tr><td><code id="sim_pop_data_+3A_vcor">vcor</code></td>
<td>
<p>a valid 5x5 correlation matrix (default NULL), giving correlation between variables. If 'NULL', values roughly represents realistic data.</p>
</td></tr>
<tr><td><code id="sim_pop_data_+3A_coefs">coefs</code></td>
<td>
<p>coefficients of age, male sex, non-white ethnicity, number of previous admissions, and deprivation decile on hospital admissions, Default (2,1,0,5,3). Divided through by coef_adjust.</p>
</td></tr>
<tr><td><code id="sim_pop_data_+3A_seed">seed</code></td>
<td>
<p>random seed (default 12345)</p>
</td></tr>
<tr><td><code id="sim_pop_data_+3A_incl_id">incl_id</code></td>
<td>
<p>include an ID column (default TRUE)</p>
</td></tr>
<tr><td><code id="sim_pop_data_+3A_incl_reason">incl_reason</code></td>
<td>
<p>include a column indicating reason for admission.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates data for a range of people for the variables
</p>

<ul>
<li><p> Age (<code>age</code>)
</p>
</li>
<li><p> Sex (<code>sexM</code>; 1 if male)
</p>
</li>
<li><p> Race/ethnicity (<code>raceNW</code>: 1 if non-white ethnicity)
</p>
</li>
<li><p> Number of previous hospital admissions (<code>PrevAdm</code>)
</p>
</li>
<li><p> Deprivation decile (<code>SIMD</code>: 1 most deprived, 10 least deprived. NOTE - opposite to English IMD)
</p>
</li>
<li><p> Urban-rural residence status (<code>urban_rural</code>: 1 for rural)
</p>
</li>
<li><p> Mainland-island residence status (<code>mainland_island</code>: 1 for island)
</p>
</li>
<li><p> Hospital admission (<code>target</code>: 1/TRUE if admitted to hospital in year following prediction date)
</p>
</li></ul>

<p>Can optionally add an ID column.
</p>
<p>Optionally includes an admission reason for samples with <code>target=1</code>. These admission reasons
roughly correspond to the first letters of ICD10 categories, and can either correspond to an
admission or death. Admission reasons are simulated with a non-constant multinomial distribution
which varies across age/sex/ethnicity/urban-rural/mainland-island/PrevAdm values in a randomly-
chosen way. The distributions of admission reasons are <em>not</em> however chosen to reflect real
distributions, nor are systematic changes in commonality of admission types across categories
intended to appear realistic.
</p>


<h3>Value</h3>

<p>data frame with realistic values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate data
dat=sim_pop_data(10000)
cor(dat[,1:7])

# See vignette
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
