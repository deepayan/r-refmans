<!DOCTYPE html><html><head><title>Help for package doremi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {doremi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze.1order'><p>DOREMI first order analysis function</p></a></li>
<li><a href='#analyze.2order'><p>DOREMI second order analysis function</p></a></li>
<li><a href='#calculate.fda'><p>Calculation of derivatives using the Functional Data Analysis (FDA) method.</p></a></li>
<li><a href='#calculate.glla'><p>Calculation of derivatives using the GLLA method</p></a></li>
<li><a href='#calculate.gold'><p>Calculation of derivatives using the GOLD method</p></a></li>
<li><a href='#cardio'><p>Measurements of cardiac frequency in 21 patients during effort tests</p></a></li>
<li><a href='#errorcheck'><p>Displays error messages for the analysis function according to the nature of the error</p>
<code>errorcheck</code> displays error messages and/or warnings concerning the validity of input arguments provided to the analysis function</a></li>
<li><a href='#generate.1order'><p>Generation of the first order differential equation solution with deSolve, for given fixed coefficients</p>
and initial condition</a></li>
<li><a href='#generate.2order'><p>Generation of the second order differential equation solution with deSolve</p></a></li>
<li><a href='#generate.excitation'><p>Excitation signal generation</p></a></li>
<li><a href='#generate.panel.1order'><p>Generation of first order differential equation solutions for several individuals with intra-individual</p>
and inter-individual noise</a></li>
<li><a href='#generate.panel.2order'><p>Generation of second order differential equation solutions for several individuals with intra-individual and inter-individual noise</p></a></li>
<li><a href='#optimum_param'><p>Function to find the optimum parameter for derivative estimation (embedding or spar according to derivative estimation method chosen)</p></a></li>
<li><a href='#plot.doremi'><p>S3 method to plot DOREMI objects</p></a></li>
<li><a href='#plot.doremidata'><p>S3 method to plot DOREMIDATA objects</p></a></li>
<li><a href='#plot.doremiparam'><p>S3 method to plot DOREMIPARAM objects</p></a></li>
<li><a href='#predict.doremi'><p>S3 method to predict signal values in a DOREMI object when entering a new excitation</p></a></li>
<li><a href='#print.doremi'><p>S3 method to print DOREMI objects</p></a></li>
<li><a href='#print.doremidata'><p>S3 method to print DOREMIDATA objects</p></a></li>
<li><a href='#rotation'><p>Measurements of response time of 17 individuals when carrying out mental rotation tasks</p></a></li>
<li><a href='#summary.doremi'><p>S3 method for DOREMI object summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamics of Return to Equilibrium During Multiple Inputs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides models to fit the dynamics of a regulated system experiencing exogenous inputs. 
    The underlying models use differential equations and linear mixed-effects regressions to estimate the 
    coefficients of the equation. With them, the functions can provide an estimated signal.
    The package provides simulation and analysis functions and also print, summary, plot and predict methods,
    adapted to the function outputs, for easy implementation and presentation of results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dcourvoisier/doremi">https://github.com/dcourvoisier/doremi</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dcourvoisier/doremi/issues">https://github.com/dcourvoisier/doremi/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>zoo, data.table, lme4, ggplot2, gridExtra, lmerTest, deSolve,
futile.logger</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, devtools, roxygen2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-19 13:29:01 UTC; denis</td>
</tr>
<tr>
<td>Author:</td>
<td>Mongin Denis <a href="https://orcid.org/0000-0002-4801-8395"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Uribe Adriana [aut],
  Courvoisier Delphine
    <a href="https://orcid.org/0000-0002-1956-2607"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mongin Denis &lt;Denis.Mongin@unige.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-29 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze.1order'>DOREMI first order analysis function</h2><span id='topic+analyze.1order'></span>

<h3>Description</h3>

<p><code>analyze.1order</code>  estimates the coefficients of a first order differential equation of the form:
</p>
<p style="text-align: center;"><code class="reqn">\frac{dy}{dt}(t) + \gamma (y(t) - yeq) = \gamma k*u(t)</code>
</p>

<p>using linear mixed-effect models.
Where y(t) is the individual's signal,<code class="reqn">\gamma</code> the decay rate (and <code class="reqn">\tau = 1/\gamma the decay time</code>),
<code class="reqn">\frac{dy(t)}{dt}</code> is the derivative and u(t) is an external excitation perturbing the dynamics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.1order(
  data,
  id = NULL,
  input = NULL,
  time = NULL,
  signal,
  dermethod = "gold",
  derparam = 3,
  order = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.1order_+3A_data">data</code></td>
<td>
<p>Is a data frame containing at least one column, that is the signal to be analyzed.</p>
</td></tr>
<tr><td><code id="analyze.1order_+3A_id">id</code></td>
<td>
<p>Is a CHARACTER containing the NAME of the column of data containing the identifier of the individual.
If this parameter is not entered when calling the function, a single individual is assumed and a linear regression is done instead
of the linear mixed-effects regression.</p>
</td></tr>
<tr><td><code id="analyze.1order_+3A_input">input</code></td>
<td>
<p>Is a CHARACTER or a VECTOR OF CHARACTERS containing the NAME(s) of data column(s) containing the EXCITATION vector(s).
If this parameter is not entered when calling the function,
the excitation is assumed to be unknown. In this case, the linear mixed-effect regression is still carried out but no coefficient is calculated
for the excitation term. The function then uses the parameters estimated by the regression to carry out an exponential fit of the signal
and build the estimated curve.
The function will consider as an excitation each column of data having a name contained in the input vector.
The function will return a coefficient for each one of the excitation variables included in the input vector.</p>
</td></tr>
<tr><td><code id="analyze.1order_+3A_time">time</code></td>
<td>
<p>Is a CHARACTER containing the NAME of the column of data containing the time vector. If this parameter is not entered when calling the function,
it is assumed that time steps are of 1 unit and the time vector is generated internally in the function.</p>
</td></tr>
<tr><td><code id="analyze.1order_+3A_signal">signal</code></td>
<td>
<p>Is a CHARACTER containing the NAME of the column of the data frame containing the SIGNAL to be studied.</p>
</td></tr>
<tr><td><code id="analyze.1order_+3A_dermethod">dermethod</code></td>
<td>
<p>is the derivative estimation method. default is &quot;gold&quot;.
The values are &quot;gold&quot;,&quot;glla&quot; and &quot;fda&quot;, corresponding to the use of
<code>calculate.gold</code>, <code>calculate.glla</code> or <code>calculate.fda</code> to estimate the derivatives</p>
</td></tr>
<tr><td><code id="analyze.1order_+3A_derparam">derparam</code></td>
<td>
<p>If dermethod &quot;glla&quot; or &quot;gold&quot; are chosen, it is the embedding number, a positive integer containing the number of points to be used for the calculation of the derivatives.
Default is 3. At least two points are needed for the calculation of the first derivative. If dermethod &quot;fda&quot; is chosen, this parameter is
spar, the parameter related to the smoothing parameter lambda used in the penalization function of the function <code>smooth.spline</code> to estimate the derivative via splines (Functional Data Analysis).
In this case, the value should be between 0 and 1, see <code>?smooth.spline</code></p>
</td></tr>
<tr><td><code id="analyze.1order_+3A_order">order</code></td>
<td>
<p>is the maximum order of the derivative estimated when using <code>calculate.gold</code> or <code>calculate.glla</code>.
Although only the first derivative is used here, using a higher order can enhance derivative estimation (see doi: <a href="https://doi.org/10.1080/00273171.2015.1123138">10.1080/00273171.2015.1123138</a>Chow et al.(2016))</p>
</td></tr>
<tr><td><code id="analyze.1order_+3A_verbose">verbose</code></td>
<td>
<p>Is a boolean that displays status messages of the function when set to 1. Useful for debugging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis performs the following linear mixed-effects regression:
</p>
<p style="text-align: center;"><code class="reqn"> \dot{y_{ij}} \sim   (b_{0} +b_{0j}) + (b_{1}+b_{1j}) y_{ij}+ (b_{2}+b_{2j}) u_{ij} +e_{ij}</code>
</p>

<p>with i accounting for the time and j for the different individuals. <code class="reqn">e_{ij}</code> are the residuals,
<code class="reqn">\dot{y_{ij}}</code> is the derivative calculated on embedding points and
<code class="reqn">y_{ij}</code> and <code class="reqn">u_{ij}</code> are the signal and the excitation averaged on embedding points.
The fixed effect coefficients estimated from the regression are:
</p>

<ul>
<li><p> gamma: <code class="reqn">b_1</code> (<code class="reqn">\gamma</code> from the differential equation)
</p>
</li>
<li><p> kgamma: <code class="reqn">b_2</code> (<code class="reqn">k\gamma</code> from the differential equation)
</p>
</li>
<li><p> yeqgamma: <code class="reqn">b_0</code> (<code class="reqn">\gamma y_{eq}</code> from the differential equation)
</p>
</li></ul>

<p>The coefficients derived to characterize the signal are calculated as follows:
</p>

<ul>
<li><p> the decay time, tau:  <code class="reqn">\tau =  \frac{1}{  b_1 } = \frac{1}{\gamma}</code>
</p>
</li>
<li><p> the gain, k: <code class="reqn">\gamma = \frac{b_2}{b_1}</code>. It is the proportionality between the stationary increase of the signal and
the excitation increase that caused it.
</p>
</li>
<li><p> the equilibrium value, yeq: <code class="reqn">yeq = \frac{b_0}{b_1}</code>. It is the stationary value reached in the absence of excitation.
</p>
</li></ul>

<p>The estimation is performed using the function lmer if there are several individuals or lm if there is only one.
With the above estimated parameters, the estimated signal can be reconstructed for
each individual by using the generate.1order function of this package (based on deSolve's ode function).
The function returns five objects:
</p>

<ol>
<li><p> data- A data.frame including the input data, the intermediate calculations used to prepare the variables for
the fit and the estimated trajectories for each individual.
</p>

<ol>
<li><p> signal_rollmean - calculation of the moving average of the signal over embedding points.
</p>
</li>
<li><p> signal_derivate1 - calculation of the first derivative of the signal with the gold, glla or fda methods in embedding points.
</p>
</li>
<li><p> time_derivate - calculation of the moving average of the time vector over embedding points.
</p>
</li>
<li><p> input_rollmean - calculation of the moving average of the excitation vector over embedding points.
</p>
</li>
<li><p> estimated - the estimated signal calculated using generate.1order with the excitation provided as input and the estimated decay time,
gain and equilibrium value obtained from the regression. The initial condition y0 and t0 are the first value of the moving averaged
signal (signal_rollmean) and time (time_derivate)
</p>
</li></ol>

</li>
<li><p> resultmean - A data.frame including the fixed effects of the coefficients estimated from the regression gamma, yeqgamma and the kgamma for each excitation considered,
with their associated standard error gamma_stde, yeqgamma_stde and kgamma_stde,
together with the derived coefficient tau (the decay time), yeq (the equilibrium value) and k (the gain)
</p>
</li>
<li><p> resultid - A data.frame including, for each individual listed by id number,  gamma, yeqgamma and the kgamma, together with the decay time tau,
the gain k and the equilibrium value yeq
</p>
</li>
<li><p> regression - A list containing the summary of the linear mixed-effects regression.
</p>
<p>As seen in the Description section, the print method by default prints only the resultmean element. Each one of the other objects
can be accessed by indicating $ and their name after the result, for instance, for a DOREMI object called &quot;result&quot;, it is possible
to access the regression summary by typing result$regression.
</p>
</li>
<li><p> embedding - contains the embedding number used to generate the results (same as function input argument)
</p>
</li>
<li><p> spar - contains the smoothing parameter used for the estimation of the derivatives using splines (method &quot;fda&quot;)
</p>
</li></ol>

<p>SImulation presenting the statistical propoerties of the ethod can be found in doi: <a href="https://doi.org/10.1080/00273171.2020.1754155">10.1080/00273171.2020.1754155</a>(Mongin et al. (2020))
Example of application of this function can be found in:
</p>

<ul>
<li> <p>doi: <a href="https://doi.org/10.1088/1361-6579/abbb6e">10.1088/1361-6579/abbb6e</a>
</p>
</li>
<li> <p>doi: <a href="https://doi.org/10.1109/ESGCO49734.2020.9158156">10.1109/ESGCO49734.2020.9158156</a>
</p>
</li>
<li> <p>doi: <a href="https://doi.org/10.1080/00273171.2020.1754155">10.1080/00273171.2020.1754155</a>
</p>
</li>
<li> <p>doi: <a href="https://doi.org/10.1038/s41598-020-69218-1">10.1038/s41598-020-69218-1</a>
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a summary of the fixed effect coefficients estimated by the linear regression
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate.gold">calculate.gold</a>, <a href="#topic+calculate.glla">calculate.glla</a>, <a href="#topic+calculate.fda">calculate.fda</a></code> to compute the derivatives, for details on embedding/spar.
and <code><a href="#topic+generate.1order">generate.1order</a></code> the function to generate the solution of the first order differential equation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myresult &lt;- analyze.1order(data = cardio,
                  id = "id",
                  input = "load",
                  time = "time",
                  signal = "hr",
                  dermethod ="gold",
                  derparam = 5)
</code></pre>

<hr>
<h2 id='analyze.2order'>DOREMI second order analysis function</h2><span id='topic+analyze.2order'></span>

<h3>Description</h3>

<p><code>analyze.2order</code>  estimates the coefficients of a second order differential equation of the form:
</p>
<p style="text-align: center;"><code class="reqn">\frac{d^2y}{dt}(t) + 2\xi\omega_{n}\frac{dy}{dt}(t) + \omega_{n}^2 (y - y_{eq}) = \omega_{n}^2 k*u(t) </code>
</p>

<p>Where y(t) is the individual's signal, <code class="reqn">\frac{dy}{dt}(t)</code> is its first derivative,<code class="reqn">\frac{d^2y}{dt}(t)</code>  its second derivative
and u(t) is the excitation.
The function estimates the coefficients <code class="reqn">2\xi\omega_{n}, \omega_{n}^2 k</code> and <code class="reqn">\omega_{n}^2 y_{eq}</code>,
from which the oscillation period T, the damping ratio <code class="reqn">\xi</code>, the equilibrium <code class="reqn">y_{eq}</code> value and the gain k can be derived.
Th estimation is based on a two step procedure: the first step consists in estimating the derivatives to then estimate in a second step the differential equation
coefficients through a linear mixed-effect model. Three different method to estimate the derivative during the first step are proposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze.2order(
  data,
  id = NULL,
  input = NULL,
  time = NULL,
  signal,
  dermethod = "gold",
  derparam = 3,
  order = 2,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.2order_+3A_data">data</code></td>
<td>
<p>Is a data frame containing at least one column, that is the signal to be analyzed.</p>
</td></tr>
<tr><td><code id="analyze.2order_+3A_id">id</code></td>
<td>
<p>Is a CHARACTER containing the NAME of the column of data containing the identifier of the individual.
If this parameter is not entered when calling the function, a single individual is assumed and a linear regression is done instead
of the linear mixed-effects regression.</p>
</td></tr>
<tr><td><code id="analyze.2order_+3A_input">input</code></td>
<td>
<p>Is a CHARACTER or a VECTOR OF CHARACTERS containing the NAME(s) of data column(s) containing the EXCITATION vector(s).
If this parameter is not entered when calling the function,
the excitation is assumed to be unknown. In this case, the linear mixed-effect regression is still carried out but no coefficient is calculated
for the excitation term. If no excitation term is supplied, one of the initial conditions is different from 0 (signal or derivative) and xi&lt;1 the function will estimate
a damped linear oscillator (DLO)</p>
</td></tr>
<tr><td><code id="analyze.2order_+3A_time">time</code></td>
<td>
<p>Is a CHARACTER containing the NAME of the column of data containing the time vector. If this parameter is not entered when calling the function,
it is assumed that time steps are of 1 unit and the time vector is generated internally in the function.</p>
</td></tr>
<tr><td><code id="analyze.2order_+3A_signal">signal</code></td>
<td>
<p>Is a CHARACTER containing the NAME of the column of the data frame containing the SIGNAL to be studied.</p>
</td></tr>
<tr><td><code id="analyze.2order_+3A_dermethod">dermethod</code></td>
<td>
<p>is the derivative estimation method. The following methods are available: &quot;gold&quot;,&quot;glla&quot; and &quot;fda&quot;</p>
</td></tr>
<tr><td><code id="analyze.2order_+3A_derparam">derparam</code></td>
<td>
<p>If dermethod &quot;glla&quot; or &quot;gold&quot; are chosen, it is the embedding number, a positive integer containing the number of points to be used for the calculation of the derivatives.
Its value by default is 3 as at least three points are needed for the calculation of the second derivative. If dermethod &quot;fda&quot; is chosen, this parameter is
spar, the parameter related to the smoothing parameter lambda used in the penalization function of the function <code>smooth.spline</code> to estimate the derivative via splines (Functional Data Analysis)</p>
</td></tr>
<tr><td><code id="analyze.2order_+3A_order">order</code></td>
<td>
<p>is the maximum order of the derivative to estimate. Using an order higher than that of the maximum derivative to estimate (1 in first order differential equations and
2 in second order differential equations), for instance, order=4 might enhance derivative estimation (see doi: <a href="https://doi.org/10.1080/00273171.2015.1123138">10.1080/00273171.2015.1123138</a>Chow et al.(2016))</p>
</td></tr>
<tr><td><code id="analyze.2order_+3A_verbose">verbose</code></td>
<td>
<p>Is a boolean that displays status messages of the function when set to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis performs the following linear mixed-effects regression:
</p>
<p style="text-align: center;"><code class="reqn"> \ddot{y_{ij}} \sim   (b_{0} +b_{0j}) + (b_{1}+b_{1j}) \dot{y_{ij}} + (b_{2}+b_{2j}) y_{ij} + (b_{3}+b_{3j}) u_{ij} + e_{ij}</code>
</p>

<p>with i accounting for the time and j for the different individuals. <code class="reqn">e_{ij}</code> are the residuals,
<code class="reqn">\dot{y_{ij}}</code> is the first derivative and <code class="reqn">\ddot{y_{ij}}</code> the second derivative calculated on embedding points, and
<code class="reqn">y_{ij}</code> and <code class="reqn">u_{ij}</code> are the signal and the excitation averaged on embedding points.
The fixed effect coefficients estimated from the regression are:
</p>

<ul>
<li><p> xi2omega: <code class="reqn">b_1</code> (<code class="reqn">2\xi\omega^2</code> from the differential equation)
</p>
</li>
<li><p> omega2: <code class="reqn">b_2</code> (<code class="reqn">\omega^2</code> from the differential equation)
</p>
</li>
<li><p> komega2: <code class="reqn">b_3</code> (<code class="reqn">k\omega^2</code> from the differential equation)
</p>
</li>
<li><p> yeqomega2: <code class="reqn">b_0</code> (<code class="reqn">\omega^2 y_{eq}</code> from the differential equation)
</p>
</li></ul>

<p>The coefficients derived to characterize the signal are calculated as follows:
</p>

<ul>
<li><p> the oscillation period  <code class="reqn">T = \sqrt{ \frac{2\pi}{ b_2 }}</code>
</p>
</li>
<li><p> the damping factor xi: <code class="reqn">xi = \frac{b_1}{2*\sqrt{b_2}}</code>
</p>
</li>
<li><p> the gain, k: <code class="reqn">k = \frac{b_3}{b_1}</code>. It is the proportionality between the stationary increase of the signal and
the excitation increase that caused it.
</p>
</li>
<li><p> the equilibrium value, yeq: <code class="reqn">yeq = \frac{b_0}{b_2}</code>. It is the stationary value reached in the absence of excitation.
</p>
</li></ul>

<p>The estimation is performed using the function lmer if there are several individuals or lm if there is only one.
With the above estimated parameters, the estimated signal is reconstructed for
each individual by using the generate.2order function of this package (based on deSolve's ode function).
The function returns five objects:
</p>

<ol>
<li><p> data- A data.frame including the input data, the intermediate calculations used to prepare the variables for
the fit and the estimated trajectories for each individual.
</p>

<ol>
<li><p> signal_rollmean - calculation of the o order derivative of the signal over embedding points.
</p>
</li>
<li><p> signal_derivate1 - calculation of the first derivative of the signal with the chosen method in embedding points/with smoothing parameter spar
</p>
</li>
<li><p> signal_derivate2 - calculation of the second derivative of the signal with the chosen method in embedding points/with smoothing parameter spar
</p>
</li>
<li><p> time_derivate - calculation of the moving average of the time vector over embedding points.
</p>
</li>
<li><p> input_rollmean - calculation of the moving average of the excitation vector over embedding points.
</p>
</li>
<li><p> estimated - the estimated signal calculated using deSolve's ode function with a second order model, the excitation provided as input and the
coefficients obtained from the fit.
</p>
</li></ol>

</li>
<li><p> resultid- A data.frame including for each individual, listed by id number, the coefficients calculated (thus fixed + random component)
</p>
</li>
<li><p> resultmean- A data.frame including the fixed effects of the coefficients mentioned above with their standard error, the coefficients characterizing the signal shape
(i.e. the period, the damping factor, the gain and the equilibrium value), and the R2 resulting from the estimation
</p>
</li>
<li><p> regression- A list containing the summary of the linear mixed-effects regression.
</p>
<p>As seen in the Description section, the print method by default prints only the resultmean element. Each one of the other objects
can be accessed by indicating $ and their name after the result, for instance, for a DOREMI object called &quot;result&quot;, it is possible
to access the regression summary by typing result$regression.
</p>
</li>
<li><p> derparam - contains the embedding number used to generate the results (if the derivative estimation method chosen is &quot;glla&quot; or &quot;gold&quot;) or
the smoothing parameter spar if the chosen method is fda
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a summary of the fixed effect coefficients (see details)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate.gold">calculate.gold</a>, <a href="#topic+calculate.glla">calculate.glla</a>, <a href="#topic+calculate.fda">calculate.fda</a></code> to compute the derivatives, for details on embedding/spar
See <code><a href="#topic+generate.2order">generate.2order</a></code> for the generation of the solution of the second order differential equation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a panel of oscillating signals
test   &lt;- generate.panel.2order(time = 0:100,
                              excitation = as.numeric(0:100&gt;50),
                              period = 15,
                              xi = 0.3,
                              k = 2,
                              internoise = 0.2,
                              intranoise = 0.3,
                              nind = 10)

# plot the signal to analyze
plot(test)


# analyze them
res &lt;- analyze.2order(data = test,
                      id = "id",
                      input = "excitation",
                      time =  "time",
                      signal = "signal",
                      derparam = 13)
res
plot(res)
</code></pre>

<hr>
<h2 id='calculate.fda'>Calculation of derivatives using the Functional Data Analysis (FDA) method.</h2><span id='topic+calculate.fda'></span>

<h3>Description</h3>

<p><code>calculate.fda</code> estimates the derivatives of a variable using the FDA
method described in several sources, such as in doi: <a href="https://doi.org/10.1007/b98888">10.1007/b98888</a>Ramsay et al. (2009)
and  doi: <a href="https://doi.org/10.1080/00273171.2015.1123138">10.1080/00273171.2015.1123138</a>Chow et al. (2016).
This method estimates a spline function that fits all the data points and then derivates this function to estimate derivatives at those points.
In order for the derivatives to exist, the function must be smooth. A roughness penalty function controlled by a smoothing parameter is then used.
The estimations are done by using the R's base smooth.spline function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.fda(signal, time, spar = NULL, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate.fda_+3A_signal">signal</code></td>
<td>
<p>is a vector containing the data from which the derivative is estimated.</p>
</td></tr>
<tr><td><code id="calculate.fda_+3A_time">time</code></td>
<td>
<p>is a vector containing the time values corresponding to the signal. Arguments signal and time must have the same length.</p>
</td></tr>
<tr><td><code id="calculate.fda_+3A_spar">spar</code></td>
<td>
<p>is the smoothing parameter used by the roughness penalty function in the smooth.spline R function.</p>
</td></tr>
<tr><td><code id="calculate.fda_+3A_order">order</code></td>
<td>
<p>parameter not used, for consistency with calculate.glla and calculate.gold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing two elements:
</p>
<p>dtime- contains the initial time values provided.
</p>
<p>dsignal- is a data.frame containing three columns and the same number of rows as the signal.
The first column is the signal data points, the second is the first derivative evaluated at those points,
and the third is the second derivative evaluated at those points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#In the following example the derivatives for the function y(t) = t^2 are calculated.
#The expected results are:
#y'(t) = 2t and y''(t) = 2
time &lt;- c(1:500)/100
signal &lt;- time^2
result &lt;- calculate.fda(signal = signal, time = time)

</code></pre>

<hr>
<h2 id='calculate.glla'>Calculation of derivatives using the GLLA method</h2><span id='topic+calculate.glla'></span>

<h3>Description</h3>

<p><code>calculate.glla</code> estimates the derivatives of a variable using the Generalized Local Linear Approximation (GLLA) method
described in doi: <a href="https://doi.org/10.4324/9780203864746">10.4324/9780203864746</a>Boker et al.(2010).
This method estimates the derivatives over a number of measurement points called the embedding number assuming an equally spaced time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.glla(signal, time, embedding = 3, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate.glla_+3A_signal">signal</code></td>
<td>
<p>is the input vector containing the data from which the derivatives are estimated.</p>
</td></tr>
<tr><td><code id="calculate.glla_+3A_time">time</code></td>
<td>
<p>is a vector containing the time values corresponding to the signal. Arguments signal and time must have the same length.</p>
</td></tr>
<tr><td><code id="calculate.glla_+3A_embedding">embedding</code></td>
<td>
<p>is an integer indicating the embedding dimension, that is the number of points to consider for derivative calculation.
Embedding must be at least #' 2 for the calculation of the first derivative (first order models) and at least 3 for the calculation of
the second derivative (second order models).</p>
</td></tr>
<tr><td><code id="calculate.glla_+3A_n">n</code></td>
<td>
<p>is the maximum order of the derivative to calculate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing three columns:
</p>
<p>dtime- contains the time values in which the derivative was calculated. That is, the moving average of the input time over embedding points.
</p>
<p>dsignal- is a data.frame containing n+1 columns and the same number of rows as the signal.
The column k is the k-1 order derivative of the signal over embedding points.
</p>
<p>embedding- number of points used for the derivative calculation.
</p>
<p>n - the maximum derivative order calculated n
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#In the following example the derivatives for the function y(t) = t^2 are calculated.
#The expected results are:
#y'(t) = 2t and y''(t) = 2
time &lt;- c(1:500)/100
signal &lt;- time^2
result &lt;- calculate.glla(signal = signal, time = time, embedding = 5)

</code></pre>

<hr>
<h2 id='calculate.gold'>Calculation of derivatives using the GOLD method</h2><span id='topic+calculate.gold'></span>

<h3>Description</h3>

<p><code>calculate.gold</code> estimates the derivatives of a variable using the Generalized Orthogonal Local Derivative (GOLD)
method described in doi: <a href="https://doi.org/10.1080/00273171.2010.498294">10.1080/00273171.2010.498294</a>Deboeck (2010). The code available on this paper was extracted and adapted for non constant time steps.
This method allows calculating over a number of measurement points (called the embedding number) derivatives with uncorrelated errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.gold(signal, time, embedding = 3, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate.gold_+3A_signal">signal</code></td>
<td>
<p>is a vector containing the data from which the derivative is estimated.</p>
</td></tr>
<tr><td><code id="calculate.gold_+3A_time">time</code></td>
<td>
<p>is a vector containing the time values corresponding to the signal. Arguments signal and time must have the same length.</p>
</td></tr>
<tr><td><code id="calculate.gold_+3A_embedding">embedding</code></td>
<td>
<p>is an integer indicating the number of points to consider for derivative calculation. Embedding must be greater than 1 because at least
two points are needed for the calculation of the first derivative and at least 3 for the calculation of the second derivative.</p>
</td></tr>
<tr><td><code id="calculate.gold_+3A_n">n</code></td>
<td>
<p>is the maximum order of derivative to estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following elements:
</p>
<p>dtime- contains the time values in which the derivative was calculated. That is, the moving average of the input time over embedding points.
</p>
<p>dsignal- is a data.frame containing n+1 columns and the same number of rows as the signal.
The column k is the k-1 order derivative of the signal over embedding points.
</p>
<p>embedding- number of points used for the derivative calculation.
</p>
<p>n - the maximum derivative order calculated n
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#In the following example the derivatives for the function y(t) = t^2 are calculated.
#The expected results are:
#y'(t) = 2t and y''(t) = 2
time &lt;- c(1:500)/100
signal &lt;- time^2
result &lt;- calculate.gold(signal = signal, time = time, embedding = 5)

</code></pre>

<hr>
<h2 id='cardio'>Measurements of cardiac frequency in 21 patients during effort tests</h2><span id='topic+cardio'></span>

<h3>Description</h3>

<p>Data containing time, cardiac frequency and load of a resistive bicycle run by patients during effort tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cardio)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1686 rows and 4 variables
</p>

<dl>
<dt>id</dt><dd><p>positive integer, arbitrary identifier of the patient</p>
</dd>
<dt>time</dt><dd><p>positive real number, time since the beginning of the test, in seconds (s)</p>
</dd>
<dt>load</dt><dd><p>positive real number, load of the resistive bicycle, effort that the patient needs to do, in watts (W)</p>
</dd>
<dt>hr</dt><dd><p>positive real number, patient's cardiac rhythm, in heart beats per minute (1/min)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mongin et al. 2018, under review (future DOI will be inserted here)
</p>

<hr>
<h2 id='errorcheck'>Displays error messages for the analysis function according to the nature of the error
<code>errorcheck</code> displays error messages and/or warnings concerning the validity of input arguments provided to the analysis function</h2><span id='topic+errorcheck'></span>

<h3>Description</h3>

<p>Displays error messages for the analysis function according to the nature of the error
<code>errorcheck</code> displays error messages and/or warnings concerning the validity of input arguments provided to the analysis function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorcheck(data, col_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorcheck_+3A_data">data</code></td>
<td>
<p>data.frame or data.table containing the data to be analyzed. Same object that is passed as input argument to the analysis function.</p>
</td></tr>
<tr><td><code id="errorcheck_+3A_col_var">col_var</code></td>
<td>
<p>column variable. Contains a string that indicates the name of the column to analyze (&quot;id&quot;,&quot;input&quot;,etc.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return a value. Either displays directly the error message/warning or changes data type in the data.frame/data.table provided
</p>

<hr>
<h2 id='generate.1order'>Generation of the first order differential equation solution with deSolve, for given fixed coefficients
and initial condition</h2><span id='topic+generate.1order'></span>

<h3>Description</h3>

<p><code>generate.1order</code> returns a data frame containing the time (supplied as input) and the solution to a first order
differential equation. The coefficients are provided as inputs, as well as the initial condition
</p>
<p style="text-align: center;"><code class="reqn">\frac{dy(t)}{dt} + \frac{(y(t) - yeq)}{\tau}  =  \frac{k}{\tau} u(t)</code>
</p>

<p>Where y(t) is the signal, dy(t) its derivative, <code class="reqn">\tau</code> is the decay time, k the gain and yeq the equilibrium value.
u(t) is the source term of the equation, that is an external excitation perturbing the dynamics.
The latter is provided as input or is set to null. The numerical solution is generated with deSolve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.1order(
  time = 0:100,
  excitation = NULL,
  y0 = 0,
  t0 = NULL,
  tau = 10,
  k = 1,
  yeq = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.1order_+3A_time">time</code></td>
<td>
<p>Is a vector containing the time values corresponding to the excitation signal.</p>
</td></tr>
<tr><td><code id="generate.1order_+3A_excitation">excitation</code></td>
<td>
<p>Is a vector containing the values of the excitation signal (u(t) in the equation). If NULL, it is considered to be 0.</p>
</td></tr>
<tr><td><code id="generate.1order_+3A_y0">y0</code></td>
<td>
<p>Signal initial value y(t=t0). Default is 0</p>
</td></tr>
<tr><td><code id="generate.1order_+3A_t0">t0</code></td>
<td>
<p>Time corresponding to the signal initial value y(t=t0). Default is the minimum value of the time vector.
Must be a value between minimum and maximum value of the time vector</p>
</td></tr>
<tr><td><code id="generate.1order_+3A_tau">tau</code></td>
<td>
<p>Signal decay time. It represents the characteristic response time of the solution of the differential equation.
A negative value will produce divergence from equilibrium.</p>
</td></tr>
<tr><td><code id="generate.1order_+3A_k">k</code></td>
<td>
<p>Signal gain. Default is 1. It represents the proportionality between the stationary increase of signal and the excitation increase that caused it.
Only relevant if the excitation is non null.</p>
</td></tr>
<tr><td><code id="generate.1order_+3A_yeq">yeq</code></td>
<td>
<p>Signal equilibrium value. Stationary value when the excitation term is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table containing three elements:
</p>

<ul>
<li><p>  y is a vector containing the values calculated with deSolve so that y is a solution to a first order differential equation with the constant
coefficients provided as input.
</p>
</li>
<li><p>  t is a vector containing the corresponding time values
</p>
</li>
<li><p> exc
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>generate.1order(t0 = 2.5,y0 = 2)
test &lt;- generate.1order(time = 0:49, excitation = c(rep(0,10),rep(1,40)))
plot(test$t,test$y)
lines(test$t,test$exc,col = 2)

### see the influence of tau

different_tau &lt;- data.table::rbindlist(lapply(1:5*4,function(x){
tmp &lt;- generate.1order(t0 = 0,
                       y0 = 2,
                       tau = x)
tmp[,tau := as.factor(x)][]
}))

ggplot2::ggplot(data = different_tau,
                ggplot2::aes(t,y,color = tau))+
  ggplot2::geom_line()

### effect of the gain

different_gain &lt;- data.table::rbindlist(lapply(1:5,function(x){
tmp &lt;- generate.1order(
  time = 1:100,
  excitation = as.numeric(1:100 &gt; 50),
  y0 = 0,
  tau = 10,
  k = x)
tmp[,k := as.factor(x)][]
}) )

  ggplot2::ggplot(different_gain)+
  ggplot2::geom_line(ggplot2::aes(t,y,color = k))+
  ggplot2::geom_line(ggplot2::aes(t,exc,color = "excitation"))
</code></pre>

<hr>
<h2 id='generate.2order'>Generation of the second order differential equation solution with deSolve</h2><span id='topic+generate.2order'></span>

<h3>Description</h3>

<p><code>generate.2order</code> returns a data frame containing the time (supplied as input) and a simulated signal generated as a solution to a second order
differential equation with constant coefficients that are provided as inputs:
</p>
<p style="text-align: center;"><code class="reqn">\frac{d^2y}{dt} + 2\xi\omega_{n}\frac{dy}{dt} + \omega_{n}^2 y = \omega_{n}^2 k*u(t)</code>
</p>

<p>Where:
y(t) is the signal, <code class="reqn">\frac{dy}{dt}</code> its derivative and <code class="reqn">\frac{d^2y}{dt}</code> its second derivative
</p>

<ul>
<li> <p><code class="reqn">\omega_{n} = \frac{2\pi}{T}</code> -where T is the period of the oscillation- is the system's natural frequency, the frequency with which the system would vibrate if there were no damping.
The term <code class="reqn">\omega_{n}^2</code> represents thus the ratio between the attraction to the equilibrium and the inertia. If we considered the example
of a mass attached to a spring, this term would represent the ratio of the spring constant and the object's mass.
</p>
</li>
<li> <p><code class="reqn">\xi</code> is the damping ratio. It represents the friction that damps the oscillation of the system (slows the rate of change of the variable).
The term <code class="reqn">2\xi\omega_n</code> thus represents the respective contribution of the inertia, the friction and the attraction to the equilibrium.
The value of <code class="reqn">\xi</code> determines the shape of the system time response, which can be:
<code class="reqn">\xi&lt;0</code>	Unstable, oscillations of increasing magnitude
<code class="reqn">\xi=0</code>	Undamped, oscillating
<code class="reqn">0&lt;\xi&lt;1</code>	Underdamped or simply &quot;damped&quot;: the oscillations are damped by an exponential of damping rate <code class="reqn">\xi\omega_{n}</code>
<code class="reqn">\xi=1</code>	Critically damped
<code class="reqn">\xi&gt;1</code>	Over-damped, no oscillations in the return to equilibrium
</p>
</li>
<li><p> k is the gain
</p>
</li>
<li><p> u(t) is an external excitation perturbing the dynamics
</p>
</li></ul>

<p>The excitation is also provided as input and it can be null (then the solution
will be a damped linear oscillator when the initial condition is different from 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.2order(
  time = 0:100,
  excitation = NULL,
  y0 = 0,
  v0 = 0,
  t0 = NULL,
  xi = 0.1,
  period = 10,
  k = 1,
  yeq = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.2order_+3A_time">time</code></td>
<td>
<p>is a vector containing the time values corresponding to the excitation signal.</p>
</td></tr>
<tr><td><code id="generate.2order_+3A_excitation">excitation</code></td>
<td>
<p>Is a vector containing the values of the excitation signal.</p>
</td></tr>
<tr><td><code id="generate.2order_+3A_y0">y0</code></td>
<td>
<p>is the initial condition for the variable y(t=t0), (0, by default), it is a scalar.</p>
</td></tr>
<tr><td><code id="generate.2order_+3A_v0">v0</code></td>
<td>
<p>is the initial condition for the derivative dy(t=t0), (0, by default), it is a scalar.</p>
</td></tr>
<tr><td><code id="generate.2order_+3A_t0">t0</code></td>
<td>
<p>is the time corresponding to the initial condition y0 and v0. Default is the minimum value of the time vector.</p>
</td></tr>
<tr><td><code id="generate.2order_+3A_xi">xi</code></td>
<td>
<p>is the damping factor. A negative value will produce divergence from equilibrium.</p>
</td></tr>
<tr><td><code id="generate.2order_+3A_period">period</code></td>
<td>
<p>is the period T of the oscillation, <code class="reqn">T = \frac{2*\pi}{\omega_{n}}</code> as mentioned</p>
</td></tr>
<tr><td><code id="generate.2order_+3A_k">k</code></td>
<td>
<p>Default is 1. It represents the proportionality between the stationary increase of signal and the excitation increase that caused it.
Only relevant if the excitation is non null.</p>
</td></tr>
<tr><td><code id="generate.2order_+3A_yeq">yeq</code></td>
<td>
<p>is the signal equilibrium value, i.e. the stationary value reached when the excitation term is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table containing four elements:
</p>

<ul>
<li><p>  t is a vector containing the corresponding time values
</p>
</li>
<li><p>  y is a vector containing the values calculated with deSolve so that y is a solution to a second order differential equation with constant
coefficients (provided as input) evaluated at the time points given by t
</p>
</li>
<li><p> dy is a vector containing the values of the derivative calculated at the same time points
</p>
</li>
<li><p> exc is the excitation vector
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>generate.2order(time=0:249,excitation=c(rep(0,10),rep(1,240)),period=10)
generate.2order(y0=10)
</code></pre>

<hr>
<h2 id='generate.excitation'>Excitation signal generation</h2><span id='topic+generate.excitation'></span>

<h3>Description</h3>

<p><code>generate.excitation</code> generates a vector of randomly located square pulses
with a given amplitude, duration and spacing between the pulses. A pulse is where the excitation passes from value 0 to value amplitude
for a given duration and then returns back to 0, thus producing a square shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.excitation(
  amplitude = 1,
  nexc = 1,
  duration = 2,
  deltatf = 0.1,
  tmax = 10,
  minspacing = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.excitation_+3A_amplitude">amplitude</code></td>
<td>
<p>is a vector of values different from 0 indicating the amplitude of the excitation. It should contain as many values
as the number of pulses (nexc). If the elements are less than the number of pulses, the amplitude vector will be &quot;recycled&quot; and the elements from it will be repeated until
all the pulses are covered (for instance, if the number of excitations nexc is 6 and the amplitude vector has two elements, pulses 1,3 and 5 will
have the same amplitude as the first element of the amplitude vector and pulses 2,4 and 6 that of the second element).</p>
</td></tr>
<tr><td><code id="generate.excitation_+3A_nexc">nexc</code></td>
<td>
<p>is an integer greater than 0 indicating the number of pulses to generate.</p>
</td></tr>
<tr><td><code id="generate.excitation_+3A_duration">duration</code></td>
<td>
<p>is a vector of values greater or equal to 0 indicating the duration of each pulse in time units. It should have as many elements as the number of pulses (nexc). If
the elements are less than the number of pulses, the amplitude vector will be &quot;recycled&quot; and the elements from it will be repeated until
all the pulses are covered.</p>
</td></tr>
<tr><td><code id="generate.excitation_+3A_deltatf">deltatf</code></td>
<td>
<p>is a value greater than 0 indicating the time step between two consecutive data points.</p>
</td></tr>
<tr><td><code id="generate.excitation_+3A_tmax">tmax</code></td>
<td>
<p>is a value greater than 0 indicating the maximum time range of the excitation vector in time units. The time vector generated will go from 0 to tmax.</p>
</td></tr>
<tr><td><code id="generate.excitation_+3A_minspacing">minspacing</code></td>
<td>
<p>as pulses are generated randomly, minspacing is a value greater than or equal to 0 that indicates minimum spacing between pulses, thus avoiding
overlapping of the pulses in time. A value of 0 indicates that pulses can follow one another.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for simulations in the context of the package. Beware that the following condition should apply:
</p>
<p style="text-align: center;"><code class="reqn">tmax &gt;= (duration+minspacing)*nexc</code>
</p>

<p>so that the pulses &quot;fit&quot; in the time lapse defined.
Compared to <code>pulsew</code> from the <code>seewave</code> package, this function can generate pulses of different duration and amplitude.
</p>


<h3>Value</h3>

<p>Returns two vectors:
</p>
<p>E- vector containing the values of the excitation generated.
</p>
<p>t- vector containing the values of time generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate.excitation (amplitude = 3,
                     nexc = 6,
                     duration = 2,
                     deltatf = 1,
                     tmax = 200,
                     minspacing = 2)
#Vector of length 201 (deltatf x tmax + 1 as it includes 0 as initial time value)
generate.excitation (amplitude = c(1,10,20),
                     nexc = 3,
                     duration = c(1,2,4),
                     deltatf = 0.5,
                     tmax = 100,
                     minspacing = 10)
</code></pre>

<hr>
<h2 id='generate.panel.1order'>Generation of first order differential equation solutions for several individuals with intra-individual
and inter-individual noise</h2><span id='topic+generate.panel.1order'></span>

<h3>Description</h3>

<p><code>generate.panel.1order</code> Generation of first order differential equation solutions for several individuals with intra-individual and inter-individual noise.
For a panel of nind individual, the function generates
nind solutions of a first order differential equation with constant coefficients distributed along a normal distribution.
Measurement noise is added to each individual signal according to the value of the intranoise parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.panel.1order(
  time,
  excitation = NULL,
  y0 = 0,
  t0 = NULL,
  tau = 10,
  k = 1,
  yeq = 0,
  nind = 1,
  internoise = 0,
  intranoise = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.panel.1order_+3A_time">time</code></td>
<td>
<p>Is a vector containing the time values corresponding to the excitation signal.</p>
</td></tr>
<tr><td><code id="generate.panel.1order_+3A_excitation">excitation</code></td>
<td>
<p>Is a vector containing the values of the excitation signal (u(t) in the equation). If NULL, it is considered to be 0.</p>
</td></tr>
<tr><td><code id="generate.panel.1order_+3A_y0">y0</code></td>
<td>
<p>Signal initial value y(t=t0). Default is 0</p>
</td></tr>
<tr><td><code id="generate.panel.1order_+3A_t0">t0</code></td>
<td>
<p>Time corresponding to the signal initial value y(t=t0). Default is the minimum value of the time vector.
Must be a value between minimum and maximum value of the time vector</p>
</td></tr>
<tr><td><code id="generate.panel.1order_+3A_tau">tau</code></td>
<td>
<p>Signal decay time. It represents the characteristic response time of the solution of the differential equation.
A negative value will produce divergence from equilibrium.</p>
</td></tr>
<tr><td><code id="generate.panel.1order_+3A_k">k</code></td>
<td>
<p>Signal gain. Default is 1. It represents the proportionality between the stationary increase of signal and the excitation increase that caused it.
Only relevant if the excitation is non null.</p>
</td></tr>
<tr><td><code id="generate.panel.1order_+3A_yeq">yeq</code></td>
<td>
<p>Signal equilibrium value. Stationary value when the excitation term is 0.</p>
</td></tr>
<tr><td><code id="generate.panel.1order_+3A_nind">nind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code id="generate.panel.1order_+3A_internoise">internoise</code></td>
<td>
<p>Is the inter-individual noise added. The tau across individuals follows a normal distribution centered on the input parameter tau
with a standard deviation of internoise*tau, except if any decay time is negative (see Details section). The same applies to the other coefficients of the differential
equation (k and yeq)</p>
</td></tr>
<tr><td><code id="generate.panel.1order_+3A_intranoise">intranoise</code></td>
<td>
<p>Is the noise to signal  ratio: dynamic noise added to each signal defined as the ratio between the variance  of the noise and the variance of the signal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for simulations in the context of the package.
The function currently simulates only positive decay times corresponding to a regulated system. When the decay time is low
and the inter individual noise is high, some individuals' decay time could be negative. In that case, the decay time
distribution is truncated at 0.1*deltat and values below are set to this limit. High values are symmetrically set at the upper percentile value
similar to a Winsorized mean. A warning provides the initial inter individual noise set as input argument and the inter individual
noise obtained after truncation.
</p>


<h3>Value</h3>

<p>Returns a data frame containing the following columns:
</p>

<ul>
<li><p> id - individual identifier (from 1 to nind).
</p>
</li>
<li><p> excitation - excitation signal
</p>
</li>
<li><p> time - time values
</p>
</li>
<li><p> signalraw - signal with no noise (internoise provided added for each individual)
</p>
</li>
<li><p> dampedsignal - signal with intranoise added
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+generate.1order">generate.1order</a></code> for calculation of the numerical solution to the differential equation
and <code><a href="#topic+generate.excitation">generate.excitation</a></code> for excitation signal generation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate.panel.1order(time = generate.excitation(3, 6, 2, 1, 200, 2)$t,
                      excitation = generate.excitation(3, 6, 2, 1, 200, 2)$exc,
                      y0 = 0,
                      tau = 10,
                      k = 1,
                      yeq = 0,
                      nind = 5,
                      internoise = 0.2,
                      intranoise = 1)
</code></pre>

<hr>
<h2 id='generate.panel.2order'>Generation of second order differential equation solutions for several individuals with intra-individual and inter-individual noise</h2><span id='topic+generate.panel.2order'></span>

<h3>Description</h3>

<p><code>generate.panel.2order</code> Generation of second order differential equation solutions for several individuals with intra-individual and inter-individual noise.
The function generates the equation coefficients following a normal distribution based on the parameter internoise and the coefficients provided as input.
It then calls the function <code><a href="#topic+generate.2order">generate.2order</a></code> to generate a solution of a second order differential equation with these parameters for the nind individuals.
Finally it adds measurement noise to each signal according to the value of the parameter intranoise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.panel.2order(
  time,
  excitation = NULL,
  y0 = 1,
  v0 = 0,
  t0 = NULL,
  xi = 0.1,
  period = 10,
  k = 1,
  yeq = 0,
  nind = 1,
  internoise = 0,
  intranoise = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.panel.2order_+3A_time">time</code></td>
<td>
<p>is a vector containing the time values corresponding to the excitation signal.</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_excitation">excitation</code></td>
<td>
<p>Is a vector containing the values of the excitation signal.</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_y0">y0</code></td>
<td>
<p>is the initial condition for the variable y(t=t0), (0, by default), it is a scalar.</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_v0">v0</code></td>
<td>
<p>is the initial condition for the derivative dy(t=t0), (0, by default), it is a scalar.</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_t0">t0</code></td>
<td>
<p>is the time corresponding to the initial condition y0 and v0. Default is the minimum value of the time vector.</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_xi">xi</code></td>
<td>
<p>is the damping factor. A negative value will produce divergence from equilibrium.</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_period">period</code></td>
<td>
<p>is the period T of the oscillation, <code class="reqn">T = \frac{2*\pi}{\omega_{n}}</code> as mentioned</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_k">k</code></td>
<td>
<p>Default is 1. It represents the proportionality between the stationary increase of signal and the excitation increase that caused it.
Only relevant if the excitation is non null.</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_yeq">yeq</code></td>
<td>
<p>is the signal equilibrium value, i.e. the stationary value reached when the excitation term is 0.</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_nind">nind</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_internoise">internoise</code></td>
<td>
<p>Is the inter-individual noise added. The damping factor across individuals follows a normal distribution centered on the input parameter xi
with a standard deviation of internoise*xi. The same applies to the other coefficients of the differential equation (T,k and yeq) and to the initial conditions (y0 and v0)</p>
</td></tr>
<tr><td><code id="generate.panel.2order_+3A_intranoise">intranoise</code></td>
<td>
<p>Is the noise to signal  ratio: dynamic noise added to each signal defined as the ratio between the variance  of the noise and the variance of the signal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for simulations in the context of the package.
</p>


<h3>Value</h3>

<p>Returns a data frame with signal and time values for the time and excitation vectors provided.
It contains the following columns:
</p>

<ul>
<li><p> id - individual identifier (from 1 to nind).
</p>
</li>
<li><p> excitation - excitation signal provided as input
</p>
</li>
<li><p> time - time values provided as input
</p>
</li>
<li><p> signalraw - signal with no noise (inter noise added for each individual)
</p>
</li>
<li><p> signal - signal with intra noise added
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+generate.2order">generate.2order</a></code> for calculation of the numerical solution to the second order differential equation
and <code><a href="#topic+generate.excitation">generate.excitation</a></code> for excitation signal generation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate.panel.2order(time = generate.excitation(3, 6, 2, 1, 200, 2)$t,
                      excitation = generate.excitation(3, 6, 2, 1, 200, 2)$exc,
                      xi = 0.1,
                      period = 0.5,
                      k = 1,
                      nind = 5,
                      internoise = 0.2,
                      intranoise = 0.1)
</code></pre>

<hr>
<h2 id='optimum_param'>Function to find the optimum parameter for derivative estimation (embedding or spar according to derivative estimation method chosen)</h2><span id='topic+optimum_param'></span>

<h3>Description</h3>

<p><code>optimum_param</code>  calculates the optimum parameter for derivative estimation by varying the latter in a range introduced as input and keeping the parameter and
coefficients having the $R^2$ closest to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimum_param(
  data,
  id = NULL,
  input = NULL,
  time,
  signal,
  dermethod = "gold",
  model = "1order",
  order = 2,
  pmin = 3,
  pmax = 21,
  pstep = 2,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimum_param_+3A_data">data</code></td>
<td>
<p>Is a data frame containing at least one column, that is the signal to be analyzed.</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_id">id</code></td>
<td>
<p>Is a CHARACTER containing the NAME of the column of data containing the identifier of the individual.
If this parameter is not entered when calling the function, a single individual is assumed and a linear regression is done instead
of the linear mixed-effects regression.</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_input">input</code></td>
<td>
<p>Is a CHARACTER or a VECTOR OF CHARACTERS containing the NAME(s) of data column(s) containing the EXCITATION vector(s).
If this parameter is not entered when calling the function,
the excitation is assumed to be unknown. In this case, the linear mixed-effect regression is still carried out but no coefficient is calculated
for the excitation term. The function then uses the parameters estimated by the regression to carry out an exponential fit of the signal
and build the estimated curve.
The function will consider as an excitation each column of data having a name contained in the input vector.
The function will return a coefficient for each one of the excitation variables included in the input vector.</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_time">time</code></td>
<td>
<p>Is a CHARACTER containing the NAME of the column of data containing the time vector. If this parameter is not entered when calling the function,
it is assumed that time steps are of 1 unit and the time vector is generated internally in the function.</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_signal">signal</code></td>
<td>
<p>Is a CHARACTER containing the NAME of the column of the data frame containing the SIGNAL to be studied.</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_dermethod">dermethod</code></td>
<td>
<p>is the derivative estimation method. The methods currently available are: &quot;gold&quot;,&quot;glla&quot; and &quot;fda&quot; (see their respective function for more details)</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_model">model</code></td>
<td>
<p>is the model to be used for analysis of the signal. The models available are &quot;1order&quot; and &quot;2order&quot;</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_order">order</code></td>
<td>
<p>is the maximum order of the derivative estimated when using <code>calculate.gold</code> or <code>calculate.glla</code>.
Using a higher order can enhance derivative estimation (see doi: <a href="https://doi.org/10.1080/00273171.2015.1123138">10.1080/00273171.2015.1123138</a>Chow et al.(2016))</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_pmin">pmin</code></td>
<td>
<p>is the minimum of the interval in which to vary the parameter (embedding number or spar according to derivative method chosen)</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_pmax">pmax</code></td>
<td>
<p>is the maximum of the interval in which to vary the parameter (embedding number or spar according to derivative method chosen)</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_pstep">pstep</code></td>
<td>
<p>is the step that will be considered when varying the parameter. For instance pmin=3, pmax=7 and pstep=2 and dermethod=&quot;gold&quot; will make the embedding number take
the values 3,5 and 7.</p>
</td></tr>
<tr><td><code id="optimum_param_+3A_verbose">verbose</code></td>
<td>
<p>Is a boolean that displays status messages of the function (and functions it calls) when set to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of three objects:
</p>

<ul>
<li><p>  analysis is a data.frame containing the resultmean object of the analysis made (result of the analyze.1order or analyze.2order function
according to model chosen) with the different values of embedding/spar and the resulting $R^2$.
</p>
</li>
<li><p>  summary_opt is a data.frame containing the analysis that had the best $R^2$ from the analysis data.frame previously mentioned
</p>
</li>
<li><p> d contains the optimum value of the embedding/spar
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+analyze.1order">analyze.1order</a></code> and <code><a href="#topic+analyze.2order">analyze.2order</a></code> for the estimation of equation coefficients in signals following a first and second order differential equation respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s2 &lt;- generate.panel.2order(time = 0:100,
                            excitation = c(rep(0,25),rep(1,76)),
                            y0 = 0,
                            v0= 0,
                            xi = 0.05,
                            period=10,
                            k=1,
                            yeq=0,
                            nind=4,
                            internoise = 0.2,
                            intranoise = 8)
resgold &lt;- optimum_param (data=s2,
                          id="id",
                          input="excitation",
                          time="time",
                          signal="signal",
                          model = "2order",
                          dermethod = "gold",
                          pmin = 3,
                          pmax = 13,
                          pstep = 2,
                          verbose = TRUE)
</code></pre>

<hr>
<h2 id='plot.doremi'>S3 method to plot DOREMI objects</h2><span id='topic+plot.doremi'></span>

<h3>Description</h3>

<p><code>plot.doremi</code> generates a plot with the observed values of the signal, the excitation values and the fitted
signal over time for each individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'doremi'
plot(x, ..., id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.doremi_+3A_x">x</code></td>
<td>
<p>DOREMI object resulting from <code><a href="#topic+analyze.1order">analyze.1order</a></code> or <code><a href="#topic+analyze.2order">analyze.2order</a></code> analysis</p>
</td></tr>
<tr><td><code id="plot.doremi_+3A_...">...</code></td>
<td>
<p>includes the additional arguments inherited from the generic plot method</p>
</td></tr>
<tr><td><code id="plot.doremi_+3A_id">id</code></td>
<td>
<p>Identifiers of the individuals to be represented in the plot.
By default, it will print the first six individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot with axis labels, legend and title. The axis labels and legend include the names of the variables set as input arguments.
The title includes the name of the DOREMI object result of the analysis. The function uses <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
to generate the graphs and so it is possible to override the values of axis labels, legend and title through ggplot commands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- generate.panel.1order(time= 0:100,
                                excitation = sin(0:100),
                                y0 = 0,
                                t0 = 0,
                                tau = 2,
                                k = 1,
                                yeq = 0,
                                nind = 2,
                                internoise = 0.1,
                                intranoise = 8)
myresult &lt;- analyze.1order(data = mydata,
                           id = "id",
                           input = "excitation",
                           time = "time",
                           signal = "signal")
plot(myresult)
</code></pre>

<hr>
<h2 id='plot.doremidata'>S3 method to plot DOREMIDATA objects</h2><span id='topic+plot.doremidata'></span>

<h3>Description</h3>

<p><code>plot.doremidata</code> generates a plot of the simulated signals resulting from the <code><a href="#topic+generate.panel.1order">generate.panel.1order</a></code> and <code><a href="#topic+generate.panel.2order">generate.panel.2order</a></code> functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'doremidata'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.doremidata_+3A_x">x</code></td>
<td>
<p>DOREMIDATA object resulting from the aforementioned functions</p>
</td></tr>
<tr><td><code id="plot.doremidata_+3A_...">...</code></td>
<td>
<p>includes the additional arguments inherited from the generic plot method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot with axis labels, legend and title. The title includes the name of the DOREMIDATA object result of the analysis.
The function uses <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
to generate the graphs and thus it is possible to override the values of axis labels, legend and title through ggplot commands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- generate.panel.1order(time=0:100,
                                excitation = c(rep(0,50),rep(1,51)),
                                nind = 6,
                                internoise = 0.2,
                                intranoise = 100)
plot(mydata)
</code></pre>

<hr>
<h2 id='plot.doremiparam'>S3 method to plot DOREMIPARAM objects</h2><span id='topic+plot.doremiparam'></span>

<h3>Description</h3>

<p><code>plot.doremiparam</code> generates a plot of the parameters resulting from the <code><a href="#topic+optimum_param">optimum_param</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'doremiparam'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.doremiparam_+3A_x">x</code></td>
<td>
<p>DOREMIPARAM object resulting from the aforementioned function</p>
</td></tr>
<tr><td><code id="plot.doremiparam_+3A_...">...</code></td>
<td>
<p>includes the additional arguments inherited from the generic plot method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot showing the evolution of the first/second order differential equation coefficients and R2 with the values taken by the embedding number/smoothing parameter
(see details of <code><a href="#topic+optimum_param">optimum_param</a></code> function).
The function uses <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
to generate the graphs and thus it is possible to override the values of axis labels, legend and title through ggplot commands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- generate.panel.1order(time = 0:130,
                          excitation = c(rep(0,30),rep(1,50),rep(0,51)),
                          nind = 5,
                          internoise = 0.2,
                          intranoise = 100)
myres&lt;- optimum_param (data = mydata,
                         id = "id",
                         input ="excitation",
                         time = "time",
                         signal = "signal",
                         model = "1order",
                         dermethod = "gold",
                         pmin = 3,
                         pmax = 11,
                         pstep = 2)
plot(myres)
</code></pre>

<hr>
<h2 id='predict.doremi'>S3 method to predict signal values in a DOREMI object when entering a new excitation</h2><span id='topic+predict.doremi'></span>

<h3>Description</h3>

<p><code>predict.doremi</code> predicts signal values with a DOREMI object when providing a new excitation vector(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'doremi'
predict(object, ..., newdata, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.doremi_+3A_object">object</code></td>
<td>
<p>DOREMI object result of an analysis with the function remi</p>
</td></tr>
<tr><td><code id="predict.doremi_+3A_...">...</code></td>
<td>
<p>Additional arguments inherited from generic predict method.</p>
</td></tr>
<tr><td><code id="predict.doremi_+3A_newdata">newdata</code></td>
<td>
<p>includes a data frame containing three columns or more:
</p>
<p>id (optional), indicating the individual identifier
</p>
<p>time, containing the time values
</p>
<p>excitation, being one or several columns containing the different excitations
used to estimate a new signal. As in the other methods for the predict function, the columns of newdata
must have the same names as those of the original object.</p>
</td></tr>
<tr><td><code id="predict.doremi_+3A_verbose">verbose</code></td>
<td>
<p>Is a boolean that displays status messages of the function when set to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the values of time, the values of the excitation and the predicted
values of the signal for the new excitation(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myresult &lt;- analyze.1order(data = cardio[id==1],
                 id="id",
                 input = "load",
                 time = "time",
                 signal = "hr")
#Copying cardio into a new data frame and modifying the excitation column
new_exc &lt;- cardio[id==1]
et &lt;- generate.excitation(amplitude = 100,
                          nexc = 6,
                          duration = 2,
                          deltatf = 1,
                          tmax = 49,
                          minspacing = 2)
new_exc$load &lt;- et$exc
new_exc$time &lt;- et$t
predresult &lt;- predict(myresult, newdata = new_exc)
</code></pre>

<hr>
<h2 id='print.doremi'>S3 method to print DOREMI objects</h2><span id='topic+print.doremi'></span>

<h3>Description</h3>

<p><code>print.doremi</code> prints the most important results of a DOREMI object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'doremi'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.doremi_+3A_x">x</code></td>
<td>
<p>DOREMI object</p>
</td></tr>
<tr><td><code id="print.doremi_+3A_...">...</code></td>
<td>
<p>includes the additional arguments inherited from the generic print method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the coefficients of the differential equation estimated (fixed coefficients, table $resultmean of the DOREMI object)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myresult &lt;- analyze.1order(data = cardio,
                 id = "id",
                 input = "load",
                 time = "time",
                 signal = "hr")
myresult
</code></pre>

<hr>
<h2 id='print.doremidata'>S3 method to print DOREMIDATA objects</h2><span id='topic+print.doremidata'></span>

<h3>Description</h3>

<p><code>print.doremidata</code> prints the a DOREMIDATA object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'doremidata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.doremidata_+3A_x">x</code></td>
<td>
<p>DOREMIDATA object</p>
</td></tr>
<tr><td><code id="print.doremidata_+3A_...">...</code></td>
<td>
<p>includes the additional arguments inherited from the generic print method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the DOREMIDATA object (datatable))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time &lt;- 0:100
data &lt;- generate.panel.2order(time = time,
                              y0 = 10,
                              v0 = 0,
                              xi = 0.1,
                              period = 30,
                              k = 1,
                              yeq = 2,
                              nind = 6,
                              internoise = 0.3,
                              intranoise = 5)
data
</code></pre>

<hr>
<h2 id='rotation'>Measurements of response time of 17 individuals when carrying out mental rotation tasks</h2><span id='topic+rotation'></span>

<h3>Description</h3>

<p>Data containing reaction time to a mental rotation task over a 60 day period for 17 individuals
doi: <a href="https://doi.org/10.1016/j.yhbeh.2012.12.007">10.1016/j.yhbeh.2012.12.007</a>(Courvoisier et al., 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rotation)
</code></pre>


<h3>Format</h3>

<p>A data frame with 619 rows and 5 variables
</p>

<dl>
<dt>id</dt><dd><p>positive integer, arbitrary identifier of the individual</p>
</dd>
<dt>sex</dt><dd><p>character, sex of the individual, as the study highlighted the difference in response time according to sex</p>
</dd>
<dt>days</dt><dd><p>positive integer,day since the beginning of the experiment</p>
</dd>
<dt>meanRT</dt><dd><p>positive integer, mean response time of the individual to execute the mental rotation task, in milliseconds (ms)</p>
</dd>
<dt>logmeanRT</dt><dd><p>natural logarithm of the mean response time</p>
</dd>
</dl>



<h3>Source</h3>

<p>Delphine S. Courvoisier, Olivier Renaud, Christian Geiser, Kerstin Paschke, Kevin Gaudy, Kirsten Jordan,
Sex hormones and mental rotation: An intensive longitudinal investigation,
</p>
<p>Hormones and Behavior,
</p>
<p>Volume 63, Issue 2,
</p>
<p>2013,
</p>
<p>Pages 345-351,
</p>
<p>doi: <a href="https://doi.org/10.1016/j.yhbeh.2012.12.007">10.1016/j.yhbeh.2012.12.007</a>
</p>

<hr>
<h2 id='summary.doremi'>S3 method for DOREMI object summary</h2><span id='topic+summary.doremi'></span>

<h3>Description</h3>

<p><code>summary.doremi</code> provides a summary containing the five lists of the DOREMI object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'doremi'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.doremi_+3A_object">object</code></td>
<td>
<p>DOREMI object (contains several lists)</p>
</td></tr>
<tr><td><code id="summary.doremi_+3A_...">...</code></td>
<td>
<p>includes the additional arguments inherited from the generic summary method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a summary containing the five lists of the DOREMI object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myresult &lt;- analyze.1order(data = cardio,
                 id = "id",
                 input = "load",
                 time = "time",
                 signal = "hr")
summary(myresult)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
