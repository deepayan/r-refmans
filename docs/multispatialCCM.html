<!DOCTYPE html><html><head><title>Help for package multispatialCCM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multispatialCCM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CCM_boot'>
<p>Run multispatial CCM algorithm on two time series</p></a></li>
<li><a href='#CCM_bootstrap'>
<p>Run multispatial CCM algorithm on two time series</p></a></li>
<li><a href='#ccmtest'>
<p>Test for significant causal signal</p></a></li>
<li><a href='#make_ccm_data'>
<p>Makes fake data for other functions</p></a></li>
<li><a href='#multispatialCCM-package'>
<p>multispatial convergent cross mapping analysis</p></a></li>
<li><a href='#SSR_check_signal'>
<p>Test process for auto-predictability.</p></a></li>
<li><a href='#SSR_pred_boot'>
<p>State space reconstruction function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multispatial Convergent Cross Mapping</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Clark</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Clark &lt;adam.tclark@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Description:</td>
<td>The multispatial convergent cross mapping algorithm can be used as a test for causal associations between pairs of processes represented by time series. This is a combination of convergent cross mapping (CCM), described in Sugihara et al., 2012, Science, 338, 496-500, and dew-drop regression, described in Hsieh et al., 2008, American Naturalist, 171, 71–80. The algorithm allows CCM to be implemented on data that are not from a single long time series. Instead, data can come from many short time series, which are stitched together using bootstrapping.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-22 17:17:32 UTC; aclark</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-22 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CCM_boot'>
Run multispatial CCM algorithm on two time series
</h2><span id='topic+CCM_boot'></span>

<h3>Description</h3>

<p>Runs the multispatial convergent cross mapping algorithm on two time series, A and B, to determine whether process A is a forcing process (i.e., causally affects) or process B. A and B do not need to be from single, long time series, but rather can be combinations of many (e.g. spatially-replicated) time series. See &quot;Arguments&quot; for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCM_boot(A, B, E, tau=1,
DesiredL=((tau*(E-1)+(E+1)):length(A)-E+2),
iterations=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCM_boot_+3A_a">A</code></td>
<td>

<p>Time series that is being tested as a forcing process (i.e., the causal process). Should be a single vector. If data come from multiple time series, gaps between these should be marked with an &quot;NA&quot;. E.g., c(1,2,3, NA, 1,2,3) implies two time series, each of length 3. Order of plots does not matter (because they will be shuffled during bootstrapping), but should match the order used in B.
</p>
</td></tr>
<tr><td><code id="CCM_boot_+3A_b">B</code></td>
<td>

<p>Time series that is being tested as a response process (i.e., the process being affected by the causal process). Should be a single vector. If data come from multiple time series, gaps between these should be marked with an &quot;NA&quot;. E.g., c(1,2,3, NA, 1,2,3) implies two time series, each of length 3. Order of plots does not matter (because they will be shuffled during bootstrapping), but should match the order used in A.
</p>
</td></tr>
<tr><td><code id="CCM_boot_+3A_e">E</code></td>
<td>

<p>Embedding dimension to use for the analysis. Should be based on dimension that provides the best prediction of process A against itself using function &quot;SSR_pred_boot&quot; (state space reconstruction).
</p>
</td></tr>
<tr><td><code id="CCM_boot_+3A_tau">tau</code></td>
<td>

<p>Number of time steps to use for lagged components in the attractor space. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="CCM_boot_+3A_desiredl">DesiredL</code></td>
<td>

<p>Desired library lengths for which to compute CCM. Defaults to the maximum possible length ((tau * (E - 1) + (E + 1)):length(A) - E + 2) (though number of resulting predictions may be smaller because of gaps in the time series). Shortening this list (e.g., only predicting every nth element) will reduce run-time for the algorithm, but may also reduce ability to detect causal relations.
</p>
</td></tr>
<tr><td><code id="CCM_boot_+3A_iterations">iterations</code></td>
<td>

<p>Number of iterations for bootstrapping. Defaults to 100.
</p>
</td></tr>
</table>


<h3>Value</h3>



<table>
<tr><td><code>A</code></td>
<td>
<p>Input process A</p>
</td></tr>
<tr><td><code>Aest</code></td>
<td>
<p>Estimated values of A from B using CCM, for the last (longest) library length considered</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Input process B</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Pearson correlation coefficient of estimates of A from B for each library length tested</p>
</td></tr>
<tr><td><code>varrho</code></td>
<td>
<p>Variance of rho based on bootstrapping for each library length</p>
</td></tr>
<tr><td><code>sdevrho</code></td>
<td>
<p>Standard error (i.e., sqrt(var/n)) of the mean of rho for each library length</p>
</td></tr>
<tr><td><code>Lobs</code></td>
<td>
<p>Library lengths for which rho was calculated</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Embedding dimension used for the analysis</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Time lag length used for the analysis</p>
</td></tr>
<tr><td><code>FULLinfo</code></td>
<td>
<p>Includes all output from .C call. Much of this is redundant with the variables listed above. Best not to look at this.</p>
</td></tr>

</table>


<h3>Warning</h3>

<p>If you do not separate distinct time series with &quot;NA&quot; as described in &quot;Arguments&quot;, they will not be treated as such!
</p>


<h3>Author(s)</h3>

<p>Adam Clark
</p>


<h3>References</h3>

<p>Sugihara, G., R. May, H. Ye, C. Hsieh, E. Deyle, M. Fogarty, and S. Munch. 2012. Detecting Causality in Complex Ecosystems. Science 338.
</p>
<p>Adam T. Clark, H. Ye, Forest Isbell, Ethan R. Deyle, Jane Cowles, David Tilman, and George Sugihara. 2015. Spatial ’convergent cross mapping’ to detect causal relationships from short time-series. Ecology, 96(6):1174–1181.
</p>


<h3>See Also</h3>

<p>SSR_pred_boot, SSR_check_signal, ccmtest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate data to use for multispatial CCM test
#See function for details - A is causally forced by B,
#but the reverse is not true.
ccm_data_out&lt;-make_ccm_data()
Accm&lt;-ccm_data_out$Accm
Bccm&lt;-ccm_data_out$Bccm

#Set optimal E - see multispatialCCM for details
E_A&lt;-2
E_B&lt;-3

#Run the CCM test
#E_A and E_B are the embedding dimensions for A and B.
#tau is the length of time steps used (default is 1)
#iterations is the number of bootsrap iterations (default 100)
# Does A "cause" B?
CCM_boot_A&lt;-CCM_boot(Accm, Bccm, E_A, tau=1, iterations=10)
# Does B "cause" A?
CCM_boot_B&lt;-CCM_boot(Bccm, Accm, E_B, tau=1, iterations=10)
</code></pre>

<hr>
<h2 id='CCM_bootstrap'>
Run multispatial CCM algorithm on two time series
</h2><span id='topic+CCM_bootstrap'></span>

<h3>Description</h3>

<p>Internal C function used by the CCM_boot function.
</p>

<hr>
<h2 id='ccmtest'>
Test for significant causal signal
</h2><span id='topic+ccmtest'></span>

<h3>Description</h3>

<p>Tests output from CCM_boot for significant causal signal. This function compares the 95% confidence intervals for esimated rho for the shortest and longest libraries calculated, and uses this to determine whether predictive power has significantly increased.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccmtest(CCM_boot_A, CCM_boot_B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccmtest_+3A_ccm_boot_a">CCM_boot_A</code></td>
<td>

<p>Output structure from a CCM test using CCM_boot
</p>
</td></tr>
<tr><td><code id="ccmtest_+3A_ccm_boot_b">CCM_boot_B</code></td>
<td>

<p>Output structure from a CCM test using CCM_boot
</p>
</td></tr>
</table>


<h3>Value</h3>



<table>
<tr><td><code>res</code></td>
<td>
<p>Structure containing the p-values for both tests.</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Adam Clark
</p>


<h3>References</h3>

<p>Sugihara, G., R. May, H. Ye, C. Hsieh, E. Deyle, M. Fogarty, and S. Munch. 2012. Detecting Causality in Complex Ecosystems. Science 338.
</p>
<p>Adam T. Clark, H. Ye, Forest Isbell, Ethan R. Deyle, Jane Cowles, David Tilman, and George Sugihara. 2015. Spatial ’convergent cross mapping’ to detect causal relationships from short time-series. Ecology, 96(6):1174–1181.
</p>


<h3>See Also</h3>

<p>CCM_boot, SSR_pred_boot, SSR_check_signal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate data to use for multispatial CCM test
#See function for details - A is causally forced by B,
#but the reverse is not true.
ccm_data_out&lt;-make_ccm_data()
Accm&lt;-ccm_data_out$Accm
Bccm&lt;-ccm_data_out$Bccm

#Set optimal E - see multispatialCCM for details
E_A&lt;-2
E_B&lt;-3

#Run the CCM test
#E_A and E_B are the embedding dimensions for A and B.
#tau is the length of time steps used (default is 1)
#iterations is the number of bootsrap iterations (default 100)
# Does A "cause" B?
CCM_boot_A&lt;-CCM_boot(Accm, Bccm, E_A, tau=1, iterations=10)
# Does B "cause" A?
CCM_boot_B&lt;-CCM_boot(Bccm, Accm, E_B, tau=1, iterations=10)

(CCM_significance_test&lt;-ccmtest(CCM_boot_A,
                   CCM_boot_B))
</code></pre>

<hr>
<h2 id='make_ccm_data'>
Makes fake data for other functions
</h2><span id='topic+make_ccm_data'></span>

<h3>Description</h3>

<p>Builds a fake data set of two interacting processes, based on the model in the Sugihara et al. publication below, and based on a two-species discrete-time competition model. In the model, process A is causally affected by process B, but process B is not influenced by process A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ccm_data(sp_sd=0.125, obs_sd=0.025,
Sstr=0.375, times=10, burnin=100,
number_of_chains=20, seednum=2718)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ccm_data_+3A_sp_sd">sp_sd</code></td>
<td>

<p>Standard deviation used to add process noise. If you are simulating multiple plots, this adds normally distributed noise with mean=0 to the growth rates of each species in different plots.
</p>
</td></tr>
<tr><td><code id="make_ccm_data_+3A_obs_sd">obs_sd</code></td>
<td>

<p>Standard deviation used to add observation error. Observation error is added to process X as a lognormal variable (X*rlnorm), with mean=0 on the lognormal scale.
</p>
</td></tr>
<tr><td><code id="make_ccm_data_+3A_sstr">Sstr</code></td>
<td>

<p>Forcing strength defining the effect of process B on process A.
</p>
</td></tr>
<tr><td><code id="make_ccm_data_+3A_times">times</code></td>
<td>

<p>Number of sequential observations desired for the time series in each plot (i.e., length of each independent time series)?
</p>
</td></tr>
<tr><td><code id="make_ccm_data_+3A_burnin">burnin</code></td>
<td>

<p>Burnin time before starting the experiment. This can be used to remove correlation among plots that occurs because of starting conditions.
</p>
</td></tr>
<tr><td><code id="make_ccm_data_+3A_number_of_chains">number_of_chains</code></td>
<td>

<p>Total number of time series (i.e., how many replicates will be assembled into a single long time series?)
</p>
</td></tr>
<tr><td><code id="make_ccm_data_+3A_seednum">seednum</code></td>
<td>

<p>Random seed used for simulation.
</p>
</td></tr>
</table>


<h3>Value</h3>



<table>
<tr><td><code>Accm</code></td>
<td>
<p>Time series for process A. Gaps between time series are indicated by a &quot;NA&quot; entry.</p>
</td></tr>
<tr><td><code>Bccm</code></td>
<td>
<p>Time series for process B. Gaps between time series are indicated by a &quot;NA&quot; entry.</p>
</td></tr>
<tr><td><code>time_ccm</code></td>
<td>
<p>Time indices corresponding to process A and B.</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Adam Clark
</p>


<h3>References</h3>

<p>Sugihara, G., R. May, H. Ye, C. Hsieh, E. Deyle, M. Fogarty, and S. Munch. 2012. Detecting Causality in Complex Ecosystems. Science 338.
</p>
<p>Adam T. Clark, H. Ye, Forest Isbell, Ethan R. Deyle, Jane Cowles, David Tilman, and George Sugihara. 2015. Spatial ’convergent cross mapping’ to detect causal relationships from short time-series. Ecology, 96(6):1174–1181.
</p>


<h3>See Also</h3>

<p>CCM_boot, SSR_pred_boot, SSR_check_signal, ccmtest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate data to use for multispatial CCM test
#See function for details - A is causally forced by B,
#but the reverse is not true.
ccm_data_out&lt;-make_ccm_data()
Accm&lt;-ccm_data_out$Accm
Bccm&lt;-ccm_data_out$Bccm
</code></pre>

<hr>
<h2 id='multispatialCCM-package'>
multispatial convergent cross mapping analysis
</h2><span id='topic+multispatialCCM-package'></span><span id='topic+multispatialCCM'></span>

<h3>Description</h3>

<p>A package for conducting convergent cross mapping (CCM) tests for causal relations for short, replicated time series. This package contains functions for implementing CCM on replicated data, as well as testing for significance of causal relationships that are detected. This package can also be used to implement state space reconstruction on replicated data (dew-drop regression, Hsieh et al.)
</p>


<h3>Details</h3>

<p>The functions in this package can analyze data from multiple replicated time series. To enter the time series into functions, they should be concatenated back-to-back into a single vector, with gaps between time series indicated by &quot;NA&quot;.
</p>
<p>The package follows the descriptions in Clark et al. There are two classes of functions: analytical, and diagnostic. Both of these should be used for conducting multispatial CCM.
</p>
<p>Analytical: CCM_boot is used to conduct multispatial CCM. SSR_pred_boot is used to find the optimal embedding dimension E for the CCM analysis, and can also be used to implement a state space reconstruction algorithm to predict process dynamics based on another process, or on its own historical dynamics.
</p>
<p>Diagnostic: SSR_check_signal is used to test whether dynamics from a time series are sufficiently nonlinear for application of CCM, and tests that they are not too dominated by noise. The ccmtest function is used to test the output from boot_CCM to determine whether it indicates a significant causal link between variables.
</p>
<p>Finally, the package also includes the function make_ccm_data, which can be used to make fake data from a simulation of two competing species. This function is used in the examples to show how to utilize the multispatial CCM functions.
</p>


<h3>Author(s)</h3>

<p>Adam Clark
</p>
<p>Maintainer: Adam Clark &lt;atclark@umn.edu&gt;
~~ The author and/or maintainer of the package ~~
</p>


<h3>References</h3>

<p>Sugihara, G., R. May, H. Ye, C. Hsieh, E. Deyle, M. Fogarty, and S. Munch. 2012. Detecting Causality in Complex Ecosystems. Science 338.
</p>
<p>Hsieh, C., C. Anderson, and G. Sugihara. 2008. Extending Nonlinear analysis to short ecological time series. American Naturalist 171:71–80.
</p>
<p>Adam T. Clark, H. Ye, Forest Isbell, Ethan R. Deyle, Jane Cowles, David Tilman, and George Sugihara. 2015. Spatial ’convergent cross mapping’ to detect causal relationships from short time-series. Ecology, 96(6):1174–1181.
</p>


<h3>See Also</h3>

<p>CCM_boot, SSR_pred_boot, SSR_check_signal, ccmtest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate data to use for multispatial CCM test
#See function for details - A is causally forced by B,
#but the reverse is not true.
ccm_data_out&lt;-make_ccm_data()
Accm&lt;-ccm_data_out$Accm
Bccm&lt;-ccm_data_out$Bccm

#Calculate optimal E
maxE&lt;-5 #Maximum E to test
#Matrix for storing output
Emat&lt;-matrix(nrow=maxE-1, ncol=2); colnames(Emat)&lt;-c("A", "B")

#Loop over potential E values and calculate predictive ability
#of each process for its own dynamics
for(E in 2:maxE) {
  #Uses defaults of looking forward one prediction step (predstep)
  #And using time lag intervals of one time step (tau)
  Emat[E-1,"A"]&lt;-SSR_pred_boot(A=Accm, E=E, predstep=1, tau=1)$rho
  Emat[E-1,"B"]&lt;-SSR_pred_boot(A=Bccm, E=E, predstep=1, tau=1)$rho
}

#Look at plots to find E for each process at which
#predictive ability rho is maximized
matplot(2:maxE, Emat, type="l", col=1:2, lty=1:2,
          xlab="E", ylab="rho", lwd=2)
legend("bottomleft", c("A", "B"), lty=1:2, col=1:2, lwd=2, bty="n")

#Results will vary depending on simulation.
#Using the seed we provide,
#maximum E for A should be 2, and maximum E for B should be 3.
#For the analyses in the paper, we use E=2 for all simulations.

E_A&lt;-2
E_B&lt;-3

#Check data for nonlinear signal that is not dominated by noise
#Checks whether predictive ability of processes declines with
#increasing time distance
#See manuscript and R code for details
signal_A_out&lt;-SSR_check_signal(A=Accm, E=E_A, tau=1,
  predsteplist=1:10)
signal_B_out&lt;-SSR_check_signal(A=Bccm, E=E_B, tau=1,
  predsteplist=1:10)

#Run the CCM test
#E_A and E_B are the embedding dimensions for A and B.
#tau is the length of time steps used (default is 1)
#iterations is the number of bootsrap iterations (default 100)
# Does A "cause" B?
#Note - increase iterations to 100 for consistant results
CCM_boot_A&lt;-CCM_boot(Accm, Bccm, E_A, tau=1, iterations=10)
# Does B "cause" A?
CCM_boot_B&lt;-CCM_boot(Bccm, Accm, E_B, tau=1, iterations=10)

#Test for significant causal signal
#See R function for details
(CCM_significance_test&lt;-ccmtest(CCM_boot_A,
                    CCM_boot_B))

#Plot results
plotxlimits&lt;-range(c(CCM_boot_A$Lobs, CCM_boot_B$Lobs))

#Plot "A causes B"
plot(CCM_boot_A$Lobs, CCM_boot_A$rho, type="l", col=1, lwd=2,
     xlim=c(plotxlimits[1], plotxlimits[2]), ylim=c(0,1),
     xlab="L", ylab="rho")
#Add +/- 1 standard error
matlines(CCM_boot_A$Lobs,
cbind(CCM_boot_A$rho-CCM_boot_A$sdevrho,
CCM_boot_A$rho+CCM_boot_A$sdevrho),
lty=3, col=1)

#Plot "B causes A"
lines(CCM_boot_B$Lobs, CCM_boot_B$rho, type="l", col=2, lty=2, lwd=2)
#Add +/- 1 standard error
matlines(CCM_boot_B$Lobs,
cbind(CCM_boot_B$rho-CCM_boot_B$sdevrho,
CCM_boot_B$rho+CCM_boot_B$sdevrho),
lty=3, col=2)

legend("topleft",
c("A causes B", "B causes A"),
lty=c(1,2), col=c(1,2), lwd=2, bty="n")
</code></pre>

<hr>
<h2 id='SSR_check_signal'>
Test process for auto-predictability.
</h2><span id='topic+SSR_check_signal'></span>

<h3>Description</h3>

<p>Predict elements of a process based historical observations of that process using cross-validation. Tests whether past observations are able to make good estimates of future elements of the time series.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSR_check_signal(A, E, tau = 1,
predsteplist = 1:10, matchSugi = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSR_check_signal_+3A_a">A</code></td>
<td>

<p>Process to be predicted. Should be a single vector. If data come from multiple time series, gaps between these should be marked with an &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code id="SSR_check_signal_+3A_e">E</code></td>
<td>

<p>Embedding dimension to use for the analysis. Should be based on dimension that provides the best prediction of process A against itself using function &quot;SSR_pred_boot&quot; (state space reconstruction).
</p>
</td></tr>
<tr><td><code id="SSR_check_signal_+3A_tau">tau</code></td>
<td>

<p>Number of time steps to use for lagged components in the attractor space. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="SSR_check_signal_+3A_predsteplist">predsteplist</code></td>
<td>

<p>Vector of time step lengths for prediction.
</p>
</td></tr>
<tr><td><code id="SSR_check_signal_+3A_matchsugi">matchSugi</code></td>
<td>

<p>Set to 1 to match results in Sugihara et al. publication described below, which removes only point i in cross validation - if 0, then removes all points within X(t-(E-1)):X(t+1)
</p>
</td></tr>
</table>


<h3>Value</h3>



<p>predatout=predatout,
rho_pre_slope=rho_pre_slope,
rho_predmaxCI=rho_predmaxCI
</p>
<table>
<tr><td><code>predatout</code></td>
<td>
<p>Vector of rho values describing predictive ability of process against itself for each prediction time step length</p>
</td></tr>
<tr><td><code>rho_pre_slope</code></td>
<td>
<p>Slope of rho values as a function of prediction distance</p>
</td></tr>
<tr><td><code>rho_predmaxCI</code></td>
<td>
<p>95% confidence interval for rho value corresponding to the longest prediction interval tested</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Adam Clark
</p>


<h3>References</h3>

<p>Sugihara, G., R. May, H. Ye, C. Hsieh, E. Deyle, M. Fogarty, and S. Munch. 2012. Detecting Causality in Complex Ecosystems. Science 338.
</p>
<p>Adam T. Clark, H. Ye, Forest Isbell, Ethan R. Deyle, Jane Cowles, David Tilman, and George Sugihara. 2015. Spatial ’convergent cross mapping’ to detect causal relationships from short time-series. Ecology, 96(6):1174–1181.
</p>


<h3>See Also</h3>

<p>CCM_boot, SSR_pred_boot, ccmtest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate data to use for multispatial CCM test
#See function for details - A is causally forced by B,
#but the reverse is not true.
ccm_data_out&lt;-make_ccm_data()
Accm&lt;-ccm_data_out$Accm
Bccm&lt;-ccm_data_out$Bccm

#Set optimal E - see multispatialCCM for details
E_A&lt;-2
E_B&lt;-3

#Check data for nonlinear signal that is not dominated by noise
#Checks whether predictive ability of processes declines with
#increasing time distance
#See manuscript and R code for details
signal_A_out&lt;-SSR_check_signal(A=Accm, E=E_A, tau=1,
  predsteplist=1:10)
signal_B_out&lt;-SSR_check_signal(A=Bccm, E=E_B, tau=1,
  predsteplist=1:10)
</code></pre>

<hr>
<h2 id='SSR_pred_boot'>
State space reconstruction function
</h2><span id='topic+SSR_pred_boot'></span>

<h3>Description</h3>

<p>Predict elements of A using B using state space reconstruction. If A=B, then the algorithm uses cross validation to assess the ability of historical portions of the A time series to predict future components of the time series. This function can be used to find the embedding dimension E that maximizes predictive ability.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSR_pred_boot(A, B = A, E, tau = 1, predstep = 1, matchSugi = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSR_pred_boot_+3A_a">A</code></td>
<td>

<p>Process to be compared to B, or to itself. Should be a single vector. If data come from multiple time series, gaps between these should be marked with an &quot;NA&quot;.
</p>
</td></tr>
<tr><td><code id="SSR_pred_boot_+3A_b">B</code></td>
<td>

<p>Process to be compared to A. If left empty, algorithm defaults to A=B.
</p>
</td></tr>
<tr><td><code id="SSR_pred_boot_+3A_e">E</code></td>
<td>

<p>Embedding dimension to use for the analysis. Should be based on dimension that provides the best prediction of process A against itself using function &quot;SSR_pred_boot&quot; (state space reconstruction).
</p>
</td></tr>
<tr><td><code id="SSR_pred_boot_+3A_tau">tau</code></td>
<td>

<p>Number of time steps to use for lagged components in the attractor space. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="SSR_pred_boot_+3A_predstep">predstep</code></td>
<td>

<p>Number of time steps into the future to make predictions from past observations.
</p>
</td></tr>
<tr><td><code id="SSR_pred_boot_+3A_matchsugi">matchSugi</code></td>
<td>

<p>Set to 1 to match results in Sugihara et al. publication described below, which removes only point i in cross validation - if 0, then removes all points within X(t-(E-1)):X(t+1)
</p>
</td></tr>
</table>


<h3>Value</h3>



<table>
<tr><td><code>A</code></td>
<td>
<p>Returns variable from input</p>
</td></tr>
<tr><td><code>Aest</code></td>
<td>
<p>Estimated values for A</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Returns variable from input</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Returns variable from input</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Returns variable from input</p>
</td></tr>
<tr><td><code>pAlength</code></td>
<td>
<p>Length of A from input</p>
</td></tr>
<tr><td><code>pBlength</code></td>
<td>
<p>Length of B from input</p>
</td></tr>
<tr><td><code>predstep</code></td>
<td>
<p>Returns variable from input</p>
</td></tr>
<tr><td><code>prepvec</code></td>
<td>
<p>Returns 1 if A and B were treated as same process</p>
</td></tr>
<tr><td><code>pmatchSugi</code></td>
<td>
<p>Returns variable from input</p>
</td></tr>
<tr><td><code>acceptablelib</code></td>
<td>
<p>List of library lengths that were used for the analysis, adjusting for ends and gaps in the library</p>
</td></tr>
<tr><td><code>plengthacceptablelib</code></td>
<td>
<p>Length of library that was used for the analysis</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Pearson correlation coefficient describing predictive ability of A against B or against itself</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Adam Clark
</p>


<h3>References</h3>

<p>Sugihara, G., R. May, H. Ye, C. Hsieh, E. Deyle, M. Fogarty, and S. Munch. 2012. Detecting Causality in Complex Ecosystems. Science 338.
</p>
<p>Adam T. Clark, H. Ye, Forest Isbell, Ethan R. Deyle, Jane Cowles, David Tilman, and George Sugihara. 2015. Spatial ’convergent cross mapping’ to detect causal relationships from short time-series. Ecology, 96(6):1174–1181.
</p>


<h3>See Also</h3>

<p>CCM_boot, SSR_check_signal, ccmtest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate data to use for multispatial CCM test
#See function for details - A is causally forced by B,
#but the reverse is not true.
ccm_data_out&lt;-make_ccm_data()
Accm&lt;-ccm_data_out$Accm
Bccm&lt;-ccm_data_out$Bccm

#Calculate optimal E
maxE&lt;-5 #Maximum E to test
#Matrix for storing output
Emat&lt;-matrix(nrow=maxE-1, ncol=2); colnames(Emat)&lt;-c("A", "B")

#Loop over potential E values and calculate predictive ability
#of each process for its own dynamics
for(E in 2:maxE) {
  #Uses defaults of looking forward one prediction step (predstep)
  #And using time lag intervals of one time step (tau)
  Emat[E-1,"A"]&lt;-SSR_pred_boot(A=Accm, E=E, predstep=1, tau=1)$rho
  Emat[E-1,"B"]&lt;-SSR_pred_boot(A=Bccm, E=E, predstep=1, tau=1)$rho
}

#Look at plots to find E for each process at which
#predictive ability rho is maximized
matplot(2:maxE, Emat, type="l", col=1:2, lty=1:2,
          xlab="E", ylab="rho", lwd=2)
legend("bottomleft", c("A", "B"), lty=1:2, col=1:2, lwd=2, bty="n")

#Results will vary depending on simulation.
#Using the seed we provide,
#maximum E for A should be 2, and maximum E for B should be 3.
#For the analyses in the paper, we use E=2 for all simulations.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
