<!DOCTYPE html><html><head><title>Help for package SIBER</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SIBER}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SIBER-package'><p>SIBER: Stable Isotope Bayesian Ellipses in R</p></a></li>
<li><a href='#addEllipse'><p>Adds an ellipse around some data to an existing plot</p></a></li>
<li><a href='#allCentroidVectors'><p>Plot the pairwise distances and angles describing the difference between</p>
centroids of all groups</a></li>
<li><a href='#allgroups'><p> The entire set of Geese isotope data</p></a></li>
<li><a href='#bayesianLayman'><p>Calculate Layman metrics on Bayesian posterior samples of a community</p></a></li>
<li><a href='#bayesianOverlap'><p>Calculate the overlap between two ellipses based on their posterior</p>
distributions.</a></li>
<li><a href='#communityMetricsML'><p>Calculate the point estimates of the Layman metrics for each community</p></a></li>
<li><a href='#concdepdemo'><p>A set of concentration dependence values for stable isotope analysis</p></a></li>
<li><a href='#correctionsdemo'><p>A set of trophic discrimination factors for brent geese feeding on their</p>
sources.</a></li>
<li><a href='#createSiberObject'><p>Read in SIBER format data and generate the SIBER object</p></a></li>
<li><a href='#demo.siber.data'><p>Simulated d13C and d15N isotope-space data</p></a></li>
<li><a href='#demo.siber.data.2'><p>Simulated d13C and d15N isotope-space data</p></a></li>
<li><a href='#ellipseBackTransform'><p>Back-transform a z-score siber ellipse to original location and scale.</p></a></li>
<li><a href='#ellipseInOut'><p>Test whether a set of points are inside or outside a defined circle</p></a></li>
<li><a href='#ellipsoidTransform'><p>Apply a normalisation transformation to vectors of data onto ellipsoids</p></a></li>
<li><a href='#extractPosteriorMeans'><p>Extract posterior means from call to <code>siberMVN</code></p></a></li>
<li><a href='#fitEllipse'><p>Fit a multivariate normal distribution to x and y data using jags</p></a></li>
<li><a href='#geese1demo'><p>A single group of the geese data</p></a></li>
<li><a href='#geese2demo'><p>A single group of the geese data</p></a></li>
<li><a href='#genCircle'><p>Create a sequence of points on a circle</p></a></li>
<li><a href='#generateSiberCommunity'><p>A utility function to simulate a single community comprised of groups</p></a></li>
<li><a href='#generateSiberData'><p>A utility function to simulate isotope data for several communities</p></a></li>
<li><a href='#generateSiberGroup'><p>A utility function to simulate a single group of data</p></a></li>
<li><a href='#groupMetricsML'><p>Calculate maximum likelihood based measures of dispersion of bivariate data</p></a></li>
<li><a href='#hullArea'><p>Calculate the area of a convex hull given its coordinates</p></a></li>
<li><a href='#kapow'><p>KAPOW!</p></a></li>
<li><a href='#laymanMetrics'><p>Calculates the 6 Layman metrics on a vector of x and y data</p></a></li>
<li><a href='#maxLikOverlap'><p>Calculate the overlap between two ellipses based on the maximum likelihood</p>
fitted ellipses.</a></li>
<li><a href='#mongoose'><p>A set of isotope observations for mongooses nested within packs</p></a></li>
<li><a href='#plotCommunityHulls'><p>Adds convex hulls to each community to an existing plot</p></a></li>
<li><a href='#plotGroupEllipses'><p>Adds ellipses to an existing plot for each of your groups</p></a></li>
<li><a href='#plotGroupHulls'><p>Plots illustrative convex hulls for each group within all communities</p></a></li>
<li><a href='#plotSiberObject'><p>Creates an isotope scatterplot and provides a wrapper to ellipse and hull plotting</p></a></li>
<li><a href='#pointsToEllipsoid'><p>Test whether a set of points are inside or outside a defined ellipse</p></a></li>
<li><a href='#posteriorSEA'><p>Calculate the SEA based on a posterior distribution of Sigma</p></a></li>
<li><a href='#siberCentroids'><p>Calculate the polar form of the vector between pairs of ellipse centroids</p></a></li>
<li><a href='#siberConvexhull'><p>Calculate metrics and plotting information for convex hulls</p></a></li>
<li><a href='#siberDensityPlot'><p>Plot credible intervals as shaded boxplots using</p>
<code>hdr.boxplot</code></a></li>
<li><a href='#siberEllipses'><p>Calculate the Bayesian Standard Ellipse Area for all groups</p></a></li>
<li><a href='#siberKapow'><p>Calculates the boundary of a union of ellipses</p></a></li>
<li><a href='#siberMVN'><p>Fit Bayesian bivariate normal distributions to each group in each community</p></a></li>
<li><a href='#sigmaSEA'><p>Calculate metrics corresponding to the Standard Ellipse based on a</p>
covariance matrix</a></li>
<li><a href='#sourcesdemo'><p>A set of isotope observations on food sources of brent geese</p></a></li>
<li><a href='#specificCentroidVectors'><p>Calculate the pairwise distances and angles describing the difference between</p>
centroids of paired groups</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stable Isotope Bayesian Ellipses in R</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.9</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS (&gt;= 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>hdrcde, graphics, grDevices, mnormt, rjags, spatstat.geom,
spatstat.utils, stats, tidyr, dplyr, ggplot2, magrittr, purrr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda, ellipse, knitr, rmarkdown, viridis</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits bi-variate ellipses to stable isotope data using Bayesian
    inference with the aim being to describe and compare their isotopic
    niche.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-19 08:46:46 UTC; andrewjackson</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Jackson <a href="https://orcid.org/0000-0001-7334-0434"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Andrew Parnell <a href="https://orcid.org/0000-0001-7956-7939"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Jackson &lt;jacksoan@tcd.ie&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-19 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SIBER-package'>SIBER: Stable Isotope Bayesian Ellipses in R</h2><span id='topic+SIBER'></span><span id='topic+SIBER-package'></span>

<h3>Description</h3>

<p>Fits bi-variate ellipses to stable isotope data using Bayesian inference with the aim being to describe and compare their isotopic niche.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andrew Jackson <a href="mailto:jacksoan@tcd.ie">jacksoan@tcd.ie</a> (<a href="https://orcid.org/0000-0001-7334-0434">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Andrew Parnell (<a href="https://orcid.org/0000-0001-7956-7939">ORCID</a>)
</p>
</li></ul>


<hr>
<h2 id='addEllipse'>Adds an ellipse around some data to an existing plot</h2><span id='topic+addEllipse'></span>

<h3>Description</h3>

<p>This function adds an ellipse based on means and covariance to an existing
plot. The ellipse can be scaled so as to represent any prediction interval of
the data you wish, or alternatively any confidence interval of the bivariate
means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEllipse(
  mu,
  sigma,
  m = NULL,
  n = 100,
  p.interval = NULL,
  ci.mean = FALSE,
  small.sample = FALSE,
  do.plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addEllipse_+3A_mu">mu</code></td>
<td>
<p>a vector of length two specifying the bivariate means</p>
</td></tr>
<tr><td><code id="addEllipse_+3A_sigma">sigma</code></td>
<td>
<p>a 2x2 covariance matrix for the data</p>
</td></tr>
<tr><td><code id="addEllipse_+3A_m">m</code></td>
<td>
<p>is the sample size of the dataset on which the ellipse is to be
plotted. This is only informative if calculating the confidence interval of
the bivariate mean, which requires a correction of <code>1/sqrt(m)</code>.
Defaults to NULL and has no effect.</p>
</td></tr>
<tr><td><code id="addEllipse_+3A_n">n</code></td>
<td>
<p>the number of data points to be used to plot the ellipse. More
points makes for a smoother ellipse, especially if it has high
eccentricity. Defaults to <code>n = 100</code>.</p>
</td></tr>
<tr><td><code id="addEllipse_+3A_p.interval">p.interval</code></td>
<td>
<p>the quantile to be used to construct a prediction ellipse
that contains p.interval proportion of the data. By default,
<code>p.interval = NULL</code> and the Standard Ellipse is drawn which contains
approximately 40% of the data. Setting <code>p.interval = 0.95</code> will
result in an ellipse that contains approximately 95% of the data.</p>
</td></tr>
<tr><td><code id="addEllipse_+3A_ci.mean">ci.mean</code></td>
<td>
<p>a logical that determines whether the ellipse drawn is a
prediction ellipse of the entire data, or a confidence interval of the
bivariate means. Defaults to <code>FALSE</code>. If set to <code>TRUE</code>, then
<code>p.interval</code> can be used to generate an appropriate % confidence
interval of the bivariate means.</p>
</td></tr>
<tr><td><code id="addEllipse_+3A_small.sample">small.sample</code></td>
<td>
<p>a logical that determines whether or not the small sample
size correction is to be applied (TRUE) or not (FALSE). Defaults to FALSE.
This allows SEAc rather than SEA to be plotted, but the correction can be
applied to any percentile ellipse.</p>
</td></tr>
<tr><td><code id="addEllipse_+3A_do.plot">do.plot</code></td>
<td>
<p>A logical that determines whether plotting should occur (TRUE
and default) or not (FALSE). Setting to false is useful if you want to
access the coordinates of the ellipse in order to calculate overlap between
ellipses for example.</p>
</td></tr>
<tr><td><code id="addEllipse_+3A_...">...</code></td>
<td>
<p>additional arguments as a list to be passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;n x 2&#8288;</code> matrix comprising the x and y coordinates of the
ellipse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-- NOT RUN --
# data(demo.siber.data)
# my.siber.data &lt;- createSiberObject(demo.siber.data)
# communityMetricsML(my.siber.data)
# -- END --
</code></pre>

<hr>
<h2 id='allCentroidVectors'>Plot the pairwise distances and angles describing the difference between
centroids of all groups</h2><span id='topic+allCentroidVectors'></span>

<h3>Description</h3>

<p>Plots the posterior densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allCentroidVectors(centroids, upper = TRUE, do.plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allCentroidVectors_+3A_centroids">centroids</code></td>
<td>
<p>the list containing distance and angle matrices as returned
by <code><a href="#topic+siberCentroids">siberCentroids()</a></code>.</p>
</td></tr>
<tr><td><code id="allCentroidVectors_+3A_upper">upper</code></td>
<td>
<p>a logical determining whether to plot the upper or lower
triangle of angles. Defaults to TRUE which is the upper triangle and
returns the angle from the second ellipse to the first by centering on the
first centroid.</p>
</td></tr>
<tr><td><code id="allCentroidVectors_+3A_do.plot">do.plot</code></td>
<td>
<p>a logical indicating whether plotting should be done or not.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="allCentroidVectors_+3A_...">...</code></td>
<td>
<p>additional arguments to pass onwards, not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nice plot. You can get the corresponding matrices used to generate
the plots if you ask for it nicely: the_data &lt;-
plotCentroidVectors(centroids)
</p>

<hr>
<h2 id='allgroups'> The entire set of Geese isotope data </h2><span id='topic+allgroups'></span>

<h3>Description</h3>

<p>A 5 column matrix containing isotopic estimates for 251 geese collected at 8
different time points. 
The first column indicates the time point group, the second and third are 
d15N (Nitrogen) and d13C 
(Carbon) isotopic values for the Geese plasma, the third and fourth are 
d15N and d13C values for 
the Geese cells. Note that these are raw values; they have not undergone
fractionation correction.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(allgroups)</code></pre>


<h3>Format</h3>

<p>A data frame with 251 observations on the following 5 variables.
</p>

<dl>
<dt><code>Group</code></dt><dd><p>Group number / time point</p>
</dd>
<dt><code>d15NPl</code></dt><dd><p>d15N plasma</p>
</dd>
<dt><code>d13CPl</code></dt><dd><p>d13C plasma</p>
</dd>
<dt><code>d15NCe</code></dt><dd><p>d15N cells</p>
</dd>
<dt><code>d13CCe</code></dt><dd><p>d13C cells</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>#see siarmenu() and option 9 for a demo using part of this data
</code></pre>

<hr>
<h2 id='bayesianLayman'>Calculate Layman metrics on Bayesian posterior samples of a community</h2><span id='topic+bayesianLayman'></span>

<h3>Description</h3>

<p>This function loops over the posterior distribution of group means within
each community and generates the corresponding Bayesian estimate of the 6
Layman metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesianLayman(mu.post)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesianLayman_+3A_mu.post">mu.post</code></td>
<td>
<p>a list of length n.communities, with each list element
containing the estimated means of the groups comprising that community. The
typical workflow to generate mu.post follows. The
Bayesian ellipses are fitted using <code><a href="#topic+siberEllipses">siberEllipses()</a></code>, then the
posterior means (centre of mass of each group) is extracted using
<code><a href="#topic+extractPosteriorMeans">extractPosteriorMeans()</a></code>. See the example below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length n.communities, with each element containing a
matrix of 6 columns, each representing the Bayesian posterior distribution
of the 6 Layman metrics for each of the posterior draws recorded by the
fitting process (i.e. which determines the number of rows in this matrix).
</p>

<hr>
<h2 id='bayesianOverlap'>Calculate the overlap between two ellipses based on their posterior
distributions.</h2><span id='topic+bayesianOverlap'></span>

<h3>Description</h3>

<p>This function loops over the posterior distribution of the means and
covariances matrices of two specified groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesianOverlap(
  ellipse1,
  ellipse2,
  ellipses.posterior,
  draws = 10,
  p.interval = 0.95,
  n = 100,
  do.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesianOverlap_+3A_ellipse1">ellipse1</code></td>
<td>
<p>character code of the form <code>"x.y"</code> where <code>x</code> is an
integer indexing the community, and <code>y</code> an integer indexing the group
within that community. This specifies the first of two ellipses whose
overlap will be compared.</p>
</td></tr>
<tr><td><code id="bayesianOverlap_+3A_ellipse2">ellipse2</code></td>
<td>
<p>same as <code>ellipse1</code> specifying a second ellipse.</p>
</td></tr>
<tr><td><code id="bayesianOverlap_+3A_ellipses.posterior">ellipses.posterior</code></td>
<td>
<p>a list of posterior means and covariances fitted
using <code><a href="#topic+siberEllipses">siberEllipses()</a></code>.</p>
</td></tr>
<tr><td><code id="bayesianOverlap_+3A_draws">draws</code></td>
<td>
<p>an integer specifying how many of the posterior draws are to be
used to estimate the posterior overlap. Defaults to <code>10</code> which uses
the first 10 draws. In all cases, the selection will be <code>1:draws</code> so
independence of the posterior draws is assumed. Setting to <code>NULL</code> will
use all the draws (WARNING - like to be very slow).</p>
</td></tr>
<tr><td><code id="bayesianOverlap_+3A_p.interval">p.interval</code></td>
<td>
<p>the prediction interval used to scale the ellipse as per
<code><a href="#topic+addEllipse">addEllipse()</a></code>.</p>
</td></tr>
<tr><td><code id="bayesianOverlap_+3A_n">n</code></td>
<td>
<p>the number of points on the edge of the ellipse used to define it.
Defaults to <code>100</code> as per <code><a href="#topic+addEllipse">addEllipse()</a></code>.</p>
</td></tr>
<tr><td><code id="bayesianOverlap_+3A_do.plot">do.plot</code></td>
<td>
<p>logical switch to determine whether the corresponding ellipses
should be plotted or not. A use-case would be in conjunction with a low
numbered <code>draws</code> so as to visualise a relatively small number of the
posterior ellipses. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame comprising three columns: the area of overlap, the area
of the first ellipse and the area of the second ellipse and as many rows as
specified by <code>draws</code>.
</p>

<hr>
<h2 id='communityMetricsML'>Calculate the point estimates of the Layman metrics for each community</h2><span id='topic+communityMetricsML'></span>

<h3>Description</h3>

<p>This function loops over each community, determines the centre of mass
(centroid) of each of the groups comprising the community using the basic
<code><a href="base.html#topic+mean">base::mean()</a></code> function independently on the marginal x and y vectors,
and calculates the corresponding 6 Layman metrics based on these points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communityMetricsML(siber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="communityMetricsML_+3A_siber">siber</code></td>
<td>
<p>a siber object as created by <code><a href="#topic+createSiberObject">createSiberObject()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 6 x m matrix of the 6 Layman metrics of dX_range, dY_range, TA,
CD, MNND and SDNND in rows, for each community by column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.siber.data)
my.siber.data &lt;- createSiberObject(demo.siber.data)
communityMetricsML(my.siber.data)

</code></pre>

<hr>
<h2 id='concdepdemo'>A set of concentration dependence values for stable isotope analysis</h2><span id='topic+concdepdemo'></span>

<h3>Description</h3>

<p>A dataset of concentration dependent corrections for 4 food sources of brent
geese. Intended for use in a Stable Isotope Mixing Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(concdepdemo)
</code></pre>


<h3>Format</h3>

<p>A 5 column, 4 row data.frame object containing the concentration
dependence data for the geese1demo and geese2demo datasets. The first
column Source is a factor determining the name of the source. The second
and third columns are the mean d13C and mean d15N concentration values for
each source respectively. Columns 3 and 5 are the standard deviations but
these are not currently implemented in either simmr or MixSIAR stable
isotope mixing models. Note that the order of the isotope data has been
swapped since siar in order to present d13C as the first isotope and hence
on the x-axis by default.
</p>


<h3>Author(s)</h3>

<p>Rich Inger
</p>

<hr>
<h2 id='correctionsdemo'>A set of trophic discrimination factors for brent geese feeding on their
sources.</h2><span id='topic+correctionsdemo'></span>

<h3>Description</h3>

<p>A dataset of estimated trophic discrimination factors for brent geese. The
data assume the same TDF for each food source. Intended for use in a Stable
Isotope Mixing Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(correctionsdemo)
</code></pre>


<h3>Format</h3>

<p>A 5 column, 4 row data.frame object containing the trophic
discrimination factors for brent geese consumers relative to 4 of their food
sources (in Ireland). The first column Source is a factor determining the
name of the source. The second and third columns are the mean d13C and mean
d15N TDF values for each source respectively. Columns 3 and 5 are the standard
deviations of the d13C and d15N TDF values respectively. Note that the order of
the isotope data has been swapped since siar in order to present d13C as
the first isotope and hence on the x-axis by default.
</p>


<h3>Author(s)</h3>

<p>Rich Inger
</p>

<hr>
<h2 id='createSiberObject'>Read in SIBER format data and generate the SIBER object</h2><span id='topic+createSiberObject'></span>

<h3>Description</h3>

<p>This function takes raw isotope data and creates a SIBER object which
contains information in a structured manner that enables other functions to
loop over groups and communities, fit Bayesian ellipses, and afterwards,
generate various plots, and additional analyses on the posterior
distributions.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSiberObject_+3A_data.in">data.in</code></td>
<td>
<p>Specified In a basic R data.frame or matrix comprising 4
columns. The first two of which are typically isotope tracers, then the
third is a column that indicates the group membership, and the fourth
column indicates the community membership of an observation. Communities
labels should be entered  as sequential numbers. As of v2.0.1 group labels
can be entered as strings and/or numbers and need not be sequential.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A siber list object, that contains data that helps with various model
fitting and plotting.
</p>

<ul>
<li> <p><code>original.data</code> The original data as
passed into this function
</p>
</li>
<li> <p><code>iso.summary</code> The max, min, mean and
median of the isotope data useful for plotting
</p>
</li>
<li> <p><code>sample.sizes</code> The
number of observations tabulated by group and community
</p>
</li>
<li> <p><code>raw.data</code> A list object of length equal to the number of communities
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(demo.siber.data)
my.siber.data &lt;- createSiberObject(demo.siber.data)
names(my.siber.data)

</code></pre>

<hr>
<h2 id='demo.siber.data'>Simulated d13C and d15N isotope-space data</h2><span id='topic+demo.siber.data'></span>

<h3>Description</h3>

<p>Data for two communities, created by <code><a href="#topic+generateSiberData">generateSiberData()</a></code> used
to generate the vignette and illustrates the main functionality of SIBER.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(demo.siber.data)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code> containing four variables.
The first and second variables are generic isotopes called <code>iso1</code>
and <code>iso2</code>. The third variable <code>group</code> identifies which group
within a community an observation belongs. Group are required to be
integers in sequential order starting at <code>1</code> and numbering should
restart within each community. The fourth variable <code>community</code>
identifies which community an observation belongs, and again is required
to be an integer in sequential order staring at <code>1</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Jackson
</p>

<hr>
<h2 id='demo.siber.data.2'>Simulated d13C and d15N isotope-space data</h2><span id='topic+demo.siber.data.2'></span>

<h3>Description</h3>

<p>Data for two communities, created by <code><a href="#topic+generateSiberData">generateSiberData()</a></code> used
to generate the vignette and illustrates the main functionality of SIBER.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(demo.siber.data.2)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code> containing four variables.
The first and second variables are generic isotopes called <code>iso1</code>
and <code>iso2</code>. The third variable <code>group</code> identifies which group
within a community an observation belongs. Group are required to be
integers in sequential order starting at <code>1</code> and numbering should
restart within each community. The fourth variable <code>community</code>
identifies which community an observation belongs, and again is required
to be an integer in sequential order staring at <code>1</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew Jackson
</p>

<hr>
<h2 id='ellipseBackTransform'>Back-transform a z-score siber ellipse to original location and scale.</h2><span id='topic+ellipseBackTransform'></span>

<h3>Description</h3>

<p>Back-transforms a bivariate siber ellipse fitted to z-scored data to the
original location and scale. Not intended for direct call by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipseBackTransform(jags.output, siber, idx.community, idx.group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipseBackTransform_+3A_jags.output">jags.output</code></td>
<td>
<p>a mcmc.list object of posterior samples created by
<code><a href="rjags.html#topic+rjags-package">rjags::rjags()</a></code>. In siber this is created typically by <code><a href="#topic+fitEllipse">fitEllipse()</a></code></p>
</td></tr>
<tr><td><code id="ellipseBackTransform_+3A_siber">siber</code></td>
<td>
<p>a siber object as created by createSiberObject.</p>
</td></tr>
<tr><td><code id="ellipseBackTransform_+3A_idx.community">idx.community</code></td>
<td>
<p>an integer specifying which community to back-transform.</p>
</td></tr>
<tr><td><code id="ellipseBackTransform_+3A_idx.group">idx.group</code></td>
<td>
<p>an integer specifying which group to back-transform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 6 x n matrix representing the back-transformed posterior
distributions of the bivariate normal distribution for a specified group
within a specified community, where n is the number of
posterior draws in the saved sample. The first four columns are the
covariance matrix Sigma in vector format. This vector converts to the
covariance matrix as <code>matrix(v[1:4], nrow = 2, ncol = 2)</code>. The
remaining two columns are the back-transformed means.
</p>

<hr>
<h2 id='ellipseInOut'>Test whether a set of points are inside or outside a defined circle</h2><span id='topic+ellipseInOut'></span>

<h3>Description</h3>

<p>Takes a
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipseInOut(Z, p = 0.95, r = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipseInOut_+3A_z">Z</code></td>
<td>
<p>the <code style="white-space: pre;">&#8288;i x d&#8288;</code> matrix of data points to be tested.</p>
</td></tr>
<tr><td><code id="ellipseInOut_+3A_p">p</code></td>
<td>
<p>the percentile of the ellipse to be tested.</p>
</td></tr>
<tr><td><code id="ellipseInOut_+3A_r">r</code></td>
<td>
<p>a manually defined radius of the circle to be used. Setting <code>r</code>
to be anything other than NULL will override the choice of <code>p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating whether the point is inside or outside
the circle
</p>

<hr>
<h2 id='ellipsoidTransform'>Apply a normalisation transformation to vectors of data onto ellipsoids</h2><span id='topic+ellipsoidTransform'></span>

<h3>Description</h3>

<p>Takes a vector <code>x</code> and transforms the points onto the same geometry of
a normalised ellipse given by the inverse of the covariance matrix
<code>SigSqrt</code> and the location <code>mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipsoidTransform(x, SigSqrt, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipsoidTransform_+3A_x">x</code></td>
<td>
<p>the vector of data points to be transformed</p>
</td></tr>
<tr><td><code id="ellipsoidTransform_+3A_sigsqrt">SigSqrt</code></td>
<td>
<p>the inverse of the covariance matrix</p>
</td></tr>
<tr><td><code id="ellipsoidTransform_+3A_mu">mu</code></td>
<td>
<p>the vector of means of the ellipse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of transformed data points
</p>

<hr>
<h2 id='extractPosteriorMeans'>Extract posterior means from call to <code><a href="#topic+siberMVN">siberMVN</a></code></h2><span id='topic+extractPosteriorMeans'></span>

<h3>Description</h3>

<p>This function extracts the posterior means from a call to
<code><a href="#topic+siberMVN">siberMVN()</a></code> which can then be used to calculate Bayesian layman
metrics. This function is designed to create an array of posterior means
that is more easily interrogated for plotting and summary statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractPosteriorMeans(siber, post)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractPosteriorMeans_+3A_siber">siber</code></td>
<td>
<p>a siber object as created by <code><a href="#topic+createSiberObject">createSiberObject()</a></code>.</p>
</td></tr>
<tr><td><code id="extractPosteriorMeans_+3A_post">post</code></td>
<td>
<p>a list containing the posterior estimated parameters fitted to
each group within every community. See <code><a href="#topic+siberMVN">siberMVN()</a></code> which creates
this object for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length n.communities with each entry representing a
<code>n.draws * 2 * n.groups</code> array of rows equal to the number of posterior
samples, 2 columns representing the two means of the multivariate data and
<code>n.groups</code> the number of groups within the focal community.
</p>

<hr>
<h2 id='fitEllipse'>Fit a multivariate normal distribution to x and y data using jags</h2><span id='topic+fitEllipse'></span>

<h3>Description</h3>

<p>This function contains and defines the jags model script used to fit a
bivariate normal distribution to a vector of x and y data. Although not
intended for direct calling by users, it presents a quick way to fit a model
to a single group of data. Advanced users should be able to manipulate the
contained jags model to fit more complex models using different likelihoods,
such as multivariate lognormal distributions, multivariate gamma
distributions etc...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitEllipse(x, y, parms, priors, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitEllipse_+3A_x">x</code></td>
<td>
<p>a vector of data representing the x-axis</p>
</td></tr>
<tr><td><code id="fitEllipse_+3A_y">y</code></td>
<td>
<p>a vector of data representing the y-axis</p>
</td></tr>
<tr><td><code id="fitEllipse_+3A_parms">parms</code></td>
<td>
<p>a list containing four items providing details of the
<code><a href="rjags.html#topic+rjags-package">rjags::rjags()</a></code> run to be sampled.
</p>

<ul>
<li> <p><code>n.iter</code> The number of iterations to sample
</p>
</li>
<li> <p><code>n.burnin</code> The number of iterations to discard as a burnin from the
start of sampling.
</p>
</li>
<li> <p><code>n.thin</code> The number of samples to thin by.
</p>
</li>
<li> <p><code>n.chains</code> The number of chains to fit.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fitEllipse_+3A_priors">priors</code></td>
<td>
<p>a list of three items specifying the priors to be passed to the
jags model.
</p>

<ul>
<li> <p><code>R</code> The scaling vector for the diagonal of
Inverse Wishart distribution prior on the covariance matrix Sigma.
Typically set to a 2x2 matrix <code>matrix(c(1, 0, 0, 1), 2, 2)</code>.
</p>
</li>
<li> <p><code>k</code> The
degrees of freedom of the Inverse Wishart distribution for the covariance
matrix Sigma. Typically set to the dimensionality of Sigma, which in this
bivariate case is 2.
</p>
</li>
<li> <p><code>tau</code> The precision on the normal prior on the
means mu.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fitEllipse_+3A_id">id</code></td>
<td>
<p>a character string to prepend to the raw saved jags model output.
This is typically passed on from the calling function
<code><a href="#topic+siberMVN">siberMVN()</a></code> and identifies the community and group with an
integer labelling system. Defaults to NULL which will prevent the output
object being saved even if <code>parms$save.output</code> is set to <code>TRUE</code>.
The file itself will be saved to the user-specified location via
<code>parms$save.dir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mcmc.list object of posterior samples created by jags.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- stats::rnorm(50)
y &lt;- stats::rnorm(50)
parms &lt;- list()
parms$n.iter &lt;- 2 * 10^3
parms$n.burnin &lt;- 500
parms$n.thin &lt;- 2
parms$n.chains &lt;- 2
priors &lt;- list()
priors$R &lt;- 1 * diag(2)
priors$k &lt;- 2
priors$tau.mu &lt;- 1.0E-3
fitEllipse(x, y, parms, priors)

</code></pre>

<hr>
<h2 id='geese1demo'>A single group of the geese data</h2><span id='topic+geese1demo'></span>

<h3>Description</h3>

<p>A dataset for a single group of geese (as consumers) for two isotope tracers.
Intended for use in a Stable Isotope Mixing Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geese1demo)
</code></pre>


<h3>Format</h3>

<p>A 2 column, 9 row matrix containing the plasma data for the first
group of geese. Columns are in the order d13C and d15N. Retained here as
legacy from now defunct package siar. Note that the order of the data has
been swapped since siar in order to present d13C as the first isotope and
hence on the x-axis by default.
</p>


<h3>Author(s)</h3>

<p>Rich Inger
</p>

<hr>
<h2 id='geese2demo'>A single group of the geese data</h2><span id='topic+geese2demo'></span>

<h3>Description</h3>

<p>A dataset for a single group of geese (as consumers) for two isotope tracers.
Intended for use in a Stable Isotope Mixing Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geese2demo)
</code></pre>


<h3>Format</h3>

<p>A 3 column, 251 row matrix containing the plasma data for the 8
groups of gees as consumers. Columns are in the order Group which is an
integer that determines which of the 8 groups the observation belongs. The
second and third columns are d13C and d15N values derived from the blood
plasma for each observation. Retained here as legacy from now defunct
package siar. Note that the order of the isotope data has been swapped
since siar in order to present d13C as the first isotope and hence on the
x-axis by default.
</p>


<h3>Author(s)</h3>

<p>Rich Inger
</p>

<hr>
<h2 id='genCircle'>Create a sequence of points on a circle</h2><span id='topic+genCircle'></span>

<h3>Description</h3>

<p>This is a helper function that creates a sequence of points on a circle of
radius <code>r</code> as a resolution determined by <code>n</code>. It is not intended
for direct calling, and is used by the ellipse plotting function
<code><a href="#topic+addEllipse">addEllipse()</a></code>. NB not an exported function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCircle(n = 100, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCircle_+3A_n">n</code></td>
<td>
<p>the number of points to create around the circle. Defaults to 100.</p>
</td></tr>
<tr><td><code id="genCircle_+3A_r">r</code></td>
<td>
<p>the radius of the circle to create.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2 x n matrix of x and y coordinates of points on a circle.
</p>

<hr>
<h2 id='generateSiberCommunity'>A utility function to simulate a single community comprised of groups</h2><span id='topic+generateSiberCommunity'></span>

<h3>Description</h3>

<p>This function simulates data for a single community by sampling from a normal
distribution with different means for each group within some specified
boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSiberCommunity(
  n.groups = 3,
  community.id = 1,
  n.obs = 30,
  mu.range = c(-1, 1, -1, 1),
  wishSigmaScale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSiberCommunity_+3A_n.groups">n.groups</code></td>
<td>
<p>the an integer specifying the number of groups to simulate.
Defaults to 3.</p>
</td></tr>
<tr><td><code id="generateSiberCommunity_+3A_community.id">community.id</code></td>
<td>
<p>an integer identifying the community's ID number.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="generateSiberCommunity_+3A_n.obs">n.obs</code></td>
<td>
<p>the number of observations to draw per group.</p>
</td></tr>
<tr><td><code id="generateSiberCommunity_+3A_mu.range">mu.range</code></td>
<td>
<p>a vector of length 4, specifying the mix and max x and y
values to sample means from. Group means are sampled from a uniform
distribution within this range. The first two entries are the min and max of
the x-axis, and the second two the min and max of the y-axis.  Defaults to
<code>c(-1, 1, -1, 1)</code>.</p>
</td></tr>
<tr><td><code id="generateSiberCommunity_+3A_wishsigmascale">wishSigmaScale</code></td>
<td>
<p>is a simple multiplier for the call to
<code><a href="stats.html#topic+rWishart">stats::rWishart()</a></code> which scales the diagonal sigma matrix using
<code>wishSigmaScale * diag(2)</code> that is ultimately passed on to
<code>generateSiberGroup</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame object comprising a column of x and y data, a group
identifying column and a community identifying column, all of which are
numeric.
</p>

<hr>
<h2 id='generateSiberData'>A utility function to simulate isotope data for several communities</h2><span id='topic+generateSiberData'></span>

<h3>Description</h3>

<p>This function simulates data for a specified number of communities. It is a
wrapper function for <code><a href="#topic+generateSiberCommunity">generateSiberCommunity()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSiberData(
  n.groups = 3,
  n.communities = 2,
  n.obs = 30,
  mu.range = c(-1, 1, -1, 1),
  wishSigmaScale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSiberData_+3A_n.groups">n.groups</code></td>
<td>
<p>the an integer specifying the number of groups per community
to simulate. Defaults to 3.</p>
</td></tr>
<tr><td><code id="generateSiberData_+3A_n.communities">n.communities</code></td>
<td>
<p>the number of communities to simulate data for. Defaults
to 2.</p>
</td></tr>
<tr><td><code id="generateSiberData_+3A_n.obs">n.obs</code></td>
<td>
<p>the number of observations to draw per group.</p>
</td></tr>
<tr><td><code id="generateSiberData_+3A_mu.range">mu.range</code></td>
<td>
<p>a vector of length 4, specifying the mix and max x and y
values to sample means from. Group means are sampled from a uniform
distribution within this range. The first two entries are the min and max
of the x-axis, and the second two the min and max of the y-axis. Defaults
to <code>c(-1, 1, -1, 1)</code>.</p>
</td></tr>
<tr><td><code id="generateSiberData_+3A_wishsigmascale">wishSigmaScale</code></td>
<td>
<p>is a simple multiplier for the call to
<code><a href="stats.html#topic+rWishart">stats::rWishart()</a></code> which scales the diagonal sigma matrix using
<code>wishSigmaScale * diag(2)</code> that is ultimately passed on to
<code>generateSiberGroup</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame object comprising a column of x and y data, a group
identifying column and a community identifying column, all of which are
numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generateSiberData()

</code></pre>

<hr>
<h2 id='generateSiberGroup'>A utility function to simulate a single group of data</h2><span id='topic+generateSiberGroup'></span>

<h3>Description</h3>

<p>This function simulates data for a single group by sampling from a normal
distribution with different means for each group within some specified
boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSiberGroup(mu.range = c(-1, 1, -1, 1), n.obs = 30, wishSigmaScale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSiberGroup_+3A_mu.range">mu.range</code></td>
<td>
<p>a vector of length 4, specifying the mix and max x and y
values to sample means from. Group means are sampled from a uniform
distribution within this range. The first two entries are the min and max of
the x-axis, and the second two the min and max of the y-axis.</p>
</td></tr>
<tr><td><code id="generateSiberGroup_+3A_n.obs">n.obs</code></td>
<td>
<p>the number of observations to draw per group. Defaults to 30.</p>
</td></tr>
<tr><td><code id="generateSiberGroup_+3A_wishsigmascale">wishSigmaScale</code></td>
<td>
<p>is a simple multiplier for the call to
<code><a href="stats.html#topic+rWishart">stats::rWishart()</a></code> which scales the diagonal sigma matrix using
<code>wishSigmaScale * diag(2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame object comprising a column of x and y data, a group
identifying column and a community identifying column, all of which are
numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generateSiberGroup()

</code></pre>

<hr>
<h2 id='groupMetricsML'>Calculate maximum likelihood based measures of dispersion of bivariate data</h2><span id='topic+groupMetricsML'></span>

<h3>Description</h3>

<p>This function loops over each group within each community and calculates the
convex hull total area, Standard Ellipse Area (SEA) and its corresponding
small sample size corrected version SEAc based on the maximum likelihood
estimates of the means and covariance matrices of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupMetricsML(siber)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupMetricsML_+3A_siber">siber</code></td>
<td>
<p>a siber object as created by createSiberObject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3 x m matrix of the 6 Layman metrics of dX_range, dY_range, TA,
CD, MNND and SDNND in rows, where each column is a different group nested
within a community.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo.siber.data)
my.siber.data &lt;- createSiberObject(demo.siber.data)
groupMetricsML(my.siber.data)

</code></pre>

<hr>
<h2 id='hullArea'>Calculate the area of a convex hull given its coordinates</h2><span id='topic+hullArea'></span>

<h3>Description</h3>

<p>Given the coordinates of a convex hull (i.e. a polygon), this function
calculates its area. Not intended for direct use outside of
<code><a href="#topic+siberConvexhull">siberConvexhull()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hullArea(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hullArea_+3A_x">x</code></td>
<td>
<p>a vector of x-axis data</p>
</td></tr>
<tr><td><code id="hullArea_+3A_y">y</code></td>
<td>
<p>a vector of y-axis data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the area of the convex hull in units of
<code>x * y</code>; i.e. most commonly in permille squared for isotope data.
</p>

<hr>
<h2 id='kapow'>KAPOW!</h2><span id='topic+kapow'></span>

<h3>Description</h3>

<p>This function packs a punch and makes a pretty figure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kapow(cd = 7, ng = 25, n = 50, sc = 10, do.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kapow_+3A_cd">cd</code></td>
<td>
<p>sets the random seed to this</p>
</td></tr>
<tr><td><code id="kapow_+3A_ng">ng</code></td>
<td>
<p>the number of ellipses to draw</p>
</td></tr>
<tr><td><code id="kapow_+3A_n">n</code></td>
<td>
<p>the number of data points to simulate per group, but never displayed</p>
</td></tr>
<tr><td><code id="kapow_+3A_sc">sc</code></td>
<td>
<p>the scaling factor the rwishart sigma called by
<code><a href="stats.html#topic+rWishart">stats::rWishart()</a></code></p>
</td></tr>
<tr><td><code id="kapow_+3A_do.plot">do.plot</code></td>
<td>
<p>a logical indicating whether the plot should be printed
(defaults to TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>

<hr>
<h2 id='laymanMetrics'>Calculates the 6 Layman metrics on a vector of x and y data</h2><span id='topic+laymanMetrics'></span>

<h3>Description</h3>

<p>This function takes two x and y vectors, and calculates the corresponding
6 Layman metrics based on these points. Note that for generality, the
original metrics of dC_range and dN_range have been renamed dX_range and
dY_range respectively. These modified names represent the x and y axes in
terms of the order in which the data have been entered, and relate typically
to how one plots the data. These x and y vectors could represent the means
of the group members comprising a community as is preferred under the SIBER
model framework. However, one could use them to calculate the point estimates
of the 6 Layman metrics for an entire group of data. In fact, you are free
to pass this function any set of <code>x</code> and <code>y</code> data you wish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laymanMetrics(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laymanMetrics_+3A_x">x</code></td>
<td>
<p>a vector of locations in the x-axis direction.</p>
</td></tr>
<tr><td><code id="laymanMetrics_+3A_y">y</code></td>
<td>
<p>a vector of locations in the y-axis direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the 6 Layman metrics of dX_range, dY_range, TA,
CD, MNND and SDNND
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- stats::runif(10)
y &lt;- stats::runif(10)
laymanMetrics(x, y)

</code></pre>

<hr>
<h2 id='maxLikOverlap'>Calculate the overlap between two ellipses based on the maximum likelihood
fitted ellipses.</h2><span id='topic+maxLikOverlap'></span>

<h3>Description</h3>

<p>This function uses the ML estimated means and covariances matrices of two
specified groups to calculate the area of overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxLikOverlap(
  ellipse1,
  ellipse2,
  siber.object,
  p.interval = 0.95,
  n = 100,
  do.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxLikOverlap_+3A_ellipse1">ellipse1</code></td>
<td>
<p>character code of the form <code>"x.y"</code> where <code>x</code> is an
integer indexing the community, and <code>y</code> an integer indexing the group
within that community. This specifies the first of two ellipses whose
overlap will be compared.</p>
</td></tr>
<tr><td><code id="maxLikOverlap_+3A_ellipse2">ellipse2</code></td>
<td>
<p>same as <code>ellipse1</code> specifying a second ellipse.</p>
</td></tr>
<tr><td><code id="maxLikOverlap_+3A_siber.object">siber.object</code></td>
<td>
<p>an object created by  <code><a href="#topic+createSiberObject">createSiberObject()</a></code>
which contains the ML estimates for the means and covariance matrices for
each group.</p>
</td></tr>
<tr><td><code id="maxLikOverlap_+3A_p.interval">p.interval</code></td>
<td>
<p>the prediction interval used to scale the ellipse as per
<code><a href="#topic+addEllipse">addEllipse()</a></code>.</p>
</td></tr>
<tr><td><code id="maxLikOverlap_+3A_n">n</code></td>
<td>
<p>the number of points on the edge of the ellipse used to define it.
Defaults to <code>100</code> as per <code><a href="#topic+addEllipse">addEllipse()</a></code>.</p>
</td></tr>
<tr><td><code id="maxLikOverlap_+3A_do.plot">do.plot</code></td>
<td>
<p>logical switch to determine whether the corresponding ellipses
should be plotted or not. A use-case would be in conjunction with a low
numbered <code>draws</code> so as to visualise a relatively small number of the
posterior ellipses. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector comprising three columns: the area of overlap, the area of
the first ellipse and the area of the second ellipse and as many rows as
specified by <code>draws</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load in the included demonstration dataset data("demo.siber.data")
siber.example &lt;- createSiberObject(demo.siber.data) 

# The first ellipse is referenced using a character string representation 
# where in "x.y", "x" is the community, and "y" is the group within that 
# community.
ellipse1 &lt;- "1.2" 

# Ellipse two is similarly defined: community 1, group3 
ellipse2 &lt;- "1.3"

# the overlap betweeen the corresponding 95% prediction ellipses is given by: 
ellipse95.overlap &lt;- maxLikOverlap(ellipse1, ellipse2, siber.example,
p.interval = 0.95, n = 100)

</code></pre>

<hr>
<h2 id='mongoose'>A set of isotope observations for mongooses nested within packs</h2><span id='topic+mongoose'></span>

<h3>Description</h3>

<p>A dataset of multiple isotopes per individual mongooses nested within packs
where the goal is to understand isotopic niche occupancy of individuals
with respect to their own pack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mongoose)
</code></pre>


<h3>Format</h3>

<p>A 4 column, 783 row data.frame object containing unique individual
mongoose identifiers in the first column &quot;indiv.id&quot;; an integer identifier for
the pack to which each individual belongs in &quot;pack&quot;; Delta 13 Carbon values
&quot;c13; and Delta 15 Nitrogen values in &quot;n15&quot;. See the paper Sheppard et al
2018 <a href="https://doi.org/10.1111/ele.12933">doi:10.1111/ele.12933</a> for more details, although N.B.
the data here are provided as an example, not as a reproducible analysis of
that paper.
</p>


<h3>Author(s)</h3>

<p>Harry Marshall
</p>

<hr>
<h2 id='plotCommunityHulls'>Adds convex hulls to each community to an existing plot</h2><span id='topic+plotCommunityHulls'></span>

<h3>Description</h3>

<p>This function loops over each community and plots the convex hull
based on the centres of each of the groups that make up the community. See
the demonstration scripts for example implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCommunityHulls(
  siber,
  plot.args = list(col = 1, lty = 2),
  iso.order = c(1, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCommunityHulls_+3A_siber">siber</code></td>
<td>
<p>a siber object as created by createSiberObject.R</p>
</td></tr>
<tr><td><code id="plotCommunityHulls_+3A_plot.args">plot.args</code></td>
<td>
<p>a list of plotting arguments with the following suggested,
but non-exhaustive inputs. Additional plotting arguments for passing to the
internal call to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code> can either be specified here,
or as additional arguments under the <code>...</code> method.
</p>

<ul>
<li> <p><code>col</code> the color of the lines of the convex hull. See <code><a href="graphics.html#topic+lines">graphics::lines()</a></code>
for more details.
</p>
</li>
<li> <p><code>lty</code> the line type of the convex hull.See <code><a href="graphics.html#topic+lines">graphics::lines()</a></code>
for more details.
</p>
</li>
<li> <p><code>lwd</code> the line width of the convex hulls. See <code><a href="graphics.html#topic+lines">graphics::lines()</a></code>
for more details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotCommunityHulls_+3A_iso.order">iso.order</code></td>
<td>
<p>a vector of length 2, either c(1,2) or c(2,1). The order
determines which of the columns of raw data are plotted on the x (1) or y
(2) axis. N.B. this will be deprecated in a future release, and plotting
order will be achieved at point of data-entry.</p>
</td></tr>
<tr><td><code id="plotCommunityHulls_+3A_...">...</code></td>
<td>
<p>additional arguments for passing to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Convex hulls, drawn as lines on an existing figure.
</p>

<hr>
<h2 id='plotGroupEllipses'>Adds ellipses to an existing plot for each of your groups</h2><span id='topic+plotGroupEllipses'></span>

<h3>Description</h3>

<p>This function loops over each community and group within, and plots an
ellipse around the data. See demonstration scripts for more examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGroupEllipses(siber, plot.args = list(), iso.order = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGroupEllipses_+3A_siber">siber</code></td>
<td>
<p>a siber object as created by createSiberObject</p>
</td></tr>
<tr><td><code id="plotGroupEllipses_+3A_plot.args">plot.args</code></td>
<td>
<p>a list of plotting arguments for passing to
<code><a href="#topic+addEllipse">addEllipse()</a></code>. See <code><a href="#topic+addEllipse">addEllipse()</a></code> for details of the
options, and you can also pass additional arguments such as line widths and
styles. See also the demonstration scripts for examples of use.</p>
</td></tr>
<tr><td><code id="plotGroupEllipses_+3A_iso.order">iso.order</code></td>
<td>
<p>a vector of length 2, either <code>c(1,2)</code> or <code>c(2,1)</code>.
The order determines which of the columns of raw data are plotted on the x
(1) or y (2) axis. N.B. this will be deprecated in a future release, and
plotting order will be achieved at point of data-entry.</p>
</td></tr>
<tr><td><code id="plotGroupEllipses_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+addEllipse">addEllipse()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ellipses, drawn as lines on an existing figure.
</p>

<hr>
<h2 id='plotGroupHulls'>Plots illustrative convex hulls for each group within all communities</h2><span id='topic+plotGroupHulls'></span>

<h3>Description</h3>

<p>This function loops over each community and group within, and plots a
convex hull around the data. N.B. use of convex hulls to compare isotopic
niche width among groups within or between communities is not recommended
owing to strong sample size bias. Use of ellipse area is recommended instead.
This feature is provided for illustrative purposes only, and because some
people have expressed a desire for this feature for figure generation. See
demonstration scripts for more examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGroupHulls(siber, plot.args = NULL, iso.order = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGroupHulls_+3A_siber">siber</code></td>
<td>
<p>a siber object as created by createSiberObject</p>
</td></tr>
<tr><td><code id="plotGroupHulls_+3A_plot.args">plot.args</code></td>
<td>
<p>a list of plotting arguments for passing to
<code><a href="graphics.html#topic+lines">graphics::lines()</a></code>. See <code><a href="graphics.html#topic+lines">graphics::lines()</a></code> for
details of the options. See also the demonstration scripts for examples of
use.</p>
</td></tr>
<tr><td><code id="plotGroupHulls_+3A_iso.order">iso.order</code></td>
<td>
<p>a vector of length 2, either <code>c(1,2)</code> or<code>c(2,1)</code>.
The order determines which of the columns of raw data are plotted on the x
(1) or y (2) axis. N.B. this will be deprecated in a future release, and
plotting order will be achieved at point of data-entry.</p>
</td></tr>
<tr><td><code id="plotGroupHulls_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+addEllipse">addEllipse()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A series of convex hulls added to an existing plot.
</p>

<hr>
<h2 id='plotSiberObject'>Creates an isotope scatterplot and provides a wrapper to ellipse and hull plotting</h2><span id='topic+plotSiberObject'></span>

<h3>Description</h3>

<p>This function takes a SIBER object as created by
<code><a href="#topic+createSiberObject">createSiberObject</a></code>, and loops over communities and their groups,
creating a scatterplot, and adding ellipses and hulls as desired. Ellipses can be
added to groups, while convex hulls can be added at both the group and
community level (the former for illustrative purposes only, with no
analytical tools in SIBER to fit Bayesian hulls to individual groups. This is
not mathematically possible in a Bayesian framework.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSiberObject(
  siber,
  iso.order = c(1, 2),
  ax.pad = 1,
  hulls = TRUE,
  community.hulls.args = NULL,
  ellipses = TRUE,
  group.ellipses.args = NULL,
  group.hulls = FALSE,
  group.hulls.args = NULL,
  bty = "L",
  xlab = "Isotope 1",
  ylab = "Isotope 2",
  las = 1,
  x.limits = NULL,
  y.limits = NULL,
  points.order = 1:25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSiberObject_+3A_siber">siber</code></td>
<td>
<p>a siber object as created by <code><a href="#topic+createSiberObject">createSiberObject()</a></code>.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_iso.order">iso.order</code></td>
<td>
<p>a vector of length 2, either <code>c(1,2)</code> or <code>c(2,1)</code>. The order
determines which of the columns of raw data are plotted on the x (1) or y
(2) axis. N.B. this will be deprecated in a future release, and plotting
order will be achieved at point of data-entry.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_ax.pad">ax.pad</code></td>
<td>
<p>a padding amount to apply to the x-axis either side of the
extremes of the data. Defaults to 1.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_hulls">hulls</code></td>
<td>
<p>a logical defaulting to <code>TRUE</code> determining whether or not hulls
based on the means of groups within communities should be drawn. That is, a
community-level convex hull.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_community.hulls.args">community.hulls.args</code></td>
<td>
<p>a list of plotting arguments to pass to
<code><a href="#topic+plotCommunityHulls">plotCommunityHulls()</a></code>. See <code><a href="#topic+plotCommunityHulls">plotCommunityHulls()</a></code> for
further details.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_ellipses">ellipses</code></td>
<td>
<p>a logical defaulting to TRUE determining whether or not an
ellipse should be drawn around each group within each community.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_group.ellipses.args">group.ellipses.args</code></td>
<td>
<p>a list of plotting arguments to pass to
<code><a href="#topic+plotGroupEllipses">plotGroupEllipses()</a></code>. See <code><a href="#topic+plotGroupEllipses">plotGroupEllipses()</a></code> for
further details.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_group.hulls">group.hulls</code></td>
<td>
<p>a logical defaulting to FALSE determining whether or not
convex hulls should be drawn around each group within each community.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_group.hulls.args">group.hulls.args</code></td>
<td>
<p>a list of plotting options to pass to
<code><a href="#topic+plotGroupHulls">plotGroupHulls()</a></code>. See <code><a href="#topic+plotGroupHulls">plotGroupHulls()</a></code> for further
details.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_bty">bty</code></td>
<td>
<p>a string specifying the box type for the plot. See
<code><a href="graphics.html#topic+par">graphics::par()</a></code> for details.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_xlab">xlab</code></td>
<td>
<p>a string for the x-axis label.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_ylab">ylab</code></td>
<td>
<p>a string for the y-axis label.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_las">las</code></td>
<td>
<p>a scalar determining the rotation of the y-axis labels. Defaults
to horizontal with <code>las = 1</code>. See <code><a href="graphics.html#topic+par">graphics::par()</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_x.limits">x.limits</code></td>
<td>
<p>allows you to specify a two-element vector of lower and upper
x-axis limits. Specifying this argument over-rides the automatic plotting
and ax.pad option. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_y.limits">y.limits</code></td>
<td>
<p>allows you to specify a two-element vector of lower and upper
y-axis limits. Specifying this argument over-rides the automatic plotting
and ax.pad option. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_points.order">points.order</code></td>
<td>
<p>a vector of integers specifying the order of point types
to use. See <code><a href="graphics.html#topic+points">graphics::points()</a></code> for how integers map onto point
types. Defaults to the sequence 1:15 as per <code><a href="graphics.html#topic+points">graphics::points()</a></code>.
It must have at least as many entries as there are communities to plot,
else a warning will be issued, and the order will default to the sequence
<code>1:25</code>.</p>
</td></tr>
<tr><td><code id="plotSiberObject_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An isotope scatterplot.
</p>

<hr>
<h2 id='pointsToEllipsoid'>Test whether a set of points are inside or outside a defined ellipse</h2><span id='topic+pointsToEllipsoid'></span>

<h3>Description</h3>

<p>Takes a <code style="white-space: pre;">&#8288;i x d&#8288;</code> matrix of points where <code>d</code> is the dimension of the
space considered, and <code>i</code> is the number of points and returns
<code>TRUE</code> or <code>FALSE</code> for whether each point is inside or outside a
d-dimensional ellipsoid defined by a covariance matrix <code>Sigma</code> and
vector of means <code>mu</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointsToEllipsoid(X, Sigma, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointsToEllipsoid_+3A_x">X</code></td>
<td>
<p>the <code style="white-space: pre;">&#8288;i x d&#8288;</code> matrix of data points to be transformed</p>
</td></tr>
<tr><td><code id="pointsToEllipsoid_+3A_sigma">Sigma</code></td>
<td>
<p>the <code style="white-space: pre;">&#8288;d x d&#8288;</code> covariance matrix of the ellipsoid</p>
</td></tr>
<tr><td><code id="pointsToEllipsoid_+3A_mu">mu</code></td>
<td>
<p>the vector of means of the ellipse of length <code>d</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of transformed data points corresponding to <code>X</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(runif(200,-2.5, 2.5), ncol = 2, nrow = 100)
SIG &lt;- matrix(c(1,0,0,1), ncol = 2, nrow = 2)
mu &lt;- c(0, 0)
Z &lt;- pointsToEllipsoid(X, SIG, mu)
test &lt;- ellipseInOut(Z, p = 0.95)
plot(X, col = test + 1, xlim = c(-3, 3), ylim = c(-3, 3), asp = 1)
addEllipse(mu, SIG, p.interval = 0.95)

</code></pre>

<hr>
<h2 id='posteriorSEA'>Calculate the SEA based on a posterior distribution of Sigma</h2><span id='topic+posteriorSEA'></span>

<h3>Description</h3>

<p>This function loops over each posterior draw of a single group's Bayesian
bivariate ellipse and calculates the Standard Ellipse Area (SEA) for each
draw, thereby generating a distribution of SEA estimates. Not intended for
direct calling outside of <code><a href="#topic+siberEllipses">siberEllipses()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriorSEA(post)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriorSEA_+3A_post">post</code></td>
<td>
<p>a matrix of posterior covariance matrices and mean estimates for
a bivariate ellipse. In SIBER, this is typically one list element of the
object returned by <code><a href="#topic+siberMVN">siberMVN()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of posterior Bayesian Standard Ellipse Areas (SEA_B)
</p>

<hr>
<h2 id='siberCentroids'>Calculate the polar form of the vector between pairs of ellipse centroids</h2><span id='topic+siberCentroids'></span>

<h3>Description</h3>

<p>This function loops over each group within each community and calculates the
vector in polar form between the estimated centroids of each ellipse to each
other ellipse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siberCentroids(corrected.posteriors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siberCentroids_+3A_corrected.posteriors">corrected.posteriors</code></td>
<td>
<p>the Bayesian ellipses as returned by
<code><a href="#topic+siberMVN">siberMVN()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two arrays, one <code>r</code> contains the pairwise
distances between ellipse centroids in as the first two dimensions, with
the third dimension containing the same for each posterior draw defining
the ellipse. The second array <code>theta</code> has the same structure and
contains the angle in radians (from 0 to 2*pi) between the pairs. A third
object <code>labels</code> refers to  which community.group combination is in
each of the first two dimensions of the arrays.
</p>

<hr>
<h2 id='siberConvexhull'>Calculate metrics and plotting information for convex hulls</h2><span id='topic+siberConvexhull'></span>

<h3>Description</h3>

<p>This function calculates the area of the convex hull describing a set of
bivariate points, and returns other information useful for plotting the hull.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siberConvexhull(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siberConvexhull_+3A_x">x</code></td>
<td>
<p>a vector of x-axis data</p>
</td></tr>
<tr><td><code id="siberConvexhull_+3A_y">y</code></td>
<td>
<p>a vector of y-axis data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length four comprising:
</p>

<ul>
<li> <p><code>TA</code> the area of the convex hull.
</p>
</li>
<li> <p><code>hullX</code> the x-coordinates of the points describing the convex hull.
</p>
</li>
<li> <p><code>hullY</code> the y-coordinates of the points describing the convex hull.
</p>
</li>
<li> <p><code>ind</code> the indices of the original data in <code>x</code> and <code>y</code> that
form the boundaries of the convex hull.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- stats::rnorm(15)
y &lt;- stats::rnorm(15)
siberConvexhull(x, y)

</code></pre>

<hr>
<h2 id='siberDensityPlot'>Plot credible intervals as shaded boxplots using
<code><a href="hdrcde.html#topic+hdr.boxplot">hdr.boxplot</a></code></h2><span id='topic+siberDensityPlot'></span>

<h3>Description</h3>

<p>This function is essentially <code><a href="hdrcde.html#topic+hdr.boxplot">hdrcde::hdr.boxplot()</a></code> but it more
easily works with matrices of data, where each column is a different variable
of interest. It has some limitations though....
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siberDensityPlot(
  dat,
  probs = c(95, 75, 50),
  xlab = "Group",
  ylab = "Value",
  xticklabels = NULL,
  yticklabels = NULL,
  clr = matrix(rep(grDevices::gray((9:1)/10), ncol(dat)), nrow = 9, ncol = ncol(dat)),
  scl = 1,
  xspc = 0.5,
  prn = F,
  ct = "mode",
  ylims = NULL,
  lbound = -Inf,
  ubound = Inf,
  main = "",
  ylab.line = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siberDensityPlot_+3A_dat">dat</code></td>
<td>
<p>a matrix of data for which density region boxplots will be
constructed and plotted for each column.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_probs">probs</code></td>
<td>
<p>a vector of credible intervals to represent as box edges.
Defaults to <code style="white-space: pre;">&#8288;c(95, 75, 50&#8288;</code>.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_xlab">xlab</code></td>
<td>
<p>a string for the x-axis label. Defaults to <code>"Group"</code>.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_ylab">ylab</code></td>
<td>
<p>a string of the y-axis label. Defaults to '&quot;Value&quot;.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_xticklabels">xticklabels</code></td>
<td>
<p>a vector of strings to override the x-axis tick labels.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_yticklabels">yticklabels</code></td>
<td>
<p>a vector of strings to override the y-axis tick labels.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_clr">clr</code></td>
<td>
<p>a matrix of colours to use for shading each of the box regions.
Defaults to greyscale <code>grDevices::gray((9:1)/10)</code> replicated for as
many columns as there are in <code>dat</code>. When specified by the user, rows
contain the colours of each of the confidence regions specified in
<code>probs</code> and columns represent each of the columns of data in
<code>dat</code>. In this way, one could have shades of blue, red and yellow for
each of the groups.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_scl">scl</code></td>
<td>
<p>a scalar multiplier to scale the box widths. Defaults to 1.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_xspc">xspc</code></td>
<td>
<p>a scalar determining the amount of spacing between each box.
Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_prn">prn</code></td>
<td>
<p>a logical value determining whether summary statistics of each
column should be printed to screen <code>prn = TRUE</code> or suppressed as per
default <code>prn = FALSE</code>.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_ct">ct</code></td>
<td>
<p>a string of either <code>c("mode", "mean", "median")</code> which
determines which measure of central tendency will be plotted as a point in
the middle of the boxes. Defaults to <code>"mode"</code>.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_ylims">ylims</code></td>
<td>
<p>a vector of length two, specifying the lower and upper limits
for the y-axis. Defaults to <code>NULL</code> which inspects the data for appropriate
limits.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_lbound">lbound</code></td>
<td>
<p>a lower boundary to specify on the distribution to avoid the
density kernel estimating values beyond that which can be expected a
priori. Useful for example when plotting dietary proportions which must lie
in the interval <code style="white-space: pre;">&#8288;0 &lt;= Y &lt;= 1&#8288;</code>. Defaults to <code>-Inf</code></p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_ubound">ubound</code></td>
<td>
<p>an upper boundary to specify on the distribution to avoid the
density kernel estimating values beyond that which can be expected a
priori. Useful for example when plotting dietary proportions which must lie
in the interval <code style="white-space: pre;">&#8288;0 &lt;= Y &lt;= 1&#8288;</code>. Defaults to <code>+Inf</code>.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_main">main</code></td>
<td>
<p>a title for the figure. Defaults to blank.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_ylab.line">ylab.line</code></td>
<td>
<p>a postive scalar indicating the line spacing for rendering
the y-axis label. This is included as using the permille symbol has a
tendency to push the axis label off the plotting window margins. See the
<code>line</code> option in <code><a href="graphics.html#topic+axis">graphics::axis()</a></code> for more details as
ylab.line passes to this.</p>
</td></tr>
<tr><td><code id="siberDensityPlot_+3A_...">...</code></td>
<td>
<p>further graphical parameters for passing to
<code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new figure window.
</p>


<h3>Warning</h3>

<p>: This function will not currently recognise and plot
multimodal distributions, unlike <code><a href="hdrcde.html#topic+hdr.boxplot">hdrcde::hdr.boxplot()</a></code>. You
should take care, and plot basic histograms of each variable (column in the
object you are passing) and check that they are
indeed unimodal as expected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A basic default greyscale density plot
Y &lt;- matrix(stats::rnorm(1000), 250, 4)
siberDensityPlot(Y)

# A more colourful example
my_clrs &lt;- matrix(c("lightblue", "blue", "darkblue",
"red1", "red3", "red4",
"yellow1", "yellow3", "yellow4",
"turquoise", "turquoise3", "turquoise4"), nrow = 3, ncol = 4)
siberDensityPlot(Y, clr = my_clrs)

</code></pre>

<hr>
<h2 id='siberEllipses'>Calculate the Bayesian Standard Ellipse Area for all groups</h2><span id='topic+siberEllipses'></span>

<h3>Description</h3>

<p>This function loops over each group within each community and calculates the
posterior distribution describing the corresponding Standard Ellipse Area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siberEllipses(corrected.posteriors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siberEllipses_+3A_corrected.posteriors">corrected.posteriors</code></td>
<td>
<p>the Bayesian ellipses as returned by
<code><a href="#topic+siberMVN">siberMVN()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of with each column containing the posterior estimates of
the SEA.
</p>

<hr>
<h2 id='siberKapow'>Calculates the boundary of a union of ellipses</h2><span id='topic+siberKapow'></span>

<h3>Description</h3>

<p>Intended to calculate the area of an ellipse as a proportion of a group of
ellipses represented by their union, i.e. the total area encompassed by all
ellipses superimposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siberKapow(
  dtf,
  isoNames = c("iso1", "iso2"),
  group = "group",
  pEll = stats::pchisq(1, df = 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siberKapow_+3A_dtf">dtf</code></td>
<td>
<p>a data.frame object comprising bivariate data as a requirement,
and possibly other variables too but these are currently ignored.</p>
</td></tr>
<tr><td><code id="siberKapow_+3A_isonames">isoNames</code></td>
<td>
<p>a character vector of length 2 providing the names of the
variables containing the x and y data respectively.</p>
</td></tr>
<tr><td><code id="siberKapow_+3A_group">group</code></td>
<td>
<p>a character vector of length 1 providing the name of the
grouping variable on which to calculate the KAPOW ellipse.</p>
</td></tr>
<tr><td><code id="siberKapow_+3A_pell">pEll</code></td>
<td>
<p>the probability ellipse to draw for each group. Defaults to the
Standard Ellipse with <code>pEll = stats::pchisq(1, df = 2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>spatstat.geom::owin</code> containing the numerically calculated
ellipses and their union along with the raw ellipse boundaries in both raw
and <code>spatstat.geom::owin</code> format.
</p>

<hr>
<h2 id='siberMVN'>Fit Bayesian bivariate normal distributions to each group in each community</h2><span id='topic+siberMVN'></span>

<h3>Description</h3>

<p>This function loops over each community and then loops over each group
member, fitting a Bayesian multivariate (bivariate in this case) normal
distribution to each group of data. Not intended for direct calling by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siberMVN(siber, parms, priors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siberMVN_+3A_siber">siber</code></td>
<td>
<p>a siber object as created by <code><a href="#topic+createSiberObject">createSiberObject()</a></code></p>
</td></tr>
<tr><td><code id="siberMVN_+3A_parms">parms</code></td>
<td>
<p>a list containing four items providing details of the
<code><a href="rjags.html#topic+rjags-package">rjags::rjags()</a></code> run to be sampled.
</p>

<ul>
<li> <p><code>n.iter</code> The number of iterations to sample
</p>
</li>
<li> <p><code>n.burnin</code> The number of iterations to discard as a burnin from the
start of sampling.
</p>
</li>
<li> <p><code>n.thin</code> The number of samples to thin by.
</p>
</li>
<li> <p><code>n.chains</code> The number of chains to fit.
</p>
</li></ul>
</td></tr>
<tr><td><code id="siberMVN_+3A_priors">priors</code></td>
<td>
<p>a list of three items specifying the priors to be passed to
the jags model.
</p>

<ul>
<li> <p><code>R</code> The scaling vector for the diagonal of Inverse Wishart
distribution prior on the covariance matrix Sigma. Typically
set to a 2x2 matrix <code>matrix(c(1, 0, 0, 1), 2, 2)</code>.
</p>
</li>
<li> <p><code>k</code> The degrees of freedom of the Inverse Wishart distribution for
the covariance matrix Sigma. Typically set to the dimensionality of Sigma,
which in this bivariate case is 2.
</p>
</li>
<li> <p><code>tau</code> The precision on the normal prior on the means mu.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length equal to the total number of groups in all
communities. Each entry is named 1.1 1.2... 2.1.. with the first number
designating the community, and the second number the group within that
community. So, 2.3 would be the third group within the second community.
Each list entry is a 6 x n matrix representing the back-transformed posterior
distributions of the bivariate normal distribution, where n is the number of
posterior draws in the saved sample. The first two columns are the back-
transformed means, and the remaining four columns are the covariance matrix
Sigma in vector format. This vector converts to the covariance matrix as
<code>matrix(v[1:4], nrow = 2, ncol = 2)</code>.
</p>

<hr>
<h2 id='sigmaSEA'>Calculate metrics corresponding to the Standard Ellipse based on a
covariance matrix</h2><span id='topic+sigmaSEA'></span>

<h3>Description</h3>

<p>This function takes a covariance 2x2 matrix Sigma and returns various
metrics relating to the corresponding Standard Ellipse. The function is
limited to the 2-dimensional case, as many of the ancillary summary
statistics are not defined for higher dimensions (e.g. eccentricity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmaSEA(sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmaSEA_+3A_sigma">sigma</code></td>
<td>
<p>a 2x2 covariance ellipse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list comprising the following metrics for summarising the Standard
Ellipse
</p>

<ul>
<li> <p><code>SEA</code>  the Standard Ellipse Area (not sample size corrected).
</p>
</li>
<li> <p><code>eccentricity</code> a measure of the elongation of the ellipse.
</p>
</li>
<li> <p><code>a</code> the length of the semi-major axis.
</p>
</li>
<li> <p><code>b</code> the length of the semi-minor axis.
</p>
</li></ul>



<h3>Note</h3>

<p>This function is currently based on the eigenvalue and
eigenvector approach which is more flexible for higher dimensional problems
method for calculating the standard ellipse, and replaces the parametric
method used previously in siar and siber.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A perfect circle
sigma &lt;- matrix( c(1, 0, 0, 1), 2, 2)
sigmaSEA(sigma)

</code></pre>

<hr>
<h2 id='sourcesdemo'>A set of isotope observations on food sources of brent geese</h2><span id='topic+sourcesdemo'></span>

<h3>Description</h3>

<p>A dataset of isotope observations on 4 food sources of brent geese comprising
their mean and standard deviations. Intended for use in a Stable Isotope
Mixing Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sourcesdemo)
</code></pre>


<h3>Format</h3>

<p>A 5 column, 4 row data.frame object containing 4 different plants and
their measurements on 2 different isotopes. The first column Sources is a
factor determining the name of the source. The second and third columns are
the mean d13C and mean d15N values for each source respectively. Columns 3
and 5 are the standard deviations of the d13C and d15N values respectively.
Note that the order of the isotope data has been swapped since siar in
order to present d13C as the first isotope and hence on the x-axis by
default.
</p>


<h3>Author(s)</h3>

<p>Rich Inger
</p>

<hr>
<h2 id='specificCentroidVectors'>Calculate the pairwise distances and angles describing the difference between
centroids of paired groups</h2><span id='topic+specificCentroidVectors'></span>

<h3>Description</h3>

<p>Plots the posterior densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specificCentroidVectors(centroids, do.these, upper = TRUE, do.plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specificCentroidVectors_+3A_centroids">centroids</code></td>
<td>
<p>the list containing distance and angle matrices as returned
by <code><a href="#topic+siberCentroids">siberCentroids()</a></code>.</p>
</td></tr>
<tr><td><code id="specificCentroidVectors_+3A_do.these">do.these</code></td>
<td>
<p>a character vector of the pattern used to find paired matches in
the matrix of all comparisons. Usually the group names within any of the
communities.</p>
</td></tr>
<tr><td><code id="specificCentroidVectors_+3A_upper">upper</code></td>
<td>
<p>a logical determining whether to plot the upper or lower
triangle of angles. Defaults to TRUE which is the upper triangle and
returns the angle from the second ellipse to the first by centering on the
first centroid.</p>
</td></tr>
<tr><td><code id="specificCentroidVectors_+3A_do.plot">do.plot</code></td>
<td>
<p>a logical indicating whether plotting should be done or not.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="specificCentroidVectors_+3A_...">...</code></td>
<td>
<p>additional arguments to pass onwards, not currently implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nice plot. You can get the corresponding matrices used to generate
the plots if you ask for it nicely: thedata &lt;-
plotCentroidVectors(centroids)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
