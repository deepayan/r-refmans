<!DOCTYPE html><html><head><title>Help for package crosstalkr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crosstalkr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_expression'><p>attach expression values from user-provided expression vector to graph.</p></a></li>
<li><a href='#add_value'><p>Attach a generic user-provided value to graph</p></a></li>
<li><a href='#as_gene_symbol'><p>Convert from most other representations of gene name to gene.symbol</p></a></li>
<li><a href='#bootstrap_null'><p>Bootstrap null distribution for RWR</p></a></li>
<li><a href='#calc_dnp_i'><p>helper function to calculate dnp for one sample</p></a></li>
<li><a href='#calc_np'><p>calculate network potential for one node.</p></a></li>
<li><a href='#calc_np_all'><p>function to calculate the network potential for each protein in a user-provided vector - cpp internal version</p></a></li>
<li><a href='#calc_np_all_legacy'><p>function to calculate the network potential for each protein in a user-provided vector</p></a></li>
<li><a href='#calc_np_i'><p>helper function to calculate np for one sample</p></a></li>
<li><a href='#check_crosstalk'><p>Check to make sure incoming object is a valid crosstalk df.</p></a></li>
<li><a href='#combine_null'><p>.combine function for compute_null foreach looping structure</p></a></li>
<li><a href='#compute_crosstalk'><p>Identify proteins with a statistically significant relationship to user-provided seeds.</p></a></li>
<li><a href='#compute_dnp'><p>main function to compute delta np for every gene in a given dataframe - assumes compute_np has already been run for a given dataset</p></a></li>
<li><a href='#compute_np'><p>main function to compute np from a user-provided expression matrix.</p></a></li>
<li><a href='#compute_null_dnp'><p>function to compute null distribution of dnp</p></a></li>
<li><a href='#crosstalk_subgraph'><p>Helper function to generate subgraph from crosstalk_df output of <code>compute_crosstalk</code></p></a></li>
<li><a href='#crosstalkr'><p>crosstalkr: A package for the identification of functionally relevant subnetworks from high-dimensional omics data.</p></a></li>
<li><a href='#detect_inputtype'><p>Determine which format of gene is used to specify by user-defined seed proteins</p></a></li>
<li><a href='#dist_calc'><p>Internal function that computes the mean/stdev for each gene from a wide-format data frame.</p></a></li>
<li><a href='#ensembl_type'><p>Determine if ensembl id is a Protein, gene, or transcript_id</p></a></li>
<li><a href='#experiment_breakout'><p>helper function to split experiment names into constituent parts</p></a></li>
<li><a href='#fcalc_np_all'><p>Function to calculate the network potential for vertices v</p></a></li>
<li><a href='#final_combine'><p>final .combine function to run in compute_null_dnp foreach looping structure</p></a></li>
<li><a href='#final_dist_calc'><p>Internal function that computes the mean/stdev for each gene from a wide-format data frame.</p></a></li>
<li><a href='#get_neighbors'><p>function to get graph neighbors (along with their expression values) for a given gene in a given network g</p></a></li>
<li><a href='#get_random_graph'><p>Helper function for compute_null_dnp - returns a graph with randomly permuted edges.</p></a></li>
<li><a href='#get_topn'><p>Helper function for compute_null_dnp - returns the top n genes by dnp for each sample</p></a></li>
<li><a href='#gfilter'><p>Generic function to filter either an igraph object or a PPI network</p></a></li>
<li><a href='#gfilter.ct'><p>Method to filter the graph based on parameters passed to compute_crosstalk</p></a></li>
<li><a href='#gfilter.igraph_method'><p>Method to filter graph based on any igraph method that scores verticies.</p></a></li>
<li><a href='#gfilter.np'><p>Method to filter graph based on network potential values.</p></a></li>
<li><a href='#gfilter.value'><p>Method to filter graph based on user provided value</p></a></li>
<li><a href='#is_ensembl'><p>Determine if a character vector contains ensembl gene_ids</p></a></li>
<li><a href='#is_entrez'><p>Determine if a character vector contains entrez gene_ids</p></a></li>
<li><a href='#load_ppi'><p>Helper function to load requested PPI w/ parameters</p></a></li>
<li><a href='#match_seeds'><p>Identify random sets of seeds with similar degree distribution to parent seed proteins</p></a></li>
<li><a href='#node_repression'><p>Function to eliminate a node from a network g and calculate the change in some measure of network state</p></a></li>
<li><a href='#norm_colsum'><p>Function to normalize adjacency matrix by dividing each value by the colsum.</p></a></li>
<li><a href='#plot_ct'><p>Plot subnetwork identified using the compute_crosstalk function</p></a></li>
<li><a href='#ppi_intersection'><p>Function to allow users to choose the intersection of stringdb and biogrid</p>
Only works with the human PPI. min_score parameter only applies to strindb</a></li>
<li><a href='#ppi_union'><p>Function to allow users to choose the union of stringdb and biogrid</p>
Only works with the human PPI. min_score parameter only applies to strindb</a></li>
<li><a href='#prep_biogrid'><p>Prepare biogrid for use in analyses</p></a></li>
<li><a href='#prep_stringdb'><p>Prepare Stringdb for use in analyses</p></a></li>
<li><a href='#sparseRWR'><p>Perform random walk with repeats on a sparse matrix</p></a></li>
<li><a href='#supported_species'><p>returns a dataframe with information on supported species</p></a></li>
<li><a href='#tidy_expression'><p>helper function to convert expression matrix to tidy dataframe (if not already)</p></a></li>
<li><a href='#to_taxon_id'><p>helper to convert user-inputs to ncbi reference taxonomy.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis of Graph-Structured Data with a Focus on
Protein-Protein Interaction Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a general toolkit for drug target identification. We include functionality to reduce large graphs to subgraphs and prioritize nodes. In addition to being optimized for use with generic graphs, we also provides support to analyze protein-protein interactions networks from online repositories. For more details on core method, refer to Weaver et al. (2021) <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1008755">https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1008755</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, magrittr, withr, readr, dplyr, stringr, tidyr, tibble,
igraph (&ge; 1.2.0), Matrix, ensembldb, foreach, doParallel,
Rcpp, iterators, ggplot2, STRINGdb</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tidygraph, ggraph, testthat (&ge; 2.0.0), knitr,
EnsDb.Hsapiens.v86, rmarkdown, here</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-03 14:08:32 UTC; dtw43</td>
</tr>
<tr>
<td>Author:</td>
<td>Davis Weaver [aut, cre] (0000-0003-3086-497X)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Davis Weaver &lt;davis.weaver@case.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 11:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_expression'>attach expression values from user-provided expression vector to graph.</h2><span id='topic+add_expression'></span>

<h3>Description</h3>

<p>attach expression values from user-provided expression vector to graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_expression(exp, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_expression_+3A_exp">exp</code></td>
<td>
<p>expression vector - assumed to be a named vector where the values are expression and the names are the gene name</p>
</td></tr>
<tr><td><code id="add_expression_+3A_g">g</code></td>
<td>
<p>igraph object - will be filtered so that only nodes found in both exp and g are kept</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subgraph of g containing only shared keys with exp and with expression attached.
</p>

<hr>
<h2 id='add_value'>Attach a generic user-provided value to graph</h2><span id='topic+add_value'></span>

<h3>Description</h3>

<p>Attach a generic user-provided value to graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_value(val, g, val_name = "value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_value_+3A_val">val</code></td>
<td>
<p>named numeric vector where the names correspond to vertices in g</p>
</td></tr>
<tr><td><code id="add_value_+3A_g">g</code></td>
<td>
<p>igraph object - will be filtered so that only nodes found in both exp and g are kept</p>
</td></tr>
<tr><td><code id="add_value_+3A_val_name">val_name</code></td>
<td>
<p>str key for val</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subgraph of g containing only shared keys with val and val attached
</p>

<hr>
<h2 id='as_gene_symbol'>Convert from most other representations of gene name to gene.symbol</h2><span id='topic+as_gene_symbol'></span>

<h3>Description</h3>

<p>Convert from most other representations of gene name to gene.symbol
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_gene_symbol(x, edb = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_gene_symbol_+3A_x">x</code></td>
<td>
<p>vector of ensemble.gene ids, ensemble.peptide ids, ensemble.transcript
ids or entrez gene ids</p>
</td></tr>
<tr><td><code id="as_gene_symbol_+3A_edb">edb</code></td>
<td>
<p>ensemble database object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of gene symbols
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#1) from numeric formatted entrez id
as_gene_symbol(1956)
#2) from character formatted entrez id
as_gene_symbol("1956")
#3) from ensemble gene id
as_gene_symbol("ENSG00000146648")
#4) From a vector of entrez ids
as_gene_symbol(c("123", "1956", "2012"))

</code></pre>

<hr>
<h2 id='bootstrap_null'>Bootstrap null distribution for RWR</h2><span id='topic+bootstrap_null'></span>

<h3>Description</h3>

<p>This function will generate a bootstrapped null distribution to identify
signficant vertices in a PPI given a set of user-defined seed proteins.
Bootstrapping is done by performing random walk with repeats repeatedly over &quot;random&quot;
sets of seed proteins. Degree distribution of user-provided seeds is used to inform sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_null(
  seed_proteins,
  g,
  n = 1000,
  agg_int = 100,
  gamma = 0.6,
  eps = 1e-10,
  tmax = 1000,
  norm = TRUE,
  set_seed = NULL,
  cache = NULL,
  seed_name = NULL,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_null_+3A_seed_proteins">seed_proteins</code></td>
<td>
<p>user defined seed proteins</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_n">n</code></td>
<td>
<p>number of random walks with repeats to create null distribution</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_agg_int">agg_int</code></td>
<td>
<p>number of runs before we need to aggregate the results - necessary to save memory. set at lower numbers to save even more memory.</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_gamma">gamma</code></td>
<td>
<p>restart probability</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_eps">eps</code></td>
<td>
<p>maximum allowed difference between the computed probabilities at the steady state</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_tmax">tmax</code></td>
<td>
<p>the maximum number of iterations for the RWR</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_norm">norm</code></td>
<td>
<p>if True, w is normalized by dividing each value by the column sum.</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_set_seed">set_seed</code></td>
<td>
<p>integer to set random number seed - for reproducibility</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_cache">cache</code></td>
<td>
<p>A filepath to a folder downloaded files should be stored</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_seed_name">seed_name</code></td>
<td>
<p>Name to give the cached ngull distribution - must be a character string</p>
</td></tr>
<tr><td><code id="bootstrap_null_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use - defaults to 1. Significant speedup can be achieved by using multiple cores for computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing mean/ standard deviation for null distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#g &lt;- prep_biogrid()
#bootstrap_null(seed_proteins = c("EGFR", "KRAS"), g= g, ncores = 1, n = 10)

</code></pre>

<hr>
<h2 id='calc_dnp_i'>helper function to calculate dnp for one sample</h2><span id='topic+calc_dnp_i'></span>

<h3>Description</h3>

<p>helper function to calculate dnp for one sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_dnp_i(df, g, v_rm = NULL, keep_all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_dnp_i_+3A_df">df</code></td>
<td>
<p>dataframe with one cell line + log expression</p>
</td></tr>
<tr><td><code id="calc_dnp_i_+3A_g">g</code></td>
<td>
<p>igraph object containing ppi info</p>
</td></tr>
<tr><td><code id="calc_dnp_i_+3A_v_rm">v_rm</code></td>
<td>
<p>passed to <code><a href="#topic+node_repression">node_repression()</a></code></p>
</td></tr>
<tr><td><code id="calc_dnp_i_+3A_keep_all">keep_all</code></td>
<td>
<p>logical flag denoting if we should keep genes that we didn't calculate dnp for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>same dataframe with dnp calculated for each gene.
</p>

<hr>
<h2 id='calc_np'>calculate network potential for one node.</h2><span id='topic+calc_np'></span>

<h3>Description</h3>

<p>calculate network potential for one node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_np(c_i, c_j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_np_+3A_c_i">c_i</code></td>
<td>
<p>expression for a given node.</p>
</td></tr>
<tr><td><code id="calc_np_+3A_c_j">c_j</code></td>
<td>
<p>vector of expressions for each neighbor of c_i</p>
</td></tr>
</table>

<hr>
<h2 id='calc_np_all'>function to calculate the network potential for each protein in a user-provided vector - cpp internal version</h2><span id='topic+calc_np_all'></span>

<h3>Description</h3>

<p>function to calculate the network potential for each protein in a user-provided vector - cpp internal version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_np_all(exp, g, v = "default", neighbors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_np_all_+3A_exp">exp</code></td>
<td>
<p>expression vector - assumed to be a named vector where the values are expression and the names are the gene name</p>
</td></tr>
<tr><td><code id="calc_np_all_+3A_g">g</code></td>
<td>
<p>igraph object - will be filtered so that only nodes found in both exp and g are kept</p>
</td></tr>
<tr><td><code id="calc_np_all_+3A_v">v</code></td>
<td>
<p>character vector of nodes over which to calculate network potential.</p>
</td></tr>
<tr><td><code id="calc_np_all_+3A_neighbors">neighbors</code></td>
<td>
<p>named list containing the neighbors for each node of graph g. If not provided,
it will be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe containing network potential for each of the inputed gene names.
</p>

<hr>
<h2 id='calc_np_all_legacy'>function to calculate the network potential for each protein in a user-provided vector</h2><span id='topic+calc_np_all_legacy'></span>

<h3>Description</h3>

<p>Mostly just used to help debug the CPP version - not exported
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_np_all_legacy(
  exp,
  g,
  v = as.character(names(igraph::V(g))),
  neighbors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_np_all_legacy_+3A_exp">exp</code></td>
<td>
<p>expression vector - assumed to be a named vector where the values are expression and the names are the gene name</p>
</td></tr>
<tr><td><code id="calc_np_all_legacy_+3A_g">g</code></td>
<td>
<p>igraph object - will be filtered so that only nodes found in both exp and g are kept</p>
</td></tr>
<tr><td><code id="calc_np_all_legacy_+3A_v">v</code></td>
<td>
<p>character vector of nodes over which to calculate network potential.</p>
</td></tr>
<tr><td><code id="calc_np_all_legacy_+3A_neighbors">neighbors</code></td>
<td>
<p>named list containing the neighbors for each node of graph g. If not provided,
it will be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe containing network potential for each of the inputed gene names.
</p>

<hr>
<h2 id='calc_np_i'>helper function to calculate np for one sample</h2><span id='topic+calc_np_i'></span>

<h3>Description</h3>

<p>helper function to calculate np for one sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_np_i(df, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_np_i_+3A_df">df</code></td>
<td>
<p>dataframe with one cell line + log expression</p>
</td></tr>
<tr><td><code id="calc_np_i_+3A_g">g</code></td>
<td>
<p>igraph object containing ppi info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>same dataframe with np calculated for each gene.
</p>

<hr>
<h2 id='check_crosstalk'>Check to make sure incoming object is a valid crosstalk df.</h2><span id='topic+check_crosstalk'></span>

<h3>Description</h3>

<p>This function is a helper function for <code>plot_ct</code> that verifies the input is a valid output of compute_crosstalk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_crosstalk(crosstalk_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_crosstalk_+3A_crosstalk_df">crosstalk_df</code></td>
<td>
<p>a dataframe containing the results of <code>compute_crosstalk</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>message if not correct object type, null otherwise
</p>

<hr>
<h2 id='combine_null'>.combine function for compute_null foreach looping structure</h2><span id='topic+combine_null'></span>

<h3>Description</h3>

<p>.combine function for compute_null foreach looping structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_null(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_null_+3A_x">x</code></td>
<td>
<p>aggregated data structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='compute_crosstalk'>Identify proteins with a statistically significant relationship to user-provided seeds.</h2><span id='topic+compute_crosstalk'></span>

<h3>Description</h3>

<p><code>compute_crosstalk</code> returns a dataframe of proteins that are significantly
associated with user-defined seed proteins. These identified &quot;crosstalkers&quot;
can be combined with the user-defined seed proteins to identify functionally
relevant subnetworks. Affinity scores for every protein in the network are
calculated using a random-walk with repeats (<code>sparseRWR</code>). Significance is
determined by comparing these affinity scores to a bootstrapped null distribution
(see <code>bootstrap_null</code>). If using non-human PPI from string, refer to the stringdb documentation
for how to specify proteins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_crosstalk(
  seed_proteins,
  g = NULL,
  use_ppi = TRUE,
  ppi = "stringdb",
  species = "homo sapiens",
  n = 1000,
  union = FALSE,
  intersection = FALSE,
  gamma = 0.6,
  eps = 1e-10,
  tmax = 1000,
  norm = TRUE,
  set_seed,
  cache = NULL,
  min_score = 700,
  seed_name = NULL,
  ncores = 1,
  significance_level = 0.95,
  p_adjust = "bonferroni",
  agg_int = 100,
  return_g = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_crosstalk_+3A_seed_proteins">seed_proteins</code></td>
<td>
<p>user defined seed proteins</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_g">g</code></td>
<td>
<p>igraph network object.</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_use_ppi">use_ppi</code></td>
<td>
<p>bool, should g be a protein-protein interaction network? If
false, user must provide an igraph object in <code>g</code></p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_ppi">ppi</code></td>
<td>
<p>character string describing the ppi to use: currently only &quot;stringdb&quot; and &quot;biogrid&quot; are supported.</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_species">species</code></td>
<td>
<p>character string describing the species of interest.
For a list of supported species, see <code>supported_species</code>.
Non human species are only compatible with &quot;stringdb&quot;</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_n">n</code></td>
<td>
<p>number of random walks with repeats to create null distribution</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_union">union</code></td>
<td>
<p>bool, should we take the union of string db and biogrid to compute the PPI? Only applicable for the human PPI</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_intersection">intersection</code></td>
<td>
<p>bool, should we take the intersection of string db and biogrid to compute the PPI? Only applicable for the human PPI</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_gamma">gamma</code></td>
<td>
<p>restart probability</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_eps">eps</code></td>
<td>
<p>maximum allowed difference between the computed probabilities at the steady state</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_tmax">tmax</code></td>
<td>
<p>the maximum number of iterations for the RWR</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_norm">norm</code></td>
<td>
<p>if True, w is normalized by dividing each value by the column sum.</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_set_seed">set_seed</code></td>
<td>
<p>integer to set random number seed - for reproducibility</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_cache">cache</code></td>
<td>
<p>A filepath to a folder downloaded files should be stored</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_min_score">min_score</code></td>
<td>
<p>minimum connectivity score for each edge in the network.</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_seed_name">seed_name</code></td>
<td>
<p>Name to give the cached ngull distribution - must be a character string</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use - defaults to 1. Significant speedup can be achieved by using multiple cores for computation.</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_significance_level">significance_level</code></td>
<td>
<p>user-defined signficance level for hypothesis testing</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_p_adjust">p_adjust</code></td>
<td>
<p>adjustment method to correct for multiple hypothesis testing:
defaults to &quot;holm&quot;. see <code>p.adjust.methods</code> for other potential
adjustment methods.</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_agg_int">agg_int</code></td>
<td>
<p>number of runs before we need to aggregate the results - necessary to save memory. set at lower numbers to save even more memory.</p>
</td></tr>
<tr><td><code id="compute_crosstalk_+3A_return_g">return_g</code></td>
<td>
<p>bool, should we return the graph used? mostly for internal use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing affinity score, p-value, for all &quot;crosstalkers&quot;
related to a given set of seeds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#1) easy to use for querying biological networks - n = 10000 is more appropriate for actual analyses
#compute_crosstalk(c("EGFR", "KRAS"), n =10)

#2) Also works for any other kind of graph- just specify g (must be igraph formatted as of now)
g &lt;- igraph::sample_gnp(n = 1000, p = 10/1000)
compute_crosstalk(c(1,3,5,8,10), g = g, use_ppi = FALSE, n = 100)


</code></pre>

<hr>
<h2 id='compute_dnp'>main function to compute delta np for every gene in a given dataframe - assumes compute_np has already been run for a given dataset</h2><span id='topic+compute_dnp'></span>

<h3>Description</h3>

<p>This function takes a tidy dataframe as input containing RNA sequencing data for one or more samples and conducts in-silico repression.
Make sure to run with the same arguments for ppi and cache to maintain consistency for a given pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_dnp(
  cache = NULL,
  df,
  experiment_name,
  ppi,
  ncores = 1,
  min_score = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_dnp_+3A_cache">cache</code></td>
<td>
<p>user-provided filepath for where to store data etc</p>
</td></tr>
<tr><td><code id="compute_dnp_+3A_df">df</code></td>
<td>
<p>dataframe output of <a href="#topic+compute_np">compute_np</a></p>
</td></tr>
<tr><td><code id="compute_dnp_+3A_experiment_name">experiment_name</code></td>
<td>
<p>name of the experiment for saving output.</p>
</td></tr>
<tr><td><code id="compute_dnp_+3A_ppi">ppi</code></td>
<td>
<p>should we use biogrid or stringdb for the PPI</p>
</td></tr>
<tr><td><code id="compute_dnp_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for calculations</p>
</td></tr>
<tr><td><code id="compute_dnp_+3A_min_score">min_score</code></td>
<td>
<p>if ppi is stringdb, which mininum score should we use to filter edges?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='compute_np'>main function to compute np from a user-provided expression matrix.</h2><span id='topic+compute_np'></span>

<h3>Description</h3>

<p>main function to compute np from a user-provided expression matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_np(
  cache = NULL,
  experiment_name,
  ppi = "biogrid",
  min_score = NULL,
  exp_mat,
  mir_paper = TRUE,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_np_+3A_cache">cache</code></td>
<td>
<p>user-provided filepath for where to store data etc</p>
</td></tr>
<tr><td><code id="compute_np_+3A_experiment_name">experiment_name</code></td>
<td>
<p>name of the experiment for saving output.</p>
</td></tr>
<tr><td><code id="compute_np_+3A_ppi">ppi</code></td>
<td>
<p>should we use biogrid or stringdb for the PPI</p>
</td></tr>
<tr><td><code id="compute_np_+3A_min_score">min_score</code></td>
<td>
<p>if ppi is stringdb, which mininum score should we use to filter edges?</p>
</td></tr>
<tr><td><code id="compute_np_+3A_exp_mat">exp_mat</code></td>
<td>
<p>expression matrix where columns are samples and rows are features</p>
</td></tr>
<tr><td><code id="compute_np_+3A_mir_paper">mir_paper</code></td>
<td>
<p>are we running this in the context of the mir paper? a few quirks of that data</p>
</td></tr>
<tr><td><code id="compute_np_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for calculations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tidy data frame with one column for expression and another for np
</p>

<hr>
<h2 id='compute_null_dnp'>function to compute null distribution of dnp</h2><span id='topic+compute_null_dnp'></span>

<h3>Description</h3>

<p><code>compute_null_dnp</code> calculates a null distribution for the change in network potential for
for each node in a cell signaling network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_null_dnp(
  cache = NULL,
  df,
  ppi = "biogrid",
  n,
  n_genes = 50,
  experiment_name,
  ncores = 4,
  min_score = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_null_dnp_+3A_cache">cache</code></td>
<td>
<p>user-provided filepath for where to store data etc</p>
</td></tr>
<tr><td><code id="compute_null_dnp_+3A_df">df</code></td>
<td>
<p>output of <code><a href="#topic+compute_dnp">compute_dnp()</a></code></p>
</td></tr>
<tr><td><code id="compute_null_dnp_+3A_ppi">ppi</code></td>
<td>
<p>should we use biogrid or stringdb for the PPI</p>
</td></tr>
<tr><td><code id="compute_null_dnp_+3A_n">n</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="compute_null_dnp_+3A_n_genes">n_genes</code></td>
<td>
<p>integer describing number of genes per sample that we will compute the null distribution for</p>
</td></tr>
<tr><td><code id="compute_null_dnp_+3A_experiment_name">experiment_name</code></td>
<td>
<p>name of the experiment for saving output.</p>
</td></tr>
<tr><td><code id="compute_null_dnp_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use for calculations</p>
</td></tr>
<tr><td><code id="compute_null_dnp_+3A_min_score">min_score</code></td>
<td>
<p>if ppi is stringdb, which mininum score should we use to filter edges?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input for this function will be the output of <code><a href="#topic+compute_dnp">compute_dnp()</a></code>.
To compute the null distribution, the nodes in the provided cell signaling
network will be randomly permuted <code>n</code> times, with dnp computed or each new
cell signaling network. The mean and standard error of dnp for this set of random
networks will constitute the null model that we will use for comparison.
Be warned that this operation is extremely expensive computationally. It is
recommended to either use a high-performance cluster or limit the computation of the
null distribution to a small number of nodes.
To distribute the workload over multiple cores, just specify ncores.
</p>


<h3>Value</h3>

<p>df, also saves to cache if specified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_dnp">compute_dnp()</a></code> and <code><a href="#topic+compute_np">compute_np()</a></code>
</p>

<hr>
<h2 id='crosstalk_subgraph'>Helper function to generate subgraph from crosstalk_df output of <code>compute_crosstalk</code></h2><span id='topic+crosstalk_subgraph'></span>

<h3>Description</h3>

<p>Useful if the user wants to carry out further analysis or design custom visualizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosstalk_subgraph(crosstalk_df, g, seed_proteins, tg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosstalk_subgraph_+3A_crosstalk_df">crosstalk_df</code></td>
<td>
<p>a dataframe containing the results of <code>compute_crosstalk</code></p>
</td></tr>
<tr><td><code id="crosstalk_subgraph_+3A_g">g</code></td>
<td>
<p>igraph network object.</p>
</td></tr>
<tr><td><code id="crosstalk_subgraph_+3A_seed_proteins">seed_proteins</code></td>
<td>
<p>user defined seed proteins</p>
</td></tr>
<tr><td><code id="crosstalk_subgraph_+3A_tg">tg</code></td>
<td>
<p>bool do we want to tidy the graph for plotting?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tidygraph structure containing information about the crosstalkr subgraph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ct_df &lt;- compute_crosstalk(c("EGFR", "KRAS"))
g &lt;- prep_biogrid()
crosstalk_subgraph(ct_df, g = g, seed_proteins = c("EGFR", "KRAS"))

## End(Not run)
</code></pre>

<hr>
<h2 id='crosstalkr'>crosstalkr: A package for the identification of functionally relevant subnetworks from high-dimensional omics data.</h2><span id='topic+crosstalkr'></span>

<h3>Description</h3>

<p>crosstalkr provides a key user function, <code>compute_crosstalk</code> as well
as several additional functions that assist in setup and visualization (under development).
</p>


<h3>crosstalkr functions</h3>

<p><code>compute_crosstalk</code> calculates affinity scores of all proteins in a network
relative to user-provided seed proteins. Users can use the human interactome or
provide a network represented as an igraph object.
</p>
<p><code>sparseRWR</code> performs random walk with restarts on a sparse matrix.
Compared to dense matrix implementations, this should be extremely fast.
</p>
<p><code>bootstrap_null</code> Generates a null distribution based on n calls to
<code>sparseRWR</code>
</p>
<p><code>setup_init</code> manages download and storage of interactome data to
speed up future analysis
</p>
<p><code>plot_ct</code> allows users to visualize the subnetwork identified in
<code>compute_crosstalk</code>. This function relies on the ggraph framework.
Users are encouraged to use ggraph or other network visualization packages for
more customized figures.
</p>
<p><code>crosstalk_subgraph</code> converts the output of <code>compute_crosstalk</code> to a
tidygraph object containing only the identified nodes and their connections to the
user-provided seed_proteins. This function also adds degree, degree_rank, and
seed_label as attributes to the identified subgraph to assist in plotting.
</p>

<hr>
<h2 id='detect_inputtype'>Determine which format of gene is used to specify by user-defined seed proteins</h2><span id='topic+detect_inputtype'></span>

<h3>Description</h3>

<p>Determine which format of gene is used to specify by user-defined seed proteins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_inputtype(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_inputtype_+3A_x">x</code></td>
<td>
<p>vector of gene symbols</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;gene_symbol&quot;, &quot;entrez_id&quot;, &quot;ensemble_id&quot; or &quot;other&quot;
</p>

<hr>
<h2 id='dist_calc'>Internal function that computes the mean/stdev for each gene from a wide-format data frame.</h2><span id='topic+dist_calc'></span>

<h3>Description</h3>

<p>This function is called by the high-level function &quot;bootstrap_null&quot;.
Not expected to be used by end-users - we only export it so that environments
inside foreach loops can find it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_calc(df, seed_proteins)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_calc_+3A_df">df</code></td>
<td>
<p>: numeric vector</p>
</td></tr>
<tr><td><code id="dist_calc_+3A_seed_proteins">seed_proteins</code></td>
<td>
<p>user defined seed proteins</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing summary statistics for the computed null distribution
</p>

<hr>
<h2 id='ensembl_type'>Determine if ensembl id is a Protein, gene, or transcript_id</h2><span id='topic+ensembl_type'></span>

<h3>Description</h3>

<p>Determine if ensembl id is a Protein, gene, or transcript_id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensembl_type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensembl_type_+3A_x">x</code></td>
<td>
<p>vector or single gene symbol</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character: &quot;PROTEINID&quot;, &quot;GENEID&quot;, &quot;TRANSCRIPTID&quot;
</p>

<hr>
<h2 id='experiment_breakout'>helper function to split experiment names into constituent parts</h2><span id='topic+experiment_breakout'></span>

<h3>Description</h3>

<p>this is highly specific  to the miR paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>experiment_breakout(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="experiment_breakout_+3A_df">df</code></td>
<td>
<p>dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='fcalc_np_all'>Function to calculate the network potential for vertices v</h2><span id='topic+fcalc_np_all'></span>

<h3>Description</h3>

<p>Function to calculate the network potential for vertices v
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcalc_np_all(neighbors, vertices, v, exp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fcalc_np_all_+3A_neighbors">neighbors</code></td>
<td>
<p>list of neighbors for every node in the graph, type Rcpp::list</p>
</td></tr>
<tr><td><code id="fcalc_np_all_+3A_vertices">vertices</code></td>
<td>
<p>node list for graph, type Rcpp::StringVector</p>
</td></tr>
<tr><td><code id="fcalc_np_all_+3A_v">v</code></td>
<td>
<p>list of nodes for which we plan to calculate network potential</p>
</td></tr>
<tr><td><code id="fcalc_np_all_+3A_exp">exp</code></td>
<td>
<p>named vector of expression for each node in vertices</p>
</td></tr>
</table>

<hr>
<h2 id='final_combine'>final .combine function to run in compute_null_dnp foreach looping structure</h2><span id='topic+final_combine'></span>

<h3>Description</h3>

<p>final .combine function to run in compute_null_dnp foreach looping structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>final_combine(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="final_combine_+3A_x">x</code></td>
<td>
<p>aggregated info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='final_dist_calc'>Internal function that computes the mean/stdev for each gene from a wide-format data frame.</h2><span id='topic+final_dist_calc'></span>

<h3>Description</h3>

<p>This function is called by the high-level function &quot;bootstrap_null&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>final_dist_calc(df_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="final_dist_calc_+3A_df_list">df_list</code></td>
<td>
<p>: list of dataframes from foreach loop in bootstrap_null</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='get_neighbors'>function to get graph neighbors (along with their expression values) for a given gene in a given network g</h2><span id='topic+get_neighbors'></span>

<h3>Description</h3>

<p>just a wrapper around <code><a href="igraph.html#topic+neighbors">igraph::neighbors()</a></code> for convenience
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_neighbors(gene, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_neighbors_+3A_gene">gene</code></td>
<td>
<p>gene to grab neighbors from.</p>
</td></tr>
<tr><td><code id="get_neighbors_+3A_g">g</code></td>
<td>
<p>igraph object - will be filtered so that only nodes found in both exp and g are kept</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named numeric vector.
</p>

<hr>
<h2 id='get_random_graph'>Helper function for compute_null_dnp - returns a graph with randomly permuted edges.</h2><span id='topic+get_random_graph'></span>

<h3>Description</h3>

<p>currently just a wrapper for igraph::rewire but may add more functionality in the future
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_random_graph(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_random_graph_+3A_g">g</code></td>
<td>
<p>graph to be permuted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+rewire">igraph::rewire()</a></code>
</p>

<hr>
<h2 id='get_topn'>Helper function for compute_null_dnp - returns the top n genes by dnp for each sample</h2><span id='topic+get_topn'></span>

<h3>Description</h3>

<p>Helper function for compute_null_dnp - returns the top n genes by dnp for each sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_topn(df, n_genes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_topn_+3A_df">df</code></td>
<td>
<p>output of <code><a href="#topic+compute_dnp">compute_dnp()</a></code></p>
</td></tr>
<tr><td><code id="get_topn_+3A_n_genes">n_genes</code></td>
<td>
<p>integer describing number of genes per sample that we will compute the null distribution for</p>
</td></tr>
</table>

<hr>
<h2 id='gfilter'>Generic function to filter either an igraph object or a PPI network</h2><span id='topic+gfilter'></span>

<h3>Description</h3>

<p>Generic function to filter either an igraph object or a PPI network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfilter(
  method = NULL,
  g = NULL,
  val = NULL,
  use_ppi,
  igraph_method = NULL,
  n = 100,
  desc = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gfilter_+3A_method">method</code></td>
<td>
<p>str</p>
</td></tr>
<tr><td><code id="gfilter_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="gfilter_+3A_val">val</code></td>
<td>
<p>named numeric vector - some measure of node state (i.e. gene expression in the case of a PPI)</p>
</td></tr>
<tr><td><code id="gfilter_+3A_use_ppi">use_ppi</code></td>
<td>
<p>bool - should we use a ppi from online repository?</p>
</td></tr>
<tr><td><code id="gfilter_+3A_igraph_method">igraph_method</code></td>
<td>
<p>bool - is the user-provided method an igraph node scoring function?</p>
</td></tr>
<tr><td><code id="gfilter_+3A_n">n</code></td>
<td>
<p>int - number of nodes to include in the returned subgraph</p>
</td></tr>
<tr><td><code id="gfilter_+3A_desc">desc</code></td>
<td>
<p>bool - do we want the top or bottom examples of the provided metric</p>
</td></tr>
<tr><td><code id="gfilter_+3A_...">...</code></td>
<td>
<p>additional params passed to <code><a href="#topic+load_ppi">load_ppi()</a></code> or <code><a href="#topic+compute_crosstalk">compute_crosstalk()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph
</p>


<h3>See Also</h3>

<p><a href="#topic+gfilter.ct">gfilter.ct</a>, <a href="#topic+gfilter.np">gfilter.np</a>, <a href="#topic+gfilter.igraph_method">gfilter.igraph_method</a>
</p>

<hr>
<h2 id='gfilter.ct'>Method to filter the graph based on parameters passed to compute_crosstalk</h2><span id='topic+gfilter.ct'></span>

<h3>Description</h3>

<p>Method to filter the graph based on parameters passed to compute_crosstalk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfilter.ct(seeds, return_df = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gfilter.ct_+3A_seeds">seeds</code></td>
<td>
<p>vector (str or numeric) user provided vertex ids to use as seeds in the random walk with restarts'</p>
</td></tr>
<tr><td><code id="gfilter.ct_+3A_return_df">return_df</code></td>
<td>
<p>bool should we return a list containing the filtered graph + the RWR output that was used to do the filtering?</p>
</td></tr>
<tr><td><code id="gfilter.ct_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+compute_crosstalk">compute_crosstalk()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>

<hr>
<h2 id='gfilter.igraph_method'>Method to filter graph based on any igraph method that scores verticies.</h2><span id='topic+gfilter.igraph_method'></span>

<h3>Description</h3>

<p>Method to filter graph based on any igraph method that scores verticies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfilter.igraph_method(g, use_ppi = TRUE, method, n = 500, desc, val_name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gfilter.igraph_method_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="gfilter.igraph_method_+3A_use_ppi">use_ppi</code></td>
<td>
<p>bool - should we use a ppi from online repository?</p>
</td></tr>
<tr><td><code id="gfilter.igraph_method_+3A_method">method</code></td>
<td>
<p>str</p>
</td></tr>
<tr><td><code id="gfilter.igraph_method_+3A_n">n</code></td>
<td>
<p>int - number of nodes to include in the returned subgraph</p>
</td></tr>
<tr><td><code id="gfilter.igraph_method_+3A_desc">desc</code></td>
<td>
<p>bool - do we want the top or bottom examples of the provided metric</p>
</td></tr>
<tr><td><code id="gfilter.igraph_method_+3A_val_name">val_name</code></td>
<td>
<p>str</p>
</td></tr>
<tr><td><code id="gfilter.igraph_method_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <a href="#topic+load_ppi">load_ppi</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph
</p>

<hr>
<h2 id='gfilter.np'>Method to filter graph based on network potential values.</h2><span id='topic+gfilter.np'></span>

<h3>Description</h3>

<p>convenience function - it just calls gfilter.value after computing np
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfilter.np(g, val, use_ppi = TRUE, n = 500, desc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gfilter.np_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="gfilter.np_+3A_val">val</code></td>
<td>
<p>named numeric vector - some measure of node state (i.e. gene expression in the case of a PPI)</p>
</td></tr>
<tr><td><code id="gfilter.np_+3A_use_ppi">use_ppi</code></td>
<td>
<p>bool - should we use a ppi from online repository?</p>
</td></tr>
<tr><td><code id="gfilter.np_+3A_n">n</code></td>
<td>
<p>int - number of nodes to include in the returned subgraph</p>
</td></tr>
<tr><td><code id="gfilter.np_+3A_desc">desc</code></td>
<td>
<p>bool - do we want the top or bottom examples of the provided metric</p>
</td></tr>
<tr><td><code id="gfilter.np_+3A_...">...</code></td>
<td>
<p>additional params passed to <code><a href="#topic+load_ppi">load_ppi()</a></code> or <code><a href="#topic+compute_crosstalk">compute_crosstalk()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information on network potential, see <a href="https://journals.plos.org/ploscompbiol/article/comments?id=10.1371/journal.pcbi.1008755">related paper</a>
</p>


<h3>Value</h3>

<p>igraph
</p>

<hr>
<h2 id='gfilter.value'>Method to filter graph based on user provided value</h2><span id='topic+gfilter.value'></span>

<h3>Description</h3>

<p>Method to filter graph based on user provided value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfilter.value(g, val, use_ppi = TRUE, n = 500, val_name = "value", desc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gfilter.value_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="gfilter.value_+3A_val">val</code></td>
<td>
<p>named numeric vector - some measure of node state (i.e. gene expression in the case of a PPI)</p>
</td></tr>
<tr><td><code id="gfilter.value_+3A_use_ppi">use_ppi</code></td>
<td>
<p>bool - should we use a ppi from online repository?</p>
</td></tr>
<tr><td><code id="gfilter.value_+3A_n">n</code></td>
<td>
<p>int - number of nodes to include in the returned subgraph</p>
</td></tr>
<tr><td><code id="gfilter.value_+3A_val_name">val_name</code></td>
<td>
<p>str</p>
</td></tr>
<tr><td><code id="gfilter.value_+3A_desc">desc</code></td>
<td>
<p>bool - do we want the top or bottom examples of the provided metric</p>
</td></tr>
<tr><td><code id="gfilter.value_+3A_...">...</code></td>
<td>
<p>additional params passed to <code><a href="#topic+load_ppi">load_ppi()</a></code> or <code><a href="#topic+compute_crosstalk">compute_crosstalk()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph
</p>

<hr>
<h2 id='is_ensembl'>Determine if a character vector contains ensembl gene_ids</h2><span id='topic+is_ensembl'></span>

<h3>Description</h3>

<p>Determine if a character vector contains ensembl gene_ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_ensembl(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_ensembl_+3A_x">x</code></td>
<td>
<p>vector or single gene symbol</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='is_entrez'>Determine if a character vector contains entrez gene_ids</h2><span id='topic+is_entrez'></span>

<h3>Description</h3>

<p>Determine if a character vector contains entrez gene_ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_entrez(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_entrez_+3A_x">x</code></td>
<td>
<p>vector or single gene symbol</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='load_ppi'>Helper function to load requested PPI w/ parameters</h2><span id='topic+load_ppi'></span>

<h3>Description</h3>

<p>Helper function to load requested PPI w/ parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_ppi(
  cache = NULL,
  union = FALSE,
  intersection = FALSE,
  species = "9606",
  min_score = 0,
  ppi = "stringdb"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_ppi_+3A_cache">cache</code></td>
<td>
<p>A filepath to a folder downloaded files should be stored</p>
</td></tr>
<tr><td><code id="load_ppi_+3A_union">union</code></td>
<td>
<p>bool</p>
</td></tr>
<tr><td><code id="load_ppi_+3A_intersection">intersection</code></td>
<td>
<p>bool</p>
</td></tr>
<tr><td><code id="load_ppi_+3A_species">species</code></td>
<td>
<p>species code either using latin species name or taxon id</p>
</td></tr>
<tr><td><code id="load_ppi_+3A_min_score">min_score</code></td>
<td>
<p>minimum connectivity score for each edge in the network.</p>
</td></tr>
<tr><td><code id="load_ppi_+3A_ppi">ppi</code></td>
<td>
<p>str</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>

<hr>
<h2 id='match_seeds'>Identify random sets of seeds with similar degree distribution to parent seed proteins</h2><span id='topic+match_seeds'></span>

<h3>Description</h3>

<p>This function will generate n character vectors of seeds to be passed to sparseRWR
as part of the construction of a boostrapped null distribution for significance testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_seeds(g, seed_proteins, n, set_seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_seeds_+3A_g">g</code></td>
<td>
<p>igraph object representing the network under study. specified by &quot;ppi&quot; in bootstrap_null</p>
</td></tr>
<tr><td><code id="match_seeds_+3A_seed_proteins">seed_proteins</code></td>
<td>
<p>user defined seed proteins</p>
</td></tr>
<tr><td><code id="match_seeds_+3A_n">n</code></td>
<td>
<p>number of random walks with repeats to create null distribution</p>
</td></tr>
<tr><td><code id="match_seeds_+3A_set_seed">set_seed</code></td>
<td>
<p>integer to set random number seed - for reproducibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of character vectors: randomly generated seed proteins with a similar
degree distribution to parent seed proteins
</p>

<hr>
<h2 id='node_repression'>Function to eliminate a node from a network g and calculate the change in some measure of network state</h2><span id='topic+node_repression'></span>

<h3>Description</h3>

<p>this function is still under development.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_repression(
  g,
  v_rm = as.character(names(igraph::V(g))),
  exp,
  state_function = calc_np_all,
  neighbors_only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_repression_+3A_g">g</code></td>
<td>
<p>igraph network object</p>
</td></tr>
<tr><td><code id="node_repression_+3A_v_rm">v_rm</code></td>
<td>
<p>index of vertices to remove</p>
</td></tr>
<tr><td><code id="node_repression_+3A_exp">exp</code></td>
<td>
<p>expression vector for nodes in graph g</p>
</td></tr>
<tr><td><code id="node_repression_+3A_state_function">state_function</code></td>
<td>
<p>function to use to calculate network state before and after node_repression</p>
</td></tr>
<tr><td><code id="node_repression_+3A_neighbors_only">neighbors_only</code></td>
<td>
<p>logical designating whether state function should be calculated for all nodes or just neighbors</p>
</td></tr>
<tr><td><code id="node_repression_+3A_...">...</code></td>
<td>
<p>additional parameters passed to state function.</p>
</td></tr>
</table>

<hr>
<h2 id='norm_colsum'>Function to normalize adjacency matrix by dividing each value by the colsum.</h2><span id='topic+norm_colsum'></span>

<h3>Description</h3>

<p>Function to normalize adjacency matrix by dividing each value by the colsum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_colsum(w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_colsum_+3A_w">w</code></td>
<td>
<p>The adjacency matrix of a given graph in sparse format - dgCMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>input matrix, normalized by column sums
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) Normalize by column sum on a simple matrix
v1 = (c(1,1,1,0))
v2 = c(0,0,0,1)
v3 = c(1,1,1,0)
v4 = c(0,0,0,1)
w = matrix(data = c(v1,v2,v3,v4), ncol = 4, nrow = 4)
norm_colsum(w)

</code></pre>

<hr>
<h2 id='plot_ct'>Plot subnetwork identified using the compute_crosstalk function</h2><span id='topic+plot_ct'></span>

<h3>Description</h3>

<p>Convenience function for plotting crosstalkers - if you want to make more
customized/dynamic figures, there are lots of packages that can facilitate that,
including: <code>visnetwork</code>, <code>ggraph</code>, and even the base R plotting library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ct(crosstalk_df, g, label_prop = 0.1, prop_keep = 0.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ct_+3A_crosstalk_df">crosstalk_df</code></td>
<td>
<p>a dataframe containing the results of <code>compute_crosstalk</code></p>
</td></tr>
<tr><td><code id="plot_ct_+3A_g">g</code></td>
<td>
<p>igraph network object.</p>
</td></tr>
<tr><td><code id="plot_ct_+3A_label_prop">label_prop</code></td>
<td>
<p>Proportion of nodes to label - based on degree</p>
</td></tr>
<tr><td><code id="plot_ct_+3A_prop_keep">prop_keep</code></td>
<td>
<p>How many proteins do we want to keep in the visualization (as a proportion of total) -
subsets on top x proteins ranked by affinity score</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, draws the identified subgraph to device\
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ct_df &lt;- compute_crosstalk(c("EGFR", "KRAS"))
g &lt;- prep_biogrid()
plot_ct(ct_df, g = g)

## End(Not run)

</code></pre>

<hr>
<h2 id='ppi_intersection'>Function to allow users to choose the intersection of stringdb and biogrid
Only works with the human PPI. min_score parameter only applies to strindb</h2><span id='topic+ppi_intersection'></span>

<h3>Description</h3>

<p>Function to allow users to choose the intersection of stringdb and biogrid
Only works with the human PPI. min_score parameter only applies to strindb
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppi_intersection(cache = NULL, min_score = 800, edb = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppi_intersection_+3A_cache">cache</code></td>
<td>
<p>A filepath to a folder downloaded files should be stored</p>
</td></tr>
<tr><td><code id="ppi_intersection_+3A_min_score">min_score</code></td>
<td>
<p>minimum connectivity score for each edge in the network.</p>
</td></tr>
<tr><td><code id="ppi_intersection_+3A_edb">edb</code></td>
<td>
<p>ensemble database object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object corresponding to PPI following intersection
</p>

<hr>
<h2 id='ppi_union'>Function to allow users to choose the union of stringdb and biogrid
Only works with the human PPI. min_score parameter only applies to strindb</h2><span id='topic+ppi_union'></span>

<h3>Description</h3>

<p>Function to allow users to choose the union of stringdb and biogrid
Only works with the human PPI. min_score parameter only applies to strindb
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppi_union(cache = NULL, min_score = 0, edb = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppi_union_+3A_cache">cache</code></td>
<td>
<p>A filepath to a folder downloaded files should be stored</p>
</td></tr>
<tr><td><code id="ppi_union_+3A_min_score">min_score</code></td>
<td>
<p>minimum connectivity score for each edge in the network.</p>
</td></tr>
<tr><td><code id="ppi_union_+3A_edb">edb</code></td>
<td>
<p>ensemble database object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object corresponding to PPI following union
</p>

<hr>
<h2 id='prep_biogrid'>Prepare biogrid for use in analyses</h2><span id='topic+prep_biogrid'></span>

<h3>Description</h3>

<p>Prepare biogrid for use in analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_biogrid(cache = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_biogrid_+3A_cache">cache</code></td>
<td>
<p>A filepath to a folder downloaded files should be stored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object built from the adjacency matrix downloaded from thebiogrid.org.
</p>

<hr>
<h2 id='prep_stringdb'>Prepare Stringdb for use in analyses</h2><span id='topic+prep_stringdb'></span>

<h3>Description</h3>

<p>Basically a wrapper around the get_graph method from the stringdb package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_stringdb(
  cache = NULL,
  edb = "default",
  min_score = 200,
  version = "11.5",
  species = "homo sapiens"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_stringdb_+3A_cache">cache</code></td>
<td>
<p>A filepath to a folder downloaded files should be stored</p>
</td></tr>
<tr><td><code id="prep_stringdb_+3A_edb">edb</code></td>
<td>
<p>ensemble database object</p>
</td></tr>
<tr><td><code id="prep_stringdb_+3A_min_score">min_score</code></td>
<td>
<p>minimum connectivity score for each edge in the network.</p>
</td></tr>
<tr><td><code id="prep_stringdb_+3A_version">version</code></td>
<td>
<p>stringdb version</p>
</td></tr>
<tr><td><code id="prep_stringdb_+3A_species">species</code></td>
<td>
<p>species code either using latin species name or taxon id</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object built from the adjacency matrix downloaded from stringdb.
</p>

<hr>
<h2 id='sparseRWR'>Perform random walk with repeats on a sparse matrix</h2><span id='topic+sparseRWR'></span>

<h3>Description</h3>

<p>This function borrows heavily from the RWR function in the RANKS package (cite here)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseRWR(seed_proteins, w, gamma = 0.6, eps = 1e-10, tmax = 1000, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseRWR_+3A_seed_proteins">seed_proteins</code></td>
<td>
<p>user defined seed proteins</p>
</td></tr>
<tr><td><code id="sparseRWR_+3A_w">w</code></td>
<td>
<p>The adjacency matrix of a given graph in sparse format - dgCMatrix</p>
</td></tr>
<tr><td><code id="sparseRWR_+3A_gamma">gamma</code></td>
<td>
<p>restart probability</p>
</td></tr>
<tr><td><code id="sparseRWR_+3A_eps">eps</code></td>
<td>
<p>maximum allowed difference between the computed probabilities at the steady state</p>
</td></tr>
<tr><td><code id="sparseRWR_+3A_tmax">tmax</code></td>
<td>
<p>the maximum number of iterations for the RWR</p>
</td></tr>
<tr><td><code id="sparseRWR_+3A_norm">norm</code></td>
<td>
<p>if True, w is normalized by dividing each value by the column sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector, affinity scores for all nodes in graph relative to provided seeds
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) Run Random walk with restarts on a simple matrix
v1 = (c(1,1,1,0))
v2 = c(0,0,0,1)
v3 = c(1,1,1,0)
v4 = c(0,0,0,1)
w = matrix(data = c(v1,v2,v3,v4), ncol = 4, nrow = 4)
sparseRWR(seed_proteins = c(1,3), w = w, norm = TRUE)

# 2) Works just as well on a sparse matrix
v1 = (c(1,1,1,0))
v2 = c(0,0,0,1)
v3 = c(1,1,1,0)
v4 = c(0,0,0,1)
w = matrix(data = c(v1,v2,v3,v4), ncol = 4, nrow = 4)
w = Matrix::Matrix(w, sparse = TRUE)
sparseRWR(seed_proteins = c(1,4), w = w, norm = TRUE)

#3) Sample workflow for use with human protein-protein interaction network
#g &lt;- prep_biogrid()
#w &lt;- igraph::as_adjacency_matrix(g)
#sparseRWR(seed_proteins = c("EGFR", "KRAS"), w = w, norm = TRUE)

</code></pre>

<hr>
<h2 id='supported_species'>returns a dataframe with information on supported species</h2><span id='topic+supported_species'></span>

<h3>Description</h3>

<p>returns a dataframe with information on supported species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supported_species()
</code></pre>


<h3>Value</h3>

<p>dataframe
</p>

<hr>
<h2 id='tidy_expression'>helper function to convert expression matrix to tidy dataframe (if not already)</h2><span id='topic+tidy_expression'></span>

<h3>Description</h3>

<p>helper function to convert expression matrix to tidy dataframe (if not already)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_expression(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_expression_+3A_df">df</code></td>
<td>
<p>dataframe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='to_taxon_id'>helper to convert user-inputs to ncbi reference taxonomy.</h2><span id='topic+to_taxon_id'></span>

<h3>Description</h3>

<p>helper to convert user-inputs to ncbi reference taxonomy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_taxon_id(species)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_taxon_id_+3A_species">species</code></td>
<td>
<p>user-inputted species</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string corresponding to taxon id
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
