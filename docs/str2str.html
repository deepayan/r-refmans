<!DOCTYPE html><html lang="en"><head><title>Help for package str2str</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {str2str}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#str2str-package'><p>Structure to Structure</p></a></li>
<li><a href='#a2d'><p>(3D+) Array to Data-Frame</p></a></li>
<li><a href='#a2la'><p>(3D+) Array to List of (3D+) Arrays</p></a></li>
<li><a href='#a2ld'><p>3D Array to List of Data-Frames</p></a></li>
<li><a href='#a2lm'><p>(3D) Array to List of Matrices</p></a></li>
<li><a href='#a2v'><p>(3D+) Array to (Atomic) Vector</p></a></li>
<li><a href='#abind+26lt+3B-'><p>Add array slices to 3D+ Array</p>
<code>`abind&lt;-`</code> adds array slices to arrays as a side effect. It used the function
<code>abind</code> in the <code>abind</code> package. The purpose of the function is to replace
the need to use ary2 &lt;- abind(ary1, mat1); ary3 &lt;- rbind(ary2, mat2); ary4 &lt;- rbind(ary3, mat3),
etc. It allows you to specify the dimension you wish to bind <code>along</code> as well as the dimname you
wish to bind <code>after</code>. Unlike <code>`cbind&lt;-`</code>, <code>`rbind&lt;-`</code>, and <code>`append&lt;-`</code>,
it does not have overwriting functionality (I could not figure out how to code that);
therefore, if <code>value</code> has some dimnames that are the same as those in <code>a</code>,
it will NOT overwrite them and simply bind them to <code>a</code>, resulting in duplicate
dimnames.</a></li>
<li><a href='#all_diff'><p>Test if All Elements are Different</p></a></li>
<li><a href='#all_same'><p>Test if All Elements are the Same</p></a></li>
<li><a href='#append+26lt+3B-'><p>Add Elements to Vectors</p></a></li>
<li><a href='#cat0'><p>Concatenate and Print with No Separator</p></a></li>
<li><a href='#cbind_fill'><p>Bind DataFrames Along Columns - Filling in Missing Rows with NA</p></a></li>
<li><a href='#cbind_fill_matrix'><p>Bind Matrices Along Columns - Filling in Missing Rows with NA</p></a></li>
<li><a href='#cbind+26lt+3B-'><p>Add Columns to Data Objects</p></a></li>
<li><a href='#codes'><p>Integer Codes of Factor Levels</p></a></li>
<li><a href='#d2a'><p>Data-Frame to (3D+) Array or Matrix</p></a></li>
<li><a href='#d2d'><p>Data-Frame to Data-Frame (e.g., factors to character vectors)</p></a></li>
<li><a href='#d2ld'><p>Data-Frame to List of Data-Frames</p></a></li>
<li><a href='#d2lv'><p>Data-Frame to List of (Atomic) Vectors</p></a></li>
<li><a href='#d2m'><p>Data-Frame to Matrix</p></a></li>
<li><a href='#d2v'><p>Data-Frame to (Atomic) Vector</p></a></li>
<li><a href='#dimlabels'><p>Dimension labels (i.e., names of dimnames)</p></a></li>
<li><a href='#dimlabels+26lt+3B-'><p>Add Elements to Vectors</p></a></li>
<li><a href='#e2l'><p>Environment to List</p></a></li>
<li><a href='#fct2v'><p>Factor to (Atomic) Vector</p></a></li>
<li><a href='#grab'><p><code>grab</code> extracts the contents of objects in an environment based on their</p>
object names as a character vector. The object contents are stored to a list
where the names are the object names.</a></li>
<li><a href='#inbtw'><p>Elements Inbetween Values Within a (Atomic) Vector</p></a></li>
<li><a href='#is.avector'><p>Test for an Atomic Vector</p></a></li>
<li><a href='#is.cnumeric'><p>Test for Character Numbers</p></a></li>
<li><a href='#is.colnames'><p>Test for 'colnames'</p></a></li>
<li><a href='#is.Date'><p>Test for a Date object</p></a></li>
<li><a href='#is.dummy'><p>Test for a Dummy Variable</p></a></li>
<li><a href='#is.empty'><p>Test for Empty Characters</p></a></li>
<li><a href='#is.names'><p>Test for 'names'</p></a></li>
<li><a href='#is.POSIXct'><p>Test for a POSIXct object</p></a></li>
<li><a href='#is.POSIXlt'><p>Test for a POSIXlt object</p></a></li>
<li><a href='#is.row.names'><p>Test for 'row.names'</p></a></li>
<li><a href='#is.rownames'><p>Test for 'rownames'</p></a></li>
<li><a href='#is.whole'><p>Test for Whole Numbers</p></a></li>
<li><a href='#Join'><p>Join (or Merge) a List of Data-frames</p></a></li>
<li><a href='#la2a'><p>List of (3D+) Arrays to (3D+) Array</p></a></li>
<li><a href='#laynames'><p>Names of the Layers (the Third Dimension)</p></a></li>
<li><a href='#ld2a'><p>List of Data-Frames to a 3D Array</p></a></li>
<li><a href='#ld2d'><p>List of Data-Frames to Data-Frame</p></a></li>
<li><a href='#ld2v'><p>List of Data-Frames to (Atomic) Vector</p></a></li>
<li><a href='#lm2a'><p>List of Matrices to 3D Array</p></a></li>
<li><a href='#lm2d'><p>List of Matrices to Data-Frame</p></a></li>
<li><a href='#lm2v'><p>List of Matrices to (Atomic) Vector</p></a></li>
<li><a href='#lv2d'><p>List of (atomic) vectors to Data-Frame</p></a></li>
<li><a href='#lv2m'><p>List of (atomic) Vectors to Matrix</p></a></li>
<li><a href='#lv2v'><p>List of (atomic) Vectors to (atomic) Vector</p></a></li>
<li><a href='#m2d'><p>Matrix to Data-Frame</p></a></li>
<li><a href='#m2lv'><p>Matrix to List of (Atomic) Vectors</p></a></li>
<li><a href='#m2v'><p>Matrix to (Atomic) Vector</p></a></li>
<li><a href='#ndim'><p>Number of Object Dimensions</p></a></li>
<li><a href='#nlay'><p>Number of Layers (the Third Dimension)</p></a></li>
<li><a href='#not.colnames'><p>Identify Elements That are Not Colnames</p></a></li>
<li><a href='#not.names'><p>Identify Elements That are Not Names</p></a></li>
<li><a href='#not.row.names'><p>Identify Elements That are Not Row.names</p></a></li>
<li><a href='#not.rownames'><p>Identify Elements That are Not Rownames</p></a></li>
<li><a href='#order.custom'><p>Custom Order Permutation</p></a></li>
<li><a href='#pick'><p>Extract Elements From a (Atomic) Vector</p></a></li>
<li><a href='#rbind+26lt+3B-'><p>Add Rows to Data Objects</p></a></li>
<li><a href='#sn'><p>Set a Vector's Names as its Elements</p></a></li>
<li><a href='#stack2'><p>Stack one Set of Variables from Wide to Long</p></a></li>
<li><a href='#t_list'><p>Transpose a List</p></a></li>
<li><a href='#try_expr'><p>Add Try to Expression</p></a></li>
<li><a href='#try_fun'><p>Add Try to Function</p></a></li>
<li><a href='#undim'><p>Undimension an Object</p></a></li>
<li><a href='#undimlabel'><p>Undimlabel an Object</p></a></li>
<li><a href='#undimname'><p>Undimname an Object</p></a></li>
<li><a href='#unstack2'><p>Unstack one Set of Variables from Long to Wide</p></a></li>
<li><a href='#v2d'><p>(Atomic) Vector to Data-Frame</p></a></li>
<li><a href='#v2fct'><p>Character Vector to (Unordered) Factor</p></a></li>
<li><a href='#v2frm'><p>Character Vector to Formula</p></a></li>
<li><a href='#v2lv'><p>(Atomic) Vector to List of (Atomic) Vectors</p></a></li>
<li><a href='#v2m'><p>(Atomic) Vector to Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Convert R Objects from One Structure to Another</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Offers a suite of functions for converting to and from
    (atomic) vectors, matrices, data.frames, and (3D+) arrays as well
    as lists of these objects. It is an alternative to the base R
    as.&lt;str&gt;.&lt;method&gt;() functions (e.g., as.data.frame.array()) that
    provides more useful and/or flexible restructuring of R objects.
    To do so, it only works with common structuring of R objects (e.g.,
    data.frames with only atomic vector columns).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), datasets, stats, utils, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, checkmate, plyr, reshape</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-20 21:24:07 UTC; David Disabato</td>
</tr>
<tr>
<td>Author:</td>
<td>David Disabato [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Disabato &lt;ddisab01@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-20 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='str2str-package'>Structure to Structure</h2><span id='topic+str2str'></span><span id='topic+str2str-package'></span>

<h3>Description</h3>

<p><code>str2str</code> is a package for converting R objects to
different structures. It focuses on four primary R objects: (atomic)
vectors, matrices, data.frames, and arrays as well as lists of these
objects. For example, converting a (atomic) vector to a data.frame (i.e.,
<code>v2d()</code>) or a list of (atomic) vectors to a matrix (i.e.,
<code>lv2m()</code>. The current version of the package does not have a function
for every convertion (e.g., <code>a2m()</code>), but some additional convertion
functions may be included in future versions if I find a use for them. The
package was motivated by limitations of the base R <code>as.&lt;str&gt;.&lt;method&gt;</code>
suite of functions and the <code>plyr</code> R package <code>**ply(.fun = NULL)</code>
suite of functions for converting R objects to different structures. While
those functions are often useful, there are times different conversions are
desired or different naming schemes are desired. That is what this package
offers R users. It also contains various utility functions for working with
common R objects. For example, <code>is.colnames</code> and <code>ndim</code>.
</p>


<h3>Limitations</h3>

<p>This packages does NOT handle the nuances of R objects.
It is not for comprehensive restructuring of any version of R objects, but
rather for restructuring commonly used versions of R objects. For example,
the functions are not tested with the raw and complex typeof atomic
vectors, list arrays, or data.frames containing non-atomic vector columns
(e.g., matrix or list columns). The base R <code>as.&lt;str&gt;.&lt;method&gt;</code>
functions allow for comprehensive restructuring of R objects; however, at
the cost of less convenient convertions for commonly used versions of R
objects. The <code>str2str</code> package seeks to fill that gap in useability.
</p>


<h3>Abbreviations</h3>

<p>See the table below
</p>
<dl>
<dt>v</dt><dd><p>(atomic) vector</p>
</dd>
<dt>m</dt><dd><p>matrix</p>
</dd>
<dt>d</dt><dd><p>data.frame</p>
</dd>
<dt>a</dt><dd><p>(3D+) array</p>
</dd>
<dt>l</dt><dd><p>list</p>
</dd>
<dt>el</dt><dd><p>elements</p>
</dd>
<dt>nm</dt><dd><p>names</p>
</dd>
<dt>uv</dt><dd><p>unique values</p>
</dd>
<dt>lgl</dt><dd><p>logical</p>
</dd>
<dt>int</dt><dd><p>integer</p>
</dd>
<dt>dbl</dt><dd><p>double</p>
</dd>
<dt>num</dt><dd><p>numeric</p>
</dd>
<dt>chr</dt><dd><p>character</p>
</dd>
<dt>fct</dt><dd><p>factor</p>
</dd>
<dt>lvl</dt><dd><p>levels</p>
</dd>
<dt>vrb</dt><dd><p>variable</p>
</dd>
<dt>frm</dt><dd><p>formula</p>
</dd>
<dt>fun</dt><dd><p>function</p>
</dd>
<dt>rtn</dt><dd><p>return</p>
</dd>
<dt>str</dt><dd><p>structure</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Disabato <a href="mailto:ddisab01@gmail.com">ddisab01@gmail.com</a>
</p>

<hr>
<h2 id='a2d'>(3D+) Array to Data-Frame</h2><span id='topic+a2d'></span>

<h3>Description</h3>

<p><code>a2d</code> converts a (3D+ array) to a data.frame. It allows you to specify a
dimension of the array to be the columns. All other dimensions are variables
in the data.frame. This is different than <code>as.data.frame.array</code> which
converts the (3D+) array to a matrix first; although it is very similar to
<code>as.data.frame.table</code> when <code>col</code> = 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2d(a, col = 0, stringsAsFactors = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a2d_+3A_a">a</code></td>
<td>
<p>3D+ array.</p>
</td></tr>
<tr><td><code id="a2d_+3A_col">col</code></td>
<td>
<p>integer vector or character vector of length 1 specifing the dimension
of <code>a</code> to have as columns in the return object. If an integer vector,
<code>col</code> refers to the dimension number. If a character vector, <code>col</code>
refers to the name of the dimension (i.e., dimlabel). The columns are in order
of the dimnames for that dimension (not alphabetical order like <code>reshape::cast</code>).
If 0 (default), then no dimension of the array are columns and the function becomes
similar to <code>as.data.frame.table</code>.</p>
</td></tr>
<tr><td><code id="a2d_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical vector of length 1 specifying whether the variable
dimensions should be factors of chracter vectors.</p>
</td></tr>
<tr><td><code id="a2d_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>a</code> is a (3D+) array.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>a2d</code> is mostly a wrapper for <code>reshape::melt.array</code> (+ <code>reshape::cast</code>)
that allows for the variable dimensions to be character vectors rather than factors.
</p>


<h3>Value</h3>

<p>data.frame of <code>a</code>'s elements. The colnames of the variable dimensions
are the dimlabels in <code>a</code>. If there were no dimlabels in <code>a</code>, then each
dimension is named after its number with an X in front. If <code>col</code> is not 0,
then the rest of the colnames are the dimnames of
that dimension from <code>a</code>. If <code>col</code> is 0, then the names of the single
column with <code>a</code>'s elements is &quot;element&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a2d(HairEyeColor)
a2d(HairEyeColor, col = 1)
a2d(HairEyeColor, col = "Hair", stringsAsFactors = TRUE)
a2d(HairEyeColor, col = 2)
a2d(HairEyeColor, col = "Sex", stringsAsFactors = TRUE)
try_expr(a2d(as.matrix(attitude))) # error due to inputting a matrix. Instead use `m2d`.

# correlation array example from psych::corr.test(attitude[1:3])
# corr_test &lt;- psych::corr.test(attitude[1:3])
# a &lt;- lm2a(corr_test[c("r","se","t","p")])
r &lt;- matrix(c(1.0000000, 0.8254176, 0.4261169, 0.8254176, 1.0000000, 0.5582882,
   0.4261169, 0.5582882, 1.0000000), nrow = 3, ncol = 3, byrow = FALSE)
se &lt;- matrix(c(0.0000000, 0.1066848, 0.1709662, 0.1066848, 0.0000000, 0.1567886,
   0.1709662, 0.1567886, 0.0000000), nrow = 3, ncol = 3, byrow = FALSE)
t &lt;- matrix(c(Inf, 7.736978, 2.492404, 7.736978, Inf, 3.560771,
   2.492404, 3.560771, Inf), nrow = 3, ncol = 3, byrow = FALSE)
p &lt;- matrix(c(0.000000e+00, 1.987682e-08, 1.887702e-02, 5.963047e-08, 0.000000e+00,
   1.345519e-03, 0.018877022, 0.002691039, 0.000000000), nrow = 3, ncol = 3, byrow = FALSE)
a &lt;- abind::abind(r, se, t, p, along = 3L)
dimnames(a) &lt;- list(names(attitude[1:3]), names(attitude[1:3]), c("r","se","t","p"))
d &lt;- a2d(a = a, col = 3)

</code></pre>

<hr>
<h2 id='a2la'>(3D+) Array to List of (3D+) Arrays</h2><span id='topic+a2la'></span>

<h3>Description</h3>

<p><code>a2la</code> converts an (3D+) array to a list of (3D+) arrays. This function
is a simple wrapper for <code>asplit(x = a, MARGIN = along)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2la(a, along = ndim(a), check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a2la_+3A_a">a</code></td>
<td>
<p>(3D+) array</p>
</td></tr>
<tr><td><code id="a2la_+3A_along">along</code></td>
<td>
<p>integerish vector of length 1 specifying the dimension to split
the array along. Default is the last dimension of <code>a</code>.</p>
</td></tr>
<tr><td><code id="a2la_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>a</code> is a 3D+ array.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of arrays where each array is one dimension less than <code>a</code>
and the names of the list are <code>dimnames(a)[[along]]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># without dimnames
a &lt;- abind::abind(HairEyeColor*1, HairEyeColor*2, HairEyeColor*3, along = 4L)
a2la(a)
# with dimnames
a &lt;- abind::abind("one" = HairEyeColor*1, "two" = HairEyeColor*2,
   "three" = HairEyeColor*3, along = 4L)
a2la(a)
a2la(a, along = 1) # along = 1
</code></pre>

<hr>
<h2 id='a2ld'>3D Array to List of Data-Frames</h2><span id='topic+a2ld'></span>

<h3>Description</h3>

<p><code>a2ld</code> converts a 3D array to a list of data.frames. This is a simple call
to <code>a2lm</code> followed by <code>m2d</code>. The default is to convert the third
dimension to the list dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2ld(a, along = 3L, stringsAsFactors = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a2ld_+3A_a">a</code></td>
<td>
<p>3D array.</p>
</td></tr>
<tr><td><code id="a2ld_+3A_along">along</code></td>
<td>
<p>integer vector of length 1 specifying the dimension to slice the array
along. This dimension is converted to the list dimension. 1 = rows; 2 = columns;
3 = layers.</p>
</td></tr>
<tr><td><code id="a2ld_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical vector of length 1 specifying whether character
vectors should be converted to factors. Note, that if the array is character
and <code>stringsAsFactors</code> = TRUE, then all columns in the returned list of
data.frames will be factors.</p>
</td></tr>
<tr><td><code id="a2ld_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>a</code> is a 3D array.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data.frames - all with the same dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a2ld(HairEyeColor)
a2ld(HairEyeColor, along = 1)
try_expr(a2ld(mtcars)) # error b/c not a 3D array
</code></pre>

<hr>
<h2 id='a2lm'>(3D) Array to List of Matrices</h2><span id='topic+a2lm'></span>

<h3>Description</h3>

<p><code>a2lm</code> converts a (3D) array to a list of matrices. This is a simple call
to <code>asplit</code> with a default to convert the third dimension to a list dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2lm(a, along = 3L, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a2lm_+3A_a">a</code></td>
<td>
<p>3D array.</p>
</td></tr>
<tr><td><code id="a2lm_+3A_along">along</code></td>
<td>
<p>integer vector of length 1 specifying the dimension to slice the array
along. This dimension is converted to the list dimension. 1 = rows; 2 = columns;
3 = layers.</p>
</td></tr>
<tr><td><code id="a2lm_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>a</code> is a 3D array.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of matrices - all with the same dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a2lm(HairEyeColor)
a2lm(HairEyeColor, along = 1)
try_expr(a2lm(mtcars)) # error b/c  not a 3D array
</code></pre>

<hr>
<h2 id='a2v'>(3D+) Array to (Atomic) Vector</h2><span id='topic+a2v'></span>

<h3>Description</h3>

<p><code>a2v</code> converts a matrix to a (atomic) vector. The benefit of <code>m2v</code>
over <code>as.vector</code> or <code>c</code> is that 1) the vector can be formed along rows
any sequence of dimensions and 2) the dimnames from <code>a</code> can be used for
the names of the returned vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2v(a, along = ndim(a):1, use.dimnames = TRUE, sep = "_", check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a2v_+3A_a">a</code></td>
<td>
<p>3D+ array.</p>
</td></tr>
<tr><td><code id="a2v_+3A_along">along</code></td>
<td>
<p>numeric vector of length = <code>ndim(a)</code> that contains the integers
<code>1:ndim(a)</code> specifying the order which the array elements should be concatenated.
For example, with a 3D array, <code>3:1</code> (default) specifies to split the array by
layers first, then columns, and then rows. See examples.</p>
</td></tr>
<tr><td><code id="a2v_+3A_use.dimnames">use.dimnames</code></td>
<td>
<p>logical vector of length 1 that specifies whether the dimnames
of <code>a</code> should be used to create the names for the returned vector. If FALSE,
the returned vector will have NULL names. If TRUE, then each element's name will
be analogous to <code>paste(dimnames(a)[[1L]][i], dimnames(a)[[2L]][j], dimnames(a)[[3L]][k],
..., sep = sep)</code>. If <code>a</code> does not have dimnames, then they will be replaced
by dimension positions.</p>
</td></tr>
<tr><td><code id="a2v_+3A_sep">sep</code></td>
<td>
<p>character vector of length 1 specifying the string that will separate
the dimnames from each dimension in the naming scheme of the return object. Note,
<code>sep</code> is not used if <code>use.dimnames</code> = FALSE.</p>
</td></tr>
<tr><td><code id="a2v_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>a</code> is a 3D+ array.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(atomic) vector of length = <code>length(a)</code> where the order of elements
from <code>a</code> has been determined by <code>along</code> and the names determined by
the <code>use.dimnames</code>, <code>dimnames(a)</code>, and <code>sep</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a2v(HairEyeColor) # layers, then columns, then rows (default)
a2v(HairEyeColor, along = c(3,1,2)) # layers, then rows, then columns
a2v(HairEyeColor, along = 1:3) # rows, then columns, then layers
a2v(HairEyeColor, along = 1:3, use.dimnames = FALSE)
</code></pre>

<hr>
<h2 id='abind+26lt+3B-'>Add array slices to 3D+ Array
<code>`abind&lt;-`</code> adds array slices to arrays as a side effect. It used the function
<code>abind</code> in the <code>abind</code> package. The purpose of the function is to replace
the need to use ary2 &lt;- abind(ary1, mat1); ary3 &lt;- rbind(ary2, mat2); ary4 &lt;- rbind(ary3, mat3),
etc. It allows you to specify the dimension you wish to bind <code>along</code> as well as the dimname you
wish to bind <code>after</code>. Unlike <code>`cbind&lt;-`</code>, <code>`rbind&lt;-`</code>, and <code>`append&lt;-`</code>,
it does not have overwriting functionality (I could not figure out how to code that);
therefore, if <code>value</code> has some dimnames that are the same as those in <code>a</code>,
it will NOT overwrite them and simply bind them to <code>a</code>, resulting in duplicate
dimnames.</h2><span id='topic+abind+3C-'></span>

<h3>Description</h3>

<p>Some traditional R folks may find this function uncomfortable. R is famous for limiting
side effects, except for a few notable exceptions (e.g., <code>`[&lt;-`</code> and <code>`names&lt;-`</code>).
Part of the reason is that side effects can be computationally inefficient in R.
The entire object often has to be re-constructed and re-saved to memory. For
example, a more computationally efficient alternative to abind(ary) &lt;- mat1;
abind(ary) &lt;- mat2; abind(ary) &lt;- mat3 is ary1 &lt;- do.call(what = abind,
args = list(ary, mat1, mat2, mat3)). However, <code>`abind&lt;-`</code> was not created
for R programming use when computational efficiency is valued; it is created
for R interactive use when user convenience is valued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abind(
  a,
  along = ndim(a),
  after = dim(a)[along],
  dim.nm = NULL,
  overwrite = FALSE
) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abind+2B26lt+2B3B-_+3A_a">a</code></td>
<td>
<p>3D+ array.</p>
</td></tr>
<tr><td><code id="abind+2B26lt+2B3B-_+3A_along">along</code></td>
<td>
<p>either an integer vector with length 1 or a character vector of
length 1 specifying the dimension along which to bind <code>value</code>. If an integer
vector, it is the position of the dimension. If a character vector it is the
dimension with that dimlabel.</p>
</td></tr>
<tr><td><code id="abind+2B26lt+2B3B-_+3A_after">after</code></td>
<td>
<p>either an integer vector with length 1 or a character vector of
length 1 specifying where to add <code>value</code> within the dimension specified by
<code>along</code>. If an integer vector, it is the position within the dimension.
If a character vector it is the dimname within the dimension. Similar to
<code>append</code>, use 0L if you want the added array slice to be first.</p>
</td></tr>
<tr><td><code id="abind+2B26lt+2B3B-_+3A_dim.nm">dim.nm</code></td>
<td>
<p>character vector of length equal to <code>ndim(value)[along]</code> that
specifies the dimnames of <code>value</code> once added to <code>a</code> as array slices.
This is an optional argument that defaults to NULL where the pre-existing dimnames
of <code>value</code> are used.</p>
</td></tr>
<tr><td><code id="abind+2B26lt+2B3B-_+3A_overwrite">overwrite</code></td>
<td>
<p>not currently used, but there are plans to use it in future
versions of the functions. Right now the only option is FALSE.</p>
</td></tr>
<tr><td><code id="abind+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>matrix or array to be added as slices to <code>a</code>. Must have ndim
equal to <code>ndim(a)</code> or <code>ndim(a) - 1L</code>. Note, the dimensions have to match
those in <code>a</code>. For example, if <code>value</code> is a matrix you want to bind
along the third dimension of <code>a</code>, then <code>dim(value)</code> must be equal to
<code>dim(a)[1:2]</code>. If not, you will get an error from <code>abind::abind</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Like other similar functions (e.g., <code>`names&lt;-`</code> and <code>`[&lt;-`</code>),
<code>`rbind&lt;-`</code> does not appear to have a return object. However, it technically
does as a side effect. The argument <code>data</code> will have been changed such that
<code>value</code> has been added as rows. If a traditional return object is desired,
and no side effects, then it can be called like a traditional function:
dat2 &lt;- 'rbind&lt;-'(dat1, value = add1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># abind along the last dimension
# default `along` and `after`
HairEyeColor2 &lt;- HairEyeColor
intersex_ary &lt;- array(1:16, dim = c(4,4,1), dimnames = list(NULL, NULL, "Sex" = "Intersex"))
abind(HairEyeColor2) &lt;- intersex_ary
print(HairEyeColor2)
# user-specified `along` and `after`
HairEyeColor2 &lt;- HairEyeColor
intersex_ary &lt;- array(1:16, dim = c(4,4,1), dimnames = list(NULL, NULL, "Sex" = "Intersex"))
abind(HairEyeColor2, along = "Sex", after = 0L) &lt;- intersex_ary
print(HairEyeColor2)
# matrix as `value`
HairEyeColor2 &lt;- HairEyeColor
intersex_mat &lt;- matrix(1:16, nrow = 4, ncol = 4)
abind(HairEyeColor2, dim.nm = "Intersex") &lt;- intersex_mat
print(HairEyeColor2)

# abind along the first dimension
# array as `value`
HairEyeColor2 &lt;- HairEyeColor
auburn_ary &lt;- array(1:8, dim = c(1,4,2), dimnames = list("Hair" = "Auburn", NULL, NULL))
abind(HairEyeColor2, along = 1L) &lt;- auburn_ary
print(HairEyeColor2)
# matrix as `value`
HairEyeColor2 &lt;- HairEyeColor
auburn_mat &lt;- matrix(1:8, nrow = 4, ncol = 2) # rotate 90-degrees counter-clockwise in your mind
abind(HairEyeColor2, along = 1L, dim.nm = "Auburn") &lt;- auburn_mat
print(HairEyeColor2)
# `after` in the middle
HairEyeColor2 &lt;- HairEyeColor
auburn_mat &lt;- matrix(1:8, nrow = 4, ncol = 2) # rotate 90-degrees counter-clockwise in your mind
abind(HairEyeColor2, along = 1L, after = 2L, dim.nm = "Auburn") &lt;- auburn_mat
print(HairEyeColor2)

# abind along the second dimension
# array as `value`
HairEyeColor2 &lt;- HairEyeColor
amber_ary &lt;- array(1:8, dim = c(4,1,2), dimnames = list(NULL, "Eye" = "Amber", NULL))
abind(HairEyeColor2, along = 2L) &lt;- amber_ary
print(HairEyeColor2)
# matrix as `value`
HairEyeColor2 &lt;- HairEyeColor
amber_mat &lt;- matrix(1:8, nrow = 4, ncol = 2)
abind(HairEyeColor2, along = 2L, dim.nm = "Amber") &lt;- amber_mat
print(HairEyeColor2)
# `after` in the middle
HairEyeColor2 &lt;- HairEyeColor
amber_mat &lt;- matrix(1:8, nrow = 4, ncol = 2)
abind(HairEyeColor2, along = 2L, after = "Blue", dim.nm = "Amber") &lt;- amber_mat
print(HairEyeColor2)
</code></pre>

<hr>
<h2 id='all_diff'>Test if All Elements are Different</h2><span id='topic+all_diff'></span>

<h3>Description</h3>

<p><code>all_diff</code> tests if all elements are different. The elements could be either
from an atomic vector, list vector, or list. If <code>x</code> does not have any unique
values (e.g., NULL), then FALSE is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_diff(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_diff_+3A_x">x</code></td>
<td>
<p>atomic vector, list vector, or list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The machine precision of <code>all_diff</code> for numeric vectors is the same as
<code>unique</code>. This can causes a problem for some floating-point numbers.
</p>


<h3>Value</h3>

<p>logical vector of length 1 specifying whether all the elements in <code>x</code>
are the same (TRUE) or not (FALSE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all_diff(1:10)
all_diff(c(1:10, 10))
all_diff(c(1.0000000, 1.0000001, 0.9999999)) # machine precision good for most cases
all_diff(1) # works for vectors of length 1
</code></pre>

<hr>
<h2 id='all_same'>Test if All Elements are the Same</h2><span id='topic+all_same'></span>

<h3>Description</h3>

<p><code>all_same</code> tests if all elements are the same. The elements could be either
from an atomic vector, list vector, or list. If <code>x</code> does not have any unique
values (e.g., NULL), then FALSE is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_same(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_same_+3A_x">x</code></td>
<td>
<p>atomic vector, list vector, or list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The machine precision of <code>all_same</code> for numeric vectors is the same as
<code>unique</code>. This can causes a problem for some floating-point numbers.
</p>


<h3>Value</h3>

<p>logical vector of length 1 specifying whether all the elements in <code>x</code>
are the same (TRUE) or not (FALSE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all_same(rep.int("a", times = 10))
all_same(rep.int(1, times = 10))
all_same(c(1.0000000, 1.0000001, 0.9999999)) # machine precision good for most cases
all_same(1) # works for vectors of length 1
</code></pre>

<hr>
<h2 id='append+26lt+3B-'>Add Elements to Vectors</h2><span id='topic+append+3C-'></span>

<h3>Description</h3>

<p><code>`append&lt;-`</code> adds elements to vectors as a side effect. The purpose of
the function is to replace the need to use vec2 &lt;- append(vec1, add1);
vec3 &lt;- append(vec2, add2); vec4 &lt;- append(vec3, add3), etc. It functions similarly
to <code>`[&lt;-.default`</code>, but allows you to specify the location of the elements
similar to <code>append</code> (vs. <code>c</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append(x, after = length(x), nm = NULL, overwrite = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="append+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>atomic vector, list vector, or list.</p>
</td></tr>
<tr><td><code id="append+2B26lt+2B3B-_+3A_after">after</code></td>
<td>
<p>either an integer vector with length 1 or a character vector of
length 1 specifying where to add <code>value</code>. If an integer vector, it is the position
of an element. If a character vector, it is the element with that name. Similar to
<code>append</code>, use 0L if you want the added elements to be first.</p>
</td></tr>
<tr><td><code id="append+2B26lt+2B3B-_+3A_nm">nm</code></td>
<td>
<p>character vector of length equal to the <code>length(value)</code> that specifies
the names of <code>value</code> once added to <code>x</code> as elements. This is an optional
argument that defaults to NULL where the pre-existing names of <code>value</code> are used.</p>
</td></tr>
<tr><td><code id="append+2B26lt+2B3B-_+3A_overwrite">overwrite</code></td>
<td>
<p>logical vector of length 1 specifying whether elements from
<code>value</code> or <code>nm</code> should overwrite elements in <code>x</code> with the
same names. Note, if <code>overwrite</code> = FALSE, repeat names are possible
similar to <code>append</code>.</p>
</td></tr>
<tr><td><code id="append+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>vector of the same typeof as <code>x</code> to be added as elements to <code>x</code>.
Note that for atomic vectors, if more complex elements are added, then the return
object will be typeof the most complex element in <code>x</code> and <code>value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some traditional R folks may find this function uncomfortable. R is famous for limiting
side effects, except for a few notable exceptions (e.g., <code>`[&lt;-`</code> and <code>`names&lt;-`</code>).
Part of the reason is that side effects can be computationally inefficient in R.
The entire object often has to be re-constructed and re-saved to memory. For
example, a more computationally efficient alternative to append(vec) &lt;- add1;
append(vec) &lt;- add2; append(vec) &lt;- add3 is vec1 &lt;- do.call(what = c,
args = list(dat, add1, add2, add3)). However, <code>`append&lt;-`</code> was not created
for R programming use when computational efficiency is valued; it was created
for R interactive use when user convenience is valued.
</p>


<h3>Value</h3>

<p>Like other similar functions (e.g., <code>`names&lt;-`</code> and <code>`[&lt;-`</code>),
it does not appear to have a return object. However, it technically does as a
side effect. The argument <code>x</code> will have been changed such that <code>value</code>
has been added as elements. If a traditional return object is desired, and no side
effects, then it can be called like a traditional function:
vec2 &lt;- 'append&lt;-'(vec1, value = add1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# no names
x &lt;- letters
append(x) &lt;- LETTERS
append(x, after = match("z", table = x)) &lt;- "case_switch" # with the position
   # of the added value specified

# ya names
y &lt;- setNames(object = letters, nm = LETTERS)
append(y) &lt;- c("ONE" = 1, "TWO" = 2, "THREE" = 3) # with names provided by `value`
tmp &lt;- 1:(length(y) - 3)
y &lt;- y[tmp] # if I put a () inside of a [], Roxygen doesn't like it
append(y, nm = c("ONE","TWO","THREE")) &lt;- c(1,2,3) # with names specified by `nm`
append(y, after = "Z", nm = "ZERO") &lt;- "0" # using name to provide `after`

# using overwrite
append(y, overwrite = TRUE) &lt;- c("ONE" = "one","TWO" = "two", "THREE" = "three")
append(y, overwrite = FALSE) &lt;- c("ONE" = "one","TWO" = "two", "THREE" = "three")

</code></pre>

<hr>
<h2 id='cat0'>Concatenate and Print with No Separator</h2><span id='topic+cat0'></span>

<h3>Description</h3>

<p><code>cat0</code> concatenates and prints objects without any separator. <code>cat0</code>
is to <code>cat</code> as <code>paste0</code> is to <code>paste</code>. It also allows you to
specify line breaks before (<code>n.before</code>) and after (<code>n.after</code>) the
the printing of the concatenated R objects. <code>cat0</code> function can be useful
in conjunction with <code>sink</code> for quick and dirty exporting of results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat0(
  ...,
  n.before = 1L,
  n.after = 1L,
  file = "",
  fill = FALSE,
  labels = NULL,
  append = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat0_+3A_...">...</code></td>
<td>
<p>one or more R objects. See details of <code>cat</code> for types of objects
allowed.</p>
</td></tr>
<tr><td><code id="cat0_+3A_n.before">n.before</code></td>
<td>
<p>integer vector of length 1 specifying how many line breaks to have
before printing the concatenated R objects.</p>
</td></tr>
<tr><td><code id="cat0_+3A_n.after">n.after</code></td>
<td>
<p>integer vector of length 1 specifying how many line breaks to have
after printing the concatenated R objects.</p>
</td></tr>
<tr><td><code id="cat0_+3A_file">file</code></td>
<td>
<p>A connection or a character string naming the file to print to.
If &quot;&quot; (default), <code>cat0</code> prints to the standard output connection - the
console - unless redirected by <code>sink</code>.</p>
</td></tr>
<tr><td><code id="cat0_+3A_fill">fill</code></td>
<td>
<p>A logical or (positive) numeric vector of length 1 controlling how
the output is broken into successive lines. If FALSE (default), new line breaks are
only created explicity by <code>"\n"</code> bring called. If TRUE, the output is broken into
lines with print width equal to the option &quot;width&quot; (<code>options()[["width"]]</code>).
If a (positive) number, then the output is broken after width of that length.</p>
</td></tr>
<tr><td><code id="cat0_+3A_labels">labels</code></td>
<td>
<p>A character vector of labels for the lines printed. Ignored if
<code>fill</code> = FALSE.</p>
</td></tr>
<tr><td><code id="cat0_+3A_append">append</code></td>
<td>
<p>A logical vector of length 1. Only used if the argument <code>file</code>
is the name of a file (and not a connection). If TRUE, output will be appended
to the existing file. If FALSE, output will overwrite the contents of the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing as the function only prints and does not return an R object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat0(names(attitude))
cat0("MODEL COEFFICIENTS:", coef(lm(rating ~ critical + advance, data = attitude)),
   n.before = 0, n.after = 2)
</code></pre>

<hr>
<h2 id='cbind_fill'>Bind DataFrames Along Columns - Filling in Missing Rows with NA</h2><span id='topic+cbind_fill'></span>

<h3>Description</h3>

<p><code>cbind_fill</code> binds together matrix-like objects by columns. The input
objects will all internally be converted to data.frames by the generic function
<code>as.data.frame</code>. When some objects do not contain rows that are present in other
objects, NAs will be added to fill up the returned combined data.frame. If a matrix
doesn't have rownames, the row number is used. Note that this means that a row
with name &quot;1&quot; is merged with the first row of a matrix without name and so on.
The returned matrix will always have row names. Colnames are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind_fill(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbind_fill_+3A_...">...</code></td>
<td>
<p>any combination of data.frames, matrices, or atomic vectors input
as separate arguments or a list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cbind_fill</code> ensures each object has unique colnames and then calls
<code>Join(by = "0")</code>. It is intended to be the column version of <code>plyr::rbind.fill</code>;
it differs by allowing inputs to be matrices or vectors in addition to data.frames.
</p>


<h3>Value</h3>

<p>data.frame created by combining all the objects input together. It will always
have rownames. If colnames are not provided to the matrix-like objects, the
returned colnames can be rather esoteric since default colnaming will be revised
to ensure each colname is unique. If <code>...</code> is a list of vectors, then the
colnames will be the names of the list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cbind_fill_matrix">cbind_fill_matrix</a></code>
<code><a href="plyr.html#topic+rbind.fill">rbind.fill</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# standard use
A &lt;- data.frame("first" = 1:2, "second" = 3:4)
B &lt;- data.frame("third" = 6:8, "fourth" = 9:11)
print(A)
print(B)
cbind_fill(A, B)

# help with unstack()
row_keep &lt;- sample(1:nrow(InsectSprays), size = 36)
InsectSprays2 &lt;- InsectSprays[row_keep, ]
unstacked &lt;- unstack(InsectSprays2)
cbind_fill(unstacked)

# using rownames for binding
rownames(A) &lt;- c("one", "two")
rownames(B) &lt;- c("three","two","one")
print(A)
print(B)
cbind_fill(A, B)

# matrices as input
A &lt;- matrix(1:4, 2)
B &lt;- matrix(6:11, 3)
print(A)
print(B)
cbind_fill(A, B)

# atomic vector input
A &lt;- data.frame("first" = 1:2, "second" = 3:4)
B &lt;- data.frame("third" = 6:8, "fourth" = 9:11)
C &lt;- c(12,13,14,15)
D &lt;- c(16,17,18,19)
cbind_fill(A, B, C, D)

# same as plyr::rbind.fill, it doesn't handles well some inputs with custom rownames
# and others with default rownames
rownames(A) &lt;- c("one", "two")
print(A)
print(B)
cbind_fill(A, B)

</code></pre>

<hr>
<h2 id='cbind_fill_matrix'>Bind Matrices Along Columns - Filling in Missing Rows with NA</h2><span id='topic+cbind_fill_matrix'></span>

<h3>Description</h3>

<p><code>cbind_fill_matrix</code> binds together matrix-like objects by columns. The input
objects will all internally be converted to matrices by the generic function
<code>as.matrix</code>. When some objects do not contain rows that are present in other
objects, NAs will be added to fill up the returned combined matrix. If a matrix
doesn't have rownames, the row number is used. Note that this means that a row
with name &quot;1&quot; is merged with the first row of a matrix without name and so on.
The returned matrix will always have row names. Colnames are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind_fill_matrix(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbind_fill_matrix_+3A_...">...</code></td>
<td>
<p>any combination of matrices, data.frames, or atomic vectors input
as separate arguments or a list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cbind_fill_matrix</code> is <code>t.default</code> + <code>plyr::rbind.fill.matrix</code>
+ <code>t.default</code> and is based on the code within <code>plyr::rbind.fill.matrix</code>.
</p>


<h3>Value</h3>

<p>matrix created by combining all the objects input together. It will always
have rownames. It will only have colnames if <code>...</code> is a list of vectors,
in which the colnames will be the names of the list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cbind_fill">cbind_fill</a></code>
<code><a href="plyr.html#topic+rbind.fill.matrix">rbind.fill.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# standard use
A &lt;- matrix(1:4, 2)
B &lt;- matrix(6:11, 3)
print(A)
print(B)
cbind_fill_matrix(A, B)

# help with unstack()
row_keep &lt;- sample(1:nrow(InsectSprays), size = 36)
InsectSprays2 &lt;- InsectSprays[row_keep, ]
unstacked &lt;- unstack(InsectSprays2)
cbind_fill_matrix(unstacked)

# using rownames for binding
rownames(A) &lt;- c("one", "two")
rownames(B) &lt;- c("three","two","one")
print(A)
print(B)
cbind_fill_matrix(A, B)

# data.frame input
C &lt;- data.frame("V1" = c(12,13,14,15), row.names = c("one","two","three","four"))
print(C)
cbind_fill_matrix(A, B, C)

# atomic vector input
A &lt;- matrix(1:4, 2)
B &lt;- matrix(6:11, 3)
C &lt;- c(12,13,14,15)
cbind_fill_matrix(A, B, C)

# same as plyr::rbind.fill.matrix, cbind_fill_matrix doesn't like some input
# with dimnames and others without...
rownames(A) &lt;- c("one", "two")
print(A)
print(B)
cbind_fill_matrix(A, B)

</code></pre>

<hr>
<h2 id='cbind+26lt+3B-'>Add Columns to Data Objects</h2><span id='topic+cbind+3C-'></span>

<h3>Description</h3>

<p><code>`cbind&lt;-`</code> adds columns to data objects as a side effect. The purpose of
the function is to replace the need to use dat2 &lt;- cbind(dat1, add1);
dat3 &lt;- cbind(dat2, add2); dat4 &lt;- cbind(dat3, add3), etc. For data.frames,
it functions similarly to <code>`[&lt;-.data.frame`</code>, but allows you to specify the
location of the columns similar to <code>append</code> (vs. <code>c</code>) and overwrite
columns with the same colnames. For matrices, it offers more novel functionality
since <code>`[&lt;-.matrix`</code> does not exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind(data, after = ncol(data), col.nm = NULL, overwrite = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cbind+2B26lt+2B3B-_+3A_data">data</code></td>
<td>
<p>data.frame or matrix of data.</p>
</td></tr>
<tr><td><code id="cbind+2B26lt+2B3B-_+3A_after">after</code></td>
<td>
<p>either an integer vector with length 1 or a character vector of
length 1 specifying where to add <code>value</code>. If an integer vector, it is the
position of a column. If a character vector it is the column with that name.
Similar to <code>append</code>, use 0L if you want the added columns to be first.</p>
</td></tr>
<tr><td><code id="cbind+2B26lt+2B3B-_+3A_col.nm">col.nm</code></td>
<td>
<p>character vector of length equal to <code>NCOL(value)</code> that
specifies the colnames of <code>value</code> once added to <code>data</code> as columns.
This is an optional argument that defaults to NULL where the pre-existing colnames
of <code>value</code> are used.</p>
</td></tr>
<tr><td><code id="cbind+2B26lt+2B3B-_+3A_overwrite">overwrite</code></td>
<td>
<p>logical vector of length 1 specifying whether columns from
<code>value</code> or <code>col.nm</code> should overwrite columns in <code>data</code> with the
same colnames. Note, if <code>overwrite</code> = FALSE, repeat colnames are possible
similar to <code>cbind</code>.</p>
</td></tr>
<tr><td><code id="cbind+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>data.frame, matrix, or atomic vector to be added as columns to
<code>data</code>. If a data.frame or matrix, it must have the same nrow as <code>data</code>.
If an atomic vector, it must have length equal to nrow of <code>data</code>. Note, if it
is an atomic vector and <code>col.nm</code> is NULL, then the name of the added column
will be &quot;value&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some traditional R folks may find this function uncomfortable. R is famous for limiting
side effects, except for a few notable exceptions (e.g., <code>`[&lt;-`</code> and <code>`names&lt;-`</code>).
Part of the reason is that side effects can be computationally inefficient in R.
The entire object often has to be re-constructed and re-saved to memory. For
example, a more computationally efficient alternative to cbind(dat) &lt;- add1;
cbind(dat) &lt;- add2; cbind(dat) &lt;- add3 is dat1 &lt;- do.call(what = cbind,
args = list(dat, add1, add2, add3)). However, <code>`cbind&lt;-`</code> was not created
for R programming use when computational efficiency is valued; it is created
for R interactive use when user convenience is valued.
</p>
<p>Similar to <code>`cbind`</code>, <code>`cbind&lt;-`</code> works with both data.frames and matrices.
This is because <code>`cbind`</code> is a generic function with a default method that
works with matrices and a data.frame method that works with data.frames. Similar
to <code>`cbind`</code>, if colnames of <code>value</code> are not given and <code>col.nm</code>
is left NULL, then the colnames of the return object are automatically created
and can be dissatisfying.
</p>


<h3>Value</h3>

<p>Like other similar functions (e.g., <code>`names&lt;-`</code> and <code>`[&lt;-`</code>),
<code>`cbind&lt;-`</code> does not appear to have a return object. However, it technically
does as a side effect. The argument <code>data</code> will have been changed such that
<code>value</code> has been added as columns. If a traditional return object is desired,
and no side effects, then it can be called like a traditional function:
dat2 &lt;- 'cbind&lt;-'(dat1, value = add1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>attitude2 &lt;- attitude
cbind(attitude2) &lt;- rowMeans(attitude2) # defaults to colnames = "value"
attitude2["value"] &lt;- NULL
cbind(attitude2, col.nm = "mean") &lt;- rowMeans(attitude2) # colnames specified by `col.nm`
attitude2["mean"] &lt;- NULL
cbind(attitude2, after = "privileges", col.nm = c("mean","sum")) &lt;-
   cbind(rowMeans(attitude2), rowSums(attitude2)) # `value` can be a matrix
attitude2[c("mean","sum")] &lt;- NULL
attitude2 &lt;- `cbind&lt;-`(data = attitude2, value = rowMeans(attitude2)) # traditional call
attitude2["value"] &lt;- NULL
cbind(attitude2, after = "privileges", col.nm = "mean") &lt;-
   rowMeans(attitude2) # `data` can be a matrix
cbind(attitude2) &lt;- data.frame("mean" = rep.int(x = "mean", times = 30L)) # overwrite = TRUE
cbind(attitude2, overwrite = FALSE) &lt;-
   data.frame("mean" = rep.int(x = "mean", times = 30L)) # overwrite = FALSE
cbind(attitude2) &lt;- data.frame("mean" = rep.int(x = "MEAN", times = 30L),
   "sum" = rep.int(x = "SUM", times = 30L)) # will overwrite only the first "mean" column
   # then will append the remaining columns
</code></pre>

<hr>
<h2 id='codes'>Integer Codes of Factor Levels</h2><span id='topic+codes'></span>

<h3>Description</h3>

<p><code>codes</code> returns the integer codes for each factor level from a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codes(fct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="codes_+3A_fct">fct</code></td>
<td>
<p>factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector with length = <code>length(levels(fct))</code>, elements = integer
codes of <code>fct</code> and names = <code>levels(fct)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>codes(state.region)
codes(iris$"Species")
</code></pre>

<hr>
<h2 id='d2a'>Data-Frame to (3D+) Array or Matrix</h2><span id='topic+d2a'></span>

<h3>Description</h3>

<p><code>d2a</code> converts a data.frame to a (3D+) array or matrix. This function assumes
the data.frame contains 2+ variable dimensions, which will correspond to the
returned arrays/matrix dimensions. One or multiple variables can contain the
elements of the returned array (only one variable can contain the elements for
returning a matrix). In the case of multiple variables, they will be binded as
the last dimension in the returned array with dimnames equal to the variable names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2a(d, dim.nm = names(d)[-ncol(d)], rtn.dim.lab = "el_nm", check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d2a_+3A_d">d</code></td>
<td>
<p>data.frame with at least 3 columns, where 2+ columns are variable
dimensions and 1+ columns contain the to-be returned array/matrix elements.</p>
</td></tr>
<tr><td><code id="d2a_+3A_dim.nm">dim.nm</code></td>
<td>
<p>character vector of 2+ length specifying the colnames in <code>d</code>
that contain the variable dimensions. These do not need to be factors or character
vectors. Note, all columns in <code>d</code> other than <code>dim.nm</code> are assumed to be
element columns.</p>
</td></tr>
<tr><td><code id="d2a_+3A_rtn.dim.lab">rtn.dim.lab</code></td>
<td>
<p>character vector of length 1 specifying the dimlabel to use
for the last dimension in the returned array when there are multiple element columns
in <code>d</code>. Note, that <code>NA</code> will be converted to &quot;NA&quot; and <code>NULL</code> will
return an error. If you don't want any dimlabel to show, <code>""</code> is probably the
best option. If there is only one element column in <code>d</code>, this argument is
ignored by <code>d2a</code>.</p>
</td></tr>
<tr><td><code id="d2a_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>d</code> is a data.frame.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>d2a</code> is a wrapper for <code>reshape::cast</code> with the addition of reordering
the dimnames by position, which sorts the dimnames by the position they first
appear in the variable dimensions of the data.frame (<code>reshape::cast</code> sorts
all the dimnames alphabetically).
</p>


<h3>Value</h3>

<p>(3D+) array or matrix formed from the dimensions <code>d[dim.nm]</code> with
dimlabels = <code>dim.nm</code> (and <code>rtn.dim.lab</code> if there are multiple element
columns). The dimnames are the unique elements <code>d[dim.nm]</code> and are ordered by
position (rather than alphabetically), which allow for conversions back to the
original array after a call to <code>a2d()</code> or matrix after a call to <code>m2d()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 3D array
print(HairEyeColor)
d &lt;- reshape::melt.array(HairEyeColor)
a &lt;- reshape::cast(d, Hair ~ Eye ~ Sex)
identical(a, unclass(HairEyeColor)) # not the same as HairEyeColor
d &lt;- a2d(HairEyeColor)
a &lt;- d2a(d, dim.nm = c("Hair","Eye","Sex"))
identical(a, unclass(HairEyeColor)) # yes the same as HairEyeColor

# matrix
attitude_mat &lt;- d2m(attitude)
d &lt;- m2d(attitude_mat, col = 0)
m &lt;- d2a(d)
identical(m, attitude_mat) # yes the same as attitude_mat

# correlation data.frame example for p-values using psych::corr.test(attitude[1:3])
# corr_test &lt;- psych::corr.test(attitude)
# a &lt;- lm2a(corr_test[c("r","se","t","p")])
r &lt;- matrix(c(1.0000000, 0.8254176, 0.4261169, 0.8254176, 1.0000000, 0.5582882,
   0.4261169, 0.5582882, 1.0000000), nrow = 3, ncol = 3, byrow = FALSE)
se &lt;- matrix(c(0.0000000, 0.1066848, 0.1709662, 0.1066848, 0.0000000, 0.1567886,
   0.1709662, 0.1567886, 0.0000000), nrow = 3, ncol = 3, byrow = FALSE)
t &lt;- matrix(c(Inf, 7.736978, 2.492404, 7.736978, Inf, 3.560771,
   2.492404, 3.560771, Inf), nrow = 3, ncol = 3, byrow = FALSE)
p &lt;- matrix(c(0.000000e+00, 1.987682e-08, 1.887702e-02, 5.963047e-08, 0.000000e+00,
   1.345519e-03, 0.018877022, 0.002691039, 0.000000000), nrow = 3, ncol = 3, byrow = FALSE)
a &lt;- abind::abind(r, se, t, p, along = 3L)
dimnames(a) &lt;- list(names(attitude[1:3]), names(attitude[1:3]), c("r","se","t","p"))
d &lt;- a2d(a = a, col = 3)
a2 &lt;- d2a(d = d, dim.nm = c("X1","X2"))
all.equal(a, a2) # dimlabels differ
dimnames(a2) &lt;- unname(dimnames(a2))
all.equal(a, a2) # now it is true

# correlation data.frame example for confidence intervals using psych::corr.test(attitude[1:3])
# corr_test &lt;- psych::corr.test(attitude[1:3])
# d &lt;- corr_test[["ci"]][c("r","p","lower","upper")]
# cbind(d, after = 0L) &lt;- reshape::colsplit(row.names(d), split = "-", names = c("X1","X2"))
# tmp &lt;- d[c("X2","X1","r","p","lower","upper")]
# d2 &lt;- plyr::rename(tmp, c("X1" = "X2", "X2" = "X1"))
# short_nm &lt;- unique(c(fct2v(d[["X1"]]), fct2v(d[["X2"]])))
# d3 &lt;- data.frame("X1" = short_nm, "X2" = short_nm,
#    "r" = NA_real_, "p" = NA_real_, "lower" = NA_real_, "upper" = NA_real_)
# d_all &lt;- ld2d(ld = list(d, d2, d3), rtn.listnames.nm = NULL, rtn.rownames.nm = NULL)
d_all &lt;- data.frame(
   "X1" = c("ratng","ratng","cmpln","cmpln","prvlg","prvlg","ratng","cmpln","prvlg"),
   "X2" = c("cmpln","prvlg","prvlg","ratng","ratng","cmpln","ratng","cmpln","prvlg"),
   "r" = c(0.8254176, 0.4261169, 0.5582882, 0.8254176, 0.4261169, 0.5582882, NA, NA, NA),
   "p" = c(1.987682e-08, 1.887702e-02, 1.345519e-03, 1.987682e-08,
      1.887702e-02, 1.345519e-03, NA, NA, NA),
   "lower" = c(0.66201277, 0.07778967, 0.24787510, 0.66201277, 0.07778967,
      0.24787510, NA, NA, NA),
   "upper" = c(0.9139139, 0.6817292, 0.7647418, 0.9139139, 0.6817292,
      0.7647418, NA, NA, NA)
)
tmp &lt;- d2a(d = d_all, dim.nm = c("X1","X2"), rtn.dim.lab = "stat")
short_nm &lt;- c("ratng","cmpln","prvlg")
dim_names &lt;- list(short_nm, short_nm, c("r","p","lower","upper"))
a &lt;- do.call(what = `[`, args = c(list(tmp), dim_names))
print(a)

</code></pre>

<hr>
<h2 id='d2d'>Data-Frame to Data-Frame (e.g., factors to character vectors)</h2><span id='topic+d2d'></span>

<h3>Description</h3>

<p><code>d2d</code> converts a data.frame to a modified version of the data.frame. It is
used to convert factors, character vectors, and logical vectors to different
classes/types (e.g., factors to character vectors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2d(
  d,
  fct = "chr",
  chr = "chr",
  lgl = "int",
  order.lvl = "alphanum",
  decreasing = FALSE,
  na.lvl = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d2d_+3A_d">d</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="d2d_+3A_fct">fct</code></td>
<td>
<p>character vector of length 1 specifying what factors should be converted
to. There are three options: 1) &quot;chr&quot; for converting to character vectors (i.e.,
factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e., factor codes),
or 3) &quot;fct&quot; for keeping the factor as is without any changes.</p>
</td></tr>
<tr><td><code id="d2d_+3A_chr">chr</code></td>
<td>
<p>character vector of length 1 specifying what character vectors should
be converted to. There are three options: 1) &quot;fct&quot; for converting to factors (i.e.,
elements will be factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e.,
factor codes after first converting to a factor), or 3) &quot;chr&quot; for keeping the
character vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="d2d_+3A_lgl">lgl</code></td>
<td>
<p>character vector of length 1 specifying what logical vectors should
be converted to. There are four options: 1) &quot;fct&quot; for converting to factors (i.e.,
&quot;TRUE&quot; and &quot;FALSE&quot; will be factor labels), 2) &quot;chr&quot; for converting to character
vectors (i.e., elements will be &quot;TRUE&quot; and &quot;FALSE&quot;), 3) &quot;int&quot; for converting to
integer vectors (i.e., TRUE = 1; FALSE = 0), and 4) &quot;lgl&quot; for keeping the logical
vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="d2d_+3A_order.lvl">order.lvl</code></td>
<td>
<p>character vector of length 1 specifying how you want to order
the levels of the factor. The options are &quot;alphanum&quot;, which sorts the levels
alphanumerically (with NA last); &quot;position&quot;, which sorts the levels by the position
the level first appears; &quot;frequency&quot;, which sorts the levels by their frequency.
If any frequencies are tied, then the ties are sorted alphanumerically (with NA last).</p>
</td></tr>
<tr><td><code id="d2d_+3A_decreasing">decreasing</code></td>
<td>
<p>logical vector of length 1 specifying whether the ordering of the
levels should be decreasing (TRUE) rather than increasing (FALSE).</p>
</td></tr>
<tr><td><code id="d2d_+3A_na.lvl">na.lvl</code></td>
<td>
<p>logical vector of length 1 specifying if NA should be considered a level.</p>
</td></tr>
<tr><td><code id="d2d_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>d</code> is a data.frame.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>d2d</code> internally uses the <code>fct2v</code> and <code>v2fct</code> functions. See them
or more details about how column conversions work.
</p>


<h3>Value</h3>

<p>data.frame with the same dim and dimnames as <code>d</code>, but with potentially
altered columns which were factors, character vectors, and/or integer vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(
"lgl_1" = c(TRUE, FALSE, NA),
"lgl_2" = c(FALSE, TRUE, NA),
"int_1" = c(1L, NA, 2L),
"int_2" = c(2L, NA, 1L),
"dbl_1" = c(1.1, NA, 2.2),
"dbl_2" = c(2.2, NA, 1.1),
"chr_1" = c(NA, "a","b"),
"chr_2" = c(NA, "b","a"),
"fct_1" = factor(c(NA, "one","two")),
"fct_2" = factor(c(NA, "two","one"))
)
str(dat)
x &lt;- d2d(dat); str(x) # default
x &lt;- d2d(dat, fct = "fct", chr = "fct", lgl = "fct"); str(x) # all to factors
x &lt;- d2d(dat, fct = "int", chr = "int"); str(x) # all to integers
</code></pre>

<hr>
<h2 id='d2ld'>Data-Frame to List of Data-Frames</h2><span id='topic+d2ld'></span>

<h3>Description</h3>

<p><code>d2ld</code> converts a data.frame to a list of data.frames. This is a simple call
to <code>split.data.frame</code> splitting the data.frame up by groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2ld(
  d,
  by,
  keep.by = TRUE,
  drop = FALSE,
  sep = ".",
  lex.order = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d2ld_+3A_d">d</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="d2ld_+3A_by">by</code></td>
<td>
<p>character vector of colnames specifying the groups to split the data.frame
up by. Can be multiple colnames, which implicitly calls <code>interaction</code>.</p>
</td></tr>
<tr><td><code id="d2ld_+3A_keep.by">keep.by</code></td>
<td>
<p>logical vector of length 1 specifying whether the by columns should
be kept in the list of data.frames (TRUE) or removed (FALSE).</p>
</td></tr>
<tr><td><code id="d2ld_+3A_drop">drop</code></td>
<td>
<p>logical vector of length 1 specifying whether unused groups
from the <code>by</code> columns should be dropped (TRUE) or kept (FALSE). This only applies
when there are multiple <code>by</code> columns. <code>drop</code> = FALSE can then result in some
data.frames with <code>nrow</code> = 0. See <code>interaction</code> for details.</p>
</td></tr>
<tr><td><code id="d2ld_+3A_sep">sep</code></td>
<td>
<p>character vector of length 1 specifying the string used to separate
the group names. Only applicable with multiple <code>by</code> columns. See
<code>interaction</code> for details.</p>
</td></tr>
<tr><td><code id="d2ld_+3A_lex.order">lex.order</code></td>
<td>
<p>logical vector of length 1 specifying the order of the data.frames
in the list based on the groups in the <code>by</code> columns. This only applies
when there are multiple <code>by</code> columns. See <code>interaction</code> for details.</p>
</td></tr>
<tr><td><code id="d2ld_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>d</code> is a data.frame and
<code>by</code> are colnames of <code>d</code>. This argument is available to allow flexibility
in whether the user values informative error messages (TRUE) vs. computational
efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data.frames split by the groups specified in the <code>by</code> columns.
The list names are the group names (with <code>sep</code> if there are multiple
<code>by</code> columns).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# one grouping variable
d2ld(d = mtcars, by = "vs")
d2ld(d = mtcars, by = "gear")

# two grouping variables
d2ld(d = mtcars, by = c("vs","gear"))
d2ld(d = mtcars, by = c("vs","gear"), lex.order = TRUE)

# keep.by argument
d2ld(d = mtcars, by = "vs", keep.by = FALSE)
d2ld(d = mtcars, by = "gear", keep.by = FALSE)
d2ld(d = mtcars, by = c("vs","gear"), keep.by = FALSE)

</code></pre>

<hr>
<h2 id='d2lv'>Data-Frame to List of (Atomic) Vectors</h2><span id='topic+d2lv'></span>

<h3>Description</h3>

<p><code>d2lv</code> converts a data.frame to a list of (atomic) vectors. This function
is really only worthwhile when <code>along</code> = 1 since when <code>along</code> = 2,
the function is essentially <code>as.list.data.frame(d)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2lv(d, along, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d2lv_+3A_d">d</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="d2lv_+3A_along">along</code></td>
<td>
<p>numeric vector of length 1 specifying which dimension to slice
the data.frame along. If 1, then the data.frame is sliced by rows. If 2, then the
data.frame is sliced by columns.</p>
</td></tr>
<tr><td><code id="d2lv_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>d</code> is a data.frame.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of (atomic) vectors. If <code>along</code> = 1, then the names are the
rownames of <code>d</code> and the vectors are rows from <code>d</code>. If <code>along</code> = 2,
then the names are the colnames of <code>d</code> and the vector are columns from <code>d</code>.
Note, the vectors always have the same length as <code>nrow(d)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d2lv(mtcars, along = 1)
d2lv(mtcars, along = 2)
d2lv(CO2, along = 1) # all vectors converted to typeof character
d2lv(CO2, along = 2) # each column stays its own typeof (or class for factors)
# check = FALSE
try_expr(d2lv(mtcars, along = 3, check = FALSE)) # less informative error message
try_expr(d2lv(mtcars, along = 3, check = TRUE)) # more informative error message
</code></pre>

<hr>
<h2 id='d2m'>Data-Frame to Matrix</h2><span id='topic+d2m'></span>

<h3>Description</h3>

<p><code>d2m</code> converts a data.frame to a matrix. The user can specify how to convert
factors, character vectors, and integer vectors in the data.frame through the
internal use of the <code>d2d</code> function. After the call to <code>d2d</code>, <code>d2m</code>
simply calls <code>as.matrix.data.frame(rownames.force = TRUE)</code>, which will
return a matrix of the most complex typeof of any column in the data.frame
(most complex to least complex: character, double, integer, logical). Therefore,
if any factors or character vectors are left in the data.frame, it will return
a character matrix. On the other side of things, if all columns in the data.frame
are logical, then it will return a logical matrix. However, if every column in the
data.frame is logical except for one factor or character vector, then it will
return a character matrix. (If you have a data.frame where 2 columns are the matrix
dimnames and one column is the matrix elements, then use <code>d2a()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2m(
  d,
  fct = "chr",
  chr = "chr",
  lgl = "int",
  order.lvl = "alphanum",
  decreasing = FALSE,
  na.lvl = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d2m_+3A_d">d</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="d2m_+3A_fct">fct</code></td>
<td>
<p>character vector of length 1 specifying what factors should be converted
to. There are three options: 1) &quot;chr&quot; for converting to character vectors (i.e.,
factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e., factor codes),
or 3) &quot;fct&quot; for keeping the factor as is without any changes.</p>
</td></tr>
<tr><td><code id="d2m_+3A_chr">chr</code></td>
<td>
<p>character vector of length 1 specifying what character vectors should
be converted to. There are three options: 1) &quot;fct&quot; for converting to factors (i.e.,
elements will be factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e.,
factor codes after first converting to a factor), or 3) &quot;chr&quot; for keeping the
character vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="d2m_+3A_lgl">lgl</code></td>
<td>
<p>character vector of length 1 specifying what logical vectors should
be converted to. There are four options: 1) &quot;fct&quot; for converting to factors (i.e.,
&quot;TRUE&quot; and &quot;FALSE&quot; will be factor labels), 2) &quot;chr&quot; for converting to character
vectors (i.e., elements will be &quot;TRUE&quot; and &quot;FALSE&quot;), 3) &quot;int&quot; for converting to
integer vectors (i.e., TRUE = 1; FALSE = 0), and 4) &quot;lgl&quot; for keeping the logical
vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="d2m_+3A_order.lvl">order.lvl</code></td>
<td>
<p>character vector of length 1 specifying how you want to order
the levels of the factor. The options are &quot;alphanum&quot;, which sorts the levels
alphanumerically (with NA last); &quot;position&quot;, which sorts the levels by the position
the level first appears; &quot;frequency&quot;, which sorts the levels by their frequency.
If any frequencies are tied, then the ties are sorted alphanumerically (with NA last).</p>
</td></tr>
<tr><td><code id="d2m_+3A_decreasing">decreasing</code></td>
<td>
<p>logical vector of length 1 specifying whether the ordering of the
levels should be decreasing (TRUE) rather than increasing (FALSE).</p>
</td></tr>
<tr><td><code id="d2m_+3A_na.lvl">na.lvl</code></td>
<td>
<p>logical vector of length 1 specifying if NA should be considered a level.</p>
</td></tr>
<tr><td><code id="d2m_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>d</code> is a data.frame.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with the same dim and dimnames as <code>d</code>. After applying the
factor, character vector, and/or integer vector conversions through <code>d2d</code>,
the matrix will have typeof = most complex typeof of any column in the modified
data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- d2m(mtcars); str(x)
dat &lt;- as.data.frame(CO2)
x &lt;- d2m(dat); str(x)
x &lt;- d2m(dat, fct = "int"); str(x)
</code></pre>

<hr>
<h2 id='d2v'>Data-Frame to (Atomic) Vector</h2><span id='topic+d2v'></span>

<h3>Description</h3>

<p><code>d2v</code> converts a data.frame to a matrix. The user can specify how to convert
factors, character vectors, and integer vectors in the data.frame through the
internal use of the <code>d2d</code> function. After the call to <code>d2d</code>, the
data.frame is simplied to an atomic vector, which will return a vector of the most
complex typeof of any column in the data.frame (most complex to least complex:
character, double, integer, logical). Therefore, if any factors or character
vectors are left in the data.frame, it will return a character vector. On the
other side of things, if all columns in the data.frame are logical, then it will
return a logical vector. However, if every column in the data.frame is logical
except for one factor or character vector, then it will return a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2v(
  d,
  along = 2,
  use.dimnames = TRUE,
  sep = "_",
  fct = "chr",
  chr = "chr",
  lgl = "int",
  order.lvl = "alphanum",
  decreasing = FALSE,
  na.lvl = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d2v_+3A_d">d</code></td>
<td>
<p>data.frame.</p>
</td></tr>
<tr><td><code id="d2v_+3A_along">along</code></td>
<td>
<p>numeric vector of length one that is equal to either 1 or 2.
1 means that <code>d</code> is split along rows (i.e., dimension 1) and then concatenated.
2 means that <code>d</code> is split along columns (i.e., dimension 2) and then concatenated.</p>
</td></tr>
<tr><td><code id="d2v_+3A_use.dimnames">use.dimnames</code></td>
<td>
<p>logical vector of length 1 that specifies whether the dimnames
of <code>d</code> should be used to create the names for the returned vector. If FALSE,
the returned vector will have NULL names. If TRUE, see details of <code>m2v</code>.</p>
</td></tr>
<tr><td><code id="d2v_+3A_sep">sep</code></td>
<td>
<p>character vector of length 1 specifying the string that will separate
the rownames and colnames in the naming scheme of the returned vector. Note, <code>sep</code>
is not used if <code>use.dimnames</code> = FALSE.</p>
</td></tr>
<tr><td><code id="d2v_+3A_fct">fct</code></td>
<td>
<p>character vector of length 1 specifying what factors should be converted
to. There are three options: 1) &quot;chr&quot; for converting to character vectors (i.e.,
factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e., factor codes),
or 3) &quot;fct&quot; for keeping the factor as is without any changes.</p>
</td></tr>
<tr><td><code id="d2v_+3A_chr">chr</code></td>
<td>
<p>character vector of length 1 specifying what character vectors should
be converted to. There are three options: 1) &quot;fct&quot; for converting to factors (i.e.,
elements will be factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e.,
factor codes after first converting to a factor), or 3) &quot;chr&quot; for keeping the
character vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="d2v_+3A_lgl">lgl</code></td>
<td>
<p>character vector of length 1 specifying what logical vectors should
be converted to. There are four options: 1) &quot;fct&quot; for converting to factors (i.e.,
&quot;TRUE&quot; and &quot;FALSE&quot; will be factor labels), 2) &quot;chr&quot; for converting to character
vectors (i.e., elements will be &quot;TRUE&quot; and &quot;FALSE&quot;), 3) &quot;int&quot; for converting to
integer vectors (i.e., TRUE = 1; FALSE = 0), and 4) &quot;lgl&quot; for keeping the logical
vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="d2v_+3A_order.lvl">order.lvl</code></td>
<td>
<p>character vector of length 1 specifying how you want to order
the levels of the factor. The options are &quot;alphanum&quot;, which sorts the levels
alphanumerically (with NA last); &quot;position&quot;, which sorts the levels by the position
the level first appears; &quot;frequency&quot;, which sorts the levels by their frequency.
If any frequencies are tied, then the ties are sorted alphanumerically (with NA last).</p>
</td></tr>
<tr><td><code id="d2v_+3A_decreasing">decreasing</code></td>
<td>
<p>logical vector of length 1 specifying whether the ordering of the
levels should be decreasing (TRUE) rather than increasing (FALSE).</p>
</td></tr>
<tr><td><code id="d2v_+3A_na.lvl">na.lvl</code></td>
<td>
<p>logical vector of length 1 specifying if NA should be considered a level.</p>
</td></tr>
<tr><td><code id="d2v_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>d</code> is a data.frame.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(atomic) vector with elements from <code>d</code>. If <code>d</code> had one row,
then the names of the return object are <code>names(d)</code>. If <code>d</code> has one
column, then the names of the return object are <code>row.names(d)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># general data.frame
d2v(mtcars) # default
d2v(d = mtcars, along = 1) # concatenate along rows
d2v(d = mtcars, sep = ".") # change the sep of the rownames(d) and colnames(d)
d2v(d = mtcars, use.dimnames = FALSE) # return object has no names
# one row/column data.frame
one_row &lt;- mtcars[1,, drop = FALSE]
d2v(one_row)
one_col &lt;- mtcars[, 1, drop = FALSE]
d2v(one_col)
one_all &lt;- mtcars[1,1, drop = FALSE]
d2v(one_all)
d2v(one_all, use.dimnames = FALSE)
</code></pre>

<hr>
<h2 id='dimlabels'>Dimension labels (i.e., names of dimnames)</h2><span id='topic+dimlabels'></span>

<h3>Description</h3>

<p><code>dimlabels</code> returns the the dimension labels (i.e., names of dimnames)
of an object. This is most useful for arrays, which can have anywhere from 1
to 1000+ dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimlabels(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimlabels_+3A_x">x</code></td>
<td>
<p>object that has dimensions (e.g., array).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dimlabels</code> is a very simple function that is simply <code>names(dimnames(x))</code>.
</p>


<h3>Value</h3>

<p>character vector of length  = <code>ndim(x)</code> specifying the dimension
labels (i.e., names of dimnames) of <code>x</code>. If <code>x</code> does not have any
dimensions, or has dimensions but no dimension labels, then NULL is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dimlabels(state.region)
dimlabels(attitude)
dimlabels(HairEyeColor)
</code></pre>

<hr>
<h2 id='dimlabels+26lt+3B-'>Add Elements to Vectors</h2><span id='topic+dimlabels+3C-'></span>

<h3>Description</h3>

<p><code>`dimlabels&lt;-`</code> adds elements to vectors as a side effect. The purpose of
the function is to replace <code>names(dimnames(x))</code> with a single function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimlabels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimlabels+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>array or any object with dimnames. The object may or may not already have
dimlabels.</p>
</td></tr>
<tr><td><code id="dimlabels+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>character vector of dimlabels to be added to <code>x</code>. If
<code>`dimlabels&lt;-`</code> is used on its own, then the length of <code>value</code> must
be the same as ndim. If <code>`dimlabels&lt;-`</code> is used in confunction with the subsetting
function <code>`[[&lt;-`</code> or <code>`[&lt;-`</code>, then the length of <code>values</code> should
be equal to the length of dimlabels after from the subsetting. This is the same
way <code>`names&lt;-`</code> works.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Like other similar functions (e.g., <code>`names&lt;-`</code> and <code>`[&lt;-`</code>),
it does not appear to have a return object. However, it technically does as a
side effect. The argument <code>x</code> will have been changed such that <code>value</code>
has been added as dimlabels. If a traditional return object is desired, and no side
effects, then it can be called like a traditional function:
obj2 &lt;- 'dimlabels&lt;-'(x = obj, value = dimlab).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(c(letters, NA), dim = c(3,3,3),
   dimnames = replicate(3, expr = 1:3, simplify = FALSE))
dimlabels(a) &lt;- c("first","second","third")
dimlabels(a)[[2]] &lt;- c("2nd")
dimlabels(a)[c(1,3)] &lt;- c("1st","3rd")
print(a)
</code></pre>

<hr>
<h2 id='e2l'>Environment to List</h2><span id='topic+e2l'></span>

<h3>Description</h3>

<p><code>e2l</code> converts an environment to a list. The function assumes you don't
want *all* objects in an environment and uses <code>pick</code> to determine which
objects you want included. If you want all objects in an environment, then use
<code>grab(x = objects(envir, all.names = TRUE), envir)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e2l(
  e = sys.frame(),
  val,
  pat = FALSE,
  not = FALSE,
  fixed = FALSE,
  sorted = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="e2l_+3A_e">e</code></td>
<td>
<p>environment to pull the objects from. Default is the global environment.</p>
</td></tr>
<tr><td><code id="e2l_+3A_val">val</code></td>
<td>
<p>character vector specifying which objects from <code>e</code> will be extracted.
If <code>pat</code> = FALSE (default), then <code>val</code> can have length &gt; 1, and exact
matching will be done via <code>is.element</code> (essentially <code>match</code>). If
<code>pat</code> = TRUE, then <code>val</code> has to be a character vector of length 1 and
partial matching will be done via <code>grepl</code> with the option of regular expressions
if <code>fixed</code> = FALSE (default).</p>
</td></tr>
<tr><td><code id="e2l_+3A_pat">pat</code></td>
<td>
<p>logical vector of length 1 specifying whether <code>val</code> should refer to
exact matching (FALSE) via <code>is.element</code> (essentially <code>match</code>) or partial
matching (TRUE) and/or use of regular expressions via <code>grepl</code>. See details
for a brief description of some common symbols and <code>help(regex)</code> for more.</p>
</td></tr>
<tr><td><code id="e2l_+3A_not">not</code></td>
<td>
<p>logical vector of length 1 specifying whether <code>val</code> indicates
values that should be retained (FALSE) or removed (TRUE).</p>
</td></tr>
<tr><td><code id="e2l_+3A_fixed">fixed</code></td>
<td>
<p>logical vector of length 1 specifying whether <code>val</code> refers to
values as is (TRUE) or a regular expression (FALSE). Only used if <code>pat</code> = TRUE.</p>
</td></tr>
<tr><td><code id="e2l_+3A_sorted">sorted</code></td>
<td>
<p>logical vector of length 1 specifying whether the objects should
be sorted alphanumerically. If FALSE, the objects are usually in the order they
were initially created, but not always (see <code>help(objects)</code>).</p>
</td></tr>
<tr><td><code id="e2l_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>e</code> is an environment.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with object contents from environment <code>e</code> with names as the
object names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model_1 &lt;- lm(v2frm(names(attitude)), data = attitude)
model_2 &lt;- lm(v2frm(names(mtcars)), data = mtcars)
model_3 &lt;- lm(v2frm(names(airquality)), data = airquality)
e2l(val = "model_", pat = TRUE)
</code></pre>

<hr>
<h2 id='fct2v'>Factor to (Atomic) Vector</h2><span id='topic+fct2v'></span>

<h3>Description</h3>

<p><code>fct2v</code> converts a factor to an (atomic) vector. It allows the user to specify
whether they want the factor to always return a character vector (<code>simplify = TRUE</code>),
simplified if possible (<code>simplify = FALSE</code>), or just return the integer codes
(<code>codes = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct2v(fct, simplify = TRUE, codes = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fct2v_+3A_fct">fct</code></td>
<td>
<p>factor.</p>
</td></tr>
<tr><td><code id="fct2v_+3A_simplify">simplify</code></td>
<td>
<p>logical vector of length 1 specifying whether R should attempt to
simplify <code>fct</code> to typeof simplier than character (e.g., logical, integer, double).
If FALSE, a character vector is always returned.</p>
</td></tr>
<tr><td><code id="fct2v_+3A_codes">codes</code></td>
<td>
<p>logical vector of length 1 specifying whether the integer codes of
<code>fct</code> should be returned. If <code>codes</code> = TRUE, then <code>simplify</code> is ignored.</p>
</td></tr>
<tr><td><code id="fct2v_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>fct</code> is a factor.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>simplify = TRUE</code>, <code>fct2v</code> uses <code>type.convert</code> to try to simplify
the factor. Note, missing values are assumed to be &quot;NA&quot; and decimals are assumed
to be &quot;.&quot;; however, &quot;L&quot; after a number is not interpreted as an integer specifier.
</p>


<h3>Value</h3>

<p>(atomic) vector of the same length as <code>fct</code>. If <code>codes</code> = TRUE,
then the returned vector is typeof integer containing the underlying factor codes.
If <code>codes</code> = FALSE and <code>simplify</code> = FALSE, then the returned vector is
typeof character containing the factor levels. If <code>codes</code> = FALSE, and
<code>simplify</code> = TRUE, then the returned vector is the simpliest typeof possible
without having to coerce any elements to NA. For example, if <code>fct</code> contains
all integer numerals (e.g., &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, etc), then it will be converted to an
integer vector. See examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fct2v(state.region)
fct2v(fct = factor(c("7.00001","8.54321","9.99999"))) # double
fct2v(fct = factor(c("7","8","9")), simplify = FALSE) # character
fct2v(fct = factor(c("7","8","9")), simplify = TRUE) # integer
fct2v(fct = factor(c("7","8","9")), codes = TRUE) # integer codes
fct2v(fct = factor(c("7L","8L","9L")),
   simplify = TRUE) # does not understand "L" for integers
</code></pre>

<hr>
<h2 id='grab'><code>grab</code> extracts the contents of objects in an environment based on their
object names as a character vector. The object contents are stored to a list
where the names are the object names.</h2><span id='topic+grab'></span>

<h3>Description</h3>

<p><code>grab</code> extracts the contents of objects in an environment based on their
object names as a character vector. The object contents are stored to a list
where the names are the object names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab(x, envir = sys.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grab_+3A_x">x</code></td>
<td>
<p>character vector providing the exact names of objects in the environment
<code>envir</code>.</p>
</td></tr>
<tr><td><code id="grab_+3A_envir">envir</code></td>
<td>
<p>environment to pull the objects from. Default is the global environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of objects with names <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grab(x = c("attitude","mtcars","airquality"))
grab(x = c("mean.default","mean.Date","mean.difftime"))
</code></pre>

<hr>
<h2 id='inbtw'>Elements Inbetween Values Within a (Atomic) Vector</h2><span id='topic+inbtw'></span>

<h3>Description</h3>

<p><code>inbtw</code> extracts all elements inbetween (by position) two specific elements
of a (atomic) vector. This can be useful when working with rownames and colnames
since <code>seq</code> does not work with names. Primary for character vectors but
can be used with other typeof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inbtw(x, from, to, left = TRUE, right = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inbtw_+3A_x">x</code></td>
<td>
<p>atomic vector.</p>
</td></tr>
<tr><td><code id="inbtw_+3A_from">from</code></td>
<td>
<p>vector of length 1 specifying the element to start with on the left.</p>
</td></tr>
<tr><td><code id="inbtw_+3A_to">to</code></td>
<td>
<p>vector of length 1 specifying the element to end with on the right.</p>
</td></tr>
<tr><td><code id="inbtw_+3A_left">left</code></td>
<td>
<p>logical vector of length 1 specifying whether the leftmost element,
<code>from</code>, should be included in the return object.</p>
</td></tr>
<tr><td><code id="inbtw_+3A_right">right</code></td>
<td>
<p>logical vector of length 1 specifying whether the rightmost element,
<code>to</code>, should be included in the return object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An error is returned if either <code>from</code> or <code>to</code> don't appear in <code>x</code>
or appear more than once in <code>x</code>.
</p>


<h3>Value</h3>

<p>vector of the same type as <code>x</code> that only includes elements in <code>x</code>
inbetween (by position) <code>from</code> and <code>to</code>, which may or may not include
<code>from</code> and <code>to</code> themselves, depending on <code>left</code> and <code>right</code>,
respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># character vector
row_names &lt;- inbtw(x = row.names(LifeCycleSavings), from = "China", to = "Peru")
LifeCycleSavings[row_names, ] # default use
row_names &lt;- inbtw(x = row.names(LifeCycleSavings), from = "China", to = "Peru",
   right = FALSE, left = FALSE)
LifeCycleSavings[row_names, ] # use with right and left arguments FALSE
try_expr(inbtw(x = row.names(LifeCycleSavings), from = "china",
   to = "peru")) # error due to `from` and `to` not appearing in `x`
try_expr(inbtw(x = rep.int(x = row.names(LifeCycleSavings), times = 2), from = "China",
   to = "Peru")) # error due to `from` and `to` appearing more than once in `x`
# numeric vector
vec &lt;- sample(x = 150:199, size = 50)
inbtw(x = vec, from = 150, to = 199)
# list vector (error)
lst &lt;- list(FALSE, 3L, 9.87, "abc", factor("lvl"))
try_expr(inbtw(x = lst, from = 3L, to = "abc")) # error because `lst` is a
   # list vector and not an atomic vector
</code></pre>

<hr>
<h2 id='is.avector'>Test for an Atomic Vector</h2><span id='topic+is.avector'></span>

<h3>Description</h3>

<p><code>is.avector</code> returns whether an object is an atomic vector with typeof
character, logical, integer, or double.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.avector(x, attr.ok = TRUE, fct.ok = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.avector_+3A_x">x</code></td>
<td>
<p>object whose structure is desired to be tested.</p>
</td></tr>
<tr><td><code id="is.avector_+3A_attr.ok">attr.ok</code></td>
<td>
<p>logical vector with length 1 specifying whether non-core attributes
are allowed in <code>x</code>. Core attributes are 1) &quot;names&quot;, 2) &quot;dim&quot;, 3) &quot;dimnames&quot;,
4) &quot;levels&quot;, and 5) &quot;class&quot;. Therefore, <code>attr.ok</code> refers to attributes *other*
than these 5.</p>
</td></tr>
<tr><td><code id="is.avector_+3A_fct.ok">fct.ok</code></td>
<td>
<p>logical vector with length 1 specifying whether factors are allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.avector</code> is simply a logical &quot;and&quot; of <code>is.atomic</code> and <code>is.vector</code>.
</p>


<h3>Value</h3>

<p>logical vector with length 1 specifying whether <code>x</code> is an atomic vector.
If <code>attr.ok</code> is TRUE then non-core attributes are allowed (e.g., &quot;value.labels&quot;).
If <code>fct.ok</code> is TRUE then factors are allowed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# normal use
is.avector(x = c(1,2,3))
is.avector(x = c("one" = 1, "two" = 2, "three" = 3)) # names are always okay
is.avector(x = array(c(1,2,3))) # returns false for arrays
is.avector(x = list(1,2,3)) # returns false for lists

# non-core attributes
x &lt;- structure(.Data = c(1,2,3), "names" = c("one","two","three"),
   "value.labels" = c("woman","man","non-binary"))
attributes(x)
is.avector(x)
is.avector(x, attr.ok = FALSE)

# factors
x &lt;- factor(c(1,2,3), labels = c("one","two","three"))
is.avector(x)
is.avector(x, fct.ok = FALSE)

</code></pre>

<hr>
<h2 id='is.cnumeric'>Test for Character Numbers</h2><span id='topic+is.cnumeric'></span>

<h3>Description</h3>

<p><code>is.cnumeric</code> returns whether an object is a character vector with all
number strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cnumeric(x, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.cnumeric_+3A_x">x</code></td>
<td>
<p>object whose structure is desired to be tested.</p>
</td></tr>
<tr><td><code id="is.cnumeric_+3A_warn">warn</code></td>
<td>
<p>logical vector with length 1 specifying whether warnings should be printed
due to coercing a character vector that is not all number strings (i.e., one reason
the return object could be 'FALSE').</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.cnumeric</code> is useful for ensuring that converting a character vector to
a numeric vector is safe (i.e., won't introduce NAs).
</p>


<h3>Value</h3>

<p>logical vector with length 1 specifying whether 'x' is a character vector
with all number strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.cnumeric(x = c("1","2","3")) # returns TRUE
is.cnumeric(x = c("1","number","3")) # returns FALSE
is.cnumeric(x = c("1","number","3"), warn = TRUE) # includes the warning
is.cnumeric(x = c(1,2,3)) # returns false because not a character vector
</code></pre>

<hr>
<h2 id='is.colnames'>Test for 'colnames'</h2><span id='topic+is.colnames'></span>

<h3>Description</h3>

<p><code>is.colnames</code> returns whether elements of a character vector are colnames of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.colnames(nm, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.colnames_+3A_nm">nm</code></td>
<td>
<p>character vector.</p>
</td></tr>
<tr><td><code id="is.colnames_+3A_x">x</code></td>
<td>
<p>object whose colnames are desired to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object does not have any colnames, then the function will return 'FALSE'
for each element of the character vector.
</p>


<h3>Value</h3>

<p>TRUE for every element of 'nm' that is a colname of x and FALSE otherwise.
The structure is a logical vector with length = length('nm') and names = 'nm'.
See details for special cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mtcars")
is.colnames(x = as.matrix(mtcars), nm = c("MPG","mpg"))
</code></pre>

<hr>
<h2 id='is.Date'>Test for a Date object</h2><span id='topic+is.Date'></span>

<h3>Description</h3>

<p><code>is.Date</code> returns whether an object is a Date object (aka has class = &quot;Date&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Date(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.Date_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE is <code>x</code> has class &quot;Date&quot; and FALSE if <code>x</code> does not have class &quot;Date&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date &lt;- as.Date("2021-05-24", format = "%Y-%m-%d") # as.Date.character
is.Date(date)
class(date) &lt;- append(class(date), "extra_class")
is.Date(date) # classes other than Date are allowed
is.Date(list(date)) # returns FALSE
</code></pre>

<hr>
<h2 id='is.dummy'>Test for a Dummy Variable</h2><span id='topic+is.dummy'></span>

<h3>Description</h3>

<p><code>is.dummy</code> returns whether a numeric vector is a dummy variable, meaning
all elements one of two observed values (or missing values). Depending on the argument
<code>any.values</code>, the two observed values are required to be 0 and 1 or any values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dummy(x, any.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.dummy_+3A_x">x</code></td>
<td>
<p>atomic vector.</p>
</td></tr>
<tr><td><code id="is.dummy_+3A_any.values">any.values</code></td>
<td>
<p>logical vector of length 1 specifying whether the two observed values
need to be 0 or 1 (FALSE) or can be any values (TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if 'x' is a dummy variable; FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# any.values = FALSE (default)
is.dummy(mtcars$"am") # TRUE
is.dummy(c(mtcars$"am", NA, NaN)) # works with missing values
is.dummy(c(as.integer(mtcars$"am"), NA, NaN)) # works with typeof integer
x &lt;- ifelse(mtcars$"am" == 1, yes = 2, no = 1)
is.dummy(x) # FALSE

# any.values = TRUE
is.dummy(x, any.values = TRUE) # TRUE
is.dummy(c(x, NA), any.values = TRUE) # work with missing values
is.dummy(c(as.character(x), NA), any.values = TRUE) # work with typeof character
is.dummy(mtcars$"gear") # FALSE for nominal variables with more than 2 levels

</code></pre>

<hr>
<h2 id='is.empty'>Test for Empty Characters</h2><span id='topic+is.empty'></span>

<h3>Description</h3>

<p><code>is.empty</code> returns whether elements of a character vector are empty (i.e., &quot;&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.empty(x, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.empty_+3A_x">x</code></td>
<td>
<p>character vector.</p>
</td></tr>
<tr><td><code id="is.empty_+3A_trim">trim</code></td>
<td>
<p>logical vector with a single element specifying whether white spaces
should be trimmed from the character vector. See <code>trimws</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE for every element of 'x' that is empty (i.e., &quot;&quot;) and FALSE otherwise.
The structure is a logical vector with length = length('x') and names = names('x').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c("1", " ", "")
is.empty(v)
</code></pre>

<hr>
<h2 id='is.names'>Test for 'names'</h2><span id='topic+is.names'></span>

<h3>Description</h3>

<p><code>is.names</code> returns whether elements of a character vector are names of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.names(nm, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.names_+3A_nm">nm</code></td>
<td>
<p>character vector.</p>
</td></tr>
<tr><td><code id="is.names_+3A_x">x</code></td>
<td>
<p>object whose names are desired to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object does not have any names, then the function will return 'FALSE'
for each element 'nm'.
</p>


<h3>Value</h3>

<p>TRUE for every element of 'nm' that is a name of 'x' and FALSE otherwise.
The structure is a logical vector with length = length('nm') and names = 'nm'.
See details for special cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- setNames(object = letters, nm = LETTERS)
is.names(x = v, nm = c("A","a"))
data("mtcars")
is.names(x = mtcars, nm = c("MPG","mpg"))
</code></pre>

<hr>
<h2 id='is.POSIXct'>Test for a POSIXct object</h2><span id='topic+is.POSIXct'></span>

<h3>Description</h3>

<p><code>is.POSIXct</code> returns whether an object is a POSIXct object (aka has class = &quot;POSIXct&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.POSIXct(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.POSIXct_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE is <code>x</code> has class &quot;POSIXct&quot; and FALSE if <code>x</code> does not have class &quot;POSIXct&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- as.POSIXlt("2021-05-24 21:49:11", tz = "America/New_York",
   format = "%Y-%m-%d %H:%M:%OS") # as.POSIXlt.character
time &lt;- as.POSIXct(tmp) # as.POSIXct.POSIXlt
is.POSIXct(time)
class(time) &lt;- append(class(time), "extra_class")
is.POSIXct(time) # classes other than POSIXct are allowed
is.POSIXct(list(time)) # returns FALSE
</code></pre>

<hr>
<h2 id='is.POSIXlt'>Test for a POSIXlt object</h2><span id='topic+is.POSIXlt'></span>

<h3>Description</h3>

<p><code>is.POSIXlt</code> returns whether an object is a POSIXlt object (aka has class = &quot;POSIXlt&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.POSIXlt(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.POSIXlt_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE is <code>x</code> has class &quot;POSIXlt&quot; and FALSE if <code>x</code> does not have class &quot;POSIXlt&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time &lt;- as.POSIXlt("2021-05-24 21:49:11", tz = "America/New_York",
   format = "%Y-%m-%d %H:%M:%OS") # as.POSIXlt.character
is.POSIXlt(time)
class(time) &lt;- append(class(time), "extra_class")
is.POSIXlt(time) # classes other than POSIXlt are allowed
is.POSIXlt(list(time)) # returns FALSE
</code></pre>

<hr>
<h2 id='is.row.names'>Test for 'row.names'</h2><span id='topic+is.row.names'></span>

<h3>Description</h3>

<p><code>is.row.names</code> returns whether elements of a character vector are row.names of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.row.names(nm, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.row.names_+3A_nm">nm</code></td>
<td>
<p>character vector.</p>
</td></tr>
<tr><td><code id="is.row.names_+3A_x">x</code></td>
<td>
<p>object whose row.names are desired to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object does not have any row.names, then the function will return 'FALSE'
for each element of the character vector. As a reminder, <code>row.names</code> does not
respond to a manually added &quot;row.names&quot; attribute (e.g., to a vector). If this is
tried, then <code>is.row.names</code> will return 'FALSE' for each element 'nm'.
</p>


<h3>Value</h3>

<p>TRUE for every element of 'nm' that is a row.name of x and FALSE otherwise.
The structure is a logical vector with length = length('nm') and names = 'nm'.
See details for special cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mtcars")
is.row.names(x = mtcars, nm = c("Mazda RX4","mazda RX4"))
</code></pre>

<hr>
<h2 id='is.rownames'>Test for 'rownames'</h2><span id='topic+is.rownames'></span>

<h3>Description</h3>

<p><code>is.rownames</code> returns whether elements of a character vector are rownames of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rownames(nm, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.rownames_+3A_nm">nm</code></td>
<td>
<p>character vector.</p>
</td></tr>
<tr><td><code id="is.rownames_+3A_x">x</code></td>
<td>
<p>object whose rownames are desired to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object does not have any rownames, then the function will return 'FALSE'
for each element of the character vector.
</p>


<h3>Value</h3>

<p>TRUE for every element of 'nm' that is a rowname of x and FALSE otherwise.
The structure is a logical vector with length = length('nm') and names = 'nm'.
See details for special cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mtcars")
is.rownames(x = as.matrix(mtcars), nm = c("Mazda RX4","mazda RX4"))
</code></pre>

<hr>
<h2 id='is.whole'>Test for Whole Numbers</h2><span id='topic+is.whole'></span>

<h3>Description</h3>

<p><code>is.whole</code> returns whether elements of a numeric vector are whole numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.whole(x, tol = .Machine[["double.eps"]])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.whole_+3A_x">x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="is.whole_+3A_tol">tol</code></td>
<td>
<p>tolerance allowed for double floating point numbers. This is always
a positive number. The default is based on the numerical characteristics of
the machine that R is running on. See <code>.Machine</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE for every element of 'x' that is a whole number and FALSE otherwise.
The structure is a logical vector with length = length('x') and names = names('x').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- c(1.0, 1L, 1.1)
is.whole(v)
</code></pre>

<hr>
<h2 id='Join'>Join (or Merge) a List of Data-frames</h2><span id='topic+Join'></span>

<h3>Description</h3>

<p><code>Join</code> merges a list of data.frames into a single data.frame. It is a
looped version of <code>plyr::join</code> that allows you to merge more than 2
data.frames in the same function call. It is different from <code>plyr::join_all</code>
because it allows you to join by the row.names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Join(
  data.list,
  by,
  type = "full",
  match = "all",
  rownamesAsColumn = FALSE,
  rtn.rownames.nm = "row_names"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Join_+3A_data.list">data.list</code></td>
<td>
<p>list of data.frames of data.</p>
</td></tr>
<tr><td><code id="Join_+3A_by">by</code></td>
<td>
<p>character vector specifying what colnames to merge <code>data.list</code> by.
It can include &quot;0&quot; which specifies the rownames of <code>data.list</code>. If you are merging
by rownames, then you can only merge by rownames and not other columns as well.
This is because rownames, by definition, have all unique values. Note, it is
assumed that no data.frame in <code>data.list</code> has a colname of &quot;0&quot;, otherwise
unexpected results are possible. If <code>by</code> is NULL, then all common columns
will be used for merging. This is not recommended as it can result in <code>Join</code>
merging different data.frames in <code>data.list</code> by different columns.</p>
</td></tr>
<tr><td><code id="Join_+3A_type">type</code></td>
<td>
<p>character vector of length 1 specifying the type of merge. Options
are the following: 1. &quot;full&quot; = all rows from any of the data.frames in
<code>data.list</code>, 2. &quot;left&quot; = only rows from the first data.frame in
<code>data.list</code>: <code>data.list[[1L]]</code>), 3. &quot;right&quot; = only rows from the last
data.frame in <code>data.list</code>: <code>data.list[[length(data.list)]]</code>,
4. &quot;inner&quot; = only rows present in each and every of the data.frames in
<code>data.list</code>. See <code><a href="plyr.html#topic+join">join</a></code>.</p>
</td></tr>
<tr><td><code id="Join_+3A_match">match</code></td>
<td>
<p>character vector of length 1 specifying whether merged elements should
be repeated in each row of the return object when duplicate values exist on the
<code>by</code> columns. If &quot;all&quot;, the merged elements will only appear in every row of the return object
with repeated values. If &quot;first&quot;, only the merged elements will only appear in the
first row of the return object with subsequent rows containing NAs.
See <code><a href="plyr.html#topic+join">join</a></code>.</p>
</td></tr>
<tr><td><code id="Join_+3A_rownamesascolumn">rownamesAsColumn</code></td>
<td>
<p>logical vector of length 1 specifying whether the original
rownames in <code>data.list</code> should be a column in the return object. If TRUE,
the rownames are a column and the returned data.frame has default row.names 1:nrow.
If FALSE, the returned data.frame has rownames from the merging.</p>
</td></tr>
<tr><td><code id="Join_+3A_rtn.rownames.nm">rtn.rownames.nm</code></td>
<td>
<p>character vector of length 1 specifying what the names of the rownames
column should be in the return object. The <code>rtn.rownames.nm</code> argument is only
used if <code>rownamesAsColumn</code> = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Join</code> is a polished rendition of <code>Reduce(f = plyr::join, x = data.list)</code>.
A future version of the function might allow for the <code>init</code> and <code>right</code>
arguments from <code>Reduce</code>.
</p>


<h3>Value</h3>

<p>data.frame of all uniquely colnamed columns from <code>data.list</code> with
the rows included specified by <code>type</code> and rownames specified by <code>rownamesAsColumn</code>.
Similar to <code>plyr::join</code>, <code>Join</code> returns the rows in the same order as
they appeared in <code>data.list</code>.
</p>


<h3>See Also</h3>

<p><code><a href="plyr.html#topic+join_all">join_all</a></code>
<code><a href="plyr.html#topic+join">join</a></code>
<code><a href="base.html#topic+merge">merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# by column
mtcars1 &lt;- mtcars
mtcars1$"id" &lt;- row.names(mtcars)
mtcars2 &lt;- data.frame("id" = mtcars1$"id", "forward" = 1:32)
mtcars3 &lt;- data.frame("id" = mtcars1$"id", "backward" = 32:1)
mtcars_list &lt;- list(mtcars1, mtcars2, mtcars3)
by_column &lt;- Join(data.list = mtcars_list, by = "id")
by_column2 &lt;- Join(data.list = mtcars_list, by = "id", rownamesAsColumn = TRUE)
by_column3 &lt;- Join(data.list = mtcars_list, by = NULL)

# by rownames
mtcars1 &lt;- mtcars
mtcars2 &lt;- data.frame("forward" = 1:32, row.names = row.names(mtcars))
mtcars3 &lt;- data.frame("backward" = 32:1, row.names = row.names(mtcars))
by_rownm &lt;- Join(data.list = list(mtcars1, mtcars2, mtcars3), by = "0")
by_rownm2 &lt;- Join(data.list = list(mtcars1, mtcars2, mtcars3), by = "0",
   rownamesAsColumn = TRUE)
identical(x = by_column[names(by_column) != "id"],
   y = by_rownm) # same as converting rownames to a column in the data
identical(x = by_column2[names(by_column2) != "id"],
   y = by_rownm2) # same as converting rownames to a column in the data

# inserted NAs (by columns)
mtcars1 &lt;- mtcars[1:4]
mtcars2 &lt;- setNames(obj = as.data.frame(scale(x = mtcars1[-1],
   center = TRUE, scale = FALSE)), nm = paste0(names(mtcars1[-1]), "_c"))
mtcars3 &lt;- setNames(obj = as.data.frame(scale(x = mtcars1[-1],
   center = FALSE, scale = TRUE)), nm = paste0(names(mtcars1[-1]), "_s"))
tmp &lt;- lapply(X = list(mtcars1, mtcars2, mtcars3), FUN = function(dat)
   dat[sample(x = row.names(dat), size = 10), ])
mtcars_list &lt;- lapply(X = tmp, FUN = reshape::namerows)
by_column_NA &lt;- Join(data.list = mtcars_list, by = "id") # join by row.names
by_column_NA2 &lt;- Join(data.list = mtcars_list, by = "id", rownamesAsColumn = TRUE)
identical(x = row.names(by_column_NA), # rownames from any data.frame are retained
   y = Reduce(f = union, x = lapply(X = mtcars_list, FUN = row.names)))

# inserted NAs (by rownames)
mtcars1 &lt;- mtcars[1:4]
mtcars2 &lt;- setNames(obj = as.data.frame(scale(x = mtcars1, center = TRUE, scale = FALSE)),
   nm = paste0(names(mtcars1), "_c"))
mtcars3 &lt;- setNames(obj = as.data.frame(scale(x = mtcars1, center = FALSE, scale = TRUE)),
   nm = paste0(names(mtcars1), "_s"))
mtcars_list &lt;- lapply(X = list(mtcars1, mtcars2, mtcars3), FUN = function(dat)
   dat[sample(x = row.names(dat), size = 10), ])
by_rownm_NA &lt;- Join(data.list = mtcars_list, by = "0") # join by row.names
by_rownm_NA2 &lt;- Join(data.list = mtcars_list, by = "0", rownamesAsColumn = TRUE)
identical(x = row.names(by_rownm_NA), # rownames from any data.frame are retained
   y = Reduce(f = union, x = lapply(X = mtcars_list, FUN = row.names)))

# types of joins
Join(data.list = mtcars_list, by = "0", type = "left") # only rows included in mtcars1
Join(data.list = mtcars_list, by = "0", type = "right") # only rows included in mtcars3
Join(data.list = mtcars_list, by = "0", type = "inner") # only rows included in
   # all 3 data.frames (might be empty due to random chance from sample() call)

# errors returned
tmp &lt;- str2str::try_expr(
   Join(data.list = list(mtcars, as.matrix(mtcars), as.matrix(mtcars)))
)
print(tmp[["error"]]) # "The elements with the following positions in
   # `data.list` are not data.frames: 2 , 3"
tmp &lt;- str2str::try_expr(
   Join(data.list = replicate(n = 3, mtcars, simplify = FALSE), by = 0)
)
print(tmp[["error"]]) # "Assertion on 'by' failed: Must be of type
   # 'character' (or 'NULL'), not 'double'."
tmp &lt;- str2str::try_expr(
   Join(data.list = replicate(n = 3, mtcars, simplify = FALSE), by = c("0","mpg"))
)
print(tmp[["error"]]) # "If '0' is a value in `by`, then it must be the
   # only value and `by` must be length 1."
tmp &lt;- str2str::try_expr(
   Join(data.list = list(attitude, attitude, mtcars), by = "mpg")
)
print(tmp[["error"]]) # "The data.frames associated with the following positions in
   # `data.list` do not contain the `by` columns: 1 , 2"

</code></pre>

<hr>
<h2 id='la2a'>List of (3D+) Arrays to (3D+) Array</h2><span id='topic+la2a'></span>

<h3>Description</h3>

<p><code>la2a</code> converts a list of (3D+) arrays to a one dimension larger (3D+)
array where the list dimension becomes the additional dimension of the array.
<code>la2a</code> is a simple wrapper function for <code>abind::abind</code>. If you have
a list of matrices, then use <code>lm2a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>la2a(la, dim.order = 1:(ndim(la[[1]]) + 1L), dimlab.list = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="la2a_+3A_la">la</code></td>
<td>
<p>list of 3D+ arrays which each have the same dimensions.</p>
</td></tr>
<tr><td><code id="la2a_+3A_dim.order">dim.order</code></td>
<td>
<p>integer vector of length = <code>ndim(la[[1]]) + 1L</code> specifying
the order of dimensions for the returned array. The default is <code>1:(ndim(la[[1]]) + 1L)</code>
which means the arrays within <code>la</code> maintain their dimensions and the list
dimension is appended as the last dimension.</p>
</td></tr>
<tr><td><code id="la2a_+3A_dimlab.list">dimlab.list</code></td>
<td>
<p>character vector of length 1 specifying the dimlabel for
the list dimension.</p>
</td></tr>
<tr><td><code id="la2a_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>la</code> is a list of 3D+ arrays.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D+ array where the list elements of <code>la</code> is now a dimension. The
order of the dimensions is determined by the argument <code>dim.order</code>. The
dimnames of the returned array is determined by the dimnames in <code>la[[1]]</code>
and <code>names(la)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>la &lt;- list("one" = HairEyeColor, "two" = HairEyeColor*2, "three" = HairEyeColor*3)
la2a(la) # default
la2a(la, dimlab.list = "Multiple")
la2a(la, dim.order = c(4,3,1,2))
la2a(la, dim.order = c(4,3,1,2), dimlab.list = "Multiple")
</code></pre>

<hr>
<h2 id='laynames'>Names of the Layers (the Third Dimension)</h2><span id='topic+laynames'></span>

<h3>Description</h3>

<p><code>laynames</code> returns the names of the layers - the third dimension - of an array.
If the object does not have a third dimension (e.g., matrix), then the function
will return NULL. If the object does not have any dimensions
(e.g., atomic vector), then the function will also return NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laynames(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="laynames_+3A_x">x</code></td>
<td>
<p>array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R does not have standard terminology for the third dimension. There are several common terms
people use including &quot;height&quot; and &quot;page&quot;. I personally prefer &quot;layer&quot; as it makes sense
whether the user visualizes the third dimension as going into/ontop a desk or into/ontop a wall.
</p>


<h3>Value</h3>

<p>Names of the layers (the third dimension) of <code>x</code>. The structure is
a character vector with length = <code>nlay(x)</code>. See details for special cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>laynames(HairEyeColor)
a &lt;- array(data = NA, dim = c(6,7,8,9))
laynames(a)
laynames(c(1,2,3))
</code></pre>

<hr>
<h2 id='ld2a'>List of Data-Frames to a 3D Array</h2><span id='topic+ld2a'></span>

<h3>Description</h3>

<p><code>ld2a</code> converts a list of data.frames to a 3D array. The data.frames must
have the same dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ld2a(
  ld,
  dim.order = c(1, 2, 3),
  dimlab.list = NULL,
  fct = "chr",
  chr = "chr",
  lgl = "int",
  order.lvl = "alphanum",
  decreasing = FALSE,
  na.lvl = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ld2a_+3A_ld">ld</code></td>
<td>
<p>list of data.frames that all have the same dimensions.</p>
</td></tr>
<tr><td><code id="ld2a_+3A_dim.order">dim.order</code></td>
<td>
<p>integer vector of length 3 specifying the order of dimensions for
the returned array. The default is <code>c(1,2,3)</code> which means the rows of the
data.frames in <code>ld</code> is the first dimension (i.e., rows), the columns of the
data.frames in <code>ld</code> is the second dimension (i.e., columns), and the list
elements of <code>ld</code> is the third dimension (i.e., layers).</p>
</td></tr>
<tr><td><code id="ld2a_+3A_dimlab.list">dimlab.list</code></td>
<td>
<p>character vector of length 1 specifying the dimlabel for
the list dimension.</p>
</td></tr>
<tr><td><code id="ld2a_+3A_fct">fct</code></td>
<td>
<p>character vector of length 1 specifying what factors should be converted
to. There are three options: 1) &quot;chr&quot; for converting to character vectors (i.e.,
factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e., factor codes),
or 3) &quot;fct&quot; for keeping the factor as is without any changes.</p>
</td></tr>
<tr><td><code id="ld2a_+3A_chr">chr</code></td>
<td>
<p>character vector of length 1 specifying what character vectors should
be converted to. There are three options: 1) &quot;fct&quot; for converting to factors (i.e.,
elements will be factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e.,
factor codes after first converting to a factor), or 3) &quot;chr&quot; for keeping the
character vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="ld2a_+3A_lgl">lgl</code></td>
<td>
<p>character vector of length 1 specifying what logical vectors should
be converted to. There are four options: 1) &quot;fct&quot; for converting to factors (i.e.,
&quot;TRUE&quot; and &quot;FALSE&quot; will be factor labels), 2) &quot;chr&quot; for converting to character
vectors (i.e., elements will be &quot;TRUE&quot; and &quot;FALSE&quot;), 3) &quot;int&quot; for converting to
integer vectors (i.e., TRUE = 1; FALSE = 0), and 4) &quot;lgl&quot; for keeping the logical
vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="ld2a_+3A_order.lvl">order.lvl</code></td>
<td>
<p>character vector of length 1 specifying how you want to order
the levels of the factor. The options are &quot;alphanum&quot;, which sorts the levels
alphanumerically (with NA last); &quot;position&quot;, which sorts the levels by the position
the level first appears; &quot;frequency&quot;, which sorts the levels by their frequency.
If any frequencies are tied, then the ties are sorted alphanumerically (with NA last).</p>
</td></tr>
<tr><td><code id="ld2a_+3A_decreasing">decreasing</code></td>
<td>
<p>logical vector of length 1 specifying whether the ordering of the
levels should be decreasing (TRUE) rather than increasing (FALSE).</p>
</td></tr>
<tr><td><code id="ld2a_+3A_na.lvl">na.lvl</code></td>
<td>
<p>logical vector of length 1 specifying if NA should be considered a level.</p>
</td></tr>
<tr><td><code id="ld2a_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>ld</code> is a list of data.frames.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the columns of the data.frames in <code>ld</code> are not all the same typeof, then
the return object is coerced to the most complex type of any data.frame column (e.g.,
character &gt; double &gt; integer &gt; logical). See <code>unlist</code> for details about
the hierarchy of object types.
</p>


<h3>Value</h3>

<p>3D array with all the elements from <code>ld</code> organized into dimensions
specified by <code>dim.order</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ld &lt;- list("first" = BOD, "second" = BOD*2, "third" = BOD*3)
ld2a(ld)
ld &lt;- list("cars" = cars, "mtcars" = mtcars)
try_expr(ld2a(ld)) # error
</code></pre>

<hr>
<h2 id='ld2d'>List of Data-Frames to Data-Frame</h2><span id='topic+ld2d'></span>

<h3>Description</h3>

<p><code>ld2d</code> converts a list of data.frames to a data.frame. The function is
primarily for rbinding a list of data.frames (<code>along</code> = 1). An option to
cbind the list of data.frames is included (<code>along</code> = 2), but is just a call to
<code>data.frame(ld, stringsAsFactors = stringsAsFactors, check.names = check.names)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ld2d(
  ld,
  along = 1,
  fill = FALSE,
  rtn.listnames.nm = "list_names",
  rtn.rownames.nm = "row_names",
  stringsAsFactors = FALSE,
  check.names = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ld2d_+3A_ld">ld</code></td>
<td>
<p>list of data.frames.</p>
</td></tr>
<tr><td><code id="ld2d_+3A_along">along</code></td>
<td>
<p>integer vector of length 1 specifying which dimension the data.frames
from <code>ld</code> should be binded along: 1 is for rows and 2 is for columns.</p>
</td></tr>
<tr><td><code id="ld2d_+3A_fill">fill</code></td>
<td>
<p>logical vector of length 1 specifying whether to fill in missing values
for any data.frames from <code>ld</code> that do not have all the columns. At this time,
<code>fill</code> is only available for rbinding and only used if <code>along</code> = 1.</p>
</td></tr>
<tr><td><code id="ld2d_+3A_rtn.listnames.nm">rtn.listnames.nm</code></td>
<td>
<p>character of length 1 specifying what the name of the
column containing the names/positions of <code>ld</code> should be in the returned
data.frame. If NULL, then no column is created for the names/positions of <code>ld</code>
in the returned data.frame.</p>
</td></tr>
<tr><td><code id="ld2d_+3A_rtn.rownames.nm">rtn.rownames.nm</code></td>
<td>
<p>character of length 1 specifying what the name of the
column containing the rownames of <code>ld</code>'s data.frames should be in the returned
data.frame. If NULL, then no column is created for the rownames of <code>ld</code>'s
data.frames in the returned data.frame.</p>
</td></tr>
<tr><td><code id="ld2d_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical vector of length 1 specifying whether character columns
from <code>ld</code> should be converted to factors. Only available and used if <code>fill</code>
= FALSE.</p>
</td></tr>
<tr><td><code id="ld2d_+3A_check.names">check.names</code></td>
<td>
<p>logical vector of length 1 specifying whether the colnames
of the returned data.frame should be checked for duplicates and made unique.
Only used if for cbinding with <code>along</code> = 2.</p>
</td></tr>
<tr><td><code id="ld2d_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>ld</code> is a list of data.frames.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the rows (if <code>along</code> = 1) or columns (if <code>along</code>
= 2) of <code>ld</code> binded together.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># without listnames and default rownames
ld &lt;- list(BOD*1, BOD*2, BOD*3)
ld2d(ld)
# with listnames and default rownames
names(ld) &lt;- LETTERS[1:3]
ld2d(ld)
# without listnames and custom rownames
ld &lt;- lapply(unname(ld), FUN = `row.names&lt;-`, letters[1:6])
ld2d(ld)
# with listnames and custom rownames
ld &lt;- setNames(ld, LETTERS[1:3])
ld2d(ld)
# can handle same named columns in different positions
ld &lt;- list(BOD*1, rev(BOD*2), rev(BOD*3))
ld2d(ld)
# can handle some columns being absent with fill = TRUE
ld[[2]]$"demand" &lt;- NULL
try_expr(ld2d(ld, fill = FALSE)) # error
ld2d(ld, fill = TRUE) # NAs added
# along = 2 for cbinding
ld2d(ld, along = 2) # does not check/rename for double colnames
ld2d(ld, along = 2, check.names = TRUE) # makes unique colnames
ld2d(setNames(ld, nm = c("One","Two","Three")), along = 2,
   check.names = TRUE) # does not add prefixes from list names
</code></pre>

<hr>
<h2 id='ld2v'>List of Data-Frames to (Atomic) Vector</h2><span id='topic+ld2v'></span>

<h3>Description</h3>

<p><code>ld2v</code> converts a list of data.frames to a (atomic) vector. This function is
a combination of <code>d2v</code> and <code>lv2v</code>. This function can be useful in
conjunction with the <code>boot::boot</code> function when wanting to generate a
<code>statistic</code> function that returns an atomic vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ld2v(
  ld,
  along = 2,
  use.listnames = TRUE,
  use.dimnames = TRUE,
  sep = "_",
  fct = "chr",
  chr = "chr",
  lgl = "int",
  order.lvl = "alphanum",
  decreasing = FALSE,
  na.lvl = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ld2v_+3A_ld">ld</code></td>
<td>
<p>list of data.frames. They do NOT have to have the same dimensions.</p>
</td></tr>
<tr><td><code id="ld2v_+3A_along">along</code></td>
<td>
<p>numeric vector of length one that is equal to either 1 or 2.
1 means that each data.frame in <code>ld</code> is split along rows (i.e., dimension 1)
and then concatenated. 2 means that each data.frame in <code>ld</code> is split along columns
(i.e., dimension 2) and then concatenated.</p>
</td></tr>
<tr><td><code id="ld2v_+3A_use.listnames">use.listnames</code></td>
<td>
<p>logical vector of length 1 specifying whether the returned
vector should have names based on the list the element came from. If <code>ld</code>
does not have names, <code>use.listnames</code> = TRUE will have the list positions
serve as the list names (e.g., &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, etc.)</p>
</td></tr>
<tr><td><code id="ld2v_+3A_use.dimnames">use.dimnames</code></td>
<td>
<p>logical vector of length 1 specifying whether the returned
vector should have names based on the dimnames of the data.frame the element came from.
If a data.frame within <code>ld</code> does not have dimnames, <code>use.dimnames</code> = TRUE
will have the dimension positions serve as the dimnames (e.g., &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, etc.)</p>
</td></tr>
<tr><td><code id="ld2v_+3A_sep">sep</code></td>
<td>
<p>character vector of length 1 specifying the string used to separate
the listnames and dimnames from each other when creating the names of the returned
vector.</p>
</td></tr>
<tr><td><code id="ld2v_+3A_fct">fct</code></td>
<td>
<p>character vector of length 1 specifying what factors should be converted
to. There are three options: 1) &quot;chr&quot; for converting to character vectors (i.e.,
factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e., factor codes),
or 3) &quot;fct&quot; for keeping the factor as is without any changes.</p>
</td></tr>
<tr><td><code id="ld2v_+3A_chr">chr</code></td>
<td>
<p>character vector of length 1 specifying what character vectors should
be converted to. There are three options: 1) &quot;fct&quot; for converting to factors (i.e.,
elements will be factor labels), 2) &quot;int&quot; for converting to integer vectors (i.e.,
factor codes after first converting to a factor), or 3) &quot;chr&quot; for keeping the
character vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="ld2v_+3A_lgl">lgl</code></td>
<td>
<p>character vector of length 1 specifying what logical vectors should
be converted to. There are four options: 1) &quot;fct&quot; for converting to factors (i.e.,
&quot;TRUE&quot; and &quot;FALSE&quot; will be factor labels), 2) &quot;chr&quot; for converting to character
vectors (i.e., elements will be &quot;TRUE&quot; and &quot;FALSE&quot;), 3) &quot;int&quot; for converting to
integer vectors (i.e., TRUE = 1; FALSE = 0), and 4) &quot;lgl&quot; for keeping the logical
vectors as is without any changes.</p>
</td></tr>
<tr><td><code id="ld2v_+3A_order.lvl">order.lvl</code></td>
<td>
<p>character vector of length 1 specifying how you want to order
the levels of the factor. The options are &quot;alphanum&quot;, which sorts the levels
alphanumerically (with NA last); &quot;position&quot;, which sorts the levels by the position
the level first appears; &quot;frequency&quot;, which sorts the levels by their frequency.
If any frequencies are tied, then the ties are sorted alphanumerically (with NA last).</p>
</td></tr>
<tr><td><code id="ld2v_+3A_decreasing">decreasing</code></td>
<td>
<p>logical vector of length 1 specifying whether the ordering of the
levels should be decreasing (TRUE) rather than increasing (FALSE).</p>
</td></tr>
<tr><td><code id="ld2v_+3A_na.lvl">na.lvl</code></td>
<td>
<p>logical vector of length 1 specifying if NA should be considered a level.</p>
</td></tr>
<tr><td><code id="ld2v_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>ld</code> is a list of data.frames.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>use.listnames</code> and <code>use.dimnames</code> are both TRUE (default), the returned
vector elements the following naming scheme: &quot;[listname][sep][rowname][sep][colname]&quot;.
</p>
<p>If the columns of the data.frames in <code>ld</code> are not all the same typeof, then
the return object is coerced to the most complex type of any data.frame column (e.g.,
character &gt; double &gt; integer &gt; logical). See <code>unlist</code> for details about
the hierarchy of object types.
</p>


<h3>Value</h3>

<p>(atomic) vector with an element for each element from <code>ld</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ld &lt;- list("cars" = cars, "mtcars" = mtcars)
# use.listnames = TRUE &amp; use.dimnames = TRUE
ld2v(ld) # the first part of the name is the list names followed by the dimnames
# use.listnames = FALSE &amp; use.dimnames = TRUE
ld2v(ld, use.listnames = FALSE) # only dimnames used,
   # which can result in repeat names
# use.listnames = TRUE &amp; use.dimnames = FALSE
ld2v(ld, use.dimnames = FALSE) # listnames and vector position without any
   # reference to matrix dimensions
# use.listnames = FALSE &amp; use.dimnames = FALSE
ld2v(ld, use.listnames = FALSE, use.dimnames = FALSE) # no names at all
# when list does not have names
ld &lt;- replicate(n = 3, expr = attitude, simplify = FALSE)
ld2v(ld) # the first digit of the names is the list position and
   # the subsequent digits are the matrix dimnames
ld2v(ld, use.listnames = FALSE) # only dimnames used,
   # which can result in repeat names
</code></pre>

<hr>
<h2 id='lm2a'>List of Matrices to 3D Array</h2><span id='topic+lm2a'></span>

<h3>Description</h3>

<p><code>lm2a</code> converts a list of matrices to a 3D array where the list dimension
becomes the third dimension of the array (layers). <code>lm2a</code> is a simple
wrapper function for <code>abind::abind</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm2a(lm, dim.order = c(1, 2, 3), dimlab.list = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm2a_+3A_lm">lm</code></td>
<td>
<p>list of matrices which each have the same dimensions.</p>
</td></tr>
<tr><td><code id="lm2a_+3A_dim.order">dim.order</code></td>
<td>
<p>integer vector of length 3 specifying the order of dimensions for
the returned array. The default is <code>c(1,2,3)</code> which means the rows of the
matrices in <code>lm</code> is the first dimension (i.e., rows), the columns of the
matrices in <code>lm</code> is the second dimension (i.e., columns), and the list
elements of <code>lm</code> is the third dimension (i.e., layers).</p>
</td></tr>
<tr><td><code id="lm2a_+3A_dimlab.list">dimlab.list</code></td>
<td>
<p>character vector of length 1 specifying the dimlabel for
the list dimension.</p>
</td></tr>
<tr><td><code id="lm2a_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>lm</code> is a list of matrices.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D array where the list elements of <code>lm</code> is now a dimension. The
order of the dimensions is determined by the argument <code>dim.order</code> with dimnames
specified by names(<code>lm</code>). The dimnames of the returned array is determined
by the dimnames in <code>lm[[1]]</code> and <code>names(lm)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lm &lt;- asplit(HairEyeColor, MARGIN = 3L)
lm2a(lm) # default
lm2a(lm, dimlab.list = "Sex")
lm2a(lm, dim.order = c(3,1,2))
lm2a(lm, dim.order = c(3,1,2), dimlab.list = "Sex")
</code></pre>

<hr>
<h2 id='lm2d'>List of Matrices to Data-Frame</h2><span id='topic+lm2d'></span>

<h3>Description</h3>

<p><code>lm2d</code> converts a list of matrices to a data.frame. The function is
primarily for rbinding a list of matrices (<code>along</code> = 1). An option to
cbind the list of matrices is included (<code>along</code> = 2), but is just a call to
<code>data.frame(lapply(lm, m2d), stringsAsFactors = stringsAsFactors, check.names = check.names)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm2d(
  lm,
  along = 1,
  fill = FALSE,
  rtn.listnames.nm = "list_names",
  rtn.rownames.nm = "row_names",
  stringsAsFactors = FALSE,
  check.names = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm2d_+3A_lm">lm</code></td>
<td>
<p>list of matrices.</p>
</td></tr>
<tr><td><code id="lm2d_+3A_along">along</code></td>
<td>
<p>numeric vector of length 1 specifying which dimension the matrices
from <code>lm</code> should be binded along: 1 is for rows and 2 is for columns.</p>
</td></tr>
<tr><td><code id="lm2d_+3A_fill">fill</code></td>
<td>
<p>logical vector of length 1 specifying whether to fill in missing values
for any matrices from <code>lm</code> that do not have all the columns. At this time,
<code>fill</code> is only available for rbinding and only used if <code>along</code> = 1.</p>
</td></tr>
<tr><td><code id="lm2d_+3A_rtn.listnames.nm">rtn.listnames.nm</code></td>
<td>
<p>character of length 1 specifying what the name of the
column containing the names/positions of <code>lm</code> should be in the returned
data.frame. If NULL, then no column is created for the names/positions of <code>lm</code>
in the returned data.frame.</p>
</td></tr>
<tr><td><code id="lm2d_+3A_rtn.rownames.nm">rtn.rownames.nm</code></td>
<td>
<p>character of length 1 specifying what the name of the
column containing the names/positions of the rows within <code>lm</code>'s matrices
should be in the returned data.frame. If NULL, then no column is created for
the rownames of <code>lm</code>'s matrices in the returned data.frame.</p>
</td></tr>
<tr><td><code id="lm2d_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical vector of length 1 specifying whether character columns
from <code>lm</code> should be converted to factors. Note, that is a matrix is character,
then <code>stringsAsFactors</code> would apply to all columns.</p>
</td></tr>
<tr><td><code id="lm2d_+3A_check.names">check.names</code></td>
<td>
<p>logical vector of length 1 specifying whether the colnames
of the returned data.frame should be checked for duplicates and made unique.
Only used if for cbinding with <code>along</code> = 2.</p>
</td></tr>
<tr><td><code id="lm2d_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>lm</code> is a list of matrices.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Another way to convert a list of matrices to a data.frame is to convert the list
dimension, row dimension, and column dimension in the list of matrices all to
variable dimensions in the data.frame. If this is desired, call <code>a2d(lm2a(lm))</code>
instead of <code>lm2d</code>.
</p>


<h3>Value</h3>

<p>data.frame with the rows (if <code>along</code> = 1) or columns (if <code>along</code>
= 2) of <code>lm</code> binded together.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># list names and rownames
lm &lt;- asplit(HairEyeColor, MARGIN = 3L)
lm2d(lm) # default
lm2d(lm, rtn.listnames.nm = "Sex", rtn.rownames.nm = "Hair")
# no list names
lm2 &lt;- `names&lt;-`(lm, value = NULL)
lm2d(lm2)
lm2d(lm2, rtn.listnames.nm = NULL)
# no rownames too
lm3 &lt;- lapply(lm2, `rownames&lt;-`, value = NULL)
lm2d(lm3)
lm2d(lm3, rtn.rownames.nm = NULL)
lm2d(lm3, rtn.listnames.nm = NULL, rtn.rownames.nm = NULL)
# cbinding as columns
lm2d(lm3, along = 2)
lm2d(lm3, along = 2, check.names = TRUE)
</code></pre>

<hr>
<h2 id='lm2v'>List of Matrices to (Atomic) Vector</h2><span id='topic+lm2v'></span>

<h3>Description</h3>

<p><code>lm2v</code> converts a list of matrices to a (atomic) vector. This function is
a combination of <code>m2v</code> and <code>lv2v</code>. This function can be useful in
conjunction with the <code>boot::boot</code> function when wanting to generate a
<code>statistic</code> function that returns an atomic vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm2v(
  lm,
  along = 2,
  use.listnames = TRUE,
  use.dimnames = TRUE,
  sep = "_",
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm2v_+3A_lm">lm</code></td>
<td>
<p>list of matrices. They do NOT have to be the same typeof or have the
same dimensions.</p>
</td></tr>
<tr><td><code id="lm2v_+3A_along">along</code></td>
<td>
<p>numeric vector of length one that is equal to either 1 or 2.
1 means that each matrix in <code>lm</code> is split along rows (i.e., dimension 1)
and then concatenated. 2 means that each matrix in <code>lm</code> is split along columns
(i.e., dimension 2) and then concatenated.</p>
</td></tr>
<tr><td><code id="lm2v_+3A_use.listnames">use.listnames</code></td>
<td>
<p>logical vector of length 1 specifying whether the returned
vector should have names based on the list the element came from. If <code>lm</code>
does not have names, <code>use.listnames</code> = TRUE will have the list positions
serve as the list names (e.g., &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, etc.)</p>
</td></tr>
<tr><td><code id="lm2v_+3A_use.dimnames">use.dimnames</code></td>
<td>
<p>logical vector of length 1 specifying whether the returned
vector should have named based on the dimnames of the matrix the element came from.
If a matrix within <code>lm</code> does not have dimnames, <code>use.dimnames</code> = TRUE
will have the dimension positions serve as the dimnames (e.g., &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, etc.)</p>
</td></tr>
<tr><td><code id="lm2v_+3A_sep">sep</code></td>
<td>
<p>character vector of length 1 specifying the string used to separate
the listnames and dimnames from each other when creating the names of the returned
vector.</p>
</td></tr>
<tr><td><code id="lm2v_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>lm</code> is a list of matrices.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>list.names</code> and <code>use.dimnames</code> are both TRUE (default), the returned
vector elements the following naming scheme: &quot;[listname][sep][rowname][sep][colname]&quot;.
</p>
<p>If the matrices in <code>lm</code> are not all the same typeof, then the return object
is coerced to the most complex type of any matrix (e.g., character &gt; double &gt;
integer &gt; logical). See <code>unlist</code> for details about the hierarchy of object types.
</p>


<h3>Value</h3>

<p>(atomic) vector with an element for each element from 'lm'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lm &lt;- list("numeric" = data.matrix(npk), "character" = as.matrix(npk))
# use.listnames = TRUE &amp; use.dimnames = TRUE
lm2v(lm) # the first part of the name is the list names followed by the dimnames
# use.listnames = FALSE &amp; use.dimnames = TRUE
lm2v(lm, use.listnames = FALSE) # only dimnames used,
   # which can result in repeat names
# use.listnames = TRUE &amp; use.dimnames = FALSE
lm2v(lm, use.dimnames = FALSE) # listnames and vector position without any
   # reference to matrix dimensions
# use.listnames = FALSE &amp; use.dimnames = FALSE
lm2v(lm, use.listnames = FALSE, use.dimnames = FALSE) # no names at all
# when list does not have names
lm &lt;- replicate(n = 3, expr = as.matrix(attitude, rownames.force = TRUE), simplify = FALSE)
lm2v(lm) # the first digit of the names is the list position and
   # the subsequent digits are the matrix dimnames
lm2v(lm, use.listnames = FALSE) # no listnames; only dimnames used,
   # which can result in repeat names
</code></pre>

<hr>
<h2 id='lv2d'>List of (atomic) vectors to Data-Frame</h2><span id='topic+lv2d'></span>

<h3>Description</h3>

<p><code>lv2d</code> converts a list of (atomic) vectors to a data.frame. This function
is similar to <code>as.data.frame.list</code>, but allows for more flexibility in how
the data.frame will be structured (e.g., rowwise), while simplifying the dimension
naming process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lv2d(
  lv,
  along,
  fill = FALSE,
  risky = FALSE,
  stringsAsFactors = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lv2d_+3A_lv">lv</code></td>
<td>
<p>list of (atomic) vectors.</p>
</td></tr>
<tr><td><code id="lv2d_+3A_along">along</code></td>
<td>
<p>numeric vector of length 1 specifying either 1 for binding along rows
(i.e., each list element is a row) or 2 for binding along columns (i.e., each
list element in a column).</p>
</td></tr>
<tr><td><code id="lv2d_+3A_fill">fill</code></td>
<td>
<p>logical vector of length 1 specifying whether 1) to allow the vectors
in <code>lv</code> to have different lengths, names, or both, 2) to bind by the names
of the vectors within <code>lv</code> rather than by their positions (unless no names
are present in which case positions are used), and 3) fill in any missing values
in the return object with NA.</p>
</td></tr>
<tr><td><code id="lv2d_+3A_risky">risky</code></td>
<td>
<p>logical vector of length 1 specifying whether to use <code>list2DF</code>
rather than <code>data.frame</code> when <code>along</code> = 2 and <code>fill</code> = TRUE.
If either <code>along</code> = 1 or <code>fill</code> = FALSE, this argument is not used.</p>
</td></tr>
<tr><td><code id="lv2d_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical vector of length 1 specifying whether character
vectors should be coerced to factors. See <code>default.stringsAsFactors</code>.</p>
</td></tr>
<tr><td><code id="lv2d_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>lv</code> is a list of atomic
vectors. This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If fill = FALSE, <code>lv2d</code> uses a combination of <code>do.call</code> and <code>rbind</code>
if <code>along</code> = 1 or <code>do.call</code> and <code>cbind</code> if <code>along</code> = 2.
rownames and colnames of the returned data.frame are determined by the names of
<code>lv</code> and the names of the first vector within <code>lv</code>. If either are NULL,
then the positions are used as the dimension names. If fill = FALSE, then an
error is returned ff the vectors in <code>lv</code> do not all have the same length.
If fill = FALSE, there is no check to ensure the elements within each <code>lv</code>
vector have the same names in the same order. The names are taken from the first
vector in <code>lv</code>, and it is assumed those names and their order apply to each
vector in <code>lv</code>. Essentially, if fill = FALSE, <code>lv</code> binds the vectors
by positions and not names.
</p>
<p>If fill = TRUE, <code>lv2d</code> uses <code>plyr::rbind.fill</code> if <code>along</code> = 1 or
<code>plyr::join_all</code> by the vector names if <code>along</code> = 2. If fill = TRUE,
<code>lv2d</code> binds the vectors by by names (and by positions if no names are present).
Depending on what the user wants, fill = FALSE or TRUE could be safer. If the user
wants an error returned when any vectors within <code>lv</code> have different lengths,
then fill = FALSE should be used. If the user wants to bind by names rather than
position, then fill = TRUE should be used.
</p>


<h3>Value</h3>

<p>data.frame with the elements of 'lv' either as rows or columns and dimnames
determined along the names of 'lv' and 'lv'[[1]].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1) `lv` has names; vectors have names
lv &lt;- setNames(object = lapply(X = letters, FUN = setNames, nm = "alphabet"), nm = LETTERS)
lv2d(lv, along = 1)
lv2d(lv, along = 2)
lv2d(lv, along = 2, stringsAsFactors = TRUE)

# 2) `lv` has names; no vector names
lv &lt;- setNames(object = as.list(letters), nm = LETTERS)
lv2d(lv, along = 1)
lv2d(lv, along = 2)

# 3) no `lv` names; vector have names
lv &lt;- lapply(X = letters, FUN = setNames, nm = "alphabet")
lv2d(lv, along = 1)
lv2d(lv, along = 2)

# 4) no `lv` names; no vector names
lv &lt;- as.list.default(letters)
lv2d(lv, along = 1)
lv2d(lv, along = 2)

# we want vectors combined along rows
lv &lt;- lapply(X = unclass(mtcars), FUN = `names&lt;-`, value = row.names(mtcars))
rbind(lv) # not what we want (array list)
rbind.data.frame(lv) # also not what we want (combined along cols)
do.call(what = rbind.data.frame, args = lv) # doesn't have useful dimnames
lv2d(lv, along = 1) # finally what we want

# fill = TRUE
tmp &lt;- lapply(X = unclass(mtcars), FUN = `names&lt;-`, value = row.names(mtcars))
lv &lt;- lapply(X = tmp, FUN = function(v) v[-(sample(x = seq_along(v), size = 9))])
lv2d(lv, along = 1L, fill = TRUE) # NA for missing values in any given row
tmp &lt;- lapply(X = unclass(as.data.frame(t(mtcars))), FUN = `names&lt;-`, value = names(mtcars))
lv &lt;- lapply(X = tmp, FUN = function(v) v[-(sample(x = seq_along(v), size = 3))])
lv2d(lv, along = 2L, fill = TRUE) # NA for missing values in any given column

# actual use case
lv &lt;- lapply(X = sn(1:30), FUN = function(i)
   coef(lm(v2frm(names(attitude)), data = attitude[-i, ])))
lv2d(lv, along = 2) # coefs in a data.frame

# when vectors have named elements in different positions use fill = TRUE
lv &lt;- list("row_1" = c("col_A" = "col_A1", "col_B" = "col_B1", "col_C" = "col_C1"),
"row_2" = c("col_B" = "col_B2", "col_C" = "col_C2", "col_A" = "col_A2"),
"row_3" = c("col_C" = "col_C3", "col_A" = "col_A3", "col_B" = "col_B3"))
lv2d(lv, along = 1, fill = FALSE) # probably not what you want (See details)
lv2d(lv, along = 1, fill = TRUE) # what we want

# when you have a list with only one vector
lv &lt;- list("A" = c("one" = 1, "two" = 2, "three" = 3))
x &lt;- lv2m(lv, along = 1, fill = FALSE)
y &lt;- lv2m(lv, along = 1, fill = TRUE)
identical(x, y)

</code></pre>

<hr>
<h2 id='lv2m'>List of (atomic) Vectors to Matrix</h2><span id='topic+lv2m'></span>

<h3>Description</h3>

<p><code>lv2m</code> converts a list of (atomic) vectors to a matrix. This function
is similar to a hypothetical <code>as.matrix.list</code> method if it existed.
Note, if the vectors are not all the same typeof, then the matrix will have
the most complex typeof any vector in <code>lv</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lv2m(lv, along, fill = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lv2m_+3A_lv">lv</code></td>
<td>
<p>list of (atomic) vectors.</p>
</td></tr>
<tr><td><code id="lv2m_+3A_along">along</code></td>
<td>
<p>numeric vector of length 1 specifying either 1 for binding along rows
(i.e., each list element is a row) and 2 for binding along columns (i.e., each
list element in a column).</p>
</td></tr>
<tr><td><code id="lv2m_+3A_fill">fill</code></td>
<td>
<p>logical vector of length 1 specifying whether 1) to allow the vectors
in <code>lv</code> to have different lengths, names, or both, 2) to bind by the names
of the vectors within <code>lv</code> rather than by their positions (unless no names
are present in which case positions are used), and 3) fill in any missing values
in the return object with NA.</p>
</td></tr>
<tr><td><code id="lv2m_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>lv</code> is a list of atomic
vectors. This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If fill = FALSE, <code>lv2m</code> uses a combination of <code>do.call</code> and <code>rbind</code>
if <code>along</code> = 1 or <code>do.call</code> and <code>cbind</code> if <code>along</code> = 2.
rownames and colnames of the returned data.frame are determined by the names of
<code>lv</code> and the names of the first vector within <code>lv</code>. If either are NULL,
then the positions are used as the dimension names. If fill = FALSE, then an
error is returned ff the vectors in <code>lv</code> do not all have the same length.
If fill = FALSE, there is no check to ensure the elements within each <code>lv</code>
vector have the same names in the same order. The names are taken from the first
vector in <code>lv</code>, and it is assumed those names and their order apply to each
vector in <code>lv</code>. Essentially, if fill = FALSE, <code>lv</code> binds the vectors
by positions and not names.
</p>
<p>If fill = TRUE, <code>lv2m</code> uses <code>plyr::rbind.fill.matrix</code> if <code>along</code> = 1 or
<code>plyr::rbind.fill.matrix</code> and <code>t.default</code> if <code>along</code> = 2. If fill = TRUE,
<code>lv2d</code> binds the vectors by by names (and by positions if no names are present).
Depending on what the user wants, fill = FALSE or TRUE could be safer. If the user
wants an error returned when any vectors within <code>lv</code> have different lengths,
then fill = FALSE should be used. If the user wants to bind by names rather than
position, then fill = TRUE should be used.
</p>


<h3>Value</h3>

<p>matrix with the elements of <code>lv</code> either as rows or columns and dimnames
determined by the names of <code>lv</code> and <code>lv[[1]]</code>. The typeof is determined
by the highest typeof in the elements of <code>lv</code> (i.e., highest to lowest: character &gt;
double &gt; integer &gt; logical).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1) `lv` has names; vectors have names
lv &lt;- setNames(object = lapply(X = letters, FUN = setNames, nm = "alphabet"), nm = LETTERS)
lv2m(lv, along = 1)
lv2m(lv, along = 2)

# 2) `lv` has names; no vector names
lv &lt;- setNames(object = as.list(letters), nm = LETTERS)
lv2m(lv, along = 1)
lv2m(lv, along = 2)

# 3) no `lv` names; vector have names
lv &lt;- lapply(X = letters, FUN = setNames, nm = "alphabet")
lv2m(lv, along = 1)
lv2m(lv, along = 2)

# 4) no `lv` names; no vector names
lv &lt;- as.list.default(letters)
lv2m(lv, along = 1)
lv2m(lv, along = 2)

# actual use case (sort of)
lv &lt;- lapply(X = asplit(x = as.matrix(attitude), MARGIN = 1),
   FUN = undim) # need undim since asplit returns 1D arrays
cbind(lv) # not what we want
do.call(what = cbind, args = lv) # doesn't have useful dimnames
lv2m(lv, along = 2) # finally what we want

# when vectors have named elements in different positions
lv &lt;- list("row_1" = c("col_A" = "col_A1", "col_B" = "col_B1", "col_C" = "col_C1"),
   "row_2" = c("col_B" = "col_B2", "col_C" = "col_C2", "col_A" = "col_A2"),
   "row_3" = c("col_C" = "col_C3", "col_A" = "col_A3", "col_B" = "col_B3"))
lv2m(lv, along = 1, fill = FALSE) # probably not what you want
lv2m(lv, along = 1, fill = TRUE) # what you want (See details)

# when you have a list with only one vector
lv &lt;- list("A" = c("one" = 1, "two" = 2, "three" = 3))
x &lt;- lv2m(lv, along = 1, fill = FALSE)
y &lt;- lv2m(lv, along = 1, fill = TRUE)
identical(x, y)

</code></pre>

<hr>
<h2 id='lv2v'>List of (atomic) Vectors to (atomic) Vector</h2><span id='topic+lv2v'></span>

<h3>Description</h3>

<p><code>lv2v</code> converts a list of (atomic) vectors to an (atomic) vector. <code>lv2v</code>
is simply a wrapper function for <code>unlist</code> that allows for more control
over the names of the returned (atomic) vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lv2v(lv, use.listnames = TRUE, use.vecnames = TRUE, sep = "_", check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lv2v_+3A_lv">lv</code></td>
<td>
<p>list of (atomic) vectors.</p>
</td></tr>
<tr><td><code id="lv2v_+3A_use.listnames">use.listnames</code></td>
<td>
<p>logical vector of length 1 specifying whether the names of
<code>lv</code> should be used to construct names for the returned vector. If <code>lv</code>
does not have names and <code>use.listnames</code> = TRUE, then the list positions will
be used as names (i.e., &quot;1&quot;,&quot;2&quot;,&quot;3&quot;, etc.).</p>
</td></tr>
<tr><td><code id="lv2v_+3A_use.vecnames">use.vecnames</code></td>
<td>
<p>logical vector of length 1 specifying whether the names of
each vector within <code>lv</code> should be used to construct names for the returned vector.
If any vectors within <code>lv</code> do not have names and <code>use.vecnames</code> = TRUE,
then the vector positions will be used as names (i.e., &quot;1&quot;,&quot;2&quot;,&quot;3&quot;, etc.).</p>
</td></tr>
<tr><td><code id="lv2v_+3A_sep">sep</code></td>
<td>
<p>character vector of length 1 specifying what string to use to separate
list names from vector element names. Only used if <code>use.listnames</code> = TRUE.</p>
</td></tr>
<tr><td><code id="lv2v_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>lv</code> is a list of atomic
vectors. This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are four different scenarios. Each scenario is given as well as the structure
of the returned object when both <code>use.listnames</code> and <code>use.vecnames</code> are
TRUE (default): 1) if both <code>lv</code> and its vectors have names, then the names of
the return object will be a pasted combination of the <code>lv</code> element's name
and the vector element's name separated by <code>sep</code>; 2) if only <code>lv</code> has
names and its vectors do not, then the names of the returned vector will be a
pasted combination of the <code>lv</code> element's name and the vector element's position
separated by <code>sep</code>; 3) if the vectors have names and <code>lv</code> does not,
then the names of the returned vector will be a pasted combination of the <code>lv</code>
positions and vector names separated by <code>sep</code>; 4) if both <code>lv</code> and its
vectors do not have names, then the names of the returned vector will be the pasted
combination of the <code>lv</code> positions and vector element's positions separated
by <code>sep</code>.
</p>
<p>If you want to convert a list of vectors where each vector has length = 1 and the
list has names, then you probably want to specify <code>use.vecnames</code> = FALSE.
This will replicate the functionality of <code>unlist(lv)</code>. See the last example.
</p>
<p>If you want have a list of vectors where each vector has length &gt; 1 and you
want to convert it to a list vector (i.e., all vectors with length = 1),
then you can combine <code>lv2v</code> with <code>v2lv</code> via <code>v2lv(lv2v(v))</code>.
</p>


<h3>Value</h3>

<p>atomic vector with length = sum of the lengths of the atomic vectors in
<code>lv</code> and typeof = the highest typeof present in the atomic vectors in <code>lv</code>
(i.e., from high to low: character &gt; double &gt; integer &gt; logical). See the argument
<code>use.listnames</code> for how names are created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1) both `lv` and its atomic vectors have names
lv &lt;- setNames(object = Map(object = 1:26, nm = letters, f = setNames), nm = LETTERS)
lv2v(lv, use.listnames = TRUE, use.vecnames = TRUE)
lv2v(lv, use.listnames = FALSE, use.vecnames = TRUE)
lv2v(lv, use.listnames = TRUE, use.vecnames = FALSE)
lv2v(lv, use.listnames = FALSE, use.vecnames = FALSE)
# 2) only `lv` has names
lv &lt;- list("lower" = letters, "upper" = LETTERS)
lv2v(lv, use.listnames = TRUE, use.vecnames = TRUE)
lv2v(lv, use.listnames = FALSE, use.vecnames = TRUE)
lv2v(lv, use.listnames = TRUE, use.vecnames = FALSE) # FYI - results in repeat names
lv2v(lv, use.listnames = FALSE, use.vecnames = FALSE)
# 3) only the atomic vectors have names
lv &lt;- list(setNames(object = 1:26, nm = letters), setNames(object = 1:26, nm = LETTERS))
lv2v(lv, use.listnames = TRUE, use.vecnames = TRUE)
lv2v(lv, use.listnames = FALSE, use.vecnames = TRUE)
lv2v(lv, use.listnames = TRUE, use.vecnames = FALSE)
lv2v(lv, use.listnames = FALSE, use.vecnames = FALSE)
# 4) neither `lv` nor its atomic vectors have names
lv &lt;- as.list(1:26)
lv2v(lv, use.listnames = TRUE, use.vecnames = TRUE)
lv2v(lv, use.listnames = FALSE, use.vecnames = TRUE) # FYI - results in repeat names
lv2v(lv, use.listnames = TRUE, use.vecnames = FALSE)
lv2v(lv, use.listnames = FALSE, use.vecnames = FALSE)
# common use case for when vectors are all length 1 and list has names
lv &lt;- setNames(as.list(letters), nm = LETTERS)
lv2v(lv, use.listnames = TRUE, use.vecnames = TRUE)
lv2v(lv, use.listnames = FALSE, use.vecnames = TRUE)
lv2v(lv, use.listnames = TRUE, use.vecnames = FALSE) # FYI - probably what you want
lv2v(lv, use.listnames = FALSE, use.vecnames = FALSE)
identical(unlist(lv), lv2v(lv, use.vecnames = FALSE)) # identical to unlist()
</code></pre>

<hr>
<h2 id='m2d'>Matrix to Data-Frame</h2><span id='topic+m2d'></span>

<h3>Description</h3>

<p><code>m2d</code> converts a matrix to a data.frame. The benefit of <code>m2d</code> over
<code>as.data.frame.matrix</code> is that it provides the <code>col</code> argument, which
allows the columns of the data.frame to be the columns of the matrix (i.e.,
<code>col = 2</code>), the rows of the matrix (i.e., <code>col = 1</code>), or the expanded
matrix (i.e., <code>col = 0</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2d(m, col = 2, stringsAsFactors = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="m2d_+3A_m">m</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="m2d_+3A_col">col</code></td>
<td>
<p>numeric vector of length 1 that is equal to either 0, 1, or 2. <code>col</code>
specifies what dimension from <code>m</code> should be the columns of the returned data.frame.
If <code>col = 2</code>, then the columns of <code>m</code> (i.e., dimension 2) are the columns
of the returned data.frame. If <code>col = 1</code>, then the rows of <code>m</code>
(i.e., dimension 1) are the columns of the returned data.frame. If <code>col = 0</code>,
neither of the <code>m</code> dimensions are the columns and instead the matrix is
expanded by <code>reshape::melt.array</code> such that in the returned data.frame
the first column is <code>rownames(m)</code>, the second column is <code>colnames(m</code>,
and the third column is the elements of <code>m</code>. If any <code>dimnames(m)</code> are
NULL, then they are replaced with the positions of the dimensions.</p>
</td></tr>
<tr><td><code id="m2d_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical vector of length 1 specifying whether any resulting
character columns in the return object should be factors. If <code>m</code> is a
character matrix and <code>stringsAsFactors</code> = TRUE, then all columns in the
returned data.frame will be factors. If <code>col</code> = 0 and <code>stringsAsFactors</code>
= TRUE, then the first two columns in the returned data.frame specifying
<code>dimnames(m)</code> will be factors.</p>
</td></tr>
<tr><td><code id="m2d_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>m</code> is a matrix.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with rownames and colnames specified by <code>dimnames(m)</code>
and <code>col</code>. If <code>col = 0</code>, then the rownames are default (i.e., &quot;1&quot;,&quot;2&quot;,&quot;3&quot;, etc.)
and the colnames are the following: the first two columns are <code>names(dimnames(m))</code>
(if NULL they are &quot;rownames&quot; and &quot;colnames&quot;, respectively) and the third is
&quot;element&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars2 &lt;- as.matrix(mtcars, rownames.force = TRUE) # to make sure dimnames stay in the example
m2d(mtcars2) # default
m2d(m = mtcars2, col = 1) # data.frame columns are matrix rownames
m2d(m = mtcars2, col = 0) # data.frame columns are the entire matrix
mat &lt;- cbind(lower = letters, upper = LETTERS)
m2d(mat)
m2d(mat, stringsAsFactors = TRUE)
m2d(mat, col = 0)
m2d(mat, col = 0, stringsAsFactors = TRUE)
</code></pre>

<hr>
<h2 id='m2lv'>Matrix to List of (Atomic) Vectors</h2><span id='topic+m2lv'></span>

<h3>Description</h3>

<p><code>m2lv</code> converts a matrix to a list of (atomic) vectors. This is useful
since there is no <code>as.list.matrix</code> method. When rownames and/or colnames
are NULL, they are replaced by their position numerals so that the dimension
information is retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2lv(m, along, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="m2lv_+3A_m">m</code></td>
<td>
<p>matrix (i.e., array with 2 dimensions).</p>
</td></tr>
<tr><td><code id="m2lv_+3A_along">along</code></td>
<td>
<p>numeric vector of length 1 specifying which dimension to slice
the matrix along. If 1, then the matrix is sliced by rows. If 2, then the
matrix is sliced by columns.</p>
</td></tr>
<tr><td><code id="m2lv_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>m</code> is a matrix.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of (atomic) vectors. If <code>along</code> = 1, then the names are the
rownames of <code>m</code> and the vectors are rows from <code>m</code>. If <code>along</code> = 2,
then the names are the colnames of <code>m</code> and the vector are columns from <code>m</code>.
Note, the vectors always have the same length as <code>nrow(m)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m2lv(VADeaths, along = 1)
m2lv(VADeaths, along = 2)
m2lv(m = as.matrix(x = attitude, rownames.force = TRUE), along = 1)
m2lv(m = as.matrix(x = attitude, rownames.force = TRUE), along = 2)
m2lv(m = as.matrix(x = unname(attitude), rownames.force = FALSE),
   along = 1) # dimnames created as position numerals
m2lv(m = as.matrix(x = unname(attitude), rownames.force = FALSE),
   along = 2) # dimnames created as position numerals
# check = FALSE
try_expr(m2lv(VADeaths, along = 3, check = FALSE)) # less informative error message
try_expr(m2lv(VADeaths, along = 3, check = TRUE)) # more informative error message
</code></pre>

<hr>
<h2 id='m2v'>Matrix to (Atomic) Vector</h2><span id='topic+m2v'></span>

<h3>Description</h3>

<p><code>m2v</code> converts a matrix to a (atomic) vector. The benefit of <code>m2v</code>
over <code>as.vector</code> or <code>c</code> is that 1) the vector can be formed along rows
as well as columns and 2) the dimnames from <code>m</code> can be used for the names of
the returned vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2v(m, along = 2, use.dimnames = TRUE, sep = "_", check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="m2v_+3A_m">m</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="m2v_+3A_along">along</code></td>
<td>
<p>numeric vector of length one that is equal to either 1 or 2.
1 means that <code>m</code> is split along rows (i.e., dimension 1) and then concatenated.
2 means that <code>m</code> is split along columns (i.e., dimension 2) and then concatenated.</p>
</td></tr>
<tr><td><code id="m2v_+3A_use.dimnames">use.dimnames</code></td>
<td>
<p>logical vector of length 1 that specifies whether the dimnames
of <code>m</code> should be used to create the names for the returned vector. If FALSE,
the returned vector will have NULL names. If TRUE, see details.</p>
</td></tr>
<tr><td><code id="m2v_+3A_sep">sep</code></td>
<td>
<p>character vector of length 1 specifying the string that will separate
the rownames and colnames in the naming scheme of the return object. Note, <code>sep</code>
is not used if <code>use.dimnames</code> = FALSE.</p>
</td></tr>
<tr><td><code id="m2v_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>m</code> is a matrix.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use.dimnames</code> = TRUE, then each element's name will be analogous to
<code>paste(rownames(m)[i], colnames(m)[j], sep = sep)</code>. If <code>m</code> does not
have rownames and/or colnames, then they will be replaced by dimension positions.
This is also true when <code>m</code> has only one row *and* one column. The exception
is when <code>m</code> has either a single row *or* single column. In these cases,
only the non-single dimension's names will be used. If <code>m</code> has one row,
then the names of the returned vector will be <code>colnames(m)</code>. If <code>m</code>
has one column, then the names of the returned vector will be <code>rownames(m)</code>.
Again, if <code>m</code> does not have rownames and/or colnames, then they will be
replaced by dimension positions.
</p>


<h3>Value</h3>

<p>(atomic) vector of length = <code>length(m)</code> where the order of elements
from <code>m</code> has been determined by <code>along</code> and the names determined by
the <code>use.dimnames</code>, <code>dimnames(m)</code>, and <code>sep</code>. See details for when
<code>use.dimnames</code> = TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># general matrix
mtcars2 &lt;- as.matrix(mtcars, rownames.force = TRUE) # to make sure dimnames stay in the example
m2v(mtcars2) # default
m2v(m = mtcars2, along = 1) # concatenate along rows
m2v(m = mtcars2, sep = ".") # change the sep of the rownames(m) and colnames(m)
m2v(m = `dimnames&lt;-`(mtcars2, list(NULL, NULL))) # use dimension positions as dimnames
m2v(m = mtcars2, use.dimnames = FALSE) # return object has no names
# one row/column matrix
one_row &lt;- mtcars2[1,, drop = FALSE]
m2v(one_row)
one_col &lt;- mtcars2[, 1, drop = FALSE]
m2v(one_col)
one_all &lt;- mtcars2[1,1, drop = FALSE]
m2v(one_all)
m2v(one_all, use.dimnames = FALSE)
</code></pre>

<hr>
<h2 id='ndim'>Number of Object Dimensions</h2><span id='topic+ndim'></span>

<h3>Description</h3>

<p><code>ndim</code> returns the number of dimensions an object has. This is most useful
for arrays, which can have anywhere from 1 to 1000+ dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ndim_+3A_x">x</code></td>
<td>
<p>object that has dimensions (e.g., array).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ndim</code> is a very simple function that is simply <code>length(dim(x))</code>.
</p>


<h3>Value</h3>

<p>integer vector of length 1 specifying the number of dimensions in <code>x</code>.
If <code>x</code> does not have any dimensions, then O is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ndim(state.region)
ndim(attitude)
ndim(HairEyeColor)
</code></pre>

<hr>
<h2 id='nlay'>Number of Layers (the Third Dimension)</h2><span id='topic+nlay'></span>

<h3>Description</h3>

<p><code>nlay</code> returns the number of layers - the third dimension - of an array.
If the object does not have a third dimension (e.g., matrix), then the function
will return NA with typeof = integer. If the object does not have any dimensions
(e.g., atomic vector), then the function will return NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlay(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nlay_+3A_x">x</code></td>
<td>
<p>array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R does not have standard terminology for the third dimension. There are several common terms
people use including &quot;height&quot; and &quot;page&quot;. I personally prefer &quot;layer&quot; as it makes sense
whether the user visualizes the third dimension as going into/ontop a desk or into/ontop a wall.
</p>


<h3>Value</h3>

<p>The number of layers (the third dimension) of <code>x</code>. The structure is
an integer vector with length = 1. See details for special cases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nlay(HairEyeColor)
a &lt;- array(data = NA, dim = c(6,7,8,9))
nlay(a)
</code></pre>

<hr>
<h2 id='not.colnames'>Identify Elements That are Not Colnames</h2><span id='topic+not.colnames'></span>

<h3>Description</h3>

<p><code>not.colnames</code> identifies which elements from <code>nm</code> are not colnames of <code>x</code>.
If all elements are colnames, then a character vector of length 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not.colnames(x, nm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="not.colnames_+3A_x">x</code></td>
<td>
<p>object with a colnames attribute</p>
</td></tr>
<tr><td><code id="not.colnames_+3A_nm">nm</code></td>
<td>
<p>character vector specifying the elements to test as colnames of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector containing the elements of <code>nm</code> that are not colnames
of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not.colnames(x = as.matrix(mtcars), nm = c("MPG","mpg"))
</code></pre>

<hr>
<h2 id='not.names'>Identify Elements That are Not Names</h2><span id='topic+not.names'></span>

<h3>Description</h3>

<p><code>not.names</code> identifies which elements from <code>nm</code> are not names of <code>x</code>.
If all elements are names, then a character vector of length 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not.names(x, nm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="not.names_+3A_x">x</code></td>
<td>
<p>object with a names attribute</p>
</td></tr>
<tr><td><code id="not.names_+3A_nm">nm</code></td>
<td>
<p>character vector specifying the elements to test as names of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector containing the elements of <code>nm</code> that are not names
of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- setNames(object = letters, nm = LETTERS)
not.names(x = v, nm = c("A","a"))
data("mtcars")
not.names(x = mtcars, nm = c("MPG","mpg"))
not.names(x = mtcars, names(mtcars)) # returns a character vector of length 0
</code></pre>

<hr>
<h2 id='not.row.names'>Identify Elements That are Not Row.names</h2><span id='topic+not.row.names'></span>

<h3>Description</h3>

<p><code>not.row.names</code> identifies which elements from <code>nm</code> are not row.names of <code>x</code>.
If all elements are row.names, then a character vector of length 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not.row.names(x, nm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="not.row.names_+3A_x">x</code></td>
<td>
<p>object with a row.names attribute</p>
</td></tr>
<tr><td><code id="not.row.names_+3A_nm">nm</code></td>
<td>
<p>character vector specifying the elements to test as row.names of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector containing the elements of <code>nm</code> that are not row.names
of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not.row.names(x = mtcars, nm = c("Mazda RX4","mazda RX4"))
</code></pre>

<hr>
<h2 id='not.rownames'>Identify Elements That are Not Rownames</h2><span id='topic+not.rownames'></span>

<h3>Description</h3>

<p><code>not.rownames</code> identifies which elements from <code>nm</code> are not rownames of <code>x</code>.
If all elements are rownames, then a character vector of length 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not.rownames(x, nm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="not.rownames_+3A_x">x</code></td>
<td>
<p>object with a rownames attribute</p>
</td></tr>
<tr><td><code id="not.rownames_+3A_nm">nm</code></td>
<td>
<p>character vector specifying the elements to test as rownames of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector containing the elements of <code>nm</code> that are not rownames
of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not.rownames(x = as.matrix(mtcars), nm = c("Mazda RX4","mazda RX4"))
</code></pre>

<hr>
<h2 id='order.custom'>Custom Order Permutation</h2><span id='topic+order.custom'></span>

<h3>Description</h3>

<p><code>order.custom</code> creates the order of the positions in the atomic vectors
from <code>X</code> that would cause the atomic vectors from <code>X</code> to be sorted
according to the atomic vectors from <code>ORD</code>. This is analogus to the
<code>order</code> function, but instead of doing default sorting (e.g., 1, 2, 3, etc.
or &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, etc.), the sorting is customized by <code>ORD</code>.
<code>order.custom</code> does custom ordering by converting each atomic vector from
<code>X</code> to an ordered factor and then default sorting the ordered factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.custom(X, ORD, na.last = FALSE, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order.custom_+3A_x">X</code></td>
<td>
<p>list of atomic vectors parellel matched with the atomic vectors in <code>X</code>
specifying the elements to be ordered. Can also be a single atomic vector, which
will internally be converted to a list with one element.</p>
</td></tr>
<tr><td><code id="order.custom_+3A_ord">ORD</code></td>
<td>
<p>list of atomic vectors that do NOT have to be the same length
specifying the order of the unique values for sorting. Can also be a single
atomic vector, which will internally be converted to a list with one element.</p>
</td></tr>
<tr><td><code id="order.custom_+3A_na.last">na.last</code></td>
<td>
<p>logical vector of length 1 specifying whether missing values
should be put last (TRUE), first (FALSE), or removed (NA).</p>
</td></tr>
<tr><td><code id="order.custom_+3A_decreasing">decreasing</code></td>
<td>
<p>logical vector of length 1 specifying whether the sorting
should start with the first element of the atomic vectors within <code>ORD</code>
and proceed forward (FALSE) or the last element of the atomic vectors within
<code>ORD</code> and proceed backwards (TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note, that the atomic vectors within <code>X</code> are always forward sequenced;
if backward sequence is desired, then the user should call <code>rev</code> on both
the input to <code>X</code> and <code>ORD</code>. This is analogous to reversing the
order of the atomic vectors given to <code>...</code> within <code>order</code>.
</p>


<h3>Value</h3>

<p>integer vector of length = <code>X[[1]]</code> (after converting <code>X</code> to
a list with one element is need be) providing the revised order of the atomic
vectors within <code>X</code> that sorts them according to <code>ORD</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># character vector
x &lt;- esoph[["tobgp"]]
order.custom(X = x, ORD = c("20-29","10-19","30+","0-9g/day"))
x[order.custom(X = x, ORD = c("20-29","10-19","30+","0-9g/day"))] # returns character
esoph[order.custom(X = x, ORD = c("20-29","10-19","30+","0-9g/day")), ]
# order by position
sort(state.region)
x &lt;- as.character(state.region)
order.custom(X = x, ORD = unique(x))
x[order.custom(X = x, ORD = unique(x))]
# numeric vector
y &lt;- esoph[["ncases"]]
order.custom(X = y, ORD = c(6,5,4,3,2,1,0,17,8,9))
y[order.custom(X = y, ORD = c(6,5,4,3,2,1,0,17,8,9))] # returns numeric
esoph[order.custom(X = y, ORD = c(6,5,4,3,2,1,0,17,8,9)), ]
   # some unique values not provided in `ORD` (appended at the end and sorted by
   # where they appear in the dataset)
y &lt;- esoph[["ncases"]]
order.custom(X = y, ORD = c(6,5,4,3,2,1,0))
y[order.custom(X = y, ORD = c(6,5,4,3,2,1,0))] # returns numeric
esoph[order.custom(X = y, ORD = c(6,5,4,3,2,1,0)), ]
# multiple vectors
z &lt;- esoph[c("agegp","alcgp","tobgp")]
ord &lt;- order.custom(X = z, ORD = list(
   "agegp" = c("45-54","55-64","35-44","65-74","25-34","75+"),
   "alcgp" = c("40-79","80-119","0-39g/day","120+"),
   "tobgp" = c("10-19","20-29","0-9g/day","30+")))
esoph[ord, ]
</code></pre>

<hr>
<h2 id='pick'>Extract Elements From a (Atomic) Vector</h2><span id='topic+pick'></span>

<h3>Description</h3>

<p><code>pick</code> extracts the elements from a (atomic) vector that meet certain criteria:
1) using exact values or regular expressions (<code>pat</code>), 2) inclusion vs.
exclusion of the value/expression (<code>not</code>), 3) based on elements or names (<code>nm</code>).
Primarily for character vectors, but can be used with other typeof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick(x, val, pat = FALSE, not = FALSE, nm = FALSE, fixed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_+3A_x">x</code></td>
<td>
<p>atomic vector or an object with names (e.g., data.frame) if <code>nm</code> = TRUE.</p>
</td></tr>
<tr><td><code id="pick_+3A_val">val</code></td>
<td>
<p>atomic vector specifying which elements of <code>x</code> will be extracted.
If <code>pat</code> = FALSE (default), then <code>val</code> should be an atomic vector of
the same typeof as <code>x</code>, can have length &gt; 1, and exact matching will be done
via <code>is.element</code> (essentially <code>match</code>). If <code>pat</code> = TRUE, then
<code>val</code> has to be a character vector of length 1 and partial matching will be
done via <code>grepl</code> with the option of regular expressions if <code>fixed</code> = FALSE
(default). Note, if <code>nm</code> = TRUE, then <code>val</code> should refer to names of
<code>x</code> to determine which elements of <code>x</code> should be extracted.</p>
</td></tr>
<tr><td><code id="pick_+3A_pat">pat</code></td>
<td>
<p>logical vector of length 1 specifying whether <code>val</code> should refer to
exact matching (FALSE) via <code>is.element</code> (essentially <code>match</code>) or partial
matching (TRUE) and/or use of regular expressions via <code>grepl</code>. See details
for a brief description of some common symbols and <code>help(regex)</code> for more.</p>
</td></tr>
<tr><td><code id="pick_+3A_not">not</code></td>
<td>
<p>logical vector of length 1 specifying whether <code>val</code> indicates
values that should be retained (FALSE) or removed (TRUE).</p>
</td></tr>
<tr><td><code id="pick_+3A_nm">nm</code></td>
<td>
<p>logical vector of length 1 specifying whether <code>val</code> refers to the
names of <code>x</code> (TRUE) rather than the elements of <code>x</code> themselves (FALSE).</p>
</td></tr>
<tr><td><code id="pick_+3A_fixed">fixed</code></td>
<td>
<p>logical vector of length 1 specifying whether <code>val</code> refers to
values as is (TRUE) or a regular expression (FALSE). Only used if <code>pat</code> = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pick</code> allows for 8 different ways to extract elements from a (atomic) vector
created by the 2x2x2 combination of logical arguments <code>pat</code>, <code>not</code>, and <code>nm</code>.
When <code>pat</code> = FALSE (default), <code>pick</code> uses <code>is.element</code> (essentially
<code>match</code>) and requires exact matching of <code>val</code> in <code>x</code>. When <code>pat</code>
= TRUE, <code>pick</code> uses <code>grepl</code> and allows for partial matching of <code>val</code>
in <code>x</code> and/or regular expressions if <code>fixed</code> = FALSE (default).
</p>
<p>When dealing with regular expressions via <code>pat</code> = TRUE and <code>fixed</code> = FALSE,
certain symbols within <code>val</code> are not interpreted as literal characters and
instead have special meanings. Some of the most commonly used symbols are <code>.</code>
= any character, <code>"|"</code> = logical or, <code>"^"</code> = starts with, <code>"\n"</code> = new line,
<code>"\t"</code> = tab.
</p>


<h3>Value</h3>

<p>a subset of <code>x</code> that only includes the elements which meet the criteria
specified by the function call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># pedagogical cases
chr &lt;- setNames(object = c("one","two","three","four","five"), nm = as.character(1:5))
# 1) pat = FALSE, not = FALSE, nm = FALSE
pick(x = chr, val = c("one","five"), pat = FALSE, not = FALSE, nm = FALSE)
# 2) pat = FALSE, not = FALSE, nm = TRUE
pick(x = chr, val = c("1","5"), pat = FALSE, not = FALSE, nm = TRUE)
# 3) pat = FALSE, not = TRUE, nm = FALSE
pick(x = chr, val = c("two","three","four"), pat = FALSE, not = TRUE, nm = FALSE)
# 4) pat = FALSE, not = TRUE, nm = TRUE
pick(x = chr, val = c("2","3","4"), pat = FALSE, not = TRUE, nm = TRUE)
# 5) pat = TRUE, not = FALSE, nm = FALSE
pick(x = chr, val = "n|v", pat = TRUE, not = FALSE, nm = FALSE)
# 6) pat = TRUE, not = FALSE, nm = TRUE
pick(x = chr, val = "1|5", pat = TRUE, not = FALSE, nm = TRUE)
# 7) pat = TRUE, not = TRUE, nm = FALSE
pick(x = chr, val = "t|r", pat = TRUE, not = TRUE, nm = FALSE)
# 8) pat = TRUE, not = TRUE, nm = TRUE
pick(x = chr, val = c("2|3|4"), pat = TRUE, not = TRUE, nm = TRUE)
datasets &lt;- data()[["results"]][, "Item"]
# actual use cases
pick(x = datasets, val = c("attitude","mtcars","airquality"),
   not = TRUE) # all but the three most common datasets used in `str2str` package examples
pick(x = datasets, val = "state", pat = TRUE) # only datasets that contain "state"
pick(x = datasets, val = "state.*state", pat = TRUE) # only datasets that have
   # "state" twice in their name
pick(x = datasets, val = "US|UK", pat = TRUE) # only datasets that contain
   # "US" or "UK"
pick(x = datasets, val = "^US|^UK", pat = TRUE) # only datasets that start with
   # "US" or "UK"
pick(x = datasets, val = "k.*o|o.*k", pat = TRUE) # only datasets containing both
   # "k" and "o"
</code></pre>

<hr>
<h2 id='rbind+26lt+3B-'>Add Rows to Data Objects</h2><span id='topic+rbind+3C-'></span>

<h3>Description</h3>

<p><code>`rbind&lt;-`</code> adds rows to data objects as a side effect. The purpose of
the function is to replace the need to use dat2 &lt;- rbind(dat1, add1);
dat3 &lt;- rbind(dat2, add2); dat4 &lt;- rbind(dat3, add3), etc. For data.frames,
it functions similarly to <code>`[&lt;-.data.frame`</code>, but allows you to specify the
location of the rows similar to <code>append</code> (vs. <code>c</code>) and overwrite
rows with the same rownames. For matrices, it offers more novel functionality
since <code>`[&lt;-.matrix`</code> does not exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind(data, after = nrow(data), row.nm = NULL, overwrite = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbind+2B26lt+2B3B-_+3A_data">data</code></td>
<td>
<p>data.frame or matrix of data.</p>
</td></tr>
<tr><td><code id="rbind+2B26lt+2B3B-_+3A_after">after</code></td>
<td>
<p>either an integer vector with length 1 or a character vector of
length 1 specifying where to add <code>value</code>. If an integer vector, it is the
position of a row. If a character vector it is the row with that name.
Similar to <code>append</code>, use 0L if you want the added rows to be first.</p>
</td></tr>
<tr><td><code id="rbind+2B26lt+2B3B-_+3A_row.nm">row.nm</code></td>
<td>
<p>character vector of length equal to <code>NROW(value)</code> that
specifies the rownames of <code>value</code> once added to <code>data</code> as columns.
This is an optional argument that defaults to NULL where the pre-existing rownames
of <code>value</code> are used.</p>
</td></tr>
<tr><td><code id="rbind+2B26lt+2B3B-_+3A_overwrite">overwrite</code></td>
<td>
<p>logical vector of length 1 specifying whether rows from
<code>value</code> or <code>row.nm</code> should overwrite rows in <code>data</code> with the
same rownames. Note, if <code>overwrite</code> = FALSE, R will prevent repeat rownames
by adding &quot;1&quot; to the end of the repeat rownames similar to <code>rbind</code>.</p>
</td></tr>
<tr><td><code id="rbind+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>data.frame, matrix, or atomic vector to be added as rows to
<code>data</code>. If a data.frame or matrix, it must have the same ncol as <code>data</code>.
If an atomic vector, it must have length equal to ncol of <code>data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some traditional R folks may find this function uncomfortable. R is famous for limiting
side effects, except for a few notable exceptions (e.g., <code>`[&lt;-`</code> and <code>`names&lt;-`</code>).
Part of the reason is that side effects can be computationally inefficient in R.
The entire object often has to be re-constructed and re-saved to memory. For
example, a more computationally efficient alternative to rbind(dat) &lt;- add1;
rbind(dat) &lt;- add2; rbind(dat) &lt;- add3 is dat1 &lt;- do.call(what = rbind,
args = list(dat, add1, add2, add3)). However, <code>`rbind&lt;-`</code> was not created
for R programming use when computational efficiency is valued; it is created
for R interactive use when user convenience is valued.
</p>
<p>Similar to <code>`rbind`</code>, <code>`rbind&lt;-`</code> works with both data.frames and matrices.
This is because <code>`rbind`</code> is a generic function with a default method that
works with matrices and a data.frame method that works with data.frames. Similar
to <code>`rbind`</code>, if rownames of <code>value</code> are not given and <code>row.nm</code>
is left NULL, then the rownames of the return object are automatically created
and can be dissatisfying.
</p>


<h3>Value</h3>

<p>Like other similar functions (e.g., <code>`names&lt;-`</code> and <code>`[&lt;-`</code>),
<code>`rbind&lt;-`</code> does not appear to have a return object. However, it technically
does as a side effect. The argument <code>data</code> will have been changed such that
<code>value</code> has been added as rows. If a traditional return object is desired,
and no side effects, then it can be called like a traditional function:
dat2 &lt;- 'rbind&lt;-'(dat1, value = add1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>attitude2 &lt;- attitude
rbind(attitude2) &lt;- colMeans(attitude2) # defaults to rownames = as.character(nrow(`data`) + 1)
attitude2 &lt;- attitude2[!(`%in%`(x = row.names(attitude2), table = "31")), ] # logical subset
rbind(attitude2, row.nm = "mean") &lt;- colMeans(attitude2)
attitude2 &lt;- attitude2[-1*(match(x = "mean", table = row.names(attitude2))), ] # position subset
rbind(attitude2, after = "10", row.nm = c("mean","sum")) &lt;-
   rbind(colMeans(attitude2), colSums(attitude2)) # `value` as a matrix
attitude2 &lt;- attitude2[grep(pattern = "mean|sum", x = row.names(attitude2),
   invert = TRUE), ] # rownames subset
attitude2 &lt;- `rbind&lt;-`(data = attitude2, value = colMeans(attitude2)) # traditional call
attitude2 &lt;- as.matrix(attitude, rownames.force = TRUE) # as.matrix.data.frame
rbind(attitude2, after = "10", row.nm = "mean") &lt;- colMeans(attitude2) # `data` as a matrix
# using overwrite
mtcars2 &lt;- mtcars
rownames(mtcars2)
add &lt;- mtcars[c("Mazda RX4","Mazda RX4 Wag","Datsun 710"), ]*11
rbind(mtcars2, overwrite = TRUE) &lt;- add
mtcars2 &lt;- mtcars
rbind(mtcars2, overwrite = FALSE) &lt;- add
</code></pre>

<hr>
<h2 id='sn'>Set a Vector's Names as its Elements</h2><span id='topic+sn'></span>

<h3>Description</h3>

<p><code>sn</code> sets a vector's names as its elements. It is a simple utility function
equal to <code>setNames(x, nm = as.character(x))</code>. This is particularly useful
when using <code>lapply</code> and you want the return object to have <code>X</code> as its names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sn(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sn_+3A_x">x</code></td>
<td>
<p>atomic or list vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with the elements of <code>x</code> as its names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sn(1:10)
sn(c("one","two","three"))
</code></pre>

<hr>
<h2 id='stack2'>Stack one Set of Variables from Wide to Long</h2><span id='topic+stack2'></span>

<h3>Description</h3>

<p><code>stack2</code> converts one set of variables in a data.frame from wide to long format.
(If you want to convert *multiple* sets of variables from wide to long, see
<code>reshape</code>.) It is a modified version of <code>stack</code> that 1) adds a column for
the rownames, 2) returns character vectors rather than factors, 3) can return
additional (repeated) columns, and 4) can order by rownames original
positions rather than the variable names being stacked call order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack2(
  data,
  select.nm,
  keep.nm = pick(x = names(data), val = select.nm, not = TRUE),
  rtn.el.nm = "el",
  rtn.vrbnames.nm = "vrb_names",
  rtn.rownames.nm = "row_names",
  order.by.rownames = TRUE,
  stringsAsFactors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stack2_+3A_data">data</code></td>
<td>
<p>data.frame of data.</p>
</td></tr>
<tr><td><code id="stack2_+3A_select.nm">select.nm</code></td>
<td>
<p>character vector of colnames from <code>data</code> specifying the
variables to be stacked.</p>
</td></tr>
<tr><td><code id="stack2_+3A_keep.nm">keep.nm</code></td>
<td>
<p>optional argument containing a character vector of colnames from
<code>data</code> specifying the additional columns to be included in the return object.
These columns are repeated down the data.frame as they are not stacked together.
The default is the inclusion of all other columns in <code>data</code> other than
<code>select.nm</code>. If NULL, then no other columns will be included.</p>
</td></tr>
<tr><td><code id="stack2_+3A_rtn.el.nm">rtn.el.nm</code></td>
<td>
<p>character vector of length 1 specifying the name of the column
in the return object that corresponds to the elements of the stacked variables.</p>
</td></tr>
<tr><td><code id="stack2_+3A_rtn.vrbnames.nm">rtn.vrbnames.nm</code></td>
<td>
<p>character vector of length 1 specifying the name of the column
in the return object that corresponds to the names of the stacked variables.</p>
</td></tr>
<tr><td><code id="stack2_+3A_rtn.rownames.nm">rtn.rownames.nm</code></td>
<td>
<p>character vector of length 1 specifying the name of the column
in the return object that corresponds to the rownames.</p>
</td></tr>
<tr><td><code id="stack2_+3A_order.by.rownames">order.by.rownames</code></td>
<td>
<p>logical vector of length 1 specifying whether the returned
data.frame should be ordered by the positions of the rownames (TRUE) or by the
positions of the names of the stacked variables (i.e., <code>select.nm</code>). Note,
the ordering is by the *positions*, not by alphabetical order. If that is desired,
convert the rownames to a (id) column and use <code>reshape::melt.data.frame</code>.</p>
</td></tr>
<tr><td><code id="stack2_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical vector of length 1 specifying whether the
<code>rtn.vrbnames.nm</code> and <code>rtn.rownames.nm</code> columns should be converted
to factors. Note, the factor levels are ordered by positions and not alphabetically
(see <code>v2fct</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stack2</code> is also very similar to <code>reshape::melt.data.frame</code>. The
differences are that it 1) adds a column for the rownames, 2) returns character
vectors rather than factors, and 3) can order by rownames original positions
rather than the variable names being stacked call order.
</p>


<h3>Value</h3>

<p>data.frame with nrow = <code>nrow(data) * length(`select.nm`)</code> from stacking the
elements of <code>data[select.nm]</code> on top of one another. The first column is
the rownames with name <code>rtn.rownames.nm</code>, the second column is the names
of the stacked variables with name <code>rtn.vrbnames.nm</code>, the third column is
the stacked elements with name <code>rtn.el.nm</code>, and the additional columns
are those specified by <code>keep.nm</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unstack2">unstack2</a></code>
<code><a href="utils.html#topic+stack">stack</a></code>
<code><a href="reshape.html#topic+melt.data.frame">melt.data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# general
stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"))
stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"), rtn.el.nm = "rating", rtn.vrbnames.nm = "item",
   rtn.rownames.nm = "row_names") # change the return object colnames
stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = pick(x = names(mtcars), val = c("disp","hp","drat","wt","qsec"),
   not = TRUE)) # include all columns from `data` in the return object

# keep options
stack2(data = mtcars, select.nm = c("mpg","cyl","disp")
   ) # default = keep all other variables in `data`
stack2(data = mtcars, select.nm = c("mpg","cyl","disp"), keep = c("gear","carb")
   ) # character vector = keep only specified variables in `data`
stack2(data = mtcars, select.nm = c("mpg","cyl","disp"), keep = NULL,
   ) # NULL = keep no other variables in `data`

# compare to utils:::stack.data.frame and reshape::melt.data.frame
ChickWeight2 &lt;- as.data.frame(datasets::ChickWeight)
ChickWeight2$"Diet" &lt;- as.integer(ChickWeight2$"Diet")
x &lt;- stack(x = ChickWeight2, select = c("weight","Diet")) # does not allow
   # keeping additional columns
y &lt;- reshape::melt(data = ChickWeight2, measure.vars = c("weight","Diet"),
   id.nm = c("Chick","Time"), variable_name = "vrb_names") # does not include
   # rownames and not ordered by rownames
z &lt;- stack2(data = ChickWeight2, select.nm = c("weight","Diet"),
   keep.nm = c("Chick","Time"))
head(x); head(y); head(z)
</code></pre>

<hr>
<h2 id='t_list'>Transpose a List</h2><span id='topic+t_list'></span>

<h3>Description</h3>

<p><code>t_list</code> transposes a list, similar to what <code>t.default</code> does for matrices.
<code>t_list</code> assumes the structure of each <code>x</code> element is the same. Tests
are done to ensure the lengths and names are the same for each <code>x</code> element.
The returned list has list elements in the same order as in <code>x[[1]]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_list(x, rtn.atomic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="t_list_+3A_x">x</code></td>
<td>
<p>list where each element has the same structure.</p>
</td></tr>
<tr><td><code id="t_list_+3A_rtn.atomic">rtn.atomic</code></td>
<td>
<p>logical vector of length 1 specifying whether the returned list
should be a list of atomic vectors (TRUE) rather than a list of lists (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any element within <code>x</code> has no names (NULL), then the transposition is
done based on positions. If all element within <code>x</code> have the same names,
then the transposition is done based on those names.
</p>


<h3>Value</h3>

<p>list where each element is from those in <code>x[[1]]</code> and each element
of the returned object has a subelement for each element in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# modeling example
iris_bySpecies &lt;- split(x = iris, f = iris$"Species")
lmObj_bySpecies &lt;- lapply(X = iris_bySpecies, FUN = function(dat) {
   lm(Sepal.Length ~ Petal.Width, data = dat)})
lmEl_bySpecies &lt;- t_list(lmObj_bySpecies)
summary(lmObj_bySpecies); summary(lmEl_bySpecies)
summary.default(lmEl_bySpecies[[1]]); summary.default(lmEl_bySpecies[[2]])

# no names
lmObj_bySpecies2 &lt;- unname(lapply(X = lmObj_bySpecies, FUN = unname))
lmEl_bySpecies2 &lt;- t_list(lmObj_bySpecies2)
summary(lmObj_bySpecies2); summary(lmEl_bySpecies2)
summary.default(lmEl_bySpecies2[[1]]); summary.default(lmEl_bySpecies2[[2]])
all(unlist(Map(name = lmEl_bySpecies, nameless = lmEl_bySpecies2,
   f = function(name, nameless) all.equal(unname(name), nameless)))) # is everything
   # but the names the same?

# atomic vector example
x &lt;- list("A" = c("a"=1,"b"=2,"c"=3),"B" = c("a"=1,"b"=2,"c"=3),
   "C" = c("a"=1,"b"=2,"c"=3))
t_list(x, rtn.atomic = TRUE)

# names in different positions
x &lt;- list("A" = c("a"=1,"b"=2,"c"=3),"B" = c("b"=2,"a"=1,"c"=3),
   "C" = c("c"=3,"b"=2,"a"=1))
t_list(x, rtn.atomic = TRUE)

# no names
x &lt;- list(c(1,2,3), c(1,2,3), c(1,2,3))
t_list(x, rtn.atomic = TRUE)

# lists with a single element
x &lt;- list("A" = c("a"=1,"b"=2,"c"=3))
t_list(lmObj_bySpecies[1])
</code></pre>

<hr>
<h2 id='try_expr'>Add Try to Expression</h2><span id='topic+try_expr'></span>

<h3>Description</h3>

<p><code>try_expr</code> evaluates an expression <code>expr</code> and returns a list with three
elements: 1) return object, 2) warning message, 3) error message. This can be
useful when you want to evaluate an expression and are not sure if it will result
in a warning and/or error and don't want R to stop if an error does arise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_expr(expr, output.class = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try_expr_+3A_expr">expr</code></td>
<td>
<p>expression</p>
</td></tr>
<tr><td><code id="try_expr_+3A_output.class">output.class</code></td>
<td>
<p>character vector of length 1 specifying the class you want
the returned object of <code>try_expr</code> to be. The default is NULL for no class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is heavily based on the following StackOverflow post:
https://stackoverflow.com/questions/4948361/how-do-i-save-warnings-and-errors-as-output-from-a-function.
</p>


<h3>Value</h3>

<p>list object with three elements: &quot;result&quot; = 1) return object of <code>expr</code>,
&quot;warning&quot; = warning message, &quot;error&quot; = error message. When an element is not
relevant (e.g., no errors), then that element is NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># apply to log()
try_expr(log(1))
try_expr(log(0))
try_expr(log(-1))
try_expr(log("a"))
# return a list where NULL if an error or warning appears
lapply(X = list("positive" = 1, "zero" = 0, "negative" = -1,"letter" = "a"),
   FUN = function(x) {
      log_try &lt;- try_expr(log(x))
      result &lt;- log_try[["result"]]
      warning &lt;- log_try[["warning"]]
      error &lt;- log_try[["error"]]
      if (!(is.null(error))) return(NULL)
      if (!(is.null(warning))) return(NULL)
      return(result)
})
</code></pre>

<hr>
<h2 id='try_fun'>Add Try to Function</h2><span id='topic+try_fun'></span>

<h3>Description</h3>

<p><code>try_fun</code> creates a version of the function <code>fun</code> that evaluates the
function and then returns a list with three elements: 1) return object, 2) warning
message, 3) error message. This can be useful when you want to apply a function
and are not sure if it will result in a warning and/or error and don't want R
to stop if an error does arise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_fun(fun, output.class = paste0(deparse(substitute(fun)), ".try"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try_fun_+3A_fun">fun</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="try_fun_+3A_output.class">output.class</code></td>
<td>
<p>character vector of length 1 specifying the class you want
the result from a call to the returned function to be. Note, if <code>fun</code>
is an annonymous function, then the default will probably not work due to the
character limitations of deparsing a function. You can always put down NULL for
no class, which will always work with annonymous functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is heavily based on the following StackOverflow post:
https://stackoverflow.com/questions/4948361/how-do-i-save-warnings-and-errors-as-output-from-a-function.
</p>


<h3>Value</h3>

<p>function that returns a list object with three elements: &quot;result&quot; = 1)
return object of <code>fun</code>, &quot;warning&quot; = warning message, &quot;error&quot; = error message.
When an element is not relevant (e.g., no errors), then that element is NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># apply to log()
log.try &lt;- try_fun(log)
log.try(1)
log.try(0)
log.try(-1)
log.try("a")
# return a list where NULL if an error or warning appears
lapply(X = list("positive" = 1, "zero" = 0, "negative" = -1,"letter" = "a"),
   FUN = function(x) {
      log_try &lt;- log.try(x)
      result &lt;- log_try[["result"]]
      warning &lt;- log_try[["warning"]]
      error &lt;- log_try[["error"]]
      if (!(is.null(error))) return(NULL)
      if (!(is.null(warning))) return(NULL)
      return(result)
})
</code></pre>

<hr>
<h2 id='undim'>Undimension an Object</h2><span id='topic+undim'></span>

<h3>Description</h3>

<p><code>undim</code> removes all dimensions from an object. This is particularly useful
for simplifying 1D arrays where the dimnames from the array are used for the
returned object. Although the function can also be used when dimensions were
temporarily (or erroneously) given to an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="undim_+3A_x">x</code></td>
<td>
<p>object with dimensions (usually an array of some kind)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> without any dimensions. If <code>x</code> is an array, then the return
object will be an atomic vector. If <code>x</code> is a 1D array, then the returned
vector will have names = the 1D dimnames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(NA, dim = 1, dimnames = list("A"))
v &lt;- undim(a)
str(a); str(v)
</code></pre>

<hr>
<h2 id='undimlabel'>Undimlabel an Object</h2><span id='topic+undimlabel'></span>

<h3>Description</h3>

<p><code>undimname</code> removes dimlabels from an object. This function is to allow
for removing dimlabels from only certain dimensions specified by <code>dims</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undimlabel(x, dims = seq_along(dim(x)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="undimlabel_+3A_x">x</code></td>
<td>
<p>object with dimlabels (usually an array of some kind)</p>
</td></tr>
<tr><td><code id="undimlabel_+3A_dims">dims</code></td>
<td>
<p>integer vector of dimension positions or character vector of dimlabels
specifying the dimensions for which dimlabels should be removed. Defaults to all dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> without any dimlabels for the dimensions specified by <code>dims</code>.
Consistent with how base R handles removed dimlabels, the removed dimlabels are
converted to NA. If all dimlabels are removed, then the dimlabels are empty (aka NULL).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matrix
m &lt;- array(rep.int(NA, times = 4), dim = c(2,2),
   dimnames = list("lower" = c("a","b"),"UPPER" = c("A","B")))
dimlabels(m)
m2 &lt;- undimlabel(m) # remove dimlabels from both dimensions
dimlabels(m2)
m3 &lt;- undimlabel(m, dims = 1) # remove dimlabels from only the first dimenion
dimlabels(m3)
m4 &lt;- undimlabel(m, dims = "lower")
dimlabels(m4)
all.equal(m3, m4) # same return object
# array
a &lt;- unclass(HairEyeColor)
dimlabels(a)
a2 &lt;- undimlabel(a) # removes dimlabels from all dimensions
dimlabels(a2)
a3 &lt;- undimlabel(a, dims = c(1,2)) # remove dimlabels from only the first and second dimenions
dimlabels(a3)
a4 &lt;- undimlabel(a, dims = c("Hair","Eye"))
dimlabels(a4)
all.equal(a3, a4)
</code></pre>

<hr>
<h2 id='undimname'>Undimname an Object</h2><span id='topic+undimname'></span>

<h3>Description</h3>

<p><code>undimname</code> removes dimnames from an object. This function is to allow
for removing dimnames from only certain dimensions specified by <code>dims</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undimname(x, dims = seq_along(dim(x)), rm.dim.lab = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="undimname_+3A_x">x</code></td>
<td>
<p>object with dimnames (usually an array of some kind)</p>
</td></tr>
<tr><td><code id="undimname_+3A_dims">dims</code></td>
<td>
<p>integer vector of dimension positions or character vector of dimlabels
specifying the dimensions for which dimnames should be removed. Defaults to all dimensions.</p>
</td></tr>
<tr><td><code id="undimname_+3A_rm.dim.lab">rm.dim.lab</code></td>
<td>
<p>logical vector of length 1 specifying whether the dimlabels from
the <code>dims</code> dimensions should be removed and converted to NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> without any dimnames for the dimensions specified by <code>dims</code>.
If a dimlabel existed for the <code>dims</code> dimensions, they will have been removed
if <code>rm.dim.lab</code> = TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matrix
m &lt;- array(rep.int(NA, times = 4), dim = c(2,2),
   dimnames = list("lower" = c("a","b"),"UPPER" = c("A","B")))
dimnames(m)
m1 &lt;- undimname(m) # remove dimnames from both dimensions
dimnames(m1)
m2 &lt;- undimname(m, rm.dim.lab = FALSE) # keep dimlabels
dimnames(m2)
m3 &lt;- undimname(m, dims = 1) # remove dimnames from only the first dimenion
dimnames(m3)
m4 &lt;- undimname(m, dims = "lower")
dimnames(m4)
all.equal(m3, m4) # same return object
m5 &lt;- undimname(m, dims = 1, rm.dim.lab = FALSE) # keeps dimlabel
dimnames(m5)
# array
a &lt;- unclass(HairEyeColor)
dimnames(a)
a1 &lt;- undimname(a) # removes dimnames from all dimensions
dimnames(a1)
a2 &lt;- undimname(a, rm.dim.lab = FALSE) # keep dimlabels
dimnames(a2)
a3 &lt;- undimname(a, dims = c(1,2)) # remove dimnames from only the first and second dimenions
dimnames(a3)
a4 &lt;- undimname(a, dims = c("Hair","Eye"))
dimnames(a4)
all.equal(a3, a4)
a5 &lt;- undimname(a, dims = c(1,2), rm.dim.lab = FALSE) # keeps dimlabel
dimnames(a5)
</code></pre>

<hr>
<h2 id='unstack2'>Unstack one Set of Variables from Long to Wide</h2><span id='topic+unstack2'></span>

<h3>Description</h3>

<p><code>unstack2</code> converts one set of variables in a data.frame from long to wide format.
(If you want to convert multiple sets of variables from long to wide, see
<code><a href="stats.html#topic+reshape">reshape</a></code>.) It is a modified version of <code>unstack</code> that 1) requires a
column for the rownames of the data.frame (or equivalently an id column with
unique values for each row in the wide format) before it was stacked, 2) can
retain additional columns not being unstacked, and 3) can order by rownames
original positions rather than their alphanumerical order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unstack2(
  data,
  rownames.nm = "row_names",
  vrbnames.nm = "vrb_names",
  el.nm = "el",
  keep.nm = pick(x = names(data), val = c(rownames.nm, vrbnames.nm, el.nm), not = TRUE),
  add.missing = TRUE,
  rownamesAsColumn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unstack2_+3A_data">data</code></td>
<td>
<p>data.frame of data containing stacked variables.</p>
</td></tr>
<tr><td><code id="unstack2_+3A_rownames.nm">rownames.nm</code></td>
<td>
<p>character vector of length 1 specifying the colname in
<code>data</code> for whom its unique values correspond to the rows in the return object.</p>
</td></tr>
<tr><td><code id="unstack2_+3A_vrbnames.nm">vrbnames.nm</code></td>
<td>
<p>character vector of length 1 specifying the colname in
<code>`data`</code> that contains the names of the variables to be unstacked.</p>
</td></tr>
<tr><td><code id="unstack2_+3A_el.nm">el.nm</code></td>
<td>
<p>character vector of length 1 specifying the colname in <code>data</code>
containing the elements from the variable to be unstacked.</p>
</td></tr>
<tr><td><code id="unstack2_+3A_keep.nm">keep.nm</code></td>
<td>
<p>optional argument containing a character vector of colnames from
<code>data</code> specifying the additional columns to be included in the return object.
The default is all the other columns in the data.frame besides <code>rownames.nm</code>,
<code>vrbnames.nm</code>, and <code>el.nm</code>. If NULL, then no additional columns are retained.
The <code>keep.nm</code> columns will be the last (aka most right) columns in the return object.</p>
</td></tr>
<tr><td><code id="unstack2_+3A_add.missing">add.missing</code></td>
<td>
<p>logical vector of length 1 specifying whether missing values
should be added when unstacking. This will occur if there are unequal number of
rows for each variable in the set. If FALSE, an error will be returned when
there are an unequal number of rows and missing values would need to be added
to create the returned data.frame.</p>
</td></tr>
<tr><td><code id="unstack2_+3A_rownamesascolumn">rownamesAsColumn</code></td>
<td>
<p>logical vector of length 1 specifying whether the unique
values in <code>rownames.nm</code> column should be a column in the return object (TRUE)
or the rownames of the return object (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unstack2</code> is also very similar to <code>reshape::cast.data.frame</code>. The
differences are that it 1) can return the rownames as rownames of the returned
data.frame rather than an id column, 2) can retain additional columns not being
unstacked, and 3) can order by rownames original positions rather than the variable
names being stacked call order.
</p>


<h3>Value</h3>

<p>data.frame with nrow = <code>length(unique(data[[rownames.nm]]))</code> from
unstacking the elements of <code>el.nm</code> alongside one another. New columns are
created for each unique value in <code>vrbnames.nm</code> as well as columns for any
colnames additional specified by <code>keep.nm</code>. If <code>rownamesAsColumn</code> = TRUE,
then the first column is the unique values in <code>rownames.nm</code>; otherwise,
they are the rownames of the return object (default).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stack2">stack2</a></code>
<code><a href="utils.html#topic+unstack">unstack</a></code>
<code><a href="reshape.html#topic+cast">cast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ordered by rownames
stacked &lt;- stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"), order.by.rownames = TRUE)
x &lt;- unstack2(stacked)
# ordered by vrbnames
stacked &lt;- stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"), order.by.rownames = FALSE)
y &lt;- unstack2(stacked)
identical(x, y)

# rownames as a column
z &lt;- unstack2(data = stacked, rownamesAsColumn = TRUE)

# compare to utils:::unstack.data.frame and reshape::cast
stacked &lt;- stack2(data = mtcars, select.nm = c("disp","hp","drat","wt","qsec"),
   keep.nm = c("vs","am"))
x &lt;- unstack(x = stacked, form = el ~ vrb_names) # automatically sorts the colnames alphabetically
y &lt;- reshape::cast(data = stacked, formula = row_names ~ vrb_names,
   value = "el") # automatically sorts the rownames alphabetically
z &lt;- unstack2(stacked) # is able to keep additional variables
head(x); head(y); head(z)

# unequal number of rows for each unique value in `data`[[`vrbnames.nm`]]
# this can occur if you are using unstack2 without having called stack2 right before
row_keep &lt;- sample(1:nrow(stacked), size = nrow(stacked) / 2)
stacked_rm &lt;- stacked[row_keep, ]
unstack2(data = stacked_rm, rownames.nm = "row_names", vrbnames.nm = "vrb_names", el.nm = "el")
## Not run:  # error when `add.missing` = FALSE
   unstack2(data = stacked_rm, rownames.nm = "row_names", vrbnames.nm = "vrb_names",
      el.nm = "el", add.missing = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='v2d'>(Atomic) Vector to Data-Frame</h2><span id='topic+v2d'></span>

<h3>Description</h3>

<p><code>v2m</code> converts an (atomic) vector to a single row or single column data.frame.
The benefit of <code>v2m</code> over <code>as.data.frame.vector</code> is that the dimension
along which the vector is binded can be either rows or columns, whereas in
<code>as.data.frame.vector</code> it can only be binded along a column, and that
<code>v2m</code> will keep the names of <code>v</code> in the dimnames of the returned
data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v2d(v, along = 2, rtn.dim.nm = NULL, stringsAsFactors = FALSE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="v2d_+3A_v">v</code></td>
<td>
<p>(atomic) vector.</p>
</td></tr>
<tr><td><code id="v2d_+3A_along">along</code></td>
<td>
<p>numeric vector of length 1 that is equal to either 1 or 2 specifying
which dimension to bind <code>v</code> along. 1 means that <code>v</code> is binded along
rows (i.e., dimension 1) into a one row data.frame. 2 means that <code>v</code> is binded
along columns (i.e., dimension 2) into a one column data.frame.</p>
</td></tr>
<tr><td><code id="v2d_+3A_rtn.dim.nm">rtn.dim.nm</code></td>
<td>
<p>character vector of length 1 specifying what dimname to use
for the dimension of length 1 in the returned data.frame. If <code>along</code> = 1,
then <code>rtn.dim.nm</code> will be the single rowname. If <code>along</code> = 2, then
<code>rtn.dim.nm</code> will be the single colname. If NULL, then the dimension of
length 1 will be created by default with <code>data.frame</code> internally, which
will have the rowname be &quot;1&quot; and the colname &quot;V1&quot;.</p>
</td></tr>
<tr><td><code id="v2d_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical vector of length 1 specifying if <code>v</code>
should be converted to a factor in the case that typeof is character.</p>
</td></tr>
<tr><td><code id="v2d_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>v</code> is an atomic vector.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with typeof = <code>typeof(v)</code>. If <code>along</code> = 1, then the
dimensions = <code>c(1L, length(v))</code> and dimnames = <code>list(rtn.dim.nm, names(v))</code>.
If <code>along</code> = 2, then the dimensions = <code>c(length(v), 1L)</code> and dimnames =
<code>list(names(v), rtn.dim.nm)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- setNames(mtcars[, "mpg"], nm = row.names(mtcars))
v2d(x)
v2d(v = x, along = 1)
v2d(v = x, rtn.dim.nm = "mpg")
</code></pre>

<hr>
<h2 id='v2fct'>Character Vector to (Unordered) Factor</h2><span id='topic+v2fct'></span>

<h3>Description</h3>

<p><code>v2fct</code> converts a character vector to a (unordered) factor. It goes
beyond <code>as.factor</code> by allowing you to specify how you want the levels ordered
and whether you want NA treated as a level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v2fct(
  v,
  order.lvl = "position",
  decreasing = FALSE,
  na.lvl = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="v2fct_+3A_v">v</code></td>
<td>
<p>character vector. If it is not a character vector (e.g., factor,
numeric vector), then it is coerced to a character vector within <code>v2fct</code>.</p>
</td></tr>
<tr><td><code id="v2fct_+3A_order.lvl">order.lvl</code></td>
<td>
<p>character vector of length 1 specifying how you want to order
the levels of the factor. The options are &quot;alphanum&quot;, which sorts the levels
alphanumerically (with NA last); &quot;position&quot;, which sorts the levels by the position
the level first appears; &quot;frequency&quot;, which sorts the levels by their frequency.
If any frequencies are tied, then the ties are sorted alphanumerically (with NA last).</p>
</td></tr>
<tr><td><code id="v2fct_+3A_decreasing">decreasing</code></td>
<td>
<p>logical vector of length 1 specifying whether the ordering of the
levels should be decreasing (TRUE) rather than increasing (FALSE).</p>
</td></tr>
<tr><td><code id="v2fct_+3A_na.lvl">na.lvl</code></td>
<td>
<p>logical vector of length 1 specifying if NA should be considered a level.</p>
</td></tr>
<tr><td><code id="v2fct_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>v</code> is an atomic vector.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>order.lvl</code> = &quot;alpanum&quot; the levels are sorted alphabetically if letters
or a combination of letters and numbers/numerals are in present in <code>v</code>.
If only numbers/numerals are present in <code>v</code>, then levels are sorted numerically.
</p>


<h3>Value</h3>

<p>factor of length = <code>length(x)</code> and names = <code>names(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no missing values
state_region &lt;- as.character(state.region)
v2fct(state_region, order.lvl = "position") # in position order
v2fct(v = state_region, order.lvl = "frequency",
   decreasing = TRUE) # most frequent to least frequent
v2fct(v = state_region, order.lvl = "alphanum") # in alphanumerical order
v2fct(v = state_region, na.lvl = TRUE) # na.lvl is inert because no NAs in `v`
# with missing values
state_region &lt;- c(NA_character_, as.character(state.region), NA_character_)
v2fct(v = state_region, order.lvl = "position", na.lvl = TRUE)
v2fct(v = state_region, order.lvl = "frequency", decreasing = TRUE, na.lvl = TRUE)
v2fct(v = state_region, order.lvl = "alphanum", na.lvl = TRUE)
identical(x = v2fct(v = state_region, order.lvl = "alphanum"),
   y = as.factor(state_region)) # equal to as.factor()
# numeric vectors
v2fct(v = round(faithful$"eruptions"), order.lvl = "position")
v2fct(v = round(faithful$"eruptions"), order.lvl = "frequency", decreasing = TRUE)
v2fct(v = round(faithful$"eruptions"), order.lvl = "alphanum")
# cnumeric vectors
cnum &lt;- c("100","99","10","9","1","0","100","99","10","9","1","0")
factor(cnum) # not in numerical order
v2fct(v = cnum, order.lvl = "alphanum") # yes in numerical order
# ties on frequency
v2fct(v = rev(npk$"block"), order.lvl = "alphanum") # ties sorted alphanumerically
v2fct(v = rev(npk$"block"), order.lvl = "position") # no possibility of ties
</code></pre>

<hr>
<h2 id='v2frm'>Character Vector to Formula</h2><span id='topic+v2frm'></span>

<h3>Description</h3>

<p><code>v2frm</code> converts a character vector to a formula. The formula has the
simple structure of y ~ x1 + x2 + x3 + ... + xn. This function is a simple
wrapper for <code>reformulate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v2frm(v, y = 1L, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="v2frm_+3A_v">v</code></td>
<td>
<p>character vector of term(s) and/or response to be included on either
side of the returned formula. If it is not a character vector (e.g., factor,
numeric vector), then it is coerced to a character vector within <code>v2frm</code>.
Note, if the length of <code>v</code> is 1, then <code>y.which</code> must be NULL because
at least one term on the right hand side is required, otherwise an error is returned.</p>
</td></tr>
<tr><td><code id="v2frm_+3A_y">y</code></td>
<td>
<p>character vector of length 1 specifying the value of the element
within <code>v</code>, or integer of length 1 specifying the position of the element
within <code>v</code>, that is the response to be placed on the left hand side of the
returned formula. If NULL, then no elements of <code>v</code> are treated as response(s)
and the left hand side is empty.</p>
</td></tr>
<tr><td><code id="v2frm_+3A_intercept">intercept</code></td>
<td>
<p>logical vector of length 1 specifying whether the intercept should
be included in the returned formula. The default is TRUE and no change is made
to the returned formula. If FALSE, then a -1 is added to the end of the right hand side.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formula with element <code>v[y]</code> on the left hand side and <code>v[-y]</code>
elements on the right hand side (rhs) separated by plus signs (+) with a -1
if <code>intercept</code> = FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v2frm(v = names(attitude))
v2frm(v = names(attitude), y = 7L)
v2frm(v = names(attitude), y = NULL)
v2frm(v = "rating", y = NULL)
try_expr(v2frm(v = "rating")) # error is returned
</code></pre>

<hr>
<h2 id='v2lv'>(Atomic) Vector to List of (Atomic) Vectors</h2><span id='topic+v2lv'></span>

<h3>Description</h3>

<p><code>v2lv</code> converts a (atomic) vector to a list of atomic vectors. The default is
conversion to a list vector where each element of the list has only one element.
The <code>n.break</code> argument allows for the input vector to be broken up into
larger sections with each section being a list element in the return object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v2lv(v, use.names = TRUE, n.break = 1L, warn.break = TRUE, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="v2lv_+3A_v">v</code></td>
<td>
<p>(atomic) vector.</p>
</td></tr>
<tr><td><code id="v2lv_+3A_use.names">use.names</code></td>
<td>
<p>logical vector of length 1 specifying whether the names from
<code>v</code> should be retained in the return object.</p>
</td></tr>
<tr><td><code id="v2lv_+3A_n.break">n.break</code></td>
<td>
<p>integer vector of length 1 specifying how <code>v</code> should be broken
up. Every <code>n.break</code> elements while seq_along <code>v</code>, a new element of the list
is created and subsequent elements of <code>v</code> are stored there. If <code>n.break</code>
is not a multiple of <code>length(v)</code>, then NAs are appended to the end of <code>v</code>
to ensure that each list element has (atomic) vectors of the same length. Note, the
default is 1L resulting in a list vector.</p>
</td></tr>
<tr><td><code id="v2lv_+3A_warn.break">warn.break</code></td>
<td>
<p>logical vector of length one specifying whether a warning
should be printed if <code>length(v) / n.break</code> is not a whole number, which
would then result in NAs being appended to the end of the vector before converting
to a list.</p>
</td></tr>
<tr><td><code id="v2lv_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>v</code> is an atomic vector.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Future versions of this function plan to allow for use similar to the <code>utils::relist</code>
function to allow reconstruction after flattening a matrix-like object to a single vector.
</p>


<h3>Value</h3>

<p>list of (atomic) vectors that are the elements of <code>v</code> broken up
according to <code>n.break</code>. The list only has names if <code>v</code> has names and
<code>n.break</code> = 1L.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec &lt;- setNames(object = mtcars[[1]], nm = row.names(mtcars))
v2lv(vec)
v2lv(vec, use.names = FALSE)
vec &lt;- unlist(mtcars)
v2lv(vec, n.break = 32) # n.break &gt; 1L and multiple of length(v)
v2lv(vec, n.break = 30) # n.break &gt; 1L and NOT multiple of length(v)
</code></pre>

<hr>
<h2 id='v2m'>(Atomic) Vector to Matrix</h2><span id='topic+v2m'></span>

<h3>Description</h3>

<p><code>v2m</code> converts an (atomic) vector to a single row or single column matrix.
The matrix will be the same typeof as the atomic vector. The benefit of <code>v2m</code>
over <code>as.matrix.default</code> is that the dimension along which the vector is binded
can be either rows or columns, whereas in <code>as.matrix.default</code> it can only
be binded along a column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v2m(v, along = 2, rtn.dim.nm = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="v2m_+3A_v">v</code></td>
<td>
<p>(atomic) vector.</p>
</td></tr>
<tr><td><code id="v2m_+3A_along">along</code></td>
<td>
<p>numeric vector of length 1 that is equal to either 1 or 2 specifying
which dimension to bind <code>v</code> along. 1 means that <code>v</code> is binded along
rows (i.e., dimension 1) into a one row matrix. 2 means that <code>v</code> is binded
along columns (i.e., dimension 2) into a one column matrix.</p>
</td></tr>
<tr><td><code id="v2m_+3A_rtn.dim.nm">rtn.dim.nm</code></td>
<td>
<p>character vector of length 1 specifying what dimname to use
for the dimension of length 1 in the returned matrix. If <code>along</code> = 1,
then <code>rtn.dim.nm</code> will be the single rowname. If <code>along</code> = 2, then
<code>rtn.dim.nm</code> will be the single colname. If NULL, then the dimension of
length 1 has no dimname.</p>
</td></tr>
<tr><td><code id="v2m_+3A_check">check</code></td>
<td>
<p>logical vector of length 1 specifying whether to check the structure
of the input arguments. For example, check whether <code>v</code> is an atomic vector.
This argument is available to allow flexibility in whether the user values
informative error messages (TRUE) vs. computational efficiency (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with typeof = <code>typeof(v)</code>. If <code>along</code> = 1, then the
dimensions = <code>c(1L, length(v))</code> and dimnames = <code>list(rtn.dim.nm, names(v))</code>.
If <code>along</code> = 2, then the dimensions = <code>c(length(v), 1L)</code> and dimnames =
<code>list(names(v), rtn.dim.nm)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars2 &lt;- as.matrix(mtcars, rownames.force = TRUE) # to make sure dimnames stay in the example
v2m(mtcars2[, "mpg"])
identical(x = v2m(mtcars2[, "mpg"]),
   y = as.matrix(mtcars2[, "mpg"])) # default = as.matrix.default()
v2m(mtcars2[, "mpg"], along = 1)
identical(x = v2m(mtcars2[, "mpg"], along = 1),
   y = t(as.matrix(mtcars2[, "mpg"]))) # = t(as.matrix.default())
v2m(v = mtcars2[, "mpg"], rtn.dim.nm = "mpg")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
