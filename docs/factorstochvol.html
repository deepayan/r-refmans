<!DOCTYPE html><html><head><title>Help for package factorstochvol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {factorstochvol}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#factorstochvol-package'><p>Bayesian Estimation of (Sparse) Latent Factor Stochastic</p>
Volatility Models through MCMC</a></li>
<li><a href='#comtimeplot'><p>Plot communalities over time.</p></a></li>
<li><a href='#corelement'><p>Extract &quot;true&quot; model-implied correlations of two series only</p></a></li>
<li><a href='#corimageplot'><p>Plot correlation matrices for certain points in time</p></a></li>
<li><a href='#cormat'><p>Generic extraction of correlation matrix</p></a></li>
<li><a href='#cormat.fsvdraws'><p>Extract posterior draws of the model-implied correlation matrix</p></a></li>
<li><a href='#cormat.fsvsim'><p>Extract &quot;true&quot; model-implied correlation matrix for several points in time</p></a></li>
<li><a href='#corplot'><p>Plots pairwise correlations over time</p></a></li>
<li><a href='#cortimeplot'><p>Plot correlations over time.</p></a></li>
<li><a href='#covelement'><p>Extract &quot;true&quot; model-implied covariances of two series only</p></a></li>
<li><a href='#covmat'><p>Generic extraction of covariance matrix</p></a></li>
<li><a href='#covmat.fsvdraws'><p>Extract posterior draws of the model-implied covariance matrix</p></a></li>
<li><a href='#covmat.fsvsim'><p>Extract &quot;true&quot; model-implied covariance matrix for several points in time</p></a></li>
<li><a href='#evdiag'><p>Plots posterior draws and posterior means of the eigenvalues of crossprod(facload)</p></a></li>
<li><a href='#expweightcov'><p>Computes the empirical exponentially weighted covariance matrix</p></a></li>
<li><a href='#facloadcredplot'><p>Displays bivariate marginal posterior distribution of factor loadings.</p></a></li>
<li><a href='#facloaddensplot'><p>Density plots of factor loadings draws</p></a></li>
<li><a href='#facloadpairplot'><p>Displays bivariate marginal posterior distributions of factor loadings.</p></a></li>
<li><a href='#facloadpointplot'><p>Displays point estimates of the factor loadings posterior.</p></a></li>
<li><a href='#facloadtraceplot'><p>Trace plots of factor loadings draws</p></a></li>
<li><a href='#findrestrict'><p>Ad-hoc method for (weakly) identifying the factor</p>
loadings matrix</a></li>
<li><a href='#fsvsample'><p>Markov Chain Monte Carlo (MCMC) Sampling for the Factor Stochastic</p>
Volatility Model.</a></li>
<li><a href='#fsvsim'><p>Simulate data from a factor SV model</p></a></li>
<li><a href='#ledermann'><p>Ledermann bound for the number of factors</p></a></li>
<li><a href='#logret'><p>Compute the log returns of a vector-valued time series</p></a></li>
<li><a href='#logvartimeplot'><p>Plot log-variances over time.</p></a></li>
<li><a href='#orderident'><p>A posteriori factor order identification</p></a></li>
<li><a href='#paratraceplot'><p>Trace plots of parameter draws.</p></a></li>
<li><a href='#plot.fsvdraws'><p>Default factor SV plot</p></a></li>
<li><a href='#plotalot'><p>Several factor SV plots useful for model diagnostics</p></a></li>
<li><a href='#predcond'><p>Predicts means and variances conditionally on the factors</p></a></li>
<li><a href='#predcor'><p>Predicts correlation matrix</p></a></li>
<li><a href='#predcov'><p>Predicts covariance matrix</p></a></li>
<li><a href='#predh'><p>Predicts factor and idiosyncratic log-volatilities h</p></a></li>
<li><a href='#predloglik'><p>Evaluates the predictive log likelihood using the predicted</p>
covariance matrix</a></li>
<li><a href='#predloglikWB'><p>Evaluates the predictive log likelihood using the Woodbury identity</p></a></li>
<li><a href='#predprecWB'><p>Predicts precision matrix and its determinant (Woodbury variant)</p></a></li>
<li><a href='#preorder'><p>Ad-hoc methods for determining the order of variables</p></a></li>
<li><a href='#print.fsvdraws'><p>Pretty printing of an fsvsdraws object</p></a></li>
<li><a href='#runningcormat'><p>Extract summary statistics for the posterior correlation matrix</p>
which have been stored during sampling</a></li>
<li><a href='#runningcovmat'><p>Extract summary statistics for the posterior covariance matrix</p>
which have been stored during sampling</a></li>
<li><a href='#signident'><p>A posteriori sign identification</p></a></li>
<li><a href='#voltimeplot'><p>Plot series-specific volatilities over time.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Estimation of (Sparse) Latent Factor Stochastic
Volatility Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Markov chain Monte Carlo (MCMC) sampler for fully Bayesian estimation of latent factor stochastic volatility models with interweaving &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1322091">doi:10.1080/10618600.2017.1322091</a>&gt;. Sparsity can be achieved through the usage of Normal-Gamma priors on the factor loading matrix &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2018.11.007">doi:10.1016/j.jeconom.2018.11.007</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>GIGrvg (&ge; 0.4), Rcpp (&ge; 1.0.0), corrplot, methods,
grDevices, graphics, stats, utils, stochvol (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>LSD (&ge; 4.0-0), coda (&ge; 0.19-2), knitr, RColorBrewer,
testthat (&ge; 2.1.0), zoo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.9.900), stochvol</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>best</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-24 09:49:56 UTC; grkastner</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregor Kastner <a href="https://orcid.org/0000-0002-8237-8271"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Darjus Hosszejni <a href="https://orcid.org/0000-0002-3803-691X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Luis Gruber <a href="https://orcid.org/0000-0002-2399-738X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregor Kastner &lt;gregor.kastner@aau.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-24 11:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='factorstochvol-package'>Bayesian Estimation of (Sparse) Latent Factor Stochastic
Volatility Models through MCMC</h2><span id='topic+factorstochvol-package'></span>

<h3>Description</h3>

<p>This packages provides a Markov chain Monte Carlo (MCMC) sampler
for fully Bayesian estimation of latent factor stochastic volatility
models. Sparsity can be achieved through the usage of Normal-Gamma
priors on the factor loadings matrix.
</p>


<h3>Details</h3>

<p>In recent years, multivariate factor stochastic volatility (SV)
models have been increasingly used to analyze financial and economic
time series because they can capture joint (co-)volatility dynamics
by a small number of latent time-varying factors. The main advantage
of such a model is its parsimony, as all variances and covariances
of a time series vector are governed by a low-dimensional common factor
with the components following independent SV models. For problems of
this kind, MCMC is a very efficient estimation method, it is however
associated with a considerable computational burden when the number
of assets is moderate to large. To overcome this, the latent volatility
states are drawn &quot;all without a loop&quot; (AWOL), ancillarity-sufficiency
interweaving strategies (ASIS) are applied to sample the univariate
components as well as the factor loadings. Thus, this package can
be applied directly estimate time-varying covariance and correlation
matrices for medium-and high-dimensional time series. To guarantee
sparsity, a hierarchical Normal-Gamma prior can be used for the
factor loadings matrix which shrinks the unnecessary factor loadings
towards zero.
</p>


<h3>Note</h3>

<p>This package is currently in active development; the interface
of some of the functions might change.
Moreover, even though I tried to carefully check everything,
factorstochvol may still contain
typos, inconsistencies, or even bugs. Your comments and suggestions
are warmly welcome!
</p>


<h3>Author(s)</h3>

<p>Gregor Kastner <a href="mailto:gregor.kastner@wu.ac.at">gregor.kastner@wu.ac.at</a>
</p>


<h3>References</h3>

<p>Kastner, G., Frühwirth-Schnatter, S., and Lopes, H.F. (2017).
Efficient Bayesian Inference for Multivariate Factor Stochastic Volatility Models.
<em>Journal of Computational and Graphical Statistics</em>, <b>26</b>(4), 905&ndash;917,
<a href="https://doi.org/10.1080/10618600.2017.1322091">doi:10.1080/10618600.2017.1322091</a>.
</p>
<p>Kastner, G. (2019). Sparse Bayesian Time-Varying Covariance Estimation
in Many Dimensions. <em>Journal of Econometrics</em>, <b>210</b>(1), 98&ndash;115.
<a href="https://doi.org/10.1016/j.jeconom.2018.11.007">doi:10.1016/j.jeconom.2018.11.007</a>.
</p>
<p>Kastner, G. and Frühwirth-Schnatter, S. (2014). Ancillarity-Sufficiency
Interweaving Strategy (ASIS) for Boosting MCMC Estimation of Stochastic
Volatility Models. <em>Computational Statistics and Data Analysis</em>,
<a href="https://doi.org/10.1016/j.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stochvol.html#topic+stochvol-package">stochvol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)

# simulate data from a (small) factor SV model:
sim &lt;- fsvsim(series = 5, factors = 2)

# estimate the model (CAVEAT: only few draws!)
res &lt;- fsvsample(sim$y, factors = 2, draws = 2000, burnin = 500)

# plot implied volas overtime:
voltimeplot(res)

# plot correlation matrix at some points in time:
par(mfrow = c(2,2))
corimageplot(res, seq(1, nrow(sim$y), length.out = 4),
             fsvsimobj = sim, plotCI = 'circle',
             plotdatedist = -2)


# plot (certain) covariances and correlations over time
par(mfrow = c(2,1))
covtimeplot(res, 1)
cortimeplot(res, 1)

# plot (all) correlations over time
corplot(res, fsvsimobj = sim, these = 1:10)

# plot factor loadings
par(mfrow = c(1,1))
facloadpointplot(res, fsvsimobj = sim)
facloadpairplot(res)
facloadcredplot(res)
facloaddensplot(res, fsvsimobj = sim)

# plot latent log variances
logvartimeplot(res, fsvsimobj = sim, show = "fac")
logvartimeplot(res, fsvsimobj = sim, show = "idi")

# plot communalities over time
comtimeplot(res, fsvsimobj = sim, show = 'joint')
comtimeplot(res, fsvsimobj = sim, show = 'series')


</code></pre>

<hr>
<h2 id='comtimeplot'>Plot communalities over time.</h2><span id='topic+comtimeplot'></span>

<h3>Description</h3>

<p><code>comtimeplot</code> plots the communalities over time, i.e. the
series-specific percentage of variance explained through the common factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comtimeplot(
  x,
  fsvsimobj = NULL,
  show = "series",
  maxrows = 5,
  ylim = c(0, 100)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comtimeplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="comtimeplot_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>Object of class <code>'fsvsim'</code> (or <code>NULL</code>), usually
resulting from a call to <code><a href="#topic+fsvsim">fsvsim</a></code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="comtimeplot_+3A_show">show</code></td>
<td>
<p>Indicator whether to show joint (<code>'joint'</code>), series-specific
(<code>'series'</code>), or both (<code>'both'</code>) communalities.</p>
</td></tr>
<tr><td><code id="comtimeplot_+3A_maxrows">maxrows</code></td>
<td>
<p>Single positive integer denoting the maximum number of series
in each plot. Defaults to 5.</p>
</td></tr>
<tr><td><code id="comtimeplot_+3A_ylim">ylim</code></td>
<td>
<p>Vector of length two denoting the range of the horizontal axis.
Defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays the joint (average) communalities over time and all
series-specific communalities. If communalities haven't been stored during
sampling, <code>comtimeplot</code> produces an error.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='corelement'>Extract &quot;true&quot; model-implied correlations of two series only</h2><span id='topic+corelement'></span>

<h3>Description</h3>

<p><code>corelement</code> extracts the model-implied (time-varying) correlations between
(exactly) two component series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corelement(x, i, j, these = seq_len(nrow(x$y)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corelement_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvsim'</code>, usually resulting from a call
of the function <code><a href="#topic+fsvsim">fsvsim</a></code>.</p>
</td></tr>
<tr><td><code id="corelement_+3A_i">i</code></td>
<td>
<p>Index of component series 1.</p>
</td></tr>
<tr><td><code id="corelement_+3A_j">j</code></td>
<td>
<p>Index of component series 2.</p>
</td></tr>
<tr><td><code id="corelement_+3A_these">these</code></td>
<td>
<p>Vector indicating which points in time should be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the requested correlations.
</p>


<h3>See Also</h3>

<p>Other simulation: 
<code><a href="#topic+cormat.fsvsim">cormat.fsvsim</a>()</code>,
<code><a href="#topic+covelement">covelement</a>()</code>,
<code><a href="#topic+covmat.fsvsim">covmat.fsvsim</a>()</code>
</p>

<hr>
<h2 id='corimageplot'>Plot correlation matrices for certain points in time</h2><span id='topic+corimageplot'></span>

<h3>Description</h3>

<p><code>corimageplot</code> plots the model-implied correlation matrices
for one or several points in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corimageplot(
  x,
  these = seq_len(nrow(x$y)),
  order = "original",
  these4order = these,
  plotdatedist = 0,
  plotCI = "n",
  date.cex = 1.5,
  col = NULL,
  fsvsimobj = NULL,
  plottype = "corrplot",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corimageplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_these">these</code></td>
<td>
<p>Index vector containing the time points to plot. Defaults
to <code>seq_len(nrow(x$y))</code>.</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_order">order</code></td>
<td>
<p>String, where <code>'none'</code> and <code>'original'</code>
indicate not to mess
with the series ordering. Other keywords
(e.g. <code>'hclust'</code>) will be forwarded to
<code><a href="corrplot.html#topic+corrMatOrder">corrMatOrder</a></code>.</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_these4order">these4order</code></td>
<td>
<p>Index vector containing the time points used for
ordering. Probably, the default (<code>these</code>) is what you want.</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_plotdatedist">plotdatedist</code></td>
<td>
<p>Numerical value indicating where the dates should
be plotted.</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_plotci">plotCI</code></td>
<td>
<p>String. If not equal to 'n', posterior credible regions are
added (posterior mean +/- 2 posterior sd). Ignored if <code>plottype</code> is
&quot;imageplot&quot;.</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_date.cex">date.cex</code></td>
<td>
<p>Size multiplier for the dates.</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_col">col</code></td>
<td>
<p>Color palette or NULL (the default).</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>To indicate data generating values in case of simulated
data, pass an object of type <code>fsvsim</code> (usually the result of a
call to <code><a href="#topic+fsvsim">fsvsim</a></code>).</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_plottype">plottype</code></td>
<td>
<p>Indicates which type of plot should be drawn. Can be
&quot;corrplot&quot; for <code><a href="corrplot.html#topic+corrplot">corrplot</a></code> (recommended for up to around
20 series), or &quot;imageplot&quot; for a simpler <code><a href="graphics.html#topic+image">image</a></code> plot.</p>
</td></tr>
<tr><td><code id="corimageplot_+3A_...">...</code></td>
<td>
<p>Additional parameters will be passed on to
<code><a href="corrplot.html#topic+corrplot">corrplot</a></code>. Ignored if <code>plottype</code> is
&quot;imageplot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>Note</h3>

<p>If correlations haven't been stored during sampling,
<code>corimageplot</code> produces an error.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='cormat'>Generic extraction of correlation matrix</h2><span id='topic+cormat'></span>

<h3>Description</h3>

<p>Generic function for extracting model-implied correlation matrices, either
from the MCMC output, or from the simulated model. Details about the
function's behavior can be found in  <code><a href="#topic+cormat.fsvdraws">cormat.fsvdraws</a></code>
(the function invoked when applied to MCMC output) or
<code><a href="#topic+cormat.fsvsim">cormat.fsvsim</a></code> (the function invoked when applied to a
simulated model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cormat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cormat_+3A_x">x</code></td>
<td>
<p>An object of class <code>fsvdraws</code> or <code>fsvsim</code>.</p>
</td></tr>
<tr><td><code id="cormat_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Structure containing the model-implied covariance matrix.
</p>


<h3>See Also</h3>

<p>Other generics: 
<code><a href="#topic+covmat">covmat</a>()</code>
</p>

<hr>
<h2 id='cormat.fsvdraws'>Extract posterior draws of the model-implied correlation matrix</h2><span id='topic+cormat.fsvdraws'></span>

<h3>Description</h3>

<p><code>cormat</code> extracts draws from the model-implied correlation matrix
from an <code>fsvdraws</code> object for all points in time which have been
stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsvdraws'
cormat(x, timepoints = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cormat.fsvdraws_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
of <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="cormat.fsvdraws_+3A_timepoints">timepoints</code></td>
<td>
<p>Vector indicating at which point(s) in time (of those that
have been stored during sampling) the correlation matrices should be extracted.
Can also be &quot;all&quot; or &quot;last&quot;.</p>
</td></tr>
<tr><td><code id="cormat.fsvdraws_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of dimension <code>m</code> times <code>m</code> times <code>draws</code>
times <code>timepoints</code> containing the posterior draws for the
model-implied covariance matrix.
</p>


<h3>Note</h3>

<p>Currently crudely implemented as a double loop in pure R,
may be slow.
</p>


<h3>See Also</h3>

<p>Other extractors: 
<code><a href="#topic+covmat.fsvdraws">covmat.fsvdraws</a>()</code>,
<code><a href="#topic+runningcormat">runningcormat</a>()</code>,
<code><a href="#topic+runningcovmat">runningcovmat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
sim &lt;- fsvsim(n = 500, series = 3, factors = 1) # simulate
res &lt;- fsvsample(sim$y, factors = 1, keeptime = "all") # estimate
cors &lt;- cormat(res, "last") # extract

# Trace plot of determinant of posterior correlation matrix
# at time t = n = 500:
detdraws &lt;- apply(cors[,,,1], 3, det)
ts.plot(detdraws)
abline(h = mean(detdraws), col = 2)          # posterior mean
abline(h = median(detdraws), col = 4)        # posterior median
abline(h = det(cormat(sim, "last")[,,1]), col = 3) # implied by DGP

# Trace plot of draws from posterior correlation of Sim1 and Sim2 at
# time t = n = 500:
ts.plot(cors[1,2,,1])
abline(h = cormat(sim, "last")[1,2,1], col = 3) # "true" value

# Smoothed kernel density estimate:
plot(density(cors[1,2,,1], adjust = 2))

# Summary statistics:
summary(cors[1,2,,1])


</code></pre>

<hr>
<h2 id='cormat.fsvsim'>Extract &quot;true&quot; model-implied correlation matrix for several points in time</h2><span id='topic+cormat.fsvsim'></span>

<h3>Description</h3>

<p><code>cormat</code> extracts the model-implied (time-varying) covariance matrix
from an <code>fsvsim</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsvsim'
cormat(x, timepoints = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cormat.fsvsim_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvsim'</code>, usually resulting from a call
of the function <code><a href="#topic+fsvsim">fsvsim</a></code>.</p>
</td></tr>
<tr><td><code id="cormat.fsvsim_+3A_timepoints">timepoints</code></td>
<td>
<p>Vector indicating at which point(s) in time the
correlation matrices should be extracted. Can also be &quot;all&quot; or &quot;last&quot;.</p>
</td></tr>
<tr><td><code id="cormat.fsvsim_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of dimension <code>m</code> times <code>m</code> times
<code>length(timepoints)</code>, containing the model-implied correlation matrix.
</p>


<h3>Note</h3>

<p>Currently crudely implemented as an R loop over all time points,
may be slow.
</p>


<h3>See Also</h3>

<p>Other simulation: 
<code><a href="#topic+corelement">corelement</a>()</code>,
<code><a href="#topic+covelement">covelement</a>()</code>,
<code><a href="#topic+covmat.fsvsim">covmat.fsvsim</a>()</code>
</p>

<hr>
<h2 id='corplot'>Plots pairwise correlations over time</h2><span id='topic+corplot'></span>

<h3>Description</h3>

<p><code>corplot</code> gives an overview of (certain) pairwise correlations.
Throws a warning if these haven't been stored during sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corplot(
  x,
  fsvsimobj = NULL,
  these = 1:(ncol(x$y) * (ncol(x$y) - 1)/2),
  start = 1,
  end = nrow(x$y),
  maxrows = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="corplot_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>To indicate data generating values in case of simulated
data, pass an object of type <code>fsvsim</code> (usually the result of a
call to <code><a href="#topic+fsvsim">fsvsim</a></code>).</p>
</td></tr>
<tr><td><code id="corplot_+3A_these">these</code></td>
<td>
<p>Indicator which correlations should be plotted. Default is all.</p>
</td></tr>
<tr><td><code id="corplot_+3A_start">start</code></td>
<td>
<p>First point in time to plot.</p>
</td></tr>
<tr><td><code id="corplot_+3A_end">end</code></td>
<td>
<p>Last point in time to plot.</p>
</td></tr>
<tr><td><code id="corplot_+3A_maxrows">maxrows</code></td>
<td>
<p>The maximum number of rows per page.</p>
</td></tr>
<tr><td><code id="corplot_+3A_...">...</code></td>
<td>
<p>Other arguments will be passed on to <code><a href="stats.html#topic+ts.plot">ts.plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='cortimeplot'>Plot correlations over time.</h2><span id='topic+cortimeplot'></span><span id='topic+covtimeplot'></span>

<h3>Description</h3>

<p><code>cortimeplot</code> draws correlations over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cortimeplot(
  x,
  series,
  these = seq_len(nrow(x$y)),
  type = "cor",
  statistic = "mean"
)

covtimeplot(
  x,
  series,
  these = seq_len(nrow(x$y)),
  type = "cov",
  statistic = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cortimeplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="cortimeplot_+3A_series">series</code></td>
<td>
<p>Single number, coercible to integer. Indicates the series
relative to which correlations are drawn.</p>
</td></tr>
<tr><td><code id="cortimeplot_+3A_these">these</code></td>
<td>
<p>Index vector containing the time points to plot. Defaults
to <code>seq_len(nrow(x$y))</code>.</p>
</td></tr>
<tr><td><code id="cortimeplot_+3A_type">type</code></td>
<td>
<p>What to plot, usually &quot;cor&quot; or &quot;cov&quot;.</p>
</td></tr>
<tr><td><code id="cortimeplot_+3A_statistic">statistic</code></td>
<td>
<p>Which posterior summary should be plotted, usually &quot;mean&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays one component series' time-varying correlations with
the other components series. Throws an error if correlations haven't been
stored during sampling.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='covelement'>Extract &quot;true&quot; model-implied covariances of two series only</h2><span id='topic+covelement'></span>

<h3>Description</h3>

<p><code>covelement</code> extracts the model-implied (time-varying) covariances between
(exactly) two component series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covelement(x, i, j, these = seq_len(nrow(x$y)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covelement_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvsim'</code>, usually resulting from a call
of the function <code><a href="#topic+fsvsim">fsvsim</a></code>.</p>
</td></tr>
<tr><td><code id="covelement_+3A_i">i</code></td>
<td>
<p>Index of component series 1.</p>
</td></tr>
<tr><td><code id="covelement_+3A_j">j</code></td>
<td>
<p>Index of component series 2.</p>
</td></tr>
<tr><td><code id="covelement_+3A_these">these</code></td>
<td>
<p>Vector indicating which points in time should be extracted,
defaults to all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with the requested covariances.
</p>


<h3>See Also</h3>

<p>Other simulation: 
<code><a href="#topic+corelement">corelement</a>()</code>,
<code><a href="#topic+cormat.fsvsim">cormat.fsvsim</a>()</code>,
<code><a href="#topic+covmat.fsvsim">covmat.fsvsim</a>()</code>
</p>

<hr>
<h2 id='covmat'>Generic extraction of covariance matrix</h2><span id='topic+covmat'></span>

<h3>Description</h3>

<p>Generic function for extracting model-implied covariance matrices, either
from the MCMC output, or from the simulated model. Details about the
function's behavior can be found in  <code><a href="#topic+covmat.fsvdraws">covmat.fsvdraws</a></code>
(the function invoked when applied to MCMC output) or
<code><a href="#topic+covmat.fsvsim">covmat.fsvsim</a></code> (the function invoked when applied to a
simulated model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmat_+3A_x">x</code></td>
<td>
<p>An object of class <code>fsvdraws</code> or <code>fsvsim</code>.</p>
</td></tr>
<tr><td><code id="covmat_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Structure containing the model-implied covariance matrix.
</p>


<h3>See Also</h3>

<p>Other generics: 
<code><a href="#topic+cormat">cormat</a>()</code>
</p>

<hr>
<h2 id='covmat.fsvdraws'>Extract posterior draws of the model-implied covariance matrix</h2><span id='topic+covmat.fsvdraws'></span>

<h3>Description</h3>

<p><code>covmat</code> extracts draws from the model-implied covariance matrix
from an <code>fsvdraws</code> object for all points in time which have been
stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsvdraws'
covmat(x, timepoints = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmat.fsvdraws_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
of <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="covmat.fsvdraws_+3A_timepoints">timepoints</code></td>
<td>
<p>Vector indicating at which point(s) in time (of those that
have been stored during sampling) the correlation matrices should be
extracted. Can also be &quot;all&quot; or &quot;last&quot;.</p>
</td></tr>
<tr><td><code id="covmat.fsvdraws_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of dimension <code>m</code> times <code>m</code> times <code>draws</code>
times <code>timepoints</code> containing the posterior draws for the
model-implied covariance matrix.
</p>


<h3>Note</h3>

<p>Currently crudely implemented as a double loop in pure R,
may be slow.
</p>


<h3>See Also</h3>

<p>Other extractors: 
<code><a href="#topic+cormat.fsvdraws">cormat.fsvdraws</a>()</code>,
<code><a href="#topic+runningcormat">runningcormat</a>()</code>,
<code><a href="#topic+runningcovmat">runningcovmat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
sim &lt;- fsvsim(n = 500, series = 3, factors = 1) # simulate
res &lt;- fsvsample(sim$y, factors = 1, keeptime = "all") # estimate
covs &lt;- covmat(res, "last") # extract

# Trace plot of determinant of posterior covariance matrix
# at time t = n = 500:
detdraws &lt;- apply(covs[,,,1], 3, det)
ts.plot(detdraws)
abline(h = mean(detdraws), col = 2)          # posterior mean
abline(h = median(detdraws), col = 4)        # posterior median
abline(h = det(covmat(sim, "last")[,,1]), col = 3) # implied by DGP

# Trace plot of draws from posterior covariance of Sim1 and Sim2 at
# time t = n = 500:
ts.plot(covs[1,2,,1])
abline(h = covmat(sim, "last")[1,2,1], col = 3) # "true" value

# Smoothed kernel density estimate:
plot(density(covs[1,2,,1], adjust = 2))

# Summary statistics:
summary(covs[1,2,,1])


</code></pre>

<hr>
<h2 id='covmat.fsvsim'>Extract &quot;true&quot; model-implied covariance matrix for several points in time</h2><span id='topic+covmat.fsvsim'></span>

<h3>Description</h3>

<p><code>covmat</code> extracts the model-implied (time-varying) covariance matrix
from an <code>fsvsim</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsvsim'
covmat(x, timepoints = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covmat.fsvsim_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvsim'</code>, usually resulting from a call
of the function <code><a href="#topic+fsvsim">fsvsim</a></code>.</p>
</td></tr>
<tr><td><code id="covmat.fsvsim_+3A_timepoints">timepoints</code></td>
<td>
<p>Vector indicating at which point(s) in time the
correlation matrices should be extracted. Can also be &quot;all&quot; or &quot;last&quot;.</p>
</td></tr>
<tr><td><code id="covmat.fsvsim_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of dimension <code>m</code> times <code>m</code> times
<code>length(timepoints)</code>, containing the model-implied covariance matrix.
</p>


<h3>Note</h3>

<p>Currently crudely implemented as an R loop over all time points,
may be slow.
</p>


<h3>See Also</h3>

<p>Other simulation: 
<code><a href="#topic+corelement">corelement</a>()</code>,
<code><a href="#topic+cormat.fsvsim">cormat.fsvsim</a>()</code>,
<code><a href="#topic+covelement">covelement</a>()</code>
</p>

<hr>
<h2 id='evdiag'>Plots posterior draws and posterior means of the eigenvalues of crossprod(facload)</h2><span id='topic+evdiag'></span>

<h3>Description</h3>

<p><code>evdiag</code> computes, returns, and visualizes the eigenvalues of crossprod(facload).
This can be used as a rough guide to choose the numbers of factors in a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evdiag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evdiag_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a matrix with posterior samples of the eigenvalues of
crossprod(facload)
</p>


<h3>Note</h3>

<p>Experimental feature. Please be aware that - for the sake of simplicity and
interpretability - both the time-varying idiosyncratic as well as the time-varying
factor volatilities are simply ignored.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='expweightcov'>Computes the empirical exponentially weighted covariance matrix</h2><span id='topic+expweightcov'></span>

<h3>Description</h3>

<p>A common way to get estimates for time-varying covariance matrices
is the compute the exponentially weighted empirical covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expweightcov(dat, alpha = 4/126, hist = 180)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expweightcov_+3A_dat">dat</code></td>
<td>
<p>Matrix containing the data, with <code>n</code> rows
(points in time) and <code>m</code> columns (component series).</p>
</td></tr>
<tr><td><code id="expweightcov_+3A_alpha">alpha</code></td>
<td>
<p>Speed of decay.</p>
</td></tr>
<tr><td><code id="expweightcov_+3A_hist">hist</code></td>
<td>
<p>How far to go back in time?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>m</code> times <code>m</code> covariance matrix estimate.
</p>

<hr>
<h2 id='facloadcredplot'>Displays bivariate marginal posterior distribution of factor loadings.</h2><span id='topic+facloadcredplot'></span>

<h3>Description</h3>

<p><code>facloadcredplot</code> illustrates the bivariate marginals of the
factor loadings distribution. It is a monochrome variant of
<code><a href="#topic+facloadpairplot">facloadpairplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facloadcredplot(x, quants = c(0.01, 0.99))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facloadcredplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="facloadcredplot_+3A_quants">quants</code></td>
<td>
<p>Posterior quantiles to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='facloaddensplot'>Density plots of factor loadings draws</h2><span id='topic+facloaddensplot'></span>

<h3>Description</h3>

<p><code>facloaddensplot</code> draws kernel smoothed density plots of the marginal
factor loadings posterior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facloaddensplot(x, fsvsimobj = NULL, rows = 5, thesecols = NULL, xlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facloaddensplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="facloaddensplot_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>To indicate data generating values in case of simulated
data, pass an object of type <code>fsvsim</code> (usually the result of a
call to <code><a href="#topic+fsvsim">fsvsim</a></code>).</p>
</td></tr>
<tr><td><code id="facloaddensplot_+3A_rows">rows</code></td>
<td>
<p>Number of rows per page.</p>
</td></tr>
<tr><td><code id="facloaddensplot_+3A_thesecols">thesecols</code></td>
<td>
<p>Which factor loadings columns should be plotted? Defaults to 1:r.</p>
</td></tr>
<tr><td><code id="facloaddensplot_+3A_xlim">xlim</code></td>
<td>
<p>Vector of length two containing lower and upper bounds of the
horizontal axis. If <code>NULL</code>, these are automatically determined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='facloadpairplot'>Displays bivariate marginal posterior distributions of factor loadings.</h2><span id='topic+facloadpairplot'></span>

<h3>Description</h3>

<p><code>facloadpairplot</code> illustrates the bivariate marginals of the
factor loadings distribution. For a monochrome variant, see
<code><a href="#topic+facloadcredplot">facloadcredplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facloadpairplot(x, maxpoints = 500, alpha = 20/maxpoints, cex = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facloadpairplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="facloadpairplot_+3A_maxpoints">maxpoints</code></td>
<td>
<p>The maximum amount of posterior draws to plot. If
the number of draws stored in <code>x</code> exceeds this number, draws are
thinned accordingly.</p>
</td></tr>
<tr><td><code id="facloadpairplot_+3A_alpha">alpha</code></td>
<td>
<p>Level of transparency.</p>
</td></tr>
<tr><td><code id="facloadpairplot_+3A_cex">cex</code></td>
<td>
<p>Controls the size of the dots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='facloadpointplot'>Displays point estimates of the factor loadings posterior.</h2><span id='topic+facloadpointplot'></span>

<h3>Description</h3>

<p><code>facloadpointplot</code> illustrates point estimates (mean, median, ...)
of the estimated factor loadings matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facloadpointplot(
  x,
  fsvsimobj = NULL,
  statistic = "median",
  cex = 6.5,
  alpha = 0.2,
  allpairs = FALSE,
  col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facloadpointplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="facloadpointplot_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>To indicate data generating values in case of simulated
data, pass an object of type <code>fsvsim</code> (usually the result of a
call to <code><a href="#topic+fsvsim">fsvsim</a></code>).</p>
</td></tr>
<tr><td><code id="facloadpointplot_+3A_statistic">statistic</code></td>
<td>
<p>Character string indicating which posterior statistic
should be displayed.</p>
</td></tr>
<tr><td><code id="facloadpointplot_+3A_cex">cex</code></td>
<td>
<p>Controls the size of the dots.</p>
</td></tr>
<tr><td><code id="facloadpointplot_+3A_alpha">alpha</code></td>
<td>
<p>Controls the level of transparency.</p>
</td></tr>
<tr><td><code id="facloadpointplot_+3A_allpairs">allpairs</code></td>
<td>
<p>Logical value; if set to TRUE, all possible
pairwise combinations will be plotted.</p>
</td></tr>
<tr><td><code id="facloadpointplot_+3A_col">col</code></td>
<td>
<p>Vector of length <code>m</code> (number of component series),
containing <code><a href="grDevices.html#topic+rgb">rgb</a></code>-type color codes used for
plotting. Will be recycled if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly, throws a warning if there aren't any
factors to plot.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='facloadtraceplot'>Trace plots of factor loadings draws</h2><span id='topic+facloadtraceplot'></span>

<h3>Description</h3>

<p><code>facloadtraceplot</code> draws trace plots of the factor loadings. Can be
an important tool to check MCMC convergence if inference about (certain)
factor loadings sought.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>facloadtraceplot(
  x,
  fsvsimobj = NULL,
  thinning = NULL,
  maxrows = 10,
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="facloadtraceplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="facloadtraceplot_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>To indicate data generating values in case of simulated
data, pass an object of type <code>fsvsim</code> (usually the result of a
call to <code><a href="#topic+fsvsim">fsvsim</a></code>).</p>
</td></tr>
<tr><td><code id="facloadtraceplot_+3A_thinning">thinning</code></td>
<td>
<p>Plot every <code>thinning</code>th draw.</p>
</td></tr>
<tr><td><code id="facloadtraceplot_+3A_maxrows">maxrows</code></td>
<td>
<p>Indicates the maximum number of rows to be drawn per page.</p>
</td></tr>
<tr><td><code id="facloadtraceplot_+3A_ylim">ylim</code></td>
<td>
<p>Vector of length two containing lower and upper bounds of the
vertical axis. If <code>NULL</code>, these are automatically determined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='findrestrict'>Ad-hoc method for (weakly) identifying the factor
loadings matrix</h2><span id='topic+findrestrict'></span>

<h3>Description</h3>

<p>In factor SV models, the identification of the factor loadings
matrix is often
chosen through a preliminary static factor analysis.
After a maximum likelihood factor model is fit to the data,
variables are ordered as follows: The variable with the
lowest loadings on all factors except the first (relative to
it) is determined to lead the first factor,
the variable with the lowest loadings on all factors except the
first two (relative to these) is determined to lead the second
factor, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findrestrict(dat, factors, transload = abs, relto = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findrestrict_+3A_dat">dat</code></td>
<td>
<p>Matrix containing the data, with <code>n</code> rows
(points in time) and <code>m</code> columns (component series).</p>
</td></tr>
<tr><td><code id="findrestrict_+3A_factors">factors</code></td>
<td>
<p>Number of factors to be used.</p>
</td></tr>
<tr><td><code id="findrestrict_+3A_transload">transload</code></td>
<td>
<p>Function for transforming the estimated
factor loadings before ordering. Defaults to the absolute value
function.</p>
</td></tr>
<tr><td><code id="findrestrict_+3A_relto">relto</code></td>
<td>
<p>Can be 'none', 'current' or 'all'. If 'none', the series
with the highest loadings is placed first, the series with the second
highest is placed second, and so on.
If 'current', the current factor loading is used as a reference, if 'all',
all previous loadings are summed up to be the reference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>m</code> times <code>factors</code> matrix indicating
the restrictions.
</p>


<h3>Note</h3>

<p>This function is automatically invoked by fsvsample if
restrict is set to 'auto'.
</p>


<h3>See Also</h3>

<p>ledermann
</p>

<hr>
<h2 id='fsvsample'>Markov Chain Monte Carlo (MCMC) Sampling for the Factor Stochastic
Volatility Model.</h2><span id='topic+fsvsample'></span>

<h3>Description</h3>

<p><code>fsvsample</code> simulates from the joint posterior distribution and returns
the MCMC draws. It is the main workhorse to conduct inference for factor
stochastic volatility models in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsvsample(
  y,
  factors = 1,
  draws = 1000,
  thin = 1,
  burnin = 1000,
  restrict = "none",
  zeromean = TRUE,
  priorfacloadtype = "rowwiseng",
  priorfacload = 0.1,
  facloadtol = 1e-18,
  priorng = c(1, 1),
  priormu = c(0, 10),
  priorphiidi = c(10, 3),
  priorphifac = c(10, 3),
  priorsigmaidi = 1,
  priorsigmafac = 1,
  priorh0idi = "stationary",
  priorh0fac = "stationary",
  priorbeta = c(0, 10000),
  keeptime = "last",
  heteroskedastic = TRUE,
  priorhomoskedastic = NA,
  runningstore = 6,
  runningstorethin = 10,
  runningstoremoments = 2,
  signident = TRUE,
  signswitch = FALSE,
  interweaving = 4,
  quiet = FALSE,
  samplefac = TRUE,
  startfac,
  startpara,
  startlogvar,
  startlatent,
  startlogvar0,
  startlatent0,
  startfacload,
  startfacloadvar,
  expert
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsvsample_+3A_y">y</code></td>
<td>
<p>Data matrix. Each of <code>m</code> columns is assumed to contain a single
(univariate) series of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_factors">factors</code></td>
<td>
<p>Number of latent factors to be estimated.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_draws">draws</code></td>
<td>
<p>Number of MCMC draws kept after burn-in.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_thin">thin</code></td>
<td>
<p>Single number greater or equal to 1, coercible to integer.
Every <code>thin</code>th MCMC draw is kept and returned. The default value
is 1, corresponding to no thinning of the draws, i.e. every draw is
stored.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_burnin">burnin</code></td>
<td>
<p>Number of initial MCMC draws to be discarded.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_restrict">restrict</code></td>
<td>
<p>Either &quot;upper&quot;, &quot;none&quot;, or &quot;auto&quot;, indicating whether
the factor loadings
matrix should be restricted to have zeros above the diagonal (&quot;upper&quot;),
whether all elements should be estimated from the data (&quot;none&quot;), or
whether the function <code><a href="#topic+findrestrict">findrestrict</a></code> should be invoked for a
priori finding suitable zeros. Setting
<code>restrict</code> to &quot;upper&quot; or &quot;auto&quot; often stabilizes MCMC
estimation and can be important for identifying the factor loadings matrix,
however, it generally is a strong prior assumption. Setting
<code>restrict</code> to &quot;none&quot; is usually the preferred option if identification
of the factor loadings matrix is of less concern but covariance estimation
or prediction is the goal. Alternatively, <code>restrict</code> can be a
logical matrix
of dimension <code>c(m, r)</code> indicating which elements should be unrestricted
(where <code>restrict</code> is <code>FALSE</code>) or zero (where <code>restrict</code> is
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_zeromean">zeromean</code></td>
<td>
<p>Logical. If <code>FALSE</code>, a constant mean is included in
the model for each of the <code>m</code> univariate series.
If <code>TRUE</code>, the mean is not modeled. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorfacloadtype">priorfacloadtype</code></td>
<td>
<p>Can be <code>"normal"</code>, <code>"rowwiseng"</code>,
<code>"colwiseng"</code>.
</p>

<dl>
<dt><code>"normal"</code>: </dt><dd><p>Normal prior. The value of <code>priorfacload</code>
is interpreted as the standard deviations of the
Gaussian prior distributions for the factor loadings.</p>
</dd>
<dt><code>"rowwiseng"</code>: </dt><dd><p>Row-wise Normal-Gamma prior. The value of <code>priorfacload</code>
is interpreted as the shrinkage parameter <code>a</code>.</p>
</dd>
<dt><code>"colwiseng"</code>: </dt><dd><p>Column-wise Normal-Gamma prior. The value of <code>priorfacload</code>
is interpreted as the shrinkage parameter <code>a</code>.</p>
</dd>
</dl>

<p>For details please see Kastner (2019).</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorfacload">priorfacload</code></td>
<td>
<p>Either a matrix of dimensions <code>m</code> times <code>factors</code>
with positive elements or a single number (which will be recycled accordingly).
The meaning of <code>priorfacload</code> depends on the setting of <code>priorfacloadtype</code>
and is explained there.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_facloadtol">facloadtol</code></td>
<td>
<p>Minimum number that the absolute value of a factor loadings draw can take.
Prevents numerical issues that can appear when strong shrinkage is enforced if chosen
to be greater than zero.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorng">priorng</code></td>
<td>
<p>Two-element vector with positive entries indicating the Normal-Gamma
prior's hyperhyperparameters <code>c</code> and <code>d</code>.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priormu">priormu</code></td>
<td>
<p>Vector of length 2 denoting prior mean and standard deviation
for unconditional levels of the idiosyncratic log variance processes.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorphiidi">priorphiidi</code></td>
<td>
<p>Vector of length 2, indicating the shape parameters for the
Beta prior distributions of the transformed parameters <code>(phi+1)/2</code>, where
<code>phi</code> denotes the persistence of the idiosyncratic log variances.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorphifac">priorphifac</code></td>
<td>
<p>Vector of length 2, indicating the shape parameters for the
Beta prior distributions of the transformed parameters <code>(phi+1)/2</code>, where
<code>phi</code> denotes the persistence of the factor log variances.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorsigmaidi">priorsigmaidi</code></td>
<td>
<p>Vector of length <code>m</code> containing the
prior volatilities of log variances. If <code>priorsigmaidi</code> has exactly
one element, it will be recycled for all idiosyncratic log variances.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorsigmafac">priorsigmafac</code></td>
<td>
<p>Vector of length <code>factors</code> containing the
prior volatilities of log variances. If <code>priorsigmafac</code> has exactly
one element, it will be recycled for all factor log variances.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorh0idi">priorh0idi</code></td>
<td>
<p>Vector of length 1 or <code>m</code>, containing
information about the Gaussian prior for the initial idiosyncratic
log variances.
If an element of <code>priorh0idi</code> is a nonnegative number, the conditional
prior of the corresponding initial log variance h0 is assumed to be Gaussian
with mean 0 and standard deviation <code>priorh0idi</code> times $sigma$.
If an element of
<code>priorh0idi</code> is the string 'stationary', the prior of the corresponding
initial log volatility is taken to be from the stationary distribution, i.e.
h0 is assumed to be Gaussian with mean 0 and variance $sigma^2/(1-phi^2)$.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorh0fac">priorh0fac</code></td>
<td>
<p>Vector of length 1 or <code>factors</code>, containing
information about the Gaussian prior for the initial factor
log variances.
If an element of <code>priorh0fac</code> is a nonnegative number, the conditional
prior of the corresponding initial log variance h0 is assumed to be Gaussian
with mean 0 and standard deviation <code>priorh0fac</code> times $sigma$.
If an element of
<code>priorh0fac</code> is the string 'stationary', the prior of the corresponding
initial log volatility is taken to be from the stationary distribution, i.e.
h0 is assumed to be Gaussian with mean 0 and variance $sigma^2/(1-phi^2)$.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorbeta">priorbeta</code></td>
<td>
<p>numeric vector of length 2, indicating the mean and
standard deviation of the Gaussian prior for the regression parameters. The
default value is <code>c(0, 10000)</code>, which constitutes a very vague prior
for many common datasets. Not used if <code>zeromean</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_keeptime">keeptime</code></td>
<td>
<p>Either a number coercible to a positive integer, or a string
equal to &quot;all&quot; or &quot;last&quot;. If a number different from 1 is provided, only every
<code>keeptime</code>th latent log-volatility is being monitored. If, e.g.,
<code>keeptime = 3</code>, draws for the latent log variances
<code>h_1,h_4,h_7,...</code> will
be kept. If <code>keeptime</code> is set to &quot;all&quot;, this is equivalent to setting it
to 1. If
<code>keeptime</code> is set to &quot;last&quot; (the default), only draws for the very last
latent log variances h_n are kept.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_heteroskedastic">heteroskedastic</code></td>
<td>
<p>Vector of length 1, 2, or <code>m + factors</code>,
containing logical values indicating whether time-varying
(<code>heteroskedastic = TRUE</code>) or constant (<code>heteroskedastic = FALSE</code>)
variance should be estimated.
If <code>heteroskedastic</code> is of length 2 it will be recycled accordingly,
whereby the first element is used for all idiosyncratic variances and
the second element is used for all factor variances.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_priorhomoskedastic">priorhomoskedastic</code></td>
<td>
<p>Only used if at least one element of
<code>heteroskedastic</code> is set to <code>FALSE</code>. In that case,
<code>priorhomoskedastic</code> must be a matrix with positive entries
and dimension c(m, 2). Values in column 1 will be interpreted as the
shape and values in column 2 will be interpreted as the rate parameter
of the corresponding inverse gamma prior distribution of the idisyncratic
variances.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_runningstore">runningstore</code></td>
<td>
<p>Because most machines these days do not have enough memory
to store all draws for all points in time, setting <code>runningstore</code> to an
integer greater than 0 will cause <code>fsvsample</code> to store the first
<code>runningstoremoments</code>
ergodic moments of certain variables of interest. More specifically, mean,
variance, skewness, etc. will be stored for certain variables
if <code>runningstore</code> is set to a value...
</p>

<dl>
<dt><code>&gt;= 1</code>: </dt><dd><p>Latent log variances <code>h_1,h_2,...,h_(n+r)</code>.</p>
</dd>
<dt><code>&gt;= 2</code>: </dt><dd><p>Latent factors <code>f_1,...,f_r</code>.</p>
</dd>
<dt><code>&gt;= 3</code>: </dt><dd><p>Latent volatilities <code>sqrt(exp(h_1,h_2,...,h_(n+r)))</code>.</p>
</dd>
<dt><code>&gt;= 4</code>: </dt><dd><p>Conditional covariance matrix and the square roots of its
diagonal elements.</p>
</dd>
<dt><code>&gt;= 5</code>: </dt><dd><p>Conditional correlation matrix.</p>
</dd>
<dt><code>&gt;= 6</code>: </dt><dd><p>Communalities, i.e. proportions of variances explained
through the common factors.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fsvsample_+3A_runningstorethin">runningstorethin</code></td>
<td>
<p>How often should the calculation of running moments be
conducted? Set to a value &gt; 1 if you want to avoid time consuming calculations
at every MCMC iteration.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_runningstoremoments">runningstoremoments</code></td>
<td>
<p>Selects how many running moments (up to 4) should be
calculated.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_signident">signident</code></td>
<td>
<p>If set to <code>FALSE</code>, no ex-post sign-identification is
performed. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_signswitch">signswitch</code></td>
<td>
<p>Set to <code>TRUE</code> to turn on a random sign switch of
factors and loadings. Note that the signs of each factor loadings matrix column
and the corresponding factor cannot be identified from the likelihood.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_interweaving">interweaving</code></td>
<td>
<p>The following values for interweaving the factor loadings
are accepted:
</p>

<dl>
<dt>0: </dt><dd><p>No interweaving.</p>
</dd>
<dt>1: </dt><dd><p>Shallow interweaving through the diagonal entries.</p>
</dd>
<dt>2: </dt><dd><p>Deep interweaving through the diagonal entries.</p>
</dd>
<dt>3: </dt><dd><p>Shallow interweaving through the largest absolute entries in each column.</p>
</dd>
<dt>4: </dt><dd><p>Deep interweaving through the largest absolute entries in each column.</p>
</dd>
</dl>

<p>For details please see Kastner et al. (2017).
A value of 4 is the highly recommended default.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_quiet">quiet</code></td>
<td>
<p>Logical value indicating whether the progress bar and other
informative output during sampling should be omitted. The default
value is <code>FALSE</code>, implying verbose output.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_samplefac">samplefac</code></td>
<td>
<p>If set to <code>FALSE</code>, the factors are not sampled (but
remain at their starting values forever). This might be useful if one
wants to include observed factors instead of latent ones.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_startfac">startfac</code></td>
<td>
<p><em>optional</em> numeric matrix of dimension
<code>c(factors, n)</code>, containing the starting values of the
latent factors.
In case of a single factor model, a numeric vector of length <code>n</code> is also accepted.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_startpara">startpara</code></td>
<td>
<p><em>optional</em> numeric matrix of dimension
<code>c(3, m + factors)</code>, containing the starting values
for the parameter draws. The first <code>m</code> columns must contain
parameters values corresponding to the idiosyncratic volatilities,
the subsequent <code>factor</code> columns must contain parameter values
corresponding to the factor volatilities. The first row of <code>startpara</code>
corresponds to <code>mu</code>, the level of the log variances (can be arbitrary
numerical values), the second row corresponds to <code>phi</code>, the persistence
parameters of the log variances (numeric values between <code>-1</code> and <code>1</code>),
and the third row corresponds to <code>sigma</code> (positive numeric values).</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_startlogvar">startlogvar</code></td>
<td>
<p><em>optional</em> numeric matrix of dimension
<code>c(n, m + factors)</code>, containing the starting values of the
latent log variances.
The first <code>m</code> rows correspond to the idiosyncratic log variances,
the subsequent <code>factor</code> rows correspond to the factor log variances.
Was previously called startlatent.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_startlatent">startlatent</code></td>
<td>
<p><em>Deprecated.</em> Please use <code>startlogvar</code> instead.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_startlogvar0">startlogvar0</code></td>
<td>
<p><em>optional</em> numeric vector of length
<code>m + factors</code>, containing the starting values of the initial latent
log variances.
The first <code>m</code> elements correspond to the idiosyncratic log variances,
the subsequent <code>factor</code> elements correspond to the factor log variances.
Was previously called startlatent0.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_startlatent0">startlatent0</code></td>
<td>
<p><em>Deprecated.</em> Please use <code>startlogvar0</code> instead.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_startfacload">startfacload</code></td>
<td>
<p><em>optional</em> numeric matrix of dimension
<code>c(m, factors)</code>, containing the starting values of the
factor loadings.
In case of a single factor model, a numeric vector of length <code>n</code> is also accepted.</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_startfacloadvar">startfacloadvar</code></td>
<td>
<p><em>optional</em> numeric matrix of dimension
<code>c(m, factors)</code>, containing the starting values of the
factor loadings variances <code class="reqn">\tau_{ij}^2</code>. Used only when the normal-gamma
prior is employed (priorfacloadtype != &quot;normal&quot;) while ignored when static
loadings variances are used (priorfacloadtype == &quot;normal&quot;).</p>
</td></tr>
<tr><td><code id="fsvsample_+3A_expert">expert</code></td>
<td>
<p><em>optional</em> named list of expert parameters for the
univariate SV models (will be transformed and passed to the <code>stochvol</code> package). For most
applications, the default values probably work best. Interested users are
referred to Kastner and Frühwirth-Schnatter (2014), the package vignette, and Kastner (2016). If
<code>expert</code> is provided, it may contain the following named elements:
</p>

<dl>
<dt><code>parameterization</code>: </dt><dd><p>Character string equal to <code>"centered"</code>,
<code>"noncentered"</code>, <code>"GIS_C"</code>, or <code>"GIS_NC"</code>. Defaults to
<code>"GIS_C"</code>.</p>
</dd>
<dt><code>mhcontrol</code>: </dt><dd><p>Single numeric value controlling the proposal
density of a Metropolis-Hastings (MH) update step when sampling
<code>sigma</code>. If <code>mhcontrol</code> is smaller than 0, an independence
proposal will be used, while values greater than zero control the
stepsize of a log-random-walk proposal. Defaults to <code>-1</code>.</p>
</dd>
<dt><code>gammaprior</code>: </dt><dd><p>Single logical value indicating whether a Gamma
prior for <code>sigma^2</code> should be used. If set to <code>FALSE</code>,
an Inverse Gamma prior is employed. Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>truncnormal</code>: </dt><dd><p>Single logical value indicating whether a
truncated Gaussian distribution should be used as proposal for
draws of <code>phi</code>. If set to <code>FALSE</code>, a regular Gaussian
prior is employed and the draw is immediately discarded when values
outside the unit ball happen to be drawn. Defaults to <code>FALSE</code>.</p>
</dd>
<dt><code>mhsteps</code>: </dt><dd><p>Either <code>1</code>, <code>2</code>, or <code>3</code>. Indicates
the number of blocks used for drawing from the posterior of the
parameters. Defaults to <code>2</code>.</p>
</dd>
<dt><code>proposalvar4sigmaphi</code>: </dt><dd><p>Single positive number indicating the
conditional prior variance of <code>sigma*phi</code> in the ridge
<em>proposal</em> density for sampling <code>(mu, phi)</code>.
Defaults to <code>10^8</code>.</p>
</dd>
<dt><code>proposalvar4sigmatheta</code>: </dt><dd><p>Single positive number indicating
the conditional prior variance of <code>sigma*theta</code> in the ridge
<em>proposal</em> density for sampling <code>(mu, phi)</code>.
Defaults to <code>10^12</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>For details concerning the factor SV algorithm please see
Kastner et al. (2017), details about the univariate SV estimation
can be found in Kastner and Frühwirth-Schnatter (2014).
</p>


<h3>Value</h3>

<p>The value returned is a list object of class <code>fsvdraws</code> holding
</p>

<dl>
<dt><code>facload</code>: </dt><dd><p>Array containing draws from the posterior distribution of the
factor loadings matrix.</p>
</dd>
<dt><code>fac</code>: </dt><dd><p>Array containing factor draws from the posterior distribution.</p>
</dd>
<dt><code>logvar</code>: </dt><dd><p>Array containing idiosyncratic and factor initial log variance draws.</p>
</dd>
<dt><code>logvar0</code>: </dt><dd><p>Array containing idiosyncratic and factor log variance draws.</p>
</dd>
<dt><code>para</code>: </dt><dd><p>Array containing parameter draws form the posterior distribution.</p>
</dd>
<dt><code>y</code>: </dt><dd><p>Matrix containing the data supplied.</p>
</dd>
<dt><code>latestauxiliary</code>: </dt><dd><p>List containing the latest draws of auxiliary quantities used for
sampling the factor loadings matrix.</p>
</dd>
<dt><code>runningstore</code>: </dt><dd><p>List whose elements contain ergodic moments of certain
variables of interest. See argument
<code>runningstore</code> for details about what
is being stored here.</p>
</dd>
<dt><code>config</code>: </dt><dd><p>List containing information on configuration parameters.</p>
</dd>
<dt><code>priors</code>: </dt><dd><p>List containing prior hyperparameter values.</p>
</dd>
<dt><code>identifier</code>: </dt><dd><p>Matrix containing the indices of the series used for
ex-post sign-identification along with the corresponding minimum distances to zero.
See <code><a href="#topic+signident">signident</a></code> for details.</p>
</dd>
</dl>

<p>To display the output, use <code>print</code>, <code>plot</code>, and in particular specialized
extractors and printing functions.
The <code>print</code> method prints a high-level overview; specialized extractors such as
<code><a href="#topic+covmat">covmat</a></code> or <code><a href="#topic+runningcovmat">runningcovmat</a></code> are also available.
The <code>plot</code> method invokes a simple covariance matrix plot; specialized plotting
functions are linked in the documentation of <code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a></code>.
</p>


<h3>References</h3>

<p>Kastner, G., Frühwirth-Schnatter, S., and Lopes, H.F. (2017).
Efficient Bayesian Inference for Multivariate Factor Stochastic Volatility Models.
<em>Journal of Computational and Graphical Statistics</em>, <b>26</b>(4), 905&ndash;917,
<a href="https://doi.org/10.1080/10618600.2017.1322091">doi:10.1080/10618600.2017.1322091</a>.
</p>
<p>Kastner, G. (2019).
Sparse Bayesian Time-Varying Covariance Estimation in Many Dimensions
<em>Journal of Econometrics</em>, <b>210</b>(1), 98&ndash;115,
<a href="https://doi.org/10.1016/j.jeconom.2018.11.007">doi:10.1016/j.jeconom.2018.11.007</a>
</p>
<p>Kastner, G. (2016).
Dealing with stochastic volatility in time series using the R package
stochvol.
<em>Journal of Statistical Software</em>, <b>69</b>(5), 1&ndash;30,
<a href="https://doi.org/10.18637/jss.v069.i05">doi:10.18637/jss.v069.i05</a>.
</p>
<p>Kastner, G. and Frühwirth-Schnatter, S. (2014).
Ancillarity-Sufficiency Interweaving Strategy (ASIS) for Boosting MCMC
Estimation of Stochastic Volatility Models.
<em>Computational Statistics &amp; Data Analysis</em>, <b>76</b>, 408&ndash;423,
<a href="https://doi.org/10.1016/j.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load exchange rate data (ships with stochvol):
data(exrates, package = "stochvol")
exrates$date &lt;- NULL

# Compute the percentage log returns:
dat &lt;- 100 * logret(exrates)

# We are going to fit a one-factor model so the ordering is irrelevant
# NOTE that these are very few draws, you probably want more...
res &lt;- fsvsample(dat, factors = 2, draws = 2000, burnin = 1000,
  runningstore = 6, zeromean = FALSE)

voltimeplot(res)

corimageplot(res, nrow(dat), plotCI = 'circle')

oldpar &lt;- par(ask = TRUE)
plot(res)
par(oldpar)
pairs(t(res$beta[1:4, ]))


</code></pre>

<hr>
<h2 id='fsvsim'>Simulate data from a factor SV model</h2><span id='topic+fsvsim'></span>

<h3>Description</h3>

<p><code>fsvsim</code> generates simulated data from a factor SV model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsvsim(
  n = 1000,
  series = 10,
  factors = 1,
  facload = "dense",
  idipara,
  facpara,
  heteroskedastic = rep(TRUE, series + factors),
  df = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsvsim_+3A_n">n</code></td>
<td>
<p>Length of the series to be generated.</p>
</td></tr>
<tr><td><code id="fsvsim_+3A_series">series</code></td>
<td>
<p>Number of component series <code>m</code>.</p>
</td></tr>
<tr><td><code id="fsvsim_+3A_factors">factors</code></td>
<td>
<p>Number of factors <code>r</code>.</p>
</td></tr>
<tr><td><code id="fsvsim_+3A_facload">facload</code></td>
<td>
<p>Can either be a matrix of dimension <code>m</code> times <code>r</code>
or one of the keywords &quot;dense&quot; and &quot;sparse&quot;. If &quot;dense&quot; is chosen,
a (rather) dense lower triangular factor loadings matrix is randomly
generated. If &quot;sparse&quot; is chosen, a (rather) sparse lower triangular
factor loadings matrix is randomly generated.</p>
</td></tr>
<tr><td><code id="fsvsim_+3A_idipara">idipara</code></td>
<td>
<p><em>Optional</em> matrix of idiosyncratic SV parameters
to be used for simulation. Must have exactly three columns containing
the values of <code>mu</code>, <code>phi</code> and <code>sigma</code> for each
of <code>m</code> series, respectively. If omitted, plausible values are
generated.</p>
</td></tr>
<tr><td><code id="fsvsim_+3A_facpara">facpara</code></td>
<td>
<p><em>Optional</em> matrix of idiosyncratic SV parameters
to be used for simulation. Must have exactly two columns containing
the values of <code>phi</code> and <code>sigma</code> for each of <code>r</code> factors,
respectively. If omitted, plausible values are generated.</p>
</td></tr>
<tr><td><code id="fsvsim_+3A_heteroskedastic">heteroskedastic</code></td>
<td>
<p>Logical vector of length <code>m+r</code>. When
<code>TRUE</code>, time-varying volatilities are generated; when
<code>FALSE</code>, constant volatilities (equal to <code>mu</code>) are generated.</p>
</td></tr>
<tr><td><code id="fsvsim_+3A_df">df</code></td>
<td>
<p>If not equal to Inf, the factors are misspecified (come from
a t distribution instead of a Gaussian). Only used for testing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned is a list object of class <code>fsvsim</code> holding
</p>

<dl>
<dt>y</dt><dd><p>The simulated data, stored in a <code>n</code> times <code>m</code> matrix with
colnames 'Sim1', 'Sim2', etc.</p>
</dd>
<dt>fac</dt><dd><p>The simulated factors, stored in a <code>r</code> times <code>r</code> matrix.</p>
</dd>
<dt>facload</dt><dd><p>Factor loadings matrix.</p>
</dd>
<dt>facvol</dt><dd><p>Latent factor log-variances for times 1 to <code>n</code>.</p>
</dd>
<dt>facvol0</dt><dd><p>Initial factor log-variances for time 0.</p>
</dd>
<dt>facpara</dt><dd><p>The parameters of the factor volatility processes.</p>
</dd>
<dt>idivol</dt><dd><p>Latent idiosyncratic log-variances for times 1 to <code>n</code>.</p>
</dd>
<dt>idivol0</dt><dd><p>Initial idiosyncratic log-variances for time 0.</p>
</dd>
<dt>idipara</dt><dd><p>The parameters of the idiosyncratic volatility
processes.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This object can be passed to many plotting functions to indicate
the data generating processes when visualizing results.
</p>

<hr>
<h2 id='ledermann'>Ledermann bound for the number of factors</h2><span id='topic+ledermann'></span>

<h3>Description</h3>

<p>In the static factor case, the Ledermann bound is the largest
integer rank for which a unique decomposition of the covariance
matrix is possible. (This is the largest possible number of
factors which can be used for <code><a href="stats.html#topic+factanal">factanal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ledermann(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ledermann_+3A_m">m</code></td>
<td>
<p>Number of component series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Ledermann bound, a nonnegative integer.
</p>


<h3>See Also</h3>

<p>preorder
</p>

<hr>
<h2 id='logret'>Compute the log returns of a vector-valued time series</h2><span id='topic+logret'></span><span id='topic+logret.matrix'></span><span id='topic+logret.data.frame'></span>

<h3>Description</h3>

<p><code>logret</code> computes the log returns of a multivariate time
series, with optional de-meaning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
logret(dat, demean = FALSE, standardize = FALSE, ...)

## S3 method for class 'data.frame'
logret(dat, demean = FALSE, standardize = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logret_+3A_dat">dat</code></td>
<td>
<p>The raw data, a matrix or data frame with <code>n</code>
(number of timepoints) rows and <code>m</code>
(number of component series) columns.</p>
</td></tr>
<tr><td><code id="logret_+3A_demean">demean</code></td>
<td>
<p>Logical value indicating whether the data should
be de-meaned.</p>
</td></tr>
<tr><td><code id="logret_+3A_standardize">standardize</code></td>
<td>
<p>Logical value indicating whether the data should
be standardized (in the sense that each component series has an empirical
variance equal to one).</p>
</td></tr>
<tr><td><code id="logret_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix containing the log returns of the (de-meaned)
data.
</p>

<hr>
<h2 id='logvartimeplot'>Plot log-variances over time.</h2><span id='topic+logvartimeplot'></span>

<h3>Description</h3>

<p><code>logvartimeplot</code> plots the idiosyncratic and factor log-variances over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logvartimeplot(x, fsvsimobj = NULL, show = "both", maxrows = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logvartimeplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="logvartimeplot_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>To indicate data generating values in case of simulated
data, pass an object of type <code>fsvsim</code> (usually the result of a
call to <code><a href="#topic+fsvsim">fsvsim</a></code>).</p>
</td></tr>
<tr><td><code id="logvartimeplot_+3A_show">show</code></td>
<td>
<p>If set to &quot;fac&quot;, only factor log-volatilities will be displayed.
If set to &quot;idi&quot;, only idiosyncratic log-volatilities will be displayed.
If set to &quot;both&quot;, factor log-volatilities will be drawn first, followed
by the idiosyncratic log-volatilities.</p>
</td></tr>
<tr><td><code id="logvartimeplot_+3A_maxrows">maxrows</code></td>
<td>
<p>Indicates the maximum number of rows to be drawn per page.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays the posterior distribution (<code>mean +/- 2sd</code>)
of log-variances of both
the factors and the idiosyncratic series.
If these haven't been stored during
sampling, <code>logvartimeplot</code> produces an error.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='orderident'>A posteriori factor order identification</h2><span id='topic+orderident'></span>

<h3>Description</h3>

<p><code>orderident</code> provides some (very ad-hoc) methods for identifying
the ordering of the factors after running the (unrestricted) MCMC
sampler by
ordering according to the argument <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderident(x, method = "summed")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderident_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="orderident_+3A_method">method</code></td>
<td>
<p>Methods currently supported:
</p>

<ul>
<li> <p><code>summean</code> Sort by sum of mean loadings (descending).
</p>
</li>
<li> <p><code>summeaninv</code> Sort by sum of mean loadings (ascending).
</p>
</li>
<li> <p><code>summeanabs</code> Sort by sum of mean absolute loadings (descending).
</p>
</li>
<li> <p><code>summed</code> Sort by sum of median loadings (descending).
</p>
</li>
<li> <p><code>summedinv</code> Sort by sum of median loadings (ascending).
</p>
</li>
<li> <p><code>summedabs</code> Sort by sum of median absolute loadings (descending).
</p>
</li>
<li> <p><code>maxmed</code> Sort by maximum median loadings (descending).
</p>
</li>
<li> <p><code>maxmedinv</code> Sort by maximum median loadings (ascending).
</p>
</li>
<li> <p><code>maxmedrel</code> Sort by maximum median loadings, relative to the sum of all median loadings on that factor (descending).
</p>
</li>
<li> <p><code>maxmedabsrel</code> Sort by maximum absolute median loadings, relative to the sum of all median loadings on that factor (descending).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>'fsvdraws'</code> with adjusted
ordering.
</p>


<h3>See Also</h3>

<p>Other postprocessing: 
<code><a href="#topic+signident">signident</a>()</code>
</p>

<hr>
<h2 id='paratraceplot'>Trace plots of parameter draws.</h2><span id='topic+paratraceplot'></span><span id='topic+paratraceplot.fsvdraws'></span>

<h3>Description</h3>

<p><code>paratraceplot</code> draws trace plots of all parameters (<code>mu, phi,
sigma</code>). Can be an important tool to check MCMC convergence if inference
about (certain) parameters is sought.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsvdraws'
paratraceplot(x, fsvsimobj = NULL, thinning = NULL, maxrows = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paratraceplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="paratraceplot_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>To indicate data generating values in case of simulated
data, pass an object of type <code>fsvsim</code> (usually the result of a
call to <code><a href="#topic+fsvsim">fsvsim</a></code>).</p>
</td></tr>
<tr><td><code id="paratraceplot_+3A_thinning">thinning</code></td>
<td>
<p>Plot every <code>thinning</code>th draw.</p>
</td></tr>
<tr><td><code id="paratraceplot_+3A_maxrows">maxrows</code></td>
<td>
<p>Indicates the maximum number of rows to be drawn per page.</p>
</td></tr>
<tr><td><code id="paratraceplot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='plot.fsvdraws'>Default factor SV plot</h2><span id='topic+plot.fsvdraws'></span>

<h3>Description</h3>

<p>Displays the correlation matrix at the last sampling point in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsvdraws'
plot(x, quantiles = c(0.05, 0.5, 0.95), col = NULL, fsvsimobj = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fsvdraws_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fsvdraws_+3A_quantiles">quantiles</code></td>
<td>
<p>Posterior quantiles to be visualized. Must be of length 1 or 3.</p>
</td></tr>
<tr><td><code id="plot.fsvdraws_+3A_col">col</code></td>
<td>
<p>Optional color palette.</p>
</td></tr>
<tr><td><code id="plot.fsvdraws_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>To indicate data generating values in case of simulated
data, pass an optional object of type <code>fsvsim</code> (usually the result of a
call to <code><a href="#topic+fsvsim">fsvsim</a></code>).</p>
</td></tr>
<tr><td><code id="plot.fsvdraws_+3A_...">...</code></td>
<td>
<p>Other arguments will be passed on to <a href="corrplot.html#topic+corrplot">corrplot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='plotalot'>Several factor SV plots useful for model diagnostics</h2><span id='topic+plotalot'></span>

<h3>Description</h3>

<p>Draws a collection of plots to explore the posterior distribution
of a fitted factor SV model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotalot(x, fsvsimobj = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotalot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="plotalot_+3A_fsvsimobj">fsvsimobj</code></td>
<td>
<p>To indicate data generating values in case of simulated
data, pass an object of type <code>fsvsim</code> (usually the result of a
call to <code><a href="#topic+fsvsim">fsvsim</a></code>).</p>
</td></tr>
<tr><td><code id="plotalot_+3A_...">...</code></td>
<td>
<p>Other arguments will be passed on to the subfunctions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+voltimeplot">voltimeplot</a>()</code>
</p>

<hr>
<h2 id='predcond'>Predicts means and variances conditionally on the factors</h2><span id='topic+predcond'></span>

<h3>Description</h3>

<p><code>predcond</code> simulates from the posterior predictive distribution
of the data, conditionally on realized values of the factors. This
has the advantage that the predictive density can be written as
the product of the marginals but introduces sampling uncertainty
that grows with the number of factors used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predcond(x, ahead = 1, each = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predcond_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="predcond_+3A_ahead">ahead</code></td>
<td>
<p>Vector of timepoints, indicating how many steps
to predict ahead.</p>
</td></tr>
<tr><td><code id="predcond_+3A_each">each</code></td>
<td>
<p>Single integer (or coercible to such) indicating how
often should be drawn from the posterior predictive distribution
for each draw that has been stored during MCMC sampling.</p>
</td></tr>
<tr><td><code id="predcond_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>fsvpredcond</code> containing two elements:
</p>

<dl>
<dt>means</dt><dd><p>Array containing the draws of the predictive means.</p>
</dd>
<dt>vols</dt><dd><p>Array containing the draws of the predictive volatilities (square root of variances).</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other predictors: 
<code><a href="#topic+predcor">predcor</a>()</code>,
<code><a href="#topic+predcov">predcov</a>()</code>,
<code><a href="#topic+predh">predh</a>()</code>,
<code><a href="#topic+predloglikWB">predloglikWB</a>()</code>,
<code><a href="#topic+predloglik">predloglik</a>()</code>,
<code><a href="#topic+predprecWB">predprecWB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
sim &lt;- fsvsim(n = 500, series = 4, factors = 1) # simulate
res &lt;- fsvsample(sim$y, factors = 1) # estimate

# Predict 1 day ahead:
predobj &lt;- predcond(res, each = 5)

# Draw from the predictive distribution:
preddraws &lt;- matrix(rnorm(length(predobj$means[,,1]),
                    mean = predobj$means[,,1],
                    sd = predobj$vols[,,1]), nrow = 4)

# Visualize the predictive distribution
pairs(t(preddraws), col = rgb(0,0,0,.1), pch = 16)


</code></pre>

<hr>
<h2 id='predcor'>Predicts correlation matrix</h2><span id='topic+predcor'></span>

<h3>Description</h3>

<p><code>predcor</code> simulates from the posterior predictive distribution
of the model-implied correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predcor(x, ahead = 1, each = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predcor_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="predcor_+3A_ahead">ahead</code></td>
<td>
<p>Vector of timepoints, indicating how many steps
to predict ahead.</p>
</td></tr>
<tr><td><code id="predcor_+3A_each">each</code></td>
<td>
<p>Single integer (or coercible to such) indicating how
often should be drawn from the posterior predictive distribution
for each draw that has been stored during MCMC sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4-dimensional array containing draws from the predictive
correlation distribution.
</p>


<h3>Note</h3>

<p>Currently crudely implemented as a triple loop in pure R,
may be slow.
</p>


<h3>See Also</h3>

<p>Other predictors: 
<code><a href="#topic+predcond">predcond</a>()</code>,
<code><a href="#topic+predcov">predcov</a>()</code>,
<code><a href="#topic+predh">predh</a>()</code>,
<code><a href="#topic+predloglikWB">predloglikWB</a>()</code>,
<code><a href="#topic+predloglik">predloglik</a>()</code>,
<code><a href="#topic+predprecWB">predprecWB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
sim &lt;- fsvsim(series = 3, factors = 1) # simulate
res &lt;- fsvsample(sim$y, factors = 1) # estimate

# Predict 1, 10, and 100 days ahead:
predobj &lt;- predcor(res, ahead = c(1, 10, 100))

# Trace plot of draws from posterior predictive distribution
# of the correlation of Sim1 and Sim2:
# (one, ten, and 100 days ahead):
plot.ts(predobj[1,2,,])

# Smoothed kernel density estimates of predicted covariance
# of Sim1 and Sim2:
plot(density(predobj[1,2,,"1"], adjust = 2))
lines(density(predobj[1,2,,"10"], adjust = 2), col = 2)
lines(density(predobj[1,2,,"100"], adjust = 2), col = 3)


</code></pre>

<hr>
<h2 id='predcov'>Predicts covariance matrix</h2><span id='topic+predcov'></span>

<h3>Description</h3>

<p><code>predcov</code> simulates from the posterior predictive distribution
of the model-implied covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predcov(x, ahead = 1, each = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predcov_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="predcov_+3A_ahead">ahead</code></td>
<td>
<p>Vector of timepoints, indicating how many steps
to predict ahead.</p>
</td></tr>
<tr><td><code id="predcov_+3A_each">each</code></td>
<td>
<p>Single integer (or coercible to such) indicating how
often should be drawn from the posterior predictive distribution
for each draw that has been stored during MCMC sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>4-dimensional array containing draws from the predictive
covariance distribution.
</p>


<h3>Note</h3>

<p>Currently crudely implemented as a triple loop in pure R,
may be slow.
</p>


<h3>See Also</h3>

<p>Other predictors: 
<code><a href="#topic+predcond">predcond</a>()</code>,
<code><a href="#topic+predcor">predcor</a>()</code>,
<code><a href="#topic+predh">predh</a>()</code>,
<code><a href="#topic+predloglikWB">predloglikWB</a>()</code>,
<code><a href="#topic+predloglik">predloglik</a>()</code>,
<code><a href="#topic+predprecWB">predprecWB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
sim &lt;- fsvsim(series = 3, factors = 1) # simulate
res &lt;- fsvsample(sim$y, factors = 1) # estimate

# Predict 1, 10, and 100 days ahead:
predobj &lt;- predcov(res, ahead = c(1, 10, 100))

# Trace plot of draws from posterior predictive distribution
# of the covariance of Sim1 and Sim2:
# (one, ten, and 100 days ahead):
plot.ts(predobj[1,2,,])

# Smoothed kernel density estimates of predicted covariance
# of Sim1 and Sim2:
plot(density(predobj[1,2,,"1"], adjust = 2))
lines(density(predobj[1,2,,"10"], adjust = 2), col = 2)
lines(density(predobj[1,2,,"100"], adjust = 2), col = 3)


</code></pre>

<hr>
<h2 id='predh'>Predicts factor and idiosyncratic log-volatilities h</h2><span id='topic+predh'></span>

<h3>Description</h3>

<p><code>predh</code> simulates from the posterior predictive distribution
of the latent log-variances h, both for factors as well as for
idiosyncratic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predh(x, ahead = 1, each = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predh_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="predh_+3A_ahead">ahead</code></td>
<td>
<p>Vector of timepoints, indicating how many steps
to predict ahead.</p>
</td></tr>
<tr><td><code id="predh_+3A_each">each</code></td>
<td>
<p>Single integer (or coercible to such) indicating how
often should be drawn from the posterior predictive distribution
for each draw that has been stored during MCMC sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>fsvpredh</code> containing two elements:
</p>

<dl>
<dt>idih</dt><dd><p>Array containing the draws of the latent idiosyncratic
log-volatilities.</p>
</dd>
<dt>factorh</dt><dd><p>Array containing the draws of the latent factor
log-volatilities.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other predictors: 
<code><a href="#topic+predcond">predcond</a>()</code>,
<code><a href="#topic+predcor">predcor</a>()</code>,
<code><a href="#topic+predcov">predcov</a>()</code>,
<code><a href="#topic+predloglikWB">predloglikWB</a>()</code>,
<code><a href="#topic+predloglik">predloglik</a>()</code>,
<code><a href="#topic+predprecWB">predprecWB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
sim &lt;- fsvsim(series = 3, factors = 1) # simulate
res &lt;- fsvsample(sim$y, factors = 1) # estimate

# Predict 1, 10, and 100 days ahead:
predobj &lt;- predh(res, ahead = c(1, 10, 100))

# Trace plot of draws from posterior predictive factor log-variance
# (one, ten, and 100 days ahead):
plot.ts(predobj$factorh[1,,])

# Smoothed kernel density estimates of predicted volas:
plot(density(exp(predobj$factorh[1,,"1"]/2), adjust = 2))
lines(density(exp(predobj$factorh[1,,"10"]/2), adjust = 2), col = 2)
lines(density(exp(predobj$factorh[1,,"100"]/2), adjust = 2), col = 3)


</code></pre>

<hr>
<h2 id='predloglik'>Evaluates the predictive log likelihood using the predicted
covariance matrix</h2><span id='topic+predloglik'></span>

<h3>Description</h3>

<p><code>predloglik</code> approximates the predictive log likelihood by
simulating from the predictive distribution of the covariance
matrix and evaluating the corresponding multivariate normal
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predloglik(
  x,
  y,
  ahead = 1,
  each = 1,
  alldraws = FALSE,
  indicator = rep(TRUE, ncol(y))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predloglik_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="predloglik_+3A_y">y</code></td>
<td>
<p>Matrix of dimension <code>length(ahead)</code> times <code>m</code> where the
predictive density should be evaluated.</p>
</td></tr>
<tr><td><code id="predloglik_+3A_ahead">ahead</code></td>
<td>
<p>Vector of timepoints, indicating how many steps
to predict ahead.</p>
</td></tr>
<tr><td><code id="predloglik_+3A_each">each</code></td>
<td>
<p>Single integer (or coercible to such) indicating how
often should be drawn from the posterior predictive distribution
for each draw that has been stored during MCMC sampling.</p>
</td></tr>
<tr><td><code id="predloglik_+3A_alldraws">alldraws</code></td>
<td>
<p>Should all the draws be returned or just the final results?
(Can be useful to assess convergence.)</p>
</td></tr>
<tr><td><code id="predloglik_+3A_indicator">indicator</code></td>
<td>
<p>Logical vector of length <code>m</code> indicating which
component series should be evaluated. The default is to evaluate
all of them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length <code>length(ahead)</code> with log predictive
likelihoods.
</p>


<h3>See Also</h3>

<p>Uses <code><a href="#topic+predcov">predcov</a></code>. If <code>m</code> is large
but only few factors are used, consider also using
<code><a href="#topic+predloglikWB">predloglikWB</a></code>.
</p>
<p>Other predictors: 
<code><a href="#topic+predcond">predcond</a>()</code>,
<code><a href="#topic+predcor">predcor</a>()</code>,
<code><a href="#topic+predcov">predcov</a>()</code>,
<code><a href="#topic+predh">predh</a>()</code>,
<code><a href="#topic+predloglikWB">predloglikWB</a>()</code>,
<code><a href="#topic+predprecWB">predprecWB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)

# Simulate a time series of length 1100:
sim &lt;- fsvsim(n = 1100, series = 3, factors = 1)
y &lt;- sim$y

# Estimate using only 1000 days:
res &lt;- fsvsample(y[seq_len(1000),], factors = 1)

# Evaluate the 1, 10, and 100 days ahead predictive log
# likelihood:
ahead &lt;- c(1, 10, 100)
scores &lt;- predloglik(res, y[1000+ahead,], ahead = ahead, each = 10)
print(scores)


</code></pre>

<hr>
<h2 id='predloglikWB'>Evaluates the predictive log likelihood using the Woodbury identity</h2><span id='topic+predloglikWB'></span>

<h3>Description</h3>

<p><code>predloglikWB</code> approximates the predictive log likelihood exploiting
the factor structure and using the Woodbury idenitity and the
corresponding matrix determinant lemma. This is recommended only
if many series and few factors are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predloglikWB(x, y, ahead = 1, each = 1, alldraws = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predloglikWB_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="predloglikWB_+3A_y">y</code></td>
<td>
<p>Matrix of dimension <code>length(ahead)</code> times <code>m</code> where the
predictive density should be evaluated.</p>
</td></tr>
<tr><td><code id="predloglikWB_+3A_ahead">ahead</code></td>
<td>
<p>Vector of timepoints, indicating how many steps
to predict ahead.</p>
</td></tr>
<tr><td><code id="predloglikWB_+3A_each">each</code></td>
<td>
<p>Single integer (or coercible to such) indicating how
often should be drawn from the posterior predictive distribution
for each draw that has been stored during MCMC sampling.</p>
</td></tr>
<tr><td><code id="predloglikWB_+3A_alldraws">alldraws</code></td>
<td>
<p>Should all the draws be returned or just the final results?
(Can be useful to assess convergence.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length <code>length(ahead)</code> with log predictive
likelihoods.
</p>


<h3>Note</h3>

<p>Currently crudely implemented as a triple loop in pure R,
may be slow.
</p>


<h3>See Also</h3>

<p>Uses <code><a href="#topic+predprecWB">predprecWB</a></code>. If <code>m</code> is small
or many factors are used, consider also using
<code><a href="#topic+predcov">predcov</a></code>.
</p>
<p>Other predictors: 
<code><a href="#topic+predcond">predcond</a>()</code>,
<code><a href="#topic+predcor">predcor</a>()</code>,
<code><a href="#topic+predcov">predcov</a>()</code>,
<code><a href="#topic+predh">predh</a>()</code>,
<code><a href="#topic+predloglik">predloglik</a>()</code>,
<code><a href="#topic+predprecWB">predprecWB</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)

# Simulate a time series of length 1100:
sim &lt;- fsvsim(n = 1100, series = 3, factors = 1)
y &lt;- sim$y

# Estimate using only 1000 days:
res &lt;- fsvsample(y[seq_len(1000),], factors = 1)

# Evaluate the 1, 10, and 100 days ahead predictive log
# likelihood:
ahead &lt;- c(1, 10, 100)
scores &lt;- predloglikWB(res, y[1000+ahead,], ahead = ahead, each = 10)
print(scores)


</code></pre>

<hr>
<h2 id='predprecWB'>Predicts precision matrix and its determinant (Woodbury variant)</h2><span id='topic+predprecWB'></span>

<h3>Description</h3>

<p><code>predprecWB</code> simulates from the posterior predictive distribution
of the model-implied precision matrix and its determinant
using the Woodbury matrix identity and the matrix determinant lemma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predprecWB(x, ahead = 1, each = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predprecWB_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="predprecWB_+3A_ahead">ahead</code></td>
<td>
<p>Vector of timepoints, indicating how many steps
to predict ahead.</p>
</td></tr>
<tr><td><code id="predprecWB_+3A_each">each</code></td>
<td>
<p>Single integer (or coercible to such) indicating how
often should be drawn from the posterior predictive distribution
for each draw that has been stored during MCMC sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing two elements:
</p>

<dl>
<dt>precision</dt><dd><p>Array containing the draws of the predicted
precision matrix.</p>
</dd>
<dt>precisionlogdet</dt><dd><p>Matrix containing the draws of the determinant
of the predicted precision matrix.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Currently crudely implemented as a triple loop in pure R,
may be slow.
</p>


<h3>See Also</h3>

<p>Usually used for evaluating the predictive likelihood when many
series but few factors are used, see
<code><a href="#topic+predloglik">predloglik</a></code> and <code><a href="#topic+predloglikWB">predloglikWB</a></code>.
</p>
<p>Other predictors: 
<code><a href="#topic+predcond">predcond</a>()</code>,
<code><a href="#topic+predcor">predcor</a>()</code>,
<code><a href="#topic+predcov">predcov</a>()</code>,
<code><a href="#topic+predh">predh</a>()</code>,
<code><a href="#topic+predloglikWB">predloglikWB</a>()</code>,
<code><a href="#topic+predloglik">predloglik</a>()</code>
</p>

<hr>
<h2 id='preorder'>Ad-hoc methods for determining the order of variables</h2><span id='topic+preorder'></span>

<h3>Description</h3>

<p>In factor SV models, the ordering of variables is often
chosen through a preliminary static factor analysis. These
methods are implemented in <code>preorder</code>.
After a maximum likelihood factor model fit to the data,
factor loadings are ordered as follows: The variable with the
highest loading on factor 1 is placed first, the variable with
the highest loading on factor 2 second (unless this variable
is already placed first, in which case the variable with the
second highest loading is taken).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preorder(
  dat,
  factors = ledermann(ncol(dat)),
  type = "fixed",
  transload = identity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preorder_+3A_dat">dat</code></td>
<td>
<p>Matrix containing the data, with <code>n</code> rows
(points in time) and <code>m</code> columns (component series).</p>
</td></tr>
<tr><td><code id="preorder_+3A_factors">factors</code></td>
<td>
<p>Number of factors to be used, defaults to the
Ledermann bound.</p>
</td></tr>
<tr><td><code id="preorder_+3A_type">type</code></td>
<td>
<p>Can be &quot;fixed&quot; or &quot;dynamic&quot;. The option &quot;fixed&quot;
means that that a <code>factors</code>-factor model is fit once and
the entire ordering is determined according to this fit
(the default). The option &quot;dynamic&quot; means that
the model is re-fit <code>factors</code> times with the number of
factors going from 1 to
<code>factors</code> and in each round the correspondingly largest
loading is chosen.</p>
</td></tr>
<tr><td><code id="preorder_+3A_transload">transload</code></td>
<td>
<p>Function for transforming the estimated
factor loadings before ordering. Defaults to the identity
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>m</code> with the ordering found.
</p>


<h3>See Also</h3>

<p>ledermann
</p>

<hr>
<h2 id='print.fsvdraws'>Pretty printing of an fsvsdraws object</h2><span id='topic+print.fsvdraws'></span>

<h3>Description</h3>

<p>Pretty printing of an fsvsdraws object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fsvdraws'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fsvdraws_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
of <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="print.fsvdraws_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>

<hr>
<h2 id='runningcormat'>Extract summary statistics for the posterior correlation matrix
which have been stored during sampling</h2><span id='topic+runningcormat'></span>

<h3>Description</h3>

<p><code>runningcormat</code> extracts summary statistics from the model-implied
correlation matrix
from an <code>fsvdraws</code> object for one point in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runningcormat(x, i, statistic = "mean", type = "cor")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runningcormat_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
of <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="runningcormat_+3A_i">i</code></td>
<td>
<p>A single point in time.</p>
</td></tr>
<tr><td><code id="runningcormat_+3A_statistic">statistic</code></td>
<td>
<p>Indicates which statistic should be extracted. Defaults
to <code>'mean'</code>.</p>
</td></tr>
<tr><td><code id="runningcormat_+3A_type">type</code></td>
<td>
<p>Indicates whether covariance (<code>cov</code>) or correlation
(<code>cor</code>) should be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix containing the requested correlation matrix summary statistic.
</p>


<h3>See Also</h3>

<p>Other extractors: 
<code><a href="#topic+cormat.fsvdraws">cormat.fsvdraws</a>()</code>,
<code><a href="#topic+covmat.fsvdraws">covmat.fsvdraws</a>()</code>,
<code><a href="#topic+runningcovmat">runningcovmat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
sim &lt;- fsvsim(n = 500, series = 3, factors = 1) # simulate
res &lt;- fsvsample(sim$y, factors = 1, runningstore = 6) # estimate

cor100mean &lt;- runningcormat(res, 100) # extract mean at t = 100
cor100sd &lt;- runningcormat(res, 100, statistic = "sd") # extract sd
lower &lt;- cor100mean - 2*cor100sd
upper &lt;- cor100mean + 2*cor100sd

true &lt;- cormat(sim, 100)[,,1] # true value

# Visualize mean +/- 2sd and data generating values
par(mfrow = c(3,3), mar = c(2, 2, 2, 2))
for (i in 1:3) {
 for (j in 1:3) {
  plot(cor100mean[i,j], ylim = range(lower, upper), pch = 3,
  main = paste(i, j, sep = ' vs. '), xlab = '', ylab = '')
  lines(c(1,1), c(lower[i,j], upper[i,j]))
  points(true[i,j], col = 3, cex = 2)
 }
}


</code></pre>

<hr>
<h2 id='runningcovmat'>Extract summary statistics for the posterior covariance matrix
which have been stored during sampling</h2><span id='topic+runningcovmat'></span>

<h3>Description</h3>

<p><code>runningcovmat</code> extracts summary statistics from the model-implied
covariance matrix
from an <code>fsvdraws</code> object for one point in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runningcovmat(x, i, statistic = "mean", type = "cov")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runningcovmat_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
of <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="runningcovmat_+3A_i">i</code></td>
<td>
<p>A single point in time.</p>
</td></tr>
<tr><td><code id="runningcovmat_+3A_statistic">statistic</code></td>
<td>
<p>Indicates which statistic should be extracted. Defaults
to <code>'mean'</code>.</p>
</td></tr>
<tr><td><code id="runningcovmat_+3A_type">type</code></td>
<td>
<p>Indicates whether covariance (<code>cov</code>) or correlation
(<code>cor</code>) should be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix containing the requested covariance matrix summary statistic.
</p>


<h3>See Also</h3>

<p>Other extractors: 
<code><a href="#topic+cormat.fsvdraws">cormat.fsvdraws</a>()</code>,
<code><a href="#topic+covmat.fsvdraws">covmat.fsvdraws</a>()</code>,
<code><a href="#topic+runningcormat">runningcormat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
sim &lt;- fsvsim(n = 500, series = 3, factors = 1) # simulate
res &lt;- fsvsample(sim$y, factors = 1) # estimate

cov100mean &lt;- runningcovmat(res, 100) # extract mean at t = 100
cov100sd &lt;- runningcovmat(res, 100, statistic = "sd") # extract sd
lower &lt;- cov100mean - 2*cov100sd
upper &lt;- cov100mean + 2*cov100sd

true &lt;- covmat(sim, 100) # true value

# Visualize mean +/- 2sd and data generating values
par(mfrow = c(3,3), mar = c(2, 2, 2, 2))
for (i in 1:3) {
 for (j in 1:3) {
  plot(cov100mean[i,j], ylim = range(lower, upper), pch = 3,
  main = paste(i, j, sep = ' vs. '), xlab = '', ylab = '')
  lines(c(1,1), c(lower[i,j], upper[i,j]))
  points(true[i,j,1], col = 3, cex = 2)
 }
}


</code></pre>

<hr>
<h2 id='signident'>A posteriori sign identification</h2><span id='topic+signident'></span>

<h3>Description</h3>

<p><code>signident</code> provides methods for identifying the signs of
the factor loadings after running the MCMC sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signident(x, method = "maximin", implementation = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signident_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="signident_+3A_method">method</code></td>
<td>
<p>Can be &quot;diagonal&quot; or &quot;maximin&quot;. If &quot;diagonal&quot; is
chosen, the diagonal elements of the factor loadings matrix
are assumed to have positive signs
and the others are arranged accordingly.
If &quot;maximin&quot; is chosen, for each factor, <code>signident</code> looks
for the series where
the minimum absolute loadings are biggest and chooses this series
to have positive loadings.</p>
</td></tr>
<tr><td><code id="signident_+3A_implementation">implementation</code></td>
<td>
<p>Either 1, 2, or 3 (the default). Determines
how the reordering is implemented. Should not be necessary to depart
from the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>'fsvdraws'</code> with adjusted
factors and factor loadings. Moreover, a list element called
<code>'identifier'</code> is added, providing the numbers of the series
used for identification and the corresponding minimum distances to
zero.
</p>


<h3>See Also</h3>

<p>Other postprocessing: 
<code><a href="#topic+orderident">orderident</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
sim &lt;- fsvsim(series = 8, factors = 2) # simulate
res &lt;- fsvsample(sim$y, factors = 2, signswitch = TRUE,
                 draws = 2000, burnin = 1000) # estimate

# Plot unidentified loadings:
facloaddensplot(res, fsvsimobj = sim, rows = 8)

# Identify:
res &lt;- signident(res)

# Plot identified loadings:
facloaddensplot(res, fsvsimobj = sim, rows = 8)


</code></pre>

<hr>
<h2 id='voltimeplot'>Plot series-specific volatilities over time.</h2><span id='topic+voltimeplot'></span>

<h3>Description</h3>

<p><code>voltimeplot</code> plots the marginal volatilities over time, i.e. the
series-specific conditional standard deviations. If these haven't been
stored during sampling (because <code>runningstore</code> has been set too low),
<code>voltimeplot</code> throws a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voltimeplot(x, these = seq_len(nrow(x$y)), legend = "topright", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voltimeplot_+3A_x">x</code></td>
<td>
<p>Object of class <code>'fsvdraws'</code>, usually resulting from a call
to <code><a href="#topic+fsvsample">fsvsample</a></code>.</p>
</td></tr>
<tr><td><code id="voltimeplot_+3A_these">these</code></td>
<td>
<p>Index vector containing the time points to plot. Defaults
to <code>seq_len(nrow(x$y))</code>, i.e., all timepoints.</p>
</td></tr>
<tr><td><code id="voltimeplot_+3A_legend">legend</code></td>
<td>
<p>Where to position the <code><a href="graphics.html#topic+legend">legend</a></code>.
If set to NULL, labels will be put directly next to the series.
Defaults to &quot;topright&quot;.</p>
</td></tr>
<tr><td><code id="voltimeplot_+3A_...">...</code></td>
<td>
<p>Additional parameters will be passed on to <code><a href="stats.html#topic+ts.plot">ts.plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+comtimeplot">comtimeplot</a>()</code>,
<code><a href="#topic+corimageplot">corimageplot</a>()</code>,
<code><a href="#topic+corplot">corplot</a>()</code>,
<code><a href="#topic+cortimeplot">cortimeplot</a>()</code>,
<code><a href="#topic+evdiag">evdiag</a>()</code>,
<code><a href="#topic+facloadcredplot">facloadcredplot</a>()</code>,
<code><a href="#topic+facloaddensplot">facloaddensplot</a>()</code>,
<code><a href="#topic+facloadpairplot">facloadpairplot</a>()</code>,
<code><a href="#topic+facloadpointplot">facloadpointplot</a>()</code>,
<code><a href="#topic+facloadtraceplot">facloadtraceplot</a>()</code>,
<code><a href="#topic+logvartimeplot">logvartimeplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.fsvdraws">plot.fsvdraws</a>()</code>,
<code><a href="#topic+plotalot">plotalot</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
