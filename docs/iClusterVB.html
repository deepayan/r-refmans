<!DOCTYPE html><html lang="en"><head><title>Help for package iClusterVB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iClusterVB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chmap'><p>Generates a heat map based on an iClusterVB object</p></a></li>
<li><a href='#iClusterVB'><p>Fast Integrative Clustering for High-Dimensional Multi-View Data Using</p>
Variational Bayesian Inference</a></li>
<li><a href='#laml'><p>LAML (Acute Myeloid Leukemia)  Data</p></a></li>
<li><a href='#piplot'><p>Generates a probability inclusion plot based on an iClusterVB object</p></a></li>
<li><a href='#plot.iClusterVB'><p>Generic plot method for 'iClusterVB' objects</p></a></li>
<li><a href='#sim_data'><p>Simulated Dataset</p></a></li>
<li><a href='#summary.iClusterVB'><p>Generic summary method for 'iClusterVB' objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Integrative Clustering and Feature Selection for High
Dimensional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Abdalkarim Alnajjar
    <a href="https://orcid.org/0009-0008-4439-1214"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Zihang Lu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Abdalkarim Alnajjar &lt;abdalkarim.alnajjar@queensu.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A variational Bayesian approach for fast integrative
    clustering and feature selection, facilitating the analysis of
    multi-view, mixed type, high-dimensional datasets with applications in
    fields like cancer research, genomics, and more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AbdalkarimA/iClusterVB">https://github.com/AbdalkarimA/iClusterVB</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AbdalkarimA/iClusterVB/issues">https://github.com/AbdalkarimA/iClusterVB/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, clustMixType, cowplot, ggplot2, graphics, grDevices,
mclust, MCMCpack, mvtnorm, pheatmap, poLCA, Rcpp (&ge; 1.0.12),
stats, utils, VarSelLCM</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, survival, survminer</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-07 22:15:58 UTC; Abdalkarim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-09 19:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='chmap'>Generates a heat map based on an iClusterVB object</h2><span id='topic+chmap'></span>

<h3>Description</h3>

<p>Generates a heat map based on an iClusterVB object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chmap(fit, rho = 0.5, cols = NULL, title = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chmap_+3A_fit">fit</code></td>
<td>
<p>A fitted iClusterVB object.</p>
</td></tr>
<tr><td><code id="chmap_+3A_rho">rho</code></td>
<td>
<p>The minimum probability of inclusion for features shown on the
heatmap. Default is 0.5. 0 would show all features. Only useful for
VS_method = 1.</p>
</td></tr>
<tr><td><code id="chmap_+3A_cols">cols</code></td>
<td>
<p>A vector of colors to use for the clusters. The default is a
random selection of colors.</p>
</td></tr>
<tr><td><code id="chmap_+3A_title">title</code></td>
<td>
<p>A character vector or a single value. Title of the heat map. The
default is &quot;View 1 - Distribution 1&quot;, ..., &quot;View R - Distribution R&quot;.</p>
</td></tr>
<tr><td><code id="chmap_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed down to
<code><a href="pheatmap.html#topic+pheatmap">pheatmap</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heat map for each data view.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting up the data
dat1 &lt;- list(
  gauss_1 = sim_data$continuous1_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  gauss_2 = sim_data$continuous2_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  poisson_1 = sim_data$count_data[c(1:20, 61:80, 121:140, 181:200), 1:75])


dist &lt;- c(
  "gaussian", "gaussian",
  "poisson")

fit_iClusterVB &lt;- iClusterVB(
  mydata = dat1,
  dist = dist,
  K = 4,
  initial_method = "VarSelLCM",
  VS_method = 1,
  max_iter = 25
)


# We can set the colors, turn off scaling and set titles

chmap(fit_iClusterVB,
  cols = c("red", "blue", "green", "purple"),
  title = c("Gene Expression", "DNA Methylation", "Copy Number"),
  scale = "none"
)
</code></pre>

<hr>
<h2 id='iClusterVB'>Fast Integrative Clustering for High-Dimensional Multi-View Data Using
Variational Bayesian Inference</h2><span id='topic+iClusterVB'></span>

<h3>Description</h3>

<p><code>iClusterVB</code> offers a novel, fast, and integrative approach to
clustering high-dimensional, mixed-type, and multi-view data. By employing
variational Bayesian inference, iClusterVB facilitates effective feature
selection and identification of disease subtypes, enhancing clinical
decision-making.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iClusterVB(
  mydata,
  dist,
  K = 10,
  initial_method = "VarSelLCM",
  VS_method = 0,
  initial_cluster = NULL,
  initial_vs_prob = NULL,
  initial_fit = NULL,
  initial_omega = NULL,
  input_hyper_parameters = NULL,
  max_iter = 200,
  early_stop = 1,
  per = 10,
  convergence_threshold = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iClusterVB_+3A_mydata">mydata</code></td>
<td>
<p>A list of length R, where R is the number of datasets,
containing the input data.
</p>

<ul>
<li><p> Note: For <b>categorical</b> data, <code>0</code>'s must be re-coded to
another, non-<code>0</code> value.
</p>
</li></ul>
</td></tr>
<tr><td><code id="iClusterVB_+3A_dist">dist</code></td>
<td>
<p>A vector of length R specifying the type of data or distribution.
Options include: 'gaussian' (for continuous data), 'multinomial' (for
binary or categorical data), and 'poisson' (for count data).</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_k">K</code></td>
<td>
<p>The maximum number of clusters, with a default value of 10. The
algorithm will converge to a model with dominant clusters, removing
redundant clusters and automating the determination of the number of
clusters.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_initial_method">initial_method</code></td>
<td>
<p>The initialization method for cluster allocation.
Options include: &quot;VarSelLCM&quot; (default), &quot;random&quot;, &quot;kproto&quot; (k-prototypes),
&quot;kmeans&quot; (continuous data only), &quot;mclust&quot; (continuous data only), or &quot;lca&quot;
(poLCA, categorical data only).</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_vs_method">VS_method</code></td>
<td>
<p>The variable/feature selection method. Options are 0 for
clustering without variable/feature selection (default) and 1 for
clustering with variable/feature selection.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_initial_cluster">initial_cluster</code></td>
<td>
<p>The initial cluster membership. The default is NULL,
which uses initial_method for initial cluster allocation. If not NULL, it
will override the initial values setting for this parameter.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_initial_vs_prob">initial_vs_prob</code></td>
<td>
<p>The initial variable/feature selection probability, a
scalar. The default is NULL, which assigns a value of 0.5.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_initial_fit">initial_fit</code></td>
<td>
<p>Initial values based on a previously fitted iClusterVB
model (an iClusterVB object). The default is NULL.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_initial_omega">initial_omega</code></td>
<td>
<p>Customized initial values for feature inclusion
probabilities. The default is NULL. If not NULL, it will override the
initial values setting for this parameter. If VS_method = 1, initial_omega
is a list of length R, with each element being an array with dimensions
{dim=c(N, p[[r]])}. Here, N is the sample size and p[[r]] is the
number of features for dataset r, where r = 1, ..., R.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_input_hyper_parameters">input_hyper_parameters</code></td>
<td>
<p>A list of the initial hyper-parameters of the
prior distributions for the model. The default is NULL, which assigns
alpha_00 = 0.001, mu_00 = 0, s2_00 = 100, a_00 = 1, b_00 = 1,kappa_00 = 1,
u_00 = 1, v_00 = 1.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_max_iter">max_iter</code></td>
<td>
<p>The maximum number of iterations for the VB algorithm. The
default is 200.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_early_stop">early_stop</code></td>
<td>
<p>Whether to stop the algorithm upon convergence or to
continue until <code>max_iter</code> is reached. Options are 1 (default) to stop
when the algorithm converges, and 0 to stop only when <code>max_iter</code> is
reached.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_per">per</code></td>
<td>
<p>Print information every &quot;per&quot; iterations. The default is 10.</p>
</td></tr>
<tr><td><code id="iClusterVB_+3A_convergence_threshold">convergence_threshold</code></td>
<td>
<p>The convergence threshold for the change in
ELBO. The default is 0.0001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>iClusterVB</code> function creates an object (list) of class
<code>iClusterVB</code>. Relevant outputs include:
</p>
<table role = "presentation">
<tr><td><code>elbo:</code></td>
<td>
<p> The evidence lower bound for each iteration.</p>
</td></tr>
<tr><td><code>cluster:</code></td>
<td>
<p> The cluster assigned to each individual.</p>
</td></tr>
<tr><td><code>initial_values:</code></td>
<td>
<p> A list of the initial values.</p>
</td></tr>
<tr><td><code>hyper_parameters:</code></td>
<td>
<p> A list of the hyper-parameters.</p>
</td></tr>
<tr><td><code>model_parameters:</code></td>
<td>
<p>A list of the model parameters after the
algorithm is run.</p>
</td></tr>
</table>

<ul>
<li><p> Of particular interest is <code>rho</code>, a list of the posterior
inclusion probabilities for the features in each of the data views. This is
the probability of including a certain predictor in the model, given the
observations. This is only available if <code>VS_method = 1</code>.
</p>
</li></ul>



<h3>Note</h3>

<p>If any of the data views are &quot;gaussian&quot;, please include them
<b>first</b>, both in the input data <code>mydata</code> and correspondingly in
the
distribution vector <code>dist</code>. For example, <code>dist &lt;-
  c("gaussian","gaussian", "poisson", "multinomial")</code>, and <b>not</b>
<code>dist &lt;- c("poisson", "gaussian","gaussian", "multinomial")</code> or
<code>dist &lt;- c("gaussian", "poisson", "gaussian", "multinomial")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sim_data comes with the iClusterVB package.
dat1 &lt;- list(
  gauss_1 = sim_data$continuous1_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  gauss_2 = sim_data$continuous2_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  poisson_1 = sim_data$count_data[c(1:20, 61:80, 121:140, 181:200), 1:75])

dist &lt;- c(
  "gaussian", "gaussian",
  "poisson")

# Note: `max_iter` is a time-intensive step.
# For the purpose of testing the code, use a small value (e.g. 10).
# For more accurate results, use a larger value (e.g. 200).

fit_iClusterVB &lt;- iClusterVB(
  mydata = dat1,
  dist = dist,
  K = 4,
  initial_method = "VarSelLCM",
  VS_method = 1,
  max_iter = 10
)

# We can obtain a summary using the summary() function
summary(fit_iClusterVB)

</code></pre>

<hr>
<h2 id='laml'>LAML (Acute Myeloid Leukemia)  Data</h2><span id='topic+laml'></span><span id='topic+laml.cli'></span><span id='topic+laml.exp'></span><span id='topic+laml.mut'></span>

<h3>Description</h3>

<p>This is a subset of the LAML (Acute Myeloid Leukemia) data
(TCGA, 2013). The Acute Myeloid Leukemia (laml_tcga) datasets were download
using the cBioPortal for Cancer Genomics tool (Cerami et al., 2012; Gao et
al., 2013). The 170 samples with gene expression data and mutation data
were included. Only a subset of the genes was selected,
as desribed below. To access the data containing all the genes, please
visit: https://github.com/AbdalkarimA/iClusterVB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(laml)
</code></pre>


<h3>Value</h3>

<p>Within the data file, there is:
</p>
<table role = "presentation">
<tr><td><code>laml.cli:</code></td>
<td>
<p> A dataframe
of clinical information for the 170 samples.</p>
</td></tr>
<tr><td><code>laml.exp:</code></td>
<td>
<p> A
matrix of 170 samples and the gene expression values of the 500 genes
chosen by Zainul Abidin and Westhead (2016) based on having the  highest ranked-based
coefficients of variation and standard deviation across the samples.
Some names may have been updated or corrected from the
supplementary material.</p>
</td></tr>
<tr><td><code>laml.mut:</code></td>
<td>
<p> A
matrix of 170 samples and the mutation status of 156 genes that had &gt;=2
mutations. 1 indicates the presence of mutation, and 0 indicates the
absence of mutation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cancer Genome Atlas Research Network, Ley, T. J., Miller, C.,
Ding, L., Raphael, B. J., Mungall, A. J., Robertson, A., Hoadley, K.,
Triche, T. J., Jr, Laird, P. W., Baty, J. D., Fulton, L. L., Fulton, R.,
Heath, S. E., Kalicki-Veizer, J., Kandoth, C., Klco, J. M., Koboldt, D. C.,
Kanchi, K. L., Kulkarni, S., … Eley, G. (2013). Genomic and epigenomic
landscapes of adult de novo acute myeloid leukemia. The New England journal
of medicine, 368(22), 2059–2074. https://doi.org/10.1056/NEJMoa1301689
</p>
<p>Cerami, E., Gao, J., Dogrusoz, U., Gross, B. E., Sumer, S. O., Aksoy, B.
A., Jacobsen, A., Byrne, C. J., Heuer, M. L., Larsson, E., Antipin, Y.,
Reva, B., Goldberg, A. P., Sander, C., &amp; Schultz, N. (2012). The cBio
cancer genomics portal: an open platform for exploring multidimensional
cancer genomics data. Cancer discovery, 2(5), 401–404.
https://doi.org/10.1158/2159-8290.CD-12-0095
</p>
<p>Gao, J., Aksoy, B. A., Dogrusoz, U., Dresdner, G., Gross, B., Sumer, S. O.,
Sun, Y., Jacobsen, A., Sinha, R., Larsson, E., Cerami, E., Sander, C., &amp;
Schultz, N. (2013). Integrative analysis of complex cancer genomics and
clinical profiles using the cBioPortal. Science signaling, 6(269), pl1.
https://doi.org/10.1126/scisignal.2004088
</p>
<p>Zainul Abidin, F. N., &amp; Westhead, D. R. (2017). Flexible model-based
clustering of mixed binary and continuous data: application to genetic
regulation and cancer. Nucleic acids research, 45(7), e53.
https://doi.org/10.1093/nar/gkw1270
</p>

<hr>
<h2 id='piplot'>Generates a probability inclusion plot based on an iClusterVB object</h2><span id='topic+piplot'></span>

<h3>Description</h3>

<p>Generates a probability inclusion plot based on an iClusterVB object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piplot(
  fit,
  plot_grid = TRUE,
  ylab = "Probability of Inclusion",
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="piplot_+3A_fit">fit</code></td>
<td>
<p>A fitted iClusterVB object.</p>
</td></tr>
<tr><td><code id="piplot_+3A_plot_grid">plot_grid</code></td>
<td>
<p>LOGICAL. Whether to use the <code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code>
function from the <b>cowplot</b> package. The default is TRUE.</p>
</td></tr>
<tr><td><code id="piplot_+3A_ylab">ylab</code></td>
<td>
<p>The y-axis label. The default is &quot;Probability of Inclusion&quot;.</p>
</td></tr>
<tr><td><code id="piplot_+3A_title">title</code></td>
<td>
<p>The title of the plots. It can be a character vector or a single
value. The default output is &quot;View 1 - Distribution 1&quot;, ..., &quot;View R -
Distribution R&quot;.</p>
</td></tr>
<tr><td><code id="piplot_+3A_...">...</code></td>
<td>
<p>Additional arguments to add to the
<code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a probability inclusion plot or plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting up the data
dat1 &lt;- list(
  gauss_1 = sim_data$continuous1_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  gauss_2 = sim_data$continuous2_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  poisson_1 = sim_data$count_data[c(1:20, 61:80, 121:140, 181:200), 1:75])


dist &lt;- c(
  "gaussian", "gaussian",
  "poisson")

fit_iClusterVB &lt;- iClusterVB(
  mydata = dat1,
  dist = dist,
  K = 4,
  initial_cluster= c(rep(1, 20), rep(2, 20), rep(3, 20), rep(4, 20)),
  VS_method = 1,
  max_iter = 20
)

piplot(fit_iClusterVB, plot_grid = FALSE)

</code></pre>

<hr>
<h2 id='plot.iClusterVB'>Generic plot method for 'iClusterVB' objects</h2><span id='topic+plot.iClusterVB'></span>

<h3>Description</h3>

<p>Generic plot method for 'iClusterVB' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iClusterVB'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.iClusterVB_+3A_x">x</code></td>
<td>
<p>A fitted iClusterVB object.</p>
</td></tr>
<tr><td><code id="plot.iClusterVB_+3A_...">...</code></td>
<td>
<p>Potential further arguments (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an evidence lower bound (ELBO) plot and a barplot of cluster
percentages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting up the data
dat1 &lt;- list(
  gauss_1 = sim_data$continuous1_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  gauss_2 = sim_data$continuous2_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  poisson_1 = sim_data$count_data[c(1:20, 61:80, 121:140, 181:200), 1:75])


dist &lt;- c(
  "gaussian", "gaussian",
  "poisson")

fit_iClusterVB &lt;- iClusterVB(
  mydata = dat1,
  dist = dist,
  K = 4,
  initial_method = "VarSelLCM",
  VS_method = 1,
  max_iter = 25
)

plot(fit_iClusterVB)

</code></pre>

<hr>
<h2 id='sim_data'>Simulated Dataset</h2><span id='topic+sim_data'></span>

<h3>Description</h3>

<p>The dataset consists of <code class="reqn">N = 240</code> individuals and <code class="reqn">R =
  4</code> data views with different data types. Two of the data views are
continuous, one is count, and one is binary. The <em>true</em> number of
clusters was set to <code class="reqn">K = 4</code>, and the cluster proportions were set at <code class="reqn">\pi_1
  = 0.25, \pi_2 = 0.25, \pi_3 = 0.25, \pi_4 = 0.25</code>, such that we have
balanced cluster proportions. Each of the data views had <code class="reqn">p_r = 500</code>
features, <code class="reqn">r = 1, \dots, 4</code>, but only 50, or 10%, were relevant
features that contributed to the clustering, and the rest were noise
features that did not contribute to the clustering. In total, there were
<code class="reqn">p = \sum_{r=1}^4 = 2000</code> features.
</p>
<p>For data view 1 (continuous), relevant features were generated from the
following normal distributions: <code class="reqn">\text{N}(10, 1)</code> for Cluster 1,
<code class="reqn">\text{N}(5, 1)</code> for Cluster 2, <code class="reqn">\text{N}(-5, 1)</code> for Cluster 3,
and <code class="reqn">\text{N}(-10, 1)</code> for Cluster 4, while noise features were
generated from <code class="reqn">\text{N}(0, 1)</code>. For data view 2 (continuous), relevant
features were generated from the following normal distributions:
<code class="reqn">\text{N}(-10, 1)</code> for Cluster 1,    <code class="reqn">\text{N}(-5, 1)</code> for Cluster
2, <code class="reqn">\text{N}(5, 1)</code> for Cluster 3, and <code class="reqn">\text{N}(10, 1)</code> for
Cluster 4, while noise features were generated from <code class="reqn">\text{N}(0, 1)</code>.
For data view 3 (binary), relevant features were generated from the
following Bernoulli distributions: <code class="reqn">\text{Bernoulli}(0.05)</code> for Cluster
1,    <code class="reqn">\text{Bernoulli}(0.2)</code> for Cluster 2,
<code class="reqn">\text{Bernoulli}(0.4)</code> for Cluster 3, and <code class="reqn">\text{Bernoulli}(0.6)</code>
for Cluster 4, while noise features were generated from
<code class="reqn">\text{Bernoulli}(0.1)</code>. For data view 4 (count), relevant features
were generated from the following Poisson distributions:
<code class="reqn">\text{Poisson}(50)</code> for Cluster 1, <code class="reqn">\text{Poisson}(35)</code> for
Cluster 2, <code class="reqn">\text{Poisson}(20)</code> for Cluster 3, and
<code class="reqn">\text{Poisson}(10)</code> for Cluster 4, while noise features were generated
from <code class="reqn">\text{Poisson}(2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sim_data)
</code></pre>


<h3>Format</h3>

<p>A list containing four datasets, and other elements of interest.
</p>

<hr>
<h2 id='summary.iClusterVB'>Generic summary method for 'iClusterVB' objects</h2><span id='topic+summary.iClusterVB'></span>

<h3>Description</h3>

<p>Generic summary method for 'iClusterVB' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iClusterVB'
summary(object, rho = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.iClusterVB_+3A_object">object</code></td>
<td>
<p>A fitted iClusterVB object.</p>
</td></tr>
<tr><td><code id="summary.iClusterVB_+3A_rho">rho</code></td>
<td>
<p>The minimum posterior inclusion probability of interest to count
the number of features that are &gt;= <code>rho</code>. Default is 0.5. Only works
for VS_method = 1.</p>
</td></tr>
<tr><td><code id="summary.iClusterVB_+3A_...">...</code></td>
<td>
<p>Potential further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a summary list for an 'agnes' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting up the data
dat1 &lt;- list(
  gauss_1 = sim_data$continuous1_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  gauss_2 = sim_data$continuous2_data[c(1:20, 61:80, 121:140, 181:200), 1:75],
  poisson_1 = sim_data$count_data[c(1:20, 61:80, 121:140, 181:200), 1:75])

dist &lt;- c(
  "gaussian", "gaussian",
  "poisson")

fit_iClusterVB &lt;- iClusterVB(
  mydata = dat1,
  dist = dist,
  K = 4,
  initial_method = "VarSelLCM",
  VS_method = 1,
  max_iter = 25
)

## S3 method for class 'iClusterVB'
summary(fit_iClusterVB, rho = 0.75)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
