<!DOCTYPE html><html><head><title>Help for package bioseq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bioseq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aa'><p>Build an amino acid (AA) vector</p></a></li>
<li><a href='#aliview'><p>AliView: DNA sequences viewer</p></a></li>
<li><a href='#alphabets'><p>Biological alphabets</p></a></li>
<li><a href='#as_aa'><p>Coercion to an amino acid (AA) vector</p></a></li>
<li><a href='#as_AAbin'><p>Coerce to AAbin</p></a></li>
<li><a href='#as_AAbin.tbl_df'><p>Coerce tibble to AAbin</p></a></li>
<li><a href='#as_dna'><p>Coercion to DNA vector</p></a></li>
<li><a href='#as_DNAbin'><p>Coerce to DNAbin</p></a></li>
<li><a href='#as_DNAbin.tbl_df'><p>Coerce tibble to DNAbin</p></a></li>
<li><a href='#as_rna'><p>Coercion to RNA vector</p></a></li>
<li><a href='#as_seqinr_alignment'><p>Coerce to seqinr alignment</p></a></li>
<li><a href='#as-tibble-ape'><p>Convert DNAbin/AAbin to tibble</p></a></li>
<li><a href='#as-tibble-bioseq'><p>Convert bioseq DNA, RNA and AA to tibble</p></a></li>
<li><a href='#bioseq-package'><p>bioseq: A Toolbox for Manipulating Biological Sequences</p></a></li>
<li><a href='#dic_genetic_codes'><p>Genetic code tables</p></a></li>
<li><a href='#dna'><p>Build a DNA vector</p></a></li>
<li><a href='#fragilaria'><p>DNA sequences (rbcL) for various Fragilaria</p></a></li>
<li><a href='#genetic-codes'><p>Genetic code tables</p></a></li>
<li><a href='#is_aa'><p>Test if the object is an amino acid vector</p></a></li>
<li><a href='#is_dna'><p>Test if the object is a DNA vector</p></a></li>
<li><a href='#is_rna'><p>Test if the object is a RNA vector</p></a></li>
<li><a href='#new_aa'><p>Amino acid (AA) vector constructor</p></a></li>
<li><a href='#new_dna'><p>DNA vector constructor</p></a></li>
<li><a href='#new_rna'><p>RNA vector constructor</p></a></li>
<li><a href='#pillar_shaft.bioseq_aa'><p>Internal formatting</p></a></li>
<li><a href='#pillar_shaft.bioseq_dna'><p>Internal formatting</p></a></li>
<li><a href='#pillar_shaft.bioseq_rna'><p>Internal formatting</p></a></li>
<li><a href='#read_fasta'><p>Read sequences in FASTA format</p></a></li>
<li><a href='#rev_complement'><p>Reverse and complement sequences</p></a></li>
<li><a href='#rna'><p>Build a RNA vector</p></a></li>
<li><a href='#seaview'><p>SeaView: DNA sequences and phylogenetic tree viewer</p></a></li>
<li><a href='#seq_cluster'><p>Cluster sequences by similarity</p></a></li>
<li><a href='#seq_combine'><p>Combine multiple sequences</p></a></li>
<li><a href='#seq_consensus'><p>Find a consensus sequence for a set of sequences.</p></a></li>
<li><a href='#seq_count_pattern'><p>Count the number of matches in sequences</p></a></li>
<li><a href='#seq_crop_pattern'><p>Crop sequences using delimiting patterns</p></a></li>
<li><a href='#seq_crop_position'><p>Crop sequences between two positions</p></a></li>
<li><a href='#seq_detect_pattern'><p>Detect the presence of patterns in sequences</p></a></li>
<li><a href='#seq_disambiguate_IUPAC'><p>Disambiguate biological sequences</p></a></li>
<li><a href='#seq_extract_pattern'><p>Extract matching patterns from sequences</p></a></li>
<li><a href='#seq_extract_position'><p>Extract a region between two positions in sequences</p></a></li>
<li><a href='#seq_nchar'><p>Count the number of character in sequences</p></a></li>
<li><a href='#seq_nseq'><p>Number of sequences in a vector</p></a></li>
<li><a href='#seq_remove_pattern'><p>Remove matched patterns in sequences</p></a></li>
<li><a href='#seq_remove_position'><p>Remove a region between two positions in sequences.</p></a></li>
<li><a href='#seq_replace_position'><p>Replace a region between two positions in sequences</p></a></li>
<li><a href='#seq_rev_translate'><p>Reverse translate amino acid sequences</p></a></li>
<li><a href='#seq_spellout'><p>Spell out sequences</p></a></li>
<li><a href='#seq_split_kmer'><p>Split sequences into k-mers</p></a></li>
<li><a href='#seq_split_pattern'><p>Split sequences</p></a></li>
<li><a href='#seq_stat_gc'><p>Compute G+C content</p></a></li>
<li><a href='#seq_stat_prop'><p>Compute proportions for characters</p></a></li>
<li><a href='#seq_translate'><p>Translate DNA/RNA sequences into amino acids</p></a></li>
<li><a href='#seq-replace'><p>Replace matched patterns in sequences</p></a></li>
<li><a href='#transcription'><p>Transcribe DNA, reverse-transcribe RNA</p></a></li>
<li><a href='#validate_seq'><p>Sequence validator</p></a></li>
<li><a href='#vec_ptype2.bioseq_aa'><p>Internal</p></a></li>
<li><a href='#write_fasta'><p>Write sequences in FASTA format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Toolbox for Manipulating Biological Sequences</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francois Keck &lt;francois.keck@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and functions to work with biological sequences (DNA, RNA and amino acid sequences).
    Implements S3 infrastructure to work with biological sequences as described in Keck (2020) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13490">doi:10.1111/2041-210X.13490</a>&gt;.
    Provides a collection of functions to perform biological conversion among classes
    (transcription, translation) and basic operations on sequences
    (detection, selection and replacement based on positions or patterns).
    The package also provides functions to import and export sequences from and to other package formats.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fkeck.github.io/bioseq/">https://fkeck.github.io/bioseq/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fkeck/bioseq/issues">https://github.com/fkeck/bioseq/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, vctrs, tibble, ape, crayon, dplyr, pillar, stringi,
stringr, stringdist, readr, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0), covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-12 12:49:49 UTC; ecoadmin</td>
</tr>
<tr>
<td>Author:</td>
<td>Francois Keck <a href="https://orcid.org/0000-0002-3323-4167"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-06 11:40:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='aa'>Build an amino acid (AA) vector</h2><span id='topic+aa'></span>

<h3>Description</h3>

<p><code>aa()</code> build a AA vector from a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aa(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aa_+3A_...">...</code></td>
<td>
<p>character to turn into AA. Can be a set of name-value pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of class bioseq_aa
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+dna">dna</a>()</code>,
<code><a href="#topic+rna">rna</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
aa("AGGTGC", "TTCGA")

aa(Seq_1 = "AGGTGC", Seq_2 = "TTCGA")

x &lt;- c("AGGTGC", "TTCGA")
aa(x)

</code></pre>

<hr>
<h2 id='aliview'>AliView: DNA sequences viewer</h2><span id='topic+aliview'></span>

<h3>Description</h3>

<p>This function uses AliView (Larsson, 2014) to visualize DNA sequences.
The software must be installed on the computer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aliview(
  x,
  aliview_exec = getOption("bioseq.aliview.exec", default = "aliview")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aliview_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.
Alternatively a <code>DNAbin</code> or <code>AAbin</code> object.</p>
</td></tr>
<tr><td><code id="aliview_+3A_aliview_exec">aliview_exec</code></td>
<td>
<p>a character string giving the path of the program.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the function assumes that the executable is installed
in a directory located on the PATH. Alternatively the user can provide
an absolute path to the executable (i.e. the location where the software
was installed/uncompressed). This information can be stored in the global
options settings using
<code>options(bioseq.aliview.exec = "my_path_to_aliview")</code>.
</p>


<h3>References</h3>

<p>Larsson, A. (2014). AliView: a fast and lightweight alignment
viewer and editor for large data sets. Bioinformatics 30(22): 3276-3278.
</p>


<h3>See Also</h3>

<p>Other GUI wrappers: 
<code><a href="#topic+seaview">seaview</a>()</code>
</p>

<hr>
<h2 id='alphabets'>Biological alphabets</h2><span id='topic+alphabets'></span>

<h3>Description</h3>

<p>List of the allowed characters for each type of sequences.
</p>


<h3>DNA</h3>

<p><code>A C G T W S M K R Y B D H V N -</code>
</p>


<h3>RNA</h3>

<p><code>A C G U W S M K R Y B D H V N -</code>
</p>


<h3>AA</h3>

<p><code>A C D E F G H I K L M N P Q R S T V W Y B X Z J U O * -</code>
</p>


<h3>References</h3>

<p>Nomenclature Committee of the
International Union of Biochemistry (NC-IUB) (1986).
Proc. Natl. Acad. Sci. USA. 83 (1): 4–8.
</p>
<p>Nomenclature and Symbolism for Amino Acids and Peptides.
IUPAC-IUB Joint Commission on Biochemical Nomenclature. 1983.
</p>

<hr>
<h2 id='as_aa'>Coercion to an amino acid (AA) vector</h2><span id='topic+as_aa'></span>

<h3>Description</h3>

<p>Coercion to an amino acid (AA) vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_aa(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_aa_+3A_x">x</code></td>
<td>
<p>An object to coerce.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An amino acid vector of class bioseq_aa
</p>


<h3>See Also</h3>

<p>Other conversions: 
<code><a href="#topic+as-tibble-ape">as-tibble-ape</a></code>,
<code><a href="#topic+as-tibble-bioseq">as-tibble-bioseq</a></code>,
<code><a href="#topic+as_AAbin">as_AAbin</a>()</code>,
<code><a href="#topic+as_DNAbin">as_DNAbin</a>()</code>,
<code><a href="#topic+as_dna">as_dna</a>()</code>,
<code><a href="#topic+as_rna">as_rna</a>()</code>,
<code><a href="#topic+as_seqinr_alignment">as_seqinr_alignment</a>()</code>
</p>

<hr>
<h2 id='as_AAbin'>Coerce to AAbin</h2><span id='topic+as_AAbin'></span>

<h3>Description</h3>

<p>Coerce to AAbin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_AAbin(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_AAbin_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="as_AAbin_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An AAbin object.
</p>


<h3>See Also</h3>

<p>Other conversions: 
<code><a href="#topic+as-tibble-ape">as-tibble-ape</a></code>,
<code><a href="#topic+as-tibble-bioseq">as-tibble-bioseq</a></code>,
<code><a href="#topic+as_DNAbin">as_DNAbin</a>()</code>,
<code><a href="#topic+as_aa">as_aa</a>()</code>,
<code><a href="#topic+as_dna">as_dna</a>()</code>,
<code><a href="#topic+as_rna">as_rna</a>()</code>,
<code><a href="#topic+as_seqinr_alignment">as_seqinr_alignment</a>()</code>
</p>

<hr>
<h2 id='as_AAbin.tbl_df'>Coerce tibble to AAbin</h2><span id='topic+as_AAbin.tbl_df'></span>

<h3>Description</h3>

<p>Coerce tibble to AAbin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_df'
as_AAbin(x, sequences, labels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_AAbin.tbl_df_+3A_x">x</code></td>
<td>
<p>a tibble.</p>
</td></tr>
<tr><td><code id="as_AAbin.tbl_df_+3A_sequences">sequences</code></td>
<td>
<p>Name of the tibble column that stores the sequences.</p>
</td></tr>
<tr><td><code id="as_AAbin.tbl_df_+3A_labels">labels</code></td>
<td>
<p>Name of the tibble column that stores the sequence labels.</p>
</td></tr>
<tr><td><code id="as_AAbin.tbl_df_+3A_...">...</code></td>
<td>
<p>Other params.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An AAbin object.
</p>

<hr>
<h2 id='as_dna'>Coercion to DNA vector</h2><span id='topic+as_dna'></span>

<h3>Description</h3>

<p>Coercion to DNA vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_dna(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_dna_+3A_x">x</code></td>
<td>
<p>An object to coerce.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DNA vector of class bioseq_dna
</p>


<h3>See Also</h3>

<p>Other conversions: 
<code><a href="#topic+as-tibble-ape">as-tibble-ape</a></code>,
<code><a href="#topic+as-tibble-bioseq">as-tibble-bioseq</a></code>,
<code><a href="#topic+as_AAbin">as_AAbin</a>()</code>,
<code><a href="#topic+as_DNAbin">as_DNAbin</a>()</code>,
<code><a href="#topic+as_aa">as_aa</a>()</code>,
<code><a href="#topic+as_rna">as_rna</a>()</code>,
<code><a href="#topic+as_seqinr_alignment">as_seqinr_alignment</a>()</code>
</p>

<hr>
<h2 id='as_DNAbin'>Coerce to DNAbin</h2><span id='topic+as_DNAbin'></span>

<h3>Description</h3>

<p>Coerce to DNAbin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_DNAbin(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_DNAbin_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="as_DNAbin_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DNAbin object.
</p>


<h3>See Also</h3>

<p>Other conversions: 
<code><a href="#topic+as-tibble-ape">as-tibble-ape</a></code>,
<code><a href="#topic+as-tibble-bioseq">as-tibble-bioseq</a></code>,
<code><a href="#topic+as_AAbin">as_AAbin</a>()</code>,
<code><a href="#topic+as_aa">as_aa</a>()</code>,
<code><a href="#topic+as_dna">as_dna</a>()</code>,
<code><a href="#topic+as_rna">as_rna</a>()</code>,
<code><a href="#topic+as_seqinr_alignment">as_seqinr_alignment</a>()</code>
</p>

<hr>
<h2 id='as_DNAbin.tbl_df'>Coerce tibble to DNAbin</h2><span id='topic+as_DNAbin.tbl_df'></span>

<h3>Description</h3>

<p>Coerce tibble to DNAbin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_df'
as_DNAbin(x, sequences, labels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_DNAbin.tbl_df_+3A_x">x</code></td>
<td>
<p>a tibble.</p>
</td></tr>
<tr><td><code id="as_DNAbin.tbl_df_+3A_sequences">sequences</code></td>
<td>
<p>Name of the tibble column that stores the sequences.</p>
</td></tr>
<tr><td><code id="as_DNAbin.tbl_df_+3A_labels">labels</code></td>
<td>
<p>Name of the tibble column that stores the sequence labels.</p>
</td></tr>
<tr><td><code id="as_DNAbin.tbl_df_+3A_...">...</code></td>
<td>
<p>Other params.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DNAbin object.
</p>

<hr>
<h2 id='as_rna'>Coercion to RNA vector</h2><span id='topic+as_rna'></span>

<h3>Description</h3>

<p>Coercion to RNA vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_rna(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_rna_+3A_x">x</code></td>
<td>
<p>An object to coerce.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A RNA vector of class bioseq_rna
</p>


<h3>See Also</h3>

<p>Other conversions: 
<code><a href="#topic+as-tibble-ape">as-tibble-ape</a></code>,
<code><a href="#topic+as-tibble-bioseq">as-tibble-bioseq</a></code>,
<code><a href="#topic+as_AAbin">as_AAbin</a>()</code>,
<code><a href="#topic+as_DNAbin">as_DNAbin</a>()</code>,
<code><a href="#topic+as_aa">as_aa</a>()</code>,
<code><a href="#topic+as_dna">as_dna</a>()</code>,
<code><a href="#topic+as_seqinr_alignment">as_seqinr_alignment</a>()</code>
</p>

<hr>
<h2 id='as_seqinr_alignment'>Coerce to seqinr alignment</h2><span id='topic+as_seqinr_alignment'></span>

<h3>Description</h3>

<p>Coerce to seqinr alignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_seqinr_alignment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_seqinr_alignment_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="as_seqinr_alignment_+3A_...">...</code></td>
<td>
<p>Other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An alignment object.
</p>


<h3>See Also</h3>

<p>Other conversions: 
<code><a href="#topic+as-tibble-ape">as-tibble-ape</a></code>,
<code><a href="#topic+as-tibble-bioseq">as-tibble-bioseq</a></code>,
<code><a href="#topic+as_AAbin">as_AAbin</a>()</code>,
<code><a href="#topic+as_DNAbin">as_DNAbin</a>()</code>,
<code><a href="#topic+as_aa">as_aa</a>()</code>,
<code><a href="#topic+as_dna">as_dna</a>()</code>,
<code><a href="#topic+as_rna">as_rna</a>()</code>
</p>

<hr>
<h2 id='as-tibble-ape'>Convert DNAbin/AAbin to tibble</h2><span id='topic+as-tibble-ape'></span><span id='topic+as_tibble.DNAbin'></span><span id='topic+as_tibble.AAbin'></span>

<h3>Description</h3>

<p>These methods convert sequences from <span class="pkg">ape</span>
formats DNAbin and AAbin to tibbles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tibble.DNAbin(x, label = "label", sequence = "sequence", ...)

as_tibble.AAbin(x, label = "label", sequence = "sequence", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as-tibble-ape_+3A_x">x</code></td>
<td>
<p>a DNAbin or AAbin object.</p>
</td></tr>
<tr><td><code id="as-tibble-ape_+3A_label">label</code></td>
<td>
<p>Name of the column that stores the sequence labels
in the returned tibble.</p>
</td></tr>
<tr><td><code id="as-tibble-ape_+3A_sequence">sequence</code></td>
<td>
<p>Name of the column that stores the sequences in the
returned tibble.</p>
</td></tr>
<tr><td><code id="as-tibble-ape_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with two columns (if name is not NULL, the default) or one
column (otherwise).
</p>


<h3>See Also</h3>

<p>Other conversions: 
<code><a href="#topic+as-tibble-bioseq">as-tibble-bioseq</a></code>,
<code><a href="#topic+as_AAbin">as_AAbin</a>()</code>,
<code><a href="#topic+as_DNAbin">as_DNAbin</a>()</code>,
<code><a href="#topic+as_aa">as_aa</a>()</code>,
<code><a href="#topic+as_dna">as_dna</a>()</code>,
<code><a href="#topic+as_rna">as_rna</a>()</code>,
<code><a href="#topic+as_seqinr_alignment">as_seqinr_alignment</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ape)
require(tibble)
x &lt;- rDNAbin(nrow = 10, ncol = 25)
as_tibble.DNAbin(x)


</code></pre>

<hr>
<h2 id='as-tibble-bioseq'>Convert bioseq DNA, RNA and AA to tibble</h2><span id='topic+as-tibble-bioseq'></span><span id='topic+as_tibble.bioseq_dna'></span><span id='topic+as_tibble.bioseq_rna'></span><span id='topic+as_tibble.bioseq_aa'></span>

<h3>Description</h3>

<p>Convert bioseq DNA, RNA and AA to tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_tibble.bioseq_dna(x, label = "label", sequence = "sequence", ...)

as_tibble.bioseq_rna(x, label = "label", sequence = "sequence", ...)

as_tibble.bioseq_aa(x, label = "label", sequence = "sequence", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as-tibble-bioseq_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="as-tibble-bioseq_+3A_label">label</code></td>
<td>
<p>Name of the column that stores the sequence
labels in the returned tibble.</p>
</td></tr>
<tr><td><code id="as-tibble-bioseq_+3A_sequence">sequence</code></td>
<td>
<p>Name of the column that stores the sequences
in the returned tibble.</p>
</td></tr>
<tr><td><code id="as-tibble-bioseq_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with two columns (if name is not NULL, the default)
or one column (otherwise).
</p>


<h3>See Also</h3>

<p>Other conversions: 
<code><a href="#topic+as-tibble-ape">as-tibble-ape</a></code>,
<code><a href="#topic+as_AAbin">as_AAbin</a>()</code>,
<code><a href="#topic+as_DNAbin">as_DNAbin</a>()</code>,
<code><a href="#topic+as_aa">as_aa</a>()</code>,
<code><a href="#topic+as_dna">as_dna</a>()</code>,
<code><a href="#topic+as_rna">as_rna</a>()</code>,
<code><a href="#topic+as_seqinr_alignment">as_seqinr_alignment</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(tibble)
x &lt;- dna(A = "ACGTTAGTGTAGCCGT", B = "CTCGAAATGA", C = NA)
as_tibble(x)


</code></pre>

<hr>
<h2 id='bioseq-package'>bioseq: A Toolbox for Manipulating Biological Sequences</h2><span id='topic+bioseq'></span><span id='topic+bioseq-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Classes and functions to work with biological sequences (DNA, RNA and amino acid sequences). Implements S3 infrastructure to work with biological sequences as described in Keck (2020) doi: <a href="https://doi.org/10.1111/2041-210X.13490">10.1111/2041-210X.13490</a>. Provides a collection of functions to perform biological conversion among classes (transcription, translation) and basic operations on sequences (detection, selection and replacement based on positions or patterns). The package also provides functions to import and export sequences from and to other package formats.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Francois Keck <a href="mailto:francois.keck@gmail.com">francois.keck@gmail.com</a> (<a href="https://orcid.org/0000-0002-3323-4167">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://fkeck.github.io/bioseq/">https://fkeck.github.io/bioseq/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/fkeck/bioseq/issues">https://github.com/fkeck/bioseq/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dic_genetic_codes'>Genetic code tables</h2><span id='topic+dic_genetic_codes'></span>

<h3>Description</h3>

<p>The function returns a list of named vectors with
Start, Stop and Full_name attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dic_genetic_codes()
</code></pre>


<h3>Value</h3>

<p>A list of genetic code tables for DNA/RNA translation.
</p>

<hr>
<h2 id='dna'>Build a DNA vector</h2><span id='topic+dna'></span>

<h3>Description</h3>

<p><code>dna()</code> build a DNA vector from a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dna(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dna_+3A_...">...</code></td>
<td>
<p>characters to turn into DNA. Can be a set of name-value pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of class <code>bioseq_dna</code>
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+aa">aa</a>()</code>,
<code><a href="#topic+rna">rna</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dna("AGGTGC", "TTCGA")

dna(Seq_1 = "AGGTGC", Seq_2 = "TTCGA")

x &lt;- c("AGGTGC", "TTCGA")
dna(x)

</code></pre>

<hr>
<h2 id='fragilaria'>DNA sequences (rbcL) for various Fragilaria</h2><span id='topic+fragilaria'></span>

<h3>Description</h3>

<p>An unparsed FASTA of DNA sequences (rbcL) for various strains of Fragilaria
retrieved from NCBI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fragilaria
</code></pre>


<h3>Format</h3>

<p>A long character vector (unparsed FASTA).
</p>


<h3>Source</h3>

<p>GenBank <a href="https://www.ncbi.nlm.nih.gov/genbank/">https://www.ncbi.nlm.nih.gov/genbank/</a> using
the following search term: &quot;(rbcl) AND Fragilaria&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_fasta">read_fasta</a></code> to parse these data.
</p>

<hr>
<h2 id='genetic-codes'>Genetic code tables</h2><span id='topic+genetic-codes'></span>

<h3>Description</h3>

<p>List of all genetic code tables available in <code>bioseq</code>.
The number in bold can be used to select a table in appropriate functions.
</p>


<h3>Available genetic codes</h3>

<p><strong>1</strong><code>.    </code>Standard
</p>
<p><strong>2</strong><code>.    </code>Vertebrate Mitochondrial
</p>
<p><strong>3</strong><code>.    </code>Yeast Mitochondrial
</p>
<p><strong>4</strong><code>.    </code>Mold Mitochondrial; Protozoan Mitochondrial;
Coelenterate Mitochondrial; Mycoplasma; Spiroplasma
</p>
<p><strong>5</strong><code>.    </code>Invertebrate Mitochondrial
</p>
<p><strong>6</strong><code>.    </code>Ciliate Nuclear; Dasycladacean Nuclear;
Hexamita Nuclear
</p>
<p><strong>9</strong><code>.    </code>Echinoderm Mitochondrial; Flatworm Mitochondrial
</p>
<p><strong>10</strong><code>.    </code>Euplotid Nuclear
</p>
<p><strong>11</strong><code>.    </code>Bacterial, Archaeal and Plant Plastid
</p>
<p><strong>12</strong><code>.    </code>Alternative Yeast Nuclear
</p>
<p><strong>13</strong><code>.    </code>Ascidian Mitochondrial
</p>
<p><strong>14</strong><code>.    </code>Alternative Flatworm Mitochondrial
</p>
<p><strong>15</strong><code>.    </code>Blepharisma Macronuclear
</p>
<p><strong>16</strong><code>.    </code>Chlorophycean Mitochondrial
</p>
<p><strong>21</strong><code>.    </code>Trematode Mitochondrial
</p>
<p><strong>22</strong><code>.    </code>Scenedesmus obliquus Mitochondrial
</p>
<p><strong>23</strong><code>.    </code>Thraustochytrium Mitochondrial
</p>
<p><strong>24</strong><code>.    </code>Pterobranchia Mitochondrial
</p>
<p><strong>25</strong><code>.    </code>Candidate Division SR1 and Gracilibacteria
</p>
<p><strong>26</strong><code>.    </code>Pachysolen tannophilus Nuclear
</p>
<p><strong>27</strong><code>.    </code>Karyorelict Nuclear
</p>
<p><strong>28</strong><code>.    </code>Condylostoma Nuclear
</p>
<p><strong>29</strong><code>.    </code>Mesodinium Nuclear
</p>
<p><strong>30</strong><code>.    </code>Peritrich Nuclear
</p>
<p><strong>31</strong><code>.    </code>Blastocrithidia Nuclear
</p>
<p><strong>32</strong><code>.    </code>Balanophoraceae Plastid
</p>
<p><strong>33</strong><code>.    </code>Cephalodiscidae Mitochondrial
</p>


<h3>References</h3>

<p>Andrzej (Anjay) Elzanowski and Jim Ostell at
National Center for Biotechnology Information (NCBI),
Bethesda, Maryland, U.S.A.
<a href="https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes">https://www.ncbi.nlm.nih.gov/Taxonomy/taxonomyhome.html/index.cgi?chapter=tgencodes</a>
</p>

<hr>
<h2 id='is_aa'>Test if the object is an amino acid vector</h2><span id='topic+is_aa'></span>

<h3>Description</h3>

<p>This function returns TRUE for objects of class bioseq_aa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_aa(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_aa_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("AGGTGC", "TTCGA")
is_aa(x)
y &lt;- aa(x)
is_aa(x)

</code></pre>

<hr>
<h2 id='is_dna'>Test if the object is a DNA vector</h2><span id='topic+is_dna'></span>

<h3>Description</h3>

<p>This function returns TRUE for objects of class bioseq_dna
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dna(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dna_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("AGGTGC", "TTCGA")
is_dna(x)
y &lt;- dna(x)
is_dna(y)

</code></pre>

<hr>
<h2 id='is_rna'>Test if the object is a RNA vector</h2><span id='topic+is_rna'></span>

<h3>Description</h3>

<p>This function returns TRUE for objects of class bioseq_rna
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rna(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rna_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("AGGTGC", "TTCGA")
is_rna(x)
y &lt;- rna(x)
is_rna(x)

</code></pre>

<hr>
<h2 id='new_aa'>Amino acid (AA) vector constructor</h2><span id='topic+new_aa'></span>

<h3>Description</h3>

<p>Amino acid (AA) vector constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_aa(x = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_aa_+3A_x">x</code></td>
<td>
<p>a character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='new_dna'>DNA vector constructor</h2><span id='topic+new_dna'></span>

<h3>Description</h3>

<p>DNA vector constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_dna(x = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_dna_+3A_x">x</code></td>
<td>
<p>a character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='new_rna'>RNA vector constructor</h2><span id='topic+new_rna'></span>

<h3>Description</h3>

<p>RNA vector constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_rna(x = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_rna_+3A_x">x</code></td>
<td>
<p>a character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='pillar_shaft.bioseq_aa'>Internal formatting</h2><span id='topic+pillar_shaft.bioseq_aa'></span>

<h3>Description</h3>

<p>Internal formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pillar_shaft.bioseq_aa(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pillar_shaft.bioseq_aa_+3A_x">x</code></td>
<td>
<p>a object.</p>
</td></tr>
<tr><td><code id="pillar_shaft.bioseq_aa_+3A_...">...</code></td>
<td>
<p>other params.</p>
</td></tr>
</table>

<hr>
<h2 id='pillar_shaft.bioseq_dna'>Internal formatting</h2><span id='topic+pillar_shaft.bioseq_dna'></span>

<h3>Description</h3>

<p>Internal formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pillar_shaft.bioseq_dna(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pillar_shaft.bioseq_dna_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="pillar_shaft.bioseq_dna_+3A_...">...</code></td>
<td>
<p>other params.</p>
</td></tr>
</table>

<hr>
<h2 id='pillar_shaft.bioseq_rna'>Internal formatting</h2><span id='topic+pillar_shaft.bioseq_rna'></span>

<h3>Description</h3>

<p>Internal formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pillar_shaft.bioseq_rna(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pillar_shaft.bioseq_rna_+3A_x">x</code></td>
<td>
<p>a object.</p>
</td></tr>
<tr><td><code id="pillar_shaft.bioseq_rna_+3A_...">...</code></td>
<td>
<p>other params.</p>
</td></tr>
</table>

<hr>
<h2 id='read_fasta'>Read sequences in FASTA format</h2><span id='topic+read_fasta'></span>

<h3>Description</h3>

<p>Read sequences in FASTA format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fasta(file, type = "DNA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fasta_+3A_file">file</code></td>
<td>
<p>A path to a file, a connection or a character string.</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_type">type</code></td>
<td>
<p>Type of data. Can be &quot;DNA&quot; (the default), &quot;RNA&quot; or &quot;AA&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DNA, RNA or AA vector (depending on <code>type</code> argument).
</p>


<h3>See Also</h3>

<p>Other input/output operations: 
<code><a href="#topic+write_fasta">write_fasta</a>()</code>
</p>

<hr>
<h2 id='rev_complement'>Reverse and complement sequences</h2><span id='topic+rev_complement'></span><span id='topic+seq_complement'></span><span id='topic+seq_reverse'></span>

<h3>Description</h3>

<p>Reverse and complement sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_complement(x)

seq_reverse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev_complement_+3A_x">x</code></td>
<td>
<p>a DNA or RNA vector.
Function <code>seq_reverse</code> also accepts AA vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reverse or complement sequence (same class as the input).
</p>


<h3>See Also</h3>

<p>Other biological operations: 
<code><a href="#topic+seq_rev_translate">seq_rev_translate</a>()</code>,
<code><a href="#topic+seq_translate">seq_translate</a>()</code>,
<code><a href="#topic+transcription">transcription</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dna("ACTTTGGCTAAG")
seq_reverse(x)
seq_complement(x)

</code></pre>

<hr>
<h2 id='rna'>Build a RNA vector</h2><span id='topic+rna'></span>

<h3>Description</h3>

<p><code>rna()</code> build a RNA vector from a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rna(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rna_+3A_...">...</code></td>
<td>
<p>characters to turn into RNA. Can be a set of name-value pairs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of class bioseq_rna
</p>


<h3>See Also</h3>

<p>Other classes: 
<code><a href="#topic+aa">aa</a>()</code>,
<code><a href="#topic+dna">dna</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rna("AGGUGC", "UUCGA")

rna(Seq_1 = "AGGUGC", Seq_2 = "UUCGA")

x &lt;- c("AGGTGC", "TTCGA")
rna(x)

</code></pre>

<hr>
<h2 id='seaview'>SeaView: DNA sequences and phylogenetic tree viewer</h2><span id='topic+seaview'></span>

<h3>Description</h3>

<p>This function opens SeaView (Gouy, Guindon &amp; Gascuel, 2010)
to visualize biological sequences and phylogenetic trees.
The software must be installed on the computer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seaview(
  x,
  seaview_exec = getOption("bioseq.seaview.exec", default = "seawiew")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seaview_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.
Alternatively a <code>DNAbin</code> or <code>AAbin</code> object or
a phylogenetic tree (class <code>phylo</code>).</p>
</td></tr>
<tr><td><code id="seaview_+3A_seaview_exec">seaview_exec</code></td>
<td>
<p>a character string giving the path of the program.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the function assumes that the executable is installed
in a directory located on the PATH. Alternatively the user can provide
an absolute path to the executable (i.e. the location where the software
was installed/uncompressed). This can be stored in the global
options settings using
<code>options(bioseq.seaview.exec = "my_path_to_seaview")</code>.
</p>


<h3>References</h3>

<p>Gouy M., Guindon S. &amp; Gascuel O. (2010) SeaView version 4 :
a multiplatform graphical user interface for sequence
alignment and phylogenetic tree building.
Molecular Biology and Evolution 27(2):221-224.
</p>


<h3>See Also</h3>

<p>Other GUI wrappers: 
<code><a href="#topic+aliview">aliview</a>()</code>
</p>

<hr>
<h2 id='seq_cluster'>Cluster sequences by similarity</h2><span id='topic+seq_cluster'></span>

<h3>Description</h3>

<p>Cluster sequences by similarity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_cluster(x, threshold = 0.05, method = "complete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_cluster_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector of sequences to clustered.</p>
</td></tr>
<tr><td><code id="seq_cluster_+3A_threshold">threshold</code></td>
<td>
<p>Threshold value (range in [0, 1]).</p>
</td></tr>
<tr><td><code id="seq_cluster_+3A_method">method</code></td>
<td>
<p>the clustering method (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses <span class="pkg">ape</span> <code><a href="ape.html#topic+dist.dna">dist.dna</a></code> and
<code><a href="ape.html#topic+dist.aa">dist.aa</a></code>
functions to compute pairwise distances among sequences and
<code><a href="stats.html#topic+hclust">hclust</a></code> for clustering.
</p>
<p>Computing a full pairwise diastance matrix can be computationally expensive.
It is recommended to use this function for moderate size dataset.
</p>
<p>Supported methods are:
</p>

<ul>
<li> <p><code>"single"</code> (= Nearest Neighbour Clustering)
</p>
</li>
<li> <p><code>"complete"</code> (= Farthest Neighbour Clustering)
</p>
</li>
<li> <p><code>"average"</code> (= UPGMA)
</p>
</li>
<li> <p><code>"mcquitty"</code> (= WPGMA)
</p>
</li></ul>



<h3>Value</h3>

<p>An integer vector with group memberships.
</p>


<h3>See Also</h3>

<p>Function <code><a href="#topic+seq_consensus">seq_consensus</a></code> to compute consensus
and representative sequences for clusters.
</p>
<p>Other aggregation operations: 
<code><a href="#topic+seq_consensus">seq_consensus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c("-----TACGCAGTAAAAGCTACTGATG",
       "CGTCATACGCAGTAAAAACTACTGATG",
       "CTTCATACGCAGTAAAAACTACTGATG",
       "CTTCATATGCAGTAAAAACTACTGATG",
       "CTTCATACGCAGTAAAAACTACTGATG",
       "CGTCATACGCAGTAAAAGCTACTGATG",
       "CTTCATATGCAGTAAAAGCTACTGACG")
x &lt;- dna(x)
seq_cluster(x)

</code></pre>

<hr>
<h2 id='seq_combine'>Combine multiple sequences</h2><span id='topic+seq_combine'></span>

<h3>Description</h3>

<p>Combine multiple sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_combine(..., sep = "", collapse = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_combine_+3A_...">...</code></td>
<td>
<p>One or more vectors of sequences (DNA, RNA, AA).
They must all be of the same type. Short vectors are recycled.</p>
</td></tr>
<tr><td><code id="seq_combine_+3A_sep">sep</code></td>
<td>
<p>String to insert between input vectors.</p>
</td></tr>
<tr><td><code id="seq_combine_+3A_collapse">collapse</code></td>
<td>
<p>If not <code>NULL</code>, combine everything with this
string as separator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The strings <code>sep</code> and <code>collapse</code>w ill be coerced to
the type of input vectors with a warning if some character have to replaced.
</p>


<h3>Value</h3>

<p>A vector of sequences (if collapse is <code>NULL</code>).
A vector with a single sequence, otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_join">stri_join</a></code> from <span class="pkg">stringi</span> and
<code><a href="stringr.html#topic+str_c">str_c</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACGTTAGTGTAGCCGT", "CTCGAAATGA")
y &lt;- dna("TTTTTTTT", "AAAAAAAAA")
seq_combine(x, y)
seq_combine(y, x, sep = "CCCCC")
seq_combine(y, x, sep = "CCCCC", collapse = "GGGGG")

</code></pre>

<hr>
<h2 id='seq_consensus'>Find a consensus sequence for a set of sequences.</h2><span id='topic+seq_consensus'></span>

<h3>Description</h3>

<p>Find a consensus sequence for a set of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_consensus(x, method = "chr_majority", weights = NULL, gaps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_consensus_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_consensus_+3A_method">method</code></td>
<td>
<p>the consensus method (see Details).</p>
</td></tr>
<tr><td><code id="seq_consensus_+3A_weights">weights</code></td>
<td>
<p>an optional numeric vector of same length
as <code>x</code> giving a weight for each input sequence.</p>
</td></tr>
<tr><td><code id="seq_consensus_+3A_gaps">gaps</code></td>
<td>
<p>logical. Should the gaps (&quot;-&quot;) taken into account.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;chr_majority&quot;, &quot;chr_ambiguity&quot;, &quot;seq_centrality&quot;, &quot;seq_majority&quot;
</p>
<p>For chr_ambiguity gap character always override other characters.
Use gaps = FALSE to ignore gaps.
</p>


<h3>Value</h3>

<p>A consensus sequence
</p>


<h3>See Also</h3>

<p>Other aggregation operations: 
<code><a href="#topic+seq_cluster">seq_cluster</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("-----TACGCAGTAAAAGCTACTGATG",
       "CGTCATACGCAGTAAAAACTACTGATG",
       "CTTCATACGCAGTAAAAACTACTGATG",
       "CTTCATATGCAGTAAAAACTACTGATG",
       "CTTCATACGCAGTAAAAACTACTGATG",
       "CGTCATACGCAGTAAAAGCTACTGATG",
       "CTTCATATGCAGTAAAAGCTACTGACG")
x &lt;- dna(x)
seq_consensus(x)
</code></pre>

<hr>
<h2 id='seq_count_pattern'>Count the number of matches in sequences</h2><span id='topic+seq_count_pattern'></span>

<h3>Description</h3>

<p>Count the number of matches in sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_count_pattern(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_count_pattern_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_count_pattern_+3A_pattern">pattern</code></td>
<td>
<p>a DNA, RNA or AA vectors (but same as <code>x</code>)
or a character vector of regular expressions, or a list.
See section Patterns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Patterns</h3>

<p>It is important to understand how patterns are treated in <span class="pkg">bioseq</span>.
</p>
<p>Patterns are recycled along the sequences (usually the <code>x</code> argument).
This means that if a pattern (vector or list) is of length &gt; 1, it will be
replicated until it is the same length as <code>x</code>.
The reverse is not true and a vector of patterns longer than
a vector of sequences will raise a warning.
</p>
<p>Patterns can be DNA, RNA or AA vectors
(but they must be from the same class as
the sequences they are matched against).
If patterns are DNA, RNA or AA vectors,
they are disambiguated prior to matching.
For example pattern dna(&quot;ARG&quot;) will match AAG or AGG.
</p>
<p>Alternatively, patterns can be a simple character vector
containing regular expressions.
</p>
<p>Vectors of patterns (DNA, RNA, AA or regex) can also be provided in a list.
In that case, each vector of the list will be collapsed prior matching,
which means that each vector element will be used as an alternative pattern.
For example pattern list(c(&quot;AAA&quot;, &quot;CCC&quot;), &quot;GG&quot;)
will match AAA or CCC in the first sequence,
GG in the second sequence, AAA or CCC in the third,
and so on following the recycling rule.
</p>
<p>@section Fuzzy matching:
When <code>max_error</code> is greater than zero, the function perform
fuzzy matching. Fuzzy matching does not support regular expression.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_count">stri_count</a></code> from <span class="pkg">stringi</span> and
<code><a href="stringr.html#topic+str_count">str_count</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACGTTAGTGTAGCCGT", "CTCGAAATGA")
seq_count_pattern(x, dna("AAA"))
seq_count_pattern(x, "T.G")

</code></pre>

<hr>
<h2 id='seq_crop_pattern'>Crop sequences using delimiting patterns</h2><span id='topic+seq_crop_pattern'></span>

<h3>Description</h3>

<p>Crop sequences using delimiting patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_crop_pattern(
  x,
  pattern_in,
  pattern_out,
  max_error_in = 0,
  max_error_out = 0,
  include_patterns = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_crop_pattern_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector to be cropped.</p>
</td></tr>
<tr><td><code id="seq_crop_pattern_+3A_pattern_in">pattern_in</code></td>
<td>
<p>patterns defining the beginning (left-side).</p>
</td></tr>
<tr><td><code id="seq_crop_pattern_+3A_pattern_out">pattern_out</code></td>
<td>
<p>patterns defining the end (right-side).</p>
</td></tr>
<tr><td><code id="seq_crop_pattern_+3A_max_error_in">max_error_in</code>, <code id="seq_crop_pattern_+3A_max_error_out">max_error_out</code></td>
<td>
<p>numeric values ranging from
0 to 1 and giving the maximum error rate allowed between the
target sequence and <code>pattern_in</code>/<code>pattern_out</code>.
Error rate is relative to the length of the pattern.</p>
</td></tr>
<tr><td><code id="seq_crop_pattern_+3A_include_patterns">include_patterns</code></td>
<td>
<p>logical. Should the matched pattern
sequence included in the returned sequences?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cropped DNA, RNA or AA vector.
Sequences where patterns are not detected returns <code>NA</code>.
</p>


<h3>Fuzzy matching</h3>

<p>When <code>max_error_in</code> or <code>max_error_out</code> are greater
than zero, the function perform fuzzy matching.
Fuzzy matching does not support regular expression.
</p>


<h3>Patterns</h3>

<p>It is important to understand how patterns are treated in <span class="pkg">bioseq</span>.
</p>
<p>Patterns are recycled along the sequences (usually the <code>x</code> argument).
This means that if a pattern (vector or list) is of length &gt; 1, it will be
replicated until it is the same length as <code>x</code>.
The reverse is not true and a vector of patterns longer than
a vector of sequences will raise a warning.
</p>
<p>Patterns can be DNA, RNA or AA vectors
(but they must be from the same class as
the sequences they are matched against).
If patterns are DNA, RNA or AA vectors,
they are disambiguated prior to matching.
For example pattern dna(&quot;ARG&quot;) will match AAG or AGG.
</p>
<p>Alternatively, patterns can be a simple character vector
containing regular expressions.
</p>
<p>Vectors of patterns (DNA, RNA, AA or regex) can also be provided in a list.
In that case, each vector of the list will be collapsed prior matching,
which means that each vector element will be used as an alternative pattern.
For example pattern list(c(&quot;AAA&quot;, &quot;CCC&quot;), &quot;GG&quot;)
will match AAA or CCC in the first sequence,
GG in the second sequence, AAA or CCC in the third,
and so on following the recycling rule.
</p>
<p>@section Fuzzy matching:
When <code>max_error</code> is greater than zero, the function perform
fuzzy matching. Fuzzy matching does not support regular expression.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_extract">stri_extract</a></code> from <span class="pkg">stringi</span>,
<code><a href="stringr.html#topic+str_extract">str_extract</a></code> from <span class="pkg">stringr</span> and
<code><a href="stringdist.html#topic+afind">afind</a></code> from <span class="pkg">stringdist</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACGTTAAAAAGTGTAGCCCCCGT", "CTCGAAATGA")
seq_crop_pattern(x, pattern_in = "AAAA", pattern_out = "CCCC")
</code></pre>

<hr>
<h2 id='seq_crop_position'>Crop sequences between two positions</h2><span id='topic+seq_crop_position'></span>

<h3>Description</h3>

<p>Crop sequences between two positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_crop_position(x, position_in = 1, position_out = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_crop_position_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_crop_position_+3A_position_in">position_in</code></td>
<td>
<p>an integer giving the position where to start cropping.</p>
</td></tr>
<tr><td><code id="seq_crop_position_+3A_position_out">position_out</code></td>
<td>
<p>an integer giving the position where to stop cropping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cropped DNA, RNA or AA vector.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_sub">stri_sub</a></code> from <span class="pkg">stringi</span> and
<code><a href="stringr.html#topic+str_sub">str_sub</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACGTTAGTGTAGCCGT")

# Drop the first 3 nucleotides (ACG)
seq_crop_position(x, position_in = 4)

# Crop codon between position 4 and 6
seq_crop_position(x, position_in = 4, position_out = 6)

</code></pre>

<hr>
<h2 id='seq_detect_pattern'>Detect the presence of patterns in sequences</h2><span id='topic+seq_detect_pattern'></span>

<h3>Description</h3>

<p>Detect the presence of patterns in sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_detect_pattern(x, pattern, max_error = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_detect_pattern_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_detect_pattern_+3A_pattern">pattern</code></td>
<td>
<p>a DNA, RNA or AA vectors (but same as <code>x</code>)
or a character vector of regular expressions, or a list.
See section Patterns.</p>
</td></tr>
<tr><td><code id="seq_detect_pattern_+3A_max_error">max_error</code></td>
<td>
<p>numeric value ranging from 0 to 1 and giving the
maximum error rate allowed between the target sequence and the pattern.
Error rate is relative to the length of the pattern.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Patterns</h3>

<p>It is important to understand how patterns are treated in <span class="pkg">bioseq</span>.
</p>
<p>Patterns are recycled along the sequences (usually the <code>x</code> argument).
This means that if a pattern (vector or list) is of length &gt; 1, it will be
replicated until it is the same length as <code>x</code>.
The reverse is not true and a vector of patterns longer than
a vector of sequences will raise a warning.
</p>
<p>Patterns can be DNA, RNA or AA vectors
(but they must be from the same class as
the sequences they are matched against).
If patterns are DNA, RNA or AA vectors,
they are disambiguated prior to matching.
For example pattern dna(&quot;ARG&quot;) will match AAG or AGG.
</p>
<p>Alternatively, patterns can be a simple character vector
containing regular expressions.
</p>
<p>Vectors of patterns (DNA, RNA, AA or regex) can also be provided in a list.
In that case, each vector of the list will be collapsed prior matching,
which means that each vector element will be used as an alternative pattern.
For example pattern list(c(&quot;AAA&quot;, &quot;CCC&quot;), &quot;GG&quot;)
will match AAA or CCC in the first sequence,
GG in the second sequence, AAA or CCC in the third,
and so on following the recycling rule.
</p>
<p>@section Fuzzy matching:
When <code>max_error</code> is greater than zero, the function perform
fuzzy matching. Fuzzy matching does not support regular expression.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_detect">stri_detect</a></code> from <span class="pkg">stringi</span>,
<code><a href="stringr.html#topic+str_detect">str_detect</a></code> from <span class="pkg">stringr</span> and
<code><a href="stringdist.html#topic+afind">afind</a></code> from <span class="pkg">stringdist</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna(c("ACGTTAGTGTAGCCGT", "CTCGAAATGA"))
seq_detect_pattern(x, dna(c("CCG", "AAA")))

# Regular expression
seq_detect_pattern(x, "^A.{2}T")

# Fuzzy matching
seq_detect_pattern(x, dna("AGG"), max_error = 0.2)
# No match. The pattern has three character, the max_error
# has to be &gt; 1/3 to allow one character difference.

seq_detect_pattern(x, dna("AGG"), max_error = 0.4)
# Match

</code></pre>

<hr>
<h2 id='seq_disambiguate_IUPAC'>Disambiguate biological sequences</h2><span id='topic+seq_disambiguate_IUPAC'></span>

<h3>Description</h3>

<p>This function finds all the combinations of sequences corresponding
to a given vector of sequences with ambiguities (IUPAC codes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_disambiguate_IUPAC(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_disambiguate_IUPAC_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of DNA, RNA or AA vectors (depending on the input)
giving all possible combinations.
</p>


<h3>See Also</h3>

<p>Other op-misc: 
<code><a href="#topic+seq_nchar">seq_nchar</a>()</code>,
<code><a href="#topic+seq_nseq">seq_nseq</a>()</code>,
<code><a href="#topic+seq_spellout">seq_spellout</a>()</code>,
<code><a href="#topic+seq_stat_gc">seq_stat_gc</a>()</code>,
<code><a href="#topic+seq_stat_prop">seq_stat_prop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna(c("AYCTGW", "CTTN"))
seq_disambiguate_IUPAC(x)

y &lt;- seq_transcribe(x)
seq_disambiguate_IUPAC(y)

z &lt;- aa("YJSNAALNX")
z &lt;- seq_translate(y)
seq_disambiguate_IUPAC(z)

</code></pre>

<hr>
<h2 id='seq_extract_pattern'>Extract matching patterns from sequences</h2><span id='topic+seq_extract_pattern'></span>

<h3>Description</h3>

<p>Extract matching patterns from sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_extract_pattern(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_extract_pattern_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_extract_pattern_+3A_pattern">pattern</code></td>
<td>
<p>a DNA, RNA or AA vectors (but same as <code>x</code>)
or a character vector of regular expressions, or a list.
See section Patterns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of same class as <code>x</code>.
</p>


<h3>Patterns</h3>

<p>It is important to understand how patterns are treated in <span class="pkg">bioseq</span>.
</p>
<p>Patterns are recycled along the sequences (usually the <code>x</code> argument).
This means that if a pattern (vector or list) is of length &gt; 1, it will be
replicated until it is the same length as <code>x</code>.
The reverse is not true and a vector of patterns longer than
a vector of sequences will raise a warning.
</p>
<p>Patterns can be DNA, RNA or AA vectors
(but they must be from the same class as
the sequences they are matched against).
If patterns are DNA, RNA or AA vectors,
they are disambiguated prior to matching.
For example pattern dna(&quot;ARG&quot;) will match AAG or AGG.
</p>
<p>Alternatively, patterns can be a simple character vector
containing regular expressions.
</p>
<p>Vectors of patterns (DNA, RNA, AA or regex) can also be provided in a list.
In that case, each vector of the list will be collapsed prior matching,
which means that each vector element will be used as an alternative pattern.
For example pattern list(c(&quot;AAA&quot;, &quot;CCC&quot;), &quot;GG&quot;)
will match AAA or CCC in the first sequence,
GG in the second sequence, AAA or CCC in the third,
and so on following the recycling rule.
</p>
<p>@section Fuzzy matching:
When <code>max_error</code> is greater than zero, the function perform
fuzzy matching. Fuzzy matching does not support regular expression.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_extract">stri_extract</a></code> from <span class="pkg">stringi</span> and
<code><a href="stringr.html#topic+str_extract">str_extract</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACGTTAGTGTAGCCGT", "CTCGAAATGA")
seq_extract_pattern(x, dna("AAA"))
seq_extract_pattern(x, "T.G")

</code></pre>

<hr>
<h2 id='seq_extract_position'>Extract a region between two positions in sequences</h2><span id='topic+seq_extract_position'></span>

<h3>Description</h3>

<p>Extract a region between two positions in sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_extract_position(x, position_in, position_out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_extract_position_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_extract_position_+3A_position_in">position_in</code></td>
<td>
<p>an integer giving the position where to start to extract.</p>
</td></tr>
<tr><td><code id="seq_extract_position_+3A_position_out">position_out</code></td>
<td>
<p>an integer giving the position where to stop to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same class as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_extract">stri_extract</a></code> from <span class="pkg">stringi</span> and
<code><a href="stringr.html#topic+str_extract">str_extract</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACGTTAGTGTAGCCGT", "CTCGAAATGA")
seq_extract_position(x, 3, 8)

</code></pre>

<hr>
<h2 id='seq_nchar'>Count the number of character in sequences</h2><span id='topic+seq_nchar'></span>

<h3>Description</h3>

<p>Count the number of character in sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_nchar(x, gaps = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_nchar_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_nchar_+3A_gaps">gaps</code></td>
<td>
<p>if <code>FALSE</code> gaps are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector giving the size of each sequence of <code>x</code>.
</p>


<h3>See Also</h3>

<p>Other op-misc: 
<code><a href="#topic+seq_disambiguate_IUPAC">seq_disambiguate_IUPAC</a>()</code>,
<code><a href="#topic+seq_nseq">seq_nseq</a>()</code>,
<code><a href="#topic+seq_spellout">seq_spellout</a>()</code>,
<code><a href="#topic+seq_stat_gc">seq_stat_gc</a>()</code>,
<code><a href="#topic+seq_stat_prop">seq_stat_prop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna(c("ATGCAGA", "GGR-----","TTGCCTAGKTGAACC"))
seq_nchar(x)
seq_nchar(x, gaps = FALSE)

</code></pre>

<hr>
<h2 id='seq_nseq'>Number of sequences in a vector</h2><span id='topic+seq_nseq'></span>

<h3>Description</h3>

<p>This is an alias for <code>length</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_nseq(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_nseq_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer.
</p>


<h3>See Also</h3>

<p>Other op-misc: 
<code><a href="#topic+seq_disambiguate_IUPAC">seq_disambiguate_IUPAC</a>()</code>,
<code><a href="#topic+seq_nchar">seq_nchar</a>()</code>,
<code><a href="#topic+seq_spellout">seq_spellout</a>()</code>,
<code><a href="#topic+seq_stat_gc">seq_stat_gc</a>()</code>,
<code><a href="#topic+seq_stat_prop">seq_stat_prop</a>()</code>
</p>

<hr>
<h2 id='seq_remove_pattern'>Remove matched patterns in sequences</h2><span id='topic+seq_remove_pattern'></span>

<h3>Description</h3>

<p>Remove matched patterns in sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_remove_pattern(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_remove_pattern_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_remove_pattern_+3A_pattern">pattern</code></td>
<td>
<p>a DNA, RNA or AA vectors (but same as <code>x</code>)
or a character vector of regular expressions, or a list.
See section Patterns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same class as <code>x</code>.
</p>


<h3>Patterns</h3>

<p>It is important to understand how patterns are treated in <span class="pkg">bioseq</span>.
</p>
<p>Patterns are recycled along the sequences (usually the <code>x</code> argument).
This means that if a pattern (vector or list) is of length &gt; 1, it will be
replicated until it is the same length as <code>x</code>.
The reverse is not true and a vector of patterns longer than
a vector of sequences will raise a warning.
</p>
<p>Patterns can be DNA, RNA or AA vectors
(but they must be from the same class as
the sequences they are matched against).
If patterns are DNA, RNA or AA vectors,
they are disambiguated prior to matching.
For example pattern dna(&quot;ARG&quot;) will match AAG or AGG.
</p>
<p>Alternatively, patterns can be a simple character vector
containing regular expressions.
</p>
<p>Vectors of patterns (DNA, RNA, AA or regex) can also be provided in a list.
In that case, each vector of the list will be collapsed prior matching,
which means that each vector element will be used as an alternative pattern.
For example pattern list(c(&quot;AAA&quot;, &quot;CCC&quot;), &quot;GG&quot;)
will match AAA or CCC in the first sequence,
GG in the second sequence, AAA or CCC in the third,
and so on following the recycling rule.
</p>
<p>@section Fuzzy matching:
When <code>max_error</code> is greater than zero, the function perform
fuzzy matching. Fuzzy matching does not support regular expression.
</p>


<h3>See Also</h3>

<p><code><a href="stringr.html#topic+str_remove">str_remove</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACGTTAGTGTAGCCGT", "CTCGAAATGA")
seq_remove_pattern(x, dna("AAA"))
seq_remove_pattern(x, "^A.{2}T")

</code></pre>

<hr>
<h2 id='seq_remove_position'>Remove a region between two positions in sequences.</h2><span id='topic+seq_remove_position'></span>

<h3>Description</h3>

<p>Remove a region between two positions in sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_remove_position(x, position_in, position_out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_remove_position_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_remove_position_+3A_position_in">position_in</code></td>
<td>
<p>an integer giving the position where to start to remove.</p>
</td></tr>
<tr><td><code id="seq_remove_position_+3A_position_out">position_out</code></td>
<td>
<p>an integer giving the position where to stop to remove.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same class as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringr.html#topic+str_remove">str_remove</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACGTTAGTGTAGCCGT", "CTCGAAATGA")
seq_remove_position(x, 2, 6)
seq_remove_position(x, 1:2, 3:4)

</code></pre>

<hr>
<h2 id='seq_replace_position'>Replace a region between two positions in sequences</h2><span id='topic+seq_replace_position'></span>

<h3>Description</h3>

<p>Replace a region between two positions in sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_replace_position(x, position_in, position_out, replacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_replace_position_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_replace_position_+3A_position_in">position_in</code></td>
<td>
<p>an integer giving the position where to start to replace.</p>
</td></tr>
<tr><td><code id="seq_replace_position_+3A_position_out">position_out</code></td>
<td>
<p>an integer giving the position where to stop to replace.</p>
</td></tr>
<tr><td><code id="seq_replace_position_+3A_replacement">replacement</code></td>
<td>
<p>a vector of replacements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same class as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_replace">stri_replace</a></code> from <span class="pkg">stringi</span> and
<code><a href="stringr.html#topic+str_replace">str_replace</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACGTTAGTGTAGCCGT", "CTCGAAATGA")
seq_replace_position(x, c(5, 2), 6, "-------")
</code></pre>

<hr>
<h2 id='seq_rev_translate'>Reverse translate amino acid sequences</h2><span id='topic+seq_rev_translate'></span>

<h3>Description</h3>

<p>The function perform reverse translation of amino acid sequences.
Such operation does not exist in nature but is provided for completeness.
Because of codon degeneracy it is expected
to produce many ambiguous nucleotides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_rev_translate(x, code = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_rev_translate_+3A_x">x</code></td>
<td>
<p>an amino acid sequence (<code>bioseq_aa</code>)</p>
</td></tr>
<tr><td><code id="seq_rev_translate_+3A_code">code</code></td>
<td>
<p>an integer indicating the genetic code to use for
reverse translation (default 1 uses the Standard genetic code). See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gaps (-) are interpreted as unknown amino acids (X) but can be
removed prior to the translation with the function <code>seq_remove_gap</code>.
</p>


<h3>Value</h3>

<p>a vector of DNA sequences.
</p>


<h3>See Also</h3>

<p>Other biological operations: 
<code><a href="#topic+rev_complement">rev_complement</a></code>,
<code><a href="#topic+seq_translate">seq_translate</a>()</code>,
<code><a href="#topic+transcription">transcription</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna("ACTTTGGCTAAG")
y &lt;- seq_translate(x)
z &lt;- seq_rev_translate(y)
z
# There is a loss of information during the reverse translation
all.equal(x, z)

</code></pre>

<hr>
<h2 id='seq_spellout'>Spell out sequences</h2><span id='topic+seq_spellout'></span>

<h3>Description</h3>

<p>This function spells out nucleotides and amino acids in sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_spellout(x, short = FALSE, collapse = " - ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_spellout_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector</p>
</td></tr>
<tr><td><code id="seq_spellout_+3A_short">short</code></td>
<td>
<p>logical. If TRUE, the function will return
3-letters short names for amino acids (ignored for DNA and RNA).</p>
</td></tr>
<tr><td><code id="seq_spellout_+3A_collapse">collapse</code></td>
<td>
<p>a character vector to separate the results.
Set to <code>NULL</code> to avoid collapsing the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector if collapse is not <code>NULL</code>.
A list of character vectors otherwise.
</p>


<h3>See Also</h3>

<p>Other op-misc: 
<code><a href="#topic+seq_disambiguate_IUPAC">seq_disambiguate_IUPAC</a>()</code>,
<code><a href="#topic+seq_nchar">seq_nchar</a>()</code>,
<code><a href="#topic+seq_nseq">seq_nseq</a>()</code>,
<code><a href="#topic+seq_stat_gc">seq_stat_gc</a>()</code>,
<code><a href="#topic+seq_stat_prop">seq_stat_prop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dna("ACGT")
seq_spellout(x)

x &lt;- rna("ACGU")
seq_spellout(x)

x &lt;- aa("ACGBTX")
seq_spellout(x)

</code></pre>

<hr>
<h2 id='seq_split_kmer'>Split sequences into k-mers</h2><span id='topic+seq_split_kmer'></span>

<h3>Description</h3>

<p>Split sequences into k-mers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_split_kmer(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_split_kmer_+3A_x">x</code></td>
<td>
<p>A DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_split_kmer_+3A_k">k</code></td>
<td>
<p>an integer giving the size of the k-mer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of k-mer vectors of same class as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seq_split_pattern">seq_split_pattern</a></code>.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna(a ="ACGTTAGTGTAGCCGT", b = "CTCGAAATGA")
seq_split_kmer(x, k = 5)
</code></pre>

<hr>
<h2 id='seq_split_pattern'>Split sequences</h2><span id='topic+seq_split_pattern'></span>

<h3>Description</h3>

<p>Split sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_split_pattern(x, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_split_pattern_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_split_pattern_+3A_pattern">pattern</code></td>
<td>
<p>a DNA, RNA or AA vectors (but same as <code>x</code>)
or a character vector of regular expressions, or a list.
See section Patterns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of same class as <code>x</code>.
</p>


<h3>Patterns</h3>

<p>It is important to understand how patterns are treated in <span class="pkg">bioseq</span>.
</p>
<p>Patterns are recycled along the sequences (usually the <code>x</code> argument).
This means that if a pattern (vector or list) is of length &gt; 1, it will be
replicated until it is the same length as <code>x</code>.
The reverse is not true and a vector of patterns longer than
a vector of sequences will raise a warning.
</p>
<p>Patterns can be DNA, RNA or AA vectors
(but they must be from the same class as
the sequences they are matched against).
If patterns are DNA, RNA or AA vectors,
they are disambiguated prior to matching.
For example pattern dna(&quot;ARG&quot;) will match AAG or AGG.
</p>
<p>Alternatively, patterns can be a simple character vector
containing regular expressions.
</p>
<p>Vectors of patterns (DNA, RNA, AA or regex) can also be provided in a list.
In that case, each vector of the list will be collapsed prior matching,
which means that each vector element will be used as an alternative pattern.
For example pattern list(c(&quot;AAA&quot;, &quot;CCC&quot;), &quot;GG&quot;)
will match AAA or CCC in the first sequence,
GG in the second sequence, AAA or CCC in the third,
and so on following the recycling rule.
</p>
<p>@section Fuzzy matching:
When <code>max_error</code> is greater than zero, the function perform
fuzzy matching. Fuzzy matching does not support regular expression.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_split">stri_split</a></code> from <span class="pkg">stringi</span> and
<code><a href="stringr.html#topic+str_split">str_split</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq-replace">seq-replace</a></code>,
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna(a = "ACGTTAGTGTAGCCGT", b = "CTCGAAATGA")
seq_split_pattern(x, dna("AAA"))
seq_split_pattern(x, "T.G")

</code></pre>

<hr>
<h2 id='seq_stat_gc'>Compute G+C content</h2><span id='topic+seq_stat_gc'></span>

<h3>Description</h3>

<p>Compute G+C content
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_stat_gc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_stat_gc_+3A_x">x</code></td>
<td>
<p>a DNA or RNA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ambiguous characters (other than S and W) are ignored.
</p>


<h3>Value</h3>

<p>A numeric vector of G+C proportions.
</p>


<h3>See Also</h3>

<p>Other op-misc: 
<code><a href="#topic+seq_disambiguate_IUPAC">seq_disambiguate_IUPAC</a>()</code>,
<code><a href="#topic+seq_nchar">seq_nchar</a>()</code>,
<code><a href="#topic+seq_nseq">seq_nseq</a>()</code>,
<code><a href="#topic+seq_spellout">seq_spellout</a>()</code>,
<code><a href="#topic+seq_stat_prop">seq_stat_prop</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna(c("ATGCAGA", "GGR-----","TTGCCTAGKTGAACC"))

seq_stat_gc(x)

</code></pre>

<hr>
<h2 id='seq_stat_prop'>Compute proportions for characters</h2><span id='topic+seq_stat_prop'></span>

<h3>Description</h3>

<p>Compute proportions for characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_stat_prop(x, gaps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_stat_prop_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq_stat_prop_+3A_gaps">gaps</code></td>
<td>
<p>if <code>FALSE</code> gaps are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors indicating the
proportion of characters in each sequence.
</p>


<h3>See Also</h3>

<p>Other op-misc: 
<code><a href="#topic+seq_disambiguate_IUPAC">seq_disambiguate_IUPAC</a>()</code>,
<code><a href="#topic+seq_nchar">seq_nchar</a>()</code>,
<code><a href="#topic+seq_nseq">seq_nseq</a>()</code>,
<code><a href="#topic+seq_spellout">seq_spellout</a>()</code>,
<code><a href="#topic+seq_stat_gc">seq_stat_gc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- dna(c("ATGCAGA", "GGR-----","TTGCCTAGKTGAACC"))
seq_stat_prop(x)
seq_stat_prop(x, gaps = TRUE)

</code></pre>

<hr>
<h2 id='seq_translate'>Translate DNA/RNA sequences into amino acids</h2><span id='topic+seq_translate'></span>

<h3>Description</h3>

<p>Translate DNA/RNA sequences into amino acids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_translate(x, code = 1, codon_frame = 1, codon_init = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_translate_+3A_x">x</code></td>
<td>
<p>a vector of DNA (bioseq_dna) or RNA (bioseq_rna).</p>
</td></tr>
<tr><td><code id="seq_translate_+3A_code">code</code></td>
<td>
<p>an integer indicating the genetic code to use for translation
(default 1 uses the Standard genetic code). See Details.</p>
</td></tr>
<tr><td><code id="seq_translate_+3A_codon_frame">codon_frame</code></td>
<td>
<p>an integer giving the nucleotide position
where to start translation.</p>
</td></tr>
<tr><td><code id="seq_translate_+3A_codon_init">codon_init</code></td>
<td>
<p>a logical indicating whether the first codon is evaluated
as a possible codon start and translated to methionine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several genetic codes can be used for translation. See <a href="#topic+genetic-codes">genetic-codes</a>
to get the list of available genetic codes and their ID number.
</p>
<p>Gaps (-) are interpreted as unknown nucleotides (N) but can be
removed prior to the translation with the function <code>seq_remove_gap</code>.
</p>
<p>The function deals with ambiguities on both sides.
This means that if ambiguous codons cannot
be translated to amino acid, they are translated to
the most specific ambiguous amino acids
(X in the most extreme case).
</p>


<h3>Value</h3>

<p>An amino acid vector (<code>bioseq_aa</code>).
</p>


<h3>See Also</h3>

<p>Other biological operations: 
<code><a href="#topic+rev_complement">rev_complement</a></code>,
<code><a href="#topic+seq_rev_translate">seq_rev_translate</a>()</code>,
<code><a href="#topic+transcription">transcription</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dna(c("ATGCAGA", "GGR","TTGCCTAGKTGAACC", "AGGNGC", "NNN"))
seq_translate(x)

</code></pre>

<hr>
<h2 id='seq-replace'>Replace matched patterns in sequences</h2><span id='topic+seq-replace'></span><span id='topic+seq_replace_pattern'></span>

<h3>Description</h3>

<p>Replace matched patterns in sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_replace_pattern(x, pattern, replacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq-replace_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="seq-replace_+3A_pattern">pattern</code></td>
<td>
<p>a DNA, RNA or AA vectors (but same as <code>x</code>)
or a character vector of regular expressions, or a list.
See section Patterns.</p>
</td></tr>
<tr><td><code id="seq-replace_+3A_replacement">replacement</code></td>
<td>
<p>a vector of replacements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same class as <code>x</code>.
</p>


<h3>Patterns</h3>

<p>It is important to understand how patterns are treated in <span class="pkg">bioseq</span>.
</p>
<p>Patterns are recycled along the sequences (usually the <code>x</code> argument).
This means that if a pattern (vector or list) is of length &gt; 1, it will be
replicated until it is the same length as <code>x</code>.
The reverse is not true and a vector of patterns longer than
a vector of sequences will raise a warning.
</p>
<p>Patterns can be DNA, RNA or AA vectors
(but they must be from the same class as
the sequences they are matched against).
If patterns are DNA, RNA or AA vectors,
they are disambiguated prior to matching.
For example pattern dna(&quot;ARG&quot;) will match AAG or AGG.
</p>
<p>Alternatively, patterns can be a simple character vector
containing regular expressions.
</p>
<p>Vectors of patterns (DNA, RNA, AA or regex) can also be provided in a list.
In that case, each vector of the list will be collapsed prior matching,
which means that each vector element will be used as an alternative pattern.
For example pattern list(c(&quot;AAA&quot;, &quot;CCC&quot;), &quot;GG&quot;)
will match AAA or CCC in the first sequence,
GG in the second sequence, AAA or CCC in the third,
and so on following the recycling rule.
</p>
<p>@section Fuzzy matching:
When <code>max_error</code> is greater than zero, the function perform
fuzzy matching. Fuzzy matching does not support regular expression.
</p>


<h3>See Also</h3>

<p><code><a href="stringi.html#topic+stri_replace">stri_replace</a></code> from <span class="pkg">stringi</span> and
<code><a href="stringr.html#topic+str_replace">str_replace</a></code> from <span class="pkg">stringr</span>
for the underlying implementation.
</p>
<p>Other string operations: 
<code><a href="#topic+seq_combine">seq_combine</a>()</code>,
<code><a href="#topic+seq_count_pattern">seq_count_pattern</a>()</code>,
<code><a href="#topic+seq_crop_pattern">seq_crop_pattern</a>()</code>,
<code><a href="#topic+seq_crop_position">seq_crop_position</a>()</code>,
<code><a href="#topic+seq_detect_pattern">seq_detect_pattern</a>()</code>,
<code><a href="#topic+seq_extract_pattern">seq_extract_pattern</a>()</code>,
<code><a href="#topic+seq_extract_position">seq_extract_position</a>()</code>,
<code><a href="#topic+seq_remove_pattern">seq_remove_pattern</a>()</code>,
<code><a href="#topic+seq_remove_position">seq_remove_position</a>()</code>,
<code><a href="#topic+seq_replace_position">seq_replace_position</a>()</code>,
<code><a href="#topic+seq_split_kmer">seq_split_kmer</a>()</code>,
<code><a href="#topic+seq_split_pattern">seq_split_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- dna("ACGTTAGTGTAGCCGT", "CTCGAAATGA")
seq_replace_pattern(x, dna("AAA"), dna("GGGGGG"))
seq_replace_pattern(x, "^A.{2}T", "TTTTTT")

</code></pre>

<hr>
<h2 id='transcription'>Transcribe DNA, reverse-transcribe RNA</h2><span id='topic+transcription'></span><span id='topic+seq_transcribe'></span><span id='topic+seq_rev_transcribe'></span>

<h3>Description</h3>

<p>Transcribe DNA, reverse-transcribe RNA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_transcribe(x)

seq_rev_transcribe(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcription_+3A_x">x</code></td>
<td>
<p>A vector of DNA for <code>seq_transcribe</code>,
a vector of RNA for <code>seq_rev_transcribe</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of RNA for <code>seq_transcribe</code>,
a vector of DNA for <code>seq_rev_transcribe</code>
</p>


<h3>See Also</h3>

<p>Other biological operations: 
<code><a href="#topic+rev_complement">rev_complement</a></code>,
<code><a href="#topic+seq_rev_translate">seq_rev_translate</a>()</code>,
<code><a href="#topic+seq_translate">seq_translate</a>()</code>
</p>

<hr>
<h2 id='validate_seq'>Sequence validator</h2><span id='topic+validate_seq'></span>

<h3>Description</h3>

<p>Validate character strings before sequence construction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_seq(x, alphabet, invalid_replacement, type = "DNA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_seq_+3A_x">x</code></td>
<td>
<p>a character vector.</p>
</td></tr>
<tr><td><code id="validate_seq_+3A_alphabet">alphabet</code></td>
<td>
<p>a character vector defining the sequence alphabet;</p>
</td></tr>
<tr><td><code id="validate_seq_+3A_invalid_replacement">invalid_replacement</code></td>
<td>
<p>a character to replace non valid characters</p>
</td></tr>
<tr><td><code id="validate_seq_+3A_type">type</code></td>
<td>
<p>type of sequence (&quot;DNA&quot;, &quot;RNA&quot;, &quot;AA&quot;). It is only
used to provide more informative warning messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Validation steps:
</p>

<ol>
<li><p> Check that <code>x</code> is a character vector, fails if not.
</p>
</li>
<li><p> Force alpha characters to uppercase
</p>
</li>
<li><p> Delete blank characters (spaces and tabs)
</p>
</li>
<li><p> Delete line breaks
</p>
</li>
<li><p> Converts . (dots) to - (as both can represent a gap)
</p>
</li>
<li><p> Replace invalid characters with N/X (with a warning).
</p>
</li></ol>



<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='vec_ptype2.bioseq_aa'>Internal</h2><span id='topic+vec_ptype2.bioseq_aa'></span><span id='topic+vec_cast.bioseq_aa'></span><span id='topic+vec_ptype2.bioseq_dna'></span><span id='topic+vec_cast.bioseq_dna'></span><span id='topic+vec_ptype2.bioseq_rna'></span><span id='topic+vec_cast.bioseq_rna'></span>

<h3>Description</h3>

<p>Internal
</p>
<p>Internal
</p>
<p>Internal
</p>
<p>Internal
</p>
<p>Internal
</p>
<p>Internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bioseq_aa'
vec_ptype2(x, y, ...)

## S3 method for class 'bioseq_aa'
vec_cast(x, to, ...)

## S3 method for class 'bioseq_dna'
vec_ptype2(x, y, ...)

## S3 method for class 'bioseq_dna'
vec_cast(x, to, ...)

## S3 method for class 'bioseq_rna'
vec_ptype2(x, y, ...)

## S3 method for class 'bioseq_rna'
vec_cast(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_ptype2.bioseq_aa_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="vec_ptype2.bioseq_aa_+3A_y">y</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="vec_ptype2.bioseq_aa_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
<tr><td><code id="vec_ptype2.bioseq_aa_+3A_to">to</code></td>
<td>
<p>a class</p>
</td></tr>
</table>

<hr>
<h2 id='write_fasta'>Write sequences in FASTA format</h2><span id='topic+write_fasta'></span>

<h3>Description</h3>

<p>Write sequences in FASTA format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_fasta(x, file, append = FALSE, line_length = 80, block_length = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_fasta_+3A_x">x</code></td>
<td>
<p>a DNA, RNA or AA vector.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_file">file</code></td>
<td>
<p>a path to a file or a connection.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_append">append</code></td>
<td>
<p>a logical. If <code>TRUE</code> append the data to the file.
If <code>FALSE</code> (default), overwrite the file.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_line_length">line_length</code></td>
<td>
<p>length (in number of character) of one line
(excluding spaces separating blocks). Use <code>Inf</code> to avoid line breaks.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_block_length">block_length</code></td>
<td>
<p>length (in number of character) of one block.
Use the same value as <code>line_length</code> or <code>Inf</code> to avoid
block separation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other input/output operations: 
<code><a href="#topic+read_fasta">read_fasta</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
