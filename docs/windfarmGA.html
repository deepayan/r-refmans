<!DOCTYPE html><html lang="en"><head><title>Help for package windfarmGA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {windfarmGA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#windfarmGA-package'><p>windfarmGA: Genetic Algorithm for Wind Farm Layout Optimization</p></a></li>
<li><a href='#barometric_height'><p>Calculates Air Density, Air Pressure and Temperature according</p>
to the Barometric Height Formula</a></li>
<li><a href='#big_shape'><p>A POLYGON with an area of ~70 km2</p></a></li>
<li><a href='#calculate_energy'><p>Calculate Energy Outputs of Individuals</p></a></li>
<li><a href='#circle_intersection'><p>Get area of intersecting circles</p></a></li>
<li><a href='#crossover'><p>Crossover Method</p></a></li>
<li><a href='#fitness'><p>Evaluate the Individual Fitness values</p></a></li>
<li><a href='#genetic_algorithm'><p>Run a Genetic Algorithm to optimize a wind farm layout</p></a></li>
<li><a href='#get_dist_angles'><p>Calculate distances and angles of possibly influencing turbines</p></a></li>
<li><a href='#get_grids'><p>Get the Grid-IDs from binary matrix</p></a></li>
<li><a href='#grid_area'><p>Make a grid from a Simple Feature Polygon</p></a></li>
<li><a href='#hexa_area'><p>Polygon to Hexagonal Grids</p></a></li>
<li><a href='#hole_shape'><p>A POLYGON with a hole</p></a></li>
<li><a href='#init_population'><p>Create a random initial Population</p></a></li>
<li><a href='#isSpatial'><p>Transform to Simple Feature Polygons</p></a></li>
<li><a href='#multi_shape'><p>A MULTIPOLYGON with 3 Polygons</p></a></li>
<li><a href='#mutation'><p>Mutation Method</p></a></li>
<li><a href='#package_installed'><p>Is the package installed or not</p></a></li>
<li><a href='#permutations'><p>Enumerate the Combinations or Permutations of the Elements of a</p>
Vector</a></li>
<li><a href='#plot_cloud'><p>Plot outputs of all generations with standard deviations</p></a></li>
<li><a href='#plot_development'><p>Plot the progress of populations</p></a></li>
<li><a href='#plot_evolution'><p>Plot the evolution of fitness values</p></a></li>
<li><a href='#plot_fitness_evolution'><p>Plot the changes of min/mean/max fitness values</p></a></li>
<li><a href='#plot_leaflet'><p>Plot a wind warm with leaflet</p></a></li>
<li><a href='#plot_parkfitness'><p>Plot the genetic algorithm results</p></a></li>
<li><a href='#plot_random_search'><p>Plot the result of a randomized output.</p></a></li>
<li><a href='#plot_result'><p>Plot the best results</p></a></li>
<li><a href='#plot_viewshed'><p>Plot visibility</p></a></li>
<li><a href='#plot_windfarmGA'><p>Plot the results of an optimization run</p></a></li>
<li><a href='#plot_windrose'><p>Plot a Windrose</p></a></li>
<li><a href='#random_search'><p>Randomize the output of the Genetic Algorithm</p></a></li>
<li><a href='#random_search_single'><p>Randomize the location of a single turbine</p></a></li>
<li><a href='#readinteger'><p>Check Input Crossover Method</p></a></li>
<li><a href='#readintegerSel'><p>Check Input Selection Method</p></a></li>
<li><a href='#resulthex'><p>A resulting matrix of <code>genetic_algorithm</code> with 10 iterations</p>
and a hexagonal grid derived from <code>sp_polygon</code></a></li>
<li><a href='#resultrect'><p>A resulting matrix of <code>genetic_algorithm</code> with 200 iterations</p>
and a rectangular grid derived from <code>sp_polygon</code></a></li>
<li><a href='#selection'><p>Selection Method</p></a></li>
<li><a href='#sp_polygon'><p>The rectangular POLYGON used to create <code>resultrect</code> &amp; <code>resulthex</code></p></a></li>
<li><a href='#splitAt'><p>Split matrices or numeric vectors at specific indices</p></a></li>
<li><a href='#terrain_model'><p>Get topographic rasters</p></a></li>
<li><a href='#trimton'><p>Adjust the amount of turbines per windfarm</p></a></li>
<li><a href='#turbine_influences'><p>Find potentially influencing turbines</p></a></li>
<li><a href='#windata_format'><p>Transform Winddata</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Genetic Algorithm for Wind Farm Layout Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>4.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Gatscha &lt;sebastian_gatscha@gmx.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The genetic algorithm is designed to optimize wind farms of any shape. It requires a predefined amount of turbines, a unified rotor radius and an average wind speed value for each incoming wind direction. A terrain effect model can be included that downloads an 'SRTM' elevation model and loads a Corine Land Cover raster to approximate surface roughness.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, terra, sf, RColorBrewer, calibrate, grDevices, graphics,
magrittr, methods, stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ysosirius.github.io/windfarmGA/index.html">https://ysosirius.github.io/windfarmGA/index.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/YsoSirius/windfarmGA/issues">https://github.com/YsoSirius/windfarmGA/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), foreach, parallel, doParallel, progress,
stars, raster, leaflet, elevatr (&ge; 0.99.0), ggplot2, gstat,
rworldmap</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>windfarm-layout, optimization,
genetic-algorithm, renewable-energy, r, rstats, r-package</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-18 09:24:17 UTC; kona1</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Gatscha [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-18 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='windfarmGA-package'>windfarmGA: Genetic Algorithm for Wind Farm Layout Optimization</h2><span id='topic+windfarmGA'></span><span id='topic+windfarmGA-package'></span>

<h3>Description</h3>

<p>The genetic algorithm is designed to optimize wind farms of any shape. It requires a predefined amount of turbines, a unified rotor radius and an average wind speed value for each incoming wind direction. A terrain effect model can be included that downloads an 'SRTM' elevation model and loads a Corine Land Cover raster to approximate surface roughness.
</p>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p><img src="../help/figures/windfarmGA.png" width="25%" alt="Figure: windfarmGA.png" />

A package to optimize small wind farms with irregular shapes
using a genetic algorithm. It requires a fixed amount of turbines, a fixed
rotor radius and an average wind speed value for each incoming wind
direction. A terrain effect model can be included which downloads a digital
elevation model and a Corine Land Cover raster to approximate surface
roughness. Further information can be found at the description of the
function <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sebastian Gatscha <a href="mailto:sebastian_gatscha@gmx.at">sebastian_gatscha@gmx.at</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ysosirius.github.io/windfarmGA/">Documentation Github.io</a>
</p>
</li>
<li> <p><a href="https://github.com/YsoSirius/windfarmGA">Documentation</a>
</p>
</li>
<li> <p><a href="https://homepage.boku.ac.at/jschmidt/TOOLS/Masterarbeit_Gatscha.pdf">Master Thesis</a>
</p>
</li>
<li> <p><a href="https://windfarmga.shinyapps.io/windga_shiny">Shiny App</a>
</p>
</li>
<li> <p><a href="https://github.com/YsoSirius/windfarmGA/issues">Report Issues</a>
</p>
</li></ul>


<hr>
<h2 id='barometric_height'>Calculates Air Density, Air Pressure and Temperature according
to the Barometric Height Formula</h2><span id='topic+barometric_height'></span>

<h3>Description</h3>

<p>Calculates air density, temperature and air pressure
respective to certain heights according to the International
standard atmosphere and the barometric height formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barometric_height(data, height, po = 101325, ro = 1.225)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barometric_height_+3A_data">data</code></td>
<td>
<p>A data.frame containing the height values</p>
</td></tr>
<tr><td><code id="barometric_height_+3A_height">height</code></td>
<td>
<p>Column name of the height values</p>
</td></tr>
<tr><td><code id="barometric_height_+3A_po">po</code></td>
<td>
<p>Standardized air pressure at sea level (101325 Pa)</p>
</td></tr>
<tr><td><code id="barometric_height_+3A_ro">ro</code></td>
<td>
<p>Standardized air density at sea level (1,225 kg per m3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with height values and corresponding
air pressures, air densities and temperatures in Kelvin and Celsius.
</p>


<h3>See Also</h3>

<p>Other Wind Energy Calculation Functions: 
<code><a href="#topic+calculate_energy">calculate_energy</a>()</code>,
<code><a href="#topic+circle_intersection">circle_intersection</a>()</code>,
<code><a href="#topic+get_dist_angles">get_dist_angles</a>()</code>,
<code><a href="#topic+turbine_influences">turbine_influences</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(seq(0, 5000, 500))
barometric_height(data)
plot.ts(barometric_height(data))
</code></pre>

<hr>
<h2 id='big_shape'>A POLYGON with an area of ~70 km2</h2><span id='topic+big_shape'></span>

<h3>Description</h3>

<p>A POLYGON with an area of ~70 km2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>big_shape
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 1 rows and 1 columns.
</p>

<hr>
<h2 id='calculate_energy'>Calculate Energy Outputs of Individuals</h2><span id='topic+calculate_energy'></span>

<h3>Description</h3>

<p>Calculate the energy output and efficiency rates of an
individual in the current population under all given wind directions and
speeds. If the terrain effect model is activated, the main calculations to
model those effects will be done in this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_energy(
  sel,
  referenceHeight,
  RotorHeight,
  SurfaceRoughness,
  wnkl,
  distanz,
  polygon1,
  RotorR,
  dirSpeed,
  srtm_crop,
  topograp,
  cclRaster,
  weibull,
  plotit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_energy_+3A_sel">sel</code></td>
<td>
<p>A matrix of an individual of the current population</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_referenceheight">referenceHeight</code></td>
<td>
<p>The height at which the incoming wind speeds were
measured. Default is <code>RotorHeight</code></p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_rotorheight">RotorHeight</code></td>
<td>
<p>The height of the turbine hub</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_surfaceroughness">SurfaceRoughness</code></td>
<td>
<p>A surface roughness length in meters.
With the terrain effect model, a surface roughness is calculated for every
grid cell using the elevation and land cover data. Default is <code>0.3</code></p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_wnkl">wnkl</code></td>
<td>
<p>The angle from which wake influences are considered to be
negligible</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_distanz">distanz</code></td>
<td>
<p>The distance after which wake effects are considered
to be eliminated</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_polygon1">polygon1</code></td>
<td>
<p>The considered area as Simple Feature Polygon</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_rotorr">RotorR</code></td>
<td>
<p>The desired rotor radius in meter</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_dirspeed">dirSpeed</code></td>
<td>
<p>The wind speed and direction data.frame</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_srtm_crop">srtm_crop</code></td>
<td>
<p>The first element of the <code><a href="#topic+terrain_model">terrain_model</a></code> resulting list</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_topograp">topograp</code></td>
<td>
<p>Boolean value, which indicates if the terrain effect model
should be enabled or not. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_cclraster">cclRaster</code></td>
<td>
<p>The second element of the <code><a href="#topic+terrain_model">terrain_model</a></code> resulting list</p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_weibull">weibull</code></td>
<td>
<p>A boolean value that specifies whether to take Weibull
parameters into account. If <code>TRUE</code>, the wind speed values
of <code>vdirspe</code> are ignored. The algorithm will calculate the mean
wind speed for every wind turbine according to the Weibull parameters.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="calculate_energy_+3A_plotit">plotit</code></td>
<td>
<p>If <code>TRUE</code>, the process will be plotted.
Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of an individual of the current generation with
resulting wake effects, energy outputs, efficiency rates for every wind
direction. The length of the list corresponds to the number of different
wind directions.
</p>


<h3>See Also</h3>

<p>Other Wind Energy Calculation Functions: 
<code><a href="#topic+barometric_height">barometric_height</a>()</code>,
<code><a href="#topic+circle_intersection">circle_intersection</a>()</code>,
<code><a href="#topic+get_dist_angles">get_dist_angles</a>()</code>,
<code><a href="#topic+turbine_influences">turbine_influences</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a random Polygon
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))

## Create a uniform and unidirectional wind data.frame and plot the
## resulting wind rose
data.in &lt;- data.frame(ws = 12, wd = 0)
windrosePlot &lt;- plot_windrose(
  data = data.in, spd = data.in$ws,
  dir = data.in$wd, dirres = 10, spdmax = 20
)

## Assign the rotor radius and a factor of the radius for grid spacing.
Rotor &lt;- 50
fcrR &lt;- 3
resGrid &lt;- grid_area(
  shape = Polygon1, size = Rotor * fcrR, prop = 1,
  plotGrid = TRUE
)
## Assign the indexed data frame to new variable. Element 2 of the list
## is the grid, saved as Simple Feature Polygons.
resGrid1 &lt;- resGrid[[1]]

## Create an initial population with the indexed Grid, 15 turbines and
## 100 individuals.
initpop &lt;- init_population(Grid = resGrid1, n = 15, nStart = 100)

## Calculate the expected energy output of the first individual of the
## population.
par(mfrow = c(1, 2))
plot(Polygon1)
points(initpop[[1]][, "X"], initpop[[1]][, "Y"], pch = 20, cex = 2)
plot(resGrid[[2]], add = TRUE)
resCalcEn &lt;- calculate_energy(
  sel = initpop[[1]], referenceHeight = 50,
  RotorHeight = 50, SurfaceRoughness = 0.14, wnkl = 20,
  distanz = 100000, dirSpeed = data.in,
  RotorR = 50, polygon1 = Polygon1, topograp = FALSE,
  weibull = FALSE
)
resCalcEn &lt;- as.data.frame(resCalcEn)
plot(Polygon1, main = resCalcEn[, "Energy_Output_Red"][[1]])
points(x = resCalcEn[, "Bx"], y = resCalcEn[, "By"], pch = 20)


## Create a variable and multidirectional wind data.frame and plot the
## resulting wind rose
data.in10 &lt;- data.frame(ws = runif(10, 1, 25), wd = runif(10, 0, 360))
windrosePlot &lt;- plot_windrose(
  data = data.in10, spd = data.in10$ws,
  dir = data.in10$wd, dirres = 10, spdmax = 20
)

## Calculate the energy outputs for the first individual with more than one
## wind direction.
resCalcEn &lt;- calculate_energy(
  sel = initpop[[1]], referenceHeight = 50,
  RotorHeight = 50, SurfaceRoughness = 0.14, wnkl = 20,
  distanz = 100000, dirSpeed = data.in10,
  RotorR = 50, polygon1 = Polygon1, topograp = FALSE,
  weibull = FALSE
)


</code></pre>

<hr>
<h2 id='circle_intersection'>Get area of intersecting circles</h2><span id='topic+circle_intersection'></span>

<h3>Description</h3>

<p>Calculate the intersection area of two circles with different
radii and different heights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle_intersection(r1, r2, h1, h2, dx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circle_intersection_+3A_r1">r1</code></td>
<td>
<p>The radius of circle 1</p>
</td></tr>
<tr><td><code id="circle_intersection_+3A_r2">r2</code></td>
<td>
<p>The radius of circle 2</p>
</td></tr>
<tr><td><code id="circle_intersection_+3A_h1">h1</code></td>
<td>
<p>The height of the circle center 1</p>
</td></tr>
<tr><td><code id="circle_intersection_+3A_h2">h2</code></td>
<td>
<p>The height of the circle center 2</p>
</td></tr>
<tr><td><code id="circle_intersection_+3A_dx">dx</code></td>
<td>
<p>The distance on the x-axis between both centers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value
</p>


<h3>See Also</h3>

<p>Other Wind Energy Calculation Functions: 
<code><a href="#topic+barometric_height">barometric_height</a>()</code>,
<code><a href="#topic+calculate_energy">calculate_energy</a>()</code>,
<code><a href="#topic+get_dist_angles">get_dist_angles</a>()</code>,
<code><a href="#topic+turbine_influences">turbine_influences</a>()</code>
</p>

<hr>
<h2 id='crossover'>Crossover Method</h2><span id='topic+crossover'></span>

<h3>Description</h3>

<p>The crossover method creates new offspring with the selected
individuals by permutating their genetic codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossover(se6, u, uplimit, crossPart = c("EQU", "RAN"), verbose, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossover_+3A_se6">se6</code></td>
<td>
<p>The selected individuals. The output of <code><a href="#topic+selection">selection</a></code></p>
</td></tr>
<tr><td><code id="crossover_+3A_u">u</code></td>
<td>
<p>The crossover point rate</p>
</td></tr>
<tr><td><code id="crossover_+3A_uplimit">uplimit</code></td>
<td>
<p>The upper limit of allowed permutations</p>
</td></tr>
<tr><td><code id="crossover_+3A_crosspart">crossPart</code></td>
<td>
<p>The crossover method. Either &quot;EQU&quot; or &quot;RAN&quot;</p>
</td></tr>
<tr><td><code id="crossover_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, will print out further information</p>
</td></tr>
<tr><td><code id="crossover_+3A_seed">seed</code></td>
<td>
<p>Set a seed for comparability. Default is <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a binary coded matrix of all permutations and all grid cells,
where 0 indicates no turbine and 1 indicates a turbine in the grid cell.
</p>


<h3>See Also</h3>

<p>Other Genetic Algorithm Functions: 
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+genetic_algorithm">genetic_algorithm</a>()</code>,
<code><a href="#topic+init_population">init_population</a>()</code>,
<code><a href="#topic+mutation">mutation</a>()</code>,
<code><a href="#topic+selection">selection</a>()</code>,
<code><a href="#topic+trimton">trimton</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create two random parents with an index and random binary values
Parents &lt;- data.frame(
  ID = 1:20,
  bin = sample(c(0, 1), 20, replace = TRUE, prob = c(70, 30)),
  bin.1 = sample(c(0, 1), 20, replace = TRUE, prob = c(30, 70))
)

## Create random Fitness values for both individuals
FitParents &lt;- data.frame(ID = 1, Fitness = 1000, Fitness.1 = 20)

## Assign both values to a list
CrossSampl &lt;- list(Parents, FitParents)
## Cross their data at equal locations with 2 crossover parts
crossover(CrossSampl, u = 1.1, uplimit = 300, crossPart = "EQU")

## with 3 crossover parts and equal locations
crossover(CrossSampl, u = 2.5, uplimit = 300, crossPart = "EQU")

## or with random locations and 5 crossover parts
crossover(CrossSampl, u = 4.9, uplimit = 300, crossPart = "RAN")

</code></pre>

<hr>
<h2 id='fitness'>Evaluate the Individual Fitness values</h2><span id='topic+fitness'></span>

<h3>Description</h3>

<p>The fitness of all individuals in the current population
is calculated after their energy output has been evaluated in
<code><a href="#topic+calculate_energy">calculate_energy</a></code>. This function reduces the resulting energy
outputs to a single fitness value for each individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitness(
  selection,
  referenceHeight,
  RotorHeight,
  SurfaceRoughness,
  Polygon,
  resol1,
  rot,
  dirspeed,
  srtm_crop,
  topograp,
  cclRaster,
  weibull,
  Parallel,
  numCluster
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitness_+3A_selection">selection</code></td>
<td>
<p>A list containing all individuals of the current population.</p>
</td></tr>
<tr><td><code id="fitness_+3A_referenceheight">referenceHeight</code></td>
<td>
<p>The height at which the incoming wind speeds were
measured. Default is <code>RotorHeight</code></p>
</td></tr>
<tr><td><code id="fitness_+3A_rotorheight">RotorHeight</code></td>
<td>
<p>The height of the turbine hub</p>
</td></tr>
<tr><td><code id="fitness_+3A_surfaceroughness">SurfaceRoughness</code></td>
<td>
<p>A surface roughness length in meters.
With the terrain effect model, a surface roughness is calculated for every
grid cell using the elevation and land cover data. Default is <code>0.3</code></p>
</td></tr>
<tr><td><code id="fitness_+3A_polygon">Polygon</code></td>
<td>
<p>The considered area as shapefile.</p>
</td></tr>
<tr><td><code id="fitness_+3A_resol1">resol1</code></td>
<td>
<p>The resolution of the grid in meter.</p>
</td></tr>
<tr><td><code id="fitness_+3A_rot">rot</code></td>
<td>
<p>The desired rotor radius in meter.</p>
</td></tr>
<tr><td><code id="fitness_+3A_dirspeed">dirspeed</code></td>
<td>
<p>The wind data as list.</p>
</td></tr>
<tr><td><code id="fitness_+3A_srtm_crop">srtm_crop</code></td>
<td>
<p>A list of 3 raster, with 1) the elevation, 2) an orographic
and 3) a terrain raster. Calculated in <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="fitness_+3A_topograp">topograp</code></td>
<td>
<p>Boolean value, which indicates if the terrain effect model
should be enabled or not. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fitness_+3A_cclraster">cclRaster</code></td>
<td>
<p>A Corine Land Cover raster, that has to be adapted
previously by hand with the surface roughness length for every land cover
type. Is only used, when the terrain effect model is activated.</p>
</td></tr>
<tr><td><code id="fitness_+3A_weibull">weibull</code></td>
<td>
<p>A raster representing the estimated wind speeds</p>
</td></tr>
<tr><td><code id="fitness_+3A_parallel">Parallel</code></td>
<td>
<p>A boolean value, indicating whether parallel processing
should be used. The <em>parallel</em> and <em>doParallel</em> packages are used for
parallel processing. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fitness_+3A_numcluster">numCluster</code></td>
<td>
<p>If <code>Parallel</code> is TRUE, this variable defines the
number of clusters to be used. Default is <code>2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with every individual, consisting of X &amp; Y
coordinates, rotor radii, the runs and the selected grid cell IDs, and the
resulting energy outputs, efficiency rates and fitness values.
</p>


<h3>See Also</h3>

<p>Other Genetic Algorithm Functions: 
<code><a href="#topic+crossover">crossover</a>()</code>,
<code><a href="#topic+genetic_algorithm">genetic_algorithm</a>()</code>,
<code><a href="#topic+init_population">init_population</a>()</code>,
<code><a href="#topic+mutation">mutation</a>()</code>,
<code><a href="#topic+selection">selection</a>()</code>,
<code><a href="#topic+trimton">trimton</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a random rectangular shapefile
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))

## Create a uniform and unidirectional wind data.frame and plots the
## resulting wind rose
## Uniform wind speed and single wind direction
wind &lt;- data.frame(ws = 12, wd = 0)
# windrosePlot &lt;- plot_windrose(data = wind, spd = wind$ws,
#                dir = wind$wd, dirres=10, spdmax=20)

## Calculate a Grid and an indexed data.frame with coordinates and
## grid cell IDs.
Grid1 &lt;- grid_area(shape = Polygon1, size = 200, prop = 1)
Grid &lt;- Grid1[[1]]
AmountGrids &lt;- nrow(Grid)

wind &lt;- list(wind, probab = 100)
startsel &lt;- init_population(Grid, 10, 20)
fit &lt;- fitness(
  selection = startsel, referenceHeight = 100, RotorHeight = 100,
  SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200, rot = 20,
  dirspeed = wind, srtm_crop = "", topograp = FALSE, cclRaster = "",
  Parallel = FALSE
)

</code></pre>

<hr>
<h2 id='genetic_algorithm'>Run a Genetic Algorithm to optimize a wind farm layout</h2><span id='topic+genetic_algorithm'></span>

<h3>Description</h3>

<p>Run a Genetic Algorithm to optimize the layout of wind turbines
on a given area. The algorithm works with a fixed amount of turbines, a
fixed rotor radius and a mean wind speed value for every incoming wind
direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genetic_algorithm(
  Polygon1,
  GridMethod,
  Rotor,
  n,
  fcrR,
  referenceHeight,
  RotorHeight,
  SurfaceRoughness,
  Proportionality,
  iteration,
  mutr,
  vdirspe,
  topograp,
  elitism,
  nelit,
  selstate,
  crossPart1,
  trimForce,
  Projection,
  sourceCCL,
  sourceCCLRoughness,
  weibull,
  weibullsrc,
  Parallel,
  numCluster,
  verbose = FALSE,
  plotit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genetic_algorithm_+3A_polygon1">Polygon1</code></td>
<td>
<p>The considered area as SpatialPolygon, SimpleFeature Polygon
or coordinates as matrix/data.frame</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_gridmethod">GridMethod</code></td>
<td>
<p>Should the polygon be divided into rectangular or hexagonal
grid cells? The default is <code>Rectangular</code> grid. Hexagonal grids
are computed when assigning <code>h</code> or <code>hexagon</code> to this input variable.</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_rotor">Rotor</code></td>
<td>
<p>The rotor radius in meter</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_n">n</code></td>
<td>
<p>The amount of turbines</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_fcrr">fcrR</code></td>
<td>
<p>A numeric value used for grid spacing. Default is <code>5</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_referenceheight">referenceHeight</code></td>
<td>
<p>The height at which the incoming wind speeds were
measured. Default is <code>RotorHeight</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_rotorheight">RotorHeight</code></td>
<td>
<p>The height of the turbine hub</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_surfaceroughness">SurfaceRoughness</code></td>
<td>
<p>A surface roughness length in meters.
With the terrain effect model, a surface roughness is calculated for every
grid cell using the elevation and land cover data. Default is <code>0.3</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_proportionality">Proportionality</code></td>
<td>
<p>A numeric value used for the grid calculation, as it
determines the percentage a grid cell must overlay the area.
Default is <code>1</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_iteration">iteration</code></td>
<td>
<p>The number of iterations. Default is <code>20</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_mutr">mutr</code></td>
<td>
<p>A numeric mutation rate. Default is <code>0.008</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_vdirspe">vdirspe</code></td>
<td>
<p>A data.frame containing the wind speeds, directions and
probabilities. See <code><a href="#topic+windata_format">windata_format</a></code>.</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_topograp">topograp</code></td>
<td>
<p>Boolean value, which indicates if the terrain effect model
should be enabled or not. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_elitism">elitism</code></td>
<td>
<p>Boolean value, which indicates whether elitism should be
activated or not. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_nelit">nelit</code></td>
<td>
<p>If <code>elitism</code> is TRUE, this input determines the amount
of individuals in the elite group. Default is 7</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_selstate">selstate</code></td>
<td>
<p>Determines which selection method is used, &quot;FIX&quot; selects a
constant percentage and &quot;VAR&quot; selects a variable percentage, depending on
the development of the fitness values. Default is &quot;FIX&quot;</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_crosspart1">crossPart1</code></td>
<td>
<p>Determines which crossover method is used, &quot;EQU&quot; divides
the genetic code at equal intervals and &quot;RAN&quot; divides the genetic code at
random locations. Default is <code>"EQU"</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_trimforce">trimForce</code></td>
<td>
<p>If <code>TRUE</code> the algorithm will use a probabilistic
approach to correct the windfarms to the desired amount of turbines.
If <code>FALSE</code> the adjustment will be random. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_projection">Projection</code></td>
<td>
<p>A spatial reference system. Depending on your PROJ-version,
it should either be a numeric <code>EPSG-code</code> or a <code>Proj4-string</code>.
Default is <code>EPSG:3035</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_sourceccl">sourceCCL</code></td>
<td>
<p>The path to the Corine Land Cover raster (.tif). Only
required when the terrain effect model is activated.</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_sourcecclroughness">sourceCCLRoughness</code></td>
<td>
<p>The source to the adapted Corine Land Cover legend
as .csv file. Only required when terrain effect model is activated. As
default a .csv file within this package (&lsquo;<span class="file">~/extdata</span>&rsquo;) is taken that
was already adapted manually.</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_weibull">weibull</code></td>
<td>
<p>A boolean value that specifies whether to take Weibull
parameters into account. If <code>TRUE</code>, the wind speed values
of <code>vdirspe</code> are ignored. The algorithm will calculate the mean
wind speed for every wind turbine according to the Weibull parameters.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_weibullsrc">weibullsrc</code></td>
<td>
<p>A list of Weibull parameter rasters, where the first list
item must be the shape parameter raster <code>k</code> and the second item must be the
scale parameter raster <code>a</code> of the Weibull distribution. If no list is
given, then rasters included in the package are used instead, which
currently only cover Austria. This variable is only used
if <code>weibull = TRUE</code>.</p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_parallel">Parallel</code></td>
<td>
<p>A boolean value, indicating whether parallel processing
should be used. The <em>parallel</em> and <em>doParallel</em> packages are used for
parallel processing. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_numcluster">numCluster</code></td>
<td>
<p>If <code>Parallel</code> is TRUE, this variable defines the
number of clusters to be used. Default is <code>2</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE it will print information for every generation.
Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="genetic_algorithm_+3A_plotit">plotit</code></td>
<td>
<p>If TRUE it will plot the best windfarm of every generation.
Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A terrain effect model can be included in the optimization process.
Therefore, a digital elevation model will be downloaded automatically via
the <code>elevatr::get_elev_raster</code> function. A land cover raster can also
downloaded automatically from the EEA-website, or the path to a raster file
can be passed to <code>sourceCCL</code>. The algorithm uses an adapted version of
the Raster legend (&quot;clc_legend.csv&quot;), which is stored in the package
directory &lsquo;<span class="file">~/inst/extdata</span>&rsquo;. To use other values for the land cover
roughness lengths, insert a column named <strong>&quot;Rauhigkeit_z&quot;</strong> to the
.csv file, assign a surface roughness length to all land cover types. Be
sure that all rows are filled with numeric values and save the file with
<strong>&quot;;&quot;</strong> separation. Assign the path of the file to the input variable
<code>sourceCCLRoughness</code> of this function.
</p>


<h3>Value</h3>

<p>The result is a matrix with aggregated values per generation; the
best individual regarding energy and efficiency per generation, some fuzzy
control variables per generation, a list of all fitness values per
generation, the amount of individuals after each process, a matrix of all
energy, efficiency and fitness values per generation, the selection and
crossover parameters, a matrix with the generational difference in maximum
and mean energy output, a matrix with the given inputs, a dataframe with
the wind information, the mutation rate per generation and a matrix with
all tested wind farm layouts.
</p>


<h3>See Also</h3>

<p>Other Genetic Algorithm Functions: 
<code><a href="#topic+crossover">crossover</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+init_population">init_population</a>()</code>,
<code><a href="#topic+mutation">mutation</a>()</code>,
<code><a href="#topic+selection">selection</a>()</code>,
<code><a href="#topic+trimton">trimton</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Create a random rectangular shapefile
library(sf)

Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))

## Create a uniform and unidirectional wind data.frame and plot the
## resulting wind rose
data.in &lt;- data.frame(ws = 12, wd = 0)
windrosePlot &lt;- plot_windrose(
  data = data.in, spd = data.in$ws,
  dir = data.in$wd, dirres = 10, spdmax = 20
)

## Runs an optimization run for 20 iterations with the
## given shapefile (Polygon1), the wind data.frame (data.in),
## 12 turbines (n) with rotor radii of 30m (Rotor) and rotor height of 100m.
result &lt;- genetic_algorithm(
  Polygon1 = Polygon1,
  n = 12,
  vdirspe = data.in,
  Rotor = 30,
  RotorHeight = 100
)
plot_windfarmGA(result = result, Polygon1 = Polygon1)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_dist_angles'>Calculate distances and angles of possibly influencing turbines</h2><span id='topic+get_dist_angles'></span>

<h3>Description</h3>

<p>Calculate distances and angles for a turbine and all it's
potentially influencing turbines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dist_angles(t, o, wnkl, dist, polYgon, plotAngles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_dist_angles_+3A_t">t</code></td>
<td>
<p>A data.frame of the current individual with X and Y coordinates</p>
</td></tr>
<tr><td><code id="get_dist_angles_+3A_o">o</code></td>
<td>
<p>A numeric value indicating the index of the current turbine</p>
</td></tr>
<tr><td><code id="get_dist_angles_+3A_wnkl">wnkl</code></td>
<td>
<p>The angle from which wake influences are considered to be
negligible</p>
</td></tr>
<tr><td><code id="get_dist_angles_+3A_dist">dist</code></td>
<td>
<p>A numeric value indicating the distance, after which the wake
effects are considered to be eliminated.</p>
</td></tr>
<tr><td><code id="get_dist_angles_+3A_polygon">polYgon</code></td>
<td>
<p>A shapefile representing the considered area</p>
</td></tr>
<tr><td><code id="get_dist_angles_+3A_plotangles">plotAngles</code></td>
<td>
<p>A logical variable, which is used to plot the distances and
angles. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with the distances, angles and heights of potentially
influencing turbines
</p>


<h3>See Also</h3>

<p>Other Wind Energy Calculation Functions: 
<code><a href="#topic+barometric_height">barometric_height</a>()</code>,
<code><a href="#topic+calculate_energy">calculate_energy</a>()</code>,
<code><a href="#topic+circle_intersection">circle_intersection</a>()</code>,
<code><a href="#topic+turbine_influences">turbine_influences</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

## Exemplary input Polygon with 2km x 2km:
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))

## Create a random windfarm with 10 turbines
t &lt;- st_coordinates(st_sample(Polygon1, 10))
t &lt;- cbind(t, "Z" = 1)
wnkl &lt;- 20
dist &lt;- 100000

## Evaluate and plot for every turbine all other potentially influencing turbines
potInfTur &lt;- list()
for (i in 1:(length(t[, 1]))) {
  potInfTur[[i]] &lt;- get_dist_angles(
    t = t, o = i, wnkl = wnkl,
    dist = dist, polYgon = Polygon1, plotAngles = TRUE
  )
}
potInfTur

</code></pre>

<hr>
<h2 id='get_grids'>Get the Grid-IDs from binary matrix</h2><span id='topic+get_grids'></span>

<h3>Description</h3>

<p>Retrieve the grid ID's from the binary matrix, where the
binary code indicates which grid cells are used in the current wind farm
constellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_grids(trimtonOut, Grid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_grids_+3A_trimtonout">trimtonOut</code></td>
<td>
<p>Input matrix with binary values</p>
</td></tr>
<tr><td><code id="get_grids_+3A_grid">Grid</code></td>
<td>
<p>Grid of the considered area</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of all individuals with X and Y coordinates and the
grid cell ID.
</p>


<h3>See Also</h3>

<p>Other Helper Functions: 
<code><a href="#topic+grid_area">grid_area</a>()</code>,
<code><a href="#topic+hexa_area">hexa_area</a>()</code>,
<code><a href="#topic+isSpatial">isSpatial</a>()</code>,
<code><a href="#topic+permutations">permutations</a>()</code>,
<code><a href="#topic+readinteger">readinteger</a>()</code>,
<code><a href="#topic+readintegerSel">readintegerSel</a>()</code>,
<code><a href="#topic+splitAt">splitAt</a>()</code>,
<code><a href="#topic+windata_format">windata_format</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a random rectangular shapefile
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(0, 0, 2000, 2000, 0),
    c(0, 2000, 2000, 0, 0)
  ))),
  crs = 3035
))

## Calculate a Grid and an indexed data.frame with coordinates and
## grid cell Ids.
Grid1 &lt;- grid_area(shape = Polygon1, size = 200, prop = 1)
Grid &lt;- Grid1[[1]]
AmountGrids &lt;- nrow(Grid)

startsel &lt;- init_population(Grid, 10, 20)
wind &lt;- data.frame(ws = 12, wd = 0)
wind &lt;- list(wind, probab = 100)
fit &lt;- fitness(
  selection = startsel, referenceHeight = 100, RotorHeight = 100,
  SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200, rot = 20,
  dirspeed = wind, srtm_crop = "", topograp = FALSE, cclRaster = ""
)
allparks &lt;- do.call("rbind", fit)

## SELECTION
## print the amount of Individuals selected.
## Check if the amount of Turbines is as requested.
selec6best &lt;- selection(fit, Grid, 2, TRUE, 6, "VAR")

## CROSSOVER
## u determines the amount of crossover points,
## crossPart determines the method used (Equal/Random),
## uplimit is the maximum allowed permutations
crossOut &lt;- crossover(selec6best, 2, uplimit = 300, crossPart = "RAN")

## MUTATION
## Variable Mutation Rate is activated if more than 2 individuals represent
## the current best solution.
mut &lt;- mutation(a = crossOut, p = 0.3)

## TRIMTON
## After Crossover and Mutation, the amount of turbines in a windpark change
## and have to be corrected to the required amount of turbines.
mut1 &lt;- trimton(
  mut = mut, nturb = 10, allparks = allparks,
  nGrids = AmountGrids, trimForce = FALSE
)

## Get the new Grid-Ids and run a new fitness run.
getRectV &lt;- get_grids(mut1, Grid)
fit &lt;- fitness(
  selection = getRectV, referenceHeight = 100, RotorHeight = 100,
  SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200, rot = 20,
  dirspeed = wind, srtm_crop = "", topograp = FALSE, cclRaster = ""
)
head(fit)

</code></pre>

<hr>
<h2 id='grid_area'>Make a grid from a Simple Feature Polygon</h2><span id='topic+grid_area'></span>

<h3>Description</h3>

<p>Create a grid from a given polygon with a certain resolution
and proportionality. The grid cell centroids represent possible
wind turbine locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_area(shape, size = 500, prop = 1, plotGrid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid_area_+3A_shape">shape</code></td>
<td>
<p>Simple Feature Polygon of the considered area</p>
</td></tr>
<tr><td><code id="grid_area_+3A_size">size</code></td>
<td>
<p>The cellsize of the grid in meters. Default is 500</p>
</td></tr>
<tr><td><code id="grid_area_+3A_prop">prop</code></td>
<td>
<p>A factor used for grid calculation. It determines the minimum
percentage that a grid cell must cover the area. Default is 1</p>
</td></tr>
<tr><td><code id="grid_area_+3A_plotgrid">plotGrid</code></td>
<td>
<p>Logical value indicating whether the results should be
plotted. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with 2 elements. List element 1 will have the grid
cell IDS, and the X and Y coordinates of the centers of each grid cell.
List element 2 is the grid as Simple Feature Polygons, which is used for
plotting purposes.
</p>


<h3>Note</h3>

<p>The grid of the genetic algorithm will have a resolution of <code>Rotor
  * fcrR</code>. See the arguments of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code>
</p>


<h3>See Also</h3>

<p>Other Helper Functions: 
<code><a href="#topic+get_grids">get_grids</a>()</code>,
<code><a href="#topic+hexa_area">hexa_area</a>()</code>,
<code><a href="#topic+isSpatial">isSpatial</a>()</code>,
<code><a href="#topic+permutations">permutations</a>()</code>,
<code><a href="#topic+readinteger">readinteger</a>()</code>,
<code><a href="#topic+readintegerSel">readintegerSel</a>()</code>,
<code><a href="#topic+splitAt">splitAt</a>()</code>,
<code><a href="#topic+windata_format">windata_format</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Exemplary input Polygon with 2km x 2km:
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(0, 0, 2000, 2000, 0),
    c(0, 2000, 2000, 0, 0)
  ))),
  crs = 3035
))

## Create a Grid
grid_area(Polygon1, 200, 1, TRUE)
grid_area(Polygon1, 400, 1, TRUE)

## Examplary irregular input Polygon
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(0, 0, 2000, 3000, 0),
    c(20, 200, 2000, 0, 20)
  ))),
  crs = 3035
))

## Create a Grid
grid_area(Polygon1, 200, 1, TRUE)
grid_area(Polygon1, 200, 0.1, TRUE)
grid_area(Polygon1, 400, 1, TRUE)
grid_area(Polygon1, 400, 0.1, TRUE)

</code></pre>

<hr>
<h2 id='hexa_area'>Polygon to Hexagonal Grids</h2><span id='topic+hexa_area'></span>

<h3>Description</h3>

<p>The function takes a Simple Feature Polygon and a size argument
and creates a list with an indexed matrix with coordinates and a
Simple Feature object, that consists of hexagonal grids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexa_area(shape, size = 500, plotGrid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexa_area_+3A_shape">shape</code></td>
<td>
<p>Simple Feature Polygon of the considered area</p>
</td></tr>
<tr><td><code id="hexa_area_+3A_size">size</code></td>
<td>
<p>The cellsize of the grid in meters. Default is 500</p>
</td></tr>
<tr><td><code id="hexa_area_+3A_plotgrid">plotGrid</code></td>
<td>
<p>Logical value indicating whether the results should be
plotted. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with 2 elements. List element 1 will have the grid
cell IDS, and the X and Y coordinates of the centers of each grid cell.
List element 2 is the grid as Simple Feature Polygons, which is used for
plotting purposes.
</p>


<h3>See Also</h3>

<p>Other Helper Functions: 
<code><a href="#topic+get_grids">get_grids</a>()</code>,
<code><a href="#topic+grid_area">grid_area</a>()</code>,
<code><a href="#topic+isSpatial">isSpatial</a>()</code>,
<code><a href="#topic+permutations">permutations</a>()</code>,
<code><a href="#topic+readinteger">readinteger</a>()</code>,
<code><a href="#topic+readintegerSel">readintegerSel</a>()</code>,
<code><a href="#topic+splitAt">splitAt</a>()</code>,
<code><a href="#topic+windata_format">windata_format</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
## Exemplary input Polygon with 2km x 2km:
Poly &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))
HexGrid &lt;- hexa_area(Poly, 100, TRUE)

</code></pre>

<hr>
<h2 id='hole_shape'>A POLYGON with a hole</h2><span id='topic+hole_shape'></span>

<h3>Description</h3>

<p>A POLYGON with a hole
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hole_shape
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 1 rows and 2 columns.
</p>

<hr>
<h2 id='init_population'>Create a random initial Population</h2><span id='topic+init_population'></span>

<h3>Description</h3>

<p>Create <code>nStart</code> random sub-selections from the indexed
grid and assign binary variable 1 to selected grids. This function
initiates the genetic algorithm with a first random population and will
only be needed in the first iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_population(Grid, n, nStart = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_population_+3A_grid">Grid</code></td>
<td>
<p>The data.frame output of <code><a href="#topic+grid_area">grid_area</a></code>&quot; function, with
X and Y coordinates and Grid cell IDs.</p>
</td></tr>
<tr><td><code id="init_population_+3A_n">n</code></td>
<td>
<p>A numeric value indicating the amount of required turbines.</p>
</td></tr>
<tr><td><code id="init_population_+3A_nstart">nStart</code></td>
<td>
<p>A numeric indicating the amount of randomly generated initial
individuals. Default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of <code>nStart</code> initial individuals, each consisting
of <code>n</code> turbines. Resulting list has the x and y coordinates, the grid
cell ID and a binary variable of 1, indicating a turbine in the grid cell.
</p>


<h3>See Also</h3>

<p>Other Genetic Algorithm Functions: 
<code><a href="#topic+crossover">crossover</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+genetic_algorithm">genetic_algorithm</a>()</code>,
<code><a href="#topic+mutation">mutation</a>()</code>,
<code><a href="#topic+selection">selection</a>()</code>,
<code><a href="#topic+trimton">trimton</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
## Exemplary input Polygon with 2km x 2km:
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))

Grid &lt;- grid_area(Polygon1, 200, 1, TRUE)

## Create 5 individuals with 10 wind turbines each.
firstPop &lt;- init_population(Grid = Grid[[1]], n = 10, nStart = 5)

</code></pre>

<hr>
<h2 id='isSpatial'>Transform to Simple Feature Polygons</h2><span id='topic+isSpatial'></span>

<h3>Description</h3>

<p>Helper Function, which transforms SpatialPolygons or coordinates
in matrix/data.frame - form to a Simple Feature Polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSpatial(shape, proj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isSpatial_+3A_shape">shape</code></td>
<td>
<p>An area as SpatialPolygon, SimpleFeature Polygon or coordinates
as matrix/data.frame</p>
</td></tr>
<tr><td><code id="isSpatial_+3A_proj">proj</code></td>
<td>
<p>Which Projection should be assigned to matrix / data.frame
coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the columns are named, it will look for common abbreviation to
match x/y or long/lat columns. If the columns are not named, the first 2
numeric columns are taken.
</p>


<h3>Value</h3>

<p>A Simple Feature Polygon
</p>


<h3>See Also</h3>

<p>Other Helper Functions: 
<code><a href="#topic+get_grids">get_grids</a>()</code>,
<code><a href="#topic+grid_area">grid_area</a>()</code>,
<code><a href="#topic+hexa_area">hexa_area</a>()</code>,
<code><a href="#topic+permutations">permutations</a>()</code>,
<code><a href="#topic+readinteger">readinteger</a>()</code>,
<code><a href="#topic+readintegerSel">readintegerSel</a>()</code>,
<code><a href="#topic+splitAt">splitAt</a>()</code>,
<code><a href="#topic+windata_format">windata_format</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sf)
df &lt;- rbind(
  c(4498482, 2668272), c(4498482, 2669343),
  c(4499991, 2669343), c(4499991, 2668272)
)
isSpatial(df)

Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))
isSpatial(st_coordinates(Polygon1), 3035)

</code></pre>

<hr>
<h2 id='multi_shape'>A MULTIPOLYGON with 3 Polygons</h2><span id='topic+multi_shape'></span>

<h3>Description</h3>

<p>A MULTIPOLYGON with 3 Polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_shape
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 1 rows and 1 columns.
</p>

<hr>
<h2 id='mutation'>Mutation Method</h2><span id='topic+mutation'></span>

<h3>Description</h3>

<p>The function randomly mutates an individual's genetic code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation(a, p, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutation_+3A_a">a</code></td>
<td>
<p>The binary matrix of all individuals</p>
</td></tr>
<tr><td><code id="mutation_+3A_p">p</code></td>
<td>
<p>The mutation rate</p>
</td></tr>
<tr><td><code id="mutation_+3A_seed">seed</code></td>
<td>
<p>Set a seed for comparability. Default is <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a binary matrix with mutated genes.
</p>


<h3>See Also</h3>

<p>Other Genetic Algorithm Functions: 
<code><a href="#topic+crossover">crossover</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+genetic_algorithm">genetic_algorithm</a>()</code>,
<code><a href="#topic+init_population">init_population</a>()</code>,
<code><a href="#topic+selection">selection</a>()</code>,
<code><a href="#topic+trimton">trimton</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create 4 random individuals with binary values
a &lt;- cbind(
  bin0 = sample(c(0, 1), 20, replace = TRUE, prob = c(70, 30)),
  bin1 = sample(c(0, 1), 20, replace = TRUE, prob = c(30, 70)),
  bin2 = sample(c(0, 1), 20, replace = TRUE, prob = c(30, 70)),
  bin3 = sample(c(0, 1), 20, replace = TRUE, prob = c(30, 70))
)
a

## Mutate the individuals with a low percentage
aMut &lt;- mutation(a, 0.1, NULL)
## Check which values are not like the originals
a == aMut

## Mutate the individuals with a high percentage
aMut &lt;- mutation(a, 0.4, NULL)
## Check which values are not like the originals
a == aMut

</code></pre>

<hr>
<h2 id='package_installed'>Is the package installed or not</h2><span id='topic+package_installed'></span><span id='topic+is_foreach_installed'></span><span id='topic+is_parallel_installed'></span><span id='topic+is_doparallel_installed'></span><span id='topic+is_ggplot2_installed'></span><span id='topic+is_leaflet_installed'></span><span id='topic+is_elevatr_installed'></span>

<h3>Description</h3>

<p>Is the package installed or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_foreach_installed()

is_parallel_installed()

is_doparallel_installed()

is_ggplot2_installed()

is_leaflet_installed()

is_elevatr_installed()
</code></pre>


<h3>Value</h3>

<p>An invisible boolean value, indicating if the package is
installed or not.
</p>

<hr>
<h2 id='permutations'>Enumerate the Combinations or Permutations of the Elements of a
Vector</h2><span id='topic+permutations'></span>

<h3>Description</h3>

<p>permutations enumerates the possible permutations. The
function is forked and minified from gtools::permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations(n, r, v = 1:n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutations_+3A_n">n</code></td>
<td>
<p>Size of the source vector</p>
</td></tr>
<tr><td><code id="permutations_+3A_r">r</code></td>
<td>
<p>Size of the target vectors</p>
</td></tr>
<tr><td><code id="permutations_+3A_v">v</code></td>
<td>
<p>Source vector. Defaults to 1:n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix where each row contains a vector of length r.
</p>


<h3>Author(s)</h3>

<p>Original versions by Bill Venables. Extended to handle repeats.allowed
by Gregory R. Warnes
</p>


<h3>References</h3>

<p>Venables, Bill. &quot;Programmers Note&quot;, R-News, Vol 1/1, Jan. 2001.
<a href="https://cran.r-project.org/doc/Rnews/">https://cran.r-project.org/doc/Rnews/</a>
</p>


<h3>See Also</h3>

<p>Other Helper Functions: 
<code><a href="#topic+get_grids">get_grids</a>()</code>,
<code><a href="#topic+grid_area">grid_area</a>()</code>,
<code><a href="#topic+hexa_area">hexa_area</a>()</code>,
<code><a href="#topic+isSpatial">isSpatial</a>()</code>,
<code><a href="#topic+readinteger">readinteger</a>()</code>,
<code><a href="#topic+readintegerSel">readintegerSel</a>()</code>,
<code><a href="#topic+splitAt">splitAt</a>()</code>,
<code><a href="#topic+windata_format">windata_format</a>()</code>
</p>

<hr>
<h2 id='plot_cloud'>Plot outputs of all generations with standard deviations</h2><span id='topic+plot_cloud'></span>

<h3>Description</h3>

<p>Plot the fitness, efficiency and energy outputs of all
generations and the corresponding standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cloud(result, pl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_cloud_+3A_result">result</code></td>
<td>
<p>The output of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="plot_cloud_+3A_pl">pl</code></td>
<td>
<p>Should the results be plotted? Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with the values for fitness, efficiency and
energy for all evaluated individuals
</p>


<h3>See Also</h3>

<p>Other Plotting Functions: 
<code><a href="#topic+plot_development">plot_development</a>()</code>,
<code><a href="#topic+plot_evolution">plot_evolution</a>()</code>,
<code><a href="#topic+plot_fitness_evolution">plot_fitness_evolution</a>()</code>,
<code><a href="#topic+plot_parkfitness">plot_parkfitness</a>()</code>,
<code><a href="#topic+plot_result">plot_result</a>()</code>,
<code><a href="#topic+plot_windfarmGA">plot_windfarmGA</a>()</code>,
<code><a href="#topic+plot_windrose">plot_windrose</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plot the results of a hexagonal grid optimization
plcdf &lt;- plot_cloud(resulthex, TRUE)

</code></pre>

<hr>
<h2 id='plot_development'>Plot the progress of populations</h2><span id='topic+plot_development'></span>

<h3>Description</h3>

<p>Plot the changes in mean and max fitness values to previous
generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_development(result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_development_+3A_result">result</code></td>
<td>
<p>The output of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Used for plotting
</p>


<h3>See Also</h3>

<p>Other Plotting Functions: 
<code><a href="#topic+plot_cloud">plot_cloud</a>()</code>,
<code><a href="#topic+plot_evolution">plot_evolution</a>()</code>,
<code><a href="#topic+plot_fitness_evolution">plot_fitness_evolution</a>()</code>,
<code><a href="#topic+plot_parkfitness">plot_parkfitness</a>()</code>,
<code><a href="#topic+plot_result">plot_result</a>()</code>,
<code><a href="#topic+plot_windfarmGA">plot_windfarmGA</a>()</code>,
<code><a href="#topic+plot_windrose">plot_windrose</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot_development(resultrect)

</code></pre>

<hr>
<h2 id='plot_evolution'>Plot the evolution of fitness values</h2><span id='topic+plot_evolution'></span>

<h3>Description</h3>

<p>Plot the evolution of energy outputs and efficiency rates over
the whole generations. Plots min, mean and max values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_evolution(result, ask = TRUE, spar = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_evolution_+3A_result">result</code></td>
<td>
<p>The output of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="plot_evolution_+3A_ask">ask</code></td>
<td>
<p>Should R wait for interaction for subsequent plotting. Default is
TRUE</p>
</td></tr>
<tr><td><code id="plot_evolution_+3A_spar">spar</code></td>
<td>
<p>A numeric value determining how exact a spline should be drawn.
Default is 0.1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Used for plotting
</p>


<h3>See Also</h3>

<p>Other Plotting Functions: 
<code><a href="#topic+plot_cloud">plot_cloud</a>()</code>,
<code><a href="#topic+plot_development">plot_development</a>()</code>,
<code><a href="#topic+plot_fitness_evolution">plot_fitness_evolution</a>()</code>,
<code><a href="#topic+plot_parkfitness">plot_parkfitness</a>()</code>,
<code><a href="#topic+plot_result">plot_result</a>()</code>,
<code><a href="#topic+plot_windfarmGA">plot_windfarmGA</a>()</code>,
<code><a href="#topic+plot_windrose">plot_windrose</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plot the results of a rectangular grid optimization
plot_evolution(resultrect, ask = TRUE, spar = 0.1)

</code></pre>

<hr>
<h2 id='plot_fitness_evolution'>Plot the changes of min/mean/max fitness values</h2><span id='topic+plot_fitness_evolution'></span>

<h3>Description</h3>

<p>Plot the evolution of fitness values and the change in the min,
mean and max fitness values to the former generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fitness_evolution(result, spar = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_fitness_evolution_+3A_result">result</code></td>
<td>
<p>The output of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="plot_fitness_evolution_+3A_spar">spar</code></td>
<td>
<p>A numeric value determining how exact a spline should be drawn.
Default is 0.1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Used for plotting
</p>


<h3>See Also</h3>

<p>Other Plotting Functions: 
<code><a href="#topic+plot_cloud">plot_cloud</a>()</code>,
<code><a href="#topic+plot_development">plot_development</a>()</code>,
<code><a href="#topic+plot_evolution">plot_evolution</a>()</code>,
<code><a href="#topic+plot_parkfitness">plot_parkfitness</a>()</code>,
<code><a href="#topic+plot_result">plot_result</a>()</code>,
<code><a href="#topic+plot_windfarmGA">plot_windfarmGA</a>()</code>,
<code><a href="#topic+plot_windrose">plot_windrose</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plot the results of a hexagonal grid optimization
plot_fitness_evolution(resulthex, 0.1)

</code></pre>

<hr>
<h2 id='plot_leaflet'>Plot a wind warm with leaflet</h2><span id='topic+plot_leaflet'></span>

<h3>Description</h3>

<p>Plot a resulting wind farm on a leaflet map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_leaflet(result, Polygon1, which = 1, orderitems = TRUE, GridPol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_leaflet_+3A_result">result</code></td>
<td>
<p>The output of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="plot_leaflet_+3A_polygon1">Polygon1</code></td>
<td>
<p>The considered area as SpatialPolygon, SimpleFeature Polygon
or coordinates as matrix/data.frame</p>
</td></tr>
<tr><td><code id="plot_leaflet_+3A_which">which</code></td>
<td>
<p>A numeric value, indicating which individual to plot. The
default is 1. Combined with <code>orderitems = TRUE</code> this will show the
best performing wind farm.</p>
</td></tr>
<tr><td><code id="plot_leaflet_+3A_orderitems">orderitems</code></td>
<td>
<p>A logical value indicating whether the results should be
ordered by energy values <code>TRUE</code> or chronologically <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot_leaflet_+3A_gridpol">GridPol</code></td>
<td>
<p>By default, the grid will be calculated based on the inputs
of <code>result</code> and the <code>Polygon1</code>. But another spatial object or the
output of the  <code><a href="#topic+grid_area">grid_area</a></code> or <code><a href="#topic+hexa_area">hexa_area</a></code> functions
can also be</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a leaflet map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Plot the best wind farm on a leaflet map (ordered by energy values)
plot_leaflet(result = resulthex, Polygon1 = sp_polygon, which = 1)

## Plot the last wind farm (ordered by chronology).
plot_leaflet(
  result = resulthex, Polygon1 = sp_polygon, orderitems = FALSE,
  which = 1
)

## Plot the best wind farm on a leaflet map with the rectangular Grid
Grid &lt;- grid_area(sp_polygon, size = 150, prop = 0.4)
plot_leaflet(
  result = resultrect, Polygon1 = sp_polygon, which = 1,
  GridPol = Grid[[2]]
)

## Plot the last wind farm with hexagonal Grid
Grid &lt;- hexa_area(sp_polygon, size = 75)
plot_leaflet(
  result = resulthex, Polygon1 = sp_polygon, which = 1,
  GridPol = Grid[[2]]
)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_parkfitness'>Plot the genetic algorithm results</h2><span id='topic+plot_parkfitness'></span>

<h3>Description</h3>

<p>Plot the evolution of fitness values with the influences of
selection, crossover and mutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_parkfitness(result, spar = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_parkfitness_+3A_result">result</code></td>
<td>
<p>The output of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="plot_parkfitness_+3A_spar">spar</code></td>
<td>
<p>A numeric value determining how exact a spline should be drawn.
Default is 0.1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Used for plotting
</p>


<h3>See Also</h3>

<p>Other Plotting Functions: 
<code><a href="#topic+plot_cloud">plot_cloud</a>()</code>,
<code><a href="#topic+plot_development">plot_development</a>()</code>,
<code><a href="#topic+plot_evolution">plot_evolution</a>()</code>,
<code><a href="#topic+plot_fitness_evolution">plot_fitness_evolution</a>()</code>,
<code><a href="#topic+plot_result">plot_result</a>()</code>,
<code><a href="#topic+plot_windfarmGA">plot_windfarmGA</a>()</code>,
<code><a href="#topic+plot_windrose">plot_windrose</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Plot the results of a hexagonal grid optimization
plot_parkfitness(resulthex)

</code></pre>

<hr>
<h2 id='plot_random_search'>Plot the result of a randomized output.</h2><span id='topic+plot_random_search'></span>

<h3>Description</h3>

<p>Plotting method for the results of
<code><a href="#topic+random_search_single">random_search_single</a></code> and <code><a href="#topic+random_search">random_search</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_random_search(resultRS, result, Polygon1, best)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_random_search_+3A_resultrs">resultRS</code></td>
<td>
<p>The result of the random functions
<code><a href="#topic+random_search_single">random_search_single</a></code> and <code><a href="#topic+random_search">random_search</a></code>.</p>
</td></tr>
<tr><td><code id="plot_random_search_+3A_result">result</code></td>
<td>
<p>The output of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="plot_random_search_+3A_polygon1">Polygon1</code></td>
<td>
<p>The considered area as SpatialPolygon, SimpleFeature Polygon
or coordinates as matrix/data.frame</p>
</td></tr>
<tr><td><code id="plot_random_search_+3A_best">best</code></td>
<td>
<p>How many best candidates to plot. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Used for plotting
</p>


<h3>See Also</h3>

<p>Other Randomization: 
<code><a href="#topic+random_search">random_search</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))

Res &lt;- random_search(result = resultrect, Polygon1 = Polygon1)
plot_random_search(resultRS = Res, result = resultrect, Polygon1 = Polygon1, best = 2)

</code></pre>

<hr>
<h2 id='plot_result'>Plot the best results</h2><span id='topic+plot_result'></span>

<h3>Description</h3>

<p>Plot the best solutions of the genetic algorithm.
Depending on <code>plotEn</code>, either the best energy or efficiency solutions
can be plotted. <code>best</code> indicates the amount of best solutions to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_result(
  result,
  Polygon1,
  best = 3,
  plotEn = 1,
  topographie = FALSE,
  Grid = TRUE,
  sourceCCLRoughness = NULL,
  sourceCCL = NULL,
  weibullsrc
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_result_+3A_result">result</code></td>
<td>
<p>The output of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="plot_result_+3A_polygon1">Polygon1</code></td>
<td>
<p>The considered area as SpatialPolygon, SimpleFeature Polygon
or coordinates as matrix/data.frame</p>
</td></tr>
<tr><td><code id="plot_result_+3A_best">best</code></td>
<td>
<p>A numeric value indicating how many of the best individuals
should be plotted</p>
</td></tr>
<tr><td><code id="plot_result_+3A_ploten">plotEn</code></td>
<td>
<p>A numeric value that indicates if the best energy or efficiency
output should be plotted. <code>1</code> plots the best energy solutions
and <code>2</code> plots the best efficiency solutions</p>
</td></tr>
<tr><td><code id="plot_result_+3A_topographie">topographie</code></td>
<td>
<p>A logical value, indicating whether terrain effects should
be considered and plotted or not</p>
</td></tr>
<tr><td><code id="plot_result_+3A_grid">Grid</code></td>
<td>
<p>If <code>TRUE</code> (default) the used grid will be added to the plot.
You can also pass another Simple Feature object</p>
</td></tr>
<tr><td><code id="plot_result_+3A_sourcecclroughness">sourceCCLRoughness</code></td>
<td>
<p>The source to the adapted Corine Land Cover legend
as .csv file. Only required when terrain effect model is activated. As
default a .csv file within this package (&lsquo;<span class="file">~/extdata</span>&rsquo;) is taken that
was already adapted manually.</p>
</td></tr>
<tr><td><code id="plot_result_+3A_sourceccl">sourceCCL</code></td>
<td>
<p>The path to the Corine Land Cover raster (.tif). Only
required when the terrain effect model is activated.</p>
</td></tr>
<tr><td><code id="plot_result_+3A_weibullsrc">weibullsrc</code></td>
<td>
<p>A list of Weibull parameter rasters, where the first list
item must be the shape parameter raster <code>k</code> and the second item must be the
scale parameter raster <code>a</code> of the Weibull distribution. If no list is
given, then rasters included in the package are used instead, which
currently only cover Austria. This variable is only used
if <code>weibull = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame of the best (energy/efficiency) individual
during all iterations
</p>


<h3>See Also</h3>

<p>Other Plotting Functions: 
<code><a href="#topic+plot_cloud">plot_cloud</a>()</code>,
<code><a href="#topic+plot_development">plot_development</a>()</code>,
<code><a href="#topic+plot_evolution">plot_evolution</a>()</code>,
<code><a href="#topic+plot_fitness_evolution">plot_fitness_evolution</a>()</code>,
<code><a href="#topic+plot_parkfitness">plot_parkfitness</a>()</code>,
<code><a href="#topic+plot_windfarmGA">plot_windfarmGA</a>()</code>,
<code><a href="#topic+plot_windrose">plot_windrose</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Add some data examples from the package
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))

## Plot the results of a hexagonal grid optimization
plot_result(resulthex, Polygon1, best = 1, plotEn = 1, topographie = FALSE)

## Plot the results of a rectangular grid optimization
plot_result(resultrect, Polygon1, best = 1, plotEn = 1, topographie = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_viewshed'>Plot visibility</h2><span id='topic+plot_viewshed'></span>

<h3>Description</h3>

<p>Calculate and plot visibility for given points in a given area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_viewshed(r, turbine_locs, h1 = 0, h2 = 0, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_viewshed_+3A_r">r</code></td>
<td>
<p>The elevation SpatRaster</p>
</td></tr>
<tr><td><code id="plot_viewshed_+3A_turbine_locs">turbine_locs</code></td>
<td>
<p>Coordinates, SpatialPoint or SimpleFeature Points
representing the wind turbines</p>
</td></tr>
<tr><td><code id="plot_viewshed_+3A_h1">h1</code></td>
<td>
<p>A single number or numeric vector giving the extra height offsets
for the <code>turbine_locs</code></p>
</td></tr>
<tr><td><code id="plot_viewshed_+3A_h2">h2</code></td>
<td>
<p>The height offset for Point 2</p>
</td></tr>
<tr><td><code id="plot_viewshed_+3A_plot">plot</code></td>
<td>
<p>Should the result be plotted. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot_viewshed_+3A_...">...</code></td>
<td>
<p>forwarded to <code>terra::plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mosaiced SpatRaster, representing the visibility for all <code>turbine_locs</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sf)
library(terra)

f &lt;- system.file("ex/elev.tif", package = "terra")
r &lt;- rast(f)
x &lt;- project(r, "EPSG:2169")
shape &lt;- sf::st_as_sf(as.polygons(terra::boundaries(x)))
plot(shape)
st_crs(shape) &lt;- 2169
locs &lt;- st_sample(shape, 10, type = "random")
plot_viewshed(x, locs, h1 = 0, h2 = 0, plot = TRUE)

</code></pre>

<hr>
<h2 id='plot_windfarmGA'>Plot the results of an optimization run</h2><span id='topic+plot_windfarmGA'></span>

<h3>Description</h3>

<p>Plot the results of a genetic algorithm run with given inputs.
Several plots try to show all relevant effects and outcomes of the
algorithm. 6 plot methods are available that can be selected individually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_windfarmGA(
  result,
  Polygon1,
  whichPl = "all",
  best = 1,
  plotEn = 1,
  weibullsrc
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_windfarmGA_+3A_result">result</code></td>
<td>
<p>The output of <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="plot_windfarmGA_+3A_polygon1">Polygon1</code></td>
<td>
<p>The considered area as SpatialPolygon, SimpleFeature Polygon
or coordinates as matrix/data.frame</p>
</td></tr>
<tr><td><code id="plot_windfarmGA_+3A_whichpl">whichPl</code></td>
<td>
<p>Which plots should be shown: 1-6 are possible. The default is
&quot;all&quot; which shows all available plots</p>
</td></tr>
<tr><td><code id="plot_windfarmGA_+3A_best">best</code></td>
<td>
<p>A numeric value indicating how many of the best individuals
should be plotted</p>
</td></tr>
<tr><td><code id="plot_windfarmGA_+3A_ploten">plotEn</code></td>
<td>
<p>A numeric value that indicates if the best energy or efficiency
output should be plotted. <code>1</code> plots the best energy solutions
and <code>2</code> plots the best efficiency solutions</p>
</td></tr>
<tr><td><code id="plot_windfarmGA_+3A_weibullsrc">weibullsrc</code></td>
<td>
<p>A list of Weibull parameter rasters, where the first list
item must be the shape parameter raster <code>k</code> and the second item must be the
scale parameter raster <code>a</code> of the Weibull distribution. If no list is
given, then rasters included in the package are used instead, which
currently only cover Austria. This variable is only used
if <code>weibull = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Used for plotting
</p>


<h3>See Also</h3>

<p>Other Plotting Functions: 
<code><a href="#topic+plot_cloud">plot_cloud</a>()</code>,
<code><a href="#topic+plot_development">plot_development</a>()</code>,
<code><a href="#topic+plot_evolution">plot_evolution</a>()</code>,
<code><a href="#topic+plot_fitness_evolution">plot_fitness_evolution</a>()</code>,
<code><a href="#topic+plot_parkfitness">plot_parkfitness</a>()</code>,
<code><a href="#topic+plot_result">plot_result</a>()</code>,
<code><a href="#topic+plot_windrose">plot_windrose</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))

## Plot the results of a hexagonal grid optimization
plot_windfarmGA(resulthex, Polygon1, whichPl = "all", best = 1, plotEn = 1)

## Plot the results of a rectangular grid optimization
plot_windfarmGA(resultrect, Polygon1, whichPl = "all", best = 1, plotEn = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_windrose'>Plot a Windrose</h2><span id='topic+plot_windrose'></span>

<h3>Description</h3>

<p>Plot a wind rose of the wind data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_windrose(
  data,
  spd,
  dir,
  spdres = 2,
  dirres = 10,
  spdmin = 1,
  spdmax = 30,
  palette = "YlGnBu",
  spdseq = NULL,
  plotit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_windrose_+3A_data">data</code></td>
<td>
<p>A data.frame containing the wind information</p>
</td></tr>
<tr><td><code id="plot_windrose_+3A_spd">spd</code></td>
<td>
<p>The column of the wind speeds in &quot;data&quot;</p>
</td></tr>
<tr><td><code id="plot_windrose_+3A_dir">dir</code></td>
<td>
<p>The column of the wind directions in &quot;data&quot;</p>
</td></tr>
<tr><td><code id="plot_windrose_+3A_spdres">spdres</code></td>
<td>
<p>The increment of the wind speed legend. Default is 2</p>
</td></tr>
<tr><td><code id="plot_windrose_+3A_dirres">dirres</code></td>
<td>
<p>The size of the wind sectors. Default is 10</p>
</td></tr>
<tr><td><code id="plot_windrose_+3A_spdmin">spdmin</code></td>
<td>
<p>Minimum wind speed. Default is 1</p>
</td></tr>
<tr><td><code id="plot_windrose_+3A_spdmax">spdmax</code></td>
<td>
<p>Maximal wind speed. Default is 30</p>
</td></tr>
<tr><td><code id="plot_windrose_+3A_palette">palette</code></td>
<td>
<p>A color palette used for drawing the wind rose</p>
</td></tr>
<tr><td><code id="plot_windrose_+3A_spdseq">spdseq</code></td>
<td>
<p>A wind speed sequence, that is used for plotting</p>
</td></tr>
<tr><td><code id="plot_windrose_+3A_plotit">plotit</code></td>
<td>
<p>Should the windrose be plotted? Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Used for plotting
</p>


<h3>See Also</h3>

<p>Other Plotting Functions: 
<code><a href="#topic+plot_cloud">plot_cloud</a>()</code>,
<code><a href="#topic+plot_development">plot_development</a>()</code>,
<code><a href="#topic+plot_evolution">plot_evolution</a>()</code>,
<code><a href="#topic+plot_fitness_evolution">plot_fitness_evolution</a>()</code>,
<code><a href="#topic+plot_parkfitness">plot_parkfitness</a>()</code>,
<code><a href="#topic+plot_result">plot_result</a>()</code>,
<code><a href="#topic+plot_windfarmGA">plot_windfarmGA</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Exemplary Input Wind speed and direction data frame
# Uniform wind speed and single wind direction
data.in &lt;- data.frame(ws = 12, wd = 0)
windrosePlot &lt;- plot_windrose(
  data = data.in, spd = data.in$ws,
  dir = data.in$wd
)

# Random wind speeds and random wind directions
data.in &lt;- data.frame(
  ws = sample(1:25, 10),
  wd = sample(1:260, 10)
)
windrosePlot &lt;- plot_windrose(
  data = data.in, spd = data.in$ws,
  dir = data.in$wd
)

</code></pre>

<hr>
<h2 id='random_search'>Randomize the output of the Genetic Algorithm</h2><span id='topic+random_search'></span>

<h3>Description</h3>

<p>Perform a random search in the grid cells, to further optimize
the output of the wind farm layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_search(result, Polygon1, n = 20, best = 1, Plot = FALSE, max_dist = 2.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_search_+3A_result">result</code></td>
<td>
<p>The resulting matrix of the function <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="random_search_+3A_polygon1">Polygon1</code></td>
<td>
<p>The considered area as SpatialPolygon, SimpleFeature Polygon
or coordinates as matrix/data.frame</p>
</td></tr>
<tr><td><code id="random_search_+3A_n">n</code></td>
<td>
<p>The number of random searches to be performed. Default is 20.</p>
</td></tr>
<tr><td><code id="random_search_+3A_best">best</code></td>
<td>
<p>Which best individuals should be the starting conditions for a
random search. The default is 1.</p>
</td></tr>
<tr><td><code id="random_search_+3A_plot">Plot</code></td>
<td>
<p>Should the random search be plotted? Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="random_search_+3A_max_dist">max_dist</code></td>
<td>
<p>A numeric value multiplied by the rotor radius to perform
collision checks. Default is <code>2.2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list.
</p>


<h3>See Also</h3>

<p>Other Randomization: 
<code><a href="#topic+plot_random_search">plot_random_search</a>()</code>,
<code><a href="#topic+random_search_single">random_search_single</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
new &lt;- random_search(resultrect, sp_polygon, n = 20, best = 4)
plot_random_search(resultRS = new, result = resultrect, Polygon1 = sp_polygon, best = 2)

</code></pre>

<hr>
<h2 id='random_search_single'>Randomize the location of a single turbine</h2><span id='topic+random_search_single'></span>

<h3>Description</h3>

<p>Perform a random search for a single turbine, to further
optimize the output of the wind farm layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_search_single(result, Polygon1, n = 20, Plot = FALSE, max_dist = 2.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_search_single_+3A_result">result</code></td>
<td>
<p>The resulting matrix of the function <code><a href="#topic+genetic_algorithm">genetic_algorithm</a></code></p>
</td></tr>
<tr><td><code id="random_search_single_+3A_polygon1">Polygon1</code></td>
<td>
<p>The considered area as SpatialPolygon, SimpleFeature Polygon
or coordinates as matrix/data.frame</p>
</td></tr>
<tr><td><code id="random_search_single_+3A_n">n</code></td>
<td>
<p>The number of random searches to be performed. Default is 20.</p>
</td></tr>
<tr><td><code id="random_search_single_+3A_plot">Plot</code></td>
<td>
<p>Should the random search be plotted? Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="random_search_single_+3A_max_dist">max_dist</code></td>
<td>
<p>A numeric value multiplied by the rotor radius to perform
collision checks. Default is 2.2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list
</p>


<h3>See Also</h3>

<p>Other Randomization: 
<code><a href="#topic+plot_random_search">plot_random_search</a>()</code>,
<code><a href="#topic+random_search">random_search</a>()</code>
</p>
<p>Other Plotting Functions: 
<code><a href="#topic+plot_cloud">plot_cloud</a>()</code>,
<code><a href="#topic+plot_development">plot_development</a>()</code>,
<code><a href="#topic+plot_evolution">plot_evolution</a>()</code>,
<code><a href="#topic+plot_fitness_evolution">plot_fitness_evolution</a>()</code>,
<code><a href="#topic+plot_parkfitness">plot_parkfitness</a>()</code>,
<code><a href="#topic+plot_result">plot_result</a>()</code>,
<code><a href="#topic+plot_windfarmGA">plot_windfarmGA</a>()</code>,
<code><a href="#topic+plot_windrose">plot_windrose</a>()</code>
</p>

<hr>
<h2 id='readinteger'>Check Input Crossover Method</h2><span id='topic+readinteger'></span>

<h3>Description</h3>

<p>Checks whether the input for <code><a href="#topic+crossover">crossover</a></code> is given
correctly. If not, a message is prompted which asks to input one of the 2
available crossover methods. The available inputs are &quot;E&quot; and &quot;R&quot;. &quot;E&quot;
refers to partitioning at equal intervals and &quot;R&quot; refers to random
partitioning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readinteger()
</code></pre>


<h3>Value</h3>

<p>Returns the selected crossover method (character)
</p>


<h3>See Also</h3>

<p>Other Helper Functions: 
<code><a href="#topic+get_grids">get_grids</a>()</code>,
<code><a href="#topic+grid_area">grid_area</a>()</code>,
<code><a href="#topic+hexa_area">hexa_area</a>()</code>,
<code><a href="#topic+isSpatial">isSpatial</a>()</code>,
<code><a href="#topic+permutations">permutations</a>()</code>,
<code><a href="#topic+readintegerSel">readintegerSel</a>()</code>,
<code><a href="#topic+splitAt">splitAt</a>()</code>,
<code><a href="#topic+windata_format">windata_format</a>()</code>
</p>

<hr>
<h2 id='readintegerSel'>Check Input Selection Method</h2><span id='topic+readintegerSel'></span>

<h3>Description</h3>

<p>Checks whether the input for <code><a href="#topic+selection">selection</a></code> is given
correctly. If not, a message is prompted which asks to input one of the 2
available selection methods. The available inputs are &quot;F&quot; and &quot;V&quot;. &quot;F&quot;
refers to a fixed percentage of 50% and &quot;V&quot; refers to a variable
percentage, based on the development of the population fitness values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readintegerSel()
</code></pre>


<h3>Value</h3>

<p>Returns the selected selection method (character)
</p>


<h3>See Also</h3>

<p>Other Helper Functions: 
<code><a href="#topic+get_grids">get_grids</a>()</code>,
<code><a href="#topic+grid_area">grid_area</a>()</code>,
<code><a href="#topic+hexa_area">hexa_area</a>()</code>,
<code><a href="#topic+isSpatial">isSpatial</a>()</code>,
<code><a href="#topic+permutations">permutations</a>()</code>,
<code><a href="#topic+readinteger">readinteger</a>()</code>,
<code><a href="#topic+splitAt">splitAt</a>()</code>,
<code><a href="#topic+windata_format">windata_format</a>()</code>
</p>

<hr>
<h2 id='resulthex'>A resulting matrix of <code>genetic_algorithm</code> with 10 iterations
and a hexagonal grid derived from <code>sp_polygon</code></h2><span id='topic+resulthex'></span>

<h3>Description</h3>

<p>A resulting matrix of <code>genetic_algorithm</code> with 10 iterations
and a hexagonal grid derived from <code>sp_polygon</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resulthex
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 10 rows and 13 columns.
</p>

<hr>
<h2 id='resultrect'>A resulting matrix of <code>genetic_algorithm</code> with 200 iterations
and a rectangular grid derived from <code>sp_polygon</code></h2><span id='topic+resultrect'></span>

<h3>Description</h3>

<p>A resulting matrix of <code>genetic_algorithm</code> with 200 iterations
and a rectangular grid derived from <code>sp_polygon</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resultrect
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 200 rows and 13 columns.
</p>

<hr>
<h2 id='selection'>Selection Method</h2><span id='topic+selection'></span>

<h3>Description</h3>

<p>Select a certain amount of individuals and recombine them to
parental teams. Add the mean fitness value of both parents to the parental
team. Depending on the selected <code>selstate</code>, the algorithm will either
take always 50 percent or a variable percentage of the current population.
The variable percentage depends on the evolution of the populations fitness
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection(fit, Grid, teil, elitism, nelit, selstate, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selection_+3A_fit">fit</code></td>
<td>
<p>A list of all fitness-evaluated individuals</p>
</td></tr>
<tr><td><code id="selection_+3A_grid">Grid</code></td>
<td>
<p>Is the indexed grid output from <code><a href="#topic+grid_area">grid_area</a></code></p>
</td></tr>
<tr><td><code id="selection_+3A_teil">teil</code></td>
<td>
<p>A numeric value that determines the selection percentage</p>
</td></tr>
<tr><td><code id="selection_+3A_elitism">elitism</code></td>
<td>
<p>Boolean value, which indicates whether elitism should be
activated or not. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="selection_+3A_nelit">nelit</code></td>
<td>
<p>If <code>elitism</code> is TRUE, this input determines the amount
of individuals in the elite group. Default is 7</p>
</td></tr>
<tr><td><code id="selection_+3A_selstate">selstate</code></td>
<td>
<p>Determines which selection method is used, &quot;FIX&quot; selects a
constant percentage and &quot;VAR&quot; selects a variable percentage, depending on
the development of the fitness values. Default is &quot;FIX&quot;</p>
</td></tr>
<tr><td><code id="selection_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, will print out further information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list with 2 elements. Element 1 is the binary encoded matrix
which shows all selected individuals. Element 2 represent the mean fitness
values of each parental team.
</p>


<h3>See Also</h3>

<p>Other Genetic Algorithm Functions: 
<code><a href="#topic+crossover">crossover</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+genetic_algorithm">genetic_algorithm</a>()</code>,
<code><a href="#topic+init_population">init_population</a>()</code>,
<code><a href="#topic+mutation">mutation</a>()</code>,
<code><a href="#topic+trimton">trimton</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Exemplary input Polygon with 2km x 2km:
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4498482, 4498482, 4499991, 4499991, 4498482),
    c(2668272, 2669343, 2669343, 2668272, 2668272)
  ))),
  crs = 3035
))

## Calculate a Grid and an indexed data.frame with coordinates and grid cell Ids.
Grid1 &lt;- grid_area(shape = Polygon1, size = 200, prop = 1)
Grid &lt;- Grid1[[1]]
AmountGrids &lt;- nrow(Grid)

startsel &lt;- init_population(Grid, 10, 20)
wind &lt;- as.data.frame(cbind(ws = 12, wd = 0))
wind &lt;- list(wind, probab = 100)
fit &lt;- fitness(
  selection = startsel, referenceHeight = 100, RotorHeight = 100,
  SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200,
  rot = 20, dirspeed = wind,
  srtm_crop = "", topograp = FALSE, cclRaster = ""
)
allparks &lt;- do.call("rbind", fit)
## SELECTION
## print the amount of Individuals selected. Check if the amount
## of Turbines is as requested.
selec6best &lt;- selection(fit, Grid, 2, TRUE, 6, "VAR")
selec6best &lt;- selection(fit, Grid, 2, TRUE, 6, "FIX")
selec6best &lt;- selection(fit, Grid, 4, FALSE, 6, "FIX")

</code></pre>

<hr>
<h2 id='sp_polygon'>The rectangular POLYGON used to create <code>resultrect</code> &amp; <code>resulthex</code></h2><span id='topic+sp_polygon'></span>

<h3>Description</h3>

<p>The rectangular POLYGON used to create <code>resultrect</code> &amp; <code>resulthex</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_polygon
</code></pre>


<h3>Format</h3>

<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 1 rows and 1 columns.
</p>

<hr>
<h2 id='splitAt'>Split matrices or numeric vectors at specific indices</h2><span id='topic+splitAt'></span>

<h3>Description</h3>

<p>The function is used by the crossover method to
split a genetic code at certain intervals. See also <code><a href="#topic+crossover">crossover</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitAt(x, pos)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitAt_+3A_x">x</code></td>
<td>
<p>A numeric variable that represents an individual's
binary genetic code</p>
</td></tr>
<tr><td><code id="splitAt_+3A_pos">pos</code></td>
<td>
<p>A numeric value that indicates where to split the genetic code</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the split genetic code.
</p>


<h3>See Also</h3>

<p>Other Helper Functions: 
<code><a href="#topic+get_grids">get_grids</a>()</code>,
<code><a href="#topic+grid_area">grid_area</a>()</code>,
<code><a href="#topic+hexa_area">hexa_area</a>()</code>,
<code><a href="#topic+isSpatial">isSpatial</a>()</code>,
<code><a href="#topic+permutations">permutations</a>()</code>,
<code><a href="#topic+readinteger">readinteger</a>()</code>,
<code><a href="#topic+readintegerSel">readintegerSel</a>()</code>,
<code><a href="#topic+windata_format">windata_format</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splitAt(1:100, 20)
splitAt(as.matrix(1:100), 20)

</code></pre>

<hr>
<h2 id='terrain_model'>Get topographic rasters</h2><span id='topic+terrain_model'></span>

<h3>Description</h3>

<p>Calculate the SpatRasters needed for the terrain model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terrain_model(
  topograp = TRUE,
  Polygon1,
  sourceCCL,
  sourceCCLRoughness,
  plotit = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terrain_model_+3A_topograp">topograp</code></td>
<td>
<p>Boolean value, which indicates if the terrain effect model
should be enabled or not. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="terrain_model_+3A_polygon1">Polygon1</code></td>
<td>
<p>The considered area as SpatialPolygon, SimpleFeature Polygon
or coordinates as matrix/data.frame</p>
</td></tr>
<tr><td><code id="terrain_model_+3A_sourceccl">sourceCCL</code></td>
<td>
<p>The path to the Corine Land Cover raster (.tif). Only
required when the terrain effect model is activated.</p>
</td></tr>
<tr><td><code id="terrain_model_+3A_sourcecclroughness">sourceCCLRoughness</code></td>
<td>
<p>The source to the adapted Corine Land Cover legend
as .csv file. Only required when terrain effect model is activated. As
default a .csv file within this package (&lsquo;<span class="file">~/extdata</span>&rsquo;) is taken that
was already adapted manually.</p>
</td></tr>
<tr><td><code id="terrain_model_+3A_plotit">plotit</code></td>
<td>
<p>Plots the elevation data</p>
</td></tr>
<tr><td><code id="terrain_model_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE it will print information for every generation.
Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of SpatRasters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(4651704, 4651704, 4654475, 4654475, 4651704),
    c(2692925, 2694746, 2694746, 2692925, 2692925)
  ))),
  crs = 3035
))
Polygon_wgs84 &lt;- sf::st_transform(Polygon1, st_crs(4326))
srtm &lt;- elevatr::get_elev_raster(locations = Polygon_wgs84, z = 11)
res &lt;- terrain_model(srtm, Polygon1)

## End(Not run)
</code></pre>

<hr>
<h2 id='trimton'>Adjust the amount of turbines per windfarm</h2><span id='topic+trimton'></span>

<h3>Description</h3>

<p>Adjust the mutated individuals to the required amount of
turbines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimton(mut, nturb, allparks, nGrids, trimForce, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimton_+3A_mut">mut</code></td>
<td>
<p>A binary matrix with the mutated individuals</p>
</td></tr>
<tr><td><code id="trimton_+3A_nturb">nturb</code></td>
<td>
<p>A numeric value indicating the amount of required turbines</p>
</td></tr>
<tr><td><code id="trimton_+3A_allparks">allparks</code></td>
<td>
<p>A data.frame consisting of all individuals of the current
generation</p>
</td></tr>
<tr><td><code id="trimton_+3A_ngrids">nGrids</code></td>
<td>
<p>A numeric value indicating the total amount of grid cells</p>
</td></tr>
<tr><td><code id="trimton_+3A_trimforce">trimForce</code></td>
<td>
<p>If <code>TRUE</code> the algorithm will use a probabilistic
approach to correct the windfarms to the desired amount of turbines.
If <code>FALSE</code> the adjustment will be random. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="trimton_+3A_seed">seed</code></td>
<td>
<p>Set a seed for comparability. Default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a binary matrix with the correct amount of turbines per
individual
</p>


<h3>See Also</h3>

<p>Other Genetic Algorithm Functions: 
<code><a href="#topic+crossover">crossover</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+genetic_algorithm">genetic_algorithm</a>()</code>,
<code><a href="#topic+init_population">init_population</a>()</code>,
<code><a href="#topic+mutation">mutation</a>()</code>,
<code><a href="#topic+selection">selection</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a random rectangular shapefile
library(sf)
Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(0, 0, 2000, 2000, 0),
    c(0, 2000, 2000, 0, 0)
  ))),
  crs = 3035
))

## Create a uniform and unidirectional wind data.frame and plots the
## resulting wind rose
## Uniform wind speed and single wind direction
data.in &lt;- as.data.frame(cbind(ws = 12, wd = 0))

## Calculate a Grid and an indexed data.frame with coordinates and grid cell Ids.
Grid1 &lt;- grid_area(shape = Polygon1, size = 200, prop = 1)
Grid &lt;- Grid1[[1]]
AmountGrids &lt;- nrow(Grid)

startsel &lt;- init_population(Grid, 10, 20)
wind &lt;- as.data.frame(cbind(ws = 12, wd = 0))
wind &lt;- list(wind, probab = 100)
fit &lt;- fitness(
  selection = startsel, referenceHeight = 100, RotorHeight = 100,
  SurfaceRoughness = 0.3, Polygon = Polygon1, resol1 = 200, rot = 20,
  dirspeed = wind, srtm_crop = "", topograp = FALSE, cclRaster = ""
)
allparks &lt;- do.call("rbind", fit)
## SELECTION
## print the amount of Individuals selected.
## Check if the amount of Turbines is as requested.
selec6best &lt;- selection(fit, Grid, 2, TRUE, 6, "VAR")
selec6best &lt;- selection(fit, Grid, 2, TRUE, 6, "FIX")
selec6best &lt;- selection(fit, Grid, 4, FALSE, 6, "FIX")
## CROSSOVER
## u determines the amount of crossover points,
## crossPart determines the method used (Equal/Random),
## uplimit is the maximum allowed permutations
crossOut &lt;- crossover(selec6best, 2, uplimit = 300, crossPart = "RAN")
crossOut &lt;- crossover(selec6best, 7, uplimit = 500, crossPart = "RAN")
crossOut &lt;- crossover(selec6best, 3, uplimit = 300, crossPart = "EQU")
## MUTATION
## Variable Mutation Rate is activated if more than 2 individuals represent
## the current best solution.
mut &lt;- mutation(a = crossOut, p = 0.3, NULL)
## TRIMTON
## After Crossover and Mutation, the amount of turbines in a windpark change and have to be
## corrected to the required amount of turbines.
mut1 &lt;- trimton(
  mut = mut, nturb = 10, allparks = allparks, nGrids = AmountGrids,
  trimForce = FALSE
)
colSums(mut)
colSums(mut1)

</code></pre>

<hr>
<h2 id='turbine_influences'>Find potentially influencing turbines</h2><span id='topic+turbine_influences'></span>

<h3>Description</h3>

<p>Find all turbines that could potentially influence another
turbine and save them to a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turbine_influences(t, wnkl, dist, polYgon, dirct, plotAngles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turbine_influences_+3A_t">t</code></td>
<td>
<p>A data.frame of the current individual with X and Y coordinates</p>
</td></tr>
<tr><td><code id="turbine_influences_+3A_wnkl">wnkl</code></td>
<td>
<p>The angle from which wake influences are considered to be
negligible</p>
</td></tr>
<tr><td><code id="turbine_influences_+3A_dist">dist</code></td>
<td>
<p>A numeric value indicating the distance, after which the wake
effects are considered to be eliminated.</p>
</td></tr>
<tr><td><code id="turbine_influences_+3A_polygon">polYgon</code></td>
<td>
<p>A shapefile representing the considered area</p>
</td></tr>
<tr><td><code id="turbine_influences_+3A_dirct">dirct</code></td>
<td>
<p>A numeric value indicating the current wind direction</p>
</td></tr>
<tr><td><code id="turbine_influences_+3A_plotangles">plotAngles</code></td>
<td>
<p>A logical variable, which is used to plot the distances and
angles. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of all individuals of the current generation which
could potentially influence other turbines. List includes the relevant
coordinates, the distances and angles in between and assigns the Point ID.
</p>


<h3>See Also</h3>

<p>Other Wind Energy Calculation Functions: 
<code><a href="#topic+barometric_height">barometric_height</a>()</code>,
<code><a href="#topic+calculate_energy">calculate_energy</a>()</code>,
<code><a href="#topic+circle_intersection">circle_intersection</a>()</code>,
<code><a href="#topic+get_dist_angles">get_dist_angles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Exemplary input Polygon with 2km x 2km:
library(sf)

Polygon1 &lt;- sf::st_as_sf(sf::st_sfc(
  sf::st_polygon(list(cbind(
    c(0, 0, 2000, 2000, 0),
    c(0, 2000, 2000, 0, 0)
  ))),
  crs = 3035
))

t &lt;- st_coordinates(st_sample(Polygon1, 10))
t &lt;- cbind(t, "Z" = 1)
wnkl &lt;- 20
dist &lt;- 100000
dirct &lt;- 0

res &lt;- turbine_influences(t, wnkl, dist, Polygon1, dirct, plotAngles = TRUE)

</code></pre>

<hr>
<h2 id='windata_format'>Transform Winddata</h2><span id='topic+windata_format'></span>

<h3>Description</h3>

<p>Helper Function, which transforms winddata to an acceptable
format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>windata_format(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="windata_format_+3A_df">df</code></td>
<td>
<p>The wind data with speeds, direction and optionally a probability
column. If not assigned, it will be calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of windspeed and probabilities
</p>


<h3>See Also</h3>

<p>Other Helper Functions: 
<code><a href="#topic+get_grids">get_grids</a>()</code>,
<code><a href="#topic+grid_area">grid_area</a>()</code>,
<code><a href="#topic+hexa_area">hexa_area</a>()</code>,
<code><a href="#topic+isSpatial">isSpatial</a>()</code>,
<code><a href="#topic+permutations">permutations</a>()</code>,
<code><a href="#topic+readinteger">readinteger</a>()</code>,
<code><a href="#topic+readintegerSel">readintegerSel</a>()</code>,
<code><a href="#topic+splitAt">splitAt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
wind_df &lt;- data.frame(
  ws = c(12, 30, 45),
  wd = c(0, 90, 150),
  probab = 30:32
)
windata_format(wind_df)

wind_df &lt;- data.frame(
  speed = c(12, 30, 45),
  direction = c(90, 90, 150),
  probab = c(10, 20, 60)
)
windata_format(wind_df)

wind_df &lt;- data.frame(
  speed = c(12, 30, 45),
  direction = c(400, 90, 150)
)
windata_format(wind_df)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
