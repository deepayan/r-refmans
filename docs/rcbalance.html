<!DOCTYPE html><html><head><title>Help for package rcbalance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rcbalance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rcbalance-package'>
<p>Large, Sparse Optimal Matching with Refined Covariate Balance</p></a></li>
<li><a href='#build.dist.struct'>
<p>Build Distance Structure for Matching with Refined Balance</p></a></li>
<li><a href='#callrelax'>
<p>Solve Network Flow Problem using External Solver</p></a></li>
<li><a href='#count.pairings'>
<p>Count treatment-control pairings.</p></a></li>
<li><a href='#dist2net'>
<p>Building and Manipulating Network Flow Problems</p></a></li>
<li><a href='#rcbalance'>
<p>Optimal Matching with Refined Covariate Balance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Large, Sparse Optimal Matching with Refined Covariate Balance</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-3-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel D. Pimentel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Samuel D. Pimentel &lt;spi@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for large, sparse optimal matching of treated units
	and control units in observational studies.  Provisions are
	made for refined covariate balance constraints, which include
	fine and near-fine balance as special cases.  Matches are 
	optimal in the sense that they are computed as solutions to
	network optimization problems rather than greedy algorithms.
	See Pimentel, et al.(2015) &lt;<a href="https://doi.org/10.1080%2F01621459.2014.997879">doi:10.1080/01621459.2014.997879</a>&gt; 
	and Pimentel (2016), Obs. Studies 2(1):4-23. The rrelaxiv 
	package, which provides an alternative solver for
	the underlying network flow problems, carries an
	academic license and is not available on CRAN, but
	may be downloaded from Github at 
	<a href="https://github.com/josherrickson/rrelaxiv/">https://github.com/josherrickson/rrelaxiv/</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), MASS, plyr</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlemon</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>optmatch, testthat, rrelaxiv</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://errickson.net/rrelaxiv/">https://errickson.net/rrelaxiv/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-25 16:55:21 UTC; sdbpimentel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-25 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rcbalance-package'>
Large, Sparse Optimal Matching with Refined Covariate Balance
</h2><span id='topic+rcbalance-package'></span>

<h3>Description</h3>

<p>Tools for large, sparse optimal matching of treated units
	and control units in observational studies.  Provisions are
	made for refined covariate balance constraints, which include
	fine and near-fine balance as special cases.  Matches are 
	optimal in the sense that they are computed as solutions to
	network optimization problems rather than greedy algorithms.
	See Pimentel, et al.(2015) &lt;doi:10.1080/01621459.2014.997879&gt; 
	and Pimentel (2016), Obs. Studies 2(1):4-23. The rrelaxiv 
	package, which provides an alternative solver for
	the underlying network flow problems, carries an
	academic license and is not available on CRAN, but
	may be downloaded from Github at 
	&lt;https://github.com/josherrickson/rrelaxiv/&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> rcbalance</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Large, Sparse Optimal Matching with Refined Covariate Balance</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.8.8</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-3-25</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Samuel D. Pimentel</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Samuel D. Pimentel &lt;spi@berkeley.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Tools for large, sparse optimal matching of treated units
	and control units in observational studies.  Provisions are
	made for refined covariate balance constraints, which include
	fine and near-fine balance as special cases.  Matches are 
	optimal in the sense that they are computed as solutions to
	network optimization problems rather than greedy algorithms.
	See Pimentel, et al.(2015) &lt;doi:10.1080/01621459.2014.997879&gt; 
	and Pimentel (2016), Obs. Studies 2(1):4-23. The rrelaxiv 
	package, which provides an alternative solver for
	the underlying network flow problems, carries an
	academic license and is not available on CRAN, but
	may be downloaded from Github at 
	&lt;https://github.com/josherrickson/rrelaxiv/&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.2.0), MASS, plyr</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> rlemon</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> MIT + file LICENSE</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> optmatch, testthat, rrelaxiv</td>
</tr>
<tr>
 <td style="text-align: left;">
Additional_repositories: </td><td style="text-align: left;"> https://errickson.net/rrelaxiv/</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
build.dist.struct       Build Distance Structure for Matching with
                        Refined Balance
callrelax               Solve Network Flow Problem using External
                        Solver
count.pairings          Count treatment-control pairings.
dist2net                Building and Manipulating Network Flow Problems
rcbalance               Optimal Matching with Refined Covariate Balance
rcbalance-package       Large, Sparse Optimal Matching with Refined
                        Covariate Balance
</pre>
<p>This package computes sparse matches that are optimal under a set of refined covariate balance constraints.  These constraints, provided by the user, are a set of nested categorical variables of decreasing imporance which must be marginally balanced as closely as possible in the resulting treated and matched control populations.   For more detail see the references.
</p>
<p>The main function is <code>rcbalance</code>, which takes a distance/sparsity object containing information about matchability of the treated and control units and a list of fine balance variables and produces a match.  The <code>build.dist.struct</code> function can be used to construct the distance/sparsity object from covariate information.  The <code>count.pairings</code> function can be used to assess the sparsity of a proposed match.  The other functions are largely for internal use and should not be needed by the large majority of users.
</p>
<p>By default the package uses the R package <code>rlemon</code> to solve the minimum-cost network flow optimization problems by which matches are computed. Alternatively, users may specify that the <code>rrelaxiv</code> package
should be used instead. However, this package carries an academic license
and is not available on CRAN so users must install it themselves.
</p>


<h3>Author(s)</h3>

<p>Samuel D. Pimentel
</p>
<p>Maintainer: Samuel D. Pimentel &lt;spi@berkeley.edu&gt;
</p>


<h3>References</h3>

<p>Pimentel, S.D., Kelz, R.R., Silber, J.H., and Rosenbaum, P.R. (2015) Large, sparse optimal matching with refined covariate balance in an observational study of the health outcomes produced by new surgeons, JASA 110 (510), 515-527.
</p>
<p>Pimentel, S.D. (2016) Large, sparse optimal matching with R package rcbalance, Obs. Studies 2, 4-23.
</p>

<hr>
<h2 id='build.dist.struct'>
Build Distance Structure for Matching with Refined Balance
</h2><span id='topic+build.dist.struct'></span>

<h3>Description</h3>

<p>This function computes rank-based Mahalanobis distances between treated and control units and returns an object suitable for use in the distance.structure argument of rcbalance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.dist.struct(z, X, exact = NULL, calip.option = "propensity",
calip.cov = NULL, caliper = 0.2, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.dist.struct_+3A_z">z</code></td>
<td>

<p>a vector of treatment and control indicators, 1 for treatment and 0 for control.
</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_x">X</code></td>
<td>

<p>a data frame or a numeric or logical matrix containing covariate information for treated and control units.  Its row count must be equal to the length of <code>z</code>.  
</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_exact">exact</code></td>
<td>

<p>an optional vector of the same length as <code>z</code>.  If this argument is specified, treated units will only be allowed to match to control units that have equal values in the corresponding indices of the exact vector.  For example, to match patients within hospitals only, one could set exact equal to a vector of hospital IDs for each patient.
</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_calip.option">calip.option</code></td>
<td>
<p> one of <code>('propensity','user','none')</code>.
If 'propensity' is specified (the default option), the function estimates a propensity score via logistic regression of <code>z</code> on <code>X</code> and imposes a propensity score caliper.  If 'user' is specified, the user must provide a vector of values on which a caliper will be enforced using the <code>calip.cov</code> argument.  If 'none' is specified no caliper is used.
</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_calip.cov">calip.cov</code></td>
<td>

<p>see <code>calip.option</code>.
</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_caliper">caliper</code></td>
<td>

<p>gives the size of the caliper when the user specifies the <code>calip.option</code> argument as 'propensity' or 'calip.cov'.
</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_verbose">verbose</code></td>
<td>

<p>if <code>TRUE</code>, prints output describing specific adjustments made in creating the distance objects.  	
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>X</code> is a data frame and contains any character variables they are converted to factors with a warning.  If there are missing values in factor columns of <code>X</code>, they are treated as a new factor level.   If there are missing values in numeric or logical columns of <code>X</code>, an indicator of missingness for that column is added to <code>X</code> and the missing values are imputed with the column mean.  This follows the recommendations of Rosenbaum (<em>Design of Observational Studies</em> section 9.4, 2010).
</p>


<h3>Value</h3>

<p>A distance.structure object, the form of which is described in the documentation for the <code>distance.structure</code> argument of <code>rcbalance</code>.  Treated and control indices are numbered <code>1:nt</code> and <code>1:nc</code> respectively based on the order in which they appear in the <code>z</code> vector.
</p>


<h3>Author(s)</h3>

<p>Samuel D. Pimentel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcbalance">rcbalance</a></code>
</p>

<hr>
<h2 id='callrelax'>
Solve Network Flow Problem using External Solver
</h2><span id='topic+callrelax'></span>

<h3>Description</h3>

<p>Solves network flow optimization problems by calling an external solver, either the Lemon Optimization library or the RELAX-IV algorithm, as implemented in FORTRAN by Dimitri Bertsekas and Paul Tseng.  
</p>
<p>IMPORTANT NOTE 1: the RELAX-IV code is bound by an academic license; as a result the <code>rrelaxiv</code> package implementing it is not available on CRAN and must be downloaded separately. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callrelax(net, solver = 'rlemon')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callrelax_+3A_net">net</code></td>
<td>

<p>a network flow problem, formatted as a list with the following arguments (where the network contains nnode nodes, numbered 1 through nnode and narc arcs): 
</p>

<ul>
<li><p> startn: a vector of length narc containing the node numbers of the start nodes of each arc in the network.
</p>
</li>
<li><p> endn: a vector of length narc containing the node numbers of the end nodes of each arc in the network.
</p>
</li>
<li><p> ucap: a vector of length narc containing the (integer) upper capacity of each arc in the network.
</p>
</li>
<li><p> cost: a vector of length narc containing the (integer) cost of each arc in the network.
</p>
</li>
<li><p> b: a vector of length nnode containing the (integer) supply or demand of each node in the network.  Supplies are given as positive numbers and demands as negative numbers.
</p>
</li></ul>

</td></tr>
<tr><td><code id="callrelax_+3A_solver">solver</code></td>
<td>

<p>the name of the package used to solve the network flow optimization problem underlying the match, one of 'rlemon' (which uses the Lemon Optimization Library) and 'rrelaxiv' (which uses the RELAX-IV algorithm). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>crash</code></td>
<td>
<p>an integer equal to zero (included in order to support legacy versions of code).</p>
</td></tr>
<tr><td><code>feasible</code></td>
<td>
<p>an integer, equal to zero if the problem is infeasible and equal to 1 if it is feasible. A
network with a supply/demand vector of all zeroes may also be flagged as infeasible.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a vector equal in length to the number of arcs in argument problem net, giving in each coordinate the number of units of flow passing across the corresponding edge in the optimal network flow.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel D. Pimentel
</p>

<hr>
<h2 id='count.pairings'>
Count treatment-control pairings.
</h2><span id='topic+count.pairings'></span>

<h3>Description</h3>

<p>Given a treatment indicator and a potential blocking variable, counts the number of allowed treatment-control pairings in the whole match within blocks of the proposed variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.pairings(z, exact)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count.pairings_+3A_z">z</code></td>
<td>

<p>a vector of treatment indicators.  Must contain exactly 2 distinct values, one for treated and one for control.
</p>
</td></tr>
<tr><td><code id="count.pairings_+3A_exact">exact</code></td>
<td>

<p>a vector of categories of a potential blocking variable.  Must be the same length as argument <code>z</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of within-block treatment-control edges contained in the sparse match with the proposed blocks.
</p>


<h3>Author(s)</h3>

<p>Samuel D. Pimentel
</p>

<hr>
<h2 id='dist2net'>
Building and Manipulating Network Flow Problems
</h2><span id='topic+dist2net'></span><span id='topic+dist2net.matrix'></span><span id='topic+add.layer'></span><span id='topic+remove.layer'></span><span id='topic+penalty.update'></span><span id='topic+penalize.near.exact'></span>

<h3>Description</h3>

<p>These are internal rcbalance methods not meant to be called directly by users.  They are used to construct a network flow problem from the information about a matching problem that is passed to the <code>rcbalance</code> method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2net(dist.struct, k, exclude.treated = FALSE, ncontrol = NULL)

dist2net.matrix(dist.struct, k, exclude.treated = FALSE)

add.layer(net.layers, new.layer)

penalty.update(net.layers, newtheta, newp = NA)

penalize.near.exact(net.layers, near.exact)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist2net_+3A_dist.struct">dist.struct</code></td>
<td>

<p>An object specifying the sparsity structure of the match.  For the dist2net method it is a list of vectors, and for the dist2net.matrix method it is a matrix or InfinitySparseMatrix.   See rcbalance documentation for more details.
</p>
</td></tr>
<tr><td><code id="dist2net_+3A_k">k</code></td>
<td>

<p>a nonnegative integer. The number of control units to which each treated unit will be matched.
</p>
</td></tr>
<tr><td><code id="dist2net_+3A_exclude.treated">exclude.treated</code></td>
<td>

<p>if <code>TRUE</code>, then when there is no feasible match using all treated units, a minimal number of treated units may be dropped so that a match can be formed.  Specifying this argument adds penalized edges to the network so that such a match can be computed. NOTE: this argument is incompatible with values of <code>k</code> greater than 1.
</p>
</td></tr>
<tr><td><code id="dist2net_+3A_ncontrol">ncontrol</code></td>
<td>

<p>the number of controls in the matching problem.  If left <code>NULL</code> (the default value), the value will be intuited from the maximum control label in the sparsity object.
</p>
</td></tr>
<tr><td><code id="dist2net_+3A_net.layers">net.layers</code></td>
<td>

<p>a layered network object of the type produced by the dist2net function.  
</p>
</td></tr>
<tr><td><code id="dist2net_+3A_new.layer">new.layer</code></td>
<td>

<p>a vector equal in length to the number of treated and control units in the matching problem.  Each coordinate contains the value of a new fine balance variable for the corresponding unit.
</p>
</td></tr>
<tr><td><code id="dist2net_+3A_newtheta">newtheta</code></td>
<td>
<p>optional argument giving a new value for the theta field of the net.layers object (see value section for description of this field).</p>
</td></tr>
<tr><td><code id="dist2net_+3A_newp">newp</code></td>
<td>
<p>optional argument giving a new value for the p field of the net.layers object (see value section for description of this field).</p>
</td></tr>
<tr><td><code id="dist2net_+3A_near.exact">near.exact</code></td>
<td>
<p>a vector equal in length to the number of treated and control units in the matching problem.  Edges between units with different values of this variable will be penalized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dist2net</code> and <code>dist2net.matrix</code> take the distance structure given to <code>rcbalance</code> encoding information about the matching problem and converts it into a network flow problem.  <code>add.layer</code> adds network structure to handle an individual fine balance variable (it can be called iteratively to add many such variables).  <code>penalty.update</code> is used to change the penalties for each layer (and the penalties for edges used to exclude treated units if they are present) and <code>penalize.near.exact</code> is used to add penalties to the treated-control edges to allow near-exact matching. See the references for a detailed description of how the matching problem is transformed into a network.
</p>


<h3>Value</h3>

<p>A layered network object, formatted as a list with the following arguments (where narcs is the number of arcs and nnodes is the number of nodes in the network):
</p>
<table>
<tr><td><code>startn</code></td>
<td>
<p>a vector of length narc containing the node numbers of the start nodes of each arc in the network.</p>
</td></tr>
<tr><td><code>endn</code></td>
<td>
<p> a vector of length narc containing the node numbers of the end nodes of each arc in the network.</p>
</td></tr>
<tr><td><code>ucap</code></td>
<td>
<p> a vector of length narc containing the (integer) upper capacity of each arc in the network.</p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p> a vector of length narc containing the (integer) cost of each arc in the network.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p> a vector of length nnode containing the (integer) supply or demand of each node in the network.  Supplies are given as positive numbers and demands as negative numbers.</p>
</td></tr>
<tr><td><code>tcarcs</code></td>
<td>
<p>an integer giving the total number of arcs between the treated and control nodes in the network.</p>
</td></tr>
<tr><td><code>layers</code></td>
<td>
<p>a list object containing information about the refined covariate balance layers of the network.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>a vector of treatment indicators.</p>
</td></tr>
<tr><td><code>fb.structure</code></td>
<td>
<p>a matrix containing information about the membership of the treated and control units in the different classes of refined balance covariates.</p>
</td></tr>
<tr><td><code>penalties</code></td>
<td>
<p>a vector of integer penalties, one for each fine balance layer.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>a value no less than 1 giving the ratio by which the penalty is increased with each additional layer of fine balance.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>a nonnegative value giving the penalty for the finest level of fine balance.</p>
</td></tr>			
</table>


<h3>Author(s)</h3>

<p>Samuel D. Pimentel
</p>

<hr>
<h2 id='rcbalance'>
Optimal Matching with Refined Covariate Balance
</h2><span id='topic+rcbalance'></span>

<h3>Description</h3>

<p>This function computes an optimal match with refined covariate balance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcbalance(distance.structure, near.exact = NULL, fb.list = NULL, 
treated.info = NULL, control.info = NULL, exclude.treated = FALSE, target.group = NULL,
 k = 1, penalty = 3, tol = 1e-5, solver = 'rlemon')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcbalance_+3A_distance.structure">distance.structure</code></td>
<td>

<p>a list of vectors that encodes information about covariate distances between treated and control units.  The list is equal in length to the number of treated units.  Each vector corresponds to a treated unit and is equal in length to the number of control units to which it can be matched.  It is assumed that there are a total of <code>nc</code> control units in the problem and that they are numbered from 1 to <code>nc</code>.  The names of each vector in the list give the index (in the vector <code>1:nc</code>) of the control units to which the treated unit in question can be matched, and the elements of each vector are the covariate distances between the treated unit and the corresponding control.  Note that for a dense matching problem (in which each treated unit can be matched to any control), every vector in the list will have length nc and rownames 1 through nc.
</p>
<p>Alternatively, this same information can be passed as a <code>matrix</code> or  <code>InfinitySparseMatrix</code> with rows corresponding to treated units and columns corresponding to controls.  Entries given as <code>Inf</code> correspond to pairs that cannot be matched.  
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_near.exact">near.exact</code></td>
<td>
 
<p>an optional character vector specifying names of covariates for near-exact matching.  This argument takes precedence over any refined covariate balance constraints, so the match will produce the best refined covariate balance subject to matching exactly on this variable wherever possible.  If multiple covariates are named, near-exact matching will be done on their interaction.
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_fb.list">fb.list</code></td>
<td>

<p>an optional list of character vectors specifying covariates to be used for refined balance.  Each element of the list corresponds to a level of refined covariate balance, and the levels are assumed to be in decreasing order of priority.  Each character vector should contain one or more names of categorical covariates on which the user would like to enforce near fine balance.  If multiple covariates are specified, an interaction is created between the categories of the covariates and near fine balance is enforced on the interaction.  IMPORTANT: covariates or interactions coming later in the list must be nested within covariates coming earlier in the list; if this is not the case the function will stop with an error.  An easy way to ensure that this occurs is to include in each character vector all the variables named in earlier list elements.  If the <code>fb.list</code> argument is specified, the <code>treated.info</code> and <code>control.info</code> arguments must also be specified.
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_treated.info">treated.info</code></td>
<td>

<p>an optional data frame containing covariate information for the treated units in the problem.  The row count of this data frame must be equal to the length of the <code>distance.structure</code> argument, and it is assumed that row <code>i</code> contains covariate information for the treated unit described by element <code>i</code> of <code>distance.structure</code>.  In addition, the column count and column names must be identical to those of the <code>control.info</code> argument, and the column names must include all of the covariate names mentioned in the <code>near.exact</code> and <code>fb.list</code> arguments.
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_control.info">control.info</code></td>
<td>

<p>an optional data frame containing covariate information for the control units in the problem.  The row count of this data frame must be no smaller than the maximum control index in the <code>distance.structure</code> argument, and it is assumed that row <code>i</code> contains the covariate information for the control indexed by <code>i</code> in distance.structure.  In addition, the column count and column names must be identical to those of the <code>treated.info</code> argument.
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_exclude.treated">exclude.treated</code></td>
<td>

<p>if <code>TRUE</code>, then when there is no feasible match using all treated units, a minimal number of treated units will be dropped so that a match can be formed.  The excluded treated units will be selected optimally so that the cost of the matching is reduced as much as possible.  NOTE: <code>exclude.treated</code> = <code>TRUE</code> is incompatible with arguments to <code>target.group</code> and with values of <code>k</code> larger than 1. 
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_target.group">target.group</code></td>
<td>

<p>an optional data frame of observations with the desired covariate distribution for the selected control group,
if it differs from the covariate distribution of the treated units.  This argument will be ignored unless <code>fb.list</code>, <code>treated.info</code> and <code>control.info</code> are also specified, and it must have the same dimensions as <code>treated.info</code>.
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_k">k</code></td>
<td>

<p>a nonnegative integer. The number of control units to which each treated unit will be matched.
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_penalty">penalty</code></td>
<td>

<p>a value greater than 1.  This is a tuning parameter that helps ensure the different levels of refined covariate balance are prioritized correctly.   Setting the penalty higher tends to improve the guarantee of match optimality up to a point, but penalties above a certain level cause integer overflows and throw errors.  Usually it is not recommended that the user change this parameter from its default value.
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_tol">tol</code></td>
<td>

<p>edge cost tolerance.  This is the smallest tolerated difference between matching costs; cost differences smaller than this will be considered zero.  Match distances will be scaled by inverse tolerance, so when matching with large edge costs or penalties the tolerance may need to be increased.
</p>
</td></tr>
<tr><td><code id="rcbalance_+3A_solver">solver</code></td>
<td>

<p>the name of the package used to solve the network flow optimization problem underlying the match, one of 'rlemon' (which uses the Lemon Optimization Library) and 'rrelaxiv' (which uses the RELAX-IV algorithm). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use the option <code>solver = 'rrelaxiv'</code>, the user must install the
<code>rrelaxiv</code> manually; it is not hosted on CRAN because it carries an academic
license.  
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>matches</code></td>
<td>
<p>a nt by k matrix containing the matched sets produced by the algorithm (where nt is the number of treated units).  The rownames of this matrix are the numbers of the treated units (indexed by their position in distance.structure), and the elements of each row contain the indices of the control units to which this treated unit has been matched.</p>
</td></tr>
<tr><td><code>fb.tables</code></td>
<td>
<p>a list of matrices, equal in length to the fb.list argument.  Each matrix is a contingency table giving the counts among treated units and matched controls for each level of the categorical variable specified by the corresponding element of fb.list. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Samuel D. Pimentel
</p>


<h3>References</h3>

<p>Pimentel, S.D., Kelz, R.R., Silber, J.H., and Rosenbaum, P.R. (2015) Large, sparse optimal matching with refined covariate balance in an observational study of the health outcomes produced by new surgeons, JASA 110 (510), 515-527.	
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(optmatch)	
data(nuclearplants)

#require exact match on variables ne and pt, use rank-based Mahalanobis distance
my.dist.struct &lt;- build.dist.struct(z = nuclearplants$pr, 
	X = subset(nuclearplants[c('date','t1','t2','cap','bw','cum.n')]),
	exact = paste(nuclearplants$ne, nuclearplants$pt, sep = '.'))

#match with refined covariate balance, first on ct then on (ct x bw)
rcbalance(my.dist.struct, fb.list = list('ct',c('ct','bw')),
 	treated.info = nuclearplants[which(nuclearplants$pr ==1),],
 	control.info = nuclearplants[which(nuclearplants$pr == 0),])

#repeat the same match using match_on tool from optmatch and regular Mahalanobis distance
exact.mask &lt;- exactMatch(pr ~ ne + pt, data = nuclearplants)
my.dist.matrix &lt;- match_on(pr ~ date + t1 + t2 + cap + bw + cum.n,
	within = exact.mask, data = nuclearplants)
match.matrix &lt;- 
	rcbalance(my.dist.matrix*100, fb.list = list('ct',c('ct','bw')), 
	treated.info = nuclearplants[which(nuclearplants$pr ==1),],
	control.info = nuclearplants[which(nuclearplants$pr == 0),])

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
