<!DOCTYPE html><html><head><title>Help for package gdi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gdi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cscorr'><p>Measure and analyze cross-sectional geometry supplied as an image.</p></a></li>
<li><a href='#csI'><p>Calculates the second moment of area (=area moment of inertia, Ix and Iy) and polar moment of inertia (Iz or J) for a cross-section given as an image.</p></a></li>
<li><a href='#fdetect'><p>Tool to help determine which threshold value and method to use with measuresil() or cscorr(). The function analyzes all pixels along the edges of the image to determine the background color, to help with deciding on appropriate settings and avoid errors introduced by inappropriate settings</p></a></li>
<li><a href='#gdi'><p>Estimate volume using Graphic Double Integration.</p></a></li>
<li><a href='#hCOM'><p>Finds the horizontal (x axis, i.e. the axis vertical to the cross-sections) position of the center of mass (COM) of the volume. Experimental; only valid for &quot;raw&quot; gdi results with segment volumes approximated as elliptical prisms, or for manually supplied segment COMs. COM is calculated as a weighted mean of all segment COMs, with the segment mass as the weighting factor.</p></a></li>
<li><a href='#imghist'><p>Simple histogram analysis for all color values in an input image. Can be used to help assess whether a chosen threshold value is appropriate for differentiating the silhouette from the background, or for general image analysis purposes.</p></a></li>
<li><a href='#measuresil'><p>Take pixel-by-pixel measurements of a silhouette in jpeg or png format for use with the gdi function.</p></a></li>
<li><a href='#plot_sil'><p>Plots a silhouette read by measuresil()</p></a></li>
<li><a href='#rotI'><p>Calculates the rotational inertia of a body. Only works with simple circular/elliptical and rectangular cross-sections, thus pixel-precise estimates are recommended.</p></a></li>
<li><a href='#sellipse'><p>Estimate area of a superellipse. Assistant function for gdi.</p></a></li>
<li><a href='#sellipse.coo'><p>calculate coordinates for plotting a superellipse for visualizing body cross-sections</p></a></li>
<li><a href='#vCOM'><p>Finds the vertical (y axis, i.e. the axis parallel to the cross-section diameter) position of the center of mass (COM) of the volume. Experimental; only valid for &quot;raw&quot; gdi results with segment volumes approximated as elliptical prisms, or for manually supplied segment COMs. COM is calculated as a weighted mean of all segment COMs, with the segment mass as the weighting factor. Estimates have lower accuracy compared to hCOM, because cross-sectional geometry and variation in density throughout the cross-section is not taken into account.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Volumetric Analysis using Graphic Double Integration</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Darius Nau [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Darius Nau &lt;dariusnau@gmx.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools implementing an automated version of the graphic double integration technique (GDI) for volume implementation, and some other related utilities for paleontological image-analysis. GDI was first employed by Jerison (1973) &lt;ISBN:9780323141086&gt; and Hurlburt (1999) &lt;<a href="https://doi.org/10.1080%2F02724634.1999.10011145">doi:10.1080/02724634.1999.10011145</a>&gt; and is primarily used for volume or mass estimation of (extinct) animals. The package 'gdi' aims to make this technique as convenient and versatile as possible. The core functions of 'gdi' provide utilities for automatically measuring diameters from digital silhouettes provided as image files and calculating volume via graphic double integration with simple elliptical, superelliptical (following Motani 2001 &lt;<a href="https://doi.org/10.1666/0094-8373(2001)027%3C0735:EBMFST%3E2.0.CO;2">doi:10.1666/0094-8373(2001)027%3C0735:EBMFST%3E2.0.CO;2</a>&gt;) or complex cross-sectional models. Additionally, the package provides functions for estimating the center of mass position (COM), the moment of inertia (I) for 3D shapes and the second moment of area (Ix) of 2D cross-sections, as well as for visualization of results.</td>
</tr>
<tr>
<td>Depends:</td>
<td>jpeg, png</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-07 17:11:33 UTC; suirad</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-07 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cscorr'>Measure and analyze cross-sectional geometry supplied as an image.</h2><span id='topic+cscorr'></span>

<h3>Description</h3>

<p>Measure and analyze cross-sectional geometry supplied as an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cscorr(
  image_file,
  threshold = 0.5,
  channel = 4,
  method = "greater",
  return = "area_corr",
  k = 2,
  scale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cscorr_+3A_image_file">image_file</code></td>
<td>
<p>Image to be read. Images can be jpeg or png files, or a previously read image saved as an array/matrix-type object in R.</p>
</td></tr>
<tr><td><code id="cscorr_+3A_threshold">threshold</code></td>
<td>
<p>Reference value for color criterium after which pixels that are part of the cross-section are differentiated from the background.</p>
</td></tr>
<tr><td><code id="cscorr_+3A_channel">channel</code></td>
<td>
<p>Color channel to which to apply the threshold criterium. Default is 4 (alpha channel of rgba image). Channel setting needs to be adjusted depending on the color mode of the image used (e.g. there are two channels to choose from in a greyscale image, and 3 in an rgb image).</p>
</td></tr>
<tr><td><code id="cscorr_+3A_method">method</code></td>
<td>
<p>Method for determining which pixels to count. Default &quot;greater&quot; counts pixels with value greater than threshold (e.g. higher opacity, in the case of an alpha channel). &quot;less&quot; counts pixels with a value less than the threshold. &quot;not&quot; counts all pixels not precisely matching threshold. Any other character string results in only pixels exactly matching the value given as threshold being counted.</p>
</td></tr>
<tr><td><code id="cscorr_+3A_return">return</code></td>
<td>
<p>What value to return. Possible values are &quot;area_corr&quot; (Default, returns ratio between measured area and area of ellipse with same horizontal and vertical diameters), &quot;aspect_ratio&quot; (returns aspect ratio), &quot;diameters&quot; (returns diameters), &quot;area&quot; (returns area) and &quot;rotI&quot; (returns correction factors for rotational inertia calculations). Any other value for this parameter will prompt the function to return a vector containing all of these outputs.</p>
</td></tr>
<tr><td><code id="cscorr_+3A_k">k</code></td>
<td>
<p>optional superellipse exponent for the (super)ellipse to which the measurements should be compared (for the &quot;area_corr&quot; setting for the parameter return).</p>
</td></tr>
<tr><td><code id="cscorr_+3A_scale">scale</code></td>
<td>
<p>Optional scale of the image (for raw area measurements).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a numeric of length 1 (depending on the input of the return parameter), defaulting to the area correction factor (if return==&quot;area_corr&quot;), or (if return is left empty or does not match any of the predefined settings) a numeric vector with 8 elements, containing all the possible outputs (x and y diameters, aspect ratio, area and area correction factor, correction factors representing ratios of rotational inertia in x, y and z planes relative an ellipse of equal diameters).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file(package="gdi")
correction_factor &lt;- cscorr(file.path(fdir,"exdata","cross_section.png"))
</code></pre>

<hr>
<h2 id='csI'>Calculates the second moment of area (=area moment of inertia, Ix and Iy) and polar moment of inertia (Iz or J) for a cross-section given as an image.</h2><span id='topic+csI'></span>

<h3>Description</h3>

<p>Calculates the second moment of area (=area moment of inertia, Ix and Iy) and polar moment of inertia (Iz or J) for a cross-section given as an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csI(
  image_file,
  threshold = 0.5,
  channel = 4,
  method = "greater",
  scale = 1,
  return = "total"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csI_+3A_image_file">image_file</code></td>
<td>
<p>Image to be read. Images can be jpeg or png files, or a previously read image saved as an object in R.</p>
</td></tr>
<tr><td><code id="csI_+3A_threshold">threshold</code></td>
<td>
<p>Reference value for color criterium after which pixels that are part of the silhouette should be differentiated from the background.</p>
</td></tr>
<tr><td><code id="csI_+3A_channel">channel</code></td>
<td>
<p>color channel to which to apply the threshold criterium. Default is 4 (alpha channel of rgba image). Channel setting needs to be adjusted depending on the color mode of the image used (e.g. there are two channels to choose from in a greyscale image, and 3 in an rgb image).</p>
</td></tr>
<tr><td><code id="csI_+3A_method">method</code></td>
<td>
<p>Method for determining which pixels to count. Default &quot;greater&quot; counts pixels with value greater than threshold (e.g. higher opacity, in the case of an alpha channel). &quot;less&quot; counts pixels with a value less than the threshold. &quot;not&quot; counts all pixels not precisely matching threshold. Any other character string results in only pixels exactly matching the value given as threshold being counted.</p>
</td></tr>
<tr><td><code id="csI_+3A_scale">scale</code></td>
<td>
<p>Optional scale of the image (number of pixels per linear unit).</p>
</td></tr>
<tr><td><code id="csI_+3A_return">return</code></td>
<td>
<p>What to return, defaults to returning both x and y second moments of area and polar moment of inertia for the entire shape (if return==&quot;total&quot;), otherwise returns raw data matrix for all pixels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing Ix, Iy and Iz for the shape (default), or a matrix containing area moments and coordinates for each pixel in the image, as well as area moments converted relative to the common centroid of the shape using parallel axis theorem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file(package="gdi")
csI(file.path(fdir,"exdata","cross_section.png"))
</code></pre>

<hr>
<h2 id='fdetect'>Tool to help determine which threshold value and method to use with measuresil() or cscorr(). The function analyzes all pixels along the edges of the image to determine the background color, to help with deciding on appropriate settings and avoid errors introduced by inappropriate settings</h2><span id='topic+fdetect'></span>

<h3>Description</h3>

<p>Tool to help determine which threshold value and method to use with measuresil() or cscorr(). The function analyzes all pixels along the edges of the image to determine the background color, to help with deciding on appropriate settings and avoid errors introduced by inappropriate settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdetect(image_file, threshold = 0.5, channel = 4, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdetect_+3A_image_file">image_file</code></td>
<td>
<p>Image to be read. Images can be jpeg or png files, or a previously read image saved as an object in R.</p>
</td></tr>
<tr><td><code id="fdetect_+3A_threshold">threshold</code></td>
<td>
<p>Reference value for color criterium after which pixels that are part of the silhouette should be differentiated from the background.</p>
</td></tr>
<tr><td><code id="fdetect_+3A_channel">channel</code></td>
<td>
<p>Color channel to which to apply the threshold criterium. Default is 4 (alpha channel of rgba image). Channel setting needs to be adjusted depending on the color mode of the image used (e.g. there are two channels to choose from in a greyscale image, and 3 in an rgb image).</p>
</td></tr>
<tr><td><code id="fdetect_+3A_plot">plot</code></td>
<td>
<p>Whether to plot a histogram with the detected color values (if TRUE) or not (if FALSE, default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list()-object containing: $edgetable (a table of the different color values detected and their respective frequencies), $histogram (a histogram-object of the color values), $most_common (the most common color value found), $foreground (a character string, indicating whether the foreground color value is likely &quot;greater&quot; or &quot;less&quot; than the specified threshold), $result (a character string giving a summary of the results)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file(package="gdi")
fdetect(file.path(fdir,"exdata","lat.png"))
</code></pre>

<hr>
<h2 id='gdi'>Estimate volume using Graphic Double Integration.</h2><span id='topic+gdi'></span>

<h3>Description</h3>

<p>Estimate volume using Graphic Double Integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdi(
  lat,
  dors,
  indices = NULL,
  scale = 10,
  sliceL = 1/scale,
  method = "raw",
  k = 2,
  corr = 1,
  smooth.ends = FALSE,
  return = "total"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdi_+3A_lat">lat</code></td>
<td>
<p>Measurements of diameter in lateral view/first of two orthogonal views to be used with the gdi. Can be either a numeric vector, a data.frame (output of measuresil(...,return=&quot;all&quot;) with a collumn named &quot;diameter&quot;, or a text file with diameter measurements to be scanned.</p>
</td></tr>
<tr><td><code id="gdi_+3A_dors">dors</code></td>
<td>
<p>Measurements of diameter in dorsal view/second of two orthogonal views to be used with the gdi. Can be either a numeric vector, a data.frame (output of measuresil(...,return=&quot;all&quot;) with a collumn named &quot;diameter&quot;, or a text file with diameter measurements to be scanned. Must be the same length as lat.</p>
</td></tr>
<tr><td><code id="gdi_+3A_indices">indices</code></td>
<td>
<p>Optional indices specifying a subset of the silhouette measurement vectors to be analyzed. Useful if separate segment calculations are desired.</p>
</td></tr>
<tr><td><code id="gdi_+3A_scale">scale</code></td>
<td>
<p>Scale of the data, given in terms of how many units of the input data (e.g. pixels) are in one side of the desired unit of output volume. Defaults to 10.</p>
</td></tr>
<tr><td><code id="gdi_+3A_slicel">sliceL</code></td>
<td>
<p>Length of individual segments to be used in the GDI. Defaults to 1/scale.</p>
</td></tr>
<tr><td><code id="gdi_+3A_method">method</code></td>
<td>
<p>Method to be used for the GDI. Default &quot;raw&quot; setting calculates each segment as an elliptical cylinder with volume = Area * SliceL. Any other string will result in volume being calculated as an elliptical frustum with base areas based on the measurements of segments i and i+1.</p>
</td></tr>
<tr><td><code id="gdi_+3A_k">k</code></td>
<td>
<p>Superellipse exponent to be used for the cross-sectional area. Defaults to 2.0 (normal ellipse).</p>
</td></tr>
<tr><td><code id="gdi_+3A_corr">corr</code></td>
<td>
<p>Correction factor for area of cross-sections, calculated as the ratio between the actual cross-sectional area and that of a (super)ellipse (depending on the specified exponent k) with the same diameters. This setting enables the function to account for complex, non-elliptical cross-sections. Default value is 1, i.e. no correction. Can be either a single number, or a numeric vector of the same length as lat and dors (in the case of a changing cross-sectional geometry along the length of the body).</p>
</td></tr>
<tr><td><code id="gdi_+3A_smooth.ends">smooth.ends</code></td>
<td>
<p>If method != &quot;raw&quot;, specify whether first and last segments should be left raw, or taper to 0 (i.e. be approximated as cones). Only applies if there are no leading or following zeros in the measurement vectors.</p>
</td></tr>
<tr><td><code id="gdi_+3A_return">return</code></td>
<td>
<p>Determines whether to report the estimated total volume (if default/&quot;total&quot;), or a data.frame() with segment radii, areas and volumes (if left empty of any other character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a single number representing the total volume estimated (with names indicating the horizontal length of the silhouette in the unit determined by scale), or (if return!=&quot;total&quot;) a data.frame() containing columns with the radii in both dimensions, the estimated elliptical or superelliptical areas, and the segment volumes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lateral &lt;- rep(2,4) #generate example data
dorsal &lt;- rep(2,4)
gdi(lat=lateral, dors=dorsal, scale=10, method="raw", k=2.0)
gdi(lat=lateral, dors=lateral/2, scale=10, method="smooth", k=2.3)
</code></pre>

<hr>
<h2 id='hCOM'>Finds the horizontal (x axis, i.e. the axis vertical to the cross-sections) position of the center of mass (COM) of the volume. Experimental; only valid for &quot;raw&quot; gdi results with segment volumes approximated as elliptical prisms, or for manually supplied segment COMs. COM is calculated as a weighted mean of all segment COMs, with the segment mass as the weighting factor.</h2><span id='topic+hCOM'></span>

<h3>Description</h3>

<p>Finds the horizontal (x axis, i.e. the axis vertical to the cross-sections) position of the center of mass (COM) of the volume. Experimental; only valid for &quot;raw&quot; gdi results with segment volumes approximated as elliptical prisms, or for manually supplied segment COMs. COM is calculated as a weighted mean of all segment COMs, with the segment mass as the weighting factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hCOM(
  x,
  volumes = NULL,
  align = "h",
  subtract = NULL,
  densities = NULL,
  scale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hCOM_+3A_x">x</code></td>
<td>
<p>Either a data frame that is the output of gdi(..., return=&quot;all&quot;), or a numeric vector of horizontal segment COM positions.</p>
</td></tr>
<tr><td><code id="hCOM_+3A_volumes">volumes</code></td>
<td>
<p>An optional separate vector of volumes, required if x is not a data.frame containing volumes.</p>
</td></tr>
<tr><td><code id="hCOM_+3A_align">align</code></td>
<td>
<p>alignment of the silhouette, if &quot;h&quot; (default) the silhouette is assumed to be horizontally aligned, if any other value (e.g. &quot;v&quot;) then the silhouette is assumed to be vertically aligned.</p>
</td></tr>
<tr><td><code id="hCOM_+3A_subtract">subtract</code></td>
<td>
<p>An optional separate vector of volumes, with length equal to the length or nrow() of x, to be subtracted from the volumes for the COM calculation.</p>
</td></tr>
<tr><td><code id="hCOM_+3A_densities">densities</code></td>
<td>
<p>An optional vector of segment densities, with length equal to the length or nrow() of x, to be multiplied with the volumes for the COM calculation. If both subtract and densities are supplied, the density is applied only to the &quot;residual&quot; volume that is left after subtraction.</p>
</td></tr>
<tr><td><code id="hCOM_+3A_scale">scale</code></td>
<td>
<p>Optional scale value (number of pixels to chosen unit of measurement)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class numeric() containing the x coordinate of the center of mass of the shape, in pixels (or chosen units, if manually calculated)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file(package="gdi")
measuresil(file.path(fdir,"exdata","lat.png"), return="all")-&gt;lat_
measuresil(file.path(fdir,"exdata","dors.png"), return="all")-&gt;dors_
gdi(lat_, dors_, return="all")-&gt;gdiresults
hCOM(gdiresults)
</code></pre>

<hr>
<h2 id='imghist'>Simple histogram analysis for all color values in an input image. Can be used to help assess whether a chosen threshold value is appropriate for differentiating the silhouette from the background, or for general image analysis purposes.</h2><span id='topic+imghist'></span>

<h3>Description</h3>

<p>Simple histogram analysis for all color values in an input image. Can be used to help assess whether a chosen threshold value is appropriate for differentiating the silhouette from the background, or for general image analysis purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imghist(
  image_file,
  threshold = 0.5,
  channel = 4,
  breaks = seq(0, 1, 0.05),
  plot = TRUE,
  unique = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imghist_+3A_image_file">image_file</code></td>
<td>
<p>Image to be read. Images can be jpeg or png files, or a previously read image saved as an object in R.</p>
</td></tr>
<tr><td><code id="imghist_+3A_threshold">threshold</code></td>
<td>
<p>Reference value for color criterium after which pixels that are part of the silhouette should be differentiated from the background.</p>
</td></tr>
<tr><td><code id="imghist_+3A_channel">channel</code></td>
<td>
<p>color channel to which to apply the threshold criterium. Default is 4 (alpha channel of rgba image). Channel setting needs to be adjusted depending on the color mode of the image used (e.g. there are two channels to choose from in a greyscale image, and 3 in an rgb image).</p>
</td></tr>
<tr><td><code id="imghist_+3A_breaks">breaks</code></td>
<td>
<p>A vector of breaks for the histogram, defaults to a bin width of 0.05 between color values of 0 and 1.</p>
</td></tr>
<tr><td><code id="imghist_+3A_plot">plot</code></td>
<td>
<p>Whether to plot a histogram, defaults to TRUE</p>
</td></tr>
<tr><td><code id="imghist_+3A_unique">unique</code></td>
<td>
<p>Whether to return counts for unique color values, defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotted histogram (unless plot==FALSE), and a matrix containing the counts from the histogram (default) or the counts for unique color values (if unique==TRUE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file(package="gdi")
imghist(file.path(fdir,"exdata","lat.png"))
</code></pre>

<hr>
<h2 id='measuresil'>Take pixel-by-pixel measurements of a silhouette in jpeg or png format for use with the gdi function.</h2><span id='topic+measuresil'></span>

<h3>Description</h3>

<p>Take pixel-by-pixel measurements of a silhouette in jpeg or png format for use with the gdi function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measuresil(
  image_file,
  threshold = 0.5,
  channel = 4,
  method = "greater",
  align = "h",
  return = "diameters"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measuresil_+3A_image_file">image_file</code></td>
<td>
<p>Image to be read. Images can be jpeg or png files, or a previously read image saved as an object in R.</p>
</td></tr>
<tr><td><code id="measuresil_+3A_threshold">threshold</code></td>
<td>
<p>Reference value for color criterium after which pixels that are part of the silhouette are differentiated from the background.</p>
</td></tr>
<tr><td><code id="measuresil_+3A_channel">channel</code></td>
<td>
<p>Color channel to which to apply the threshold criterium. Default is 4 (alpha channel of rgba image). Channel setting needs to be adjusted depending on the color mode of the image used (e.g. there are two channels to choose from in a greyscale image with transparency, and 3 in an rgb image without transparency, or 4 in a full rgba image).</p>
</td></tr>
<tr><td><code id="measuresil_+3A_method">method</code></td>
<td>
<p>Method for determining which pixels to count. Default &quot;greater&quot; counts pixels with value greater than threshold (e.g. higher opacity, in the case of an alpha channel). &quot;less&quot; counts pixels with a value less than the threshold. &quot;not&quot; counts all pixels not precisely matching threshold. Any other character string results in only pixels exactly matching the value given as threshold being counted.</p>
</td></tr>
<tr><td><code id="measuresil_+3A_align">align</code></td>
<td>
<p>Indicate whether the silhouette long axis is aligned horizontally (setting &quot;h&quot;, default), or vertically (any other parameter setting).</p>
</td></tr>
<tr><td><code id="measuresil_+3A_return">return</code></td>
<td>
<p>Setting for what to return, default setting (&quot;diameters&quot;) returns a single vector containing the diameters, any other setting returns a data frame containing centers and diameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the measurements of the silhouette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file(package="gdi")
lat &lt;- measuresil(file.path(fdir,"exdata","lat.png"))
</code></pre>

<hr>
<h2 id='plot_sil'>Plots a silhouette read by measuresil()</h2><span id='topic+plot_sil'></span>

<h3>Description</h3>

<p>Plots a silhouette read by measuresil()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sil(sil, flip = FALSE, add = FALSE, xoffset = 0, yoffset = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sil_+3A_sil">sil</code></td>
<td>
<p>A data frame that is the output of measuresil(..., return=&quot;all&quot;), containing the center and the diameter of the silhouette at each value for x.</p>
</td></tr>
<tr><td><code id="plot_sil_+3A_flip">flip</code></td>
<td>
<p>Whether to flip axes (useful if measuresil() was performed using align=&quot;v&quot;, defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot_sil_+3A_add">add</code></td>
<td>
<p>Whether to add to an existing plot</p>
</td></tr>
<tr><td><code id="plot_sil_+3A_xoffset">xoffset</code></td>
<td>
<p>Optional value by which to shift the silhouette on the x axis</p>
</td></tr>
<tr><td><code id="plot_sil_+3A_yoffset">yoffset</code></td>
<td>
<p>Optional value by which to shift the silhouette on the y axis</p>
</td></tr>
<tr><td><code id="plot_sil_+3A_...">...</code></td>
<td>
<p>Other parameters to pass on to plot() or lines()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotted silhouette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file(package="gdi")
measuresil(file.path(fdir,"exdata","lat.png"), return="all")-&gt;lat_
plot_sil(lat_)
</code></pre>

<hr>
<h2 id='rotI'>Calculates the rotational inertia of a body. Only works with simple circular/elliptical and rectangular cross-sections, thus pixel-precise estimates are recommended.</h2><span id='topic+rotI'></span>

<h3>Description</h3>

<p>Calculates the rotational inertia of a body. Only works with simple circular/elliptical and rectangular cross-sections, thus pixel-precise estimates are recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotI(
  x,
  y = NULL,
  dors_diam = NULL,
  lat_diam = NULL,
  axis_coord = NULL,
  axis = "yaw",
  volumes = NULL,
  densities = 1,
  corr = 1,
  scale = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotI_+3A_x">x</code></td>
<td>
<p>Either a data frame that is structured like output of gdi(..., return=&quot;all&quot;) containing masses and diameters for pixel-wide segments, or a numeric vector of segment COM positions.</p>
</td></tr>
<tr><td><code id="rotI_+3A_y">y</code></td>
<td>
<p>An optional vector of vertical (dorsoventral) segment COM positions.</p>
</td></tr>
<tr><td><code id="rotI_+3A_dors_diam">dors_diam</code></td>
<td>
<p>An optional vector of transverse diameters of the silhouette, required if not contained in x.</p>
</td></tr>
<tr><td><code id="rotI_+3A_lat_diam">lat_diam</code></td>
<td>
<p>An optional vector of vertical diameters of the silhouette, required if not contained in x. Needed if inertia for &quot;roll&quot; or &quot;pitch&quot; should be calculated.</p>
</td></tr>
<tr><td><code id="rotI_+3A_axis_coord">axis_coord</code></td>
<td>
<p>An optional coordinate of the axis of rotation, defaults to the center of mass of the entire volume if not set.</p>
</td></tr>
<tr><td><code id="rotI_+3A_axis">axis</code></td>
<td>
<p>Axis of rotation, defaults to &quot;yaw&quot; (i.e. rotation around vertical axis), can also be &quot;pitch&quot; (rotation around transverse axis) or &quot;roll&quot; (rotation around horizontal axis). For yaw rotation, the body is assumed to be bilaterally symmetrical, whereas for pitch rotation, dorsoventral variation in COM of segments is taken into account.</p>
</td></tr>
<tr><td><code id="rotI_+3A_volumes">volumes</code></td>
<td>
<p>An optional separate vector of volumes, required if x is not a data.frame containing them.</p>
</td></tr>
<tr><td><code id="rotI_+3A_densities">densities</code></td>
<td>
<p>An optional vector of segment densities, with length equal to the length or nrow() of x, to be multiplied with the volumes to calculate masses used in the inertial calculation.</p>
</td></tr>
<tr><td><code id="rotI_+3A_corr">corr</code></td>
<td>
<p>An optional correction factor for the cross-sectional shape, given as the ratio between the characteristic mass moment of inertia of a plane with the given shape (e.g. determined by cscorr()) and an elliptical plane with the same diameters and assigned mass. Allows the calculation of moments of inertia for bodies with arbitrary cross-sectional shapes.</p>
</td></tr>
<tr><td><code id="rotI_+3A_scale">scale</code></td>
<td>
<p>Scale value, i.e. number of pixels representing 1 m</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing: The total mass (on the basis of gdi volumes and optional densities), the rotational inertia of the shape using a point mass approximation of each segment (yaw/pitch rotation only), rotational inertia using a cylindrical approximation for each segment, rotational inertia using a cuboidal approximation (note that this only changes the mass distribution, while segment masses are still assumed to correspond to gdi results multiplied by optional densities), and rotational inertia using a corrected cylindrical approximation based on value for corr.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file(package="gdi")
measuresil(file.path(fdir,"exdata","lat.png"), return="all")-&gt;lat_
measuresil(file.path(fdir,"exdata","dors.png"), return="all")-&gt;dors_
gdi(lat_, dors_, return="all")-&gt;gdiresults
rotI(gdiresults)
</code></pre>

<hr>
<h2 id='sellipse'>Estimate area of a superellipse. Assistant function for gdi.</h2><span id='topic+sellipse'></span>

<h3>Description</h3>

<p>Estimate area of a superellipse. Assistant function for gdi.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sellipse(a, b, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sellipse_+3A_a">a</code></td>
<td>
<p>First radius of the superellipse.</p>
</td></tr>
<tr><td><code id="sellipse_+3A_b">b</code></td>
<td>
<p>Second radius of the superellipse.</p>
</td></tr>
<tr><td><code id="sellipse_+3A_k">k</code></td>
<td>
<p>superellipse exponent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number giving the area of the superellipse
</p>


<h3>Examples</h3>

<pre><code class='language-R'>major_radius&lt;-2
minor_radius&lt;-3
exponent&lt;-2.3
sellipse(major_radius, minor_radius, exponent)
</code></pre>

<hr>
<h2 id='sellipse.coo'>calculate coordinates for plotting a superellipse for visualizing body cross-sections</h2><span id='topic+sellipse.coo'></span>

<h3>Description</h3>

<p>calculate coordinates for plotting a superellipse for visualizing body cross-sections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sellipse.coo(k, res = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sellipse.coo_+3A_k">k</code></td>
<td>
<p>superellipse exponent.</p>
</td></tr>
<tr><td><code id="sellipse.coo_+3A_res">res</code></td>
<td>
<p>the desired resolution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sellipse.coo(2.0)-&gt;df #get coordinates for normal ellipse (exponent k=2)
plot(df$x,df$y,col="black", type="l") #plot normal ellipse
sellipse.coo(2.3)-&gt;df2 # get coordinates for superellipse with exponent 2.3
lines(df$x,df$y, col="blue") #plot superellipse
</code></pre>

<hr>
<h2 id='vCOM'>Finds the vertical (y axis, i.e. the axis parallel to the cross-section diameter) position of the center of mass (COM) of the volume. Experimental; only valid for &quot;raw&quot; gdi results with segment volumes approximated as elliptical prisms, or for manually supplied segment COMs. COM is calculated as a weighted mean of all segment COMs, with the segment mass as the weighting factor. Estimates have lower accuracy compared to hCOM, because cross-sectional geometry and variation in density throughout the cross-section is not taken into account.</h2><span id='topic+vCOM'></span>

<h3>Description</h3>

<p>Finds the vertical (y axis, i.e. the axis parallel to the cross-section diameter) position of the center of mass (COM) of the volume. Experimental; only valid for &quot;raw&quot; gdi results with segment volumes approximated as elliptical prisms, or for manually supplied segment COMs. COM is calculated as a weighted mean of all segment COMs, with the segment mass as the weighting factor. Estimates have lower accuracy compared to hCOM, because cross-sectional geometry and variation in density throughout the cross-section is not taken into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vCOM(
  y,
  volumes = NULL,
  subtract = NULL,
  densities = NULL,
  scale = 1,
  from_top = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vCOM_+3A_y">y</code></td>
<td>
<p>A data.frame that is the output of gdi(..., return=&quot;all&quot;), or a numeric vector containing vertical COM positions for segments</p>
</td></tr>
<tr><td><code id="vCOM_+3A_volumes">volumes</code></td>
<td>
<p>An optional separate vector or data.frame (output of gdi(...,return=&quot;all&quot;) or vector of volumes.</p>
</td></tr>
<tr><td><code id="vCOM_+3A_subtract">subtract</code></td>
<td>
<p>An optional separate vector of volumes, with length equal to the length or nrow() of x, to be subtracted from the volumes for the COM calculation.</p>
</td></tr>
<tr><td><code id="vCOM_+3A_densities">densities</code></td>
<td>
<p>An optional vector of segment densities, with length equal to the length or nrow() of x, to be multiplied with the volumes for the COM calculation. If both subtract and densities are supplied, the density is applied only to the &quot;residual&quot; volume that is left after subtraction.</p>
</td></tr>
<tr><td><code id="vCOM_+3A_scale">scale</code></td>
<td>
<p>Optional scale value (number of pixels to chosen unit of measurement)</p>
</td></tr>
<tr><td><code id="vCOM_+3A_from_top">from_top</code></td>
<td>
<p>Whether the output coordinate should be measured from the top of the image (standard for image processing software), if TRUE, or from the bottom (standard for plotting in R (if FALSE, default). If TRUE, an attribute to y, containing the vertical dimension relative to which the measurement should be taken is required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class numeric() containing the y coordinate of the center of mass of the shape, in pixels (or chosen units, if manually calculated)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdir &lt;- system.file(package="gdi")
measuresil(file.path(fdir,"exdata","lat.png"), return="all")-&gt;lat_
measuresil(file.path(fdir,"exdata","dors.png"), return="all")-&gt;dors_
gdi(lat_, dors_, return="all")-&gt;gdiresults
vCOM(gdiresults)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
