<!DOCTYPE html><html lang="en"><head><title>Help for package GPArotateDF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPArotateDF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#00.GPArotateDF'><p>Derivative-Free Gradient Projection Algorithms for Factor Rotation</p></a></li>
<li><a href='#ff.rotationsDF'><p>Rotations</p></a></li>
<li><a href='#GPADF'><p>Rotation Optimization</p></a></li>
<li><a href='#rotationsDF'><p>Rotations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2023.11-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Derivative Free Gradient Projection Factor Rotation</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Derivative Free Gradient Projection Algorithms for Factor Rotation.
    For more details see ?GPArotateDF. Theory for these functions can be found in
    the following publications:
    Jennrich (2004) &lt;<a href="https://doi.org/10.1007%2FBF02295647">doi:10.1007/BF02295647</a>&gt;.
    Bernaards and Jennrich (2005) &lt;<a href="https://doi.org/10.1177%2F0013164404272507">doi:10.1177/0013164404272507</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>GPArotation</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-24 18:12:32 UTC; coen</td>
</tr>
<tr>
<td>Author:</td>
<td>Coen Bernaards [aut, cre],
  Paul Gilbert [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Coen Bernaards &lt;cab.gparotation@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-24 22:10:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='00.GPArotateDF'>Derivative-Free Gradient Projection Algorithms for Factor Rotation</h2><span id='topic+GPArotateDF'></span><span id='topic+GPArotateDF-package'></span><span id='topic+GPArotateDF.Intro'></span>

<h3>Description</h3>

<p>Derivative-Free GPA Rotation for Factor Analysis
</p>
<p>The GPArotateDF package contains functions for the rotation of factor loadings
matrices without the need for deriving gradients. Both orthogonal and oblique rotation 
algorithms are available. Additionally, a number of rotation criteria are provided.
The GP algorithms minimize the rotation criterion function, and provide the 
corresponding rotation matrix. For oblique rotation, the covariance / correlation matrix
of the factors is also provided. The derivartive-free rotation method implemented in this package 
is described in Jennrich (2004). The GPArotation package is based on Bernaards and Jennrich (2005). 
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GPArotateDF</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL Version 2.</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> GPArotation </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of functions:
</p>
<p>Derivative-Free Gradient Projection Rotation Algorithms <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+GPForth.df">GPForth.df</a></code> </td><td style="text-align: left;"> Orthogonal rotation function </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+GPFoblq.df">GPFoblq.df</a></code> </td><td style="text-align: left;"> Oblique rotation function </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Rotations<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+cubimax.df">cubimax.df</a></code> </td><td style="text-align: left;"> Cubimax rotation  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fssQ.df">fssQ.df</a></code> </td><td style="text-align: left;"> Oblique Forced Simple Structure rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+fssT.df">fssT.df</a></code> </td><td style="text-align: left;"> Orthogonal Forced Simple Structure rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>ff routines to compute value of the criterion <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.bentler">ff.bentler</a></code></td><td style="text-align: left;"> Bentler's Invariant Pattern Simplicity ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.cf">ff.cf</a></code> </td><td style="text-align: left;"> Crawford-Ferguson Family ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.cubimax">ff.cubimax</a></code> </td><td style="text-align: left;"> Cubimax ff  </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.entropy">ff.entropy</a></code> </td><td style="text-align: left;"> Minimum Entropy ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.geomin">ff.geomin</a></code></td><td style="text-align: left;"> Geomin ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.infomax">ff.infomax</a></code> </td><td style="text-align: left;"> Infomax ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.oblimax">ff.oblimax</a></code> </td><td style="text-align: left;"> Oblimax ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.pst">ff.pst</a></code></td><td style="text-align: left;"> Partially Specified Target ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.quartimax">ff.quartimax</a></code></td><td style="text-align: left;"> Quartimax ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.quartimin">ff.quartimin</a></code></td><td style="text-align: left;"> Quartimin ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.simplimax">ff.simplimax</a></code></td><td style="text-align: left;"> Simplimax ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.fss">ff.fss</a></code></td><td style="text-align: left;"> Forced Simple Structure ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.target">ff.target</a></code></td><td style="text-align: left;"> Target ff </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+ff.varimax">ff.varimax</a></code></td><td style="text-align: left;"> Varimax ff </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Utility functions<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>NormalizingWeight</code> </td><td style="text-align: left;"> Kaiser normalization (not exported from NAMESPACE) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
</p>


<h3>References</h3>

<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676&ndash;696.
</p>
<p>Jennrich, R.I. (2004). Derivative free gradient projection algorithms for rotation.
<em>Psychometrika</em>, <b>69</b>, 475&ndash;480.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPForth.df">GPForth.df</a></code>,
<code><a href="#topic+GPFoblq.df">GPFoblq.df</a></code>
</p>

<hr>
<h2 id='ff.rotationsDF'>Rotations</h2><span id='topic+ff.bentler'></span><span id='topic+ff.cf'></span><span id='topic+ff.cubimax'></span><span id='topic+ff.entropy'></span><span id='topic+ff.fss'></span><span id='topic+ff.geomin'></span><span id='topic+ff.infomax'></span><span id='topic+ff.oblimax'></span><span id='topic+ff.pst'></span><span id='topic+ff.quartimax'></span><span id='topic+ff.quartimin'></span><span id='topic+ff.simplimax'></span><span id='topic+ff.target'></span><span id='topic+ff.varimax'></span>

<h3>Description</h3>

<p>Optimize factor loading rotation objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	ff.bentler(L)
	ff.cf(L, kappa=0)
	ff.cubimax(L)
	ff.entropy(L)
	ff.geomin(L, delta=0.01)
	ff.infomax(L) 
	ff.oblimax(L)
	ff.pst(L, W=NULL, Target=NULL)
	ff.quartimax(L)
	ff.quartimin(L)
	ff.simplimax(L, k=nrow(L))
	ff.fss(L, kij=2)
	ff.target(L, Target=NULL) 
	ff.varimax(L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ff.rotationsDF_+3A_l">L</code></td>
<td>
<p>a factor loading matrix</p>
</td></tr>
<tr><td><code id="ff.rotationsDF_+3A_kappa">kappa</code></td>
<td>
<p>see details.</p>
</td></tr>
<tr><td><code id="ff.rotationsDF_+3A_delta">delta</code></td>
<td>
<p>constant added to Lambda^2 in objective calculation.</p>
</td></tr>
<tr><td><code id="ff.rotationsDF_+3A_target">Target</code></td>
<td>
<p>rotation target for objective calculation.</p>
</td></tr>
<tr><td><code id="ff.rotationsDF_+3A_w">W</code></td>
<td>
<p>weighting of each element in target.</p>
</td></tr>
<tr><td><code id="ff.rotationsDF_+3A_k">k</code></td>
<td>
<p>number of close to zero loadings.</p>
</td></tr>
<tr><td><code id="ff.rotationsDF_+3A_kij">kij</code></td>
<td>
<p>minimum additional number of forced simple structure loadings in a pair of factors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used to optimize a rotation objective. The name need to be included
in a call to <code>GPForth.df</code> or <code>GPFoblq</code>. Calling the functions itself computes the values
but no rotation is performed.
</p>
<p>Functions listed here are all exported through NAMESPACE, and primarily serve as examples 
for programming new rotation methods.  New rotation methods can be programmed with a name
<code>ff.newmethod</code>. The inputs are the matrix L, and optionally any additional arguments. The
output should be a list with elements 
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>f</code>       </td><td style="text-align: left;"> the value of the criterion at L.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>Method</code>  </td><td style="text-align: left;"> a string indicating the criterion.</td>
</tr>
<tr>
 <td style="text-align: left;">         
  </td>
</tr>

</table>

<p>Please note that the function value <code>f</code> has to be minimized. If the rotation criterion
is supposed to maximize, then use the negative of the criterion to miniize. 
Functions which are available are 
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>ff.bentler</code>   </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;">  Bentler's invariant pattern simplicity criterion</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.cf</code>		   </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;">  Crawford-Ferguson family	   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.cubimax</code>   </td><td style="text-align: left;"> orthogonal    </td><td style="text-align: left;">  	</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.entropy</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;">  minimum entropy			</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.fss</code> 	   </td><td style="text-align: left;"> orthogonal or oblique	   </td><td style="text-align: left;">  Forced Simple Structure (see Vignette)   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.geomin</code>    </td><td style="text-align: left;"> orthogonal or oblique  </td><td style="text-align: left;"> 				   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.infomax</code>   </td><td style="text-align: left;"> orthogonal or oblique   </td><td style="text-align: left;"> 				   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.oblimax</code>   </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         				</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.pst</code>	   </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;">  partially specified target rotation	</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.quartimax</code> </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 					</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.quartimin</code> </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         				</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.simplimax</code> </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">         				</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.target</code>    </td><td style="text-align: left;"> orthogonal or oblique </td><td style="text-align: left;">  target rotation			</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ff.varimax</code>   </td><td style="text-align: left;"> orthogonal </td><td style="text-align: left;"> 					</td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>

<p>The argument <code>kappa</code> parameterizes the family for the Crawford-Ferguson 
method. If <code>m</code> is the number of factors and <code>p</code> is the number of 
items then <code>kappa</code> values having special names are <code>0=</code>Quartimax, 
<code>1/p=</code>Varimax, <code>m/(2*p)=</code>Equamax, <code>(m-1)/(p+m-2)=</code>Parsimax, <code>1=</code>Factor parsimony.
</p>
<p>For the argument <code>kij</code> for Forced Simple Structure see <code><a href="#topic+rotationsDF">rotationsDF</a></code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>f</code></td>
<td>
<p>criterion function value.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich</p>


<h3>References</h3>

<p>Jennrich, R.I. (2004) Derivative free gradient projection algorithms for rotation,
Psychometrika: <b>69</b>(3), 475&ndash;480.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPForth.df">GPForth.df</a></code>, 
<code><a href="#topic+GPFoblq.df">GPFoblq.df</a></code>, 
<code><a href="#topic+fssQ.df">fssQ.df</a></code>,
<code><a href="#topic+fssT.df">fssT.df</a></code>,
<code><a href="#topic+cubimax.df">cubimax.df</a></code>,
<code><a href="#topic+rotationsDF">rotationsDF</a></code>,
<code><a href="stats.html#topic+factanal">factanal</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data("Harman", package="GPArotation")
  qHarman  &lt;- GPForth.df(Harman8, Tmat=diag(2), method="quartimax")
  
  # define a new function as ff.newname for use with factanal
  ff.expomax &lt;- function(L)
  {
    f &lt;- -sum(diag(expm1(abs(L))))
    list(f = f, Method = "DF-Expomax")
  }
  GPForth.df(Harman8, method ="expomax")

  expomax.df &lt;- function(L, Tmat = diag(ncol(L)), normalize = FALSE, eps = 1e-5, maxit = 1000){
   GPForth.df(L, Tmat=Tmat, method = "expomax", normalize = normalize, eps= eps, maxit = maxit)	
  }
  expomax.df(Harman8, normalize = TRUE)
  factanal(factors = 2, covmat = ability.cov, rotation = "expomax.df", 
      control = list(rotate =c(normalize = TRUE)))
 </code></pre>

<hr>
<h2 id='GPADF'>Rotation Optimization</h2><span id='topic+GPForth.df'></span><span id='topic+GPFoblq.df'></span>

<h3>Description</h3>

<p>Derivative free gradient projection rotation optimization routine used by various rotation
objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    GPForth.df(A, Tmat=diag(ncol(A)), normalize = FALSE, eps=1e-5, 
       maxit=1000, method="varimax", methodArgs=NULL)
    GPFoblq.df(A, Tmat=diag(ncol(A)), normalize = FALSE, eps=1e-5, 
       maxit=1000, method="quartimin", methodArgs=NULL)
    </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GPADF_+3A_a">A</code></td>
<td>
<p>initial factor loadings matrix for which the rotation 
criterian is to be optimized.</p>
</td></tr>
<tr><td><code id="GPADF_+3A_tmat">Tmat</code></td>
<td>
<p>initial rotation matrix.</p>
</td></tr>
<tr><td><code id="GPADF_+3A_normalize">normalize</code></td>
<td>
<p>see details.</p>
</td></tr>
<tr><td><code id="GPADF_+3A_eps">eps</code></td>
<td>
<p>convergence is assumed when the norm of the gradient is smaller
than eps.</p>
</td></tr>
<tr><td><code id="GPADF_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations allowed in the main loop.</p>
</td></tr>
<tr><td><code id="GPADF_+3A_method">method</code></td>
<td>
<p>rotation objective criterian.</p>
</td></tr>
<tr><td><code id="GPADF_+3A_methodargs">methodArgs</code></td>
<td>
<p>a list ofmethodArgs arguments passed to the rotation objective</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Derivative free gradient projection rotation optimization routines can be used to
rotate a loadings matrix. The rotation criteria in the <code>GPArotation</code> package
require a derivative to operate. In certain cases, the derivative is complex
or non-existent. The derivative free gradient projection method provides a numerical
alternative to the <code>GPArotation</code> package. 
The functions in the package <code>GPArotateDF</code> follow most of the functionality
and logic as in the <code>GPArotation</code> package. Please consult the documentation 
in <code>GPArotation</code> for further details. 
</p>
<p>The argument <code>method</code> can be used to specify a string indicating
the rotation objective. <code>GPFoblq</code> defaults to <code>"quartimin"</code> 
and <code>GPForth</code> defaults to <code>"varimax"</code>. Available rotation objective functions
include <code>"ff.bentler"</code>, <code>"ff.cf"</code>, <code>"ff.cubimax"</code>, <code>"ff.entropy"</code>, 
<code>"ff.fss"</code>, <code>"ff.geomin"</code>, <code>"ff.infomax"</code>, <code>"ff.oblimax"</code>,
<code>"ff.pst"</code>, <code>"ff.quartimax"</code>,<code>"ff.quartimin"</code>, <code>"ff.simplimax"</code>, 
<code>"ff.target"</code>, and <code>"ff.varimax"</code>. 
Most of the rotation criteria are avaible in the GPArotation pacakage 
except for <code>cubimax</code> and <code>Forced Simple Structure</code>.
</p>
<p>The rotation criteria are in the functions prefixed by &quot;ff.&quot; that are used 
in the actual function call. The <code>ff.*</code> function call
would typically not be used directly, but are needed for rotation. Since
these are illustrative of computation, these are all exported
from the package namespace. 
New criteria for use with derivative free GP rotation do require a function of the type
<code>ff.newCriterionName</code> that provides value for complexity <code>f</code>, and name of method.
</p>
<p>Some rotation criteria (including <code>"simplimax"</code>, <code>"pst"</code>, 
<code>"target"</code>, <code>"cf"</code>, <code>"fss"</code>) require one or more additional arguments. 
Check GPArotation documentation for details or see <code><a href="#topic+ff.fss">ff.fss</a></code>. 
</p>
<p>The argument normalize gives an indication of if and how any normalization should 
be done before rotation, and then undone after rotation. If normalize is FALSE 
(the default) no normalization is done. If normalize is TRUE then Kaiser normalization 
is done. (So squared row entries of normalized A sum to 1.0. This is sometimes 
called Horst normalization.) If normalize is a vector of length equal to the 
number of indicators (= number of rows of A) then the colums are divided by 
normalize before rotation and multiplied by normalize after rotation. 
If normalize is a function then it should take A as an argument and return a vector 
which is used like the vector above.
</p>


<h3>Value</h3>

<p>A GPArotation object which is a list with elements 
</p>
<table role = "presentation">
<tr><td><code>loadings</code></td>
<td>
<p>The rotated loadings, one column for each factor. If randomStarts
were requested then this is the rotated loadings matrix with the 
lowest criterion value.</p>
</td></tr>
<tr><td><code>Th</code></td>
<td>
<p>The rotation matrix, loadings %*% t(Th) = A.</p>
</td></tr>
<tr><td><code>Table</code></td>
<td>
<p>A matrix recording the iterations of the rotation optimization.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function.</p>
</td></tr>
<tr><td><code>orthogonal</code></td>
<td>
<p>A logical indicating if the rotation is orthogonal.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>A logical indicating if convergence was obtained.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>t(Th) %*% Th.  The covariance matrix of the rotated factors.
This will be the identity matrix for orthogonal
rotations so is omitted (NULL) for the result from GPForth.df.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>The gradient of the objective function at the rotated loadings.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich
with some R modifications by Paul Gilbert.</p>


<h3>References</h3>

<p>Jennrich, R.I. (2004). Derivative free gradient projection algorithms for rotation. 
<em>Psychometrika</em>, <b>69</b>, 475&ndash;480.
</p>
<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676&ndash;696.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cubimax.df">cubimax.df</a></code>
<code><a href="#topic+fssQ.df">fssQ.df</a></code>
<code><a href="#topic+fssT.df">fssT.df</a></code>
<code><a href="#topic+ff.bentler">ff.bentler</a></code>, 
<code><a href="#topic+ff.cf">ff.cf</a></code>, 
<code><a href="#topic+ff.cubimax">ff.cubimax</a></code>, 
<code><a href="#topic+ff.entropy">ff.entropy</a></code>,
<code><a href="#topic+ff.fss">ff.fss</a></code>, 
<code><a href="#topic+ff.geomin">ff.geomin</a></code>, 
<code><a href="#topic+ff.infomax">ff.infomax</a></code>, 
<code><a href="#topic+ff.oblimax">ff.oblimax</a></code>, 
<code><a href="#topic+ff.pst">ff.pst</a></code>,
<code><a href="#topic+ff.quartimax">ff.quartimax</a></code>,
<code><a href="#topic+ff.quartimin">ff.quartimin</a></code>, 
<code><a href="#topic+ff.simplimax">ff.simplimax</a></code>, 
<code><a href="#topic+ff.target">ff.target</a></code>, 
<code><a href="#topic+ff.varimax">ff.varimax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # GPRSorth and rotation name 
  data("Harman", package = "GPArotation")
  GPForth.df(Harman8, method = "quartimax")
  GPForth.df(Harman8, method = "cubimax")
  GPForth.df(Harman8, method = "varimax")
  GPFoblq.df(Harman8, method = "quartimin")

  # displaying results of factor analysis rotation output
  origdigits &lt;- options("digits")
  Abor.unrotated &lt;- factanal(factors = 2, covmat = ability.cov, rotation = "none")
  Abor &lt;- GPFoblq.df(loadings(Abor.unrotated), method = "quartimin")
  Abor
  print(Abor)
  print(Abor, Table = TRUE)
  print(Abor, digits = 2)
  summary(Abor)
  options(digits = origdigits$digits)
  </code></pre>

<hr>
<h2 id='rotationsDF'>Rotations</h2><span id='topic+rotationsDF'></span><span id='topic+cubimax.df'></span><span id='topic+fssQ.df'></span><span id='topic+fssT.df'></span>

<h3>Description</h3>

<p>Optimize factor loading rotation objective.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	cubimax.df(A, Tmat=diag(ncol(A)), normalize=FALSE, eps=1e-5, maxit=1000)
	fssQ.df(A, Tmat=diag(ncol(A)), kij=2, normalize=FALSE, eps=1e-5, maxit=1000)
	fssT.df(A, Tmat=diag(ncol(A)), kij=2, normalize=FALSE, eps=1e-5, maxit=1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotationsDF_+3A_a">A</code></td>
<td>
<p>an initial factor loadings matrix to be rotated.</p>
</td></tr>
<tr><td><code id="rotationsDF_+3A_tmat">Tmat</code></td>
<td>
<p>initial rotation matrix.</p>
</td></tr>
<tr><td><code id="rotationsDF_+3A_kij">kij</code></td>
<td>
<p>minimum additional number of forced simple structure loadings in a pair of factors.</p>
</td></tr>
<tr><td><code id="rotationsDF_+3A_normalize">normalize</code></td>
<td>
<p>parameter passed to optimization routine (<code>GPForth.df</code> or <code>GPFoblq.df</code>).</p>
</td></tr>
<tr><td><code id="rotationsDF_+3A_eps">eps</code></td>
<td>
<p>parameter passed to optimization routine (<code>GPForth.df</code> or <code>GPFoblq.df</code>).</p>
</td></tr>
<tr><td><code id="rotationsDF_+3A_maxit">maxit</code></td>
<td>
<p>parameter passed to optimization routine (<code>GPForth.df</code> or <code>GPFoblq.df</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions listed here optimize a rotation objective. They can be used directly or the
function name can be passed to factor analysis functions like <code>factanal</code>.  
</p>
<p>Available rotations are 
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code>cubimax.df</code>   </td><td style="text-align: left;"> orthogonal  </td><td style="text-align: left;">  Cubimax	</td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>fssQ.df</code> 	  </td><td style="text-align: left;"> oblique	   </td><td style="text-align: left;">  Forced Simple Structure (see Vignette)   </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>fssT.df</code> 	  </td><td style="text-align: left;"> orthogonal  </td><td style="text-align: left;">  Forced Simple Structure (see Vignette)   </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>

<p>The argument <code>kij</code> for Forced Simple Structure is the minimum number 
of forced simple structure loadings in a pair of factors, in addition to 
the number of factors itself. Meaningful values are integers (1, ..., items - factors )
</p>


<h3>Value</h3>

<p>A list (which includes elements used by <code>factanal</code>) with:
</p>
<table role = "presentation">
<tr><td><code>loadings</code></td>
<td>
<p>Lh from <code>GPForth.df</code> or <code>GPFoblq.df</code>.</p>
</td></tr> 
<tr><td><code>Th</code></td>
<td>
<p>Th from <code>GPForth.df</code> or <code>GPFoblq.df</code>.</p>
</td></tr>  
<tr><td><code>Table</code></td>
<td>
<p>Table from <code>GPForth.df</code> or <code>GPFoblq.df</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating the rotation objective function.</p>
</td></tr>
<tr><td><code>orthogonal</code></td>
<td>
<p>A logical indicating if the rotation is orthogonal.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Convergence indicator from <code>GPForth.df</code> or <code>GPFoblq.df</code>.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>t(Th) %*% Th.  The covariance matrix of the rotated factors.
This will be the identity matrix for orthogonal
rotations so is omitted (NULL) for the result from GPForth.df.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Coen A. Bernaards and Robert I. Jennrich</p>


<h3>References</h3>

<p>Bernaards, C.A. and Jennrich, R.I. (2005) Gradient Projection Algorithms 
and Software for Arbitrary Rotation Criteria in Factor Analysis. 
<em>Educational and Psychological Measurement</em>, <b>65</b>, 676&ndash;696.
</p>
<p>Jennrich, R.I. (2004) Derivative free gradient projection algorithms for rotation,
<em>Psychometrika</em>, <b>69</b>(3), 475&ndash;480.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GPForth.df">GPForth.df</a></code>, 
<code><a href="#topic+GPFoblq.df">GPFoblq.df</a></code>, 
<code><a href="#topic+ff.cubimax">ff.cubimax</a></code>, 
<code><a href="#topic+ff.fss">ff.fss</a></code>, 
<code><a href="stats.html#topic+factanal">factanal</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(ability.cov)
  x &lt;- factanal(factors = 3, covmat = ability.cov, rotation="none")
  fssT.df(x$loadings, kij = 2)
  fssQ.df(x$loadings, kij = 4)

  # 3 different methods
  data("WansbeekMeijer", package="GPArotation")
  fa.unrotated  &lt;- factanal(factors = 3, covmat=NetherlandsTV, rotation="none")
  #
  fa.varimax &lt;- GPForth.df(loadings(fa.unrotated), method = "varimax", normalize = TRUE)
  fa.cubimax &lt;- cubimax.df(loadings(fa.unrotated), normalize = TRUE)
  fa.quartimax &lt;- GPForth.df(loadings(fa.unrotated), method = "quartimax", normalize = TRUE)
  print(cbind(loadings(fa.varimax), loadings(fa.cubimax), loadings(fa.quartimax)), digits = 2)   
  </code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
