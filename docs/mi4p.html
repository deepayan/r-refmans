<!DOCTYPE html><html><head><title>Help for package mi4p</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mi4p}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check.conditions'><p>Check if the design is valid</p></a></li>
<li><a href='#check.design'><p>Check if the design is valid</p></a></li>
<li><a href='#datasim'><p>A single simulated dataset</p></a></li>
<li><a href='#eBayes.mod'><p>MI-aware Modifed eBayes Function</p></a></li>
<li><a href='#formatLimmaResult'><p>Format a Result from Limma</p></a></li>
<li><a href='#hid.ebayes'><p>MI-aware Modifed eBayes Function</p></a></li>
<li><a href='#limmaCompleteTest.mod'><p>Computes a hierarchical differential analysis</p></a></li>
<li><a href='#make.contrast'><p>Builds the contrast matrix</p></a></li>
<li><a href='#make.design'><p>Builds the design matrix</p></a></li>
<li><a href='#make.design.1'><p>Builds the design matrix for designs of level 1</p></a></li>
<li><a href='#make.design.2'><p>Builds the design matrix for designs of level 2</p></a></li>
<li><a href='#make.design.3'><p>Builds the design matrix for designs of level 3</p></a></li>
<li><a href='#meanImp_emmeans'><p>Multiple Imputation Estimate</p></a></li>
<li><a href='#mi4limma'><p>Differential analysis after multiple imputation</p></a></li>
<li><a href='#mi4p-package'><p>mi4p: Multiple imputation for proteomics</p></a></li>
<li><a href='#mm_peptides'><p>mm_peptides - peptide-level intensities for mouse</p></a></li>
<li><a href='#multi.impute'><p>Multiple imputation of quantitative proteomics datasets</p></a></li>
<li><a href='#MVgen'><p>Amputation of a dataset</p></a></li>
<li><a href='#norm.200.m100.sd1.vs.m200.sd1.list'><p>A list of simulated datasets.</p></a></li>
<li><a href='#proj_matrix'><p>Variance-Covariance Matrix Projection</p></a></li>
<li><a href='#protdatasim'><p>Data simulation function</p></a></li>
<li><a href='#qData'><p>Extract of the abundances of Exp1_R25_pept dataset</p></a></li>
<li><a href='#rubin1.all'><p>First Rubin rule (all peptides)</p></a></li>
<li><a href='#rubin1.one'><p>First Rubin rule (a given peptide)</p></a></li>
<li><a href='#rubin2.all'><p>Computes the 2nd Rubin's rule (all peptides)</p></a></li>
<li><a href='#rubin2bt.all'><p>2nd Rubin's rule Between-Imputation component (all peptides)</p></a></li>
<li><a href='#rubin2bt.one'><p>2nd Rubin's rule Between-Imputation Component (a given peptide)</p></a></li>
<li><a href='#rubin2wt.all'><p>2nd Rubin's rule Within-Variance Component (all peptides)</p></a></li>
<li><a href='#rubin2wt.one'><p>2nd Rubin's rule Within-Variance Component (a given peptide)</p></a></li>
<li><a href='#sTab'><p>Experimental design for the Exp1_R25_pept dataset</p></a></li>
<li><a href='#test.design'><p>Check if xxxxxx</p></a></li>
<li><a href='#within_variance_comp_emmeans'><p>Multiple Imputation Within Variance Component</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Imputation for Proteomics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-23</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>emmeans, foreach, imp4p, impute, limma, mice, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Biobase, knitr, R.rsp, markdown, prettydoc, rmarkdown, DAPAR,
ProteoMM</td>
</tr>
<tr>
<td>Author:</td>
<td>Marie Chion <a href="https://orcid.org/0000-0001-8956-8388"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Christine Carapito
    <a href="https://orcid.org/0000-0002-0079-319X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Frederic Bertrand <a href="https://orcid.org/0000-0002-0837-8281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Gordon Smyth [ctb],
  Davis McCarthy [ctb],
  Hélène Borges [ctb],
  Thomas Burger [ctb],
  Quentin Giai-Gianetto [ctb],
  Samuel Wieczorek [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederic Bertrand &lt;frederic.bertrand@utt.fr&gt;</td>
</tr>
<tr>
<td>Contact:</td>
<td>Marie Chion &lt;marie.chion@protonmail.fr&gt;, Frederic Bertrand
&lt;frederic.bertrand@utt.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for multiple imputation for proteomics is proposed by Marie Chion, Christine Carapito and Frederic Bertrand (2021) &lt;<a href="https://arxiv.org/abs/2108.07086">arXiv:2108.07086</a>&gt;. It is dedicated to dealing with multiple imputation for proteomics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See the file COPYRIGHTS</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Classification/MSC:</td>
<td>62J05, 62J07, 62J99, 92C42</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mariechion.github.io/mi4p/">https://mariechion.github.io/mi4p/</a>,
<a href="https://github.com/mariechion/mi4p/">https://github.com/mariechion/mi4p/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mariechion/mi4p/issues/">https://github.com/mariechion/mi4p/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-23 10:36:43 UTC; fbertran</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-23 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check.conditions'>Check if the design is valid</h2><span id='topic+check.conditions'></span>

<h3>Description</h3>

<p>This function checks the validity of the conditions.
</p>
<p>This function was included from the <code>check.conditions</code> 
function in the <code>DAPAR</code> package, since <code>DAPAR</code> was to be removed from 
Bioconductor &gt;= 3.15.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.conditions(conds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.conditions_+3A_conds">conds</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>


<h3>Author(s)</h3>

<p>Samuel Wieczorek as the author of 
<code>check.conditions</code> in the <code>DAPAR</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
utils::data(Exp1_R25_pept, package='DAPARdata')
check.conditions(Biobase::pData(Exp1_R25_pept)$Condition)

## End(Not run)

</code></pre>

<hr>
<h2 id='check.design'>Check if the design is valid</h2><span id='topic+check.design'></span>

<h3>Description</h3>

<p>This function checks the validity of the experimental design.
</p>
<p>This function was included from the <code>check.design</code> 
function in the <code>DAPAR</code> package, since <code>DAPAR</code> was to be removed from 
Bioconductor &gt;= 3.15.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.design(sTab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.design_+3A_stab">sTab</code></td>
<td>
<p>The data.frame which correspond to the pData function of MSnbase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean
</p>


<h3>Author(s)</h3>

<p>Thomas Burger, Quentin Giai-Gianetto, Samuel Wieczorek as 
the authors of <code>check.design</code> in the <code>DAPAR</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
utils::data(Exp1_R25_pept, package='DAPARdata')
check.design(Biobase::pData(Exp1_R25_pept)[,1:3])

## End(Not run)

</code></pre>

<hr>
<h2 id='datasim'>A single simulated dataset</h2><span id='topic+datasim'></span>

<h3>Description</h3>

<p>This dataset was simulated using the default values of the 
values of the options of the protdatasim function and the set.seed value set 
to 4619.
</p>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 11 variables.
</p>
 
<dl>
<dt>id.obs</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X1</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X2</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X3</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X4</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X5</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X6</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X7</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X8</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X9</dt><dd><p>a numeric vector</p>
</dd> 
<dt>X10</dt><dd><p>a numeric vector</p>
</dd> 
</dl>



<h3>Author(s)</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand.
</p>


<h3>Source</h3>

<p>We simulated the data.
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(datasim)
str(datasim)

</code></pre>

<hr>
<h2 id='eBayes.mod'>MI-aware Modifed eBayes Function</h2><span id='topic+eBayes.mod'></span>

<h3>Description</h3>

<p>Modified eBayes function to be used instead of the one in the limma package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eBayes.mod(
  fit,
  VarRubin,
  proportion = 0.01,
  stdev.coef.lim = c(0.1, 4),
  trend = FALSE,
  robust = FALSE,
  winsor.tail.p = c(0.05, 0.1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eBayes.mod_+3A_fit">fit</code></td>
<td>
<p>an MArrayLM fitted model object produced by lmFit or contrasts.fit. For ebayes only, fit can alternatively be an unclassed list produced by lm.series, gls.series or mrlm containing components coefficients, stdev.unscaled, sigma and df.residual.</p>
</td></tr>
<tr><td><code id="eBayes.mod_+3A_varrubin">VarRubin</code></td>
<td>
<p>a variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="eBayes.mod_+3A_proportion">proportion</code></td>
<td>
<p>numeric value between 0 and 1, assumed proportion of genes which are differentially expressed</p>
</td></tr>
<tr><td><code id="eBayes.mod_+3A_stdev.coef.lim">stdev.coef.lim</code></td>
<td>
<p>numeric vector of length 2, assumed lower and upper limits for the standard deviation of log2-fold-changes for differentially expressed genes</p>
</td></tr>
<tr><td><code id="eBayes.mod_+3A_trend">trend</code></td>
<td>
<p>logical, should an intensity-trend be allowed for the prior variance? Default is that the prior variance is constant.</p>
</td></tr>
<tr><td><code id="eBayes.mod_+3A_robust">robust</code></td>
<td>
<p>logical, should the estimation of df.prior and var.prior be robustified against outlier sample variances?</p>
</td></tr>
<tr><td><code id="eBayes.mod_+3A_winsor.tail.p">winsor.tail.p</code></td>
<td>
<p>numeric vector of length 1 or 2, giving left and right tail proportions of x to Winsorize. Used only when robust=TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eBayes produces an object of class MArrayLM (see MArrayLM-class) containing everything found in <code>fit</code> plus the following added components:
</p>
 
<dl>
<dt>t</dt><dd><p>numeric matrix of moderated t-statistics.</p>
</dd>
<dt>p.value</dt><dd><p>numeric matrix of two-sided p-values corresponding to the t-statistics.</p>
</dd>
<dt>lods</dt><dd><p>numeric matrix giving the log-odds of differential expression (on the natural log scale).</p>
</dd>
<dt>s2.prior</dt><dd><p>estimated prior value for sigma^2. A row-wise vector if covariate is non-NULL, otherwise a single value.</p>
</dd>
<dt>df.prior</dt><dd><p>degrees of freedom associated with s2.prior. A row-wise vector if robust=TRUE, otherwise a single value.</p>
</dd>
<dt>df.total</dt><dd><p>row-wise numeric vector giving the total degrees of freedom associated with the t-statistics for each gene. Equal to df.prior+df.residual or sum(df.residual), whichever is smaller.</p>
</dd>
<dt>s2.post</dt><dd><p>row-wise numeric vector giving the posterior values for sigma^2.</p>
</dd>
<dt>var.prior</dt><dd><p>column-wise numeric vector giving estimated prior values for the variance of the log2-fold-changes for differentially expressed gene for each constrast. Used for evaluating lods.</p>
</dd>
<dt>F</dt><dd><p>row-wise numeric vector of moderated F-statistics for testing all contrasts defined by the columns of fit simultaneously equal to zero.</p>
</dd>
<dt>F.p.value</dt><dd><p>row-wise numeric vector giving p-values corresponding to F.</p>
</dd>
</dl>

<p>The matrices t, p.value and lods have the same dimensions as the input object fit, with rows corresponding to genes and columns to coefficients or contrasts. The vectors s2.prior, df.prior, df.total, F and F.p.value correspond to rows, with length equal to the number of genes. The vector var.prior corresponds to columns, with length equal to the number of contrasts. If s2.prior or df.prior have length 1, then the same value applies to all genes.
</p>
<p>s2.prior, df.prior and var.prior contain empirical Bayes hyperparameters used to obtain df.total, s2.post and lods.
</p>


<h3>Author(s)</h3>

<p>Modified by M. Chion and F. Bertrand. Original by Gordon Smyth and Davis McCarthy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
VarRubin.matrix &lt;- rubin2.all(datasim_imp[1:5,,],
attr(datasim,"metadata")$Condition)
set.seed(2016)
sigma2 &lt;- 0.05 / rchisq(100, df=10) * 10
y &lt;- datasim_imp[,,1]
design &lt;- cbind(Intercept=1,Group=as.numeric(
attr(datasim,"metadata")$Condition)-1)
fit.model &lt;- limma::lmFit(y,design)
eBayes.mod(fit=fit.model,VarRubin.matrix[[1]])
</code></pre>

<hr>
<h2 id='formatLimmaResult'>Format a Result from Limma</h2><span id='topic+formatLimmaResult'></span>

<h3>Description</h3>

<p>It is not exported by <code>DAPAR</code> and has to be reproduced here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatLimmaResult(fit, conds, contrast)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatLimmaResult_+3A_fit">fit</code></td>
<td>
<p>Limma fit</p>
</td></tr>
<tr><td><code id="formatLimmaResult_+3A_conds">conds</code></td>
<td>
<p>Condition vector</p>
</td></tr>
<tr><td><code id="formatLimmaResult_+3A_contrast">contrast</code></td>
<td>
<p>Contrast vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two dataframes : logFC and P_Value. The first one contains the logFC values of all the comparisons (one column for one comparison), the second one contains the pvalue of all the comparisons (one column for one comparison). The names of the columns for those two dataframes are identical and correspond to the description of the comparison.
</p>


<h3>Author(s)</h3>

<p>Adapted from the code of Samuel Wieczorek in the <code>DAPAR</code> package as it is an object that is not exported by the <code>DAPAR</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># library(DAPAR)
set.seed(2016)
data(qData)
data(sTab)
contrast=1
sTab.old &lt;- sTab
conds &lt;- factor(sTab$Condition, levels = unique(sTab$Condition))
sTab &lt;- sTab[unlist(lapply(split(sTab, conds), function(x) {
  x["Sample.name"]
})), ]
qData &lt;- qData[, unlist(lapply(split(sTab.old, conds), function(x) {
  x["Sample.name"]
}))]
conds &lt;- conds[order(conds)]
res.l &lt;- NULL
design.matrix &lt;- mi4p::make.design(sTab)
contra &lt;- mi4p::make.contrast(design.matrix, condition = conds, 
                                 contrast)
cmtx &lt;- limma::makeContrasts(contrasts = contra, levels = make.names(colnames(design.matrix)))
fit &lt;- limma::eBayes(limma::contrasts.fit(limma::lmFit(qData, 
                                                      design.matrix), cmtx))
res.l &lt;- mi4p::formatLimmaResult(fit, conds, contrast)
</code></pre>

<hr>
<h2 id='hid.ebayes'>MI-aware Modifed eBayes Function</h2><span id='topic+hid.ebayes'></span>

<h3>Description</h3>

<p>Modified eBayes function to be used instead of the one, <code>.ebayes</code>, implemented in the limma package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hid.ebayes(
  fit,
  VarRubin,
  mod = TRUE,
  proportion = 0.01,
  stdev.coef.lim = c(0.1, 4),
  trend = FALSE,
  robust = FALSE,
  winsor.tail.p = c(0.05, 0.1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hid.ebayes_+3A_fit">fit</code></td>
<td>
<p>an MArrayLM fitted model object produced by lmFit or contrasts.fit. For ebayes only, fit can alternatively be an unclassed list produced by lm.series, gls.series or mrlm containing components coefficients, stdev.unscaled, sigma and df.residual.</p>
</td></tr>
<tr><td><code id="hid.ebayes_+3A_varrubin">VarRubin</code></td>
<td>
<p>a variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="hid.ebayes_+3A_mod">mod</code></td>
<td>
<p>TRUE (not used at the moment)</p>
</td></tr>
<tr><td><code id="hid.ebayes_+3A_proportion">proportion</code></td>
<td>
<p>numeric value between 0 and 1, assumed proportion of genes which are differentially expressed</p>
</td></tr>
<tr><td><code id="hid.ebayes_+3A_stdev.coef.lim">stdev.coef.lim</code></td>
<td>
<p>numeric vector of length 2, assumed lower and upper limits for the standard deviation of log2-fold-changes for differentially expressed genes</p>
</td></tr>
<tr><td><code id="hid.ebayes_+3A_trend">trend</code></td>
<td>
<p>logical, should an intensity-trend be allowed for the prior variance? Default is that the prior variance is constant.</p>
</td></tr>
<tr><td><code id="hid.ebayes_+3A_robust">robust</code></td>
<td>
<p>logical, should the estimation of df.prior and var.prior be robustified against outlier sample variances?</p>
</td></tr>
<tr><td><code id="hid.ebayes_+3A_winsor.tail.p">winsor.tail.p</code></td>
<td>
<p>numeric vector of length 1 or 2, giving left and right tail proportions of x to Winsorize. Used only when robust=TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eBayes produces an object of class MArrayLM (see MArrayLM-class) containing everything found in <code>fit</code> plus the following added components:
</p>
 
<dl>
<dt>t</dt><dd><p>numeric matrix of moderated t-statistics.</p>
</dd>
<dt>p.value</dt><dd><p>numeric matrix of two-sided p-values corresponding to the t-statistics.</p>
</dd>
<dt>lods</dt><dd><p>numeric matrix giving the log-odds of differential expression (on the natural log scale).</p>
</dd>
<dt>s2.prior</dt><dd><p>estimated prior value for sigma^2. A row-wise vector if covariate is non-NULL, otherwise a single value.</p>
</dd>
<dt>df.prior</dt><dd><p>degrees of freedom associated with s2.prior. A row-wise vector if robust=TRUE, otherwise a single value.</p>
</dd>
<dt>df.total</dt><dd><p>row-wise numeric vector giving the total degrees of freedom associated with the t-statistics for each gene. Equal to df.prior+df.residual or sum(df.residual), whichever is smaller.</p>
</dd>
<dt>s2.post</dt><dd><p>row-wise numeric vector giving the posterior values for sigma^2.</p>
</dd>
<dt>var.prior</dt><dd><p>column-wise numeric vector giving estimated prior values for the variance of the log2-fold-changes for differentially expressed gene for each constrast. Used for evaluating lods.</p>
</dd>
<dt>F</dt><dd><p>row-wise numeric vector of moderated F-statistics for testing all contrasts defined by the columns of fit simultaneously equal to zero.</p>
</dd>
<dt>F.p.value</dt><dd><p>row-wise numeric vector giving p-values corresponding to F.</p>
</dd>
</dl>

<p>The matrices t, p.value and lods have the same dimensions as the input object fit, with rows corresponding to genes and columns to coefficients or contrasts. The vectors s2.prior, df.prior, df.total, F and F.p.value correspond to rows, with length equal to the number of genes. The vector var.prior corresponds to columns, with length equal to the number of contrasts. If s2.prior or df.prior have length 1, then the same value applies to all genes.
</p>
<p>s2.prior, df.prior and var.prior contain empirical Bayes hyperparameters used to obtain df.total, s2.post and lods.
</p>


<h3>Author(s)</h3>

<p>Modified by M. Chion and F. Bertrand. Original by Gordon Smyth and Davis McCarthy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
VarRubin.matrix &lt;- rubin2.all(datasim_imp[1:5,,],
attr(datasim,"metadata")$Condition)
set.seed(2016)
sigma2 &lt;- 0.05 / rchisq(100, df=10) * 10
y &lt;- datasim_imp[,,1]
design &lt;- cbind(Intercept=1,Group=as.numeric(
attr(datasim,"metadata")$Condition)-1)
fit.model &lt;- limma::lmFit(y,design)
hid.ebayes(fit=fit.model,VarRubin.matrix[[1]])
</code></pre>

<hr>
<h2 id='limmaCompleteTest.mod'>Computes a hierarchical differential analysis</h2><span id='topic+limmaCompleteTest.mod'></span>

<h3>Description</h3>

<p>Modified version of the <code>limmaCompleteTest</code> function from the <code>DAPAR</code> package to return both the fit and the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limmaCompleteTest.mod(qData, sTab, comp.type = "OnevsOne")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limmaCompleteTest.mod_+3A_qdata">qData</code></td>
<td>
<p>A matrix of quantitative data, without any missing values.</p>
</td></tr>
<tr><td><code id="limmaCompleteTest.mod_+3A_stab">sTab</code></td>
<td>
<p>A dataframe of experimental design (<code>pData()</code>).</p>
</td></tr>
<tr><td><code id="limmaCompleteTest.mod_+3A_comp.type">comp.type</code></td>
<td>
<p>A string that corresponds to the type of comparison. Values are: 'anova1way', 'OnevsOne' and 'OnevsAll'; default is 'OnevsOne'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two dataframes : logFC and P_Value. The first one contains the logFC values of all the comparisons (one column for one comparison), the second one contains the pvalue of all the comparisons (one column for one comparison). The names of the columns for those two dataframes are identical and correspond to the description of the comparison.
</p>


<h3>Author(s)</h3>

<p>Adapted from Hélène Borges, Thomas Burger, Quentin Giai-Gianetto, Samuel Wieczorek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016)
data(qData)
data(sTab)
limma &lt;- limmaCompleteTest.mod(qData, sTab, comp.type='OnevsOne')
</code></pre>

<hr>
<h2 id='make.contrast'>Builds the contrast matrix</h2><span id='topic+make.contrast'></span>

<h3>Description</h3>

<p>This function builds the contrast matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.contrast(design, condition, contrast = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.contrast_+3A_design">design</code></td>
<td>
<p>The data.frame which correspond to the pData function of 
MSnbase</p>
</td></tr>
<tr><td><code id="make.contrast_+3A_condition">condition</code></td>
<td>
<p>xxxxx</p>
</td></tr>
<tr><td><code id="make.contrast_+3A_contrast">contrast</code></td>
<td>
<p>An integer that Indicates if the test consists of the 
comparison of each biological condition versus each of the other ones 
(Contrast=1; for example H0:&quot;C1=C2&quot; vs H1:&quot;C1!=C2&quot;, etc.) 
or each condition versus all others (Contrast=2; e.g.  H0:&quot;C1=(C2+C3)/2&quot; vs
H1:&quot;C1!=(C2+C3)/2&quot;, etc. if there are three conditions).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A constrat matrix
</p>


<h3>Author(s)</h3>

<p>Thomas Burger, Quentin Giai-Gianetto, Samuel Wieczorek originally in 
the <code>DAPAR</code> package. Included in this package since <code>DAPAR</code> was to be removed from 
Bioconductor &gt;= 3.15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
utils::data(Exp1_R25_pept, package='DAPARdata')
design &lt;- make.design(Biobase::pData(Exp1_R25_pept))
conds &lt;- Biobase::pData(Exp1_R25_pept)$Condition
make.contrast(design, conds)

## End(Not run)

</code></pre>

<hr>
<h2 id='make.design'>Builds the design matrix</h2><span id='topic+make.design'></span>

<h3>Description</h3>

<p>This function builds the design matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.design(sTab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.design_+3A_stab">sTab</code></td>
<td>
<p>The data.frame which correspond to the pData function of MSnbase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design matrix
</p>


<h3>Author(s)</h3>

<p>Thomas Burger, Quentin Giai-Gianetto, Samuel Wieczorek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
utils::data(Exp1_R25_pept, package='DAPARdata')
make.design(Biobase::pData(Exp1_R25_pept))

## End(Not run)

</code></pre>

<hr>
<h2 id='make.design.1'>Builds the design matrix for designs of level 1</h2><span id='topic+make.design.1'></span>

<h3>Description</h3>

<p>This function builds the design matrix for design of level 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.design.1(sTab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.design.1_+3A_stab">sTab</code></td>
<td>
<p>The data.frame which correspond to the pData function of MSnbase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design matrix
</p>


<h3>Author(s)</h3>

<p>Thomas Burger, Quentin Giai-Gianetto, Samuel Wieczorek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
utils::data(Exp1_R25_pept, package='DAPARdata')
make.design.1(Biobase::pData(Exp1_R25_pept))

## End(Not run)

</code></pre>

<hr>
<h2 id='make.design.2'>Builds the design matrix for designs of level 2</h2><span id='topic+make.design.2'></span>

<h3>Description</h3>

<p>This function builds the design matrix for design of level 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.design.2(sTab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.design.2_+3A_stab">sTab</code></td>
<td>
<p>The data.frame which correspond to the pData function of MSnbase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design matrix
</p>


<h3>Author(s)</h3>

<p>Thomas Burger, Quentin Giai-Gianetto, Samuel Wieczorek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
utils::data(Exp1_R25_pept, package='DAPARdata')
make.design.2(Biobase::pData(Exp1_R25_pept))

## End(Not run)

</code></pre>

<hr>
<h2 id='make.design.3'>Builds the design matrix for designs of level 3</h2><span id='topic+make.design.3'></span>

<h3>Description</h3>

<p>This function builds the design matrix for design of level 3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.design.3(sTab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.design.3_+3A_stab">sTab</code></td>
<td>
<p>The data.frame which correspond to the pData function of MSnbase</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design matrix
</p>


<h3>Author(s)</h3>

<p>Thomas Burger, Quentin Giai-Gianetto, Samuel Wieczorek originally in 
the DAPAR package. Included in this package since DAPAR was to be removed from 
Bioconductor &gt;= 3.15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
utils::data(Exp1_R25_pept, package='DAPARdata')
sTab &lt;-cbind(Biobase::pData(Exp1_R25_pept), Tech.Rep=1:6)
make.design.3(sTab)

## End(Not run)

</code></pre>

<hr>
<h2 id='meanImp_emmeans'>Multiple Imputation Estimate</h2><span id='topic+meanImp_emmeans'></span>

<h3>Description</h3>

<p>Computes the multiple imputation parameter estimate using the emmeans package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanImp_emmeans(ind, peptide = 1, tabdata, metacond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanImp_emmeans_+3A_ind">ind</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id="meanImp_emmeans_+3A_peptide">peptide</code></td>
<td>
<p>name of the peptide</p>
</td></tr>
<tr><td><code id="meanImp_emmeans_+3A_tabdata">tabdata</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="meanImp_emmeans_+3A_metacond">metacond</code></td>
<td>
<p>a factor to specify the groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
meanImp_emmeans(1,1,datasim_imp,attr(datasim,"metadata")$Condition)
</code></pre>

<hr>
<h2 id='mi4limma'>Differential analysis after multiple imputation</h2><span id='topic+mi4limma'></span>

<h3>Description</h3>

<p>This function performs hierarchical differential analysis using a moderated 
t-test statistic, which accounts for multiple imputation variability if 
applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi4limma(qData, sTab, VarRubin, comp.type = "OnevsOne", robust = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi4limma_+3A_qdata">qData</code></td>
<td>
<p>A matrix of quantitative data, without any missing values. It 
should be the averaged matrix from the array resulting from 
<code><a href="#topic+multi.impute">multi.impute</a></code>.</p>
</td></tr>
<tr><td><code id="mi4limma_+3A_stab">sTab</code></td>
<td>
<p>The experimental matrix, also corresponding to the pData function 
of MSnbase.</p>
</td></tr>
<tr><td><code id="mi4limma_+3A_varrubin">VarRubin</code></td>
<td>
<p>A numerical vector, resulting from <code><a href="#topic+proj_matrix">proj_matrix</a></code>.
It denotes the vector of projected variance-covariance matrices. It should be
of length the number of peptides or proteins considered.</p>
</td></tr>
<tr><td><code id="mi4limma_+3A_comp.type">comp.type</code></td>
<td>
<p>A string that corresponds to the type of comparison. Values 
are: 'anova1way', 'OnevsOne' and 'OnevsAll'; default is 'OnevsOne'.</p>
</td></tr>
<tr><td><code id="mi4limma_+3A_robust">robust</code></td>
<td>
<p>logical, should the estimation of df.prior and var.prior be 
robustified against outlier sample variances? (as in limma's eBayes)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two dataframes : logFC and P_Value. The first one contains 
the logFC values of all the comparisons (one column for one comparison), the 
second one contains the pvalue of all the comparisons (one column for one 
comparison). The names of the columns for those two dataframes are identical 
and correspond to the description of the comparison.
</p>


<h3>Author(s)</h3>

<p>Adapted by Marie Chion, from <code>limmaCompleteTest</code> of the 
<code>DAPAR</code> package by Hélène Borges, Thomas Burger, 
Quentin Giai-Gianetto and Samuel Wieczorek.
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting 
for multiple imputation-induced variability for differential analysis in 
mass spectrometry-based label-free quantitative proteomics</em>. 
arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2016)
data(qData)
data(sTab)
fit.limma &lt;- mi4limma(qData, sTab, diag(1,2))
</code></pre>

<hr>
<h2 id='mi4p-package'>mi4p: Multiple imputation for proteomics</h2><span id='topic+mi4p-package'></span><span id='topic+mi4p'></span>

<h3>Description</h3>

<p>Imputing missing values is common practice in label-free quantitative 
proteomics. Imputation replaces a missing value by a user-defined one. 
However, the imputation itself is not optimally considered downstream of the
imputation process. In particular, imputed datasets are considered as if 
they had always been complete. The uncertainty due to the imputation is not 
properly taken into account. Hence, the mi4p package provides a more 
accurate statistical analysis of multiple-imputed datasets. A rigorous 
multiple imputation methodology is implemented, leading to a less biased 
estimation of parameters and their variability thanks to Rubin’s rules. The
imputation-based peptide’s intensities’ variance estimator is then moderated 
using Bayesian hierarchical models. This estimator is finally included in 
moderated t-test statistics to provide differential analyses results.
</p>


<h3>Author(s)</h3>

<p>This package has been written by Marie Chion, Christine Carapito and 
Frederic Bertrand.  
Maintainer: &lt;frederic.bertrand@utt.fr&gt;
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple 
imputation-induced variability for differential analysis in mass 
spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. 
<a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>
<p>M. Chion, Ch. Carapito, F. Bertrand. Towards a more accurate differential 
analysis of multiple imputed proteomics data with mi4limma. Statistical 
Analysis of Proteomic Data: Methods and Tools, 2022. hal-03442944
<a href="https://hal.archives-ouvertes.fr/hal-03442944">https://hal.archives-ouvertes.fr/hal-03442944</a>
</p>

<hr>
<h2 id='mm_peptides'>mm_peptides - peptide-level intensities for mouse</h2><span id='topic+mm_peptides'></span>

<h3>Description</h3>

<p>A dataset containing the protein and petide information and peptide-level
intensities for 6 samples: 3 CG and 3 mCG groups. There are 69 proteins.
The columns are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mm_peptides)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1102 rows and 13 colummns, compiring 7 columns of
metadata and 6 columns of peptide intensities. 69 proteins.
</p>


<h3>Details</h3>


<ul>
<li><p> Sequence - peptide sequence - randomly chosen from a larger list of
sequences
</p>
</li>
<li><p> MatchedID - numeric ID that links proteins in the two datasets,
unnecessary if datasets are for the same species
</p>
</li>
<li><p> ProtID - protein ID, artificial protein ID, eg. Prot1, Prot2, ...
</p>
</li>
<li><p> GeneID - gene ID, artificial gene ID, eg. Gene1, Gene2, ...
</p>
</li>
<li><p> ProtName - artificial Protein Name
</p>
</li>
<li><p> ProtIDLong - long protein ID, full protein name, here artificially
simulated
</p>
</li>
<li><p> GeneIDLong - long gene ID, full gene name, here artificially
simulated
</p>
</li>
<li><p> CG1 - raw intensity column for sample 1 in CG group
</p>
</li>
<li><p> CG2 - raw intensity column for sample 2 in CG group
</p>
</li>
<li><p> CG3 - raw intensity column for sample 3 in CG group
</p>
</li>
<li><p> mCG1 - raw intensity column for sample 1 in mCG group
</p>
</li>
<li><p> mCG2 - raw intensity column for sample 2 in mCG group
</p>
</li>
<li><p> mCG3 - raw intensity column for sample 3 in mCG group
</p>
</li></ul>


<hr>
<h2 id='multi.impute'>Multiple imputation of quantitative proteomics datasets</h2><span id='topic+multi.impute'></span>

<h3>Description</h3>

<p><code><a href="#topic+multi.impute">multi.impute</a></code> performs multiple imputation on a
given quantitative proteomics dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi.impute(data, conditions, nb.imp = NULL, method, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi.impute_+3A_data">data</code></td>
<td>
<p>A quantitative matrix to be imputed, with proteins/peptides in
rows and samples in columns.</p>
</td></tr>
<tr><td><code id="multi.impute_+3A_conditions">conditions</code></td>
<td>
<p>A vector of length the number of samples where each element
corresponds to the condition the sample belongs to.</p>
</td></tr>
<tr><td><code id="multi.impute_+3A_nb.imp">nb.imp</code></td>
<td>
<p>The number of imputation to perform.</p>
</td></tr>
<tr><td><code id="multi.impute_+3A_method">method</code></td>
<td>
<p>A single character string describing the imputation method to 
be used. See details.</p>
</td></tr>
<tr><td><code id="multi.impute_+3A_parallel">parallel</code></td>
<td>
<p>Logical, whether or not use parallel computing
(with <code><a href="foreach.html#topic+foreach">foreach</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple imputation consists in imputing several times a given
dataset using a given method. Here, imputation methods can be chosen either 
from <code><a href="mice.html#topic+mice">mice</a></code>, <code><a href="imp4p.html#topic+imp4p-package">imp4p-package</a></code> or 
<code><a href="impute.html#topic+impute.knn">impute.knn</a></code>:
</p>

<ul>
<li><p> &quot;pmm&quot;, &quot;midastouch&quot;, &quot;sample&quot;, &quot;cart&quot;, &quot;rf&quot;,&quot;mean&quot;, &quot;norm&quot;, 
&quot;norm.nob&quot;, &quot;norm.boot&quot;, &quot;norm.predict&quot;: imputation methods as described 
in <code><a href="mice.html#topic+mice">mice</a></code>.
</p>
</li>
<li><p> &quot;RF&quot; imputes missing values using random forests algorithm as 
described in <code><a href="imp4p.html#topic+impute.RF">impute.RF</a></code>.
</p>
</li>
<li><p> &quot;MLE&quot; imputes missing values using maximum likelihood estimation
as described in <code><a href="imp4p.html#topic+impute.mle">impute.mle</a></code>.
</p>
</li>
<li><p> &quot;PCA&quot; imputes missing values using principal component analysis as 
described in <code><a href="imp4p.html#topic+impute.PCA">impute.PCA</a></code>.
</p>
</li>
<li><p> &quot;SLSA&quot; imputes missing values using structured least squares 
algorithm as described in <code><a href="imp4p.html#topic+impute.slsa">impute.slsa</a></code>.
</p>
</li>
<li><p> &quot;kNN&quot; imputes missing values using k nearest neighbors as 
described in <code><a href="impute.html#topic+impute.knn">impute.knn</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric array of dimension c(dim(data),nb.imp).
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple 
imputation-induced variability for differential analysis in mass 
spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. 
<a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
multi.impute(data = datasim[,-1], conditions = attr(datasim,"metadata")$Condition, method = "MLE")
</code></pre>

<hr>
<h2 id='MVgen'>Amputation of a dataset</h2><span id='topic+MVgen'></span>

<h3>Description</h3>

<p>This function is designed to ampute datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVgen(dataset, prop_NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVgen_+3A_dataset">dataset</code></td>
<td>
<p>dataset to be amputed</p>
</td></tr>
<tr><td><code id="MVgen_+3A_prop_na">prop_NA</code></td>
<td>
<p>desired proportion of missing values in the amputed dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataset with missing values.
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_amp &lt;- MVgen(datasim, .2)
sum(is.na(datasim_amp))/prod(dim(datasim_amp))
</code></pre>

<hr>
<h2 id='norm.200.m100.sd1.vs.m200.sd1.list'>A list of simulated datasets.</h2><span id='topic+norm.200.m100.sd1.vs.m200.sd1.list'></span>

<h3>Description</h3>

<p>This list of 100 datasets was simulated using the default 
values of the options of the protdatasim function and the set.seed value set 
to 4619.
</p>


<h3>Format</h3>

<p>The format is: List of 100 data.frames.
</p>
 
<dl>
<dt>data.frame</dt><dd><p>200 obs. of 11 variables
</p>
 
<dl>
<dt>id.obs</dt><dd><p>int [1:200] 1 2 3 4 5 6 7 8 9 10 ...</p>
</dd>  
<dt>X1</dt><dd><p>num [1:200] 99.6 99.9 100.2 99.8 100.4 ...</p>
</dd>  
<dt>X2</dt><dd><p>num [1:200] 97.4 101.3 100.3 100.2 101.7 ...</p>
</dd>  
<dt>X3</dt><dd><p>num [1:200] 100.3 100.9 99.1 101.2 100.6 ...</p>
</dd>
<dt>X4</dt><dd><p>num [1:200] 99.4 99.2 98.5 99.1 99.5 ...</p>
</dd>  
<dt>X5</dt><dd><p>num [1:200] 98.5 99.7 100 100.2 100.7 ...</p>
</dd>  
<dt>X6</dt><dd><p>num [1:200] 200 199 199 200 199 ...</p>
</dd>  
<dt>X7</dt><dd><p>num [1:200] 200 200 202 199 199 ...</p>
</dd>  
<dt>X8</dt><dd><p>num [1:200] 202 199 200 199 201 ...</p>
</dd>  
<dt>X9</dt><dd><p>num [1:200] 200 200 199 201 200 ...</p>
</dd>  
<dt>X10</dt><dd><p>num [1:200] 200 198 200 201 199 ...</p>
</dd>
</dl>
</dd>
<dt>attr(*, &quot;metadata&quot;)</dt><dd><p>'data.frame': 10 obs. of 3 variables:
</p>
 
<dl>
<dt>Sample.name</dt><dd><p>chr [1:10] &quot;X1&quot; &quot;X2&quot; &quot;X3&quot; &quot;X4&quot; ...</p>
</dd>
<dt>Condition</dt><dd><p>Factor w/ 2 levels &quot;A&quot;,&quot;B&quot;: 1 1 1 1 1 2 2 2 2 2</p>
</dd> 
<dt>Bio.Rep</dt><dd><p>int [1:10] 1 2 3 4 5 6 7 8 9 10</p>
</dd>
</dl>
</dd>
<dt>...</dt><dd><p>...</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand.
</p>


<h3>Source</h3>

<p>We simulated the data.
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(norm.200.m100.sd1.vs.m200.sd1.list)
str(norm.200.m100.sd1.vs.m200.sd1.list)

</code></pre>

<hr>
<h2 id='proj_matrix'>Variance-Covariance Matrix Projection</h2><span id='topic+proj_matrix'></span>

<h3>Description</h3>

<p>Use a projection of the given variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_matrix(VarRubin.matrix, metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj_matrix_+3A_varrubin.matrix">VarRubin.matrix</code></td>
<td>
<p>A variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="proj_matrix_+3A_metadata">metadata</code></td>
<td>
<p>Metadata of the experiment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of variance-covariance matrices.
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
VarRubin.matrix &lt;- rubin2.all(datasim_imp[1:5,,],
attr(datasim,"metadata")$Condition)
proj_matrix(VarRubin.matrix, attr(datasim,"metadata"))
</code></pre>

<hr>
<h2 id='protdatasim'>Data simulation function</h2><span id='topic+protdatasim'></span>

<h3>Description</h3>

<p>Function to simulate benchmark datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protdatasim(
  iii = 1,
  nobs = 200,
  nobs1 = 10,
  ng1 = 5,
  ng2 = 5,
  mg1 = 100,
  mg2 = 200,
  dispg1 = 1,
  dispg2 = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protdatasim_+3A_iii">iii</code></td>
<td>
<p>A parameter useful to loop over for simulated lists of datasets. It has no effect.</p>
</td></tr>
<tr><td><code id="protdatasim_+3A_nobs">nobs</code></td>
<td>
<p>Number of peptides</p>
</td></tr>
<tr><td><code id="protdatasim_+3A_nobs1">nobs1</code></td>
<td>
<p>Number of peptides with differential expressions between the two conditions</p>
</td></tr>
<tr><td><code id="protdatasim_+3A_ng1">ng1</code></td>
<td>
<p>Number of biological replicates in condition A</p>
</td></tr>
<tr><td><code id="protdatasim_+3A_ng2">ng2</code></td>
<td>
<p>Number of biological replicates in condition B</p>
</td></tr>
<tr><td><code id="protdatasim_+3A_mg1">mg1</code></td>
<td>
<p>Mean in condition A</p>
</td></tr>
<tr><td><code id="protdatasim_+3A_mg2">mg2</code></td>
<td>
<p>Mean in condition B</p>
</td></tr>
<tr><td><code id="protdatasim_+3A_dispg1">dispg1</code></td>
<td>
<p>Dispersion in condition A</p>
</td></tr>
<tr><td><code id="protdatasim_+3A_dispg2">dispg2</code></td>
<td>
<p>Dispersion in condition B</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the simulated and attribute metadata.
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_sim &lt;- protdatasim()
attr(data_sim,"metadata")

norm.200.m100.sd1.vs.m200.sd1_list &lt;- lapply(1:100, protdatasim)
attr(norm.200.m100.sd1.vs.m200.sd1_list[[1]],"metadata")

</code></pre>

<hr>
<h2 id='qData'>Extract of the abundances of Exp1_R25_pept dataset</h2><span id='topic+qData'></span>

<h3>Description</h3>

<p>The data frame <code>qData</code> contains the first 500 rows of six columns that are the quantitation of peptides for the six replicates. They were obtained using the code <code>exprs(Exp1_R25_pept)[1:500,]</code>.
</p>


<h3>Format</h3>

<p>The format is: num [1:500, 1:6] 24.8 24.7 24.6 NA 24.5 ...  -
attr(*, &quot;dimnames&quot;)=List of 2 ..$ : chr [1:500] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; ...  ..$ :
chr [1:6] &quot;Intensity_C_R1&quot; &quot;Intensity_C_R2&quot; &quot;Intensity_C_R3&quot;
&quot;Intensity_D_R1&quot; ...
</p>


<h3>Details</h3>

<p>The <code>DAPARdata</code>'s <code>Exp1_R25_pept</code> dataset is the final outcome of a quantitative mass spectrometry-based proteomic analysis of two samples containing different concentrations of 48 human proteins (UPS1 standard from Sigma-Aldrich) within a constant yeast background (see Giai Gianetto et al. (2016) for details). It contains the abundance values of the different human and yeast peptides identified and quantified in these two conditions. The two conditions represent the measured abundances of peptides when respectively 25 fmol and 10 fmol of UPS1 human proteins were mixed with the yeast extract before mass spectrometry analyses. This results in a concentration ratio of 2.5. Three technical replicates were acquired for each condition.
</p>


<h3>Source</h3>

<p>The <code>DAPARdata</code> package.
</p>


<h3>References</h3>

<p>Cox J., Hein M.Y., Luber C.A., Paron I., Nagaraj N., Mann M. Accurate proteome-wide label-free quantification by delayed normalization and maximal peptide ratio extraction, termed MaxLFQ. Mol Cell Proteomics. 2014 Sep, 13(9):2513-26.
</p>
<p>Giai Gianetto, Q., Combes, F., Ramus, C., Bruley, C., Coute, Y., Burger, T. (2016). Calibration plot for proteomics: A graphical tool to visually check the assumptions underlying FDR control in quantitative experiments. Proteomics, 16(1), 29-32.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(qData)
str(qData)
pairs(qData)
 
</code></pre>

<hr>
<h2 id='rubin1.all'>First Rubin rule (all peptides)</h2><span id='topic+rubin1.all'></span>

<h3>Description</h3>

<p>Computes the first Rubin's rule for all the peptides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rubin1.all(
  data,
  metacond,
  funcmean = meanImp_emmeans,
  is.parallel = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rubin1.all_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="rubin1.all_+3A_metacond">metacond</code></td>
<td>
<p>a factor to specify the groups</p>
</td></tr>
<tr><td><code id="rubin1.all_+3A_funcmean">funcmean</code></td>
<td>
<p>function that should be used to compute the mean</p>
</td></tr>
<tr><td><code id="rubin1.all_+3A_is.parallel">is.parallel</code></td>
<td>
<p>Logical, whether or not use parallel computing
(with <code><a href="foreach.html#topic+foreach">foreach</a></code>).</p>
</td></tr>
<tr><td><code id="rubin1.all_+3A_verbose">verbose</code></td>
<td>
<p>Logical, should messages be displayed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimated parameters.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
rubin1.all(datasim_imp[1:5,,],funcmean = meanImp_emmeans,
attr(datasim,"metadata")$Condition)
</code></pre>

<hr>
<h2 id='rubin1.one'>First Rubin rule (a given peptide)</h2><span id='topic+rubin1.one'></span>

<h3>Description</h3>

<p>Computes the first Rubin's rule for a given peptide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rubin1.one(peptide, data, funcmean = meanImp_emmeans, metacond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rubin1.one_+3A_peptide">peptide</code></td>
<td>
<p>peptide for which the variance-covariance matrix should be 
derived.</p>
</td></tr>
<tr><td><code id="rubin1.one_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="rubin1.one_+3A_funcmean">funcmean</code></td>
<td>
<p>function that should be used to compute the mean</p>
</td></tr>
<tr><td><code id="rubin1.one_+3A_metacond">metacond</code></td>
<td>
<p>a factor to specify the groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimated parameters.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting 
for multiple imputation-induced variability for differential analysis in mass
spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. 
<a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
rubin1.one(1,datasim_imp,funcmean = meanImp_emmeans,
attr(datasim,"metadata")$Condition)
</code></pre>

<hr>
<h2 id='rubin2.all'>Computes the 2nd Rubin's rule (all peptides)</h2><span id='topic+rubin2.all'></span>

<h3>Description</h3>

<p>Computes the total variance-covariance component in the 2nd Rubin's rule for all peptides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rubin2.all(
  data,
  metacond,
  funcmean = meanImp_emmeans,
  funcvar = within_variance_comp_emmeans,
  is.parallel = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rubin2.all_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="rubin2.all_+3A_metacond">metacond</code></td>
<td>
<p>a factor to specify the groups</p>
</td></tr>
<tr><td><code id="rubin2.all_+3A_funcmean">funcmean</code></td>
<td>
<p>function that should be used to compute the mean</p>
</td></tr>
<tr><td><code id="rubin2.all_+3A_funcvar">funcvar</code></td>
<td>
<p>function that should be used to compute the variance</p>
</td></tr>
<tr><td><code id="rubin2.all_+3A_is.parallel">is.parallel</code></td>
<td>
<p>should parallel computing be used?</p>
</td></tr>
<tr><td><code id="rubin2.all_+3A_verbose">verbose</code></td>
<td>
<p>should messages be displayed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of variance-covariance matrices.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
rubin2.all(datasim_imp[1:5,,],attr(datasim,"metadata")$Condition)
</code></pre>

<hr>
<h2 id='rubin2bt.all'>2nd Rubin's rule Between-Imputation component (all peptides)</h2><span id='topic+rubin2bt.all'></span>

<h3>Description</h3>

<p>Computes the between-imputation component in the 2nd Rubin's rule for all peptides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rubin2bt.all(
  data,
  funcmean = meanImp_emmeans,
  metacond,
  is.parallel = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rubin2bt.all_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="rubin2bt.all_+3A_funcmean">funcmean</code></td>
<td>
<p>function that should be used to compute the mean</p>
</td></tr>
<tr><td><code id="rubin2bt.all_+3A_metacond">metacond</code></td>
<td>
<p>a factor to specify the groups</p>
</td></tr>
<tr><td><code id="rubin2bt.all_+3A_is.parallel">is.parallel</code></td>
<td>
<p>should parallel computing be used?</p>
</td></tr>
<tr><td><code id="rubin2bt.all_+3A_verbose">verbose</code></td>
<td>
<p>should messages be displayed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of variance-covariance matrices.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
rubin2bt.all(datasim_imp[1:5,,],funcmean = meanImp_emmeans,
attr(datasim,"metadata")$Condition)
</code></pre>

<hr>
<h2 id='rubin2bt.one'>2nd Rubin's rule Between-Imputation Component (a given peptide)</h2><span id='topic+rubin2bt.one'></span>

<h3>Description</h3>

<p>Computes the between-imputation component in the 2nd Rubin's rule for a given peptide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rubin2bt.one(peptide, data, funcmean, metacond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rubin2bt.one_+3A_peptide">peptide</code></td>
<td>
<p>peptide for which the variance-covariance matrix should be derived.</p>
</td></tr>
<tr><td><code id="rubin2bt.one_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="rubin2bt.one_+3A_funcmean">funcmean</code></td>
<td>
<p>function that should be used to compute the mean</p>
</td></tr>
<tr><td><code id="rubin2bt.one_+3A_metacond">metacond</code></td>
<td>
<p>a factor to specify the groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
rubin2bt.one(1,datasim_imp,funcmean = meanImp_emmeans,
attr(datasim,"metadata")$Condition)
</code></pre>

<hr>
<h2 id='rubin2wt.all'>2nd Rubin's rule Within-Variance Component (all peptides)</h2><span id='topic+rubin2wt.all'></span>

<h3>Description</h3>

<p>Computes the within-variance component in the 2nd Rubin's rule for all peptides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rubin2wt.all(
  data,
  funcvar = mi4p::within_variance_comp_emmeans,
  metacond,
  is.parallel = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rubin2wt.all_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="rubin2wt.all_+3A_funcvar">funcvar</code></td>
<td>
<p>function that should be used to compute the variance</p>
</td></tr>
<tr><td><code id="rubin2wt.all_+3A_metacond">metacond</code></td>
<td>
<p>a factor to specify the groups</p>
</td></tr>
<tr><td><code id="rubin2wt.all_+3A_is.parallel">is.parallel</code></td>
<td>
<p>should parallel computing be used?</p>
</td></tr>
<tr><td><code id="rubin2wt.all_+3A_verbose">verbose</code></td>
<td>
<p>should messages be displayed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of variance-covariance matrices.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], 
conditions = attr(datasim,"metadata")$Condition, method = "MLE")
rubin2wt.all(datasim_imp[1:5,,],funcvar = within_variance_comp_emmeans,
attr(datasim,"metadata")$Condition)
</code></pre>

<hr>
<h2 id='rubin2wt.one'>2nd Rubin's rule Within-Variance Component (a given peptide)</h2><span id='topic+rubin2wt.one'></span>

<h3>Description</h3>

<p>Computes the within-variance component in the 2nd Rubin's rule for a given peptide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rubin2wt.one(peptide, data, funcvar, metacond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rubin2wt.one_+3A_peptide">peptide</code></td>
<td>
<p>peptide for which the variance-covariance matrix should be derived.</p>
</td></tr>
<tr><td><code id="rubin2wt.one_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="rubin2wt.one_+3A_funcvar">funcvar</code></td>
<td>
<p>function that should be used to compute the variance</p>
</td></tr>
<tr><td><code id="rubin2wt.one_+3A_metacond">metacond</code></td>
<td>
<p>a factor to specify the groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
rubin2wt.one(1,datasim_imp,funcvar=within_variance_comp_emmeans,
attr(datasim,"metadata")$Condition)
</code></pre>

<hr>
<h2 id='sTab'>Experimental design for the Exp1_R25_pept dataset</h2><span id='topic+sTab'></span>

<h3>Description</h3>

<p>The data frame <code>sTab</code>  contains the experimental design and gives few informations about the samples. They were obtained using the code <code>pData(Exp1_R25_pept)</code>.
</p>


<h3>Format</h3>

<p>A data frame with 6 observations on the following 3 variables.
</p>
 
<dl>
<dt>Sample.name</dt><dd><p>a character vector</p>
</dd>
<dt>Condition</dt><dd><p>a character vector</p>
</dd> 
<dt>Bio.Rep</dt><dd><p>a numeric vector</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The <code>DAPARdata</code>'s <code>Exp1_R25_pept</code> dataset is the final outcome of a quantitative mass spectrometry-based proteomic analysis of two samples containing different concentrations of 48 human proteins (UPS1 standard from Sigma-Aldrich) within a constant yeast background (see Giai Gianetto et al. (2016) for details). It contains the abundance values of the different human and yeast peptides identified and quantified in these two conditions. The two conditions represent the measured abundances of peptides when respectively 25 fmol and 10 fmol of UPS1 human proteins were mixed with the yeast extract before mass spectrometry analyses. This results in a concentration ratio of 2.5. Three technical replicates were acquired for each condition.
</p>


<h3>Source</h3>

<p>The <code>DAPARdata</code> package.
</p>


<h3>References</h3>

<p>Cox J., Hein M.Y., Luber C.A., Paron I., Nagaraj N., Mann M. Accurate proteome-wide label-free quantification by delayed normalization and maximal peptide ratio extraction, termed MaxLFQ. Mol Cell Proteomics. 2014 Sep, 13(9):2513-26.
</p>
<p>Giai Gianetto, Q., Combes, F., Ramus, C., Bruley, C., Coute, Y., Burger, T. (2016). Calibration plot for proteomics: A graphical tool to visually check the assumptions underlying FDR control in quantitative experiments. Proteomics, 16(1), 29-32.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sTab)
str(sTab)

</code></pre>

<hr>
<h2 id='test.design'>Check if xxxxxx</h2><span id='topic+test.design'></span>

<h3>Description</h3>

<p>This function check xxxxx
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.design(tab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.design_+3A_tab">tab</code></td>
<td>
<p>A data.frame which correspond to xxxxxx</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two items
</p>


<h3>Author(s)</h3>

<p>Thomas Burger, Quentin Giai-Gianetto, Samuel Wieczorek originally in 
the <code>DAPAR</code> package. Included in this package since <code>DAPAR</code> was to be removed from 
Bioconductor &gt;= 3.15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
utils::data(Exp1_R25_pept, package='DAPARdata')
test.design(Biobase::pData(Exp1_R25_pept)[,1:3])

## End(Not run)

</code></pre>

<hr>
<h2 id='within_variance_comp_emmeans'>Multiple Imputation Within Variance Component</h2><span id='topic+within_variance_comp_emmeans'></span>

<h3>Description</h3>

<p>Computes the multiple imputation within variance component using the emmeans package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>within_variance_comp_emmeans(ind, peptide, data, metacond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="within_variance_comp_emmeans_+3A_ind">ind</code></td>
<td>
<p>index</p>
</td></tr>
<tr><td><code id="within_variance_comp_emmeans_+3A_peptide">peptide</code></td>
<td>
<p>name of the peptide</p>
</td></tr>
<tr><td><code id="within_variance_comp_emmeans_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="within_variance_comp_emmeans_+3A_metacond">metacond</code></td>
<td>
<p>a factor to specify the groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Frédéric Bertrand
</p>


<h3>References</h3>

<p>M. Chion, Ch. Carapito and F. Bertrand (2021). <em>Accounting for multiple imputation-induced variability for differential analysis in mass spectrometry-based label-free quantitative proteomics</em>. arxiv:2108.07086. <a href="https://arxiv.org/abs/2108.07086">https://arxiv.org/abs/2108.07086</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mi4p)
data(datasim)
datasim_imp &lt;- multi.impute(data = datasim[,-1], conditions = 
attr(datasim,"metadata")$Condition, method = "MLE")
within_variance_comp_emmeans(1,1,datasim_imp,
attr(datasim,"metadata")$Condition)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
