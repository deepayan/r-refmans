<!DOCTYPE html><html lang="en"><head><title>Help for package xergm.common</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xergm.common}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust'><p>Adjust the dimensions of a matrix to the dimensions of another matrix</p></a></li>
<li><a href='#alliances'><p>Longitudinal international defense alliance network, 1981&ndash;2000</p></a></li>
<li><a href='#checkdegeneracy'><p>Generic function for checking whether a statistical network model is degenerate</p></a></li>
<li><a href='#chemnet'><p>German Toxic Chemicals Policy Network in the 1980s (Volker Schneider)</p></a></li>
<li><a href='#getformula'><p>Retrieve a formula object from a model object</p></a></li>
<li><a href='#gof'><p>Goodness of fit for inferential network models</p></a></li>
<li><a href='#handleMissings'><p>Handle missing data in matrices.</p></a></li>
<li><a href='#interpret'><p>Generic interpretation function for statistical network models</p></a></li>
<li><a href='#is.mat.onemode'><p>Check whether a matrix is one-mode or directed</p></a></li>
<li><a href='#knecht'><p>Longitudinal classroom friendship network and behavior (Andrea Knecht)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.7.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-04-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Common Infrastructure for Extensions of Exponential Random Graph
Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Datasets and definitions of generic functions used in dependencies of the 'xergm' package.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/leifeld/xergm.common">http://github.com/leifeld/xergm.common</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), ergm (&ge; 3.5.1), network (&ge; 1.13.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-06 18:58:53 UTC; philip</td>
</tr>
<tr>
<td>Author:</td>
<td>Philip Leifeld [aut, cre],
  Skyler J. Cranmer [ctb],
  Bruce A. Desmarais [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philip Leifeld &lt;philip.leifeld@essex.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-07 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust'>Adjust the dimensions of a matrix to the dimensions of another matrix</h2><span id='topic+adjust'></span>

<h3>Description</h3>

<p>Adjust the dimensions of a matrix to the dimensions of another matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust(source, target, remove = TRUE, add = TRUE, value = NA, 
    returnlabels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_+3A_source">source</code></td>
<td>
<p> A matrix, network, list or data.frame object or a vector which should be adjusted. </p>
</td></tr>
<tr><td><code id="adjust_+3A_target">target</code></td>
<td>
<p> A matrix, network, list or data.frame object or a vector to which the source object is compared with regard to its labels. </p>
</td></tr>
<tr><td><code id="adjust_+3A_remove">remove</code></td>
<td>
<p> Should rows and columns that are not present in the target object be removed? </p>
</td></tr>
<tr><td><code id="adjust_+3A_add">add</code></td>
<td>
<p> Should rows and columns that are present in the target object but not in the source object be added to the source object? </p>
</td></tr>
<tr><td><code id="adjust_+3A_value">value</code></td>
<td>
<p> The value to be inserted if a new row or column is added. By default, new cells are filled with <code>NA</code> values, but other sensible values may include <code>-Inf</code> or <code>0</code>. </p>
</td></tr>
<tr><td><code id="adjust_+3A_returnlabels">returnlabels</code></td>
<td>
<p> Return a list of added and removed row and column labels rather than the actual matrix, vector, or network object? </p>
</td></tr>
</table>


<h3>Details</h3>

<p>An adjacency matrix (the <code>source</code> matrix) is compared to another adjacency matrix (the <code>target</code> matrix) by matching the row or column labels. If the target matrix contains rows/columns which are not present in the source matrix, new rows and columns with the corresponding labels and NA values in the cells are inserted into the source matrix. If the source matrix contains rows/columns which are not present in the target matrix, these rows and columns are removed from the source matrix. In addition to adjacency matrices, two-mode matrices, network objects (also with vertex attributes), and vectors are supported.
</p>


<h3>See Also</h3>

<p><a href="#topic+handleMissings">handleMissings</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create sociomatrix a with 13 vertices a to m
vertices &lt;- letters[1:13]
a &lt;- matrix(rbinom(length(vertices)^2, 1, 0.1), nrow = length(vertices))
rownames(a) &lt;- colnames(a) &lt;- vertices

# create sociomatrix b with the same vertices except f and k, but additional n
vertices &lt;- c(vertices[-c(6, 11)], "n")
b &lt;- matrix(rbinom(length(vertices)^2, 1, 0.1), nrow = length(vertices))
rownames(b) &lt;- colnames(b) &lt;- vertices

# check dimensions
dim(a)  # 13 x 13
dim(b)  # 12 x 12

# adjust a to b: add n and fill up with NAs; remove f and k
adjust(a, b, add = TRUE, remove = TRUE)

# more complex example with additional attributes stored in the network object; 
# convert a to network objects with additional vertex and network attributes
nw &lt;- network(a)
vertices &lt;- letters[1:13]
nwattrib1 &lt;- matrix(rbinom(length(vertices)^2, 1, 0.1), nrow = length(vertices))
nwattrib2 &lt;- nwattrib1
rownames(nwattrib1) &lt;- colnames(nwattrib1) &lt;- vertices
set.network.attribute(nw, "nwattrib1", nwattrib1)
set.network.attribute(nw, "nwattrib2", nwattrib2)
set.vertex.attribute(nw, "vattrib", 1:length(vertices))

# check presence of the two attributes
list.network.attributes(nw)  # nwattrib1 and nwattrib2 are listed
get.network.attribute(nw, "nwattrib1")  # returns sociomatrix with labels
get.network.attribute(nw, "nwattrib2")  # returns sociomatrix without labels
list.vertex.attributes(nw)  # vattrib is listed
get.vertex.attribute(nw, "vattrib")  # returns numeric vector 1:13

# adjust the network including the two attributes
nw.adjusted &lt;- adjust(nw, b, add = TRUE, remove = TRUE)
as.matrix(nw.adjusted)  # note that the order of nodes may have changed
get.network.attribute(nw.adjusted, "nwattrib1")  # returns adjusted sociomatrix
get.network.attribute(nw.adjusted, "nwattrib2")  # returns adjusted sociomatrix
get.vertex.attribute(nw.adjusted, "vattrib")  # returns adjusted vector
</code></pre>

<hr>
<h2 id='alliances'>Longitudinal international defense alliance network, 1981&ndash;2000</h2><span id='topic+alliances'></span><span id='topic+allyNet'></span><span id='topic+contigMat'></span><span id='topic+lNet'></span><span id='topic+LSP'></span><span id='topic+warNet'></span>

<h3>Description</h3>

<p>The alliances dataset contains the international defense alliance
network among 164 countries, covering the years 1981&ndash;2000. In addition
to the yearly defense alliance network, it contains data on military
capabilities, governing regime type, geographic contiguity and
international conflict. This is an excerpt from a dataset that has
been used in two published analyses. The full dataset (Cranmer,
Desmarais and Menninga 2012; Cranmer, Desmarais and Kirlkand 2012)
contains a large number of countries and a much longer time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("alliances")</code></pre>


<h3>Format</h3>


<dl>
<dt><code>allyNet</code></dt><dd><p>is a list of network objects at 20 time points, 1981&ndash;2000, containing undirected defense alliance networks. In addition to the alliance ties, each network object contains three vertex attributes. <code>cinc</code> is the &quot;CINC&quot; or Composite Index of National Capability score (see <a href="https://correlatesofwar.org/data-sets/national-material-capabilities">https://correlatesofwar.org/data-sets/national-material-capabilities</a>). <code>polity</code> is the &quot;polity score&quot; of each country in the respective year. Quoting the online description, &quot;the Polity Score captures this regime authority spectrum on a 21-point scale ranging from -10 (hereditary monarchy) to +10 (consolidated democracy),&quot; (see <a href="http://www.systemicpeace.org/polityproject.html">http://www.systemicpeace.org/polityproject.html</a>). <code>year</code> is simply the year recorded as a vertex attribute.</p>
</dd>
<dt><code>contigMat</code></dt><dd><p>is a 164 x 164 binary matrix in which a 1 indicates that two countries share a border.</p>
</dd>
<dt><code>lNet</code></dt><dd><p>is a list of 20 matrices. Each element is the adjacency matrix from the previous year. This is used to model memory in the ties.</p>
</dd>
<dt><code>LSP</code></dt><dd><p>is a list of 20 matrices. Each element is a matrix recording the number of shared partners between countries in the alliance network from the previous year.</p>
</dd>
<dt><code>warNet</code></dt><dd><p>is a list of 20 matrices. Each element is a binary matrix that indicates whether two states were in a militarized interstate dispute in the respective year.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were gathered by Skyler Cranmer and Bruce Desmarais in the
process of writing Cranmer, Desmarais and Menninga (2012) and Cranmer,
Desmarais and Kirlkand (2012).
</p>
<p>Permission to redistribute this dataset along with this package was
granted by Skyler Cranmer and Bruce Desmarais on December 15, 2015.
Questions about the data should be directed to them.
</p>


<h3>References</h3>

<p>Skyler J. Cranmer, Bruce A. Desmarais, and Justin H. Kirkland (2012): Toward a Network Theory of Alliance Formation. <em>International Ineractions</em> 38(3): 295&ndash;324.
</p>
<p>Skyler J. Cranmer, Bruce A. Desmarais, and Elizabeth Menninga (2012): Complex Dependencies in the Alliance Network. <em>International Ineractions</em> 29(3):279&ndash;313.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("xergm")
data("alliances")

# btergm formulas look very similar to ERGM formulas.
# Note the R argument; usually want R &gt; 1000.
# Here it is set to 50 to limit computation time.
# First, set the seed for replicability.
set.seed(123)
model &lt;- btergm(allyNet ~ edges + gwesp(0, fixed = TRUE)
    + edgecov(lNet) + edgecov(LSP) + edgecov(warNet)
    + nodecov("polity") + nodecov("cinc") + absdiff("polity")
    + absdiff("cinc") + edgecov(contigMat) + nodecov("year"),
    R = 50)

# View estimates and confidence intervals.
summary(model)

# Evaluate model fit. Simulate 100 networks for each time point.
# Calculate edgewise shared partners, degree and geodesic distance
# distance distributions.
alliance_gof &lt;- gof(model, statistics = c(deg, esp, geodesic))

# Plot goodness of fit.
plot(alliance_gof)

## End(Not run)
</code></pre>

<hr>
<h2 id='checkdegeneracy'>Generic function for checking whether a statistical network model is degenerate</h2><span id='topic+checkdegeneracy'></span><span id='topic+check.degeneracy'></span>

<h3>Description</h3>

<p>Generic function for checking whether a statistical network model is degenerate.</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkdegeneracy(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkdegeneracy_+3A_object">object</code></td>
<td>
<p> An <code>mtergm</code> or <code>btergm</code> object. </p>
</td></tr>
<tr><td><code id="checkdegeneracy_+3A_...">...</code></td>
<td>
<p> Custom arguments to be handed over to subroutines. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>checkdegeneracy</code> function permits degeneracy checking for statistical network models (mtergm and btergm objects). See the specific methods in the <span class="pkg">btergm</span> package.
</p>

<hr>
<h2 id='chemnet'>German Toxic Chemicals Policy Network in the 1980s (Volker Schneider)</h2><span id='topic+chemnet'></span><span id='topic+schneider'></span><span id='topic+chemnetde'></span><span id='topic+ChemNetDe'></span><span id='topic+ChemNetDE'></span><span id='topic+pol'></span><span id='topic+scifrom'></span><span id='topic+scito'></span><span id='topic+sci'></span><span id='topic+committee'></span><span id='topic+infrep'></span><span id='topic+intpos'></span><span id='topic+types'></span>

<h3>Description</h3>

<p>The chemnet dataset contains network and attribute data and for the 
30 most influential political actors with regard to toxic chemicals 
regulation in Germany in 1983/1984. While the original dataset 
contains up to 47 actors, this dataset contains the &quot;complete 
influence core&quot; of mutually relevant actors. The data are 
cross-sectional. There are no missing data; the response rate was 
100 percent. Volker Schneider (University of Konstanz) collected 
this dataset for his dissertation (Schneider 1988). The dataset was 
later re-used for a journal publication on information exchange in 
policy networks (Leifeld and Schneider 2012).
</p>
<p>The chemnet dataset contains network relations on 
political/strategic and technical/scientific information exchange, 
influence attribution, and membership in policy committees/forums, 
as well as nodal attributes on the actor type and opinions about 
the six most salient issues related to the political process that 
was leading to a new chemicals law at the time being.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chemnet)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>pol</code></dt><dd><p>is a directed 30 x 30 adjancency matrix 
indicating which row actor sends political/strategic information 
to which column actor. <code>1</code> indicates an information exchange 
tie, and <code>0</code> indicates the absence of a network tie.</p>
</dd>
<dt><code>scito</code></dt><dd><p>is a directed 30 x 30 adjacency matrix 
indicating which row actor sends technical/scientific information 
to which column actor. <code>1</code> indicates an information exchange 
tie, and <code>0</code> indicates the absence of a network tie. In 
contrast to political/strategic information exchange, two separate 
survey questions were asked about technical/scientific information 
exchange: sending information, and receiving information. The two 
matrices contain the same relation but one time from the sender's
perspective and one time from the receiver's perspective. By 
combining the two matrices, one can create a &quot;confirmed&quot; 
technical/scientific information exchange relation. The 
<code>scito</code> matrix contains ties from the sender's perspective.</p>
</dd>
<dt><code>scifrom</code></dt><dd><p>is a directed 30 x 30 adjacency matrix 
indicating which row actor receives technical/scientific 
information from which column actor. <code>1</code> indicates an 
information exchange tie, and <code>0</code> indicates the absence of a 
network tie. In contrast to political/strategic information 
exchange, two separate survey questions were asked about 
technical/scientific information exchange: sending information, 
and receiving information. The two matrices contain the same 
relation but one time from the sender's perspective and one time 
from the receiver's perspective. By combining the two matrices, 
one can create a &quot;confirmed&quot; technical/scientific information 
exchange relation. The <code>scifrom</code> matrix contains ties from 
the receiver's perspective.</p>
</dd>
<dt><code>infrep</code></dt><dd><p>is a directed 30 x 30 adjancency matrix 
indicating which row actor deems which column actor &quot;particularly 
influential&quot;. <code>1</code> indicates such a tie, and <code>0</code> 
indicates the absence of an influence attribution tie.</p>
</dd>
<dt><code>committee</code></dt><dd><p>is a 30 x 20 two-mode (bipartite) network 
matrix indicating which row actor is a member of which policy 
committee/forum (as indicated by the column labels). <code>1</code> 
indicates a membership tie, and <code>0</code> indicates 
non-membership.</p>
</dd>
<dt><code>types</code></dt><dd><p>is a one-column data.frame where the 
<code>type</code> variable contains the actor type of each node. The 
following values are possible:</p>
</dd>
</dl>

<ul>
<li><p><code>gov</code> (government actor, e.g., a federal ministry)
</p>
</li>
<li><p><code>ig</code> (interest group
</p>
</li>
<li><p><code>io</code> (international organization)
</p>
</li>
<li><p><code>par</code> (political party)
</p>
</li>
<li><p><code>sci</code> (scientific organization)
</p>
</li></ul>

<dl>
<dt>intpos</dt><dd><p>is a 30 x 6 matrix containing the interest positions 
of the 30 political actors on the six most salient political 
issues related to a pending new chemicals law. <code>-1</code> indicates 
a negative stance, i.e., the actor rejects the proposal; <code>1</code> 
indicates a positive stance, i.e., the actor supports the 
proposal; and <code>0</code> indicates a neutral or absent opinion.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were collected using paper-based questionnaires. The 
questionnaires were administered in personal interviews (PAPI). 
Further information, including the actual survey, data on 
additional actors, the full names of the policy committees/forums, 
and the full list of unabbreviated actor names can be found online 
at <a href="http://hdl.handle.net/1902.1/17004">http://hdl.handle.net/1902.1/17004</a> in the replication 
archive of Leifeld and Schneider (2012).
</p>

<ul>
<li><p>Replication archive: <a href="http://hdl.handle.net/1902.1/17004">http://hdl.handle.net/1902.1/17004</a>
</p>
</li>
<li><p>AJPS publication: <a href="http://dx.doi.org/10.1111/j.1540-5907.2011.00580.x">http://dx.doi.org/10.1111/j.1540-5907.2011.00580.x</a>
</p>
</li></ul>

<p>The dataset is publicly available. Questions about the data or the 
original study should be directed to Volker Schneider 
(volker.schneider@uni-konstanz.de), the author of the original study 
and person who collected the data.
</p>


<h3>References</h3>

<p>Leifeld, Philip and Volker Schneider (2012): Information Exchange 
in Policy Networks. <em>American Journal of Political Science</em> 
53(3): 731&ndash;744. <a href="http://dx.doi.org/10.1111/j.1540-5907.2011.00580.x">http://dx.doi.org/10.1111/j.1540-5907.2011.00580.x</a>.
</p>
<p>Schneider, Volker (1988): <em>Politiknetzwerke der 
Chemikalienkontrolle. Eine Analyse einer transnationalen 
Politikentwicklung</em>. Walter de Gruyter: Berlin/New York.
</p>
<p>Schneider, Volker and Philip Leifeld (2009): Ueberzeugungssysteme, 
Diskursnetzwerke und politische Kommunikation: Ein zweiter Blick auf 
die deutsche Chemikalienkontrolle der 1980er Jahre. In: Volker 
Schneider, Frank Janning, Philip Leifeld and Thomas Malang (editors): 
<em>Politiknetzwerke. Modelle, Anwendungen und Visualisierungen</em>. 
Pages 139&ndash;158. Wiesbaden: VS Verlag fuer Sozialwissenschaften. 
<a href="http://dx.doi.org/10.1007%2F978-3-531-91883-9_6">http://dx.doi.org/10.1007%2F978-3-531-91883-9_6</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Replication code for Leifeld and Schneider (2012), AJPS.
# Note that the estimates can only be reproduced approximately 
# due to internal changes in the statnet package.

# preparatory steps
library("statnet")
library("xergm")
library("texreg")
seed &lt;- 12345
set.seed(seed)
data("chemnet")

# create confirmed network relation
sci &lt;- scito * t(scifrom)  # equation 1 in the AJPS paper
prefsim &lt;- dist(intpos, method = "euclidean")  # equation 2
prefsim &lt;- max(prefsim) - prefsim  # equation 3
prefsim &lt;- as.matrix(prefsim)
committee &lt;- committee %*% t(committee)  # equation 4
diag(committee) &lt;- 0 # the diagonal has no meaning
types &lt;- types[, 1]  # convert to vector

# create network objects and store attributes
nw.pol &lt;- network(pol) # political/stratgic information exchange
set.vertex.attribute(nw.pol, "orgtype", types)
set.vertex.attribute(nw.pol, "betweenness", 
    betweenness(nw.pol)) # centrality

nw.sci &lt;- network(sci) # technical/scientific information exchange
set.vertex.attribute(nw.sci, "orgtype", types)
set.vertex.attribute(nw.sci, "betweenness", 
    betweenness(nw.sci)) # centrality

# ERGM: model 1 in the AJPS paper; only preference similarity
model1 &lt;- ergm(nw.pol ~ edges + edgecov(prefsim), 
    control = control.ergm(seed = seed))
summary(model1)

# ERGM: model 2 in the AJPS paper; complete model
model2 &lt;- ergm(nw.pol ~ 
    edges + 
    edgecov(prefsim) + 
    mutual + 
    nodemix("orgtype", base = -7) + 
    nodeifactor("orgtype", base = -1) + 
    nodeofactor("orgtype", base = -5) + 
    edgecov(committee) + 
    edgecov(nw.sci) + 
    edgecov(infrep) + 
    gwesp(0.1, fixed = TRUE) + 
    gwdsp(0.1, fixed = TRUE), 
    control = control.ergm(seed = seed)
)
summary(model2)

# ERGM: model 3 in the AJPS paper; only preference similarity
model3 &lt;- ergm(nw.sci ~ edges + edgecov(prefsim), 
    control = control.ergm(seed = seed))
summary(model3)

# ERGM: model 4 in the AJPS paper; complete model
model4 &lt;- ergm(nw.sci ~ 
    edges + 
    edgecov(prefsim) + 
    mutual + 
    nodemix("orgtype", base = -7) + 
    nodeifactor("orgtype", base = -1) + 
    nodeofactor("orgtype", base = -5) + 
    edgecov(committee) + 
    edgecov(nw.pol) + 
    edgecov(infrep) + 
    gwesp(0.1, fixed = TRUE) + 
    gwdsp(0.1, fixed = TRUE), 
    control = control.ergm(seed = seed)
)
summary(model4)

# regression table using the texreg package
screenreg(list(model1, model2, model3, model4))

# goodness of fit using the btergm package
gof2 &lt;- gof(model2, roc = FALSE, pr = FALSE)
gof2  # print gof output
plot(gof2)  # visual inspection of GOF

gof4 &lt;- gof(model4, roc = FALSE, pr = FALSE)
gof4
plot(gof4)

# MCMC diagnostics
pdf("diagnostics2.pdf")
mcmc.diagnostics(model2)
dev.off()

pdf("diagnostics4.pdf")
mcmc.diagnostics(model4)
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='getformula'>Retrieve a formula object from a model object</h2><span id='topic+getformula'></span>

<h3>Description</h3>

<p>Retrieve a formula object from a model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getformula(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getformula_+3A_x">x</code></td>
<td>
<p> A network model. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic <code>getformula</code> function serves to extract a formula from a model object.
</p>

<hr>
<h2 id='gof'>Goodness of fit for inferential network models</h2><span id='topic+gof'></span>

<h3>Description</h3>

<p>Assess goodness of fit and degeneracy of inferential network models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gof_+3A_object">object</code></td>
<td>
<p> A network model. </p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>
<p> Arbitrary further arguments are handed over to the <code><a href="ergm.html#topic+simulate.formula">simulate.formula</a></code> function or the <code><a href="RSiena.html#topic+siena07">siena07</a></code> function. For details, refer to the help page of these functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic <code>gof</code> function provides goodness-of-fit measures and degeneracy checks for inferential network models. See the specific help pages in the <span class="pkg">btergm</span> package and other packages.
</p>


<h3>See Also</h3>

<p><a href="ergm.html#topic+simulate.formula">simulate.formula</a>
</p>

<hr>
<h2 id='handleMissings'>Handle missing data in matrices.</h2><span id='topic+handleMissings'></span>

<h3>Description</h3>

<p>Handle missing data in matrices.</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleMissings(mat, na = NA, method = "remove", logical = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handleMissings_+3A_mat">mat</code></td>
<td>
<p> A matrix object. </p>
</td></tr>
<tr><td><code id="handleMissings_+3A_na">na</code></td>
<td>
<p> The value that missing data are coded as. Usually <code>NA</code>, sometimes <code>9</code> or <code>10</code>. </p>
</td></tr>
<tr><td><code id="handleMissings_+3A_method">method</code></td>
<td>
<p> What should be done with the missing data? If <code>method = "remove"</code> is set, the function determines how many missing entries are in each row and column and iteratively removes rows or columns with the largest amount of missing data until no missing data are left in the matrix. If <code>method = "fillmode"</code> is set, the modal value of the matrix is identified (usually <code>0</code> in network matrices) and missing cells are imputed by filling in this modal value. <code>method = "zero"</code> replaces NAs by 0s. </p>
</td></tr>
<tr><td><code id="handleMissings_+3A_logical">logical</code></td>
<td>
<p> Return a matrix with logical values indicating which cells should be removed? By default the manipulated matrix is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deals with missing data in matrices or network objects used for inferential network analysis. It can either remove missing rows and/or columns iteratively (rows and columns with more NA values first, then successively rows and columns with fewer NA entries) or replace missing values by the modal value of the matrix or by 0. The function can return either the manipulated matrix or a matrix with logical values indicating which of the cells should be removed.
</p>


<h3>See Also</h3>

<p><a href="#topic+adjust">adjust</a>
</p>

<hr>
<h2 id='interpret'>Generic interpretation function for statistical network models</h2><span id='topic+interpret'></span><span id='topic+interpretation'></span>

<h3>Description</h3>

<p>Generic interpretation function for statistical network models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpret(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpret_+3A_object">object</code></td>
<td>
<p> An <code>ergm</code> or <code>btergm</code> object. </p>
</td></tr>
<tr><td><code id="interpret_+3A_...">...</code></td>
<td>
<p> Custom arguments to be handed over to subroutines. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>interpret</code> function facilitates interpretation of statistical network models at the micro level, as described in Desmarais and Cranmer (2012). See the specific methods in the <span class="pkg">btergm</span> package.
</p>


<h3>References</h3>

<p>Desmarais, Bruce A. and Skyler J. Cranmer (2012):
Micro-Level Interpretation of Exponential Random Graph Models with
Application to Estuary Networks.
<em>The Policy Studies Journal</em> 40(3): 402&ndash;434.
</p>

<hr>
<h2 id='is.mat.onemode'>Check whether a matrix is one-mode or directed</h2><span id='topic+is.mat.onemode'></span><span id='topic+is.mat.directed'></span>

<h3>Description</h3>

<p>Check whether a matrix represents a one-mode network (as opposed to a two-mode network) and whether a network represented by a matrix is directed (as opposed to undirected).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mat.onemode(mat)

is.mat.directed(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.mat.onemode_+3A_mat">mat</code></td>
<td>
<p> A matrix object containing zeros and ones. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>is.mat.onemode</code> function returns <code>TRUE</code> if the input matrix <code>mat</code> represents a one-mode network and <code>FALSE</code> otherwise. 
The <code>is.mat.directed</code> function returns <code>TRUE</code> if the input matrix <code>mat</code> represents a directed network and <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='knecht'>Longitudinal classroom friendship network and behavior (Andrea Knecht)</h2><span id='topic+knecht'></span><span id='topic+advice'></span><span id='topic+alcohol'></span><span id='topic+delinquency'></span><span id='topic+demographics'></span><span id='topic+friendship'></span><span id='topic+primary'></span>

<h3>Description</h3>

<p>The Knecht dataset contains the friendship network of 26 pupils in 
a Dutch school class measured at four time points along with 
several demographic and behavioral covariates like age, sex, 
ethnicity, religion, delinquency, alcohol consumption, primary 
school co-attendance, and school advice. Some of these covariates 
are constant while others vary over time.
</p>
<p>The full dataset (see Knecht 2006 and 2008) contains a large number 
of classrooms while the dataset presented here is an excerpt based 
on one single classroom. This excerpt was first used in a tutorial 
for the software <span class="pkg">Siena</span> and the corresponding R package 
<span class="pkg">RSiena</span> (Snijders, Steglich and van de Bunt 2010). The 
following description was largely copied from the original data 
description provided on the homepage of the <span class="pkg">Siena</span> project 
(see below for the URL).
</p>
<p>The data were collected between September 2003 and June 2004 by 
Andrea Knecht, supervised by Chris Baerveldt, at the Department 
of Sociology of the University of Utrecht (NL). The entire study 
is reported in Knecht (2008). The project was funded by the 
Netherlands Organisation for Scientific Research NWO, grant 
401-01-554. The 26 students were followed over their first year at 
secondary school during which friendship networks as well as other 
data were assessed at four time points at intervals of three 
months. There were 17 girls and 9 boys in the class, aged 11&ndash;13 
at the beginning of the school year. Network data were assessed by 
asking students to indicate up to twelve classmates which they 
considered good friends. Delinquency is defined as a rounded 
average over four types of minor delinquency (stealing, vandalism, 
graffiti, and fighting), measured in each of the four waves of 
data collection. The five-point scale ranged from &lsquo;never&rsquo; to 'more 
than 10 times', and the distribution is highly skewed. In a range 
of 1&ndash;5, the mode was 1 at all four waves, the average rose over 
time from 1.4 to 2.0, and the value 5 was never observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(knecht)</code></pre>


<h3>Format</h3>

<p>Note: the data have to be transformed before they can be used 
with btergm and related packages (see examples below).
</p>

<dl>
<dt><code>friendship</code></dt><dd><p>is a list of adjacency matrices at four 
time points, containing friendship nominations of the column node 
by the row node. The following values are used: <code>0</code> = no, 
<code>1</code> = yes, <code>NA</code> = missing, <code>10</code> = not a member of 
the classroom (structural zero).</p>
</dd>
<dt><code>demographics</code></dt><dd><p>is a data frame with 26 rows (the 
pupils) and four demographic variables about the pupils:</p>
</dd>
</dl>

<ul>
<li><p><code>sex</code> (<code>1</code> = girl, <code>2</code> = boy)
</p>
</li>
<li><p><code>age</code> (in years)
</p>
</li>
<li><p><code>ethnicity</code> (<code>1</code> = Dutch, <code>2</code> = other, 
<code>0</code> = missing)
</p>
</li>
<li><p><code>religion</code> (<code>1</code> = Christian, <code>2</code> = 
non-religious, <code>3</code> = non-Christian religion, <code>0</code> = 
missing)
</p>
</li></ul>

<dl>
<dt><code>primary</code></dt><dd><p>is a 26 x 26 matrix indicating whether two pupils 
attended the same primary school. <code>0</code> = no, <code>1</code> = yes.</p>
</dd>
<dt><code>delinquency</code></dt><dd><p>is a data frame with 26 rows (the pupils) 
and four columns (the four time steps). It contains the rounded 
average of four items (stealing, vandalizing, fighting, graffiti). 
Categories: frequency over last three months, <code>1</code> = never, 
<code>2</code> = once, <code>3</code> = 2&ndash;4 times, <code>4</code> = 5&ndash;10 times, 
<code>5</code> = more than 10 times; <code>0</code> = missing.</p>
</dd>
<dt><code>alcohol</code></dt><dd><p>is a data frame with 26 rows (the pupils) 
and 3 columns (waves 2, 3, and 4). It contains data on alcohol use 
(&ldquo;How often did you drink alcohol with friends in the last 
three months?&rdquo;). Categories: <code>1</code> = never, <code>2</code> = once, 
<code>3</code> = 2&ndash;4 times, <code>4</code> = 5&ndash;10 times, <code>5</code> = more 
than 10 times; <code>0</code> = missing.</p>
</dd>
<dt><code>advice</code></dt><dd><p>is a data frame with one variable, &ldquo;school 
advice&rdquo;, the assessment given at the end of primary school about 
the school capabilities of the pupil (<code>4</code> = low, <code>8</code> = 
high, <code>0</code> = missing)</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data were gathered by Andrea Knecht, as part of her PhD 
research, building on methods developed by Chris Baerveldt, 
initiator and supervisor of the project. The project is funded by 
the Netherlands Organisation for Scientific Research NWO, grant 
401-01-554, and is part of the research program &ldquo;Dynamics 
of Networks and Behavior&rdquo; with principle investigator Tom A. B. 
Snijders.
</p>

<ul>
<li><p>Complete original data: <a href="https://easy.dans.knaw.nl/ui/datasets/id/easy-dataset:48665">https://easy.dans.knaw.nl/ui/datasets/id/easy-dataset:48665</a>
</p>
</li>
<li><p>This excerpt in Siena format: <a href="http://www.stats.ox.ac.uk/~snijders/siena/klas12b.zip">http://www.stats.ox.ac.uk/~snijders/siena/klas12b.zip</a>
</p>
</li>
<li><p>Siena dataset description: <a href="http://www.stats.ox.ac.uk/~snijders/siena/tutorial2010_data.htm">http://www.stats.ox.ac.uk/~snijders/siena/tutorial2010_data.htm</a>
</p>
</li></ul>

<p>Permission to redistribute this dataset along with this 
package was granted by Andrea Knecht on April 17, 2014. Questions 
about the data or the original study should be directed to her.
</p>


<h3>References</h3>

<p>Knecht, Andrea (2006): <em>Networks and Actor Attributes in Early 
Adolescence</em> [2003/04]. Utrecht, The Netherlands Research School ICS, 
Department of Sociology, Utrecht University. (ICS-Codebook no. 61).
</p>
<p>Knecht, Andrea (2008): <em>Friendship Selection and Friends' 
Influence. Dynamics of Networks and Actor Attributes in Early 
Adolescence</em>. PhD Dissertation, University of Utrecht. <a href="http://dspace.library.uu.nl/bitstream/handle/1874/25950/full.pdf">http://dspace.library.uu.nl/bitstream/handle/1874/25950/full.pdf</a>.
</p>
<p>Knecht, Andrea, Tom A. B. Snijders, Chris Baerveldt, Christian E. 
G. Steglich, and Werner Raub (2010): Friendship and Delinquency: 
Selection and Influence Processes in Early Adolescence.
<em>Social Development</em> 19(3): 494&ndash;514. <a href="http://dx.doi.org/10.1111/j.1467-9507.2009.00564.x">http://dx.doi.org/10.1111/j.1467-9507.2009.00564.x</a>.
</p>
<p>Leifeld, Philip and Skyler J. Cranmer (2014): A Theoretical and 
Empirical Comparison of the Temporal Exponential Random Graph 
Model and the Stochastic Actor-Oriented Model. Paper presented 
at the 7th Political Networks Conference, McGill University, 
Montreal, Canada, May 30. <a href="http://arxiv.org/abs/1506.06696">http://arxiv.org/abs/1506.06696</a>.
</p>
<p>Leifeld, Philip, Skyler J. Cranmer and Bruce A. Desmarais (2017): 
Temporal Exponential Random Graph Models with btergm: Estimation 
and Bootstrap Confidence Intervals. <em>Journal of Statistical 
Software</em>.
</p>
<p>Snijders, Tom A. B., Christian E. G. Steglich, and Gerhard G. van 
de Bunt (2010): Introduction to Actor-Based Models for Network 
Dynamics. <em>Social Networks</em> 32: 44&ndash;60. <a href="http://dx.doi.org/10.1016/j.socnet.2009.02.004">http://dx.doi.org/10.1016/j.socnet.2009.02.004</a>.
</p>
<p>Steglich, Christian E. G. and Andrea Knecht (2009): Die 
statistische Analyse dynamischer Netzwerkdaten. In: Stegbauer, 
Christian and Roger Haeussling (editors), <em>Handbuch der 
Netzwerkforschung</em>, Wiesbaden: Verlag fuer Sozialwissenschaften.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# ====================================================================
# The following example was taken from the JSS article about btergm 
# that is referenced above (Leifeld, Cranmer and Desmarais 2017).
# ====================================================================

require("texreg")
require("sna")
require("xergm")
require("RSiena")
data("knecht")

# step 1: make sure the network matrices have node labels
for (i in 1:length(friendship)) {
  rownames(friendship[[i]]) &lt;- 1:nrow(friendship[[i]])
  colnames(friendship[[i]]) &lt;- 1:ncol(friendship[[i]])
}
rownames(primary) &lt;- rownames(friendship[[1]])
colnames(primary) &lt;- colnames(friendship[[1]])
sex &lt;- demographics$sex
names(sex) &lt;- 1:length(sex)

# step 2: imputation of NAs and removal of absent nodes:
friendship &lt;- handleMissings(friendship, na = 10, method = "remove")
friendship &lt;- handleMissings(friendship, na = NA, method = "fillmode")

# step 3: add nodal covariates to the networks
for (i in 1:length(friendship)) {
  s &lt;- adjust(sex, friendship[[i]])
  friendship[[i]] &lt;- network(friendship[[i]])
  friendship[[i]] &lt;- set.vertex.attribute(friendship[[i]], "sex", s)
  idegsqrt &lt;- sqrt(degree(friendship[[i]], cmode = "indegree"))
  friendship[[i]] &lt;- set.vertex.attribute(friendship[[i]],
      "idegsqrt", idegsqrt)
  odegsqrt &lt;- sqrt(degree(friendship[[i]], cmode = "outdegree"))
  friendship[[i]] &lt;- set.vertex.attribute(friendship[[i]],
      "odegsqrt", odegsqrt)
}
sapply(friendship, network.size)

# step 4: plot the networks
pdf("knecht.pdf")
par(mfrow = c(2, 2), mar = c(0, 0, 1, 0))
for (i in 1:length(friendship)) {
  plot(network(friendship[[i]]), main = paste("t =", i),
  usearrows = TRUE, edge.col = "grey50")
}
dev.off()

# step 5: estimate TERGMS without and with temporal dependencies
model.2a &lt;- btergm(friendship ~ edges + mutual + ttriple +
    transitiveties + ctriple + nodeicov("idegsqrt") +
    nodeicov("odegsqrt") + nodeocov("odegsqrt") +
    nodeofactor("sex") + nodeifactor("sex") + nodematch("sex") +
    edgecov(primary), R = 100)

model.2b &lt;- btergm(friendship ~ edges + mutual + ttriple +
    transitiveties + ctriple + nodeicov("idegsqrt") +
    nodeicov("odegsqrt") + nodeocov("odegsqrt") +
    nodeofactor("sex") + nodeifactor("sex") + nodematch("sex") +
    edgecov(primary) + delrecip + memory(type = "stability"),
    R = 100)

# step 6: alternatively, estimate via MCMC-MLE:
model.2d &lt;- mtergm(friendship ~ edges + mutual + ttriple +
    transitiveties + ctriple + nodeicov("idegsqrt") +
    nodeicov("odegsqrt") + nodeocov("odegsqrt") +
    nodeofactor("sex") + nodeifactor("sex") + nodematch("sex") +
    edgecov(primary) + delrecip + memory(type = "stability"),
    control = control.ergm(MCMC.samplesize = 5000, MCMC.interval = 2000))

# step 7: GOF assessment with out-of-sample prediction
model.2e &lt;- btergm(friendship[1:3] ~ edges + mutual + ttriple +
    transitiveties + ctriple + nodeicov("idegsqrt") +
    nodeicov("odegsqrt") + nodeocov("odegsqrt") +
    nodeofactor("sex") + nodeifactor("sex") + nodematch("sex") +
    edgecov(primary) + delrecip + memory(type = "stability"),
    R = 100)

gof.2e &lt;- gof(model.2e, nsim = 100, target = friendship[[4]],
    formula = friendship[3:4] ~ edges + mutual + ttriple +
    transitiveties + ctriple + nodeicov("idegsqrt") +
    nodeicov("odegsqrt") + nodeocov("odegsqrt") +
    nodeofactor("sex") + nodeifactor("sex") + nodematch("sex") +
    edgecov(primary) + delrecip + memory(type = "stability"),
    coef = coef(model.2b), statistics = c(esp, dsp, geodesic,
    deg, triad.undirected, rocpr))
pdf("gof-2e.pdf", width = 8, height = 6)
plot(gof.2e)
dev.off()

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
