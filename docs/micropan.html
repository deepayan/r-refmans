<!DOCTYPE html><html><head><title>Help for package micropan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {micropan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#micropan'><p>Microbial Pan-Genome Analysis</p></a></li>
<li><a href='#bClust'><p>Clustering sequences based on pairwise distances</p></a></li>
<li><a href='#bDist'><p>Computes distances between sequences</p></a></li>
<li><a href='#binomixEstimate'><p>Binomial mixture model estimates</p></a></li>
<li><a href='#blastpAllAll'><p>Making BLAST search all against all genomes</p></a></li>
<li><a href='#chao'><p>The Chao lower bound estimate of pan-genome size</p></a></li>
<li><a href='#dClust'><p>Clustering sequences based on domain sequence</p></a></li>
<li><a href='#distJaccard'><p>Computing Jaccard distances between genomes</p></a></li>
<li><a href='#distManhattan'><p>Computing Manhattan distances between genomes</p></a></li>
<li><a href='#entrezDownload'><p>Downloading genome data</p></a></li>
<li><a href='#fluidity'><p>Computing genomic fluidity for a pan-genome</p></a></li>
<li><a href='#geneWeights'><p>Gene cluster weighting</p></a></li>
<li><a href='#getAccessions'><p>Collecting contig accession numbers</p></a></li>
<li><a href='#heaps'><p>Heaps law estimate</p></a></li>
<li><a href='#hmmerCleanOverlap'><p>Removing overlapping hits from HMMER3 scans</p></a></li>
<li><a href='#hmmerScan'><p>Scanning a profile Hidden Markov Model database</p></a></li>
<li><a href='#isOrtholog'><p>Identifies orthologs in gene clusters</p></a></li>
<li><a href='#panMatrix'><p>Computing the pan-matrix for a set of gene clusters</p></a></li>
<li><a href='#panPca'><p>Principal component analysis of a pan-matrix</p></a></li>
<li><a href='#panPrep'><p>Preparing FASTA files for pan-genomics</p></a></li>
<li><a href='#rarefaction'><p>Rarefaction curves for a pan-genome</p></a></li>
<li><a href='#readBlastSelf'><p>Reads BLAST result files</p></a></li>
<li><a href='#readHmmer'><p>Reading results from a HMMER3 scan</p></a></li>
<li><a href='#xmpl'><p>Data sets for use in examples</p></a></li>
<li><a href='#xzcompress'><p>Compressing and uncompressing text files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Microbial Pan-Genome Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-07-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Lars Snipen and Kristian Hovde Liland</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lars Snipen &lt;lars.snipen@nmbu.no&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions for computations and visualizations of microbial pan-genomes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), microseq, dplyr, stringr, igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>tibble, rlang</td>
</tr>
<tr>
<td>LazyData:</td>
<td>FALSE</td>
</tr>
<tr>
<td>ZipData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-15 13:00:24 UTC; larssn</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-15 13:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='micropan'>Microbial Pan-Genome Analysis</h2><span id='topic+micropan'></span><span id='topic+micropan-package'></span>

<h3>Description</h3>

<p>A collection of functions for computations and visualizations of microbial pan-genomes.
Some of the functions make use of external software that needs to be installed on the system, see the
package vignette for more details on this.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>
<p>Maintainer: Lars Snipen &lt;lars.snipen@nmbu.no&gt;
</p>


<h3>References</h3>

<p>Snipen, L., Liland, KH. (2015). micropan: an R-package for microbial pan-genomics. BMC Bioinformatics, 16:79.
</p>

<hr>
<h2 id='bClust'>Clustering sequences based on pairwise distances</h2><span id='topic+bClust'></span>

<h3>Description</h3>

<p>Sequences are clustered by hierarchical clustering based on a set of pariwise distances.
The distances must take values between 0.0 and 1.0, and all pairs <em>not</em> listed are assumed to
have distance 1.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bClust(dist.tbl, linkage = "complete", threshold = 0.75, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bClust_+3A_dist.tbl">dist.tbl</code></td>
<td>
<p>A <code>tibble</code> with pairwise distances.</p>
</td></tr>
<tr><td><code id="bClust_+3A_linkage">linkage</code></td>
<td>
<p>A text indicating what type of clustering to perform, either &lsquo;<span class="samp">&#8288;complete&#8288;</span>&rsquo; (default),
&lsquo;<span class="samp">&#8288;average&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;single&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="bClust_+3A_threshold">threshold</code></td>
<td>
<p>Specifies the maximum size of a cluster. Must be a distance, i.e. a number between
0.0 and 1.0.</p>
</td></tr>
<tr><td><code id="bClust_+3A_verbose">verbose</code></td>
<td>
<p>Logical, turns on/off text output during computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing clusters (gene families) is an essential step in many comparative studies.
<code><a href="#topic+bClust">bClust</a></code> will assign sequences into gene families by a hierarchical clustering approach.
Since the number of sequences may be huge, a full all-against-all distance matrix will be impossible
to handle in memory. However, most sequence pairs will have an &lsquo;infinite&rsquo; distance between them,
and only the pairs with a finite (smallish) distance need to be considered.
</p>
<p>This function takes as input the distances in <code>dist.tbl</code> where only the relevant distances are
listed. The columns &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo; contain tags identifying pairs of sequences. The column
&lsquo;<span class="samp">&#8288;Distance&#8288;</span>&rsquo; contains the distances, always a number from 0.0 to 1.0. Typically, this is the output
from <code><a href="#topic+bDist">bDist</a></code>. All pairs of sequences <em>not</em> listed are assumed to have distance 1.0,
which is considered the &lsquo;infinite&rsquo; distance.
All sequences must be listed at least once in ceither column &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo; of the <code>dist.tbl</code>.
This should pose no problem, since all sequences must have distance 0.0 to themselves, and should be listed
with this distance once (&lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo; containing the same tag). 
</p>
<p>The &lsquo;<span class="samp">&#8288;linkage&#8288;</span>&rsquo; defines the type of clusters produced. The &lsquo;<span class="samp">&#8288;threshold&#8288;</span>&rsquo; indicates the size of
the clusters. A &lsquo;<span class="samp">&#8288;single&#8288;</span>&rsquo; linkage clustering means all members of a cluster have at least one other
member of the same cluster within distance &lsquo;<span class="samp">&#8288;threshold&#8288;</span>&rsquo; from itself. An &lsquo;<span class="samp">&#8288;average&#8288;</span>&rsquo; linkage means
all members of a cluster are within the distance &lsquo;<span class="samp">&#8288;threshold&#8288;</span>&rsquo; from the center of the cluster. A
&lsquo;<span class="samp">&#8288;complete&#8288;</span>&rsquo; linkage means all members of a cluster are no more than the distance &lsquo;<span class="samp">&#8288;threshold&#8288;</span>&rsquo;
away from any other member of the same cluster. 
</p>
<p>Typically, &lsquo;<span class="samp">&#8288;single&#8288;</span>&rsquo; linkage produces big clusters where members may differ a lot, since they are
only required to be close to something, which is close to something,...,which is close to some other
member. On the other extreme, &lsquo;<span class="samp">&#8288;complete&#8288;</span>&rsquo; linkage will produce small and tight clusters, since all
must be similar to all. The &lsquo;<span class="samp">&#8288;average&#8288;</span>&rsquo; linkage is between, but closer to &lsquo;<span class="samp">&#8288;complete&#8288;</span>&rsquo; linkage. If
you want the &lsquo;<span class="samp">&#8288;threshold&#8288;</span>&rsquo; to specify directly the maximum distance tolerated between two members of
the same gene family, you must use &lsquo;<span class="samp">&#8288;complete&#8288;</span>&rsquo; linkage. The &lsquo;<span class="samp">&#8288;single&#8288;</span>&rsquo; linkage is the fastest
alternative to compute. Using the default setting of &lsquo;<span class="samp">&#8288;single&#8288;</span>&rsquo; linkage and maximum &lsquo;<span class="samp">&#8288;threshold&#8288;</span>&rsquo;
(1.0) will produce the largest and fewest clusters possible.
</p>


<h3>Value</h3>

<p>The function returns a vector of integers, indicating the cluster membership of every unique
sequence from the &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo; columns of the input &lsquo;<span class="samp">&#8288;dist.tbl&#8288;</span>&rsquo;. The name
of each element indicates the sequence. The numerical values have no meaning as such, they are simply
categorical indicators of cluster membership.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bDist">bDist</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="#topic+dClust">dClust</a></code>, <code><a href="#topic+isOrtholog">isOrtholog</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading example BLAST distances
data(xmpl.bdist)

# Clustering with default settings
clst &lt;- bClust(xmpl.bdist)
# Other settings, and verbose
clst &lt;- bClust(xmpl.bdist, linkage = "average", threshold = 0.5, verbose = TRUE)

</code></pre>

<hr>
<h2 id='bDist'>Computes distances between sequences</h2><span id='topic+bDist'></span>

<h3>Description</h3>

<p>Computes distance between all sequences based on the BLAST bit-scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bDist(blast.files = NULL, blast.tbl = NULL, e.value = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bDist_+3A_blast.files">blast.files</code></td>
<td>
<p>A text vector of BLAST result filenames.</p>
</td></tr>
<tr><td><code id="bDist_+3A_blast.tbl">blast.tbl</code></td>
<td>
<p>A table with BLAST results.</p>
</td></tr>
<tr><td><code id="bDist_+3A_e.value">e.value</code></td>
<td>
<p>A threshold E-value to immediately discard (very) poor BLAST alignments.</p>
</td></tr>
<tr><td><code id="bDist_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating if textual output should be given to monitor the progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The essential input is either a vector of BLAST result filenames (<code>blast.files</code>) or a
table of the BLAST results (<code>blast.tbl</code>). It is no point in providing both, then <code>blast.tbl</code> is ignored.
</p>
<p>For normal sized data sets (e.g. less than 100 genomes), you would provide the BLAST filenames as the argument
<code>blast.files</code> to this function.
Then results are read, and distances are computed. Only if you have huge data sets, you may find it more efficient to 
read the files using <code><a href="#topic+readBlastSelf">readBlastSelf</a></code> and <code><a href="#topic+readBlastPair">readBlastPair</a></code> separately, and then provide as the
argument <code>blast.tbl]</code> the table you get from binding these results. In all cases, the BLAST result files must
have been produced by <code><a href="#topic+blastpAllAll">blastpAllAll</a></code>.
</p>
<p>Setting a small &lsquo;<span class="samp">&#8288;e.value&#8288;</span>&rsquo; threshold can speed up the computation and reduce the size of the
output, but you may loose some alignments that could produce smallish distances for short sequences.
</p>
<p>The distance computed is based on alignment bitscores. Assume the alignment of query A against hit B
has a bitscore of S(A,B). The distance is D(A,B)=1-2*S(A,B)/(S(A,A)+S(B,B)) where S(A,A) and S(B,B) are
the self-alignment bitscores, i.e. the scores of aligning against itself. A distance of
0.0 means A and B are identical. The maximum possible distance is 1.0, meaning there is no BLAST between A and B.
</p>
<p>This distance should not be interpreted as lack of identity! A distance of 0.0 means 100% identity,
but a distance of 0.25 does <em>not</em> mean 75% identity. It has some resemblance to an evolutinary
(raw) distance, but since it is based on protein alignments, the type of mutations plays a significant
role, not only the number of mutations.
</p>


<h3>Value</h3>

<p>The function returns a table with columns &lsquo;<span class="samp">&#8288;Dbase&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;Bitscore&#8288;</span>&rsquo;
and &lsquo;<span class="samp">&#8288;Distance&#8288;</span>&rsquo;. Each row corresponds to a pair of sequences (Dbase and Query sequences) having at least
one BLAST hit between
them. All pairs <em>not</em> listed in the output have distance 1.0 between them.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blastpAllAll">blastpAllAll</a></code>, <code><a href="#topic+readBlastSelf">readBlastSelf</a></code>, <code><a href="#topic+readBlastPair">readBlastPair</a></code>,
<code><a href="#topic+bClust">bClust</a></code>, <code><a href="#topic+isOrtholog">isOrtholog</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using BLAST result files in this package...
prefix &lt;- c("GID1_vs_GID1_",
            "GID2_vs_GID1_",
            "GID3_vs_GID1_",
            "GID2_vs_GID2_",
            "GID3_vs_GID2_",
            "GID3_vs_GID3_")
bf &lt;- file.path(path.package("micropan"), "extdata", str_c(prefix, ".txt.xz"))

# We need to uncompress them first...
blast.files &lt;- tempfile(pattern = prefix, fileext = ".txt.xz")
ok &lt;- file.copy(from = bf, to = blast.files)
blast.files &lt;- unlist(lapply(blast.files, xzuncompress))

# Computing pairwise distances
blast.dist &lt;- bDist(blast.files)

# Read files separately, then use bDist
self.tbl &lt;- readBlastSelf(blast.files)
pair.tbl &lt;- readBlastPair(blast.files)
blast.dist &lt;- bDist(blast.tbl = bind_rows(self.tbl, pair.tbl))

# ...and cleaning...
ok &lt;- file.remove(blast.files)

# See also example for blastpAl

</code></pre>

<hr>
<h2 id='binomixEstimate'>Binomial mixture model estimates</h2><span id='topic+binomixEstimate'></span>

<h3>Description</h3>

<p>Fits binomial mixture models to the data given as a pan-matrix. From the fitted models
both estimates of pan-genome size and core-genome size are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomixEstimate(
  pan.matrix,
  K.range = 3:5,
  core.detect.prob = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomixEstimate_+3A_pan.matrix">pan.matrix</code></td>
<td>
<p>A pan-matrix, see <code><a href="#topic+panMatrix">panMatrix</a></code> for details.</p>
</td></tr>
<tr><td><code id="binomixEstimate_+3A_k.range">K.range</code></td>
<td>
<p>The range of model complexities to explore. The vector of integers specify the number
of binomial densities to combine in the mixture models.</p>
</td></tr>
<tr><td><code id="binomixEstimate_+3A_core.detect.prob">core.detect.prob</code></td>
<td>
<p>The detection probability of core genes. This should almost always be 1.0,
since a core gene is by definition always present in all genomes, but can be set fractionally smaller.</p>
</td></tr>
<tr><td><code id="binomixEstimate_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if textual output should be given to monitor the progress of the
computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A binomial mixture model can be used to describe the distribution of gene clusters across
genomes in a pan-genome. The idea and the details of the computations are given in Hogg et al (2007),
Snipen et al (2009) and Snipen &amp; Ussery (2012).
</p>
<p>Central to the concept is the idea that every gene has a detection probability, i.e. a probability of
being present in a genome. Genes who are always present in all genomes are called core genes, and these
should have a detection probability of 1.0. Other genes are only present in a subset of the genomes, and
these have smaller detection probabilities. Some genes are only present in one single genome, denoted
ORFan genes, and an unknown number of genes have yet to be observed. If the number of genomes investigated
is large these latter must have a very small detection probability. 
</p>
<p>A binomial mixture model with &lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo; components estimates &lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo; detection probabilities from the
data. The more components you choose, the better you can fit the (present) data, at the cost of less
precision in the estimates due to less degrees of freedom. <code><a href="#topic+binomixEstimate">binomixEstimate</a></code> allows you to
fit several models, and the input &lsquo;<span class="samp">&#8288;K.range&#8288;</span>&rsquo; specifies which values of &lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo; to try out. There no
real point using &lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo; less than 3, and the default is &lsquo;<span class="samp">&#8288;K.range=3:5&#8288;</span>&rsquo;. In general, the more genomes
you have the larger you can choose &lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo; without overfitting.  Computations will be slower for larger
values of &lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo;. In order to choose the optimal value for &lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo;, <code><a href="#topic+binomixEstimate">binomixEstimate</a></code>
computes the BIC-criterion, see below.
</p>
<p>As the number of genomes grow, we tend to observe an increasing number of gene clusters. Once a
&lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo;-component binomial mixture has been fitted, we can estimate the number of gene clusters not yet
observed, and thereby the pan-genome size. Also, as the number of genomes grows we tend to observe fewer
core genes. The fitted binomial mixture model also gives an estimate of the final number of core gene
clusters, i.e. those still left after having observed &lsquo;infinite&rsquo; many genomes.
</p>
<p>The detection probability of core genes should be 1.0, but can at times be set fractionally smaller.
This means you accept that even core genes are not always detected in every genome, e.g. they may be
there, but your gene prediction has missed them. Notice that setting the &lsquo;<span class="samp">&#8288;core.detect.prob&#8288;</span>&rsquo; to less
than 1.0 may affect the core gene size estimate dramatically.
</p>


<h3>Value</h3>

<p><code><a href="#topic+binomixEstimate">binomixEstimate</a></code> returns a <code>list</code> with two components, the &lsquo;<span class="samp">&#8288;BIC.tbl&#8288;</span>&rsquo;
and &lsquo;<span class="samp">&#8288;Mix.tbl&#8288;</span>&rsquo;.
</p>
<p>The &lsquo;<span class="samp">&#8288;BIC.tbl&#8288;</span>&rsquo; is a <code>tibble</code> listing, in each row, the results for each number of components
used, given by the input &lsquo;<span class="samp">&#8288;K.range&#8288;</span>&rsquo;. The column &lsquo;<span class="samp">&#8288;Core.size&#8288;</span>&rsquo; is the estimated number of
core gene families, the column &lsquo;<span class="samp">&#8288;Pan.size&#8288;</span>&rsquo; is the estimated pan-genome size. The column
&lsquo;<span class="samp">&#8288;BIC&#8288;</span>&rsquo; is the Bayesian Information Criterion (Schwarz, 1978) that should be used to choose the
optimal component number (&lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo;). The number of components where &lsquo;<span class="samp">&#8288;BIC&#8288;</span>&rsquo; is minimized is the
optimum. If minimum &lsquo;<span class="samp">&#8288;BIC&#8288;</span>&rsquo; is reached for the largest &lsquo;<span class="samp">&#8288;K&#8288;</span>&rsquo; value you should extend the
&lsquo;<span class="samp">&#8288;K.range&#8288;</span>&rsquo; to larger values and re-fit. The function will issue
a <code>warning</code> to remind you of this.
</p>
<p>The &lsquo;<span class="samp">&#8288;Mix.tbl&#8288;</span>&rsquo; is a <code>tibble</code> with estimates from the mixture models. The column &lsquo;<span class="samp">&#8288;Component&#8288;</span>&rsquo;
indicates the model, i.e. all rows where &lsquo;<span class="samp">&#8288;Component&#8288;</span>&rsquo; has the same value are from the same model.
There will be 3 rows for 3-component model, 4 rows for 4-component, etc. The column &lsquo;<span class="samp">&#8288;Detection.prob&#8288;</span>&rsquo;
contain the estimated detection probabilities for each component of the mixture models. A 
&lsquo;<span class="samp">&#8288;Mixing.proportion&#8288;</span>&rsquo; is the proportion of the gene clusters having the corresponding &lsquo;<span class="samp">&#8288;Detection.prob&#8288;</span>&rsquo;,
i.e. if core genes have &lsquo;<span class="samp">&#8288;Detection.prob&#8288;</span>&rsquo; 1.0, the corresponding &lsquo;<span class="samp">&#8288;Mixing.proportion&#8288;</span>&rsquo; (same row)
indicates how large fraction of the gene families are core genes.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Hogg, J.S., Hu, F.Z, Janto, B., Boissy, R., Hayes, J., Keefe, R., Post, J.C., Ehrlich, G.D. (2007).
Characterization and modeling of the Haemophilus influenzae core- and supra-genomes based on the
complete genomic sequences of Rd and 12 clinical nontypeable strains. Genome Biology, 8:R103.
</p>
<p>Snipen, L., Almoy, T., Ussery, D.W. (2009). Microbial comparative pan-genomics using binomial
mixture models. BMC Genomics, 10:385.
</p>
<p>Snipen, L., Ussery, D.W. (2012). A domain sequence approach to pangenomics: Applications to
Escherichia coli. F1000 Research, 1:19.
</p>
<p>Schwarz, G. (1978). Estimating the Dimension of a Model. The Annals of Statistics, 6(2):461-464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panMatrix">panMatrix</a></code>, <code><a href="#topic+chao">chao</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading an example pan-matrix
data(xmpl.panmat)

# Estimating binomial mixture models
binmix.lst &lt;- binomixEstimate(xmpl.panmat, K.range = 3:8)
print(binmix.lst$BIC.tbl) # minimum BIC at 3 components

## Not run: 
# The pan-genome gene distribution as a pie-chart
library(ggplot2)
ncomp &lt;- 3
binmix.lst$Mix.tbl %&gt;% 
  filter(Components == ncomp) %&gt;% 
  ggplot() +
  geom_col(aes(x = "", y = Mixing.proportion, fill = Detection.prob)) +
  coord_polar(theta = "y") +
  labs(x = "", y = "", title = "Pan-genome gene distribution") +
  scale_fill_gradientn(colors = c("pink", "orange", "green", "cyan", "blue"))
  
# The distribution in an average genome
binmix.lst$Mix.tbl %&gt;% 
  filter(Components == ncomp) %&gt;% 
  mutate(Single = Mixing.proportion * Detection.prob) %&gt;%
  ggplot() +
  geom_col(aes(x = "", y = Single, fill = Detection.prob)) +
  coord_polar(theta = "y") +
  labs(x = "", y = "", title = "Average genome gene distribution") +
  scale_fill_gradientn(colors = c("pink", "orange", "green", "cyan", "blue"))

## End(Not run)

</code></pre>

<hr>
<h2 id='blastpAllAll'>Making BLAST search all against all genomes</h2><span id='topic+blastpAllAll'></span>

<h3>Description</h3>

<p>Runs a reciprocal all-against-all BLAST search to look for similarity of proteins
within and across genomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blastpAllAll(
  prot.files,
  out.folder,
  e.value = 1,
  job = 1,
  threads = 1,
  start.at = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blastpAllAll_+3A_prot.files">prot.files</code></td>
<td>
<p>A vector with FASTA filenames.</p>
</td></tr>
<tr><td><code id="blastpAllAll_+3A_out.folder">out.folder</code></td>
<td>
<p>The folder where the result files should end up.</p>
</td></tr>
<tr><td><code id="blastpAllAll_+3A_e.value">e.value</code></td>
<td>
<p>The chosen E-value threshold in BLAST.</p>
</td></tr>
<tr><td><code id="blastpAllAll_+3A_job">job</code></td>
<td>
<p>An integer to separate multiple jobs.</p>
</td></tr>
<tr><td><code id="blastpAllAll_+3A_threads">threads</code></td>
<td>
<p>The number of CPU's to use.</p>
</td></tr>
<tr><td><code id="blastpAllAll_+3A_start.at">start.at</code></td>
<td>
<p>An integer to specify where in the file-list to start BLASTing.</p>
</td></tr>
<tr><td><code id="blastpAllAll_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code> some text output is produced to monitor the progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A basic step in pangenomics and many other comparative studies is to cluster proteins into
groups or families. One commonly used approach is based on BLASTing. This function uses the
&lsquo;<span class="samp">&#8288;blast+&#8288;</span>&rsquo; software available for free from NCBI (Camacho et al, 2009). More precisely, the blastp
algorithm with the BLOSUM45 scoring matrix and all composition based statistics turned off.
</p>
<p>A vector listing FASTA files of protein sequences is given as input in &lsquo;<span class="samp">&#8288;prot.files&#8288;</span>&rsquo;. These files
must have the genome_id in the first token of every header, and in their filenames as well, i.e. all input
files should first be prepared by <code><a href="#topic+panPrep">panPrep</a></code> to ensure this. Note that only protein sequences
are considered here. If your coding genes are stored as DNA, please translate them to protein prior to
using this function, see <code><a href="microseq.html#topic+translate">translate</a></code>.
</p>
<p>In the first version of this package we used reciprocal BLASTing, i.e. we computed both genome A against
B and B against A. This may sometimes produce slightly different results, but in reality this is too
costly compared to its gain, and we now only make one of the above searches. This basically halves the
number of searches. This step is still very time consuming for larger number of genomes. Note that the 
protein files are sorted by the genome_id (part of filename) inside this function. This is to ensure a 
consistent ordering irrespective of how they are enterred.
</p>
<p>For every pair of genomes a result file is produced. If two genomes have genome_id's &lsquo;<span class="samp">&#8288;GID111&#8288;</span>&rsquo;,
and &lsquo;<span class="samp">&#8288;GID222&#8288;</span>&rsquo; then the result file &lsquo;<span class="samp">&#8288;GID222_vs_GID111.txt&#8288;</span>&rsquo; will
be found in &lsquo;<span class="samp">&#8288;out.folder&#8288;</span>&rsquo; after the completion of this search. The last of the two genome_id is always
the first in alphabetical order of the two.
</p>
<p>The &lsquo;<span class="samp">&#8288;out.folder&#8288;</span>&rsquo; is scanned for already existing result files, and <code><a href="#topic+blastpAllAll">blastpAllAll</a></code> never
overwrites an existing result file. If a file with the name &lsquo;<span class="samp">&#8288;GID111_vs_GID222.txt&#8288;</span>&rsquo; already exists in
the &lsquo;<span class="samp">&#8288;out.folder&#8288;</span>&rsquo;, this particular search is skipped. This makes it possible to run multiple jobs in
parallell, writing to the same &lsquo;<span class="samp">&#8288;out.folder&#8288;</span>&rsquo;. It also makes it possible to add new genomes, and only
BLAST the new combinations without repeating previous comparisons. 
</p>
<p>This search can be slow if the genomes contain many proteins and it scales quadratically in the number of
input files. It is best suited for the study of a smaller number of genomes. By
starting multiple R sessions, you can speed up the search by running <code><a href="#topic+blastpAllAll">blastpAllAll</a></code> from each R
session, using the same &lsquo;<span class="samp">&#8288;out.folder&#8288;</span>&rsquo; but different integers for the <code>job</code> option. At the same
time you may also want to start the BLASTing at different places in the file-list, by giving larger values
to the argument <code>start.at</code>. This is 1 by default, i.e. the BLASTing starts at the first protein file.
If you are using a multicore computer you can also increase the number of CPUs by increasing <code>threads</code>.
</p>
<p>The result files are tab-separated text files, and can be read into R, but more
commonly they are used as input to <code><a href="#topic+bDist">bDist</a></code> to compute distances between sequences for subsequent
clustering.
</p>


<h3>Value</h3>

<p>The function produces a result file for each pair of files listed in &lsquo;<span class="samp">&#8288;prot.files&#8288;</span>&rsquo;.
These result files are located in <code>out.folder</code>. Existing files are never overwritten by
<code><a href="#topic+blastpAllAll">blastpAllAll</a></code>, if you want to re-compute something, delete the corresponding result files first.
</p>


<h3>Note</h3>

<p>The &lsquo;<span class="samp">&#8288;blast+&#8288;</span>&rsquo; software must be installed on the system for this function to work, i.e. the command
&lsquo;<span class="samp">&#8288;system("makeblastdb -help")&#8288;</span>&rsquo; must be recognized as valid commands if you
run them in the Console window.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Camacho, C., Coulouris, G., Avagyan, V., Ma, N., Papadopoulos, J., Bealer, K., Madden, T.L.
(2009). BLAST+: architecture and applications. BMC Bioinformatics, 10:421.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panPrep">panPrep</a></code>, <code><a href="#topic+bDist">bDist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This example requires the external BLAST+ software
# Using protein files in this package
pf &lt;- file.path(path.package("micropan"), "extdata",
                str_c("xmpl_GID", 1:3, ".faa.xz"))

# We need to uncompress them first...
prot.files &lt;- tempfile(fileext = c("_GID1.faa.xz","_GID2.faa.xz","_GID3.faa.xz"))
ok &lt;- file.copy(from = pf, to = prot.files)
prot.files &lt;- unlist(lapply(prot.files, xzuncompress))

# Blasting all versus all
out.dir &lt;- "."
blastpAllAll(prot.files, out.folder = out.dir)

# Reading results, and computing blast.distances
blast.files &lt;- list.files(out.dir, pattern = "GID[0-9]+_vs_GID[0-9]+.txt")
blast.distances &lt;- bDist(file.path(out.dir, blast.files))

# ...and cleaning...
ok &lt;- file.remove(prot.files)
ok &lt;- file.remove(file.path(out.dir, blast.files))

## End(Not run)

</code></pre>

<hr>
<h2 id='chao'>The Chao lower bound estimate of pan-genome size</h2><span id='topic+chao'></span>

<h3>Description</h3>

<p>Computes the Chao lower bound estimated number of gene clusters in a pan-genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chao(pan.matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chao_+3A_pan.matrix">pan.matrix</code></td>
<td>
<p>A pan-matrix, see <code><a href="#topic+panMatrix">panMatrix</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The size of a pan-genome is the number of gene clusters in it, both those observed and those
not yet observed.
</p>
<p>The input &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo; is a a matrix with one row for each
genome and one column for each observed gene cluster in the pan-genome. See <code><a href="#topic+panMatrix">panMatrix</a></code>
for how to construct this.
</p>
<p>The number of observed gene clusters is simply the number of columns in &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo;. The
number of gene clusters not yet observed is estimated by the Chao lower bound estimator (Chao, 1987).
This is based solely on the number of clusters observed in 1 and 2 genomes. It is a very simple and
conservative estimator, i.e. it is more likely to be too small than too large.
</p>


<h3>Value</h3>

<p>The function returns an integer, the estimated pan-genome size. This includes both the number
of gene clusters observed so far, as well as the estimated number not yet seen.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Chao, A. (1987). Estimating the population size for capture-recapture data with unequal
catchability. Biometrics, 43:783-791.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panMatrix">panMatrix</a></code>, <code><a href="#topic+binomixEstimate">binomixEstimate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a pan-matrix in this package
data(xmpl.panmat)

# Estimating the pan-genome size using the Chao estimator
chao.pansize &lt;- chao(xmpl.panmat)

</code></pre>

<hr>
<h2 id='dClust'>Clustering sequences based on domain sequence</h2><span id='topic+dClust'></span>

<h3>Description</h3>

<p>Proteins are clustered by their sequence of protein domains. A domain sequence is the
ordered sequence of domains in the protein. All proteins having identical domain sequence are assigned
to the same cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dClust(hmmer.tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dClust_+3A_hmmer.tbl">hmmer.tbl</code></td>
<td>
<p>A <code>tibble</code> of results from a <code><a href="#topic+hmmerScan">hmmerScan</a></code> against a domain database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A domain sequence is simply the ordered list of domains occurring in a protein. Not all proteins
contain known domains, but those who do will have from one to several domains, and these can be ordered
forming a sequence. Since domains can be more or less conserved, two proteins can be quite different in
their amino acid sequence, and still share the same domains. Describing, and grouping, proteins by their
domain sequence was proposed by Snipen &amp; Ussery (2012) as an alternative to clusters based on pairwise
alignments, see <code><a href="#topic+bClust">bClust</a></code>. Domain sequence clusters are less influenced by gene prediction errors.
</p>
<p>The input is a <code>tibble</code> of the type produced by <code><a href="#topic+readHmmer">readHmmer</a></code>. Typically, it is the
result of scanning proteins (using <code><a href="#topic+hmmerScan">hmmerScan</a></code>) against Pfam-A or any other HMMER3 database
of protein domains. It is highly reccomended that you remove overlapping hits in &lsquo;<span class="samp">&#8288;hmmer.tbl&#8288;</span>&rsquo; before
you pass it as input to <code><a href="#topic+dClust">dClust</a></code>. Use the function <code><a href="#topic+hmmerCleanOverlap">hmmerCleanOverlap</a></code> for this.
Overlapping hits are in some cases real hits, but often the poorest of them are artifacts.
</p>


<h3>Value</h3>

<p>The output is a numeric vector with one element for each unique sequence in the &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo;
column of the input &lsquo;<span class="samp">&#8288;hmmer.tbl&#8288;</span>&rsquo;. Sequences with identical number belong to the same cluster. The
name of each element identifies the sequence.
</p>
<p>This vector also has an attribute called &lsquo;<span class="samp">&#8288;cluster.info&#8288;</span>&rsquo; which is a character vector containing the
domain sequences. The first element is the domain sequence for cluster 1, the second for cluster 2, etc.
In this way you can, in addition to clustering the sequences, also see which domains the sequences of a
particular cluster share.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Snipen, L. Ussery, D.W. (2012). A domain sequence approach to pangenomics: Applications
to Escherichia coli. F1000 Research, 1:19.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panPrep">panPrep</a></code>, <code><a href="#topic+hmmerScan">hmmerScan</a></code>, <code><a href="#topic+readHmmer">readHmmer</a></code>,
<code><a href="#topic+hmmerCleanOverlap">hmmerCleanOverlap</a></code>, <code><a href="#topic+bClust">bClust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># HMMER3 result files in this package
hf &lt;- file.path(path.package("micropan"), "extdata", 
                str_c("GID", 1:3, "_vs_microfam.hmm.txt.xz"))

# We need to uncompress them first...
hmm.files &lt;- tempfile(fileext = rep(".xz", length(hf)))
ok &lt;- file.copy(from = hf, to = hmm.files)
hmm.files &lt;- unlist(lapply(hmm.files, xzuncompress))

# Reading the HMMER3 results, cleaning overlaps...
hmmer.tbl &lt;- NULL
for(i in 1:3){
  readHmmer(hmm.files[i]) %&gt;% 
    hmmerCleanOverlap() %&gt;% 
    bind_rows(hmmer.tbl) -&gt; hmmer.tbl
}

# The clustering
clst &lt;- dClust(hmmer.tbl)

# ...and cleaning...
ok &lt;- file.remove(hmm.files)

</code></pre>

<hr>
<h2 id='distJaccard'>Computing Jaccard distances between genomes</h2><span id='topic+distJaccard'></span>

<h3>Description</h3>

<p>Computes the Jaccard distances between all pairs of genomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distJaccard(pan.matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distJaccard_+3A_pan.matrix">pan.matrix</code></td>
<td>
<p>A pan-matrix, see <code><a href="#topic+panMatrix">panMatrix</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jaccard index between two sets is defined as the size of the intersection of
the sets divided by the size of the union. The Jaccard distance is simply 1 minus the Jaccard index.
</p>
<p>The Jaccard distance between two genomes describes their degree of overlap with respect to gene
cluster content. If the Jaccard distance is 0.0, the two genomes contain identical gene clusters.
If it is 1.0 the two genomes are non-overlapping. The difference between a genomic fluidity (see
<code><a href="#topic+fluidity">fluidity</a></code>) and a Jaccard distance is small, they both measure overlap between genomes,
but fluidity is computed for the population by averaging over many pairs, while Jaccard distances are
computed for every pair. Note that only presence/absence of gene clusters are considered, not multiple
occurrences.
</p>
<p>The input &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo; is typically constructed by <code><a href="#topic+panMatrix">panMatrix</a></code>.
</p>


<h3>Value</h3>

<p>A <code>dist</code> object (see <code><a href="stats.html#topic+dist">dist</a></code>) containing all pairwise Jaccard distances
between genomes.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panMatrix">panMatrix</a></code>, <code><a href="#topic+fluidity">fluidity</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a pan-matrix in this package
data(xmpl.panmat)

# Jaccard distances
Jdist &lt;- distJaccard(xmpl.panmat)

# Making a dendrogram based on the distances,
# see example for distManhattan

</code></pre>

<hr>
<h2 id='distManhattan'>Computing Manhattan distances between genomes</h2><span id='topic+distManhattan'></span>

<h3>Description</h3>

<p>Computes the (weighted) Manhattan distances beween all pairs of genomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distManhattan(pan.matrix, scale = 0, weights = rep(1, ncol(pan.matrix)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distManhattan_+3A_pan.matrix">pan.matrix</code></td>
<td>
<p>A pan-matrix, see <code><a href="#topic+panMatrix">panMatrix</a></code> for details.</p>
</td></tr>
<tr><td><code id="distManhattan_+3A_scale">scale</code></td>
<td>
<p>An optional scale to control how copy numbers should affect the distances.</p>
</td></tr>
<tr><td><code id="distManhattan_+3A_weights">weights</code></td>
<td>
<p>Vector of optional weights of gene clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Manhattan distance is defined as the sum of absolute elementwise differences between
two vectors. Each genome is represented as a vector (row) of integers in &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo;. The
Manhattan distance between two genomes is the sum of absolute difference between these rows. If
two rows (genomes) of the &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo; are identical, the corresponding Manhattan distance
is &lsquo;<span class="samp">&#8288;0.0&#8288;</span>&rsquo;.
</p>
<p>The &lsquo;<span class="samp">&#8288;scale&#8288;</span>&rsquo; can be used to control how copy number differences play a role in the distances
computed. Usually we assume that going from 0 to 1 copy of a gene is the big change of the genome,
and going from 1 to 2 (or more) copies is less. Prior to computing the Manhattan distance, the
&lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo; is transformed according to the following affine mapping: If the original value in
&lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; is not 0, then the transformed value is &lsquo;<span class="samp">&#8288;1 + (x-1)*scale&#8288;</span>&rsquo;.
Note that with &lsquo;<span class="samp">&#8288;scale=0.0&#8288;</span>&rsquo; (default) this will result in 1 regardless of how large &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; was.
In this case the Manhattan distance only distinguish between presence and absence of gene clusters.
If &lsquo;<span class="samp">&#8288;scale=1.0&#8288;</span>&rsquo; the value &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; is left untransformed. In this case the difference between 1
copy and 2 copies is just as big as between 1 copy and 0 copies. For any &lsquo;<span class="samp">&#8288;scale&#8288;</span>&rsquo; between 0.0 and
1.0 the transformed value is shrunk towards 1, but a certain effect of larger copy numbers is still
present. In this way you can decide if the distances between genomes should be affected, and to what
degree, by differences in copy numbers beyond 1. Notice that as long as &lsquo;<span class="samp">&#8288;scale=0.0&#8288;</span>&rsquo; (and no
weighting) the Manhattan distance has a nice interpretation, namely the number of gene clusters that
differ in present/absent status between two genomes.
</p>
<p>When summing the difference across gene clusters we can also up- or downweight some clusters compared
to others. The vector &lsquo;<span class="samp">&#8288;weights&#8288;</span>&rsquo; must contain one value for each column in &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo;. The
default is to use flat weights, i.e. all clusters count equal. See <code><a href="#topic+geneWeights">geneWeights</a></code> for
alternative weighting strategies.
</p>


<h3>Value</h3>

<p>A <code>dist</code> object (see <code><a href="stats.html#topic+dist">dist</a></code>) containing all pairwise Manhattan distances
between genomes.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panMatrix">panMatrix</a></code>, <code><a href="#topic+distJaccard">distJaccard</a></code>, <code><a href="#topic+geneWeights">geneWeights</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a pan-matrix in this package
data(xmpl.panmat)

# Manhattan distances between genomes
Mdist &lt;- distManhattan(xmpl.panmat)

## Not run: 
# Making a dendrogram based on shell-weighted distances
library(ggdendro)
weights &lt;- geneWeights(xmpl.panmat, type = "shell")
Mdist &lt;- distManhattan(xmpl.panmat, weights = weights)
ggdendrogram(dendro_data(hclust(Mdist, method = "average")),
  rotate = TRUE, theme_dendro = FALSE) +
  labs(x = "Genomes", y = "Shell-weighted Manhattan distance", title = "Pan-genome dendrogram")

## End(Not run)

</code></pre>

<hr>
<h2 id='entrezDownload'>Downloading genome data</h2><span id='topic+entrezDownload'></span>

<h3>Description</h3>

<p>Retrieving genomes from NCBI using the Entrez programming utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entrezDownload(accession, out.file, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entrezDownload_+3A_accession">accession</code></td>
<td>
<p>A character vector containing a set of valid accession numbers at the NCBI
Nucleotide database.</p>
</td></tr>
<tr><td><code id="entrezDownload_+3A_out.file">out.file</code></td>
<td>
<p>Name of the file where downloaded sequences should be written in FASTA format.</p>
</td></tr>
<tr><td><code id="entrezDownload_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if textual output should be given during execution, to monitor
the download progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Entrez programming utilities is a toolset for automatic download of data from the
NCBI databases, see <a href="https://www.ncbi.nlm.nih.gov/books/NBK25500/">E-utilities Quick Start</a>
for details. <code><a href="#topic+entrezDownload">entrezDownload</a></code> can be used to download genomes from the NCBI Nucleotide
database through these utilities.
</p>
<p>The argument &lsquo;<span class="samp">&#8288;accession&#8288;</span>&rsquo; must be a set of valid accession numbers at NCBI Nucleotide, typically
all accession numbers related to a genome (chromosomes, plasmids, contigs, etc). For completed genomes,
where the number of sequences is low, &lsquo;<span class="samp">&#8288;accession&#8288;</span>&rsquo; is typically a single text listing all accession
numbers separated by commas. In the case of some draft genomes having a large number of contigs, the
accession numbers must be split into several comma-separated texts. The reason for this is that Entrez
will not accept too many queries in one chunk. 
</p>
<p>The downloaded sequences are saved in &lsquo;<span class="samp">&#8288;out.file&#8288;</span>&rsquo; on your system. This will be a FASTA formatted file.
Note that all downloaded sequences end up in this file. If you want to download multiple genomes,
you call <code><a href="#topic+entrezDownload">entrezDownload</a></code> multiple times and store in multiple files.
</p>


<h3>Value</h3>

<p>The name of the resulting FASTA file is returned (same as <code>out.file</code>), but the real result of
this function is the creation of the file itself.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAccessions">getAccessions</a></code>, <code><a href="microseq.html#topic+readFasta">readFasta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Accession numbers for the chromosome and plasmid of Buchnera aphidicola, strain APS
acc &lt;- "BA000003.2,AP001071.1"
genome.file &lt;- tempfile(pattern = "Buchnera_aphidicola", fileext = ".fna")
txt &lt;- entrezDownload(acc, out.file = genome.file)

# ...cleaning...
ok &lt;- file.remove(genome.file)

## End(Not run)

</code></pre>

<hr>
<h2 id='fluidity'>Computing genomic fluidity for a pan-genome</h2><span id='topic+fluidity'></span>

<h3>Description</h3>

<p>Computes the genomic fluidity, which is a measure of population diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluidity(pan.matrix, n.sim = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluidity_+3A_pan.matrix">pan.matrix</code></td>
<td>
<p>A pan-matrix, see <code><a href="#topic+panMatrix">panMatrix</a></code> for details.</p>
</td></tr>
<tr><td><code id="fluidity_+3A_n.sim">n.sim</code></td>
<td>
<p>An integer specifying the number of random samples to use in the computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genomic fluidity between two genomes is defined as the number of unique gene
families divided by the total number of gene families (Kislyuk et al, 2011). This is averaged
over &lsquo;<span class="samp">&#8288;n.sim&#8288;</span>&rsquo; random pairs of genomes to obtain a population estimate.
</p>
<p>The genomic fluidity between two genomes describes their degree of overlap with respect to gene
cluster content. If the fluidity is 0.0, the two genomes contain identical gene clusters. If it
is 1.0 the two genomes are non-overlapping. The difference between a Jaccard distance (see
<code><a href="#topic+distJaccard">distJaccard</a></code>) and genomic fluidity is small, they both measure overlap between
genomes, but fluidity is computed for the population by averaging over many pairs, while Jaccard
distances are computed for every pair. Note that only presence/absence of gene clusters are
considered, not multiple occurrences.
</p>
<p>The input &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo; is typically constructed by <code><a href="#topic+panMatrix">panMatrix</a></code>.
</p>


<h3>Value</h3>

<p>A vector with two elements, the mean fluidity and its sample standard deviation over
the &lsquo;<span class="samp">&#8288;n.sim&#8288;</span>&rsquo; computed values.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Kislyuk, A.O., Haegeman, B., Bergman, N.H., Weitz, J.S. (2011). Genomic fluidity:
an integrative view of gene diversity within microbial populations. BMC Genomics, 12:32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panMatrix">panMatrix</a></code>, <code><a href="#topic+distJaccard">distJaccard</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a pan-matrix in this package
data(xmpl.panmat)

# Fluidity based on this pan-matrix
fluid &lt;- fluidity(xmpl.panmat)

</code></pre>

<hr>
<h2 id='geneWeights'>Gene cluster weighting</h2><span id='topic+geneWeights'></span>

<h3>Description</h3>

<p>This function computes weights for gene cluster according to their distribution in a pan-genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geneWeights(pan.matrix, type = c("shell", "cloud"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneWeights_+3A_pan.matrix">pan.matrix</code></td>
<td>
<p>A pan-matrix, see <code><a href="#topic+panMatrix">panMatrix</a></code> for details.</p>
</td></tr>
<tr><td><code id="geneWeights_+3A_type">type</code></td>
<td>
<p>A text indicating the weighting strategy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When computing distances between genomes or a PCA, it is possible to give weights to the
different gene clusters, emphasizing certain aspects.
</p>
<p>As proposed by Snipen &amp; Ussery (2010), we have implemented two types of weighting: The default
&lsquo;<span class="samp">&#8288;"shell"&#8288;</span>&rsquo; type means gene families occuring frequently in the genomes, denoted shell-genes, are
given large weight (close to 1) while those occurring rarely are given small weight (close to 0).
The opposite is the &lsquo;<span class="samp">&#8288;"cloud"&#8288;</span>&rsquo; type of weighting. Genes observed in a minority of the genomes are
referred to as cloud-genes. Presumeably, the &lsquo;<span class="samp">&#8288;"shell"&#8288;</span>&rsquo; weighting will give distances/PCA reflecting
a more long-term evolution, since emphasis is put on genes who have just barely diverged away from the
core. The &lsquo;<span class="samp">&#8288;"cloud"&#8288;</span>&rsquo; weighting emphasizes those gene clusters seen rarely. Genomes with similar
patterns among these genes may have common recent history. A &lsquo;<span class="samp">&#8288;"cloud"&#8288;</span>&rsquo; weighting typically gives
a more erratic or &lsquo;noisy&rsquo; picture than the &lsquo;<span class="samp">&#8288;"shell"&#8288;</span>&rsquo; weighting.
</p>


<h3>Value</h3>

<p>A vector of weights, one for each column in <code>pan.matrix</code>.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Snipen, L., Ussery, D.W. (2010). Standard operating procedure for computing pangenome
trees. Standards in Genomic Sciences, 2:135-141.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panMatrix">panMatrix</a></code>, <code><a href="#topic+distManhattan">distManhattan</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for distManhattan

</code></pre>

<hr>
<h2 id='getAccessions'>Collecting contig accession numbers</h2><span id='topic+getAccessions'></span>

<h3>Description</h3>

<p>Retrieving the accession numbers for all contigs from a master record GenBank file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAccessions(master.record.accession, chunk.size = 99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAccessions_+3A_master.record.accession">master.record.accession</code></td>
<td>
<p>The accession number (single text) to a master record GenBank file having
the WGS entry specifying the accession numbers to all contigs of the WGS genome.</p>
</td></tr>
<tr><td><code id="getAccessions_+3A_chunk.size">chunk.size</code></td>
<td>
<p>The maximum number of accession numbers returned in one text.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to download a WGS genome (draft genome) using <code><a href="#topic+entrezDownload">entrezDownload</a></code> you will
need the accession number of every contig. This is found in the master record GenBank file, which is
available for every WGS genome. <code><a href="#topic+getAccessions">getAccessions</a></code> will extract these from the GenBank file and
return them in the apropriate way to be used by <code><a href="#topic+entrezDownload">entrezDownload</a></code>.
</p>
<p>The download API at NCBI will not tolerate too many accessions per query, and for this reason you need
to split the accessions for many contigs into several texts using <code>chunk.size</code>.
</p>


<h3>Value</h3>

<p>A character vector where each element is a text listing the accession numbers separated by comma.
Each vector element will contain no more than <code>chunk.size</code> accession numbers, see 
<code><a href="#topic+entrezDownload">entrezDownload</a></code> for details on this. The vector returned by <code><a href="#topic+getAccessions">getAccessions</a></code>
is typically used as input to <code><a href="#topic+entrezDownload">entrezDownload</a></code>.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+entrezDownload">entrezDownload</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The master record accession for the WGS genome Mycoplasma genitalium, strain G37
acc &lt;- getAccessions("AAGX00000000")
# Then we use this to download all contigs and save them
genome.file &lt;- tempfile(fileext = ".fna")
txt &lt;- entrezDownload(acc, out.file = genome.file)

# ...cleaning...
ok &lt;- file.remove(genome.file)

## End(Not run)

</code></pre>

<hr>
<h2 id='heaps'>Heaps law estimate</h2><span id='topic+heaps'></span>

<h3>Description</h3>

<p>Estimating if a pan-genome is open or closed based on a Heaps law model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heaps(pan.matrix, n.perm = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heaps_+3A_pan.matrix">pan.matrix</code></td>
<td>
<p>A pan-matrix, see <code><a href="#topic+panMatrix">panMatrix</a></code> for details.</p>
</td></tr>
<tr><td><code id="heaps_+3A_n.perm">n.perm</code></td>
<td>
<p>The number of random permutations of genome ordering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An open pan-genome means there will always be new gene clusters observed as long as new genomes
are being sequenced. This may sound controversial, but in a pragmatic view, an open pan-genome indicates
that the number of new gene clusters to be observed in future genomes is &lsquo;large&rsquo; (but not literally
infinite). Opposite, a closed pan-genome indicates we are approaching the end of new gene clusters. 
</p>
<p>This function is based on a Heaps law approach suggested by Tettelin et al (2008). The Heaps law model
is fitted to the number of new gene clusters observed when genomes are ordered in a random way. The model
has two parameters, an intercept and a decay parameter called &lsquo;<span class="samp">&#8288;alpha&#8288;</span>&rsquo;. If &lsquo;<span class="samp">&#8288;alpha&gt;1.0&#8288;</span>&rsquo; the
pan-genome is closed, if &lsquo;<span class="samp">&#8288;alpha&lt;1.0&#8288;</span>&rsquo; it is open.
</p>
<p>The number of permutations, &lsquo;<span class="samp">&#8288;n.perm&#8288;</span>&rsquo;, should be as large as possible, limited by computation time.
The default value of 100 is certainly a minimum.
</p>
<p>Word of caution: The Heaps law assumes independent sampling. If some of the genomes in the data set
form distinct sub-groups in the population, this may affect the results of this analysis severely.
</p>


<h3>Value</h3>

<p>A vector of two estimated parameters: The &lsquo;<span class="samp">&#8288;Intercept&#8288;</span>&rsquo; and the decay parameter &lsquo;<span class="samp">&#8288;alpha&#8288;</span>&rsquo;.
If &lsquo;<span class="samp">&#8288;alpha&lt;1.0&#8288;</span>&rsquo; the pan-genome is open, if &lsquo;<span class="samp">&#8288;alpha&gt;1.0&#8288;</span>&rsquo; it is closed.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Tettelin, H., Riley, D., Cattuto, C., Medini, D. (2008). Comparative genomics: the
bacterial pan-genome. Current Opinions in Microbiology, 12:472-477.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binomixEstimate">binomixEstimate</a></code>, <code><a href="#topic+chao">chao</a></code>, <code><a href="#topic+rarefaction">rarefaction</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a pan-matrix in this package 
data(xmpl.panmat)

# Estimating population openness
h.est &lt;- heaps(xmpl.panmat, n.perm = 500)
print(h.est)
# If alpha &lt; 1 it indicates an open pan-genome

</code></pre>

<hr>
<h2 id='hmmerCleanOverlap'>Removing overlapping hits from HMMER3 scans</h2><span id='topic+hmmerCleanOverlap'></span>

<h3>Description</h3>

<p>Removing hits to avoid overlapping HMMs on the same protein sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmerCleanOverlap(hmmer.tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmmerCleanOverlap_+3A_hmmer.tbl">hmmer.tbl</code></td>
<td>
<p>A table (<code>tibble</code>) with <code><a href="#topic+hmmerScan">hmmerScan</a></code> results, see <code><a href="#topic+readHmmer">readHmmer</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When scanning sequences against a profile HMM database using <code><a href="#topic+hmmerScan">hmmerScan</a></code>, we
often find that several patterns (HMMs) match in the same region of the query sequence, i.e. we have
overlapping hits. The function <code><a href="#topic+hmmerCleanOverlap">hmmerCleanOverlap</a></code> will remove the poorest overlapping hit
in a recursive way such that all overlaps are eliminated.
</p>
<p>The input is a <code>tibble</code> of the type produced by <code><a href="#topic+readHmmer">readHmmer</a></code>.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> which is a subset of the input, where some rows may have been deleted to
avoid overlapping hits.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmerScan">hmmerScan</a></code>, <code><a href="#topic+readHmmer">readHmmer</a></code>, <code><a href="#topic+dClust">dClust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the example in the Help-file for dClust.

</code></pre>

<hr>
<h2 id='hmmerScan'>Scanning a profile Hidden Markov Model database</h2><span id='topic+hmmerScan'></span>

<h3>Description</h3>

<p>Scanning FASTA formatted protein files against a database of pHMMs using the HMMER3
software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmmerScan(in.files, dbase, out.folder, threads = 0, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmmerScan_+3A_in.files">in.files</code></td>
<td>
<p>A character vector of file names.</p>
</td></tr>
<tr><td><code id="hmmerScan_+3A_dbase">dbase</code></td>
<td>
<p>The full path-name of the database to scan (text).</p>
</td></tr>
<tr><td><code id="hmmerScan_+3A_out.folder">out.folder</code></td>
<td>
<p>The name of the folder to put the result files.</p>
</td></tr>
<tr><td><code id="hmmerScan_+3A_threads">threads</code></td>
<td>
<p>Number of CPU's to use.</p>
</td></tr>
<tr><td><code id="hmmerScan_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if textual output should be given to monitor the progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The HMMER3 software is purpose-made for handling profile Hidden Markov Models (pHMM)
describing patterns in biological sequences (Eddy, 2008). This function will make calls to the
HMMER3 software to scan FASTA files of proteins against a pHMM database. 
</p>
<p>The files named in &lsquo;<span class="samp">&#8288;in.files&#8288;</span>&rsquo; must contain FASTA formatted protein sequences. These files
should be prepared by <code><a href="#topic+panPrep">panPrep</a></code> to make certain each sequence, as well as the file name,
has a GID-tag identifying their genome. The database named in &lsquo;<span class="samp">&#8288;db&#8288;</span>&rsquo; must be a HMMER3 formatted
database. It is typically the Pfam-A database, but you can also make your own HMMER3 databases, see
the HMMER3 documentation for help.
</p>
<p><code><a href="#topic+hmmerScan">hmmerScan</a></code> will query every input file against the named database. The database contains
profile Hidden Markov Models describing position specific sequence patterns. Each sequence in every
input file is scanned to see if some of the patterns can be matched to some degree. Each input file
results in an output file with the same GID-tag in the name. The result files give tabular output, and
are plain text files. See <code><a href="#topic+readHmmer">readHmmer</a></code> for how to read the results into R.
</p>
<p>Scanning large databases like Pfam-A takes time, usually several minutes per genome. The scan is set
up to use only 1 cpu per scan by default. By increasing <code>threads</code> you can utilize multiple CPUs, typically
on a computing cluster.
Our experience is that from a multi-core laptop it is better to start this function in default mode
from mutliple R-sessions. This function will not overwrite an existing result file, and multiple parallel
sessions can write results to the same folder.
</p>


<h3>Value</h3>

<p>This function produces files in the folder specified by &lsquo;<span class="samp">&#8288;out.folder&#8288;</span>&rsquo;. Existing files are
never overwritten by <code><a href="#topic+hmmerScan">hmmerScan</a></code>, if you want to re-compute something, delete the
corresponding result files first.
</p>


<h3>Note</h3>

<p>The HMMER3 software must be installed on the system for this function to work, i.e. the command
&lsquo;<span class="samp">&#8288;system("hmmscan -h")&#8288;</span>&rsquo; must be recognized as a valid command if you run it in the Console window.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Eddy, S.R. (2008). A Probabilistic Model of Local Sequence Alignment That Simplifies
Statistical Significance Estimation. PLoS Computational Biology, 4(5).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panPrep">panPrep</a></code>, <code><a href="#topic+readHmmer">readHmmer</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This example require the external software HMMER
# Using example files in this package
pf &lt;- file.path(path.package("micropan"), "extdata", "xmpl_GID1.faa.xz")
dbf &lt;- file.path(path.package("micropan"), "extdata",
                 str_c("microfam.hmm", c(".h3f.xz",".h3i.xz",".h3m.xz",".h3p.xz")))

# We need to uncompress them first...
prot.file &lt;- tempfile(pattern = "GID1.faa", fileext=".xz")
ok &lt;- file.copy(from = pf, to = prot.file)
prot.file &lt;- xzuncompress(prot.file)
db.files &lt;- str_c(tempfile(), c(".h3f.xz",".h3i.xz",".h3m.xz",".h3p.xz"))
ok &lt;- file.copy(from = dbf, to = db.files)
db.files &lt;- unlist(lapply(db.files, xzuncompress))
db.name &lt;- str_remove(db.files[1], "\\.[a-z0-9]+$")

# Scanning the FASTA file against microfam.hmm...
hmmerScan(in.files = prot.file, dbase = db.name, out.folder = ".")

# Reading results
hmm.file &lt;- file.path(".", str_c("GID1_vs_", basename(db.name), ".txt"))
hmm.tbl &lt;- readHmmer(hmm.file)

# ...and cleaning...
ok &lt;- file.remove(prot.file)
ok &lt;- file.remove(str_remove(db.files, ".xz"))

## End(Not run)

</code></pre>

<hr>
<h2 id='isOrtholog'>Identifies orthologs in gene clusters</h2><span id='topic+isOrtholog'></span>

<h3>Description</h3>

<p>Finds the ortholog sequences in every cluster based on pairwise distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isOrtholog(clustering, dist.tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isOrtholog_+3A_clustering">clustering</code></td>
<td>
<p>A vector of integers indicating the cluster for every sequence. Sequences with
the same number belong to the same cluster. The name of each element is the tag identifying the sequence.</p>
</td></tr>
<tr><td><code id="isOrtholog_+3A_dist.tbl">dist.tbl</code></td>
<td>
<p>A <code>tibble</code> with pairwise distances. The columns &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo; and
&lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo; contain tags identifying pairs of sequences. The column &lsquo;<span class="samp">&#8288;Distance&#8288;</span>&rsquo; contains the
distances, always a number from 0.0 to 1.0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>clustering</code> is typically produced by <code><a href="#topic+bClust">bClust</a></code>. The input
<code>dist.tbl</code> is typically produced by <code><a href="#topic+bDist">bDist</a></code>.
</p>
<p>The concept of orthologs is difficult for prokaryotes, and this function finds orthologs in a
simplistic way. For a given cluster, with members from many genomes, there is one ortholog from every
genome. In cases where a genome has two or more members in the same cluster, only one of these is an
ortholog, the rest are paralogs.
</p>
<p>Consider all sequences from the same genome belonging to the same cluster. The ortholog is defined as
the one having the smallest sum of distances to all other members of the same cluster, i.e. the one
closest to the &lsquo;center&rsquo; of the cluster.
</p>
<p>Note that the status as ortholog or paralog depends greatly on how clusters are defined in the first
place. If you allow large and diverse (and few) clusters, many sequences will be paralogs. If you define
tight and homogenous (and many) clusters, almost all sequences will be orthologs.
</p>


<h3>Value</h3>

<p>A vector of logicals with the same number of elements as the input &lsquo;<span class="samp">&#8288;clustering&#8288;</span>&rsquo;, indicating
if the corresponding sequence is an ortholog (<code>TRUE</code>) or not (<code>FALSE</code>). The name of each
element is copied from &lsquo;<span class="samp">&#8288;clustering&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bDist">bDist</a></code>, <code><a href="#topic+bClust">bClust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Loading distance data and their clustering results
data(list = c("xmpl.bdist","xmpl.bclst"))

# Finding orthologs
is.ortholog &lt;- isOrtholog(xmpl.bclst, xmpl.bdist)
# The orthologs are
which(is.ortholog)

## End(Not run)

</code></pre>

<hr>
<h2 id='panMatrix'>Computing the pan-matrix for a set of gene clusters</h2><span id='topic+panMatrix'></span>

<h3>Description</h3>

<p>A pan-matrix has one row for each genome and one column for each gene cluster, and
cell &lsquo;<span class="samp">&#8288;[i,j]&#8288;</span>&rsquo; indicates how many members genome &lsquo;<span class="samp">&#8288;i&#8288;</span>&rsquo; has in gene family &lsquo;<span class="samp">&#8288;j&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panMatrix(clustering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panMatrix_+3A_clustering">clustering</code></td>
<td>
<p>A named vector of integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pan-matrix is a central data structure for pan-genomic analysis. It is a matrix with
one row for each genome in the study, and one column for each gene cluster. Cell &lsquo;<span class="samp">&#8288;[i,j]&#8288;</span>&rsquo;
contains an integer indicating how many members genome &lsquo;<span class="samp">&#8288;i&#8288;</span>&rsquo; has in cluster &lsquo;<span class="samp">&#8288;j&#8288;</span>&rsquo;.
</p>
<p>The input <code>clustering</code> must be a named integer vector with one element for each sequence in the study,
typically produced by either <code><a href="#topic+bClust">bClust</a></code> or <code><a href="#topic+dClust">dClust</a></code>. The name of each element
is a text identifying every sequence. The value of each element indicates the cluster, i.e. those
sequences with identical values are in the same cluster. IMPORTANT: The name of each sequence must
contain the &lsquo;<span class="samp">&#8288;genome_id&#8288;</span>&rsquo; for each genome, i.e. they must of the form &lsquo;<span class="samp">&#8288;GID111_seq1&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;GID111_seq2&#8288;</span>&rsquo;,...
where the &lsquo;<span class="samp">&#8288;GIDxxx&#8288;</span>&rsquo; part indicates which genome the sequence belongs to. See <code><a href="#topic+panPrep">panPrep</a></code>
for details.
</p>
<p>The rows of the pan-matrix is named by the &lsquo;<span class="samp">&#8288;genome_id&#8288;</span>&rsquo; for every genome. The columns are just named
&lsquo;<span class="samp">&#8288;Cluster_x&#8288;</span>&rsquo; where &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; is an integer copied from &lsquo;<span class="samp">&#8288;clustering&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>An integer matrix with a row for each genome and a column for each sequence cluster.
The input vector &lsquo;<span class="samp">&#8288;clustering&#8288;</span>&rsquo; is attached as the attribute &lsquo;<span class="samp">&#8288;clustering&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bClust">bClust</a></code>, <code><a href="#topic+dClust">dClust</a></code>, <code><a href="#topic+distManhattan">distManhattan</a></code>,
<code><a href="#topic+distJaccard">distJaccard</a></code>, <code><a href="#topic+fluidity">fluidity</a></code>, <code><a href="#topic+chao">chao</a></code>,
<code><a href="#topic+binomixEstimate">binomixEstimate</a></code>, <code><a href="#topic+heaps">heaps</a></code>, <code><a href="#topic+rarefaction">rarefaction</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading clustering data in this package
data(xmpl.bclst)

# Pan-matrix based on the clustering
panmat &lt;- panMatrix(xmpl.bclst)

## Not run: 
# Plotting cluster distribution
library(ggplot2)
tibble(Clusters = as.integer(table(factor(colSums(panmat &gt; 0), levels = 1:nrow(panmat)))),
       Genomes = 1:nrow(panmat)) %&gt;% 
ggplot(aes(x = Genomes, y = Clusters)) +
geom_col()

## End(Not run)

</code></pre>

<hr>
<h2 id='panPca'>Principal component analysis of a pan-matrix</h2><span id='topic+panPca'></span>

<h3>Description</h3>

<p>Computes a principal component decomposition of a pan-matrix, with possible
scaling and weightings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panPca(pan.matrix, scale = 0, weights = rep(1, ncol(pan.matrix)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panPca_+3A_pan.matrix">pan.matrix</code></td>
<td>
<p>A pan-matrix, see <code><a href="#topic+panMatrix">panMatrix</a></code> for details.</p>
</td></tr>
<tr><td><code id="panPca_+3A_scale">scale</code></td>
<td>
<p>An optional scale to control how copy numbers should affect the distances.</p>
</td></tr>
<tr><td><code id="panPca_+3A_weights">weights</code></td>
<td>
<p>Vector of optional weights of gene clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A principal component analysis (PCA) can be computed for any matrix, also a pan-matrix.
The principal components will in this case be linear combinations of the gene clusters. One major
idea behind PCA is to truncate the space, e.g. instead of considering the genomes as points in a
high-dimensional space spanned by all gene clusters, we look for a few &lsquo;smart&rsquo; combinations
of the gene clusters, and visualize the genomes in a low-dimensional space spanned by these directions.
</p>
<p>The &lsquo;<span class="samp">&#8288;scale&#8288;</span>&rsquo; can be used to control how copy number differences play a role in the PCA. Usually
we assume that going from 0 to 1 copy of a gene is the big change of the genome, and going from 1 to
2 (or more) copies is less. Prior to computing the PCA, the &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo; is transformed according
to the following affine mapping: If the original value in &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo; is &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;, and &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo;
is not 0, then the transformed value is &lsquo;<span class="samp">&#8288;1 + (x-1)*scale&#8288;</span>&rsquo;. Note that with &lsquo;<span class="samp">&#8288;scale=0.0&#8288;</span>&rsquo;
(default) this will result in 1 regardless of how large &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; was. In this case the PCA only
distinguish between presence and absence of gene clusters. If &lsquo;<span class="samp">&#8288;scale=1.0&#8288;</span>&rsquo; the value &lsquo;<span class="samp">&#8288;x&#8288;</span>&rsquo; is
left untransformed. In this case the difference between 1 copy and 2 copies is just as big as between
1 copy and 0 copies. For any &lsquo;<span class="samp">&#8288;scale&#8288;</span>&rsquo; between 0.0 and 1.0 the transformed value is shrunk towards
1, but a certain effect of larger copy numbers is still present. In this way you can decide if the PCA
should be affected, and to what degree, by differences in copy numbers beyond 1.
</p>
<p>The PCA may also up- or downweight some clusters compared to others. The vector &lsquo;<span class="samp">&#8288;weights&#8288;</span>&rsquo; must
contain one value for each column in &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo;. The default is to use flat weights, i.e. all
clusters count equal. See <code><a href="#topic+geneWeights">geneWeights</a></code> for alternative weighting strategies.
</p>


<h3>Value</h3>

<p>A <code>list</code> with three tables:
</p>
<p>&lsquo;<span class="samp">&#8288;Evar.tbl&#8288;</span>&rsquo; has two columns, one listing the component number and one listing the relative 
explained variance for each component. The relative explained variance always sums to 1.0 over
all components. This value indicates the importance of each component, and it is always in
descending order, the first component being the most important.
This is typically the first result you look at after a PCA has been computed, as it indicates
how many components (directions) you need to capture the bulk of the total variation in the data.
</p>
<p>&lsquo;<span class="samp">&#8288;Scores.tbl&#8288;</span>&rsquo; has a column listing the &lsquo;<span class="samp">&#8288;GID.tag&#8288;</span>&rsquo; for each genome, and then one column for each
principal component. The columns are ordered corresponding to the elements in &lsquo;<span class="samp">&#8288;Evar&#8288;</span>&rsquo;. The
scores are the coordinates of each genome in the principal component space.
</p>
<p>&lsquo;<span class="samp">&#8288;Loadings.tbl&#8288;</span>&rsquo; is similar to &lsquo;<span class="samp">&#8288;Scores.tbl&#8288;</span>&rsquo; but contain values for each gene cluster
instead of each genome. The columns are ordered corresponding to the elements in &lsquo;<span class="samp">&#8288;Evar&#8288;</span>&rsquo;.
The loadings are the contributions from each gene cluster to the principal component directions.
NOTE: Only gene clusters having a non-zero variance is used in a PCA. Gene clusters with the
same value for every genome have no impact and are discarded from the &lsquo;<span class="samp">&#8288;Loadings&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distManhattan">distManhattan</a></code>, <code><a href="#topic+geneWeights">geneWeights</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a pan-matrix in this package
data(xmpl.panmat)

# Computing panPca
ppca &lt;- panPca(xmpl.panmat)

## Not run: 
# Plotting explained variance
library(ggplot2)
ggplot(ppca$Evar.tbl) +
  geom_col(aes(x = Component, y = Explained.variance))
# Plotting scores
ggplot(ppca$Scores.tbl) +
  geom_text(aes(x = PC1, y = PC2, label = GID.tag))
# Plotting loadings
ggplot(ppca$Loadings.tbl) +
  geom_text(aes(x = PC1, y = PC2, label = Cluster))

## End(Not run)

</code></pre>

<hr>
<h2 id='panPrep'>Preparing FASTA files for pan-genomics</h2><span id='topic+panPrep'></span>

<h3>Description</h3>

<p>Preparing a FASTA file before starting comparisons of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panPrep(in.file, genome_id, out.file, protein = TRUE, min.length = 10, discard = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panPrep_+3A_in.file">in.file</code></td>
<td>
<p>The name of a FASTA formatted file with protein or nucleotide sequences for coding
genes in a genome.</p>
</td></tr>
<tr><td><code id="panPrep_+3A_genome_id">genome_id</code></td>
<td>
<p>The Genome Identifier, see below.</p>
</td></tr>
<tr><td><code id="panPrep_+3A_out.file">out.file</code></td>
<td>
<p>Name of file where the prepared sequences will be written.</p>
</td></tr>
<tr><td><code id="panPrep_+3A_protein">protein</code></td>
<td>
<p>Logical, indicating if the &lsquo;<span class="samp">&#8288;in.file&#8288;</span>&rsquo; contains protein (<code>TRUE</code>) or
nucleotide (<code>FALSE</code>) sequences.</p>
</td></tr>
<tr><td><code id="panPrep_+3A_min.length">min.length</code></td>
<td>
<p>Minimum sequence length</p>
</td></tr>
<tr><td><code id="panPrep_+3A_discard">discard</code></td>
<td>
<p>A text, a regular expression, and sequences having a match against this in their
headerline will be discarded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will read the <code>in.file</code> and produce another, slightly modified, FASTA file
which is prepared for the comparisons using <code><a href="#topic+blastpAllAll">blastpAllAll</a></code>, <code><a href="#topic+hmmerScan">hmmerScan</a></code>
or any other method.
</p>
<p>The main purpose of <code><a href="#topic+panPrep">panPrep</a></code> is to make certain every sequence is labeled with a tag
called a &lsquo;<span class="samp">&#8288;genome_id&#8288;</span>&rsquo; identifying the genome from which it comes. This text contains the text
&ldquo;GID&rdquo; followed by an integer. This integer can be any integer as long as it is unique to every
genome in the study. If a genome has the text &ldquo;GID12345&rdquo; as identifier, then the
sequences in the file produced by <code><a href="#topic+panPrep">panPrep</a></code> will have headerlines starting with
&ldquo;GID12345_seq1&rdquo;, &ldquo;GID12345_seq2&rdquo;, &ldquo;GID12345_seq3&rdquo;...etc. This makes it possible
to quickly identify which genome every sequence belongs to.
</p>
<p>The &lsquo;<span class="samp">&#8288;genome_id&#8288;</span>&rsquo; is also added to the file name specified in &lsquo;<span class="samp">&#8288;out.file&#8288;</span>&rsquo;. For this reason the
&lsquo;<span class="samp">&#8288;out.file&#8288;</span>&rsquo; must have a file extension containing letters only. By convention, we expect FASTA
files to have one of the extensions &lsquo;<span class="samp">&#8288;.fsa&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;.faa&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;.fa&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;.fasta&#8288;</span>&rsquo;.
</p>
<p><code><a href="#topic+panPrep">panPrep</a></code> will also remove sequences shorter than <code>min.length</code>, removing stop codon
symbols (&lsquo;<span class="samp">&#8288;*&#8288;</span>&rsquo;), replacing alien characters with &lsquo;<span class="samp">&#8288;X&#8288;</span>&rsquo; and converting all sequences to upper-case.
If the input &lsquo;<span class="samp">&#8288;discard&#8288;</span>&rsquo; contains a regular expression, any sequences having a match to this in their
headerline are also removed. Example: If we use the <code>prodigal</code> software (see <code><a href="microseq.html#topic+findGenes">findGenes</a></code>)
to find proteins in a genome, partially predicted genes will have the text &lsquo;<span class="samp">&#8288;partial=10&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;partial=01&#8288;</span>&rsquo; in their headerline. Using &lsquo;<span class="samp">&#8288;discard= "partial=01|partial=10"&#8288;</span>&rsquo; will remove
these from the data set.
</p>


<h3>Value</h3>

<p>This function produces a FASTA formatted sequence file, and returns the name of this file.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmerScan">hmmerScan</a></code>, <code><a href="#topic+blastpAllAll">blastpAllAll</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using a protein file in this package
# We need to uncompress it first...
pf &lt;- file.path(path.package("micropan"),"extdata","xmpl.faa.xz")
prot.file &lt;- tempfile(fileext = ".xz")
ok &lt;- file.copy(from = pf, to = prot.file)
prot.file &lt;- xzuncompress(prot.file)

# Prepping it, using the genome_id "GID123"
prepped.file &lt;- panPrep(prot.file, genome_id = "GID123", out.file = tempfile(fileext = ".faa"))

# Reading the prepped file
prepped &lt;- readFasta(prepped.file)
head(prepped)

# ...and cleaning...
ok &lt;- file.remove(prot.file, prepped.file)

</code></pre>

<hr>
<h2 id='rarefaction'>Rarefaction curves for a pan-genome</h2><span id='topic+rarefaction'></span>

<h3>Description</h3>

<p>Computes rarefaction curves for a number of random permutations of genomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rarefaction(pan.matrix, n.perm = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rarefaction_+3A_pan.matrix">pan.matrix</code></td>
<td>
<p>A pan-matrix, see <code><a href="#topic+panMatrix">panMatrix</a></code> for details.</p>
</td></tr>
<tr><td><code id="rarefaction_+3A_n.perm">n.perm</code></td>
<td>
<p>The number of random genome orderings to use. If &lsquo;<span class="samp">&#8288;n.perm=1&#8288;</span>&rsquo; the fixed order of
the genomes in &lsquo;<span class="samp">&#8288;pan.matrix&#8288;</span>&rsquo; is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A rarefaction curve is simply the cumulative number of unique gene clusters we observe as
more and more genomes are being considered. The shape of this curve will depend on the order of the
genomes. This function will typically compute rarefaction curves for a number of (&lsquo;<span class="samp">&#8288;n.perm&#8288;</span>&rsquo;)
orderings. By using a large number of permutations, and then averaging over the results, the effect
of any particular ordering is smoothed.
</p>
<p>The averaged curve illustrates how many new gene clusters we observe for each new genome. If this
levels out and becomes flat, it means we expect few, if any, new gene clusters by sequencing more
genomes. The function <code><a href="#topic+heaps">heaps</a></code> can be used to estimate population openness based on this
principle.
</p>


<h3>Value</h3>

<p>A table with the curves in the columns. The first column is the number of genomes, while 
all other columns are the cumulative number of clusters, one column for each permutation.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heaps">heaps</a></code>, <code><a href="#topic+panMatrix">panMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a pan-matrix in this package 
data(xmpl.panmat)

# Rarefaction
rar.tbl &lt;- rarefaction(xmpl.panmat, n.perm = 1000)

## Not run: 
# Plotting
library(ggplot2)
library(tidyr)
rar.tbl %&gt;% 
  gather(key = "Permutation", value = "Clusters", -Genome) %&gt;% 
  ggplot(aes(x = Genome, y = Clusters, group = Permutation)) +
    geom_line()

## End(Not run)

</code></pre>

<hr>
<h2 id='readBlastSelf'>Reads BLAST result files</h2><span id='topic+readBlastSelf'></span><span id='topic+readBlastPair'></span>

<h3>Description</h3>

<p>Reads files from a search with blastpAllAll
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBlastSelf(blast.files, e.value = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readBlastSelf_+3A_blast.files">blast.files</code></td>
<td>
<p>A text vector of filenames.</p>
</td></tr>
<tr><td><code id="readBlastSelf_+3A_e.value">e.value</code></td>
<td>
<p>A threshold E-value to immediately discard (very) poor BLAST alignments.</p>
</td></tr>
<tr><td><code id="readBlastSelf_+3A_verbose">verbose</code></td>
<td>
<p>Logical, indicating if textual output should be given to monitor the progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The filenames given as input must refer to BLAST result files produced by <code><a href="#topic+blastpAllAll">blastpAllAll</a></code>.
</p>
<p>With <code>readBlastSelf</code> you only read the self-alignment results, i.e. blasting a genome against itself. With
<code>readBlastPair</code> you read all the other files, i.e. different genomes compared. You may use all blast file
names as input to both, they will select the proper files based on their names, e.g. GID1_vs_GID1.txt is read
by <code>readBlastSelf</code> while GID2_vs_GID1.txt is read by <code>readBlastPair</code>.
</p>
<p>Setting a small &lsquo;<span class="samp">&#8288;e.value&#8288;</span>&rsquo; threshold will filter the alignment, and may speed up this and later processing,
but you may also loose some important alignments for short sequences.
</p>
<p>Both these functions are used by <code><a href="#topic+bDist">bDist</a></code>. The reason we provide them separately is to allow the user
to complete this file reading before calling <code><a href="#topic+bDist">bDist</a></code>. If you have a huge number of files, a
skilled user may utilize parallell processing to speed up the reading. For normal size data sets (e.g. less than 100 genomes)
you should probably use <code><a href="#topic+bDist">bDist</a></code> directly.
</p>


<h3>Value</h3>

<p>The functions returns a table with columns &lsquo;<span class="samp">&#8288;Dbase&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;Bitscore&#8288;</span>&rsquo;
and &lsquo;<span class="samp">&#8288;Distance&#8288;</span>&rsquo;. Each row corresponds to a pair of sequences (a Dbase and a Query sequence) having at least
one BLAST hit between
them. All pairs <em>not</em> listed have distance 1.0 between them. You should normally bind the output from 
<code>readBlastSelf</code> to the ouptut from <code>readBlastPair</code> and use the result as input to <code><a href="#topic+bDist">bDist</a></code>.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bDist">bDist</a></code>, <code><a href="#topic+blastpAllAll">blastpAllAll</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using BLAST result files in this package...
prefix &lt;- c("GID1_vs_GID1_",
            "GID2_vs_GID1_",
            "GID3_vs_GID1_",
            "GID2_vs_GID2_",
            "GID3_vs_GID2_",
            "GID3_vs_GID3_")
bf &lt;- file.path(path.package("micropan"), "extdata", str_c(prefix, ".txt.xz"))

# We need to uncompress them first...
blast.files &lt;- tempfile(pattern = prefix, fileext = ".txt.xz")
ok &lt;- file.copy(from = bf, to = blast.files)
blast.files &lt;- unlist(lapply(blast.files, xzuncompress))

# Reading self-alignment files, then the other files
self.tbl &lt;- readBlastSelf(blast.files)
pair.tbl &lt;- readBlastPair(blast.files)

# ...and cleaning...
ok &lt;- file.remove(blast.files)

# See also examples for bDist

</code></pre>

<hr>
<h2 id='readHmmer'>Reading results from a HMMER3 scan</h2><span id='topic+readHmmer'></span>

<h3>Description</h3>

<p>Reading a text file produced by <code><a href="#topic+hmmerScan">hmmerScan</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readHmmer(hmmer.file, e.value = 1, use.acc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readHmmer_+3A_hmmer.file">hmmer.file</code></td>
<td>
<p>The name of a <code><a href="#topic+hmmerScan">hmmerScan</a></code> result file.</p>
</td></tr>
<tr><td><code id="readHmmer_+3A_e.value">e.value</code></td>
<td>
<p>Numeric threshold, hits with E-value above this are ignored (default is 1.0).</p>
</td></tr>
<tr><td><code id="readHmmer_+3A_use.acc">use.acc</code></td>
<td>
<p>Logical indicating if accession numbers should be used to identify the hits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads a text file produced by <code><a href="#topic+hmmerScan">hmmerScan</a></code>. By specifying a smaller
&lsquo;<span class="samp">&#8288;e.value&#8288;</span>&rsquo; you filter out poorer hits, and fewer results are returned. The option &lsquo;<span class="samp">&#8288;use.acc&#8288;</span>&rsquo;
should be turned off (FALSE) if you scan against your own database where accession numbers are lacking.
</p>


<h3>Value</h3>

<p>The results are returned in a &lsquo;<span class="samp">&#8288;tibble&#8288;</span>&rsquo; with columns &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo;,
&lsquo;<span class="samp">&#8288;Evalue&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;Score&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;Start&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;Stop&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;Description&#8288;</span>&rsquo;. &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo; is the tag
identifying each query sequence. &lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo; is the name or accession number for a pHMM in the database
describing patterns. The &lsquo;<span class="samp">&#8288;Evalue&#8288;</span>&rsquo; is the &lsquo;<span class="samp">&#8288;ievalue&#8288;</span>&rsquo; in the HMMER3 terminology. The &lsquo;<span class="samp">&#8288;Score&#8288;</span>&rsquo;
is the HMMER3 score for the match between &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo;. The &lsquo;<span class="samp">&#8288;Start&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;Stop&#8288;</span>&rsquo;
are the positions within the &lsquo;<span class="samp">&#8288;Query&#8288;</span>&rsquo; where the &lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo; (pattern) starts and stops.
&lsquo;<span class="samp">&#8288;Description&#8288;</span>&rsquo; is the description of the &lsquo;<span class="samp">&#8288;Hit&#8288;</span>&rsquo;. There is one line for each hit.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hmmerScan">hmmerScan</a></code>, <code><a href="#topic+hmmerCleanOverlap">hmmerCleanOverlap</a></code>, <code><a href="#topic+dClust">dClust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the examples in the Help-files for dClust and hmmerScan.

</code></pre>

<hr>
<h2 id='xmpl'>Data sets for use in examples</h2><span id='topic+xmpl'></span><span id='topic+xmpl.bdist'></span><span id='topic+xmpl.bclst'></span><span id='topic+xmpl.panmat'></span>

<h3>Description</h3>

<p>This data set contains several files with various objects used in examples
in some of the functions in the <code>micropan</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(xmpl.bdist)
data(xmpl.bclst)
data(xmpl.panmat)
</code></pre>


<h3>Details</h3>

<p>&lsquo;<span class="samp">&#8288;xmpl.bdist&#8288;</span>&rsquo; is a <code>tibble</code> with 4 columns holding all
BLAST distances between pairs of proteins in an example with 10 small genomes.
</p>
<p>&lsquo;<span class="samp">&#8288;xmpl.bclst&#8288;</span>&rsquo; is a clustering vector of all proteins in the
genomes from &lsquo;<span class="samp">&#8288;xmpl.bdist&#8288;</span>&rsquo;.
</p>
<p>&lsquo;<span class="samp">&#8288;xmpl.panmat&#8288;</span>&rsquo; is a pan-matrix with 10 rows and 1210 columns
computed from &lsquo;<span class="samp">&#8288;xmpl.bclst&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# BLAST distances, only the first 20 are displayed
data(xmpl.bdist)
head(xmpl.bdist)

# Clustering vector
data(xmpl.bclst)
print(xmpl.bclst[1:30])

# Pan-matrix
data(xmpl.panmat)
head(xmpl.panmat)

</code></pre>

<hr>
<h2 id='xzcompress'>Compressing and uncompressing text files</h2><span id='topic+xzcompress'></span><span id='topic+xzuncompress'></span>

<h3>Description</h3>

<p>These functions are adapted from the <code>R.utils</code> package from gzip to xz. Internally
<code>xzfile()</code> (see connections) is used to read (write) chunks to (from) the xz file. If the
process is interrupted before completed, the partially written output file is automatically removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xzcompress(
  filename,
  destname = sprintf("%s.xz", filename),
  temporary = FALSE,
  skip = FALSE,
  overwrite = FALSE,
  remove = TRUE,
  BFR.SIZE = 1e+07,
  compression = 6,
  ...
)

xzuncompress(
  filename,
  destname = gsub("[.]xz$", "", filename, ignore.case = TRUE),
  temporary = FALSE,
  skip = FALSE,
  overwrite = FALSE,
  remove = TRUE,
  BFR.SIZE = 1e+07,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xzcompress_+3A_filename">filename</code></td>
<td>
<p>Path name of input file.</p>
</td></tr>
<tr><td><code id="xzcompress_+3A_destname">destname</code></td>
<td>
<p>Pathname of output file.</p>
</td></tr>
<tr><td><code id="xzcompress_+3A_temporary">temporary</code></td>
<td>
<p>If TRUE, the output file is created in a temporary directory.</p>
</td></tr>
<tr><td><code id="xzcompress_+3A_skip">skip</code></td>
<td>
<p>If TRUE and the output file already exists, the output file is returned as is.</p>
</td></tr>
<tr><td><code id="xzcompress_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE and the output file already exists, the file is silently overwritting,
otherwise an exception is thrown (unless skip is TRUE).</p>
</td></tr>
<tr><td><code id="xzcompress_+3A_remove">remove</code></td>
<td>
<p>If TRUE, the input file is removed afterward, otherwise not.</p>
</td></tr>
<tr><td><code id="xzcompress_+3A_bfr.size">BFR.SIZE</code></td>
<td>
<p>The number of bytes read in each chunk.</p>
</td></tr>
<tr><td><code id="xzcompress_+3A_compression">compression</code></td>
<td>
<p>The compression level used (1-9).</p>
</td></tr>
<tr><td><code id="xzcompress_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the pathname of the output file. The number of bytes processed is returned as an attribute.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating small file
tf &lt;- tempfile()
cat(file=tf, "Hello world!")

# Compressing
tf.xz &lt;- xzcompress(tf)
print(file.info(tf.xz))

# Uncompressing
tf &lt;- xzuncompress(tf.xz)
print(file.info(tf))
file.remove(tf)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
