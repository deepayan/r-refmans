<!DOCTYPE html><html><head><title>Help for package pedigreeTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pedigreeTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pedigreeTools-package'><p>pedigreeTools: Versatile Functions for Working with Pedigrees</p></a></li>
<li><a href='#Dmat'><p>Mendelian sampling variance</p></a></li>
<li><a href='#editPed'><p>Edits a disordered or incomplete pedigree</p></a></li>
<li><a href='#getA'><p>Additive relationship matrix</p></a></li>
<li><a href='#getAInv'><p>Inverse of the additive relationship matrix</p></a></li>
<li><a href='#getASelfing'><p>Extends the pedigree according to number of selfing cycles</p>
and also optionally computes the Additive Relationship Matrix for that pedigree.</a></li>
<li><a href='#getASubset'><p>Subset of additive relationship matrix</p></a></li>
<li><a href='#getGenAncestors'><p>Counts number of generations of ancestors for one subject. Use recursion.</p></a></li>
<li><a href='#getT'><p>Gene flow from a pedigree</p></a></li>
<li><a href='#getTInv'><p>Inverse gene flow from a pedigree</p></a></li>
<li><a href='#inbreeding'><p>Inbreeding coefficients from a pedigree</p></a></li>
<li><a href='#ped2DF'><p>Convert a pedigree to a data frame</p></a></li>
<li><a href='#pedigree'><p>Constructor for pedigree objects</p></a></li>
<li><a href='#pedigree-class'><p>Pedigree class</p></a></li>
<li><a href='#prunePed'><p>Subsets a pedigree for a specified vector of individuals up to a</p>
specified number of previous generations using recursion.</a></li>
<li><a href='#relfactor'><p>Relationship factor from a pedigree</p></a></li>
<li><a href='#relfactorInv'><p>Inverse relationship factor from a pedigree</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-11</td>
</tr>
<tr>
<td>Title:</td>
<td>Versatile Functions for Working with Pedigrees</td>
</tr>
<tr>
<td>Author:</td>
<td>Ana Ines Vazquez, Douglas Bates, Siddharth Avadhanam, Paulino Perez Rodriguez and Gregor Gorjanc</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paulino Perez Rodriguez &lt;perpdgo@colpos.mx&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to sort, edit and prune pedigrees and to extract the inbreeding coefficients
    and the relationship matrix (includes code for pedigrees from self-pollinated species). 
    The use of pedigree data is central to genetics research within the animal and plant breeding communities to predict 
    breeding values. The relationship matrix between the individuals can be derived from pedigree structure 
    ('Vazquez et al., 2010') &lt;<a href="https://doi.org/10.2527%2Fjas.2009-1952">doi:10.2527/jas.2009-1952</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.0)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Rpedigree/pedigreeTools/">https://github.com/Rpedigree/pedigreeTools/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-15 00:15:16 UTC; pperez</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-15 07:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='pedigreeTools-package'>pedigreeTools: Versatile Functions for Working with Pedigrees</h2><span id='topic+pedigreeTools'></span><span id='topic+pedigreeTools-package'></span>

<h3>Description</h3>

<p>Tools to sort, edit and prune pedigrees and to extract the inbreeding
coefficients and the relationship matrix (includes code for pedigrees from
self-pollinated species). The use of pedigree data is central to genetics
research within the animal and plant breeding communities to predict breeding
values. The relationship matrix between the individuals can be derived from
pedigree structure following the algorithms described for example in
Vazquez et al., 2010 &lt;doi:10.2527/jas.2009-1952&gt;.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Rpedigree/pedigreeTools/">https://github.com/Rpedigree/pedigreeTools/</a>
</p>
</li></ul>


<hr>
<h2 id='Dmat'>Mendelian sampling variance</h2><span id='topic+Dmat'></span><span id='topic+getD'></span><span id='topic+getDInv'></span>

<h3>Description</h3>

<p>Determine the diagonal factor in the decomposition of the
relationship matrix A as TDT' where T is unit lower triangular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dmat(ped, vector = TRUE)

getD(ped, vector = TRUE)

getDInv(ped, vector = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dmat_+3A_ped">ped</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
<tr><td><code id="Dmat_+3A_vector">vector</code></td>
<td>
<p>logical, return a vector or sparse matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getD()</code>: Mendelian sampling variance
</p>
</li>
<li> <p><code>getDInv()</code>: Mendelian sampling precision (= 1 / variance)
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
(D &lt;- getD(ped))
(DInv &lt;- getDInv(ped))

# Test for correctness
DExp &lt;- c(1.00, 1.00, 0.50, 0.75, 0.50, 0.46875)
stopifnot(!any(abs(D - DExp) &gt; .Machine$double.eps))

DInvExp &lt;- 1 / DExp
stopifnot(!any(abs(DInv - DInvExp) &gt; .Machine$double.eps))
</code></pre>

<hr>
<h2 id='editPed'>Edits a disordered or incomplete pedigree</h2><span id='topic+editPed'></span>

<h3>Description</h3>

<p>Edits a disordered or incomplete pedigree by:
1) adding labels for the sires and dams not listed as labels before and
2) ordering pedigree based on recursive calls to <code><a href="#topic+getGenAncestors">getGenAncestors</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editPed(sire, dam, label, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editPed_+3A_sire">sire</code></td>
<td>
<p>integer vector or factor representation of the sires</p>
</td></tr>
<tr><td><code id="editPed_+3A_dam">dam</code></td>
<td>
<p>integer vector or factor representation of the dams</p>
</td></tr>
<tr><td><code id="editPed_+3A_label">label</code></td>
<td>
<p>character vector of labels</p>
</td></tr>
<tr><td><code id="editPed_+3A_verbose">verbose</code></td>
<td>
<p>logical to print the row of the pedigree that the
function is ordering. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the pedigree ordered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- data.frame(sire=as.character(c(NA,NA,NA,NA,NA,1,3,5,6,4,8,1,10,8)),
                  dam=as.character(c(NA,NA,NA,NA,NA,2,2,NA,7,7,NA,9,9,13)),
                  label=as.character(1:14))
ped &lt;- ped[sample(replace=FALSE, 1:14),]
ped &lt;- editPed(sire = ped$sire, dam = ped$dam, label = ped$label)
ped &lt;- with(ped, pedigree(label = label, sire = sire, dam = dam))
</code></pre>

<hr>
<h2 id='getA'>Additive relationship matrix</h2><span id='topic+getA'></span>

<h3>Description</h3>

<p>Returns the additive relationship matrix for the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getA(ped, labs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getA_+3A_ped">ped</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
<tr><td><code id="getA_+3A_labs">labs</code></td>
<td>
<p>a character vector or a factor giving individual labels to
which to restrict the relationship matrix and corresponding factor. If
<code>labs</code> is a factor then the levels of the factor are used as the
labels. Default is the complete set of individuals in the pedigree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (<a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix</a> - symmetric sparse)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
(A &lt;- getA(ped))

# Test for correctness
AExp &lt;- matrix(data = c(1.0000, 0.0000, 0.5000, 0.5000, 0.5000, 0.2500,
                        0.0000, 1.0000, 0.5000, 0.0000, 0.2500, 0.6250,
                        0.5000, 0.5000, 1.0000, 0.2500, 0.6250, 0.5625,
                        0.5000, 0.0000, 0.2500, 1.0000, 0.6250, 0.3125,
                        0.5000, 0.2500, 0.6250, 0.6250, 1.1250, 0.6875,
                        0.2500, 0.6250, 0.5625, 0.3125, 0.6875, 1.1250),
               byrow = TRUE, nrow = 6)
stopifnot(!any(abs(A - AExp) &gt; .Machine$double.eps))
stopifnot(Matrix::isSymmetric(A))
</code></pre>

<hr>
<h2 id='getAInv'>Inverse of the additive relationship matrix</h2><span id='topic+getAInv'></span>

<h3>Description</h3>

<p>Returns the inverse of additive relationship matrix for the
pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAInv(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAInv_+3A_ped">ped</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (<a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix</a> - symmetric sparse)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
(AInv &lt;- getAInv(ped))

# Test for correctness
AInvExp &lt;- matrix(data = c( 1.833,  0.500, -1.000, -0.667,  0.000,  0.000,
                            0.500,  2.033, -1.000,  0.000,  0.533, -1.067,
                           -1.000, -1.000,  2.500,  0.500, -1.000,  0.000,
                           -0.667,  0.000,  0.500,  1.833, -1.000,  0.000,
                            0.000,  0.533, -1.000, -1.000,  2.533, -1.067,
                            0.000, -1.067,  0.000,  0.000, -1.067,  2.133),
                  byrow = TRUE, nrow = 6)
stopifnot(!any(abs(round(AInv, digits = 3) - AInvExp) &gt; .Machine$double.eps))
AInvExp &lt;- solve(getA(ped))
stopifnot(!any(abs(round(AInv, digits = 14) - round(AInvExp, digits = 14)) &gt; .Machine$double.eps))
stopifnot(is(AInv, "sparseMatrix"))
stopifnot(Matrix::isSymmetric(AInv))
</code></pre>

<hr>
<h2 id='getASelfing'>Extends the pedigree according to number of selfing cycles
and also optionally computes the Additive Relationship Matrix for that pedigree.</h2><span id='topic+getASelfing'></span>

<h3>Description</h3>

<p>Extends the pedigree according to number of selfing cycles
and also optionally computes the Additive Relationship Matrix for that pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getASelfing(
  ID,
  Par1,
  Par2,
  nCycles,
  nCyclesDefault,
  sepChar = "-F",
  verbose = FALSE,
  fileNewPed = NULL,
  computeA = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getASelfing_+3A_id">ID</code></td>
<td>
<p>is a vector of individual IDs</p>
</td></tr>
<tr><td><code id="getASelfing_+3A_par1">Par1</code></td>
<td>
<p>vector of IDs of one of the parents</p>
</td></tr>
<tr><td><code id="getASelfing_+3A_par2">Par2</code></td>
<td>
<p>vector of IDs of the other parent</p>
</td></tr>
<tr><td><code id="getASelfing_+3A_ncycles">nCycles</code></td>
<td>
<p>vector that indicates number of selfing cycles for each individual.</p>
</td></tr>
<tr><td><code id="getASelfing_+3A_ncyclesdefault">nCyclesDefault</code></td>
<td>
<p>default value of nCycles</p>
</td></tr>
<tr><td><code id="getASelfing_+3A_sepchar">sepChar</code></td>
<td>
<p>character, used for expanded pedigree IDs</p>
</td></tr>
<tr><td><code id="getASelfing_+3A_verbose">verbose</code></td>
<td>
<p>logical, print progress</p>
</td></tr>
<tr><td><code id="getASelfing_+3A_filenewped">fileNewPed</code></td>
<td>
<p>Output csv file (comma separated value) with columns 'label', 'sire', 'dam', with the full pull pedigree expanded taking into account the selfing cycles</p>
</td></tr>
<tr><td><code id="getASelfing_+3A_computea">computeA</code></td>
<td>
<p>Indicates if the A matrix is to be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns A matrix computed for the extended pedigree if computeA=TRUE
</p>

<hr>
<h2 id='getASubset'>Subset of additive relationship matrix</h2><span id='topic+getASubset'></span>

<h3>Description</h3>

<p>Returns subset of the additive relationship matrix for the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getASubset(ped, labs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getASubset_+3A_ped">ped</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
<tr><td><code id="getASubset_+3A_labs">labs</code></td>
<td>
<p>a character vector or a factor giving individual labels to
which to restrict the relationship matrix and corresponding factor using
Colleau et al. (2002) algorithm. If <code>labs</code> is a factor then the levels
of the factor are used as the labels. Default is the complete set of
individuals in the pedigree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (<a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix</a> - symmetric sparse)
</p>


<h3>References</h3>

<p>Colleau, J.-J. An indirect approach to the extensive calculation of
relationship coefficients. Genet Sel Evol 34, 409 (2002).
https://doi.org/10.1186/1297-9686-34-4-409
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
(A &lt;- getA(ped))
(ASubset  &lt;- A[4:6, 4:6])
(ASubset2 &lt;- getASubset(ped, labs = 4:6))

(ASubset3  &lt;- A[6:4, 6:4])
(ASubset4 &lt;- getASubset(ped, labs = 6:4))

# Test for correctness
stopifnot(!any(abs(ASubset - ASubset2) &gt; .Machine$double.eps))
stopifnot(!any(abs(ASubset3 - ASubset4) &gt; .Machine$double.eps))
stopifnot(Matrix::isSymmetric(ASubset2))
stopifnot(Matrix::isSymmetric(ASubset4))
</code></pre>

<hr>
<h2 id='getGenAncestors'>Counts number of generations of ancestors for one subject. Use recursion.</h2><span id='topic+getGenAncestors'></span>

<h3>Description</h3>

<p>Counts number of generations of ancestors for one subject. Use recursion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGenAncestors(ped, id, ngen = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGenAncestors_+3A_ped">ped</code></td>
<td>
<p>data.frame with a pedigree and a column for the number of
generations of each subject.</p>
</td></tr>
<tr><td><code id="getGenAncestors_+3A_id">id</code></td>
<td>
<p>subject for which we want the number of generations.</p>
</td></tr>
<tr><td><code id="getGenAncestors_+3A_ngen">ngen</code></td>
<td>
<p>number of generation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame object with the pedigree and generation of
ancestors for subject id.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
ped &lt;- ped2DF(ped)
ped$id &lt;- row.names(ped)
ped$generation &lt;- NA
(tmp1 &lt;- getGenAncestors(ped, id = 1))
(tmp2 &lt;- getGenAncestors(ped, id = 4))
(tmp3 &lt;- getGenAncestors(ped, id = 6))

# Test for correctness
stopifnot(tmp1$generation[1] == 0)
stopifnot(all(is.na(tmp1$generation[-1])))
stopifnot(all(tmp2$generation[c(1, 4)] == c(0, 1)))
stopifnot(all(is.na(tmp2$generation[-c(1, 4)])))
stopifnot(all(tmp3$generation == c(0, 0, 1, 1, 2, 3)))
</code></pre>

<hr>
<h2 id='getT'>Gene flow from a pedigree</h2><span id='topic+getT'></span>

<h3>Description</h3>

<p>Get gene flow matrix from a pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getT(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getT_+3A_ped">ped</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (<a href="Matrix.html#topic+dtCMatrix-class">dtCMatrix</a> - lower unitriangular sparse)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
(T &lt;- getT(ped))

# Test for correctness
TExp &lt;- matrix(data = c(1.00, 0.000, 0.00, 0.00, 0.0, 0,
                        0.00, 1.000, 0.00, 0.00, 0.0, 0,
                        0.50, 0.500, 1.00, 0.00, 0.0, 0,
                        0.50, 0.000, 0.00, 1.00, 0.0, 0,
                        0.50, 0.250, 0.50, 0.50, 1.0, 0,
                        0.25, 0.625, 0.25, 0.25, 0.5, 1),
               byrow = TRUE, nrow = 6)
stopifnot(!any(abs(T  - TExp) &gt; .Machine$double.eps))
</code></pre>

<hr>
<h2 id='getTInv'>Inverse gene flow from a pedigree</h2><span id='topic+getTInv'></span>

<h3>Description</h3>

<p>Get inverse gene flow matrix from a pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTInv(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTInv_+3A_ped">ped</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (<a href="Matrix.html#topic+dtCMatrix-class">dtCMatrix</a> - lower unitriangular sparse)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
(TInv &lt;- getTInv(ped))

# Test for correctness
TInvExp &lt;- matrix(data = c( 1.0,  0.0,  0.0,  0.0,  0.0,  0.0,
                            0.0,  1.0,  0.0,  0.0,  0.0,  0.0,
                           -0.5, -0.5,  1.0,  0.0,  0.0,  0.0,
                           -0.5,  0.0,  0.0,  1.0,  0.0,  0.0,
                            0.0,  0.0, -0.5, -0.5,  1.0,  0.0,
                            0.0, -0.5,  0.0,  0.0, -0.5,  1.0),
                  byrow = TRUE, nrow = 6)
stopifnot(!any(abs(TInv  - TInvExp) &gt; .Machine$double.eps))
stopifnot(is(TInv, "sparseMatrix"))
</code></pre>

<hr>
<h2 id='inbreeding'>Inbreeding coefficients from a pedigree</h2><span id='topic+inbreeding'></span>

<h3>Description</h3>

<p>Create the inbreeding coefficients according to the algorithm
given in &quot;Comparison of four direct algorithms for computing inbreeding
coefficients&quot; by Mehdi Sargolzaei and Hiroaki Iwaisaki, Animal Science
Journal (2005) 76, 401&ndash;406.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inbreeding(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inbreeding_+3A_ped">ped</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the inbreeding coefficients as a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
(F &lt;- inbreeding(ped))

# Test for correctness
FExp &lt;- c(0.000, 0.000, 0.000, 0.000, 0.125, 0.125)
stopifnot(!any(abs(F - FExp) &gt; .Machine$double.eps))
</code></pre>

<hr>
<h2 id='ped2DF'>Convert a pedigree to a data frame</h2><span id='topic+ped2DF'></span>

<h3>Description</h3>

<p>Express a pedigree as a data frame with <code>sire</code> and
<code>dam</code> stored as factors. If the pedigree is an object of
class <a href="#topic+pedinbred-class">pedinbred</a> then the inbreeding coefficients are
appended as the variable <code>F</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2DF(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ped2DF_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
ped2DF(ped)
</code></pre>

<hr>
<h2 id='pedigree'>Constructor for pedigree objects</h2><span id='topic+pedigree'></span>

<h3>Description</h3>

<p>A simple constructor for a pedigree object. The main point for
the constructor is to use coercions to make the calls easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigree(sire, dam, label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedigree_+3A_sire">sire</code></td>
<td>
<p>integer vector or factor representation of the sires</p>
</td></tr>
<tr><td><code id="pedigree_+3A_dam">dam</code></td>
<td>
<p>integer vector or factor representation of the dams</p>
</td></tr>
<tr><td><code id="pedigree_+3A_label">label</code></td>
<td>
<p>character vector of individual labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an pedigree object of class <a href="#topic+pedigree-class">pedigree</a>
</p>


<h3>Note</h3>

<p><code>sire</code>, <code>dam</code> and <code>label</code> must all have the
same length and all labels in <code>sire</code> and <code>dam</code> must occur
in <code>label</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
ped
</code></pre>

<hr>
<h2 id='pedigree-class'>Pedigree class</h2><span id='topic+pedigree-class'></span><span id='topic+pedinbred-class'></span>

<h3>Description</h3>

<p>Pedigree class
</p>

<hr>
<h2 id='prunePed'>Subsets a pedigree for a specified vector of individuals up to a
specified number of previous generations using recursion.</h2><span id='topic+prunePed'></span>

<h3>Description</h3>

<p>Subsets a pedigree for a specified vector of individuals up to a
specified number of previous generations using recursion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prunePed(ped, selectVector, ngen = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prunePed_+3A_ped">ped</code></td>
<td>
<p>Data Frame pedigree to be subset</p>
</td></tr>
<tr><td><code id="prunePed_+3A_selectvector">selectVector</code></td>
<td>
<p>Vector of individuals to select from pedigree</p>
</td></tr>
<tr><td><code id="prunePed_+3A_ngen">ngen</code></td>
<td>
<p>Number of previous generations of parents to select starting from selectVector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Subsetted pedigree as a DataFrame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
</code></pre>

<hr>
<h2 id='relfactor'>Relationship factor from a pedigree</h2><span id='topic+relfactor'></span><span id='topic+getL'></span>

<h3>Description</h3>

<p>Determine the right Cholesky factor of the relationship matrix
for the pedigree <code>ped</code>, possibly restricted to the specific labels
that occur in <code>labs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relfactor(ped, labs = NULL)

getL(ped, labs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relfactor_+3A_ped">ped</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
<tr><td><code id="relfactor_+3A_labs">labs</code></td>
<td>
<p>a character vector or a factor giving individual labels to
which to restrict the relationship matrix and corresponding factor using
Colleau et al. (2002) algorithm. If <code>labs</code> is a factor then the levels
of the factor are used as the labels. Default is the complete set of
individuals in the pedigree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the right Cholesky factor is returned, which is upper
triangular, that is from A = LL' = R'R (lower 
(upper triangular) and not L (lower triangular) as the function name might
suggest.
</p>


<h3>Value</h3>

<p>matrix (<a href="Matrix.html#topic+dtCMatrix-class">dtCMatrix</a> - upper triangular sparse)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getL()</code>: Relationship factor from a pedigree
</p>
</li></ul>


<h3>References</h3>

<p>Colleau, J.-J. An indirect approach to the extensive calculation of
relationship coefficients. Genet Sel Evol 34, 409 (2002).
https://doi.org/10.1186/1297-9686-34-4-409
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
(L &lt;- getL(ped))
chol(getA(ped))

# Test for correctness
LExp &lt;- matrix(data = c(1.0000, 0.0000, 0.5000, 0.5000, 0.5000, 0.2500,
                        0.0000, 1.0000, 0.5000, 0.0000, 0.2500, 0.6250,
                        0.0000, 0.0000, 0.7071, 0.0000, 0.3536, 0.1768,
                        0.0000, 0.0000, 0.0000, 0.8660, 0.4330, 0.2165,
                        0.0000, 0.0000, 0.0000, 0.0000, 0.7071, 0.3536,
                        0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.6847),
               byrow = TRUE, nrow = 6)
stopifnot(!any(abs(round(L, digits = 4) - LExp) &gt; .Machine$double.eps))
LExp &lt;- chol(getA(ped))
stopifnot(!any(abs(L - LExp) &gt; .Machine$double.eps))

(L &lt;- getL(ped, labs = 4:6))
(LExp &lt;- chol(getA(ped)[4:6, 4:6]))
stopifnot(!any(abs(L - LExp) &gt; .Machine$double.eps))
</code></pre>

<hr>
<h2 id='relfactorInv'>Inverse relationship factor from a pedigree</h2><span id='topic+relfactorInv'></span><span id='topic+getLInv'></span>

<h3>Description</h3>

<p>Get inverse of the left Cholesky factor of the relationship
matrix for the pedigree <code>ped</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relfactorInv(ped)

getLInv(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relfactorInv_+3A_ped">ped</code></td>
<td>
<p><code><a href="#topic+pedigree">pedigree</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the inverse of the left Cholesky factor is returned,
which is lower triangular, that is from A = LL' (lower 
inv(A) = inv(LL') = inv(L)' inv(L) (upper 
triangular).
</p>


<h3>Value</h3>

<p>matrix (<a href="Matrix.html#topic+dtCMatrix-class">dtCMatrix</a> - triangular sparse)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getLInv()</code>: Inverse relationship factor from a pedigree
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>ped &lt;- pedigree(sire = c(NA, NA, 1,  1, 4, 5),
                dam =  c(NA, NA, 2, NA, 3, 2),
                label = 1:6)
(LInv &lt;- getLInv(ped))
solve(Matrix::t(getL(ped)))

# Test for correctness
LInvExp &lt;- matrix(data = c( 1.0000,  0.0000,  0.0000,  0.0000,  0.0000, 0.0000,
                            0.0000,  1.0000,  0.0000,  0.0000,  0.0000, 0.0000,
                           -0.7071, -0.7071,  1.4142,  0.0000,  0.0000, 0.0000,
                           -0.5774,  0.0000,  0.0000,  1.1547,  0.0000, 0.0000,
                            0.0000,  0.0000, -0.7071, -0.7071,  1.4142, 0.0000,
                            0.0000, -0.7303,  0.0000,  0.0000, -0.7303, 1.4606),
                  byrow = TRUE, nrow = 6)
stopifnot(!any(abs(round(LInv, digits = 4) - LInvExp) &gt; .Machine$double.eps))
L &lt;- t(chol(getA(ped)))
LInvExp &lt;- solve(L)
stopifnot(!any(abs(LInv - LInvExp) &gt; .Machine$double.eps))
stopifnot(is(LInv, "sparseMatrix"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
