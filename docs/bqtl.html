<!DOCTYPE html><html><head><title>Help for package bqtl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bqtl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A+20Starting+20Point'><p>Some Introductory Comments</p></a></li>
<li><a href='#adjust.linear.bayes'><p>Use Laplace Approximations to improve linear approximations to</p>
the posterior</a></li>
<li><a href='#bqtl'><p> Bayesian QTL Model Fitting</p></a></li>
<li><a href='#bqtl-internal'><p>Internal BQTL functions</p></a></li>
<li><a href='#bqtl.fitter'><p>Get loglikelihoods for many models of a common form</p></a></li>
<li><a href='#coef.bqtl'><p> Extract Coefficients from fitted objects</p></a></li>
<li><a href='#configs'><p>Lookup loci or effects for genetic model formulas</p></a></li>
<li><a href='#covar'><p>Treat locus as covariate</p></a></li>
<li><a href='#formula.bqtl'><p> Extract formula from bqtl object</p></a></li>
<li><a href='#lapadj'><p>Approximate marginal posterior for chosen model</p></a></li>
<li><a href='#linear.bayes'><p> Bayesian QTL mapping via Linearized Likelihood</p></a></li>
<li><a href='#little.ana.bc'><p> A simulated dataset</p></a></li>
<li><a href='#little.ana.f2'><p> A simulated dataset</p></a></li>
<li><a href='#little.bc.markers'><p> Simulated Marker Data</p></a></li>
<li><a href='#little.bc.pheno'><p> Simulated Phenotype Data</p></a></li>
<li><a href='#little.f2.markers'><p> Simulated Marker Data</p></a></li>
<li><a href='#little.f2.pheno'><p> Simulated Phenotype Data</p></a></li>
<li><a href='#little.map.dx'><p> Marker Map Description for Simulated Data</p></a></li>
<li><a href='#little.map.frame'><p> Package of Simulated Marker Map Information</p></a></li>
<li><a href='#little.mf.5'><p> Package of Simulated Marker Map Information</p></a></li>
<li><a href='#locus'><p>Lookup loci or effects for genetic model formulas</p></a></li>
<li><a href='#loglik'><p> Extract loglikelihood, log posterior, or posterior from fitted models</p></a></li>
<li><a href='#make.analysis.obj'><p>Set up data for QTL mapping</p></a></li>
<li><a href='#make.loc.right'><p> Keep track of fully informative markers or states</p></a></li>
<li><a href='#make.location.prior'><p> Provide a default prior</p></a></li>
<li><a href='#make.map.frame'><p>Create marker map specifications</p></a></li>
<li><a href='#make.marker.numeric'><p>Translate a marker.frame.object to numeric matrix</p></a></li>
<li><a href='#make.regressor.matrix'>
<p>Create regressors using expected marker values</p></a></li>
<li><a href='#make.state.matrix'>
<p>Create state.matrix.object</p></a></li>
<li><a href='#make.varcov'><p> Create moment matrices</p></a></li>
<li><a href='#map.index'><p>Look up numerical index(es) of map locations</p></a></li>
<li><a href='#map.location'><p> Report map location</p></a></li>
<li><a href='#map.names'><p>Look up names of markers or loci</p></a></li>
<li><a href='#marker.fill'>
<p>Map Positions Between Markers</p></a></li>
<li><a href='#marker.levels'><p> Define marker level codes</p></a></li>
<li><a href='#plot.map.frame'><p> plots by chromosome location</p></a></li>
<li><a href='#predict.bqtl'><p> fitted values from QTL models</p></a></li>
<li><a href='#predict.linear.bayes'><p> Residuals or Predicted Values for linear.bayes objects</p></a></li>
<li><a href='#residuals.bqtl'><p> Residuals from QTL models</p></a></li>
<li><a href='#summary.adj'><p>Summarize Laplace approximations</p></a></li>
<li><a href='#summary.bqtl'><p>Summarize bqtl object</p></a></li>
<li><a href='#summary.map.frame'><p> Summary methods for basic data objects</p></a></li>
<li><a href='#summary.swap'><p>Summarize Gibbs samples for a k-gene model</p></a></li>
<li><a href='#swap'><p> MCMC sampling of multigene models</p></a></li>
<li><a href='#swapbc1'>
<p>Sample BC1 or Recombinant Inbred loci  via approximate posterior.</p></a></li>
<li><a href='#swapf2'>
<p>Sample F2 loci  via approximate posterior</p></a></li>
<li><a href='#twohk'><p> One and Two Gene Models Using Linearized Posterior</p></a></li>
<li><a href='#twohkbc1'><p> One and Two Gene Models Using Linearized Posterior</p></a></li>
<li><a href='#varcov'><p> Create moment matrices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-36</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-29</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian QTL Mapping Toolkit</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles C. Berry &lt;cberry@ucsd.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles C. Berry &lt;cberry@ucsd.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>QTL mapping toolkit for inbred crosses and recombinant
        inbred lines. Includes maximum likelihood and Bayesian tools.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 20:45:18 UTC; cberry</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-29 23:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='A+20Starting+20Point'>Some Introductory Comments</h2><span id='topic+bqtl-package'></span>

<h3>Description</h3>

<p>Some pointers to a few key functions in <em>BQTL</em></p>


<h3>New to R?</h3>


<ul>
<li><p> Be sure to check out all of the free documentation
that comes with R.
</p>
</li>
<li><p> The <code>example</code> function is very
helpful in getting familiar with a new function. You type
<code>example(fun)</code> and the examples in the documentation for
<code>fun</code> are run, then you can read the documentaiton to get a bette
sense of what is really going on. My personal favorite is to type
<code>par(ask=T)</code>, hit the 'enter' key, then <code>example(image)</code>,
and 'enter' again; after each display you hit the 'enter' key to get
to the next one.
</p>
</li>
<li> 
<p><code>library(bqtl)</code> is needed to load the <em>BQTL</em> functions and data
sets.</p>
</li></ul>



<h3>Key Functions</h3>


<dl>
<dt>Data Input</dt><dd><p> \  </p>
</dd>
</dl>

<dl>
<dt><code><a href="#topic+make.map.frame">make.map.frame</a></code></dt><dd><p>defines the map,</p>
</dd>
<dt><code><a href="#topic+marker.levels">marker.levels</a></code></dt><dd><p>The help page describes several
functions that define the coding scheme for
marker levels, </p>
</dd>
<dt><code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code></dt><dd><p>combines marker data, phenotype
data,and the <code>map.frame</code> to create an object that can be
used by data analysis functions.</p>
</dd>
</dl>

<dl>
<dt>Maximum Likelihood Methods</dt><dd><p> \  </p>
</dd>
</dl>

<dl>
<dt><code><a href="#topic+bqtl">bqtl</a></code></dt><dd><p>does a host of things from marker regression
and interval mapping to full maximum likelihood. The best way to
get started is to run <code>example(bqtl)</code> and take a look at
the resulting output.</p>
</dd>
<dt><code><a href="#topic+locus">locus</a></code></dt><dd><p> is very helpful in specification of runs.</p>
</dd> 
</dl>

<dl>
<dt>Approximate Bayesian Analysis </dt><dd><p> \ </p>
</dd>
</dl>

<dl>
<dt><code><a href="#topic+linear.bayes">linear.bayes</a></code></dt><dd>
<p>For a good starting point try <code>example(linear.bayes)</code></p>
</dd></dl>




<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>

<hr>
<h2 id='adjust.linear.bayes'>Use Laplace Approximations to improve linear approximations to
the posterior  </h2><span id='topic+adjust.linear.bayes'></span>

<h3>Description</h3>

<p>The approximation provided by <code>linear.bayes</code> can be improved by
performing Laplace approximations. This function is a development
version of a wrapper to do that for all of the returned by
<code>linear.bayes</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust.linear.bayes(lbo, ana.obj=lbo$call$ana.obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust.linear.bayes_+3A_lbo">lbo</code></td>
<td>
<p> The object returned by <code>linear.bayes</code> </p>
</td></tr>
<tr><td><code id="adjust.linear.bayes_+3A_ana.obj">ana.obj</code></td>
<td>
<p> The <code>analysis.object</code> used to create
<code>lbo</code>. This need not be given explicitly, iff the original
version is in the search path. </p>
</td></tr>
<tr><td><code id="adjust.linear.bayes_+3A_...">...</code></td>
<td>
<p> currently unused </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"adjust.linear.bayes"</code> containing:
</p>
<table>
<tr><td><code>odds</code></td>
<td>
<p>A vector, typically of length k giving the odds for models
of size 1, 2, ..., k under a uniform posterior relative to a model
with no genes.</p>
</td></tr>
<tr><td><code>loc.posterior</code></td>
<td>
<p>The marginal posterior probabilities by locus</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>The marginal posterior means of the coefficients</p>
</td></tr>
<tr><td><code>one.gene.adj</code></td>
<td>
<p>Results of fits for one gene models</p>
</td></tr>
<tr><td><code>n.gene.adj</code></td>
<td>
<p>Results of fits for modles with more than one gene</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call to <code>adjust.linear.bayes</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p> For large <code>linear.bayes</code> objects invloving many gene models,
this can require a very long time to run.</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+linear.bayes">linear.bayes</a></code></p>

<hr>
<h2 id='bqtl'> Bayesian QTL Model Fitting </h2><span id='topic+bqtl'></span>

<h3>Description</h3>

<p>Find maximum likelihood estimate(s) or posterior mode(s) for QTL
model(s). Use Laplace approximation to determine the posterior mass
associated with the model(s). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
bqtl(reg.formula, ana.obj, scope = ana.obj$reg.names, expand.specials = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bqtl_+3A_reg.formula">reg.formula</code></td>
<td>
<p>A formula.object like <code> y ~ add.PVV4 *
     add.H15C12 </code>.  The names of the independent
variables on the right hand side of the formula are the names of loci
or the names of additive and dominance terms associated with loci.  In
addition, one can use <code>locus</code> or <code>configs</code> terms to specify
one or a collection of terms in a shorthand notation.  See <code>
     <a href="#topic+locus">locus</a></code> for more details.  The left hand side is the name
of a trait variable stored in the search path, as a column of the
data frame <code>data</code>, or <code>y</code> if the phenotype variable in
<code> ana.obj</code> is used. </p>
</td></tr>  
<tr><td><code id="bqtl_+3A_ana.obj">ana.obj</code></td>
<td>
<p> The result of <code> <a href="#topic+make.analysis.obj">make.analysis.obj</a> </code>. </p>
</td></tr>
<tr><td><code id="bqtl_+3A_scope">scope</code></td>
<td>
<p>passed to <code>lapadj</code></p>
</td></tr>
<tr><td><code id="bqtl_+3A_expand.specials">expand.specials</code></td>
<td>
<p>passed to <code>lapadj</code></p>
</td></tr>
<tr><td><code id="bqtl_+3A_...">...</code></td>
<td>
<p> Arguments to pass to <code>lapadj</code>, e.g. <code>rparm</code> and
<code>return.hess</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <code>lapadj</code>. It does a lot
of useful packaging through the <code> <a href="#topic+configs">configs</a> </code> terms. If there
is no <code>configs</code> term, then the result is simply the output of
<code> <a href="#topic+lapadj">lapadj</a></code> with the <code>call</code> attribute replaced by the
call to <code>bqtl</code>  
</p>


<h3>Value</h3>

<p>The result(s) of calling <code> <a href="#topic+lapadj">lapadj</a></code>.
If <code>configs</code> is used in the <code>reg.formula</code>, then the
result is a list with one element for each formula. Each element is the
value returned by <code>lapadj</code>
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>References</h3>

<p>Tierney L. and Kadane J.B. (1986) Accurate Approximations for Posterior Moments
and Marginal Densities. <em>JASA</em>, <b>81</b>,82&ndash;86. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locus">locus</a></code>, <code><a href="#topic+configs">configs</a></code>, <code><a href="#topic+lapadj">lapadj</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(little.ana.bc )                        # load  BC1 dataset

loglik( bqtl( bc.phenotype ~ 1, little.ana.bc ) ) #null loglikelihood
                                                  #on chr 1 near cM 25
loglik(bqtl(bc.phenotype~locus(chromo=1,cM=25),little.ana.bc))

little.bqtl &lt;-                              # two genes with epistasis
   bqtl(bc.phenotype ~ m.12 * m.24, little.ana.bc)
summary(little.bqtl)

several.epi &lt;-                              # 20 epistatic models
    bqtl( bc.phenotype ~ m.12 * locus(31:50), little.ana.bc)
several.main &lt;-                             # main effects only
    bqtl( bc.phenotype ~ m.12 + locus(31:50), little.ana.bc)

max.loglik &lt;- max( loglik(several.epi) - loglik(several.main) )

round(
     c( Chi.Square=2*max.loglik, df=1, p.value=1-pchisq(2*max.loglik,1))
      ,2)

five.gene &lt;-                                 ## a five gene model
  bqtl( bc.phenotype ~ locus( 12, 32, 44, 22, 76 ), little.ana.bc , return.hess=TRUE )

regr.coef.table &lt;- summary(five.gene)$coefficients

round( regr.coef.table[,"Value"] +  # coefs inside 95% CI
          qnorm(0.025) * regr.coef.table[,"Std.Err"] %o%
            c("Lower CI"=1,"Estimate"=0,"Upper CI"=-1),3)



</code></pre>

<hr>
<h2 id='bqtl-internal'>Internal BQTL functions</h2><span id='topic++25equiv+25'></span><span id='topic+map.dx'></span><span id='topic+rhs.bqtl'></span><span id='topic+uniq.config'></span><span id='topic+zero.dup'></span><span id='topic+version.bqtl'></span>

<h3>Description</h3>

<p>Internal bqtl functions and objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %equiv% y
 map.dx(lambda, theta, min.lambda)
rhs.bqtl(reg.terms, ana.obj, bqtl.specials, local.covar, scope, 
    expand.specials = NULL, method, ...) 
zero.dup(x,dig=6)
uniq.config(swap.obj)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bqtl-internal_+3A_lambda">lambda</code></td>
<td>
<p> (2*(recomb fraction-1/2) </p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_theta">theta</code></td>
<td>
<p>recomb fraction</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_min.lambda">min.lambda</code></td>
<td>
<p>smallest map distance to use</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_reg.terms">reg.terms</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_ana.obj">ana.obj</code></td>
<td>
<p>an analysis.object</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_bqtl.specials">bqtl.specials</code></td>
<td>
<p>a vector of acceptable special names</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_local.covar">local.covar</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_scope">scope</code></td>
<td>
<p>vector of strings</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_expand.specials">expand.specials</code></td>
<td>
<p>logical,whether to use expand.grid on the loci</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_method">method</code></td>
<td>
<p>e'g' &quot;F2&quot;, &quot;BC!&quot;, etc</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_...">...</code></td>
<td>
<p>not sure</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_swap.obj">swap.obj</code></td>
<td>
<p>result of swap</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_x">x</code></td>
<td>
<p>numeric vector or matrix</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_y">y</code></td>
<td>
<p>numeric vector or matrix</p>
</td></tr>
<tr><td><code id="bqtl-internal_+3A_dig">dig</code></td>
<td>
<p>how many significant digits to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='bqtl.fitter'>Get loglikelihoods for many models of a common form </h2><span id='topic+bqtl.fitter'></span>

<h3>Description</h3>

<p>For a single type of model, this function evaluates multiple models that
differ only in terms of the loci involved. The looping is all done by
internal C functions, so this is faster than simply using <code>bqtl</code> to
do the same thing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bqtl.fitter(setup, loc.mat, ana.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bqtl.fitter_+3A_setup">setup</code></td>
<td>
<p>The object returned by  <code>bqtl( &lt;...&gt; , setup=TRUE )</code> </p>
</td></tr>
<tr><td><code id="bqtl.fitter_+3A_loc.mat">loc.mat</code></td>
<td>
<p>A matrix of locus numbers, s.t. <code>nrow(loc.mat)</code>
equals the number of loci in <code>setup</code> </p>
</td></tr>
<tr><td><code id="bqtl.fitter_+3A_ana.obj">ana.obj</code></td>
<td>
<p>An <code>analysis.object</code>. Usually the one used in <code>setup</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to avoid the computational overhead of running large loops of
very repetitive operations in R/S, <code>bqtl.fitter</code> used after the
<code>setup=TRUE</code> option in <code><a href="#topic+bqtl">bqtl</a></code> will loop through the
loci specified in <code>loc.mat</code> using internal C code. This is many
times faster than running the same code via <code>bqtl</code>.
</p>


<h3>Value</h3>

<p>For now it only returns the loglikelihood. But it would be trivial to
build an option that would allow other quantities computed to be
returned, and this should probably be done. However, some care is
needed to keep objects from becoming unmanageably large.
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+bqtl">bqtl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data( little.ana.bc )
little.setup &lt;-
bqtl( bc.phenotype~locus(1)*locus(2), little.ana.bc, setup=TRUE )
combos &lt;- t( as.matrix( expand.grid( 1:21, 44:64 ) ) )
little.update &lt;- bqtl.fitter(little.setup, combos, little.ana.bc)
little.res &lt;- matrix( little.update, nr=21 )
image( 1:21, 44:64, little.res )
rm(little.ana.bc, little.update, little.res  )
</code></pre>

<hr>
<h2 id='coef.bqtl'> Extract Coefficients from fitted objects </h2><span id='topic+coef.bqtl'></span><span id='topic+coef.bqtl.list'></span>

<h3>Description</h3>

<p>Return a vector or matrix of coefficients as appropriate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bqtl'
coef(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.bqtl_+3A_object">object</code></td>
<td>
<p>The object returned by <code>bqtl</code></p>
</td></tr>
<tr><td><code id="coef.bqtl_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A vector (if <code>bqtl</code> returned a single fit) or matrix (if
<code>bqtl</code> returned a list with more than one fit)
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+bqtl">bqtl</a></code></p>

<hr>
<h2 id='configs'>Lookup loci or effects for genetic model formulas </h2><span id='topic+configs'></span>

<h3>Description</h3>

<p>Convert numeric indexes to names of regressors for a genetic model.
One or many genetic models can be specified through the use of this
function.  It is used on the right hand side of a formula in the
<code><a href="#topic+bqtl">bqtl</a></code> function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configs(x,...,scope, method = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="configs_+3A_x">x</code></td>
<td>
 
<p>Typically an integer, an integer vector, an array, or a list with a
<code>configs</code> component such as returned by <code><a href="#topic+swapbc1">swapbc1</a> </code>.
However, it can also be a character string, vector, et cetera, in which
case the elements must belong to <code>names(scope)</code> </p>
</td></tr>
<tr><td><code id="configs_+3A_...">...</code></td>
<td>
 
<p>Optional arguments to be used when <code>is.atomic(x)</code> is TRUE. </p>
</td></tr>
<tr><td><code id="configs_+3A_scope">scope</code></td>
<td>
<p> (Optional and) 
</p>
<p>Usually not supplied by the user.  Rather <code>bqtl</code> fills this in
automatically.  A vector of regressor names, like the <code>reg.names</code>
component returned by <code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code>.  When
<code>mode(x)</code> is <code>"character"</code>, then <code>names(scope)</code>
<b>must</b> be non-<code>NULL</code> </p>
</td></tr>
<tr><td><code id="configs_+3A_method">method</code></td>
<td>
<p> (Optional and) Usually not supplied by the user. A method
like &quot;F2&quot;. Typically, this is determined by internal code.
</p>
</td></tr></table>


<h3>Details</h3>

 <p><code>configs</code> is used in the model formula notation of
<code>bqtl</code>, possibly more than once, and possibly with regressors named
in the usual manner.  <code>configs</code> is intended to speed up the
specification and examination of genetic models by allowing many models
to be specified in a shorthand notation in a single model formula.  The
names of genetic loci can consist of marker names, names that encode
chromosome number and location, or other shorthand notations.  The names
of terms in genetic models will typically include the names of the locus
and may prepend &quot;add.&quot; or &quot;dom.&quot; or similar abbreviations for the
'additive' and 'dominance' terms associated with the locus. 
</p>
<p>When used as in <code>bqtl( y ~ configs(34), my.analysis.obj )</code>, it will
look up the term <code>my.analysis.obj$reg.names[34]</code>.  When
this is passed back to <code>bqtl</code>, it get pasted into the formula and
is subsequently processed to yield the fit for a one gene model.
</p>
<p>When used as in <code>bqtl( y ~ configs(34,75,172), my.analysis.obj)</code> it
looks up each term and returns a result to <code>bqtl</code> that results in
fitting a 3 gene model (without interaction terms). 
</p>
<p>When <code>x</code> is a vector, array, or list, the processing typically
returns pieces of many model formulas.  <code>bqtl(y ~ configs(26:75),
...)</code> results in a list of 50 different one gene model fits from
<code>bqtl</code> for the terms corresponding to the 26th through the 75th
variables.  <code> bqtl(y ~
configs(cbind(c(15,45,192),c(16,46,193))),...)</code> returns two four gene
models.  And more generally, whenever <code>is.array(x)</code> is TRUE, the
columns (or slices) specify <code> dim(x)[1]/length(x)</code> different
models.  When <code>x$configs</code> is an array, this also happens.  This turns
out to be useful when the result of running <code><a href="#topic+swapbc1">swapbc1</a></code> or
<code><a href="#topic+swapf2">swapf2</a></code> is treated as an importance sample.  In such a case,
<code>bqtl(y ~ configs(my.swap),my.analysis.obj)</code> will return a list in
which element <code>i</code> is the ith sample drawn when <code>my.swap &lt;-
swapbc1(...)</code> was run.
</p>


<h3>Value</h3>

<p>A character vector whose element(s) can be parsed as the right hand side
of a model formula. 
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+bqtl">bqtl</a></code> and the examples there for a sense of how to use
<code>configs</code>, 
<code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code> for the setup that encodes the marker
map and the marker information,
<code><a href="#topic+swapbc1">swapbc1</a></code> and 
<code><a href="#topic+swapf2">swapf2</a></code> for generating samples to be screened by <code>bqtl</code>.
</p>

<hr>
<h2 id='covar'>Treat locus as covariate </h2><span id='topic+covar'></span>

<h3>Description</h3>

<p>Sometimes it is helps speed computations to linearize the likelihood
or at least a part of it w.r.t. the locus allele values. Both
'Haley-Knott regression' and 'composite interval mapping' use this
approach. <code>covar</code> provides a mechanism for creating formula
objects that specify such linearizations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covar_+3A_x">x</code></td>
<td>
<p>The name of a locus (except for F2 designs, when it is the
name of an effect like 'add.m.32') or any argument of the sort that 
<code><a href="#topic+locus">locus</a></code> allows. If <code>x</code> evaluates to a single value,
then additional atomic elements may be included as with
<code>locus</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>covar</code> actually only returns <code>x</code>. The real
work is done by a <code>covar</code> function that is hidden inside of
<code>bqtl</code>, where the arguments are parsed as for <code>locus</code>. Each
of the return values from <code>locus</code> is prefixed by &quot;covar(&quot; and
suffixed by &quot;)&quot;. If <code>x</code> is a name of a locus or effect, then
<code>paste("covar(",deparse(x),")")</code> is returned. Later, when
<code>bqtl</code> calls <code>lapadj</code>, terms like <code>covar(PVV4.1)</code> are
recognized as requiring a linearization w.r.t. effect 'PVV4.1'.</p>


<h3>Value</h3>

<p>a character string or vector 
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>


<h3>References</h3>

<p>HALEY, C. S. and S. A. KNOTT, 1992  A simple regression method for
mapping quantitative trait loci in line crosses using flanking
markers. Heredity 69:315-324.
</p>
<p>Knapp SJ, Bridges WC, and Birkes D. Mapping quantitative trait loci
using molecular marker linkage maps. Theoretical and Applied Genetics
79: 583-592, 1990.
</p>
<p>ZENG, Z.-B., 1994 Precision mapping of quantitative trait
loci. Genetics 136:1457-1468
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locus">locus</a></code>, <code><a href="#topic+add">add</a></code>, <code><a href="#topic+dom">dom</a></code>,
<code><a href="#topic+configs">configs</a></code> 
</p>

<hr>
<h2 id='formula.bqtl'> Extract formula from bqtl object </h2><span id='topic+formula.bqtl'></span>

<h3>Description</h3>

<p>formula method for class <code>bqtl</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bqtl'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.bqtl_+3A_x">x</code></td>
<td>
<p>The object returned by <code>bqtl</code> </p>
</td></tr>
<tr><td><code id="formula.bqtl_+3A_...">...</code></td>
<td>
<p> unused </p>
</td></tr>
</table>


<h3>Value</h3>

<p> a formula object
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+bqtl">bqtl</a></code></p>

<hr>
<h2 id='lapadj'>Approximate marginal posterior for chosen model</h2><span id='topic+lapadj'></span>

<h3>Description</h3>

<p>lapadj provides the Laplace approximation to the marginal posterior
(over coefficients and dispersion parameter) for a given genetical
model for a quantitative trait. A by-product is the parameter value
corresponding to the maximum posterior or likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> lapadj(reg.formula, ana.obj,  
         rparm = NULL,  tol = 1e-10,
	return.hess = FALSE, mode.names = NULL, mode.mat = NULL,
          maxit = 100, nem = 1,setup.only=FALSE,subset=NULL,casewt=NULL,
         start.parm=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapadj_+3A_reg.formula">reg.formula</code></td>
<td>
<p> A formula, like
<code>y~add.X.3+dom.X.3+add.x.45*add.x.72</code></p>
</td></tr>
<tr><td><code id="lapadj_+3A_ana.obj">ana.obj</code></td>
<td>
<p> See<code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code>, which returns
objects like this</p>
</td></tr>
<tr><td><code id="lapadj_+3A_rparm">rparm</code></td>
<td>

<p>One of the following:
</p>
<p>A scalar that will be used as the ridge parameter for all
design terms except for the intercept ridge parameter which is set
to zero 
</p>
<p>A vector who named elements  can be matched by the design term
names returned in <code>$reg.vec</code>. If no term named
&quot;intercept&quot; is provided,
</p>
<p><code>rparm["intercept"]</code> will be set to zero. 
</p>
<p>A vector with <code>(q-1)*k</code> elements (this works when there are
no interactions specified). If names are provided, these will be
used for matching.
</p>
<p>Positive entries are 'ridge' parameters or variance ratios in a
Bayesian prior for the regression coefficients. Larger values imply
more shrinkage or a more concentrated prior for the regresion
coefficients.   
</p>
</td></tr> 
<tr><td><code id="lapadj_+3A_tol">tol</code></td>
<td>
<p>Iteration control parameter  </p>
</td></tr>
<tr><td><code id="lapadj_+3A_return.hess">return.hess</code></td>
<td>
<p>Logical, include the Hessian in the output? </p>
</td></tr>
<tr><td><code id="lapadj_+3A_mode.names">mode.names</code></td>
<td>
<p>names to use as <code>dimnames(mode.mat)[[2]]</code>  </p>
</td></tr>
<tr><td><code id="lapadj_+3A_mode.mat">mode.mat</code></td>
<td>
<p>Not usually set by the user. A matrix which indicates the values of regressor
variables corresponding to the allele states. If <code>mode.mat</code> is
not given by the user,
<code>ana.obj$mode.mat</code> is used.</p>
</td></tr>
<tr><td><code id="lapadj_+3A_maxit">maxit</code></td>
<td>
<p> Maximum Number of iterations to perform</p>
</td></tr>
<tr><td><code id="lapadj_+3A_nem">nem</code></td>
<td>
<p> Number of EM iterations to use in reinitializing the
pseudo-Hessian </p>
</td></tr>
<tr><td><code id="lapadj_+3A_setup.only">setup.only</code></td>
<td>
<p> If TRUE, do not run. Return an object that can be use
for a direct call to <code>.C</code></p>
</td></tr>
<tr><td><code id="lapadj_+3A_subset">subset</code></td>
<td>
<p> expression to evaluate using <code>ana.obj$data</code> as the
environment</p>
</td></tr>
<tr><td><code id="lapadj_+3A_casewt">casewt</code></td>
<td>
<p> a vector of non-negative weights </p>
</td></tr>  
<tr><td><code id="lapadj_+3A_start.parm">start.parm</code></td>
<td>
<p>Vector of starting values for the maximization</p>
</td></tr>
<tr><td><code id="lapadj_+3A_...">...</code></td>
<td>
<p> other objects needed in fitting </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The core of this function is a quasi-Newton optimizer due to Minami
(1993) that has a computational burden that is only a bit more than
the EM algorithm, but features fast convergence.  This is used to find
the mode of the posterior. Once this is in hand, one can find the
Laplace approximation to the marginal likelihood. In addition, some
useful quantities are provided that help in estimating the marginal
posterior over groups of models. 
</p>


<h3>Value</h3>

<p>A list with components to be used in constructing approximations to the
marginal posterior or a list that can be used to call the underlying C
code directly. In the former case, these are:
</p>
<table>
<tr><td><code>adj</code></td>
<td>
<p>The ratio of the laplace approximation to the posterior for
the correct likelihood to the laplace approximation to the posterior
for  the linearized likelihood</p>
</td></tr>
<tr><td><code>logpost</code></td>
<td>
<p>The logarithm of the posterior or likelihood at the mode</p>
</td></tr>
<tr><td><code>parm</code></td>
<td>
<p>the location of the mode</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>The laplace approximation of the marginal posterior
for the exact likelihood</p>
</td></tr>
<tr><td><code>hk.approx</code></td>
<td>
<p> Laplace approximation to the linearized likelihood</p>
</td></tr>
<tr><td><code>hk.exact</code></td>
<td>
<p> Exact marginal posterior for the linearized likelihood</p>
</td></tr>
<tr><td><code>reg.vec</code></td>
<td>
<p>A vector of the variables used</p>
</td></tr>
<tr><td><code>rparm</code></td>
<td>

<p>Values of ridge parameters used in this problem.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>References</h3>

<p> Berry C.C.(1998) Computationally Efficient Bayesian QTL Mapping
in Experimental Crosses. <em>ASA Proceedings of the Biometrics
Section</em>. 164&ndash;169.
</p>
<p>Minami M. (1993) Variance estimation for simultaneous response growth curve
models.  Thesis (Ph. D.)&ndash;University of California, San Diego,
Department of Mathematics.
</p>

<hr>
<h2 id='linear.bayes'> Bayesian QTL mapping via Linearized Likelihood</h2><span id='topic+linear.bayes'></span>

<h3>Description</h3>

<p>The Bayesian QTL models via a likelihood that is linearized w.r.t. a
fixed genetic model. By default, all one and two gene models (without
epistasis) are fitted and a MCMC sampler is used to fit 3,4, and 5 gene
and (optionally) larger models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear.bayes(x, ana.obj, partial=NULL, rparm, specs,
scope, subset, casewt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear.bayes_+3A_x">x</code></td>
<td>
<p> a formula giving the QTL and the candidate loci or a
<code>varcov</code> object </p>
</td></tr>
<tr><td><code id="linear.bayes_+3A_ana.obj">ana.obj</code></td>
<td>
<p>An analysis.object, see <code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code>
</p>
</td></tr>
<tr><td><code id="linear.bayes_+3A_partial">partial</code></td>
<td>
<p>a formula giving covariates to be controlled </p>
</td></tr>
<tr><td><code id="linear.bayes_+3A_rparm">rparm</code></td>
<td>
<p> A ridge parameter. A value of 1 is suggested, but the
default is 0. </p>
</td></tr>
<tr><td><code id="linear.bayes_+3A_specs">specs</code></td>
<td>
<p> An optional list with components <code>gene.number</code> (to
indicate the model sizes), <code>burn.in</code> (to indicate the number of
initial MCMC cycles to discard), and <code>n.cycles</code> (to indicate how
many MCMC cycles to perform for each model size). If no values are
supplied, <code>specs</code> defaults to
</p>
<p><code>list(gene.number=c(1,2,3,4,5),burn.in=1,n.cycles=c(0,0,200,100,100))</code></p>
</td></tr>
<tr><td><code id="linear.bayes_+3A_scope">scope</code></td>
<td>
<p>Not generally used. If supplied this will be passed to
<code>varcov</code>. </p>
</td></tr> 
<tr><td><code id="linear.bayes_+3A_subset">subset</code></td>
<td>
<p>Not generally used. If supplied this will be passed to
<code>varcov</code>.  </p>
</td></tr>
<tr><td><code id="linear.bayes_+3A_casewt">casewt</code></td>
<td>
<p>Not generally used. If supplied this will be passed to
<code>varcov</code>. </p>
</td></tr>
<tr><td><code id="linear.bayes_+3A_...">...</code></td>
<td>
<p>optional arguments to pass to <code>twohk</code> and <code>swap</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for
<code><a href="#topic+varcov">varcov</a></code>, <code><a href="#topic+twohk">twohk</a></code>, <code><a href="#topic+swap">swap</a></code>, and
<code><a href="#topic+summary.swap">summary.swap</a></code>, and a better understanding of optional
arguments and the object generated is gained from their
documentation.
</p>


<h3>Value</h3>

<table>
<tr><td><code>hk</code></td>
<td>
<p>The object returned by <code><a href="#topic+twohk">twohk</a></code></p>
</td></tr>
<tr><td><code>swaps</code></td>
<td>
<p>A list of objects returned by calls to
<code><a href="#topic+swap">swap</a></code>.  Element i in <code>swaps</code> is for i gene
models.</p>
</td></tr>
<tr><td><code>smry</code></td>
<td>
<p>A list of objects returned by calls to
<code><a href="#topic+summary.swap">summary.swap</a></code>. Some elements may be <code>NULL</code> if no
samples were requested or if the sampling process yielded degenerate
results. Usually, this happens if no posterior is specified for the
regression coefficients, i.e. if <code>rparm=0</code> was used or implied </p>
</td></tr>
<tr><td><code>odds</code></td>
<td>
<p>A Vector of odds (relative to a no gene setup) for each
model size evaluated. The odds are computed under a prior that
places equal weights on models of each size considered (and are,
therefore,  Bayes Factors). If models of size 1 and 2 are not
evaluated or if some degenerate results were encountered, this will
be <code>NULL</code></p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>A vector of posterior means of the regression
coefficients. If models of size 1 and 2 are not
evaluated or if some degenerate results were encountered, this will
be <code>NULL</code></p>
</td></tr>
<tr><td><code>loc.posterior</code></td>
<td>
<p>A vector of locus-wise posterior probabilities
that the interval covered by this locus contains a gene.If models of
size 1 and 2 are not evaluated or if some degenerate results were
encountered, this will be <code>NULL</code></p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call that generated this object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>References</h3>

<p> Berry C.C.(1998) Computationally Efficient Bayesian QTL Mapping
in Experimental Crosses. <em>ASA Proceedings of the Biometrics
Section</em>. 164&ndash;169.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( little.ana.bc )
little.lin &lt;- linear.bayes( bc.phenotype~locus(all), little.ana.bc, rparm=1 )
par(mfrow=c(2,3))
plot( little.ana.bc, little.lin$loc.posterior, type="h" )
little.lin$odds
par(mfrow=c(1,1))
plot(fitted(little.lin), residuals(little.lin))

</code></pre>

<hr>
<h2 id='little.ana.bc'> A simulated dataset </h2><span id='topic+little.ana.bc'></span>

<h3>Description</h3>

<p>A simulation of a BC1 cross of 150 organisms with a genome of around 500
cM consisting of 5 chromosomes. The format is that created by
<code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code>
</p>


<h3>Details</h3>

<p>This dataset is built up from several others. The basic data are:
</p>

<dl>
<dt>little.bc.pheno</dt><dd><p>A vector of phenotype data</p>
</dd>
<dt>little.bc.markers</dt><dd><p> A <code>map.frame</code> of marker data and</p>
</dd>
<dt>little.dx</dt><dd><p> A data frame with 50 rows and 2 columns that specify
the map locations of a simulated set of markers </p>
</dd>
</dl>

<p>These are used to construct
</p>

<dl>
<dt>little.mf.5</dt><dd><p>A <code>map.frame</code> with 'pseudo-markers' at least
every 5 cM made from
</p>
<p><code>little.mf.5 &lt;-  make.map.frame(little.map.frame,
    nint=marker.fill( little.map.frame, reso=5, TRUE ))</code>
</p>
</dd></dl>

<p>Then phenotype, covariate, and marker data are combined
</p>
<p>with <code>little.mf.5</code>
</p>

<dl>
<dt>little.bc.pheno</dt><dd><p> A <code>data.frame</code> with the
variable <code>bc.phenotype</code></p>
</dd>
<dt>little.bc.markers</dt><dd><p>A <code>data.frame</code> with marker state information</p>
</dd>
</dl>


<h3>See Also</h3>

<p>The examples in <code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code></p>

<hr>
<h2 id='little.ana.f2'> A simulated dataset </h2><span id='topic+little.ana.f2'></span>

<h3>Description</h3>

<p>A simulation of an F2 cross of 150 organisms with a genome of around 500
cM consisting of 5 chromosomes. The format is that created by <code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(little.ana.f2)</code></pre>

<hr>
<h2 id='little.bc.markers'> Simulated Marker Data </h2><span id='topic+little.bc.markers'></span>

<h3>Description</h3>

<p>The <code>little.bc.markers</code> data frame has 150 rows and 50
columns with the simulated marker data from a BC1 cross of 150
organisms with a genome of around 500 cM consisting of 5
chromosomes. Some <code>NA</code>'s have been intentionally introduced. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(little.bc.markers)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>m.1</dt><dd>
<p>a factor with levels
<code>AA</code> 
<code>Aa</code> 
</p>
</dd>
<dt>m.2</dt><dd>
<p>a factor with levels
<code>AA</code> 
<code>Aa</code> 
</p>
</dd>
<dt>m.3</dt><dd><p> ditto </p>
</dd>
<dt>m.4</dt><dd><p> ditto </p>
</dd>
<dt>m.5</dt><dd><p> ditto </p>
</dd>
<dt>m.6</dt><dd><p> ditto </p>
</dd>
<dt>m.7</dt><dd><p> ditto </p>
</dd>
<dt>m.8</dt><dd><p> ditto </p>
</dd>
<dt>m.9</dt><dd><p> ditto </p>
</dd>
<dt>m.10</dt><dd><p> ditto </p>
</dd>
<dt>m.11</dt><dd><p> ditto </p>
</dd>
<dt>m.12</dt><dd><p> ditto </p>
</dd>
<dt>m.13</dt><dd><p> ditto </p>
</dd>
<dt>m.14</dt><dd><p> ditto </p>
</dd>
<dt>m.15</dt><dd><p> ditto </p>
</dd>
<dt>m.16</dt><dd><p> ditto </p>
</dd>
<dt>m.17</dt><dd><p> ditto </p>
</dd>
<dt>m.18</dt><dd><p> ditto </p>
</dd>
<dt>m.19</dt><dd><p> ditto </p>
</dd>
<dt>m.20</dt><dd><p> ditto </p>
</dd>
<dt>m.21</dt><dd><p> ditto </p>
</dd>
<dt>m.22</dt><dd><p> ditto </p>
</dd>
<dt>m.23</dt><dd><p> ditto </p>
</dd>
<dt>m.24</dt><dd><p> ditto </p>
</dd>
<dt>m.25</dt><dd><p> ditto </p>
</dd>
<dt>m.26</dt><dd><p> ditto </p>
</dd>
<dt>m.27</dt><dd><p> ditto </p>
</dd>
<dt>m.28</dt><dd><p> ditto </p>
</dd>
<dt>m.29</dt><dd><p> ditto </p>
</dd>
<dt>m.30</dt><dd><p> ditto </p>
</dd>
<dt>m.31</dt><dd><p> ditto </p>
</dd>
<dt>m.32</dt><dd><p> ditto </p>
</dd>
<dt>m.33</dt><dd><p> ditto </p>
</dd>
<dt>m.34</dt><dd><p> ditto </p>
</dd>
<dt>m.35</dt><dd><p> ditto </p>
</dd>
<dt>m.36</dt><dd><p> ditto </p>
</dd>
<dt>m.37</dt><dd><p> ditto </p>
</dd>
<dt>m.38</dt><dd><p> ditto </p>
</dd>
<dt>m.39</dt><dd><p> ditto </p>
</dd>
<dt>m.40</dt><dd><p> ditto </p>
</dd>
<dt>m.41</dt><dd><p> ditto </p>
</dd>
<dt>m.42</dt><dd><p> ditto </p>
</dd>
<dt>m.43</dt><dd><p> ditto </p>
</dd>
<dt>m.44</dt><dd><p> ditto </p>
</dd>
<dt>m.45</dt><dd><p> ditto </p>
</dd>
<dt>m.46</dt><dd><p> ditto </p>
</dd>
<dt>m.47</dt><dd><p> ditto </p>
</dd>
<dt>m.48</dt><dd><p> ditto </p>
</dd>
<dt>m.49</dt><dd><p> ditto </p>
</dd>
<dt>m.50</dt><dd><p> ditto </p>
</dd>
<dt>row.names</dt><dd><p>row.names</p>
</dd></dl>


<hr>
<h2 id='little.bc.pheno'> Simulated Phenotype Data  </h2><span id='topic+little.bc.pheno'></span>

<h3>Description</h3>

<p>The <code>little.bc.pheno</code> data frame has 150 rows and 1 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(little.bc.pheno)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>bc.phenotype</dt><dd>
<p>a numeric vector of simulated phenotype data</p>
</dd></dl>

<hr>
<h2 id='little.f2.markers'> Simulated Marker Data </h2><span id='topic+little.f2.markers'></span>

<h3>Description</h3>

<p>The <code>little.f2.markers</code> data frame has 150 rows and 50 columns with
the simulated marker data from an F2 cross of 150
organisms with a genome of around 500 cM consisting of 5 chromosomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(little.f2.markers)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>m.1</dt><dd>
<p>a factor with levels
<code>AA</code> 
<code>Aa</code>
<code>aa</code> 
</p>
</dd>
<dt>m.2</dt><dd>
<p>a factor with levels
<code>AA</code> 
<code>Aa</code>
<code>aa</code>  
</p>
</dd>
<dt>m.3</dt><dd><p> ditto </p>
</dd>
<dt>m.4</dt><dd><p> ditto </p>
</dd>
<dt>m.5</dt><dd><p> ditto </p>
</dd>
<dt>m.6</dt><dd><p> ditto </p>
</dd>
<dt>m.7</dt><dd><p> ditto </p>
</dd>
<dt>m.8</dt><dd><p> ditto </p>
</dd>
<dt>m.9</dt><dd><p> ditto </p>
</dd>
<dt>m.10</dt><dd><p> ditto </p>
</dd>
<dt>m.11</dt><dd><p> ditto </p>
</dd>
<dt>m.12</dt><dd><p> ditto </p>
</dd>
<dt>m.13</dt><dd><p> ditto </p>
</dd>
<dt>m.14</dt><dd><p> ditto </p>
</dd>
<dt>m.15</dt><dd><p> ditto </p>
</dd>
<dt>m.16</dt><dd><p> ditto </p>
</dd>
<dt>m.17</dt><dd><p> ditto </p>
</dd>
<dt>m.18</dt><dd><p> ditto </p>
</dd>
<dt>m.19</dt><dd><p> ditto </p>
</dd>
<dt>m.20</dt><dd><p> ditto </p>
</dd>
<dt>m.21</dt><dd><p> ditto </p>
</dd>
<dt>m.22</dt><dd><p> ditto </p>
</dd>
<dt>m.23</dt><dd><p> ditto </p>
</dd>
<dt>m.24</dt><dd><p> ditto </p>
</dd>
<dt>m.25</dt><dd>
<p>a factor with levels
<code>A-</code> 
<code>aa</code> 
</p>
</dd>
<dt>m.26</dt><dd><p> ditto </p>
</dd>
<dt>m.27</dt><dd><p> ditto </p>
</dd>
<dt>m.28</dt><dd><p> ditto </p>
</dd>
<dt>m.29</dt><dd><p> ditto </p>
</dd>
<dt>m.30</dt><dd><p> ditto </p>
</dd>
<dt>m.31</dt><dd><p> ditto </p>
</dd>
<dt>m.32</dt><dd><p> ditto </p>
</dd>
<dt>m.33</dt><dd><p> ditto </p>
</dd>
<dt>m.34</dt><dd><p> ditto </p>
</dd>
<dt>m.35</dt><dd><p> ditto </p>
</dd>
<dt>m.36</dt><dd><p> ditto </p>
</dd>
<dt>m.37</dt><dd><p> ditto </p>
</dd>
<dt>m.38</dt><dd><p> ditto </p>
</dd>
<dt>m.39</dt><dd><p> ditto </p>
</dd>
<dt>m.40</dt><dd><p> ditto </p>
</dd>
<dt>m.41</dt><dd><p> ditto </p>
</dd>
<dt>m.42</dt><dd><p> ditto </p>
</dd>
<dt>m.43</dt><dd><p> ditto </p>
</dd>
<dt>m.44</dt><dd><p> ditto </p>
</dd>
<dt>m.45</dt><dd>
<p>a factor with levels
<code>a-</code> 
</p>
</dd>
<dt>m.46</dt><dd><p> ditto </p>
</dd>
<dt>m.47</dt><dd><p> ditto </p>
</dd>
<dt>m.48</dt><dd><p> ditto </p>
</dd>
<dt>m.49</dt><dd>
<p>a factor with levels
<code>AA</code> 
<code>Aa</code> 
<code>aa</code>
</p>
</dd>
<dt>m.50</dt><dd>
<p>a factor with levels
<code>AA</code> 
<code>Aa</code> 
<code>aa</code>
</p>
</dd>
<dt>row.names</dt><dd><p>row names</p>
</dd></dl>


<hr>
<h2 id='little.f2.pheno'> Simulated Phenotype Data </h2><span id='topic+little.f2.pheno'></span>

<h3>Description</h3>

<p>The <code>little.f2.pheno</code> data frame has 150 rows and 1 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(little.f2.pheno)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>f2.phenotype</dt><dd>
<p>a numeric vector of simulated phenotype data
</p>
</dd>
</dl>


<hr>
<h2 id='little.map.dx'> Marker Map Description for Simulated Data </h2><span id='topic+little.map.dx'></span>

<h3>Description</h3>

<p>The <code>little.map.dx</code> data frame has 50 rows and 2 columns that specify 
the map locations of a simulated set of markers </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(little.map.dx)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>marker.names</dt><dd>
<p>a factor with levels
<code>m.1</code> ... <code>m.50</code> 
</p>
</dd>
<dt>cM</dt><dd>
<p>a numeric vector of map locations in centimorgans
</p>
</dd>
</dl>


<hr>
<h2 id='little.map.frame'> Package of Simulated Marker Map Information </h2><span id='topic+little.map.frame'></span>

<h3>Description</h3>

<p>The <code>little.map.frame</code> data frame has 50 rows and 9 columns that
describe the marker map of <code><a href="#topic+little.map.dx">little.map.dx</a></code> in the format
produced by <code><a href="#topic+make.map.frame">make.map.frame</a></code>. <code>little.map.dx</code> has the
minimal data needed to construct this.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(little.map.frame)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>marker.name</dt><dd>
<p>a factor with levels
<code>m.1</code> 
<code>m.2</code> 
...
<code>m.50</code> 
</p>
</dd>
<dt>cM</dt><dd>
<p>a vector of locations
</p>
</dd>
<dt>prior</dt><dd>
<p>weights to be used in sampling and Bayesian computations
</p>
</dd>
<dt>pos.type</dt><dd>
<p>a factor with levels
<code>left</code>
<code>right</code> 
<code>center</code> 
</p>
</dd>
<dt>is.marker</dt><dd>
<p>always <code>TRUE</code> for these data
</p>
</dd>
<dt>pos.plot</dt><dd>
<p>a vector of plotting positions
</p>
</dd>
<dt>lambda</dt><dd>
<p>transformed recombination fractions
</p>
</dd>
<dt>locus</dt><dd>
<p>an abbreviated locus name
</p>
</dd>
<dt>chr.num</dt><dd>
<p>the chromosome number 1, 2, 3, 4, or 5.
</p>
</dd>
</dl>


<hr>
<h2 id='little.mf.5'> Package of Simulated Marker Map Information </h2><span id='topic+little.mf.5'></span>

<h3>Description</h3>

<p>The <code>little.mf.5</code> data frame has 114 rows and 9 columns
consisting of <code>little.map.frame</code> plus 64 'virtual' marker loci
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(little.mf.5)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>marker.name</dt><dd>
<p>The marker names taken from <code>little.map.frame</code> and those created to
fill virtual markers in between actual markers.
</p>
</dd>
<dt>cM</dt><dd>
<p>a vector of locations
</p>
</dd>
<dt>prior</dt><dd>
<p>weights to be used in sampling and Bayesian computations
</p>
</dd>
<dt>pos.type</dt><dd>
<p>a factor with levels
<code>left</code> 
<code>right</code> 
<code>center</code> 
</p>
</dd>
<dt>is.marker</dt><dd>
<p><code>TRUE</code> for the 50 markers, <code>FALSE</code> for the 'virtual' markers
</p>
</dd>
<dt>pos.plot</dt><dd>
<p>a vector of plotting positions
</p>
</dd>
<dt>lambda</dt><dd>
<p>transformed recombination fractions
</p>
</dd>
<dt>locus</dt><dd>
<p>an abbreviated locus name
</p>
</dd>
<dt>chr.num</dt><dd>
<p>the chromosome number 1, 2, 3, 4, or 5.
</p>
</dd>
</dl>


<hr>
<h2 id='locus'>Lookup loci or effects for genetic model formulas </h2><span id='topic+locus'></span><span id='topic+add'></span><span id='topic+dom'></span>

<h3>Description</h3>

<p>Convert numeric indexes to names of regressors for a genetic model.
One or many genetic models can be specified through the use of this
function.  It is used on the right hand side of a formula in the
<code><a href="#topic+bqtl">bqtl</a></code> function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locus(x, ..., scope, method, chromo, cM, ana.obj)
add(x, ..., scope, method)
dom(x, ..., scope, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locus_+3A_x">x</code></td>
<td>
 
<p>Typically an integer, an integer vector, or an array whose elements
are integers. These index loci described in a <code>map.frame</code>
object. 
</p>
<p>However, <code>x</code> can also be a character string, vector, et cetera,
in which case the elements must belong to <code>names(scope)</code>. </p>
</td></tr>
<tr><td><code id="locus_+3A_...">...</code></td>
<td>
 
<p>Optional arguments (usually integers) to be used when
<code>is.atomic(x)</code> is TRUE. 
</p>
</td></tr>
<tr><td><code id="locus_+3A_chromo">chromo</code></td>
<td>
<p>A chromosome number or 2 ordered numbers. The loci on the
chromosome or in the range of chromosome numbers are used. If
<code>chromo</code> is used, <code>x</code> must not be used.</p>
</td></tr>
<tr><td><code id="locus_+3A_cm">cM</code></td>
<td>
<p>(Optional) map distance or two giving a location near a locus
or range of locations from which loci will be included. If the one
chromosome number is specified in <code>chromo</code>, <code>cM</code> must be 
ordered. If <code>cM</code> is omitted, all loci on the chromosome(s) will
be included.</p>
</td></tr>
<tr><td><code id="locus_+3A_scope">scope</code></td>
<td>
<p> (Optional and)
Usually not supplied by the user.  Rather <code>bqtl</code> fills this in
automatically.  A vector of regressor names, like the <code>reg.names</code>
component returned by <code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code>.</p>
</td></tr>
<tr><td><code id="locus_+3A_method">method</code></td>
<td>
<p> (Optional and) 
Usually not supplied by the user. Like <code>scope</code>, <code>bqtl</code> takes
care of filling this in with &quot;BC1&quot;, &quot;F2&quot;, et cetera as appropriate.</p>
</td></tr>
<tr><td><code id="locus_+3A_ana.obj">ana.obj</code></td>
<td>
<p>Usually not specified by the user. This is the
<code>analysis.object</code> to be used to lookup loci if a <code>chromo</code>
argument is used.</p>
</td></tr>  </table>


<h3>Details</h3>

 <p><code>locus</code> is used in the model
formula notation of <code>bqtl</code>, possibly more than once, and possibly
with regressors named in the usual manner.  <code>locus</code> is intended to
speed up the specification and examination of genetic models by allowing
many models to be specified in a shorthand notation in a single model
formula.  The names of genetic loci can consist of marker names, names
that encode chromosome number and location, or other shorthand
notations.  The names of terms in genetic models will typically include
the names of the locus and may prepend &quot;add.&quot; or &quot;dom.&quot; or similar
abbreviations for the 'additive' and 'dominance' terms associated with
the locus.
</p>
<p>When used as in <code>bqtl( y ~ locus(34), my.analysis.obj )</code>, it will
look up the term or terms corresponding to the 34th locus. When
this is passed back to <code>bqtl</code>, it is pasted into a text string that
will become a formula and is subsequently processed to yield the fit for
a one gene model.
</p>
<p>When used as in <code>bqtl( y ~ locus(34,75,172), my.analysis.obj)</code> it
looks up each term and returns a result to <code>bqtl</code> that results in
fitting a 3 gene model (without interaction terms). 
</p>
<p>When <code>x</code> is a vector or array, the processing typically returns
pieces character strings for many model formulas.  <code>bqtl(y ~
locus(26:75), ...)</code> results in a list of 50 different one gene model
fits from <code>bqtl</code> for the terms corresponding to the 26th through
the 75th variables.  <code> bqtl(y ~
locus(cbind(c(15,45,192),c(16,46,193))),...)</code> returns two three gene
models.  And more generally, whenever <code>is.array(x)</code> is TRUE, the
columns (or slices) specify <code> dim(x)[1]/length(x)</code> different
models. 
</p>
<p>The <code>chromo</code> argument performs a lookup of loci on the chromosome
via the function <code><a href="#topic+map.index">map.index</a></code>. If <code>cM</code> is also given,
the locus nearest that location is used. If two values are given for
<code>cM</code> all loci in the range are used.
</p>
<p><code>add(x)</code> and <code>dom(x)</code> are alternatives that specify that only
the <em>additive</em> or <em>dominance</em> terms in an F2 intercross. 
</p>


<h3>Value</h3>

<p>A character vector whose element(s) can be parsed as the right hand side
of a model formula(s). 
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

 
<p><code>configs</code>,
<code><a href="#topic+bqtl">bqtl</a></code>, and the examples there for a sense of how to use
<code>locus</code>, 
<code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code> for the setup that encodes the marker
map and the marker information.
</p>

<hr>
<h2 id='loglik'> Extract loglikelihood, log posterior, or posterior from fitted models </h2><span id='topic+loglik'></span><span id='topic+loglik.default'></span><span id='topic+loglik.bqtl'></span><span id='topic+loglik.bqtl.list'></span><span id='topic+logpost'></span><span id='topic+logpost.default'></span><span id='topic+logpost.bqtl'></span><span id='topic+logpost.bqtl.list'></span><span id='topic+posterior'></span><span id='topic+posterior.default'></span><span id='topic+posterior.bqtl'></span><span id='topic+posterior.bqtl.list'></span>

<h3>Description</h3>

<p>A fitted model or a list of such generated by <code>bqtl</code> has a maximum
log likelihood or log posterior and a posterior. These functions simply
extract them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik(x, ...)
logpost(x, ...)
posterior(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_+3A_x">x</code></td>
<td>
<p> The object produced by <code>bqtl</code> </p>
</td></tr>
<tr><td><code id="loglik_+3A_...">...</code></td>
<td>
<p> Currently unused </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numbers whose length equals the number of fitted models in <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+bqtl">bqtl</a></code> </p>

<hr>
<h2 id='make.analysis.obj'>Set up data for QTL mapping </h2><span id='topic+make.analysis.obj'></span>

<h3>Description</h3>

<p>Create commonly used objects for the analysis of a backcross or
intercross experiment or of recombinant inbred lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.analysis.obj(data, map.frame, marker.frame, marker.levels=NULL,
method="F2", casewt=NULL,varcov=FALSE,mode.mat=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.analysis.obj_+3A_data">data</code></td>
<td>
<p> A <code>data.frame</code> (or vector) of phenotype and
(optionally) covariate information </p>
</td></tr>
<tr><td><code id="make.analysis.obj_+3A_map.frame">map.frame</code></td>
<td>
<p> A <code>map.frame.object</code> (see <code> <a href="#topic+make.map.frame">make.map.frame</a> </code>)  encoding the map
information and other details of the study </p>
</td></tr>
<tr><td><code id="make.analysis.obj_+3A_marker.frame">marker.frame</code></td>
<td>
<p> A <code>marker.frame.object</code>.  A matrix or data.frame
of marker state information.  </p>
</td></tr>
<tr><td><code id="make.analysis.obj_+3A_marker.levels">marker.levels</code></td>
<td>
<p>A vector of length six or <code>NULL</code>. If
<code>NULL</code> then the defaults for the elements are:
</p>

<table>
<tr>
 <td style="text-align: left;">
 Element    </td><td style="text-align: center;">  F2.default </td><td style="text-align: center;">  BC.default</td><td style="text-align: center;"> RI.default </td>
</tr>
<tr>
 <td style="text-align: left;">
 1  </td><td style="text-align: center;">   <code>"AA"</code>           </td><td style="text-align: center;">     <code>"AA"</code>
 </td><td style="text-align: center;">     <code>"AA"</code>   </td>
</tr>
<tr>
 <td style="text-align: left;">
 2  </td><td style="text-align: center;">   <code>"Aa"</code>           </td><td style="text-align: center;">     <code>"Aa"</code>
 </td><td style="text-align: center;">      <code>"aa"</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
   3  </td><td style="text-align: center;">   <code>"aa"</code>           </td><td style="text-align: center;">    <code>"nil"</code>
   </td><td style="text-align: center;">       <code>"nil"</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
   4  </td><td style="text-align: center;">   <code>"A-"</code>  </td><td style="text-align: center;">  <code>"nil"</code>
   </td><td style="text-align: center;">   <code>"nil"</code>     </td>
</tr>
<tr>
 <td style="text-align: left;">
   5  </td><td style="text-align: center;">  <code>"a-"</code>   </td><td style="text-align: center;">    <code>"nil"</code>
   </td><td style="text-align: center;">   <code>"nil"</code>      </td>
</tr>
<tr>
 <td style="text-align: left;">
   6  </td><td style="text-align: center;">  <code>"--"</code>     </td><td style="text-align: center;">    <code>"--"</code>
   </td><td style="text-align: center;">   <code>"--"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>NA's are allowed in <code>marker.frame</code> as well as the sixth
element(<code>"--"</code> by default) to denote missing data.  To use other
coding schemes replace &quot;AA&quot; and &quot;aa&quot; by codes for homozygous states,
&quot;Aa&quot; by the code for heterozygotes, &quot;A-&quot; by the code for 'not aa',
&quot;a-&quot; by the code for 'not AA', and <code>"--"</code> by the missing code.
Positions 3:5 are just placeholders if <code>method!="F2"</code>, but must
be present.</p>
</td></tr> 
<tr><td><code id="make.analysis.obj_+3A_method">method</code></td>
<td>
<p>One of &quot;F2&quot;, &quot;BC1&quot;, &quot;RI.self&quot;, or &quot;RI.sib&quot; </p>
</td></tr>
<tr><td><code id="make.analysis.obj_+3A_casewt">casewt</code></td>
<td>
<p>If there are multiple observations on one genotype (such
as in recombinant inbreds) this can be used to assign a weight to
each observation. The wisdom of doing this is debatable. </p>
</td></tr>
<tr><td><code id="make.analysis.obj_+3A_varcov">varcov</code></td>
<td>
<p>If FALSE, don't create a varcov.object. Otherwise give an
index into data to select a dependent variable. See <code> <a href="#topic+varcov">varcov</a></code>
</p>
</td></tr>
<tr><td><code id="make.analysis.obj_+3A_mode.mat">mode.mat</code></td>
<td>
<p>If <code>NULL</code> use the default. For
<code>method=="F2"</code> ( and the default <code>marker.levels</code> of
<code>AA</code>, <code>Aa</code>, and <code>aa</code> ), 
this is a 3 by 2 matrix:
</p>

<table>
<tr>
 <td style="text-align: left;">
     Genotype </td><td style="text-align: right;"> add </td><td style="text-align: right;"> dom </td>
</tr>
<tr>
 <td style="text-align: left;">
     AA </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> -1 </td>
</tr>
<tr>
 <td style="text-align: left;">
     Aa </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
     aa </td><td style="text-align: right;"> -1 </td><td style="text-align: right;"> -1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td>
</tr>

</table>

<p>For <code>method=="BC1"</code> ( and the default <code>marker.levels</code> of
<code>AA</code> and <code>Aa</code> ),it is
</p>

<table>
<tr>
 <td style="text-align: left;">
     Genotype </td><td style="text-align: right;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
     AA </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
     Aa </td><td style="text-align: right;"> -1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td>
</tr>

</table>

<p>and for RIL methods ( and the default <code>marker.levels</code> of
<code>AA</code> and <code>aa</code> ),it is
</p>

<table>
<tr>
 <td style="text-align: left;">
     Genotype </td><td style="text-align: right;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
     AA </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
     aa </td><td style="text-align: right;"> -1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td>
</tr>

</table>

<p>Other choices of <code>marker.levels</code> will relabel the corresponding
rows.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A lot of stuff is bundled together in one object. The function is
really just a wrapper calling other <code>make.*</code> functions.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p><code>data.frame</code> of phenotype, covariate information,
and regressors created by <code> make.regressor.matrix </code></p>
</td></tr>
<tr><td><code>varcov</code></td>
<td>
<p>A varcov.object. See  <code> make.varcov </code> </p>
</td></tr>
<tr><td><code>reg.names</code></td>
<td>
<p>The names of the regressors from <code>
      make.regressor.matrix </code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The <code> method </code> argument in the call.</p>
</td></tr>
<tr><td><code>state.matrix</code></td>
<td>
<p>See <code> make.state.matrix </code></p>
</td></tr>
<tr><td><code>loc.right</code></td>
<td>
<p>See <code> make.loc.right </code></p>
</td></tr>
<tr><td><code>map.frame</code></td>
<td>
<p>See <code> make.map.frame </code></p>
</td></tr>
<tr><td><code>casewt</code></td>
<td>
<p>The <code> casewt </code> argument</p>
</td></tr>
<tr><td><code>mode.mat</code></td>
<td>
<p>The <code>mode.mat</code> used</p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>A string giving the version of BQTL from qhich the
objects was created</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call</p>
</td></tr>
</table>


<h3>Note</h3>

<p> This can be quite a LARGE object.It might be better
in crosses with lots (say, thousands) of markers, or in which many
'virtual' markers are used, or on computers with limited RAM to
store each component separately. Not all components are used in
every type of analysis. </p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+make.map.frame">make.map.frame</a></code> for definition of the marker map, The
internally used functions are: <code><a href="#topic+make.loc.right">make.loc.right</a></code>,
<code><a href="#topic+make.state.matrix">make.state.matrix</a></code>, <code><a href="#topic+make.regressor.matrix">make.regressor.matrix</a></code>,
<code><a href="#topic+make.varcov">make.varcov</a></code>,  and <code><a href="#topic+make.marker.numeric">make.marker.numeric</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data( little.bc.pheno )
data( little.mf.5 )
data( little.bc.markers )
names(little.bc.pheno)
little.ana.bc &lt;- make.analysis.obj(little.bc.pheno$bc.phenotype,
                                   little.mf.5,little.bc.markers,
                                   method="BC1")
summary( little.ana.bc )


</code></pre>

<hr>
<h2 id='make.loc.right'> Keep track of fully informative markers or states</h2><span id='topic+make.loc.right'></span>

<h3>Description</h3>

<p>Helps speed computations in multigene models by allowing a quick
assessment of whether two loci are independent given the marker
information for the individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.loc.right(marker.frame, marker.distances)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.loc.right_+3A_marker.frame">marker.frame</code></td>
<td>
<p> A <code>marker.frame.object</code>  </p>
</td></tr> 
<tr><td><code id="make.loc.right_+3A_marker.distances">marker.distances</code></td>
<td>
<p>Actually a misnomer, this is a vector with a
zero in the last position of each chromosome.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimension as <code>marker.frame</code> whose elements
index the column on the next (right) fully informative marker.
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>

<hr>
<h2 id='make.location.prior'> Provide a default prior</h2><span id='topic+make.location.prior'></span>

<h3>Description</h3>

<p>Uses the map distances as a means of assigning a prior for chromosomal
location.  Basically, this function attempts to assign equal weight
according to the spacing or markers and 'virtual' markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.location.prior( x, add.2.end=0, normalize=TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.location.prior_+3A_x">x</code></td>
<td>
 <p><code class="reqn">x = e^{-mgd}</code> ,where mgd is the map distance in Morgans </p>
</td></tr>
<tr><td><code id="make.location.prior_+3A_add.2.end">add.2.end</code></td>
<td>
<p> How many Morgans to extend the first and last
interval on each chromosome </p>
</td></tr>
<tr><td><code id="make.location.prior_+3A_normalize">normalize</code></td>
<td>
<p> If TRUE, let the result sum to 1.0 </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>length(x)</code> whose sum is one, if <code>normalize==TRUE</code>
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry, <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>

<hr>
<h2 id='make.map.frame'>Create marker map specifications</h2><span id='topic+make.map.frame'></span>

<h3>Description</h3>

<p>A map.frame.object describes a marker map and additional loci that may
be used in a QTL study.  Each row pertains to one locus.  Names of
markers, abbreviated names, distances, and other necessary and useful
information are bundled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.map.frame(dx,chr.num = NULL, prior = make.location.prior(lambda), 
    morgan = 100, nint = NULL, reso = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.map.frame_+3A_dx">dx</code></td>
<td>
<p> An object of class <code>"map.frame"</code> or class
<code>"data.frame"</code> or a vector or a
data.frame with a column named <code>cM</code>, <code>M</code>, or <code>dx</code> or
whose first column gives location  
on each chromosome in  centiMorgans (from start of
chromosome or Morgans if <code>M</code> was the column name).  It is best
if <code>names(dx)</code> (for vector arguments) 
or <code>row.names(dx)</code> (for data.frame arguments) give names of
markers for later reference, but this isn't really necessary.  </p>
</td></tr> 
<tr><td><code id="make.map.frame_+3A_chr.num">chr.num</code></td>
<td>
<p> (Optional) Vector of  chromosome  numbers</p>
</td></tr>
<tr><td><code id="make.map.frame_+3A_prior">prior</code></td>
<td>
<p> (Optional) Vector of Prior probabilities for the loci </p>
</td></tr>
<tr><td><code id="make.map.frame_+3A_morgan">morgan</code></td>
<td>
<p> 100 if centiMorgans, 1 if Morgans </p>
</td></tr>
<tr><td><code id="make.map.frame_+3A_nint">nint</code></td>
<td>
<p> (Optional) Vector of one plus number of 'virtual' markers to be
inserted after each locus </p>
</td></tr>
<tr><td><code id="make.map.frame_+3A_reso">reso</code></td>
<td>
<p>Maximum distance between loci. If necessary fill in with 'pseudo-markers'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The QTL analysis depends on information about the marker map and on
specifications of the loci to be studied.  The 'map.frame' contains
this information. 
</p>


<h3>Value</h3>

<p>A data frame with components:
</p>
<table>
<tr><td><code>marker.name</code></td>
<td>
<p>The full text identifier for this marker,
e.g.  &quot;HH.360L.Col&quot; is a marker on chromosome 1 of arabidopsis
thaliana, and names like this can be used for reference
purposes.  'Virtual' markers have a suffix appended to the name of the
previous marker.</p>
</td></tr>
<tr><td><code>cM</code></td>
<td>
<p>Location on the chromosome.  If this is a marker of a locus
that was input via <code>dx</code>, then it is just the value of <code>dx</code>.</p>
</td></tr>
<tr><td><code>pos.type</code></td>
<td>
<p>&quot;left&quot; if it is the first locus on this
chromosome,&quot;right&quot; if it is last, or &quot;center&quot; otherwise. </p>
</td></tr>
<tr><td><code>is.marker</code></td>
<td>
<p>TRUE if this was actually a marker, FALSE if it is a
'virtual' marker</p>
</td></tr>
<tr><td><code>pos.plot</code></td>
<td>
<p>Plotting position for this locus.  Typically the same as
<code>dx</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Twice the recombination fraction minus one.</p>
</td></tr>
<tr><td><code>locus</code></td>
<td>
<p>An abbreviation for the locus of the form
&quot;C.&lt;<code>chr.num</code>&gt;.&lt;<code>cM</code>&gt;&quot;</p>
</td></tr>
<tr><td><code>chr.num</code></td>
<td>
<p>The chromosome number.</p>
</td></tr>
</table>


<h3>Note</h3>

<p> The idea in having all of this bundled together is to make it
easier for plot and summary methods to be implemented and to allow
convenient references in formula based methods.</p>


<h3>Author(s)</h3>

<p> Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( little.map.dx )
little.map.frame &lt;- make.map.frame( little.map.dx )
plot( little.map.frame ) # there is a plot method
# add 'virtual' markers to map
little.mf.5 &lt;-   make.map.frame(little.map.frame,reso=5)
print(little.mf.5[1:10,],digits=1) # show a few rows
plot( little.mf.5 ) # notice the 'virtual' markers added

</code></pre>

<hr>
<h2 id='make.marker.numeric'>Translate a marker.frame.object to numeric matrix </h2><span id='topic+make.marker.numeric'></span>

<h3>Description</h3>

<p>Not to be called directly by users. This utility function simply
returns the coded numeric values corresponding to the allele states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.marker.numeric(marker.frame, level.names=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.marker.numeric_+3A_marker.frame">marker.frame</code></td>
<td>
<p> A data.frame.object consisting of factors or
character vectors that encode the allele states.</p>
</td></tr>
<tr><td><code id="make.marker.numeric_+3A_level.names">level.names</code></td>
<td>
<p> A vector of length 6 to translate the levels
attribute or character codes into allele states that
<code>make.state.matrix</code> understands. If necessary, dummy codes are
used to fill the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, for which column i is
<code>match(as.character(marker.frame[,i]),level.names)</code>
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>

<hr>
<h2 id='make.regressor.matrix'>
Create regressors using expected marker values
</h2><span id='topic+make.regressor.matrix'></span>

<h3>Description</h3>

<p>Create regression variables for markers and loci between or near
markers by imputation conditional on known marker states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.regressor.matrix(state.matrix, mode.mat=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.regressor.matrix_+3A_state.matrix">state.matrix</code></td>
<td>

<p>A state.matrix.object - see <code><a href="#topic+make.state.matrix">make.state.matrix</a></code> for more details
</p>
</td></tr>
<tr><td><code id="make.regressor.matrix_+3A_mode.mat">mode.mat</code></td>
<td>

<p>A matrix which indicates the values of regressor variables
corresponding to the allele states.  If mode.mat=NULL (the default) a
mode.mat is inferred from the dimensions of state.matrix.  For the F2
intercross these are typically additive and dominance codes like
(-1,0,1) and (1,-1,1).  For BC1 backcross and RI lines, typically the
values are (-1,1).
</p>
</td></tr></table>


<h3>Value</h3>

<p>A matrix with variables suitable for use as regressors.
</p>


<h3>References</h3>

<p>Haley C.S. and Knott S.A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking
markers. <em>Heredity</em> <b>69</b>,315-324.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.state.matrix">make.state.matrix</a></code>
</p>

<hr>
<h2 id='make.state.matrix'>
Create state.matrix.object
</h2><span id='topic+make.state.matrix'></span>

<h3>Description</h3>

<p>Create a state.matrix.object to be used encode marker information in a
form in which it can be used in subsequent calculations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.state.matrix(marker.frame, marker.distances, method="F2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.state.matrix_+3A_marker.frame">marker.frame</code></td>
<td>

<p>Actually, this is a misnomer. This is NOT
a<code>marker.frame.object</code>. Rather it is obtained by by call like
<code>make.marker.numeric(marker.frame.object)</code> (see <code>
      <a href="#topic+make.marker.numeric">make.marker.numeric</a> </code>) and it is coerced to 
a matrix. It  encodes marker allele states. One column is used for each 
marker or pseudo-marker (basically a placeholder with all missing
values). The entries are in 1:6, if NA's are present, they are
recoded to 6.  The columns are arranged in
linkage groups with presumed order reflected in the actual order of the
columns.  
</p>
</td></tr>
<tr><td><code id="make.state.matrix_+3A_marker.distances">marker.distances</code></td>
<td>

<p>Distances between the markers in the 'lambda' metric. -log(lambda)/2
is the Haldance map distance. Linkage groups are separated by values
of 0.0. 
</p>
</td></tr>
<tr><td><code id="make.state.matrix_+3A_method">method</code></td>
<td>

<p>method = &quot;F2&quot; is the default, and   &quot;BC1&quot;, &quot;RI.self&quot;, and &quot;RI.sib&quot; are
other options. The assumed setup is as follows (strains are A and a):
</p>

<table>
<tr>
 <td style="text-align: left;">
    marker state </td><td style="text-align: center;">  F2.code </td><td style="text-align: center;">  BC.code</td><td style="text-align: center;"> RI.code </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"AA"</code>  </td><td style="text-align: center;">    1    </td><td style="text-align: center;">     1   </td><td style="text-align: center;">    1</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"Aa"</code> </td><td style="text-align: center;">     2  </td><td style="text-align: center;">      2 </td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"aa"</code>  </td><td style="text-align: center;">    3   </td><td style="text-align: center;">        </td><td style="text-align: center;">      2 </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"A-"</code> (not aa)    </td><td style="text-align: center;">  4      </td><td style="text-align: center;">   </td><td style="text-align: center;">     </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"a-"</code> (not AA) </td><td style="text-align: center;">    5    </td><td style="text-align: center;">     </td><td style="text-align: center;">        </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"--"</code> (unknown) </td><td style="text-align: center;">    6 </td><td style="text-align: center;">        6   </td><td style="text-align: center;">    6</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

</td></tr></table>


<h3>Value</h3>

<p>n by k by q array. q is  3 for method=&quot;F2&quot; and 2 for others methods.  Each
element encodes the probability of the allele state conditional on the
marker states. 
</p>


<h3>Note</h3>

<p>It might have been better to design this array so that the third
subscript moves fastest.  In large problems, the current structure may
involve excessive memory access.</p>


<h3>References</h3>

<p>Lander E.S. and Green P. (1987) Construction of multilocus genetic linkage maps
in humans. <em>Proceedings of the National Academy of Sciences of the
United States of America</em>, <b>84</b>(8), 2363&ndash;7.
</p>
<p>Jiang C. and Zeng Z-B.  (1997) Mapping quantitative trait loci with dominant and
missing markers in various crosses from tow inbred lines. <em>Genetica</em>
<b>101</b>, 47-58.  
</p>

<hr>
<h2 id='make.varcov'> Create moment matrices</h2><span id='topic+make.varcov'></span>

<h3>Description</h3>

<p>Create a moment matrix of the marker variables and of the regressors by
the phenotype variable.  For use in regression modelling on the markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.varcov(regressor.matrix, y, subset=is.finite(y), casewt=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.varcov_+3A_regressor.matrix">regressor.matrix</code></td>
<td>
<p>The object produced by <code><a href="#topic+make.regressor.matrix">make.regressor.matrix</a></code> </p>
</td></tr>
<tr><td><code id="make.varcov_+3A_y">y</code></td>
<td>
<p> A vector of phenotype information with the same number of
elements as there are rows in <code>regressor.matrix</code> </p>
</td></tr>
<tr><td><code id="make.varcov_+3A_subset">subset</code></td>
<td>
<p> Logical vector with the same number of
elements as there are rows in <code>regressor.matrix</code> to indicate
which rows to keep.  </p>
</td></tr>
<tr><td><code id="make.varcov_+3A_casewt">casewt</code></td>
<td>
<p>Optional vector of case weights. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>var.x</code></td>
<td>
<p>Moment matrix of the marker regressor variables</p>
</td></tr>
<tr><td><code>cov.xy</code></td>
<td>
<p>Moment matrix of the marker regressor variables versus
the phenotype variable</p>
</td></tr>
<tr><td><code>var.y</code></td>
<td>
<p>The Second central moment of the phenotype variable</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
 <p><code> sum(subset==TRUE) - 1</code>
</p>
</td></tr></table>


<h3>Note</h3>

<p> It is generally NOT a good idea to do regressions on
ill-conditioned designs using the moment matrices like this.  The
excuse for doing so here is twofold.  First, calculations using this
method are used to perform importance sampling, so minor numerical
inaccuracies in computing the probabilites used in sampling get
straightened out by the importance weights.  Second, it will typically
be the case that a prior is set on the regression coefficients and
this results in a positive constant (aka a 'ridge' parameter) being
added to diagonal of <code>varcov$var.x</code> and this reduces the
ill-conditioning.  Of course the rational for using the method is to
speed the sampling, and it is very effective at doing so.</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>

<hr>
<h2 id='map.index'>Look up numerical index(es) of map locations</h2><span id='topic+map.index'></span><span id='topic+map.index.default'></span><span id='topic+map.index.analysis.object'></span>

<h3>Description</h3>

<p>One way to index a locus (loci) in a genetic map is by the numerical index of
its row (their rows). <code>map.index</code> performs a lookup in a specific
<code>map.frame</code> given one (or two) chromosome number(s) and one (or
two) map distance(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.index(x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.index_+3A_x">x</code></td>
<td>
<p>A <code>map.frame</code> or <code>analysis.object</code></p>
</td></tr>
<tr><td><code id="map.index_+3A_...">...</code></td>
<td>
<p> For methods that look up a location in a <code>map.frame</code>
the following named arguments may be used:
<code>chromo </code>A chromosome number or 2 ordered numbers 
<code>cM </code>(Optional) map distance or two. If the same chromosome
number is used twice in <code>chromo</code>, <code>cM</code> must be
ordered. If <code>cM</code> is omitted, all loci on the chromosome will
be included.
</p>
</td></tr></table>


<h3>Details</h3>

<p>It is often convenient to refer to genetic loci or regions by the
numerical index(es) in a <code>map.frame</code>. <code>map.index</code> allows
lookups according to the approximate map location.
</p>


<h3>Value</h3>

<p>A numerical vector of one or more row numbers. If only <code>chromo</code> is
specified, all row numbers on the specified chromosome are returned. If
<code>chromo</code> has two elements, then all row numbers on those
chromosomes with numbers in <code>range(chromo)</code> will be returned. If
one of each of <code>chromo</code> and <code>cM</code> are specified, then the row
number of the closest locus will be returned. For two of each, row
numbers in the range of the closest matches will be returned.
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+make.map.frame">make.map.frame</a></code> for a description of how map
information is organized.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(little.ana.bc)
map.index(little.ana.bc,chromo=1,cM=25) # locus nearest 1,25
index.chr.1 &lt;- map.index(little.ana.bc,chromo=1)
fit.on.1 &lt;- bqtl(bc.phenotype~locus(index.chr.1),little.ana.bc)
summary( loglik( fit.on.1 ) )

</code></pre>

<hr>
<h2 id='map.location'> Report map location  </h2><span id='topic+map.loc'></span><span id='topic+map.location'></span><span id='topic+map.location.default'></span><span id='topic+map.location.analysis.object'></span><span id='topic+map.location.bqtl'></span><span id='topic+map.location.bqtl.list'></span>

<h3>Description</h3>

<p>Report the chromosome number and location of loci in a genetic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.location(x,... )
map.loc(x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.location_+3A_x">x</code></td>
<td>
<p>A object of class <code>map.frame</code>,<code>analysis.object</code>,
<code>bqtl</code>, or <code>bqtl.list</code></p>
</td></tr>
<tr><td><code id="map.location_+3A_...">...</code></td>
<td>
<p>Other arguments usage depend on the class of <code>x</code> :
<code>y</code> A vector of row numbers or <code>map.names</code> specifying which
subset of the <code>map.frame</code> of <code>x</code> is to be returned
<code>chromo</code>: A vector of chromosome numbers
<code>cM </code> (Optional) map distance vector. If the same chromosome
number is used twice in <code>chromo</code>, <code>cM</code> must be
ordered. If <code>cM</code> is omitted, all loci on each chromosome listed
in <code>chromo</code> will be included.
</p>
<p><code>map.names</code>A vector of <code>map.names</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p> It is often helpful to refer to genentic loci by their
locations. The methods of <code>map.location</code> (alias <code>map.loc</code>)
will extract the row index, chromosome number and location, and the name
for specified loci. For direct lookups of the loci in a <code>map.frame</code>
or <code>analysis.object</code>, one must specify <code>y</code> or <code>chromo</code> or
<code>map.names</code>. When <code>class(x)=="bqtl"</code> <code>map.location</code>s of
terms used in a call to <code>bqtl</code> are returned. When <code>cM</code> is
used, an attempt will be made to match the location; if the match fails,
the nearest locus will be used. When there are two elements in
<code>chromo</code> and two in <code>cM</code>, all the map locations in between the
matching loci will be returned.
</p>


<h3>Value</h3>

<p>An object of class <code>map.location</code> which inherits from
<code>map.frame</code>. It has columns:
</p>
<table>
<tr><td><code>chr.num</code></td>
<td>
<p>The chromosome number</p>
</td></tr>
<tr><td><code>cM</code></td>
<td>
<p>The location in centiMorgans on that chromosome.</p>
</td></tr>
<tr><td><code>marker.name</code></td>
<td>
<p>The name by which that marker is known</p>
</td></tr>
<tr><td><code>attr(</code>, <code>"row.names")</code></td>
<td>
<p>An index of the locations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+make.map.frame">make.map.frame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(little.ana.bc)

map.loc(little.ana.bc, c(1,15,45))
map.loc(little.ana.bc,chromo=3,cM=22)
map.loc(little.ana.bc,"m.12")
rm(little.ana.bc)
</code></pre>

<hr>
<h2 id='map.names'>Look up names of markers or loci</h2><span id='topic+map.names'></span><span id='topic+map.names.default'></span><span id='topic+map.names.bqtl'></span><span id='topic+map.names.bqtl.list'></span><span id='topic+map.names.analysis.object'></span><span id='topic+map.names.map.frame'></span>

<h3>Description</h3>

<p>This is  a generic helper function with methods  that will
return the names of markers or loci. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.names(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.names_+3A_x">x</code></td>
<td>
<p> An object that has marker names in it. Methods for objects
of the 
<code>map.frame</code>, <code>analysis.object</code>,<code>bqtl</code>, and
<code>bqtl.list</code> class.</p>
</td></tr>
<tr><td><code id="map.names_+3A_...">...</code></td>
<td>
<p>For <code>class(x)=="analysis.object"</code> or
<code>class(x)=="map.frame"</code>, arguments <code>chromo</code> and <code>cM</code>
can be used as in <code>map.index</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When applied to an object of class <code>bqtl</code>
</p>
<pre>map.names(x, \dots, ana.obj )
  </pre>
<p>can be used to specify where to find the data.
</p>


<h3>Value</h3>

<p>A character vector 
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+map.index">map.index</a></code>, <code><a href="#topic+map.location">map.location</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(little.ana.bc)

map.names(little.ana.bc,chromo=1,cM=24)

map.names(little.ana.bc,chromo=c(1,1),cM=c(40,55))

fit &lt;- bqtl( bc.phenotype ~ locus(23,42) , little.ana.bc )

map.names( fit )


</code></pre>

<hr>
<h2 id='marker.fill'>
Map Positions Between Markers
</h2><span id='topic+marker.fill'></span>

<h3>Description</h3>

<p>Given a set of markers, one wants to create a finer map at a given
resolution. marker fill takes a a collection of marker distances and a
desired resolution and finds positions that are intermediate and at
that resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker.fill(map.frame, reso, return.nint = FALSE)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker.fill_+3A_map.frame">map.frame</code></td>
<td>

<p>A map.frame.object.
</p>
</td></tr>
<tr><td><code id="marker.fill_+3A_reso">reso</code></td>
<td>

<p>The desired interval between loci in the same metric as <code>map.frame$cM</code>
</p>
</td></tr>
<tr><td><code id="marker.fill_+3A_return.nint">return.nint</code></td>
<td>
<p>Whether to output a vector of number of intervals to
produce in each existing interlocus interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.nint</code> is <code>TRUE</code>, a vector of integers is
returned. It indicates how many intervals to place between this marker
and the next to achive the desired minimum distance.
</p>
<p>If <code>return.nint</code> is <code>FALSE</code>, a vector of distances is
returned. The names attribute has suffixes 
added to indicate positions filled to the 'right' of existing
markers. Thus if markers 'mark.01' and 'mark.02' are in succession at
a distance of 3 and reso==1, then the value associated with 'mark.01'
(which was 3) becomes 1, a value of 1 is associated with new loci
called 'mark.01.1' and 'mark.01.2' in created with values of 1
each. The returned vector is ordered by chromosome, then marker or
filled locus.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.map.frame">make.map.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data( little.map.frame  )
little.nint &lt;- marker.fill( little.map.frame, reso=5, TRUE )
cbind(nint=little.nint,cM=little.map.frame$cM)[1:10,]
rm( little.map.frame, little.nint )
</code></pre>

<hr>
<h2 id='marker.levels'> Define marker level codes </h2><span id='topic+marker.levels'></span><span id='topic+bc1.levels'></span><span id='topic+f2.levels'></span><span id='topic+ri.levels'></span>

<h3>Description</h3>

<p>The coding scheme used to define marker.levels is set up by these
functions. <em>BQTL</em> has defaults that these functions can help the
user to redefine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc1.levels( AA="AA", Aa="Aa", miss.val="--")
ri.levels(  AA="AA", aa="aa", miss.val="--")
f2.levels(  AA="AA", Aa="Aa", aa="aa", not.aa="A-", not.AA="a-",
miss.val="--")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marker.levels_+3A_aa">AA</code></td>
<td>
<p>Always used: the code for the homozygous state from one parent line</p>
</td></tr>
<tr><td><code id="marker.levels_+3A_aa">Aa</code></td>
<td>
<p>F2 and BC1 setups: the code for the heterozygous state </p>
</td></tr>
<tr><td><code id="marker.levels_+3A_aa">aa</code></td>
<td>
<p>F2 and RI setups: the code for the homozygous state for the
other parent line </p>
</td></tr>
<tr><td><code id="marker.levels_+3A_not.aa">not.aa</code></td>
<td>
<p>F2 only: the code for a dominant marker that rules out  <code>aa</code> </p>
</td></tr>
<tr><td><code id="marker.levels_+3A_not.aa">not.AA</code></td>
<td>
<p>F2 only: the code for a dominant marker that rules out <code>AA</code> </p>
</td></tr>
<tr><td><code id="marker.levels_+3A_miss.val">miss.val</code></td>
<td>
<p>The character string for a missing (unknown) allele
state. <code>NA</code>s are automatically detected, so this is only needed
if string values are used to denote missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is essential that the codes intended by the user be
clearly understood by <em>BQTL</em>. It is hoped that thees functions
provide a bridge between the internals of <em>BQTL</em> and the user's
view of the marker codes. Numeric values can be used, but they will be
coerced to character values.</p>


<h3>Value</h3>

<p>A vector with 6 elements corresponding to the values of 
<code>AA</code>, <code>Aa</code>, <code>aa</code>, <code>not.aa</code>, <code>not.AA</code>, and
<code>miss.val</code>. For RI and BC1 setups, those that do not apply will
be unnamed and set to <code>"nil"</code>
</p>


<h3>Author(s)</h3>

<p> Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
### show the defaults:

f2.levels()
bc1.levels()
ri.levels()

### suppose that 1,2,3 are codes used in F2:

f2.levels(1,2,3)

### show what would happen changing "Aa" to "H"

f2.levels(Aa="H")
bc1.levels(Aa="H")

</code></pre>

<hr>
<h2 id='plot.map.frame'> plots by chromosome location </h2><span id='topic+plot.map.frame'></span><span id='topic+plot.analysis.object'></span>

<h3>Description</h3>

<p>Multiple x-y plots are formed using chromosome numbers
(<code>chr.num</code>) and positions (<code>pos.plot</code>) specified in a object
of the sort created by <code><a href="#topic+make.map.frame">make.map.frame</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map.frame'
plot(x, y, fun = if (y.type == "matrix") matlines else
                 lines, type = "l", include.rug = TRUE, rug.lwd = 0.1,
                 title.string = NULL, y.range = NULL, ylab =
                 deparse(substitute(y)), xlab = "Location", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.map.frame_+3A_x">x</code></td>
<td>
<p>A <code>map.frame.object</code> or an <code>analysis.object</code>  </p>
</td></tr>
<tr><td><code id="plot.map.frame_+3A_y">y</code></td>
<td>
<p> (optional) A vector with as many elements or a
matrix with as many rows as <code>nrow(x)</code> .  If omitted, a plot
will be drawn in a single frame representing the chromosomes as
horizontal bars and giving tic marks to show the locations markers
and virtual markers (if any).</p>
</td></tr>  
<tr><td><code id="plot.map.frame_+3A_...">...</code></td>
<td>
<p> more args</p>
</td></tr>
<tr><td><code id="plot.map.frame_+3A_fun">fun</code></td>
<td>
<p>  A plotting function to be used <em>after</em> the plot axes and
labels have been drawn.  The current default <code>if (y.type ==
      "matrix") matlines else lines</code> usually is good enough.  But a
fancier function could be used for a fancier plot. </p>
</td></tr>
<tr><td><code id="plot.map.frame_+3A_type">type</code></td>
<td>
 <p><code>"l"</code> for lines, &quot;p&quot; for points, et cetera.  see <code><a href="graphics.html#topic+par">par</a></code> </p>
</td></tr>
<tr><td><code id="plot.map.frame_+3A_include.rug">include.rug</code></td>
<td>
<p> if <code>TRUE</code> place a tick on the x-axis at each marker location </p>
</td></tr>
<tr><td><code id="plot.map.frame_+3A_rug.lwd">rug.lwd</code></td>
<td>
<p>size of ticks</p>
</td></tr>
<tr><td><code id="plot.map.frame_+3A_title.string">title.string</code></td>
<td>
<p> (optional) label to prepend to each title </p>
</td></tr>
<tr><td><code id="plot.map.frame_+3A_y.range">y.range</code></td>
<td>
<p>range for y limits</p>
</td></tr>
<tr><td><code id="plot.map.frame_+3A_ylab">ylab</code></td>
<td>
<p> plot label for y-axis, see <code><a href="graphics.html#topic+par">par</a></code>  </p>
</td></tr>
<tr><td><code id="plot.map.frame_+3A_xlab">xlab</code></td>
<td>
<p> plot label for x-axis, see <code><a href="graphics.html#topic+par">par</a></code>  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables drawing graphs that depend on chromosome and
chromosome location.  Typically, one will use a command like
<code>par(mfrow=c(nrows,ncols))</code> first to set up a page on which
multiple plots will be drawn.  However, one can draw one plot per page
on postscript devices by leaving <code>par(mfrow=c(1,1))</code>
</p>


<h3>Value</h3>

<p><code>NULL</code> - this function is called only for its side effects
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+lines">lines</a></code>, and 
<code><a href="graphics.html#topic+matlines">matlines</a></code> for general information on plotting functions;
<code><a href="graphics.html#topic+par">par</a></code> for optional arguments to add as arguments; and 
<code><a href="#topic+make.map.frame">make.map.frame</a></code> for the details on the object the drives this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data( little.ana.bc )
null.llk &lt;- loglik(bqtl(bc.phenotype~1,little.ana.bc))
llk &lt;- loglik( bqtl( bc.phenotype~locus(all), little.ana.bc) ) - null.llk
.old.par &lt;- par(mfrow=c(2,3))
plot.map.frame(little.ana.bc$map.frame,llk)
par(.old.par)


</code></pre>

<hr>
<h2 id='predict.bqtl'> fitted values from QTL models</h2><span id='topic+predict.bqtl'></span><span id='topic+fitted.bqtl'></span>

<h3>Description</h3>

<p>The estimated coefficients and expected locus values are used to find
fitted values for the QTL model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bqtl'
predict(object, newdata, ...)
## S3 method for class 'bqtl'
fitted(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bqtl_+3A_object">object</code></td>
<td>
<p> An object of class <code><a href="#topic+bqtl">bqtl</a></code></p>
</td></tr>
<tr><td><code id="predict.bqtl_+3A_newdata">newdata</code></td>
<td>
<p>An optional data.frame for which fitted values are to
be found. If not specified, the a search for the original data frame
for the fit will be made. </p>
</td></tr>
<tr><td><code id="predict.bqtl_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated coefficients for a specific QTL model fit are used along
with the  expected locus values (conditionally on the marker values)
are used to find fitted values for the QTL model. This is <em>not</em> the only
way in which such fits could be obtained; one could condition the
expect marker values on <em>both</em> the trait value and the marker
values. One could also define fitted values for specific genotype
combinations, e.g. for a backcross with k animals and a two gene model
4 fitted values could be determined for each animal leading to 2*2*k
values. In fact, using <code>newdata</code> one can do this.
</p>


<h3>Value</h3>

<p> A vector with as many elements as rows in newdata (after
removing missing data) or in the original model.frame.
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+bqtl">bqtl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(little.ana.bc)

fit.pheno &lt;- bqtl(bc.phenotype~locus(15)+locus(42),little.ana.bc)

summary(predict(fit.pheno))

genotype.grid &lt;- expand.grid( c(-1,1), c(-1,1) )     # set up a grid
names(genotype.grid) &lt;- map.names( fit.pheno )       # use matching names

fit.vals &lt;- predict( fit.pheno, genotype.grid )      # make predictions
cbind( genotype.grid, fit.vals )                     # print them!

</code></pre>

<hr>
<h2 id='predict.linear.bayes'> Residuals or Predicted Values for linear.bayes objects </h2><span id='topic+predict.linear.bayes'></span><span id='topic+fitted.linear.bayes'></span><span id='topic+residuals.linear.bayes'></span>

<h3>Description</h3>

<p>The <code>linear.bayes</code> object returns fitted coefficients. These are
used to construct predicted values. Since the fitting process for
<code>linear.bayes</code> objects is based on moments of centered variables,
the 'intercept' is lost; see &lsquo;Details&rsquo; below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linear.bayes'
residuals(object, ...)
## S3 method for class 'linear.bayes'
predict(object, newdata = lb.call$ana.obj, return.resids =
                 FALSE, ...)
## S3 method for class 'linear.bayes'
fitted(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.linear.bayes_+3A_object">object</code></td>
<td>
<p>An object returned by <code>linear.bayes</code> </p>
</td></tr>
<tr><td><code id="predict.linear.bayes_+3A_...">...</code></td>
<td>
<p>possibly the following</p>
</td></tr>
<tr><td><code id="predict.linear.bayes_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> in which to do the calculations </p>
</td></tr>
<tr><td><code id="predict.linear.bayes_+3A_return.resids">return.resids</code></td>
<td>
<p>Not usually set by the user. </p>
</td></tr> </table>


<h3>Details</h3>

<p> Since the linear.bayes <code>object</code> is based on a moment
matrix, some information is lost thsat must be reconstructed or
assumed. The intercept and possibly the coefficients for control
variates are aong these. Also, when the call to <code>linear.bayes</code>
supplied the moment matrix rather than formulae with which to create
one, then it is unclear what variable was used as the regressand and
hence which variable to use in ofrming residuals. So, in that case,
<code>residuals</code> will report an error </p>


<h3>Value</h3>

<p>A vector of predicted values or residuals
</p>


<h3>Author(s)</h3>

<p> Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+linear.bayes">linear.bayes</a></code></p>

<hr>
<h2 id='residuals.bqtl'> Residuals from QTL models</h2><span id='topic+residuals.bqtl'></span>

<h3>Description</h3>

<p>The phenotype data, estimated coefficients, and expected locus values
are used to find fitted values for the QTL model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bqtl'
residuals(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.bqtl_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+bqtl">bqtl</a></code></p>
</td></tr>
<tr><td><code id="residuals.bqtl_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr></table>


<h3>Details</h3>

<p>The estimated coefficients for a specific QTL model fit are used along
with the  expected locus values (conditionally on the marker values)
are used to find fitted values for the QTL model; these are subtracted
from the origianl trait values to get residuals. This is <em>not</em> the
only  way in which such fits could be obtained; one could condition the
expected marker values on <em>both</em> the trait value and the marker
values. One could also define fitted values for specific genotype
combinations, e.g. for a backcross with k animals and a two gene model
4 fitted values could be determined for each animal leading to 2*2*k
residuals. 
</p>


<h3>Value</h3>

<p> A vector with as many elements trait values used in the original
fitted model.
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+bqtl">bqtl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(little.ana.bc)

fit.pheno &lt;- bqtl(bc.phenotype~locus(15)+locus(42),little.ana.bc)

summary(residuals(fit.pheno))

plot( fitted( fit.pheno ), residuals( fit.pheno) )



</code></pre>

<hr>
<h2 id='summary.adj'>Summarize Laplace approximations </h2><span id='topic+summary.adj'></span>

<h3>Description</h3>

<p> The linear approximations of <code>swap</code> are much improved
by the use a Laplace approximations for loci that are not
markers. This function combines the results of a call like
<code>bqtl(y~configs(swap.obj),...)</code> with the data in
<code>swap.obj</code> to provide improved posteriors, et cetera</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'adj'
summary(object, n.loc, coef.znames, mode.names=c("add",
"dom"), imp.denom=NULL, swap.obj=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.adj_+3A_object">object</code></td>
<td>
<p>Typically, this is the result of a call like
<code>bqtl(y~configs(swap.obj),...)</code>  </p>
</td></tr>
<tr><td><code id="summary.adj_+3A_n.loc">n.loc</code></td>
<td>
<p>The number of genes in this model </p>
</td></tr>
<tr><td><code id="summary.adj_+3A_coef.znames">coef.znames</code></td>
<td>
<p><code>map.names</code> for the sample space </p>
</td></tr>
<tr><td><code id="summary.adj_+3A_mode.names">mode.names</code></td>
<td>
<p><code>NULL</code> except for &quot;F2&quot;, in which case it is
uusally c(&quot;add&quot;,&quot;dom&quot;) </p>
</td></tr>
<tr><td><code id="summary.adj_+3A_imp.denom">imp.denom</code></td>
<td>
<p>Optional, and only used when some sampling scheme
other than the default MCMC generates <code>object</code> </p>
</td></tr>
<tr><td><code id="summary.adj_+3A_swap.obj">swap.obj</code></td>
<td>
<p>The result of a call to <code>swap</code> </p>
</td></tr>
<tr><td><code id="summary.adj_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are a lot of details. This sections nneds to be revised to
reflect them.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>adj</code></td>
<td>
<p>This multiplier adjusts the posterior odds for k vs k-1
gene models </p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>An estimate of the variance of <code>adj</code></p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>Posterior means of coefficients</p>
</td></tr>
<tr><td><code>loc</code></td>
<td>
<p>Marginal Posterior for location for k gene model</p>
</td></tr>
<tr><td><code>hk.ratio.mean</code></td>
<td>
<p>argh! I need to look this up</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>References</h3>

<p>Berry C.C. (1998) Computationally Efficient Bayesian QTL Mapping in
Experimental Crosses. <em>ASA Proceedings of the Biometrics
Section,</em> 164-169. 
</p>

<hr>
<h2 id='summary.bqtl'>Summarize bqtl object </h2><span id='topic+summary.bqtl'></span>

<h3>Description</h3>

<p>Extract coefficients (and related stats), loglikelihood, and residual
standard error of the trait.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bqtl'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bqtl_+3A_object">object</code></td>
<td>
<p>The result of <code>link{bqtl}</code> </p>
</td></tr>
<tr><td><code id="summary.bqtl_+3A_...">...</code></td>
<td>
<p> Currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> Either a vector of regression coefficents, or if
object was created via <code>bqtl(...,return.hess=TRUE)</code>, then
a matrix with coefficients, standard errors, t-statistics, and p-values</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>the loglikelihood or log posterior</p>
</td></tr>
<tr><td><code>std.res</code></td>
<td>
<p> The residual standard deviation of the trait</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p> The counts of all observations, the number omitted, and the
number used in the fit</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(little.ana.bc)
fit &lt;- bqtl( bc.phenotype~locus(4)*locus(45), little.ana.bc,
return.hess=TRUE )
summary(fit)

</code></pre>

<hr>
<h2 id='summary.map.frame'> Summary methods for basic data objects </h2><span id='topic+summary.map.frame'></span><span id='topic+summary.analysis.object'></span>

<h3>Description</h3>

<p>Provide a simple report on the data structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map.frame'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.map.frame_+3A_object">object</code></td>
<td>
<p> A <code>map.frame</code> or <code>analysis.object</code> </p>
</td></tr>
<tr><td><code id="summary.map.frame_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>

<hr>
<h2 id='summary.swap'>Summarize Gibbs samples for a k-gene model </h2><span id='topic+summary.swap'></span>

<h3>Description</h3>

<p>Calculate marginal posteriors for location, posterior means for
coefficients, and the Bayes Factor for k vs k-1 genes  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'swap'
summary(object, method=NULL, ncoef=length(object$alt.coef), nloc=object$nloc,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.swap_+3A_object">object</code></td>
<td>
<p> The result of <code><a href="#topic+swap">swap</a></code> </p>
</td></tr>
<tr><td><code id="summary.swap_+3A_method">method</code></td>
<td>
<p>Optional. One of the supported methods, see <code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code> </p>
</td></tr>
<tr><td><code id="summary.swap_+3A_ncoef">ncoef</code></td>
<td>
<p>Optional. The number of coefficients in the class of
models. Typically, <code>2*nloc</code> for <code>method=="F2"</code> and
<code>nloc</code> for all other methods  </p>
</td></tr>
<tr><td><code id="summary.swap_+3A_nloc">nloc</code></td>
<td>
<p>Optional. The number of loci in the sample space. </p>
</td></tr>
<tr><td><code id="summary.swap_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>loc.posterior</code></td>
<td>
<p>A vector of (marginal) posterior odds for each
locus compared to a no gene model</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>Posterior means of coefficients.</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>A list with components <code>mean</code>, an estimate of the
Bayes Factor for k versus k-1 gene models, and <code>var</code>, an estimate
of its variance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>

<hr>
<h2 id='swap'> MCMC sampling of multigene models</h2><span id='topic+swap'></span>

<h3>Description</h3>

<p>Given a k-gene model as a starting point, one gene is deleted and
another is sampled in its place. This is done using an approximation to
the posterior. Then another gene is deleted and another sampled,...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap(varcov, invars, rparm, nreps, ana.obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_+3A_varcov">varcov</code></td>
<td>
<p>The result of <code><a href="#topic+make.varcov">make.varcov</a></code> </p>
</td></tr>
<tr><td><code id="swap_+3A_invars">invars</code></td>
<td>
<p> Vector of
numerical indexes of <code>ana.obj$reg.names</code> telling which
variables to start in the model. The first of these is immediately
removed, so it is merely a placeholder.  The number of genes in the
model is therefore <code>k &lt;- length(invars)</code> (except when
<code>ana.obj$method=="F2"</code> when it is <code>k &lt;-
      length(unique(col(ana.obj$reg.names)[invars]))</code>)  </p>
</td></tr>
<tr><td><code id="swap_+3A_rparm">rparm</code></td>
<td>
<p>Scalar or vector with <code>nrow(varcov$var.x)</code> elements;
the 'ridge' parameters for the independent variables - larger values
imply more shrinkage or a more concentrated prior for the regresion
coefficients.  </p>
</td></tr>
<tr><td><code id="swap_+3A_nreps">nreps</code></td>
<td>
<p> How many cycles (of <code>k</code> samples each) to perform.  </p>
</td></tr>
<tr><td><code id="swap_+3A_ana.obj">ana.obj</code></td>
<td>
<p> An <code>analysis.object</code> &mdash; see <a href="#topic+make.analysis.obj">make.analysis.obj</a></p>
</td></tr>
<tr><td><code id="swap_+3A_...">...</code></td>
<td>
<p>Additional arguments override the default choices of
candidate loci (<code>locs</code>), prior for locus (<code>locs.prior</code>),
or method specified by <code>ana.obj</code>. Also, the default prior for
model (<code>combo.prior</code>) when <code>ana.obj$method=="F2" can be
      overridden. See <a href="#topic+swapbc1">swapbc1</a> and <a href="#topic+swapf2">swapf2</a> for details. </code>
</p>
</td></tr></table>


<h3>Details</h3>

<p>An MCMC sampler for loci using the object of <code> make.varcov </code> is
executed.  This sampler uses the exact posterior probability under the
assumed correctness of the regression model using expected genotypes
given marker values.  This amounts to linearizing the likelihood with
respect to the  (possibly unknown) locus states.  For models where the
loci are fully informative markers this is the true posterior.
</p>
<p>The chain is implemented as follows: given a set of regressor
variables to start, one variable is removed, all regressor
variables not in the model are examined to determine the effect of each
on the posterior.  One variable is sampled.  The process is repeated until
each variable has been removed and a new one sampled in its place
(possibly the same variable that was removed is sampled).  And this whole
cycle is repeated <code>nreps</code> times.  
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>config</code></td>
<td>
<p> A k by k by nreps array (or, for
<code>ana.obj$method=="F2"</code>, a 2k by k by nreps array) of the
locations (variables) sampled in each iteration.</p>
</td></tr> 
<tr><td><code>posteriors</code></td>
<td>
<p> A vector of length <code>k*nreps</code> with the
posteriors of the models.</p>
</td></tr> 
<tr><td><code>coefs</code></td>
<td>
<p>A k by k matrix of the regression coefficients(or, for
<code>ana.obj$method=="F2"</code>, a 2k by nreps matrix).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call to <code>swap</code></p>
</td></tr>
<tr><td><code>cond</code></td>
<td>
<p>The <code>k*nreps</code> posterior probabilities of the k-1 gene
models.</p>
</td></tr>
<tr><td><code>marg</code></td>
<td>
<p>The <code>k*nreps</code> marginal posteriors for all k gene
models that could be formed  using  the current k-1 gene model</p>
</td></tr>
<tr><td><code>alt.marginal</code></td>
<td>
<p>A vector with <code>length(locs)</code> (or <code>2*length(locs)</code>) elements.  At
each step, the posterior associated with  each candidate locus is
added to an element of this vector.  After all steps are finished,
the result is normalized to sum to one.  This turns out to be a
stable estimate of the marginal posterior. </p>
</td></tr>
<tr><td><code>alt.coef</code></td>
<td>
<p>A vector with <code>length(locs)</code> (or
<code>2*length(locs)</code>) elements.  At each step, the product of each
posterior times the coefficient(s) associated with a candidate locus
is added to an element of this 
vector.  After all steps are finished, the result is normalized by
the total marginal posterior.  This turns out to be a stable
estimate of the marginal (over all models) posterior mean of the
regression coefficients. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>References</h3>

<p>Berry C.C. (1998) Computationally Efficient Bayesian QTL Mapping in
Experimental Crosses. <em>ASA Proceedings of the Biometrics
Section,</em> 164-169. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( little.ana.bc )
little.vc &lt;- varcov( bc.phenotype~locus(all), little.ana.bc)
little.4 &lt;- swap( little.vc, c(1,15,55,75), rparm=1, 50, little.ana.bc )
little.4.smry &lt;- summary( little.4 )
print(c("Bayes Factor (3 vs 4)"=little.4.smry$ratio$mean))
par(mfrow=c(3,2))
plot( little.ana.bc, little.4.smry$loc.posterior, type="h",
 ylab="E(genes)" )
rm(little.4,little.vc,little.ana.bc)
</code></pre>

<hr>
<h2 id='swapbc1'>
Sample BC1 or Recombinant Inbred loci  via approximate posterior.
</h2><span id='topic+swapbc1'></span>

<h3>Description</h3>

<p>An MCMC sampler for loci using precomputed dispersion matrices,
various priors, and a pre-selected set of variables.  For use with BC1
(backcross) designs and recombinant inbred lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swapbc1(varcov, invars, rparm, nreps, ana.obj, locs=NULL,
locs.prior=NULL, tol=1e-10 )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swapbc1_+3A_varcov">varcov</code></td>
<td>
<p> The result of <code> <a href="#topic+make.varcov">make.varcov</a></code></p>
</td></tr>
<tr><td><code id="swapbc1_+3A_rparm">rparm</code></td>
<td>
<p> Scalar or vector with <code>nrow(varcov$var.x)</code> elements;
the 'ridge' parameters for the independent variables - larger values
imply more shrinkage or a more concentrated prior for the regresion
coefficients. </p>
</td></tr>
<tr><td><code id="swapbc1_+3A_nreps">nreps</code></td>
<td>
<p>How many cycles of MCMC to perform</p>
</td></tr>
<tr><td><code id="swapbc1_+3A_ana.obj">ana.obj</code></td>
<td>
<p>A object produced by <code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code></p>
</td></tr>
<tr><td><code id="swapbc1_+3A_invars">invars</code></td>
<td>

<p>Which variables to start in the model. The first of these is
immediately removed, so it is merely a placeholder.  The number of
genes in the model is therefore <code>k &lt;- length(invars)</code></p>
</td></tr>
<tr><td><code id="swapbc1_+3A_locs">locs</code></td>
<td>

<p>The columns of <code>varcov\$var.x</code> to use.  The default uses all of
them.</p>
</td></tr> 
<tr><td><code id="swapbc1_+3A_locs.prior">locs.prior</code></td>
<td>

<p>The prior mass to associate with each variable.  Typically, these sum
to one, but sometimes they might each be set to one (as in computing
lod scores). </p>
</td></tr>
<tr><td><code id="swapbc1_+3A_tol">tol</code></td>
<td>
<p>Used in forming QR decomposition.  Let it be.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An MCMC sampler for loci using the object of <code> make.varcov </code> is
executed.  This sampler uses the exact posterior probability under the
assumed correctness of the regression model using expected genotypes
given marker values.  This amounts to linearizing the likelihood with
respect to the  (possibly unknown) locus states.  For models where the
loci are fully informative markers this is the true posterior.
</p>
<p>The chain is implemented as follows: given a set of regressor
variables to start, one variable is removed, all regressor
variables not in the model are examined to determine the effect of each
on the posterior.  One variable is sampled.  The process is repeated until
each variable has been removed and a new one sampled in its place
(possibly the same variable that was removed is sampled).  And this whole
cycle is repeated <code>nreps</code> times.  
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>config</code></td>
<td>
<p> A k by k by nreps array of the locations sampled in
each iteration. </p>
</td></tr>
<tr><td><code>posteriors</code></td>
<td>
<p> A vector of length <code>k*nreps</code> with the
posteriors of the models.</p>
</td></tr> 
<tr><td><code>coefs</code></td>
<td>
<p>A k by k matrix of the regression coefficients.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call to <code>swapbc1</code></p>
</td></tr>
<tr><td><code>cond</code></td>
<td>
<p>The <code>k*nreps</code> posterior probabilities of the k-1 gene
models.</p>
</td></tr>
<tr><td><code>marg</code></td>
<td>
<p>The <code>k*nreps</code> marginal posteriors for all k gene
models that could be formed  using  the current k-1 gene model</p>
</td></tr>
<tr><td><code>alt.marginal</code></td>
<td>
<p>A vector with <code>length(locs)</code> elements.  At
each step, the posterior associated with  each candidate locus is
added to an element of this vector.  After all steps are finished,
the result is normalized to sum to one.  This turns out to be an
exceedingly stable estimate of the marginal posterior. </p>
</td></tr>
<tr><td><code>alt.coef</code></td>
<td>
<p>A vector with <code>length(locs)</code> elements.  At
each step, the product of each posterior times the coefficient
associated with a candidate locus is 
added to an element of this vector.  After all steps are finished,
the result is normalized by the total marginal posterior.  This turns
out to be an exceedingly stable estimate of the marginal (over all
models) posterior mean of the regression coefficients. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>References</h3>

<p>Berry C.C. (1998) Computationally Efficient Bayesian QTL Mapping in
Experimental Crosses. <em>ASA Proceedings of the Biometrics
Section,</em> 164-169.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+swapf2">swapf2</a></code>
</p>

<hr>
<h2 id='swapf2'>
Sample F2 loci  via approximate posterior 
</h2><span id='topic+swapf2'></span>

<h3>Description</h3>

<p>An MCMC sampler for loci using precomputed dispersion matrices,
various priors, and a pre-selected set of variables. For use with F2
intercross design.
</p>
<p>Using precomputed dispersion matrices, various priors, and a pre-selected set of variables, one locus is removed, all other loci are examined to determine the effect of each on the posterior. One locus is sampled. The process is repeated until each locus has been removed and a new one sampled in its place (possibly the same one that was removed is sampled). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swapf2(varcov, invars, rparm, nreps, ana.obj, locs, 
    locs.prior, combo.prior, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swapf2_+3A_varcov">varcov</code></td>
<td>
<p> The result of <code> make.varcov </code>. The columns of
<code>varcov$var.x</code> must alternate 'additive' and 'dominance' terms.</p>
</td></tr>
<tr><td><code id="swapf2_+3A_rparm">rparm</code></td>
<td>

<p>The 'ridge' parameters for the independent variables - larger values
imply more shrinkage or a more concentrated prior for the regresion
coefficients. </p>
</td></tr>
<tr><td><code id="swapf2_+3A_nreps">nreps</code></td>
<td>
<p>How many cycles of MCMC to perform</p>
</td></tr>
<tr><td><code id="swapf2_+3A_ana.obj">ana.obj</code></td>
<td>
<p>A object produced by <code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code></p>
</td></tr>
<tr><td><code id="swapf2_+3A_invars">invars</code></td>
<td>
<p>A vector of variable indexes. This determines which
variables to start in the model. If both additive and 
dominance terms are to be used, they should occupy adjacent
locations in <code>invars</code>. The variable(s) associated with the
first locus is (are) immediately removed, serving only as
placeholder(s). If there are k loci associated with the variables,
then all subsequent models have k loci, although the nuimber of
variables may vary according to the selection of one or both of the
'additive' or 'dominance' terms.  </p>
</td></tr> 
<tr><td><code id="swapf2_+3A_locs">locs</code></td>
<td>

<p>The pairs of columns of <code>varcov$var.x</code> to use. The default
uses all of them.</p>
</td></tr>
<tr><td><code id="swapf2_+3A_locs.prior">locs.prior</code></td>
<td>
<p> Vector whose elements are 
the prior masses to associate with each locus. Typically, these sum
to one, but sometimes they might each be set to one (as in computing
lod scores). The default value sets them all to 1.0.
</p>
</td></tr>
<tr><td><code id="swapf2_+3A_combo.prior">combo.prior</code></td>
<td>

<p>The prior probability for each term or combination of terms for the
phenotypic effect at a locus. Typically, there will be three of
these - one for the 'additive' term (linear in number of alleles
from one parent strain), the 'dominance' term (quadratic in allele
number), or both terms. The default sets them all to 1/3.
</p>
</td></tr>
<tr><td><code id="swapf2_+3A_tol">tol</code></td>
<td>
<p>Used in forming QR decomposition. Let it be.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A call to <code>swapf2</code> is used to obtain the results. This function
is really just a wrapper. 
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>configs</code></td>
<td>
<p> A 2k by k by nreps array of indexes of variables sampled in
each of the nreps iterations. Models using less than 2k variables
<code>configs[,i,j]</code> will contain one or more zeroes in the last
position(s) </p>
</td></tr>
<tr><td><code>posteriors</code></td>
<td>
<p> A vector of length <code>k*nreps</code> with the
posteriors of the models sampled.</p>
</td></tr> 
<tr><td><code>coefs</code></td>
<td>
<p>A 2k by k by nreps matrix of the regression
coefficients. Models using less than 2k variables 
<code>configs[,i,j]</code> will contain one or more zeroes in the last
position(s) </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call to <code>swapf2</code></p>
</td></tr>
<tr><td><code>cond</code></td>
<td>
<p>The <code>k*nreps</code> posterior probabilities of the k-1 gene
models.</p>
</td></tr> 
<tr><td><code>marg</code></td>
<td>
<p>The <code>k*nreps</code> marginal posteriors for all k gene
models that could be formed using the current k-1 gene model)</p>
</td></tr>
<tr><td><code>alt.marginal</code></td>
<td>
<p>A vector with <code>length(locs)</code> elements. At
each step, the posterior associated with  each candidate locus is
added to an element of this vector. After all steps are finished,
the result is normalized to sum to one. This turns out to be an
exceedingly stable estimate of the relative marginal posterior. </p>
</td></tr>
<tr><td><code>alt.coef</code></td>
<td>
<p>A vector with <code>2*length(locs)</code> elements. At
each step, the product of each posterior times the coefficient
associated with a candidate variable is 
added to an element of this vector. After all steps are finished,
the result is normalized by the total marginal posterior. This turns
out to be an rather stable estimate of the marginal (over all
models) posterior mean of the regression coefficients. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>References</h3>

<p>Berry C.C. (1998) Computationally Efficient Bayesian QTL Mapping in
Experimental Crosses. <em>ASA Proceedings of the Biometrics
Section,</em> 164-169.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+swapbc1">swapbc1</a></code>
</p>

<hr>
<h2 id='twohk'> One and Two Gene Models Using Linearized Posterior </h2><span id='topic+twohk'></span>

<h3>Description</h3>

<p>Fits all one and two gene models (without interactions aka 'epistasis')
in an intercross, backcross, or recombinant inbred line. Uses a linear
approximation to the likelihood, i.e. the expected allele states are
used. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twohk(varcov, ana.obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twohk_+3A_varcov">varcov</code></td>
<td>
<p> An object produced by <code> <a href="#topic+make.varcov">make.varcov</a></code> </p>
</td></tr>
<tr><td><code id="twohk_+3A_ana.obj">ana.obj</code></td>
<td>
<p>An <code>analysis.object</code> &mdash; see <code>make.analysis.obj</code> </p>
</td></tr>
<tr><td><code id="twohk_+3A_...">...</code></td>
<td>
<p>Additional arguments override the default choices of
candidate loci (<code>locs</code>), prior for locus (<code>locs.prior</code>),
or method specified by <code>ana.obj</code>:
<code>locs</code> A vector indexing the loci to use.
<code>locs.prior</code> 
The prior mass to  associate with each locus. Typically, these sum
to one, but sometimes they might each be set to one (as in computing
lod scores). 
<code>combo.prior</code> Only valid for <code>ana.obj$method=="F2"</code>. 
The prior probability for each term or combination of terms for the
phenotypic effect at a locus. Typically, there will be three of
these - one for the 'additive' term (linear in number of alleles
from one parent strain), the 'dominance' term (quadratic in allele
number), or both terms. The default sets them all to 1/3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal posterior (integrating over regression parameters and
dispersion) is calculated for each one and two gene model under the
assumed correctness of the regression model using expected genotypes
given marker values. This amounts to linearizing the likelihood with
respect to the  (possibly unknown) locus states. For models where the
loci are fully informative markers this is the true posterior.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>loc.1</code></td>
<td>
<p>The marginal posterior for each one gene model relative to
a no gene model.  For
<code>twohkf2</code> this is a matrix of 3 columns; the first for models
with additive terms, the second for dominance terms, and the third
for both. The sum over all three columns yields the marginal
posterior for the locus.</p>
</td></tr>
<tr><td><code>loc.2</code></td>
<td>
<p>The marginal posterior for each locus &mdash; obtained by summing
over all two gene models that include that locus&mdash;  relative to
a no gene model. For
<code>twohkf2</code> this is a matrix of 3 columns; the first for models
with additive terms, the second for dominance terms, and the third for both. </p>
</td></tr>
<tr><td><code>coefs.1</code></td>
<td>
<p>The regression coefficients for the genetic effect for 
each locus. For <code>twohkf2</code>, this is a matrix with two rows; the
first is for the 'additive effect' and the second is for the
'dominance' effect.</p>
</td></tr>
<tr><td><code>coefs.2</code></td>
<td>
<p>The marginal posterior mean of regression coefficients
for the genetic effect for each locus - obtained by averaging over
all two gene models that include that locus according to the
posterior masses. For <code>twohkf2</code>, this is a matrix with two rows; the
first is for the 'additive effect' and the second is for the
'dominance' effect.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>References</h3>

<p>Haley C.S. and Knott S.A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking
markers. <em>Heredity</em> <b>69</b>,315-324. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(little.ana.bc)
little.vc&lt;-make.varcov(little.ana.bc$data[,little.ana.bc$reg.names],
  little.ana.bc$data$bc.phenotype)
little.2&lt;- twohk(little.vc,little.ana.bc,rparm=1)
print( c(odds.1=sum(little.2$loc.1),odds.2=sum(little.2$loc.2)) )
par(mfrow=c(3,2))
little.pe &lt;- 2 * little.2$loc.2 / sum(little.2$loc.2)   #locus-wise posterior expectation
plot(little.ana.bc,little.pe,type="h",ylab="E(genes")
rm(little.2,little.vc,little.pe,little.ana.bc)
</code></pre>

<hr>
<h2 id='twohkbc1'> One and Two Gene Models Using Linearized Posterior</h2><span id='topic+twohkbc1'></span><span id='topic+twohkf2'></span>

<h3>Description</h3>

<p>Fits all one and two gene models (without interactions aka
'epistasis') in an intercross, backcross, or recombinant inbred
line. Uses a linear 
approximation to the likelihood, i.e. the expected allele states are
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twohkbc1(varcov, ana.obj, rparm = 0, locs = NULL, locs.prior =
                 NULL)
twohkf2(varcov, ana.obj, rparm, locs, locs.prior,
combo.prior) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twohkbc1_+3A_varcov">varcov</code></td>
<td>
<p> An object produced by <code> <a href="#topic+make.varcov">make.varcov</a></code> </p>
</td></tr>
<tr><td><code id="twohkbc1_+3A_ana.obj">ana.obj</code></td>
<td>
<p>An object produced by <code> <a href="#topic+make.analysis.obj">make.analysis.obj</a></code></p>
</td></tr>
<tr><td><code id="twohkbc1_+3A_rparm">rparm</code></td>
<td>
<p> The 'ridge' parameters for the independent variables -
larger values imply more shrinkage or a more concentrated prior for
the regresion coefficients. </p>
</td></tr> 
<tr><td><code id="twohkbc1_+3A_locs">locs</code></td>
<td>
<p> The columns (or pairs of columns for <code>twohkf2</code>) of
<code>varcov\$var.x</code> to use. The default uses all of them.</p>
</td></tr>
<tr><td><code id="twohkbc1_+3A_locs.prior">locs.prior</code></td>
<td>
 
<p>The prior mass to  associate with each locus. Typically, these sum
to one, but sometimes they might each be set to one (as in computing
lod scores). </p>
</td></tr>
<tr><td><code id="twohkbc1_+3A_combo.prior">combo.prior</code></td>
<td>
<p>Only valid for <code>twohkf2</code>. 
The prior probability for each term or combination of terms for the
phenotypic effect at a locus. Typically, there will be three of
these - one for the 'additive' term (linear in number of alleles
from one parent strain), the 'dominance' term (quadratic in allele
number), or both terms. The default sets them all to 1/3.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal posterior (integrating over regression parameters and
dispersion) is calculated for each one and two gene model under the
assumed correctness of the regression model using expected genotypes
given marker values. This amounts to linearizing the likelihood with
respect to the  (possibly unknown) locus states. For models where the
loci are fully informative markers this is the true posterior.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>loc.1</code></td>
<td>
<p>The marginal posterior for each one gene model.  For
<code>twohkf2</code> this is a matrix of 3 columns; the first for models
with additive terms, the second for dominance terms, and the third
for both. The sum over all three columns yields the marginal
posterior for the locus.</p>
</td></tr>
<tr><td><code>loc.2</code></td>
<td>
<p>The marginal posterior for each locus - obtained by summing
over all two gene models that include that locus. For
<code>twohkf2</code> this is a matrix of 3 columns; the first for models
with additive terms, the second for dominance terms, and the third for both. </p>
</td></tr>
<tr><td><code>coefs.1</code></td>
<td>
<p>The regression coefficients for the genetic effect for 
each locus. For <code>twohkf2</code>, this is a matrix with two rows; the
first is for the 'additive effect' and the second is for the
'dominance' effect.</p>
</td></tr>
<tr><td><code>coefs.2</code></td>
<td>
<p>The marginal posterior mean of regression coefficients
for the genetic effect for each locus - obtained by averaging over
all two gene models that include that locus according to the
posterior masses. For <code>twohkf2</code>, this is a matrix with two rows; the
first is for the 'additive effect' and the second is for the
'dominance' effect.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>References</h3>

<p>Haley C.S. and Knott S.A. (1992) A simple regression method for mapping
quantitative trait loci in line crosses using flanking
markers. <em>Heredity</em> <b>69</b>,315-324. </p>

<hr>
<h2 id='varcov'> Create moment matrices</h2><span id='topic+varcov'></span>

<h3>Description</h3>

<p>Create a moment matrix of the marker variables and of the regressors by
the phenotype variable.  For use in regression modelling on the markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcov(x, ana.obj, partial=NULL, scope,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcov_+3A_x">x</code></td>
<td>
<p>A formula to specify the dependent and independent variables
to be used in subsequent calculations e.g <code>trait ~ locus(.) </code></p>
</td></tr>
<tr><td><code id="varcov_+3A_ana.obj">ana.obj</code></td>
<td>
<p>An <code>analysis.object</code>,
see<code><a href="#topic+make.analysis.obj">make.analysis.obj</a></code>  </p>
</td></tr>
<tr><td><code id="varcov_+3A_partial">partial</code></td>
<td>
<p>A formula whose right hand side specifies variables to
be treated as covariates. </p>
</td></tr>
<tr><td><code id="varcov_+3A_scope">scope</code></td>
<td>
<p> Usually not explicitly used. Optional vector of variable
names. </p>
</td></tr>
<tr><td><code id="varcov_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a wrapper for <code><a href="#topic+make.varcov">make.varcov</a></code>.</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>var.x</code></td>
<td>
<p>Moment matrix of the marker regressor variables</p>
</td></tr>
<tr><td><code>cov.xy</code></td>
<td>
<p>Moment matrix of the marker regressor variables versus
the phenotype variable</p>
</td></tr>
<tr><td><code>var.y</code></td>
<td>
<p>The Second central moment of the phenotype variable</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom, when no variables are specified in
<code>partial</code> it is <code> sum(subset==TRUE) - 1</code>
</p>
</td></tr></table>


<h3>Note</h3>

<p> It is generally NOT a good idea to do regressions on
ill-conditioned designs using the moment matrices.  The
excuse for doing so here is twofold.  First, calculations using this
method are used to perform importance sampling, so minor numerical
inaccuracies in computing the probabilites used in sampling get
straightened out by the importance weights.  Second, it will typically
be the case that a prior is set on the regression coefficients and
this results in a positive constant (aka a 'ridge' parameter) being
added to diagonal of <code>varcov()$var.x</code> and this reduces the
ill-conditioning.  Of course the rational for using the method is to
speed the sampling, and it is very effective at doing so.</p>


<h3>Author(s)</h3>

<p>Charles C. Berry <a href="mailto:cberry@ucsd.edu">cberry@ucsd.edu</a> </p>


<h3>See Also</h3>

<p>The examples in <code><a href="#topic+swap">swap</a></code> and <code><a href="#topic+twohk">twohk</a></code>.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
