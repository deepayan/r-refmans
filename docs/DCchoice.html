<!DOCTYPE html><html lang="en"><head><title>Help for package DCchoice</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DCchoice}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DCchoice-package'><p>DCchoice: a package for analyzing dichotomous choice contingent valuation data</p></a></li>
<li><a href='#AP'><p>Albemarle-Pamlico sounds CVM data</p></a></li>
<li><a href='#bootCI'><p>Calculating confidence intervals for WTP using a nonparametric bootstrap method</p></a></li>
<li><a href='#Carson'><p>Exxon Valdez Oil Spill CVM data</p></a></li>
<li><a href='#ct2df'>
<p>Convert a data frame in contingency-table format into a simple data frame of individual observations</p></a></li>
<li><a href='#dbchoice'><p>Parametric approach to analyze double-bounded dichotomous choice contingent valuation data</p></a></li>
<li><a href='#dccvResponse'>
<p>Generate artificial responses to dichotomous choice CV questions</p></a></li>
<li><a href='#KR'><p>Kristr\&quot;om's single-bounded dichotomous choice CVM data</p></a></li>
<li><a href='#krCI'><p>Calculating confidence intervals for WTP using a parametric simulation</p></a></li>
<li><a href='#kristrom'>
<p>The Kristr\&quot;om's nonparametric approach to analyze single-bounded dichotomous choice contingent valuation data</p></a></li>
<li><a href='#oohbchoice'><p>Parametric approach to analyze one-and-one-half-bound dichotomous choice contingent valuation data</p></a></li>
<li><a href='#oohbsyn'><p>Synthetic data set for oohbchoice()</p></a></li>
<li><a href='#plot.dbchoice'>
<p>Plotting dbchoice objects</p></a></li>
<li><a href='#plot.kristrom'>
<p>Plotting <code>kristrom</code> objects</p></a></li>
<li><a href='#plot.sbchoice'>
<p>Plotting sbchoice objects</p></a></li>
<li><a href='#plot.turnbull'>
<p>Plotting <code>turnbull</code> objects</p></a></li>
<li><a href='#predict.dbchoice'>
<p>Predicting model for dbchoice</p></a></li>
<li><a href='#predict.sbchoice'>
<p>Predicting model for sbchoice</p></a></li>
<li><a href='#sbchoice'><p>Parametric approach to analyze single-bounded dichotomous choice contingent valuation data</p></a></li>
<li><a href='#spike-models'><p>Parametric approach to analyze dichotomous choice contingent valuation data on the basis of a simple spike model</p></a></li>
<li><a href='#summary.dbchoice'>
<p>Summarizing <code>dbchoice</code> estimation</p></a></li>
<li><a href='#summary.kristrom'>
<p>Summarizing the Kristr\&quot;om's nonparametric estimation of WTP</p></a></li>
<li><a href='#summary.sbchoice'>
<p>Summarizing <code>sbchoice</code> estimation</p></a></li>
<li><a href='#summary.turnbull'>
<p>Summarizing the Kaplan-Meier-Turnbull nonparametric estimation of WTP</p></a></li>
<li><a href='#turnbull'><p>The Kaplan-Meier-Turnbull nonparametric approach to analyze dichotomous choice contingent valuation data</p></a></li>
<li><a href='#update.dbchoice'>
<p>Updating and refitting model for dbchoice</p></a></li>
<li><a href='#update.sbchoice'>
<p>Updating and refitting model for sbchoice</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyzing Dichotomous Choice Contingent Valuation Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for analyzing dichotomous choice contingent 
   valuation (CV) data. It provides functions for estimating parametric and 
   nonparametric models for single-, one-and-one-half-, and double-bounded 
   CV data. For details, see Aizaki et al. (2022) &lt;<a href="https://doi.org/10.1007%2Fs42081-022-00171-1">doi:10.1007/s42081-022-00171-1</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MASS, interval, Formula</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Ecdat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.agr.hokudai.ac.jp/spmur/">http://www.agr.hokudai.ac.jp/spmur/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hideo Aizaki &lt;azk-r@spa.nifty.com&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Tomoaki Nakatani [aut, cph] (original developer),
  Hideo Aizaki [aut, cre],
  Kazuo Sato [ctb] (theoretical part of the manual)</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-10 06:03:52 UTC; rpkgdev</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-10 23:40:50 UTC</td>
</tr>
</table>
<hr>
<h2 id='DCchoice-package'>DCchoice: a package for analyzing dichotomous choice contingent valuation data</h2><span id='topic+DCchoice-package'></span><span id='topic+DCchoice'></span>

<h3>Description</h3>

<p>The package provides functions for analyzing single-, one-and-one-half-, and double-bounded dichotomous 
choice contingent valuation (CV) data
</p>


<h3>Details</h3>

<p>This package provides functions for analyzing single-, one-and-one-half-, and double-bounded dichotomous 
choice contingent valuation (CV) data.
</p>
<p>In the single-bounded dichotomous choice (SBDC) CV that was first proposed by Bishop and Heberlein (1979) 
respondents are requested to answer a question like the following:
</p>
<p><strong>If the environmental policy burdens you with USD <code class="reqn">X</code> annually, would you agree or disagree to it?</strong><br />
</p>
<p>This format, respondents only states &quot;yes (I agree)&quot; or &quot;no (I disagree),&quot; meaning whether their 
willingness to pay (WTP) is greater or lower than the bid (USD <code class="reqn">X</code>) they are offered.
</p>
<p>The double-bounded dichotomous choice (DBDC) CV was proposed by Hanemann (1985) 
and Carson (1985) to improve the efficiency of SBDC-CV. 
In the CV format, respondents are requested to answer the second (follow-up) question 
just after they answer the SBDC-CV style question 
(the first/initial question). An example of DBDC-CV 
questions is as follows (<code class="reqn">Xl &lt; X &lt; Xh</code>):
</p>
<p>First question<br />
<strong>If the environmental policy burdens you with USD <code class="reqn">X</code> annually, would you agree or disagree to it?</strong>
</p>
<p>Second question for the respondents who agree to the policy in the first question<br />
<strong>If the amount of tax is USD <code class="reqn">Xh</code>, would you agree or disagree to it?</strong>
</p>
<p>Second question for the respondents who disagree to the policy in the first question<br />
<strong>If the amount of tax is USD <code class="reqn">Xl</code>, would you agree or disagree to it?</strong>
</p>
<p>In the DBDC-CV question, there are four possible response 
outcomes: (yes, yes); (yes, no); (no, yes); and (no, no). If the respondent <code class="reqn">i</code>'s answer 
is (yes, yes), the analyst can tell <code class="reqn">WTPi &gt; Xh</code> (<code class="reqn">WTPi</code> is the WTP of the 
respondent <code class="reqn">i</code>). Similarly, (yes, no) means <code class="reqn">X &lt; WTPi &lt; Xh</code>, (no, yes) means 
<code class="reqn">Xl &lt; WTPi &lt; X</code>, and (no, no) means <code class="reqn">WTPi &lt;Xl</code>.
</p>
<p>One-and-one-half-bound dichotomous choice (OOHBDC) CV, which was developed by Cooper et al. (2002), 
is an intermediate CV format between SBDC-CV format and DBDC-CV format. 
</p>
<p>In the OOHBDC-CV survey, after answering the first SBDC-CV style question (the first stage), 
only respondents who satisfy certain conditions are requested to answer an additional 
SBDC-CV style question (the second stage). Details in the OOHBDC-CV survey are as follows: 
</p>
<p>Step 1) A list of bid ranges [BLj, BHj] (j = 1, 2, ..., J), where BLj &lt; BHj, 
are decided: i.e., [BL1, BH1], [BL2, BH2], ..., and [BLJ, BHJ]. 
</p>
<p>Step 2) One of the bid ranges is randomly presented to respondents (e.g., a bid range of [BL3, BH3] for j = 3).
</p>
<p>Step 3) One of the two bids presented to the respondents is selected randomly 
(i.e., BL3 or BH3 in the case of step 2 example) and then the respondents are asked 
whether they would be willing to pay the amount of the bid selected (the first stage).
</p>
<p>Step 4) The respondents are asked to answer the second stage if they satisfy either condition: 
(a) their answer in the first stage is &quot;yes&quot; when the lower bid is presented in the first stage, 
or (b) their answer in the first stage is &quot;no&quot; when the higher bid is presented in the first stage. 
</p>
<p>Therefore, there are six possible responses to the OOHBDC-CV survey: &quot;no&quot;, &quot;yes-no&quot;, and &quot;yes-yes&quot; 
when the lower bid is shown in the first stage; and &quot;yes&quot;, &quot;no-yes&quot;, and &quot;no-no&quot; when the higher bid is
shown in the first stage. Refer to Cooper et al. (2002) for detailed explanation of OOHBDC-CV, 
including the example CV questions.
</p>
<p>There are two ways of estimating WTP from the SBDC-, OOHBDC-, and DBDC-CV: 
parametric and nonparametric approaches. In this package, the functions <code><a href="#topic+sbchoice">sbchoice</a></code>, 
<code><a href="#topic+oohbchoice">oohbchoice</a></code>, and <code><a href="#topic+dbchoice">dbchoice</a></code>, which are based on the utility difference 
approach (Hanemann, 1984), are developed for the parametric approach to SBDC, OOHBDC, and DBDC data, 
respectively. 
</p>
<p>Confidence intervals for the estimates of WTPs are constructed by two methods. 
These are the Krinsky and Robb (1986, 1990)'s method and the bootstrap one. 
The former is implemented by  <code><a href="#topic+krCI">krCI</a></code> while the latter by <code><a href="#topic+bootCI">bootCI</a></code>. 
</p>
<p>Both of the methods rely on simulation techniques with different settings. Usually, 
a bootstrap method takes much longer time than the Krinsky and Robb's method does. 
It has been pointed out that each method has both advantages and disadvantages, see, 
for instance, the discussions in Hole (2007) and the references therein. 
</p>
<p>Functions for nonparametric approaches are also included in the package. <code><a href="#topic+kristrom">kristrom</a></code> 
(Kristrom, 1990) and <code><a href="#topic+turnbull.sb">turnbull.sb</a></code> (Carson and Steinberg, 1990) are designed for 
analyses for SBDC data, whereas <code><a href="#topic+turnbull.oohb">turnbull.oohb</a></code> and <code><a href="#topic+turnbull.db">turnbull.db</a></code> 
(Carson and Hanemann, 2005) for OOHBDC and DBDC ones, respectively.
</p>


<h3>Acknowledgments</h3>

<p>This work was supported by JSPS KAKENHI Grant Number JP20K06251.
</p>


<h3>Note</h3>

<p><span class="pkg">DCchoice</span> depends on <span class="pkg">interval</span> (Fay and Shaw, 2010) package. 
It further depends on several packages, among which <span class="pkg">Icens</span> 
(Gentleman and Vandal, 2011) package may not be installed by the GUI Package Installer 
accessible from the menu bar (Windows and Mac OS) 
because it is available only from <a href="http://bioconductor.org/">Bioconductor</a>. 
</p>
<p>To install <span class="pkg">DCchoice</span> and other dependent packages simultaneously, use the 
<code><a href="utils.html#topic+install.packages">install.packages</a></code> function instead. See the <b>Examples</b> section for the 
code. 
</p>


<h3>References</h3>

<p>Aizaki H, Nakatani T, Sato K (2014).
<em>Stated Preference Methods Using R.</em>
CRC Press, Boca Raton FL.
</p>
<p>Aizaki H, Nakatani T, Sato K, Fogarty J (2022).
&ldquo;R package DCchoice for dichotomous choice contingent valuation: a
contribution to open scientific software and its impact&rdquo;
<em>Japanese Journal of Statistics and Data Science</em>, <b>5</b>, 871&ndash;884.
<a href="https://link.springer.com/article/10.1007/s42081-022-00171-1">https://link.springer.com/article/10.1007/s42081-022-00171-1</a>.
</p>
<p>Bishop RC, Heberlein TA (1979).
&ldquo;Measuring Values of Extra-Market Goods: Are Indirect
Measures Biased?&rdquo;
<em>American Journal of Agricultural Economics</em>, <b>61</b>(5),
926&ndash;930.
</p>
<p>Carson RT (1985).
&ldquo;Three Essays on Contingent Valuation&rdquo;.
Dissertation, University of California Berkeley.
</p>
<p>Carson RT, Hanemann WM (2005).
&ldquo;Contingent Valuation.&rdquo;
in KG M\&quot;aler, JR Vincent (eds.), <em>Handbook of Environmental Economics</em>. 
Elsevier, New York.
</p>
<p>Carson RT, Steinberg D (1990).
&ldquo;Experimental Design for Discrete Choice Voter Preference Surveys.&rdquo;
in <em>1989 Proceeding of the Survey Methodology Section of the
American Statistical Association</em>, 821&ndash;822.
</p>
<p>Cooper JC, Hanemann M, Signorello G (2002).
&ldquo;One-and-one-half-bound dichotomous choice contingent valuation&rdquo;,
<em>The Review of Economics and Statistics</em>,
<b>84</b>, 742&ndash;750.
</p>
<p>Croissant Y (2011).
<em><span class="pkg">Ecdat</span>: Data Sets for Econometrics,</em> 
<span class="rlang"><b>R</b></span> package version 0.1-6.1, 
<a href="https://CRAN.R-project.org/package=Ecdat">https://CRAN.R-project.org/package=Ecdat</a>.
</p>
<p>Fay MP, Shaw PA (2010).
&ldquo;Exact and Asymptotic Weighted Logrank Tests for Interval Censored Data: 
The <span class="pkg">interval</span> <span class="rlang"><b>R</b></span> Package&rdquo;, 
<em>Journal of Statistical Software</em>, 
<b>36</b>(2), 1-34. <a href="https://www.jstatsoft.org/v36/i02/">https://www.jstatsoft.org/v36/i02/</a>.
</p>
<p>Gentleman R, Vandal A (2011).
<em>Icens: NPMLE for Censored and Truncated Data</em>. 
<span class="rlang"><b>R</b></span> package version 1.24.0, 
<a href="https://CRAN.R-project.org/package=Icens">https://CRAN.R-project.org/package=Icens</a>.
</p>
<p>Hanemann, WM (1984). 
&ldquo;Welfare Evaluations in Contingent Valuation Experiments with Discrete Responses&rdquo;, 
<em>American Journal of Agricultural Economics</em>,
<b>66</b>(2), 332&ndash;341.
</p>
<p>Hanemann WM (1985).
&ldquo;Some Issues in Continuous- and Discrete-Response Contingent
Valuation Studies.&rdquo;
<em>Northeastern Journal of Agricultural Economics</em>, <b>14</b>,
5&ndash;13.
</p>
<p>Hole AR (2007).
&ldquo;A Comparison of Approaches to Estimating Confidence Intervals for 
Willingness to Pay Measure.&rdquo;
<em>Health Economics</em>, <b>16</b>, 827&ndash;840.
</p>
<p>Krinsky I, Robb AL (1986).
&ldquo;On Approximating the Statistical Properties of Elasticities.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>68</b>, 715&ndash;719.
</p>
<p>Krinsky I, Robb AL (1990).
&ldquo;On Approximating the Statistical Properties of Elasticities: 
A Correction.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>72</b>, 189&ndash;190.
</p>
<p>Kristr\&quot;om B (1990). 
&ldquo;A Non-Parametric Approach to the Estimation of Welfare 
Measures in Discrete Response Valuation Studies.&rdquo;
<em>Land Economics</em>, <b>66</b>(2), 135&ndash;139.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Installation of DCchoice along with dependent packages is carried out 
## by the following lines of code:
## Not run: 
install.packages("DCchoice", 
  repos = c("@CRAN@", "http://www.bioconductor.org/packages/release/bioc"), 
  dep = TRUE)

## End(Not run)
## You may select a CRAN mirror a few times.
## For Mac and Unix/Linux users, add the option argument 'type="source"'. 
</code></pre>

<hr>
<h2 id='AP'>Albemarle-Pamlico sounds CVM data</h2><span id='topic+AP'></span>

<h3>Description</h3>

<p>Double-bounded dichotomous choice survey data for quality inprovements in 
the Albemarle-Pamlico sounds, North Carolina.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AP)
</code></pre>


<h3>Format</h3>

<p>a data frame containing 721 observations.
</p>

<dl>
<dt>bid1</dt><dd><p>a vector of bids expressd in USD.</p>
</dd>
<dt>bid2</dt><dd><p>a vector of bids expressd in USD.</p>
</dd>
<dt>R1</dt><dd><p>a vector of binary dummies equal to 1 if the bid is accepted and 0 otherwise.</p>
</dd>
<dt>R2</dt><dd><p>a vector of binary dummies equal to 1 if the bid is accepted and 0 otherwise.</p>
</dd>
<dt>income</dt><dd><p>a numeric vrector containing the annual household income in 1995 USD of the respondent</p>
</dd>
<dt>work</dt><dd><p>a vector of binary dummies equal to 1 if the respondent is employed in fulltime and 0 otherwise.</p>
</dd>
<dt>age</dt><dd><p>a numeric vector containing the age of the respondent.</p>
</dd>
<dt>female</dt><dd><p>a vector of binary dummies equal to 1 if the respondent is female and 0 otherwise.</p>
</dd>
<dt>married</dt><dd><p>a vector of binary dummies equal to 1 if the respondent is married and 0 otherwise.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The original data are based on a telephone survey regarding quality improvements 
in the Albemarle-Pamlico sounds, North Carolina. The data were intensively analyzed, 
for instance, in Whitehead (1995) and Whitehead, et. al. (1998) in different contexts. Details of the survey can be 
found in the web site (see <em>Source</em> for the URL). 
</p>
<p>The original data have $1077$ observations and include the bids and the responses 
of the double-bounded dichotomous choice survey. Various socio-demographic 
characteristics are also collected by the survey. 
</p>
<p>A subset of the data consisting of the responses to the CVM questions 
as well as minimum number of socio-demographic characteristics. In addition, 
observations with missing values were removed from the subset. 
</p>


<h3>Source</h3>

<p>The complete data and details can be obtained in the online version of 
Whitehead (2015).
</p>
<p>The data are included here under kind permission from Professor 
John Whitehead, Appalachian State University.
</p>


<h3>References</h3>

<p>Whitehead JC (1995).
&ldquo;Willingness to Pay for Quality Improvements: Comparative
Statics and Interpretation of Contingent Valuation Results.&rdquo;
<em>Land Economics</em>, <b>71</b>(2), 207&ndash;215.
</p>
<p>Whitehead JC (2015).
&ldquo;Albemarle-Pamlico Sounds Revealed and Stated Preference Data.&rdquo;
<em>Data in Brief</em>, <b>3</b>, 90&ndash;94.
</p>
<p>Whitehead JC, Haab TC, Huang JC (1998).
&ldquo;Part-Whole Bias in Contingent Valuation: Will Scope Effects 
be Detected with Inexpensive Survey Methods?&rdquo;
<em>Southern Economic Journal</em>, <b>65</b>(1), 160&ndash;168.
</p>

<hr>
<h2 id='bootCI'>Calculating confidence intervals for WTP using a nonparametric bootstrap method</h2><span id='topic+bootCI'></span><span id='topic+print.bootCI'></span>

<h3>Description</h3>

<p>This function calculates confidence intervals for WTP using the nonparametric bootstrap method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootCI(obj, nboot = 1000, CI = 0.95, individual = NULL)

## S3 method for class 'bootCI'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootCI_+3A_obj">obj</code></td>
<td>
<p>an S3 class object <code>"dbchoice"</code> or <code>"sbchoice"</code>.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_nboot">nboot</code></td>
<td>
<p>the number of bootstrap resampling.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_ci">CI</code></td>
<td>
<p>a percentile of the confidence intervals to be estimated.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_individual">individual</code></td>
<td>
<p>a data frame containing covariates that show an individual of which to estimate WTP.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_x">x</code></td>
<td>
<p>an object of class <code>"bootCI"</code>.</p>
</td></tr>
<tr><td><code id="bootCI_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bootstrap method resamples the data at our hands and repeatedly estimates the model 
with the bootstrapped data to formulate an empirical distribution of the associated WTP. 
This is a clear contrast with the method of Krinsky and Robb (1986, 1990) where the parameters are 
directly drawn from the multivariate normal distribution.
</p>
<p>The upper and the lower bound of the interval is determined similarly to the case of 
the function <code><a href="#topic+krCI">krCI</a></code>.
</p>
<p>Hole (2007) conducted simulation experiments to compare the performance of the method of Krinsky 
and Robb (1986, 1990) with the bootstrap one. 
</p>
<p>A WTP of a specific individual (e.g., a representative respondent) can be estimated 
when assigning covariates to <code>individual</code>. See Example for details.
</p>


<h3>Value</h3>

<p>The function <code>bootCI()</code> returns an object of S3 class <code>"bootCI"</code>. 
An object of <code>"bootCI"</code> is a list with the following components.
</p>
<table role = "presentation">
<tr><td><code>out</code></td>
<td>
<p>the output table with simulated confidence intervals as well as 
the four type of WTP estimates (mean, truncated mean, truncated mean with adjustment 
and median) from the ML estimation.</p>
</td></tr>
<tr><td><code>mWTP</code></td>
<td>
<p>a vector of simulated mean WTP. When |beta| &lt; 1, this item is set 
to <code>-999</code>.</p>
</td></tr>
<tr><td><code>tr.mWTP</code></td>
<td>
<p>a vector of simulated mean WTP truncated at the maximum bid.</p>
</td></tr>
<tr><td><code>adj.tr.mWTP</code></td>
<td>
<p>a vector of simulated mean WTP truncated at the maximum bid with the adjustment.</p>
</td></tr>
<tr><td><code>medWTP</code></td>
<td>
<p>a vector of simulated median WTP.</p>
</td></tr>
</table>
<p>When the parameter estimate on the bid does not satisfy the condition for the existence 
of the finite mean WTP (|beta|&gt;1), the values of the lower and the upper bound of the 
confidence interval are coerced to set to <code>-999</code>.
</p>
<p>The generic function <code>print()</code> is available for the object of class 
<code>"bootCI"</code> and displays the table of simulated confidence intervals. 
</p>
<p>The table contains the confidence intervals for the four types (mean, truncated mean, 
truncated mean with adjustment and median) of WTP from the ML estimation. 
The adjustment for the truncated mean WTP is implemented by the method of Boyle 
<em>et~al.</em>(1988). 
</p>


<h3>Warning</h3>

<p>It is time consuming (usually takes several minutes) to implement this function.
</p>


<h3>References</h3>

<p>Boyle KJ, Welsh MP, Bishop RC (1988).
&ldquo;Validation of Empirical Measures of Welfare Change: Comment.&rdquo;
<em>Land Economics</em>, <b>64</b>(1), 94&ndash;98.
</p>
<p>Hole AR (2007).
&ldquo;A Comparison of Approaches to Estimating Confidence Intervals for 
Willingness to Pay Measure.&rdquo;
<em>Health Economics</em>, <b>16</b>, 827&ndash;840.
</p>
<p>Krinsky I, Robb AL (1986).
&ldquo;On Approximating the Statistical Properties of Elasticities.&rdquo; 
<em>The Review of Economics and Statistics</em>, <b>68</b>, 715&ndash;719.
</p>
<p>Krinsky I, Robb AL (1990).
&ldquo;On Approximating the Statistical Properties of Elasticities:
A Correction.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>72</b>, 189&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krCI">krCI</a></code>, <code><a href="#topic+dbchoice">dbchoice</a></code>, <code><a href="#topic+sbchoice">sbchoice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in dbchoice and sbchoice.
</code></pre>

<hr>
<h2 id='Carson'>Exxon Valdez Oil Spill CVM data</h2><span id='topic+CarsonSB'></span><span id='topic+CarsonDB'></span>

<h3>Description</h3>

<p>Contingency tables for the suggested bids and the number of 
respondents saying yes or no to the bids in the Exxon Valdez 
Oil Spill CVM survey. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CarsonSB)
data(CarsonDB)
</code></pre>


<h3>Format</h3>

<p>Both <code>CarsonSB</code> and <code>CarsonDB</code> are data frame objects 
of contingency tables. 
</p>
<p>For <code>CarsonSB</code>, 
</p>

<dl>
<dt>T1</dt><dd><p>a bid expressd in USD.</p>
</dd>
<dt>Y</dt><dd><p>a number of respondents accepting the bid.</p>
</dd>
<dt>N</dt><dd><p>a number of respondents not accepting the bid.</p>
</dd>
</dl>

<p>For <code>CarsonDB</code>, 
</p>

<dl>
<dt>T1</dt><dd><p>a first stage bid expressd in USD.</p>
</dd>
<dt>TU</dt><dd><p>a second stage bid increased from the first one, expressd in USD.</p>
</dd>
<dt>TL</dt><dd><p>a second stage bid decreased from the first one, expressd in USD.</p>
</dd>
<dt>yy</dt><dd><p>a number of respondents accepting both the first and the second bids.</p>
</dd>
<dt>yn</dt><dd><p>a number of respondents accepting only the first bid.</p>
</dd>
<dt>ny</dt><dd><p>a number of respondents accepting only the second bid.</p>
</dd>
<dt>nn</dt><dd><p>a number of respondents not accepting the first nor the second bids.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Out of <code>CarsonSB</code> and <code>CarsonSB</code>, one may reconstruct the original yes/no 
type of data for 1043 observations. See the example for <code>CarsonSB</code>. 
</p>


<h3>Source</h3>

<p><code>CarsonSB</code> and <code>CarsonDB</code> are reproduced from Tables A-15, 
A-16 and A-17 in Appendix C.1 of Carson et.al (1992). 
</p>
<p>The data are included under kind permission from Professor Richard 
T. Carson of University of California, San Diego. 
</p>


<h3>References</h3>

<p>Carson RT, Mitchell RC, Hanemann WM, Kopp RJ, Presser S, Ruud PA (1992).
&ldquo;A Contingent Valuation Study of Lost Passive Use Values
Resulting from the Exxon Valdez Oil Spill.&rdquo;
<em>Technical Report Report to the Attorney General of the State of
Alaska</em>, Natural Resource Damage Assessment Inc.
<a href="https://mpra.ub.uni-muenchen.de/6984/">https://mpra.ub.uni-muenchen.de/6984/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ct2df">ct2df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The following lines of code reconstruct the original yes/no type of data 
## for 1043 observations. A data frame object sb.data consists of two variables, 
## namely, bid1 and R1. The conversion into a simole data frame object can be 
## done either manually or by using the \code{ct2df} function. 
data(CarsonSB)

## Using the \code{ct2df} function
CarsonSB.dat &lt;- ct2df(
  x    = CarsonSB,
  bid1 = "T1",
  y    = "Y",
  n    = "N",
  type = "single")
head(CarsonSB.dat)

# Manual conversion
n &lt;- rowSums(CarsonSB[, -1])
sb.data &lt;- data.frame(
  bid = c(rep(CarsonSB$T1[1], n[1]), 
          rep(CarsonSB$T1[2], n[2]), 
          rep(CarsonSB$T1[3], n[3]), 
          rep(CarsonSB$T1[4], n[4])), 
  R1 = c(rep(1, CarsonSB$Y[1]), rep(0, CarsonSB$N[1]),
         rep(1, CarsonSB$Y[2]), rep(0, CarsonSB$N[2]),
         rep(1, CarsonSB$Y[3]), rep(0, CarsonSB$N[3]),
         rep(1, CarsonSB$Y[4]), rep(0, CarsonSB$N[4]))
)
dim(sb.data)
head(sb.data)

## Double-bounded dichotomous choice CV format.
data(CarsonDB)
CarsonDB
CarsonDB.dat &lt;- ct2df(
  x     = CarsonDB,
  bid1  = "T1",
  bid2h = "TU",
  bid2l = "TL",
  yy    = "yy",
  yn    = "yn",
  ny    = "ny",
  nn    = "nn",
  type  = "double")
head(CarsonDB.dat)

## An example of manual conversion is omitted. 
## See Appendix 2.A of Aizaki, et. al. (2014). 

</code></pre>

<hr>
<h2 id='ct2df'>
Convert a data frame in contingency-table format into a simple data frame of individual observations
</h2><span id='topic+ct2df'></span>

<h3>Description</h3>

<p>A convinience function converting a data frame object in contingency-table format of bid(s) and responses of dichotomous choice CV into a simple data frame of individual observations. The outcome is suitable for the analysis using functions in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct2df(x,
  bid1 = "bid1", bid2h = "bidh", bid2l = "bidl", bidl = "bidl", bidh = "bidh",
  nny = "nny", nnn = "nnn", yy = "yy", yn = "yn", ny = "ny", nn = "nn",
  y = "y", n = "n", n_y = "n_y", n_n = "n_n", nn_y = "nn_y", nn_n = "nn_n", 
  type = "double", spike = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ct2df_+3A_x">x</code></td>
<td>

<p>a data frame object in contingency-table format containing bid(s) and responses
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_bid1">bid1</code></td>
<td>

<p>a character string showing the bid (for &quot;single&quot;) or the bid in the first stage (for &quot;double&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_bid2h">bid2h</code></td>
<td>

<p>a character string showing the second (higher) bid when respondents answer &quot;Yes&quot; in the first stage
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_bid2l">bid2l</code></td>
<td>

<p>a character string showing the second (lower) bid when respondents answer &quot;No&quot; in the first stage
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_bidh">bidh</code></td>
<td>

<p>a character string showing the higher bid (for &quot;oohb&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_bidl">bidl</code></td>
<td>

<p>a character string showing the lower bid (for &quot;oohb&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_nny">nny</code></td>
<td>

<p>a character string showing a number of respondents rejecting the first and the second bids and having a positive willingness-to-pay (WTP) (for a spike &quot;double&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_nnn">nnn</code></td>
<td>

<p>a character string showing a number of respondents rejecting the first and the second bids and having a zero WTP (for a spike &quot;double&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_yy">yy</code></td>
<td>

<p>a character string showing a number of respondents accepting both the first and the second bids
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_yn">yn</code></td>
<td>

<p>a character string showing a number of respondents accepting only the first bid
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_ny">ny</code></td>
<td>

<p>a character string showing a number of respondents accepting only the second bid (for &quot;double&quot;) or rejecting the first bid and having a positive WTP (for a spike &quot;single&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_nn">nn</code></td>
<td>

<p>a character string showing a number of respondents rejecting the first and the second bids (for &quot;double&quot;) or rejecting the first bid and having a zero WTP (for a spike &quot;single&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_y">y</code></td>
<td>

<p>a character string showing a number of respondents accepting the bid
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_n">n</code></td>
<td>

<p>a character string showing a number of respondents rejecting the bid
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_n_y">n_y</code></td>
<td>

<p>a character string showing a number of respondents rejecting the bid and having a positive WTP (for a spike &quot;oohb&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_n_n">n_n</code></td>
<td>

<p>a character string showing a number of respondents rejecting the bid and having a zero WTP (for a spike &quot;oohb&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_nn_y">nn_y</code></td>
<td>

<p>a character string showing a number of respondents rejecting the first and second bids and having a positive WTP (for a spike &quot;oohb&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_nn_n">nn_n</code></td>
<td>

<p>a character string showing a number of respondents rejecting the first and second bid and having a zero WTP (for a spike &quot;oohb&quot;)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_type">type</code></td>
<td>

<p>a character string setting the elicitation format, which takes one of &quot;single&quot; (single-bounded dichotomous choice format), &quot;oohb&quot; (one-and-one-half-bounded dichotomous choice format), or &quot;double&quot; (double-bounded dichotomous choice format)
</p>
</td></tr>
<tr><td><code id="ct2df_+3A_spike">spike</code></td>
<td>

<p>a logical code: <code>TRUE</code> for a spike model. The default is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+ct2df">ct2df</a></code> implements a conversion of a data frame 
containing bid(s) and responses regarding dichotomous choice CV in 
contingency-table format into a data frame suitable for use by the functions 
<code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="#topic+oohbchoice">oohbchoice</a></code>, <code><a href="#topic+dbchoice">dbchoice</a></code>, <code><a href="#topic+sbspike">sbspike</a></code>, <code><a href="#topic+oohbspike">oohbspike</a></code>, <code><a href="#topic+dbspike">dbspike</a></code>, <code><a href="#topic+kristrom">kristrom</a></code>, 
<code><a href="#topic+turnbull.sb">turnbull.sb</a></code>, and <code><a href="#topic+turnbull.db">turnbull.db</a></code>. 
See <code><a href="#topic+CarsonSB">CarsonSB</a></code> and <code><a href="#topic+CarsonDB">CarsonDB</a></code> for dataset 
in contingency-table format.
</p>
<p>See the examples below and ones in <code><a href="#topic+spike-models">spike-models</a></code>, for usage in detail.
</p>


<h3>Value</h3>

<p>The function returns a data frame, in which each row shows a single respondent. It contains the following variables.
</p>
<p>For &quot;single&quot;,
</p>
<table role = "presentation">
<tr><td><code>R1</code></td>
<td>

<p>a response to a bid: 1 for &quot;Yes&quot;, 0 for &quot;No&quot;
</p>
</td></tr>
<tr><td><code>bid1</code></td>
<td>

<p>the bid
</p>
</td></tr>
</table>
<p>For &quot;double&quot;,
</p>
<table role = "presentation">
<tr><td><code>B1</code></td>
<td>

<p>a bid in the first stage
</p>
</td></tr>
<tr><td><code>B2H</code></td>
<td>

<p>a (higher) bid in the second stage when the response is &quot;Yes&quot; in the first stage
</p>
</td></tr>
<tr><td><code>B2L</code></td>
<td>

<p>a (lower) bid in the second stage when the response is &quot;No&quot; in the first stage
</p>
</td></tr>
<tr><td><code>R</code></td>
<td>

<p>a combination of responses in the first and second stages, which takes yy for &quot;Yes&quot; and &quot;Yes&quot;, yn for &quot;Yes&quot; and &quot;No&quot;, ny for &quot;No&quot; and &quot;Yes&quot;, or nn for &quot;No&quot; and &quot;No&quot;
</p>
</td></tr>
<tr><td><code>R1</code></td>
<td>

<p>the response in the first stage, which takes 1 for &quot;Yes&quot;, 0 for &quot;No&quot;
</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>

<p>the response in the second stage, which takes 1 for &quot;Yes&quot;, 0 for &quot;No&quot;
</p>
</td></tr>
<tr><td><code>bid1</code></td>
<td>

<p>the bid in the first stage
</p>
</td></tr>
<tr><td><code>bid2</code></td>
<td>

<p>the bid in the second stage the respondent faced
</p>
</td></tr>
</table>
<p>For &quot;oohb&quot;,
</p>
<table role = "presentation">
<tr><td><code>BH</code></td>
<td>
<p>a higher bid</p>
</td></tr>
<tr><td><code>BL</code></td>
<td>
<p>a lower bid</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>a combination of responses in the first and second stages</p>
</td></tr>
<tr><td><code>R1</code></td>
<td>
<p>the response in the first stage, which takes <code>1</code> if the bid is accepted, and <code>0</code> otherwise</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>the response in the second stage, which takes <code>1</code> if the bid is accepted, <code>0</code> if the bid is not accepted, and <code>-9</code> if the respondent has no second stage</p>
</td></tr>
</table>
<p>For spike models,
</p>
<table role = "presentation">
<tr><td><code>S</code></td>
<td>
<p>the response in a simple spike question, which takes <code>1</code> if the respondent has a positive WTP, and <code>0</code> otherwise</p>
</td></tr>
</table>


<h3>References</h3>

<p>Aizaki H, Nakatani T, Sato K (2014). Stated Preference Methods Using R. CRC Press, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="#topic+oohbchoice">oohbchoice</a></code>, <code><a href="#topic+dbchoice">dbchoice</a></code>,
<code><a href="#topic+sbspike">sbspike</a></code>, <code><a href="#topic+oohbspike">oohbspike</a></code>, <code><a href="#topic+dbspike">dbspike</a></code>,
<code><a href="#topic+kristrom">kristrom</a></code>, <code><a href="#topic+turnbull.sb">turnbull.sb</a></code>, <code><a href="#topic+turnbull.db">turnbull.db</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single-bounded dichotomous choice CV format
data(CarsonSB)
CarsonSB
CarsonSB.dat &lt;- ct2df(
  x    = CarsonSB,
  bid1 = "T1",
  y    = "Y",
  n    = "N",
  type = "single")
head(CarsonSB.dat)
summary(turnbull.sb(R1 ~ bid1, data = CarsonSB.dat))

# Double-bounded dichotomous choice CV format
data(CarsonDB)
CarsonDB
CarsonDB.dat &lt;- ct2df(
  x     = CarsonDB,
  bid1  = "T1",
  bid2h = "TU",
  bid2l = "TL",
  yy    = "yy",
  yn    = "yn",
  ny    = "ny",
  nn    = "nn",
  type  = "double")
head(CarsonDB.dat)
summary(turnbull.db(R1 + R2 ~ bid1 + bid2, data = CarsonDB.dat))
</code></pre>

<hr>
<h2 id='dbchoice'>Parametric approach to analyze double-bounded dichotomous choice contingent valuation data</h2><span id='topic+dbchoice'></span><span id='topic+print.dbchoice'></span><span id='topic+vcov.dbchoice'></span><span id='topic+logLik.dbchoice'></span>

<h3>Description</h3>

<p>This function analyzes double-bounded dichotomous choice contingent 
valuation (CV) data on the basis of the utility difference approach.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbchoice(formula, data, subset, na.action = na.omit, dist = "log-logistic",
         par = NULL, ...)

## S3 method for class 'dbchoice'
print(x, digits = max(3, getOption("digits") - 1), ...)

## S3 method for class 'dbchoice'
vcov(object, ...)

## S3 method for class 'dbchoice'
logLik(object, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbchoice_+3A_formula">formula</code></td>
<td>
<p>an object of S3 class <code>"formula"</code> and specifies the model structure.</p>
</td></tr>
<tr><td><code id="dbchoice_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model formula.</p>
</td></tr>
<tr><td><code id="dbchoice_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations.</p>
</td></tr>
<tr><td><code id="dbchoice_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contains <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="dbchoice_+3A_dist">dist</code></td>
<td>
<p>a character string setting the error distribution in the model, which 
takes one of <code>"logistic"</code>, <code>"normal"</code>, <code>"log-logistic"</code>, 
<code>"log-normal"</code> or <code>"weibull"</code>.</p>
</td></tr>
<tr><td><code id="dbchoice_+3A_par">par</code></td>
<td>
<p>a vector of initial parameters over which the optimization is carried out.</p>
</td></tr>
<tr><td><code id="dbchoice_+3A_x">x</code></td>
<td>
<p>an object of class <code>"dbchoice"</code>.</p>
</td></tr>
<tr><td><code id="dbchoice_+3A_digits">digits</code></td>
<td>
<p>a number of digits to display.</p>
</td></tr>
<tr><td><code id="dbchoice_+3A_object">object</code></td>
<td>
<p>an object of class <code>"dbchoice"</code>.</p>
</td></tr>
<tr><td><code id="dbchoice_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>dbchoice()</code> implements an analysis of double-bounded dichotomous choice 
contingent valuation (CV) data on the basis of the utility difference approach (Hanemann, 1984). 
A generic call to <code>dbchoice()</code> is given by
</p>
<p><code>dbchoice(formula, data, dist = "log-logistic", ...)</code>
</p>
<p>The extractor function <code>summary()</code> is available for a <code>"dbchoice"</code> class object. 
See <code><a href="#topic+summary.dbchoice">summary.dbchoice</a></code> for details.
</p>
<p>There are two functions available for computing the confidence intervals for the estimates of WTPs. 
<code><a href="#topic+krCI">krCI</a></code> implements simulations to construct empirical distributions of the WTP while 
<code><a href="#topic+bootCI">bootCI</a></code> carries out nonparametric bootstrapping. 
</p>
<p>The argument <code>formula</code> defines the response variables and covariates. The argument <code>data</code> 
is mandatory where the data frame containing the variables in the model is specified. The argument <code>dist</code> 
sets the error distribution. 
Currently, one of <code>"logistic"</code>, <code>"normal"</code>, <code>"log-logistic"</code>, <code>"log-normal"</code>, 
or <code>"weibull"</code> is available. 
The default value is <code>dist = "log-logistic"</code>, so that it may be omitted if the user wants to estimate a model 
with log-logistic error distribution.
</p>
<p>The difference between normal and log-normal models or between logistic or 
log-logistic ones is how the bid variable is incorporated into the model to be estimated. 
For the Weibull model, the bid variable must be entered in the natural log. 
Therefore, the user must be careful in defining the model formula that is explained in details 
below.
</p>
<p>A typical structure of the formula for <code>dbchoice()</code> is defined as follows:
</p>
<p><code>R1 + R2 ~ (the names of the covariates) | BD1 + BD2</code>
</p>
<p>The formula is an object of class <code>"formula"</code> and specifies the model structure. It has to be written in a 
symbolic expression in <span class="rlang"><b>R</b></span>.
The formula consists of three parts. The first part, the left-hand side of the tilde sign (<code>~</code>), must 
contain the response variables for the suggested prices in the first and the second stage of CV questions. 
In the example below, <code>R1</code> denotes a binary or two-level factor response variable for a bid in the first 
stage and <code>R2</code> for a bid in the second stage. Each of <code>R1</code> and <code>R2</code> contains <code>"Yes"</code> or 
<code>"No"</code> to the bid or <code>1</code> for <code>"Yes"</code> and <code>0</code> for <code>"No"</code>.
</p>
<p>The covariates are defined in the second part in the place of <code>(the names of the covariates)</code>. Each covariate is 
connected with the arithmetic operator <code>+</code> and <code>(the names of the covariates)</code> in the above syntax should be 
replaced with <code>var1 + var2</code> and the like. The plus sign is nothing to do with addition of the two variables 
in the symbolic expression. When the covariate contains only a constant term, a value of <code>1</code> is set as the 
covariate (that is, <code>R1 + R2 ~ 1 | BD1 + BD2</code>)
</p>
<p>The last part starts after the vertical bar (<code>|</code>). The names of the two variables (<code>BD1</code> and <code>BD2</code>) 
containing suggested prices in the first and second stage of double-bounded dichotomous choice CV question are 
specified in this part. The two variables are also connected with the arithmetic operator (<code>+</code>).
</p>
<p>According to the structure of the formula, a data set (data frame) consists of three parts. An example of the 
data set is as follows (<code>sex</code>, <code>age</code>, and <code>income</code> are respondents characteristics and assumed 
to be covariates):
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>R1</code>  </td><td style="text-align: right;"> <code>R2</code>   </td><td style="text-align: right;"> <code>sex</code>  </td><td style="text-align: right;"> <code>age</code>  </td><td style="text-align: right;"> <code>income</code> </td><td style="text-align: right;"> <code>BD1</code> </td><td style="text-align: right;"> <code>BD2</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    Yes </td><td style="text-align: right;"> Yes  </td><td style="text-align: right;"> Male </td><td style="text-align: right;"> 20   </td><td style="text-align: right;"> Low    </td><td style="text-align: right;"> 100 </td><td style="text-align: right;"> 250</td>
</tr>
<tr>
 <td style="text-align: right;">
    Yes </td><td style="text-align: right;"> No   </td><td style="text-align: right;"> Male </td><td style="text-align: right;"> 30   </td><td style="text-align: right;"> Low    </td><td style="text-align: right;"> 500 </td><td style="text-align: right;"> 1000</td>
</tr>
<tr>
 <td style="text-align: right;">
    ... </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;">
</td>
</tr>

</table>

<p>The second bid in the double-bounded dichotomous choice CV question is larger or lower than the first bit 
according to the response to the first stage: if the response to the first stage is <code>"Yes"</code>, the second bid is 
larger than the first bid; if the response is <code>"No"</code>, the second bid is lower than the first bid. In the example 
above, <code>BD2</code> is set as the second bid according to each respondent faced in the second stage. However, 
the followings style of data set is frequently prepared:
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>R1</code>  </td><td style="text-align: right;"> <code>R2</code>  </td><td style="text-align: right;"> <code>sex</code>  </td><td style="text-align: right;"> <code>age</code> </td><td style="text-align: right;"> <code>income</code> </td><td style="text-align: right;"> <code>BD1</code> </td><td style="text-align: right;"> <code>BD2H</code> </td><td style="text-align: right;"> <code>BD2L</code></td>
</tr>
<tr>
 <td style="text-align: right;">
    Yes </td><td style="text-align: right;"> Yes </td><td style="text-align: right;"> Male </td><td style="text-align: right;"> 20  </td><td style="text-align: right;"> Low    </td><td style="text-align: right;"> 100 </td><td style="text-align: right;"> 250  </td><td style="text-align: right;"> 50</td>
</tr>
<tr>
 <td style="text-align: right;">
    Yes </td><td style="text-align: right;"> No  </td><td style="text-align: right;"> Male </td><td style="text-align: right;"> 30  </td><td style="text-align: right;"> Low    </td><td style="text-align: right;"> 500 </td><td style="text-align: right;"> 1000 </td><td style="text-align: right;"> 250</td>
</tr>
<tr>
 <td style="text-align: right;">
    ... </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> 
</td>
</tr>

</table>

<p><code>BD2H</code> is the second (higher) bid when the respondent answers <code>"Yes"</code> in the first stage; <code>BD2L</code> 
is the second (lower) bid when the respondent answers <code>"No"</code> in the first stage. In this case, the users 
have to convert <code>BD2H</code> and <code>BD2L</code> into <code>BD2</code> (see the section &quot;Examples&quot;).
</p>
<p>The function <code>dbchoice()</code> analyzes double-bounded dichotomous choice CV data using the function 
<code><a href="stats.html#topic+optim">optim</a></code> on the basis of the initial coefficients that are estimated from a binary 
logit model analysis of the first-stage CV responses (the binary logit model is estimated internally 
by the function <code><a href="stats.html#topic+glm">glm</a></code> with the argument <code>family = binomial(link = "logit"))</code>.
</p>
<p>Nonparametric analysis of double-bounded dichotomous choice data can be done by <code><a href="#topic+turnbull.db">turnbull.db</a></code>. 
A single-bounded analogue of <code>dbchoice</code> is called <code><a href="#topic+sbchoice">sbchoice</a></code>.
</p>


<h3>Value</h3>

<p>This function returns an S3 class object <code>"dbchoice"</code> that is a list with the following components.
</p>
<table role = "presentation">
<tr><td><code>f.stage</code></td>
<td>
<p>a list of components returned from the function <code><a href="stats.html#topic+glm">glm</a></code> based on the 
responses to the first CV question. The coefficient estimates of the first stage estimation is 
used as the initial coefficients for full analysis using the function <code><a href="stats.html#topic+optim">optim</a></code>.
If <code>par</code> is not <code>NULL</code>, the supplied vector is returned.</p>
</td></tr>
<tr><td><code>dbchoice</code></td>
<td>
<p>a list of components returned from the function <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of estimated coefficients.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>an estimate of the Hessian. See also <code>Hessian</code> in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>distribution</code></td>
<td>
<p>a character string showing the error distribution used.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>a value of the log likelihood at the estimates.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>an logical code: <code>TRUE</code> means a successful convergence.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>a vector of two integers describing the number of calls to the object function and the 
numerical gradient, respectively. See also <code>counts</code> in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>a number of observations.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>a named matrix of the covariates used in the model.</p>
</td></tr>
<tr><td><code>bid</code></td>
<td>
<p>a named matrix of the bids used in the model.</p>
</td></tr>
<tr><td><code>yn</code></td>
<td>
<p>a named matrix of the responses to the initial and follow-up CV questions used in the model.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the data matrix.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>terms</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>contrasts used for factors</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>levels used for factors</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bateman IJ, Carson RT, Day B, Hanemann M, Hanley N, Hett T, Jones-Lee M, Loomes
G, Mourato S, \&quot;Ozdemiro\=glu E, Pearce DW, Sugden R, Swanson J (eds.) (2002).
<em>Economic Valuation with Stated Preference Techniques: A Manual.</em> 
Edward Elger, Cheltenham, UK.
</p>
<p>Carson RT, Hanemann WM (2005).
&ldquo;Contingent Valuation.&rdquo;
in KG M\&quot;aler, JR Vincent (eds.), <em>Handbook of Environmental Economics</em>. 
Elsevier, New York.
</p>
<p>Croissant Y (2011).
<em><span class="pkg">Ecdat</span>: Data Sets for Econometrics,</em> 
<span class="rlang"><b>R</b></span> package version 0.1-6.1, 
<a href="https://CRAN.R-project.org/package=Ecdat">https://CRAN.R-project.org/package=Ecdat</a>.
</p>
<p>Hanemann, WM (1984). 
&ldquo;Welfare Evaluations in Contingent Valuation Experiments with Discrete Responses&rdquo;, 
<em>American Journal of Agricultural Economics</em>,
<b>66</b>(2), 332&ndash;341.
</p>
<p>Hanemann M, Kanninen B (1999).
&ldquo;The Statistical Analysis of Discrete-Response CV Data.&rdquo;, 
in IJ Bateman, KG Willis (eds.), 
<em>Valuing Environmental Preferences: Theory and Practice of the Contingent 
Valuation Methods in the US, EU, and Developing Countries</em>, 
302&ndash;441. 
Oxford University Press, New York.
</p>
<p>Hanemann WM, Loomis JB, Kanninen BJ (1991).
&ldquo;Statistical Efficiency of Double-Bounded Dichotomous Choice 
Contingent Valuation.&rdquo; 
<em>American Journal of Agricultural Economics</em>, <b>73</b>(4), 1255&ndash;1263.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dbchoice">summary.dbchoice</a></code>, <code><a href="#topic+krCI">krCI</a></code>, <code><a href="#topic+bootCI">bootCI</a></code>, 
<code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="#topic+turnbull.db">turnbull.db</a></code>, <code><a href="Ecdat.html#topic+NaturalPark">NaturalPark</a></code>, 
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples are based on a data set NaturalPark in the package 
## Ecdat (Croissant 2011): DBDCCV style question for measuring 
## willingness to pay for the preservation of the Alentejo Natural 
## Park. The data set (dataframe) contains seven variables: 
## bid1 (bid in the initial question), bidh (higher bid in the follow-up 
## question), bidl (lower bid in the follow-up question), answers 
## (response outcomes in a factor format with four levels of "nn", 
## "ny", "yn", "yy"), respondents' characteristic variables such 
## as age, sex and income (see NaturalPark for details).
data(NaturalPark, package = "Ecdat")
head(NaturalPark)

## The variable answers are converted into a format that is suitable for the 
## function dbchoice() as follows:
NaturalPark$R1 &lt;- ifelse(substr(NaturalPark$answers, 1, 1) == "y", 1, 0)
NaturalPark$R2 &lt;- ifelse(substr(NaturalPark$answers, 2, 2) == "y", 1, 0)

## We assume that the error distribution in the model is a 
## log-logistic; therefore, the bid variables bid1 is converted 
## into LBD1 as follows:
NaturalPark$LBD1 &lt;- log(NaturalPark$bid1)

## Further, the variables bidh and bidl are integrated into one 
## variable (bid2) and the variable is converted into LBD2 as follows:
NaturalPark$bid2 &lt;- ifelse(NaturalPark$R1 == 1, NaturalPark$bidh, NaturalPark$bidl)
NaturalPark$LBD2 &lt;- log(NaturalPark$bid2)

## The utility difference function is assumed to contain covariates (sex, age, and 
## income) as well as two bid variables (LBD1 and LBD2) as follows:
fmdb &lt;- R1 + R2 ~ sex + age + income | LBD1 + LBD2

## Not run: 
## The formula may be alternatively defined as
fmdb &lt;- R1 + R2 ~ sex + age + income | log(bid1) + log(bid2)

## End(Not run)

## The function dbchoice() with the function fmdb and the dataframe 
## NP is executed as follows:
NPdb &lt;- dbchoice(fmdb, data = NaturalPark)
NPdb
NPdbs &lt;- summary(NPdb)
NPdbs

## The confidence intervals for these WTPs are calculated using the 
## function krCI() or bootCI() as follows:
## Not run: 
krCI(NPdb)
bootCI(NPdb)

## End(Not run)
## The WTP of a female with age = 5 and income = 3 is calculated
## using function krCI() or bootCI() as follows:
## Not run: 
krCI(NPdb, individual = data.frame(sex = "female", age = 5, income = 3))
bootCI(NPdb, individual = data.frame(sex = "female", age = 5, income = 3))

## End(Not run)

## The variable age and income are deleted from the fitted model, 
## and the updated model is fitted as follows:
update(NPdb, .~. - age - income |.)

## The bid design used in this example is created as follows:
bid.design &lt;- unique(NaturalPark[, c(1:3)])
bid.design &lt;- log(bid.design)
colnames(bid.design) &lt;- c("LBD1", "LBDH", "LBDL")
bid.design
## Respondents' utility and probability of choosing Yes-Yes, Yes-No, 
## No-Yes, and No-No under the fitted model and original data are 
## predicted as follows: 
head(predict(NPdb, type = "utility", bid = bid.design))
head(predict(NPdb, type = "probability", bid = bid.design))
## Utility and probability of choosing Yes for a female with age = 5 
## and income = 3 under bid = 10 are predicted as follows:
predict(NPdb, type = "utility",
    newdata = data.frame(sex = "female", age = 5, income = 3, LBD1 = log(10)))
predict(NPdb, type = "probability",
    newdata = data.frame(sex = "female", age = 5, income = 3, LBD1 = log(10)))

## Plot of probabilities of choosing yes is drawn as drawn as follows:
plot(NPdb)
## The range of bid can be limited (e.g., [log(10), log(20)]):
plot(NPdb, bid = c(log(10), log(20)))
</code></pre>

<hr>
<h2 id='dccvResponse'>
Generate artificial responses to dichotomous choice CV questions
</h2><span id='topic+dccvResponse'></span>

<h3>Description</h3>

<p>This function synthesizes responses to DCCV questions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dccvResponse(bid, b, n, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dccvResponse_+3A_bid">bid</code></td>
<td>

<p>a vector (for SBDC) or matrix (for DBDC) containing a bid design
</p>
</td></tr>
<tr><td><code id="dccvResponse_+3A_b">b</code></td>
<td>

<p>a vector containing parameters of independent variables in the model
</p>
</td></tr>
<tr><td><code id="dccvResponse_+3A_n">n</code></td>
<td>

<p>an integer value showing the number of respondents in the resultant dataset
</p>
</td></tr>
<tr><td><code id="dccvResponse_+3A_seed">seed</code></td>
<td>

<p>seed for a random number generator
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function synthesizes response to SBDC- or DBDC-CV questions on the basis of the utility difference approach. See Aizaki et al. (2014) for detail on the model.
</p>
<p>See the examples below for usage in detail.
</p>


<h3>Value</h3>

<p>This function returns a data frame, in which each row shows a single respondent. It contains the following variables.
</p>
<p>For SBDC-CV,
</p>
<table role = "presentation">
<tr><td><code>R1</code></td>
<td>

<p>a response to a bid: 1 for &quot;Yes&quot;, 0 for &quot;No&quot;
</p>
</td></tr>
<tr><td><code>bid1</code></td>
<td>

<p>the bid
</p>
</td></tr>
</table>
<p>For DBDC-CV,
</p>
<table role = "presentation">
<tr><td><code>R1</code></td>
<td>

<p>the response in the first stage, which takes 1 for &quot;Yes&quot;, 0 for &quot;No&quot;
</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>

<p>the response in the second stage, which takes 1 for &quot;Yes&quot;, 0 for &quot;No&quot;
</p>
</td></tr>
<tr><td><code>bid1</code></td>
<td>

<p>the bid in the first stage
</p>
</td></tr>
<tr><td><code>bid2</code></td>
<td>

<p>the bid in the second stage the respondent faced
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Aizaki H, Nakatani T, Sato K (2014). Stated Preference Methods Using R. CRC Press, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="#topic+dbchoice">dbchoice</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># SBDC-CV
data(CarsonSB)
CarsonSB
CarsonSB[, 1]
SB &lt;- dccvResponse(bid = CarsonSB[, 1], b = c(0.64, -0.011), n = 1000)
head(SB)
sbchoice(R1 ~ 1|bid1, dist = "logistic", data = SB)

# DBDC-CV
data(CarsonDB)
CarsonDB
CarsonDB[, 1:3]
DB &lt;- dccvResponse(bid = data.matrix(CarsonDB[, 1:3]), b = c(0.7, -0.016), n = 1000)
head(DB)
dbchoice(R1 + R2 ~ 1|bid1 + bid2, dist = "logistic", data = DB)
</code></pre>

<hr>
<h2 id='KR'>Kristr\&quot;om's single-bounded dichotomous choice CVM data</h2><span id='topic+KR'></span>

<h3>Description</h3>

<p>A single-bounded dichotomous choice CVM data analyzed in
Kristr\&quot;om (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(KR)
</code></pre>


<h3>Format</h3>

<p>A data frame of single-bounded dichotomous choice contingent 
valuation survey data. The number of observations is 562. 
</p>

<dl>
<dt>bid1</dt><dd><p>a vector of bids expressd in SEK.</p>
</dd>
<dt>R1</dt><dd><p>a vector of binary dummies equal to 1 if the bid is accepted and 0 otherwise.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data consist of the responses to the single-bounded dichotomous 
choice survey for a sample of 562 Swedes regarding preservation of 
the eleven virgin forests in Sweden. See Kristr\&quot;om (1990) 
for more details.
</p>


<h3>Source</h3>

<p>The data are used in Kristr\&quot;om (1990). 
</p>
<p>The data are bundled in this package under kind permission from 
Professor Bengt Kristr\&quot;om, Swedish University of Agricultural Sciences.
</p>


<h3>References</h3>

<p>Kristr\&quot;om B (1990). 
&ldquo;A Non-Parametric Approach to the Estimation of Welfare 
Measures in Discrete Response Valuation Studies.&rdquo;
<em>Land Economics</em>, <b>66</b>(2), 135&ndash;139.
</p>

<hr>
<h2 id='krCI'>Calculating confidence intervals for WTP using a parametric simulation</h2><span id='topic+krCI'></span><span id='topic+print.krCI'></span>

<h3>Description</h3>

<p>This function calculates confidence intervals for WTP using the method of Krinsky 
and Robb (1986, 1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krCI(obj, nsim = 1000, CI = 0.95, individual = NULL)

## S3 method for class 'krCI'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="krCI_+3A_obj">obj</code></td>
<td>
<p>an S3 class object <code>"dbchoice"</code> or <code>"sbchoice"</code>.</p>
</td></tr>
<tr><td><code id="krCI_+3A_nsim">nsim</code></td>
<td>
<p>the number of draws of the parameters.</p>
</td></tr>
<tr><td><code id="krCI_+3A_ci">CI</code></td>
<td>
<p>a percentile of the confidence intervals to be estimated.</p>
</td></tr>
<tr><td><code id="krCI_+3A_individual">individual</code></td>
<td>
<p>a data frame containing covariates that show an individual of which to estimate WTP.</p>
</td></tr>
<tr><td><code id="krCI_+3A_x">x</code></td>
<td>
<p>an object of class <code>"krCI"</code>.</p>
</td></tr>
<tr><td><code id="krCI_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the method of Krinsky and Robb (1986, 1990), a set of parameters is drawn <code>nsim</code> times 
from a multivariate normal distribution with a vector of the parameter estimates as a mean 
and the variance-covariance matrix of the parameter estimates. Then, various WTPs are computed for 
each draw of simulated parameters. As a result, we are able to build an empirical distribution 
of the WTPs concerned, and hence the confidence intervals. For each WTP, and when <code>nsim = 1000</code>, 
the lower and the upper bound of the 95% confidence interval (<code>CI = 0.95</code>) correspond to 
the 26th and the 975th sorted estimates, respectively.
</p>
<p>Confidence intervals based on the bootstrap method are calculated by <code><a href="#topic+bootCI">bootCI</a></code>. 
</p>
<p>Hole (2007) conducted simulation experiments to compare the performance of the method of Krinsky 
and Robb (1986, 1990) with the bootstrap one. 
</p>
<p>A WTP of a specific individual (e.g., a representative respondent) can be estimated 
when assigning covariates to <code>individual</code>. See Example for details.
</p>


<h3>Value</h3>

<p>The function <code>krCI()</code> returns an object of S3 class <code>"krCI"</code>. 
An object of <code>"krCI"</code> is a list with the following components.
</p>
<table role = "presentation">
<tr><td><code>out</code></td>
<td>
<p>the output table with simulated confidence intervals as well as 
the four type of WTP estimates (mean, truncated mean, truncated mean with adjustment 
and median) from the ML estimation.</p>
</td></tr>
<tr><td><code>mWTP</code></td>
<td>
<p>a vector of simulated mean WTP. When |beta| &lt; 1, this item is set 
to <code>-999</code>.</p>
</td></tr>
<tr><td><code>tr.mWTP</code></td>
<td>
<p>a vector of simulated mean WTP truncated at the maximum bid.</p>
</td></tr>
<tr><td><code>adj.tr.mWTP</code></td>
<td>
<p>a vector of simulated mean WTP truncated at the maximum bid with the adjustment.</p>
</td></tr>
<tr><td><code>medWTP</code></td>
<td>
<p>a vector of simulated median WTP.</p>
</td></tr>
</table>
<p>When the parameter estimate on the bid does not satisfy the condition for the existence 
of the finite mean WTP (|beta|&gt;1), the values of the lower and the upper bound of the 
confidence interval are coerced to set to <code>-999</code>.
</p>
<p>The table contains the confidence intervals for the four types (mean, truncated mean, 
truncated mean with adjustment and median) of WTP estimate from the ML estimation. 
The adjustment for the truncated mean WTP is implemented by the method of Boyle 
<em>et~al.</em>(1988). 
</p>
<p>The generic function <code>print()</code> is available for the object of class 
<code>"krCI"</code> and displays the table of simulated confidence intervals. 
</p>


<h3>References</h3>

<p>Boyle KJ, Welsh MP, Bishop RC (1988).
&ldquo;Validation of Empirical Measures of Welfare Change: Comment.&rdquo;
<em>Land Economics</em>, <b>64</b>(1), 94&ndash;98.
</p>
<p>Hole AR (2007).
&ldquo;A Comparison of Approaches to Estimating Confidence Intervals for 
Willingness to Pay Measure.&rdquo;
<em>Health Economics</em>, <b>16</b>, 827&ndash;840.
</p>
<p>Krinsky I, Robb AL (1986).
&ldquo;On Approximating the Statistical Properties of Elasticities.&rdquo; 
<em>The Review of Economics and Statistics</em>, <b>68</b>, 715&ndash;719.
</p>
<p>Krinsky I, Robb AL (1990).
&ldquo;On Approximating the Statistical Properties of Elasticities:
A Correction.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>72</b>, 189&ndash;190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootCI">bootCI</a></code>, <code><a href="#topic+dbchoice">dbchoice</a></code>, <code><a href="#topic+sbchoice">sbchoice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in dbchoice and sbchoice.
</code></pre>

<hr>
<h2 id='kristrom'>
The Kristr\&quot;om's nonparametric approach to analyze single-bounded dichotomous choice contingent valuation data
</h2><span id='topic+kristrom'></span><span id='topic+print.kristrom'></span>

<h3>Description</h3>

<p>This function analyzes single-bounded dichotomous choice contingent valuation (CV) data on the basis 
of the Kristr\&quot;om's nonparametric method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kristrom(formula, data, subset)

## S3 method for class 'kristrom'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kristrom_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the model structure.</p>
</td></tr>
<tr><td><code id="kristrom_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model formula.</p>
</td></tr>
<tr><td><code id="kristrom_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations.</p>
</td></tr>
<tr><td><code id="kristrom_+3A_x">x</code></td>
<td>
<p>an object of class <code>"kristrom"</code>.</p>
</td></tr>
<tr><td><code id="kristrom_+3A_digits">digits</code></td>
<td>
<p>a number of digits to display.</p>
</td></tr>
<tr><td><code id="kristrom_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>kristrom()</code> analyzes single-bounded dichotomous choice contingent 
valuation (CV) data on the basis of Kristr\&quot;om's nonparametric method (Kristr\&quot;om 1990).
</p>
<p>The argument <code>formula</code> defines the response variables and bid variables. 
The argument <code>data</code> is set as a data frame containing the variables in the model. 
</p>
<p>A typical structure of the formula for <code>kristrom()</code> is defined as follows:
</p>
<p><code>R1 ~ BD1</code>
</p>
<p>The formula consists of two parts. The first part, the left-hand side of the tilde sign 
(<code>~</code>), must contain the response variable (e.g., <code>R1</code>) for the suggested prices 
in the CV questions. The response variable contains <code>"Yes"</code> or <code>"No"</code> to the bid 
or <code>1</code> for <code>"Yes"</code> and <code>0</code> for <code>"No"</code>. The other part, which starts 
after the tilde sign, must contain a bid variable (e.g., <code>BD1</code>) containing suggested 
prices in the CV question.
</p>
<p>The structure of data set which assigned to the argument data is the same as that in case 
of <code>dbchoice()</code>. See <code><a href="#topic+dbchoice">dbchoice</a></code> for details in the data set structure.
</p>


<h3>Value</h3>

<p>The function <code>kristrom()</code> returns an object of S3 class <code>"kristrom"</code>. 
An object of <code>"kristrom"</code> is a list with the following components. 
</p>
<table role = "presentation">
<tr><td><code>tab.dat</code></td>
<td>
<p>a matrix describing the number of respondents who answered <code>"yes"</code> to CV question, 
total number of respondents, and ratio of respondents who answered <code>"yes"</code> among the total number of 
respondents for each value of the suggested bids.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the number of rows of <code>tab.dat</code>.</p>
</td></tr>
<tr><td><code>adj.p</code></td>
<td>
<p>a vector describing the probability of a yes-answer to the suggested bid, which is the same 
as the last column of <code>tab.dat</code>.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>unq.bid</code></td>
<td>
<p>a vector of the unique bids.</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>a matrix of the estimated Kristr\&quot;om's survival probabilities.</p>
</td></tr>
</table>
<p>The generic function <code>print()</code> is available for fitted model object of class <code>"kristrom"</code> 
and displays the estimated Kristr\&quot;om's survival probabilities. 
</p>
<p>The extractor function <code>summary()</code> is used to display the estimated Kristr\&quot;om's survival 
probabilities as well as three types of WTP estimates (Kaplan-Meier and Spearman-Karber mean, and median estimates). Note that the Spearman-Karber mean estimate is computed 
upto the X-intercept.
</p>
<p>A graph of the estimated empirical survival function is depicted by <code>plot()</code>. 
See <code><a href="#topic+plot.kristrom">plot.kristrom</a></code> for details. 
</p>
<p><code><a href="#topic+turnbull.sb">turnbull.sb</a></code> is an alternative nonparametric method for analyzing single-bounded 
dichotomous choice data. A parametric analysis can be done by <code><a href="#topic+sbchoice">sbchoice</a></code>.
</p>


<h3>References</h3>

<p>Croissant Y (2011).
<em><span class="pkg">Ecdat</span>: Data Sets for Econometrics,</em> 
<span class="rlang"><b>R</b></span> package version 0.1-6.1, 
<a href="https://CRAN.R-project.org/package=Ecdat">https://CRAN.R-project.org/package=Ecdat</a>.
</p>
<p>Kristr\&quot;om B (1990). 
&ldquo;A Non-Parametric Approach to the Estimation of Welfare 
Measures in Discrete Response Valuation Studies.&rdquo;
<em>Land Economics</em>, <b>66</b>(2), 135&ndash;139.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.kristrom">plot.kristrom</a></code>, <code><a href="Ecdat.html#topic+NaturalPark">NaturalPark</a></code>, 
<code><a href="#topic+turnbull.sb">turnbull.sb</a></code>, <code><a href="#topic+sbchoice">sbchoice</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples for kristrom() are also based on a data set NaturalPark in the package 
## Ecdat (Croissant 2011): so see the section Examples in the dbchoice() for details.
data(NaturalPark, package = "Ecdat")

## The variable answers are converted into a format that is suitable for the function 
## kristrom() as follows:
NaturalPark$R1 &lt;- ifelse(substr(NaturalPark$answers, 1, 1) == "y", 1, 0)

## The formula is defined as follows:
fmks &lt;- R1 ~ bid1

## The function kristrom() with the function fmks and the data frame NP 
## is executed as follows:
NPks &lt;- kristrom(fmks, data = NaturalPark)
NPks
NPkss &lt;- summary(NPks)
NPkss
plot(NPks)
</code></pre>

<hr>
<h2 id='oohbchoice'>Parametric approach to analyze one-and-one-half-bound dichotomous choice contingent valuation data</h2><span id='topic+oohbchoice'></span>

<h3>Description</h3>

<p>This function analyzes one-and-one-half-bound dichotomous choice contingent 
valuation (CV) data on the basis of the utility difference approach.</p>


<h3>Usage</h3>

<pre><code class='language-R'>oohbchoice(formula, data, subset, na.action = na.omit, dist = "log-logistic",
           par = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oohbchoice_+3A_formula">formula</code></td>
<td>
<p>an object of S3 class <code>"Formula"</code> and specifies the model structure.</p>
</td></tr>
<tr><td><code id="oohbchoice_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model formula.</p>
</td></tr>
<tr><td><code id="oohbchoice_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations.</p>
</td></tr>
<tr><td><code id="oohbchoice_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contains <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="oohbchoice_+3A_dist">dist</code></td>
<td>
<p>a character string setting the error distribution in the model, which 
takes one of <code>"logistic"</code>, <code>"normal"</code>, <code>"log-logistic"</code>, 
<code>"log-normal"</code> or <code>"weibull"</code>.</p>
</td></tr>
<tr><td><code id="oohbchoice_+3A_par">par</code></td>
<td>
<p>a vector of initial parameters over which the optimization is carried out.</p>
</td></tr>
<tr><td><code id="oohbchoice_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One-and-one-half-bound dichotomous choice contingent valuation (OOHBDC-CV), which was developed by Cooper et al. (2002), is an intermediate CV format between single-bounded dichotomous choice (SBDC) CV format and double-bounded dichotomous choice (DBDC) CV format. 
</p>
<p>On the basis of an example of environmental valuation study, we will explain differences in question format among SBDC-CV, DBDC-CV, and OOHBDC-CV below.
</p>
<p>In any of three CV surveys, two situations are firstly explained to the respondents: the current situation and the improved situation where an environmental improvement plan is assumed to be implemented. Question following the explanation of situations differs according to CV types.
</p>
<p>In an SBDC-CV survey, after the explanation of situation mentioned above, the respondents are asked whether they would be willing to pay a certain amount of money toward the implementation of the plan. Therefore, there are two possible responses to the SBDC-CV survey: &quot;yes (agree),&quot; and &quot;no (disagree).&quot; The amounts (bids) that respondents are requested to contribute toward the plan are listed in advance. Each respondent is requested to answer a question randomly assigned with one of the listed bids. 
</p>
<p>In a DBDC-CV survey, the CV question consists of two stages: after answering the SBDC-CV style question mentioned above (the first stage), the respondents are also asked to answer an additional SBDC-CV style question (the second stage). The bid in the second stage varies according the response in the first stage: a higher bid is displayed in the second stage if the response in the first stage is &quot;yes,&quot; whereas a lower bid is displayed when the response in the first stage is &quot;no.&quot; Therefore, there are four possible responses to the DBDC-CV survey: &quot;yes-yes&quot; (&quot;yes&quot; in the both stages), &quot;yes-no&quot; (&quot;yes&quot; and &quot;no&quot; in the first and second stages, respectively), &quot;no-yes&quot; (&quot;no&quot; and &quot;yes&quot; in the first and second stages, respectively), and &quot;no-no&quot; (&quot;no&quot; in the both stages).
</p>
<p>In the OOHBDC-CV survey, after answering the first SBDC-CV style question (the first stage), only respondents who satisfy certain conditions are requested to answer an additional SBDC-CV style question (the second stage). Details in the OOHBDC-CV survey are as follows:
Step 1) A list of bid ranges [BLj, BHj] (j = 1, 2, ..., J), where BLj &lt; BHj, are decided: i.e., [BL1, BH1], [BL2, BH2], ..., and [BLJ, BHJ]. 
Step 2) One of the bid ranges is randomly presented to respondents (e.g., a bid range of [BL3, BH3] for j = 3).
Step 3) One of the two bids presented to the respondents is selected randomly (i.e., BL3 or BH3 in the case of step 2 example) and then the respondents are asked whether they would be willing to pay the amount of the bid selected (the first stage).
Step 4) The respondents are asked to answer the second stage if they satisfy either condition: (a) their answer in the first stage is &quot;yes&quot; when the lower bid is presented in the first stage, or (b) their answer in the first stage is &quot;no&quot; when the higher bid is presented in the first stage. Therefore, there are six possible responses to the OOHBDC-CV survey: &quot;no&quot;, &quot;yes-no&quot;, and &quot;yes-yes&quot; when the lower bid is shown in the first stage; and &quot;yes&quot;, &quot;no-yes&quot;, and &quot;no-no&quot; when the higher bid is shown in the first stage. Refer to Cooper et al. (2002) for detailed explanation of OOHBDC-CV, including the example CV questions.
</p>
<p>The function <code>oohbchoice()</code> implements an analysis of OOHBDC-CV responses (data) on the basis of the utility difference approach (Hanemann, 1984). 
</p>
<p>The function returns an object of S3 class <code>oohbchoice</code> (see below for details), which inherits from an S3 class <code>dbchoice</code>. The generic functions for the S3 class <code>dbchoice</code> such as <code>print()</code>, <code>summary()</code>, <code>vcov()</code>, <code>logLik()</code>, <code>plot()</code>, and <code>update()</code>, are available for the S3 class <code>oohbchoice</code>. In addition, the two functions <code>krCI()</code> and <code>bootCI()</code> are available to compute the confidence intervals for the estimates of willingness-to-pays (WTPs): <code>krCI()</code> implements simulations to construct empirical distributions of the WTP, while <code>bootCI()</code> carries out nonparametric bootstrapping (see the package <span class="pkg">DCchoice</span> for details).
</p>
<p>Although <code>oohbchoice()</code> has six arguments, a basic generic call to <code>oohbchoice()</code> is given as follows:
</p>
<p><code>oohbchoice(formula, data, dist = "log-logistic")</code>
</p>
<p>The argument <code>formula</code> defines the response variables and covariates (see below for details on the formula). The argument <code>data</code> specifies the data frame containing the variables in the model. The argument <code>dist</code> sets the error distribution: one of <code>"logistic"</code>, <code>"normal"</code>, <code>"log-logistic"</code> (default value), <code>"log-normal"</code>, or <code>"weibull"</code> is available. The difference between normal and log-normal models or between logistic or log-logistic ones is how the bid variable is incorporated into the model to be estimated. For the Weibull model, the bid variable must be entered in the natural log. Therefore, the user must be careful in defining the model formula that is explained in details below. 
</p>
<p>A typical structure of the formula for <code>oohbchoice()</code> is defined as follows: 
</p>
<p><code>R1 + R2 ~ (the names of the covariates) | BL + BH</code>
</p>
<p>The formula is an object of S3 class <code>Formula</code> and specifies the model structure. It has to be written in a symbolic expression in R. The formula consists of three parts as follows.
</p>
<p>The first part, the left-hand side of the tilde sign (<code>~</code>), must contain the response variables for the suggested prices in the first and the second stage of CV questions. In the example below, <code>R1</code> denotes a binary or two-level factor response variable for a bid in the first stage and <code>R2</code> for a bid in the second stage. <code>R1</code> contains <code>yes</code> or <code>no</code> to the bid in the first stage or <code>1</code> for <code>yes</code> and <code>0</code> for <code>no</code>. <code>R2</code> contains <code>yes</code>, <code>no</code>, <code>none</code> to the bid in the second stage or <code>1</code> for <code>yes</code>, <code>0</code> for <code>no</code>, and <code>-9</code> for <code>none</code>. The value of <code>none</code> (<code>-9</code>) means that the respondents have no second stage: the respondents are asked to answer the second stage question only if they satisfy either condition: (a) they answer <code>yes</code> in the first stage when the lower bid is shown in the first stage, or (b) they answer <code>no</code> in the first stage when the higher bid is shown in the first stage.
</p>
<p>The covariates are defined in the second part of the formula in the place of (the names of the covariates). Each covariate is connected with the arithmetic operator <code>+</code> and (the names of the covariates) in the above syntax should be replaced with <code>var1 + var2</code> and the like. The plus sign is nothing to do with addition of the two variables in the symbolic expression. When the covariate contains only a constant term, a value of <code>1</code> is set as the covariate: <code>R1 + R2 ~ 1 | BL + BH</code> (see the examples section below) 
</p>
<p>The last part of the formula starts after the vertical bar (<code>|</code>). The names of the two variables (<code>BL</code> and <code>BH</code>) containing suggested lower and higher prices in OOHBDC-CV question are specified in this part. The two variables are also connected with the arithmetic operator (<code>+</code>). 
</p>
<p>According to the structure of the formula, a data set (data frame) consists of three parts. An example of the data set (first six rows) is as follows (<code>gender</code> and <code>age</code> are respondents' characteristics and assumed to be covariates): 
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>id</code> </td><td style="text-align: right;"> <code>R1</code>  </td><td style="text-align: right;">  <code>R2</code>  </td><td style="text-align: right;"> <code>gender</code> </td><td style="text-align: right;">    <code>age</code> </td><td style="text-align: right;">  <code>BL</code> </td><td style="text-align: right;">  <code>BH</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>1</code>  </td><td style="text-align: right;"> <code>no</code>  </td><td style="text-align: right;">  <code>none</code> </td><td style="text-align: right;">  <code>male</code> </td><td style="text-align: right;">    <code>51</code> </td><td style="text-align: right;">  <code>2000</code> </td><td style="text-align: right;">  <code>2500</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>2</code>  </td><td style="text-align: right;"> <code>yes</code> </td><td style="text-align: right;">  <code>no</code> </td><td style="text-align: right;">  <code>male</code> </td><td style="text-align: right;">    <code>30</code> </td><td style="text-align: right;">  <code>500</code> </td><td style="text-align: right;">  <code>1000</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>3</code>  </td><td style="text-align: right;"> <code>yes</code> </td><td style="text-align: right;">  <code>yes</code> </td><td style="text-align: right;">  <code>female</code> </td><td style="text-align: right;">  <code>25</code> </td><td style="text-align: right;">  <code>500</code> </td><td style="text-align: right;">  <code>1000</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>4</code>  </td><td style="text-align: right;"> <code>yes</code> </td><td style="text-align: right;">  <code>none</code> </td><td style="text-align: right;">  <code>male</code> </td><td style="text-align: right;">    <code>48</code> </td><td style="text-align: right;">  <code>1000</code> </td><td style="text-align: right;">  <code>1500</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>5</code>  </td><td style="text-align: right;"> <code>no</code>  </td><td style="text-align: right;">  <code>yes</code> </td><td style="text-align: right;">  <code>male</code> </td><td style="text-align: right;">    <code>60</code> </td><td style="text-align: right;">  <code>1000</code> </td><td style="text-align: right;"> <code>1500</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>6</code>  </td><td style="text-align: right;"> <code>no</code>  </td><td style="text-align: right;">  <code>no</code> </td><td style="text-align: right;">  <code>female</code> </td><td style="text-align: right;">  <code>34</code> </td><td style="text-align: right;">  <code>2500</code> </td><td style="text-align: right;">  <code>3000</code>
</td>
</tr>

</table>

<p>Respondent 1 faced a bid range [<code>2000</code>, <code>2500</code>]; respondents 2 and 3 faced a bid range [<code>500</code>, <code>1000</code>]; respondents 4 and 5 faced a bid range [<code>1000</code>, <code>1500</code>]; and respondent 6 faced [<code>2500</code>, <code>3000</code>]. Respondent 1 answered <code>no</code> in the first stage of CV question and had no the second stage; respondent 2 answered <code>yes</code> and <code>no</code> in the first and second stage, respectively; respondent 3 answered <code>yes</code> and <code>yes</code> in the both stages; respondent 4 answered <code>yes</code> in the first stage and had no the second stage; respondent 5 answered <code>no</code> and <code>yes</code> in the first and second stage; and respondent 6 answered <code>no</code> in the both stages.
</p>
<p>Note that <code>BL</code> and <code>BH</code> are NOT the first stage bid and the second stage bid, respectively. The function <code>oohbchoice()</code> understands which bids (<code>BL</code> and <code>BH</code>) are presented in the first stage and second stage, respectively, on the basis of values of variables <code>R1</code> and <code>R2</code>.
</p>
<p>Nonparametric analysis of OOHBDC-CV data can be done by <code><a href="#topic+turnbull.oohb">turnbull.oohb</a></code>. 
</p>


<h3>Value</h3>

<p>The function returns an S3 class object <code>oohbchoice</code>, which inherits from the S3 class <code>dbchoice</code>. See <code>dbchoice()</code> for the details on the S3 object <code>dbchoice</code>.
</p>


<h3>Acknowledgments</h3>

<p>We would like to thank Dr. Joseph C. Cooper and Dr. Giovanni Signorello for their kindness.
</p>


<h3>References</h3>

<p>Cooper JC, Hanemann M, Signorello G (2002).
&ldquo;One-and-one-half-bound dichotomous choice contingent valuation&rdquo;,
<em>The Review of Economics and Statistics</em>,
<b>84</b>, 742&ndash;750.
</p>
<p>Hanemann WM (1984).
&ldquo;Welfare Evaluations in Contingent Valuation Experiments with Discrete Responses&rdquo;,
<em>American Journal of Agricultural Economics</em>,
<b>66</b>(2), 332&ndash;341.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.dbchoice">summary.dbchoice</a></code>, <code><a href="#topic+oohbsyn">oohbsyn</a></code>, <code><a href="#topic+krCI">krCI</a></code>, <code><a href="#topic+bootCI">bootCI</a></code>, 
<code><a href="#topic+turnbull.oohb">turnbull.oohb</a></code>, <code><a href="Formula.html#topic+Formula">Formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See oohbsyn.
</code></pre>

<hr>
<h2 id='oohbsyn'>Synthetic data set for oohbchoice()</h2><span id='topic+oohbsyn'></span>

<h3>Description</h3>

<p>Dataset created artificially for the examples section of the function <code>oohbhoice()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oohbsyn)
</code></pre>


<h3>Format</h3>

<p>A data frame with 80 observations on the following variables.
</p>

<dl>
<dt>id</dt><dd><p>a vector of the identification number of the respondent.</p>
</dd>
<dt>gender</dt><dd><p>a vector containing the gender of the respondent, taking <code>male</code> or <code>female</code>.</p>
</dd>
<dt>age</dt><dd><p>a vector containing the age of the respondent.</p>
</dd>
<dt>BL</dt><dd><p>a vector of lower bid.</p>
</dd>
<dt>BH</dt><dd><p>a vector of higher bid.</p>
</dd>
<dt>R1</dt><dd><p>a vector of response to the first stage CV question, taking a value of <code>1</code> if the bid is accepted, and <code>0</code> otherwise.</p>
</dd>
<dt>R2</dt><dd><p>a vector of response to the second stage CV question, taking a value of <code>1</code> if the bid is accepted, <code>0</code> if the bid is not accepted, and <code>-9</code> if the respondent has no the second stage question.</p>
</dd>
</dl>
 


<h3>See Also</h3>

<p><code><a href="#topic+oohbchoice">oohbchoice</a></code>, <code><a href="#topic+turnbull.oohb">turnbull.oohb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Parametric model
data(oohbsyn)
oohb1 &lt;- oohbchoice(R1 + R2 ~ 1 | log(BL) + log(BH), data = oohbsyn)
summary(oohb1)
oohb2 &lt;- oohbchoice(R1 + R2 ~ age + gender | log(BL) + log(BH), data = oohbsyn)
summary(oohb2)

## Non-parametric model
oohb3 &lt;- turnbull.oohb(R1 + R2 ~ BL + BH, data = oohbsyn)
summary(oohb3)
plot(oohb3)
</code></pre>

<hr>
<h2 id='plot.dbchoice'>
Plotting dbchoice objects
</h2><span id='topic+plot.dbchoice'></span>

<h3>Description</h3>

<p>Plotting method for objects of class <code>"dbchoice"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbchoice'
plot(x, type = NULL, main = NULL, sub = NULL, xlab = NULL, 
ylab = NULL, lwd = NULL, lty = NULL, xlim = NULL, ylim = NULL, bid = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dbchoice_+3A_x">x</code></td>
<td>

<p>an object of class <code>"kristrom"</code>.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_type">type</code></td>
<td>

<p>type of plot.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_main">main</code></td>
<td>

<p>the main title of the plot. If unspecified, no main title is displayed.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_sub">sub</code></td>
<td>

<p>the sub-title of the plot. If unspecified, no sub-title is displayed.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_xlab">xlab</code></td>
<td>

<p>the x label of the plot. If missing, <code>xlab = "Bid"</code> is used. 
Setting <code>xlab = ""</code> displays no x label.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_ylab">ylab</code></td>
<td>

<p>the y label of the plot. If missing, <code>ylab = "Probability of selecting yes"</code> is 
used. Setting <code>ylab = ""</code> displays no y label.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_lwd">lwd</code></td>
<td>

<p>the line width for the plot. If missing, <code>lwd = 3</code> is used.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_lty">lty</code></td>
<td>

<p>the line type for the plot. If missing, <code>lty = 1</code> is used.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_xlim">xlim</code></td>
<td>

<p>the x limits of the plot.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_ylim">ylim</code></td>
<td>

<p>the y limits of the plot.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_bid">bid</code></td>
<td>

<p>the bid limits should be drawn. If missing, the minimum and maximum values of the bid
variable(s) in the original dataset is used.
</p>
</td></tr>
<tr><td><code id="plot.dbchoice_+3A_...">...</code></td>
<td>

<p>optional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>plot()</code> draws choice probabilities of yes according to 
the range of bid (covariates are set on average). Choice probabilities are 
calculated according to the relevant single-bounded dichotomous choice model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbchoice">dbchoice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in dbchoice.
</code></pre>

<hr>
<h2 id='plot.kristrom'>
Plotting <code>kristrom</code> objects
</h2><span id='topic+plot.kristrom'></span>

<h3>Description</h3>

<p>Plotting method for objects of class <code>"kristrom"</code>. The empirical survival curve 
is plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kristrom'
plot(x, main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
    lwd = NULL, lty = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.kristrom_+3A_x">x</code></td>
<td>
<p>an object of class <code>"kristrom"</code>.</p>
</td></tr>
<tr><td><code id="plot.kristrom_+3A_main">main</code></td>
<td>
<p>the main title of the plot. If unspecified, no main title is displayed.</p>
</td></tr>
<tr><td><code id="plot.kristrom_+3A_sub">sub</code></td>
<td>
<p>the sub-title of the plot. If unspecified, no sub-title is displayed.</p>
</td></tr>
<tr><td><code id="plot.kristrom_+3A_xlab">xlab</code></td>
<td>
<p>the x label of the plot. If missing, <code>xlab = "Bid"</code> is used. 
Setting <code>xlab = ""</code> displays no x label.</p>
</td></tr>
<tr><td><code id="plot.kristrom_+3A_ylab">ylab</code></td>
<td>
<p>the y label of the plot. If missing, <code>ylab = "Survival Probability"</code> is 
used. Setting <code>ylab = ""</code> displays no y label.</p>
</td></tr>
<tr><td><code id="plot.kristrom_+3A_lwd">lwd</code></td>
<td>
<p>the line width for the plot. If missing, <code>lwd = 3</code> is used.</p>
</td></tr>
<tr><td><code id="plot.kristrom_+3A_lty">lty</code></td>
<td>
<p>the line type for the plot. If missing, <code>lty = 1</code> is used.</p>
</td></tr>
<tr><td><code id="plot.kristrom_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+kristrom">kristrom</a></code>, <code><a href="#topic+summary.kristrom">summary.kristrom</a></code>
</p>

<hr>
<h2 id='plot.sbchoice'>
Plotting sbchoice objects
</h2><span id='topic+plot.sbchoice'></span>

<h3>Description</h3>

<p>Plotting method for objects of class <code>"sbchoice"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbchoice'
plot(x, type = NULL, main = NULL, sub = NULL, xlab = NULL, 
ylab = NULL, lwd = NULL, lty = NULL, xlim = NULL, ylim = NULL, bid = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sbchoice_+3A_x">x</code></td>
<td>

<p>an object of class <code>"kristrom"</code>.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_type">type</code></td>
<td>

<p>type of plot.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_main">main</code></td>
<td>

<p>the main title of the plot. If unspecified, no main title is displayed.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_sub">sub</code></td>
<td>

<p>the sub-title of the plot. If unspecified, no sub-title is displayed.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_xlab">xlab</code></td>
<td>

<p>the x label of the plot. If missing, <code>xlab = "Bid"</code> is used. 
Setting <code>xlab = ""</code> displays no x label.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_ylab">ylab</code></td>
<td>

<p>the y label of the plot. If missing, <code>ylab = "Probability of selecting yes"</code> is 
used. Setting <code>ylab = ""</code> displays no y label.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_lwd">lwd</code></td>
<td>

<p>the line width for the plot. If missing, <code>lwd = 3</code> is used.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_lty">lty</code></td>
<td>

<p>the line type for the plot. If missing, <code>lty = 1</code> is used.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_xlim">xlim</code></td>
<td>

<p>the x limits of the plot.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_ylim">ylim</code></td>
<td>

<p>the y limits of the plot.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_bid">bid</code></td>
<td>

<p>the bid limits should be drawn. If missing, the minimum and maximum values of the bid
variable(s) in the original dataset is used.
</p>
</td></tr>
<tr><td><code id="plot.sbchoice_+3A_...">...</code></td>
<td>

<p>optional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>plot()</code> draws choice probabilities of yes according to 
the range of bid (covariates are set on average).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbchoice">sbchoice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in sbchoice.
</code></pre>

<hr>
<h2 id='plot.turnbull'>
Plotting <code>turnbull</code> objects
</h2><span id='topic+plot.turnbull'></span>

<h3>Description</h3>

<p>Plotting method for objects of class <code>"turnbull"</code>. The empirical survival curve and confidence interval (if computed) are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'turnbull'
plot(x, main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
        lwd = NULL, lty = NULL, plotCI = FALSE, ltyCI = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.turnbull_+3A_x">x</code></td>
<td>
<p>an object of class <code>"turnbull"</code>.</p>
</td></tr>
<tr><td><code id="plot.turnbull_+3A_main">main</code></td>
<td>
<p>the main title of the plot. If unspecified, no main title is displayed.</p>
</td></tr>
<tr><td><code id="plot.turnbull_+3A_sub">sub</code></td>
<td>
<p>the sub-title of the plot. If unspecified, no sub-title is displayed.</p>
</td></tr>
<tr><td><code id="plot.turnbull_+3A_xlab">xlab</code></td>
<td>
<p>the x label of the plot. If missing, <code>xlab = "Bid"</code> is used. 
Setting <code>xlab = ""</code> displays no x label.</p>
</td></tr>
<tr><td><code id="plot.turnbull_+3A_ylab">ylab</code></td>
<td>
<p>the y label of the plot. If missing, <code>ylab = "Survival Probability"</code> is 
used. Setting <code>ylab = ""</code> displays no y label.</p>
</td></tr>
<tr><td><code id="plot.turnbull_+3A_lwd">lwd</code></td>
<td>
<p>the line width for the plot. If missing, <code>lwd = 3</code> is used.</p>
</td></tr>
<tr><td><code id="plot.turnbull_+3A_lty">lty</code></td>
<td>
<p>the line type for the plot. If missing, <code>lty = 1</code> is used.</p>
</td></tr>
<tr><td><code id="plot.turnbull_+3A_plotci">plotCI</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>x</code> contains the estimates of the confidence intervals, these are plotted along with the survival function.</p>
</td></tr>
<tr><td><code id="plot.turnbull_+3A_ltyci">ltyCI</code></td>
<td>
<p>a graphical parameter defining the line type of the confidence interval. By default, <code>ltyCI = 5</code> (dashed line).</p>
</td></tr>
<tr><td><code id="plot.turnbull_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+turnbull.sb">turnbull.sb</a></code>, <code><a href="#topic+turnbull.db">turnbull.db</a></code>, <code><a href="#topic+summary.turnbull">summary.turnbull</a></code>
</p>

<hr>
<h2 id='predict.dbchoice'>
Predicting model for dbchoice
</h2><span id='topic+predict.dbchoice'></span>

<h3>Description</h3>

<p>Predicting method for objects of class &quot;dbchoice&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbchoice'
predict(object, newdata = NULL, type = c("utility", "probability"), 
bid = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.dbchoice_+3A_object">object</code></td>
<td>

<p>an object of class &quot;dbchoice&quot;.
</p>
</td></tr>
<tr><td><code id="predict.dbchoice_+3A_newdata">newdata</code></td>
<td>

<p>a data frame containing new data to predict. If <code>NULL</code>, the original data is used.
</p>
</td></tr>
<tr><td><code id="predict.dbchoice_+3A_type">type</code></td>
<td>

<p>type of prediction (utility or probability).
</p>
</td></tr>
<tr><td><code id="predict.dbchoice_+3A_bid">bid</code></td>
<td>

<p>a bid design needed to predict with original data.
</p>
</td></tr>
<tr><td><code id="predict.dbchoice_+3A_...">...</code></td>
<td>

<p>optional arguments. Currently not in use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>predict()</code> for S3 object &quot;dbchoice&quot; calculates predicted values 
according to the fitted model that is included in <code>object</code>. The values are 
predicted with the original data used for fitting the model if <code>newdata = NULL</code>, 
otherwise with a new data assigned to <code>newdata</code>. There are two notes for 
<code>dbchoice()</code>: a bid design used for the fit must be assigned to <code>bid</code>, 
when predicting with the original data; the predicted values are calculated according 
to the relevant single-bounded dichotomous choice model, when predicting with a new 
data. See examples for details.
</p>
<p>The current function does not estimate standard errors of predicted values.
</p>


<h3>Value</h3>

<p>When <code>newdata = NULL</code> and <code>type = utility</code>, a matrix containing utility 
values under first (<code>f</code>), second upper (<code>u</code>), and second lower (<code>l</code>) bids 
is returned. When <code>newdata = NULL</code> and <code>type = probability</code>, a matrix 
containing probabilities of choosing Yes-Yes (<code>yy</code>), No-No (<code>nn</code>), Yes-No (<code>yn</code>), 
and No-Yes (<code>ny</code>) is returned. When a new data is assigned to <code>newdata</code>,
predictions are calculated according to the relevant single-bounded dichotomous choice 
model, and a vector containing utility values of choosing yes (<code>type = utility</code>) 
or probability of choosing yes (<code>type = probability</code>) is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbchoice">dbchoice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in dbchoice.
</code></pre>

<hr>
<h2 id='predict.sbchoice'>
Predicting model for sbchoice
</h2><span id='topic+predict.sbchoice'></span>

<h3>Description</h3>

<p>Predicting method for objects of class &quot;sbchoice&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbchoice'
predict(object, newdata = NULL, type = c("utility", "probability"), 
...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.sbchoice_+3A_object">object</code></td>
<td>

<p>an object of class &quot;sbchoice&quot;.
</p>
</td></tr>
<tr><td><code id="predict.sbchoice_+3A_newdata">newdata</code></td>
<td>

<p>a data frame containing new data to predict. If <code>NULL</code>, the original data is used.
</p>
</td></tr>
<tr><td><code id="predict.sbchoice_+3A_type">type</code></td>
<td>

<p>type of prediction (utility or probability).
</p>
</td></tr>
<tr><td><code id="predict.sbchoice_+3A_...">...</code></td>
<td>

<p>optional arguments. Currently not in use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>predict()</code> for S3 object &quot;sbchoice&quot; calculates predicted values 
according to the fitted model that is included in <code>object</code>. The values are 
predicted with the original data used for fitting the model if <code>newdata = NULL</code>, 
otherwise with a new data assigned to <code>newdata</code>.
</p>
<p>The current function does not estimate standard errors of predicted values.
</p>


<h3>Value</h3>

<p>When <code>newdata = NULL</code> and <code>type = utility</code>, a vector containing utility 
values of choosing Yes under bid values is returned. When <code>newdata = NULL</code> 
and <code>type = probability</code>, a vector containing probabilities of choosing Yes
is returned. When a new data is assigned to <code>newdata</code>, a vector containing 
utility values of choosing Yes (<code>type = utility</code>) or probability of 
choosing Yes (<code>type = probability</code>) under the new data is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbchoice">sbchoice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in sbchoice.
</code></pre>

<hr>
<h2 id='sbchoice'>Parametric approach to analyze single-bounded dichotomous choice contingent valuation data</h2><span id='topic+sbchoice'></span><span id='topic+print.sbchoice'></span><span id='topic+vcov.sbchoice'></span><span id='topic+logLik.sbchoice'></span>

<h3>Description</h3>

<p>This function analyzes single-bounded dichotomous choice contingent valuation (CV) data 
on the basis of the utility difference approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbchoice(formula, data, subset, na.action = na.omit, 
         dist = "log-logistic", ...)

## S3 method for class 'sbchoice'
print(x, digits = max(3, getOption("digits") - 1), ...)

## S3 method for class 'sbchoice'
vcov(object, ...)

## S3 method for class 'sbchoice'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sbchoice_+3A_formula">formula</code></td>
<td>
<p>an S3 class object <code>"formula"</code> and specifies the model structure.</p>
</td></tr>
<tr><td><code id="sbchoice_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model formula.</p>
</td></tr>
<tr><td><code id="sbchoice_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations.</p>
</td></tr>
<tr><td><code id="sbchoice_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contains <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="sbchoice_+3A_dist">dist</code></td>
<td>
<p>a character string setting the error distribution in the model, which takes one 
of <code>"logistic"</code>, <code>"normal"</code>, <code>"log-logistic"</code>, <code>"log-normal"</code> or 
<code>"weibull"</code>.</p>
</td></tr>
<tr><td><code id="sbchoice_+3A_x">x</code></td>
<td>
<p>an object of class <code>"sbchoice"</code>.</p>
</td></tr>
<tr><td><code id="sbchoice_+3A_digits">digits</code></td>
<td>
<p>a number of digits to display.</p>
</td></tr>
<tr><td><code id="sbchoice_+3A_object">object</code></td>
<td>
<p>an object of class <code>"dbchoice"</code>.</p>
</td></tr>
<tr><td><code id="sbchoice_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>sbchoice()</code> implements an analysis of single-bounded dichotomous choice 
contingent valuation (CV) data on the basis of the utility difference approach 
(Hanemann, 1984).
</p>
<p>The extractor function <code>summary()</code> is available for a <code>"sbchoice"</code> class object. 
See<br />
<code><a href="#topic+summary.sbchoice">summary.sbchoice</a></code> for details.
</p>
<p>There are two functions available for computing the confidence intervals for the estimates of WTPs. 
<code><a href="#topic+krCI">krCI</a></code> implements simulations to construct empirical distributions of the WTP while 
<code><a href="#topic+bootCI">bootCI</a></code> carries out nonparametric bootstrapping. 
</p>
<p>Most of the details of <code>sbchoice()</code> is the same as those of <code>dbchoice()</code>, a double-bounded 
analogue of <code>sbchoice</code>. See the section <strong>Details</strong> in <code><a href="#topic+dbchoice">dbchoice</a></code>. Differences between 
the two functions are as follows:
</p>

<ul>
<li><p> In the model formula, the first part contains only one response variable (e.g., <code>R1</code>) 
and the third part contains only one bid variable (e.g., <code>BD1</code>) because respondents are 
requested to answer a CV question in the single-bounded dichotomous choice CV. The following 
is a typical structure of the formula:<br />
<code>R1 ~ (the names of the covariates) | BD1</code>
</p>
</li>
<li><p> The function <code>sbchoice()</code> analyzes the responses to single-bounded dichotomous choice CV 
questions internally using the function <code>glm()</code> with the argument <br />
<code>family = binomial(link = "logit")</code><br /> 
or<br />
<code>family = binomial(link = "probit")</code>.<br />
When <code>dist = "weibull"</code>, optimization is carried out using the <code>optim()</code> function 
with a hard-coded log-likelihood function.
</p>
</li>
<li><p> Outputs from <code>sbchoice()</code> are slightly different from those from <code>dbchoice()</code> 
because the analysis in <code>sbchoice()</code> internally depends on the function <code>glm()</code> 
for the (log-) normal or (log-) logistic distributions. (see the <b>Value</b> section).
</p>
</li></ul>

<p>Nonparametric analysis of single-bounded dichotomous choice data can be done by <code><a href="#topic+turnbull.sb">turnbull.sb</a></code> 
or by <code><a href="#topic+kristrom">kristrom</a></code>. 
</p>


<h3>Value</h3>

<p>This function returns an object of S3 class <code>"sbchoice"</code> that is a list with the following components.
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of estimated coefficients.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>glm.out</code></td>
<td>
<p>a list of components returned from <code>glm()</code> with the data set and the formula. In case 
of the Weibull distribution, a list of components from the <code>optim()</code> is saved.</p>
</td></tr>
<tr><td><code>glm.null</code></td>
<td>
<p>a list of components returned from <code>glm()</code> with the data set and a formula 
containing only constant (null model). In case of the Weibull distribution, a list of 
components from the <code>optim()</code> is saved.</p>
</td></tr>
<tr><td><code>distribution</code></td>
<td>
<p>a character string showing the error distribution used.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>a number of observations.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>a named matrix of the covariates used in the model.</p>
</td></tr>
<tr><td><code>bid</code></td>
<td>
<p>a named matrix of the bids used in the model.</p>
</td></tr>
<tr><td><code>yn</code></td>
<td>
<p>a named matrix of the responses to the CV question used in the model.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the data matrix.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>terms</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>contrasts used for factors</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>levels used for factors</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bateman IJ, Carson RT, Day B, Hanemann M, Hanley N, Hett T, Jones-Lee M, Loomes
G, Mourato S, \&quot;Ozdemiro\=glu E, Pearce DW, Sugden R, Swanson J (eds.) (2002).
<em>Economic Valuation with Stated Preference Techniques: A Manual.</em> 
Edward Elger, Cheltenham, UK.
</p>
<p>Boyle KJ, Welsh MP, Bishop RC (1988).
&ldquo;Validation of Empirical Measures of Welfare Change: Comment.&rdquo;
<em>Land Economics</em>, <b>64</b>(1), 94&ndash;98.
</p>
<p>Carson RT, Hanemann WM (2005).
&ldquo;Contingent Valuation.&rdquo;
in KG M\&quot;aler, JR Vincent (eds.), <em>Handbook of Environmental Economics</em>. 
Elsevier, New York.
</p>
<p>Croissant Y (2011).
<em><span class="pkg">Ecdat</span>: Data Sets for Econometrics,</em> 
<span class="rlang"><b>R</b></span> package version 0.1-6.1, 
<a href="https://CRAN.R-project.org/package=Ecdat">https://CRAN.R-project.org/package=Ecdat</a>.
</p>
<p>Hanemann, WM (1984). 
&ldquo;Welfare Evaluations in Contingent Valuation Experiments with Discrete Responses&rdquo;,
<em>American Journal of Agricultural Economics</em>,
<b>66</b>(2), 332&ndash;341.
</p>
<p>Hanemann M, Kanninen B (1999).
&ldquo;The Statistical Analysis of Discrete-Response CV Data.&rdquo;, 
in IJ Bateman, KG Willis (eds.), 
<em>Valuing Environmental Preferences: Theory and Practice of the Contingent 
Valuation Methods in the US, EU, and Developing Countries</em>, 
302&ndash;441. 
Oxford University Press, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sbchoice">summary.sbchoice</a></code>, 
<code><a href="#topic+krCI">krCI</a></code>, <code><a href="#topic+bootCI">bootCI</a></code>, 
<code><a href="Ecdat.html#topic+NaturalPark">NaturalPark</a></code>, 
<code><a href="#topic+turnbull.sb">turnbull.sb</a></code>, <code><a href="#topic+kristrom">kristrom</a></code>
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>
<code><a href="#topic+dbchoice">dbchoice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples for sbchoice() are also based on a data set NaturalPark 
## in the package Ecdat (Croissant 2011): so see the section Examples 
## in the dbchoice() for details.
data(NaturalPark, package = "Ecdat")

## The variable answers are converted into a format that is suitable for 
## the function sbchoice() as follows:
NaturalPark$R1 &lt;- ifelse(substr(NaturalPark$answers, 1, 1) == "y", 1, 0)
NaturalPark$R2 &lt;- ifelse(substr(NaturalPark$answers, 2, 2) == "y", 1, 0)


## We assume that the error distribution in the model is a log-logistic; 
## therefore, the bid variables bid1 is converted into LBD1 as follows:
NaturalPark$LBD1 &lt;- log(NaturalPark$bid1)

## The utility difference function is assumed to contain covariates 
## (sex, age, and income) as well as the bid variable (LBD1) as follows 
## (R2 is not used because of single-bounded dichotomous choice CV format):
fmsb &lt;- R1 ~ sex + age + income | LBD1

## Not run: 
## The formula may be alternatively defined as
fmsb &lt;- R1 ~ sex + age + income | log(bid1)

## End(Not run)

## The function sbchoice() with the function fmsb and the data frame NP 
## is executed as follows:
NPsb &lt;- sbchoice(fmsb, data = NaturalPark)
NPsb
NPsbs &lt;- summary(NPsb)
NPsbs

## Not run: 
## Generic functions such as summary() and coefficients() work for glm.out
summary(NPsb$glm.out)
coefficients(NPsb$glm.out)

## The confidence intervals for these WTPs are calculated using the 
## function krCI() or bootCI() as follows:
krCI(NPsb)
bootCI(NPsb)
## The WTP of a female with age = 5 and income = 3 is calculated
## using function krCI() or bootCI() as follows:
krCI(NPsb, individual = data.frame(sex = "female", age = 5, income = 3))
bootCI(NPsb, individual = data.frame(sex = "female", age = 5, income = 3))

## End(Not run)

## The variable age and income are deleted from the fitted model, 
## and the updated model is fitted as follows:
update(NPsb, .~. - age - income |.)

## Respondents' utility and probability of choosing Yes under 
## the fitted model and original data are predicted as follows: 
head(predict(NPsb, type = "utility"))
head(predict(NPsb, type = "probability"))
## Utility and probability of choosing Yes for a female with age = 5 
## and income = 3 under bid = 10 are predicted as follows:
predict(NPsb, type = "utility",
    newdata = data.frame(sex = "female", age = 5, income = 3, LBD1 = log(10)))
predict(NPsb, type = "probability",
    newdata = data.frame(sex = "female", age = 5, income = 3, LBD1 = log(10)))

## Plot of probabilities of choosing yes is drawn as drawn as follows:
plot(NPsb)
## The range of bid can be limited (e.g., [log(10), log(20)]):
plot(NPsb, bid = c(log(10), log(20)))
</code></pre>

<hr>
<h2 id='spike-models'>Parametric approach to analyze dichotomous choice contingent valuation data on the basis of a simple spike model</h2><span id='topic+spike-models'></span><span id='topic+spike'></span><span id='topic+spike+20models'></span><span id='topic+sbspike'></span><span id='topic+oohbspike'></span><span id='topic+dbspike'></span><span id='topic+spikeCoef'></span><span id='topic+print.spike'></span><span id='topic+summary.spike'></span><span id='topic+print.summary.spike'></span><span id='topic+vcov.spike'></span><span id='topic+logLik.spike'></span><span id='topic+plot.spike'></span>

<h3>Description</h3>

<p>These functions implement a simple spike model analysis of single-, one-and-one-half-, and double-bounded dichotomous choice contingent valuation data using the maximum likelihood method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## for the single-bounded data
sbspike(formula, data, subset, na.action = na.omit, par = NULL, ...)

## for the one-and-one-half-bounded data
oohbspike(formula, data, subset, na.action = na.omit, par = NULL, ...)

## for the double-bounded data
dbspike(formula, data, subset, na.action = na.omit, par = NULL, ...)

## S3 method for class 'spike'
print(x, digits = max(3, getOption("digits") - 1), ...)

## S3 method for class 'spike'
summary(object, ...)

## S3 method for class 'summary.spike'
print(x, digits = max(3, getOption("digits") - 1), ...)

## S3 method for class 'spike'
logLik(object, ...)

## S3 method for class 'spike'
vcov(object, ...)

## S3 method for class 'spike'
plot(x, type = "l", main = NULL, sub = NULL, 
  xlab = "Bid", ylab = "Probability", lwd = 3, lty = 1, 
  xlim = c(0, max(x$bid)), ylim = c(0, 1), bid = c(0, max(x$bid)), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spike-models_+3A_formula">formula</code></td>
<td>
<p>an object of S3 class <code>'Formula'</code> specifying the model structure.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model formula.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contains <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_par">par</code></td>
<td>
<p>a vector of initial parameters over which the optimization is carried out.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_x">x</code>, <code id="spike-models_+3A_object">object</code></td>
<td>
<p>an object of class <code>'spike'</code>.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_digits">digits</code></td>
<td>
<p>the number of digits to display.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_type">type</code></td>
<td>
<p>type of plot.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_main">main</code></td>
<td>
<p>the main title of the plot. If unspecified, no main title is displayed.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_sub">sub</code></td>
<td>
<p>the sub-title of the plot. If unspecified, no sub-title is displayed.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_xlab">xlab</code></td>
<td>
<p>the x label of the plot. The default is <code>"Bid"</code>. </p>
</td></tr>
<tr><td><code id="spike-models_+3A_ylab">ylab</code></td>
<td>
<p>the y label of the plot. The default is <code>"Probability"</code>.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_lwd">lwd</code></td>
<td>
<p>the line width for the plot. The default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_lty">lty</code></td>
<td>
<p>the line type for the plot. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot. The default is <code>c(0, max(x$bid))</code>.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. The default is <code>c(0, 1)</code>.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_bid">bid</code></td>
<td>
<p>the bid limits that should be drawn. The default is <code>c(0, max(x$bid))</code>.</p>
</td></tr>
<tr><td><code id="spike-models_+3A_...">...</code></td>
<td>
<p>optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code><a href="#topic+sbspike">sbspike</a></code>, <code><a href="#topic+oohbspike">oohbspike</a></code>, and <code><a href="#topic+dbspike">dbspike</a></code> implement a spike model analysis of single-, one-and-one-half-, and double-bounded dichotomous choice contingent valuation (SB, OOHB, and DB DCCV) data, respectively. A simple spike model assumes a non-zero probability of zero willingness to pay (WTP) for a good/service and a zero probability of negative WTP. These functions are developed according to the original simplest spike model proposed by Kristr\&quot;om (1997) and its follow-up studies (i.e., Yoo and Kwak (2002) for DB DCCV and Kwak et al. (2013) for OOHB DCCV). These functions use a maximum likelihood methods to fit the models with the CV data.
</p>
<p>Since the usage of spike model functions <code><a href="#topic+sbspike">sbspike</a></code>, <code><a href="#topic+oohbspike">oohbspike</a></code>, and <code><a href="#topic+dbspike">dbspike</a></code> are similar to the un-spike (the ordinary) DCCV model functions <code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="#topic+oohbchoice">oohbchoice</a></code>, and <code><a href="#topic+dbchoice">dbchoice</a></code>, respectively, this help below explains only the differences in usage between the spike and ordinary model functions. We assume that you understand how to use the ordinary model functions <code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="#topic+oohbchoice">oohbchoice</a></code>, and <code><a href="#topic+dbchoice">dbchoice</a></code>. If you are unfamiliar with the ordinary model functions, please refer to helps for these at first.
</p>
<p>The first difference between the spike and ordinal model functions is that an argument <code>distribution</code> used in the ordinary model functions is not defined in the spike functions: the functions for spike models assume that the error distribution is only a logistic with a spike, and thus the other distributions (i.e., log-logistic, normal, log-normal, and Weibull) are not available to the spike model functions.
</p>
<p>The other difference is about an argument <code>formula</code>, which is assigned an object of the S3 class <code>'<a href="Formula.html#topic+Formula">Formula</a>'</code>. For a model formula for the ordinary model functions, the left-handed side of the tilde (<code>~</code>) contains only response variable(s) (i.e., the response to SB DCCV question, <code>R1</code>, for <code><a href="#topic+sbchoice">sbchoice</a></code>; the response to the first stage of OOHB/DB DCCV question, <code>R1</code>, and the second one, <code>R2</code>, for <code><a href="#topic+oohbchoice">oohbchoice</a></code> and <code><a href="#topic+dbchoice">dbchoice</a></code>), while it contains both the response variable(s) and spike variable for the spike model functions. The spike variable, <code>S</code>, which must be set in the second part (after the vertical bar [<code>|</code>]) of the left-handed side of the tilde, takes the value of <code>1</code> if the respondent has a positive WTP for a good specified in the DCCV question and <code>0</code> otherwise. See Kristr\&quot;om (1997) for a question to measure whether the respondent has a positive WTP or not. A typical structure of the formula for spike model functions consists of the following four parts:
</p>
<p>for <code>sbspike()</code>,
<code>R1 | S ~ &lt;the names of the covariates&gt; | BD1</code>
</p>
<p>for <code>dbspike()</code>,
<code>R1 + R2 | S ~ &lt;the names of the covariates&gt; | BD1 + BD2</code>
</p>
<p>and for <code>oohbspike()</code>,
<code>R1 + R2 | S ~ &lt;the names of the covariates&gt; | BL + BH</code>
</p>
<p>where <code>BD1</code> and <code>BD2</code> are variables containing suggested prices in the first and second stages of the SB/DB DCCV question; and <code>BL</code> and <code>BH</code> are variables containing suggested lower and higher prices in the OOHB DCCV question.
</p>
<p>According to the structure of the formula, a data set (data frame) consists of four parts. An example of the data set for <code><a href="#topic+dbspike">dbspike</a></code> is as follows (<code>sex</code>, <code>age</code>, and <code>income</code> are respondent characteristics and assumed to be covariates):
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>R1</code> </td><td style="text-align: right;"> <code>R2</code> </td><td style="text-align: right;"> <code>S</code> </td><td style="text-align: right;"> <code>sex</code> </td><td style="text-align: right;"> <code>age</code> </td><td style="text-align: right;"> <code>income</code> </td><td style="text-align: right;"> <code>BD1</code> </td><td style="text-align: right;"> <code>BD2</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Yes</code> </td><td style="text-align: right;"> <code>Yes</code> </td><td style="text-align: right;"> <code>1</code> </td><td style="text-align: right;"> <code>Male</code> </td><td style="text-align: right;"> <code>20</code> </td><td style="text-align: right;"> <code>Low</code> </td><td style="text-align: right;"> <code>100</code> </td><td style="text-align: right;"> <code>250</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Yes</code> </td><td style="text-align: right;"> <code>No</code> </td><td style="text-align: right;"> <code>0</code> </td><td style="text-align: right;"> <code>Male</code> </td><td style="text-align: right;"> <code>30</code> </td><td style="text-align: right;"> <code>Low</code> </td><td style="text-align: right;"> <code>500</code> </td><td style="text-align: right;"> <code>1000</code></td>
</tr>
<tr>
 <td style="text-align: right;">
  ... </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;"> </td><td style="text-align: right;">
</td>
</tr>

</table>

<p>The spike model functions fit the models with DCCV data using the function <code><a href="stats.html#topic+optim">optim</a></code> on the basis of the initial coefficients estimated from an un-spike (ordinary) binary logit model analysis of the response to the SB DCCV question, or the first-stage response to the OOHB/DB DCCV question. The binary logit model is estimated internally using the function <code><a href="stats.html#topic+glm">glm</a></code> with the argument <code>family = binomial(link = "logit")</code>.
</p>
<p>The spike model functions return an S3 <code>'spike'</code> class object. Various methods for the S3 <code>"spike"</code> class object are provided as follows: <code>print()</code> displays estimated coefficients; <code>summary()</code> extracts detailed information on the fitted model; <code>summary.print()</code> displays information extracted by <code>summary()</code>; <code>logLik()</code> extracts the value of a log-likelihood function at estimates; <code>vcov()</code> returns the variance-covariance matrix of the fitted model; and <code>plot()</code> draws an estimated survival distribution of the WTP according to the fitted model. These S3 methods correspond to those for the ordinary DCCV functions <code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="#topic+oohbchoice">oohbchoice</a></code>, and <code><a href="#topic+dbchoice">dbchoice</a></code>. Therefore, for details, see helps for the corresponding methods for ordinary DCCV functions. Note that the mean and median WTPs calculated by <code>summary()</code> for the spike model functions are defined as follows (see Kristr\&quot;om 1997): mean WTP = ln(1 + exp(A))/B if the parameter for a bid variable (B) is positive (A is the constant), and NA otherwise; median WTP = A/B if 1/(1 + exp(-A)) &lt; 0.5, and 0 otherwise. When covariates are included in the fitted model, the constant in the mean and median WTPs is replaced with <b>x'b</b>, where <b>x</b> is a row vector of covariates at the sample mean including the value of 1 for the constant, and <b>b</b> is a column vector of estimates for covariates including the constant. See Yoo and Kwak (2009), Kwak et al. (2013), and Lee et al. (2010) for SB, OOHB, and DB spike models with covariates, respectively. 
</p>
<p>The existing functions <code><a href="#topic+bootCI">bootCI</a></code> and <code><a href="#topic+krCI">krCI</a></code>, which compute the confidence intervals for the estimates of WTPs using non-parametric and parametric bootstrapping approaches respectively, were revised to handle an S3 <code>'spike'</code> class object. An existing function <code><a href="#topic+ct2df">ct2df</a></code> was also updated to handle a data set in contingency-table format for spike model functions.
</p>
<p>Furthermore, a new function <code><a href="#topic+spikeCoef">spikeCoef</a></code> was developed to estimate a spike for the fitted model as 1/(1 + exp(A)), where A is the constant. This function returns the estimated spike, its standard error, and the corresponding z- and p-values under the null hypothesis where the spike is zero. The standard error is calculated using the delta method. When covariates are included in the fitted model, the constant in the formula is replaced with <b>x'b</b> as the mean and median WTP calculations. See the examples below, for details.
</p>


<h3>Value</h3>

<p>These spike model functions return an S3 class object <code>'spike'</code>, which is a list with the following components.
</p>
<table role = "presentation">
<tr><td><code>f.stage</code></td>
<td>
<p>a list of components returned from the un-spike (ordinary) binary logit mode analysis using the function <code><a href="stats.html#topic+glm">glm</a></code> based on the responses to the SB DCCV question, or the first stage of the OOHB/DB DCCV question. If the argument <code>par</code> is not <code>NULL</code>, the supplied vector is returned.</p>
</td></tr>
<tr><td><code>optim.out</code></td>
<td>
<p>a list of components returned from the function <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of estimated coefficients.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>an estimate of the Hessian. See also Hessian in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>a value of the log likelihood at the estimates.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a logical code: <code>TRUE</code> means a successful convergence.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>a vector of two integers describing the number of calls to the object function and numerical gradient, respectively. See also counts in <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>a number of observations.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>a named matrix of the covariates used in the model.</p>
</td></tr>
<tr><td><code>bid</code></td>
<td>
<p>a named matrix of the bids used in the model.</p>
</td></tr>
<tr><td><code>yn</code></td>
<td>
<p>a named matrix of the responses to the SB DCCV question or the first and second stage of the OOHB/DB DCCV question used in the model.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the data matrix.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>terms.</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>contrasts used for factors.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>levels used for factors.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kristr\&quot;om B. (1997) Spike models in contingent valuation. <em>American Journal of Agricultural Economics</em> <b>79</b>: 1013&ndash;1023.
</p>
<p>Yoo S-H, Kwak S-J. (2002) Using a spike model to deal with zero response data from double bounded dichotomous choice contingent valuation surveys. <em>Applied Economics Letters</em> <b>9</b>: 929&ndash;932.
</p>
<p>Kwak S-J, Yoo S-H, Kim C-S. (2013) Measuring the willingness to pay for tap water quality improvements: results of a contingent valuation survey in Pusan. <em>Water</em> <b>5</b>: 1638&ndash;1652.
</p>
<p>Lee J-S, Yoo S-H, Kwak S-J. (2010) Public's willingness to pay for preventing climate change. <em>Applied Economics Letters</em> <b>17</b>: 619&ndash;622.
</p>
<p>Yoo S-H, Kwak S-Y. (2009) Willingness to pay for green electricity in Korea: a contingent valuation study. <em>Energy Policy</em> <b>37</b>: 5408&ndash;5416.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="#topic+oohbchoice">oohbchoice</a></code>, <code><a href="#topic+dbchoice">dbchoice</a></code>,
<code><a href="#topic+ct2df">ct2df</a></code>, <code><a href="#topic+krCI">krCI</a></code>, <code><a href="#topic+bootCI">bootCI</a></code>, 
<code><a href="#topic+CarsonSB">CarsonSB</a></code>, <code><a href="#topic+CarsonDB">CarsonDB</a></code>, <code><a href="#topic+oohbsyn">oohbsyn</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, 
<code><a href="Formula.html#topic+Formula">Formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example datasets were created by modifying CarsonSB, CarsonDB, and oohbsyn.

# Spike SB Example
sb &lt;- data.frame(
 bid = c(10, 30, 60, 120),
 y   = c(178, 138, 129, 88),
 ny  = c(56, 45, 50, 76),
 nn  = c(30, 84, 76, 93))
SB &lt;- ct2df(sb, bid1 = "bid", type = "single", spike = TRUE)
head(SB)
dim(SB)
SBout &lt;- sbspike(R1 | S ~ 1 | bid1, data = SB)
summary(SBout)
spikeCoef(SBout)
## Not run: 
krCI(SBout)
bootCI(SBout)
## End(Not run)
plot(SBout, main = "Spike SB model")

# Spike DB Example
db &lt;- data.frame(
 bidh = c(30, 60, 120),
 bid1 = c(10, 30, 60),
 bidl = c(5, 10, 30),
 yy   = c(119, 69, 54),
 yn   = c(59, 69, 75),
 ny   = c(8, 31, 25),
 nny  = c(47, 61, 35),
 nnn  = c(31, 37, 66))
DB &lt;- ct2df(x = db, type = "double", spike = TRUE)
head(DB)
dim(DB)
DBout &lt;- dbspike(R1 + R2 | S ~ 1 | bid1 + bid2, data = DB)
summary(DBout)
spikeCoef(DBout)
## Not run: 
krCI(DBout)
bootCI(DBout)
## End(Not run)
plot(DBout, main = "Spike DB model")

# Spike OOHB Example
oohb &lt;- data.frame(
 bidl = c(2, 4, 6, 8),
 bidh = c(4, 6, 8, 10),
 yy   = c(8, 6, 4, 2),
 yn   = c(1, 3, 1, 1),
 n_y  = c(1, 1, 4, 4),
 n_n  = c(0, 1, 1, 3),
 y    = c(7, 6, 3, 1),
 ny   = c(2, 2, 3, 1),
 nn_y = c(1, 1, 2, 5),
 nn_n = c(0, 0, 2, 3))
OOHB &lt;- ct2df(x = oohb, type = "oohb", spike = TRUE)
head(OOHB)
dim(OOHB)
OOHBout &lt;- oohbspike(R1 + R2 | S ~ 1 | BL + BH, data = OOHB)
summary(OOHBout)
spikeCoef(OOHBout)
## Not run: 
krCI(OOHBout)
bootCI(OOHBout)
## End(Not run)
plot(OOHBout, main = "Spike OOHB model")
</code></pre>

<hr>
<h2 id='summary.dbchoice'>
Summarizing <code>dbchoice</code> estimation
</h2><span id='topic+summary.dbchoice'></span><span id='topic+print.summary.dbchoice'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>"dbchoice"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbchoice'
summary(object, ...)

## S3 method for class 'summary.dbchoice'
print(x, digits = max(3, getOption("digits") - 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dbchoice_+3A_object">object</code></td>
<td>
<p>an object of class <code>"dbchoice"</code>.</p>
</td></tr>
<tr><td><code id="summary.dbchoice_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.dbchoice"</code>.</p>
</td></tr>
<tr><td><code id="summary.dbchoice_+3A_digits">digits</code></td>
<td>
<p>a number of digits to display.</p>
</td></tr>
<tr><td><code id="summary.dbchoice_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>summary.dbchoice()</code> computes and returns a list of summary
statistics of the fitted model in <code>object</code> of the <code>"dbchoice"</code> class. 
</p>
<p>Some of the values are printed up to certain decimal places. Actual values of 
individual components are displayed separately, for instance, by <code>summary(object)$coefficients</code>. 
See the <b>Value</b> section for a list of components.
</p>


<h3>Value</h3>

<p>In addition to those available in the <code>object</code> of the <code>"dbchoice"</code> class, 
the following list components are added.
</p>
<table role = "presentation">
<tr><td><code>medianWTP</code></td>
<td>
<p>the estimated median WTP.</p>
</td></tr>
<tr><td><code>meanWTP</code></td>
<td>
<p>the estimated mean WTP.</p>
</td></tr>
<tr><td><code>trunc.meanWTP</code></td>
<td>
<p>the estimated mean WTP truncated at the maximum bid.</p>
</td></tr>
<tr><td><code>adj.trunc.meanWTP</code></td>
<td>
<p>the truncated mean WTP with the adjustment of 
Boyle <em>et~al.</em>(1988).</p>
</td></tr>
<tr><td><code>LR.test</code></td>
<td>
<p>a vector containing the likelihood ratio test statistic, the degrees 
of freedom and the associated p-value. The null is that all the parameters on the explanatory variables other than constant and the bid variable are jointly zero.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>a table of estimates including their s.e., z-value, and p-value.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>information criterion (AIC and BIC).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Boyle KJ, Welsh MP, Bishop RC (1988).
&ldquo;Validation of Empirical Measures of Welfare Change: Comment.&rdquo;
<em>Land Economics</em>, <b>64</b>(1), 94&ndash;98.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbchoice">dbchoice</a></code>
</p>

<hr>
<h2 id='summary.kristrom'>
Summarizing the Kristr\&quot;om's nonparametric estimation of WTP
</h2><span id='topic+summary.kristrom'></span><span id='topic+print.summary.kristrom'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>"kristrom"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kristrom'
summary(object, digits = max(3, getOption("digits") - 1), ...)

## S3 method for class 'summary.kristrom'
print(x, digits = max(3, getOption("digits") - 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.kristrom_+3A_object">object</code></td>
<td>
<p>an object of class <code>"kristrom"</code>.</p>
</td></tr>
<tr><td><code id="summary.kristrom_+3A_x">x</code></td>
<td>
<p>an object of class <code>"kristrom"</code>.</p>
</td></tr>
<tr><td><code id="summary.kristrom_+3A_digits">digits</code></td>
<td>
<p>a number of digits to display.</p>
</td></tr>
<tr><td><code id="summary.kristrom_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.kristrom">plot.kristrom</a></code>, <code><a href="#topic+kristrom">kristrom</a></code>, 
<code><a href="Ecdat.html#topic+NaturalPark">NaturalPark</a></code>, <code><a href="#topic+sbchoice">sbchoice</a></code> 
</p>

<hr>
<h2 id='summary.sbchoice'>
Summarizing <code>sbchoice</code> estimation
</h2><span id='topic+summary.sbchoice'></span><span id='topic+print.summary.sbchoice'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>sbchoice</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbchoice'
summary(object, ...)

## S3 method for class 'summary.sbchoice'
print(x, digits = max(3, getOption("digits") - 1), ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sbchoice_+3A_object">object</code></td>
<td>
<p>an object of class <code>"sbchoice"</code>.</p>
</td></tr>
<tr><td><code id="summary.sbchoice_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.sbchoice"</code>.</p>
</td></tr>
<tr><td><code id="summary.sbchoice_+3A_digits">digits</code></td>
<td>
<p>a number of digits to display.</p>
</td></tr>
<tr><td><code id="summary.sbchoice_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>summary.sbchoice()</code> computes and returns a list of summary
statistics of the fitted model in <code>object</code> of the <code>"sbchoice"</code> class. 
</p>
<p>Some of the values are printed up to certain decimal places. Actual values of 
individual components are displayed separately, for instance, by <code>summary(object)$coefficients</code>. 
See the <b>Value</b> section for a list of components.
</p>
<p>Since the model for the single-bounded dichotomous choice CV data is estimated by <code><a href="stats.html#topic+glm">glm</a></code>, 
an object of class<br />
<code>"summary.sbchoice"</code> is constructed based on a <code>"summary.glm"</code> 
class object. The summary of the <code>"summary.glm"</code> class object is available by 
<code>summary(object)$glm.summary</code>. Other components computed by 
<code><a href="stats.html#topic+summary.glm">summary.glm</a></code> are also accessible. See <code><a href="stats.html#topic+summary.glm">summary.glm</a></code> 
for details.
</p>


<h3>Value</h3>

<p>In addition to those available in the <code>object</code> of the <code>"sbchoice"</code> class, 
the following list components are added.
</p>
<table role = "presentation">
<tr><td><code>glm.summary</code></td>
<td>
<p>a summary of the <code>glm</code> estimation. It is an object of class 
<code>"summary.glm"</code>.</p>
</td></tr>
<tr><td><code>glm.null.summary</code></td>
<td>
<p>a summary of the <code>glm</code> estimation of the null model 
(i.e., only with the intercept). It is an object of class <code>"summary.glm"</code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the value of the log-likelihood of the model.</p>
</td></tr>
<tr><td><code>loglik.null</code></td>
<td>
<p>the value of the log-likelihood of the null model.</p>
</td></tr>
<tr><td><code>psdR2</code></td>
<td>
<p>McFadden's pseudo-R2 measure.</p>
</td></tr>
<tr><td><code>adjpsdR2</code></td>
<td>
<p>McFadden's pseudo-R2 measure adjusted for the degrees of freedom.</p>
</td></tr>
<tr><td><code>medianWTP</code></td>
<td>
<p>the estimated median WTP.</p>
</td></tr>
<tr><td><code>meanWTP</code></td>
<td>
<p>the estimated mean WTP.</p>
</td></tr>
<tr><td><code>trunc.meanWTP</code></td>
<td>
<p>the estimated mean WTP truncated at the maximum bid.</p>
</td></tr>
<tr><td><code>adj.trunc.meanWTP</code></td>
<td>
<p>the truncated mean WTP with the adjustment of 
Boyle <em>et~al.</em>(1988).</p>
</td></tr>
<tr><td><code>LR.test</code></td>
<td>
<p>a vector containing the likelihood ratio test statistic, the degrees 
of freedom and the associated p-value.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>information criterion (AIC and BIC).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Boyle KJ, Welsh MP, Bishop RC (1988).
&ldquo;Validation of Empirical Measures of Welfare Change: Comment.&rdquo;
<em>Land Economics</em>, <b>64</b>(1), 94&ndash;98.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+summary.glm">summary.glm</a></code>
</p>

<hr>
<h2 id='summary.turnbull'>
Summarizing the Kaplan-Meier-Turnbull nonparametric estimation of WTP
</h2><span id='topic+summary.turnbull'></span><span id='topic+print.summary.turnbull'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>"turnbull"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'turnbull'
summary(object, printCI = TRUE, ...)

## S3 method for class 'summary.turnbull'
print(x, digits = max(3, getOption("digits") - 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.turnbull_+3A_object">object</code></td>
<td>
<p>an object of class <code>"turnbull"</code>.</p>
</td></tr>
<tr><td><code id="summary.turnbull_+3A_printci">printCI</code></td>
<td>
<p>an argument controlling whether the summary of confidence interval estimates are printed. The CIs are not summarized and printed unless <code>conf.int = TRUE</code> in <code>turnbull.sb</code> or <code>turnbull.db</code>. </p>
</td></tr>
<tr><td><code id="summary.turnbull_+3A_x">x</code></td>
<td>
<p>an object of class <code>"turnbull"</code>.</p>
</td></tr>
<tr><td><code id="summary.turnbull_+3A_digits">digits</code></td>
<td>
<p>a number of digits to display.</p>
</td></tr>
<tr><td><code id="summary.turnbull_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>

<hr>
<h2 id='turnbull'>The Kaplan-Meier-Turnbull nonparametric approach to analyze dichotomous choice contingent valuation data</h2><span id='topic+turnbull.db'></span><span id='topic+turnbull.sb'></span><span id='topic+turnbull.oohb'></span><span id='topic+print.turnbull'></span>

<h3>Description</h3>

<p>This function analyzes single-, one-and-one-half-, or double-bounded dichotomous choice contingent valuation (CV) 
data on the basis of the Kaplan-Meier-Turnbull method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## for the single-bounded data
turnbull.sb(formula, data, subset, conf.int = FALSE, B = 200, 
            conf.level = 0.95, timeMessage = FALSE, seed = 19439101, ...)

## for the one-and-one-half-bound data
turnbull.oohb(formula, data, subset, conf.int = FALSE, B = 200, 
              conf.level = 0.95, timeMessage = FALSE, seed = 19439101, ...)


## for the double-bounded data
turnbull.db(formula, data, subset, conf.int = FALSE, B = 200, 
            conf.level = 0.95, timeMessage = FALSE, seed = 19439101, ...)

## S3 method for class 'turnbull'
print(x, digits = max(3, getOption("digits") - 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turnbull_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the model structure.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model formula.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_x">x</code></td>
<td>
<p>an object of class <code>"turnbull"</code>.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_conf.int">conf.int</code></td>
<td>
<p>logical. If <code>TRUE</code>, the confidence intervals are computed.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_b">B</code></td>
<td>
<p>number of bootstrap resampling for confidence interval estimation. Defaulted to 200.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_conf.level">conf.level</code></td>
<td>
<p>a confidence coefficient. Defaulted to 0.95.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_timemessage">timeMessage</code></td>
<td>
<p>logical. If <code>TRUE</code>, the estimated time for bootstrapping is displayed.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_digits">digits</code></td>
<td>
<p>a number of digits to display.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_seed">seed</code></td>
<td>
<p>a seed for a random number generator.</p>
</td></tr>
<tr><td><code id="turnbull_+3A_...">...</code></td>
<td>
<p>optional arguments. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>turnbull.sb()</code>, <code>turnbull.oohb()</code>, and <code>turnbull.db()</code> analyze single-,  
one-and-one-half-, and double-bounded dichotomous choice contingent valuation (CV) data, respectively, on 
the basis of the modified Kaplan-Meier-Turnbull method (Carson and Steinberg, 1990).
</p>
<p><strong>For single-bounded dichotomous choice data</strong><br />
Most of the details of <code>turnbull.sb()</code> is the same as those of <code>turnbull.db()</code>. 
See the subsequent section for details. 
</p>
<p>A difference between <code>turnbull.sb()</code> and <code>turnbull.db()</code> appears in the 
definition of the model formula. In <code>turnbull.sb()</code>, the first part contains 
only one response variable (e.g., <code>R1</code>) and the other part contains only one 
bid variable (e.g., <code>BD1</code>) because respondents are requested to answer a CV 
question in the single-bounded dichotomous choice CV. A typical structure of the 
formula is given by
</p>
<p><code>R1 ~ BD1</code>
</p>
<p><code><a href="#topic+kristrom">kristrom</a></code> is an alternative nonparametric method for analyzing single-bounded 
dichotomous choice data. A parametric analysis can be done by <code><a href="#topic+sbchoice">sbchoice</a></code>.
</p>
<p><strong>For one-and-one-half-bound dichotomous choice data</strong><br />
The details of <code>turnbull.oohb()</code> is the same as those of <code>turnbull.db()</code>.
See the the subsequent section for details.
</p>
<p>A difference between <code>turnbull.oohb()</code> and <code>turnbull.db()</code> appears in the
definition of variables. See <code><a href="#topic+oohbchoice">oohbchoice</a></code> and <code><a href="#topic+oohbsyn">oohbsyn</a></code> 
for the details of creating response and bid variables.  
</p>
<p><strong>For double-bounded dichotomous choice data</strong><br />
A generic call to <code>turnbull.db()</code> is given by
</p>
<p><code>turnbull.db(formula, data)</code>
</p>
<p>The argument <code>formula</code> defines the response variables and bid variables. The argument 
<code>data</code> is set as a data frame containing the variables in the model. 
</p>
<p>A typical structure of the formula for <code>turnbull.db()</code> is defined as follows:
</p>
<p><code>R1 + R2 ~ BD1 + BD2</code>
</p>
<p>The formula consists of two parts. The first part, the left-hand side of the 
tilde sign (<code>~</code>), must contain the response variables for the suggested 
prices in the first and the second stage of CV questions. In the above example, 
<code>R1</code> denotes a binary or two-level factor response variable for a bid in 
the first stage and <code>R2</code> for a bid in the second stage. Each of <code>R1</code> 
and <code>R2</code> contains <code>"Yes"</code> or <code>"No"</code> to the bid or <code>1</code> for 
<code>"Yes"</code> and <code>0</code> for <code>"No"</code>. 
The two variables are connected with the arithmetic operator (<code>+</code>). The other 
part, which starts after the tilde sign, must contain bid variables (<code>BD1</code>, 
<code>BD2</code>) containing suggested prices in the first and second stage of double-bounded 
dichotomous choice CV question. The two variables are also connected with the 
arithmetic operator (<code>+</code>).
</p>
<p>A parametric approach for analyzing double-bounded dichotomous choice data can be 
carried out by <code><a href="#topic+dbchoice">dbchoice</a></code>. 
</p>
<p>The structure of data set which assigned to the argument <code>data</code> is the same as that 
of <code>dbchoice()</code>. See <code><a href="#topic+dbchoice">dbchoice</a></code> for details in the data set structure.
</p>
<p>The confidence intervals are computed by the bootstrap method in <code><a href="interval.html#topic+icfit">icfit</a></code> of the <span class="pkg">interval</span> (Fay and Shaw, 2010) package. The arguments <code>conf.int</code>, <code>B</code>, <code>conf.level</code> and <code>timeMessage</code> are passed to <code>icfit()</code>. The bootstrap can be time consuming, so that it is in general not advisable to increase the number of bootstrap resamplint <code>B</code>. See the help of <code><a href="interval.html#topic+icfit">icfit</a></code> for futher detail.
</p>
<p>The generic function <code>print()</code> is available for a fitted model object 
of class <code>"turnbull"</code> and displays simply estimated probabilities of 
the distribution: this is the same as the element <code>pf</code> in the function 
<code><a href="interval.html#topic+icfit">icfit</a></code> of the <span class="pkg">interval</span> (Fay and Shaw, 2010) package.
</p>
<p>The extractor function <code>summary()</code> is also available for a fitted model 
object of class <code>"turnbull"</code> and the generic function <code>print.summary()</code> 
displays the survival probability and three types of WTP estimates (a Kaplan-Meier mean, 
a Spearman-Karber mean, and median WTPs). In estimating the two types of mean WTP, 
the area under the survivor function is truncated at the maximum bid because 
there seems no unified approach to determine an ending point of bids at which 
the acceptance probability is zero. Therefore, we leave the decision of how 
the area is treated to the user. In practice, once the ending point, 
$bid_end$, is found, it is straightforward to compute the triangular 
area by $0.5(bid_end - bid_max)P_max$ where $bid_max$ is 
the maximum bid and $P_max$ is the acceptance probability for 
$bid_max$, both of which are reported in the summarized output.
</p>
<p>Furthermore, the generic function <code>plot()</code> is available for a fitted model object 
of class <code>"turnbull"</code> and displays the empirical survival function. See 
<code><a href="#topic+plot.turnbull">plot.turnbull</a></code> for details.
</p>


<h3>Value</h3>

<p>Both <code>turnbull.db()</code> and <code>turnbull.sb()</code> return an object of S3 class 
<code>"turnbull"</code> that is a list with the following components.
</p>
<table role = "presentation">
<tr><td><code>left</code></td>
<td>
<p>a vector of left endpoints of censored interval. The vector is 
internally assigned to the argument <code>L</code> in <code>icfit()</code> of the 
<span class="pkg">interval</span> package.</p>
</td></tr>
<tr><td><code>right</code></td>
<td>
<p>a vector of right endpoints of censored interval. The vector is 
internally assigned to the argument <code>R</code> in <code>icfit()</code> of the 
<span class="pkg">interval</span> package.</p>
</td></tr>
<tr><td><code>turnbull</code></td>
<td>
<p>a list of components returned from <code>icfit()</code>.</p>
</td></tr>
<tr><td><code>unq.dib</code></td>
<td>
<p>a vector of unique bids including Inf.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>estimates for confidence intervals from <code>icfit()</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Croissant Y (2011).
<em><span class="pkg">Ecdat</span>: Data Sets for Econometrics,</em> 
<span class="rlang"><b>R</b></span> package version 0.1-6.1, 
<a href="https://CRAN.R-project.org/package=Ecdat">https://CRAN.R-project.org/package=Ecdat</a>.
</p>
<p>Fay MP, Shaw PA (2010).
&ldquo;Exact and Asymptotic Weighted Logrank Tests for Interval Censored Data: 
The <span class="pkg">interval</span> <span class="rlang"><b>R</b></span> Package&rdquo;, 
<em>Journal of Statistical Software</em>, 
<b>36</b>(2), 1-34. <a href="https://www.jstatsoft.org/v36/i02/">https://www.jstatsoft.org/v36/i02/</a>.
</p>
<p>Krinsky I, Robb AL (1986).
&ldquo;On Approximating the Statistical Properties of Elasticities.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>68</b>, 715&ndash;719.
</p>
<p>Krinsky I, Robb AL (1990).
&ldquo;On Approximating the Statistical Properties of Elasticities: 
A Correction.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>72</b>, 189&ndash;190.
</p>
<p>Turnbull BW (1976).
&ldquo;The Empirical Distribution Function with Arbitrarily 
Grouped, Censored and Truncated Data.&rdquo;
<em>Journal of the Royal Statistical Society. Series B</em>,
<b>38</b>(3), 290&ndash;295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.turnbull">summary.turnbull</a></code>, <code><a href="#topic+plot.turnbull">plot.turnbull</a></code>, <code><a href="#topic+kristrom">kristrom</a></code>, 
<code><a href="#topic+sbchoice">sbchoice</a></code>, <code><a href="#topic+dbchoice">dbchoice</a></code>, <code><a href="Ecdat.html#topic+NaturalPark">NaturalPark</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, 
<code><a href="interval.html#topic+icfit">icfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples are based on turnbull.db(). turnbull.sb() is similarly 
## implemented. A difference appears in the definition of the model 
## formula. See "Details" section of the help.

## A data set used here is NaturalPark in the package Ecdat (Croissant, 
## 2011): double-bounded dichotomous choice CV style question for 
## measuring willingness to pay for the preservation of the Alentejo 
## Natural Park. The data frame contains seven variables: bid1 (bid in 
## the initial question), bidh (higher bid in the follow-up question), 
## bidl (lower bid in the follow-up question), answers (response 
## outcomes in a factor format with four levels of "nn", "ny", "yn", "yy"), 
## respondents' characteristic variables such as age, sex and income (see 
## NaturalPark for details).
data(NaturalPark, package = "Ecdat")

## The variable answers are converted into a format that is suitable for 
## the function turnbull.db() as follows:
NaturalPark$R1 &lt;- ifelse(substr(NaturalPark$answers, 1, 1) == "y", 1, 0)
NaturalPark$R2 &lt;- ifelse(substr(NaturalPark$answers, 2, 2) == "y", 1, 0)

## The variables bidh and bidl are integrated into one variable (bid2) 
## as follows:
NaturalPark$bid2 &lt;- ifelse(NaturalPark$R1 == 1, NaturalPark$bidh, NaturalPark$bidl)

## The formula for turnbull.sb and turnbull.db are defined respectively as follows:
fmts &lt;- R1 ~ bid1
fmtd &lt;- R1 + R2 ~ bid1 + bid2

## The function turnbull.db() with the formula fmtd and the data frame 
## NaturalPark is executed as follows:
NPts &lt;- turnbull.sb(fmts, data = NaturalPark)
NPts
NPtss &lt;- summary(NPts)
NPtss
plot(NPts)


## The function turnbull.db() with the formula fmtd and the data frame 
## NaturalPark is executed as follows:
NPtd &lt;- turnbull.db(fmtd, data = NaturalPark)
NPtd
NPtds &lt;- summary(NPtd)
NPtds
plot(NPtd)
</code></pre>

<hr>
<h2 id='update.dbchoice'>
Updating and refitting model for dbchoice
</h2><span id='topic+update.dbchoice'></span>

<h3>Description</h3>

<p>Updating and refitting method for object of class &quot;dbchoice&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dbchoice'
update(object, new, evaluate = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.dbchoice_+3A_object">object</code></td>
<td>

<p>an object of class &quot;dbchoice&quot;.
</p>
</td></tr>
<tr><td><code id="update.dbchoice_+3A_new">new</code></td>
<td>

<p>a new call.
</p>
</td></tr>
<tr><td><code id="update.dbchoice_+3A_evaluate">evaluate</code></td>
<td>

<p>If <code>TRUE</code>, refit the updated model, otherwise return the updated call.
</p>
</td></tr>
<tr><td><code id="update.dbchoice_+3A_...">...</code></td>
<td>

<p>optional arguments. Currently not in use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>update()</code> for S3 object &quot;dbchoice&quot; updates a model used for 
the fit that is included in <code>object</code> according to a new call assigned to 
<code>new</code>, and then refits the updated model. The function returns the refitted 
model object when <code>evaluate = TRUE</code>, otherwise the updated model call.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbchoice">dbchoice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in dbchoice.
</code></pre>

<hr>
<h2 id='update.sbchoice'>
Updating and refitting model for sbchoice
</h2><span id='topic+update.sbchoice'></span>

<h3>Description</h3>

<p>Updating and refitting method for object of class &quot;sbchoice&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbchoice'
update(object, new, evaluate = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.sbchoice_+3A_object">object</code></td>
<td>

<p>an object of class &quot;sbchoice&quot;.
</p>
</td></tr>
<tr><td><code id="update.sbchoice_+3A_new">new</code></td>
<td>

<p>a new call.
</p>
</td></tr>
<tr><td><code id="update.sbchoice_+3A_evaluate">evaluate</code></td>
<td>

<p>If <code>TRUE</code>, refit the updated model, otherwise return the updated call.
</p>
</td></tr>
<tr><td><code id="update.sbchoice_+3A_...">...</code></td>
<td>

<p>optional arguments. Currently not in use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>update()</code> for S3 object &quot;sbchoice&quot; updates a model used for 
the fit that is included in <code>object</code> according to a new call assigned to 
<code>new</code>, and then refits the updated model. The function returns the refitted 
model object when <code>evaluate = TRUE</code>, otherwise the updated model call.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbchoice">sbchoice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See Examples in sbchoice.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
