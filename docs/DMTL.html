<!DOCTYPE html><html><head><title>Help for package DMTL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DMTL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#confined'><p>Restrict data in a given interval</p></a></li>
<li><a href='#dist_match'><p>Distribution Matching for Source and Reference Datasets</p></a></li>
<li><a href='#DMTL'><p>Distribution Mapping based Transfer Learning</p></a></li>
<li><a href='#EN_predict'><p>Predictive Modeling using Elastic Net</p></a></li>
<li><a href='#estimate_cdf'><p>Estimate Cumulative Distribution</p></a></li>
<li><a href='#match_func'><p>Estimate Inverse Mapping</p></a></li>
<li><a href='#norm_data'><p>Normalize matrix per column in [0, 1]</p></a></li>
<li><a href='#norm01'><p>Normalize vector in [0, 1]</p></a></li>
<li><a href='#performance'><p>Evaluate Regression Model Performance using Various Metrics</p></a></li>
<li><a href='#RF_predict'><p>Predictive Modeling using Random Forest Regression</p></a></li>
<li><a href='#SVM_predict'><p>Predictive Modeling using Support Vector Machine</p></a></li>
<li><a href='#zscore'><p>Standardize matrix per column</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Applying Distribution Mapping Based Transfer Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>
	Implementation of a transfer learning framework employing distribution mapping based domain transfer. Uses the renowned concept of histogram matching (see Gonzalez and Fittes (1977) &lt;<a href="https://doi.org/10.1016%2F0094-114X%2877%2990062-3">doi:10.1016/0094-114X(77)90062-3</a>&gt;, Gonzalez and Woods (2008) &lt;isbn:9780131687288&gt;) and extends it to include distribution measures like kernel density estimates (KDE; see Wand and Jones (1995) &lt;isbn:978-0-412-55270-0&gt;, Jones et al. (1996) &lt;doi:10.2307/2291420). In the typical application scenario, one can use the underlying sample distributions (histogram or KDE) to generate a map between two distinct but related domains to transfer the target data to the source domain and utilize the available source data for better predictive modeling design. Suitable for the case where a one-to-one sample matching is not possible, thus one needs to transform the underlying data distribution to utilize the more available data for modeling. </td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret (&ge; 6.0-86), glmnet (&ge; 4.1), kernlab (&ge; 0.9-29), ks
(&ge; 1.11.7), randomForest (&ge; 4.6-14)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dhruba018/DMTL">https://github.com/dhruba018/DMTL</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-17 19:05:38 UTC; SRDhruba</td>
</tr>
<tr>
<td>Author:</td>
<td>Saugato Rahman Dhruba
    <a href="https://orcid.org/0000-0001-5947-6757"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Souparno Ghosh [ctb],
  Ranadip Pal [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Saugato Rahman Dhruba &lt;dhruba018@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-18 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='confined'>Restrict data in a given interval</h2><span id='topic+confined'></span>

<h3>Description</h3>

<p>This function filters a data vector using a given interval so that only the
values falling inside the interval remains and any value that is less than
the leftmost end gets replaced by that end-value, and similarly, any value
greater than the rightmost end gets replaced by that end-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confined(x, lims = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confined_+3A_x">x</code></td>
<td>
<p>Vector containing data.</p>
</td></tr>
<tr><td><code id="confined_+3A_lims">lims</code></td>
<td>
<p>Limit for the values. Values falling within this limit will pass
without any change. Any value <code>x &lt; lims[1]</code> will get replaced by <code>lims[1]</code>,
and any value <code>x &gt; lims[2]</code> will get replaced by <code>lims[2]</code>. Defaults to
<code>c(0, 1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100, 0, 1)
x_filt &lt;- confined(x, lims = c(-0.5, 0.5))
print(range(x_filt))

</code></pre>

<hr>
<h2 id='dist_match'>Distribution Matching for Source and Reference Datasets</h2><span id='topic+dist_match'></span>

<h3>Description</h3>

<p>This function matches a source distribution to a given reference distribution
such that the data in the source space can effectively be transferred to the
reference space <em>i.e.</em> domain transfer <em>via</em> distribution matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_match(
  src,
  ref,
  src_cdf,
  ref_cdf,
  lims,
  density = FALSE,
  samples = 1e+06,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_match_+3A_src">src</code></td>
<td>
<p>Vector containing the source data to be matched.</p>
</td></tr>
<tr><td><code id="dist_match_+3A_ref">ref</code></td>
<td>
<p>Vector containing the reference data to estimate the reference
distribution for matching.</p>
</td></tr>
<tr><td><code id="dist_match_+3A_src_cdf">src_cdf</code></td>
<td>
<p>Vector containing source distribution values. If missing,
these values are estimated from the source data using <code>estimate_cdf()</code>.</p>
</td></tr>
<tr><td><code id="dist_match_+3A_ref_cdf">ref_cdf</code></td>
<td>
<p>Vector containing reference distribution values. If missing,
these values are estimated from the reference data using <code>estimate_cdf()</code>.</p>
</td></tr>
<tr><td><code id="dist_match_+3A_lims">lims</code></td>
<td>
<p>Vector providing the range of the knot values for mapping. If
missing, these values are estimated from the reference data.</p>
</td></tr>
<tr><td><code id="dist_match_+3A_density">density</code></td>
<td>
<p>Flag for using kernel density estimates for matching instead
of histogram counts. Defaults to <code>False</code>.</p>
</td></tr>
<tr><td><code id="dist_match_+3A_samples">samples</code></td>
<td>
<p>Sample size for estimating distributions if <code>src_cdf</code> and/or
<code>ref_cdf</code> are missing. Defaults to <code>1e6</code>.</p>
</td></tr>
<tr><td><code id="dist_match_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator (for reproducible outcomes).
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the matched values corresponding to <code>src</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(7531)
x1 &lt;- rnorm(100, 0.2, 0.6)
x2 &lt;- runif(200)
matched &lt;- dist_match(src = x1, ref = x2, lims = c(0, 1))

## Plot histograms...
opar &lt;- par(mfrow = c(1, 3))
hist(x1);    hist(x2);    hist(matched)
par(opar)              # Reset par

</code></pre>

<hr>
<h2 id='DMTL'>Distribution Mapping based Transfer Learning</h2><span id='topic+DMTL'></span>

<h3>Description</h3>

<p>This function performs distribution mapping based transfer learning (DMTL)
regression for given target (primary) and source (secondary) datasets. The
data available in the source domain are used to design an appropriate
predictive model. The target features with unknown response values are
transferred to the source domain <em>via</em> distribution matching and then the
corresponding response values in the source domain are predicted using the
aforementioned predictive model. The response values are then transferred to
the original target space by applying distribution matching again. Hence,
this function needs an <strong>unmatched</strong> pair of target datasets (features and
response values) and a <strong>matched</strong> pair of source datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DMTL(
  target_set,
  source_set,
  use_density = FALSE,
  pred_model = "RF",
  model_optimize = FALSE,
  sample_size = 1000,
  random_seed = NULL,
  all_pred = FALSE,
  get_verbose = FALSE,
  allow_parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DMTL_+3A_target_set">target_set</code></td>
<td>
<p>List containing the target datasets. A named list with
components <code>X</code> (predictors) and <code>y</code> (response). The predictions are performed
to estimate the response values corresponding to <code>X</code> while <code>y</code> is only used
to estimate the response distribution parameters.</p>
</td></tr>
<tr><td><code id="DMTL_+3A_source_set">source_set</code></td>
<td>
<p>List containing the source datasets. A named list with
components <code>X</code> (predictors) and <code>y</code> (response). These two sets must be matched
and used in both distribution estimation and predictive modeling.</p>
</td></tr>
<tr><td><code id="DMTL_+3A_use_density">use_density</code></td>
<td>
<p>Flag for using kernel density as distribution estimate
instead of histogram counts. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DMTL_+3A_pred_model">pred_model</code></td>
<td>
<p>String indicating the underlying predictive model. The
currently available options are -
</p>

<ul>
<li> <p><code>RF</code> for random forest regression. If <code>model_optimize = FALSE</code>, builds a
model with <code>n_tree = 200</code> and <code>m_try = 0.4</code>.
</p>
</li>
<li> <p><code>SVM</code> for support vector regression. If <code>model_optimize = FALSE</code>, builds a
model with <code>kernel = "poly"</code>, <code>C = 2</code>, and <code>degree = 3</code>.
</p>
</li>
<li> <p><code>EN</code> for elastic net regression. If <code>model_optimize = FALSE</code>, builds a
model with <code>alpha = 0.8</code> and <code>lambda</code> generated from a 5-fold cross
validation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="DMTL_+3A_model_optimize">model_optimize</code></td>
<td>
<p>Flag for model parameter tuning. If <code>TRUE</code>, performs a
grid search to optimize parameters and train with the resulting model.
If <code>FALSE</code>, uses a set of predefined parameters. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DMTL_+3A_sample_size">sample_size</code></td>
<td>
<p>Sample size for estimating distributions of target and
source datasets. Defaults to <code>1e3</code>.</p>
</td></tr>
<tr><td><code id="DMTL_+3A_random_seed">random_seed</code></td>
<td>
<p>Seed for random number generator (for reproducible
outcomes). Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="DMTL_+3A_all_pred">all_pred</code></td>
<td>
<p>Flag for returning the prediction values in the source space.
If <code>TRUE</code>, the function returns a named list with two components- <code>target</code>
and <code>source</code> (predictions in the target space and source space,
respectively). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DMTL_+3A_get_verbose">get_verbose</code></td>
<td>
<p>Flag for displaying the progress when optimizing the
predictive model <em>i.e.</em>, <code>model_optimize = TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DMTL_+3A_allow_parallel">allow_parallel</code></td>
<td>
<p>Flag for allowing parallel processing when performing
grid search <em>i.e.</em>, <code>model_optimimze = TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>all_pred = FALSE</code>, a vector containing the final prediction values.
</p>
<p>If <code>all_pred = TRUE</code>, a named list with two components <code>target</code> and <code>source</code>
<em>i.e.</em>, predictions in the original target space and in source space,
respectively.
</p>


<h3>Note</h3>


<ul>
<li><p> The datasets in <code>target_set</code> (<em>i.e.</em>, <code>X</code> and <code>y</code>) do not need to be
matched (<em>i.e.</em>, have the same number of rows) since the response values are
used only to estimate distribution for mapping while the feature values are
used for both mapping and final prediction. In contrast, the datasets in
<code>source_set</code> (<em>i.e.</em>, <code>X</code> and <code>y</code>) must have matched samples.
</p>
</li>
<li><p> It is recommended to normalize the two response values (<code>y</code>) so that
they will be in the same range. If normalization is not performed, <code>DMTL()</code>
uses the range of target <code>y</code> values as the prediction range.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(8644)

## Generate two dataset with different underlying distributions...
x1 &lt;- matrix(rnorm(3000, 0.3, 0.6), ncol = 3)
dimnames(x1) &lt;- list(paste0("sample", 1:1000), paste0("f", 1:3))
y1 &lt;- 0.3*x1[, 1] + 0.1*x1[, 2] - x1[, 3] + rnorm(1000, 0, 0.05)
x2 &lt;- matrix(rnorm(3000, 0, 0.5), ncol = 3)
dimnames(x2) &lt;- list(paste0("sample", 1:1000), paste0("f", 1:3))
y2 &lt;- -0.2*x2[, 1] + 0.3*x2[, 2] - x2[, 3] + rnorm(1000, 0, 0.05)

## Model datasets using DMTL &amp; compare with a baseline model...
library(DMTL)

target &lt;- list(X = x1, y = y1)
source &lt;- list(X = x2, y = y2)
y1_pred &lt;- DMTL(target_set = target, source_set = source, pred_model = "RF")
y1_pred_bl &lt;- RF_predict(x_train = x2, y_train = y2, x_test = x1)

print(performance(y1, y1_pred, measures = c("MSE", "PCC")))
print(performance(y1, y1_pred_bl, measures = c("MSE", "PCC")))

</code></pre>

<hr>
<h2 id='EN_predict'>Predictive Modeling using Elastic Net</h2><span id='topic+EN_predict'></span>

<h3>Description</h3>

<p>This function trains a Elastic Net regressor using the training data
provided and predict response for the test features. This implementation
depends on the <code>glmnet</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EN_predict(
  x_train,
  y_train,
  x_test,
  lims,
  optimize = FALSE,
  alpha = 0.8,
  seed = NULL,
  verbose = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EN_predict_+3A_x_train">x_train</code></td>
<td>
<p>Training features for designing the EN regressor.</p>
</td></tr>
<tr><td><code id="EN_predict_+3A_y_train">y_train</code></td>
<td>
<p>Training response for designing the EN regressor.</p>
</td></tr>
<tr><td><code id="EN_predict_+3A_x_test">x_test</code></td>
<td>
<p>Test features for which response values are to be predicted.
If <code>x_test</code> is not given, the function will return the trained model.</p>
</td></tr>
<tr><td><code id="EN_predict_+3A_lims">lims</code></td>
<td>
<p>Vector providing the range of the response values for modeling.
If missing, these values are estimated from the training response.</p>
</td></tr>
<tr><td><code id="EN_predict_+3A_optimize">optimize</code></td>
<td>
<p>Flag for model tuning. If <code>TRUE</code>, performs a grid search for
parameters. If <code>FALSE</code>, uses the parameters provided. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EN_predict_+3A_alpha">alpha</code></td>
<td>
<p>EN mixing parameter with <code class="reqn">0 \le \alpha \le 1</code>. <code>alpha = 1</code>
is the lasso penalty, and <code>alpha = 0</code> the ridge penalty. Defaults to <code>0.8</code>.
Valid only when <code>optimize = FALSE</code>.</p>
</td></tr>
<tr><td><code id="EN_predict_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator (for reproducible outcomes).
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="EN_predict_+3A_verbose">verbose</code></td>
<td>
<p>Flag for printing the tuning progress when <code>optimize = TRUE</code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="EN_predict_+3A_parallel">parallel</code></td>
<td>
<p>Flag for allowing parallel processing when performing grid
search <em>i.e.</em>, <code>optimimze = TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x_test</code> is missing, the trained EN regressor.
</p>
<p>If <code>x_test</code> is provided, the predicted values using the model.
</p>


<h3>Note</h3>

<p>The response values are filtered to be bound by range in <code>lims</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(86420)
x &lt;- matrix(rnorm(3000, 0.2, 1.2), ncol = 3);    colnames(x) &lt;- paste0("x", 1:3)
y &lt;- 0.3*x[, 1] + 0.1*x[, 2] - x[, 3] + rnorm(1000, 0, 0.05)

## Get the model only...
model &lt;- EN_predict(x_train = x[1:800, ], y_train = y[1:800], alpha = 0.6)

## Get predictive performance...
y_pred &lt;- EN_predict(x_train = x[1:800, ], y_train = y[1:800], x_test = x[801:1000, ])
y_test &lt;- y[801:1000]
print(performance(y_test, y_pred, measures = "RSQ"))

</code></pre>

<hr>
<h2 id='estimate_cdf'>Estimate Cumulative Distribution</h2><span id='topic+estimate_cdf'></span>

<h3>Description</h3>

<p>This function estimates the values of the cumulative distribution function
(CDF) for a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_cdf(
  x,
  bootstrap = TRUE,
  samples = 1e+06,
  density = FALSE,
  binned = TRUE,
  grids = 10000,
  unit_range = FALSE,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_cdf_+3A_x">x</code></td>
<td>
<p>Vector containing data.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Flag for performing bootstrapping on <code>x</code> to get a better
estimate of the CDF. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_samples">samples</code></td>
<td>
<p>Sample size for bootstrapping. Defaults to <code>1e6</code>. Ignored
when <code>bootstrap = FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_density">density</code></td>
<td>
<p>Flag for calculating kernel density estimates (KDE) instead
of histogram counts. Depends on the <code>ks</code> package for density estimation.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_binned">binned</code></td>
<td>
<p>Flag for calculating binned KDE. Defaults to <code>TRUE</code>. Ignored
when <code>density = FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_grids">grids</code></td>
<td>
<p>Size parameter for the estimation grid when <code>density = TRUE</code>.
Used to calculate the grid sizes for KDE bandwidth estimation (<code>grids*10</code>),
and grid size KDE estimation (<code>bgridsize = grids</code> if <code>binned = TRUE</code> else
<code>gridsize = grids/10</code>). Defaults to <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_unit_range">unit_range</code></td>
<td>
<p>Flag for unity data range (<em>i.e.</em>, data is normalized
between 0 and 1). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator (for reproducible outcomes).
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="estimate_cdf_+3A_...">...</code></td>
<td>
<p>Other options relevant for distribution estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>density = FALSE</code>, a function of class <code>ecdf</code>, inheriting from the
<code>stepfun</code> class, and hence inheriting a <code>knots()</code> method.
</p>
<p>If <code>density = TRUE</code>, an object of class <code>kcde</code> which has the fields
<code>eval.points</code> and <code>estimate</code> necessary for calculating a map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(100)
x_hist_cdf &lt;- estimate_cdf(x, samples = 1000, unit_range = TRUE)
x_kde_cdf &lt;- estimate_cdf(x, density = TRUE, unit_range = TRUE)

</code></pre>

<hr>
<h2 id='match_func'>Estimate Inverse Mapping</h2><span id='topic+match_func'></span>

<h3>Description</h3>

<p>This function estimates an inverse map <code class="reqn">g</code> for a given set of knots
(input) and values (output) corresponding to a certain map <code class="reqn">f</code> <em>i.e.</em>,
given <code class="reqn">x, y | f: x --&gt; y</code>, <code>match_func()</code> estimates <code class="reqn">g: y --&gt; x</code>
using linear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_func(knots, vals, new_vals, lims, get_func = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_func_+3A_knots">knots</code></td>
<td>
<p>Vector containing knots for the distribution estimate.</p>
</td></tr>
<tr><td><code id="match_func_+3A_vals">vals</code></td>
<td>
<p>Vector containing distribution values corresponding to the knots.</p>
</td></tr>
<tr><td><code id="match_func_+3A_new_vals">new_vals</code></td>
<td>
<p>Vector containing distribution values for which the knots
are unknown. If missing, <code>match_func()</code> simply returns the map function.</p>
</td></tr>
<tr><td><code id="match_func_+3A_lims">lims</code></td>
<td>
<p>Vector providing the range of the knot values for mapping. If
missing, these values are estimated from the given knots.</p>
</td></tr>
<tr><td><code id="match_func_+3A_get_func">get_func</code></td>
<td>
<p>Flag for returning the map function if <code>new_vals</code> is
provided. If <code>TRUE</code>, <code>match_func()</code> returns a named list with two components-
<code>mapped</code> and <code>func</code> (mapped knots for <code>new_vals</code> and the mapping function,
respectively). Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>new_vals</code> is missing, a function performing interpolation
(linear or constant) of the given data points.
</p>
<p>If <code>get_func = FALSE</code>, a vector containing the matched knots that will
produce <code>new_vals</code> for the map <code class="reqn">f</code>.
</p>
<p>If <code>get_func = TRUE</code>, a named list with two components- <code>mapped</code> and <code>func</code>
(mapped knots for <code>new_vals</code> and the mapping function, respectively).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
x &lt;- rnorm(100, 1, 0.5)
F &lt;- ecdf(x)
fval &lt;- F(x)
map &lt;- match_func(knots = x, vals = fval)

x2 &lt;- rnorm(20, 0.8, 0.5)
F2 &lt;- ecdf(x2)
fval2 &lt;- F2(x2)
matched &lt;- match_func(knots = x, vals = fval, new_vals = fval2)

## Plot histograms...
opar &lt;- par(mfrow = c(1, 3))
hist(x);    hist(x2);    hist(matched)
par(opar)              # Reset par

</code></pre>

<hr>
<h2 id='norm_data'>Normalize matrix per column in [0, 1]</h2><span id='topic+norm_data'></span>

<h3>Description</h3>

<p>This function normalizes each column of a dataframe or matrix (-alike)
between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_data(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_data_+3A_x">X</code></td>
<td>
<p>Dataframe or matrix (-alike) containing data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(1000, 0.2, 0.3), nrow = 100)
X_norm &lt;- norm_data(X)
print(range(X_norm))

</code></pre>

<hr>
<h2 id='norm01'>Normalize vector in [0, 1]</h2><span id='topic+norm01'></span>

<h3>Description</h3>

<p>This function normalizes a given vector between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm01(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm01_+3A_x">x</code></td>
<td>
<p>Vector containing data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100, 0.2, 0.3)
x_norm &lt;- norm01(x)
print(range(x_norm))

</code></pre>

<hr>
<h2 id='performance'>Evaluate Regression Model Performance using Various Metrics</h2><span id='topic+performance'></span>

<h3>Description</h3>

<p>This function produces the predictive performance for a regression model
using various common performance metrics such as MSE, R-squared, or
Correlation coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance(y_obs, y_pred, measures = c("NRMSE", "NMAE", "PCC"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performance_+3A_y_obs">y_obs</code></td>
<td>
<p>Observed response values</p>
</td></tr>
<tr><td><code id="performance_+3A_y_pred">y_pred</code></td>
<td>
<p>Predicted response values</p>
</td></tr>
<tr><td><code id="performance_+3A_measures">measures</code></td>
<td>
<p>Performance measures. One can specify a single measure or a
vector containing multiple measures in terms of common error or similarity
metrics. The available options are roughly divided into 3 categories -
</p>

<ul>
<li><p> &quot;MSE&quot;, &quot;RMSE&quot;, &quot;NRMSE&quot; for mean squared error, root mean squared error, and
normalized root mean squared error, respectively.
</p>
</li>
<li><p> &quot;MAE&quot;, &quot;NMAE&quot; for mean absolute error, and normalized mean absolute error,
respectively.
</p>
</li>
<li><p> &quot;PCC&quot;, &quot;SCC&quot;, &quot;RSQ&quot; for Pearson's correlation, Spearman's correlation, and
R-squared, respectively.
</p>
</li></ul>

<p>Defaults to <code>c("NRMSE", "NMAE", "PCC")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the performance metric values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
x &lt;- rnorm(1000, 0.2, 0.5)
y &lt;- x^2 + rnorm(1000, 0, 0.1)
y_fit &lt;- predict(lm(y ~ x))
print(performance(y, y_fit, measures = c("MSE", "RSQ")))

</code></pre>

<hr>
<h2 id='RF_predict'>Predictive Modeling using Random Forest Regression</h2><span id='topic+RF_predict'></span>

<h3>Description</h3>

<p>This function trains a Random Forest regressor using the training data
provided and predict response for the test features. This implementation
depends on the <code>randomForest</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RF_predict(
  x_train,
  y_train,
  x_test,
  lims,
  optimize = FALSE,
  n_tree = 300,
  m_try = 0.3333,
  seed = NULL,
  verbose = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RF_predict_+3A_x_train">x_train</code></td>
<td>
<p>Training features for designing the RF regressor.</p>
</td></tr>
<tr><td><code id="RF_predict_+3A_y_train">y_train</code></td>
<td>
<p>Training response for designing the RF regressor.</p>
</td></tr>
<tr><td><code id="RF_predict_+3A_x_test">x_test</code></td>
<td>
<p>Test features for which response values are to be predicted.
If <code>x_test</code> is not given, the function will return the trained model.</p>
</td></tr>
<tr><td><code id="RF_predict_+3A_lims">lims</code></td>
<td>
<p>Vector providing the range of the response values for modeling.
If missing, these values are estimated from the training response.</p>
</td></tr>
<tr><td><code id="RF_predict_+3A_optimize">optimize</code></td>
<td>
<p>Flag for model tuning. If <code>TRUE</code>, performs a grid search for
parameters. If <code>FALSE</code>, uses the parameters provided. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="RF_predict_+3A_n_tree">n_tree</code></td>
<td>
<p>Number of decision trees to be built in the forest. Defaults
to <code>300</code>. Valid only when <code>optimize = FALSE</code>.</p>
</td></tr>
<tr><td><code id="RF_predict_+3A_m_try">m_try</code></td>
<td>
<p>Fraction of the features to be used for building each tree.
Defaults to <code>0.3333</code> (or 33.33%). Valid only when <code>optimize = FALSE</code>.</p>
</td></tr>
<tr><td><code id="RF_predict_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator (for reproducible outcomes).
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="RF_predict_+3A_verbose">verbose</code></td>
<td>
<p>Flag for printing the tuning progress when <code>optimize = TRUE</code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="RF_predict_+3A_parallel">parallel</code></td>
<td>
<p>Flag for allowing parallel processing when performing grid
search <em>i.e.</em>, <code>optimimze = TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x_test</code> is missing, the trained RF regressor.
</p>
<p>If <code>x_test</code> is provided, the predicted values using the model.
</p>


<h3>Note</h3>

<p>The response values are filtered to be bound by range in <code>lims</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(86420)
x &lt;- matrix(rnorm(3000, 0.2, 1.2), ncol = 3);    colnames(x) &lt;- paste0("x", 1:3)
y &lt;- 0.3*x[, 1] + 0.1*x[, 2] - x[, 3] + rnorm(1000, 0, 0.05)

## Get the model only...
model &lt;- RF_predict(x_train = x[1:800, ], y_train = y[1:800], n_tree = 300)

## Get predictive performance...
y_pred &lt;- RF_predict(x_train = x[1:800, ], y_train = y[1:800], x_test = x[801:1000, ])
y_test &lt;- y[801:1000]
print(performance(y_test, y_pred, measures = "RSQ"))

</code></pre>

<hr>
<h2 id='SVM_predict'>Predictive Modeling using Support Vector Machine</h2><span id='topic+SVM_predict'></span>

<h3>Description</h3>

<p>This function trains a Support Vector Machine regressor using the training
data provided and predict response for the test features. This implementation
depends on the <code>kernlab</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVM_predict(
  x_train,
  y_train,
  x_test,
  lims,
  kernel = "rbf",
  optimize = FALSE,
  C = 2,
  kpar = list(sigma = 0.1),
  eps = 0.01,
  seed = NULL,
  verbose = FALSE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVM_predict_+3A_x_train">x_train</code></td>
<td>
<p>Training features for designing the SVM regressor.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_y_train">y_train</code></td>
<td>
<p>Training response for designing the SVM regressor.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_x_test">x_test</code></td>
<td>
<p>Test features for which response values are to be predicted.
If <code>x_test</code> is not given, the function will return the trained model.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_lims">lims</code></td>
<td>
<p>Vector providing the range of the response values for modeling.
If missing, these values are estimated from the training response.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_kernel">kernel</code></td>
<td>
<p>Kernel function for SVM implementation. The available options
are <code>linear</code>, <code>poly</code>, <code>rbf</code>, and <code>tanh</code>. Defaults to <code>rbf</code>.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_optimize">optimize</code></td>
<td>
<p>Flag for model tuning. If <code>TRUE</code>, performs a grid search for
parameters. If <code>FALSE</code>, uses the parameters provided. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_c">C</code></td>
<td>
<p>Cost of constraints violation. This is the constant &quot;C&quot; of the
regularization term in the Lagrange formulation. Defaults to <code>2</code>. Valid only
when <code>optimize = FALSE</code>.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_kpar">kpar</code></td>
<td>
<p>List of kernel parameters. This is a named list that contains
the parameters to be used with the specified kernel. The valid parameters
for the existing kernels are -
</p>

<ul>
<li> <p><code>sigma</code> for the radial basis (rbf) kernel. Note that this is the
<strong>inverse</strong> kernel width.
</p>
</li>
<li> <p><code>degree</code>, <code>scale</code>, <code>offset</code> for the polynomial kernel.
</p>
</li>
<li> <p><code>scale</code>, <code>offset</code> for the hyperbolic tangent kernel.
</p>
</li></ul>

<p>Valid only when <code>optimize = FALSE</code>. Defaults to <code>list(sigma = 0.1)</code>.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_eps">eps</code></td>
<td>
<p>The insensitive-loss function used for epsilon-SVR. Defaults to
<code>0.01</code>.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator (for reproducible outcomes).
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_verbose">verbose</code></td>
<td>
<p>Flag for printing the tuning progress when <code>optimize = TRUE</code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="SVM_predict_+3A_parallel">parallel</code></td>
<td>
<p>Flag for allowing parallel processing when performing grid
search <em>i.e.</em>, <code>optimimze = TRUE</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x_test</code> is missing, the trained SVM regressor.
</p>
<p>If <code>x_test</code> is provided, the predicted values using the model.
</p>


<h3>Note</h3>

<p>The response values are filtered to be bound by range in <code>lims</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(86420)
x &lt;- matrix(rnorm(3000, 0.2, 1.2), ncol = 3);    colnames(x) &lt;- paste0("x", 1:3)
y &lt;- 0.3*x[, 1] + 0.1*x[, 2] - x[, 3] + rnorm(1000, 0, 0.05)

## Get the model only...
model &lt;- SVM_predict(x_train = x[1:800, ], y_train = y[1:800], kernel = "rbf")

## Get predictive performance...
y_pred &lt;- SVM_predict(x_train = x[1:800, ], y_train = y[1:800], x_test = x[801:1000, ])
y_test &lt;- y[801:1000]
print(performance(y_test, y_pred, measures = "RSQ"))

</code></pre>

<hr>
<h2 id='zscore'>Standardize matrix per column</h2><span id='topic+zscore'></span>

<h3>Description</h3>

<p>This function standardized each column of a dataframe or matrix (-alike) to
have <code class="reqn">mean = 0</code> and <code class="reqn">sd = 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zscore(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zscore_+3A_x">X</code></td>
<td>
<p>Dataframe or matrix (-alike) containing data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The standardized dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(100, 0.2, 0.3), nrow = 20)
X_std &lt;- zscore(X)
print(apply(X_std, 2, mean))
print(apply(X_std, 2, sd))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
