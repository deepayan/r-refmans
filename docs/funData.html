<!DOCTYPE html><html><head><title>Help for package funData</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {funData}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.intWeights'><p>Calculate weights for numerical integration</p></a></li>
<li><a href='#.scalarProduct'><p>Generic method for scalar products, based on integrate</p></a></li>
<li><a href='#addError'><p>Add Gaussian white noise to functional data objects</p></a></li>
<li><a href='#addError,funData-method'><p>Add gaussian white noise to functional data</p></a></li>
<li><a href='#addError,multiFunData-method'><p>Add gaussian white noise to multivariate functional data</p></a></li>
<li><a href='#approxNA'><p>Approximate missing values for funData objects</p></a></li>
<li><a href='#approxNA,funData-method'><p>approxNA for funData objects</p></a></li>
<li><a href='#argvals'><p>Extract and set slots from functional data objects</p></a></li>
<li><a href='#argvals,funData-method'><p>Get argvals slot for funData objects</p></a></li>
<li><a href='#argvals,irregFunData-method'><p>Get argvals slot for irregular functional data objects</p></a></li>
<li><a href='#argvals,multiFunData-method'><p>Get argvals slot for multiFunData objects</p></a></li>
<li><a href='#argvals&lt;-,funData-method'><p>Set argvals slot for funData objects</p></a></li>
<li><a href='#argvals&lt;-,irregFunData-method'><p>Set argvals slot for irregular functional objects</p></a></li>
<li><a href='#argvals&lt;-,multiFunData-method'><p>Set argvals slot for multiFunData objects</p></a></li>
<li><a href='#Arith.funData'><p>Arithmetics for functional data objects</p></a></li>
<li><a href='#as.data.frame.funData'><p>Coerce functional data objects to a data.frame</p></a></li>
<li><a href='#as.funData'><p>Coerce an irregFunData object to class funData</p></a></li>
<li><a href='#as.irregFunData'><p>Coerce a funData object to class irregFunData</p></a></li>
<li><a href='#as.multiFunData'><p>Coerce a funData object to class multiFunData</p></a></li>
<li><a href='#autoplot.funData'><p>Visualize functional data objects using ggplot</p></a></li>
<li><a href='#autoplot.irregFunData'><p>Visualize irregular functional data objects using ggplot</p></a></li>
<li><a href='#autoplot.multiFunData'><p>Visualize multivariate functional data objects using ggplot</p></a></li>
<li><a href='#dimSupp'><p>Support dimension of functional data</p></a></li>
<li><a href='#dimSupp,funData-method'><p>dimSupp for funData objects</p></a></li>
<li><a href='#dimSupp,irregFunData-method'><p>dimSupp for irregular functional data objects</p></a></li>
<li><a href='#dimSupp,multiFunData-method'><p>dimSupp for multiFunData objects</p></a></li>
<li><a href='#efFourier'><p>Calculate the first M Fourier basis functions</p></a></li>
<li><a href='#efPoly'><p>Legendre Polynomials of degree 0,...,M-1</p></a></li>
<li><a href='#eFun'><p>Generate orthonormal eigenfunctions</p></a></li>
<li><a href='#efWiener'><p>Calculate the first M eigenfunctions of the Wiener process</p></a></li>
<li><a href='#eVal'><p>Generate a sequence of simulated eigenvalues</p></a></li>
<li><a href='#expand.int'><p>Function to expand integers to a grid of indices</p></a></li>
<li><a href='#extractObs'><p>Extract observations of functional data</p></a></li>
<li><a href='#extractObs,funData-method'><p>extractObs for funData objects</p></a></li>
<li><a href='#extractObs,irregFunData-method'><p>extractObs for irregular functional data</p></a></li>
<li><a href='#extractObs,multiFunData-method'><p>extractObs for multiFunData objects</p></a></li>
<li><a href='#extrapolateIrreg'><p>Extrapolate irregular functional data to a given domain</p></a></li>
<li><a href='#fd2funData'><p>Convert an fd object to funData</p></a></li>
<li><a href='#flipFuns'><p>Flip functional data objects</p></a></li>
<li><a href='#flipFuns,funData,funData-method'><p>Flip univariate functional data</p></a></li>
<li><a href='#flipFuns,funData,irregFunData-method'><p>Flip irregular functional data - funData as reference</p></a></li>
<li><a href='#flipFuns,irregFunData,irregFunData-method'><p>Flip irregular functional data - irregFunData as reference</p></a></li>
<li><a href='#flipFuns,multiFunData,multiFunData-method'><p>Flip multivariate functional data</p></a></li>
<li><a href='#funData-class'><p>A class for (univariate) functional data</p></a></li>
<li><a href='#funData-setAs'><p>Coerce a funData object to class multiFunData</p></a></li>
<li><a href='#funData2fd'><p>Convert a funData object to fd</p></a></li>
<li><a href='#ggplot'><p>ggplot Graphics for Functional Data Objects</p></a></li>
<li><a href='#integrate'><p>Integrate functional data</p></a></li>
<li><a href='#integrate,funData-method'><p>Integrate method for funData objects</p></a></li>
<li><a href='#integrate,irregFunData-method'><p>Integrate method for irregular functional data objects</p></a></li>
<li><a href='#integrate,multiFunData-method'><p>Integrate method for multiFunData objects</p></a></li>
<li><a href='#integrate3D'><p>Integrate a function on a rectangular 3D grid</p></a></li>
<li><a href='#irregFunData-class'><p>A class for irregularly sampled functional data</p></a></li>
<li><a href='#irregFunData-setAs'><p>Coerce an irregFunData object to class funData</p></a></li>
<li><a href='#Math.funData'><p>Mathematical operations for functional data objects</p></a></li>
<li><a href='#meanFunction'><p>Mean for functional data</p></a></li>
<li><a href='#meanFunction,funData-method'><p>Mean for functional data</p></a></li>
<li><a href='#meanFunction,irregFunData-method'><p>Mean for irregular functional data</p></a></li>
<li><a href='#meanFunction,multiFunData-method'><p>Mean for multivariate functional data</p></a></li>
<li><a href='#multiFunData-class'><p>A class for multivariate functional data</p></a></li>
<li><a href='#nObs'><p>Get the number of observations</p></a></li>
<li><a href='#nObs,funData-method'><p>nObs for funData objects</p></a></li>
<li><a href='#nObs,irregFunData-method'><p>nObs for irregular functional data objects</p></a></li>
<li><a href='#nObs,multiFunData-method'><p>nObs for multiFunData objects</p></a></li>
<li><a href='#nObsPoints'><p>Get the number of observation points</p></a></li>
<li><a href='#nObsPoints,funData-method'><p>nObsPoints for funData objects</p></a></li>
<li><a href='#nObsPoints,irregFunData-method'><p>nObsPoints for irregular functional data objects</p></a></li>
<li><a href='#nObsPoints,multiFunData-method'><p>nObsPoints for multiFunData objects</p></a></li>
<li><a href='#norm'><p>Calculate the norm of functional data</p></a></li>
<li><a href='#norm,funData,missing-method'><p>Calculate the norm for univariate functional data</p></a></li>
<li><a href='#norm,irregFunData,missing-method'><p>Calculate the norm for irregular functional data</p></a></li>
<li><a href='#norm,multiFunData,missing-method'><p>Calculate the norm for multivariate functional data</p></a></li>
<li><a href='#norm.funData'><p>Calculate the norm for univariate functional data</p></a></li>
<li><a href='#norm.irregFunData'><p>Calculate the norm for irregular functional data</p></a></li>
<li><a href='#plot.funData'><p>Plotting univariate functional data</p></a></li>
<li><a href='#plot.irregFunData'><p>Plotting irregular functional data</p></a></li>
<li><a href='#plot.multiFunData'><p>Plotting multivariate functional data</p></a></li>
<li><a href='#print.funData'><p>A print method for univariate functional data</p></a></li>
<li><a href='#print.irregFunData'><p>A print method for irregular functional data</p></a></li>
<li><a href='#scalarProduct'><p>Calculate the scalar product for functional data objects</p></a></li>
<li><a href='#scalarProduct,funData,funData-method'><p>Scalar product for functional data</p></a></li>
<li><a href='#scalarProduct,funData,irregFunData-method'><p>Scalar product for irregular and functional data</p></a></li>
<li><a href='#scalarProduct,irregFunData,funData-method'><p>Scalar product for irregular and functional data</p></a></li>
<li><a href='#scalarProduct,irregFunData,irregFunData-method'><p>Scalar product for irregular functional data</p></a></li>
<li><a href='#scalarProduct,multiFunData,multiFunData-method'><p>Scalar product for multivariate functional data</p></a></li>
<li><a href='#simFunData'><p>Simulate univariate functional data</p></a></li>
<li><a href='#simMultiFunData'><p>Simulate multivariate functional data</p></a></li>
<li><a href='#simMultiSplit'><p>Simulate multivariate eigenfunctions based on a split 'big' ONB</p></a></li>
<li><a href='#simMultiWeight'><p>Simulate multivariate eigenfunctions based on weighted orthonormal bases</p></a></li>
<li><a href='#sparsify'><p>Generate a sparse version of functional data objects</p></a></li>
<li><a href='#sparsify,funData-method'><p>sparsify for univariate functional data</p></a></li>
<li><a href='#sparsify,multiFunData-method'><p>sparsify for multivariate functional data</p></a></li>
<li><a href='#tensorProduct'><p>Tensor product for univariate functions on one-dimensional domains</p></a></li>
<li><a href='#tensorProduct,funData-method'><p>Tensor product for functional data</p></a></li>
<li><a href='#X,funData-method'><p>Get X slot for funData objects</p></a></li>
<li><a href='#X,irregFunData-method'><p>Get X slot for irregular functional data objects</p></a></li>
<li><a href='#X,multiFunData-method'><p>Get X slot for multiFunData objects</p></a></li>
<li><a href='#X&lt;-,funData-method'><p>Set X slot for funData objects</p></a></li>
<li><a href='#X&lt;-,irregFunData-method'><p>Set X slot for irregular functional data objects</p></a></li>
<li><a href='#X&lt;-,multiFunData-method'><p>Set X slot for multiFunData objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An S4 Class for Functional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Clara Happ-Kurz [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Clara Happ-Kurz &lt;chk_R@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>S4 classes for univariate and multivariate functional data with
    utility functions. See &lt;<a href="https://doi.org/10.18637%2Fjss.v093.i05">doi:10.18637/jss.v093.i05</a>&gt; for a detailed description 
    of the package functionalities and its interplay with the MFPCA package for 
    multivariate functional principal component analysis 
    <a href="https://CRAN.R-project.org/package=MFPCA">https://CRAN.R-project.org/package=MFPCA</a>. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ClaraHapp/funData">https://github.com/ClaraHapp/funData</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, fields, foreach, graphics, grDevices, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, fda, ggplot2 (&ge; 3.0.0), gridExtra, reshape2, zoo,
testthat (&ge; 2.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'funDataClass.R' 'coerce.R' 'funDataMethods.R' 'get_set.R'
'names.R' 'plotMethods.R' 'simulation.R' 'str.R' 'subset.R'
'summary.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 12:52:25 UTC; clara</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-14 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.intWeights'>Calculate weights for numerical integration</h2><span id='topic+.intWeights'></span>

<h3>Description</h3>

<p>This function calculates the weights for numerical integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.intWeights(argvals, method = "trapezoidal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".intWeights_+3A_argvals">argvals</code></td>
<td>
<p>A numeric vector of x-Values</p>
</td></tr>
<tr><td><code id=".intWeights_+3A_method">method</code></td>
<td>
<p>A character string, giving the numerical integration method to use (default is <code>trapezoidal</code>, alternatively use <code>midpoint</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integration weights
</p>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>
</p>

<hr>
<h2 id='.scalarProduct'>Generic method for scalar products, based on integrate</h2><span id='topic+.scalarProduct'></span>

<h3>Description</h3>

<p>Generic method for scalar products, based on integrate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.scalarProduct(object1, object2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".scalarProduct_+3A_object1">object1</code>, <code id=".scalarProduct_+3A_object2">object2</code></td>
<td>
<p>Generic objects</p>
</td></tr>
<tr><td><code id=".scalarProduct_+3A_...">...</code></td>
<td>
<p>Further objects passed to <code><a href="#topic+integrate">integrate</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='addError'>Add Gaussian white noise to functional data objects</h2><span id='topic+addError'></span>

<h3>Description</h3>

<p>This function generates an artificial noisy version of a functional data 
object of class <code><a href="#topic+funData-class">funData</a></code> (univariate) or 
<code><a href="#topic+multiFunData-class">multiFunData</a></code> (multivariate) by adding iid. realizations
of Gaussian random variables <code class="reqn">\varepsilon \sim \mathcal{N}(0,
\sigma^2)</code> to the observations. The standard deviation
<code class="reqn">\sigma</code> can be supplied by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addError(funDataObject, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addError_+3A_fundataobject">funDataObject</code></td>
<td>
<p>A functional data object of class 
<code><a href="#topic+funData-class">funData</a></code> or <code><a href="#topic+multiFunData-class">multiFunData</a></code>.</p>
</td></tr>
<tr><td><code id="addError_+3A_sd">sd</code></td>
<td>
<p>The standard deviation <code class="reqn">\sigma</code> of the Gaussian white noise 
that is added to the data. Defaults to <code>1</code>. See Description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>funDataObject</code>, which is a noisy
version of the original data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>,
<code><a href="#topic+simFunData">simFunData</a></code>, <code><a href="#topic+simMultiFunData">simMultiFunData</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(no.readonly = TRUE)
set.seed(1)

# Univariate functional data
plain &lt;- simFunData(argvals = seq(0,1,0.01), M = 10, eFunType = "Fourier",
                    eValType = "linear", N = 1)$simData
noisy &lt;- addError(plain , sd = 0.5)
veryNoisy &lt;- addError(plain, sd = 2)

plot(plain, main = "Add error", ylim = range(veryNoisy@X))
plot(noisy, type = "p", pch = 20, add = TRUE)
plot(veryNoisy, type = "p", pch = 4, add = TRUE)
legend("topright", c("Plain", "Noisy", "Very Noisy"), lty = c(1, NA, NA), pch = c(NA, 20 ,4))

# Multivariate functional data
plain &lt;- simMultiFunData(type = "split", argvals = list(seq(0,1,0.01), seq(-.5,.5,0.02)), M = 10,
                        eFunType = "Fourier", eValType = "linear", N = 1)$simData
noisy &lt;- addError(plain , sd = 0.5)
veryNoisy &lt;- addError(plain, sd = 2)

par(mfrow = c(1,2))
plot(plain[[1]], main = "Add error (multivariate)", ylim = range(veryNoisy[[1]]@X))
plot(noisy[[1]], type = "p", pch = 20, add = TRUE)
plot(veryNoisy[[1]], type = "p", pch = 4, add = TRUE)

plot(plain[[2]], main = "Add error (multivariate)", ylim = range(veryNoisy[[2]]@X))
plot(noisy[[2]], type = "p", pch = 20, add = TRUE)
plot(veryNoisy[[2]], type = "p", pch = 4, add = TRUE)
legend("topright", c("Plain", "Noisy", "Very Noisy"), lty = c(1, NA, NA), pch = c(NA, 20 ,4))

par(oldPar)
</code></pre>

<hr>
<h2 id='addError+2CfunData-method'>Add gaussian white noise to functional data</h2><span id='topic+addError+2CfunData-method'></span>

<h3>Description</h3>

<p>Add gaussian white noise to functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
addError(funDataObject, sd)
</code></pre>

<hr>
<h2 id='addError+2CmultiFunData-method'>Add gaussian white noise to multivariate functional data</h2><span id='topic+addError+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>Add gaussian white noise to multivariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
addError(funDataObject, sd)
</code></pre>

<hr>
<h2 id='approxNA'>Approximate missing values for funData objects</h2><span id='topic+approxNA'></span>

<h3>Description</h3>

<p>This function approximates missing values for <code>funData</code> objects based on
the <a href="zoo.html#topic+na.approx">na.approx</a> interpolation method from the package <span class="pkg">zoo</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approxNA(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approxNA_+3A_object">object</code></td>
<td>
<p>An object of  class <code>funData</code> with missing values (coded 
by <code>NA</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>funData</code> object where missing values have been imputed.
</p>


<h3>Warning</h3>

<p>This function requires the package <span class="pkg">zoo</span> to be 
installed, otherwise it will throw a warning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate some data
f &lt;- simFunData(N = 10, M = 8, eVal = "linear", eFun = "Poly", argvals = seq(0, 1, 0.01))$simData

# Sparsify, i.e. generate artificial missings in the data
fSparse &lt;- sparsify(f, minObs = 10, maxObs = 50)

# plot
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,3))
plot(f, main = "Original Data") 
plot(fSparse, main = "Sparse Data")
plot(approxNA(fSparse), main = "Reconstructed Data")
# faster with plot(fSparse, plotNA = TRUE, main = "Reconstructed Data")

par(oldpar)
</code></pre>

<hr>
<h2 id='approxNA+2CfunData-method'>approxNA for funData objects</h2><span id='topic+approxNA+2CfunData-method'></span>

<h3>Description</h3>

<p>approxNA for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
approxNA(object)
</code></pre>

<hr>
<h2 id='argvals'>Extract and set slots from functional data objects</h2><span id='topic+argvals'></span><span id='topic+getArgvals'></span><span id='topic+getArgvals+2CfunData-method'></span><span id='topic+getArgvals+2CmultiFunData-method'></span><span id='topic+getArgvals+2CirregFunData-method'></span><span id='topic+X'></span><span id='topic+getX'></span><span id='topic+getX+2CfunData-method'></span><span id='topic+getX+2CmultiFunData-method'></span><span id='topic+getX+2CirregFunData-method'></span><span id='topic+argvals+3C-'></span><span id='topic+setArgvals'></span><span id='topic+setArgvals+2CfunData-method'></span><span id='topic+setArgvals+2CmultiFunData-method'></span><span id='topic+setArgvals+2CirregFunData-method'></span><span id='topic+X+3C-'></span><span id='topic+setX'></span><span id='topic+setX+2CfunData-method'></span><span id='topic+setX+2CmultiFunData-method'></span><span id='topic+setX+2CirregFunData-method'></span>

<h3>Description</h3>

<p>These functions can be used to extract and set the slots of
<code>funData</code>, <code>irregFunData</code> and <code>multiFunData</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argvals(object)

getArgvals(object)

## S4 method for signature 'funData'
getArgvals(object)

## S4 method for signature 'multiFunData'
getArgvals(object)

## S4 method for signature 'irregFunData'
getArgvals(object)

X(object)

getX(object)

## S4 method for signature 'funData'
getX(object)

## S4 method for signature 'multiFunData'
getX(object)

## S4 method for signature 'irregFunData'
getX(object)

argvals(object) &lt;- value

setArgvals(object, value)

## S4 method for signature 'funData'
setArgvals(object, value)

## S4 method for signature 'multiFunData'
setArgvals(object, value)

## S4 method for signature 'irregFunData'
setArgvals(object, value)

X(object) &lt;- value

setX(object, value)

## S4 method for signature 'funData'
setX(object, value)

## S4 method for signature 'multiFunData'
setX(object, value)

## S4 method for signature 'irregFunData'
setX(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="argvals_+3A_object">object</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code>.</p>
</td></tr>
<tr><td><code id="argvals_+3A_value">value</code></td>
<td>
<p>New <code>argvals</code> or <code>X</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>funData</code> or <code>irregFunData</code> have two slots,
<code>argvals</code> (for the x-values) and <code>X</code> (for the y-values for
each observation). Using the <code>argvals</code> (alias: <code>getArgvals</code>)
and <code>X</code> (alias: <code>getX</code>) methods for the classes
<code>funData</code> and <code>irregFunData</code> is equivalent to accessing the
slots directly via <code>object@argvals</code> and <code>object@X</code>.
Analogously, the <code>argvals&lt;-</code> and <code>X&lt;-</code> functions are
equivalent to setting <code>object@argvals</code> to <code>value</code> or
<code>object@X</code> to <code>value</code>, respectively. The new values must
hence have the same structure as the original ones. As an exception,
for an object of class <code>funData</code> the number of new X values may
differ from the current (e.g. when adding new observations). In this
case, the function throws a warning.
</p>
<p>Objects of class <code>multiFunData</code> are lists of several
<code>funData</code> objects. The functions <code>argvals</code> and <code>X</code> for
<code>multiFunData</code> objects therefore return a list of the same length
as <code>object</code>, where each list element corresponds to the
<code>argvals</code> or <code>X</code> slot of the univariate element. The
<code>argvals&lt;-</code> and <code>X&lt;-</code> functions for <code>multiFunData</code>
objects must receive lists of the same length as <code>object</code>, where
each list element corresponds to the new <code>argvals</code> or new <code>X</code>
slot for the univariate elements.
</p>


<h3>Value</h3>

<p>See Details.
</p>


<h3>Warning</h3>

<p>The functions <code>getArgvals</code> / <code>getX</code> and
<code>setArgvals</code> / <code>setX</code> from former package versions are
deprecated. use <code>argvals</code> and <code>X</code> instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>,
<code><a href="#topic+irregFunData-class">irregFunData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Univariate
object &lt;- funData(argvals = 1:5, X = rbind(1:5, 6:10))
object

# get-methods
argvals(object)
X(object)

# set-methods
argvals(object) &lt;- 0:4
object 
## Not run: argvals(object) &lt;- 1:4 # wrong length
X(object) &lt;- rbind(0:4, 5:9)
## Not run: X(object) &lt;- rbind(0:4, 5:9, 10:14) # warning: now 3 observations (was 2 before)
## Not run: X(object) &lt;- rbind(1:4, 5:8) # wrong length

### Univariate (irregular)
irregObject &lt;- irregFunData(argvals = list(1:5, 2:4), X = list(2:6, 3:5))
irregObject

# get-methods
argvals(irregObject)
X(irregObject)

# set-methods
argvals(irregObject) &lt;- list(0:4, 1:3)
X(irregObject) &lt;- list(12:16, 13:15)

### Multivariate
multiObject &lt;- multiFunData(object, funData(argvals = 1:3, X = rbind(3:5, 6:8)))
multiObject

# get-methods
argvals(multiObject)
X(multiObject)

# set-methods (for special cases see univariate version)
argvals(multiObject) &lt;- list(5:1, 3:1)
X(multiObject) &lt;- list(rbind(5:1, 10:6), rbind(5:3, 8:6))
</code></pre>

<hr>
<h2 id='argvals+2CfunData-method'>Get argvals slot for funData objects</h2><span id='topic+argvals+2CfunData-method'></span>

<h3>Description</h3>

<p>Get argvals slot for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
argvals(object)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+argvals">argvals</a></code>
</p>

<hr>
<h2 id='argvals+2CirregFunData-method'>Get argvals slot for irregular functional data objects</h2><span id='topic+argvals+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Get argvals slot for irregular functional data objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData'
argvals(object)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+argvals">argvals</a></code>
</p>

<hr>
<h2 id='argvals+2CmultiFunData-method'>Get argvals slot for multiFunData objects</h2><span id='topic+argvals+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>Get argvals slot for multiFunData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
argvals(object)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+argvals">argvals</a></code>
</p>

<hr>
<h2 id='argvals+26lt+3B-+2CfunData-method'>Set argvals slot for funData objects</h2><span id='topic+argvals+3C-+2CfunData-method'></span>

<h3>Description</h3>

<p>Set argvals slot for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'funData'
argvals(object) &lt;- value
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+argvals+3C-">argvals&lt;-</a></code>
</p>

<hr>
<h2 id='argvals+26lt+3B-+2CirregFunData-method'>Set argvals slot for irregular functional objects</h2><span id='topic+argvals+3C-+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Set argvals slot for irregular functional objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'irregFunData'
argvals(object) &lt;- value
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+argvals+3C-">argvals&lt;-</a></code>
</p>

<hr>
<h2 id='argvals+26lt+3B-+2CmultiFunData-method'>Set argvals slot for multiFunData objects</h2><span id='topic+argvals+3C-+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>Set argvals slot for multiFunData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'multiFunData'
argvals(object) &lt;- value
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+argvals+3C-">argvals&lt;-</a></code>
</p>

<hr>
<h2 id='Arith.funData'>Arithmetics for functional data objects</h2><span id='topic+Arith.funData'></span><span id='topic+Arith+2CfunData+2CfunData-method'></span><span id='topic+Arith+2CfunData+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2CfunData-method'></span><span id='topic+Arith+2CmultiFunData+2CmultiFunData-method'></span><span id='topic+Arith+2CmultiFunData+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2CmultiFunData-method'></span><span id='topic+Arith+2CirregFunData+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2CirregFunData-method'></span><span id='topic+Arith+2CirregFunData+2CirregFunData-method'></span><span id='topic+Arith+2CirregFunData+2CfunData-method'></span><span id='topic+Arith+2CfunData+2CirregFunData-method'></span>

<h3>Description</h3>

<p>These functions allow basic arithmetics (such as '+', '-', '*', 'sqrt') for
functional data and numerics based on <code><a href="methods.html#topic+Arith">Arith</a></code>.  The
operations are made pointwise for each observation. See examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData,funData'
Arith(e1, e2)

## S4 method for signature 'funData,numeric'
Arith(e1, e2)

## S4 method for signature 'numeric,funData'
Arith(e1, e2)

## S4 method for signature 'multiFunData,multiFunData'
Arith(e1, e2)

## S4 method for signature 'multiFunData,numeric'
Arith(e1, e2)

## S4 method for signature 'numeric,multiFunData'
Arith(e1, e2)

## S4 method for signature 'irregFunData,numeric'
Arith(e1, e2)

## S4 method for signature 'numeric,irregFunData'
Arith(e1, e2)

## S4 method for signature 'irregFunData,irregFunData'
Arith(e1, e2)

## S4 method for signature 'irregFunData,funData'
Arith(e1, e2)

## S4 method for signature 'funData,irregFunData'
Arith(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arith.funData_+3A_e1">e1</code>, <code id="Arith.funData_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>funData</code>, <code>irregFunData</code>,
<code>multiFunData</code> or <code>numeric</code>. If two functional data objects are
used, they must be of the same class, have the same domain and the same
number of observations. For exceptions, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If two objects of a functional data class (<code>funData</code>,
<code>irregFunData</code> or <code>multiFunData</code>) are used, they normally must be
of the same class, have the same domain and the same number of observations.
Exceptions are accepted if </p>
<ul>
<li><p> one object has only one
observation. In this case, the arithmetic operations ('+', '-', '*', ...) are
done pairwise for this single function and all functions of the other object.
A typical example would be when subtracting the mean function from all
observations in a <code>funData</code> object. This single function must be defined
on the same domain as the other functions (or, in case of
<code>irregFunData</code>, on the union of all observation grids). </p>
</li>
<li><p> one of the
two objects is of class <code>irregFunData</code>. Then, the other object can be of
class <code>funData</code>, too, if it is defined on the union of all observation
grids. The result is an <code>irregFunData</code> object which is defined on the
same observation grid as the original <code>irregFunData</code> object.</p>
</li></ul>



<h3>Value</h3>

<p>An object of the same functional data class as <code>e1</code> or
<code>e2</code>, respectively.
</p>


<h3>Warning</h3>

<p>Note that not all combinations of operations and classes
make sense, e.g. <code>e1 ^ e2</code> is sensible if <code>e1</code> is of class
<code>funData</code>, <code>irregFunData</code> or <code>multiFunData</code> and <code>e2</code> is
numeric. The reverse is not true.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>,
<code><a href="#topic+multiFunData-class">multiFunData</a></code>, <a href="methods.html#topic+Arith">Arith</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)
par(mfrow = c(3,2), mar = rep(2.1,4))

argvals &lt;- seq(0, 2*pi, 0.01)
object1 &lt;- funData(argvals, outer(seq(0.75, 1.25, by = 0.05), sin(argvals)))
object2 &lt;- funData(argvals, outer(seq(0.75, 1.25, by = 0.05), cos(argvals)))

plot(object1, main = "Object1")
plot(object2, main = "Object2")

# Only functional data objects
plot(object1 + object2, main = "Sum")
plot(object1 - object2, main = "Difference")

# Mixed
plot(4 * object1 + 5,  main = "4 * Object1 + 5") # Note y-axis!
plot(object1^2 + object2^2, main = "Pythagoras")

### Irregular
ind &lt;- replicate(11, sort(sample(1:length(argvals), sample(5:10, 1))))
i1 &lt;- irregFunData(
   argvals = lapply(1:11, function(i, ind, x){x[ind[[i]]]}, ind = ind, x = object1@argvals[[1]]),
   X = lapply(1:11, function(i, ind, y){y[i, ind[[i]]]}, ind = ind, y = object1@X))
i2 &lt;- irregFunData(
   argvals = lapply(1:11, function(i, ind, x){x[ind[[i]]]}, ind = ind, x = object2@argvals[[1]]),
   X = lapply(1:11, function(i, ind, y){y[i, ind[[i]]]}, ind = ind, y = object2@X))

plot(i1, main = "Object 1 (irregular)")
plot(i2, main = "Object 2 (irregular)")

# Irregular and regular functional data objects
plot(i1 + i2, main = "Sum")
plot(i1 - object2, main = "Difference")

# Mixed
plot(4 * i1 + 5,  main = "4 * i1 + 5") # Note y-axis!
plot(i1^2 + i2^2, main = "Pythagoras")
par(oldpar)
</code></pre>

<hr>
<h2 id='as.data.frame.funData'>Coerce functional data objects to a data.frame</h2><span id='topic+as.data.frame.funData'></span><span id='topic+as.data.frame+2CfunData-method'></span><span id='topic+as.data.frame+2CmultiFunData-method'></span><span id='topic+as.data.frame+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Coerce objects of class <code>funData</code>,  <code>multiFunData</code> and
<code>irregFunData</code> to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
as.data.frame(x)

## S4 method for signature 'multiFunData'
as.data.frame(x)

## S4 method for signature 'irregFunData'
as.data.frame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.funData_+3A_x">x</code></td>
<td>
<p>The functional data object that is to be transformed to a
<code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>obs</code> (gives index/name of
observed curve), <code>argvals1, ... argvalsd</code> with <code>d</code> the
dimension of the support and <code>X</code> for the observed values.
One-dimensional functions have only <code>argvals1</code>, two-dimensional
functions (images) have <code>argvals1</code> and <code>argvals2</code>, etc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>,
<code><a href="#topic+irregFunData-class">irregFunData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>,
<code><a href="base.html#topic+data.frame">data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># one-dimensional domain
f1 &lt;- funData(argvals = 1:5, X = matrix(1:20, nrow = 4))
head(as.data.frame(f1))

# two-dimensional domain
f2 &lt;- funData(argvals = list(1:5, 1:6), X = array(1:120, c(4,5,6)))
head(as.data.frame(f2))

# multivariate functional data
m1 &lt;- multiFunData(f1, f2)
str(as.data.frame(m1))

# irregular functional data
i1 &lt;- irregFunData(argvals = list(1:5, 2:4, 3:5), X = list(1:5, 2:4, -(3:1)))
head(as.data.frame(i1))
</code></pre>

<hr>
<h2 id='as.funData'>Coerce an irregFunData object to class funData</h2><span id='topic+as.funData'></span><span id='topic+as.funData+2CirregFunData-method'></span>

<h3>Description</h3>

<p>This function coerces an object of class <code>irregFunData</code> to a
<code>funData</code> object with missing values, which is defined on the union of
all observation points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.funData(object)

## S4 method for signature 'irregFunData'
as.funData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.funData_+3A_object">object</code></td>
<td>
<p>The <code>irregFunData</code> object that is to be converted to a
<code>funData</code> object with missing values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>
</p>

<hr>
<h2 id='as.irregFunData'>Coerce a funData object to class irregFunData</h2><span id='topic+as.irregFunData'></span><span id='topic+as.irregFunData+2CfunData-method'></span>

<h3>Description</h3>

<p>This function coerces an object of class <code>funData</code> to a
<code>irregFunData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.irregFunData(object)

## S4 method for signature 'funData'
as.irregFunData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.irregFunData_+3A_object">object</code></td>
<td>
<p>The <code>funData</code> object that is to be converted to a
<code>irregFunData</code> object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>
</p>

<hr>
<h2 id='as.multiFunData'>Coerce a funData object to class multiFunData</h2><span id='topic+as.multiFunData'></span><span id='topic+as.multiFunData+2CfunData-method'></span>

<h3>Description</h3>

<p>Coerce a <code>funData</code> object to class <code>multiFunData</code> with one element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.multiFunData(object)

## S4 method for signature 'funData'
as.multiFunData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.multiFunData_+3A_object">object</code></td>
<td>
<p>The <code>funData</code> object that is to be converted to a
<code>multiFunData</code> object of length 1.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create funData object with 5 observations
x &lt;- seq(0,1,0.01)
f1 &lt;- funData(argvals = x, X = 1:5 %o% x)
f1
class(f1)

# coerce to multiFunData object (of length 1)
m1 &lt;- as.multiFunData(f1)
m1
class(m1)
</code></pre>

<hr>
<h2 id='autoplot.funData'>Visualize functional data objects using ggplot</h2><span id='topic+autoplot.funData'></span><span id='topic+autolayer.funData'></span>

<h3>Description</h3>

<p>This function allows to plot <code>funData</code> objects based on the 
<span class="pkg">ggplot2</span> package. The function provides a wrapper that rearranges the 
data in a <code>funData</code> object on a one- or two-dimensional domain and 
provides a basic <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object, which can be 
customized using all functionalities of the <span class="pkg">ggplot2</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot.funData(
  object,
  obs = seq_len(nObs(object)),
  geom = "line",
  plotNA = FALSE,
  ...
)

autolayer.funData(
  object,
  obs = seq_len(nObs(object)),
  geom = "line",
  plotNA = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.funData_+3A_object">object</code></td>
<td>
<p>A <code>funData</code> object on a one- or two-dimensional domain.</p>
</td></tr>
<tr><td><code id="autoplot.funData_+3A_obs">obs</code></td>
<td>
<p>A vector of numerics giving the observations to plot. Defaults to 
all observations in <code>object</code>. For two-dimensional functions (images) 
<code>obs</code> must have length 1.</p>
</td></tr>
<tr><td><code id="autoplot.funData_+3A_geom">geom</code></td>
<td>
<p>A character string describing the geometric object to use.
Defaults to <code>"line"</code>. See <span class="pkg">ggplot2</span> for details.</p>
</td></tr>
<tr><td><code id="autoplot.funData_+3A_plotna">plotNA</code></td>
<td>
<p>Logical. If <code>TRUE</code>, missing values are interpolated using 
the <code><a href="#topic+approxNA">approxNA</a></code> function (only for one-dimensional functions). 
Defaults to <code>FALSE</code>. See Details.</p>
</td></tr>
<tr><td><code id="autoplot.funData_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="ggplot2.html#topic+geom_line">geom_line</a></code> (for
one dimensional domains, e.g. <code>alpha, color, fill, linetype, size</code>) or
to <code><a href="ggplot2.html#topic+geom_raster">geom_raster</a></code> (for two-dimensional domains, e.g.
<code>hjust, vjust, interpolate</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If some observations contain missing values (coded via <code>NA</code>), the 
functions can be interpolated using the option <code>plotNA = TRUE</code>. This 
option relies on the <code><a href="zoo.html#topic+na.approx">na.approx</a></code> function in package 
<code><a href="zoo.html#topic+zoo">zoo</a></code> and is currently implemented for one-dimensional 
functions only in the function <code><a href="#topic+approxNA">approxNA</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be customized  using 
all functionalities of the <span class="pkg">ggplot2</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, 
<code><a href="#topic+plot.funData">plot.funData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Install / load package ggplot2 before running the examples
library("ggplot2")

# One-dimensional
argvals &lt;- seq(0,2*pi,0.01)
object &lt;- funData(argvals,
                   outer(seq(0.75, 1.25, length.out = 11), sin(argvals)))

g &lt;- autoplot(object) # returns ggplot object
g # plot the object

# add the mean function in red
g + autolayer(meanFunction(object),  col = 2)

# Two-dimensional
X &lt;- array(0, dim = c(2, length(argvals), length(argvals)))
X[1,,] &lt;- outer(argvals, argvals, function(x,y){sin((x-pi)^2 + (y-pi)^2)})
X[2,,] &lt;- outer(argvals, argvals, function(x,y){sin(2*x*pi) * cos(2*y*pi)})
object2D &lt;- funData(list(argvals, argvals), X)


autoplot(object2D, obs = 1)
autoplot(object2D, obs = 2)
## Not run: autoplot(object2D) # must specify obs!

### More examples ###

par(mfrow = c(1,1))

# using plotNA (needs packages zoo and gridExtra)


objectMissing &lt;- funData(1:5, rbind(c(1, NA, 5, 4, 3), c(10, 9, NA, NA, 6)))
g1 &lt;- autoplot(objectMissing) # the default
g2 &lt;- autoplot(objectMissing, plotNA = TRUE) # requires zoo

gridExtra::grid.arrange(g1 + ggtitle("plotNA = FALSE (default)"),
                        g2 + ggtitle("plotNA = TRUE")) # requires gridExtra

# Customizing plots (see ggplot2 documentation for more details)
# parameters passed to geom_line are passed via the ... argument
gFancy &lt;- autoplot(object, color = "red", linetype = 2) 
gFancy

# new layers can be added directly to the ggplot object
gFancy + theme_bw() # add new layers to the ggplot object
gFancy + ggtitle("Fancy Plot with Title and Axis Legends") + 
         xlab("The x-Axis") + ylab("The y-Axis")

autoplot(object2D, obs = 1) + ggtitle("Customized 2D plot") + theme_minimal() +
          scale_fill_gradient(high = "green", low = "blue", name = "Legend here")

</code></pre>

<hr>
<h2 id='autoplot.irregFunData'>Visualize irregular functional data objects using ggplot</h2><span id='topic+autoplot.irregFunData'></span><span id='topic+autolayer.irregFunData'></span>

<h3>Description</h3>

<p>This function allows to plot <code>irregFunData</code> objects on their domain
based on the <span class="pkg">ggplot2</span> package. The function provides a wrapper that
returns a basic
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object, which can be customized using all
functionalities of the <span class="pkg">ggplot2</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot.irregFunData(object, obs = seq_len(nObs(object)), geom = "line", ...)

autolayer.irregFunData(object, obs = seq_len(nObs(object)), geom = "line", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.irregFunData_+3A_object">object</code></td>
<td>
<p>A <code>irregFunData</code> object.</p>
</td></tr>
<tr><td><code id="autoplot.irregFunData_+3A_obs">obs</code></td>
<td>
<p>A vector of numerics giving the observations to plot. Defaults to
all observations in <code>object</code>. For two-dimensional functions (images)
<code>obs</code> must have length 1.</p>
</td></tr>
<tr><td><code id="autoplot.irregFunData_+3A_geom">geom</code></td>
<td>
<p>A character string describing the geometric object to use.
Defaults to <code>"line"</code>. See <span class="pkg">ggplot2</span> for details.</p>
</td></tr>
<tr><td><code id="autoplot.irregFunData_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="ggplot2.html#topic+stat_identity">stat_identity</a></code>,
e.g. <code>alpha, color, fill, linetype, size</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be customized using
all functionalities of the <span class="pkg">ggplot2</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irregFunData-class">irregFunData</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, 
<code><a href="#topic+plot.irregFunData">plot.irregFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Install / load package ggplot2 before running the examples
library("ggplot2")

# Generate data
argvals &lt;- seq(0,2*pi,0.01)
ind &lt;- replicate(5, sort(sample(1:length(argvals), sample(5:10,1))))
object &lt;- irregFunData(argvals = lapply(ind, function(i){argvals[i]}),
                  X = lapply(ind, function(i){sample(1:10,1) / 10 * argvals[i]^2}))

# Plot the data
autoplot(object)

 # Parameters passed to geom_line are passed via the ... argument
autoplot(object, color = "red", linetype = 3)

# Plot the data and add green dots for the 2nd function
autoplot(object) + autolayer(object, obs = 2, geom = "point", color = "green")

# New layers can be added directly to the ggplot object using functions from the ggplot2 package
g &lt;- autoplot(object)
g + theme_bw() + ggtitle("Plot with minimal theme and axis labels") +
    xlab("The x-Axis") + ylab("The y-Axis")
</code></pre>

<hr>
<h2 id='autoplot.multiFunData'>Visualize multivariate functional data objects using ggplot</h2><span id='topic+autoplot.multiFunData'></span>

<h3>Description</h3>

<p>This function allows to plot <code>multiFunData</code> objects based on the <span class="pkg">ggplot2</span> package. The 
function applies the <code><a href="#topic+autoplot.funData">autoplot.funData</a></code> function to each element and returns either a 
combined plot with all elements plotted in one row or a list containing the different subplots as
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> objects. The individual objects can be customized using all 
functionalities of the <span class="pkg">ggplot2</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot.multiFunData(
  object,
  obs = seq_len(nObs(object)),
  dim = seq_len(length(object)),
  plotGrid = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.multiFunData_+3A_object">object</code></td>
<td>
<p>A <code>multiFunData</code> object that is to be plotted.</p>
</td></tr>
<tr><td><code id="autoplot.multiFunData_+3A_obs">obs</code></td>
<td>
<p>A vector of numerics giving the observations to plot. Defaults to all observations in 
<code>object</code>. For two-dimensional functions (images) <code>obs</code> must have length 1.</p>
</td></tr>
<tr><td><code id="autoplot.multiFunData_+3A_dim">dim</code></td>
<td>
<p>The dimensions to plot. Defaults to <code>length(object)</code>, i.e. all functions in 
<code>object</code> are plotted.</p>
</td></tr>
<tr><td><code id="autoplot.multiFunData_+3A_plotgrid">plotGrid</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the data is plotted using 
<code><a href="gridExtra.html#topic+grid.arrange">grid.arrange</a></code> and the list of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> objects is 
returned invisibly. If <code>FALSE</code>, only the list of objects is returned. Defaults to 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.multiFunData_+3A_...">...</code></td>
<td>
<p>Further parameters passed to the univariate <code><a href="#topic+autoplot.funData">autoplot.funData</a></code> functions for 
<code>funData</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> objects that are also printed directly as a grid 
if <code>plotGrid = TRUE</code>.
</p>


<h3>Warning</h3>

<p>Currently, the function does not accept different parameters for the univariate
elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiFunData-class">multiFunData</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, 
<code><a href="#topic+plot.multiFunData">plot.multiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load packages ggplot2 and gridExtra before running the examples
library("ggplot2"); library("gridExtra")

# One-dimensional elements
argvals &lt;- seq(0, 2*pi, 0.01)
f1 &lt;- funData(argvals, outer(seq(0.75, 1.25, length.out = 11), sin(argvals)))
f2 &lt;- funData(argvals, outer(seq(0.75, 1.25, length.out = 11), cos(argvals)))

m1 &lt;- multiFunData(f1, f2)

g &lt;- autoplot(m1) # default
g[[1]] # plot first element
g[[2]] # plot second element
gridExtra::grid.arrange(grobs = g, nrow = 1) # requires gridExtra package

autoplot(m1, plotGrid = TRUE) # the same directly with plotGrid = TRUE


# Mixed-dimensional elements
X &lt;- array(0, dim = c(11, length(argvals), length(argvals)))
X[1,,] &lt;- outer(argvals, argvals, function(x,y){sin((x-pi)^2 + (y-pi)^2)})
f2 &lt;- funData(list(argvals, argvals), X)

m2 &lt;- multiFunData(f1, f2)

autoplot(m2, obs = 1, plotGrid = TRUE)

# Customizing plots (see ggplot2 documentation for more details)
g2 &lt;- autoplot(m2, obs = 1)
g2[[1]] &lt;- g2[[1]] + ggtitle("First element") + theme_bw()
g2[[2]] &lt;- g2[[2]] + ggtitle("Second element") + 
                     scale_fill_gradient(high = "green", low = "blue")
gridExtra::grid.arrange(grobs = g2, nrow = 1) # requires gridExtra package

</code></pre>

<hr>
<h2 id='dimSupp'>Support dimension of functional data</h2><span id='topic+dimSupp'></span>

<h3>Description</h3>

<p>This function returns the support dimension of an object of class
<code>funData</code>, <code>irregFunData</code> or <code>multiFunData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimSupp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimSupp_+3A_object">object</code></td>
<td>
<p>An object of  class <code>funData</code>, <code>irregFunData</code> or <code>multiFunData</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>object</code> is univariate (i.e. of class <code>funData</code> or <code>irregFunData</code>), the
function returns the dimension of the support of <code>object</code>. If
<code>object</code> is multivariate (i.e. of class <code>multiFunData</code>), the
function returns a vector, giving the support dimension of each element.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate (one-dimensional)
object1 &lt;- funData(argvals = 1:5, X = rbind(1:5, 6:10))
dimSupp(object1)

# Univariate (two-dimensional)
object2 &lt;- funData(argvals = list(1:10, 1:5), X = array(rnorm(100), dim = c(2,10,5)))
dimSupp(object2)

# Univariate (irregular)
irregObject &lt;- irregFunData(argvals = list(1:5, 2:4), X = list(2:6, 3:5))
dimSupp(irregObject)

# Multivariate
multiObject &lt;- multiFunData(object1, object2)
dimSupp(multiObject)
</code></pre>

<hr>
<h2 id='dimSupp+2CfunData-method'>dimSupp for funData objects</h2><span id='topic+dimSupp+2CfunData-method'></span>

<h3>Description</h3>

<p>dimSupp for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
dimSupp(object)
</code></pre>

<hr>
<h2 id='dimSupp+2CirregFunData-method'>dimSupp for irregular functional data objects</h2><span id='topic+dimSupp+2CirregFunData-method'></span>

<h3>Description</h3>

<p>dimSupp for irregular functional data objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData'
dimSupp(object)
</code></pre>

<hr>
<h2 id='dimSupp+2CmultiFunData-method'>dimSupp for multiFunData objects</h2><span id='topic+dimSupp+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>dimSupp for multiFunData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
dimSupp(object)
</code></pre>

<hr>
<h2 id='efFourier'>Calculate the first M Fourier basis functions</h2><span id='topic+efFourier'></span>

<h3>Description</h3>

<p>This function calculates the first M orthonormal Fourier basis functions on
an arbitrary interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efFourier(argvals, M, linear = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efFourier_+3A_argvals">argvals</code></td>
<td>
<p>A vector, defining a (fine) grid on the interval for which the
Fourier basis functions are computed.</p>
</td></tr>
<tr><td><code id="efFourier_+3A_m">M</code></td>
<td>
<p>An integer, specifying the number of basis functions that are
calculated.</p>
</td></tr>
<tr><td><code id="efFourier_+3A_linear">linear</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the last function is not a Fourier
function but the linear function orthogonalized to all previous Fourier
basis functions. Defaults to <code>FALSE</code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>linear</code>, the last basis function does not belong to the  Fourier
basis, but is the linear function orthogonalized to all previous Fourier
basis functions via the Gram-Schmidt method. This is implemented only if
<code>argvalss</code> is a grid defining the unit interval <code class="reqn">[0,1]</code>.
</p>


<h3>Value</h3>

<p>A univariate functional data object of class
<code><a href="#topic+funData-class">funData</a></code> containing the Fourier basis functions on
the given interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+simFunData">simFunData</a></code>, <code><a href="#topic+simMultiFunData">simMultiFunData</a></code>
</p>

<hr>
<h2 id='efPoly'>Legendre Polynomials of degree 0,...,M-1</h2><span id='topic+efPoly'></span>

<h3>Description</h3>

<p>This function iteratively calculates orthonormal Legendre polynomials of
degree 0,...,M-1 on an arbitrary interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efPoly(argvals, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efPoly_+3A_argvals">argvals</code></td>
<td>
<p>A vector, defining a (fine) grid on the interval for which the
Legendre polynomials are computed.</p>
</td></tr>
<tr><td><code id="efPoly_+3A_m">M</code></td>
<td>
<p>An integer, specifying the number (and hence the degree) of
polynomials that are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A univariate functional data object of class <code><a href="#topic+funData-class">funData</a></code>
containing the Legendre polynomials on the given interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+simFunData">simFunData</a></code>, <code><a href="#topic+simMultiFunData">simMultiFunData</a></code>
</p>

<hr>
<h2 id='eFun'>Generate orthonormal eigenfunctions</h2><span id='topic+eFun'></span>

<h3>Description</h3>

<p>This function calculates <code class="reqn">M</code> (orthonormal) basis functions on a given 
interval, that can be interpreted as the first <code class="reqn">M</code> eigenfunctions of an 
appropriate data generating process of functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eFun(argvals, M, ignoreDeg = NULL, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eFun_+3A_argvals">argvals</code></td>
<td>
<p>A vector of numerics, defining a (fine) grid on the interval
for which the basis functions are computed.</p>
</td></tr>
<tr><td><code id="eFun_+3A_m">M</code></td>
<td>
<p>An integer, specifying the number of functions that are calculated.</p>
</td></tr>
<tr><td><code id="eFun_+3A_ignoredeg">ignoreDeg</code></td>
<td>
<p>A vector of numerics, specifying the degrees to be ignored 
for type <code>"PolyHigh"</code>. Defaults to <code>NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="eFun_+3A_type">type</code></td>
<td>
<p>A character string, specifying the type of functions that are
calculated. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements three families of orthonormal basis functions plus 
variations of them. The parameter <code>type</code>, that specifies the functions 
to be calculated, can have the following values: </p>
<ul>
<li>
<p><code>"Poly"</code>: Calculate orthonormal Legendre polynomials of degree
0,...,M-1. </p>
</li>
<li> <p><code>"PolyHigh"</code>: Calculate <code class="reqn">M</code> orthonormal Legendre
Polynomials of higher degree. The vector of indices <code>ignoreDeg</code>
specifies the functions to be ignored. If <code>ignoreDeg</code> is not specified,
the function returns an error. </p>
</li>
<li> <p><code>"Fourier"</code>: Calculate the first
<code class="reqn">M</code> Fourier basis functions. </p>
</li>
<li> <p><code>"FourierLin"</code>: Calculate the
first <code class="reqn">M-1</code> Fourier basis functions plus the linear function,
orthonormalized to the previous functions via Gram-Schmidts method. This type
is currently implemented for functions on the unit interval <code class="reqn">[0,1]</code> only.
If the function is called with other <code>argvals</code>, an error is thrown.
</p>
</li>
<li> <p><code>"Wiener"</code>: Calculate the first <code class="reqn">M</code> orthonormal eigenfunctions
of the Wiener process. </p>
</li></ul>



<h3>Value</h3>

<p>A univariate functional data object of class 
<code><a href="#topic+funData-class">funData</a></code> containing the basis functions on the given 
interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+simFunData">simFunData</a></code>,
<code><a href="#topic+simMultiFunData">simMultiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(no.readonly = TRUE)

argvals &lt;- seq(0,1,0.01)

par(mfrow = c(3,2))
plot(eFun(argvals, M = 4, type = "Poly"), main = "Poly", ylim = c(-3,3))
plot(eFun(argvals, M = 4, ignoreDeg = 1:2, type = "PolyHigh"), main = "PolyHigh",  ylim = c(-3,3))
plot(eFun(argvals, M = 4, type = "Fourier"), main = "Fourier", ylim = c(-3,3))
plot(eFun(argvals, M = 4, type = "FourierLin"), main = "FourierLin", ylim = c(-3,3))
plot(eFun(argvals, M = 4, type = "Wiener"), main = "Wiener",  ylim = c(-3,3))
par(oldPar)
</code></pre>

<hr>
<h2 id='efWiener'>Calculate the first M eigenfunctions of the Wiener process</h2><span id='topic+efWiener'></span>

<h3>Description</h3>

<p>This function calculates the first M (orthonormal) eigenfunctions of the
Wiener process on an arbitrary interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efWiener(argvals, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efWiener_+3A_argvals">argvals</code></td>
<td>
<p>A vector, defining a (fine) grid on the interval for which the
eigenfunctions are computed.</p>
</td></tr>
<tr><td><code id="efWiener_+3A_m">M</code></td>
<td>
<p>An integer, specifying the number of eigenfunctions that are
calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A univariate functional data object of class
<code><a href="#topic+funData-class">funData</a></code> containing the eigenfunctions of the Wiener
process on the given interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+simFunData">simFunData</a></code>, <code><a href="#topic+simMultiFunData">simMultiFunData</a></code>
</p>

<hr>
<h2 id='eVal'>Generate a sequence of simulated eigenvalues</h2><span id='topic+eVal'></span>

<h3>Description</h3>

<p>This function generates <code class="reqn">M</code> decreasing eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eVal(M, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eVal_+3A_m">M</code></td>
<td>
<p>An integer, the number of eigenvalues to be generated.</p>
</td></tr>
<tr><td><code id="eVal_+3A_type">type</code></td>
<td>
<p>A character string specifying the type of eigenvalues that should
be calculated. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements three types of eigenvalues: </p>
<ul>
<li> 
<p><code>"linear":</code> The eigenvalues start at  <code class="reqn">1</code> and decrease linearly 
towards <code class="reqn">0</code>: </p>
<p style="text-align: center;"><code class="reqn">\nu_m = \frac{M+1-m}{m}.</code>
</p>
 </li>
<li>
<p><code>"exponential":</code> The eigenvalues start at <code class="reqn">1</code>  and decrease
exponentially towards <code class="reqn">0</code>: </p>
<p style="text-align: center;"><code class="reqn">\nu_m =
\exp\left(-\frac{m-1}{2}\right).</code>
</p>
</li>
<li>
<p><code>"wiener":</code> The eigenvalues correspond to the eigenvalues of the Wiener
process: </p>
<p style="text-align: center;"><code class="reqn">\nu_m = \frac{1}{(\pi/2 \cdot (2m-1))^2}.</code>
</p>
 </li></ul>



<h3>Value</h3>

<p>A vector containing the <code>M</code> decreasing eigenvalues.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)

# simulate M = 10 eigenvalues
M &lt;- 10
eLin &lt;- eVal(M = M, type = "linear")
eExp &lt;- eVal(M = M, type = "exponential")
eWien &lt;- eVal(M = M, type = "wiener")

par(mfrow = c(1,1))
plot(1:M, eLin, pch = 20, xlab = "m", ylab = expression(nu[m]), ylim = c(0,1))
points(1:M, eExp, pch = 20, col = 3)
points(1:M, eWien, pch = 20, col = 4)
legend("topright", legend = c("linear", "exponential", "wiener"), pch = 20, col = c(1,3,4))

par(oldpar)
</code></pre>

<hr>
<h2 id='expand.int'>Function to expand integers to a grid of indices</h2><span id='topic+expand.int'></span>

<h3>Description</h3>

<p>This function takes an arbitrary number <code class="reqn">K</code> of integer values <code class="reqn">n_1,\ldots, n_K</code> and 
creates a data frame with all combinations from <code>1:</code><code class="reqn">n_k</code>, where the first column 
(taking values from 1 to <code class="reqn">n_1</code>) varies slowest and the last column (())taking values from 1 
to <code class="reqn">n_K</code>) varies fastest. Internally, this function depends on <code><a href="base.html#topic+expand.grid">expand.grid</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.int(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.int_+3A_...">...</code></td>
<td>
<p>An arbitrary number of integer values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the same number of columns as integers supplied and containing all 
combinations of indices from 1 to the given integers. If no number is supplied, the function
returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For two integers
funData:::expand.int(2,5) # first column varies slowest

# For three integers
funData:::expand.int(2,3,4)
</code></pre>

<hr>
<h2 id='extractObs'>Extract observations of functional data</h2><span id='topic+extractObs'></span><span id='topic+subset+2CfunData-method'></span><span id='topic+subset+2CmultiFunData-method'></span><span id='topic+subset+2CirregFunData-method'></span><span id='topic++5B+2CfunData+2CANY+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CmultiFunData+2CANY+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CirregFunData+2CANY+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>This function extracts one or more observations and/or observations on
a part of the domain from a <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractObs(
  object,
  obs = seq_len(nObs(object)),
  argvals = funData::argvals(object)
)

## S4 method for signature 'funData'
subset(x, obs = seq_len(nObs(x)), argvals = funData::argvals(x))

## S4 method for signature 'multiFunData'
subset(x, obs = seq_len(nObs(x)), argvals = funData::argvals(x))

## S4 method for signature 'irregFunData'
subset(x, obs = seq_len(nObs(x)), argvals = funData::argvals(x))

## S4 method for signature 'funData,ANY,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'multiFunData,ANY,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'irregFunData,ANY,missing,missing'
x[i = seq_len(nObs(x)), j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractObs_+3A_object">object</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code>.</p>
</td></tr>
<tr><td><code id="extractObs_+3A_obs">obs</code></td>
<td>
<p>A numeric vector, giving the indices of the observations to
extract (default: all observations).</p>
</td></tr>
<tr><td><code id="extractObs_+3A_argvals">argvals</code></td>
<td>
<p>The part of the domain to be extracted (default: the
whole domain <code>object</code>@<code>argvals</code>). Must be a list or a
numeric vector (only for one-dimensional domains, see also the
definition of <code><a href="#topic+funData-class">funData</a></code>,
<code><a href="#topic+multiFunData-class">multiFunData</a></code>).</p>
</td></tr>
<tr><td><code id="extractObs_+3A_x">x</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code> (for <code>subset</code>).</p>
</td></tr>
<tr><td><code id="extractObs_+3A_i">i</code></td>
<td>
<p>A numeric vector, giving the indices of the observations to
extract when using <code>x[i]</code>. Defaults to all observations.</p>
</td></tr>
<tr><td><code id="extractObs_+3A_j">j</code>, <code id="extractObs_+3A_drop">drop</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="extractObs_+3A_...">...</code></td>
<td>
<p>Used to pass further arguments to <code>extractObs</code>. Here
only usable for <code>argvals</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of an <code>irregFunData</code> object, some functions may not have
observation points in the given part of the domain. In this case, the
functions are removed from the extracted dataset and a warning is
thrown.
</p>
<p>If only observations are to be extracted, the usual notation
<code>object[1:3]</code> is equivalent to <code>extractObs(object, obs =
1:3)</code>. This works only if the domain remains unchanged.
</p>


<h3>Value</h3>

<p>An object of class <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code> containing the desired observations.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>x[i</code>: 
</p>
</li></ul>


<h3>Warning</h3>

<p>The function is currently implemented only for
functional data with up to three-dimensional domains.
</p>


<h3>Alias</h3>

<p>The function <code>subset</code> is an alias for
<code>extractObs</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>,
<code><a href="#topic+irregFunData-class">irregFunData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate - one-dimensional domain
object1 &lt;- funData(argvals = 1:5, X = rbind(1:5, 6:10))
extractObs(object1, obs = 1)
extractObs(object1, argvals = 1:3)
extractObs(object1, argvals = list(1:3)) # the same as the statement before
# alias
subset(object1, argvals = 1:3)

# Univariate - two-dimensional domains
object2 &lt;- funData(argvals = list(1:5, 1:6), X = array(1:60, dim = c(2, 5, 6)))
extractObs(object2, obs = 1)
extractObs(object2, argvals = list(1:3, c(2,4,6))) # argvals must be supplied as list

# Univariate - irregular
irregObject &lt;- irregFunData(argvals = list(1:5, 2:4), X = list(2:6, 3:5))
extractObs(irregObject, obs = 2)
extractObs(irregObject, argvals = 1:3)
extractObs(irregObject, argvals = c(1,5)) # throws a warning, as second function has no observations

# Multivariate
multiObject &lt;- multiFunData(object1, object2)
extractObs(multiObject, obs = 2)
multiObject[2] # shorthand
extractObs(multiObject, argvals = list(1:3, list(1:3, c(2,4,6))))


### Shorthand via "[]"
object1[1]
object1[argvals = 1:3]
object2[1] 
object2[argvals = list(1:3, c(2,4,6))]
irregObject[2]
irregObject[argvals = 1:3]
</code></pre>

<hr>
<h2 id='extractObs+2CfunData-method'>extractObs for funData objects</h2><span id='topic+extractObs+2CfunData-method'></span>

<h3>Description</h3>

<p>extractObs for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
extractObs(
  object,
  obs = seq_len(nObs(object)),
  argvals = funData::argvals(object)
)
</code></pre>

<hr>
<h2 id='extractObs+2CirregFunData-method'>extractObs for irregular functional data</h2><span id='topic+extractObs+2CirregFunData-method'></span>

<h3>Description</h3>

<p>extractObs for irregular functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData'
extractObs(
  object,
  obs = seq_len(nObs(object)),
  argvals = funData::argvals(object)
)
</code></pre>

<hr>
<h2 id='extractObs+2CmultiFunData-method'>extractObs for multiFunData objects</h2><span id='topic+extractObs+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>extractObs for multiFunData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
extractObs(
  object,
  obs = seq_len(nObs(object)),
  argvals = funData::argvals(object)
)
</code></pre>

<hr>
<h2 id='extrapolateIrreg'>Extrapolate irregular functional data to a given domain</h2><span id='topic+extrapolateIrreg'></span>

<h3>Description</h3>

<p>This function extrapolates an <code>irregFunData</code> object to a given domain.
If only one point is observed, the function is extrapolated as a constant; in
all other cases it is extrapolated linearly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrapolateIrreg(object, rangex = range(object@argvals))
</code></pre>

<hr>
<h2 id='fd2funData'>Convert an fd object to funData</h2><span id='topic+fd2funData'></span>

<h3>Description</h3>

<p>This function converts an object of class <code><a href="fda.html#topic+fd">fd</a></code> (from
package <span class="pkg">fda</span>) to an object of class <code><a href="#topic+funData">funData</a></code>. It
heavily builds on the function <code><a href="fda.html#topic+eval.fd">eval.fd</a></code> from the
<span class="pkg">fda</span> package. The <code><a href="fda.html#topic+fd">fd</a></code> representation assumes a
basis representation for the observed functions and therefore
implicitly smoothes the data. In <code>funData</code> objects, the data is
saved in 'raw' format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd2funData(fdobj, argvals, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd2funData_+3A_fdobj">fdobj</code></td>
<td>
<p>An <code>fd</code> object</p>
</td></tr>
<tr><td><code id="fd2funData_+3A_argvals">argvals</code></td>
<td>
<p>A vector or a list of length one, containing a vector
with argument values at which the functions in <code>fdobj</code> should be
evaluated.</p>
</td></tr>
<tr><td><code id="fd2funData_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="fda.html#topic+eval.fd">eval.fd</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+funData">funData</a></code>.
</p>


<h3>Warning</h3>

<p>Time names in <code>fdobj$fdnames$time</code> are not
preserved.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="fda.html#topic+fd">fd</a></code>,
<code><a href="fda.html#topic+eval.fd">eval.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Install / load package fda before running the examples
library("fda")

# from Data2fd help
daybasis &lt;- create.fourier.basis(c(0, 365), nbasis=65)
# fd object of daily temperatures
tempfd &lt;- Data2fd(argvals = day.5, y = CanadianWeather$dailyAv[,,"Temperature.C"], daybasis)
# convert to funData
tempFun &lt;- fd2funData(tempfd, argvals = day.5)

# plot to compare
par(mfrow = c(1,2))
plot(tempfd, main = "fd object")
plot(tempFun, main = "funData object") 
</code></pre>

<hr>
<h2 id='flipFuns'>Flip functional data objects</h2><span id='topic+flipFuns'></span>

<h3>Description</h3>

<p>This function flips an object <code>newObject</code> of class <code>funData</code>, 
<code>irregFunData</code> or <code>multiFunData</code> with respect to a reference object
<code>refObject</code> of the same class (or of class <code>funData</code>, if 
<code>newObject</code> is irregular). This is particularly useful when dealing with
functional principal components, as they are only defined up to a sign 
change. For details, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipFuns(refObject, newObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipFuns_+3A_refobject">refObject</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code> that serves as reference. It must have the same number
of observations as <code>newObject</code> or have only one observation. In this
case, all observations in <code>newObject</code> are flipped with respect to this
single observation.</p>
</td></tr>
<tr><td><code id="flipFuns_+3A_newobject">newObject</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code> that is to be flipped with respect to <code>refObject</code>.</p>
</td></tr>
<tr><td><code id="flipFuns_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="#topic+norm">norm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional principal component analysis is an important tool in functional 
data analysis. Just as eigenvectors, eigenfunctions (or functional principal 
components) are only defined up to a sign change. This may lead to 
difficulties in simulation studies or when bootstrapping pointwise confidence
bands, as in these cases one wants the estimates to have the same 
&quot;orientation&quot; as the true function (in simulation settings) or the 
non-bootstrapped estimate (when calculating bootstrap confidence bands). This
function allows to flip (i.e. multiply by <code class="reqn">-1</code>) all observations in 
<code>newObject</code> that have a different orientation than their counterparts in
<code>refData</code>.
</p>
<p>Technically, the function compares the distance between <code>newObject</code> and 
<code>refObject</code> </p>
<p style="text-align: center;"><code class="reqn">|||f_\mathrm{new} - f_\mathrm{ref}|||</code>
</p>
<p> and the distance between  <code>newObject</code> and 
<code>-1 * refObject</code> </p>
<p style="text-align: center;"><code class="reqn">|||f_\mathrm{new} + f_\mathrm{ref}|||.</code>
</p>
<p> If <code>newObject</code> is closer to <code>-1 * refObject</code>, it is 
flipped, i.e. multiplied by -1.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>newData</code> with flipped 
observations.
</p>


<h3>Warning</h3>

<p>The function is currently implemented only for functional data with one- and 
two-dimensional domains.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>,
<code><a href="#topic+multiFunData-class">multiFunData</a></code>, <code><a href="#topic+Arith.funData">Arith.funData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Univariate
argvals &lt;- seq(0,2*pi,0.01)
refData &lt;- funData(argvals, rbind(sin(argvals))) # one observation as reference
newData &lt;- funData(argvals, outer(sample(c(-1,1), 11, replace = TRUE) * seq(0.75, 1.25, by = 0.05),
                               sin(argvals)))

oldpar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2))

plot(newData, col = "grey", main = "Original data")
plot(refData, col = "red", lwd = 2, add = TRUE)

plot(flipFuns(refData, newData), col = "grey", main = "Flipped data")
plot(refData, col = "red", lwd = 2, add = TRUE)

### Univariate (irregular)
ind &lt;- replicate(11, sort(sample(1:length(argvals), sample(5:10,1)))) # sample observation points
argvalsIrreg &lt;- lapply(ind, function(i){argvals[i]})
argvalsIrregAll &lt;- unique(sort(unlist(argvalsIrreg)))
 # one observation as reference (fully observed)
refDataFull &lt;- funData(argvals, rbind(sin(argvals)))
 # one observation as reference (irregularly observed)
refDataIrreg &lt;- irregFunData(argvals = list(argvalsIrregAll), X = list(sin(argvalsIrregAll)))
newData &lt;- irregFunData(argvals = argvalsIrreg, X = mapply(function(x, a, s){s * a * sin(x)},
     x = argvalsIrreg, a = seq(0.75, 1.25, by = 0.05), s = sample(c(-1,1), 11, replace = TRUE)))

plot(newData, col = "grey", main = "Original data (regular reference)")
plot(refDataFull, col = "red", lwd = 2, add = TRUE)

plot(flipFuns(refDataFull, newData), col = "grey", main = "Flipped data")
plot(refDataFull, col = "red", lwd = 2, add = TRUE)

plot(newData, col = "grey", main = "Original data (irregular reference)")
plot(refDataIrreg, col = "red", lwd = 2, add = TRUE)

plot(flipFuns(refDataIrreg, newData), col = "grey", main = "Flipped data")
plot(refDataIrreg, col = "red", lwd = 2, add = TRUE)

### Multivariate
refData &lt;- multiFunData(funData(argvals, rbind(sin(argvals))), # one observation as reference
                        funData(argvals, rbind(cos(argvals)))) 
sig &lt;- sample(c(-1,1), 11, replace = TRUE) 
newData &lt;- multiFunData(funData(argvals, outer(sig * seq(0.75, 1.25, by = 0.05), sin(argvals))),
                        funData(argvals, outer(sig * seq(0.75, 1.25, by = 0.05), cos(argvals))))
                        
par(mfrow = c(2,2))

plot(newData[[1]], col = topo.colors(11), main = "Original data")
plot(refData[[1]], col = "red", lwd = 2, add = TRUE)

plot(newData[[2]], col = topo.colors(11), main = "Original data")
plot(refData[[2]], col = "red", lwd = 2, add = TRUE)

plot(flipFuns(refData, newData)[[1]], col = topo.colors(11), main = "Flipped data")
plot(refData[[1]], col = "red", lwd = 2, add = TRUE)

plot(flipFuns(refData, newData)[[2]], col = topo.colors(11), main = "Flipped data")
plot(refData[[2]], col = "red", lwd = 2, add = TRUE)

par(oldpar)
</code></pre>

<hr>
<h2 id='flipFuns+2CfunData+2CfunData-method'>Flip univariate functional data</h2><span id='topic+flipFuns+2CfunData+2CfunData-method'></span>

<h3>Description</h3>

<p>Flip univariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData,funData'
flipFuns(refObject, newObject)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+flipFuns">flipFuns</a></code>
</p>

<hr>
<h2 id='flipFuns+2CfunData+2CirregFunData-method'>Flip irregular functional data - funData as reference</h2><span id='topic+flipFuns+2CfunData+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Flip irregular functional data - funData as reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData,irregFunData'
flipFuns(refObject, newObject, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+flipFuns">flipFuns</a></code>
</p>

<hr>
<h2 id='flipFuns+2CirregFunData+2CirregFunData-method'>Flip irregular functional data - irregFunData as reference</h2><span id='topic+flipFuns+2CirregFunData+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Flip irregular functional data - irregFunData as reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData,irregFunData'
flipFuns(refObject, newObject, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+flipFuns">flipFuns</a></code>
</p>

<hr>
<h2 id='flipFuns+2CmultiFunData+2CmultiFunData-method'>Flip multivariate functional data</h2><span id='topic+flipFuns+2CmultiFunData+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>Flip multivariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData,multiFunData'
flipFuns(refObject, newObject)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+flipFuns">flipFuns</a></code>
</p>

<hr>
<h2 id='funData-class'>A class for (univariate) functional data</h2><span id='topic+funData-class'></span><span id='topic+funData'></span><span id='topic+funData+2Clist+2Carray-method'></span><span id='topic+funData+2Cnumeric+2Carray-method'></span><span id='topic+show+2CfunData-method'></span><span id='topic+names+2CfunData-method'></span><span id='topic+names+3C-+2CfunData-method'></span><span id='topic+str+2CfunData-method'></span><span id='topic+summary+2CfunData-method'></span>

<h3>Description</h3>

<p>The <code>funData</code> class represents functional data on <code class="reqn">d</code>-dimensional
domains. The two slots represent the domain (x-values) and the values of the 
different observations (y-values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funData(argvals, X)

## S4 method for signature 'list,array'
funData(argvals, X)

## S4 method for signature 'numeric,array'
funData(argvals, X)

## S4 method for signature 'funData'
show(object)

## S4 method for signature 'funData'
names(x)

## S4 replacement method for signature 'funData'
names(x) &lt;- value

## S4 method for signature 'funData'
str(object, ...)

## S4 method for signature 'funData'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funData-class_+3A_argvals">argvals</code></td>
<td>
<p>A list of numeric vectors or a single numeric vector, giving the 
sampling points in the domains. See Details.</p>
</td></tr>
<tr><td><code id="funData-class_+3A_x">X</code></td>
<td>
<p>An array of dimension  <code class="reqn">N \times M</code> (for one-dimensional
domains, or <code class="reqn">N \times M_1 \times \ldots \times M_d</code> for higher-dimensional domains), giving the observed values for
<code class="reqn">N</code> individuals. Missing values can be included via <code>NA</code>. See
Details.</p>
</td></tr>
<tr><td><code id="funData-class_+3A_object">object</code></td>
<td>
<p>A <code>funData</code> object.</p>
</td></tr>
<tr><td><code id="funData-class_+3A_x">x</code></td>
<td>
<p>The <code>funData</code> object.</p>
</td></tr>
<tr><td><code id="funData-class_+3A_value">value</code></td>
<td>
<p>The names to be given to the <code>funData</code> curves.</p>
</td></tr>
<tr><td><code id="funData-class_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>summary</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional data can be seen as realizations of a random process </p>
<p style="text-align: center;"><code class="reqn">X: 
\mathcal{T} \to \mathrm{IR}</code>
</p>
<p> on a <code class="reqn">d</code>-dimensional 
domain <code class="reqn">\mathcal{T}</code>. The data is usually sampled on a fine grid 
<code class="reqn">T \subset \mathcal{T}</code>, which is represented in the 
<code>argvals</code> slot of a <code>funData</code> object. All observations are assumed 
to be sampled over the same grid <code class="reqn">T</code>, but can contain missing values 
(see below). If <code class="reqn">\mathcal{T}</code> is one-dimensional, <code>argvals</code> 
can be supplied either as a numeric vector, containing the x-values or as a 
list, containing such a vector. If <code class="reqn">\mathcal{T}</code> is 
higher-dimensional, <code>argvals</code> must always be supplied as a list, 
containing numeric vectors of the x-values in dimensions 
<code class="reqn">1,\ldots,d</code>.
</p>
<p>The observed values are represented in the <code>X</code> slot of a <code>funData</code> 
object, which is an array of dimension  <code class="reqn">N \times M</code> (for 
one-dimensional domains, or <code class="reqn">N \times M_1 \times \ldots \times M_d</code> for higher-dimensional domains). Here <code class="reqn">N</code> equals 
the number of observations and <code class="reqn">M</code> denotes the number of sampling 
points (for higher dimensional domains <code class="reqn">M_i</code> denotes the number of
sampling points in dimension <code class="reqn">i, i = 1,\ldots, d</code>).
Missing values in the observations are allowed and must be marked by
<code>NA</code>. If missing values occur due to irregular observation points, the
data can be stored alternatively as an object of class
<code><a href="#topic+irregFunData-class">irregFunData</a></code>.
</p>
<p>Generic functions for the <code>funData</code> class include a print method, 
<a href="#topic+plot.funData">plotting</a> and <a href="#topic+Arith.funData">basic arithmetics</a>. 
Further methods for <code>funData</code>: </p>
 <ul>
<li> <p><code><a href="#topic+dimSupp">dimSupp</a></code>, 
<code><a href="#topic+nObs">nObs</a></code>: Informations about the support dimensions and the number 
of observations, </p>
</li>
<li> <p><code><a href="#topic+getArgvals">getArgvals</a></code>, <code><a href="#topic+extractObs">extractObs</a></code>: 
Getting/Setting slot values (instead of accessing them directly via 
<code>funData@argvals, funData@X</code>) and extracting single observations or 
data on a subset of the domain, </p>
</li>
<li> <p><code><a href="#topic+integrate">integrate</a></code>, 
<code><a href="#topic+norm">norm</a></code>: Integrate all observations over their domain or 
calculating the <code class="reqn">L^2</code> norm.</p>
</li></ul>

<p>A <code>funData</code> object can be coerced to a <code>multiFunData</code> object using 
<code>as.multiFunData(funDataObject).</code>
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>funData(argvals = list, X = array)</code>: Constructor for functional data objects with <code>argvals</code> given as list.
</p>
</li>
<li> <p><code>funData(argvals = numeric, X = array)</code>: Constructor for functional data objects with <code>argvals</code>
given as vector of numerics (only valid for one-dimensional domains).
</p>
</li>
<li> <p><code>show(funData)</code>: Print basic information about the <code>funData</code> object
in the console. The default console output for <code>funData</code> objects.
</p>
</li>
<li> <p><code>names(funData)</code>: Get the names of the <code>funData</code> object.
</p>
</li>
<li> <p><code>names(funData) &lt;- value</code>: Set the names of the <code>funData</code> object.
</p>
</li>
<li> <p><code>str(funData)</code>: A <code>str</code> method for <code>funData</code> objects, giving a compact overview of the structure.
</p>
</li>
<li> <p><code>summary(funData)</code>: A <code>summary</code> method for <code>funData</code> objects.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>funData()</code>: Constructor for functional data objects, first argument (argvals) passed as list or vector of numerics
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>argvals</code></dt><dd><p>The domain <code class="reqn">\mathcal{T}</code> of the data. See Details.</p>
</dd>
<dt><code>X</code></dt><dd><p>The functional data samples. See Details.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+irregFunData-class">irregFunData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Creating a one-dimensional funData object with 2 observations
# Basic
f1 &lt;- new("funData", argvals = list(1:5), X = rbind(1:5,6:10))
# Using the constructor with first argument supplied as array
f2 &lt;- funData(argvals = list(1:5), X = rbind(1:5, 6:10)) 
# Using the constructor with first argument supplied as numeric vector
f3 &lt;- funData(argvals = 1:5, X = rbind(1:5, 6:10)) 
# Test if all the same
all.equal(f1,f2) 
all.equal(f1,f3)
# Display funData object in the console
f3 

# A more realistic object
argvals &lt;- seq(0,2*pi,0.01)
object &lt;- funData(argvals, outer(seq(0.75, 1.25, by = 0.05), sin(argvals)))
# Display / summary give basic information
object 
summary(object)
# Use the plot function to get an impression of the data
plot(object) 


### Higher-dimensional funData objects with 2 observations
# Basic
g1 &lt;- new("funData", argvals = list(1:5, 1:3),
                     X = array(1:30, dim = c(2,5,3))) 
# Using the constructor
g2 &lt;- funData(argvals = list(1:5, 1:3),
              X = array(1:30, dim = c(2,5,3)))
# Test if the same
all.equal(g1,g2)
# Display funData object in the console
g2 
# Summarize information
summary(g2)
</code></pre>

<hr>
<h2 id='funData-setAs'>Coerce a funData object to class multiFunData</h2><span id='topic+funData-setAs'></span>

<h3>Description</h3>

<p>Coerce a funData object to class multiFunData
</p>
<p>Coerce a funData object to class irregFunData
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+as.multiFunData">as.multiFunData</a></code>
</p>
<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+as.irregFunData">as.irregFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create funData object with 5 observations
f &lt;- simFunData(N = 5, M = 7, eValType = "linear",
                eFunType = "Fourier", argvals = seq(0,1,0.01))$simData

# sparsify artificially
fSparse &lt;- sparsify(f, minObs = 4, maxObs = 10)

# coerce to irregFunData object
i &lt;- as.irregFunData(fSparse)
i
</code></pre>

<hr>
<h2 id='funData2fd'>Convert a funData object to fd</h2><span id='topic+funData2fd'></span>

<h3>Description</h3>

<p>This function converts an object of class <code><a href="#topic+funData">funData</a></code> to an
object of class <code><a href="fda.html#topic+fd">fd</a></code> (from package <span class="pkg">fda</span>). It
heavily builds on the function <code><a href="fda.html#topic+Data2fd">Data2fd</a></code> from the
<span class="pkg">fda</span> package. The <code><a href="fda.html#topic+fd">fd</a></code> representation assumes a
basis representation for the observed functions and therefore
implicitly smoothes the data. In <code>funData</code> objects, the data is
saved in 'raw' format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funData2fd(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funData2fd_+3A_object">object</code></td>
<td>
<p>A <code>funData</code> object</p>
</td></tr>
<tr><td><code id="funData2fd_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="fda.html#topic+Data2fd">Data2fd</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="fda.html#topic+fd">fd</a></code>.
</p>


<h3>Warning</h3>

<p>This function works only for funData objects on
one-dimensional domains.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="fda.html#topic+fd">fd</a></code>,
<code><a href="fda.html#topic+Data2fd">Data2fd</a></code>, <code><a href="#topic+fd2funData">fd2funData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Install / load package fda before running the examples
library("fda")

# from Data2fd help
daybasis &lt;- create.fourier.basis(c(0, 365), nbasis=65)
# funData object with temperature
tempFun &lt;- funData(day.5, t(CanadianWeather$dailyAv[, , "Temperature.C"]))
# convert to fd
tempfd &lt;- funData2fd(tempFun, daybasis)

# plot to compare
par(mfrow = c(1,2))
plot(tempFun, main = "funData object (raw data)")
plot(tempfd, main = "fd object (smoothed)")
</code></pre>

<hr>
<h2 id='ggplot'>ggplot Graphics for Functional Data Objects</h2><span id='topic+ggplot'></span><span id='topic+ggplot+2CfunData-method'></span><span id='topic+ggplot+2CmultiFunData-method'></span><span id='topic+ggplot+2CirregFunData-method'></span>

<h3>Description</h3>

<p>This function is deprecated. Use <code><a href="#topic+autoplot.funData">autoplot.funData</a></code> /
<code><a href="#topic+autolayer.funData">autolayer.funData</a></code> for <code>funData</code> objects,
<code><a href="#topic+autoplot.multiFunData">autoplot.multiFunData</a></code> for <code>multiFunData</code> objects and
<code><a href="#topic+autoplot.irregFunData">autoplot.irregFunData</a></code> /
<code><a href="#topic+autolayer.irregFunData">autolayer.irregFunData</a></code> for <code>irregFunData</code> objects
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot(data, ...)

## S4 method for signature 'funData'
ggplot(data, add = FALSE, ...)

## S4 method for signature 'multiFunData'
ggplot(data, ...)

## S4 method for signature 'irregFunData'
ggplot(data, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_+3A_data">data</code></td>
<td>
<p>A <code>funData</code>, <code>multiFunData</code> or
<code>irregFunData</code> object.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_...">...</code></td>
<td>
<p>Further parameters passed to the class-specific methods.</p>
</td></tr>
<tr><td><code id="ggplot_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, add to current plot (only for 
one-dimensional functions). Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the default case, this function calls <a href="ggplot2.html#topic+ggplot">ggplot</a> (if available).
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>,
<code><a href="ggplot2.html#topic+autoplot">autoplot</a></code>, <code><a href="ggplot2.html#topic+autolayer">autolayer</a></code>
from package <span class="pkg">ggplot2</span>
</p>

<hr>
<h2 id='integrate'>Integrate functional data</h2><span id='topic+integrate'></span>

<h3>Description</h3>

<p>Integrate all observations of a <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code> object over their domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_+3A_object">object</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code>.</p>
</td></tr>
<tr><td><code id="integrate_+3A_...">...</code></td>
<td>
<p>Further parameters (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further parameters passed to this function may include: </p>
 <ul>
<li>
<p><code>method</code>: Character string. The integration rule to be used, passed to
the internal function <code>.intWeights</code>. Defaults to <code>"trapezoidal"</code>
(alternative: <code>"midpoint"</code>). </p>
</li>
<li> <p><code>fullDom</code>: Logical. If
<code>object</code> is of class <code>irregFunData</code>, setting fullDom = <code>TRUE</code>
extrapolates all functions linearly to the full domain before calculating the
integrals. Defaults to <code>FALSE</code>. For details on the extrapolation, see
<code><a href="#topic+extrapolateIrreg">extrapolateIrreg</a></code>.</p>
</li></ul>



<h3>Value</h3>

<p>A vector of numerics, containing the integral values for each
observation.
</p>


<h3>Warning</h3>

<p>The function is currently implemented only for functional
data with up to three-dimensional domains. In the default case, this
function calls <a href="stats.html#topic+integrate">integrate</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>,
<code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate
object &lt;- funData(argvals = 1:5, X = rbind(1:5, 6:10))
integrate(object)

# Univariate (irregular)
irregObject &lt;-irregFunData(argvals = list(1:5, 2:4), X = list(2:6, 3:5))
integrate(irregObject) # fullDom = FALSE
integrate(irregObject, fullDom = TRUE)

# Multivariate
multiObject &lt;- multiFunData(object, funData(argvals = 1:3, X = rbind(3:5, 6:8)))
integrate(multiObject)
</code></pre>

<hr>
<h2 id='integrate+2CfunData-method'>Integrate method for funData objects</h2><span id='topic+integrate+2CfunData-method'></span>

<h3>Description</h3>

<p>Integrate method for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
integrate(object, method = "trapezoidal")
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+funData-class">funData</a></code>
</p>

<hr>
<h2 id='integrate+2CirregFunData-method'>Integrate method for irregular functional data objects</h2><span id='topic+integrate+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Integrate method for irregular functional data objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData'
integrate(object, method = "trapezoidal", fullDom = FALSE)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>
</p>

<hr>
<h2 id='integrate+2CmultiFunData-method'>Integrate method for multiFunData objects</h2><span id='topic+integrate+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>Integrate method for multiFunData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
integrate(object, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>

<hr>
<h2 id='integrate3D'>Integrate a function on a rectangular 3D grid</h2><span id='topic+integrate3D'></span>

<h3>Description</h3>

<p>Integrate a function on a rectangular 3D grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate3D(f, argvals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate3D_+3A_f">f</code></td>
<td>
<p>A 3D array, representing the function evaluations on the grid</p>
</td></tr>
<tr><td><code id="integrate3D_+3A_argvals">argvals</code></td>
<td>
<p>A list with 3 elements, representing the grid points in the first, second and third dimension of f</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the numerical integration of f on the given grid.
</p>

<hr>
<h2 id='irregFunData-class'>A class for irregularly sampled functional data</h2><span id='topic+irregFunData-class'></span><span id='topic+irregFunData'></span><span id='topic+irregFunData+2Clist+2Clist-method'></span><span id='topic+show+2CirregFunData-method'></span><span id='topic+names+2CirregFunData-method'></span><span id='topic+names+3C-+2CirregFunData-method'></span><span id='topic+str+2CirregFunData-method'></span><span id='topic+summary+2CirregFunData-method'></span>

<h3>Description</h3>

<p>The <code>irregFunData</code> class represents functional data that is sampled 
irregularly on one-dimensional domains. The two slots represent the 
observation points (x-values) and the observed function values (y-values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irregFunData(argvals, X)

## S4 method for signature 'list,list'
irregFunData(argvals, X)

## S4 method for signature 'irregFunData'
show(object)

## S4 method for signature 'irregFunData'
names(x)

## S4 replacement method for signature 'irregFunData'
names(x) &lt;- value

## S4 method for signature 'irregFunData'
str(object, ...)

## S4 method for signature 'irregFunData'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irregFunData-class_+3A_argvals">argvals</code></td>
<td>
<p>A list of numerics, corresponding to the observation points for each realization <code class="reqn">X_i</code> (see Details).</p>
</td></tr>
<tr><td><code id="irregFunData-class_+3A_x">X</code></td>
<td>
<p>A list of numerics, corresponding to the observed functions <code class="reqn">X_i</code> (see Details).</p>
</td></tr>
<tr><td><code id="irregFunData-class_+3A_object">object</code></td>
<td>
<p>An <code>irregFunData</code> object.</p>
</td></tr>
<tr><td><code id="irregFunData-class_+3A_x">x</code></td>
<td>
<p>The <code>irregFunData</code> object.</p>
</td></tr>
<tr><td><code id="irregFunData-class_+3A_value">value</code></td>
<td>
<p>The names to be given to the <code>irregFunData</code> curves.</p>
</td></tr>
<tr><td><code id="irregFunData-class_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>summary</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Irregular functional data are realizations of a random process </p>
<p style="text-align: center;"><code class="reqn">X: 
\mathcal{T} \to \mathrm{IR},</code>
</p>
<p> where each realization 
<code class="reqn">X_i</code> of <code class="reqn">X</code> is given on an individual grid <code class="reqn">T_i \subset 
\mathcal{T}</code> of observation points. As for the 
<code><a href="#topic+funData-class">funData</a></code> class, each object of the <code>irregFunData</code>
class has two slots; the <code>argvals</code> slot represents the observation
points and the <code>X</code> slot represents the observed data. In contrast to the
regularly sampled data, both slots are defined as lists of vectors, where
each entry corresponds to one observed function: </p>
<ul>
<li>
<p><code>argvals[[i]]</code> contains the vector of observation points <code class="reqn">T_i</code> for
the i-th function, </p>
</li>
<li> <p><code>X[[i]]</code> contains the corresponding observed
data <code class="reqn">X_i(t_{ij}), t_{ij} \in T_i</code>.</p>
</li></ul>

<p>Generic functions for the <code>irregFunData</code> class include a print method, 
<a href="#topic+plot.irregFunData">plotting</a> and <a href="#topic+Arith.funData">basic 
arithmetics</a>. Further methods for <code>irregFunData</code>: </p>
 <ul>
<li> 
<p><code><a href="#topic+dimSupp">dimSupp</a></code>, <code><a href="#topic+nObs">nObs</a></code>: Informations about the support 
dimensions and the number of observations, </p>
</li>
<li> <p><code><a href="#topic+getArgvals">getArgvals</a></code>, 
<code><a href="#topic+extractObs">extractObs</a></code>: Getting/setting slot values (instead of accessing 
them directly via <code>irregObject@argvals, irregObject@X</code>) and extracting
single observations or data on a subset of the domain, </p>
</li>
<li> 
<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+norm">norm</a></code>: Integrate all observations over 
their domain or calculating the <code class="reqn">L^2</code> norm.</p>
</li></ul>

<p>An <code>irregFunData</code> object can be coerced to a <code>funData</code> object using
<code>as.funData(irregObject)</code>. The regular functional data object is defined
on the union of all observation grids of the irregular object. The value of 
the new object is marked as missing (<code>NA</code>) for observation points that 
are in the union, but not in the original observation grid.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>irregFunData(argvals = list, X = list)</code>: Constructor for irregular functional data
objects.
</p>
</li>
<li> <p><code>show(irregFunData)</code>: Print basic information about the <code>irregFunData</code> object
in the console. The default console output for <code>irregFunData</code> objects.
</p>
</li>
<li> <p><code>names(irregFunData)</code>: Get the names of the <code>irregFunData</code> object.
</p>
</li>
<li> <p><code>names(irregFunData) &lt;- value</code>: Set the names of the <code>irregFunData</code> object.
</p>
</li>
<li> <p><code>str(irregFunData)</code>: A <code>str</code> method for <code>irregFunData</code> objects, giving a compact overview of the structure.
</p>
</li>
<li> <p><code>summary(irregFunData)</code>: A <code>summary</code> method for <code>irregFunData</code> objects.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>irregFunData()</code>: Constructor for irregular functional data objects
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>argvals</code></dt><dd><p>A list of numerics, representing the observation grid <code class="reqn">T_i</code>
for each realization <code class="reqn">X_i</code> of <code class="reqn">X</code>.</p>
</dd>
<dt><code>X</code></dt><dd><p>A list of numerics, representing the values of each observation 
<code class="reqn">X_i</code> of <code class="reqn">X</code> on the corresponding observation points <code class="reqn">T_i</code>.</p>
</dd>
</dl>


<h3>Warning</h3>

<p>Currently, the class is implemented only for functional 
data on one-dimensional domains <code class="reqn">\mathcal{T} \subset \mathrm{IR}</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct an irregular functional data object
i1 &lt;- irregFunData(argvals = list(1:5, 2:4), X = list(2:6, 3:5))
# Display in the console
i1
# Summarize
summary(i1)

# A more realistic object
argvals &lt;- seq(0,2*pi, 0.01)
ind &lt;- replicate(11, sort(sample(1:length(argvals), sample(5:10,1)))) # sample observation points
argvalsIrreg &lt;- lapply(ind, function(i){argvals[i]})
i2 &lt;- irregFunData(argvals = argvalsIrreg, X = mapply(function(x, a){a * sin(x)},
             x = argvalsIrreg, a = seq(0.75, 1.25, by = 0.05)))
# Display/summary gives basic information
i2
summary(i2)
# Use the plot function to get an impression of the data
plot(i2) 
</code></pre>

<hr>
<h2 id='irregFunData-setAs'>Coerce an irregFunData object to class funData</h2><span id='topic+irregFunData-setAs'></span>

<h3>Description</h3>

<p>Coerce an irregFunData object to class funData
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+as.funData">as.funData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create irregFunData object with 2 observations
i1 &lt;- irregFunData(argvals = list(1:5, 3:6), X = list(2:6, 4:7))
i1@argvals # argvals and X are both lists with 2 entries
i1@X

# coerce to funData object (with missing values)
f1 &lt;- as.funData(i1)
# argvals is a list containing one vector
# (one-dimensional domain, union of all observation points)
f1@argvals
# X is a matrix with 2 rows and missing values
f1@X
</code></pre>

<hr>
<h2 id='Math.funData'>Mathematical operations for functional data objects</h2><span id='topic+Math.funData'></span><span id='topic+Math+2CfunData-method'></span><span id='topic+Math+2CmultiFunData-method'></span><span id='topic+Math+2CirregFunData-method'></span>

<h3>Description</h3>

<p>These functions allow to apply mathematical operations (such as <code class="reqn">exp(),
log(), sin(), cos()</code> or <code class="reqn">abs()</code> to functional data objects based on
<code><a href="methods.html#topic+Math">Math</a></code>.  The operations are made pointwise for each
observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
Math(x)

## S4 method for signature 'multiFunData'
Math(x)

## S4 method for signature 'irregFunData'
Math(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math.funData_+3A_x">x</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or
<code>multiFunData</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same functional data class as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>,
<code><a href="#topic+multiFunData-class">multiFunData</a></code>, <a href="methods.html#topic+Math">Math</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2))

# simulate a funData object on 0..1 with 10 observations
argvals &lt;- seq(0, 1, 0.01)
f &lt;- simFunData(argvals = argvals, N = 10, 
                M = 5, eFunType = "Fourier", eValType = "linear")$simData

### FunData
plot(f, main = "Original data")
plot(abs(f), main = "Absolute values")

### Irregular
# create an irrgFunData object by sparsifying f
i &lt;- as.irregFunData(sparsify(f, minObs = 5, maxObs = 10))

plot(i, main = "Sparse data")
plot(cumsum(i), main = "'cumsum' of sparse data")

### Multivariate
m &lt;- multiFunData(f, -1*f)
plot(m, main = "Multivariate Data")
plot(exp(m), main = "Exponential")

par(oldpar)
</code></pre>

<hr>
<h2 id='meanFunction'>Mean for functional data</h2><span id='topic+meanFunction'></span>

<h3>Description</h3>

<p>This function calculates the pointwise mean function for objects of class 
<code>funData</code>, <code>irregFunData</code> or <code>multiFunData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanFunction(object, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanFunction_+3A_object">object</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or 
<code>multiFunData</code>.</p>
</td></tr>
<tr><td><code id="meanFunction_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>TRUE</code>, NA values are removed before computing 
the mean. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>object</code> with one observation 
that corresponds to the pointwise mean function of the functions in 
<code>object</code>.
</p>


<h3>Warning</h3>

<p>If <code>object</code> is of class <code>irregFunData</code>, the option <code>na.rm =
TRUE</code> is not implemented and throws an error. If <code>na.rm = FALSE</code>, the
functions must be observed on the same domain.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>, 
<code><a href="#topic+multiFunData-class">multiFunData</a></code>, <code><a href="#topic+Arith.funData">Arith.funData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Univariate (one-dimensional support)
x &lt;- seq(0, 2*pi, 0.01)
f1 &lt;- funData(x, outer(seq(0.75, 1.25, 0.05), sin(x)))

plot(f1)
plot(meanFunction(f1), col = 1, lwd = 2, add = TRUE)

### Univariate (two-dimensional support)
f2 &lt;- funData(list(1:5, 1:3), array(rep(1:5,each = 11, times = 3), dim = c(11,5,3)))
all.equal(f2[1], meanFunction(f2)) # f2 has 11 identical observations

### Multivariate
m1 &lt;- multiFunData(f1,f2)
all.equal(m1[6], meanFunction(m1)) # observation 6 equals the pointwise mean

### Irregular
i1 &lt;- irregFunData(argvals = list(1:3,1:3,1:3), X = list(1:3,2:4,3:5))
all.equal(meanFunction(i1), i1[2])
# don't run: functions are not defined on the same domain
## Not run: meanFunction(irregFunData(argvals = list(1:3,1:5), X = list(1:3,1:5))) 
</code></pre>

<hr>
<h2 id='meanFunction+2CfunData-method'>Mean for functional data</h2><span id='topic+meanFunction+2CfunData-method'></span>

<h3>Description</h3>

<p>Mean for functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
meanFunction(object, na.rm = FALSE)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+meanFunction">meanFunction</a></code>
</p>

<hr>
<h2 id='meanFunction+2CirregFunData-method'>Mean for irregular functional data</h2><span id='topic+meanFunction+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Mean for irregular functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData'
meanFunction(object, na.rm = FALSE)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+meanFunction">meanFunction</a></code>
</p>

<hr>
<h2 id='meanFunction+2CmultiFunData-method'>Mean for multivariate functional data</h2><span id='topic+meanFunction+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>Mean for multivariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
meanFunction(object, na.rm = FALSE)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+meanFunction">meanFunction</a></code>
</p>

<hr>
<h2 id='multiFunData-class'>A class for multivariate functional data</h2><span id='topic+multiFunData-class'></span><span id='topic+multiFunData'></span><span id='topic+multiFunData+2CANY-method'></span><span id='topic+names+2CmultiFunData-method'></span><span id='topic+names+3C-+2CmultiFunData-method'></span><span id='topic+str+2CmultiFunData-method'></span><span id='topic+summary+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>The <code>multiFunData</code> class represents multivariate functional data on 
(potentially) different domains, i.e. a multivariate functional data object 
is a vector of (univariate) functional data objects, just as a vector in 
<code class="reqn">\mathrm{IR}^n</code> is a vector of <code class="reqn">n</code> scalars. In this implementation, a 
<code>multiFunData</code> object is represented as a list of univariate 
<code>funData</code> objects, see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiFunData(...)

## S4 method for signature 'ANY'
multiFunData(...)

## S4 method for signature 'multiFunData'
names(x)

## S4 replacement method for signature 'multiFunData'
names(x) &lt;- value

## S4 method for signature 'multiFunData'
str(object, ...)

## S4 method for signature 'multiFunData'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiFunData-class_+3A_...">...</code></td>
<td>
<p>A list of funData objects or several funData objects passed as one
argument, each. See Details.</p>
</td></tr>
<tr><td><code id="multiFunData-class_+3A_x">x</code></td>
<td>
<p>The <code>multiFunData</code> object.</p>
</td></tr>
<tr><td><code id="multiFunData-class_+3A_value">value</code></td>
<td>
<p>The names to be given to the <code>multiFunData</code> curves.</p>
</td></tr>
<tr><td><code id="multiFunData-class_+3A_object">object</code></td>
<td>
<p>A <code>multiFunData</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>multiFunData</code> object is represented as a list of univariate 
<code>funData</code> objects, each having a <code>argvals</code> and <code>X</code> slot, 
representing the x-values and the observed y-values (see the 
<code><a href="#topic+funData">funData</a></code> class). When constructing a <code>multiFunData</code> object,
the  elements can be supplied as a list of <code>funData</code> objects or can be
passed directly as arguments to the constructor function.
</p>
<p>Most functions implemented for the <code><a href="#topic+funData">funData</a></code> class are also 
implemented for <code>multiFunData</code> objects. In most cases, they simply apply
the corresponding univariate method to each element of the multivariate 
object and return it as a vector (if the result of the univariate function is
scalar, such as <code><a href="#topic+dimSupp">dimSupp</a></code>) or as a <code>multiFunData</code> object (if
the result of the univariate function is a <code>funData</code> object, such as 
<code><a href="#topic+extractObs">extractObs</a></code>).
</p>
<p>The norm of a multivariate functional data <code class="reqn">f = (f_1 , \ldots, f_p)</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">||| f ||| := \left(\sum_{j=1}^p ||
f_j ||^2 \right) ^{1/2}.</code>
</p>

<p>A <code>funData</code> object can be coerced to a <code>multiFunData</code> object with
one element using <code>as.multiFunData(funDataObject).</code>
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>multiFunData(ANY)</code>: Constructor for multivariate functional data
objects.
</p>
</li>
<li> <p><code>names(multiFunData)</code>: Get the names of the <code>multiFunData</code> object.
</p>
</li>
<li> <p><code>names(multiFunData) &lt;- value</code>: Set the names of the <code>multiFunData</code> object.
</p>
</li>
<li> <p><code>str(multiFunData)</code>: A <code>str</code> method for <code>multiFunData</code> objects, giving a compact overview of the structure.
</p>
</li>
<li> <p><code>summary(multiFunData)</code>: A <code>summary</code> method for <code>multiFunData</code> objects.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>multiFunData()</code>: Constructor for multivariate functional data objects
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Creating a multifunData object with 2 observations on the same domain
# Univariate elements
x &lt;- 1:5
f1 &lt;- funData(x, rbind(x, x+1))
f2 &lt;- funData(x,rbind(x^2, sin(x)))
# Basic
m1 &lt;- new("multiFunData", list(f1,f2))
# Using the constructor, passing the elements as list
m2 &lt;- multiFunData(list(f1,f2))
# Using the constructor, passing the elements directly
m3 &lt;- multiFunData(f1,f2)
# Test if all the same
all.equal(m1,m2)
all.equal(m1,m3)
# Display multiFunData object in the console
m3
# Summarize
summary(m3)

### Creating a multifunData object with 2 observations on different domains (both 1D)
# A new element
y &lt;- 1:3
g1 &lt;- funData(y, rbind(3*y, y+4))
# Create the multiFunData object
m4 &lt;- multiFunData(f1,g1)
# Display multiFunData object in the console
m4

### Creating a multifunData object with 2 observations on different domains (1D and 2D)
# A new element
y &lt;- 1:3; z &lt;- 1:4
g2 &lt;- funData(list(y,z), array(rnorm(24), dim = c(2,3,4)))
# Create the multiFunData object
m5 &lt;- multiFunData(f1,g2)
# Display multiFunData object in the console
m5

### A more realistic object
# element 1
x &lt;- seq(0,2*pi, 0.01)
f1 &lt;- funData(x, outer(seq(0.75, 1.25, length.out = 6), sin(x)))
# element 2
y &lt;- seq(-1,1, 0.01); z &lt;- seq(-0.5, 0.5, 0.01)
X2 &lt;- array(NA, c(6, length(y), length(z)))
for(i in 1:6) X2[i,,] &lt;- outer(y, z, function(x,y){sin(i*pi*y)*cos(i*pi*z)})
f2 &lt;- funData(list(y,z), X2)
# MultiFunData Object
m6 &lt;- multiFunData(f1,f2)
# Display multiFunData object in the console for basic information
m6
# Summarize
summary(m6)
# Use the plot function to get an impression of the data
## Not run: plot(m6) # m6 has 2D element, must specify one observation for plotting
plot(m6, obs = 1, main = c("1st element (obs 1)", "2nd element (obs 1)"))
plot(m6, obs = 6, main = c("1st element (obs 6)", "2nd element (obs 6)"))
</code></pre>

<hr>
<h2 id='nObs'>Get the number of observations</h2><span id='topic+nObs'></span>

<h3>Description</h3>

<p>This functions returns the number of observations in a <code>funData</code>, <code>irregFunData</code> or <code>multiFunData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nObs(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nObs_+3A_object">object</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or <code>multiFunData</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of observations in <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate
object &lt;- funData(argvals = 1:5, X = rbind(1:5, 6:10))
nObs(object)

# Univariate (irregular)
irregObject &lt;- irregFunData(argvals = list(1:5, 2:4), X = list(2:6, 3:5))
nObs(irregObject)

# Multivariate
multiObject &lt;- multiFunData(object, funData(argvals = 1:3, X = rbind(3:5, 6:8)))
nObs(multiObject)
</code></pre>

<hr>
<h2 id='nObs+2CfunData-method'>nObs for funData objects</h2><span id='topic+nObs+2CfunData-method'></span>

<h3>Description</h3>

<p>nObs for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
nObs(object)
</code></pre>

<hr>
<h2 id='nObs+2CirregFunData-method'>nObs for irregular functional data objects</h2><span id='topic+nObs+2CirregFunData-method'></span>

<h3>Description</h3>

<p>nObs for irregular functional data objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData'
nObs(object)
</code></pre>

<hr>
<h2 id='nObs+2CmultiFunData-method'>nObs for multiFunData objects</h2><span id='topic+nObs+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>nObs for multiFunData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
nObs(object)
</code></pre>

<hr>
<h2 id='nObsPoints'>Get the number of observation points</h2><span id='topic+nObsPoints'></span>

<h3>Description</h3>

<p>This functions returns the number of observation points in an object of class
<code>funData</code>, <code>multiFunData</code> or <code>irregFunData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nObsPoints(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nObsPoints_+3A_object">object</code></td>
<td>
<p>An object of class <code>funData</code>, <code>multiFunData</code> or 
<code>irregFunData</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the class of <code>object</code>, the function returns different 
values: </p>
 <ul>
<li><p> If <code>object</code> is of class <code>funData</code>, the 
function returns a vector of length <code>dimSupp(object)</code>, giving the number
of observations in each dimension. </p>
</li>
<li><p> If <code>object</code> is of class 
<code>multiFunData</code>, the function returns a list of the same length as 
<code>object</code>, where the <code>j</code>-th entry is a vector, corresponding to the 
observations point of <code>object[[j]]</code>. </p>
</li>
<li><p> If <code>object</code> is of class
<code>irregFunData</code>, the function returns an array of length
<code>nObs(object)</code>, where the <code>j</code>-th entry corresponds to the number of
observations in the <code>j</code>-th observed function.</p>
</li></ul>



<h3>Value</h3>

<p>The number of observation points in <code>object</code>. See Details.
</p>


<h3>Warning</h3>

<p>Do not confound with <code><a href="#topic+nObs">nObs</a></code>, which returns the 
number of observations (i.e. the number of observed functions) in an object
of a functional data class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irregFunData-class">irregFunData</a></code>, <code><a href="#topic+extractObs">extractObs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate (one-dimensional)
object1 &lt;- funData(argvals = 1:5, X = rbind(1:5, 6:10))
nObsPoints(object1)

# Univariate (two-dimensional)
object2 &lt;- funData(argvals = list(1:5, 1:6), X = array(1:60, dim = c(2, 5, 6)))
nObsPoints(object2)

# Multivariate
multiObject &lt;- multiFunData(object1, object2)
nObsPoints(multiObject)

# Univariate (irregular)
irregObject &lt;- irregFunData(argvals = list(1:5, 2:4), X = list(2:6, 3:5))
nObsPoints(irregObject)
</code></pre>

<hr>
<h2 id='nObsPoints+2CfunData-method'>nObsPoints for funData objects</h2><span id='topic+nObsPoints+2CfunData-method'></span>

<h3>Description</h3>

<p>nObsPoints for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
nObsPoints(object)
</code></pre>

<hr>
<h2 id='nObsPoints+2CirregFunData-method'>nObsPoints for irregular functional data objects</h2><span id='topic+nObsPoints+2CirregFunData-method'></span>

<h3>Description</h3>

<p>nObsPoints for irregular functional data objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData'
nObsPoints(object)
</code></pre>

<hr>
<h2 id='nObsPoints+2CmultiFunData-method'>nObsPoints for multiFunData objects</h2><span id='topic+nObsPoints+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>nObsPoints for multiFunData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
nObsPoints(object)
</code></pre>

<hr>
<h2 id='norm'>Calculate the norm of functional data</h2><span id='topic+norm'></span>

<h3>Description</h3>

<p>This function calculates the norm for each observation of a <code>funData</code>, 
<code>irregFunData</code> or <code>multiFunData</code> object.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_+3A_object">object</code></td>
<td>
<p>An object of class <code>funData</code>, <code>irregFunData</code> or 
<code>multiFunData</code>.</p>
</td></tr>
<tr><td><code id="norm_+3A_...">...</code></td>
<td>
<p>Further parameters (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>funData</code> objects, the standard <code class="reqn">L^2</code> norm is calculated: 
</p>
<p style="text-align: center;"><code class="reqn">||f|| = \left( \int_{\mathcal{T}} f(t)^2 dt \right)^{1/2}.</code>
</p>
<p> For <code>irregFunData</code> objects, each observed function is
integrated only on the observed grid points (unless <code>fullDom = TRUE</code>).
</p>
<p>The (weighted) norm of a multivariate functional data object <code class="reqn">f = (f_1 ,
\ldots, f_p)</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">||| f ||| :=
\left(\sum_{j=1}^p w_j || f_j ||^2 \right) ^{1/2}.</code>
</p>

<p>Further parameters passed to this function may include: </p>
 <ul>
<li> 
<p><code>squared</code>: Logical. If <code>TRUE</code> (default), the function calculates 
the squared norm, otherwise the result is not squared. </p>
</li>
<li> <p><code>obs</code>: A 
numeric vector, giving the indices of the observations, for which the norm is
to be calculated. Defaults to all observations. </p>
</li>
<li> <p><code>method</code>: A 
character string, giving the integration method to be used. See 
<code><a href="#topic+integrate">integrate</a></code> for details. </p>
</li>
<li> <p><code>weight</code>: An optional vector
of weights for the scalar product; particularly useful for multivariate 
functional data, where each entry can be weighted in the scalar product / 
norm. Defaults to <code>1</code> for each element. </p>
</li>
<li> <p><code>fullDom</code>: Logical.
If <code>object</code> is of class <code><a href="#topic+irregFunData-class">irregFunData</a></code> and
<code>fullDom = TRUE</code>, all functions are extrapolated to the same domain.
Defaults to <code>FALSE</code>. See <code><a href="#topic+integrate">integrate</a></code> for details. </p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector representing the norm of each observation.
</p>


<h3>Warning</h3>

<p>The function is currently implemented only for functional 
data with one- and two-dimensional domains.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>, 
<code><a href="#topic+multiFunData-class">multiFunData</a></code>, <code><a href="#topic+integrate">integrate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate
object &lt;- funData(argvals = 1:5, X = rbind(1:5, 6:10))
norm(object)

# Univariate (irregular)
irregObject &lt;- irregFunData(argvals = list(1:5, 2:4), X = list(2:6, 3:5))
norm(irregObject) # no extrapolation
norm(irregObject, fullDom = TRUE) # extrapolation (of second function)

# Multivariate
multiObject &lt;- multiFunData(object, funData(argvals = 1:3, X = rbind(3:5, 6:8)))
norm(multiObject)
norm(multiObject, weight = c(2,1)) # with weight vector, giving more weight to the first element
</code></pre>

<hr>
<h2 id='norm+2CfunData+2Cmissing-method'>Calculate the norm for univariate functional data</h2><span id='topic+norm+2CfunData+2Cmissing-method'></span>

<h3>Description</h3>

<p>Calculate the norm for univariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData,missing'
norm(
  x,
  squared = TRUE,
  obs = seq_len(nObs(x)),
  method = "trapezoidal",
  weight = 1
)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+norm">norm</a></code>, <code><a href="#topic+funData-class">funData</a></code>
</p>

<hr>
<h2 id='norm+2CirregFunData+2Cmissing-method'>Calculate the norm for irregular functional data</h2><span id='topic+norm+2CirregFunData+2Cmissing-method'></span>

<h3>Description</h3>

<p>Calculate the norm for irregular functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData,missing'
norm(
  x,
  squared = TRUE,
  obs = seq_len(nObs(x)),
  method = "trapezoidal",
  weight = 1,
  fullDom = FALSE
)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+norm">norm</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>
</p>

<hr>
<h2 id='norm+2CmultiFunData+2Cmissing-method'>Calculate the norm for multivariate functional data</h2><span id='topic+norm+2CmultiFunData+2Cmissing-method'></span>

<h3>Description</h3>

<p>Calculate the norm for multivariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData,missing'
norm(
  x,
  squared = TRUE,
  obs = seq_len(nObs(x)),
  method = "trapezoidal",
  weight = rep(1, length(x))
)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+norm">norm</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>
</p>

<hr>
<h2 id='norm.funData'>Calculate the norm for univariate functional data</h2><span id='topic+norm.funData'></span>

<h3>Description</h3>

<p>Calculate the norm for univariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.funData(object, squared, obs, method, weight)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+norm">norm</a></code>
</p>

<hr>
<h2 id='norm.irregFunData'>Calculate the norm for irregular functional data</h2><span id='topic+norm.irregFunData'></span>

<h3>Description</h3>

<p>Calculate the norm for irregular functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.irregFunData(object, squared, obs, method, weight, fullDom)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+norm">norm</a></code>
</p>

<hr>
<h2 id='plot.funData'>Plotting univariate functional data</h2><span id='topic+plot.funData'></span><span id='topic+plot+2CfunData+2Cmissing-method'></span>

<h3>Description</h3>

<p>This function plots observations of univariate functional data on their 
domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funData'
plot(
  x,
  y,
  obs = seq_len(nObs(x)),
  type = "l",
  lty = 1,
  lwd = 1,
  col = NULL,
  xlab = "argvals",
  ylab = "",
  legend = TRUE,
  plotNA = FALSE,
  add = FALSE,
  ...
)

## S4 method for signature 'funData,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.funData_+3A_x">x</code></td>
<td>
<p>An object of class <code>funData</code>.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_y">y</code></td>
<td>
<p>Missing.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_obs">obs</code></td>
<td>
<p>A vector of numerics giving the observations to plot. Defaults to 
all observations in <code>x</code>. For two-dimensional functions (images) 
<code>obs</code> must have length 1.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_type">type</code></td>
<td>
<p>The type of plot. Defaults to <code>"l"</code> (line plot). See 
<code><a href="graphics.html#topic+plot">plot</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_lty">lty</code></td>
<td>
<p>The line type. Defaults to <code>1</code> (solid line). See 
<code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_lwd">lwd</code></td>
<td>
<p>The line width. Defaults to <code>1</code>. See
<code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_col">col</code></td>
<td>
<p>The color of the functions. If not supplied (<code>NULL</code>, default 
value), one-dimensional functions are plotted in the 
<code><a href="grDevices.html#topic+rainbow">rainbow</a></code> palette and two-dimensional functions are 
plotted using <code><a href="fields.html#topic+tim.colors">tim.colors</a></code> from package 
<code><a href="fields.html#topic+fields-package">fields-package</a></code>.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_xlab">xlab</code>, <code id="plot.funData_+3A_ylab">ylab</code></td>
<td>
<p>The titles for x- and y-axis. Defaults to <code>"argvals"</code>
for the x-axis and no title for the y-axis. See
<code><a href="graphics.html#topic+plot">plot</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_legend">legend</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a color legend is plotted for 
two-dimensional functions (images). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_plotna">plotNA</code></td>
<td>
<p>Logical. If <code>TRUE</code>, missing values are interpolated using
the <a href="#topic+approxNA">approxNA</a> function (only for one-dimensional functions). Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, add to current plot (only for 
one-dimensional functions). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.funData_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+matplot">matplot</a> </code> 
(one-dimensional functions) or <code><a href="fields.html#topic+image.plot">image.plot</a></code>/ 
<code><a href="graphics.html#topic+image">image</a></code> (two-dimensional functions).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If some observations contain missing values (coded via <code>NA</code>), the 
functions can be interpolated using the option <code>plotNA = TRUE</code>. This 
option relies on the <code><a href="zoo.html#topic+na.approx">na.approx</a></code> function in package 
<code><a href="zoo.html#topic+zoo">zoo</a></code> and is currently implemented for one-dimensional 
functions only in the function <code><a href="#topic+approxNA">approxNA</a></code>.
</p>


<h3>Warning</h3>

<p>The function is currently implemented only for functional 
data with one- and two-dimensional domains.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>, 
<code><a href="fields.html#topic+image.plot">image.plot</a></code>, <code><a href="graphics.html#topic+image">image</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)

# One-dimensional
argvals &lt;- seq(0,2*pi,0.01)
object &lt;- funData(argvals,
                   outer(seq(0.75, 1.25, length.out = 11), sin(argvals)))

plot(object, main = "One-dimensional functional data")

# Two-dimensional
X &lt;- array(0, dim = c(2, length(argvals), length(argvals)))
X[1,,] &lt;- outer(argvals, argvals, function(x,y){sin((x-pi)^2 + (y-pi)^2)})
X[2,,] &lt;- outer(argvals, argvals, function(x,y){sin(2*x*pi) * cos(2*y*pi)})
object2D &lt;- funData(list(argvals, argvals), X)

plot(object2D, main = "Two-dimensional functional data (obs 1)", obs = 1)
plot(object2D, main = "Two-dimensional functional data (obs 2)", obs = 2)
## Not run: plot(object2D, main = "Two-dimensional functional data") # must specify obs!


### More examples ###
par(mfrow = c(1,1))

# using plotNA
if(requireNamespace("zoo", quietly = TRUE))
{
objectMissing &lt;- funData(1:5, rbind(c(1, NA, 5, 4, 3), c(10, 9, NA, NA, 6)))
par(mfrow = c(1,2))
plot(objectMissing, type = "b", pch = 20, main = "plotNA = FALSE") # the default
plot(objectMissing, type = "b", pch = 20, plotNA = TRUE, main = "plotNA = TRUE") # requires zoo
}

# Changing colors
plot(object, main = "1D functional data in grey", col = "grey")
plot(object, main = "1D functional data in heat.colors", col = heat.colors(nObs(object)))

plot(object2D, main = "2D functional data in topo.colors", obs = 1, col = topo.colors(64))
par(oldpar)

</code></pre>

<hr>
<h2 id='plot.irregFunData'>Plotting irregular functional data</h2><span id='topic+plot.irregFunData'></span><span id='topic+plot+2CirregFunData+2Cmissing-method'></span>

<h3>Description</h3>

<p>This function plots observations of irregular functional data on their domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'irregFunData'
plot(
  x,
  y,
  obs = seq_len(nObs(x)),
  type = "b",
  pch = 20,
  col = grDevices::rainbow(length(obs)),
  xlab = "argvals",
  ylab = "",
  xlim = range(x@argvals[obs]),
  ylim = range(x@X[obs]),
  log = "",
  add = FALSE,
  ...
)

## S4 method for signature 'irregFunData,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.irregFunData_+3A_x">x</code></td>
<td>
<p>An object of class <code>irregFunData</code>.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_y">y</code></td>
<td>
<p>Missing.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_obs">obs</code></td>
<td>
<p>A vector of numerics giving the observations to plot. Defaults to all observations in 
<code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_type">type</code></td>
<td>
<p>The type of plot. Defaults to <code>"b"</code> (line and point plot). See 
<code><a href="graphics.html#topic+plot">plot</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_pch">pch</code></td>
<td>
<p>The point type. Defaults to <code>20</code> (solid small circles). See 
<code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_col">col</code></td>
<td>
<p>The color of the functions. Defaults to the <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> palette.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_xlab">xlab</code>, <code id="plot.irregFunData_+3A_ylab">ylab</code></td>
<td>
<p>The titles for x- and y-axis. Defaults to <code>"argvals"</code> for the x-axis and no
title for the y-axis. See <code><a href="graphics.html#topic+plot">plot</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_xlim">xlim</code>, <code id="plot.irregFunData_+3A_ylim">ylim</code></td>
<td>
<p>The limits for x- and y-axis. Defaults to the total range of the data that is to
plot. See <code><a href="graphics.html#topic+plot">plot</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_log">log</code></td>
<td>
<p>A character string, specifying the axis that is to be logarithmic. Can be <code>""</code> 
(non-logarithmic axis, the default), <code>"x", "y", "xy"</code> or <code>"yx"</code>. See 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> for details. This parameter is ignored, if <code>add =
TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, add to current plot (only for one-dimensional functions). 
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.irregFunData_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.funData">plot.funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code>, 
<code><a href="graphics.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)

# Generate data
argvals &lt;- seq(0,2*pi,0.01)
ind &lt;- replicate(5, sort(sample(1:length(argvals), sample(5:10,1))))
object &lt;- irregFunData(argvals = lapply(ind, function(i){argvals[i]}),
                  X = lapply(ind, function(i){sample(1:10,1) / 10 * argvals[i]^2}))

plot(object, main = "Irregular functional data")

par(oldpar)
</code></pre>

<hr>
<h2 id='plot.multiFunData'>Plotting multivariate functional data</h2><span id='topic+plot.multiFunData'></span><span id='topic+plot+2CmultiFunData+2Cmissing-method'></span>

<h3>Description</h3>

<p>This function plots observations of multivariate functional data on their domain. The graphic
device is split in a number of subplots (specified by <code>dim</code>) via <code>mfrow</code>
(<code><a href="graphics.html#topic+par">par</a></code>) and the univariate elements are plotted using <code>plot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiFunData'
plot(
  x,
  y,
  obs = seq_len(nObs(x)),
  dim = seq_len(length(x)),
  par.plot = NULL,
  main = names(x),
  xlab = "argvals",
  ylab = "",
  log = "",
  ylim = NULL,
  ...
)

## S4 method for signature 'multiFunData,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.multiFunData_+3A_x">x</code></td>
<td>
<p>An object of class <code>multiFunData</code>.</p>
</td></tr>
<tr><td><code id="plot.multiFunData_+3A_y">y</code></td>
<td>
<p>Missing.</p>
</td></tr>
<tr><td><code id="plot.multiFunData_+3A_obs">obs</code></td>
<td>
<p>A vector of numerics giving the observations to plot. Defaults to 
all observations in <code>x</code>. For two-dimensional functions (images) 
<code>obs</code> must have length 1.</p>
</td></tr>
<tr><td><code id="plot.multiFunData_+3A_dim">dim</code></td>
<td>
<p>The dimensions to plot. Defaults to <code>length(x)</code>, i.e. all 
functions in <code>x</code> are plotted.</p>
</td></tr>
<tr><td><code id="plot.multiFunData_+3A_par.plot">par.plot</code></td>
<td>
<p>Graphic parameters to be passed to the plotting regions. The 
option <code>mfrow</code> is ignored. Defaults to <code>NULL</code>. See 
<code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.multiFunData_+3A_main">main</code></td>
<td>
<p>A string vector, giving the title of the plot. Can have the same 
length as <code>dim</code> (different titles for each dimension) or length 
<code>1</code> (one title for all dimensions). Defaults to <code>names(x)</code>.</p>
</td></tr>
<tr><td><code id="plot.multiFunData_+3A_xlab">xlab</code>, <code id="plot.multiFunData_+3A_ylab">ylab</code></td>
<td>
<p>The titles for x- and y-axis. Defaults to <code>"argvals"</code> 
for the x-axis and no title for the y-axis for all elements. Can be 
supplied as a vector of the same length as <code>dim</code> (one x-/y-lab for each 
element) or a single string that is applied for all elements. See 
<code><a href="graphics.html#topic+plot">plot</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.multiFunData_+3A_log">log</code></td>
<td>
<p>A character string, specifying the axis that is to be logarithmic.
Can be <code>""</code> (non-logarithmic axis), <code>"x", "y", "xy"</code> or 
<code>"yx"</code>. Defaults to <code>""</code> for all plots. Can be supplied as a 
vector of the same length as <code>dim</code> (one log-specification for each 
element) or a single string that is applied for all elements. See 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.multiFunData_+3A_ylim">ylim</code></td>
<td>
<p>Specifies the limits of the y-Axis. Can be either <code>NULL</code> 
(the default, limits are chosen automatically), a vector of length 2 
(giving the minimum and maximum range for all elements at the same time) or
a list of the same length as <code>dim</code> (specifying the limits for each
element separately).</p>
</td></tr>
<tr><td><code id="plot.multiFunData_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The function is currently implemented only for functional data with one- and
two-dimensional domains.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>, 
<code><a href="#topic+plot.funData">plot.funData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)
argvals &lt;- seq(0, 2*pi, 0.1)

# One-dimensional elements
f1 &lt;- funData(argvals, outer(seq(0.75, 1.25, length.out = 11), sin(argvals)))
f2 &lt;- funData(argvals, outer(seq(0.75, 1.25, length.out = 11), cos(argvals)))

m1 &lt;- multiFunData(f1, f2)
plot(m1, main = c("1st element", "2nd element")) # different titles
plot(m1, main = "Multivariate Functional Data") # one title for all

# Mixed-dimensional elements
X &lt;- array(0, dim = c(11, length(argvals), length(argvals)))
X[1,,] &lt;- outer(argvals, argvals, function(x,y){sin((x-pi)^2 + (y-pi)^2)})
g &lt;- funData(list(argvals, argvals), X)

m2 &lt;- multiFunData(f1, g)
# different titles and labels
plot(m2, main = c("1st element", "2nd element"), obs = 1,
     xlab = c("xlab1", "xlab2"), 
     ylab = "one ylab for all")
# one title for all
plot(m2, main = "Multivariate Functional Data", obs = 1) 

## Not run: plot(m2, main = c("1st element", "2nd element")) # must specify obs!

par(oldpar)
</code></pre>

<hr>
<h2 id='print.funData'>A print method for univariate functional data</h2><span id='topic+print.funData'></span>

<h3>Description</h3>

<p>This function prints basic information about a <code>funData</code> object. This is
the standard console output for <code>funData</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'funData'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.funData_+3A_x">x</code></td>
<td>
<p>A <code>funData</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='print.irregFunData'>A print method for irregular functional data</h2><span id='topic+print.irregFunData'></span>

<h3>Description</h3>

<p>This function prints basic information about a <code>irregFunData</code> object. This is
the standard console output for <code>irregFunData</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'irregFunData'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.irregFunData_+3A_x">x</code></td>
<td>
<p>An <code>irregFunData</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='scalarProduct'>Calculate the scalar product for functional data objects</h2><span id='topic+scalarProduct'></span>

<h3>Description</h3>

<p>This function calculates the scalar product between two objects of the class 
<code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+irregFunData-class">irregFunData</a></code> and 
<code><a href="#topic+multiFunData-class">multiFunData</a></code>. For univariate functions <code class="reqn">f,g</code> on a
domain <code class="reqn">\mathcal{T}</code>, the scalar product is defined as 
</p>
<p style="text-align: center;"><code class="reqn">\int_\mathcal{T} f(t) g(t) \mathrm{d}t</code>
</p>
<p> and 
for multivariate functions <code class="reqn">f,g</code> on domains <code class="reqn">\mathcal{T}_1, \ldots, 
\mathcal{T}_p</code>, it is defined as </p>
<p style="text-align: center;"><code class="reqn">\sum_{j = 1}^p
\int_{\mathcal{T}_j} f^{(j)}(t) g^{(j)}(t) \mathrm{d}t.</code>
</p>
<p> As seen in the formula, the objects 
must be defined on the same domain. The scalar product is calculated pairwise
for all observations, thus the objects must also have the same number of 
observations or one object may have only one observation (for which the 
scalar product is calculated with all observations of the other object)). 
Objects of the classes <code><a href="#topic+funData">funData</a></code> and <code><a href="#topic+irregFunData">irregFunData</a></code> 
can be combined, see <code><a href="#topic+integrate">integrate</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalarProduct(object1, object2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalarProduct_+3A_object1">object1</code>, <code id="scalarProduct_+3A_object2">object2</code></td>
<td>
<p>Two objects of class<code><a href="#topic+funData">funData</a></code>, 
<code><a href="#topic+irregFunData">irregFunData</a></code> or <code><a href="#topic+multiFunData">multiFunData</a></code>, for that the 
scalar product is to be calculated.</p>
</td></tr>
<tr><td><code id="scalarProduct_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="#topic+integrate">integrate</a></code>. For
<code><a href="#topic+multiFunData-class">multiFunData</a></code> objects, one can also pass a
<code>weight</code> argument. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code><a href="#topic+multiFunData-class">multiFunData</a></code> one can pass an optional vector
<code>weight</code> for calculating a weighted scalar product. This vector must
have the same number of elements as the <code><a href="#topic+multiFunData">multiFunData</a></code> objects
and have to be non-negative with at least one weight that is different from
0. Defaults to <code>1</code> for each element. See also <code><a href="#topic+norm">norm</a></code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>nObs(object1)</code> (or <code>nObs(object2)</code>, if 
<code>object1</code> has only one observation), containing the pairwise scalar 
product for each observation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+norm">norm</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create two funData objectw with 5 observations on [0,1]
f &lt;- simFunData(N = 5, M = 7, eValType = "linear",
                eFunType = "Fourier", argvals = seq(0,1,0.01))$simData
g &lt;- simFunData(N = 5, M = 4, eValType = "linear",
                eFunType = "Poly", argvals = seq(0,1,0.01))$simData
                
# calculate the scalar product
scalarProduct(f,g)

# the scalar product of an object with itself equals the squared norm
all.equal(scalarProduct(f,f), norm(f, squared = TRUE))

# This works of course also for multiFunData objects...
m &lt;- multiFunData(f,g)
all.equal(scalarProduct(m,m), norm(m, squared = TRUE))

# ...and for irregFunData objects
i &lt;- as.irregFunData(sparsify(f, minObs = 5, maxObs = 10))
all.equal(scalarProduct(i,i), norm(i, squared = TRUE))

# Scalar product between funData and irregFunData objects
scalarProduct(i,f)

# Weighted scalar product for multiFunData objects
scalarProduct(m,m, weight = c(1,2))
</code></pre>

<hr>
<h2 id='scalarProduct+2CfunData+2CfunData-method'>Scalar product for functional data</h2><span id='topic+scalarProduct+2CfunData+2CfunData-method'></span>

<h3>Description</h3>

<p>Scalar product for functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData,funData'
scalarProduct(object1, object2, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+norm">norm</a></code>.
</p>

<hr>
<h2 id='scalarProduct+2CfunData+2CirregFunData-method'>Scalar product for irregular and functional data</h2><span id='topic+scalarProduct+2CfunData+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Scalar product for irregular and functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData,irregFunData'
scalarProduct(object1, object2, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+norm">norm</a></code>.
</p>

<hr>
<h2 id='scalarProduct+2CirregFunData+2CfunData-method'>Scalar product for irregular and functional data</h2><span id='topic+scalarProduct+2CirregFunData+2CfunData-method'></span>

<h3>Description</h3>

<p>Scalar product for irregular and functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData,funData'
scalarProduct(object1, object2, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+norm">norm</a></code>.
</p>

<hr>
<h2 id='scalarProduct+2CirregFunData+2CirregFunData-method'>Scalar product for irregular functional data</h2><span id='topic+scalarProduct+2CirregFunData+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Scalar product for irregular functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData,irregFunData'
scalarProduct(object1, object2, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+norm">norm</a></code>.
</p>

<hr>
<h2 id='scalarProduct+2CmultiFunData+2CmultiFunData-method'>Scalar product for multivariate functional data</h2><span id='topic+scalarProduct+2CmultiFunData+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>Scalar product for multivariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData,multiFunData'
scalarProduct(object1, object2, weight = rep(1, length(object1)), ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+integrate">integrate</a></code>, <code><a href="#topic+norm">norm</a></code>.
</p>

<hr>
<h2 id='simFunData'>Simulate univariate functional data</h2><span id='topic+simFunData'></span>

<h3>Description</h3>

<p>This functions simulates (univariate) functional data <code class="reqn">f_1,\ldots, f_N</code> based on a truncated 
Karhunen-Loeve representation: </p>
<p style="text-align: center;"><code class="reqn">f_i(t) = \sum_{m = 1}^M \xi_{i,m} \phi_m(t).</code>
</p>
<p> on one- or
higher-dimensional domains. The eigenfunctions (basis functions) <code class="reqn">\phi_m(t)</code> are generated 
using <code><a href="#topic+eFun">eFun</a></code>, the scores <code class="reqn">\xi_{i,m}</code> are simulated independently from a normal
distribution with zero mean and decreasing variance based on the <code><a href="#topic+eVal">eVal</a></code> function. For
higher-dimensional domains, the eigenfunctions are constructed as tensors of marginal orthonormal
function systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simFunData(argvals, M, eFunType, ignoreDeg = NULL, eValType, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simFunData_+3A_argvals">argvals</code></td>
<td>
<p>A numeric vector, containing the observation points (a fine grid on a real
interval) of the functional data that is to be simulated or a list of the marginal observation points.</p>
</td></tr>
<tr><td><code id="simFunData_+3A_m">M</code></td>
<td>
<p>An integer, giving the number of univariate basis functions to use. For higher-dimensional data, <code>M</code> is a vector with the marginal number of eigenfunctions. See Details.</p>
</td></tr>
<tr><td><code id="simFunData_+3A_efuntype">eFunType</code></td>
<td>
<p>A character string specifying the type of univariate orthonormal basis functions
to use. For data on higher-dimensional domains, <code>eFunType</code> can be a vector, specifying the marginal type of eigenfunctions to use in the tensor product. See <code><a href="#topic+eFun">eFun</a></code> for details.</p>
</td></tr>
<tr><td><code id="simFunData_+3A_ignoredeg">ignoreDeg</code></td>
<td>
<p>A vector of integers, specifying the degrees to ignore when generating the
univariate orthonormal bases. Defaults to <code>NULL</code>. For higher-dimensional data, <code>ignoreDeg</code> can be supplied as list with vectors for each marginal. See <code><a href="#topic+eFun">eFun</a></code> for details.</p>
</td></tr>
<tr><td><code id="simFunData_+3A_evaltype">eValType</code></td>
<td>
<p>A character string, specifying the type of eigenvalues/variances used for the
generation of the simulated functions based on the truncated Karhunen-Loeve representation. See
<code><a href="#topic+eVal">eVal</a></code> for details.</p>
</td></tr>
<tr><td><code id="simFunData_+3A_n">N</code></td>
<td>
<p>An integer, specifying the number of multivariate functions to be generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>simData</code></td>
<td>
<p>A <code><a href="#topic+funData-class">funData</a></code> object with <code>N</code> observations,
representing the simulated functional data.</p>
</td></tr> <tr><td><code>trueFuns</code></td>
<td>
<p>A <code><a href="#topic+funData-class">funData</a></code>
object with <code>M</code> observations, representing the true eigenfunction basis used for
simulating the data.</p>
</td></tr> <tr><td><code>trueVals</code></td>
<td>
<p>A vector of numerics, representing the true eigenvalues
used for simulating the data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+eFun">eFun</a></code>, <code><a href="#topic+eVal">eVal</a></code>, 
<code><a href="#topic+addError">addError</a></code>, <code><a href="#topic+sparsify">sparsify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(no.readonly = TRUE)

# Use Legendre polynomials as eigenfunctions and a linear eigenvalue decrease
test &lt;- simFunData(seq(0,1,0.01), M = 10, eFunType = "Poly", eValType = "linear", N = 10)

plot(test$trueFuns, main = "True Eigenfunctions")
plot(test$simData, main = "Simulated Data")

# The use of ignoreDeg for eFunType = "PolyHigh"
test &lt;- simFunData(seq(0,1,0.01), M = 4, eFunType = "Poly", eValType = "linear", N = 10)
test_noConst &lt;-  simFunData(seq(0,1,0.01), M = 4, eFunType = "PolyHigh",
                            ignoreDeg = 1, eValType = "linear", N = 10)
test_noLinear &lt;-  simFunData(seq(0,1,0.01), M = 4, eFunType = "PolyHigh",
                             ignoreDeg = 2, eValType = "linear", N = 10)
test_noBoth &lt;-  simFunData(seq(0,1,0.01), M = 4, eFunType = "PolyHigh",
                           ignoreDeg = 1:2, eValType = "linear", N = 10)

par(mfrow = c(2,2))
plot(test$trueFuns, main = "Standard polynomial basis (M = 4)")
plot(test_noConst$trueFuns, main = "No constant basis function")
plot(test_noLinear$trueFuns, main = "No linear basis function")
plot(test_noBoth$trueFuns, main = "Neither linear nor constant basis function")

# Higher-dimensional domains
simImages &lt;- simFunData(argvals = list(seq(0,1,0.01), seq(-pi/2, pi/2, 0.02)), 
             M = c(5,4), eFunType = c("Wiener","Fourier"), eValType = "linear", N = 4)
for(i in 1:4) 
   plot(simImages$simData, obs = i, main = paste("Observation", i))
               
par(oldPar)
</code></pre>

<hr>
<h2 id='simMultiFunData'>Simulate multivariate functional data</h2><span id='topic+simMultiFunData'></span>

<h3>Description</h3>

<p>This function provides a unified simulation structure for multivariate 
functional data <code class="reqn">f_1, \ldots, f_N</code> on one- or two-dimensional domains, 
based on a truncated multivariate Karhunen-Loeve representation: </p>
<p style="text-align: center;"><code class="reqn">f_i(t)
= \sum_{m = 1}^M \rho_{i,m} \psi_m(t).</code>
</p>
<p> The multivariate eigenfunctions 
(basis functions) <code class="reqn">\psi_m</code>  are constructed from univariate orthonormal 
bases. There are two different concepts for the construction, that can be 
chosen by the parameter <code>type</code>: A split orthonormal basis (<code>split</code>,
only one-dimensional domains) and weighted univariate orthonormal bases 
(<code>weighted</code>, one- and two-dimensional domains). The scores 
<code class="reqn">\rho_{i,m}</code> in the Karhunen-Loeve representation are simulated 
independently from a normal distribution with zero mean and decreasing 
variance. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMultiFunData(type, argvals, M, eFunType, ignoreDeg = NULL, eValType, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simMultiFunData_+3A_type">type</code></td>
<td>
<p>A character string, specifying the construction method for the 
multivariate eigenfunctions (either <code>"split"</code> or <code>"weighted"</code>). 
See Details.</p>
</td></tr>
<tr><td><code id="simMultiFunData_+3A_argvals">argvals</code></td>
<td>
<p>A list, containing the observation points for each element of 
the multivariate functional data that is to be simulated. The length of 
<code>argvals</code> determines the number of elements in the resulting simulated
multivariate functional data. See Details.</p>
</td></tr>
<tr><td><code id="simMultiFunData_+3A_m">M</code></td>
<td>
<p>An integer (<code>type = "split"</code>) or a list of integers (<code>type
= "weighted"</code>), giving the number of univariate basis functions to use. See 
Details.</p>
</td></tr>
<tr><td><code id="simMultiFunData_+3A_efuntype">eFunType</code></td>
<td>
<p>A character string (<code>type = "split"</code>)   or a list of 
character strings (<code>type = "weighted"</code>), specifying the type of 
univariate orthonormal basis functions to use. See Details.</p>
</td></tr>
<tr><td><code id="simMultiFunData_+3A_ignoredeg">ignoreDeg</code></td>
<td>
<p>A vector of integers (<code>type = "split"</code>)   or a list of 
integer vectors (<code>type = "weighted"</code>), specifying the degrees to 
ignore when generating the univariate orthonormal bases. Defaults to 
<code>NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="simMultiFunData_+3A_evaltype">eValType</code></td>
<td>
<p>A character string, specifying the type of 
eigenvalues/variances used for the simulation of the multivariate functions
based on the truncated Karhunen-Loeve representation. See 
<code><a href="#topic+eVal">eVal</a></code> for details.</p>
</td></tr>
<tr><td><code id="simMultiFunData_+3A_n">N</code></td>
<td>
<p>An integer, specifying the number of multivariate functions to be 
generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>type</code> defines how the eigenfunction basis for the 
multivariate Karhunen-Loeve representation is constructed: </p>
 <ul>
<li> 
<p><code>type = "split"</code>: The basis functions of an underlying 'big' orthonormal
basis are split in <code>M</code> parts, translated and possibly reflected. This 
yields an orthonormal basis of multivariate functions with <code>M</code> 
elements. This option is implemented only for one-dimensional domains. </p>
</li>
<li> 
<p><code>type = "weighted":</code> The multivariate eigenfunction basis consists of 
weighted univariate orthonormal bases.  This yields an orthonormal basis of 
multivariate functions with <code>M</code> elements. For data on two-dimensional 
domains (images), the univariate basis is constructed as a tensor product of 
univariate bases in each direction (x- and y-direction). </p>
</li></ul>

<p>Depending on <code>type</code>, the other parameters have to be specified as 
follows: </p>


<h4>Split 'big' orthonormal basis</h4>

<p> The parameters <code>M</code> 
(integer), <code>eFunType</code> (character string) and <code>ignoreDeg</code> (integer 
vector or <code>NULL</code>) are passed to the function <code><a href="#topic+eFun">eFun</a></code> to 
generate a univariate orthonormal basis on a 'big' interval. Subsequently, 
the basis functions are split and translated, such that the <code class="reqn">j</code>-th part 
of the split function is defined on the interval corresponding to 
<code>argvals[[j]]</code>. The elements of the multivariate basis functions are 
given by these split parts of the original basis functions multiplied by a 
random sign <code class="reqn">\sigma_j \in \{-1,1\}, j = 1, \ldots, p</code>.</p>



<h4>Weighted orthonormal bases</h4>

<p> The parameters <code>argvals, M, 
eFunType</code> and <code>ignoreDeg</code> are all lists of a similar structure. They are
passed element-wise to the function <code><a href="#topic+eFun">eFun</a></code> to generate 
orthonormal basis functions for each element of the multivariate functional 
data to be simulated. In case of bivariate elements (images), the 
corresponding basis functions are constructed as tensor products of 
orthonormal basis functions in each direction (x- and y-direction).
</p>
<p>If the <code class="reqn">j</code>-th element of the simulated data should be defined on a 
one-dimensional domain, then </p>
 <ul>
<li> <p><code>argvals[[j]]</code> is a list, 
containing one vector of observation points. </p>
</li>
<li> <p><code>M[[j]]</code> is an 
integer, specifying the number of basis functions to use for this entry. 
</p>
</li>
<li>  <p><code>eFunType[[j]]</code> is a character string, specifying the type of 
orthonormal basis functions to use for this entry (see <code><a href="#topic+eFun">eFun</a></code> for
possible options). </p>
</li>
<li> <p><code>ignoreDeg[[j]]</code> is a vector of integers, 
specifying the degrees to ignore when constructing the orthonormal basis 
functions. The default value is <code>NULL</code>. </p>
</li></ul>

<p>If the <code class="reqn">j</code>-th element of the simulated data should be defined on a 
two-dimensional domain, then </p>
 <ul>
<li> <p><code>argvals[[j]]</code> is a list, 
containing two vectors of observation points, one for each direction 
(observation points in x-direction and in y-direction). </p>
</li>
<li> <p><code>M[[j]]</code> 
is a vector of two integers, giving the number of basis functions for each 
direction (x- and y-direction). </p>
</li>
<li> <p><code>eFunType[[j]]</code> is a vector of two
character strings, giving the type of orthonormal basis functions for each 
direction (x- and y-direction, see <code><a href="#topic+eFun">eFun</a></code> for possible options).
The corresponding basis functions are constructed as tensor products of 
orthonormal basis functions in each direction. </p>
</li>
<li> <p><code>ignoreDeg[[j]]</code> is
a list, containing two integer vectors that specify the degrees to ignore 
when constructing the orthonormal basis functions in each direction. The 
default value is <code>NULL</code>. </p>
</li></ul>
<p> The total number of basis functions (i.e. the
product of <code>M[[j]]</code> for all <code>j</code>) must be equal!</p>



<h3>Value</h3>

<table>
<tr><td><code>simData</code></td>
<td>
<p>A <code><a href="#topic+multiFunData-class">multiFunData</a></code> object with 
<code>N</code> observations, representing the simulated multivariate functional 
data.</p>
</td></tr> <tr><td><code>trueFuns</code></td>
<td>
<p>A <code><a href="#topic+multiFunData-class">multiFunData</a></code> object with 
<code>M</code> observations, representing the multivariate eigenfunction basis 
used for simulating the data.</p>
</td></tr> <tr><td><code>trueVals</code></td>
<td>
<p>A vector of numerics, 
representing the eigenvalues used for simulating the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>C. Happ, S. Greven (2018): Multivariate Functional Principal 
Component Analysis for Data Observed on Different (Dimensional) Domains. 
Journal of the American Statistical Association, 113(522): 649-659.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiFunData-class">multiFunData</a></code>, <code><a href="#topic+eFun">eFun</a></code>, 
<code><a href="#topic+eVal">eVal</a></code>, <code><a href="#topic+simFunData">simFunData</a></code>, <code><a href="#topic+addError">addError</a></code>, 
<code><a href="#topic+sparsify">sparsify</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(no.readonly = TRUE)

# split
split &lt;- simMultiFunData(type = "split", argvals = list(seq(0,1,0.01), seq(-0.5,0.5,0.02)),
                 M = 5, eFunType = "Poly", eValType = "linear", N = 7)

par(mfrow = c(1,2))
plot(split$trueFuns, main = "Split: True Eigenfunctions", ylim = c(-2,2))
plot(split$simData, main = "Split: Simulated Data")

# weighted (one-dimensional domains)
weighted1D &lt;- simMultiFunData(type = "weighted",
                 argvals = list(list(seq(0,1,0.01)), list(seq(-0.5,0.5,0.02))),
                 M = c(5,5), eFunType = c("Poly", "Fourier"), eValType = "linear", N = 7)

plot(weighted1D$trueFuns, main = "Weighted (1D): True Eigenfunctions", ylim = c(-2,2))
plot(weighted1D$simData, main = "Weighted (1D): Simulated Data")

# weighted (one- and two-dimensional domains)
weighted &lt;- simMultiFunData(type = "weighted",
               argvals = list(list(seq(0,1,0.01), seq(0,10,0.1)), list(seq(-0.5,0.5,0.01))),
               M = list(c(5,4), 20), eFunType = list(c("Poly", "Fourier"), "Wiener"),
               eValType = "linear", N = 7)

plot(weighted$trueFuns, main = "Weighted: True Eigenfunctions (m = 2)", obs = 2)
plot(weighted$trueFuns, main = "Weighted: True Eigenfunctions (m = 15)", obs = 15)
plot(weighted$simData, main = "Weighted: Simulated Data (1st observation)", obs = 1)
plot(weighted$simData, main = "Weighted: Simulated Data (2nd observation)", obs = 2)

par(oldPar)
</code></pre>

<hr>
<h2 id='simMultiSplit'>Simulate multivariate eigenfunctions based on a split 'big' ONB</h2><span id='topic+simMultiSplit'></span>

<h3>Description</h3>

<p>Simulate multivariate eigenfunctions based on a split 'big' ONB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMultiSplit(argvals, M, eFunType, ignoreDeg = NULL, eValType, N)
</code></pre>

<hr>
<h2 id='simMultiWeight'>Simulate multivariate eigenfunctions based on weighted orthonormal bases</h2><span id='topic+simMultiWeight'></span>

<h3>Description</h3>

<p>Simulate multivariate eigenfunctions based on weighted orthonormal bases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMultiWeight(argvals, M, eFunType, ignoreDeg = NULL, eValType, N)
</code></pre>

<hr>
<h2 id='sparsify'>Generate a sparse version of functional data objects</h2><span id='topic+sparsify'></span>

<h3>Description</h3>

<p>This function generates an artificially sparsified version of a functional
data object of class <code><a href="#topic+funData-class">funData</a></code> (univariate) or
<code><a href="#topic+multiFunData-class">multiFunData</a></code> (multivariate). The minimal and maximal number
of observation points for all observations can be supplied by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify(funDataObject, minObs, maxObs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify_+3A_fundataobject">funDataObject</code></td>
<td>
<p>A functional data object of class
<code><a href="#topic+funData-class">funData</a></code> or <code><a href="#topic+multiFunData-class">multiFunData</a></code>.</p>
</td></tr>
<tr><td><code id="sparsify_+3A_minobs">minObs</code>, <code id="sparsify_+3A_maxobs">maxObs</code></td>
<td>
<p>The minimal/maximal number of observation points. Must be a scalar for
univariate functional data (<code><a href="#topic+funData-class">funData</a></code> class) or a
vector of the same length as <code>funDataObject</code> for multivariate
functional data (<code><a href="#topic+multiFunData-class">multiFunData</a></code> class), giving the
minimal/maximal number of observations for each element. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The technique for artificially sparsifying the data is as described in Yao et
al. (2005): For each element <code class="reqn">x_i^{(j)}</code> of an observed
(multivariate) functional data object <code class="reqn">x_i</code>, a random number
<code class="reqn">R_i^{(j)} \in \{\mathrm{minObs}, \ldots, \mathrm{maxObs}\}</code> of observation points is generated. The points
are sampled uniformly from the full grid <code class="reqn">\{t_{j,1} , \ldots , t_{j,
S_j}\} \subset \mathcal{T}_j</code>, resulting in
observations </p>
<p style="text-align: center;"><code class="reqn"> x_{i,r}^{(j)} = x_i^{(j)}(t_{j,r}), \quad r = 1
,\ldots,R_i^{(j)},~ j = 1, \ldots, p.</code>
</p>



<h3>Value</h3>

<p>An object of the same class as <code>funDataObject</code>, which is a
sparse version of the original data.
</p>


<h3>Warning</h3>

<p>This function is currently implemented for 1D data only.
</p>


<h3>References</h3>

<p>Yao, F., H.-G. Mueller and J.-L. Wang (2005): Functional Data
Analysis for Sparse Longitudinal Data. Journal of the American Statistical
Association, 100 (470), 577&ndash;590.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>, <code><a href="#topic+multiFunData-class">multiFunData</a></code>,
<code><a href="#topic+simFunData">simFunData</a></code>, <code><a href="#topic+simMultiFunData">simMultiFunData</a></code>,
<code><a href="#topic+addError">addError</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,1))
set.seed(1)

# univariate functional data
full &lt;- simFunData(argvals = seq(0,1, 0.01), M = 10, eFunType = "Fourier",
                   eValType = "linear", N = 3)$simData
sparse &lt;- sparsify(full, minObs = 4, maxObs = 10)

plot(full, main = "Sparsify")
plot(sparse, type = "p", pch = 20, add = TRUE)
legend("topright", c("Full", "Sparse"), lty = c(1, NA), pch = c(NA, 20))

# Multivariate
full &lt;- simMultiFunData(type = "split", argvals = list(seq(0,1, 0.01), seq(-.5,.5, 0.02)),
                        M = 10, eFunType = "Fourier", eValType = "linear", N = 3)$simData
sparse &lt;- sparsify(full, minObs = c(4, 30), maxObs = c(10, 40))

par(mfrow = c(1,2))
plot(full[[1]], main = "Sparsify (multivariate)", sub = "minObs = 4, maxObs = 10")
plot(sparse[[1]], type = "p", pch = 20, add = TRUE)

plot(full[[2]], main = "Sparsify (multivariate)", sub = "minObs = 30, maxObs = 40")
plot(sparse[[2]], type = "p", pch = 20, add = TRUE)
legend("bottomright", c("Full", "Sparse"), lty = c(1, NA), pch = c(NA, 20))

par(oldPar)
</code></pre>

<hr>
<h2 id='sparsify+2CfunData-method'>sparsify for univariate functional data</h2><span id='topic+sparsify+2CfunData-method'></span>

<h3>Description</h3>

<p>sparsify for univariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
sparsify(funDataObject, minObs, maxObs)
</code></pre>

<hr>
<h2 id='sparsify+2CmultiFunData-method'>sparsify for multivariate functional data</h2><span id='topic+sparsify+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>sparsify for multivariate functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
sparsify(funDataObject, minObs, maxObs)
</code></pre>

<hr>
<h2 id='tensorProduct'>Tensor product for univariate functions on one-dimensional domains</h2><span id='topic+tensorProduct'></span>

<h3>Description</h3>

<p>This function calculates tensor product functions for up to three objects of
class <code>funData</code> defined on one-dimensional domains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tensorProduct(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tensorProduct_+3A_...">...</code></td>
<td>
<p>Two or three objects of class <code>funData</code>, that must be defined
on a one-dimensional domain, each.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class as <code>funData</code> that corresponds to the tensor 
product of the input functions.
</p>


<h3>Warning</h3>

<p>The function is only implemented for up to three functions
on one-dimensional domains.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+funData-class">funData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Tensor product of two functional data objects
x &lt;- seq(0, 2*pi, 0.1)
f1 &lt;- funData(x, outer(seq(0.75, 1.25, 0.1), sin(x)))
y &lt;- seq(-pi, pi, 0.1)
f2 &lt;- funData(y, outer(seq(0.25, 0.75, 0.1), sin(y)))

plot(f1, main = "f1")
plot(f2, main = "f2")

tP &lt;- tensorProduct(f1, f2)
dimSupp(tP)
plot(tP, obs = 1)

### Tensor product of three functional data objects
z &lt;- seq(-1, 1, 0.05)
f3 &lt;- funData(z, outer(seq(0.75, 1.25, 0.1), z^2))

plot(f1, main = "f1")
plot(f2, main = "f2")
plot(f3, main = "f3")

tP2 &lt;- tensorProduct(f1, f2, f3)
dimSupp(tP2)
</code></pre>

<hr>
<h2 id='tensorProduct+2CfunData-method'>Tensor product for functional data</h2><span id='topic+tensorProduct+2CfunData-method'></span>

<h3>Description</h3>

<p>Tensor product for functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
tensorProduct(...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+tensorProduct">tensorProduct</a></code>
</p>

<hr>
<h2 id='X+2CfunData-method'>Get X slot for funData objects</h2><span id='topic+X+2CfunData-method'></span>

<h3>Description</h3>

<p>Get X slot for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'funData'
X(object)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+X">X</a></code>
</p>

<hr>
<h2 id='X+2CirregFunData-method'>Get X slot for irregular functional data objects</h2><span id='topic+X+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Get X slot for irregular functional data objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'irregFunData'
X(object)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+X">X</a></code>
</p>

<hr>
<h2 id='X+2CmultiFunData-method'>Get X slot for multiFunData objects</h2><span id='topic+X+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>Get X slot for multiFunData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'multiFunData'
X(object)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+X">X</a></code>
</p>

<hr>
<h2 id='X+26lt+3B-+2CfunData-method'>Set X slot for funData objects</h2><span id='topic+X+3C-+2CfunData-method'></span>

<h3>Description</h3>

<p>Set X slot for funData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'funData'
X(object) &lt;- value
</code></pre>

<hr>
<h2 id='X+26lt+3B-+2CirregFunData-method'>Set X slot for irregular functional data objects</h2><span id='topic+X+3C-+2CirregFunData-method'></span>

<h3>Description</h3>

<p>Set X slot for irregular functional data objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'irregFunData'
X(object) &lt;- value
</code></pre>

<hr>
<h2 id='X+26lt+3B-+2CmultiFunData-method'>Set X slot for multiFunData objects</h2><span id='topic+X+3C-+2CmultiFunData-method'></span>

<h3>Description</h3>

<p>Set X slot for multiFunData objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'multiFunData'
X(object) &lt;- value
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
