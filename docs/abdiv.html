<!DOCTYPE html><html><head><title>Help for package abdiv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {abdiv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#berger_parker_d'><p>Berger-Parker dominance</p></a></li>
<li><a href='#binomial_deviance'><p>Binomial deviance and CY index of dissimilarity</p></a></li>
<li><a href='#bray_curtis'><p>Bray-Curtis distance</p></a></li>
<li><a href='#bray_curtis_components'><p>Balanced variation and abundance gradient components for abundance data</p></a></li>
<li><a href='#canberra'><p>Canberra and related distances</p></a></li>
<li><a href='#chebyshev'><p>Chebyshev distance</p></a></li>
<li><a href='#correlation_distance'><p>Correlation and cosine distance</p></a></li>
<li><a href='#diversity_measures'><p>Diversity measures implemented</p></a></li>
<li><a href='#euclidean'><p>Euclidean and related distances</p></a></li>
<li><a href='#faith_pd'><p>Faith's phylogenetic diversity</p></a></li>
<li><a href='#faith_tree'><p>Example data for Faith's phylogenetic diversity</p></a></li>
<li><a href='#hamming'><p>Hamming distance</p></a></li>
<li><a href='#jaccard'><p>Beta diversity for presence/absence data</p></a></li>
<li><a href='#jaccard_components'><p>Nestedness and turnover components for presence/absence data</p></a></li>
<li><a href='#kempton_taylor_q'><p>Kempton-Taylor Q index</p></a></li>
<li><a href='#kullback_leibler_divergence'><p>Kullback-Leibler divergence</p></a></li>
<li><a href='#leprieur_tree'><p>Example data for phylogenetic nestedness and turnover components</p></a></li>
<li><a href='#lozupone_tree'><p>Example data for UniFrac distance</p></a></li>
<li><a href='#manhattan'><p>Manhattan and related distances</p></a></li>
<li><a href='#margalef'><p>Margalef's richness index</p></a></li>
<li><a href='#match_to_tree'><p>Match vector of counts to phylogenetic tree</p></a></li>
<li><a href='#mcintosh_d'><p>McIntosh dominance index D</p></a></li>
<li><a href='#mcintosh_e'><p>McIntosh's evenness measure E</p></a></li>
<li><a href='#menhinick'><p>Menhinick's richness index</p></a></li>
<li><a href='#minkowski'><p>Minkowski distance</p></a></li>
<li><a href='#morisita'><p>The Morisita index and Horn-Morisita index</p></a></li>
<li><a href='#richness'><p>Richness or number of observed species</p></a></li>
<li><a href='#ruzicka'><p>Ruzicka or weighted Jaccard distance</p></a></li>
<li><a href='#shannon'><p>Shannon diversity and related measures</p></a></li>
<li><a href='#simpson'><p>Simpson's index and related measures</p></a></li>
<li><a href='#strong'><p>Strong's dominance index</p></a></li>
<li><a href='#unifrac'><p>UniFrac distance</p></a></li>
<li><a href='#unifrac_components'><p>Nestedness and turnover components of unweighted UniFrac distance</p></a></li>
<li><a href='#weighted_kulczynski_second'><p>Weighted Kulczynski distance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Alpha and Beta Diversity Measures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of measures for measuring ecological diversity.
  Ecological diversity comes in two flavors: alpha diversity measures the
  diversity within a single site or sample, and beta diversity measures the
  diversity across two sites or samples. This package overlaps considerably
  with other R packages such as 'vegan', 'gUniFrac', 'betapart', and 'fossil'.
  We also include a wide range of functions that are implemented in software
  outside the R ecosystem, such as 'scipy', 'Mothur', and 'scikit-bio'.  The
  implementations here are designed to be basic and clear to the reader.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kylebittinger/abdiv">https://github.com/kylebittinger/abdiv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kylebittinger/abdiv/issues">https://github.com/kylebittinger/abdiv/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), vegan</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-15 02:25:11 UTC; bittingerk</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyle Bittinger [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyle Bittinger &lt;kylebittinger@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-20 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='berger_parker_d'>Berger-Parker dominance</h2><span id='topic+berger_parker_d'></span>

<h3>Description</h3>

<p>The Berger-Parker dominance is the proportion of the most abundant species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>berger_parker_d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="berger_parker_d_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts or proportions.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Equivalent to <code>berger_parker_d()</code> in
<code>skbio.diversity.alpha</code>.
</p>
</li>
<li><p> Equivalent to the <code>bergerparker</code> calculator in Mothur.
</p>
</li></ul>



<h3>Value</h3>

<p>The Berger-Parker dominance, <code class="reqn">0 &lt; D_{BP} \leq 1</code>. If the vector
sums to zero, the Berger-Parker dominance is undefined, and we return
<code>NaN</code>.
</p>


<h3>References</h3>

<p>Berger WH, Parker FL. Diversity of Planktonic Foraminifera in Deep-Sea
Sediments. Science. 1970;168(3937):1345-1347.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
berger_parker_d(x) # 15 / 28
</code></pre>

<hr>
<h2 id='binomial_deviance'>Binomial deviance and CY index of dissimilarity</h2><span id='topic+binomial_deviance'></span><span id='topic+cy_dissimilarity'></span>

<h3>Description</h3>

<p>The binomial deviance dissimilarity and the CY (or Cao) index of
dissimilarity were created to compare species counts at sites with moderate
to large differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial_deviance(x, y)

cy_dissimilarity(x, y, base = 10, min_value = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomial_deviance_+3A_x">x</code>, <code id="binomial_deviance_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
<tr><td><code id="binomial_deviance_+3A_base">base</code></td>
<td>
<p>Base of the logarithm</p>
</td></tr>
<tr><td><code id="binomial_deviance_+3A_min_value">min_value</code></td>
<td>
<p>Replacement for zero or near-zero values. Values less than
<code>min_value</code> are replaced with <code>min_value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both of these measures were designed to be used with whole-numbered counts,
and may not make sense for comparing normalized vectors or vectors of
species proportions.
</p>
<p>For two vectors <code>x</code> and <code>y</code>, the binomial deviance dissimilarity
is
</p>
<p style="text-align: center;"><code class="reqn">
  d(x,y) = \sum_i{
    \frac{1}{n_i}
    \left (
      x_i \log{\frac{x_i}{n_i}} +
      y_i \log{\frac{y_i}{n_i}} -
      (x_i + y_i) log{2}
    \right )
  },
</code>
</p>

<p>where <code class="reqn">n_i = x_i + y_i</code>. This value is the weighted average of the
deviance for each species, under a binomial model where the expected counts
are <code class="reqn">n_i / 2</code> at each site. It was proposed by Anderson and Millar in
2004. Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to vegdist() with method = &quot;binomial&quot;.
</p>
</li></ul>

<p>The CY index was proposed by Cao, Williams, and Bark in 1997. For two
vectors <code>x</code> and <code>y</code>, the CY index is
</p>
<p style="text-align: center;"><code class="reqn">
  d(x,y) = \frac{1}{N} \sum_i
  \left (
    \frac{
      (x_i + y_i) \log_{10} ( \frac{x_i + y_i}{2} ) -
      x_i \log_{10}(y_i) - y_i \log_{10}(x_i)
    }{
      x_i + y_i
    }
  \right ),
</code>
</p>

<p>where <code class="reqn">N</code> is the total number of species in vectors <code class="reqn">x</code> and <code class="reqn">y</code>.
Double zeros are not considered in the measure.
</p>
<p>When either <code class="reqn">x_i</code> or <code class="reqn">y_i</code> are zero, they need to be replaced by
another value in the CY index to avoid infinities. Cao suggested replacing
zero values with <code class="reqn">0.1</code>, which is one log lower than the minimum value
for whole-numbered counts. Here, we use a <code>min_value</code> argument to allow
the user set a lower limit on the values. For vectors of species counts,
this function follows the formulation of Cao by default.
</p>
<p>Relation of the CY index to other definitions:
</p>

<ul>
<li><p> Equivalent to the <code>vegdist()</code> function with
<code>method = "cao"</code>, if <code>base = exp(1)</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The Binomial deviance or CY index of dissimilarity. The CY index is
undefined if all elements of <code>x</code> and <code>y</code> are zero, in which case
we return <code>NaN</code>.
</p>


<h3>References</h3>

<p>Anderson MJ, Millar RB. Spatial variation and effects of habitat on
temperate reef fish assemblages in northeastern New Zealand. Journal of
Experimental Marine Biology and Ecology 2004;305:191–221.
</p>
<p>Cao Y, Williams WP, Bark AW. Similarity measure bias in river benthic
Aufwuchs community analysis. Water Environment Research 1997;69(1):95-106.
</p>

<hr>
<h2 id='bray_curtis'>Bray-Curtis distance</h2><span id='topic+bray_curtis'></span>

<h3>Description</h3>

<p>The Bray-Curtis distance is the Manhattan distance divided by the sum of
both vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bray_curtis(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bray_curtis_+3A_x">x</code>, <code id="bray_curtis_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two vectors <code>x</code> and <code>y</code>, the Bray-Curtis distance is defined
as </p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \frac{\sum_i |x_i - y_i|}{\sum_i x_i + y_i}.</code>
</p>
<p> The
Bray-Curtis distance is connected to many other distance measures in this
package; we try to list some of the more important connections here. Relation
to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>vegdist()</code> with <code>method = "bray"</code>.
</p>
</li>
<li><p> Equivalent to the <code>braycurtis()</code> function in
<code>scipy.spatial.distance</code> for positive vectors. They take the
absolute value of <code class="reqn">x_i + y_i</code> in the denominator.
</p>
</li>
<li><p> Equivalent to the <code>braycurtis</code> and <code>odum</code> calculators in
Mothur.
</p>
</li>
<li><p> Equivalent to <code class="reqn">D_{14} = 1 - S_{17}</code> in
Legendre &amp; Legendre.
</p>
</li>
<li><p> The Bray-Curtis distance on proportions is equal to half the
Manhattan distance.
</p>
</li>
<li><p> The Bray-Curtis distance on presence/absence vectors is equal to the
Sorenson index of dissimilarity.
</p>
</li></ul>



<h3>Value</h3>

<p>The Bray-Curtis distance between <code>x</code> and <code>y</code>. The
Bray-Curtis distance is undefined if the sum of all elements in <code>x</code>
and <code>y</code> is zero, in which case we return <code>NaN</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
y &lt;- c(10, 2, 0, 1, 1, 0)
bray_curtis(x, y)

# For proportions, equal to half the Manhattan distance
bray_curtis(x / sum(x), y / sum(y))
manhattan(x / sum(x), y / sum(y)) / 2
</code></pre>

<hr>
<h2 id='bray_curtis_components'>Balanced variation and abundance gradient components for abundance data</h2><span id='topic+bray_curtis_components'></span><span id='topic+bray_curtis_balanced'></span><span id='topic+bray_curtis_gradient'></span><span id='topic+ruzicka_balanced'></span><span id='topic+ruzicka_gradient'></span>

<h3>Description</h3>

<p>Balanced variation and abundance gradient components for abundance data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bray_curtis_balanced(x, y)

bray_curtis_gradient(x, y)

ruzicka_balanced(x, y)

ruzicka_gradient(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bray_curtis_components_+3A_x">x</code>, <code id="bray_curtis_components_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The balanced variation or abundance gradient component of distance
between <code>x</code> and <code>y</code>. This quantity is undefined when either
<code>x</code> or <code>y</code> have all elements equal to zero, in which case we
return <code>NaN</code>.
</p>


<h3>References</h3>

<p>Baselga A. Separating the two components of abundance-based dissimilarity:
balanced changes in abundance vs.abundance gradients. Methods in Ecology
and Evolution. 2013;4:552–557.
</p>
<p>Baselga A. Partitioning abundance-based multiple-site dissimilarity into
components: balanced variation in abundance and abundance gradients.
Methods in Ecology and Evolution. 2017;8:799–808.
</p>

<hr>
<h2 id='canberra'>Canberra and related distances</h2><span id='topic+canberra'></span><span id='topic+clark_coefficient_of_divergence'></span>

<h3>Description</h3>

<p>The Canberra distance and Clark's coefficient of divergence are measures
that use the absolute difference over the sum for each element of the
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canberra(x, y)

clark_coefficient_of_divergence(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canberra_+3A_x">x</code>, <code id="canberra_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vectors <code>x</code> and <code>y</code>, the Canberra distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \sum_i \frac{|x_i - y_i|}{x_i + y_i}.</code>
</p>
<p> Elements where
<code class="reqn">x_i + y_i = 0</code> are not included in the sum. Relation of
<code>canberra()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to R's built-in <code>dist()</code> function with
<code>method = "canberra"</code>.
</p>
</li>
<li><p> Equivalent to the <code>vegdist()</code> function with
<code>method = "canberra"</code>, multiplied by the number of entries where
<code>x &gt; 0</code>, <code>y &gt; 0</code>, or both.
</p>
</li>
<li><p> Equivalent to the <code>canberra()</code> function in
<code>scipy.spatial.distance</code> for positive vectors. They take the
absolute value of <code class="reqn">x_i</code> and <code class="reqn">y_i</code> in the denominator.
</p>
</li>
<li><p> Equivalent to the <code>canberra</code> calculator in Mothur, multiplied
by the total number of species in <code>x</code> and <code>y</code>.
</p>
</li>
<li><p> Equivalent to <code class="reqn">D_{10}</code> in Legendre &amp; Legendre.
</p>
</li></ul>

<p>Clark's coefficient of divergence involves summing squares and taking a
square root afterwards:
</p>
<p style="text-align: center;"><code class="reqn">
  d(x, y) = \sqrt{
    \frac{1}{n} \sum_i \left( \frac{x_i - y_i}{x_i + y_i} \right)^2
  },</code>
</p>

<p>where <code class="reqn">n</code> is the number of elements where <code>x &gt; 0</code>, <code>y &gt; 0</code>, or
both. Relation of <code>clark_coefficient_of_divergence()</code> to other
definitions:
</p>

<ul>
<li><p> Equivalent to <code class="reqn">D_{11}</code> in Legendre &amp; Legendre.
</p>
</li></ul>



<h3>Value</h3>

<p>The Canberra distance or Clark's coefficient of divergence. If every
element in <code>x</code> and <code>y</code> is zero, Clark's coefficient of
divergence is undefined, and we return <code>NaN</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
y &lt;- c(10, 2, 0, 1, 1, 0)
canberra(x, y)
clark_coefficient_of_divergence(x, y)
</code></pre>

<hr>
<h2 id='chebyshev'>Chebyshev distance</h2><span id='topic+chebyshev'></span>

<h3>Description</h3>

<p>The Chebyshev distance is the maximum absolute difference between the vector
elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chebyshev(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chebyshev_+3A_x">x</code>, <code id="chebyshev_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vectors <code>x</code> and <code>y</code>, the Chebyshev distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \max_i |x_i - y_i|.</code>
</p>
<p> Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to the <code>chebyshev()</code> function in
<code>scipy.spatial.distance</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The Chebyshev distance between <code>x</code> and <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
y &lt;- c(10, 2, 0, 1, 1, 0)
chebyshev(x, y) # should be 5
</code></pre>

<hr>
<h2 id='correlation_distance'>Correlation and cosine distance</h2><span id='topic+correlation_distance'></span><span id='topic+cosine_distance'></span>

<h3>Description</h3>

<p>The correlation and cosine distances, which are derived from the dot
product of the two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation_distance(x, y)

cosine_distance(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation_distance_+3A_x">x</code>, <code id="correlation_distance_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vectors <code>x</code> and <code>y</code>, the cosine distance is defined as the
cosine of the angle between the vectors,
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = 1 - \frac{x \cdot y}{|x| |y|},</code>
</p>
<p> where <code class="reqn">|x|</code> is the
magnitude or L2 norm of the vector, <code class="reqn">|x| = \sqrt{\sum_i x_i^2}</code>.
Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to the <code>cosine()</code> function in
<code>scipy.spatial.distance</code>.
</p>
</li></ul>

<p>The correlation distance is simply equal to one minus the Pearson
correlation between vectors. Mathematically, it is equivalent to the cosine
distance between the vectors after they are centered (<code class="reqn">x - \bar{x}</code>).
Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to the <code>correlation()</code> function in
<code>scipy.spatial.distance</code>.
</p>
</li>
<li><p> Equivalent to the <code>1 - mempearson</code> calculator in Mothur.
</p>
</li></ul>



<h3>Value</h3>

<p>The correlation or cosine distance. These are undefined if either
<code>x</code> or <code>y</code> contain all zero elements, that is, if <code class="reqn">|x| = 0</code>
or <code class="reqn">|y| = 0</code>. In this case, we return <code>NaN</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2, 0)
y &lt;- c(5, 5)
cosine_distance(x, y)
# The two vectors form a 45 degree angle, or pi / 4
1 - cos(pi / 4)

v &lt;- c(3.5, 0.1, 1.4)
w &lt;- c(3.3, 0.5, 0.9)
correlation_distance(v, w)
1 - cor(v, w)
</code></pre>

<hr>
<h2 id='diversity_measures'>Diversity measures implemented</h2><span id='topic+diversity_measures'></span><span id='topic+alpha_diversities'></span><span id='topic+beta_diversities'></span><span id='topic+phylogenetic_alpha_diversities'></span><span id='topic+phylogenetic_beta_diversities'></span>

<h3>Description</h3>

<p>The diversity functions offered in <code>abdiv</code> are organized based on the
function signature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha_diversities

beta_diversities

phylogenetic_alpha_diversities

phylogenetic_beta_diversities
</code></pre>


<h3>Format</h3>

<p>Four objects of class <code>character</code>.</p>


<h3>Details</h3>

<p>The following character vectors are provided:
</p>

<dl>
<dt><code>alpha_diversities</code></dt><dd>
<p>All non-phylogenetic alpha diversity measures. These functions take a
single numeric vector as an argument.</p>
</dd>
<dt><code>beta_diversities</code></dt><dd>
<p>All non-phylogenetic beta diversity measures. These functions take two
numeric vectors as arguments.</p>
</dd>
<dt><code>phylogenetic_alpha_diversities</code></dt><dd>
<p>There is only one phylogenetic alpha diversity measure implemented, but
we use the plural to be consistent with the other vectors. This function
takes a numeric vector, a phylogenetic tree object, and optionally a
character vector of species labels.</p>
</dd>
<dt><code>phylogenetic_beta_diversities</code></dt><dd>
<p>Phylogenetic measures of beta diversity. These functions take two
numeric vectors, a phylogenetic tree object, and optionally a
character vector of species labels.</p>
</dd>
</dl>


<hr>
<h2 id='euclidean'>Euclidean and related distances</h2><span id='topic+euclidean'></span><span id='topic+rms_distance'></span><span id='topic+chord'></span><span id='topic+hellinger'></span><span id='topic+geodesic_metric'></span>

<h3>Description</h3>

<p>These distance and diversity measures are mathematically similar to the
Euclidean distance between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean(x, y)

rms_distance(x, y)

chord(x, y)

hellinger(x, y)

geodesic_metric(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidean_+3A_x">x</code>, <code id="euclidean_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vectors <code>x</code> and <code>y</code>, the Euclidean distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \sqrt{\sum_i (x_i - y_i) ^ 2}.</code>
</p>

<p>Relation of <code>euclidean()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to R's built-in <code>dist()</code> function with
<code>method = "euclidean"</code>.
</p>
</li>
<li><p> Equivalent to <code>vegdist()</code> with <code>method = "euclidean"</code>.
</p>
</li>
<li><p> Equivalent to the <code>euclidean()</code> function in
<code>scipy.spatial.distance</code>.
</p>
</li>
<li><p> Equivalent to the <code>structeuclidean</code> calculator in Mothur, to
<code>speciesprofile</code> if <code>x</code> and <code>y</code> are transformed to
relative abundance, and to <code>memeuclidean</code> if <code>x</code> and <code>y</code>
are transformed to presence/absence.
</p>
</li>
<li><p> Equivalent to <code class="reqn">D_1</code> in Legendre &amp; Legendre.
</p>
</li>
<li><p> Equivalent to the <em>distance between species profiles</em>,
<code class="reqn">D_{18}</code> in Legendre &amp; Legendre if <code>x</code> and <code>y</code> are
transformed to relative abundance.
</p>
</li></ul>

<p>The <em>root-mean-square</em> distance or <em>average</em> distance is similar
to Euclidean distance. As the name implies, it is computed as the square
root of the mean of the squared differences between elements of <code>x</code>
and <code>y</code>: </p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \sqrt{\frac{1}{n} \sum_i^n (x_i - y_i) ^ 2}.</code>
</p>

<p>Relation of <code>rms_distance()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to <code class="reqn">D_2</code> in Legendre &amp; Legendre.
</p>
</li></ul>

<p>The <em>chord</em> distance is the Euclidean distance after scaling each
vector by its root sum of squares, <code class="reqn">\sqrt{\sum_i x_i^2}</code>. The chord
distance between any two vectors ranges from 0 to <code class="reqn">\sqrt{2}</code>.
Relation of <code>chord()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to <code class="reqn">D_3</code> in Legendre &amp; Legendre.
</p>
</li></ul>

<p>The <em>Hellinger</em> distance is equal to the chord distance computed after
a square-root transformation. Relation of <code>hellinger()</code> to other
definitions:
</p>

<ul>
<li><p> Equivalent to <code class="reqn">D_{17}</code> in Legendre &amp; Legendre.
</p>
</li>
<li><p> Equivalent to the <code>hellinger</code> calculator in Mothur.
</p>
</li></ul>

<p>The <em>geodesic metric</em> is a transformed version of the chord distance.
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \textrm{arccos} \left(1 - \frac{d_c^2(x, y)}{2} \right),</code>
</p>

<p>where <code class="reqn">d_c</code> is the chord distance. It gives the length of the arc on a
hypersphere between the vectors, if the vectors are normalized to unit
length. Relation of <code>geodesic_metric()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to <code class="reqn">D_4</code> in Legendre &amp; Legendre.
</p>
</li></ul>



<h3>Value</h3>

<p>The distance between <code>x</code> and <code>y</code>. The chord distance,
Hellinger distance, and geodesic metric are not defined if all elements
of either vector are zero. We return <code>NaN</code> in this case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
y &lt;- c(10, 2, 0, 1, 1, 0)
euclidean(x, y)
# The "distance between species profiles"
euclidean(x / sum(x), y / sum(y))
rms_distance(x, y)
chord(x, y)
hellinger(x, y)
# Hellinger is chord distance after square root transform
chord(sqrt(x), sqrt(y))
geodesic_metric(x, y)

# No species in common with x
v &lt;- c(0, 0, 0, 5, 0, 5)
chord(v, x)
sqrt(2)
</code></pre>

<hr>
<h2 id='faith_pd'>Faith's phylogenetic diversity</h2><span id='topic+faith_pd'></span>

<h3>Description</h3>

<p>Faith's phylogenetic diversity gives the total branch length on a
phylogenetic tree that is spanned by a community.  The abundance of each
species in the community is not considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faith_pd(x, tree, x_labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faith_pd_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts or proportions, or a logical
vector of species presence/absence.</p>
</td></tr>
<tr><td><code id="faith_pd_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree object..</p>
</td></tr>
<tr><td><code id="faith_pd_+3A_x_labels">x_labels</code></td>
<td>
<p>A character vector of species labels for <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the vector <code>x</code> is named, the names will be automatically
used to match <code>x</code> with the tree. Missing names are filled in with
zero counts. If <code>x</code> is not named and <code>x_labels</code> is provided,
these labels are used to match the elements of <code>x</code> with the tree.
If <code>x</code> is not named and <code>x_labels</code> is not provided, it is
assumed that <code>x</code> is already in the correct order, and we simply
check that its length matches the number of tips in the tree.
</p>


<h3>Value</h3>

<p>Faith's phylogenetic diversity, <code class="reqn">PD \geq 0</code>.
</p>


<h3>References</h3>

<p>Faith DP. Conservation evaluation and phylogenetic diversity.
Biol. Conserv. 1992;61:1–10. doi: 10.1016/0006-3207(92)91201-3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Faith's phylogenetic diversity for whole tree is equal to the sum of the
# branch lengths.
sum(faith_tree$edge.length)
faith_pd(c(1, 1, 1, 1, 1), faith_tree)

# Can use named vector or additional argument to match species to tree.
faith_tree$tip.label
faith_pd(c(0, 0, 0, 10, 12), faith_tree)
faith_pd(c(d=10, e=12), faith_tree)
faith_pd(c(10, 12), faith_tree, c("d", "e"))
</code></pre>

<hr>
<h2 id='faith_tree'>Example data for Faith's phylogenetic diversity</h2><span id='topic+faith_tree'></span>

<h3>Description</h3>

<p>This example was used to illustrate phylogenetic diversity in Faith and
Richards (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faith_tree
</code></pre>


<h3>Format</h3>

<p><code>faith_tree</code> is a phylogenetic tree with five tips, labeled
a-e. It was created with the <code>ape</code> library.</p>


<h3>Details</h3>

<p>In the paper, they give the total branch length as 41, but they
don't assign a length to the branch leading to species &quot;b&quot; and &quot;c&quot;. Looking
at the figure, we estimated that the length should be 4. For that reason,
the total branch length of <code>faith_tree</code> is 45, rather than 41.
</p>


<h3>Source</h3>

<p>Faith DP, Richards ZT. Biology (Basel). 2012;1(3):906-32.
10.3390/biology1030906
</p>

<hr>
<h2 id='hamming'>Hamming distance</h2><span id='topic+hamming'></span>

<h3>Description</h3>

<p>The Hamming distance is the number of positions where the values are
different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hamming(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hamming_+3A_x">x</code>, <code id="hamming_+3A_y">y</code></td>
<td>
<p>Numeric vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vectors <code>x</code> and <code>y</code>, the Hamming distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \sum_i [x_i \neq y_i],</code>
</p>
<p> where the quantity in the brackets
is 1 if the elements are not equal, and zero if the elements are equal.
Relation to other definitions:
</p>

<ul>
<li><p> The <code>hamming()</code> function in <code>scipy.spatial.distance</code>
divides the result by the vector length. Our function is equivalent to
the SciPy version multiplied by the vector length.
</p>
</li>
<li><p> Equivalent to the <code>hamming</code> calculator in Mothur for
presence/absence vectors.
</p>
</li></ul>



<h3>Value</h3>

<p>The Hamming distance between <code>x</code> and <code>y</code>.
</p>

<hr>
<h2 id='jaccard'>Beta diversity for presence/absence data</h2><span id='topic+jaccard'></span><span id='topic+sorenson'></span><span id='topic+kulczynski_first'></span><span id='topic+kulczynski_second'></span><span id='topic+rogers_tanimoto'></span><span id='topic+russel_rao'></span><span id='topic+sokal_michener'></span><span id='topic+sokal_sneath'></span><span id='topic+yule_dissimilarity'></span>

<h3>Description</h3>

<p>These functions transform the input vectors to binary or presence/absence
format, then compute a distance or dissimilarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard(x, y)

sorenson(x, y)

kulczynski_first(x, y)

kulczynski_second(x, y)

rogers_tanimoto(x, y)

russel_rao(x, y)

sokal_michener(x, y)

sokal_sneath(x, y)

yule_dissimilarity(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccard_+3A_x">x</code>, <code id="jaccard_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many of these indices are covered in Koleff et al. (2003), so we adopt their
notation. For two vectors <code>x</code> and <code>y</code>, we define three quantities:
</p>

<ul>
<li> <p><code class="reqn">a</code> is the number of species that are present in both <code>x</code>
and <code>y</code>,
</p>
</li>
<li> <p><code class="reqn">b</code> is the number of species that are present in <code>y</code> but
not <code>x</code>,
</p>
</li>
<li> <p><code class="reqn">c</code> is the number of species that are present in <code>x</code> but
not <code>y</code>, and
</p>
</li>
<li> <p><code class="reqn">d</code> is the number of species absent in both vectors.
</p>
</li></ul>

<p>The quantity <code class="reqn">d</code> is seldom used in ecology, for good reason. For
details, please see the discussion on the &quot;double zero problem,&quot; in section
2 of chapter 7.2 in Legendre &amp; Legendre.
</p>
<p>The <em>Jaccard</em> index of dissimilarity is <code class="reqn">1 - a / (a + b + c)</code>, or
one minus the proportion of shared species, counting over both samples
together. Relation of <code>jaccard()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to R's built-in <code>dist()</code> function with
<code>method = "binary"</code>.
</p>
</li>
<li><p> Equivalent to <code>vegdist()</code> with <code>method = "jaccard"</code>
and <code>binary = TRUE</code>.
</p>
</li>
<li><p> Equivalent to the <code>jaccard()</code> function in
<code>scipy.spatial.distance</code>, except that we always convert vectors to
presence/absence.
</p>
</li>
<li><p> Equivalent to <code class="reqn">1 - S_7</code> in Legendre &amp; Legendre.
</p>
</li>
<li><p> Equivalent to <code class="reqn">1 - \beta_j</code>, as well as <code class="reqn">\beta_{cc}</code>, and
<code class="reqn">\beta_g</code> in Koleff (2003).
</p>
</li></ul>

<p>The <em>Sørenson</em> or <em>Dice</em> index of dissimilarity is
<code class="reqn">1 - 2a / (2a + b + c)</code>, or one minus the average proportion of shared
species, counting over each sample individually. Relation of
<code>sorenson()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to the <code>dice()</code> function in
<code>scipy.spatial.distance</code>, except that we always convert vectors to
presence/absence.
</p>
</li>
<li><p> Equivalent to the <code>sorclass</code> calculator in Mothur, and to
<code>1 - whittaker</code>.
</p>
</li>
<li><p> Equivalent to <code class="reqn">D_{13} = 1 - S_8</code> in Legendre &amp;
Legendre.
</p>
</li>
<li><p> Equivalent to <code class="reqn">1 - \beta_{sor}</code> in Koleff (2003). Also
equivalent to Whittaker's beta diversity
(the second definition, <code class="reqn">\beta_w = (S / \bar{a}) - 1</code>), as well as
<code class="reqn">\beta_{-1}</code>, <code class="reqn">\beta_t</code>, <code class="reqn">\beta_{me}</code>, and
<code class="reqn">\beta_{hk}</code>.
</p>
</li></ul>

<p>I have not been able to track down the original reference for the first and
second Kulczynski indices, but we have good formulas from Legendre &amp;
Legendre. The <em>first Kulczynski index</em> is <code class="reqn">1 - a / (b + c)</code>, or
one minus the ratio of shared to unshared species.
</p>
<p>Relation of <code>kulczynski_first</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to <code class="reqn">1 - S_{12}</code> in Legendre &amp; Legendre.
</p>
</li>
<li><p> Equivalent to the <code>kulczynski</code> calculator in Mothur.
</p>
</li></ul>

<p>Some people refer to the <em>second Kulczynski index</em> as the
Kulczynski-Cody index. It is defined as one minus the average proportion of
shared species in each vector,
</p>
<p style="text-align: center;"><code class="reqn">
  d = 1 - \frac{1}{2} \left ( \frac{a}{a + b} + \frac{a}{a + c} \right ).
</code>
</p>

<p>Relation of <code>kulczynski_second</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to <code class="reqn">1 - S_{13}</code> in Legendre &amp; Legendre.
</p>
</li>
<li><p> Equivalent to the <code>kulczynskicody</code> calculator in Mothur.
</p>
</li>
<li><p> Equivalent to one minus the Kulczynski similarity in Hayek (1994).
</p>
</li>
<li><p> Equivalent to <code>vegdist()</code> with <code>method = "kulczynski"</code> and
<code>binary = TRUE</code>.
</p>
</li></ul>

<p>The <em>Rogers-Tanimoto</em> distance is defined as
<code class="reqn">(2b + 2c) / (a + 2b + 2c + d)</code>. Relation of <code>rogers_tanimoto()</code>
to other definitions:
</p>

<ul>
<li><p> Equivalent to the <code>rogerstanimoto()</code> function in
<code>scipy.spatial.distance</code>, except that we always convert vectors to
presence/absence.
</p>
</li>
<li><p> Equivalent to <code class="reqn">1 - S_2</code> in Legendre &amp; Legendre.
</p>
</li></ul>

<p>The <em>Russel-Rao</em> distance is defined
<code class="reqn">(b + c + d) / (a + b + c + d)</code>, or the fraction of elements not present
in both vectors, counting double absences. Relation of <code>russel_rao()</code> to
other definitions:
</p>

<ul>
<li><p> Equivalent to the <code>russelrao()</code> function in
<code>scipy.spatial.distance</code>, except that we always convert vectors to
presence/absence.
</p>
</li>
<li><p> Equivalent to <code class="reqn">1 - S_{11}</code> in Legendre &amp; Legendre.
</p>
</li></ul>

<p>The <em>Sokal-Michener</em> distance is defined as
<code class="reqn">(2b + 2c) / (a + 2b + 2c + d)</code>. Relation of <code>sokal_michener()</code> to
other definitions:
</p>

<ul>
<li><p> Equivalent to the <code>sokalmichener()</code> function in
<code>scipy.spatial.distance</code>, except that we always convert vectors to
presence/absence.
</p>
</li></ul>

<p>The <em>Sokal-Sneath</em> distance is defined as
<code class="reqn">(2b + 2c) / (a + 2b + 2c)</code>. Relation of <code>sokal_sneath()</code> to other
definitions:
</p>

<ul>
<li><p> Equivalent to the <code>sokalsneath()</code> function in
<code>scipy.spatial.distance</code>, except that we always convert vectors to
presence/absence.
</p>
</li>
<li><p> Equivalent to the <code>anderberg</code> calculator in Mothur.
</p>
</li>
<li><p> Equivalent to <code class="reqn">1 - S_{10}</code> in Legendre &amp; Legendre.
</p>
</li></ul>

<p>The <em>Yule</em> dissimilarity is defined as <code class="reqn">2bc / (ad + bc)</code>. Relation
of <code>yule_dissimilarity()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to the <code>yule()</code> function in
<code>scipy.spatial.distance</code>, except that we always convert vectors to
presence/absence.
</p>
</li>
<li><p> Equivalent to <code class="reqn">1 - S</code>, where <code class="reqn">S</code> is the Yule coefficient
in Legendre &amp; Legendre.
</p>
</li></ul>



<h3>Value</h3>

<p>The dissimilarity between <code>x</code> and <code>y</code>, based on
presence/absence. The Jaccard, Sorenson, Sokal-Sneath, Yule, and both
Kulczynski dissimilarities are not defined if both <code>x</code> and <code>y</code>
have no nonzero elements. In addition, the second Kulczynski index and the
Yule index of dissimilarity are not defined if one of the vectors has no
nonzero elements. We return <code>NaN</code> for undefined values.
</p>

<hr>
<h2 id='jaccard_components'>Nestedness and turnover components for presence/absence data</h2><span id='topic+jaccard_components'></span><span id='topic+jaccard_turnover'></span><span id='topic+jaccard_nestedness'></span><span id='topic+sorenson_turnover'></span><span id='topic+sorenson_nestedness'></span>

<h3>Description</h3>

<p>Nestedness and turnover components for presence/absence data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard_turnover(x, y)

jaccard_nestedness(x, y)

sorenson_turnover(x, y)

sorenson_nestedness(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccard_components_+3A_x">x</code>, <code id="jaccard_components_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The nestedness or turnover component of distance between <code>x</code>
and <code>y</code>. This quantity is undefined when either <code>x</code> or <code>y</code>
have no observations, in which case we return <code>NaN</code>.
</p>


<h3>References</h3>

<p>Baselga A. Partitioning the turnover and nestedness components of beta
diversity. Global Ecol. Biogeogr. 2010;19:134-143.
</p>
<p>Baselga A. The relationship between species replacement, dissimilarity
derived from nestedness, and nestedness. Global Ecol. Biogeogr.
2012;21:1223–1232.
</p>

<hr>
<h2 id='kempton_taylor_q'>Kempton-Taylor Q index</h2><span id='topic+kempton_taylor_q'></span>

<h3>Description</h3>

<p>The Kempton-Taylor Q index is designed to measure species in the middle of
the abundance distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kempton_taylor_q(x, lower_quantile = 0.25, upper_quantile = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kempton_taylor_q_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts or proportions.</p>
</td></tr>
<tr><td><code id="kempton_taylor_q_+3A_lower_quantile">lower_quantile</code>, <code id="kempton_taylor_q_+3A_upper_quantile">upper_quantile</code></td>
<td>
<p>Lower and upper quantiles of the
abundance distribution. Default values are the ones suggested by Kempton
and Taylor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a vector of species counts <code>x</code>, the Kempton-Taylor Q statistic is
equal to the slope of the cumulative abundance curve across a specified
quantile range. The cumulative abundance curve is the plot of the number of
species against the log-abundance.
</p>
<p>Kempton and Taylor originally defined the index as
</p>
<p style="text-align: center;"><code class="reqn">Q = \frac{\frac{1}{2}S}{\log{R_2} - \log{R_1}},</code>
</p>
<p> where <code class="reqn">S</code> is the
total number of species observed, <code class="reqn">R_1</code> is the abundance at the lower
quantile, and <code class="reqn">R_2</code> is the abundance at the upper quantile. However,
this definition only holds if one uses the interquartile range. Because we
allow the user to adjust the upper and lower quantiles, we have to find the
number of species at these abundance values. Here, we follow the
implementation in <code>scikit-bio</code> and round inwards to find the quantile
values, taking the number of species and log-abundance values at these data
points exactly.
</p>

<ul>
<li><p> Equivalent to <code>kempton_taylor_q()</code> in
<code>skbio.diversity.alpha</code>.
</p>
</li>
<li><p> Similar to the <code>qstat</code> calculator in Mothur. Our implementation
differs slightly, and this difference affects the result.
</p>
</li></ul>



<h3>Value</h3>

<p>The Kempton-Taylor Q index, <code class="reqn">Q &lt; 0</code>. If the vector sums to zero,
we cannot compute the quantiles, and this index is undefined. In that
case, we return <code>NaN</code>.
</p>


<h3>References</h3>

<p>Kempton RA, Taylor LR. Models and statistics for species diversity. Nature.
1976;262:818-820.
</p>

<hr>
<h2 id='kullback_leibler_divergence'>Kullback-Leibler divergence</h2><span id='topic+kullback_leibler_divergence'></span>

<h3>Description</h3>

<p>Kullback-Leibler divergence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kullback_leibler_divergence(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kullback_leibler_divergence_+3A_x">x</code>, <code id="kullback_leibler_divergence_+3A_y">y</code></td>
<td>
<p>Numeric vectors representing probabilities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kullback-Leibler divergence is a non-symmetric measure of difference between
two probability vectors. In general, KL(x, y) is not equal to KL(y, x).
</p>
<p>Because this measure is defined for probabilities, the vectors x and y are
normalized in the function so they sum to 1.
</p>


<h3>Value</h3>

<p>The Kullback-Leibler divergence between <code>x</code> and <code>y</code>. We
adopt the following conventions if elements of <code>x</code> or <code>y</code> are
zero: <code class="reqn">0 \log (0 / y_i) = 0</code>, <code class="reqn">0 \log (0 / 0) = 0</code>, and
<code class="reqn">x_i \log (x_i / 0) = \infty</code>. As a result, if elements of <code>x</code> are
zero, they do not contribute to the sum. If elements of <code>y</code> are zero
where <code>x</code> is nonzero, the result will be <code>Inf</code>. If either
<code>x</code> or <code>y</code> sum to zero, we are not able to compute the
proportions, and we return <code>NaN</code>.
</p>

<hr>
<h2 id='leprieur_tree'>Example data for phylogenetic nestedness and turnover components</h2><span id='topic+leprieur_tree'></span>

<h3>Description</h3>

<p>This tree was used in Figure 2 of Leprieur et al. (2005) to demonstrate
the nestedness and turnover components of phylogenetic beta diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leprieur_tree
</code></pre>


<h3>Format</h3>

<p><code>leprieur_tree</code> is a phylogenetic tree with 8 tips, labeled
a-h. It was created with the <code>ape</code> library. All edges (branches) in the
tree are of length 1.</p>


<h3>Source</h3>

<p>Leprieur F, Albouy C, De Bortoli J, Cowman PF, Bellwood DR, Mouillot D.
Quantifying phylogenetic beta diversity: distinguishing between &quot;true&quot;
turnover of lineages and phylogenetic diversity gradients. PLoS One.
2012;7(8):e42760. 10.1371/journal.pone.0042760
</p>

<hr>
<h2 id='lozupone_tree'>Example data for UniFrac distance</h2><span id='topic+lozupone_tree'></span><span id='topic+lozupone_panel_a'></span><span id='topic+lozupone_panel_b'></span>

<h3>Description</h3>

<p>This example was used to illustrate unweighted UniFrac distance in Lozupone
and Knight (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lozupone_tree

lozupone_panel_a

lozupone_panel_b
</code></pre>


<h3>Format</h3>

<p><code>lozupone_tree</code> is a phylogenetic tree with 14 tips, labeled
A-N. It was created with the <code>ape</code> library.
</p>
<p>The data frames <code>lozupone_panel_a</code> and <code>lozupone_panel_b</code> are
transcribed from Figure 1 of the paper. They have the following columns:
</p>

<dl>
<dt>Species</dt><dd><p>The species label, matching to the phylogenetic tree.</p>
</dd>
<dt>SampleID</dt><dd><p>The community, either &quot;Circle&quot; or &quot;Square&quot;.</p>
</dd>
<dt>Counts</dt><dd>
<p>The number of organisms counted per species, always 1 for this
example.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Lozupone C, Knight R. UniFrac: a new phylogenetic method for
comparing microbial communities. Applied and environmental microbiology.
2005;71(12):8228–8235. 10.1128/AEM.71.12.8228-8235.2005
</p>

<hr>
<h2 id='manhattan'>Manhattan and related distances</h2><span id='topic+manhattan'></span><span id='topic+mean_character_difference'></span><span id='topic+modified_mean_character_difference'></span>

<h3>Description</h3>

<p>The Manhattan or city block distance is the sum of absolute differences
between the elements of two vectors. The <em>mean character</em> difference
is a closely related measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan(x, y)

mean_character_difference(x, y)

modified_mean_character_difference(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manhattan_+3A_x">x</code>, <code id="manhattan_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vectors <code>x</code> and <code>y</code>, the Manhattan distance is given by
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \sum_i |x_i - y_i|.</code>
</p>
<p> Relation of <code>manhattan()</code> to
other definitions:
</p>

<ul>
<li><p> Equivalent to R's built-in <code>dist()</code> function with
<code>method = "manhattan"</code>.
</p>
</li>
<li><p> Equivalent to <code>vegdist()</code> with <code>method = "manhattan"</code>.
</p>
</li>
<li><p> Equivalent to the <code>cityblock()</code> function in
<code>scipy.spatial.distance</code>.
</p>
</li>
<li><p> Equivalent to the <code>manhattan</code> calculator in Mothur.
</p>
</li>
<li><p> Equivalent to <code class="reqn">D_7</code> in Legendre &amp; Legendre.
</p>
</li>
<li><p> Whittaker's index of association (<code class="reqn">D_9</code> in Legendre &amp;
Legendre) is the Manhattan distance computed after transforming to
proportions and dividing by 2.
</p>
</li></ul>

<p>The mean character difference is the Manhattan distance divided by the
length of the vectors. It was proposed by Cain and Harrison in 1958.
Relation of <code>mean_character_difference()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to <code class="reqn">D_8</code> in Legendre &amp; Legendre.
</p>
</li>
<li><p> For binary data, equivalent to <code class="reqn">1 - S_1</code> in Legendre &amp; Legendre,
where <code class="reqn">S_1</code> is the simple matching coefficient.
</p>
</li></ul>

<p>The modified mean character difference is the Manhattan distance divided by
the number elements where either <code>x</code> or <code>y</code> (or both) are nonzero.
Relation of <code>modified_mean_character_difference()</code> to other
definitions:
</p>

<ul>
<li><p> Equivalent to <code class="reqn">D_{19}</code> in Legendre &amp; Legendre.
</p>
</li>
<li><p> Equivalent to <code>vegdist()</code> with <code>method = "altGower"</code>.
</p>
</li>
<li><p> For binary data, it is equivalent to the Jaccard distance.
</p>
</li></ul>



<h3>Value</h3>

<p>The distance between <code>x</code> and <code>y</code>. The modified mean
character difference is undefined if all elements in <code>x</code> and <code>y</code>
are zero, in which case we return <code>NaN</code>.
</p>


<h3>References</h3>

<p>Cain AJ, Harrison GA. An analysis of the taxonomist's judgment of affinity.
Proceedings of the Zoological Society of London 1958;131:85-98.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
y &lt;- c(10, 2, 0, 1, 1, 0)
manhattan(x, y)
# Whittaker's index of association
manhattan(x / sum(x), y / sum(y)) / 2

mean_character_difference(x, y)
# Simple matching coefficient for presence/absence data
# Should be 2 / 6
mean_character_difference(x &gt; 0, y &gt; 0)

modified_mean_character_difference(x, y)
# Jaccard distance for presence/absence data
modified_mean_character_difference(x &gt; 0, y &gt; 0)
jaccard(x, y)
</code></pre>

<hr>
<h2 id='margalef'>Margalef's richness index</h2><span id='topic+margalef'></span>

<h3>Description</h3>

<p>Margalef's richness index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margalef(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margalef_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a vector <code>x</code> of species counts, Margalef's index is
</p>
<p style="text-align: center;"><code class="reqn">D = \frac{S -1}{\log N},</code>
</p>
<p> where <code class="reqn">S</code> is the total number of species
observed and <code class="reqn">N</code> is the total number of counts.
</p>
<p>This index is appropriate only for raw counts, not transformed counts or
proportions.
</p>
<p>Equivalent to <code>margalef()</code> in <code>skbio.diversity.alpha</code>.
</p>


<h3>Value</h3>

<p>The value of Margalef's index, <code class="reqn">D \geq 0</code>. This index is
undefined when the total number of counts is 1 or 0, in which case we
return <code>NaN</code>.
</p>


<h3>References</h3>

<p>Margalef R. Information theory in ecology. General Systems 3. 1958;36-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
margalef(x)
</code></pre>

<hr>
<h2 id='match_to_tree'>Match vector of counts to phylogenetic tree</h2><span id='topic+match_to_tree'></span>

<h3>Description</h3>

<p>Match vector of counts to phylogenetic tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_to_tree(x, tree, x_labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_to_tree_+3A_x">x</code></td>
<td>
<p>A vector of species counts.</p>
</td></tr>
<tr><td><code id="match_to_tree_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree of class <code>"phylo"</code>.</p>
</td></tr>
<tr><td><code id="match_to_tree_+3A_x_labels">x_labels</code></td>
<td>
<p>A vector of species labels for <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies a couple of different methods to arrange the
data in <code>x</code> to match a phylogenetic tree.
</p>

<ul>
<li><p> If <code>x_labels</code> is provided, we use this vector to match the
elements of <code>x</code> with the tip labels in the tree.
</p>
</li>
<li><p> If <code>x_labels</code> is not provided and <code>x</code> is a named vector,
we use the names to match the tip labels in the tree.
</p>
</li>
<li><p> If <code>x_labels</code> is not provided and <code>x</code> is not named, we
assume that <code>x</code> is already in the correct order, check that the
length of <code>x</code> matches the number of tips in the tree, and return
<code>x</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The vector <code>x</code>, re-arranged to match the tree.
</p>

<hr>
<h2 id='mcintosh_d'>McIntosh dominance index D</h2><span id='topic+mcintosh_d'></span>

<h3>Description</h3>

<p>McIntosh dominance index D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcintosh_d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcintosh_d_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a vector <code>x</code> of raw species counts, the McIntosh dominance index is
defined as </p>
<p style="text-align: center;"><code class="reqn">D = \frac{N - U}{N - \sqrt{N}},</code>
</p>
<p> where <code class="reqn">N</code> is the total
number of counts and <code class="reqn">U = \sqrt{\sum_i x_i^2}</code>.
</p>
<p>This index is appropriate only for raw counts, not transformed counts or
proportions.
</p>
<p>Equivalent to <code>mcintosh_d()</code> in <code>skbio.diversity.alpha</code>.
</p>


<h3>Value</h3>

<p>The McIntosh dominance index, <code class="reqn">0 \leq D &lt; 1</code>. The index is undefined
when the total number of counts is 1 or 0, in which case we return
<code>NaN</code>.
</p>


<h3>References</h3>

<p>McIntosh RP. An index of diversity and the relation of certain concepts to
diversity. Ecology. 1967;48:1115-1126.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
mcintosh_d(x)
</code></pre>

<hr>
<h2 id='mcintosh_e'>McIntosh's evenness measure E</h2><span id='topic+mcintosh_e'></span>

<h3>Description</h3>

<p>McIntosh's evenness measure E
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcintosh_e(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcintosh_e_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a vector <code>x</code> of raw species counts, the McIntosh evenness measure
is </p>
<p style="text-align: center;"><code class="reqn">E = \frac{\sqrt{\sum_i x_i^2}}{\sqrt{(N - S + 1)^2 + S - 1},}</code>
</p>

<p>where <code class="reqn">N</code> is the total number of counts and <code class="reqn">S</code> is the total
number of species observed.
</p>
<p>This index is appropriate only for raw counts, not transformed counts or
proportions.
</p>
<p>Equivalent to <code>mcintosh_e()</code> in <code>skbio.diversity.alpha</code>.
</p>


<h3>Value</h3>

<p>McIntosh's evenness measure, <code class="reqn">0 &lt; E \leq 1</code>.  The index is
undefined when the total number of counts is 0, in which case we return
<code>NaN</code>.
</p>


<h3>References</h3>

<p>Heip C, Engels P. Comparing Species Diversity and Evenness Indices. J. Mar.
Bioi. Ass. U.K. 1974;54:559-563.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
mcintosh_e(x)
</code></pre>

<hr>
<h2 id='menhinick'>Menhinick's richness index</h2><span id='topic+menhinick'></span>

<h3>Description</h3>

<p>Menhinick's richness index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>menhinick(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="menhinick_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a vector <code>x</code> of raw species counts, the Menhinick's richness index
is <code class="reqn">\frac{S}{\sqrt{N}}</code>, where <code class="reqn">N</code> is the total number
of counts and <code class="reqn">S</code> is the total number of species observed.
</p>
<p>This index is appropriate only for raw counts, not transformed counts or
proportions.
</p>
<p>Equivalent to <code>menhinick()</code> in <code>skbio.diversity.alpha</code>.
</p>


<h3>Value</h3>

<p>Menhinick's richness index, <code class="reqn">R &gt; 0</code>. The index is undefined when
the total number of counts is 0, in which case we return <code>NaN</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
menhinick(x)
</code></pre>

<hr>
<h2 id='minkowski'>Minkowski distance</h2><span id='topic+minkowski'></span>

<h3>Description</h3>

<p>The Minkowski metric is a generalized form of Euclidean (p=2) and Manhattan
(p=1) distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minkowski(x, y, p = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minkowski_+3A_x">x</code>, <code id="minkowski_+3A_y">y</code></td>
<td>
<p>Numeric vectors.</p>
</td></tr>
<tr><td><code id="minkowski_+3A_p">p</code></td>
<td>
<p>Exponent parameter, a single number greater than zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vectors <code>x</code> and <code>y</code>, the Minkowski distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = \left( \sum_i |x_i - y_i|^p \right)^{1/p}.</code>
</p>
<p> Relation to
other definitions:
</p>

<ul>
<li><p> Equivalent to R's built-in <code>dist()</code> function with
<code>method = "minkowski"</code>.
</p>
</li>
<li><p> Equivalent to the <code>minkowski()</code> function in
<code>scipy.spatial.distance</code>.
</p>
</li>
<li><p> Equivalent to <code class="reqn">D_6</code> in Legendre &amp; Legendre.
</p>
</li></ul>

<p>The default value of <code>p = 1</code> makes this distance equal to the Manhattan
distance.
</p>


<h3>Value</h3>

<p>The Minkowski distance between <code>x</code> and <code>y</code>.
</p>

<hr>
<h2 id='morisita'>The Morisita index and Horn-Morisita index</h2><span id='topic+morisita'></span><span id='topic+horn_morisita'></span>

<h3>Description</h3>

<p>The Morisita and the Horn-Morisita indices measure the probability that
individuals drawn one from each vector will belong to different species,
relative to drawing from each vector separately. The Morisita index is
formulated for count data only, whereas the Horn-Morisita index can be
used with transformed counts or proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morisita(x, y)

horn_morisita(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morisita_+3A_x">x</code>, <code id="morisita_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For two vectors <code>x</code> and <code>y</code>, the Morisita index of dissimilarity
is
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) = 1 - \frac{2 \sum_i x_i y_i}{(\lambda_x + \lambda_y) N_x N_y},</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">\lambda_x = \frac{\sum_i x_i (x_i - 1)}{N_x (N_x - 1)}</code>
</p>
<p> and
<code class="reqn">N_x = \sum_i x_i</code> The formula for <code class="reqn">\lambda_x</code> is the unbiased
estimate for the probability of drawing two individuals of the same species
from <code>x</code>, without replacement. The correction for sampling without
replacement only makes sense for species count data.
</p>
<p>Relation of <code>morisita()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>vegdist()</code> with <code>method = "morisita"</code>.
</p>
</li></ul>

<p>Horn (1966) reformulated the index to use the equations for sampling with
replacement in <code class="reqn">\lambda_x</code> and <code class="reqn">\lambda_y</code>:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_x = \frac{\sum_i x_i^2}{N_x^2}</code>
</p>
<p> With this modification,
the index is valid for proportions or transformed count data.
</p>
<p>Relation of <code>horn_morisita()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>vegdist()</code> with <code>method = "horn"</code>.
</p>
</li>
<li><p> Equivalent to the <code>morisitahorn</code> calculator in Mothur.
</p>
</li></ul>



<h3>Value</h3>

<p>The Morisita or Horn-Morisita index between <code>x</code> and <code>y</code>.
Both are undefined if <code>x</code> or <code>y</code> have no nonzero elements, in
which case we return <code>NaN</code>.
</p>


<h3>References</h3>

<p>Mosrisita M. Measuring of interspecific association and similarity between
communities. Memoirs of the Faculty of Science, Kyushu Univ., Series E
(Biology). 1959;3:65-80.
</p>
<p>Horn HS. Measurement of &quot;Overlap&quot; in Comparative Ecological Studies. The
American Naturalist, 1966;100(914):419-424.
</p>

<hr>
<h2 id='richness'>Richness or number of observed species</h2><span id='topic+richness'></span>

<h3>Description</h3>

<p>Richness or number of observed species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>richness(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="richness_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts or proportions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The richness is simply the number of nonzero elements in <code>x</code>.
Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>observed_otus()</code> in <code>skbio.diversity.alpha</code>.
</p>
</li>
<li><p> Equivalent to <code>specnumber</code> in <code>vegan</code>.
</p>
</li>
<li><p> Equivalent to the <code>sobs</code> calculator in Mothur.
</p>
</li></ul>



<h3>Value</h3>

<p>The number of species observed, <code class="reqn">R \geq 0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
richness(x) # 4
</code></pre>

<hr>
<h2 id='ruzicka'>Ruzicka or weighted Jaccard distance</h2><span id='topic+ruzicka'></span>

<h3>Description</h3>

<p>Ruzicka or weighted Jaccard distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruzicka(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruzicka_+3A_x">x</code>, <code id="ruzicka_+3A_y">y</code></td>
<td>
<p>Numeric vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vectors <code>x</code> and <code>y</code>, the Ruzicka distance is defined as
</p>
<p style="text-align: center;"><code class="reqn">d(x, y) = 1 - \frac{\sum_i \min(x, y)}{\sum_i \max(x, y)}.</code>
</p>
<p> Relation
to other definitions:
</p>

<ul>
<li><p> Equivalent to vegdist() with method = &quot;jaccard&quot;.
</p>
</li>
<li><p> Related to the Bray-Curtis distance,
<code class="reqn">d_r = 2 d_{bc} / (1 + d_{bc})</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The Ruzicka distance between <code>x</code> and <code>y</code>. The distance is
not defined if all elements in <code>x</code> and <code>y</code> are zero, and we
return <code>NaN</code> in this case.
</p>

<hr>
<h2 id='shannon'>Shannon diversity and related measures</h2><span id='topic+shannon'></span><span id='topic+brillouin_d'></span><span id='topic+heip_e'></span><span id='topic+pielou_e'></span>

<h3>Description</h3>

<p>The Shannon index of diversity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shannon(x, base = exp(1))

brillouin_d(x)

heip_e(x)

pielou_e(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shannon_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts or proportions.</p>
</td></tr>
<tr><td><code id="shannon_+3A_base">base</code></td>
<td>
<p>Base of the logarithm to use in the calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Shannon index of diversity or Shannon information entropy has deep roots
in information theory. It is defined as </p>
<p style="text-align: center;"><code class="reqn">H = - \sum_i p_i \log{p_i},</code>
</p>

<p>where <code class="reqn">p_i</code> is the species proportion. Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>diversity()</code> in <code>vegan</code> with
<code>index = "shannon"</code>.
</p>
</li>
<li><p> Equivalent to <code>shannon()</code> in <code>skbio.diversity.alpha</code>.
</p>
</li></ul>

<p>The Brillouin index (Brillouin 1956) is similar to Shannon's index, but
accounts for sampling without replacement. For a vector of species counts
<code>x</code>, the Brillouin index is
</p>
<p style="text-align: center;"><code class="reqn">
  \frac{1}{N}\log{\frac{N!}{\prod_i x_i!}} =
  \frac{\log{N!} - \sum_i \log{x_i!}}{N}
</code>
</p>
<p> where <code class="reqn">N</code> is the total number of counts. Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>brillouin_d()</code> in <code>skbio.diversity.alpha</code>.
</p>
</li>
<li><p> Equivalent to the <code>shannon</code> calculator in Mothur.
</p>
</li></ul>

<p>The Brillouin index accounts for the total number of individuals sampled,
and should be used on raw count data, not proportions.
</p>
<p>Heip's evenness measure is </p>
<p style="text-align: center;"><code class="reqn">\frac{e^H - 1}{S - 1},</code>
</p>
<p> where <code class="reqn">S</code> is
the total number of species observed. Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>heip_e()</code> in <code>skbio.diversity.alpha</code>.
</p>
</li></ul>

<p>Pielou's Evenness index <code class="reqn">J = H / \log{S}</code>. Relation to other
definitions:
</p>

<ul>
<li><p> Equivalent to <code>peilou_e()</code> in <code>skbio.diversity.alpha</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The Shannon diversity, <code class="reqn">H \geq 0</code>, or related quantity. The
value of <code class="reqn">H</code> is undefined if <code>x</code> sums to zero, and we return
<code>NaN</code> in this case.  Heip's evenness measure and Pielou's Evenness
index are undefined if only one element of <code>x</code> is nonzero, and again
we return <code>NaN</code> if this is the case.
</p>


<h3>References</h3>

<p>Brillouin L. Science and Information Theory. 1956;Academic Press, New York.
</p>
<p>Pielou EC. The Measurement of Diversity in Different Types of Biological
Collections. Journal of Theoretical Biology. 1966;13:131-144.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
shannon(x)

# Using a different base is the same as dividing by the log of that base
shannon(x, base = 10)
shannon(x) / log(10)

brillouin_d(x)

# Brillouin index should be almost identical to Shannon index for large N
brillouin_d(10000 * x)
shannon(10000 * x)

heip_e(x)
(exp(shannon(x)) - 1) / (richness(x) - 1)

pielou_e(x)
shannon(x) / log(richness(x))
</code></pre>

<hr>
<h2 id='simpson'>Simpson's index and related measures</h2><span id='topic+simpson'></span><span id='topic+dominance'></span><span id='topic+invsimpson'></span><span id='topic+simpson_e'></span>

<h3>Description</h3>

<p>These measures are based on the sum of squared species proportions. The
function <code>dominance()</code> gives this quantity, <code>simpson()</code> gives one
minus this quantity, <code>invsimpson()</code> gives the reciprocal of the
quantity, and <code>simpson_e</code> gives the reciprocal divided by the number
of species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpson(x)

dominance(x)

invsimpson(x)

simpson_e(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpson_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts or proportions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a vector of species counts <code>x</code>, the dominance index is defined as
</p>
<p style="text-align: center;"><code class="reqn">D = \sum_i p_i^2,</code>
</p>
<p> where <code class="reqn">p_i</code> is the species proportion,
<code class="reqn">p_i = x_i / N</code>, and <code class="reqn">N</code> is the total number of counts. This is
equal to the probability of selecting two individuals from the same species,
with replacement. Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>dominance()</code> in <code>skbio.diversity.alpha</code>.
</p>
</li>
<li><p> Similar to the <code>simpson</code> calculator in Mothur. They use the
unbiased estimate <code class="reqn">p_i = x_i (x_i - 1) / (N (N -1))</code>.
</p>
</li></ul>

<p>Simpson's index is defined here as <code class="reqn">1 - D</code>, or the probability of
selecting two individuals from different species, with replacement. Relation
to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>diversity()</code> in <code>vegan</code> with
<code>index = "simpson"</code>.
</p>
</li>
<li><p> Equivalent to <code>simpson()</code> in <code>skbio.diversity.alpha</code>.
</p>
</li></ul>

<p>The inverse Simpson index is <code class="reqn">1/D</code>. Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>diversity()</code> in <code>vegan</code> with
<code>index = "invsimpson"</code>.
</p>
</li>
<li><p> Equivalent to <code>enspie()</code> in <code>skbio.diversity.alpha</code>.
</p>
</li>
<li><p> Similar to the <code>invsimpson</code> calculator in Mothur. They use
the unbiased estimate <code class="reqn">p_i = x_i (x_i - 1) / (N (N -1))</code>.
</p>
</li></ul>

<p>Simpson's evenness index is the inverse Simpson index divided by the
number of species observed, <code class="reqn">1 / (D S)</code>. Relation to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>simpson_e()</code> in <code>skbio.diversity.alpha</code>.
</p>
</li></ul>

<p>Please be warned that the naming conventions vary between sources. For
example Wikipedia calls <code class="reqn">D</code> the Simpson index and <code class="reqn">1 - D</code> the
Gini-Simpson index. We have followed the convention from <code>vegan</code>, to
avoid confusion within the <code>R</code> ecosystem.
</p>


<h3>Value</h3>

<p>The value of the dominance (<code class="reqn">0 &lt; D \leq 1</code>), Simpson index, or
inverse Simpson index. The dominance is undefined if the vector sums to
zero, in which case we return <code>NaN</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(15, 6, 4, 0, 3, 0)
dominance(x)

# Simpson is 1 - D
simpson(x)
1 - dominance(x)

# Inverse Simpson is 1/D
invsimpson(x)
1 / dominance(x)

# Simpson's evenness is 1 / (D * S)
simpson_e(x)
1 / (dominance(x) * richness(x))
</code></pre>

<hr>
<h2 id='strong'>Strong's dominance index</h2><span id='topic+strong'></span>

<h3>Description</h3>

<p>Strong's dominance index measures the maximum departure between the observed
proportions and a perfectly even community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strong(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strong_+3A_x">x</code></td>
<td>
<p>A numeric vector of species counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strong's dominance index is defined as
</p>
<p style="text-align: center;"><code class="reqn">D_W = \max_i \left [ \frac{b_i}{N} - \frac{i}{S} \right ],</code>
</p>
<p> where
<code class="reqn">b_i</code> is the abundance of the <code class="reqn">i</code>th species, ordered from smallest
to largest, <code class="reqn">N</code> is the total number of counts, and <code class="reqn">S</code> is the number
of species observed.
</p>
<p>Equivalent to <code>strong()</code> in <code>skbio.diversity.alpha</code>.
</p>


<h3>Value</h3>

<p>Strong's dominance index, <code class="reqn">0 \leq D_W &lt; 1</code>. The index is
undefined if <code>x</code> sums to 0, and we return <code>NaN</code> in this case.
</p>


<h3>References</h3>

<p>Strong WL. Assessing species abundance uneveness within and between plant
communities. Community Ecology. 2002;3:237-246.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(9, 0, 1, 2, 5, 2, 1, 1, 0, 7, 2, 1, 0, 1, 1)
strong(x)
</code></pre>

<hr>
<h2 id='unifrac'>UniFrac distance</h2><span id='topic+unifrac'></span><span id='topic+unweighted_unifrac'></span><span id='topic+weighted_unifrac'></span><span id='topic+weighted_normalized_unifrac'></span><span id='topic+variance_adjusted_unifrac'></span><span id='topic+generalized_unifrac'></span><span id='topic+information_unifrac'></span><span id='topic+phylosor'></span>

<h3>Description</h3>

<p>The UniFrac distance is a phylogenetically-weighted distance between two
communities of organisms. The measure has been extended a number of
times to include abundance-weighted and variance-adjusted versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unweighted_unifrac(x, y, tree, xy_labels = NULL)

weighted_unifrac(x, y, tree, xy_labels = NULL)

weighted_normalized_unifrac(x, y, tree, xy_labels = NULL)

variance_adjusted_unifrac(x, y, tree, xy_labels = NULL)

generalized_unifrac(x, y, tree, alpha = 0.5, xy_labels = NULL)

information_unifrac(x, y, tree, xy_labels = NULL)

phylosor(x, y, tree, xy_labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unifrac_+3A_x">x</code>, <code id="unifrac_+3A_y">y</code></td>
<td>
<p>Numeric vectors of species counts or proportions.</p>
</td></tr>
<tr><td><code id="unifrac_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree object.</p>
</td></tr>
<tr><td><code id="unifrac_+3A_xy_labels">xy_labels</code></td>
<td>
<p>A character vector of species labels for <code>x</code> and
<code>y</code>.</p>
</td></tr>
<tr><td><code id="unifrac_+3A_alpha">alpha</code></td>
<td>
<p>Generalized UniFrac parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute different variations of the UniFrac distance between
communities described by the vectors <code>x</code> and <code>y</code>. If the vectors
are named, the names will be automatically used to match the vectors with
the tree. Missing names are filled in with zero counts. If the vectors are
not named and <code>xy_labels</code> is provided, these labels will be used to
match the vectors with the tree. If the vectors are not named and
<code>xy_labels</code> is not provided, it is assumed that the vectors are already
in the correct order, and we simply check that their length matches the
number of tips in the tree.
</p>
<p><code>unweighted_unifrac</code> gives the original UniFrac distance from Lozupone
and Knight (2005), which is the fraction of total branch length leading to
community <code>x</code> or community <code>y</code>, but not both. It is based on
species presence/absence.
</p>
<p><code>weighted_unifrac</code> gives the abundance-weighted version of UniFrac
proposed by Lozupone et al. (2007). In this measure, the branch lengths of
the tree are multiplied by the absolute difference in species abundances
below each branch.
</p>
<p><code>weighted_normalized_unifrac</code> provides a normalized version of
<code>weighted_unifrac</code>, so the distance is between 0 and 1.
</p>
<p><code>variance_adjusted_unifrac</code> was proposed by Chang et al. (2011) to
adjust for the variation of weights in weighted UniFrac under random
sampling.
</p>
<p><code>generalized_unifrac</code> was proposed by Chen et al. (2012) to provide a
unified mathematical framework for weighted and unweighted UniFrac distance.
It includes a parameter, <code class="reqn">\alpha</code>, which can be used to adjust the
abundance-weighting in the distance. A value of <code class="reqn">\alpha = 1</code> corresponds
to weighted UniFrac. A value of <code class="reqn">\alpha = 0</code> corresponds to unweighted
UniFrac if presence/absence vectors are provided.  The authors suggest a
value of <code class="reqn">\alpha = 0.5</code> as a compromise between weighted and unweighted
distances.
</p>
<p><code>information_unifrac</code> was proposed by Wong et al. (2016) to connect
UniFrac distance with compositional data analysis. They also proposed a
&quot;ratio UniFrac&quot; distance, which is not yet implemented.
</p>
<p><code>phylosor</code>, proposed by Bryant et al. (2008), is closely related to
unweighted UniFrac distance. If unweighted UniFrac distance is the analogue
of Jaccard distance using branches on a phylogenetic tree, PhyloSor is the
analogue of Sorenson dissimilarity.
</p>


<h3>Value</h3>

<p>The UniFrac distance between communities <code>x</code> and <code>y</code>. The
distance is not defined if either <code>x</code> or <code>y</code> have all zero
elements. We return <code>NaN</code> if this is the case.
</p>


<h3>References</h3>

<p>Lozupone C, Knight R. UniFrac: a new phylogenetic method for
comparing microbial communities. Applied and environmental microbiology.
2005;71(12):8228–8235. 10.1128/AEM.71.12.8228-8235.2005
</p>
<p>Lozupone CA, Hamady M, Kelley ST, Knight R. Quantitative and
qualitative <code class="reqn">\beta</code> diversity measures lead to different insights into
factors that structure microbial communities. Applied and environmental
microbiology. 2007;73(5):1576–1585. 10.1128/AEM.01996-06
</p>
<p>Chang Q., et al. Variance adjusted weighted UniFrac: a powerful
beta diversity measure for comparing communities based on phylogeny.
BMC Bioinformatics. 2011;12:118. 10.1186/1471-2105-12-118
</p>
<p>Chen J, Bittinger K, Charlson ES, Hoffmann C, Lewis J, Wu GD,
et al. Associating microbiome composition with environmental covariates
using generalized UniFrac distances. Bioinformatics.
2012;28(16):2106–2113. 10.1093/bioinformatics/bts342
</p>
<p>Wong RG, Wu JR, Gloor GB. Expanding the UniFrac Toolbox.
PLOS ONE. 2016;11(9):1–20. 10.1371/journal.pone.0161196
</p>
<p>Bryant JA, Lamanna C, Morlon H, Kerkhoff AJ, Enquist BJ, Green JL.
Microbes on mountainsides: contrasting elevational patterns of bacterial
and plant diversity. Proc Natl Acad Sci U S A. 2008;105 Suppl 1:11505-11.
10.1073/pnas.0801920105
</p>


<h3>Examples</h3>

<pre><code class='language-R'># From Lozupone and Knight (2005), Figure 1.
# Panel A
x1 &lt;- c(1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1)
x2 &lt;- c(0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0)
unweighted_unifrac(x1, x2, lozupone_tree)

# Panel B
x3 &lt;- c(0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1)
x4 &lt;- c(1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0)
unweighted_unifrac(x3, x4, lozupone_tree)

# Can use named vectors to specify species
weighted_normalized_unifrac(
  c(A=1, C=1, D=1, F=1, I=1, L=1, N=1),
  c(B=1, E=1, G=1, H=1, J=1, K=1, M=1),
  lozupone_tree)
weighted_normalized_unifrac(x1, x2, lozupone_tree)

# Generalized UniFrac is equal to weighted normalized UniFrac when alpha = 1
generalized_unifrac(x1, x2, lozupone_tree, alpha=1)
generalized_unifrac(x1, x2, lozupone_tree, alpha=0.5)
</code></pre>

<hr>
<h2 id='unifrac_components'>Nestedness and turnover components of unweighted UniFrac distance</h2><span id='topic+unifrac_components'></span><span id='topic+unweighted_unifrac_turnover'></span><span id='topic+unweighted_unifrac_nestedness'></span><span id='topic+phylosor_turnover'></span><span id='topic+phylosor_nestedness'></span>

<h3>Description</h3>

<p>Nestedness and turnover components of unweighted UniFrac distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unweighted_unifrac_turnover(x, y, tree, xy_labels = NULL)

unweighted_unifrac_nestedness(x, y, tree, xy_labels = NULL)

phylosor_turnover(x, y, tree, xy_labels = NULL)

phylosor_nestedness(x, y, tree, xy_labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unifrac_components_+3A_x">x</code>, <code id="unifrac_components_+3A_y">y</code></td>
<td>
<p>Numeric vectors of species counts or proportions.</p>
</td></tr>
<tr><td><code id="unifrac_components_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree object.</p>
</td></tr>
<tr><td><code id="unifrac_components_+3A_xy_labels">xy_labels</code></td>
<td>
<p>A character vector of species labels for <code>x</code> and
<code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leprieur et al. (2012) showed that measures of phylogenetic beta diversity
could be partitioned into nestedness and turnover components, following the
approach of Baselga (2010) for Sorenson dissimilarity.
</p>


<h3>Value</h3>

<p>The nestedness or turnover component of the UniFrac distance
between communities <code>x</code> and <code>y</code>. This quantity is undefined
when either <code>x</code> or <code>y</code> have all elements equal to zero, in
which case we return <code>NaN</code>.
</p>


<h3>References</h3>

<p>Baselga A. Partitioning the turnover and nestedness components of beta
diversity. Global Ecol. Biogeogr. 2010;19:134-143.
</p>
<p>Leprieur F, Albouy C, De Bortoli J, Cowman PF, Bellwood DR, Mouillot D.
Quantifying phylogenetic beta diversity: distinguishing between &quot;true&quot;
turnover of lineages and phylogenetic diversity gradients. PLoS One.
2012;7(8):e42760. 10.1371/journal.pone.0042760
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vectors x and y have turnover but no nestedness
x &lt;- c(1, 1, 1, 0, 0, 0, 0, 0)
y &lt;- c(0, 1, 1, 1, 0, 0, 0, 0)

unweighted_unifrac(x, y, leprieur_tree)
unweighted_unifrac_turnover(x, y, leprieur_tree)
unweighted_unifrac_nestedness(x, y, leprieur_tree)

phylosor(x, y, leprieur_tree)
phylosor_turnover(x, y, leprieur_tree)
phylosor_nestedness(x, y, leprieur_tree)

# Vectors y and z have nestedness but no turnover
z &lt;- c(0, 1, 1, 1, 1, 1, 1, 1)

unweighted_unifrac(y, z, leprieur_tree)
unweighted_unifrac_turnover(y, z, leprieur_tree)
unweighted_unifrac_nestedness(y, z, leprieur_tree)

phylosor(y, z, leprieur_tree)
phylosor_turnover(y, z, leprieur_tree)
phylosor_nestedness(y, z, leprieur_tree)
</code></pre>

<hr>
<h2 id='weighted_kulczynski_second'>Weighted Kulczynski distance</h2><span id='topic+weighted_kulczynski_second'></span>

<h3>Description</h3>

<p>The quantitative version of the second Kulczynski index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_kulczynski_second(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_kulczynski_second_+3A_x">x</code>, <code id="weighted_kulczynski_second_+3A_y">y</code></td>
<td>
<p>Numeric vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantitative version of the second Kulczynski index is defined as
</p>
<p style="text-align: center;"><code class="reqn">
  d(x, y) = 1 - \frac{1}{2} \left (
    \frac{\sum_i \min{(x_i, y_i)}}{\sum_i x_i} +
    \frac{\sum_i \min{(x_i, y_i)}}{\sum_i y_i}
  \right ).
</code>
</p>

<p>Relation of <code>weighted_kulczynski_second()</code> to other definitions:
</p>

<ul>
<li><p> Equivalent to <code>vegdist()</code> with <code>method = "kulczynski"</code>.
</p>
</li>
<li><p> Equivalent to <code>structkulczynski</code> in Mothur.
</p>
</li>
<li><p> Equivalent to <code class="reqn">1 - S_{18}</code> in Legendre &amp; Legendre.
</p>
</li></ul>



<h3>Value</h3>

<p>The weighted Kulczynski distance between <code>x</code> and <code>y</code>. The
distance is undefined if the sum of <code>x</code> or the sum of <code>y</code> is
zero, in which case we return <code>NaN</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
