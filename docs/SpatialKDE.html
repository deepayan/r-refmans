<!DOCTYPE html><html><head><title>Help for package SpatialKDE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialKDE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#create_grid_rectangular'><p>Create grid</p></a></li>
<li><a href='#create_raster'><p>Create raster</p></a></li>
<li><a href='#kde'><p>Kernel Density Estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kernel Density Estimation for Spatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jancaha.github.io/SpatialKDE/index.html">https://jancaha.github.io/SpatialKDE/index.html</a>,
<a href="https://github.com/JanCaha/SpatialKDE">https://github.com/JanCaha/SpatialKDE</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate Kernel Density Estimation (KDE) for spatial data. 
  The algorithm is inspired by the tool 'Heatmap' from 'QGIS'. The method is described by:
  Hart, T., Zandbergen, P. (2014) &lt;<a href="https://doi.org/10.1108%2FPIJPSM-04-2013-0039">doi:10.1108/PIJPSM-04-2013-0039</a>&gt;, 
  Nelson, T. A., Boots, B. (2008) &lt;<a href="https://doi.org/10.1111%2Fj.0906-7590.2008.05548.x">doi:10.1111/j.0906-7590.2008.05548.x</a>&gt;,
  Chainey, S., Tompson, L., Uhlig, S.(2008) &lt;<a href="https://doi.org/10.1057%2Fpalgrave.sj.8350066">doi:10.1057/palgrave.sj.8350066</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11, progress</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, dplyr, glue, magrittr, rlang, vctrs, methods, raster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tmap, sp, knitr, rmarkdown, testthat (&ge; 2.99.0), xml2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-18 14:21:48 UTC; cahik</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Caha <a href="https://orcid.org/0000-0003-0165-0606"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Caha &lt;jan.caha@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-18 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='create_grid_rectangular'>Create grid</h2><span id='topic+create_grid_rectangular'></span><span id='topic+create_grid_hexagonal'></span>

<h3>Description</h3>

<p>Create grid of equally spaced rectangles or hexagons. The distance between centre points
in both x and y dimension is equal to <code>cell_size</code>. The function is effectively a wrapper around
<code><a href="sf.html#topic+st_make_grid">st_make_grid</a></code> with a little bit of preprocessing including generation of grid only inside
<code><a href="sf.html#topic+st_convex_hull">st_convex_hull</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_grid_rectangular(
  geometry,
  cell_size,
  side_offset = 0,
  only_inside = FALSE
)

create_grid_hexagonal(
  geometry,
  cell_size,
  side_offset = 0,
  only_inside = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_grid_rectangular_+3A_geometry">geometry</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> <code>data.frame</code> containing geometry which should be cover by
the grid.</p>
</td></tr>
<tr><td><code id="create_grid_rectangular_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> specifying the distance for equally spaced centers of polygons
(rectangular or hexagonal).</p>
</td></tr>
<tr><td><code id="create_grid_rectangular_+3A_side_offset">side_offset</code></td>
<td>
<p><code>numeric</code> specifying the side offset, distance added to the convex hull
of input geometry to generate grid for KDE. Good estimate is usually the same value as band width of KDE.</p>
</td></tr>
<tr><td><code id="create_grid_rectangular_+3A_only_inside">only_inside</code></td>
<td>
<p><code>logical</code> specifying if the grid cells should be generated only inside of the
geometry. Default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="sf.html#topic+sf">sf</a></code> <code>data.frame</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>create_grid_rectangular()</code>: Create rectangular grid
</p>
</li>
<li> <p><code>create_grid_hexagonal()</code>: Create hexagonal grid
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
nc &lt;- st_read(system.file("shape/nc.shp", package = "sf")) %&gt;% st_transform(32031)
grid &lt;- create_grid_hexagonal(nc, cell_size = 100000)
grid &lt;- create_grid_rectangular(nc, cell_size = 100000, only_inside = TRUE)

</code></pre>

<hr>
<h2 id='create_raster'>Create raster</h2><span id='topic+create_raster'></span>

<h3>Description</h3>

<p>Create raster of equally spaced cells. The distance between centre of cells
in both x and y dimension is equal to <code>cell_size</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_raster(geometry, cell_size, side_offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_raster_+3A_geometry">geometry</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> <code>data.frame</code> containing geometry which should be cover by
the raster.</p>
</td></tr>
<tr><td><code id="create_raster_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> specifying the distance for equally spaced cells.</p>
</td></tr>
<tr><td><code id="create_raster_+3A_side_offset">side_offset</code></td>
<td>
<p><code>numeric</code> specifying the side offset, distance added to the convex hull
of input geometry to generate raster for KDE. Good estimate is usually the same value as band width of KDE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="raster.html#topic+Raster-class">Raster-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
nc &lt;- st_read(system.file("shape/nc.shp", package = "sf")) %&gt;% st_transform(32031)
raster &lt;- create_raster(nc, cell_size = 100000)

</code></pre>

<hr>
<h2 id='kde'>Kernel Density Estimation</h2><span id='topic+kde'></span>

<h3>Description</h3>

<p>KDE for spatial data. The algorithm is heavily inspired by
<a href="https://github.com/qgis/QGIS/blob/b3d2619976a69d7fb67b884492da491dfaba287c/src/analysis/raster/qgskde.cpp">Heatmap tool</a>
in QGIS. The help for QGIS tools is provided <a href="https://docs.qgis.org/testing/en/docs/user_manual/processing_algs/qgis/interpolation.html#heatmap-kernel-density-estimation">at the QGIS website</a>.
The a tutorial is provided <a href="https://grindgis.com/software/heat-map-using-qgis">here</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde(
  points,
  band_width,
  decay = 1,
  kernel = c("quartic", "uniform", "triweight", "epanechnikov", "triangular"),
  scaled = FALSE,
  weights = c(),
  grid,
  cell_size,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kde_+3A_points">points</code></td>
<td>
<p><code><a href="sf.html#topic+sf">sf</a></code> <code>data.frame</code> containing only POINTS.</p>
</td></tr>
<tr><td><code id="kde_+3A_band_width">band_width</code></td>
<td>
<p><code>numeric</code> specifying the band width for KDE.</p>
</td></tr>
<tr><td><code id="kde_+3A_decay">decay</code></td>
<td>
<p><code>numeric</code> specifying the decay parameter for <code>"triangular"</code> kernel. For
other kernels besides <code>"triangular"</code> the parameter is not used.</p>
</td></tr>
<tr><td><code id="kde_+3A_kernel">kernel</code></td>
<td>
<p><code>character</code> specifying type of kernel to use. Available implemented kernels are
<code>"uniform", "quartic", "triweight", "epanechnikov", "triangular"</code>. Default is <code>"quartic"</code> and if
unknown kernel name is used it falls back to the default value.</p>
</td></tr>
<tr><td><code id="kde_+3A_scaled">scaled</code></td>
<td>
<p><code>logical</code> specifying if the output values should be scaled. Default value is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kde_+3A_weights">weights</code></td>
<td>
<p><code>numeric</code> vector of weights for individual <code>points</code>.</p>
</td></tr>
<tr><td><code id="kde_+3A_grid">grid</code></td>
<td>
<p>either <code><a href="sf.html#topic+sf">sf</a></code> <code>data.frame</code> (outcome of function
<code><a href="#topic+create_grid_rectangular">create_grid_rectangular</a></code> or <code><a href="#topic+create_grid_hexagonal">create_grid_hexagonal</a></code>) or
<code><a href="raster.html#topic+Raster-class">Raster-class</a></code> (outcome of function <code><a href="#topic+create_raster">create_raster</a></code>).
Does not have to be specified if <code>cell_size</code> is set.</p>
</td></tr>
<tr><td><code id="kde_+3A_cell_size">cell_size</code></td>
<td>
<p><code>numeric</code> specifying the distance for equal spaced points. Must be
higher than 0. Can be left out if <code>grid</code> is provided as <code>grid</code> is used instead.
The code used to generate grid is <code><a href="#topic+create_grid_rectangular">create_grid_rectangular</a>(points, cell_size, band_width)</code>.</p>
</td></tr>
<tr><td><code id="kde_+3A_quiet">quiet</code></td>
<td>
<p>Should printing of progress bar be suppressed? Default 'FALSE'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>grid</code> parameter specifies output of the function. KDE is calculated on the specified <code>grid</code>.
If grid is <code><a href="raster.html#topic+Raster-class">Raster-class</a></code> then outcome is also <code><a href="raster.html#topic+Raster-class">Raster-class</a></code>.
If grid is <code><a href="sf.html#topic+sf">sf</a></code> <code>data.frame</code> then outcome is also <code><a href="sf.html#topic+sf">sf</a></code> <code>data.frame</code>.
</p>


<h3>Value</h3>

<p>either <code><a href="sf.html#topic+sf">sf</a></code> <code>data.frame</code> or <code><a href="raster.html#topic+Raster-class">Raster-class</a></code>
depending on class of <code>grid</code> parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
nc &lt;- st_read(system.file("shape/nc.shp", package = "sf")) %&gt;% st_transform(32031)
grid &lt;- create_grid_hexagonal(nc, cell_size = 100000)
points &lt;- st_sample(nc, 500) %&gt;% st_as_sf()
kde_estimate_grid &lt;- kde(points, band_width = 150000, grid = grid)
raster &lt;- create_raster(nc, cell_size = 100000)
kde_estimate_raster &lt;- kde(points, band_width = 150000, grid = raster)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
