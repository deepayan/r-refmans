<!DOCTYPE html><html lang="en"><head><title>Help for package flexmix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flexmix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC-methods'><p>Methods for Function AIC</p></a></li>
<li><a href='#betablocker'><p>Clinical Trial of Beta-Blockers</p></a></li>
<li><a href='#BIC-methods'><p>Methods for Function BIC</p></a></li>
<li><a href='#bioChemists'><p>Articles by Graduate Students in Biochemistry Ph.D. Programs</p></a></li>
<li><a href='#boot'><p>Bootstrap a flexmix Object</p></a></li>
<li><a href='#BregFix'><p>Artificial Example for Binomial Regression</p></a></li>
<li><a href='#candy'><p>Candy Packs Purchased</p></a></li>
<li><a href='#dmft'><p>Dental Data</p></a></li>
<li><a href='#EIC'><p>Entropic Measure Information Criterion</p></a></li>
<li><a href='#ExLinear'><p>Artificial Data from a Generalized Linear Regression Mixture</p></a></li>
<li><a href='#ExNclus'><p>Artificial Example with 4 Gaussians</p></a></li>
<li><a href='#ExNPreg'><p>Artificial Example for Normal, Poisson and Binomial Regression</p></a></li>
<li><a href='#fabricfault'><p>Fabric Faults</p></a></li>
<li><a href='#fitted-methods'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#flexmix'><p>Flexible Mixture Modeling</p></a></li>
<li><a href='#flexmix-class'><p>Class &quot;flexmix&quot;</p></a></li>
<li><a href='#flexmix-internal'><p>Internal FlexMix Functions</p></a></li>
<li><a href='#FLXcomponent-class'><p>Class &quot;FLXcomponent&quot;</p></a></li>
<li><a href='#FLXcontrol-class'><p>Class &quot;FLXcontrol&quot;</p></a></li>
<li><a href='#FLXdist'><p>Finite Mixtures of Distributions</p></a></li>
<li><a href='#FLXdist-class'><p>Class &quot;FLXdist&quot;</p></a></li>
<li><a href='#FLXfit'><p>Fitter Function for FlexMix Models</p></a></li>
<li><a href='#flxglht'>
<p>Simultaneous Inference in Finite Mixtures of Regression Models</p></a></li>
<li><a href='#FLXM-class'><p>Class &quot;FLXM&quot;</p></a></li>
<li><a href='#FLXMCdist1'><p>FlexMix Clustering of Univariate Distributions</p></a></li>
<li><a href='#FLXMCfactanal'><p>Driver for Mixtures of Factor Analyzers</p></a></li>
<li><a href='#FLXMCmvbinary'><p>FlexMix Binary Clustering Driver</p></a></li>
<li><a href='#FLXMCmvcombi'><p>FlexMix Binary and Gaussian Clustering Driver</p></a></li>
<li><a href='#FLXMCmvnorm'><p>FlexMix Clustering Demo Driver</p></a></li>
<li><a href='#FLXMCmvpois'><p>FlexMix Poisson Clustering Driver</p></a></li>
<li><a href='#FLXMRcondlogit'><p>FlexMix Interface to Conditional Logit Models</p></a></li>
<li><a href='#FLXMRglm'><p>FlexMix Interface to Generalized Linear Models</p></a></li>
<li><a href='#FLXMRglmfix'><p>FlexMix Interface to GLMs with Fixed Coefficients</p></a></li>
<li><a href='#FLXMRglmnet'><p>FlexMix Interface for Adaptive Lasso / Elastic Net with GLMs</p></a></li>
<li><a href='#FLXMRlmer'><p>FlexMix Interface to Linear Mixed Models</p></a></li>
<li><a href='#FLXMRlmmc'><p>FlexMix Interface to Linear Mixed Models with Left-Censoring</p></a></li>
<li><a href='#FLXMRmgcv'><p>FlexMix Interface to GAMs</p></a></li>
<li><a href='#FLXMRmultinom'><p>FlexMix Interface to Multiomial Logit Models</p></a></li>
<li><a href='#FLXMRrobglm'><p>FlexMix Driver for Robust Estimation of Generalized Linear Models</p></a></li>
<li><a href='#FLXMRziglm'><p>FlexMix Interface to Zero Inflated Generalized Linear Models</p></a></li>
<li><a href='#FLXnested-class'><p>Class &quot;FLXnested&quot;</p></a></li>
<li><a href='#FLXP'><p>Creates the Concomitant Variable Model</p></a></li>
<li><a href='#FLXP-class'><p>Class &quot;FLXP&quot;</p></a></li>
<li><a href='#group'><p>Extract Grouping Variable</p></a></li>
<li><a href='#ICL'><p>Integrated Completed Likelihood Criterion</p></a></li>
<li><a href='#KLdiv'><p>Kullback-Leibler Divergence</p></a></li>
<li><a href='#Lapply-methods'><p>Methods for Function Lapply</p></a></li>
<li><a href='#logLik-methods'><p>Methods for Function logLik in Package <span class="pkg">flexmix</span></p></a></li>
<li><a href='#Mehta'><p>Mehta Trial</p></a></li>
<li><a href='#NregFix'><p>Artificial Example for Normal Regression</p></a></li>
<li><a href='#patent'><p>Patents and R&amp;D Spending</p></a></li>
<li><a href='#plot-methods'><p>Rootogram of Posterior Probabilities</p></a></li>
<li><a href='#plotEll'><p>Plot Confidence Ellipses for FLXMCmvnorm Results</p></a></li>
<li><a href='#posterior'><p>Determine Cluster Membership and Posterior Probabilities</p></a></li>
<li><a href='#refit-methods'><p>Refit a Fitted Model</p></a></li>
<li><a href='#relabel'><p>Relabel the Components</p></a></li>
<li><a href='#rflexmix'><p>Random Number Generator for Finite Mixtures</p></a></li>
<li><a href='#salmonellaTA98'><p>Salmonella Reverse Mutagenicity Assay</p></a></li>
<li><a href='#seizure'><p>Epileptic Seizure Data</p></a></li>
<li><a href='#stepFlexmix'><p>Run FlexMix Repeatedly</p></a></li>
<li><a href='#tribolium'><p>Tribolium Beetles</p></a></li>
<li><a href='#trypanosome'><p>Trypanosome</p></a></li>
<li><a href='#whiskey'><p>Survey Data on Brands of Scotch Whiskey Consumed</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible Mixture Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3-20</td>
</tr>
<tr>
<td>Description:</td>
<td>A general framework for finite mixtures of regression
  models using the EM algorithm is implemented. The E-step and all
  data handling are provided, while the M-step can be supplied by the
  user to easily define new models. Existing drivers implement
  mixtures of standard linear models, generalized linear models and
  model-based clustering.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grid, grDevices, methods, modeltools (&ge; 0.2-16),
nnet, stats, stats4, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>actuar, codetools, diptest, Ecdat, ellipse, gclus, glmnet,
lme4 (&ge; 1.1), MASS, mgcv (&ge; 1.8-0), mlbench, multcomp,
mvtnorm, SuppDists, survival</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-26 14:53:48 UTC; gruen</td>
</tr>
<tr>
<td>Author:</td>
<td>Bettina Gruen <a href="https://orcid.org/0000-0001-7265-4773"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Friedrich Leisch <a href="https://orcid.org/0000-0001-7278-1983"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Deepayan Sarkar <a href="https://orcid.org/0000-0003-4107-1553"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Frederic Mortier [ctb],
  Nicolas Picard <a href="https://orcid.org/0000-0001-5548-9171"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bettina Gruen &lt;Bettina.Gruen@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-28 06:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC-methods'>Methods for Function AIC</h2><span id='topic+AIC+2Cflexmix-method'></span><span id='topic+AIC+2CstepFlexmix-method'></span>

<h3>Description</h3>

<p>Compute the Akaike Information Criterion.</p>


<h3>Methods</h3>


<dl>
<dt>object = flexmix:</dt><dd><p>Compute the AIC of a <code>flexmix</code> object</p>
</dd>
<dt>object = stepFlexmix:</dt><dd><p>Compute the AIC of all
models contained in the <code>stepFlexmix</code> object.</p>
</dd>
</dl>


<hr>
<h2 id='betablocker'>Clinical Trial of Beta-Blockers</h2><span id='topic+betablocker'></span>

<h3>Description</h3>

<p>22-centre clinical trial of beta-blockers for reducing mortality after
myocardial infarction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("betablocker")</code></pre>


<h3>Format</h3>

<p>A data frame with 44 observations on the following 4 variables.
</p>

<dl>
<dt>Deaths</dt><dd><p>Number of deaths.</p>
</dd>
<dt>Total</dt><dd><p>Total number of patients.</p>
</dd>
<dt>Center</dt><dd><p>Number of clinical centre.</p>
</dd>
<dt>Treatment</dt><dd><p>A factor with levels <code>Control</code> and <code>Treated</code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>G. McLachlan and D. Peel. <em>Finite Mixture Models</em>, 2000.
John Wiley and Sons Inc.
<a href="http://www.maths.uq.edu.au/~gjm/DATA/mmdata.html">http://www.maths.uq.edu.au/~gjm/DATA/mmdata.html</a>
</p>


<h3>References</h3>

<p>M. Aitkin. Meta-analysis by random effect modelling in
generalized linear models.
<em>Statistics in Medicine</em>, <b>18</b>, 2343&ndash;2351, 1999.
</p>
<p>S. Yusuf, R. Peto, J. Lewis, R. Collins and P. Sleight. Beta
blockade during and after myocardial infarction: an overview of the
randomized trials.
<em>Progress in Cardiovascular Diseases</em>, <b>27</b>, 335&ndash;371,
1985. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("betablocker", package = "flexmix")
betaMix &lt;- initFlexmix(cbind(Deaths, Total - Deaths) ~ 1 | Center,
                       data = betablocker, k = 3, nrep = 5,
                       model = FLXMRglmfix(family = "binomial",
                         fixed = ~Treatment)) 
</code></pre>

<hr>
<h2 id='BIC-methods'>Methods for Function BIC</h2><span id='topic+BIC+2Cflexmix-method'></span><span id='topic+BIC+2CstepFlexmix-method'></span>

<h3>Description</h3>

<p>Compute the Bayesian Information Criterion.</p>


<h3>Methods</h3>


<dl>
<dt>object = flexmix:</dt><dd><p>Compute the BIC of a <code>flexmix</code> object</p>
</dd>
<dt>object = stepFlexmix:</dt><dd><p>Compute the BIC of all
models contained in the <code>stepFlexmix</code> object.</p>
</dd>
</dl>


<hr>
<h2 id='bioChemists'>Articles by Graduate Students in Biochemistry Ph.D. Programs</h2><span id='topic+bioChemists'></span>

<h3>Description</h3>

<p>A sample of 915 biochemistry graduate students.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("bioChemists")
</code></pre>


<h3>Format</h3>


<dl>
<dt>art</dt><dd><p>count of articles produced during last 3 years of Ph.D.</p>
</dd>
<dt>fem</dt><dd><p>factor indicating gender of student, with levels Men and Women</p>
</dd>
<dt>mar</dt><dd><p>factor indicating marital status of student, with levels
Single and Married</p>
</dd>
<dt>kid5</dt><dd><p>number of children aged 5 or younger</p>
</dd>
<dt>phd</dt><dd><p>prestige of Ph.D. department</p>
</dd>
<dt>ment</dt><dd><p>count of articles produced by Ph.D. mentor during last 3 years</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set is taken from package <span class="pkg">pscl</span> provided by Simon
Jackman.
</p>


<h3>Source</h3>

<p>found in Stata format at
<a href="https://jslsoc.sitehost.iu.edu/stata/spex_data/couart2.dta">https://jslsoc.sitehost.iu.edu/stata/spex_data/couart2.dta</a>
</p>


<h3>References</h3>

<p>Long, J. Scott. The origins of sex difference in
science. <em>Social Forces</em>, <b>68</b>, 1297&ndash;1315, 1990.
</p>
<p>Long, J. Scott.  <em>Regression Models for Categorical and
Limited Dependent Variables</em>, 1997. Thousand Oaks, California:
Sage. 
</p>

<hr>
<h2 id='boot'>Bootstrap a flexmix Object</h2><span id='topic+boot'></span><span id='topic+boot+2Cflexmix-method'></span><span id='topic+LR_test'></span><span id='topic+LR_test+2Cflexmix-method'></span><span id='topic+show+2CFLXboot-method'></span><span id='topic+FLXboot-class'></span><span id='topic+plot+2CFLXboot+2Cmissing-method'></span><span id='topic+parameters+2CFLXboot-method'></span><span id='topic+clusters+2CFLXboot+2ClistOrdata.frame-method'></span><span id='topic+predict+2CFLXboot-method'></span><span id='topic+posterior+2CFLXboot+2ClistOrdata.frame-method'></span>

<h3>Description</h3>

<p>Given a <code>flexmix</code> object perform parametric or empirical bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot(object, ...)
## S4 method for signature 'flexmix'
boot(object, R, sim = c("ordinary", "empirical", "parametric"),
    initialize_solution = FALSE, keep_weights = FALSE,
    keep_groups = TRUE, verbose = 0, control,
    k, model = FALSE, ...)
LR_test(object, ...)
## S4 method for signature 'flexmix'
LR_test(object, R, alternative = c("greater", "less"), control, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot_+3A_object">object</code></td>
<td>
<p>A fitted finite mixture model of class <code>flexmix</code>.</p>
</td></tr> 
<tr><td><code id="boot_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="boot_+3A_sim">sim</code></td>
<td>
<p>A character string indicating the type of simulation
required.  Possible values are <code>"ordinary"</code> (the default),
<code>"parametric"</code>, or <code>"empirical"</code>.</p>
</td></tr>
<tr><td><code id="boot_+3A_initialize_solution">initialize_solution</code></td>
<td>
<p>A logical. If <code>TRUE</code> the EM algorithm is
initialized in the given solution.</p>
</td></tr>
<tr><td><code id="boot_+3A_keep_weights">keep_weights</code></td>
<td>
<p>A logical. If <code>TRUE</code> the weights are kept.</p>
</td></tr>
<tr><td><code id="boot_+3A_keep_groups">keep_groups</code></td>
<td>
<p>A logical. If <code>TRUE</code> the groups are kept.</p>
</td></tr>
<tr><td><code id="boot_+3A_verbose">verbose</code></td>
<td>
<p>If a positive integer, then progress information
is reported every <code>verbose</code> iterations. If 0,
no output is generated during the bootstrap replications.</p>
</td></tr>
<tr><td><code id="boot_+3A_control">control</code></td>
<td>
<p>Object of class <code>FLXcontrol</code> or a named list.
If missing the control of the fitted <code>object</code> is taken.</p>
</td></tr>
<tr><td><code id="boot_+3A_k">k</code></td>
<td>
<p>Vector of integers specifying for which number of components
finite mixtures are fitted to the bootstrap samples.  If missing the
number of components of the fitted <code>object</code> are taken.</p>
</td></tr>
<tr><td><code id="boot_+3A_alternative">alternative</code></td>
<td>
<p>A character string specifying the alternative
hypothesis, must be either <code>"greater"</code> (default) or
<code>"less"</code> indicating if the alternative hypothesis is that the
mixture has one more component or one less.</p>
</td></tr>
<tr><td><code id="boot_+3A_model">model</code></td>
<td>
<p>A logical. If <code>TRUE</code> the model and the weights slot for
each sample are stored and returned.</p>
</td></tr>
<tr><td><code id="boot_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>boot</code> returns an object of class <code>FLXboot</code> which
contains the fitted parameters, the fitted priors, the log
likelihoods, the number of components of the fitted mixtures and the
information if the EM algorithm has converged.
</p>
<p><code>LR_test</code> returns an object of class <code>htest</code> containing the
number of valid bootstrap replicates, the p-value, the - twice log
likelihood ratio test statistics for the original data and the
bootstrap replicates.
</p>


<h3>Author(s)</h3>

<p>Bettina Gruen</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NPreg", package = "flexmix")
fitted &lt;- initFlexmix(yn ~ x + I(x^2) | id2, data = NPreg, k = 2)
## Not run: 
lrtest &lt;- LR_test(fitted, alternative = "greater", R = 20,
                  verbose = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='BregFix'>Artificial Example for Binomial Regression</h2><span id='topic+BregFix'></span>

<h3>Description</h3>

<p>A simple artificial regression example data set with 3 latent
classes, one independent variable <code>x</code> and a concomitant
variable <code>w</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BregFix")</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 5 variables.
</p>

<dl>
<dt><code>yes</code></dt><dd><p>number of successes</p>
</dd>
<dt><code>no</code></dt><dd><p>number of failures</p>
</dd>
<dt><code>x</code></dt><dd><p>independent variable</p>
</dd>
<dt><code>w</code></dt><dd><p>concomitant variable, a factor with levels <code>0</code> <code>1</code></p>
</dd>
<dt><code>class</code></dt><dd><p>latent class memberships</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("BregFix", package = "flexmix")
Model &lt;- FLXMRglmfix(family="binomial",
                     nested = list(formula = c(~x, ~0), k = c(2, 1)))
Conc &lt;- FLXPmultinom(~w)
FittedBin &lt;- initFlexmix(cbind(yes, no) ~ 1, data = BregFix,
                         k = 3, model = Model, concomitant = Conc)
summary(FittedBin)
</code></pre>

<hr>
<h2 id='candy'>Candy Packs Purchased</h2><span id='topic+candy'></span>

<h3>Description</h3>

<p>The data is from a new product and concept test where the number of
individual packs of hard candy purchased within the past 7 days is recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("candy")</code></pre>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 2 variables.
</p>

<dl>
<dt><code>Packages</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>D. Boehning, E. Dietz and P. Schlattmann. Recent Developments in
Computer-Assisted Analysis of Mixtures. Biometrics 54(2), 525&ndash;536,
1998.
</p>


<h3>References</h3>

  
<p>J. Magidson and J. K. Vermunt. Latent Class Models. In
D. W. Kaplan (ed.), The Sage Handbook of Quantitative Methodology for
the Social Sciences, 175&ndash;198, 2004. Thousand Oakes: Sage Publications.
</p>
<p>D. Boehning, E. Dietz and P. Schlattmann. Recent Developments in
Computer-Assisted Analysis of Mixtures. <em>Biometrics</em>,
<b>54</b>(2), 525&ndash;536, 1998.
</p>
<p>W. R. Dillon and A. Kumar. Latent structure and other mixture
models in marketing: An integrative survey and overview. In
R. P. Bagozzi (ed.), Advanced methods of marketing research,
352&ndash;388, 1994. Cambridge, UK: Blackwell.
</p>

<hr>
<h2 id='dmft'>Dental Data</h2><span id='topic+dmft'></span>

<h3>Description</h3>

<p>Count data from a dental epidemiological study for evaluation of
various programs for reducing caries collected among school
children from an urban area of Belo Horizonte (Brazil).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dmft")</code></pre>


<h3>Format</h3>

<p>A data frame with 797 observations on the following 5 variables.
</p>

<dl>
<dt>End</dt><dd><p>Number of decayed, missing or filled teeth at the end of the study.</p>
</dd>
<dt>Begin</dt><dd><p>Number of decayed, missing or filled teeth at the beginning of the study.</p>
</dd>
<dt>Gender</dt><dd><p>A factor with levels <code>male</code> and <code>female</code>.</p>
</dd>
<dt>Ethnic</dt><dd><p>A factor with levels <code>brown</code>, <code>white</code> and <code>black</code>.</p>
</dd>
<dt>Treatment</dt><dd><p>A factor with levels <code>control</code>, <code>educ</code>, <code>enrich</code>, 
<code>rinse</code>, <code>hygiene</code> and <code>all</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The aim of the caries prevention study was to compare four methods
to prevent dental caries. Interventions were carried out according
to the following scheme: 
</p>

<dl>
<dt>control</dt><dd><p>Control group</p>
</dd>
<dt>educ</dt><dd><p>Oral health education</p>
</dd>
<dt>enrich</dt><dd><p>Enrichment of the school diet with rice bran</p>
</dd>
<dt>rinse</dt><dd><p>Mouthwash with 0.2% sodium floride (NaF) solution</p>
</dd>
<dt>hygiene</dt><dd><p>Oral hygiene</p>
</dd>
<dt>all</dt><dd><p>All four methods together</p>
</dd>
</dl>



<h3>Source</h3>

<p>D. Boehning, E. Dietz, P. Schlattmann, L. Mendonca and U. Kirchner.
The zero-inflated Poisson model and the decayed, missing and
filled teeth index in dental epidemiology. <em>Journal of the Royal
Statistical Society A</em>, <b>162</b>(2), 195&ndash;209, 1999.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dmft", package = "flexmix")
dmft_flx &lt;- initFlexmix(End ~ 1, data = dmft, k = 2,
                        model = FLXMRglmfix(family = "poisson", 
                        fixed = ~ Gender + Ethnic + Treatment))
</code></pre>

<hr>
<h2 id='EIC'>Entropic Measure Information Criterion</h2><span id='topic+EIC'></span><span id='topic+EIC+2Cflexmix-method'></span><span id='topic+EIC+2CstepFlexmix-method'></span>

<h3>Description</h3>

<p>Compute the entropic measure information criterion for model selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'flexmix'
EIC(object, ...)
## S4 method for signature 'stepFlexmix'
EIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EIC_+3A_object">object</code></td>
<td>
<p>See Methods section below</p>
</td></tr>
<tr><td><code id="EIC_+3A_...">...</code></td>
<td>
<p>Some methods for this generic function may take additional,
optional arguments. At present none do.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector with the corresponding EIC value(s). 
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;flexmix&quot;:</dt><dd><p>Compute the EIC of a <code>flexmix</code> object.</p>
</dd>
<dt>object = &quot;stepFlexmix&quot;:</dt><dd><p>Compute the EIC of all
models contained in the <code>stepFlexmix</code> object.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Bettina Gruen</p>


<h3>References</h3>

<p>V. Ramaswamy, W. S. DeSarbo, D. J. Reibstein, and W. T. Robinson. An
empirical pooling approach for estimating marketing mix elasticities
with PIMS data. <em>Marketing Science</em>, <b>12</b>(1), 103&ndash;124, 1993.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NPreg", package = "flexmix")
ex1 &lt;- flexmix(yn ~ x + I(x^2), data = NPreg, k = 2)
EIC(ex1)
</code></pre>

<hr>
<h2 id='ExLinear'>Artificial Data from a Generalized Linear Regression Mixture</h2><span id='topic+ExLinear'></span>

<h3>Description</h3>

<p>Generate random data mixed from k generalized linear regressions (GLMs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExLinear(beta, n, xdist = "runif", xdist.args = NULL,
         family = c("gaussian","poisson"), sd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExLinear_+3A_beta">beta</code></td>
<td>
<p>A matrix of regression coefficients. Each row corresponds
to a variable, each column to a mixture component. The first row is
used as intercept.</p>
</td></tr>
<tr><td><code id="ExLinear_+3A_n">n</code></td>
<td>
<p>Integer, the number of observations per component.</p>
</td></tr>
<tr><td><code id="ExLinear_+3A_xdist">xdist</code></td>
<td>
<p>Character, name of a random number function for the
explanatory variables.</p>
</td></tr>
<tr><td><code id="ExLinear_+3A_xdist.args">xdist.args</code></td>
<td>
<p>List, arguments for the random number functions.</p>
</td></tr>
<tr><td><code id="ExLinear_+3A_family">family</code></td>
<td>
<p>A character string naming a GLM
family.Only <code>"gaussian"</code> and <code>"poisson"</code> are implemented
at the moment.</p>
</td></tr>
<tr><td><code id="ExLinear_+3A_sd">sd</code></td>
<td>
<p>Numeric, the error standard deviation for each component for
Gaussian responses.</p>
</td></tr>
<tr><td><code id="ExLinear_+3A_...">...</code></td>
<td>
<p>Used as default for <code>xdist.args</code> if that is not
specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, arguments <code>n</code> (and <code>sd</code> for Gaussian response) are
recycled to the number of mixture components <code>ncol(beta)</code>, and
arguments <code>xdist</code> and <code>xdist.args</code> are recycled to the
number of explanatory variables <code>nrow(beta)-1</code>. Then a design
matrix is created for each mixture component by drawing random numbers
from <code>xdist</code>. For each component, the design matrix is multiplied
by the regression coefficients to form the linear predictor. For
Gaussian responses the identity link is used, for Poisson responses
the log link.
</p>
<p>The true cluster memberships are returned as attribute <code>"clusters"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple example in 2d
beta &lt;- matrix(c(1, 2, 3, -1), ncol = 2)
sigma &lt;- c(.5, 1)
df1 &lt;- ExLinear(beta, 100, sd = sigma, min = -1, max = 2)
plot(y~x1, df1, col = attr(df1, "clusters"))

## add a second explanatory variable with exponential distribution
beta2 &lt;- rbind(beta, c(-2, 2))
df2 &lt;-  ExLinear(beta2, 100, sd = c(.5, 1),
                 xdist = c("runif", "rexp"),
                 xdist.args = list(list(min = -1, max = 2),
                                   list(rate = 3)))

summary(df2)

opar = par("mfrow")
par(mfrow = 1:2)
hist(df2$x1)
hist(df2$x2)
par(opar)

f1 &lt;- flexmix(y ~ ., data = df2, k = 2)

## sort components on Intercept
f1 &lt;- relabel(f1, "model", "Intercept")

## the parameters should be close to the true beta and sigma
round(parameters(f1), 3)
rbind(beta2, sigma)

### A simple Poisson GLM
df3 &lt;- ExLinear(beta/2, 100, min = -1, max = 2, family = "poisson")
plot(y ~ x1, df3, col = attr(df3, "clusters"))

f3 &lt;- flexmix(y ~ ., data = df3, k = 2,
              model = FLXMRglm(family = "poisson"))
round(parameters(relabel(f3, "model", "Intercept")), 3)
beta/2
</code></pre>

<hr>
<h2 id='ExNclus'>Artificial Example with 4 Gaussians</h2><span id='topic+ExNclus'></span><span id='topic+Nclus'></span>

<h3>Description</h3>

<p>A simple artificial example for normal clustering with 4 latent
classes, all of
them having a Gaussian distribution. See the function definition for
true means and covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExNclus(n)
data("Nclus")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExNclus_+3A_n">n</code></td>
<td>
<p>Number of observations in the two small latent classes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Nclus</code> data set can be re-created by <code>ExNclus(100)</code>
using <code>set.seed(2602)</code>, it has been saved as a data set for
simplicity of examples only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Nclus", package = "flexmix")
require("MASS")
eqscplot(Nclus, col = rep(1:4, c(100, 100, 150, 200)))
</code></pre>

<hr>
<h2 id='ExNPreg'>Artificial Example for Normal, Poisson and Binomial Regression</h2><span id='topic+ExNPreg'></span><span id='topic+NPreg'></span>

<h3>Description</h3>

<p>A simple artificial regression example with 2 latent classes, one
independent variable
(uniform on <code class="reqn">[0,10]</code>), and three dependent variables with
Gaussian, Poisson and Binomial distribution, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExNPreg(n)
data("NPreg")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExNPreg_+3A_n">n</code></td>
<td>
<p>Number of observations per latent class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>NPreg</code> data frame can be re-created by <code>ExNPreg(100)</code>
using <code>set.seed(2602)</code>, it has been saved as a data set for
simplicity of examples only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NPreg", package = "flexmix")
plot(yn ~ x, data = NPreg, col = class)
plot(yp ~ x, data = NPreg, col = class)
plot(yb ~ x, data = NPreg, col = class)
</code></pre>

<hr>
<h2 id='fabricfault'>Fabric Faults</h2><span id='topic+fabricfault'></span>

<h3>Description</h3>

<p>Number of faults in rolls of a textile fabric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fabricfault")</code></pre>


<h3>Format</h3>

<p>A data frame with 32 observations on the following 2 variables.
</p>

<dl>
<dt>Length</dt><dd><p>Length of role (m).</p>
</dd>
<dt>Faults</dt><dd><p>Number of faults.</p>
</dd>
</dl>



<h3>Source</h3>

<p>G. McLachlan and D. Peel. <em>Finite Mixture Models</em>, 2000,
John Wiley and Sons Inc.
<a href="http://www.maths.uq.edu.au/~gjm/DATA/mmdata.html">http://www.maths.uq.edu.au/~gjm/DATA/mmdata.html</a>
</p>


<h3>References</h3>

<p>A. F. Bissell.
A Negative Binomial Model with Varying Element Sizes
<em>Biometrika</em>, <b>59</b>, 435&ndash;441, 1972.
</p>
<p>M. Aitkin. A general maximum likelihood analysis of
overdispersion in generalized linear models.
<em>Statistics and Computing</em>, <b>6</b>, 251&ndash;262, 1996. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("fabricfault", package = "flexmix")
fabricMix &lt;- initFlexmix(Faults ~ 1, data = fabricfault, k = 2,
                         model = FLXMRglmfix(family = "poisson",
                           fixed = ~ log(Length)), 
                         nrep = 5)
</code></pre>

<hr>
<h2 id='fitted-methods'>Extract Model Fitted Values</h2><span id='topic+fitted+2Cflexmix-method'></span><span id='topic+fitted+2CFLXM-method'></span><span id='topic+fitted+2CFLXR-method'></span><span id='topic+fitted+2CFLXRMRglm-method'></span>

<h3>Description</h3>

<p>Extract fitted values for each component from a flexmix object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'flexmix'
fitted(object, drop = TRUE, aggregate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code>"flexmix"</code> or
<code>"FLXR"</code></p>
</td></tr>
<tr><td><code id="fitted-methods_+3A_drop">drop</code></td>
<td>
<p>logical, if <code>TRUE</code> then the function tries to
simplify the return object by combining lists of length 1 into
matrices.</p>
</td></tr>
<tr><td><code id="fitted-methods_+3A_aggregate">aggregate</code></td>
<td>
<p>logical, if <code>TRUE</code> then the fitted values for
each model aggregated over the components are returned.</p>
</td></tr>
<tr><td><code id="fitted-methods_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NPreg", package = "flexmix")
ex1 &lt;- flexmix(yn ~ x + I(x^2), data = NPreg, k = 2)
matplot(NPreg$x, fitted(ex1), pch = 16, type = "p")
points(NPreg$x, NPreg$yn)
</code></pre>

<hr>
<h2 id='flexmix'>Flexible Mixture Modeling</h2><span id='topic+flexmix'></span><span id='topic+flexmix+2Cformula+2CANY+2CANY+2CANY+2Cmissing-method'></span><span id='topic+flexmix+2Cformula+2CANY+2CANY+2CANY+2Clist-method'></span><span id='topic+flexmix+2Cformula+2CANY+2CANY+2CANY+2CFLXM-method'></span><span id='topic+prior+2Cflexmix-method'></span><span id='topic+show+2Cflexmix-method'></span><span id='topic+summary+2Cflexmix-method'></span><span id='topic+show+2Csummary.flexmix-method'></span>

<h3>Description</h3>

<p>FlexMix implements a general framework for finite
mixtures of regression models. Parameter estimation is performed using
the EM algorithm: the E-step is implemented by <code>flexmix</code>, while
the user can specify the M-step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexmix(formula, data = list(), k = NULL, cluster = NULL, 
        model = NULL, concomitant = NULL, control = NULL,
        weights = NULL)
## S4 method for signature 'flexmix'
summary(object, eps = 1e-4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flexmix_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fit. The
general form is <code>y~x|g</code> where <code>y</code> is the response,
<code>x</code> the set of predictors and <code>g</code> an optional grouping
factor for repeated measurements.</p>
</td></tr>
<tr><td><code id="flexmix_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="flexmix_+3A_k">k</code></td>
<td>
<p>Number of clusters (not needed if <code>cluster</code> is specified).</p>
</td></tr>
<tr><td><code id="flexmix_+3A_cluster">cluster</code></td>
<td>
<p>Either a matrix with <code>k</code> columns of initial
cluster membership probabilities for each observation; or a factor
or integer vector with the initial cluster
assignments of observations at the start of the EM
algorithm. Default is random assignment into <code>k</code>
clusters.</p>
</td></tr>
<tr><td><code id="flexmix_+3A_weights">weights</code></td>
<td>
<p>An optional vector of replication weights to be used in
the fitting process.  Should be <code>NULL</code>, an integer vector or a
formula.</p>
</td></tr>
<tr><td><code id="flexmix_+3A_model">model</code></td>
<td>
<p>Object of class <code>FLXM</code> or list of <code>FLXM</code>
objects. Default is the object returned by calling
<code><a href="#topic+FLXMRglm">FLXMRglm</a>()</code>.</p>
</td></tr>
<tr><td><code id="flexmix_+3A_concomitant">concomitant</code></td>
<td>
<p>Object of class <code>FLXP</code>. Default is the
object returned by calling <code><a href="#topic+FLXPconstant">FLXPconstant</a></code>.</p>
</td></tr>
<tr><td><code id="flexmix_+3A_control">control</code></td>
<td>
<p>Object of class <code>FLXcontrol</code> or a named list.</p>
</td></tr>
<tr><td><code id="flexmix_+3A_object">object</code></td>
<td>
<p>Object of class <code>flexmix</code>.</p>
</td></tr>
<tr><td><code id="flexmix_+3A_eps">eps</code></td>
<td>
<p>Probabilities below this threshold are treated as zero in the
summary method.</p>
</td></tr>
<tr><td><code id="flexmix_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FlexMix models are described by objects of class <code>FLXM</code>,
which in turn are created by driver functions like
<code><a href="#topic+FLXMRglm">FLXMRglm</a></code> or <code><a href="#topic+FLXMCmvnorm">FLXMCmvnorm</a></code>. Multivariate
responses with independent components can be specified using a
list of <code>FLXM</code> objects.
</p>
<p>The <code>summary</code> method lists for each component the prior
probability, the number of observations assigned to the corresponding
cluster, the number of observations with a posterior probability
larger than <code>eps</code> and the ratio of the latter two numbers (which
indicates how separated the cluster is from the others).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>flexmix</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>Friedrich Leisch. FlexMix: A general framework for finite mixture
models and latent class regression in R. <em>Journal of Statistical
Software</em>, <b>11</b>(8), 2004. doi:10.18637/jss.v011.i08
</p>
<p>Bettina Gruen and Friedrich Leisch. Fitting finite mixtures of
generalized linear regressions in R. Computational Statistics &amp; Data
Analysis, 51(11), 5247-5252, 2007. doi:10.1016/j.csda.2006.08.014
</p>
<p>Bettina Gruen and Friedrich Leisch. FlexMix Version 2: Finite
mixtures with concomitant variables and varying and constant
parameters Journal of Statistical Software, 28(4), 1-35, 2008.
doi:10.18637/jss.v028.i04
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot-methods">plot-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("NPreg", package = "flexmix")

## mixture of two linear regression models. Note that control parameters
## can be specified as named list and abbreviated if unique.
ex1 &lt;- flexmix(yn ~ x + I(x^2), data = NPreg, k = 2,
               control = list(verb = 5, iter = 100))

ex1
summary(ex1)
plot(ex1)

## now we fit a model with one Gaussian response and one Poisson
## response. Note that the formulas inside the call to FLXMRglm are
## relative to the overall model formula.
ex2 &lt;- flexmix(yn ~ x, data = NPreg, k = 2,
               model = list(FLXMRglm(yn ~ . + I(x^2)), 
                            FLXMRglm(yp ~ ., family = "poisson")))
plot(ex2)

ex2
table(ex2@cluster, NPreg$class)

## for Gaussian responses we get coefficients and standard deviation
parameters(ex2, component = 1, model = 1)

## for Poisson response we get only coefficients
parameters(ex2, component = 1, model = 2)

## fitting a model only to the Poisson response is of course
## done like this
ex3 &lt;- flexmix(yp ~ x, data = NPreg, k = 2,
               model = FLXMRglm(family = "poisson"))

## if observations are grouped, i.e., we have several observations per
## individual, fitting is usually much faster:
ex4 &lt;- flexmix(yp~x|id1, data = NPreg, k = 2,
               model = FLXMRglm(family = "poisson"))

## And now a binomial example. Mixtures of binomials are not generically
## identified, here the grouping variable is necessary:
set.seed(1234)
ex5 &lt;- initFlexmix(cbind(yb,1 - yb) ~ x, data = NPreg, k = 2,
                   model = FLXMRglm(family = "binomial"), nrep = 5)
table(NPreg$class, clusters(ex5))

ex6 &lt;- initFlexmix(cbind(yb, 1 - yb) ~ x | id2, data = NPreg, k = 2,
                   model = FLXMRglm(family = "binomial"), nrep = 5)
table(NPreg$class, clusters(ex6))

</code></pre>

<hr>
<h2 id='flexmix-class'>Class &quot;flexmix&quot;</h2><span id='topic+flexmix-class'></span>

<h3>Description</h3>

<p>A fitted <code><a href="#topic+flexmix">flexmix</a></code> model.</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p>List of <code>FLXM</code> objects.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Numeric vector with prior probabilities of clusters.</p>
</dd>
<dt><code>posterior</code>:</dt><dd><p>Named list with elements <code>scaled</code>
and <code>unscaled</code>, both matrices with one row per observation
and one column per cluster.</p>
</dd>
<dt><code>iter</code>:</dt><dd><p>Number of EM iterations.</p>
</dd>
<dt><code>k</code>:</dt><dd><p>Number of clusters after EM.</p>
</dd>
<dt><code>k0</code>:</dt><dd><p>Number of clusters at start of EM.</p>
</dd>
<dt><code>cluster</code>:</dt><dd><p>Cluster assignments of observations.</p>
</dd>
<dt><code>size</code>:</dt><dd><p>Cluster sizes.</p>
</dd>
<dt><code>logLik</code>:</dt><dd><p>Log-likelihood at EM convergence.</p>
</dd>
<dt><code>df</code>:</dt><dd><p>Total number of
parameters of the model.</p>
</dd>
<dt><code>components</code>:</dt><dd><p>List describing
the fitted components using <code>FLXcomponent</code> objects.</p>
</dd>
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"formula"</code>.</p>
</dd>
<dt><code>control</code>:</dt><dd><p>Object of class <code>"FLXcontrol"</code>.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The function call
used to create the object.</p>
</dd>
<dt><code>group</code>:</dt><dd><p>Object of class <code>"factor"</code>.</p>
</dd>
<dt><code>converged</code>:</dt><dd><p>Logical, <code>TRUE</code> if EM algorithm converged.</p>
</dd>
<dt><code>concomitant</code>:</dt><dd><p>Object of class <code>"FLXP"</code>..</p>
</dd>
<dt><code>weights</code>:</dt><dd><p>Optional weights of the observations.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>FLXdist</code>, directly.
</p>


<h3>Accessor Functions</h3>

<p>The following functions should be used for accessing the corresponding
slots:
</p>

<dl>
<dt><code>cluster</code>:</dt><dd><p>Cluster assignments of observations.</p>
</dd>
<dt><code>posterior</code>:</dt><dd><p>A matrix of posterior probabilities for each
observation.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>

<hr>
<h2 id='flexmix-internal'>Internal FlexMix Functions</h2><span id='topic+FLXgetModelmatrix'></span><span id='topic+FLXcheckComponent'></span><span id='topic+FLXcheckComponent+2CFLXM-method'></span><span id='topic+FLXcheckComponent+2CFLXMRfix-method'></span><span id='topic+FLXdeterminePostunscaled'></span><span id='topic+FLXdeterminePostunscaled+2CFLXM-method'></span><span id='topic+FLXdeterminePostunscaled+2CFLXMRfix-method'></span><span id='topic+FLXdeterminePostunscaled+2CFLXMRlmc-method'></span><span id='topic+FLXdeterminePostunscaled+2CFLXMRlmmc-method'></span><span id='topic+FLXdeterminePostunscaled+2CFLXMRcondlogit-method'></span><span id='topic+FLXgetK'></span><span id='topic+FLXgetK+2CFLXM-method'></span><span id='topic+FLXgetK+2CFLXMRfix-method'></span><span id='topic+FLXgetModelmatrix+2CFLXM-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMCsparse-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMCmvcombi-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMRcondlogit-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMRfix-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMRlmc-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMRlmmc-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMRmgcv-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMRrobglm-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMRziglm-method'></span><span id='topic+FLXgetModelmatrix+2CFLXP-method'></span><span id='topic+FLXgetObs'></span><span id='topic+FLXgetObs+2CFLXM-method'></span><span id='topic+FLXgetObs+2CFLXMRfix-method'></span><span id='topic+FLXgetObs+2CFLXMRlmc-method'></span><span id='topic+FLXmstep'></span><span id='topic+FLXmstep+2CFLXM-method'></span><span id='topic+FLXmstep+2CFLXMCmvcombi-method'></span><span id='topic+FLXmstep+2CFLXMRcondlogit-method'></span><span id='topic+FLXmstep+2CFLXMRfix-method'></span><span id='topic+FLXmstep+2CFLXMRlmc-method'></span><span id='topic+FLXmstep+2CFLXMRlmcfix-method'></span><span id='topic+FLXmstep+2CFLXMRlmmc-method'></span><span id='topic+FLXmstep+2CFLXMRlmmcfix-method'></span><span id='topic+FLXmstep+2CFLXMRmgcv-method'></span><span id='topic+FLXmstep+2CFLXMRrobglm-method'></span><span id='topic+FLXmstep+2CFLXMRziglm-method'></span><span id='topic+FLXremoveComponent'></span><span id='topic+FLXremoveComponent+2CFLXM-method'></span><span id='topic+FLXremoveComponent+2CFLXMRfix-method'></span><span id='topic+FLXremoveComponent+2CFLXMRrobglm-method'></span><span id='topic+FLXremoveComponent+2CFLXMRziglm-method'></span><span id='topic+FLXMRglm-class'></span><span id='topic+FLXR-class'></span><span id='topic+FLXRMRglm-class'></span><span id='topic+FLXRPmultinom-class'></span><span id='topic+summary.flexmix-class'></span><span id='topic+posterior+2CFLXM+2ClistOrdata.frame-method'></span><span id='topic+FLXMRfix-class'></span><span id='topic+FLXMRglmfix-class'></span><span id='topic+FLXRMRglmfix-class'></span><span id='topic+predict+2CFLXMRglmfix-method'></span><span id='topic+fitted+2CFLXMRglmfix-method'></span><span id='topic+summary+2CFLXRMRglmfix-method'></span><span id='topic+listOrdata.frame-class'></span><span id='topic+refit_optim'></span><span id='topic+refit_optim+2CFLXM-method'></span><span id='topic+refit_optim+2CFLXMC-method'></span><span id='topic+refit_optim+2CFLXMRglm-method'></span><span id='topic+refit_optim+2CFLXMRziglm-method'></span><span id='topic+refit_optim+2CFLXP-method'></span><span id='topic+FLXgetDesign'></span><span id='topic+FLXgetDesign+2CFLXM-method'></span><span id='topic+FLXgetDesign+2CFLXMRglmfix-method'></span><span id='topic+FLXgetDesign+2CFLXMRziglm-method'></span><span id='topic+FLXgetParameters'></span><span id='topic+FLXgetParameters+2CFLXdist-method'></span><span id='topic+FLXgetParameters+2CFLXM-method'></span><span id='topic+FLXgetParameters+2CFLXMC-method'></span><span id='topic+FLXgetParameters+2CFLXMRglm-method'></span><span id='topic+FLXgetParameters+2CFLXP-method'></span><span id='topic+FLXgetParameters+2CFLXPmultinom-method'></span><span id='topic+FLXreplaceParameters'></span><span id='topic+FLXreplaceParameters+2CFLXdist-method'></span><span id='topic+FLXreplaceParameters+2CFLXM-method'></span><span id='topic+FLXreplaceParameters+2CFLXMC-method'></span><span id='topic+FLXreplaceParameters+2CFLXMRglm-method'></span><span id='topic+FLXreplaceParameters+2CFLXP-method'></span><span id='topic+FLXreplaceParameters+2CFLXPmultinom-method'></span><span id='topic+FLXlogLikfun'></span><span id='topic+FLXlogLikfun+2Cflexmix-method'></span><span id='topic+FLXgradlogLikfun'></span><span id='topic+FLXgradlogLikfun+2Cflexmix-method'></span><span id='topic+FLXgradlogLikfun+2CFLXM-method'></span><span id='topic+FLXgradlogLikfun+2CFLXMRglm-method'></span><span id='topic+FLXgradlogLikfun+2CFLXP-method'></span><span id='topic+existGradient'></span><span id='topic+existGradient+2CFLXM-method'></span><span id='topic+existGradient+2CFLXMRglm-method'></span><span id='topic+existGradient+2CFLXMRcondlogit-method'></span><span id='topic+existGradient+2CFLXMRglmfix-method'></span><span id='topic+existGradient+2CFLXMRmultinom-method'></span><span id='topic+existGradient+2CFLXP-method'></span>

<h3>Description</h3>

<p>Internal flexmix functions, methods and classes.
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='FLXcomponent-class'>Class &quot;FLXcomponent&quot;</h2><span id='topic+FLXcomponent-class'></span><span id='topic+show+2CFLXcomponent-method'></span>

<h3>Description</h3>

<p>A fitted component of a <code><a href="#topic+flexmix">flexmix</a></code> model.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FLXcomponent", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>df</code>:</dt><dd><p>Number of parameters used by the component.</p>
</dd>
<dt><code>logLik</code>:</dt><dd><p>Function computing the log-likelihood of
observations.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>List with model parameters.</p>
</dd>
<dt><code>predict</code>:</dt><dd><p>Function predicting response for new data.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>

<hr>
<h2 id='FLXcontrol-class'>Class &quot;FLXcontrol&quot;</h2><span id='topic+FLXcontrol-class'></span><span id='topic+coerce+2Clist+2CFLXcontrol-method'></span><span id='topic+coerce+2CNULL+2CFLXcontrol-method'></span>

<h3>Description</h3>

<p>Hyperparameters for the EM algorithm.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FLXcontrol",
    ...)</code>. In addition, named lists can be coerced to <code>FLXcontrol</code>
objects, names are completed if unique (see examples).
</p>


<h3>Slots</h3>


<dl>
<dt><code>iter.max</code>:</dt><dd><p>Maximum number of iterations.</p>
</dd>
<dt><code>minprior</code>:</dt><dd><p>Minimum prior probability of clusters,
components falling below this threshold are removed during the
iteration.</p>
</dd>
<dt><code>tolerance</code>:</dt><dd><p>The EM algorithm is stopped when the
(relative) change of log-likelihood is smaller than <code>tolerance</code>.</p>
</dd>
<dt><code>verbose</code>:</dt><dd><p>If a positive integer, then the
log-likelihood is reported every <code>verbose</code> iterations. If 0,
no output is generated during model fitting.</p>
</dd>
<dt><code>classify</code>:</dt><dd><p>Character string, one of <code>"auto"</code>,
<code>"weighted"</code>, <code>"hard"</code> (or <code>"CEM"</code>),
<code>"random"</code> or (<code>"SEM"</code>).</p>
</dd>
<dt><code>nrep</code>:</dt><dd><p>Reports the number of random initializations
used in <code><a href="#topic+stepFlexmix">stepFlexmix</a>()</code> to determine the mixture.</p>
</dd>
</dl>

<p>Run <code>new("FLXcontrol")</code> to see the default settings of all slots.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>Examples</h3>

<pre><code class='language-R'>## have a look at the defaults
new("FLXcontrol")

## corce a list
mycont &lt;- list(iter = 200, tol = 0.001, class = "r")
as(mycont, "FLXcontrol")
</code></pre>

<hr>
<h2 id='FLXdist'>Finite Mixtures of Distributions</h2><span id='topic+FLXdist'></span><span id='topic+simulate+2CFLXdist-method'></span><span id='topic+show+2CFLXdist-method'></span>

<h3>Description</h3>

<p>Constructs objects of class <code>FLXdist</code> which represent unfitted finite mixture
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> FLXdist(formula, k = NULL, model = FLXMRglm(), components,
         concomitant = FLXPconstant())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXdist_+3A_formula">formula</code></td>
<td>
<p>A symbolic description of the model to be fit. The
general form is <code>~x|g</code> where <code>x</code> is the set of predictors
and <code>g</code> an optional grouping factor for repeated measurements.</p>
</td></tr>
<tr><td><code id="FLXdist_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of cluster or a numeric vector of
length equal to the length of components, specifying the prior
probabilities of clusters.</p>
</td></tr>
<tr><td><code id="FLXdist_+3A_model">model</code></td>
<td>
<p>Object of class <code>FLXM</code> or a list of <code>FLXM</code>
objects. Default is the object returned by calling
<code>FLXMRglm()</code>.</p>
</td></tr>
<tr><td><code id="FLXdist_+3A_components">components</code></td>
<td>
<p>A list of length equal to the number of components
containing a list of length equal to the number of models which
again contains a list of named elements for defining the parameters
of the component-specific model.</p>
</td></tr>
<tr><td><code id="FLXdist_+3A_concomitant">concomitant</code></td>
<td>
<p>Object of class <code>FLXconcomitant</code> specifying
the model for concomitant variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>FLXdist</code>.
</p>


<h3>Author(s)</h3>

<p>Bettina Gruen</p>


<h3>See Also</h3>

<p><code>FLXdist-class</code></p>

<hr>
<h2 id='FLXdist-class'>Class &quot;FLXdist&quot;</h2><span id='topic+FLXdist-class'></span><span id='topic+predict+2CFLXdist-method'></span><span id='topic+predict+2CFLXM-method'></span><span id='topic+predict+2CFLXMRglm-method'></span><span id='topic+predict+2CFLXMRmgcv-method'></span><span id='topic+parameters+2CFLXdist-method'></span><span id='topic+prior'></span><span id='topic+prior+2CFLXdist-method'></span>

<h3>Description</h3>

<p>Objects of class <code>FLXdist</code> represent unfitted finite mixture
models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FLXdist'
parameters(object, component = NULL, model = NULL, which = c("model",
    "concomitant"), simplify = TRUE, drop = TRUE)
## S4 method for signature 'FLXdist'
predict(object, newdata = list(), aggregate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXdist-class_+3A_object">object</code></td>
<td>
<p>An object of class &quot;FLXdist&quot;.</p>
</td></tr>
<tr><td><code id="FLXdist-class_+3A_component">component</code></td>
<td>
<p>Number of component(s), if <code>NULL</code> all components
are returned.</p>
</td></tr>
<tr><td><code id="FLXdist-class_+3A_model">model</code></td>
<td>
<p>Number of model(s), if <code>NULL</code> all models are
returned.</p>
</td></tr>
<tr><td><code id="FLXdist-class_+3A_which">which</code></td>
<td>
<p>Specifies if the parameters of the component specific model or the
concomitant variable model are returned.</p>
</td></tr>
<tr><td><code id="FLXdist-class_+3A_simplify">simplify</code></td>
<td>
<p>Logical, if <code>TRUE</code> the returned values are
simplified to a vector or matrix if possible.</p>
</td></tr>
<tr><td><code id="FLXdist-class_+3A_drop">drop</code></td>
<td>
<p>Logical, if <code>TRUE</code> the function tries to simplify the
return object by omitting lists of length one.</p>
</td></tr>
<tr><td><code id="FLXdist-class_+3A_newdata">newdata</code></td>
<td>
<p>Dataframe containing new data.</p>
</td></tr>
<tr><td><code id="FLXdist-class_+3A_aggregate">aggregate</code></td>
<td>
<p>Logical, if <code>TRUE</code> then the predicted values for
each model aggregated over the components are returned.</p>
</td></tr>
<tr><td><code id="FLXdist-class_+3A_...">...</code></td>
<td>
<p>Passed to the method of the model class.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt>model</dt><dd><p>List of <code>FLXM</code> objects.</p>
</dd>
<dt>prior</dt><dd><p>Numeric vector with prior probabilities of clusters.</p>
</dd>
<dt>components</dt><dd><p>List describing the components using 
<code>FLXcomponent</code> objects.</p>
</dd>
<dt><code>concomitant</code>:</dt><dd><p>Object of class <code>"FLXP"</code>.</p>
</dd>
<dt>formula</dt><dd><p>Object of class <code>"formula"</code>.</p>
</dd>
<dt>call</dt><dd><p>The function call used to create the object.</p>
</dd>
<dt>k</dt><dd><p>Number of clusters.</p>
</dd>
</dl>
  


<h3>Accessor Functions</h3>

<p>The following functions should be used for accessing the corresponding
slots:
</p>

<dl>
<dt><code>parameters</code>:</dt><dd><p>The parameters for each model and component,
return value depends on the model.</p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Numeric vector of prior class probabilities/component weights</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>See Also</h3>

<p><code>FLXdist</code></p>

<hr>
<h2 id='FLXfit'>Fitter Function for FlexMix Models</h2><span id='topic+FLXfit'></span><span id='topic+FLXfit+2Clist-method'></span>

<h3>Description</h3>

<p>This is the basic computing engine called by <code><a href="#topic+flexmix">flexmix</a></code>, it
should usually not be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXfit(model, concomitant, control, postunscaled = NULL, groups,
       weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXfit_+3A_model">model</code></td>
<td>
<p>List of <code>FLXM</code> objects.</p>
</td></tr>
<tr><td><code id="FLXfit_+3A_concomitant">concomitant</code></td>
<td>
<p>Object of class <code>FLXP</code>.</p>
</td></tr>
<tr><td><code id="FLXfit_+3A_control">control</code></td>
<td>
<p>Object of class <code>FLXcontrol</code>.</p>
</td></tr>
<tr><td><code id="FLXfit_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights to be used in the fitting
process.</p>
</td></tr>
<tr><td><code id="FLXfit_+3A_postunscaled">postunscaled</code></td>
<td>
<p>Initial a-posteriori probabilities of the
observations at the start of the EM algorithm.</p>
</td></tr>
<tr><td><code id="FLXfit_+3A_groups">groups</code></td>
<td>
<p>List with components <code>group</code> which is a factor with
optional grouping of observations and <code>groupfirst</code> which is a
logical vector for the first observation of each group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>flexmix</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexmix">flexmix</a></code>, <code><a href="#topic+flexmix-class">flexmix-class</a></code></p>

<hr>
<h2 id='flxglht'>
Simultaneous Inference in Finite Mixtures of Regression Models
</h2><span id='topic+flxglht'></span><span id='topic+flxglht+2Cflexmix+2Ccharacter-method'></span><span id='topic+flxglht+2CFLXRoptim+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Extracts coefficient estimates and their covariance estimate to
perform tests for zero coefficients or constant effects re-using
functionality from package <span class="pkg">multcomp</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flxglht(model, linfct, ...)
## S4 method for signature 'flexmix,character'
flxglht(model, linfct, ...)
## S4 method for signature 'FLXRoptim,character'
flxglht(model, linfct, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flxglht_+3A_model">model</code></td>
<td>

<p>Either a fitted mixture model of class <code>"flexmix"</code>
or a re-fitted mixture model of class <code>"FLXRoptim"</code>.
</p>
</td></tr>
<tr><td><code id="flxglht_+3A_linfct">linfct</code></td>
<td>

<p>A character string which can be either <code>"zero"</code>
or <code>"tukey"</code>.
</p>
</td></tr>
<tr><td><code id="flxglht_+3A_...">...</code></td>
<td>

<p>Currently not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only tested for finite mixture models fitted with driver
<code><a href="#topic+FLXMRglm">FLXMRglm</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"glht"</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch
</p>


<h3>References</h3>

<p>Friedrich Leisch and Torsten Hothorn. Simultaneous Inference in Finite
Mixtures of Regression Models. <em>Austrian Journal of Statistics</em>,
forthcoming.
</p>


<h3>See Also</h3>

<p><code><a href="multcomp.html#topic+glht">glht</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NPreg", package = "flexmix")

ex1 &lt;- flexmix(yn ~ x + I(x^2), data = NPreg, k = 2,
               control = list(verb = 5, iter = 100))

zero_effect &lt;- flxglht(ex1, "zero")
zero_effect
summary(zero_effect)

comp_effect &lt;- flxglht(ex1, "tukey")
comp_effect
summary(comp_effect)
</code></pre>

<hr>
<h2 id='FLXM-class'>Class &quot;FLXM&quot;</h2><span id='topic+FLXM-class'></span><span id='topic+FLXMC-class'></span><span id='topic+FLXMR-class'></span><span id='topic+FLXMCsparse-class'></span><span id='topic+show+2CFLXM-method'></span>

<h3>Description</h3>

<p>FlexMix model specification.</p>


<h3>Details</h3>

<p>The most generic class is the virtual class <code>FLXM</code>. The classes
<code>FLXMC</code> for model-based clustering and <code>FLXMR</code> for
clusterwise regression extend the virtual class. Both have further
more specific model classes which inherit from them.
</p>
<p>Model class <code>FLXMCsparse</code> allows for model-based clustering with
a sparse matrix as data input.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FLXM", ...)</code>,
typically inside driver functions like <code><a href="#topic+FLXMRglm">FLXMRglm</a></code> or
<code><a href="#topic+FLXMCmvnorm">FLXMCmvnorm</a></code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>fit</code>:</dt><dd><p>Function returning an <code>FLXcomponent</code> object.</p>
</dd>
<dt><code>defineComponent</code>:</dt><dd><p>Function or expression to determine the
<code>FLXcomponent</code> object given the parameters.</p>
</dd>
<dt><code>weighted</code>:</dt><dd><p>Logical indicating whether <code>fit</code> can do
weighted likelihood maximization.</p>
</dd>
<dt><code>name</code>:</dt><dd><p>Character string used in print methods.</p>
</dd>
<dt><code>formula</code>:</dt><dd><p>Formula describing the model.</p>
</dd>
<dt><code>fullformula</code>:</dt><dd><p>Resulting formula from updating the model
formula with the formula specified in the call to <code>flexmix</code>.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Model matrix.</p>
</dd>
<dt><code>y</code>:</dt><dd><p>Model response.</p>
</dd>
<dt><code>terms</code>, <code>xlevels</code>, <code>contrasts</code>:</dt><dd><p>Additional
information for model matrix.</p>
</dd>
<dt><code>preproc.x</code>:</dt><dd><p>Function for preprocessing matrix <code>x</code>
before the EM algorithm starts, by default the identity function.</p>
</dd>
<dt><code>preproc.y</code>:</dt><dd><p>Function for preprocessing matrix <code>y</code>
before the EM algorithm starts, by default the identity function.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>

<hr>
<h2 id='FLXMCdist1'>FlexMix Clustering of Univariate Distributions</h2><span id='topic+FLXMCdist1'></span>

<h3>Description</h3>

<p>These are drivers for <code><a href="#topic+flexmix">flexmix</a></code> implementing model-based
clustering of univariate data using different distributions for the
component-specific models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMCdist1(formula = . ~ ., dist, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMCdist1_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Only the left-hand side (response) of
the formula is used. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMCdist1_+3A_dist">dist</code></td>
<td>
<p>Character string indicating the component-specific
univariate distribution.</p>
</td></tr>
<tr><td><code id="FLXMCdist1_+3A_...">...</code></td>
<td>
<p>Arguments for the specific model drivers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently drivers for the following distributions are available:
</p>

<ol>
<li><p> Lognormal (<code>"lnorm"</code>)
</p>
</li>
<li><p> inverse Gaussian (<code>"invGauss"</code> using <code><a href="SuppDists.html#topic+invGauss">dinvGauss</a></code>)
</p>
</li>
<li><p> gamma (<code>"gamma"</code>)
</p>
</li>
<li><p> exponential (<code>"exp"</code>)
</p>
</li>
<li><p> Weibull (<code>"weibull"</code>)
</p>
</li>
<li><p> Burr (<code>"burr"</code> using <code><a href="actuar.html#topic+Burr">dburr</a></code>)
</p>
</li>
<li><p> Inverse Burr (<code>"invburr"</code> using <code><a href="actuar.html#topic+Burr">dinvburr</a></code>)
</p>
</li></ol>



<h3>Value</h3>

<p><code>FLXMCdist1</code> returns an object of class <code>FLXMC</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>Tatjana Miljkovic and Bettina Gruen. Modeling loss data using
mixtures of distributions. <em>Insurance: Mathematics and
Economics</em>, <b>70</b>, 387-396, 2016.
doi:10.1016/j.insmatheco.2016.06.019
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexmix">flexmix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("actuar")) {
    set.seed(123)
    y &lt;- c(rexp(100, 10), rexp(100, 1))
    ex &lt;- flexmix(y ~ 1, cluster = rep(1:2, each = 100), model = FLXMCdist1(dist = "exp"))    
    parameters(ex)
}
</code></pre>

<hr>
<h2 id='FLXMCfactanal'>Driver for Mixtures of Factor Analyzers</h2><span id='topic+FLXMCfactanal'></span><span id='topic+rFLXM+2CFLXMCfactanal+2CFLXcomponent-method'></span>

<h3>Description</h3>

<p>This driver for <code><a href="#topic+flexmix">flexmix</a></code> implements estimation of mixtures of
factor analyzers using ML estimation of factor analysis implemented in
<code>factanal</code> in each M-step. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMCfactanal(formula = . ~ ., factors = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMCfactanal_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Only the left-hand side (response) of
the formula is used. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMCfactanal_+3A_factors">factors</code></td>
<td>
<p>Integer specifying the number of factors in each component.</p>
</td></tr>
<tr><td><code id="FLXMCfactanal_+3A_...">...</code></td>
<td>
<p>Passed to <code>factanal</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>FLXMCfactanal</code> returns an object of class <code>FLXM</code>.
</p>


<h3>Warning</h3>

<p>This does not implement the AECM framework presented in McLachlan and
Peel (2000, p.245), but uses the available functionality in R for ML
estimation of factor analyzers. The implementation therefore is only
experimental and has not been well tested.
</p>
<p>Please note that in general a good initialization is crucial for the
EM algorithm to converge to a suitable solution for this model class.
</p>


<h3>Author(s)</h3>

<p>Bettina Gruen</p>


<h3>References</h3>

<p>G. McLachlan and D. Peel. <em>Finite Mixture Models</em>, 2000.
John Wiley and Sons Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexmix">flexmix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Reproduce (partly) Table 8.1. p.255 (McLachlan and Peel, 2000)
if (require("gclus")) {
  data("wine", package = "gclus")
  wine_data &lt;- as.matrix(wine[,-1])
  set.seed(123)
  wine_fl_diag &lt;- initFlexmix(wine_data ~ 1, k = 3, nrep = 10,
                              model = FLXMCmvnorm(diagonal = TRUE))
  wine_fl_fact &lt;- lapply(1:4, function(q) flexmix(wine_data ~ 1, model =
                          FLXMCfactanal(factors = q, nstart = 3),
                          cluster = posterior(wine_fl_diag)))
  sapply(wine_fl_fact, logLik)
  ## FULL
  set.seed(123)
  wine_full &lt;- initFlexmix(wine_data ~ 1, k = 3, nrep = 10,
                           model = FLXMCmvnorm(diagonal = FALSE))
  logLik(wine_full)
  ## TRUE
  wine_true &lt;- flexmix(wine_data ~ 1, cluster = wine$Class,
                       model = FLXMCmvnorm(diagonal = FALSE))
  logLik(wine_true)
}
</code></pre>

<hr>
<h2 id='FLXMCmvbinary'>FlexMix Binary Clustering Driver</h2><span id='topic+FLXMCmvbinary'></span><span id='topic+FLXbclust'></span>

<h3>Description</h3>

<p>This is a model driver for <code><a href="#topic+flexmix">flexmix</a></code> implementing
model-based clustering of binary data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMCmvbinary(formula = . ~ ., truncated = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMCmvbinary_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Only the left-hand side (response) of
the formula is used. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMCmvbinary_+3A_truncated">truncated</code></td>
<td>
<p>logical, if <code>TRUE</code> the observations for the
pattern with only zeros are missing and the truncated likelihood is
optimized using an EM-algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model driver can be used to cluster binary data. The only
parameter is the column-wise mean of the data, which equals the
probability of observing a 1.
</p>


<h3>Value</h3>

<p><code>FLXMCmvbinary</code> returns an object of class <code>FLXMC</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexmix">flexmix</a></code></p>

<hr>
<h2 id='FLXMCmvcombi'>FlexMix Binary and Gaussian Clustering Driver</h2><span id='topic+FLXMCmvcombi'></span>

<h3>Description</h3>

<p>This is a model driver for <code><a href="#topic+flexmix">flexmix</a></code> implementing
model-based clustering of a combination of binary and Gaussian data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMCmvcombi(formula = . ~ .)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMCmvcombi_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Only the left-hand side (response) of
the formula is used. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model driver can be used to cluster mixed-mode binary and
Gaussian data. It checks which columns of a matrix contain only zero
and ones, and does the same as <code><a href="#topic+FLXMCmvbinary">FLXMCmvbinary</a></code> for them. For
the remaining columns of the data matrix independent Gaussian
distributions are used (same as <code><a href="#topic+FLXMCmvnorm">FLXMCmvnorm</a></code> with
<code>diagonal = FALSE</code>. 
The same could be obtained by creating a corresponding list of two
models for the respective columns, but <code>FLXMCmvcombi</code> does a
better job in reporting parameters.
</p>


<h3>Value</h3>

<p><code>FLXMCmvcombi</code> returns an object of class <code>FLXMC</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexmix">flexmix</a></code>, <code><a href="#topic+FLXMCmvbinary">FLXMCmvbinary</a></code>, <code><a href="#topic+FLXMCmvnorm">FLXMCmvnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create some artificial data
x1 &lt;- cbind(rnorm(300),
            sample(0:1, 300, replace = TRUE, prob = c(0.25, 0.75)))
x2 &lt;- cbind(rnorm(300, mean = 2, sd = 0.5),
            sample(0:1, 300, replace = TRUE, prob = c(0.75, 0.25)))
x &lt;- rbind(x1, x2)

## fit the model
f1 &lt;- flexmix(x ~ 1, k = 2, model = FLXMCmvcombi())
## should be similar to the original parameters
parameters(f1)
table(clusters(f1), rep(1:2, c(300,300)))

## a column with noise should not hurt too much
x &lt;- cbind(x, rnorm(600))
f2 &lt;- flexmix(x ~ 1, k = 2, model = FLXMCmvcombi())
parameters(f2)
table(clusters(f2), rep(1:2, c(300,300)))

</code></pre>

<hr>
<h2 id='FLXMCmvnorm'>FlexMix Clustering Demo Driver</h2><span id='topic+FLXMCmvnorm'></span><span id='topic+FLXMCnorm1'></span><span id='topic+FLXmclust'></span>

<h3>Description</h3>

<p>These are demo drivers for <code><a href="#topic+flexmix">flexmix</a></code> implementing
model-based clustering of Gaussian data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMCmvnorm(formula = . ~ ., diagonal = TRUE)
FLXMCnorm1(formula = . ~ .)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMCmvnorm_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Only the left-hand side (response) of
the formula is used. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMCmvnorm_+3A_diagonal">diagonal</code></td>
<td>
<p>If <code>TRUE</code>, then the covariance matrix of the
components is restricted to diagonal matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is mostly meant as a demo for FlexMix driver programming, you
should also look at package <span class="pkg">mclust</span> for real
applications. <code>FLXMCmvnorm</code> clusters multivariate data,
<code>FLXMCnorm1</code> univariate data. In the latter case smart
initialization is important, see the example below. 
</p>


<h3>Value</h3>

<p><code>FLXMCmvnorm</code> returns an object of class <code>FLXMC</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>Friedrich Leisch. FlexMix: A general framework for finite mixture
models and latent class regression in R. <em>Journal of Statistical
Software</em>, <b>11</b>(8), 2004. doi:10.18637/jss.v011.i08
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexmix">flexmix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Nclus", package = "flexmix")

require("MASS")
eqscplot(Nclus)

## This model is wrong (one component has a non-diagonal cov matrix)
ex1 &lt;- flexmix(Nclus ~ 1, k = 4, model = FLXMCmvnorm())
print(ex1)
plotEll(ex1, Nclus)

## True model, wrong number of components
ex2 &lt;- flexmix(Nclus ~ 1, k = 6, model = FLXMCmvnorm(diagonal = FALSE))  
print(ex2)

plotEll(ex2, Nclus)

## Get parameters of first component
parameters(ex2, component = 1)

## Have a look at the posterior probabilies of 10 random observations
ok &lt;- sample(1:nrow(Nclus), 10)
p  &lt;- posterior(ex2)[ok, ]
p

## The following two should be the same
max.col(p)
clusters(ex2)[ok]

## Now try the univariate case
plot(density(Nclus[, 1]))

ex3 &lt;- flexmix(Nclus[, 1] ~ 1, cluster = cut(Nclus[, 1], 3),
               model = FLXMCnorm1())
ex3
parameters(ex3)
</code></pre>

<hr>
<h2 id='FLXMCmvpois'>FlexMix Poisson Clustering Driver</h2><span id='topic+FLXMCmvpois'></span>

<h3>Description</h3>

<p>This is a model driver for <code><a href="#topic+flexmix">flexmix</a></code> implementing
model-based clustering of Poisson distributed data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMCmvpois(formula = . ~ .)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMCmvpois_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Only the left-hand side (response) of
the formula is used. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be used to cluster Poisson distributed data where given the
component membership the variables are mutually independent.
</p>


<h3>Value</h3>

<p><code>FLXMCmvpois</code> returns an object of class <code>FLXMC</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexmix">flexmix</a></code></p>

<hr>
<h2 id='FLXMRcondlogit'>FlexMix Interface to Conditional Logit Models</h2><span id='topic+FLXMRcondlogit'></span>

<h3>Description</h3>

<p>Model driver for fitting mixtures of conditional logit models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMRcondlogit(formula = . ~ ., strata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRcondlogit_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMRcondlogit_+3A_strata">strata</code></td>
<td>
<p>A formula which is interpreted such that no intercept is
fitted and which allows to determine the variable indicating which
observations are from the same stratum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The M-step is performed using <code>coxph.fit</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRcondlogit</code> inheriting from <code>FLXMRglm</code>.
</p>


<h3>Warning</h3>

<p>To ensure identifiability repeated measurements are
necessary. Sufficient conditions are given in Gruen and Leisch (2008).
</p>


<h3>Author(s)</h3>

<p>Bettina Gruen
</p>


<h3>References</h3>

<p>Bettina Gruen and Friedrich Leisch. Identifiability of finite mixtures
of multinomial logit models with varying and fixed
effects. <em>Journal of Classification</em>, <b>25</b>, 225&ndash;247. 2008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FLXMRmultinom">FLXMRmultinom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("Ecdat")) {
  data("Catsup", package = "Ecdat")
  ## To reduce the time needed for the example only a subset is used
  Catsup &lt;- subset(Catsup, id %in% 1:100)
  Catsup$experiment &lt;- seq_len(nrow(Catsup))
  vnames &lt;- c("display", "feature", "price")
  Catsup_long &lt;-
    reshape(Catsup,
            idvar = c("id", "experiment"),
            times = c(paste("heinz", c(41, 32, 28), sep = ""),
              "hunts32"),
            timevar = "brand",
            varying = matrix(colnames(Catsup)[2:13], nrow = 3, byrow = TRUE),
            v.names = vnames,
            direction = "long")
  Catsup_long$selected &lt;- with(Catsup_long, choice == brand)
  Catsup_long &lt;- Catsup_long[, c("id", "selected", "experiment", vnames, "brand")]
  Catsup_long$brand &lt;- relevel(factor(Catsup_long$brand), "hunts32")
  set.seed(0808)
  flx1 &lt;- flexmix(selected ~ display + feature + price + brand | id,
                  model = FLXMRcondlogit(strata = ~ experiment), 
                  data = Catsup_long, k = 1)
}
</code></pre>

<hr>
<h2 id='FLXMRglm'>FlexMix Interface to Generalized Linear Models</h2><span id='topic+FLXMRglm'></span><span id='topic+FLXglm'></span>

<h3>Description</h3>

<p>This is the main driver for FlexMix interfacing the <code><a href="stats.html#topic+glm">glm</a></code>
family of models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMRglm(formula = . ~ .,
         family = c("gaussian", "binomial", "poisson", "Gamma"),
         offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRglm_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMRglm_+3A_family">family</code></td>
<td>
<p>A character string naming a <code><a href="stats.html#topic+glm">glm</a></code>
family function.</p>
</td></tr>
<tr><td><code id="FLXMRglm_+3A_offset">offset</code></td>
<td>
<p>This can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+flexmix">flexmix</a></code> for examples.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRglm</code> inheriting from <code>FLXMR</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>Friedrich Leisch. FlexMix: A general framework for finite mixture
models and latent class regression in R. <em>Journal of Statistical
Software</em>, <b>11</b>(8), 2004. doi:10.18637/jss.v011.i08
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flexmix">flexmix</a></code>, <code><a href="stats.html#topic+glm">glm</a></code></p>

<hr>
<h2 id='FLXMRglmfix'>FlexMix Interface to GLMs with Fixed Coefficients</h2><span id='topic+FLXMRglmfix'></span><span id='topic+FLXglmFix'></span>

<h3>Description</h3>

<p>This implements a driver for FlexMix which interfaces the <code>glm</code>
family of models and where it is possible to specify fixed (constant) or
nested varying coefficients or to ensure that in the Gaussian case the
variance estimate is equal for all components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMRglmfix(formula = . ~ ., fixed = ~0, varFix = FALSE, nested = NULL, 
       family = c("gaussian", "binomial", "poisson", "Gamma"),
       offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRglmfix_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code>flexmix</code> using
<code>update.formula</code>. Default is to use the original
<code>flexmix</code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMRglmfix_+3A_fixed">fixed</code></td>
<td>
<p>A formula which specifies the additional
regressors for the fixed (constant) coefficients.</p>
</td></tr>
<tr><td><code id="FLXMRglmfix_+3A_varfix">varFix</code></td>
<td>
<p>A logical indicating if the variance estimate for
Gaussian components should be constrained to be equal for all
components. It can be also a vector specifying the number of
components with equal variance.</p>
</td></tr>
<tr><td><code id="FLXMRglmfix_+3A_nested">nested</code></td>
<td>
<p>An object of class <code>FLXnested</code> or a list specifying
the nested structure.</p>
</td></tr>
<tr><td><code id="FLXMRglmfix_+3A_family">family</code></td>
<td>
<p>A character string naming a <code>glm</code>
family function.</p>
</td></tr>
<tr><td><code id="FLXMRglmfix_+3A_offset">offset</code></td>
<td>
<p>This can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRglmfix</code> 
inheriting from <code>FLXMRglm</code> and <code>FLXMRfix</code>.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>See Also</h3>

<p><code>FLXMRglm</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NPreg", package = "flexmix")
ex &lt;- flexmix(yn ~ x | id2, data = NPreg, k = 2,
              cluster = NPreg$class,
              model = FLXMRglm(yn ~ . + I(x^2)))
ex.fix &lt;- flexmix(yn ~ x | id2, data = NPreg,
                  cluster = posterior(ex),
                  model = FLXMRglmfix(nested = list(k = c(1, 1),
                                      formula = c(~0, ~I(x^2)))))
summary(refit(ex))
## Not run: 
summary(refit(ex.fix))

## End(Not run)
</code></pre>

<hr>
<h2 id='FLXMRglmnet'>FlexMix Interface for Adaptive Lasso / Elastic Net with GLMs</h2><span id='topic+FLXMRglmnet'></span><span id='topic+FLXMRglmnet-class'></span>

<h3>Description</h3>

<p>This is a driver which allows fitting of mixtures of GLMs where
the coefficients are penalized using the (adaptive) lasso or the
elastic net by reusing functionality from package <span class="pkg">glmnet</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    FLXMRglmnet(formula = . ~ ., family = c("gaussian", "binomial", "poisson"),
              adaptive = TRUE, select = TRUE, offset = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRglmnet_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMRglmnet_+3A_family">family</code></td>
<td>
<p>A character string naming a <code><a href="stats.html#topic+glm">glm</a></code>
family function.</p>
</td></tr>
<tr><td><code id="FLXMRglmnet_+3A_adaptive">adaptive</code></td>
<td>
<p>A logical indicating if the adaptive lasso should be
used. By default equal to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="FLXMRglmnet_+3A_select">select</code></td>
<td>
<p>A logical vector indicating which variables in the
model matrix should be included in the penalized part.  By default
equal to <code>TRUE</code> implying that all variables are penalized.</p>
</td></tr>
<tr><td><code id="FLXMRglmnet_+3A_offset">offset</code></td>
<td>
<p>This can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="FLXMRglmnet_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code> fitter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some care is needed to ensure convergence of the algorithm, which is
computationally more challenging than a standard EM.  In the proposed
method, not only are cluster allocations identified and component
parameters estimated as commonly done in mixture models, but there is
also variable selection via penalized regression using $k$-fold
cross-validation to choose the penalty parameter.  For the algorithm
to converge, it is necessary that the same cross-validation
partitioning be used across the EM iterations, i.e., the subsamples
for cross-validation must be defined at the beginning This is
accomplished using the <code>foldid</code> option as an additional parameter
to be passed to <code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code> (see
<span class="pkg">glmnet</span> package documentation).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRglm</code>.
</p>


<h3>Author(s)</h3>

<p>Frederic Mortier and Nicolas Picard.
</p>


<h3>References</h3>

<p>Frederic Mortier, Dakis-Yaoba Ouedraogo, Florian Claeys, Mahlet
G. Tadesse, Guillaume Cornu, Fidele Baya, Fabrice Benedet, Vincent
Freycon, Sylvie Gourlet-Fleury and Nicolas Picard.
Mixture of inhomogeneous matrix models for species-rich ecosystems.
<em>Environmetrics</em>, <b>26</b>(1), 39-51, 2015.
doi:10.1002/env.2320
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FLXMRglm">FLXMRglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    set.seed(12)
    p &lt;- 10
    beta &lt;- matrix(0, nrow = p + 1, ncol = 2)
    beta[1,] &lt;- c(-1, 1)
    beta[cbind(c(5, 10), c(1, 2))] &lt;- 1

    nobs &lt;- 100
    X &lt;- matrix(rnorm(nobs * p), nobs, p)
    mu &lt;- cbind(1, X) %*% beta
    z &lt;- sample(1:ncol(beta), nobs, replace = TRUE)
    y &lt;- mu[cbind(1:nobs, z)] + rnorm(nobs)
    data &lt;- data.frame(y, X)
    ## The maximum number of iterations is reduced to
    ## avoid a long running time.
    fo &lt;- sample(rep(seq(10), length = nrow(data)))
    ex1 &lt;- flexmix(y ~ ., data = data, k = 2, cluster = z,
                   model = FLXMRglmnet(foldid = fo),
                   control = list(iter.max = 2))
    parameters(ex1)
</code></pre>

<hr>
<h2 id='FLXMRlmer'>FlexMix Interface to Linear Mixed Models</h2><span id='topic+FLXMRlmer'></span><span id='topic+FLXMRlmer-class'></span><span id='topic+FLXMRlmm-class'></span><span id='topic+FLXMRlmmfix-class'></span><span id='topic+FLXdeterminePostunscaled+2CFLXMRlmer-method'></span><span id='topic+FLXdeterminePostunscaled+2CFLXMRlmm-method'></span><span id='topic+FLXmstep+2CFLXMRlmer-method'></span><span id='topic+FLXmstep+2CFLXMRlmm-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMRlmer-method'></span><span id='topic+FLXgetModelmatrix+2CFLXMRlmm-method'></span><span id='topic+FLXMRlmm'></span><span id='topic+FLXgetObs+2CFLXMRlmm-method'></span><span id='topic+FLXmstep+2CFLXMRlmmfix-method'></span><span id='topic+predict+2CFLXMRlmm-method'></span><span id='topic+rFLXM+2CFLXMRlmm+2CFLXcomponent-method'></span><span id='topic+rFLXM+2CFLXMRlmm+2Clist-method'></span><span id='topic+rFLXM+2CFLXMRlmc+2CFLXcomponent-method'></span><span id='topic+rFLXM+2CFLXMRlmer+2CFLXcomponent-method'></span>

<h3>Description</h3>

<p>This is a driver which allows fitting of mixtures of linear models
with random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMRlmm(formula = . ~ ., random, lm.fit = c("lm.wfit",
          "smooth.spline"), varFix = c(Random = FALSE, Residual =
          FALSE), ...)
FLXMRlmer(formula = . ~ ., random, weighted = TRUE,
          control = list(), eps = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRlmer_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code>flexmix</code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Default is to use the original
<code>flexmix</code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMRlmer_+3A_random">random</code></td>
<td>
<p>A formula for specifying the random effects.</p>
</td></tr>
<tr><td><code id="FLXMRlmer_+3A_weighted">weighted</code></td>
<td>
<p>A logical indicating if the model should be estimated
with weighted ML.</p>
</td></tr>
<tr><td><code id="FLXMRlmer_+3A_control">control</code></td>
<td>
<p>A list of control parameters. See
<code><a href="lme4.html#topic+lmer">lmer</a></code> for details.</p>
</td></tr>
<tr><td><code id="FLXMRlmer_+3A_eps">eps</code></td>
<td>
<p>Observations with a component-specific posterior smaller
than <code>eps</code> are omitted in the M-step for this component.</p>
</td></tr>
<tr><td><code id="FLXMRlmer_+3A_lm.fit">lm.fit</code></td>
<td>
<p>A character string indicating if the coefficients should
be fitted using either a linear model or the function
<code>smooth.spline</code></p>
</td></tr>
<tr><td><code id="FLXMRlmer_+3A_varfix">varFix</code></td>
<td>
<p>Named logical vector of length 2 indicating if the
variance of the random effects and the residuals are fixed over the
components.</p>
</td></tr>
<tr><td><code id="FLXMRlmer_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>smooth.spline</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FLXMRlmm</code> allows only one random effect. <code>FLXMRlmer</code> allows
an arbitrary number of random effects if <code>weighted = FALSE</code>; a
certain structure of the model matrix of the random effects has to be
given for weighted ML estimation, i.e. where <code>weighted = TRUE</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRlmer</code> and <code>FLXMRlmm</code>
inheriting from <code>FLXMRglm</code> and <code>FLXMR</code>, respectively.
</p>


<h3>Warning</h3>

<p>For <code>FLXMRlmer</code> the weighted ML estimation is only correct if the
covariate matrix of the random effects is the same for each
observation. By default weighted ML estimation is made and the
condition on the covariate matrix of the random effects is checked. If
this fails, only estimation with <code>weighted = FALSE</code> is possible
which will maximize the classification likelihood.
</p>


<h3>Author(s)</h3>

<p>Bettina Gruen</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- rep(1:50, each = 10)
x &lt;- rep(1:10, 50)
sample &lt;- data.frame(y = rep(rnorm(unique(id)/2, 0, c(5, 2)), each = 10) +
                         rnorm(length(id), rep(c(3, 8), each = 10)) +
                         rep(c(0, 3), each = 10) * x,
                     x = x,
                     id = factor(id))
fitted &lt;- flexmix(.~.|id, k = 2, model = FLXMRlmm(y ~ x, random = ~ 1),
                  data = sample, control = list(tolerance = 10^-3),
                  cluster = rep(rep(1:2, each = 10), 25))
parameters(fitted)

fitted1 &lt;- flexmix(.~.|id, k = 2, model = FLXMRlmer(y ~ x, random = ~ 1),
                  data = sample, control = list(tolerance = 10^-3),
                  cluster = rep(rep(1:2, each = 10), 25))
parameters(fitted1)

fitted2 &lt;- flexmix(.~.|id, k = 2,
                   model = FLXMRlmm(y ~ 0 + x, random = ~ 1,
                     lm.fit = "smooth.spline"),
                  data = sample, control = list(tolerance = 10^-3),
                  cluster = rep(rep(1:2, each = 10), 25))
parameters(fitted2)
</code></pre>

<hr>
<h2 id='FLXMRlmmc'>FlexMix Interface to Linear Mixed Models with Left-Censoring</h2><span id='topic+FLXMRlmmc'></span><span id='topic+FLXMRlmmc-class'></span><span id='topic+FLXMRlmmcfix-class'></span><span id='topic+FLXMRlmc-class'></span><span id='topic+FLXMRlmcfix-class'></span><span id='topic+predict+2CFLXMRlmc-method'></span>

<h3>Description</h3>

<p>This is a driver which allows fitting of mixtures of linear models
with random effects and left-censored observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMRlmmc(formula = . ~ ., random, censored, varFix, eps = 10^-6, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRlmmc_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code>flexmix</code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Default is to use the original
<code>flexmix</code> model formula.</p>
</td></tr>
<tr><td><code id="FLXMRlmmc_+3A_random">random</code></td>
<td>
<p>A formula for specifying the random effects. If missing
no random effects are fitted.</p>
</td></tr>
<tr><td><code id="FLXMRlmmc_+3A_varfix">varFix</code></td>
<td>
<p>If random effects are specified a named logical vector
of length 2 indicating if the variance of the random effects and the
residuals are fixed over the components. Otherwise a logical
indicating if the variance of the residuals are fixed over the
components.</p>
</td></tr>
<tr><td><code id="FLXMRlmmc_+3A_censored">censored</code></td>
<td>
<p>A formula for specifying the censoring variable.</p>
</td></tr>
<tr><td><code id="FLXMRlmmc_+3A_eps">eps</code></td>
<td>
<p>Observations with an a-posteriori probability smaller or
equal to <code>eps</code> are omitted in the M-step.</p>
</td></tr>
<tr><td><code id="FLXMRlmmc_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>lm.wfit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRlmmc</code>, <code>FLXMRlmmcfix</code>,
<code>FLXMRlmc</code> or <code>FLXMRlmcfix</code> inheriting from <code>FLXMR</code>.
</p>


<h3>Author(s)</h3>

<p>Bettina Gruen</p>

<hr>
<h2 id='FLXMRmgcv'>FlexMix Interface to GAMs</h2><span id='topic+FLXMRmgcv'></span><span id='topic+FLXMRmgcv-class'></span>

<h3>Description</h3>

<p>This is a driver which allows fitting of mixtures of GAMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMRmgcv(formula = . ~ ., family = c("gaussian", "binomial", "poisson"),
          offset = NULL, control = NULL, optimizer = c("outer", "newton"),
          in.out = NULL, eps = .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRmgcv_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMRmgcv_+3A_family">family</code></td>
<td>
<p>A character string naming a <code><a href="stats.html#topic+glm">glm</a></code>
family function.</p>
</td></tr>
<tr><td><code id="FLXMRmgcv_+3A_offset">offset</code></td>
<td>
<p>This can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="FLXMRmgcv_+3A_control">control</code></td>
<td>
<p>A list of fit control parameters returned by
<code>gam.control</code>.</p>
</td></tr>
<tr><td><code id="FLXMRmgcv_+3A_optimizer">optimizer</code></td>
<td>
<p>An array specifying the numerical optimization method
to use to optimize the smoothing parameter estimation criterion; for
more details see <code><a href="mgcv.html#topic+gam">gam</a></code>.</p>
</td></tr>
<tr><td><code id="FLXMRmgcv_+3A_in.out">in.out</code></td>
<td>
<p>Optional list for initializing outer iteration; for more
details see <code><a href="mgcv.html#topic+gam">gam</a></code>.</p>
</td></tr>
<tr><td><code id="FLXMRmgcv_+3A_eps">eps</code></td>
<td>
<p>Observations with an a-posteriori probability smaller or
equal to <code>eps</code> are omitted in the M-step.</p>
</td></tr>
<tr><td><code id="FLXMRmgcv_+3A_...">...</code></td>
<td>
<p>Additional arguments to be pased to the GAM fitter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRmgcv</code> inheriting from <code>FLXMRglm</code>.
</p>


<h3>Author(s)</h3>

<p>Bettina Gruen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FLXMRglm">FLXMRglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2012)
x &lt;- seq(0, 1, length.out = 100)
z &lt;- sample(0:1, length(x), replace = TRUE)
y &lt;- rnorm(length(x), ifelse(z, 5 * sin(x * 2 * pi), 10 * x - 5))
fitted_model &lt;- flexmix(y ~ s(x), model = FLXMRmgcv(),
                        cluster = z + 1,
                        control = list(tolerance = 10^-3))
plot(y ~ x, col = clusters(fitted_model))
matplot(x, fitted(fitted_model), type = "l", add = TRUE)
</code></pre>

<hr>
<h2 id='FLXMRmultinom'>FlexMix Interface to Multiomial Logit Models</h2><span id='topic+FLXMRmultinom'></span>

<h3>Description</h3>

<p>Model driver for fitting mixtures of multinomial logit models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMRmultinom(formula = . ~ ., ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRmultinom_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code><a href="#topic+flexmix">flexmix</a></code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Default is to use the original
<code><a href="#topic+flexmix">flexmix</a></code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMRmultinom_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>nnet.default</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The M-step is performed using <code>nnet.default</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRmultinom</code> inheriting from <code>FLXMRglm</code>.
</p>


<h3>Warning</h3>

<p>To ensure identifiability repeated measurements are
necessary. Sufficient conditions are given in Gruen and Leisch (2008).
</p>


<h3>Author(s)</h3>

<p>Bettina Gruen
</p>


<h3>References</h3>

<p>Bettina Gruen and Friedrich Leisch. Identifiability of finite mixtures
of multinomial logit models with varying and fixed
effects. <em>Journal of Classification</em>, <b>25</b>, 225&ndash;247. 2008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FLXMRcondlogit">FLXMRcondlogit</a></code></p>

<hr>
<h2 id='FLXMRrobglm'>FlexMix Driver for Robust Estimation of Generalized Linear Models</h2><span id='topic+FLXMRrobglm'></span><span id='topic+FLXMRrobglm-class'></span>

<h3>Description</h3>

<p>This driver adds a noise component to the mixture model which can be
used to model background noise in the data. See the Compstat paper
Leisch (2008) cited below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMRrobglm(formula = . ~ ., family = c("gaussian", "poisson"),
            bgw = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRrobglm_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code>flexmix</code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Default is to use the original
<code>flexmix</code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMRrobglm_+3A_family">family</code></td>
<td>
<p>A character string naming a <code><a href="stats.html#topic+glm">glm</a></code>
family function.</p>
</td></tr>
<tr><td><code id="FLXMRrobglm_+3A_bgw">bgw</code></td>
<td>
<p>Logical, controls whether the parameters of the background
component are fixed to multiples of location and scale of the
complete data (the default), or estimated by EM with normal weights for the
background (<code>bgw = TRUE</code>).</p>
</td></tr>
<tr><td><code id="FLXMRrobglm_+3A_...">...</code></td>
<td>
<p>passed to <code>FLXMRglm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRrobglm</code> inheriting from <code>FLXMRglm</code>.
</p>


<h3>Note</h3>

<p>The implementation of this model class is currently under development,
and some methods like <code>refit</code> are still missing.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>Friedrich Leisch. Modelling background noise in finite mixtures of
generalized linear regression models. In Paula Brito, editor, Compstat
2008&ndash;Proceedings in Computational Statistics, 385&ndash;396. Physica
Verlag, Heidelberg, Germany, 2008.<br />
Preprint available at http://epub.ub.uni-muenchen.de/6332/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Compstat paper, see paper for detailed explanation:
data("NPreg", package = "flexmix")
DATA &lt;- NPreg[, 1:2]
set.seed(3)
DATA2 &lt;- rbind(DATA, cbind(x = -runif(3), yn = 50 + runif(3)))

## Estimation without (f2) and with (f3) background component
f2 &lt;- flexmix(yn ~ x + I(x^2), data = DATA2, k = 2)
f3 &lt;- flexmix(yn ~ x + I(x^2), data = DATA2, k = 3,
              model = FLXMRrobglm(), 
              control = list(minprior = 0))

## Predict on new data for plots
x &lt;- seq(-5,15, by = .1)
y2 &lt;- predict(f2, newdata = data.frame(x = x))
y3 &lt;- predict(f3, newdata = data.frame(x = x))

## f2 was estimated without background component:
plot(yn ~ x, data = DATA2, pch = clusters(f2), col = clusters(f2))
lines(x, y2$Comp.1, col = 1)
lines(x, y2$Comp.2, col = 2)

## f3 is with background component:
plot(yn ~ x, data = DATA2, pch = 4 - clusters(f3),
     col = 4 - clusters(f3))
lines(x, y3$Comp.2, col = 2)
lines(x, y3$Comp.3, col = 1)
</code></pre>

<hr>
<h2 id='FLXMRziglm'>FlexMix Interface to Zero Inflated Generalized Linear Models</h2><span id='topic+FLXMRziglm'></span><span id='topic+FLXMRziglm-class'></span><span id='topic+refit+2CFLXMRziglm-method'></span><span id='topic+FLXreplaceParameters+2CFLXMRziglm-method'></span><span id='topic+FLXgradlogLikfun+2CFLXMRziglm-method'></span>

<h3>Description</h3>

<p>This is a driver which allows fitting of zero inflated poisson and
binomial models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXMRziglm(formula = . ~ ., family = c("binomial", "poisson"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXMRziglm_+3A_formula">formula</code></td>
<td>
<p>A formula which is interpreted relative to the formula
specified in the call to <code>flexmix</code> using
<code><a href="stats.html#topic+update.formula">update.formula</a></code>. Default is to use the original
<code>flexmix</code> model
formula.</p>
</td></tr>
<tr><td><code id="FLXMRziglm_+3A_family">family</code></td>
<td>
<p>A character string naming a <code><a href="stats.html#topic+glm">glm</a></code>
family function.</p>
</td></tr>
<tr><td><code id="FLXMRziglm_+3A_...">...</code></td>
<td>
<p>passed to <code>FLXMRglm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>FLXMRziglm</code> inheriting from <code>FLXMRglm</code>.
</p>


<h3>Note</h3>

<p>In fact this only approximates zero inflated models by fixing the
coefficient of the intercept at -Inf and the other coefficients at
zero for the first component.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data("dmft", package = "flexmix")
  Model &lt;- FLXMRziglm(family = "poisson")
  Fitted &lt;- flexmix(End ~ log(Begin + 0.5) + Gender + Ethnic + Treatment, 
                    model = Model, k = 2 , data = dmft, 
                    control = list(minprior = 0.01))
  summary(refit(Fitted))
</code></pre>

<hr>
<h2 id='FLXnested-class'>Class &quot;FLXnested&quot;</h2><span id='topic+FLXnested-class'></span><span id='topic+coerce+2Clist+2CFLXnested-method'></span><span id='topic+coerce+2CNULL+2CFLXnested-method'></span><span id='topic+coerce+2Cnumeric+2CFLXnested-method'></span><span id='topic+initialize+2CFLXnested-method'></span>

<h3>Description</h3>

<p>Specification of nesting structure for regression coefficients.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FLXnested",
  formula, k, ...)</code>. In addition, named lists can be coerced to
<code>FLXnested</code> objects, names are completed if unique.
</p>


<h3>Slots</h3>


<dl>
<dt><code>formula</code>:</dt><dd><p>Object of class <code>"list"</code> containing the
formula for determining the model matrix for each nested parameter.</p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"numeric"</code> specifying the
number of components in each group.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>

<hr>
<h2 id='FLXP'>Creates the Concomitant Variable Model</h2><span id='topic+FLXPconstant'></span><span id='topic+FLXPmultinom'></span><span id='topic+FLXconstant'></span><span id='topic+FLXmultinom'></span><span id='topic+show+2CFLXP-method'></span>

<h3>Description</h3>

<p>Creator functions for the concomitant variable
model. <code>FLXPconstant</code> specifies constant priors
and <code>FLXPmultinom</code> multinomial logit models for the priors.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLXPconstant()
FLXPmultinom(formula = ~1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FLXP_+3A_formula">formula</code></td>
<td>
<p>A formula for determining the model matrix of the
concomitant variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FLXPmultinom</code> uses <code>nnet.default</code> from <span class="pkg">nnet</span> to fit the
multinomial logit model.
</p>


<h3>Value</h3>

<p>Object of class <code>FLXP</code>. <code>FLXPmultinom</code> returns an
object of class <code>FLXPmultinom</code> which extends class
<code>FLXP</code> directly and is used for method dispatching.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>

<hr>
<h2 id='FLXP-class'>Class &quot;FLXP&quot;</h2><span id='topic+FLXP-class'></span><span id='topic+initialize+2CFLXP-method'></span><span id='topic+FLXPconstant-class'></span><span id='topic+FLXPmultinom-class'></span>

<h3>Description</h3>

<p>Concomitant model class.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("FLXP", ...)</code>,
typically inside driver functions like <code><a href="#topic+FLXPconstant">FLXPconstant</a></code> or
<code><a href="#topic+FLXPmultinom">FLXPmultinom</a></code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Character string used in print methods.</p>
</dd>
<dt><code>formula</code>:</dt><dd><p>Formula describing the model.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Model matrix.</p>
</dd>
<dt><code>fit</code>:</dt><dd><p>Function returning the fitted prior probabilities.</p>
</dd>
<dt><code>refit</code>:</dt><dd><p>Function returning the fitted concomitant model.</p>
</dd>
<dt><code>coef</code>:</dt><dd><p>Matrix containing the fitted parameters.</p>
</dd>
<dt><code>df</code>:</dt><dd><p>Function for determining the number of degrees of
freedom used.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>

<hr>
<h2 id='group'>Extract Grouping Variable</h2><span id='topic+group'></span><span id='topic+group-methods'></span><span id='topic+group+2Cflexmix-method'></span><span id='topic+group+2CFLXM-method'></span><span id='topic+group+2CFLXMRglmfix-method'></span>

<h3>Description</h3>

<p>Extract grouping variable for all observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'flexmix'
group(object)
## S4 method for signature 'FLXM'
group(object)
## S4 method for signature 'FLXMRglmfix'
group(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_+3A_object">object</code></td>
<td>
<p>an object of class <code>flexmix</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bettina Gruen</p>

<hr>
<h2 id='ICL'>Integrated Completed Likelihood Criterion</h2><span id='topic+ICL+2Cflexmix-method'></span><span id='topic+ICL+2CstepFlexmix-method'></span>

<h3>Description</h3>

<p>Compute the Integrated Completed Likelihood criterion for model selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'flexmix'
ICL(object, ...)
## S4 method for signature 'stepFlexmix'
ICL(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ICL_+3A_object">object</code></td>
<td>
<p>see Methods section below</p>
</td></tr>
<tr><td><code id="ICL_+3A_...">...</code></td>
<td>
<p>Some methods for this generic function may take additional,
optional arguments. At present none do.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector with the corresponding ICL value(s). 
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;flexmix&quot;:</dt><dd><p>Compute the ICL of a <code>flexmix</code> object.</p>
</dd>
<dt>object = &quot;stepFlexmix&quot;:</dt><dd><p>Compute the ICL of all
models contained in the <code>stepFlexmix</code> object.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>C. Biernacki, G. Celeux, and G. Govaert. Assessing a mixture model
for clustering with the integrated completed likelihood. <em>IEEE
Transactions on Pattern Analysis and Machine Intelligence</em>,
<em>22</em>(7), 719&ndash;725, 2000.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NPreg", package = "flexmix")
ex1 &lt;- flexmix(yn ~ x + I(x^2), data = NPreg, k = 2)
ICL(ex1)
</code></pre>

<hr>
<h2 id='KLdiv'>Kullback-Leibler Divergence</h2><span id='topic+KLdiv+2Cmatrix-method'></span><span id='topic+KLdiv+2Cflexmix-method'></span><span id='topic+KLdiv+2CFLXMRglm-method'></span><span id='topic+KLdiv+2CFLXMC-method'></span>

<h3>Description</h3>

<p>Estimate the Kullback-Leibler divergence of several distributions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
KLdiv(object, eps = 10^-4, overlap = TRUE,...)
## S4 method for signature 'flexmix'
KLdiv(object, method = c("continuous", "discrete"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KLdiv_+3A_object">object</code></td>
<td>
<p>See Methods section below.</p>
</td></tr>
<tr><td><code id="KLdiv_+3A_method">method</code></td>
<td>
<p>The method to be used; &quot;continuous&quot; determines
the Kullback-Leibler divergence between the unweighted theoretical
component distributions and the unweighted posterior probabilities
at the observed points are used by &quot;discrete&quot;.</p>
</td></tr>
<tr><td><code id="KLdiv_+3A_eps">eps</code></td>
<td>
<p>Probabilities below this threshold are replaced by this
threshold for numerical stability.</p>
</td></tr>
<tr><td><code id="KLdiv_+3A_overlap">overlap</code></td>
<td>
<p>Logical, do not determine the KL divergence for
those pairs where for each point at least one of the densities has a
value smaller than <code>eps</code>.</p>
</td></tr>
<tr><td><code id="KLdiv_+3A_...">...</code></td>
<td>
<p>Passed to the matrix method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates </p>
<p style="text-align: center;"><code class="reqn">\int f(x) (\log f(x) - \log g(x)) dx</code>
</p>

<p>for distributions with densities <code class="reqn">f()</code> and <code class="reqn">g()</code>.
</p>


<h3>Value</h3>

<p>A matrix of KL divergences where the rows correspond to using the
respective distribution as <code class="reqn">f()</code> in the formula above.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;matrix&quot;:</dt><dd><p>Takes as input a matrix of
density values with one row per observation and one column per
distribution.</p>
</dd>
<dt>object = &quot;flexmix&quot;:</dt><dd><p>Returns the Kullback-Leibler divergence
of the mixture components.</p>
</dd>
</dl>


<h3>Note</h3>

<p>The density functions are modified to have equal support.
A weight of at least <code>eps</code> is given to each
observation point for the modified densities.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>S. Kullback and R. A. Leibler. On information and sufficiency.<em>The
Annals of Mathematical Statistics</em>, <b>22</b>(1), 79&ndash;86, 1951.
</p>
<p>Friedrich Leisch. Exploring the structure of mixture model
components. In Jaromir Antoch, editor, Compstat 2004&ndash;Proceedings in
Computational Statistics, 1405&ndash;1412. Physika Verlag, Heidelberg,
Germany, 2004. ISBN 3-7908-1554-3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gaussian and Student t are much closer to each other than
## to the uniform:

x &lt;- seq(-3, 3, length = 200)
y &lt;- cbind(u = dunif(x), n = dnorm(x), t = dt(x, df = 10))

matplot(x, y, type = "l")
KLdiv(y)

if (require("mlbench")) {
set.seed(2606)
x &lt;-  mlbench.smiley()$x
model1 &lt;- flexmix(x ~ 1, k = 9, model = FLXmclust(diag = FALSE),
                  control  =  list(minprior = 0))
plotEll(model1, x)
KLdiv(model1)
}
</code></pre>

<hr>
<h2 id='Lapply-methods'>Methods for Function Lapply</h2><span id='topic+Lapply+2CFLXRmstep-method'></span>

<h3>Description</h3>

<p>Apply a function to each component of a finite mixture</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FLXRmstep'
Lapply(object, FUN, model = 1, component = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lapply-methods_+3A_object">object</code></td>
<td>
<p>S4 class object.</p>
</td></tr>
<tr><td><code id="Lapply-methods_+3A_fun">FUN</code></td>
<td>
<p>The function to be applied.</p>
</td></tr>
<tr><td><code id="Lapply-methods_+3A_model">model</code></td>
<td>
<p>The model (for a multivariate response) that shall be
used.</p>
</td></tr>
<tr><td><code id="Lapply-methods_+3A_component">component</code></td>
<td>
<p>Index vector for selecting the components.</p>
</td></tr>
<tr><td><code id="Lapply-methods_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FUN</code> is found by a call to <code>match.fun</code> and typically is specified
as a function or a symbol (e.g. a backquoted name) or a character
string specifying a function to be searched for from the
environment of the call to <code>Lapply</code>.
</p>


<h3>Value</h3>

<p>A list of the length equal to the number of components specified is
returned, each element of which is the result of applying <code>FUN</code> to the
specified component of the refitted mixture model.
</p>


<h3>Methods</h3>


<dl>
<dt>object = FLXRmstep:</dt><dd><p>Apply a function to each component of a
refitted <code>flexmix</code> object using method = <code>"mstep"</code>.</p>
</dd>
</dl>
  


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("NPreg", package = "flexmix")
ex2 &lt;- flexmix(yn ~ x, data = NPreg, k = 2, model = list(FLXMRglm(yn ~ 
    . + I(x^2)), FLXMRglm(yp ~ ., family = "poisson")))
ex2r &lt;- refit(ex2, method = "mstep")
Lapply(ex2r, "vcov", 2)
</code></pre>

<hr>
<h2 id='logLik-methods'>Methods for Function logLik in Package <span class="pkg">flexmix</span></h2><span id='topic+logLik+2Cflexmix-method'></span><span id='topic+logLik+2CstepFlexmix-method'></span>

<h3>Description</h3>

<p>Evaluate the log-likelihood.  This function is defined as
an S4 generic in the <code>stats4</code> package.</p>


<h3>Methods</h3>


<dl>
<dt>object = flexmix</dt><dd><p>Evaluate the log-likelihood of an
<code>flexmix</code> object</p>
</dd>
</dl>


<hr>
<h2 id='Mehta'>Mehta Trial</h2><span id='topic+Mehta'></span>

<h3>Description</h3>

<p>For a 22-centre trial the number of responses and the total number of
patients is reported for the control group and the group receiving
a new drug.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Mehta")</code></pre>


<h3>Format</h3>

<p>A data frame with 44 observations on the following 4 variables.
</p>

<dl>
<dt>Response</dt><dd><p>Number of responses.</p>
</dd>
<dt>Total</dt><dd><p>Total number of observations.</p>
</dd>
<dt>Drug</dt><dd><p>A factor indicating treatment with levels <code>New</code> and
<code>Control</code>.</p>
</dd>
<dt>Site</dt><dd><p>A factor indicating the site/centre.</p>
</dd>
</dl>



<h3>Source</h3>

<p>M. Aitkin. Meta-analysis by random effect modelling in
generalized linear models.
<em>Statistics in Medicine</em>, <b>18</b>, 2343&ndash;2351, 1999.
</p>


<h3>References</h3>

<p>C.R. Mehta, N.R. Patel and P. Senchaudhuri. Importance sampling
for estimating exact probabilities in permutational inference.
<em>Journal of the American Statistical Association</em>, <em>83</em>,
999&ndash;1005, 1988.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Mehta", package = "flexmix")
mehtaMix &lt;- initFlexmix(cbind(Response, Total-Response) ~ 1|Site, 
                        data = Mehta, nrep = 5, k = 3,
                        model = FLXMRglmfix(family = "binomial",
                          fixed = ~ Drug), 
                        control = list(minprior = 0.04))
</code></pre>

<hr>
<h2 id='NregFix'>Artificial Example for Normal Regression</h2><span id='topic+NregFix'></span>

<h3>Description</h3>

<p>A simple artificial regression example with 3 latent classes, two
independent variables, one concomitant variable and a dependent
variable which follows a Gaussian distribution.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("NregFix")
</code></pre>


<h3>Format</h3>

<p>A data frame with 200 observations on the following 5 variables.
</p>

<dl>
<dt><code>x1</code></dt><dd><p>Independent variable: numeric variable.</p>
</dd>
<dt><code>x2</code></dt><dd><p>Independent variable: a factor with two levels:
<code>0</code> and <code>1</code>.</p>
</dd>
<dt><code>w</code></dt><dd><p>Concomitant variable: a factor with two levels:
<code>0</code> and <code>1</code>.</p>
</dd>
<dt><code>y</code></dt><dd><p>Dependent variable.</p>
</dd>
<dt><code>class</code></dt><dd><p>Latent class memberships.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("NregFix", package = "flexmix")
library("lattice")
xyplot(y ~ x1 | x2 * w, data = NregFix, groups = class)
Model &lt;- FLXMRglmfix(~ 1, fixed = ~ x2, 
                     nested = list(k = c(2, 1),
                     formula = c(~x1, ~0)))
fittedModel &lt;- initFlexmix(y ~ 1, model = Model, data = NregFix, k = 3,
                           concomitant = FLXPmultinom(~ w), nrep = 5)
fittedModel
</code></pre>

<hr>
<h2 id='patent'>Patents and R&amp;D Spending</h2><span id='topic+patent'></span>

<h3>Description</h3>

<p>Number of patents, R&amp;D spending and sales in millions of dollar for 70
pharmaceutical and biomedical companies in 1976.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("patent")</code></pre>


<h3>Format</h3>

<p>A data frame with 70 observations on the following 4 variables.
</p>

<dl>
<dt>Company</dt><dd><p>Name of company.</p>
</dd>
<dt>Patents</dt><dd><p>Number of patents.</p>
</dd>
<dt>RDS</dt><dd><p>R&amp;D spending per sales.</p>
</dd>
<dt>lgRD</dt><dd><p>Logarithmized R&amp;D spendings (in millions of dollars).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data is taken from the National Bureau of Economic Research R&amp;D Masterfile.
</p>


<h3>Source</h3>

<p>P. Wang, I.M. Cockburn and M.L. Puterman. Analysis of Patent
Data &ndash; A Mixed-Poisson-Regression-Model Approach.
<em>Journal of Business &amp; Economic Statistics</em>, <b>16</b>(1),
27&ndash;41, 1998.
</p>


<h3>References</h3>

<p>B.H. Hall, C. Cummins, E. Laderman and J. Mundy. The R&amp;D Master
File Documentation.
Technical Working Paper 72, National Bureau of Economic
Research, 1988. Cambridge, MA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("patent", package = "flexmix")
patentMix &lt;- initFlexmix(Patents ~ lgRD, k = 3,
                         model = FLXMRglm(family = "poisson"),
                         concomitant = FLXPmultinom(~RDS),
                         nrep = 5, data = patent)
plot(Patents ~ lgRD, data = patent,
     pch = as.character(clusters(patentMix)))
ordering &lt;- order(patent$lgRD)
apply(fitted(patentMix), 2, function(y)
      lines(sort(patent$lgRD), y[ordering]))
</code></pre>

<hr>
<h2 id='plot-methods'>Rootogram of Posterior Probabilities</h2><span id='topic+plot-methods'></span><span id='topic+plot+2Cflexmix+2Cmissing-method'></span>

<h3>Description</h3>

<p>The <code>plot</code> method for <code><a href="#topic+flexmix-class">flexmix-class</a></code> objects gives a
rootogram or histogram of the posterior probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'flexmix,missing'
plot(x, y, mark = NULL, markcol = NULL,
  col  =  NULL, eps = 1e-4, root = TRUE, ylim = TRUE, main = NULL, xlab = "",
  ylab = "", as.table = TRUE, endpoints = c(-0.04, 1.04), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>An object of class <code>"flexmix"</code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_mark">mark</code></td>
<td>
<p>Integer: mark posteriors of this component.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_markcol">markcol</code></td>
<td>
<p>Color used for marking components.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_col">col</code></td>
<td>
<p>Color used for the bars.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_eps">eps</code></td>
<td>
<p>Posteriors smaller than <code>eps</code> are ignored.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_root">root</code></td>
<td>
<p>If <code>TRUE</code>, a rootogram of the posterior probabilities
is drawn, otherwise a standard histogram.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ylim">ylim</code></td>
<td>
<p>A logical value or a numeric vector of length 2. If
<code>TRUE</code>, the y axes of all rootograms are aligned
to have the same limits, if <code>FALSE</code> each y axis is scaled
separately. If a numeric vector is specified it is used as usual.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_main">main</code></td>
<td>
<p>Main title of the plot.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_ylab">ylab</code></td>
<td>
<p>Label of y-axis.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_as.table">as.table</code></td>
<td>
<p>Logical that controls the order in which panels
should be plotted: if <code>FALSE</code> (the default), panels are
drawn left to right, bottom to top (as in a graph); if
<code>TRUE</code>, left to right, top to bottom.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_endpoints">endpoints</code></td>
<td>
<p>Vector of length 2 indicating the range of x-values that is
to be covered by the histogram.  This applies only when
<code>breaks</code> is unspecified. In <code>do.breaks</code>, this specifies the interval
that is to be divided up.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>Further graphical parameters for the lattice function
histogram.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each mixture component a rootogram or histogram of the posterior
probabilities of all observations is 
drawn. Rootograms are very similar to histograms, the only difference
is that the height of the bars correspond to square roots of counts
rather than the counts themselves, hence low counts are more
visible and peaks less emphasized. Please note that the y-axis denotes
the number of observations in each bar in any case.
</p>
<p>Usually in each component a lot of observations have posteriors
close to zero, resulting in a high count for the corresponding
bin in the rootogram which obscures the information in the other
bins. To avoid this problem, all probabilities with a posterior below
<code>eps</code> are ignored.
</p>
<p>A peak at probability one indicates that a mixture component is well
seperated from the other components, while no peak at one and/or
significant mass in the middle of the unit interval indicates overlap
with other components.
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>Friedrich Leisch. FlexMix: A general framework for finite mixture
models and latent class regression in R. <em>Journal of Statistical
Software</em>, <b>11</b>(8), 2004. doi:10.18637/jss.v011.i08
</p>
<p>Jeremy Tantrum, Alejandro Murua and Werner Stuetzle. Assessment and
pruning of hierarchical model based clustering. Proceedings of the
9th ACM SIGKDD international conference on Knowledge Discovery and
Data Mining, 197&ndash;205. ACM Press, New York, NY, USA, 2003.
</p>
<p>Friedrich Leisch. Exploring the structure of mixture model
components. In Jaromir Antoch, editor, Compstat 2004&ndash;Proceedings in
Computational Statistics, 1405&ndash;1412. Physika Verlag, Heidelberg,
Germany, 2004. ISBN 3-7908-1554-3.
</p>

<hr>
<h2 id='plotEll'>Plot Confidence Ellipses for FLXMCmvnorm Results</h2><span id='topic+plotEll'></span>

<h3>Description</h3>

<p>Plot 50% and 95% confidence ellipses for mixtures of Gaussians fitted using
<code><a href="#topic+FLXMCmvnorm">FLXMCmvnorm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEll(object, data, which = 1:2, model = 1, project = NULL, points = TRUE,
        eqscale = TRUE, col = NULL, number = TRUE, cex = 1.5, numcol = "black", 
        pch = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotEll_+3A_object">object</code></td>
<td>
<p>An object of class <code>flexmix</code> with a fitted
<code>FLXMCmvnorm</code> model.</p>
</td></tr>
<tr><td><code id="plotEll_+3A_data">data</code></td>
<td>
<p>The response variable in a data frame or as a matrix.</p>
</td></tr>
<tr><td><code id="plotEll_+3A_which">which</code></td>
<td>
<p>Index numbers of dimensions of (projected) input space
to plot.</p>
</td></tr>
<tr><td><code id="plotEll_+3A_model">model</code></td>
<td>
<p>The model (for a multivariate response) that shall be
plotted.</p>
</td></tr>
<tr><td><code id="plotEll_+3A_project">project</code></td>
<td>
<p>Projection object, currently only the result of
<code><a href="stats.html#topic+prcomp">prcomp</a></code> is supported.</p>
</td></tr>
<tr><td><code id="plotEll_+3A_points">points</code></td>
<td>
<p>Logical, shall data points be plotted?</p>
</td></tr>
<tr><td><code id="plotEll_+3A_eqscale">eqscale</code></td>
<td>
<p>Logical, plot using <code><a href="MASS.html#topic+eqscplot">eqscplot</a></code>?</p>
</td></tr>
<tr><td><code id="plotEll_+3A_number">number</code></td>
<td>
<p>Logical, plot number labels at cluster centers?</p>
</td></tr>
<tr><td><code id="plotEll_+3A_cex">cex</code>, <code id="plotEll_+3A_numcol">numcol</code></td>
<td>
<p>Size and color of number labels.</p>
</td></tr>
<tr><td><code id="plotEll_+3A_pch">pch</code>, <code id="plotEll_+3A_col">col</code>, <code id="plotEll_+3A_...">...</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>See Also</h3>

<p><code><a href="#topic+FLXMCmvnorm">FLXMCmvnorm</a></code></p>

<hr>
<h2 id='posterior'>Determine Cluster Membership and Posterior Probabilities</h2><span id='topic+clusters+2Cflexmix+2Cmissing-method'></span><span id='topic+clusters+2CFLXdist+2CANY-method'></span><span id='topic+posterior+2Cflexmix+2Cmissing-method'></span><span id='topic+posterior+2CFLXdist+2ClistOrdata.frame-method'></span>

<h3>Description</h3>

<p>Determine posterior probabilities or cluster memberships for a fitted
<code>flexmix</code>  or unfitted <code>FLXdist</code> model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'flexmix,missing'
posterior(object, newdata, unscaled = FALSE, ...)
## S4 method for signature 'FLXdist,listOrdata.frame'
posterior(object, newdata, unscaled = FALSE, ...)
## S4 method for signature 'flexmix,missing'
clusters(object, newdata, ...)
## S4 method for signature 'FLXdist,ANY'
clusters(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_+3A_object">object</code></td>
<td>
<p>An object of class &quot;flexmix&quot; or &quot;FLXdist&quot;.</p>
</td></tr>
<tr><td><code id="posterior_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list containing new data. If missing the
posteriors of the original observations are returned.</p>
</td></tr>
<tr><td><code id="posterior_+3A_unscaled">unscaled</code></td>
<td>
<p>Logical, if <code>TRUE</code> the component-specific
likelihoods are returned.</p>
</td></tr>
<tr><td><code id="posterior_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>

<hr>
<h2 id='refit-methods'>Refit a Fitted Model</h2><span id='topic+refit+2Cflexmix-method'></span><span id='topic+FLXRmstep-class'></span><span id='topic+FLXRoptim-class'></span><span id='topic+show+2CFLXR-method'></span><span id='topic+show+2CCoefmat-method'></span><span id='topic+summary+2CFLXRoptim-method'></span><span id='topic+summary+2CFLXRmstep-method'></span><span id='topic+plot+2CFLXRoptim+2Cmissing-method'></span>

<h3>Description</h3>

<p>Refits an estimated flexmix model to obtain additional information
like coefficient significance p-values for GLM regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'flexmix'
refit(object, newdata, method = c("optim",
"mstep"), ...)
## S4 method for signature 'FLXRoptim'
summary(object, model = 1, which = c("model",
"concomitant"), ...)
## S4 method for signature 'FLXRmstep'
summary(object, model = 1, which = c("model",
"concomitant"), ...)

## S4 method for signature 'FLXRoptim,missing'
plot(x, y, model = 1, which = c("model", "concomitant"),
         bycluster = TRUE, alpha = 0.05, components, labels = NULL,
         significance = FALSE, xlab = NULL, ylab = NULL, ci = TRUE,
         scales = list(), as.table = TRUE, horizontal = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refit-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>"flexmix"</code></p>
</td></tr>
<tr><td><code id="refit-methods_+3A_newdata">newdata</code></td>
<td>
<p>Optional new data.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_method">method</code></td>
<td>
<p>Specifies if the variance covariance matrix is
determined using <code><a href="stats.html#topic+optim">optim</a></code> or if the posteriors are
assumed as given and an M-step is performed.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_model">model</code></td>
<td>
<p>The model (for a multivariate response) that shall be
used.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_which">which</code></td>
<td>
<p>Specifies if a component specific model or the
concomitant variable model is used.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_x">x</code></td>
<td>
<p>An object of class <code>"FLXRoptim"</code></p>
</td></tr>
<tr><td><code id="refit-methods_+3A_y">y</code></td>
<td>
<p>Missing object.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_bycluster">bycluster</code></td>
<td>
<p>A logical if the parameters should be group by
cluster or by variable.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_alpha">alpha</code></td>
<td>
<p>Numeric indicating the significance level.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_components">components</code></td>
<td>
<p>Numeric vector specifying which components are
plotted. The default is to plot all components.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_labels">labels</code></td>
<td>
<p>Character vector specifying the variable names used.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_significance">significance</code></td>
<td>
<p>A logical indicating if non-significant
coefficients are shaded in a lighter grey.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_xlab">xlab</code></td>
<td>
<p>String for the x-axis label.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_ylab">ylab</code></td>
<td>
<p>String for the y-axis label.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_ci">ci</code></td>
<td>
<p>A logical indicating if significant and insignificant
parameter estimates are shaded differently.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_scales">scales</code></td>
<td>
<p>See argument of the same name for
function <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_as.table">as.table</code></td>
<td>
<p>See arguments of the same name for
function <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_horizontal">horizontal</code></td>
<td>
<p>See arguments of the same name for
function <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.</p>
</td></tr>
<tr><td><code id="refit-methods_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>refit</code> method for <code>FLXMRglm</code> models in
combination with the <code>summary</code> method can be
used to obtain the usual tests for significance of coefficients. Note
that the tests are valid only if <code>flexmix</code> returned the maximum
likelihood estimator of the parameters.  If <code>refit</code> is used with
<code>method = "mstep"</code> for these component specific models the
returned object contains a <code>glm</code> object for each component where
the elements <code>model</code> which is the model frame and <code>data</code>
which contains the original dataset are missing.
</p>


<h3>Value</h3>

<p>An object inheriting form class <code>FLXR</code> is returned. For the
method using <code>optim</code> the object has class <code>FLXRoptim</code> and
for the M-step method it has class <code>FLXRmstep</code>. Both classes give
similar results for their <code>summary</code> methods. 
Objects of class <code>FLXRoptim</code> have their own <code>plot</code> method.
<code>Lapply</code> can be used to further analyse the refitted component
specific models of objects of class <code>FLXRmstep</code>.
</p>


<h3>Warning</h3>

<p>For <code>method = "mstep"</code> the standard deviations are determined
separately for each of the components using the a-posteriori
probabilities as weights without accounting for the fact that the
components have been simultaneously estimated. The derived standard
deviations are hence approximative and should only be used in an
exploratory way, as they are underestimating the uncertainty given
that the missing information of the component memberships are replaced
by the expected values.
</p>
<p>The <code>newdata</code> argument can only be specified when using
<code>method = "mstep"</code> for refitting <code>FLXMRglm</code> components. A
variant of <code>glm</code> for weighted ML estimation is used for fitting
the components and full <code>glm</code> objects are returned. Please note
that in this case the data and the model frame are stored for each
component which can significantly increase the object size.  </p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>Friedrich Leisch. FlexMix: A general framework for finite mixture
models and latent class regression in R. <em>Journal of Statistical
Software</em>, <b>11</b>(8), 2004. doi:10.18637/jss.v011.i08
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("NPreg", package = "flexmix")
ex1 &lt;- flexmix(yn ~ x + I(x^2), data = NPreg, k = 2)
ex1r &lt;- refit(ex1)

## in one component all coefficients should be highly significant,
## in the other component only the linear term
summary(ex1r)
</code></pre>

<hr>
<h2 id='relabel'>Relabel the Components</h2><span id='topic+relabel'></span><span id='topic+relabel+2CFLXdist+2Cmissing-method'></span><span id='topic+relabel+2CFLXdist+2Ccharacter-method'></span><span id='topic+relabel+2CFLXdist+2Cinteger-method'></span>

<h3>Description</h3>

<p>The components are sorted by the value of one of the parameters or
according to an integer vector containing the permutation of the
numbers from 1 to the number of components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relabel(object, by, ...)
## S4 method for signature 'FLXdist,character'
relabel(object, by, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relabel_+3A_object">object</code></td>
<td>
<p>An object of class <code>"flexmix"</code>.</p>
</td></tr>
<tr><td><code id="relabel_+3A_by">by</code></td>
<td>
<p>If a character vector, it needs to be one of <code>"prior"</code>,
<code>"model"</code>, <code>"concomitant"</code> indicating if the parameter
should be from the component-specific or the concomitant variable
model. If an integer vector it indicates how the components should
be sorted.  If missing, the components are sorted by component
size.</p>
</td></tr>
<tr><td><code id="relabel_+3A_which">which</code></td>
<td>
<p>Name (or unique substring) of a parameter if <code>by</code> is
equal to &quot;model&quot; or &quot;concomitant&quot;.</p>
</td></tr>
<tr><td><code id="relabel_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>Examples</h3>

<pre><code class='language-R'>    set.seed(123)
    beta &lt;- matrix(1:16, ncol = 4)
    beta
    df1 &lt;- ExLinear(beta, n = 100, sd = .5)
    f1 &lt;- flexmix(y~., data = df1, k = 4)

    ## There was label switching, parameters are not in the same order
    ## as in beta:
    round(parameters(f1))
        
    betas &lt;- rbind(beta, .5)
    betas

    ## This makes no sense:
    summary(abs(as.vector(betas-parameters(f1))))

    ## We relabel the components by sorting the coefficients of x1:
    r1 &lt;- relabel(f1, by = "model", which = "x1")
    round(parameters(r1))

    ## Now we can easily compare the fit with the true parameters:
    summary(abs(as.vector(betas-parameters(r1))))
</code></pre>

<hr>
<h2 id='rflexmix'>Random Number Generator for Finite Mixtures</h2><span id='topic+rflexmix'></span><span id='topic+rflexmix+2Cflexmix+2Cmissing-method'></span><span id='topic+rflexmix+2CFLXdist+2Cnumeric-method'></span><span id='topic+rflexmix+2CFLXdist+2ClistOrdata.frame-method'></span><span id='topic+rFLXM'></span><span id='topic+rFLXM+2CFLXM+2Clist-method'></span><span id='topic+rFLXM+2CFLXMC+2CFLXcomponent-method'></span><span id='topic+rFLXM+2CFLXMCmultinom+2CFLXcomponent-method'></span><span id='topic+rFLXM+2CFLXMCbinom+2CFLXcomponent-method'></span><span id='topic+rFLXM+2CFLXMRglm+2Clist-method'></span><span id='topic+rFLXM+2CFLXMRglmfix+2Clist-method'></span><span id='topic+rFLXM+2CFLXM+2CFLXcomponent-method'></span><span id='topic+rFLXM+2CFLXMRglm+2CFLXcomponent-method'></span>

<h3>Description</h3>

<p>Given a finite mixture model generate random
numbers from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rflexmix(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rflexmix_+3A_object">object</code></td>
<td>
<p>A fitted finite mixture model of class <code>flexmix</code> 
or an unfitted of class <code>FLXdist</code>.</p>
</td></tr>
<tr><td><code id="rflexmix_+3A_newdata">newdata</code></td>
<td>
<p>Optionally, a data frame in which to look for variables with
which to predict or an integer specifying the number of random draws
for model-based clustering. If omitted, the data to which the model
was fitted is used.</p>
</td></tr>
<tr><td><code id="rflexmix_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rflexmix</code> provides the creation of the model matrix for new data
and the sampling of the cluster memberships. The sampling of the
component distributions given the classification is done by calling
<code>rFLXM</code>. This step has to be provided for the different model
classes. 
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>Random sample</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>Grouping factor</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>Class membership</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bettina Gruen</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(flexmix)
sample &lt;- rflexmix(ex1)
</code></pre>

<hr>
<h2 id='salmonellaTA98'>Salmonella Reverse Mutagenicity Assay</h2><span id='topic+salmonellaTA98'></span>

<h3>Description</h3>

<p>Data on Ames Salmonella reverse mutagenicity assay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("salmonellaTA98")</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>x</dt><dd><p>Dose levels of quinoline.</p>
</dd>
<dt>y</dt><dd><p>Numbers of revertant colonies of TA98 Salmonella observed on
each of three replicate plates tested at each of six dose levels of
quinoline diameter.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set is taken from package <span class="pkg">dispmod</span> provided by Luca
Scrucca.
</p>


<h3>Source</h3>

<p>Margolin, B.J., Kaplan, N. and Zeiger, E. Statistical
analysis of the Ames Salmonella/microsome test,
<em>Proc. Natl. Acad. Sci. USA</em>, <b>76</b>, 3779&ndash;3783, 1981.
</p>


<h3>References</h3>

<p>Breslow, N.E. Extra-Poisson variation in log-linear
models, <em>Applied Statistics</em>, <b>33</b>, 38&ndash;44, 1984.
</p>
<p>Wang, P., Puterman, M.L., Cockburn, I.M., and Le, N.D. Mixed
Poisson regression models with covariate dependent rates,
<em>Biometrics</em>, <b>52</b>, 381&ndash;400, 1996.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("salmonellaTA98", package = "flexmix")
salmonMix &lt;- initFlexmix(y ~ 1,
                         data = salmonellaTA98, 
                         model = FLXMRglmfix(family = "poisson", 
                           fixed = ~ x + log(x + 10)),                        
                         k = 2, nrep = 5)
salmonMix.pr &lt;- predict(salmonMix, newdata = salmonellaTA98)
plot(y ~ x, data = salmonellaTA98, 
     pch = as.character(clusters(salmonMix)), 
     ylim = range(c(salmonellaTA98$y, unlist(salmonMix.pr))))
for (i in 1:2) lines(salmonellaTA98$x, salmonMix.pr[[i]], lty = i)
</code></pre>

<hr>
<h2 id='seizure'>Epileptic Seizure Data</h2><span id='topic+seizure'></span>

<h3>Description</h3>

<p>Data from a clinical trial where the effect of intravenous
gamma-globulin on suppression of epileptic seizures is studied.
Daily observations for a period of 140 days on one patient are given, 
where the first 27 days are a baseline period without treatment, the
remaining 113 days are the treatment period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("seizure")</code></pre>


<h3>Format</h3>

<p>A data frame with 140 observations on the following 4 variables.
</p>

<dl>
<dt>Seizures</dt><dd><p>A numeric vector, daily counts of epileptic seizures.</p>
</dd>
<dt>Hours</dt><dd><p>A numeric vector, hours of daily parental observation.</p>
</dd>
<dt>Treatment</dt><dd><p>A factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt>Day</dt><dd><p>A numeric vector.</p>
</dd>
</dl>



<h3>Source</h3>

<p>P. Wang, M. Puterman, I. Cockburn, and N. Le. Mixed poisson
regression models with covariate dependent rates.
<em>Biometrics</em>, <b>52</b>, 381&ndash;400, 1996.
</p>


<h3>References</h3>

<p>B. Gruen and F. Leisch. Bootstrapping finite mixture models.
In J. Antoch, editor, Compstat 2004&ndash;Proceedings in Computational
Statistics, 1115&ndash;1122. Physika Verlag, Heidelberg, Germany, 2004.
ISBN 3-7908-1554-3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("seizure", package = "flexmix")
plot(Seizures/Hours ~ Day, col = as.integer(Treatment),
     pch = as.integer(Treatment), data = seizure)
abline(v = 27.5, lty = 2, col = "grey")
legend(140, 9, c("Baseline", "Treatment"),
       pch = 1:2, col = 1:2, xjust = 1, yjust = 1)

set.seed(123)

## The model presented in the Wang et al paper: two components for
## "good" and "bad" days, respectively, each a Poisson GLM with hours of
## parental observation as offset

seizMix &lt;- flexmix(Seizures ~ Treatment * log(Day),
                   data = seizure, k = 2,
                   model = FLXMRglm(family = "poisson",
                     offset = log(seizure$Hours)))

summary(seizMix)
summary(refit(seizMix))

matplot(seizure$Day, fitted(seizMix)/seizure$Hours, type = "l",
        add = TRUE, col = 3:4)
</code></pre>

<hr>
<h2 id='stepFlexmix'>Run FlexMix Repeatedly</h2><span id='topic+stepFlexmix'></span><span id='topic+initFlexmix'></span><span id='topic+initMethod'></span><span id='topic+stepFlexmix-class'></span><span id='topic+initMethod-class'></span><span id='topic+plot+2CstepFlexmix+2Cmissing-method'></span><span id='topic+show+2CstepFlexmix-method'></span><span id='topic+getModel+2CstepFlexmix-method'></span><span id='topic+unique+2CstepFlexmix-method'></span>

<h3>Description</h3>

<p>Runs flexmix repeatedly for different numbers of components and returns
the maximum likelihood solution for each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initFlexmix(..., k, init = list(), control = list(), nrep = 3L,
            verbose = TRUE, drop = TRUE, unique = FALSE)
initMethod(name = c("tol.em", "cem.em", "sem.em"),
           step1 = list(tolerance = 10^-2),
           step2 = list(), control = list(), nrep = 3L)

stepFlexmix(..., k = NULL, nrep = 3, verbose = TRUE, drop = TRUE,
            unique = FALSE)

## S4 method for signature 'stepFlexmix,missing'
plot(x, y, what = c("AIC", "BIC", "ICL"),
  xlab = NULL, ylab = NULL, legend = "topright", ...)

## S4 method for signature 'stepFlexmix'
getModel(object, which = "BIC")

## S4 method for signature 'stepFlexmix'
unique(x, incomparables = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepFlexmix_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+flexmix">flexmix</a></code> (or <code><a href="graphics.html#topic+matplot">matplot</a></code>
in the <code>plot</code> method).</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_k">k</code></td>
<td>
<p>A vector of integers passed in turn to the <code>k</code> argument
of <code><a href="#topic+flexmix">flexmix</a></code>.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_init">init</code></td>
<td>
<p>An object of class <code>"initMethod"</code> or a named list
where <code>initMethod</code> is called with it as arguments in addition
to the <code>control</code> argument.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_name">name</code></td>
<td>
<p>A character string indication which initialization
strategy should be employed: short runs of EM followed by a long
(<code>"tol.em"</code>), short runs of CEM followed by a long EM run
(<code>"cem.em"</code>), short runs of SEM followed by a long EM run
(<code>"sem.em"</code>).</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_step1">step1</code></td>
<td>
<p>A named list which combined with the <code>control</code>
argument is coercable to a <code>"FLXcontrol"</code> object. This control
setting is used for the short runs.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_step2">step2</code></td>
<td>
<p>A named list which combined with the <code>control</code>
argument is coercable to a <code>"FLXcontrol"</code> object. This control
setting is used for the long run.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_control">control</code></td>
<td>
<p>A named list which combined with the <code>step1</code> or
the <code>step2</code> argument is coercable to a <code>"FLXcontrol"</code>
object.</p>
</td></tr>  
<tr><td><code id="stepFlexmix_+3A_nrep">nrep</code></td>
<td>
<p>For each value of <code>k</code> run <code><a href="#topic+flexmix">flexmix</a></code>
<code>nrep</code> times and keep only the solution with maximum
likelihood. If <code>nrep</code> is set for the long run, it is ignored,
because the EM algorithm is deterministic using the best solution
discovered in the short runs for initialization.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, show progress information during
computations.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> and <code>k</code> is of length 1, then a single
flexmix object is returned instead of a <code>"stepFlexmix"</code>
object.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_unique">unique</code></td>
<td>
<p>If <code>TRUE</code>, then <code>unique()</code> is called on the
result, see below.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_x">x</code>, <code id="stepFlexmix_+3A_object">object</code></td>
<td>
<p>An object of class <code>"stepFlexmix"</code>.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_what">what</code></td>
<td>
<p>Character vector naming information criteria to
plot. Functions of the same name must exist, which take a
<code>stepFlexmix</code> object as input and return a numeric vector like
<code>AIC,stepFlexmix-method</code> (see examples below).</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_xlab">xlab</code>, <code id="stepFlexmix_+3A_ylab">ylab</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_legend">legend</code></td>
<td>
<p>If not <code>FALSE</code> and <code>what</code> contains more
than 1 element, a legend is placed at the specified location, see
<code><a href="graphics.html#topic+legend">legend</a></code> for details.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_which">which</code></td>
<td>
<p>Number of model to get. If character, interpreted as
number of components or name of an information criterion.</p>
</td></tr>
<tr><td><code id="stepFlexmix_+3A_incomparables">incomparables</code></td>
<td>
<p>A vector of values that cannot be
compared. Currently, <code>FALSE</code> is the only possible value,
meaning that all values can be compared.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"stepFlexmix"</code> containing the best models
with respect to the log likelihood for the different number of
components in a slot if <code>length(k)&gt;1</code>, else directly an object of
class <code>"flexmix"</code>.
</p>
<p>If <code>unique = FALSE</code>, then the resulting object contains one
model per element of <code>k</code> (which is the number of clusters the EM
algorithm started with). If <code>unique = TRUE</code>, then the result
is resorted according to the number of clusters contained in the
fitted models (which may be less than the number with which the EM
algorithm started), and only the maximum likelihood solution for each
number of fitted clusters is kept. This operation can also be done
manually by calling <code>unique()</code> on objects of class
<code>"stepFlexmix"</code>. 
</p>


<h3>Author(s)</h3>

<p>Friedrich Leisch and Bettina Gruen</p>


<h3>References</h3>

<p>Friedrich Leisch. FlexMix: A general framework for finite mixture
models and latent class regression in R. <em>Journal of Statistical
Software</em>, <b>11</b>(8), 2004. doi:10.18637/jss.v011.i08
</p>
<p>Christophe Biernacki, Gilles Celeux and Gerard Govaert. Choosing
starting values for the EM algorithm for getting the highest
likelihood in multivariate Gaussian mixture models. <em>Computational
Statistics &amp; Data Analysis</em>, <b>41</b>(3&ndash;4), 561&ndash;575, 2003.
</p>
<p>Theresa Scharl, Bettina Gruen and Friedrch Leisch.  Mixtures of
regression models for time-course gene expression data: Evaluation of
initialization and random effects. <em>Bioinformatics</em>,
<b>26</b>(3), 370&ndash;377, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Nclus", package = "flexmix")

## try 2 times for k = 4
set.seed(511)
ex1 &lt;- initFlexmix(Nclus~1, k = 4, model = FLXMCmvnorm(diagonal = FALSE),
                   nrep = 2)
ex1

## now 2 times each for k = 2:5, specify control parameter
ex2 &lt;- initFlexmix(Nclus~1, k = 2:5, model = FLXMCmvnorm(diagonal = FALSE),
                   control = list(minprior = 0), nrep = 2)
ex2
plot(ex2)

## get BIC values
BIC(ex2)

## get smallest model
getModel(ex2, which = 1)

## get model with 3 components
getModel(ex2, which = "3")

## get model with smallest ICL (here same as for AIC and BIC: true k = 4)
getModel(ex2, which = "ICL")

## now 1 time each for k = 2:5, with larger minimum prior
ex3 &lt;- initFlexmix(Nclus~1, k = 2:5,
                   model = FLXMCmvnorm(diagonal = FALSE),
                   control = list(minprior = 0.1), nrep = 1)
ex3

## keep only maximum likelihood solution for each unique number of
## fitted clusters:
unique(ex3)
</code></pre>

<hr>
<h2 id='tribolium'>Tribolium Beetles</h2><span id='topic+tribolium'></span>

<h3>Description</h3>

<p>The data investigates whether the adult Tribolium species Castaneum has
developed an evolutionary advantage to recognize and avoid eggs of
their own species while foraging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("tribolium")</code></pre>


<h3>Format</h3>

<p>A data frame with 27 observations on the following 4 variables.
</p>

<dl>
<dt><code>Remaining</code></dt><dd><p>A numeric vector.</p>
</dd>
<dt><code>Total</code></dt><dd><p>A numeric vector.</p>
</dd>
<dt><code>Replicate</code></dt><dd><p>A factor with levels <code>1</code>, <code>2</code>, <code>3</code>.</p>
</dd>
<dt><code>Species</code></dt><dd><p>A factor with levels <code>Castaneum</code> <code>Confusum</code> <code>Madens</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Beetles of the genus Tribolium are cannibalistic in the sense that
adults eat the eggs of their own species as well as those of closely
related species. The experiment isolated a number of adult beetles of
the same species and presented them with a vial of 150 eggs (50 of
each type), the eggs being thoroughly mixed to ensure uniformity
throughout the vial.
</p>
<p>The data gives the consumption data for adult Castaneum species. It
reports the number of Castaneum, Confusum and Madens eggs,
respectively, that remain uneaten after two day exposure to the adult
beetles. Replicates 1, 2, and 3 correspond to different occasions on
which the experiment was conducted.
</p>


<h3>Source</h3>

<p>P. Wang and M.L. Puterman. Mixed Logistic Regression Models.
<em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>3</b>
(2), 175&ndash;200, 1998.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("tribolium", package = "flexmix")
tribMix &lt;- initFlexmix(cbind(Remaining, Total - Remaining) ~ Species, 
                   k = 2, nrep = 5, data = tribolium,
                   model = FLXMRglm(family = "binomial"))
</code></pre>

<hr>
<h2 id='trypanosome'>Trypanosome</h2><span id='topic+trypanosome'></span>

<h3>Description</h3>

<p>Trypanosome data from a dosage-response analysis to assess the
proportion of organisms belonging to different populations. It is
assumed that organisms belonging to different populations are
indistinguishable other than in terms of their reaction to the
stimulus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("trypanosome")</code></pre>


<h3>Format</h3>

<p>A data frame with 426 observations on the following 2 variables.
</p>

<dl>
<dt><code>Dead</code></dt><dd><p>A logical vector.</p>
</dd>
<dt><code>Dose</code></dt><dd><p>A numeric vector.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The experimental technique involved inspection under the microscope
of a representative aliquot of a suspension, all organisms appearing
within two fields of view being classified either alive or
dead. Hence the total numbers of organisms present at each dose and
the number showing the quantal response were both random variables.
</p>


<h3>Source</h3>

<p>R. Ashford and P.J. Walker. Quantal Response Analysis for a
Mixture of Populations. <em>Biometrics</em>, <b>28</b>, 981&ndash;988, 1972.
</p>


<h3>References</h3>

<p>D.A. Follmann and D. Lambert. Generalizing Logistic
Regression by Nonparametric Mixing. <em>Journal of the American
Statistical Association</em>, <b>84</b>(405), 195&ndash;300, 1989.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("trypanosome", package = "flexmix")
trypMix &lt;- initFlexmix(cbind(Dead, 1-Dead) ~ 1, k = 2, 
	               nrep = 5, data = trypanosome,
	               model = FLXMRglmfix(family = "binomial",
                           fixed = ~log(Dose)))
</code></pre>

<hr>
<h2 id='whiskey'>Survey Data on Brands of Scotch Whiskey Consumed</h2><span id='topic+whiskey'></span><span id='topic+whiskey_brands'></span>

<h3>Description</h3>

<p>The data set is from Simmons Study of Media and Markets and contains
the incidence matrix for scotch brands used in last year for those
households who report consuming scotch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("whiskey")</code></pre>


<h3>Format</h3>

<p>A data frame <code>whiskey</code> with 484 observations on the following 2
variables.
</p>

<dl>
<dt><code>Freq</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Incidence</code></dt><dd><p>a matrix with 21 columns</p>
</dd>
</dl>

<p>Additional information on the brands is contained in the data frame
<code>whiskey_brands</code> which is simultaneously loaded. This data frame
contains 21 observations on the following 3 variables.
</p>

<dl>
<dt><code>Brand</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>Type</code></dt><dd><p>a factor with levels <code>Blend</code> <code>Single Malt</code></p>
</dd>
<dt><code>Bottled</code></dt><dd><p>a factor with levels <code>Domestic</code> <code>Foreign</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset is taken from the <span class="pkg">bayesm</span> package. 
</p>


<h3>Source</h3>

<p>Peter Rossi and Rob McCulloch. bayesm: Bayesian Inference for
Marketing/Micro-econometrics. R package version 2.0-8, 2006.
http://gsbwww.uchicago.edu/fac/peter.rossi/research/bsm.html
</p>


<h3>References</h3>

<p>Edwards, Y. and G. Allenby. Multivariate Analysis of Multiple Response
Data, <em>Journal of Marketing Research</em>, <b>40</b>, 321&ndash;334, 2003.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
