<!DOCTYPE html><html><head><title>Help for package mbr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mbr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mbr'><p>mbr: Mass Balance Reconstruction</p></a></li>
<li><a href='#back_trans'><p>Back-transformation</p></a></li>
<li><a href='#calculate_metrics'><p>Reconstruction metrics</p></a></li>
<li><a href='#colScale'><p>Scale columns of a matrix</p></a></li>
<li><a href='#colUnscale'><p>Unscale columns of a matrix</p></a></li>
<li><a href='#cv_mb'><p>Cross-validation</p></a></li>
<li><a href='#KGE'><p>Kling-Gupta Efficiency</p></a></li>
<li><a href='#lsq_mb'><p>Least square with mass balance penalty</p></a></li>
<li><a href='#make_Z'><p>Make cross-validation folds.</p></a></li>
<li><a href='#mb_fit'><p>Fit parameters with mass balance criterion</p></a></li>
<li><a href='#mb_reconstruction'><p>Mass-balance-adjusted reconstruction</p></a></li>
<li><a href='#nRMSE'><p>Normalized root-mean-square error</p></a></li>
<li><a href='#NSE'><p>Nash-Sutcliffe Efficiency</p></a></li>
<li><a href='#obj_fun'><p>Objective function from parameters</p></a></li>
<li><a href='#p1Seasonal'><p>Seasonal streamflow at P.1 station</p></a></li>
<li><a href='#pc3seasons'><p>Principal components of tree rings</p></a></li>
<li><a href='#prepend_ones'><p>Prepend a column of ones</p></a></li>
<li><a href='#RE'><p>Reduction of Error</p></a></li>
<li><a href='#rowScale'><p>Scale rows of a Matrix</p></a></li>
<li><a href='#rowUnscale'><p>Unscale rows of a matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mass Balance Reconstruction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Hung Nguyen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hung Nguyen &lt;ntthung@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Mass-balance-adjusted Regression algorithm for streamflow reconstruction at sub-annual resolution (e.g., seasonal or monthly). The algorithm implements a penalty term to minimize the differences between the total sub-annual flows and the annual flow. The method is described in Nguyen et al (2020) &lt;<a href="https://doi.org/10.1002%2Fessoar.10504791.1">doi:10.1002/essoar.10504791.1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, dplR, MASS, Matrix, Rfast, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ntthung/mbr">https://github.com/ntthung/mbr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ntthung/mbr/issues">https://github.com/ntthung/mbr/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-12 12:06:00 UTC; ntthu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-16 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mbr'>mbr: Mass Balance Reconstruction</h2><span id='topic+mbr'></span><span id='topic+mbr-package'></span>

<h3>Description</h3>

<p>Mass-balance-adjusted Regression algorithm for streamflow reconstruction at sub-annual resolution (e.g., seasonal or monthly). The algorithm implements a penalty term to minimize the differences between the total sub-annual flows and the annual flow. The method is described in Nguyen et al (2020) &lt;DOI:10.1002/essoar.10504791.1&gt;.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ntthung/mbr">https://github.com/ntthung/mbr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ntthung/mbr/issues">https://github.com/ntthung/mbr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='back_trans'>Back-transformation</h2><span id='topic+back_trans'></span>

<h3>Description</h3>

<p>Transform the reconstructed values back to the flow space
and convert to data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>back_trans(hat, years, mus, sigmas, log.trans, N, season.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="back_trans_+3A_hat">hat</code></td>
<td>
<p>A vector of estimated flow in the transformed space.</p>
</td></tr>
<tr><td><code id="back_trans_+3A_years">years</code></td>
<td>
<p>A vector of all years in the study period</p>
</td></tr>
<tr><td><code id="back_trans_+3A_mus">mus</code></td>
<td>
<p>A vector of means, one for each target.</p>
</td></tr>
<tr><td><code id="back_trans_+3A_sigmas">sigmas</code></td>
<td>
<p>A vector of the standard deviations, one for each target.</p>
</td></tr>
<tr><td><code id="back_trans_+3A_log.trans">log.trans</code></td>
<td>
<p>A vector containing the indices of the columns to be log-transformed.</p>
</td></tr>
<tr><td><code id="back_trans_+3A_n">N</code></td>
<td>
<p>The number of targets (number of seasons plus one for the annual reconstruction).</p>
</td></tr>
<tr><td><code id="back_trans_+3A_season.names">season.names</code></td>
<td>
<p>A character vector containing the names of the seasons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with three columns: Q (the back-transformed streamflow), season, and year.
</p>

<hr>
<h2 id='calculate_metrics'>Reconstruction metrics</h2><span id='topic+calculate_metrics'></span>

<h3>Description</h3>

<p>Calculate reconstruction metrics from the instrumental period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_metrics(sim, obs, z, norm.fun = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_metrics_+3A_sim">sim</code></td>
<td>
<p>A vector of reconstruction output for instrumental period</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_obs">obs</code></td>
<td>
<p>A vector of all observations</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_z">z</code></td>
<td>
<p>A vector of left out indices in cross validation</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_norm.fun">norm.fun</code></td>
<td>
<p>The function (unquoted name) used to calculate the normalizing constant. Default is <code>mean()</code>, but other functions such as <code>sd()</code> can also be used. THe function must take a vector as input and return a scalar as output, and must have an argument <code>na.rm = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of performance metrics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calculate_metrics(rnorm(100), rnorm(100), z = 1:10)
calculate_metrics(rnorm(100), rnorm(100), z = 1:10, norm.fun = sd)
</code></pre>

<hr>
<h2 id='colScale'>Scale columns of a matrix</h2><span id='topic+colScale'></span>

<h3>Description</h3>

<p>Same as <code>base::scale()</code> but much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colScale(x, add_attr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colScale_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="colScale_+3A_add_attr">add_attr</code></td>
<td>
<p>If TRUE, the column means and standard deviations are returned as attributes. This is consistent with <code><a href="base.html#topic+scale">base::scale()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scaled matrix.
</p>


<h3>Reference</h3>

<p>This function was adopted from John Muschelli's code on <a href="https://hopstat.wordpress.com/2016/02/23/a-faster-scale-function/">StackOverflow</a>, but I changed the underlying functions to calculate mean and standard deviation from <code>matrixStats</code> to <code>Rfast</code>, which is much faster.
</p>

<hr>
<h2 id='colUnscale'>Unscale columns of a matrix</h2><span id='topic+colUnscale'></span>

<h3>Description</h3>

<p>Backtransform a matrix that was scaled before.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colUnscale(x, cm, csd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colUnscale_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="colUnscale_+3A_cm">cm</code></td>
<td>
<p>A vector of column means</p>
</td></tr>
<tr><td><code id="colUnscale_+3A_csd">csd</code></td>
<td>
<p>A vector of column standard deviations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unscaled matrix
</p>

<hr>
<h2 id='cv_mb'>Cross-validation</h2><span id='topic+cv_mb'></span>

<h3>Description</h3>

<p>Cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_mb(
  instQ,
  pc.list,
  cv.folds,
  start.year,
  lambda = 1,
  log.trans = NULL,
  force.standardize = FALSE,
  return.type = c("fval", "metrics", "metric means", "Q")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_mb_+3A_instq">instQ</code></td>
<td>
<p>Instrumental data, in the same order as pc.list. The &quot;season&quot; column must be a factor.</p>
</td></tr>
<tr><td><code id="cv_mb_+3A_pc.list">pc.list</code></td>
<td>
<p>List of PC matrices</p>
</td></tr>
<tr><td><code id="cv_mb_+3A_cv.folds">cv.folds</code></td>
<td>
<p>A list containing the cross validation folds</p>
</td></tr>
<tr><td><code id="cv_mb_+3A_start.year">start.year</code></td>
<td>
<p>The first year of record</p>
</td></tr>
<tr><td><code id="cv_mb_+3A_lambda">lambda</code></td>
<td>
<p>The penalty weight</p>
</td></tr>
<tr><td><code id="cv_mb_+3A_log.trans">log.trans</code></td>
<td>
<p>A vector containing indices of the targets to be log-transformed. If no transformation is needed, provide <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cv_mb_+3A_force.standardize">force.standardize</code></td>
<td>
<p>If TRUE, all observations are standardized. See Details.</p>
</td></tr>
<tr><td><code id="cv_mb_+3A_return.type">return.type</code></td>
<td>
<p>The type of results to be returned. Several types are possible to suit multiple use cases.
</p>

<dl>
<dt><code>fval</code></dt><dd><p>Only the objective function value (penalized least squares) is returned; this is useful for the outer optimization for site selection.</p>
</dd>
<dt><code>metrics</code></dt><dd><p>all performance metrics are returned.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;metric means&#8288;</code></dt><dd><p>the Tukey's biweight robust mean of each metric is returned.</p>
</dd>
<dt><code>Q</code></dt><dd><p>The predicted flow in each cross-validation run is returned. This is the most basic output, so that you can use it to calculate other metrics that are not provided by the package.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> containing cross-validation results (metrics, fval, or metric means) for each target.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cvFolds &lt;- make_Z(1922:2003, nRuns = 50, frac = 0.25, contiguous = TRUE)
cv &lt;- cv_mb(p1Seasonal, pc3seasons, cvFolds, 1750, log.trans = 1:3, return.type = 'metrics')
</code></pre>

<hr>
<h2 id='KGE'>Kling-Gupta Efficiency</h2><span id='topic+KGE'></span>

<h3>Description</h3>

<p>Kling-Gupta Efficiency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KGE(yhat, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KGE_+3A_yhat">yhat</code></td>
<td>
<p>Model outputs</p>
</td></tr>
<tr><td><code id="KGE_+3A_y">y</code></td>
<td>
<p>Observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>KGE value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KGE(rnorm(100), rnorm(100))
</code></pre>

<hr>
<h2 id='lsq_mb'>Least square with mass balance penalty</h2><span id='topic+lsq_mb'></span>

<h3>Description</h3>

<p>Least square with mass balance penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsq_mb(hat, obs, lambda, mus, sigmas, log.seasons, log.ann, N, sInd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsq_mb_+3A_hat">hat</code></td>
<td>
<p>A vector of estimated flow in the transformed space.</p>
</td></tr>
<tr><td><code id="lsq_mb_+3A_obs">obs</code></td>
<td>
<p>A vector of observed flow in the transformed space.</p>
</td></tr>
<tr><td><code id="lsq_mb_+3A_lambda">lambda</code></td>
<td>
<p>Penalty weight.</p>
</td></tr>
<tr><td><code id="lsq_mb_+3A_mus">mus</code></td>
<td>
<p>A vector of means, one for each target.</p>
</td></tr>
<tr><td><code id="lsq_mb_+3A_sigmas">sigmas</code></td>
<td>
<p>A vector of the standard deviations, one for each target.</p>
</td></tr>
<tr><td><code id="lsq_mb_+3A_log.seasons">log.seasons</code></td>
<td>
<p>A vector containing the indices of the seasons that are log-transformed.</p>
</td></tr>
<tr><td><code id="lsq_mb_+3A_log.ann">log.ann</code></td>
<td>
<p>TRUE if the annual reconstruction is log-transformed.</p>
</td></tr>
<tr><td><code id="lsq_mb_+3A_n">N</code></td>
<td>
<p>The number of targets (number of seasons plus one for the annual reconstruction).</p>
</td></tr>
<tr><td><code id="lsq_mb_+3A_sind">sInd</code></td>
<td>
<p>Indices of the seasons, i.e, 1...N-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objective function value: least squares plus a penalty term.
</p>

<hr>
<h2 id='make_Z'>Make cross-validation folds.</h2><span id='topic+make_Z'></span>

<h3>Description</h3>

<p>Make a list of cross-validation folds. Each element of the list is a vector of the cross-validation points for one cross-validation run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Z(obs, nRuns = 30, frac = 0.1, contiguous = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Z_+3A_obs">obs</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="make_Z_+3A_nruns">nRuns</code></td>
<td>
<p>Number of repetitions.</p>
</td></tr>
<tr><td><code id="make_Z_+3A_frac">frac</code></td>
<td>
<p>Fraction of left-out points. For leave-one-out, use <code>frac = 1</code>, otherwise use any value less than 1. Default is 0.1 (leave-10%-out).</p>
</td></tr>
<tr><td><code id="make_Z_+3A_contiguous">contiguous</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, the left-out points are made in contiguous blocks; otherwise, they are scattered randomly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cross-validation folds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- make_Z(p1Seasonal$Qa, nRuns = 30, frac = 0.25, contiguous = TRUE)
</code></pre>

<hr>
<h2 id='mb_fit'>Fit parameters with mass balance criterion</h2><span id='topic+mb_fit'></span>

<h3>Description</h3>

<p>Fit parameters with mass balance criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_fit(X, Y, lambda, mus, sigmas, log.seasons, log.ann, N, sInd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_fit_+3A_x">X</code></td>
<td>
<p>Inputs, must have columns of 1 added</p>
</td></tr>
<tr><td><code id="mb_fit_+3A_y">Y</code></td>
<td>
<p>Observed Dry, Wet, and Annual log-transformed flows</p>
</td></tr>
<tr><td><code id="mb_fit_+3A_lambda">lambda</code></td>
<td>
<p>Penalty weight.</p>
</td></tr>
<tr><td><code id="mb_fit_+3A_mus">mus</code></td>
<td>
<p>A vector of means, one for each target.</p>
</td></tr>
<tr><td><code id="mb_fit_+3A_sigmas">sigmas</code></td>
<td>
<p>A vector of the standard deviations, one for each target.</p>
</td></tr>
<tr><td><code id="mb_fit_+3A_log.seasons">log.seasons</code></td>
<td>
<p>A vector containing the indices of the seasons that are log-transformed.</p>
</td></tr>
<tr><td><code id="mb_fit_+3A_log.ann">log.ann</code></td>
<td>
<p>TRUE if the annual reconstruction is log-transformed.</p>
</td></tr>
<tr><td><code id="mb_fit_+3A_n">N</code></td>
<td>
<p>The number of targets (number of seasons plus one for the annual reconstruction).</p>
</td></tr>
<tr><td><code id="mb_fit_+3A_sind">sInd</code></td>
<td>
<p>Indices of the seasons, i.e, 1...N-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-column matrix of beta value
</p>

<hr>
<h2 id='mb_reconstruction'>Mass-balance-adjusted reconstruction</h2><span id='topic+mb_reconstruction'></span>

<h3>Description</h3>

<p>Mass-balance-adjusted reconstruction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mb_reconstruction(
  instQ,
  pc.list,
  start.year,
  lambda = 1,
  log.trans = NULL,
  force.standardize = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mb_reconstruction_+3A_instq">instQ</code></td>
<td>
<p>Instrumental data, in the same order as pc.list. The &quot;season&quot; column must be a factor.</p>
</td></tr>
<tr><td><code id="mb_reconstruction_+3A_pc.list">pc.list</code></td>
<td>
<p>List of PC matrices. The first element is for the first season, second element for second season, and so on. The last element is for the annual reconstruction.</p>
</td></tr>
<tr><td><code id="mb_reconstruction_+3A_start.year">start.year</code></td>
<td>
<p>The first year of record</p>
</td></tr>
<tr><td><code id="mb_reconstruction_+3A_lambda">lambda</code></td>
<td>
<p>The penalty weight</p>
</td></tr>
<tr><td><code id="mb_reconstruction_+3A_log.trans">log.trans</code></td>
<td>
<p>A vector containing indices of the targets to be log-transformed. If no transformation is needed, provide <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mb_reconstruction_+3A_force.standardize">force.standardize</code></td>
<td>
<p>If TRUE, all observations are standardized. See Details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with the following columns: season, year, Q, and lambda.
</p>


<h3>Details</h3>

<p>If some targets are log transformed and some are not, they will have different scales, which affects the objective function. In this case the observations will be standardized so that they are in the same range. Otherwise, standardization are skipped for speed. However, in some cases you may want to standardize any ways, for example when flows in some months are much larger than in other months. In this case, set <code>force.standardize = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mb_reconstruction(p1Seasonal, pc3seasons, 1750, lambda = 1, log.trans = 1:3)
</code></pre>

<hr>
<h2 id='nRMSE'>Normalized root-mean-square error</h2><span id='topic+nRMSE'></span>

<h3>Description</h3>

<p>RMSE is normalized by the normalization constant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nRMSE(yhat, y, normConst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nRMSE_+3A_yhat">yhat</code></td>
<td>
<p>Model outputs</p>
</td></tr>
<tr><td><code id="nRMSE_+3A_y">y</code></td>
<td>
<p>Observations</p>
</td></tr>
<tr><td><code id="nRMSE_+3A_normconst">normConst</code></td>
<td>
<p>The normalization constant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalized RMSE value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100)
nRMSE(x, y, sd(y))
</code></pre>

<hr>
<h2 id='NSE'>Nash-Sutcliffe Efficiency</h2><span id='topic+NSE'></span>

<h3>Description</h3>

<p>Nash-Sutcliffe Efficiency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSE(yhat, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NSE_+3A_yhat">yhat</code></td>
<td>
<p>Model outputs</p>
</td></tr>
<tr><td><code id="NSE_+3A_y">y</code></td>
<td>
<p>Observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NSE value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NSE(rnorm(100), rnorm(100))
</code></pre>

<hr>
<h2 id='obj_fun'>Objective function from parameters</h2><span id='topic+obj_fun'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>lsq_mb()</code>. It first calculates <code>hat</code>, then calls <code>lsq_mb()</code>.
This is used in <code>optim()</code>, so it returns a scalar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_fun(beta, X, Y, lambda, mus, sigmas, log.seasons, log.ann, N, sInd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_fun_+3A_beta">beta</code></td>
<td>
<p>Parameters</p>
</td></tr>
<tr><td><code id="obj_fun_+3A_x">X</code></td>
<td>
<p>Inputs, must have columns of 1 added</p>
</td></tr>
<tr><td><code id="obj_fun_+3A_y">Y</code></td>
<td>
<p>Observed Dry, Wet, and Annual log-transformed flows</p>
</td></tr>
<tr><td><code id="obj_fun_+3A_lambda">lambda</code></td>
<td>
<p>Penalty weight.</p>
</td></tr>
<tr><td><code id="obj_fun_+3A_mus">mus</code></td>
<td>
<p>A vector of means, one for each target.</p>
</td></tr>
<tr><td><code id="obj_fun_+3A_sigmas">sigmas</code></td>
<td>
<p>A vector of the standard deviations, one for each target.</p>
</td></tr>
<tr><td><code id="obj_fun_+3A_log.seasons">log.seasons</code></td>
<td>
<p>A vector containing the indices of the seasons that are log-transformed.</p>
</td></tr>
<tr><td><code id="obj_fun_+3A_log.ann">log.ann</code></td>
<td>
<p>TRUE if the annual reconstruction is log-transformed.</p>
</td></tr>
<tr><td><code id="obj_fun_+3A_n">N</code></td>
<td>
<p>The number of targets (number of seasons plus one for the annual reconstruction).</p>
</td></tr>
<tr><td><code id="obj_fun_+3A_sind">sInd</code></td>
<td>
<p>Indices of the seasons, i.e, 1...N-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objective function value
</p>

<hr>
<h2 id='p1Seasonal'>Seasonal streamflow at P.1 station</h2><span id='topic+p1Seasonal'></span>

<h3>Description</h3>

<p>Streamflow at P.1 station (Chiang Mai, Thailand) for three reconstruction targets: dry season (NJ, Nov-Jun), wet season (JO, Jul-Oct), and water year (WY, Nov-Oct), as used by Nguyen et al (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p1Seasonal
</code></pre>


<h3>Format</h3>

<p>A data table with 246 rows and 3 variables:
</p>

<dl>
<dt>season</dt><dd><p>a factor with three levels: &quot;NJ&quot;, &quot;JO&quot;, and &quot;WY&quot;</p>
</dd>
<dt>year</dt><dd><p>integer, from 1922 to 2003</p>
</dd>
<dt>Qa</dt><dd><p>Annual flow for each target</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.essoar.org/doi/10.1002/essoar.10504791.1">https://www.essoar.org/doi/10.1002/essoar.10504791.1</a>
</p>


<h3>References</h3>

<p>Nguyen, H. T. T., Galelli, S., Xu, C., &amp; Buckley, B. (2020). Multi-Proxy, Multi-Season Streamflow Reconstruction with Mass Balance Adjustment. Earth and Space Science Open Archive, 22. https://doi.org/10.1002/essoar.10504791.1
</p>

<hr>
<h2 id='pc3seasons'>Principal components of tree rings</h2><span id='topic+pc3seasons'></span>

<h3>Description</h3>

<p>Principal components of the Southeast Asian Dendrochronology Network, after appropriate sites have been selected for each season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc3seasons
</code></pre>


<h3>Format</h3>

<p>A list with three elements (NJ, JO, and WY), each element is a principal component matrix.
</p>


<h3>Source</h3>

<p><a href="https://www.essoar.org/doi/10.1002/essoar.10504791.1">https://www.essoar.org/doi/10.1002/essoar.10504791.1</a>
</p>


<h3>References</h3>

<p>Nguyen, H. T. T., Galelli, S., Xu, C., &amp; Buckley, B. (2020). Multi-Proxy, Multi-Season Streamflow Reconstruction with Mass Balance Adjustment. Earth and Space Science Open Archive, 22. https://doi.org/10.1002/essoar.10504791.1
</p>

<hr>
<h2 id='prepend_ones'>Prepend a column of ones</h2><span id='topic+prepend_ones'></span>

<h3>Description</h3>

<p>Prepend a column of ones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepend_ones(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepend_ones_+3A_x">x</code></td>
<td>
<p>The input matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x with a column of ones prepended, which is named 'Int' for 'intercept'
</p>

<hr>
<h2 id='RE'>Reduction of Error</h2><span id='topic+RE'></span>

<h3>Description</h3>

<p>Reduction of Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RE(yhat, y, yc_bar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RE_+3A_yhat">yhat</code></td>
<td>
<p>Model outputs in the validation set</p>
</td></tr>
<tr><td><code id="RE_+3A_y">y</code></td>
<td>
<p>Observations in the validation set</p>
</td></tr>
<tr><td><code id="RE_+3A_yc_bar">yc_bar</code></td>
<td>
<p>Mean observations in the calibration set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RE value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100)
yc_bar &lt;- mean(x[1:50])
RE(x[51:100], y[51:100], yc_bar)
</code></pre>

<hr>
<h2 id='rowScale'>Scale rows of a Matrix</h2><span id='topic+rowScale'></span>

<h3>Description</h3>

<p>Similar to <a href="#topic+colScale">colScale</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowScale(x, add_attr = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowScale_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="rowScale_+3A_add_attr">add_attr</code></td>
<td>
<p>If TRUE, the column means and standard deviations are returned as attributes. This is consistent with <code><a href="base.html#topic+scale">base::scale()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scaled matrix.
</p>

<hr>
<h2 id='rowUnscale'>Unscale rows of a matrix</h2><span id='topic+rowUnscale'></span>

<h3>Description</h3>

<p>Backtransform a matrix that was scaled before.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowUnscale(x, rm, rsd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowUnscale_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="rowUnscale_+3A_rm">rm</code></td>
<td>
<p>A vector of row means</p>
</td></tr>
<tr><td><code id="rowUnscale_+3A_rsd">rsd</code></td>
<td>
<p>A vector of row standard deviations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unscaled matrix
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
