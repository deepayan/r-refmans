<!DOCTYPE html><html lang="en"><head><title>Help for package VBLPCM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VBLPCM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#VBLPCM-package'><p>VBLPCM: Variational Bayes for the Latent Position Cluster Model for networks</p></a></li>
<li><a href='#aids.net'><p>aids blogs data as a &ldquo;network&quot; object</p></a></li>
<li><a href='#E_to_Y'><p>create an adjacency matrix from an edgelist.</p></a></li>
<li><a href='#fruchterman_reingold'><p>Perform Fruchterman-Reingold layout of a network in 2 or more dimensions.</p></a></li>
<li><a href='#gof.vblpcm'><p>Goodness of fit based on simulations from the fitted object.</p></a></li>
<li><a href='#hops_to_hopslist'><p>create a handy matrix of vectors to store the hopslist</p></a></li>
<li><a href='#log_like_forces'><p>create an initial configuration for the latent positions.</p></a></li>
<li><a href='#plot.vblpcm'><p>plot the posterior latent positions and groupings and network</p></a></li>
<li><a href='#predict.vblpcm'><p>Find all link probabilities</p></a></li>
<li><a href='#print.vblpcm'><p>print the fitted vblpcm object</p></a></li>
<li><a href='#sampson'><p>Cumulative network of positive affection within a monastery as a &ldquo;network&rdquo; object</p></a></li>
<li><a href='#simulated.network'><p>simulated.network</p></a></li>
<li><a href='#summary.vblpcm'><p>summary of a fitted vblpcm object.</p></a></li>
<li><a href='#VBLPCM-internal'><p>Internal VBLPCM objects</p></a></li>
<li><a href='#vblpcmbic'><p>calculate the BIC for the fitted VBLPCM object</p></a></li>
<li><a href='#vblpcmcovs'><p>create the design matrix for the network analysis</p></a></li>
<li><a href='#vblpcmdrawpie'><p>add a piechart of group memberships of a node to a network plot; taken mainly from latentnet equivalent</p></a></li>
<li><a href='#vblpcmfit'><p>fit the variational model through EM type iterations</p></a></li>
<li><a href='#vblpcmgroups'><p>list the maximum VB a-posteriori group memberships.</p></a></li>
<li><a href='#vblpcmKL'><p>print and returns the Kullback-Leibler divergence from the fitted vblpcm object to the true</p>
LPCM posterior</a></li>
<li><a href='#vblpcmroc'><p>ROC curve plot for vblpcmfit</p></a></li>
<li><a href='#vblpcmstart'><p>Generate sensible starting configuration for the variational parameter set.</p></a></li>
<li><a href='#Y_to_E'><p>calculate the edgelist for a given adjacency matrix</p></a></li>
<li><a href='#Y_to_M'><p>calculate the missing edges as an edgelist from an adjacency matrix with NaNs indicating</p>
missing links</a></li>
<li><a href='#Y_to_nonE'><p>calculate a non-edge list from an adjacency matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variational Bayes Latent Position Cluster Model for Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Salter-Townshend</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Salter-Townshend &lt;mike.saltertownshend@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit and simulate latent position and cluster models for network data, using a fast Variational Bayes approximation developed in Salter-Townshend and Murphy (2013) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2012.08.004">doi:10.1016/j.csda.2012.08.004</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>ergm, network</td>
</tr>
<tr>
<td>Imports:</td>
<td>mclust, sna</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Gnu Scientific Library</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>, <a href="https://mststats.github.io/#software">https://mststats.github.io/#software</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-22 15:36:25 UTC; mst</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='VBLPCM-package'>VBLPCM: Variational Bayes for the Latent Position Cluster Model for networks
</h2><span id='topic+VBLPCM-package'></span><span id='topic+VBLPCM'></span>

<h3>Description</h3>

<p>A faster approximate alternative to using latentnet. Interfaces C code to fit a
Variational Bayes approximation to the posterior for the Latent Position Cluster Model for networks. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> VBLPCM</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 2.4.9</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2023-03-22</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL (&gt;=2) </td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>This package is designed to be used as an alternative to the latentnet package when network
size computationally prohibits latentnet. It uses a Variational Bayesian Expectation Maximisation algorithm
to compute a closed-form approximation to the posterior that the ergmm function in latentnet samples
from. It may be thought of as an intermediary approximation that is more accurate than
the two-stage MLE fit provided by latentnet but a faster approximation to the MCMC sampler provided
by latentnet. In fact, the VB iterations also converge quicker than the two-stage MLE. 
</p>
<p>VBLPCM can also take advantage of the stratified sampler of Adrian Raftery, Xiaoyue Niu, Peter
Hoff and Ka Yee Yeung. This approximation to the (log)likelihood allows for even larger networks to
be analysed (see tech report below). Rather than using a fixed number of &quot;controls&quot; per geodesic
distance we set a probability of sampling each non-link at each level. 
</p>
<p>We also provide four choices of model; these are &quot;plain&quot; and three with random node-specific social effects. 
&quot;rsender&quot; for sender random effects, &quot;rreceiver&quot; for receiver random effects and &quot;rsocial&quot; for both. 
For undirected networks only &quot;plain&quot; or &quot;rsocial&quot; may be chosen. 
</p>


<h3>References</h3>

<p>Michael Salter-Townshend and Thomas Brendan Murphy (2013).
&quot;Variational Bayesian Inference for the Latent Position Cluster Model.&quot;
Computational Statistics and Data Analysis, volume 57, number 1, pages 661-671.
DOI=10.1016/j.csda.2012.08.004
</p>
<p>Pavel N. Krivitsky and Mark S. Handcock (2008). 
&quot;Fitting Latent Cluster Models for Social Networks with latentnet.&quot;
Journal of Statistical Software, number 5, volume 24, pages 1-23. 
</p>
<p>Mark S. Handcock, Adrian E. Raftery and Jeremy Tantrum (2007).
&quot;Model-Based Clustering for Social Networks.&quot;  
Journal of the Royal Statistical Society: Series A (Statistics in Society), 170(2), 301-354.
</p>
<p>Adrian Raftery, Xiaoyue Niu, Peter Hoff and Ka Yee Yeung (2012). 
&quot;Fast Inference for the Latent Space Network Model Using a Case-Control Approximate Likelihood.&quot;
Journal of Computational and Graphical Statistics. 
doi: 10.1080/10618600.2012.679240 
</p>
<p>Sucharita Gopal (2007). 
&quot;The Evolving Social Geography of Blogs&quot;
Societies and Cities in the Age of Instant Access Berlin:Springer, 275&ndash;294
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vblpcmstart">vblpcmstart</a></code>
<code><a href="#topic+vblpcmfit">vblpcmfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Sampson's monks with sender random effects ###
data(sampson,package="VBLPCM")
v.start&lt;-vblpcmstart(samplike,G=3,model="rreceiver",LSTEPS=1e3)
v.fit&lt;-vblpcmfit(v.start,STEPS=20)
### plot the mean posterior positions ###
plot(v.fit, R2=0.05,main="Sampson's Monks: VB with Receiver Random Effects")
### Who's in each group?  ###
vblpcmgroups(v.fit)

### Look at a goodness-of-fit plot ###
plot(gof(v.fit,GOF=~distance))

### create a matrix of link posterior probabilities given the fitted model ###
probs&lt;-predict.vblpcm(v.fit)
### create a boxplot goodness-of-fit graphic ###
boxplot(split(probs,as.sociomatrix(samplike)))

### run a bigger example, using the likelihood sampler set to 0.1 ###
## Not run: 
data(aids,package="VBLPCM")
v.start&lt;-vblpcmstart(aids.net,G=7,model="rsender",d=3)
use the case-control sampler with 10 controls per case
v.fit&lt;-vblpcmfit(v.start,NC=10)
plot the mean posterior positions ###
plot(v.fit, R2=0.1,main="Aids Blogs with Sender Random Effects")

### Use ROC / AUC to get a measure of model fit to the data ###
vblpcmroc(v.fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='aids.net'>aids blogs data as a &ldquo;network&quot; object</h2><span id='topic+aids'></span><span id='topic+aids.net'></span>

<h3>Description</h3>

<p>Network of citations among blogs related to AIDS, patients, and their support networks, collected by Gopal, over a three-day period in August 2005. 
A directed graph representing
the pattern of citation among 146 unique blogs related to AIDS, patients,
and their support networks, collected by Gopal over a randomly selected
three-day period in August 2005.  Vertices correspond to blogs.  A directed
edge from one blog to another indicates that the former had a link to the
latter in their web page (more specifically, the former refers to the latter
in their so-called 'blogroll').
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(aids)
</code></pre>


<h3>Source</h3>

<p>http://math.bu.edu/people/kolaczyk/datasets/AIDSBlog.zip
</p>


<h3>References</h3>

<p>S. Gopal, &quot;The evolving social geography of blogs,&quot; in Societies
and CIties in the Age of Instant Access, H. Miller, Ed.   Berlin:Springer,
2007, pp. 275-294
</p>


<h3>See Also</h3>

<p>network, plot.network, VBLPCM</p>

<hr>
<h2 id='E_to_Y'>create an adjacency matrix from an edgelist. 
</h2><span id='topic+E_to_Y'></span>

<h3>Description</h3>

<p>uses a call to C to transform edgelist to adjacency matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E_to_Y(N, NE, directed, E)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="E_to_Y_+3A_n">N</code></td>
<td>
<p>number of nodes
</p>
</td></tr>
<tr><td><code id="E_to_Y_+3A_ne">NE</code></td>
<td>
<p>number of edges
</p>
</td></tr>
<tr><td><code id="E_to_Y_+3A_directed">directed</code></td>
<td>
<p>logical indicator of directedness (TRUE=&gt;directed, FALSE=&gt;undirected
</p>
</td></tr>
<tr><td><code id="E_to_Y_+3A_e">E</code></td>
<td>
<p>the input edgelist
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NxN sociomatrix / adjacency matrix
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>sociomatrix, Y_to_E
</p>

<hr>
<h2 id='fruchterman_reingold'>Perform Fruchterman-Reingold layout of a network in 2 or more dimensions.
</h2><span id='topic+fruchterman_reingold'></span>

<h3>Description</h3>

<p>This was written and incorporated into the VBLPCM package because the
Fruchterman-Reingold routine in the network package only works in two dimensions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fruchterman_reingold(net, D=2, steps=1000, repulserad=N^D, m=N*(D-1), 
                            volume=N*(D-1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fruchterman_reingold_+3A_net">net</code></td>
<td>
<p>network object on which to perform Fruchterman-Reingold layout.
</p>
</td></tr>
<tr><td><code id="fruchterman_reingold_+3A_d">D</code></td>
<td>
<p>Desired dimension of the space in which to lay out the network.
</p>
</td></tr>
<tr><td><code id="fruchterman_reingold_+3A_steps">steps</code></td>
<td>
<p>Number of desired iterations. 
</p>
</td></tr>
<tr><td><code id="fruchterman_reingold_+3A_repulserad">repulserad</code></td>
<td>
<p>The radius at which repulsion and attraction of linked nodes are equal. 
</p>
</td></tr>
<tr><td><code id="fruchterman_reingold_+3A_m">m</code></td>
<td>
<p>The maximum change in position per iteration. 
</p>
</td></tr>
<tr><td><code id="fruchterman_reingold_+3A_volume">volume</code></td>
<td>
<p>The volume of space within which to position the nodes. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An N*D matrix of coordinates. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>log_like_forces
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### 2D example
### load the aids blogs dataset
data(aids)
### perform the Fruchterman-Reingold layout
X&lt;-fruchterman_reingold(aids.net, D=2, steps=1e3)
### plot the results
plot(X)

### 3D example
### load the aids blogs dataset
data(aids)
### perform the Fruchterman-Reingold layout
X&lt;-fruchterman_reingold(aids.net, D=3, steps=1e3)
### Not run
### plot the results in 3D
# library(rgl)
# plot3d(X)
</code></pre>

<hr>
<h2 id='gof.vblpcm'>Goodness of fit based on simulations from the fitted object. 
</h2><span id='topic+gof.vblpcm'></span>

<h3>Description</h3>

<p>Create a goodness of fit statistics and plots based on the degree distributions of networks simulated fitted 
from a fitted variational approximation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vblpcm'
gof(object, ...,
         nsim=100,
         GOF=NULL,
         verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gof.vblpcm_+3A_object">object</code></td>
<td>
<p>fitted VBLPCM object; usually output from vblpcmfit() or vblpcmstart()
</p>
</td></tr>
<tr><td><code id="gof.vblpcm_+3A_...">...</code></td>
<td>
<p>optional arguments for lower level functions
</p>
</td></tr>
<tr><td><code id="gof.vblpcm_+3A_nsim">nsim</code></td>
<td>
<p>number of networks to simulate
</p>
</td></tr>
<tr><td><code id="gof.vblpcm_+3A_gof">GOF</code></td>
<td>
<p>formula; an <span class="rlang"><b>R</b></span> formula object, of the form
<code>~ &lt;model terms&gt;</code> specifying the
statistics to use to diagnosis the goodness-of-fit of the model.
They do not need to be in the model formula specified in
<code>formula</code>, and typically are not.
Examples are the degree distribution (&quot;degree&quot;),
minimum geodesic distances (&quot;dist&quot;), and shared partner distributions
(&quot;espartners&quot; and &quot;dspartners&quot;).
For the details on the possible
<code>&lt;model terms&gt;</code>, see <code><a href="ergm.html#topic+ergm-terms">ergm-terms</a></code>.
</p>
</td></tr> 
<tr><td><code id="gof.vblpcm_+3A_verbose">verbose</code></td>
<td>
<p>Provide verbose information on the progress of the
simulation.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>A sample of graphs is randomly drawn from the posterior of the vblpcmfit() result. 
</p>
<p>A plot of the summary measures may then be plotted using plot().  
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>latentnet::gof.ergmm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sampson,package="VBLPCM")
v.start&lt;-vblpcmstart(samplike,G=3,model="rreceiver",LSTEPS=1e3)
v.fit&lt;-vblpcmfit(v.start,STEPS=20)
### plot the mean posterior positions
plot(v.fit, R2=0.05,main="Sampson's Monks: VB with Receiver Effects")
### Look at gof plots
plot(gof(v.fit,GOF=~distance,nsim=50))
</code></pre>

<hr>
<h2 id='hops_to_hopslist'>create a handy matrix of vectors to store the hopslist
</h2><span id='topic+hops_to_hopslist'></span>

<h3>Description</h3>

<p>Designed for nternal use only; store the geodesic distances in a handy format Each node gets a vector in the hopslist matrix. 
Each row describes a node and for each row: 
The first diam entries state the number of nodes that are that distance away by shortest path where diam is the 
maximum shortest path between two nodes (the graph diameter). 
eg if entry 3 in row 4 is a 5 then there are exactly 5 nodes that are 4 hops away from node 3. 
This vector is followed by the indices of all the nodes, grouped by the length of the shortest paths. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hops_to_hopslist(hops, diam, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hops_to_hopslist_+3A_hops">hops</code></td>
<td>
<p>matrix of geodesic distances
</p>
</td></tr>
<tr><td><code id="hops_to_hopslist_+3A_diam">diam</code></td>
<td>
<p>diameter of the network
</p>
</td></tr>
<tr><td><code id="hops_to_hopslist_+3A_n">N</code></td>
<td>
<p>total number of nodes in the network
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>

<hr>
<h2 id='log_like_forces'>create an initial configuration for the latent positions. 
</h2><span id='topic+log_like_forces'></span>

<h3>Description</h3>

<p>This performs an iterative relaxation type algorithm to approximately find the
positions of the nodes in the latent space that maximises the log-likelihood. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_like_forces(net, D, X, B, m ,steps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_like_forces_+3A_net">net</code></td>
<td>
<p>network object on which to perform layout. 
</p>
</td></tr>
<tr><td><code id="log_like_forces_+3A_d">D</code></td>
<td>
<p>dimension of the latent space.
</p>
</td></tr>
<tr><td><code id="log_like_forces_+3A_x">X</code></td>
<td>
<p>the initial guess for X
</p>
</td></tr>
<tr><td><code id="log_like_forces_+3A_b">B</code></td>
<td>
<p>the intercept term.
</p>
</td></tr>
<tr><td><code id="log_like_forces_+3A_m">m</code></td>
<td>
<p>usually N will suffice. 
</p>
</td></tr>
<tr><td><code id="log_like_forces_+3A_steps">steps</code></td>
<td>
<p>maximum number of iteration steps. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually only used internally in vblpcmstart()
</p>


<h3>Value</h3>

<p>Matrix of latent positions X 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>igraph::layout.fruchterman.reingold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sampson)
N=network.size(samplike)
X=matrix(runif(N*2,-2,2),ncol=2)
XX=vblpcmcovs(N,"plain",as.sociomatrix(samplike))
out&lt;-log_like_forces(samplike, 2, X, 0, m=N, 1e3)
plot(samplike,coord=out$X)
</code></pre>

<hr>
<h2 id='plot.vblpcm'>plot the posterior latent positions and groupings and network
</h2><span id='topic+plot.vblpcm'></span>

<h3>Description</h3>

<p>Plot the network using the estimated positions with clustering. The nodes are plotted
as pie-charts to show group membership probabilities. The group means are coloured crosses and the group
standard deviations are shown with coloured circles. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vblpcm'
plot(x, ..., R2 = 0.2, main = "Variational-Bayes Positions", 
                   alpha = 0.5, colours=1:x$G, RET=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.vblpcm_+3A_x">x</code></td>
<td>
<p>The fitted values; output from vblpcmfit()
</p>
</td></tr>
<tr><td><code id="plot.vblpcm_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to lower level functions
</p>
</td></tr>
<tr><td><code id="plot.vblpcm_+3A_r2">R2</code></td>
<td>
<p>scaling factor for the size of each node in the plot
</p>
</td></tr>
<tr><td><code id="plot.vblpcm_+3A_main">main</code></td>
<td>
<p>main title for the plot
</p>
</td></tr>
<tr><td><code id="plot.vblpcm_+3A_alpha">alpha</code></td>
<td>
<p>transparency of the links
</p>
</td></tr>
<tr><td><code id="plot.vblpcm_+3A_colours">colours</code></td>
<td>
<p>colours of the groups
</p>
</td></tr>
<tr><td><code id="plot.vblpcm_+3A_ret">RET</code></td>
<td>
<p>whether to return the 2D postions of nodes and clusters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the latent positions and clustering of a network fitted via vblpcmfit() or vblpcmstart()
</p>
<p>Each node appears in the latent space as a pie chart with segments size proportional to group memberships. 
The clusters are represented as circles in the latent space centred on the expected position of the group mean 
and with size proportional to the cluster standard deviation. 
</p>
<p>If applicable, the size of the pie charts represents the expected sociality effect of the node. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>latentnet::plot.ergmm
</p>

<hr>
<h2 id='predict.vblpcm'>Find all link probabilities
</h2><span id='topic+predict.vblpcm'></span>

<h3>Description</h3>

<p>generate a matrix of link probabilities based on the fitted VB model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vblpcm'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.vblpcm_+3A_object">object</code></td>
<td>
<p>The fitted values; output from vblpcmfit()
</p>
</td></tr>
<tr><td><code id="predict.vblpcm_+3A_...">...</code></td>
<td>
<p>optional additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The posterior predictive link probabilities given the fitted object
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sampson)
v.fit&lt;-vblpcmfit(vblpcmstart(samplike,G=3))
### create a matrix of link posterior probabilities given the fitted model
probs&lt;-predict.vblpcm(v.fit)
# show this graphically; separation of the boxes implies a good fit to the data
boxplot(split(probs,v.fit$Y),
        ylab=expression(paste("P(",Y[i][j],"=1)")),xlab=expression(paste(Y[i][j])))
</code></pre>

<hr>
<h2 id='print.vblpcm'>print the fitted vblpcm object
</h2><span id='topic+print.vblpcm'></span>

<h3>Description</h3>

<p>Print a vblpcm object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vblpcm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.vblpcm_+3A_x">x</code></td>
<td>
<p>The fitted values; output from vblpcmfit()
</p>
</td></tr>
<tr><td><code id="print.vblpcm_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to lower level functions
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>latentnet::print.ergmm
</p>

<hr>
<h2 id='sampson'>Cumulative network of positive affection within a monastery as a &ldquo;network&rdquo; object</h2><span id='topic+sampson'></span><span id='topic+samplike'></span>

<h3>Description</h3>

<p>Sampson (1969) recorded
the social interactions among a group of monks
while resident as an experimenter on vision, and collected
numerous sociometric rankings.  
During his stay, a political
&ldquo;crisis in the cloister&rdquo; resulted in the expulsion of four monks
(Nos. 2, 3, 17, and 18) and the voluntary departure of several
others - most immediately, Nos. 1, 7, 14, 15, and 16. (In the
end, only 5, 6, 9, and 11 remained).
Of particular interest
is the data on positive affect relations (&ldquo;liking&rdquo;), in which each
monk was asked if they had positive relations to each of the
other monks.
</p>
<p>The data were gathered at three times to capture changes in group sentiment
over time.
They were represent three time points in the period during which a
new cohort entered the monastery near the end of the study but
before the major conflict began. 
</p>
<p>Each member ranked only his top three choices on &ldquo;liking&rdquo;.
(Some subjects offered tied ranks for their top four choices).
A tie from monk A to monk B exists if A
nominated B as one of his three best friends at that that time point.
</p>
<p><code>samplike</code> is the time-aggregated network. 
It is the cumulative tie for &ldquo;liking&rdquo; over the three
periods.  For this, a tie from monk A to monk B exists if A
nominated B as one of his three best friends at any of the
three time points.
</p>
<p>This data is standard in the social network analysis
literature, having been modeled by Holland and Leinhardt
(1981), Reitz (1982), Holland, Laskey and Leinhardt (1983),
and Fienberg, Meyer, and Wasserman (1981), Hoff, Raftery, and Handcock
(2002), etc.
This is only a small piece of the data collected by Sampson.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(sampson)
</code></pre>


<h3>Source</h3>

<p>Sampson, S.~F. (1968), <em>A novitiate in a period of change: An
experimental and case study of relationships,</em> 
Unpublished ph.d. dissertation, Department of Sociology, Cornell University.
</p>


<h3>References</h3>

<p>White, H.C., Boorman, S.A. and Breiger, R.L. (1976).
<em>Social structure from multiple networks. I. Blockmodels of roles and
positions.</em>
American Journal of Sociology, 81(4), 730-780.
</p>


<h3>See Also</h3>

<p>network, plot.network, ergmm</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sampson)
plot(samplike)
</code></pre>

<hr>
<h2 id='simulated.network'>simulated.network</h2><span id='topic+Y'></span>

<h3>Description</h3>

<p>adjacency matrix simulated from the latent position cluster model with 3 well separated groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(simulated.network)
</code></pre>


<h3>Source</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>network, plot.network, VBLPCM</p>

<hr>
<h2 id='summary.vblpcm'>summary of a fitted vblpcm object. 
</h2><span id='topic+summary.vblpcm'></span>

<h3>Description</h3>

<p>Summarise the output of a call to either vblpcmstart or vblpcmfit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vblpcm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.vblpcm_+3A_object">object</code></td>
<td>
<p>The fitted values; output from vblpcmstart() or vblpcmfit()
</p>
</td></tr>
<tr><td><code id="summary.vblpcm_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to lower level functions
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>latentnet::summary.ergmm
</p>

<hr>
<h2 id='VBLPCM-internal'>Internal VBLPCM objects</h2><span id='topic+.onLoad'></span>

<h3>Description</h3>

<p>Internal VBLPCM objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='vblpcmbic'>calculate the BIC for the fitted VBLPCM object
</h2><span id='topic+vblpcmbic'></span>

<h3>Description</h3>

<p>calculate the BIC for the fitted VBLPCM object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vblpcmbic(v.params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vblpcmbic_+3A_v.params">v.params</code></td>
<td>
<p>The fitted values; output from vblpcmfit()
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BIC = BIC(edges | positions) + BIC(positions | clusters)
w/ BIC(edges | positions) = -2 loglikelihood + (P+1)log(number of edges) 
and BIC(positions | clusters) as per mclust
</p>


<h3>Value</h3>

<p>The scalar value of the BIC 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>References</h3>

<p>Mark S. Handcock, Adrian E. Raftery and Jeremy Tantrum (2007).
&quot;Model-Based Clustering for Social Networks.&quot;
Journal of the Royal Statistical Society: Series A (Statistics in Society), 170(2), 301-354.
</p>


<h3>See Also</h3>

<p>latentnet::summary.ergmm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sampson)
set.seed(1)
### plot the BIC for G=2,3,4 groups 
gbic&lt;-list(groups=NULL,bic=NULL)
for (g in 2:4)
  {
  v.fit&lt;-vblpcmfit(vblpcmstart(samplike,G=g,LSTEPS=1e3),STEPS=20)
  gbic$groups[g]=v.fit$G
  gbic$bic[g]=v.fit$BIC$overall
  }
plot(gbic$groups, gbic$bic, main="BIC results", xlab="# groups", ylab="BIC", t='b')
</code></pre>

<hr>
<h2 id='vblpcmcovs'>create the design matrix for the network analysis
</h2><span id='topic+vblpcmcovs'></span>

<h3>Description</h3>

<p>Add intercept (column of ones) and degree-based covariates (if model is for sociality effects)
to a user-supplied (default is NULL) edge covariates matrix of size N^2 rows and C columns where
C is the number of covariates. Node covariates may be converted to difference-between-pairs for
edges. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vblpcmcovs(N, model, Y, edgecovs=NULL, sendcovs=NULL, receivecovs=NULL,
                  socialcovs=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vblpcmcovs_+3A_n">N</code></td>
<td>
<p>number of nodes
</p>
</td></tr>
<tr><td><code id="vblpcmcovs_+3A_model">model</code></td>
<td>
<p>model; may be &quot;plain&quot;, &quot;rreceiver&quot;, &quot;rsender&quot; or &quot;rsocial&quot;. See Details. 
</p>
</td></tr>
<tr><td><code id="vblpcmcovs_+3A_y">Y</code></td>
<td>
<p>adjacency matrix
</p>
</td></tr>
<tr><td><code id="vblpcmcovs_+3A_edgecovs">edgecovs</code></td>
<td>
<p>optional additional covariate / attribute data on the edges
</p>
</td></tr>
<tr><td><code id="vblpcmcovs_+3A_sendcovs">sendcovs</code></td>
<td>
<p>optional additional covariate / attribute data on the nodes for links out
</p>
</td></tr>
<tr><td><code id="vblpcmcovs_+3A_receivecovs">receivecovs</code></td>
<td>
<p>optional additional covariate / attribute data on the nodes for links in
</p>
</td></tr> 
<tr><td><code id="vblpcmcovs_+3A_socialcovs">socialcovs</code></td>
<td>
<p>optional additional covariate / attribute data on the nodes for links in and out
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be used to construct design matrices with edge covariates or node covariates 
and / or sociality effects. &quot;rreceiver&quot;, &quot;rsender&quot; and &quot;rsocial&quot; model random social effects. 
Node covariates are differenced and treated as edge covariates. 
</p>


<h3>Value</h3>

<p>An edge design matrix that is Pe x N^2 and a node design matrix that is Pn x N
where Pe is the number of edge covariates and Pn is the number of node covariates. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>vblpcmstart
</p>

<hr>
<h2 id='vblpcmdrawpie'>add a piechart of group memberships of a node to a network plot; taken mainly from latentnet equivalent
</h2><span id='topic+vblpcmdrawpie'></span>

<h3>Description</h3>

<p>add a piechart of group memberships of a node to a network plot; taken mainly from latentnet equivalent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vblpcmdrawpie(center,radius,probs,n=50,colours=1:length(probs))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vblpcmdrawpie_+3A_center">center</code></td>
<td>
<p>where to postion the piechart
</p>
</td></tr>
<tr><td><code id="vblpcmdrawpie_+3A_radius">radius</code></td>
<td>
<p>radius of the piechart / node
</p>
</td></tr>
<tr><td><code id="vblpcmdrawpie_+3A_probs">probs</code></td>
<td>
<p>probability vector of cluster memberships
</p>
</td></tr>
<tr><td><code id="vblpcmdrawpie_+3A_n">n</code></td>
<td>
<p>order of polygon to approximate a circle
</p>
</td></tr>
<tr><td><code id="vblpcmdrawpie_+3A_colours">colours</code></td>
<td>
<p>the colours used; default is from palette()
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Thanks to Pavel N. Krivitsky of the latentnet package as I copied this from there. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>plot.vblpcm
</p>

<hr>
<h2 id='vblpcmfit'>fit the variational model through EM type iterations
</h2><span id='topic+vblpcmfit'></span>

<h3>Description</h3>

<p>Perform optimisation of the variational parameters of the variational approximation to
the posterior for the latent position cluster model for network data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vblpcmfit(variational.start, STEPS = 50, maxiter = 100, tol=1e-6, NC=NULL, 
           seed=NaN, d_vector=rep(TRUE,9))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vblpcmfit_+3A_variational.start">variational.start</code></td>
<td>
<p>The starting configuration; use vblpcmstart() to generate this. 
</p>
</td></tr>
<tr><td><code id="vblpcmfit_+3A_steps">STEPS</code></td>
<td>
<p>Maximum number of iterations in the main VBEM loop. 
</p>
</td></tr>
<tr><td><code id="vblpcmfit_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations for the internal univariate optimisation loops. 
</p>
</td></tr>
<tr><td><code id="vblpcmfit_+3A_tol">tol</code></td>
<td>
<p>tolerance of change in variational parameter updates below which the algorithm is deemed 
to have converged for that parameter. 
</p>
</td></tr>
<tr><td><code id="vblpcmfit_+3A_nc">NC</code></td>
<td>
<p>Number of non-links sampled in the case-control type sampler. 
Results in a speedup but loss of accuracy. 
</p>
</td></tr>
<tr><td><code id="vblpcmfit_+3A_seed">seed</code></td>
<td>
<p>Optional seed for the random number generator. Supplying NaN is equivalent to
not supplying it. Supply a value so that results may be replicated. 
</p>
</td></tr>
<tr><td><code id="vblpcmfit_+3A_d_vector">d_vector</code></td>
<td>
<p>Optional logical vector specifying which sets of variational parameters are to be
updated. See Details for more information. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>d_vector is a logical vector of length 9 that can be used to select which variational
parameters are held fixed and which are updated. The parameters are in the following order:
z (latent positions), sigma2 (variance of latent positions), lambda (membership probability 
matrix), eta (cluster centres), omega2 (cluster variances), alpha (cluster specific variance of
nodes), nu (Dirichlet parameter for marginal cluster probabilities), xi (likelihood intercept term 
mean), psi2 (likelihood intercept term variance). 
</p>


<h3>Value</h3>

<p>A v.params list containing the fitted variational parameters for the 
latent positions, clustering membership probabilities, etc. 
conv indicated whether convergence was obtained within the specified number of iterations. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>References</h3>

<p>Michael Salter-Townshend and Thomas Brendan Murphy (2009).
&quot;Variational Bayesian Inference for the Latent Position Cluster Model.&quot;
Workshop on Analyzing Networks and Learning with Graphs.
Neural Information Processing Systems.
</p>


<h3>See Also</h3>

<p>vblpcmstart, latentnet::ergmm
</p>

<hr>
<h2 id='vblpcmgroups'>list the maximum VB a-posteriori group memberships. 
</h2><span id='topic+vblpcmgroups'></span>

<h3>Description</h3>

<p>Prints to screen the most likely a-posteriori membership of each node. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vblpcmgroups(v.params, colours)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vblpcmgroups_+3A_v.params">v.params</code></td>
<td>
<p>The fitted values; output from vblpcmfit()
</p>
</td></tr>
<tr><td><code id="vblpcmgroups_+3A_colours">colours</code></td>
<td>
<p>The colours to be used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints to screen of the most probable group membership for each node. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>

<hr>
<h2 id='vblpcmKL'>print and returns the Kullback-Leibler divergence from the fitted vblpcm object to the true
LPCM posterior
</h2><span id='topic+vblpcmKL'></span>

<h3>Description</h3>

<p>print and returns the Kullback-Leibler divergence from the fitted vblpcm object to the true
LPCM posterior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vblpcmKL(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vblpcmKL_+3A_x">x</code></td>
<td>
<p>The fitted values; output from vblpcmfit() or vblpcmstart()
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The normalising constant of the posterior is unknown and therefore 
the Kullback-Leibler divergence is missing a constant. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>

<hr>
<h2 id='vblpcmroc'>ROC curve plot for vblpcmfit
</h2><span id='topic+vblpcmroc'></span>

<h3>Description</h3>

<p>Plot a Receiver Operating Curve to show model fit in terms of link prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vblpcmroc(v.params, NUM=100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vblpcmroc_+3A_v.params">v.params</code></td>
<td>
<p>The fitted values; output from vblpcmfit()
</p>
</td></tr>
<tr><td><code id="vblpcmroc_+3A_num">NUM</code></td>
<td>
<p>The number of intervals on the roc curve
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A threshold is varied between zero and one. At each point the probability of a link 
between all pairs of nodes is calculated on the v.params argument containing a fitted vblpcm object. 
If greater than the threshold the link is &quot;predicted&quot; present, else it is &quot;predicted&quot; absent. A plot 
of the proportion of true and false positives for each threshold value is thus obtained. 
</p>


<h3>Value</h3>

<p>The Area Under the Curve (AUC). The closer to 1 the better the fit. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>

<hr>
<h2 id='vblpcmstart'>Generate sensible starting configuration for the variational parameter set. 
</h2><span id='topic+vblpcmstart'></span>

<h3>Description</h3>

<p>Uses fast methods to generate sensible and coherent values for the parameters of the
variational method. There are returned as a list and that list may be passed directly to
vblpcmfit(). User specification of the configuration is recommended as tweaks to this list only. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vblpcmstart(g.network,G=1,d=2,LSTEPS=5e3,model="plain", CLUST=0, B=NULL,
           lcc=TRUE, edgecovs=NULL,sendcovs=NULL,receivecovs=NULL,
           socialcovs=NULL,START="FR", seed=NaN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vblpcmstart_+3A_g.network">g.network</code></td>
<td>
<p>a network object
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_g">G</code></td>
<td>
<p>Desired number of groups
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_d">d</code></td>
<td>
<p>Desired dimensionality of the latent space
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_lsteps">LSTEPS</code></td>
<td>
<p>Number of steps in the log-likelihood forces algorithm
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_model">model</code></td>
<td>
<p>model specified as &quot;plain&quot;, &quot;rreceiver&quot;, &quot;rsender&quot; or &quot;rsocial&quot;. See vblpcmcovs for details. 
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_clust">CLUST</code></td>
<td>
<p>degree of push to clustering at the start
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_b">B</code></td>
<td>
<p>default intercept value
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_lcc">lcc</code></td>
<td>
<p>logical indicator. TRUE =&gt; analyze largest connected component 
of g.network only FALSE =&gt; analyze the whole network. 
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_edgecovs">edgecovs</code></td>
<td>
<p>optional edge covariates.
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_sendcovs">sendcovs</code></td>
<td>
<p>optional sender node covariates.
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_receivecovs">receivecovs</code></td>
<td>
<p>optional receiver node covariates.
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_socialcovs">socialcovs</code></td>
<td>
<p>optional sociality node covariates.
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_start">START</code></td>
<td>
<p>what to start the initial positions with. 
&quot;FR&quot; for Fruchterman-Reingold. 
&quot;geodesic&quot; for geodesic distances.
&quot;laplace&quot; for using the Graph Laplacian.
&quot;random&quot; for random. 
</p>
</td></tr>
<tr><td><code id="vblpcmstart_+3A_seed">seed</code></td>
<td>
<p>Optional seed for the random number generator in R. Equivalent to using set.seed(seed). 
The default NaN value does not call set.seed(). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A v.params list containing the latent positions, clustering membership probabilities, etc. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>vblpcmfit, vblpcmcovs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sampson)
### plot the mean posterior positions with initial estimations for variational parameters
plot(vblpcmstart(samplike,G=3),main="Sampson's Monks: VB Initial Values")
### plot the mean posterior positions with final estimations for variational parameters
plot(vblpcmfit(vblpcmstart(samplike,G=3)),main="Sampson's Monks: VB Solution")
</code></pre>

<hr>
<h2 id='Y_to_E'>calculate the edgelist for a given adjacency matrix
</h2><span id='topic+Y_to_E'></span>

<h3>Description</h3>

<p>calls C code to quickly transform from adjacency to edgelist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y_to_E(N, NE, directed, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Y_to_E_+3A_n">N</code></td>
<td>
<p>number of nodes
</p>
</td></tr>
<tr><td><code id="Y_to_E_+3A_ne">NE</code></td>
<td>
<p>number of edges
</p>
</td></tr>
<tr><td><code id="Y_to_E_+3A_directed">directed</code></td>
<td>
<p>logical indicator of directedness; TRUE=&gt;directed FALSE=&gt;undirected
</p>
</td></tr>
<tr><td><code id="Y_to_E_+3A_y">Y</code></td>
<td>
<p>input adjacency matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edgelist matrix E of size NE x 2
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>edgelist, E_to_Y
</p>

<hr>
<h2 id='Y_to_M'>calculate the missing edges as an edgelist from an adjacency matrix with NaNs indicating
missing links
</h2><span id='topic+Y_to_M'></span>

<h3>Description</h3>

<p>uses C code to quickly find all pairs of nodes for which we do not know whether there
is a link or not, given an adjacency matrix with NaNs indicating unknown / unobserved linkage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y_to_M(N, NM, directed, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Y_to_M_+3A_n">N</code></td>
<td>
<p>number of nodes
</p>
</td></tr>
<tr><td><code id="Y_to_M_+3A_nm">NM</code></td>
<td>
<p>number of missing edges
</p>
</td></tr>
<tr><td><code id="Y_to_M_+3A_directed">directed</code></td>
<td>
<p>logical indicator of directedness; TRUE=&gt;directed FALSE=&gt;undirected
</p>
</td></tr>
<tr><td><code id="Y_to_M_+3A_y">Y</code></td>
<td>
<p>input adjacency matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of missing edges M
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>Y_to_E, E_to_Y, Y_to_nonE
</p>

<hr>
<h2 id='Y_to_nonE'>calculate a non-edge list from an adjacency matrix
</h2><span id='topic+Y_to_nonE'></span>

<h3>Description</h3>

<p>uses C code to quickly calculate all non-edges as a two column matrix given an
adjacency matrix. i.e. all zeros in the adjacency matrix will correspond to a row in the
non-edgelist nonE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y_to_nonE(N, NnonE, directed, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Y_to_nonE_+3A_n">N</code></td>
<td>
<p>number of nodes
</p>
</td></tr>
<tr><td><code id="Y_to_nonE_+3A_nnone">NnonE</code></td>
<td>
<p>number of non-edges
</p>
</td></tr>
<tr><td><code id="Y_to_nonE_+3A_directed">directed</code></td>
<td>
<p>logical indicator of directedness; TRUE=&gt;directed FALSE=&gt;undirected
</p>
</td></tr>
<tr><td><code id="Y_to_nonE_+3A_y">Y</code></td>
<td>
<p>input adjacency matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the non-edges with NnonE rows and 2 columns 
where NnonE is the number of non-edges. 
</p>


<h3>Author(s)</h3>

<p>Michael Salter-Townshend
</p>


<h3>See Also</h3>

<p>Y_to_E, Y_to_M, E_to_Y
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
