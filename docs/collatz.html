<!DOCTYPE html><html><head><title>Help for package collatz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {collatz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assert_sane_parameterication'><p>Sane Parameter Check</p></a></li>
<li><a href='#collatz'><p>Collatz</p></a></li>
<li><a href='#collatz_function'><p>The Collatz function</p></a></li>
<li><a href='#hailstone_sequence'><p>Hailstone Sequencer</p></a></li>
<li><a href='#reverse_function'><p>The &quot;inverse&quot;/&quot;reverse&quot; Collatz function</p></a></li>
<li><a href='#stopping_time'><p>Stopping Time</p></a></li>
<li><a href='#stopping_time_terminus'><p>Stopping Time Terminus</p></a></li>
<li><a href='#tree_graph'><p>Tree Graph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Functions Related to the Collatz/Syracuse/3n+1 Problem</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the basic functionality to interact with the Collatz conjecture.
    The parameterisation uses the same (P,a,b) notation as Conway's generalisations.
    Besides the function and reverse function, there is also functionality to retrieve
    the hailstone sequence, the "stopping time"/"total stopping time", or tree-graph. 
    The only restriction placed on parameters is that both P and a can't be 0.
    For further reading, see <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">https://en.wikipedia.org/wiki/Collatz_conjecture</a>.</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathan Levett [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathan Levett &lt;nathan.a.z.levett@gmail.com&gt;</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-08</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Skenvy/Collatz">https://github.com/Skenvy/Collatz</a>,
<a href="https://github.com/Skenvy/Collatz/tree/main/R">https://github.com/Skenvy/Collatz/tree/main/R</a>,
<a href="https://skenvy.github.io/Collatz/R/">https://skenvy.github.io/Collatz/R/</a>,
<a href="https://skenvy.github.io/Collatz/R/pdf/">https://skenvy.github.io/Collatz/R/pdf/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Skenvy/Collatz/issues/new/choose">https://github.com/Skenvy/Collatz/issues/new/choose</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), gmp</td>
</tr>
<tr>
<td>Collate:</td>
<td>'utils.R' 'collatz_function.R' 'hailstone_sequence.R'
'reverse_function.R' 'stopping_time.R' 'tree_graph.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxygen2, testthat (&ge; 3.0.0), devtools, covr, DT, pkgdown,
servr, tinytex, knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-03 15:41:28 UTC; root</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-05 08:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='assert_sane_parameterication'>Sane Parameter Check</h2><span id='topic+assert_sane_parameterication'></span>

<h3>Description</h3>

<p>Handles the sanity check for the parameterisation (P,a,b)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_sane_parameterication(P, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_sane_parameterication_+3A_p">P</code></td>
<td>
<p>Modulus used to devide n, iff n is equivalent to (0 mod P).</p>
</td></tr>
<tr><td><code id="assert_sane_parameterication_+3A_a">a</code></td>
<td>
<p>Factor by which to multiply n.</p>
</td></tr>
<tr><td><code id="assert_sane_parameterication_+3A_b">b</code></td>
<td>
<p>Value to add to the scaled value of n.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Required by both the function and reverse function, to assert that they
have sane parameters, otherwise will force stop the execution.
</p>

<hr>
<h2 id='collatz'>Collatz</h2><span id='topic+collatz'></span>

<h3>Description</h3>

<p>Functions related to the Collatz/Syracuse/3N+1 problem.
</p>


<h3>Details</h3>

<p>Provides the basic functionality to interact with the Collatz conjecture.
The parameterisation uses the same (P,a,b) notation as Conway's generalisations.
Besides the function and reverse function, there is also functionality to retrieve
the hailstone sequence, the &quot;stopping time&quot;/&quot;total stopping time&quot;, or tree-graph.
The only restriction placed on parameters is that both P and a can't be 0.
</p>

<hr>
<h2 id='collatz_function'>The Collatz function</h2><span id='topic+collatz_function'></span>

<h3>Description</h3>

<p>Returns the output of a single application of a Collatz-esque function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collatz_function(n, P = 2, a = 3, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collatz_function_+3A_n">n</code></td>
<td>
<p>(numeric|bigz) The value on which
to perform the Collatz-esque function</p>
</td></tr>
<tr><td><code id="collatz_function_+3A_p">P</code></td>
<td>
<p>(numeric|bigz): Modulus used to divide
n, iff n is equivalent to (0 mod P). Default is 2.</p>
</td></tr>
<tr><td><code id="collatz_function_+3A_a">a</code></td>
<td>
<p>(numeric|bigz) Factor by which to multiply n. Default is 3.</p>
</td></tr>
<tr><td><code id="collatz_function_+3A_b">b</code></td>
<td>
<p>(numeric|bigz) Value to add
to the scaled value of n. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will compute and return the result of applying one iteration
of a parameterised Collatz-esque function. Although it will operate with
integer inputs, for overflow safety, provide a gmp Big Integer ('bigz').
</p>


<h3>Value</h3>

<p>a numeric, either in-built or a bigz from the gmp library.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Returns the output of a single application of a Collatz-esque function.
# Without `gmp` or parameterisation, we can try something simple like
collatz_function(5)
collatz_function(16)
# If we want change the default parameterisation we can;
collatz_function(4, 5, 2, 3)
# Or if we only want to change one of them
collatz_function(3, a=-2)
# All the above work fine, but the function doesn't offer protection against
# overflowing integers by default. To venture into the world of arbitrary
# integer inputs we can use an `as.bigz` from `gmp`. Compare the two;
collatz_function(99999999999999999999)
collatz_function(as.bigz("99999999999999999999"))
</code></pre>

<hr>
<h2 id='hailstone_sequence'>Hailstone Sequencer</h2><span id='topic+hailstone_sequence'></span>

<h3>Description</h3>

<p>Calculates the values of a hailstone sequence, from an initial value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hailstone_sequence(
  initial_value,
  P = 2,
  a = 3,
  b = 1,
  max_total_stopping_time = 1000,
  total_stopping_time = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hailstone_sequence_+3A_initial_value">initial_value</code></td>
<td>
<p>(numeric|bigz)
The value to begin the hailstone sequence from.</p>
</td></tr>
<tr><td><code id="hailstone_sequence_+3A_p">P</code></td>
<td>
<p>(numeric|bigz): Modulus used to divide
n, iff n is equivalent to (0 mod P). Default is 2.</p>
</td></tr>
<tr><td><code id="hailstone_sequence_+3A_a">a</code></td>
<td>
<p>(numeric|bigz) Factor by which to multiply n. Default is 3.</p>
</td></tr>
<tr><td><code id="hailstone_sequence_+3A_b">b</code></td>
<td>
<p>(numeric|bigz) Value to add
to the scaled value of n. Default is 1.</p>
</td></tr>
<tr><td><code id="hailstone_sequence_+3A_max_total_stopping_time">max_total_stopping_time</code></td>
<td>
<p>(int) Maximum amount of times to iterate the
function, if 1 is not reached. Default is 1000.</p>
</td></tr>
<tr><td><code id="hailstone_sequence_+3A_total_stopping_time">total_stopping_time</code></td>
<td>
<p>(bool) Whether or not to execute until the &quot;total&quot;
stopping time (number of iterations to obtain 1) rather than the regular
stopping time (number of iterations to reach a value less than the initial
value). Default is TRUE.</p>
</td></tr>
<tr><td><code id="hailstone_sequence_+3A_verbose">verbose</code></td>
<td>
<p>(bool) If set to verbose, the hailstone sequence will include
control string sequences to provide information about how the
sequence terminated, whether by reaching a stopping time or entering
a cycle. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a list of successive values obtained by iterating a Collatz-esque
function, until either 1 is reached, or the total amount of iterations
exceeds max_total_stopping_time, unless total_stopping_time is FALSE, which
will terminate the hailstone at the &quot;stopping time&quot; value, i.e. the first
value less than the initial value. While the sequence has the capability to
determine that it has encountered a cycle, the cycle from &quot;1&quot; wont be
attempted or reported as part of a cycle, regardless of default or custom
parameterisation, as &quot;1&quot; is considered a &quot;total stop&quot;.
</p>


<h3>Value</h3>

<p>A keyed list consisting of a $values list of numeric | bigz
along with a $terminalCondition and $terminalStatus
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute a hailstone sequence, which defaults to the total stopping time;
hailstone_sequence(5)
# Or only compute down to the regular stopping time;
hailstone_sequence(5, total_stopping_time=FALSE)
# Remove verbose messaging;
hailstone_sequence(5, verbose=FALSE)
# It will also stop on finding a cycle;
hailstone_sequence(-56)
# And can be parameterised;
hailstone_sequence(3, -1, 3, 1)
# The hailstone sequence can run on `bigz`;
hailstone_sequence(27+as.bigz("576460752303423488"))
</code></pre>

<hr>
<h2 id='reverse_function'>The &quot;inverse&quot;/&quot;reverse&quot; Collatz function</h2><span id='topic+reverse_function'></span>

<h3>Description</h3>

<p>Calculates the values that would return the input under the Collatz function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_function(n, P = 2, a = 3, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_function_+3A_n">n</code></td>
<td>
<p>(numeric|bigz) The value on which
to perform the reverse Collatz function</p>
</td></tr>
<tr><td><code id="reverse_function_+3A_p">P</code></td>
<td>
<p>(numeric|bigz) Modulus used to divide
n, iff n is equivalent to (0 mod P) Default is 2.</p>
</td></tr>
<tr><td><code id="reverse_function_+3A_a">a</code></td>
<td>
<p>(numeric|bigz) Factor by which to multiply n. Default is 3.</p>
</td></tr>
<tr><td><code id="reverse_function_+3A_b">b</code></td>
<td>
<p>(numeric|bigz) Value to add
to the scaled value of n. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the output of a single application of a Collatz-esque reverse
function. If only one value is returned, it is the value that would be
divided by P. If two values are returned, the first is the value that
would be divided by P, and the second value is that which would undergo
the multiply and add step, regardless of which is larger.
</p>


<h3>Value</h3>

<p>A list of either numeric or bigz type
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculates the values that would return the input under the Collatz
# function. Without `gmp` or parameterisation, we can try something
# simple like
reverse_function(1)
reverse_function(2)
reverse_function(4)
# If we want change the default parameterisation we can;
reverse_function(3, -3, -2, -5)
# Or if we only want to change one of them
reverse_function(16, a=5)
# All the above work fine, but the function doesn't offer protection against
# overflowing integers by default. To venture into the world of arbitrary
# integer inputs we can use an `as.bigz` from `gmp`. Compare the two;
reverse_function(99999999999999999999)
reverse_function(as.bigz("99999999999999999999"))
</code></pre>

<hr>
<h2 id='stopping_time'>Stopping Time</h2><span id='topic+stopping_time'></span>

<h3>Description</h3>

<p>Determine the stopping time, or &quot;total&quot; stopping time, for an initial value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopping_time(
  initial_value,
  P = 2,
  a = 3,
  b = 1,
  max_stopping_time = 1000,
  total_stopping_time = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopping_time_+3A_initial_value">initial_value</code></td>
<td>
<p>(int): The value for which to find the stopping time.</p>
</td></tr>
<tr><td><code id="stopping_time_+3A_p">P</code></td>
<td>
<p>(numeric|bigz): Modulus used to divide
n, iff n is equivalent to (0 mod P). Default is 2.</p>
</td></tr>
<tr><td><code id="stopping_time_+3A_a">a</code></td>
<td>
<p>(numeric|bigz) Factor by which to multiply n. Default is 3.</p>
</td></tr>
<tr><td><code id="stopping_time_+3A_b">b</code></td>
<td>
<p>(numeric|bigz) Value to add
to the scaled value of n. Default is 1.</p>
</td></tr>
<tr><td><code id="stopping_time_+3A_max_stopping_time">max_stopping_time</code></td>
<td>
<p>(int) Maximum amount of times to iterate the
function, if the stopping time is not reached. IF the max_stopping_time
is reached, the function will return NaN. Default is 1000.</p>
</td></tr>
<tr><td><code id="stopping_time_+3A_total_stopping_time">total_stopping_time</code></td>
<td>
<p>(bool) Whether or not to execute until the &quot;total&quot;
stopping time (number of iterations to obtain 1) rather than the regular
stopping time (number of iterations to reach a value less than the initial
value). Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the stopping time, the amount of iterations required to reach a
value less than the initial value, or NaN if max_stopping_time is exceeded.
Alternatively, if total_stopping_time is TRUE, then it will instead count
the amount of iterations to reach 1. If the sequence does not stop, but
instead ends in a cycle, the result will be (Inf). If (P,a,b) are such
that it is possible to get stuck on zero, the result will be the negative of
what would otherwise be the &quot;total stopping time&quot; to reach 1, where 0 is
considered a &quot;total stop&quot; that should not occur as it does form a cycle of
length 1.
</p>


<h3>Value</h3>

<p>An integer numeral if stopped, Inf if a cycle, NaN if OOB, else NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculates the "stopping time", or optionally the "total" stopping time.
# Without `gmp` or parameterisation, we can try something simple like
stopping_time(27)
stopping_time(27, total_stopping_time=TRUE)
# If we want change the default parameterisation we can;
stopping_time(3, 5, 2, 1)
# Or if we only want to change one of them
stopping_time(17, a=5)
# All the above work fine, but the function doesn't offer protection against
# overflowing integers by default. To venture into the world of arbitrary
# integer inputs we can use an `as.bigz` from `gmp`. Compare the two;
stopping_time(99999999999999999999)
stopping_time(as.bigz("99999999999999999999"))
# As an extra note, the original motivation for creating a range of Collatz
# themed packages came from some earlier scripts for calculating the stopping
# distances under certain parameterisations. An inconsequential result of
# which was observing that all of the following, for however high `k` goes,
# should equal `96`!
stopping_time(27)
stopping_time(27+as.bigz("576460752303423488"))
stopping_time(27+(2*as.bigz("576460752303423488")))
stopping_time(27+(3*as.bigz("576460752303423488")))
stopping_time(27+(4*as.bigz("576460752303423488")))
</code></pre>

<hr>
<h2 id='stopping_time_terminus'>Stopping Time Terminus</h2><span id='topic+stopping_time_terminus'></span>

<h3>Description</h3>

<p>Provides the appropriate lambda to use to check if iterations on an initial
value have reached either the stopping time, or total stopping time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopping_time_terminus(n, total_stop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopping_time_terminus_+3A_n">n</code></td>
<td>
<p>The initial value to confirm against a stopping time check.</p>
</td></tr>
<tr><td><code id="stopping_time_terminus_+3A_total_stop">total_stop</code></td>
<td>
<p>If false, the lambda will confirm that iterations of n
have reached the oriented stopping time to reach a value closer to 0.
If true, the lambda will simply check equality to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An anonymous function to check for the stopping time.
</p>

<hr>
<h2 id='tree_graph'>Tree Graph</h2><span id='topic+tree_graph'></span>

<h3>Description</h3>

<p>Determine the Tree Graph to some depth by iteratively reversing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_graph(
  initial_value,
  max_orbit_distance,
  P = 2,
  a = 3,
  b = 1,
  cycle_prevention = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_graph_+3A_initial_value">initial_value</code></td>
<td>
<p>(int) The root value of the directed tree graph.</p>
</td></tr>
<tr><td><code id="tree_graph_+3A_max_orbit_distance">max_orbit_distance</code></td>
<td>
<p>(int) Maximum amount of times to iterate the
reverse function. There is no natural termination to populating the tree
graph, equivalent to the termination of hailstone sequences or stopping time
attempts, so this is not an optional argument like max_stopping_time or
max_total_stopping_time, as it is the intended target of orbits to obtain,
rather than a limit to avoid uncapped computation.</p>
</td></tr>
<tr><td><code id="tree_graph_+3A_p">P</code></td>
<td>
<p>(numeric|bigz): Modulus used to divide
n, iff n is equivalent to (0 mod P). Default is 2.</p>
</td></tr>
<tr><td><code id="tree_graph_+3A_a">a</code></td>
<td>
<p>(numeric|bigz) Factor by which to multiply n. Default is 3.</p>
</td></tr>
<tr><td><code id="tree_graph_+3A_b">b</code></td>
<td>
<p>(numeric|bigz) Value to add
to the scaled value of n. Default is 1.</p>
</td></tr>
<tr><td><code id="tree_graph_+3A_cycle_prevention">cycle_prevention</code></td>
<td>
<p>(set[int]) Used to prevent cycles from precipitating
by keeping track of all values added across previous nest depths. Only to be
used internally by the function recursing. Does not expect input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns nested dictionaries that model the directed tree graph up to a
maximum nesting of max_orbit_distance, with the initial_value as the root.
</p>


<h3>Value</h3>

<p>A set of nested dictionaries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Compute a tree graph, which takes both a value to initialise the tree from,
# and an "orbit distance" for how many layers deep in the tree to compute;
tree_graph(16, 3)
# It will also stop on finding a cycle;
tree_graph(4, 3)
# And can be parameterised;
tree_graph(1, 1, -3, -2, -5)
# If b is a multiple of a, but not of Pa, then 0 can have a reverse;
tree_graph(0, 1, 17, 2, -6)
# The tree graph can run on `bigz`;
tree_graph((27+as.bigz("576460752303423488")), 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
