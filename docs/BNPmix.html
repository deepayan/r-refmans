<!DOCTYPE html><html><head><title>Help for package BNPmix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BNPmix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BNPmix-package'><p>BNPmix: Bayesian Nonparametric Mixture Models</p></a></li>
<li><a href='#BNPdens'><p>BNPdens class constructor</p></a></li>
<li><a href='#BNPdens2coda'><p>set generic</p></a></li>
<li><a href='#BNPdens2coda.BNPdens'><p>Export to coda interface</p></a></li>
<li><a href='#BNPmix_BIN'><p>C++ function - compute the Binder distances</p></a></li>
<li><a href='#BNPmix_psm'><p>C++ function - compute the posterior similarity matrix</p></a></li>
<li><a href='#BNPmix_VI_LB'><p>C++ function - compute the VI lower bound</p></a></li>
<li><a href='#BNPpart'><p>BNPpart class constructor</p></a></li>
<li><a href='#cDDP'><p>C++ function to estimate DDP models with 1 grouping variables</p></a></li>
<li><a href='#cICS'><p>C++ function to estimate Pitman-Yor univariate mixtures via importance conditional sampler - LOCATION SCALE</p></a></li>
<li><a href='#cICS_L'><p>C++ function to estimate Pitman-Yor univariate mixtures via importance conditional sampler - LOCATION</p></a></li>
<li><a href='#cICS_mv'><p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - LOCATION SCALE</p></a></li>
<li><a href='#cICS_mv_L'><p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler</p></a></li>
<li><a href='#cICS_mv_MKR'><p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - PRODUCT KERNEL</p></a></li>
<li><a href='#cICS_mv_MKR_L'><p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - PRODUCT KERNEL</p></a></li>
<li><a href='#cICS_mv_P'><p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - PRODUCT KERNEL</p></a></li>
<li><a href='#clean_partition'><p>C++ function - clean the partition matrix</p></a></li>
<li><a href='#CPP'><p>Collaborative Perinatal Project data</p></a></li>
<li><a href='#cSLI'><p>C++ function to estimate Pitman-Yor univariate mixtures via slice sampler - LOCATION SCALE</p></a></li>
<li><a href='#cSLI_L'><p>C++ function to estimate Pitman-Yor univariate mixtures via slice sampler - LOCATION</p></a></li>
<li><a href='#cSLI_mv'><p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - LOCATION SCALE</p></a></li>
<li><a href='#cSLI_mv_L'><p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - LOCATION</p></a></li>
<li><a href='#cSLI_mv_MKR'><p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - PRODUCT KERNEL</p></a></li>
<li><a href='#cSLI_mv_MKR_L'><p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - PRODUCT KERNEL</p></a></li>
<li><a href='#cSLI_mv_P'><p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - LOCATION SCALE</p></a></li>
<li><a href='#dBNPdens'><p>set generic</p></a></li>
<li><a href='#dBNPdens.BNPdens'><p>Evaluate estimated univariate densities at a given point</p></a></li>
<li><a href='#DDPdensity'><p>MCMC for GM-dependent Dirichlet process mixtures of Gaussians</p></a></li>
<li><a href='#MAR'><p>C++ function to estimate Pitman-Yor univariate mixtures via marginal sampler - LOCATION SCALE</p></a></li>
<li><a href='#MAR_L'><p>C++ function to estimate Pitman-Yor univariate mixtures via marginal sampler - LOCATION</p></a></li>
<li><a href='#MAR_mv'><p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - LOCATION SCALE</p></a></li>
<li><a href='#MAR_mv_L'><p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - LOCATION</p></a></li>
<li><a href='#MAR_mv_MKR'><p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - PRODUCT KERNEL</p></a></li>
<li><a href='#MAR_mv_MKR_L'><p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - PRODUCT KERNEL</p></a></li>
<li><a href='#MAR_mv_P'><p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - LOCATION SCALE</p></a></li>
<li><a href='#partition'><p>set generic</p></a></li>
<li><a href='#partition.BNPdens'><p>Estimate the partition of the data</p></a></li>
<li><a href='#plot.BNPdens'><p>Density plot for BNPdens class</p></a></li>
<li><a href='#print.BNPdens'><p>BNPdens print method</p></a></li>
<li><a href='#PYcalibrate'><p>Pitman-Yor prior elicitation</p></a></li>
<li><a href='#PYdensity'><p>MCMC for Pitman-Yor mixtures of Gaussians</p></a></li>
<li><a href='#PYregression'><p>MCMC for Pitman-Yor mixture of Gaussian regressions</p></a></li>
<li><a href='#summary.BNPdens'><p>BNPdens summary method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Nonparametric Mixture Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-07-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Riccardo Corradin [aut, cre], Antonio Canale [ctb], Bernardo Nipoti [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Riccardo Corradin &lt;riccardo.corradin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to perform Bayesian nonparametric univariate and multivariate density estimation and clustering, by means of Pitman-Yor mixtures, and dependent Dirichlet process mixtures for partially exchangeable data. See Corradin et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i15">doi:10.18637/jss.v100.i15</a>&gt; for more details.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, ggplot2, coda, Rcpp, ggpubr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp(&ge; 0.12.13), RcppDist</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-15 14:44:08 UTC; pmzrc1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-15 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BNPmix-package'>BNPmix: Bayesian Nonparametric Mixture Models</h2><span id='topic+BNPmix'></span><span id='topic+BNPmix-package'></span>

<h3>Description</h3>

<p>Functions to perform Bayesian nonparametric univariate and multivariate density estimation and clustering, by means of Pitman-Yor mixtures, and dependent Dirichlet process mixtures for partially exchangeable data. See Corradin et al. (2021) &lt;doi:10.18637/jss.v100.i15&gt; for more details.
</p>

<hr>
<h2 id='BNPdens'>BNPdens class constructor</h2><span id='topic+BNPdens'></span>

<h3>Description</h3>

<p>A constructor for the <code>BNPdens</code> class. The class <code>BNPdens</code> is a named list containing
the output generated by a specified Bayesian nonparametric mixture model implemented by means of
a specified MCMC strategy, as in <code>PYdensity</code>,  <code>DDPdensity</code>, and  <code>PYregression</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BNPdens(
  density = NULL,
  data = NULL,
  grideval = NULL,
  grid_x = NULL,
  grid_y = NULL,
  clust = NULL,
  mean = NULL,
  beta = NULL,
  sigma2 = NULL,
  probs = NULL,
  niter = NULL,
  nburn = NULL,
  tot_time = NULL,
  univariate = TRUE,
  regression = FALSE,
  dep = FALSE,
  group_log = NULL,
  group = NULL,
  wvals = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BNPdens_+3A_density">density</code></td>
<td>
<p>a matrix containing the values taken by the density at the grid points;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_data">data</code></td>
<td>
<p>a dataset;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_grideval">grideval</code></td>
<td>
<p>a set of values where to evaluate the density;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_grid_x">grid_x</code></td>
<td>
<p>regression grid, independent variable;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_grid_y">grid_y</code></td>
<td>
<p>regression grid, dependent variable;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_clust">clust</code></td>
<td>
<p>a (<code>niter - nburn</code>) <code class="reqn">\times</code> <code>nrow(data)</code>-dimensional matrix containing
the cluster labels for each observation (cols) and MCMC iteration (rows);</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_mean">mean</code></td>
<td>
<p>values for the location parameters;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_beta">beta</code></td>
<td>
<p>coefficients for regression model (only for <code>PYregression</code>);</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_sigma2">sigma2</code></td>
<td>
<p>values of the scale parameters;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_probs">probs</code></td>
<td>
<p>values for the mixture weights;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_niter">niter</code></td>
<td>
<p>number of MCMC iterations;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_nburn">nburn</code></td>
<td>
<p>number of MCMC iterations to discard as burn-in;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_tot_time">tot_time</code></td>
<td>
<p>total execution time;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_univariate">univariate</code></td>
<td>
<p>logical, <code>TRUE</code> if the model is univariate;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_regression">regression</code></td>
<td>
<p>logical, <code>TRUE</code>  for the output of  <code>PYregression</code>;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_dep">dep</code></td>
<td>
<p>logical, <code>TRUE</code>  for the output of  <code>DDPdensity</code>;</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_group_log">group_log</code></td>
<td>
<p>group allocation for each iteration (only for <code>DDPdensity</code>);</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_group">group</code></td>
<td>
<p>vector, allocation of observations to strata (only for <code>DDPdensity</code>);</p>
</td></tr>
<tr><td><code id="BNPdens_+3A_wvals">wvals</code></td>
<td>
<p>values of the processes weights (only for <code>DDPdensity</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data_toy &lt;- c(rnorm(100, -3, 1), rnorm(100, 3, 1))
grid &lt;- seq(-7, 7, length.out = 50)
est_model &lt;- PYdensity(y = data_toy, mcmc = list(niter = 100,
                      nburn = 10, nupd = 100), output = list(grid = grid))
str(est_model)
class(est_model)
</code></pre>

<hr>
<h2 id='BNPdens2coda'>set generic</h2><span id='topic+BNPdens2coda'></span>

<h3>Description</h3>

<p>set generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BNPdens2coda(object, dens)
</code></pre>

<hr>
<h2 id='BNPdens2coda.BNPdens'>Export to coda interface</h2><span id='topic+BNPdens2coda.BNPdens'></span>

<h3>Description</h3>

<p>The method <code>BNPdens2coda</code> converts a <code>BNPdens</code> object into a <code>coda</code> mcmc object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BNPdens'
BNPdens2coda(object, dens = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BNPdens2coda.BNPdens_+3A_object">object</code></td>
<td>
<p>a BNPdens object;</p>
</td></tr>
<tr><td><code id="BNPdens2coda.BNPdens_+3A_dens">dens</code></td>
<td>
<p>logical, it can be TRUE only for models estimated with <code>PYdensity</code>.
If TRUE, it converts to <code>coda</code> also the estimated density. Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an mcmc object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_toy &lt;- cbind(c(rnorm(100, -3, 1), rnorm(100, 3, 1)),
                  c(rnorm(100, -3, 1), rnorm(100, 3, 1)))
grid &lt;- expand.grid(seq(-7, 7, length.out = 50),
                    seq(-7, 7, length.out = 50))
est_model &lt;- PYdensity(y = data_toy, mcmc = list(niter = 200, nburn = 100),
                       output = list(grid = grid))
coda_mcmc &lt;- BNPdens2coda(est_model)
class(coda_mcmc)

</code></pre>

<hr>
<h2 id='BNPmix_BIN'>C++ function - compute the Binder distances</h2><span id='topic+BNPmix_BIN'></span>

<h3>Description</h3>

<p>C++ function - compute the Binder distances
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="BNPmix_BIN_+3A_m">M</code></td>
<td>
<p>a matrix (r x n), r number of replications, n number of observations</p>
</td></tr>
<tr><td><code id="BNPmix_BIN_+3A_psm_mat">psm_mat</code></td>
<td>
<p>a posterior similarity matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>{
  M &lt;- matrix(c(1,1,1,2,1,1,2,2,1,1,2,1,1,1,1,2), ncol = 4)
  psmM &lt;- BNPmix_psm(M)
  BNPmix_BIN(M, psmM)
}

</code></pre>

<hr>
<h2 id='BNPmix_psm'>C++ function - compute the posterior similarity matrix</h2><span id='topic+BNPmix_psm'></span>

<h3>Description</h3>

<p>C++ function - compute the posterior similarity matrix
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="BNPmix_psm_+3A_m">M</code></td>
<td>
<p>a matrix (r x n), r number of replications, n number of observations</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>{
  M &lt;- matrix(c(1,1,1,2,1,1,2,2,1,1,2,1,1,2,1,1), ncol = 4)
  BNPmix_psm(M)
}

</code></pre>

<hr>
<h2 id='BNPmix_VI_LB'>C++ function - compute the VI lower bound</h2><span id='topic+BNPmix_VI_LB'></span>

<h3>Description</h3>

<p>C++ function - compute the VI lower bound
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="BNPmix_VI_LB_+3A_m">M</code></td>
<td>
<p>a matrix (r x n), r number of replications, n number of observations</p>
</td></tr>
<tr><td><code id="BNPmix_VI_LB_+3A_psm_mat">psm_mat</code></td>
<td>
<p>a posterior similarity matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>{
  M &lt;- matrix(c(1,1,1,2,1,1,2,2,1,1,2,1,1,1,1,2), ncol = 4)
  psmM &lt;- BNPmix_psm(M)
  BNPmix_VI_LB(M, psmM)
}

</code></pre>

<hr>
<h2 id='BNPpart'>BNPpart class constructor</h2><span id='topic+BNPpart'></span>

<h3>Description</h3>

<p>A constructor for the <code>BNPpart</code> class. The class <code>BNPpart</code> is a named list containing
the output of partition estimation methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BNPpart(partitions = NULL, scores = NULL, psm = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BNPpart_+3A_partitions">partitions</code></td>
<td>
<p>a matrix, each row is a visited partition;</p>
</td></tr>
<tr><td><code id="BNPpart_+3A_scores">scores</code></td>
<td>
<p>a vector, each value is the score of a visited partition;</p>
</td></tr>
<tr><td><code id="BNPpart_+3A_psm">psm</code></td>
<td>
<p>a matrix, posterior similarity matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data_toy &lt;- c(rnorm(100, -3, 1), rnorm(100, 3, 1))
grid &lt;- seq(-7, 7, length.out = 50)
est_model &lt;- PYdensity(y = data_toy, mcmc = list(niter = 100,
                      nburn = 10, nupd = 100), output = list(grid = grid))
part &lt;- partition(est_model)
class(part)

</code></pre>

<hr>
<h2 id='cDDP'>C++ function to estimate DDP models with 1 grouping variables</h2><span id='topic+cDDP'></span>

<h3>Description</h3>

<p>C++ function to estimate DDP models with 1 grouping variables
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cDDP_+3A_data">data</code></td>
<td>
<p>a vector of observations.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_group">group</code></td>
<td>
<p>group allocation of the data.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_ngr">ngr</code></td>
<td>
<p>number of groups.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_grid">grid</code></td>
<td>
<p>vector to evaluate the density.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_niter">niter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_m0">m0</code></td>
<td>
<p>expectation of location component.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_k0">k0</code></td>
<td>
<p>tuning parameter of variance of location component.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_a0">a0</code></td>
<td>
<p>parameter of scale component.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_b0">b0</code></td>
<td>
<p>parameter of scale component.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_mass">mass</code></td>
<td>
<p>mass of Dirichlet process.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_wei">wei</code></td>
<td>
<p>prior weight of the specific processes.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_b">b</code></td>
<td>
<p>tuning parameter of weights distribution</p>
</td></tr>
<tr><td><code id="cDDP_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_n_approx_unif">n_approx_unif</code></td>
<td>
<p>number of approximating values of the importance step for the weights updating.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE).</p>
</td></tr>
<tr><td><code id="cDDP_+3A_print_message">print_message</code></td>
<td>
<p>print the status.</p>
</td></tr>
<tr><td><code id="cDDP_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
</table>

<hr>
<h2 id='cICS'>C++ function to estimate Pitman-Yor univariate mixtures via importance conditional sampler - LOCATION SCALE</h2><span id='topic+cICS'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor univariate mixtures via importance conditional sampler - LOCATION SCALE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cICS_+3A_data">data</code></td>
<td>
<p>a vector of observations</p>
</td></tr>
<tr><td><code id="cICS_+3A_grid">grid</code></td>
<td>
<p>vector to evaluate the density</p>
</td></tr>
<tr><td><code id="cICS_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cICS_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cICS_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cICS_+3A_k0">k0</code></td>
<td>
<p>tuning parameter of variance of location component</p>
</td></tr>
<tr><td><code id="cICS_+3A_a0">a0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cICS_+3A_b0">b0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cICS_+3A_m1">m1</code></td>
<td>
<p>mean of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cICS_+3A_s21">s21</code></td>
<td>
<p>variance of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cICS_+3A_tau1">tau1</code></td>
<td>
<p>shape parameter of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cICS_+3A_tau2">tau2</code></td>
<td>
<p>rate parameter of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cICS_+3A_a1">a1</code></td>
<td>
<p>shape parameter of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cICS_+3A_b1">b1</code></td>
<td>
<p>rate parameter of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cICS_+3A_strength">strength</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="cICS_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="cICS_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cICS_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cICS_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cICS_+3A_discount">discount</code></td>
<td>
<p>discount parameter</p>
</td></tr>
<tr><td><code id="cICS_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cICS_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='cICS_L'>C++ function to estimate Pitman-Yor univariate mixtures via importance conditional sampler - LOCATION</h2><span id='topic+cICS_L'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor univariate mixtures via importance conditional sampler - LOCATION
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cICS_L_+3A_data">data</code></td>
<td>
<p>a vector of observations</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_grid">grid</code></td>
<td>
<p>vector to evaluate the density</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_s20">s20</code></td>
<td>
<p>variance of location component</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_a0">a0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_b0">b0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_m1">m1</code></td>
<td>
<p>hyperparameter, mean of distribution of m0</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_k1">k1</code></td>
<td>
<p>hyperparameter, scale factor of distribution of m0</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_a1">a1</code></td>
<td>
<p>hyperparameter, shape of distribution of s20</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_b1">b1</code></td>
<td>
<p>hyperparameter, scale of distribution of s20</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_strength">strength</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_discount">discount</code></td>
<td>
<p>discount parameter</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cICS_L_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='cICS_mv'>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - LOCATION SCALE</h2><span id='topic+cICS_mv'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - LOCATION SCALE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cICS_mv_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_k0">k0</code></td>
<td>
<p>tuning parameter of variance of location component</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_s0">S0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_n0">n0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_m1">m1</code></td>
<td>
<p>mean of hyperprior distribution of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_s1">S1</code></td>
<td>
<p>covariance of hyperprior distribution of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_tau1">tau1</code></td>
<td>
<p>shape parameter of hyperprior distribution of k0</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_tau2">tau2</code></td>
<td>
<p>rate parameter of hyperprior distribution of k0</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_theta1">theta1</code></td>
<td>
<p>df of hyperprior distribution of S0</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_theta1">Theta1</code></td>
<td>
<p>matrix of hyperprior distribution of S0</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_strength">strength</code></td>
<td>
<p>strength parameter</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_discount">discount</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cICS_mv_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='cICS_mv_L'>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler</h2><span id='topic+cICS_mv_L'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cICS_mv_L_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_s20">S20</code></td>
<td>
<p>variance of location component</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_s0">S0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_n0">n0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_m1">m1</code></td>
<td>
<p>mean of hyperdistribtion of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_k1">k1</code></td>
<td>
<p>scale factor of hyperdistribtion of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_theta1">theta1</code></td>
<td>
<p>df of hyperdistribtion of S20</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_theta1">Theta1</code></td>
<td>
<p>matrix of hyperdistribution of S20</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_strength">strength</code></td>
<td>
<p>strength parameter</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_discount">discount</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cICS_mv_L_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='cICS_mv_MKR'>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - PRODUCT KERNEL</h2><span id='topic+cICS_mv_MKR'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - PRODUCT KERNEL
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cICS_mv_MKR_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_k0">k0</code></td>
<td>
<p>vector, scale parameters for the location component</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_a0">a0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_b0">b0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_m1">m1</code></td>
<td>
<p>means of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_s21">s21</code></td>
<td>
<p>variances of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_tau1">tau1</code></td>
<td>
<p>shape parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_tau2">tau2</code></td>
<td>
<p>rate parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_a1">a1</code></td>
<td>
<p>shape parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_b1">b1</code></td>
<td>
<p>rate parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_strength">strength</code></td>
<td>
<p>strength parameter</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_discount">discount</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='cICS_mv_MKR_L'>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - PRODUCT KERNEL</h2><span id='topic+cICS_mv_MKR_L'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - PRODUCT KERNEL
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cICS_mv_MKR_L_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_k0">k0</code></td>
<td>
<p>vector, scale parameters for the location component</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_a0">a0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_b0">b0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_m1">m1</code></td>
<td>
<p>means of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_s21">s21</code></td>
<td>
<p>variances of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_a1">a1</code></td>
<td>
<p>shape parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_b1">b1</code></td>
<td>
<p>rate parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_strength">strength</code></td>
<td>
<p>strength parameter</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_discount">discount</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cICS_mv_MKR_L_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='cICS_mv_P'>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - PRODUCT KERNEL</h2><span id='topic+cICS_mv_P'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via importance conditional sampler - PRODUCT KERNEL
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cICS_mv_P_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_k0">k0</code></td>
<td>
<p>vector, scale parameters for the location component</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_a0">a0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_b0">b0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_m1">m1</code></td>
<td>
<p>means of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_s21">s21</code></td>
<td>
<p>variances of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_tau1">tau1</code></td>
<td>
<p>shape parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_tau2">tau2</code></td>
<td>
<p>rate parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_a1">a1</code></td>
<td>
<p>shape parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_b1">b1</code></td>
<td>
<p>rate parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_strength">strength</code></td>
<td>
<p>strength parameter</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_discount">discount</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cICS_mv_P_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='clean_partition'>C++ function - clean the partition matrix</h2><span id='topic+clean_partition'></span>

<h3>Description</h3>

<p>C++ function - clean the partition matrix
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_partition_+3A_m">M</code></td>
<td>
<p>a matrix (r x n), r number of replications, n number of observations</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>{
  M &lt;- matrix(c(1,1,1,3,1,1,4,4,1,1,3,1,1,3,1,1), ncol = 4)
  clean_partition(M)
}

</code></pre>

<hr>
<h2 id='CPP'>Collaborative Perinatal Project data</h2><span id='topic+CPP'></span>

<h3>Description</h3>

<p>A subset of the Collaborative Perinatal Project data set (Klebanoff, 2009)
focused on studying the effect of DDE exposure on pregnancies (Longnecker et al., 2001).
The dataset contains the following variables for each pregnant women enrolled in the study:
</p>

<ul>
<li><p> hosp, factor denoting the hospital where the woman was hospitalized;
</p>
</li>
<li><p> smoke, factor. It takes value 2 if the woman is a smoker, 1 otherwise;
</p>
</li>
<li><p> gest, gestational age (in weeks);
</p>
</li>
<li><p> dde, Dichlorodiphenyldichloroethylene (DDE) concentration in maternal serum;
</p>
</li>
<li><p> weight, body weight of the baby at birth (in grams);
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(CPP)
</code></pre>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>References</h3>

<p>Klebanoff M. A. (2009) The collaborative perinatal project: a 50-year retrospective.
Paediatric and perinatal epidemiology, 23, 2.
</p>
<p>Longnecker, M. P., Klebanof, M. A., Zhou, H., Brock, J. (2001)
Association between maternal serum concentration of the DDT metabolite
DDE and preterm and small-for-gestational-age babies at birth. The Lancet, 358, 110-114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CPP)
str(CPP)

</code></pre>

<hr>
<h2 id='cSLI'>C++ function to estimate Pitman-Yor univariate mixtures via slice sampler - LOCATION SCALE</h2><span id='topic+cSLI'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor univariate mixtures via slice sampler - LOCATION SCALE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSLI_+3A_data">data</code></td>
<td>
<p>a vector of observations</p>
</td></tr>
<tr><td><code id="cSLI_+3A_grid">grid</code></td>
<td>
<p>vector to evaluate the density</p>
</td></tr>
<tr><td><code id="cSLI_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cSLI_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cSLI_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cSLI_+3A_k0">k0</code></td>
<td>
<p>tuning parameter of variance of location component</p>
</td></tr>
<tr><td><code id="cSLI_+3A_a0">a0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_+3A_b0">b0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_+3A_m1">m1</code></td>
<td>
<p>mean of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_+3A_s21">s21</code></td>
<td>
<p>variance of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_+3A_tau1">tau1</code></td>
<td>
<p>shape parameter of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cSLI_+3A_tau2">tau2</code></td>
<td>
<p>rate parameter of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cSLI_+3A_a1">a1</code></td>
<td>
<p>shape parameter of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cSLI_+3A_b1">b1</code></td>
<td>
<p>rate parameter of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cSLI_+3A_mass">mass</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="cSLI_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cSLI_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cSLI_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cSLI_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cSLI_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cSLI_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
<tr><td><code id="cSLI_+3A_indep">indep</code></td>
<td>
<p>if TRUE use the independent slice efficient</p>
</td></tr>
</table>

<hr>
<h2 id='cSLI_L'>C++ function to estimate Pitman-Yor univariate mixtures via slice sampler - LOCATION</h2><span id='topic+cSLI_L'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor univariate mixtures via slice sampler - LOCATION
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSLI_L_+3A_data">data</code></td>
<td>
<p>a vector of observations</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_grid">grid</code></td>
<td>
<p>vector to evaluate the density</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_s20">s20</code></td>
<td>
<p>variance of location component</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_a0">a0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_b0">b0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_m1">m1</code></td>
<td>
<p>hyperparameter, mean of distribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_k1">k1</code></td>
<td>
<p>hyperparameter, scale factor of distribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_a1">a1</code></td>
<td>
<p>hyperparameter, shape of distribution of s20</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_b1">b1</code></td>
<td>
<p>hyperparameter, rate of distribution of s20</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_mass">mass</code></td>
<td>
<p>mass parameter</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cSLI_L_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='cSLI_mv'>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - LOCATION SCALE</h2><span id='topic+cSLI_mv'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - LOCATION SCALE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSLI_mv_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_k0">k0</code></td>
<td>
<p>tuning parameter of variance of location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_s0">S0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_n0">n0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_m1">m1</code></td>
<td>
<p>mean of hyperprior distribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_s1">S1</code></td>
<td>
<p>covariance of hyperprior distribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_tau1">tau1</code></td>
<td>
<p>shape parameter of hyperprior distribution of k0</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_tau2">tau2</code></td>
<td>
<p>rate parameter of hyperprior distribution of k0</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_theta1">theta1</code></td>
<td>
<p>df of hyperprior distribution of S0</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_theta1">Theta1</code></td>
<td>
<p>matrix of hyperprior distribution of S0</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_mass">mass</code></td>
<td>
<p>mass parameter</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
<tr><td><code id="cSLI_mv_+3A_indep">indep</code></td>
<td>
<p>if TRUE use the independent slice efficient</p>
</td></tr>
</table>

<hr>
<h2 id='cSLI_mv_L'>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - LOCATION</h2><span id='topic+cSLI_mv_L'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - LOCATION
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSLI_mv_L_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_s20">S20</code></td>
<td>
<p>variance of location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_s0">S0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_n0">n0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_m1">m1</code></td>
<td>
<p>mean of hyperdistribtion of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_k1">k1</code></td>
<td>
<p>scale factor of hyperdistribtion of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_theta1">theta1</code></td>
<td>
<p>df of hyperdistribtion of S20</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_theta1">Theta1</code></td>
<td>
<p>matrix of hyperdistribution of S20</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_mass">mass</code></td>
<td>
<p>mass parameter</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
<tr><td><code id="cSLI_mv_L_+3A_indep">indep</code></td>
<td>
<p>if TRUE use independent slice efficient</p>
</td></tr>
</table>

<hr>
<h2 id='cSLI_mv_MKR'>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - PRODUCT KERNEL</h2><span id='topic+cSLI_mv_MKR'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - PRODUCT KERNEL
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSLI_mv_MKR_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_k0">k0</code></td>
<td>
<p>vector, scale parameters for the location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_a0">a0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_b0">b0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_m1">m1</code></td>
<td>
<p>means of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_s21">s21</code></td>
<td>
<p>variances of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_tau1">tau1</code></td>
<td>
<p>shape parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_tau2">tau2</code></td>
<td>
<p>rate parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_a1">a1</code></td>
<td>
<p>shape parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_b1">b1</code></td>
<td>
<p>rate parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_strength">strength</code></td>
<td>
<p>strength parameter</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_discount">discount</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='cSLI_mv_MKR_L'>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - PRODUCT KERNEL</h2><span id='topic+cSLI_mv_MKR_L'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - PRODUCT KERNEL
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSLI_mv_MKR_L_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_k0">k0</code></td>
<td>
<p>vector, scale parameters for the location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_a0">a0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_b0">b0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_m1">m1</code></td>
<td>
<p>means of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_s21">s21</code></td>
<td>
<p>variances of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_a1">a1</code></td>
<td>
<p>shape parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_b1">b1</code></td>
<td>
<p>rate parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_strength">strength</code></td>
<td>
<p>strength parameter</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_discount">discount</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_MKR_L_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='cSLI_mv_P'>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - LOCATION SCALE</h2><span id='topic+cSLI_mv_P'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via slice sampler - LOCATION SCALE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSLI_mv_P_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_k0">k0</code></td>
<td>
<p>tuning parameter of variance of location component</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_s0">S0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_n0">n0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_m1">m1</code></td>
<td>
<p>means of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_s21">s21</code></td>
<td>
<p>variances of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_tau1">tau1</code></td>
<td>
<p>shape parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_tau2">tau2</code></td>
<td>
<p>rate parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_a1">a1</code></td>
<td>
<p>shape parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_b1">b1</code></td>
<td>
<p>rate parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_mass">mass</code></td>
<td>
<p>mass parameter</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
<tr><td><code id="cSLI_mv_P_+3A_indep">indep</code></td>
<td>
<p>if TRUE use the independent slice efficient</p>
</td></tr>
</table>

<hr>
<h2 id='dBNPdens'>set generic</h2><span id='topic+dBNPdens'></span>

<h3>Description</h3>

<p>set generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dBNPdens(object, x)
</code></pre>

<hr>
<h2 id='dBNPdens.BNPdens'>Evaluate estimated univariate densities at a given point</h2><span id='topic+dBNPdens.BNPdens'></span>

<h3>Description</h3>

<p>The method <code>dBNPdens</code> provides an approximated evaluation of estimated univariate densities at a given point, for a <code>BNPdens</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BNPdens'
dBNPdens(object, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dBNPdens.BNPdens_+3A_object">object</code></td>
<td>
<p>a <code>BNPdens</code> object (only if univariate);</p>
</td></tr>
<tr><td><code id="dBNPdens.BNPdens_+3A_x">x</code></td>
<td>
<p>the point where to evaluate the density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_toy &lt;- c(rnorm(100, -3, 1), rnorm(100, 3, 1))
grid &lt;- seq(-7, 7, length.out = 50)
est_model &lt;- PYdensity(y = data_toy, mcmc = list(niter = 200, nburn = 100),
                       output = list(grid = grid))
x &lt;- 1.4
dBNPdens(est_model, x)

</code></pre>

<hr>
<h2 id='DDPdensity'>MCMC for GM-dependent Dirichlet process mixtures of Gaussians</h2><span id='topic+DDPdensity'></span>

<h3>Description</h3>

<p>The <code>DDPdensity</code> function generates posterior density samples for a univariate Griffiths-Milne dependent Dirichlet process mixture model with Gaussian
kernel, for partially exchangeable data. The function implements the importance conditional sampler method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DDPdensity(y, group, mcmc = list(), prior = list(), output = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DDPdensity_+3A_y">y</code></td>
<td>
<p>a vector or matrix giving the data based on which densities are to be estimated;</p>
</td></tr>
<tr><td><code id="DDPdensity_+3A_group">group</code></td>
<td>
<p>vector of length <code>length(y)</code> containing the group labels (integers)
for the elements of <code>y</code>;</p>
</td></tr>
<tr><td><code id="DDPdensity_+3A_mcmc">mcmc</code></td>
<td>
<p>list of MCMC arguments:
</p>

<ul>
<li> <p><code>niter</code>  (mandatory), number of iterations.
</p>
</li>
<li> <p><code>nburn</code>  (mandatory),  number of iterations to discard as burn-in.
</p>
</li>
<li> <p><code>nupd</code>, argument controlling the number of iterations to be displayed on screen: the function reports
on standard output every time <code>nupd</code> new iterations have been carried out (default is <code>niter/10</code>).
</p>
</li>
<li> <p><code>print_message</code>, control option. If equal to <code>TRUE</code>, the status is printed
to standard output every <code>nupd</code> iterations (default is <code>TRUE</code>).
</p>
</li>
<li> <p><code>m_imp</code>, number of generated values for the importance sampling step of the
importance conditional sampler (default is 10). See <code>details</code>.
</p>
</li>
<li> <p><code>var_MH_step</code>, variance of the Gaussian proposal for the Metropolis-Hastings of the weights update (default is 0.25).
</p>
</li></ul>
</td></tr>
<tr><td><code id="DDPdensity_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information, which contains:
</p>

<ul>
<li> <p><code>strength</code>, the strength parameter, or total mass, of the marginal Dirichlet processes (default 1);
</p>
</li>
<li> <p><code>m0</code>, mean of the normal base measure on the location parameter (default is the sample mean of the data);
</p>
</li>
<li> <p><code>k0</code>, scale factor appearing in the normal base measure on the location parameter (default 1);
</p>
</li>
<li> <p><code>a0</code>, shape parameter of the inverse gamma base measure on the scale parameter (default 2);
</p>
</li>
<li> <p><code>b0</code>, scale parameter of the inverse gamma base measure on the scale parameter (default is the sample variance of the data);
</p>
</li>
<li> <p><code>wei</code>, parameter controlling the strength of dependence across Dirichlet processes (default 1/2).
</p>
</li></ul>
</td></tr>
<tr><td><code id="DDPdensity_+3A_output">output</code></td>
<td>
<p>a list of arguments for generating posterior output. It contains:
</p>

<ul>
<li> <p><code>grid</code>, a grid of points at which to evaluate the estimated posterior mean densities (common for all the groups).
</p>
</li>
<li> <p><code>out_type</code>, if <code>out_type = "FULL"</code>, return the estimated partitions and the realizations of the posterior density for each iterations. If <code>out_type = "MEAN"</code>, return
the estimated partitions and the mean of the densities sampled at each iterations. If <code>out_type = "CLUST"</code>, return the estimated partitions. Default <code>out_type = "FULL"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a Griffiths-Milne dependent Dirichlet process (GM-DDP) mixture
for density estimation for partially exchangeable data (Lijoi et al., 2014).
For each observation the <code>group</code> variable allows the observations to be gathered
into <code class="reqn">L</code>=<code>length(unique(group))</code> distinct groups.
The model assumes exchangeability within each group, with observations in the <code class="reqn">l</code>th group marginally
modelled by a location-scale Dirichlet process mixtures, i.e.
</p>
<p style="text-align: center;"><code class="reqn">\tilde f_l(y) = \int \phi(y; \mu, \sigma^2) \tilde p_l (d \mu, d \sigma^2)</code>
</p>

<p>where each <code class="reqn">\tilde p_l</code> is a Dirichlet process with total mass <code>strength</code> and base measure <code class="reqn">P_0</code>.
The vector <code class="reqn">\tilde p = (\tilde p_1,\ldots,\tilde p_L)</code> is assumed to be jointly distributed as a vector of
GM-DDP(<code>strength</code>, <code>wei</code>;  <code class="reqn">P_0</code>), where <code>strength</code> and
<code class="reqn">P_0</code> are the total mass parameter and the base measure of each <code class="reqn">\tilde p_l</code>, and <code>wei</code>
controls the dependence across the components of
<code class="reqn">\tilde p</code>. Admissible values for <code>wei</code> are in <code class="reqn">(0,1)</code>, with the two extremes of the range
corresponding to full exchangeability (<code>wei</code><code class="reqn">\rightarrow 0</code>)
and  independence across groups (<code>wei</code><code class="reqn">\rightarrow 1</code>).
</p>
<p><code class="reqn">P_0</code> is a normal-inverse gamma base measure, i.e.
</p>
<p style="text-align: center;"><code class="reqn">P_0(d\mu,d\sigma^2) = N(d \mu; m_0, \sigma^2 / k_0) \times IGa(d \sigma^2; a_0, b_0).</code>
</p>

<p>Posterior sampling is obtained by implementing the importance conditional sampler (Canale et al., 2019).
See Corradin et al. (to appear) for more details.
</p>


<h3>Value</h3>

<p>A <code>BNPdensity</code> class object containing the estimated densities for each iteration,
the allocations for each iteration; the grid used to evaluate the densities (for each group); the
densities sampled from the posterior distribution (for each group); the groups; the weights of the processes.
The function returns also informations regarding the estimation: the number of iterations, the number
of burn-in iterations and the execution time.
</p>


<h3>References</h3>

<p>Lijoi, A., Nipoti, B., and Pruenster, I. (2014). Bayesian inference with
dependent normalized completely random measures. Bernoulli 20, 12601291, doi:10.3150/13-BEJ521
</p>
<p>Canale, A., Corradin, R., &amp; Nipoti, B. (2019). Importance conditional sampling for
Bayesian nonparametric mixtures. arXiv preprint arXiv:1906.08147
</p>
<p>Corradin, R., Canale, A., Nipoti, B. (2021), BNPmix: An R Package for Bayesian Nonparametric Modeling via Pitman-Yor Mixtures,
Journal of Statistical Software, doi:10.18637/jss.v100.i15
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_toy &lt;- c(rnorm(50, -4, 1), rnorm(100, 0, 1), rnorm(50, 4, 1))
group_toy &lt;- c(rep(1,100), rep(2,100))
grid &lt;- seq(-7, 7, length.out = 50)
est_model &lt;- DDPdensity(y = data_toy, group = group_toy,
mcmc = list(niter = 200, nburn = 100, var_MH_step = 0.25),
output = list(grid = grid))
summary(est_model)
plot(est_model)

</code></pre>

<hr>
<h2 id='MAR'>C++ function to estimate Pitman-Yor univariate mixtures via marginal sampler - LOCATION SCALE</h2><span id='topic+MAR'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor univariate mixtures via marginal sampler - LOCATION SCALE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAR_+3A_data">data</code></td>
<td>
<p>a vector of observations</p>
</td></tr>
<tr><td><code id="MAR_+3A_grid">grid</code></td>
<td>
<p>vector to evaluate the density</p>
</td></tr>
<tr><td><code id="MAR_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="MAR_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="MAR_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="MAR_+3A_k0">k0</code></td>
<td>
<p>tuning parameter of variance of location component</p>
</td></tr>
<tr><td><code id="MAR_+3A_a0">a0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="MAR_+3A_b0">b0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="MAR_+3A_m1">m1</code></td>
<td>
<p>mean of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="MAR_+3A_s21">s21</code></td>
<td>
<p>variance of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="MAR_+3A_tau1">tau1</code></td>
<td>
<p>shape parameter of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="MAR_+3A_tau2">tau2</code></td>
<td>
<p>rate parameter of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="MAR_+3A_a1">a1</code></td>
<td>
<p>shape parameter of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="MAR_+3A_b1">b1</code></td>
<td>
<p>rate parameter of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="MAR_+3A_mass">mass</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="MAR_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="MAR_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="MAR_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="MAR_+3A_process">process</code></td>
<td>
<p>if 0 DP, if 1 PY</p>
</td></tr>
<tr><td><code id="MAR_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>discount parameter</p>
</td></tr>
<tr><td><code id="MAR_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="MAR_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='MAR_L'>C++ function to estimate Pitman-Yor univariate mixtures via marginal sampler - LOCATION</h2><span id='topic+MAR_L'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor univariate mixtures via marginal sampler - LOCATION
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAR_L_+3A_data">data</code></td>
<td>
<p>a vector of observations</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_grid">grid</code></td>
<td>
<p>vector to evaluate the density</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_s20">s20</code></td>
<td>
<p>variance of location component</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_a0">a0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_b0">b0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_m1">m1</code></td>
<td>
<p>hyperparameter, mean of distribution of m0</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_k1">k1</code></td>
<td>
<p>hyperparameter, scale factor of distribution of m0</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_a1">a1</code></td>
<td>
<p>hyperparameter, shape of distribution of s20</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_b1">b1</code></td>
<td>
<p>hyperparameter, scale of distribution of s20</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_mass">mass</code></td>
<td>
<p>mass parameter</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_process">process</code></td>
<td>
<p>if 0 DP, if 1 PY</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>discount parameter</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="MAR_L_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='MAR_mv'>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - LOCATION SCALE</h2><span id='topic+MAR_mv'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - LOCATION SCALE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAR_mv_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_k0">k0</code></td>
<td>
<p>tuning parameter of variance of location component</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_s0">S0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_n0">n0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_m1">m1</code></td>
<td>
<p>mean of hyperprior distribution of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_s1">S1</code></td>
<td>
<p>covariance of hyperprior distribution of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_tau1">tau1</code></td>
<td>
<p>shape parameter of hyperprior distribution of k0</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_tau2">tau2</code></td>
<td>
<p>rate parameter of hyperprior distribution of k0</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_theta1">theta1</code></td>
<td>
<p>df of hyperprior distribution of S0</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_theta1">Theta1</code></td>
<td>
<p>matrix of hyperprior distribution of S0</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_mass">mass</code></td>
<td>
<p>mass parameter</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="MAR_mv_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='MAR_mv_L'>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - LOCATION</h2><span id='topic+MAR_mv_L'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - LOCATION
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAR_mv_L_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_s20">S20</code></td>
<td>
<p>variance of location component</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_s0">S0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_n0">n0</code></td>
<td>
<p>parameter of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_m1">m1</code></td>
<td>
<p>mean of hyperdistribtion of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_k1">k1</code></td>
<td>
<p>scale factor of hyperdistribtion of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_theta1">theta1</code></td>
<td>
<p>df of hyperdistribtion of S20</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_theta1">Theta1</code></td>
<td>
<p>matrix of hyperdistribution of S20</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_mass">mass</code></td>
<td>
<p>mass parameter</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="MAR_mv_L_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='MAR_mv_MKR'>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - PRODUCT KERNEL</h2><span id='topic+MAR_mv_MKR'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - PRODUCT KERNEL
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAR_mv_MKR_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_k0">k0</code></td>
<td>
<p>vector, scale parameters for the location component</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_a0">a0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_b0">b0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_m1">m1</code></td>
<td>
<p>means of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_s21">s21</code></td>
<td>
<p>variances of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_tau1">tau1</code></td>
<td>
<p>shape parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_tau2">tau2</code></td>
<td>
<p>rate parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_a1">a1</code></td>
<td>
<p>shape parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_b1">b1</code></td>
<td>
<p>rate parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_strength">strength</code></td>
<td>
<p>strength parameter</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_discount">discount</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='MAR_mv_MKR_L'>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - PRODUCT KERNEL</h2><span id='topic+MAR_mv_MKR_L'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - PRODUCT KERNEL
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAR_mv_MKR_L_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_k0">k0</code></td>
<td>
<p>vector, scale parameters for the location component</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_a0">a0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_b0">b0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_m1">m1</code></td>
<td>
<p>means of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_s21">s21</code></td>
<td>
<p>variances of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_a1">a1</code></td>
<td>
<p>shape parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_b1">b1</code></td>
<td>
<p>rate parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_strength">strength</code></td>
<td>
<p>strength parameter</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_napprox">napprox</code></td>
<td>
<p>number of approximating values</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_discount">discount</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="MAR_mv_MKR_L_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='MAR_mv_P'>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - LOCATION SCALE</h2><span id='topic+MAR_mv_P'></span>

<h3>Description</h3>

<p>C++ function to estimate Pitman-Yor multivariate mixtures via marginal sampler - LOCATION SCALE
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAR_mv_P_+3A_data">data</code></td>
<td>
<p>a matrix of observations</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_grid">grid</code></td>
<td>
<p>matrix of points to evaluate the density</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_niter">niter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in iterations</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_m0">m0</code></td>
<td>
<p>expectation of location component</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_k0">k0</code></td>
<td>
<p>vector, scale parameters for the location component</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_a0">a0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_b0">b0</code></td>
<td>
<p>vector, parameters of scale component</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_m1">m1</code></td>
<td>
<p>means of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_s21">s21</code></td>
<td>
<p>variances of hyperdistribution of m0</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_tau1">tau1</code></td>
<td>
<p>shape parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_tau2">tau2</code></td>
<td>
<p>rate parameters of hyperdistribution of k0</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_a1">a1</code></td>
<td>
<p>shape parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_b1">b1</code></td>
<td>
<p>rate parameters of hyperdistribution of b0</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_mass">mass</code></td>
<td>
<p>mass parameter</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_nupd">nupd</code></td>
<td>
<p>number of iterations to show current updating</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_out_param">out_param</code></td>
<td>
<p>if TRUE, return also the location and scale paramteres lists</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_out_dens">out_dens</code></td>
<td>
<p>if TRUE, return also the estimated density (default TRUE)</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_sigma_py">sigma_PY</code></td>
<td>
<p>second parameter of PY</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_print_message">print_message</code></td>
<td>
<p>print the status</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_light_dens">light_dens</code></td>
<td>
<p>if TRUE return only the posterior mean of the density</p>
</td></tr>
<tr><td><code id="MAR_mv_P_+3A_hyper">hyper</code></td>
<td>
<p>if TRUE use hyperpriors, default TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='partition'>set generic</h2><span id='topic+partition'></span>

<h3>Description</h3>

<p>set generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(object, ...)
</code></pre>

<hr>
<h2 id='partition.BNPdens'>Estimate the partition of the data</h2><span id='topic+partition.BNPdens'></span>

<h3>Description</h3>

<p>The <code>partition</code> method estimates the partition of the data based on the output generated by a Bayesian nonparametric mixture
model, according to a specified criterion, for a <code>BNPdens</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BNPdens'
partition(object, dist = "VI", max_k = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition.BNPdens_+3A_object">object</code></td>
<td>
<p>an object of class <code>BNPdens</code>;</p>
</td></tr>
<tr><td><code id="partition.BNPdens_+3A_dist">dist</code></td>
<td>
<p>a loss function defined on the space of partitions;
it can be variation of information  (<code>"VI"</code>) or <code>"Binder"</code>, default <code>"VI"</code>. See details;</p>
</td></tr>
<tr><td><code id="partition.BNPdens_+3A_max_k">max_k</code></td>
<td>
<p>maximum number of clusters passed to the <code>cutree</code> function. See value below;</p>
</td></tr>
<tr><td><code id="partition.BNPdens_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method returns point estimates for the clustering of the data induced by a nonparametric mixture model.
This result is achieved exploiting two different loss fuctions on the space of partitions: variation of information
(<code>dist = 'VI'</code>) and Binder's loss (<code>dist = 'Binder'</code>). The function is based on the <code>mcclust.ext</code>
code by Sara Wade (Wade and Ghahramani, 2018).
</p>


<h3>Value</h3>

<p>The method returns a list containing a matrix with <code>nrow(data)</code> columns and 3 rows. Each row reports
the cluster labels for each observation according to three different approaches, one per row. The first and second rows
are the output of an agglomerative clustering procedure obtained by applying the function <code>hclust</code>
to the dissimilarity matrix, and by using the complete or average linkage,
respectively. The number of clusters is between 1 and <code>max_k</code> and is choosen according to a lower bound
on the expected loss, as described in Wade and Ghahramani (2018).
The third row reports the partition visited by the MCMC with the minimum distance <code>dist</code> from the dissimilarity matrix.
</p>
<p>In addition, the list reports a vector with three scores representing the lower bound on the expected loss
for the three partitions.
</p>


<h3>References</h3>

<p>Wade, S.,  Ghahramani, Z. (2018). Bayesian cluster analysis: Point estimation and credible balls.
Bayesian Analysis, 13, 559-626.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_toy &lt;- c(rnorm(10, -3, 1), rnorm(10, 3, 1))
grid &lt;- seq(-7, 7, length.out = 50)
fit &lt;- PYdensity(y = data_toy, mcmc = list(niter = 100,
                      nburn = 10, nupd = 100), output = list(grid = grid))
class(fit)
partition(fit)

</code></pre>

<hr>
<h2 id='plot.BNPdens'>Density plot for BNPdens class</h2><span id='topic+plot.BNPdens'></span>

<h3>Description</h3>

<p>Extension of the <code>plot</code> method to the <code>BNPdens</code> class. The method <code>plot.BNPdens</code> returns suitable plots for a <code>BNPdens</code>
object. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BNPdens'
plot(
  x,
  dimension = c(1, 2),
  col = "#0037c4",
  show_points = F,
  show_hist = F,
  show_clust = F,
  bin_size = NULL,
  wrap_dim = NULL,
  xlab = "",
  ylab = "",
  band = T,
  conf_level = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BNPdens_+3A_x">x</code></td>
<td>
<p>an object of class <code>BNPdens</code>;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_dimension">dimension</code></td>
<td>
<p>if <code>x</code> is the output of a model fitted to multivariate data,
<code>dimensions</code> specifies the two dimensions for the bivariate contour plot
(if they are equal, a marginal univarite plot is returned);</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_col">col</code></td>
<td>
<p>the color of the lines;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_show_points">show_points</code></td>
<td>
<p>if <code>TRUE</code>, the function plots also the observations, default <code>FALSE</code>;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_show_hist">show_hist</code></td>
<td>
<p>if <code>TRUE</code>, and the model is univariate, the function plots also the histogram of the data, default  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_show_clust">show_clust</code></td>
<td>
<p>if <code>TRUE</code> the function plots also the points colored with respect to the estimated partition, default  <code>FALSE</code>;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_bin_size">bin_size</code></td>
<td>
<p>if <code>show_hist = TRUE</code>, it correponds to the size of each bin,
default <code>range(data) / 30</code>;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_wrap_dim">wrap_dim</code></td>
<td>
<p>bivariate vector, if <code>x</code> is the output of <code>DDPdensity</code>, it correponds to the number of rows and columns in the plot. Default <code>c(ngroup, 1)</code>;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_xlab">xlab</code></td>
<td>
<p>label of the horizontal axis;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_ylab">ylab</code></td>
<td>
<p>label of the vertical axis;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_band">band</code></td>
<td>
<p>if <code>TRUE</code> and <code>x</code> is the output of a univariate model or of <code>DDPdensity</code>, the plot method displays quantile-based posterior credible bands along with estimated densities;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_conf_level">conf_level</code></td>
<td>
<p>bivariate vector, order of the quantiles for the posterior credible bands. Default <code>c(0.025, 0.975)</code>;</p>
</td></tr>
<tr><td><code id="plot.BNPdens_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>BNPdens</code> object is generated by <code>PYdensity</code>, the function returns
the univariate or bivariate estimated density plot.
If the <code>BNPdens</code> object is generated by <code>PYregression</code>, the function returns
the scatterplot of the response variable jointly with the covariates (up to four), coloured according to the estimated partition.
up to four covariates.
If <code>x</code> is a <code>BNPdens</code> object generated by <code>DDPdensity</code>, the function returns
a wrapped plot with one density per group.
The plots can be enhanced in several ways: for univariate densities, if <code>show_hist = TRUE</code>,
the plot shows also the histogram of the data; if <code>show_points = TRUE</code>,
the plot shows also the observed points along the
x-axis; if <code>show_points = TRUE</code> and <code>show_clust = TRUE</code>, the points are colored
according to the partition estimated with the <code>partition</code> function.
For multivariate densities: if  <code>show_points = TRUE</code>,
the plot shows also the scatterplot of the data;
if <code>show_points = TRUE</code> and  <code>show_clust = TRUE</code>,
the points are colored according to the estimated partition.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># PYdensity example
data_toy &lt;- c(rnorm(100, -3, 1), rnorm(100, 3, 1))
grid &lt;- seq(-7, 7, length.out = 50)
est_model &lt;- PYdensity(y = data_toy,
 mcmc = list(niter = 200, nburn = 100, nupd = 100),
 output = list(grid = grid))
class(est_model)
plot(est_model)

# PYregression example
x_toy &lt;- c(rnorm(100, 3, 1), rnorm(100, 3, 1))
y_toy &lt;- c(x_toy[1:100] * 2 + 1, x_toy[101:200] * 6 + 1) + rnorm(200, 0, 1)
grid_x &lt;- c(0, 1, 2, 3, 4, 5)
grid_y &lt;- seq(0, 35, length.out = 50)
est_model &lt;- PYregression(y = y_toy, x = x_toy,
mcmc = list(niter = 200, nburn = 100),
output = list(grid_x = grid_x, grid_y = grid_y))
summary(est_model)
plot(est_model)

# DDPdensity example
data_toy &lt;- c(rnorm(50, -4, 1), rnorm(100, 0, 1), rnorm(50, 4, 1))
group_toy &lt;- c(rep(1,100), rep(2,100))
grid &lt;- seq(-7, 7, length.out = 50)
est_model &lt;- DDPdensity(y = data_toy, group = group_toy,
mcmc = list(niter = 200, nburn = 100, napprox_unif = 50),
output = list(grid = grid))
summary(est_model)
plot(est_model)


</code></pre>

<hr>
<h2 id='print.BNPdens'>BNPdens print method</h2><span id='topic+print.BNPdens'></span>

<h3>Description</h3>

<p>The <code>BNPdens</code> method prints the type of a <code>BNPdens</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BNPdens'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BNPdens_+3A_x">x</code></td>
<td>
<p>an object of class <code>BNPdens</code>;</p>
</td></tr>
<tr><td><code id="print.BNPdens_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data_toy &lt;- c(rnorm(100, -3, 1), rnorm(100, 3, 1))
grid &lt;- seq(-7, 7, length.out = 50)
est_model &lt;- PYdensity(y = data_toy, mcmc = list(niter = 100,
                      nburn = 10, napprox = 10), output = list(grid = grid))
class(est_model)
print(est_model)
</code></pre>

<hr>
<h2 id='PYcalibrate'>Pitman-Yor prior elicitation</h2><span id='topic+PYcalibrate'></span>

<h3>Description</h3>

<p>The function <code>PYcalibrate</code> elicits the strength parameter of the Pitman-Yor
process, given the discount parameter and the prior expected number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PYcalibrate(Ek, n, discount = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PYcalibrate_+3A_ek">Ek</code></td>
<td>
<p>prior expected number of cluster;</p>
</td></tr>
<tr><td><code id="PYcalibrate_+3A_n">n</code></td>
<td>
<p>sample size;</p>
</td></tr>
<tr><td><code id="PYcalibrate_+3A_discount">discount</code></td>
<td>
<p>discount parameter; default is set equal to 0, corresponding to a Dirichlet process prior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containingtthe values of strength and discount parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PYcalibrate(5, 100)

PYcalibrate(5, 100, 0.5)

</code></pre>

<hr>
<h2 id='PYdensity'>MCMC for Pitman-Yor mixtures of Gaussians</h2><span id='topic+PYdensity'></span>

<h3>Description</h3>

<p>The <code>PYdensity</code> function generates a posterior density sample for a selection of univariate and multivariate Pitman-Yor
process mixture models with Gaussian kernels. See details below for the description of the different specifications of the implemented models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PYdensity(y, mcmc = list(), prior = list(), output = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PYdensity_+3A_y">y</code></td>
<td>
<p>a  vector or matrix giving the data based on which the density is to be estimated;</p>
</td></tr>
<tr><td><code id="PYdensity_+3A_mcmc">mcmc</code></td>
<td>
<p>a list of MCMC arguments:
</p>

<ul>
<li> <p><code>niter</code> (mandatory), number of iterations.
</p>
</li>
<li> <p><code>nburn</code> (mandatory), number of iterations to discard as burn-in.
</p>
</li>
<li> <p><code>method</code>, the MCMC sampling method to be used, options are <code>'ICS'</code>, <code>'MAR'</code> and <code>'SLI'</code> (default is <code>'ICS'</code>). See details.
</p>
</li>
<li> <p><code>model</code>, the type of model to be fitted (default is <code>'LS'</code>). See details.
</p>
</li>
<li> <p><code>nupd</code>, argument controlling the number of iterations to be displayed on screen: the function reports
on standard output every time <code>nupd</code> new iterations have been carried out (default is <code>niter/10</code>).
</p>
</li>
<li> <p><code>print_message</code>, control option. If equal to <code>TRUE</code>, the status is printed
to standard output every <code>nupd</code> iterations (default is <code>TRUE</code>).
</p>
</li>
<li> <p><code>m_imp</code>, number of generated values for the importance sampling step of <code>method = 'ICS'</code> (default is 10). See details.
</p>
</li>
<li> <p><code>slice_type</code>, when <code>method = 'SLI'</code> it specifies the type of slice sampler. Options are <code>'DEP'</code> for dependent slice-efficient, and <code>'INDEP'</code> for independent slice-efficient (default is <code>'DEP'</code>). See details.
</p>
</li>
<li> <p><code>hyper</code>, if equal to <code>TRUE</code>, hyperprior distributions on the base measure's
parameters are added, as specified in <code>prior</code> and explained in <code>details</code> (default is <code>TRUE</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="PYdensity_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. The list includes <code>strength</code> and <code>discount</code>,
the strength and discount parameters of the Pitman-Yor process
(default are <code>strength = 1</code> and <code>discount = 0</code>, the latter leading to the Dirichlet process).
The remaining parameters depend on the model choice.
</p>

<ul>
<li><p> If <code>model = 'L'</code> (location mixture) and <code>y</code> is univariate:
</p>
<p><code>m0</code> and <code>s20</code> are
mean and variance of the base measure on the location parameter (default are sample mean and sample variance of the data);
<code>a0</code> and <code>b0</code> are shape and scale parameters of the inverse gamma prior on the common scale parameter
(default are 2 and the sample variance of the data).
If <code>hyper = TRUE</code>,  optional hyperpriors on the base measure's parameters are added:
specifically, <code>m1</code> and <code>k1</code> are the mean parameter and the scale factor defining the
normal hyperprior on <code>m0</code> (default are the sample mean of the data and 1), and
<code>a1</code> and <code>b1</code> are shape and rate parameters of the inverse gamma hyperprior on <code>b0</code>
(default are 2 and the sample variance of the data). See details.
</p>
</li>
<li><p> If <code>model = 'LS'</code> (location-scale mixture) and <code>y</code> is univariate:
</p>
<p><code>m0</code> and <code>k0</code> are the mean parameter and the scale factor defining the normal base measure
on the location parameter (default are the sample mean of the data and 1), and <code>a0</code> and <code>b0</code> are
shape and scale parameters of the inverse gamma base measure on the scale parameter (default are 2 and the sample variance of the data).
If <code>hyper = TRUE</code>,  optional hyperpriors on the base measure's parameters are added:
specifically, <code>m1</code> and <code>s21</code> are mean and variance parameters of the normal hyperprior on
<code>m0</code> (default are the sample mean and the sample variance of the data);
<code>tau1</code> and <code>zeta1</code> are shape and rate parameters of the gamma hyperprior on
<code>k0</code> (default is 1 for both);
<code>a1</code> and <code>b1</code> are shape and rate parameters of the gamma hyperprior on
<code>b0</code>  (default are the sample variance of the data and 1). See details.
</p>
</li>
<li><p> If <code>model = 'L'</code> (location mixture) and <code>y</code> is multivariate (<code>p</code>-variate):
</p>
<p><code>m0</code> and <code>S20</code> are
mean and covariance of the base measure on the location parameter (default are the sample mean and the sample covariance of the data);
<code>Sigma0</code> and <code>n0</code> are the parameters of the inverse Whishart prior on
the common scale matrix (default are the sample covariance of the data and <code>p</code>+2).
If <code>hyper = TRUE</code>, optional hyperpriors on the base measure's parameters are added:
specifically, <code>m1</code> and <code>k1</code> are the mean parameter and the scale factor defining the
normal hyperprior on <code>m0</code> (default are the sample mean of the data and 1), and
<code>lambda</code> and <code>Lambda1</code> are the parameters (degrees of freedom and scale) of the inverse Wishart prior on <code>S20</code>
(default are <code>p</code>+2 and the sample covariance of the data). See details.
</p>
</li>
<li><p> If <code>model = 'LS'</code> (location-scale mixture) and <code>y</code> is multivariate (<code>p</code>-variate):
</p>
<p><code>m0</code> and <code>k0</code> are the mean parameter and the scale factor defining the normal base measure on the
location parameter (default are the sample mean of the data and 1), and
<code>n0</code> and <code>Sigma0</code> are the parameters (degrees of freedom and scale) of the inverse Wishart base measure on the location parameter
(default are <code>p</code>+2 and the sample covariance of the data).
If <code>hyper = TRUE</code>, optional hyperpriors on the base measure's parameters are added:
specifically, <code>m1</code> and <code>S1</code> are mean and covariance matrix parameters of the normal hyperprior on
<code>m0</code> (default are the sample mean and the sample covariance of the data);
<code>tau1</code> and <code>zeta1</code> are shape and rate parameters of the gamma hyperprior on
<code>k0</code> (default is 1 for both);
<code>n1</code> and <code>Sigma1</code> are the parameters (degrees of freedom and scale) of the Wishart prior for <code>Sigma0</code>
(default are <code>p</code>+2 and the sample covariance of the data divided <code>p</code>+2). See details.
</p>
</li>
<li><p> If <code>model = 'DLS'</code> (diagonal location-scale mixture):
</p>
<p><code>m0</code> and <code>k0</code> are the mean vector parameter and the vector of scale factors defining the normal base measure
on the location parameter (default are the sample mean and a vector of ones),
and <code>a0</code> and <code>b0</code> are vectors of
shape and scale parameters defining the base measure on the scale parameters (default are a vector of twos and the diagonal
of the sample covariance of the data).
If <code>hyper = TRUE</code>, optional hyperpriors on the base measure's parameters are added:
specifically, <code>m1</code> and <code>s21</code> are vectors of mean and variance parameters for the normal hyperpriors on the components of
<code>m0</code> (default are the sample mean and the diagonal of the sample covariance of the data);
<code>tau1</code> and <code>zeta1</code> are vectors of shape and rate parameters of the gamma hyperpriors on the components of
<code>k0</code> (default is a vector of ones for both);
<code>a1</code> and <code>b1</code> are vectors of shape and rate parameters of the gamma hyperpriors on the components of
<code>b0</code>  (default is the diagonal of the sample covariance of the data and a vector of ones). See details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="PYdensity_+3A_output">output</code></td>
<td>
<p>a list of arguments for generating posterior output. It contains:
</p>

<ul>
<li> <p><code>grid</code>, a grid of points at which to evaluate the estimated posterior mean density; a data frame
obtained with the <code>expand.grid</code> function.
</p>
</li>
<li> <p><code>out_param</code>, if equal to <code>TRUE</code>, the function returns the draws of the kernel's
parameters for each MCMC iteration, default is <code>FALSE</code>. See <code>value</code> for details.
</p>
</li>
<li> <p><code>out_type</code>, if <code>out_type = "FULL"</code>, the function returns the visited
partitions and the realizations of the posterior density for each iterations.
If <code>out_type = "MEAN"</code>, the function returns the estimated partitions and the mean of the densities sampled at each iterations.
If <code>out_type = "CLUST"</code>, the function returns the estimated partition.
Default <code>"FULL"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic function fits a Pitman-Yor process mixture model for density estimation and clustering. The general model is
</p>
<p style="text-align: center;"><code class="reqn">\tilde f(y) = \int K(y; \theta) \tilde p (d \theta),</code>
</p>
<p> where <code class="reqn">K(y; \theta)</code> is a kernel density with parameter
<code class="reqn">\theta\in\Theta</code>. Univariate and multivariate Gaussian kernels are implemented with different specifications for the parametric space
<code class="reqn">\Theta</code>, as described below.
The mixing measure <code class="reqn">\tilde p</code> has a Pitman-Yor process prior with strength parameter <code class="reqn">\vartheta</code>,
discount parameter <code class="reqn">\alpha</code>, and base measure <code class="reqn">P_0</code> admitting the specifications presented below. For posterior sampling,
three MCMC approaches are implemented. See details below.
</p>
<p><strong>Univariate data</strong>
</p>
<p>For univariate <code class="reqn">y</code> the function implements both a location and location-scale mixture model. The former assumes
</p>
<p style="text-align: center;"><code class="reqn">\tilde f(y) = \int \phi(y; \mu, \sigma^2) \tilde p (d \mu) \pi(\sigma^2),</code>
</p>
<p> where
<code class="reqn">\phi(y; \mu, \sigma^2)</code> is a univariate Gaussian kernel function with mean <code class="reqn">\mu</code> and variance <code class="reqn">\sigma^2</code>,
and <code class="reqn">\pi(\sigma^2)</code> is an inverse gamma prior. The base measure is specified as
</p>
<p style="text-align: center;"><code class="reqn">P_0(d \mu) = N(d \mu; m_0, \sigma^2_0),</code>
</p>

<p>and <code class="reqn">\sigma^2 \sim IGa(a_0, b_0)</code>.
Optional hyperpriors for the base measure's parameters are
</p>
<p style="text-align: center;"><code class="reqn">(m_0,\sigma^2_0) \sim N(m_1, \sigma^2_0 / k_1) \times IGa(a_1, b_1).</code>
</p>

<p>The location-scale mixture model, instead, assumes
</p>
<p style="text-align: center;"><code class="reqn">\tilde f(y) = \int \phi(y; \mu, \sigma^2) \tilde p (d \mu, d \sigma^2)</code>
</p>
<p> with normal-inverse gamma base measure
</p>
<p style="text-align: center;"><code class="reqn">P_0 (d \mu, d \sigma^2) = N(d \mu; m_0, \sigma^2 / k_0) \times IGa(d \sigma^2; a_0, b_0).</code>
</p>
<p> and (optional) hyperpriors
</p>
<p style="text-align: center;"><code class="reqn">m_0 \sim N(m_1, \sigma_1^2 ),\quad k_0 \sim Ga(\tau_1, \zeta_1),\quad b_0 \sim Ga(a_1, b_1).</code>
</p>

<p><strong>Multivariate data</strong>
</p>
<p>For multivariate <code class="reqn">y</code> (<code class="reqn">p</code>-variate) the function implements a location mixture model (with full covariance matrix) and two
different location-scale mixture models, with either full or diagonal covariance matrix. The location mixture model assumes
</p>
<p style="text-align: center;"><code class="reqn">\tilde f(y) = \int \phi_p(y; \mu, \Sigma) \tilde p (d \mu) \pi(\Sigma)</code>
</p>
<p> where
<code class="reqn">\phi_p(y; \mu, \Sigma)</code> is a <code class="reqn">p</code>-dimensional Gaussian kernel function with mean vector <code class="reqn">\mu</code> and covariance matrix
<code class="reqn">\Sigma</code>. The prior on <code class="reqn">\Sigma</code> is inverse Whishart with parameters <code class="reqn">\Sigma_0</code> and <code class="reqn">\nu_0</code>, while the
base measure is
</p>
<p style="text-align: center;"><code class="reqn">P_0(d \mu) = N(d \mu;  m_0, S_0),</code>
</p>

<p>with optional hyperpriors
</p>
<p style="text-align: center;"><code class="reqn">m_0 \sim N(m_1, S_0 / k_1),\quad S_0 \sim IW(\lambda_1, \Lambda_1).</code>
</p>

<p>The location-scale mixture model assumes
</p>
<p style="text-align: center;"><code class="reqn">\tilde f(x) = \int \phi_p(y;  \mu, \Sigma) \tilde p (d  \mu, d \Sigma).</code>
</p>
<p> Two possible structures for <code class="reqn">\Sigma</code>
are implemented, namely full and diagonal covariance. For the full covariance mixture model, the base measure is
the normal-inverse Wishart
</p>
<p style="text-align: center;"><code class="reqn">P_0 (d \mu, d \Sigma) = N(d \mu;  m_0, \Sigma / k_0) \times IW(d \Sigma; \nu_0, \Sigma_0),</code>
</p>

<p>with optional hyperpriors
</p>
<p style="text-align: center;"><code class="reqn">m_0 \sim N(m_1, S_1),\quad k_0 \sim Ga(\tau_1, \zeta_1),\quad b_0 \sim W(\nu_1, \Sigma_1).</code>
</p>

<p>The second location-scale mixture model assumes a diagonal covariance structure. This is equivalent to write the
mixture model as a mixture of products of univariate normal kernels, i.e.
</p>
<p style="text-align: center;"><code class="reqn">\tilde f(y) = \int \prod_{r=1}^p \phi(y_r;  \mu_r, \sigma^2_r) \tilde p (d  \mu_1,\ldots,d \mu_p, d \sigma_1^2,\ldots,d \sigma_p^2).</code>
</p>

<p>For this specification, the base measure is assumed defined as the product of <code class="reqn">p</code> independent normal-inverse gamma distributions, that is
</p>
<p style="text-align: center;"><code class="reqn">P_0 = \prod_{r=1}^p P_{0r}</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">P_{0r}(d \mu_r,d \sigma_r^2) = N(d \mu_r; m_{0r}, \sigma^2_r / k_{0r}) \times Ga(d \sigma^2_r; a_{0r}, b_{0r}).</code>
</p>

<p>Optional hyperpriors can be added, and, for each component, correspond to the set of hyperpriors considered
for the univariate location-scale mixture model.
</p>
<p><strong>Posterior simulation methods</strong>
</p>
<p>This generic function implements three types of MCMC algorithms for posterior simulation.
The default method is the importance conditional sampler <code>'ICS'</code> (Canale et al. 2019). Other options are
the marginal sampler <code>'MAR'</code> (Neal, 2000) and the slice sampler <code>'SLI'</code> (Kalli et al. 2011).
The importance conditional sampler performs an importance sampling step when updating the values of
individual parameters <code class="reqn">\theta</code>, which requires to sample <code>m_imp</code> values from a suitable
proposal. Large values of <code>m_imp</code> are known to improve the mixing of the chain
at the cost of increased running time (Canale et al. 2019). Two options are available for the slice sampler,
namely the dependent slice-efficient sampler (<code>slice_type = 'DEP'</code>), which is set as default, and the
independent slice-efficient sampler (<code>slice_type = 'INDEP'</code>) (Kalli et al. 2011). See Corradin et al. (to appear)
for more details.
</p>


<h3>Value</h3>

<p>A <code>BNPdens</code> class object containing the estimated density and
the cluster allocations for each iterations. If <code>out_param = TRUE</code> the output
contains also the kernel specific parameters for each iteration. If <code>mcmc_dens = TRUE</code> the output
contains also a realization from the posterior density for each iteration. IF <code>mean_dens = TRUE</code>
the output contains just the mean of the realizations from the posterior density. The output contains
also informations as the number of iterations, the number of burn-in iterations, the used
computational time and the type of estimated model (<code>univariate = TRUE</code> or <code>FALSE</code>).
</p>


<h3>References</h3>

<p>Canale, A., Corradin, R., Nipoti, B. (2019), Importance conditional sampling for Bayesian nonparametric mixtures,
arXiv preprint, arXiv:1906.08147
</p>
<p>Corradin, R., Canale, A., Nipoti, B. (2021), BNPmix: An R Package for Bayesian Nonparametric Modeling via Pitman-Yor Mixtures,
Journal of Statistical Software, 100, doi:10.18637/jss.v100.i15
</p>
<p>Kalli, M., Griffin, J. E., and Walker, S. G. (2011), Slice sampling mixture models.
Statistics and Computing 21, 93-105, doi:10.1007/s11222-009-9150-y
</p>
<p>Neal, R. M. (2000), Markov Chain Sampling Methods for Dirichlet Process Mixture Models,
Journal of Computational and Graphical Statistics 9, 249-265, doi:10.2307/1390653
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_toy &lt;- cbind(c(rnorm(100, -3, 1), rnorm(100, 3, 1)),
                  c(rnorm(100, -3, 1), rnorm(100, 3, 1)))
grid &lt;- expand.grid(seq(-7, 7, length.out = 50),
                    seq(-7, 7, length.out = 50))
est_model &lt;- PYdensity(y = data_toy, mcmc = list(niter = 200, nburn = 100),
output = list(grid = grid))
summary(est_model)
plot(est_model)

</code></pre>

<hr>
<h2 id='PYregression'>MCMC for Pitman-Yor mixture of Gaussian regressions</h2><span id='topic+PYregression'></span>

<h3>Description</h3>

<p>The <code>PYregression</code> function generates a posterior sample
for mixtures of linear regression models inspired by the ANOVA-DDP model
introduced in De Iorio et al. (2004). See details below for model specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PYregression(y, x, mcmc = list(), prior = list(), output = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PYregression_+3A_y">y</code></td>
<td>
<p>a vector of observations, univariate dependent variable;</p>
</td></tr>
<tr><td><code id="PYregression_+3A_x">x</code></td>
<td>
<p>a matrix of observations, multivariate independent variable;</p>
</td></tr>
<tr><td><code id="PYregression_+3A_mcmc">mcmc</code></td>
<td>
<p>a list of MCMC arguments:
</p>

<ul>
<li> <p><code>niter</code> (mandatory), number of iterations.
</p>
</li>
<li> <p><code>nburn</code> (mandatory), number of iterations to discard as burn-in.
</p>
</li>
<li> <p><code>method</code>, the MCMC sampling method to be used. Options are <code>'ICS'</code>, <code>'MAR'</code> and <code>'SLI'</code> (default is <code>'ICS'</code>). See details.
</p>
</li>
<li> <p><code>model</code> the type of model to be fitted (default is 'LS'). See details.
</p>
</li>
<li> <p><code>nupd</code>, argument controlling the number of iterations to be displayed on screen: the function reports
on standard output every time <code>nupd</code> new iterations have been carried out (default is <code>niter/10</code>).
</p>
</li>
<li> <p><code>print_message</code>, control option. If equal to <code>TRUE</code>, the status is printed
to standard output every <code>nupd</code> iterations (default is <code>TRUE</code>).
</p>
</li>
<li> <p><code>m_imp</code>, number of generated values for the importance sampling step of <code>method = 'ICS'</code> (default is 10). See details.
</p>
</li>
<li> <p><code>slice_type</code>, when <code>method = 'SLI'</code> it specifies the type of slice sampler. Options are <code>'DEP'</code> for dependent slice-efficient, and <code>'INDEP'</code> for independent slice-efficient (default is <code>'DEP'</code>). See details.
</p>
</li>
<li> <p><code>m_marginal</code>, number of generated values for the augmentation step needed, if <code>method = 'MAR'</code>, to implement Algorithm 8 of Neal, 2000. (Default is 100). See details.
</p>
</li>
<li> <p><code>hyper</code>, if equal to <code>TRUE</code>, hyperprior distributions on the base measure's
parameters are added, as specified in <code>prior</code> and explained in <code>details</code> (default is <code>TRUE</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="PYregression_+3A_prior">prior</code></td>
<td>
<p>a list giving the prior information. The list includes
<code>strength</code> and <code>discount</code>, the strength and discount parameters of the Pitman-Yor process
(default are <code>strength = 1</code> and <code>discount = 0</code>, the latter leading to the Dirichlet process).
The remaining parameters specify the base measure: <code>m0</code> and <code>S0</code> are
the mean and covariance of normal base measure on the regression coefficients (default are a vector of zeroes, except for the first element equal
to <code>mean(y)</code>, and a diagonal matrix with each element equal to 100);
<code>a0</code> and <code>b0</code> are the shape and scale parameters of the inverse gamma base measure on the scale component
(default are 2 and var(y)).
If <code>hyper = TRUE</code>,  optional hyperpriors on the base measure's parameters are added:
specifically, <code>m1</code> and <code>k1</code> are the  mean parameter and scale factor defining the
normal hyperprior on <code>m0</code> (default are a vector of zeroes, except for the first element equal
to the sample mean of the dependent observed variable, and 1);
<code>tau1</code> and <code>zeta1</code> are the shape and rate parameters of the gamma hyperprior on
<code>b0</code> (default is 1 for both);
<code>n1</code> and <code>S1</code> are the parameters (degrees of freedom and scale) of the Wishart prior for <code>S0</code>
(default 4 and a diagonal matrix with each element equal to 100);  See details.</p>
</td></tr>
<tr><td><code id="PYregression_+3A_output">output</code></td>
<td>
<p>list of posterior summaries:
</p>

<ul>
<li> <p><code>grid_y</code>, a vector of points where to evaluate the estimated posterior mean density of
<code>y</code>, conditionally on each value of <code>x</code> in <code>grid_x</code>;
</p>
</li>
<li> <p><code>grid_x</code>, a matrix of points where to evaluate the realization of the posterior conditional densities of
<code>y</code> given <code>x</code>;
</p>
</li>
<li> <p><code>out_type</code>, if <code>out_type = "FULL"</code>, the function returns the estimated partitions and the realizations of the posterior density for each iteration;
If <code>out_type = "MEAN"</code>, return the estimated partitions and the mean of the densities sampled at each iteration;
If <code>out_type = "CLUST"</code>, return the estimated partitions. Default <code>out_type = "FULL"</code>;
</p>
</li>
<li> <p><code>out_param</code>, if equal to <code>TRUE</code>, the function returns the draws of the kernel's
parameters for each MCMC iteration, default is <code>FALSE</code>. See <code>value</code> for details.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a Pitman-Yor process mixture of Gaussian linear regression models, i.e
</p>
<p style="text-align: center;"><code class="reqn">\tilde f(y) = \int \phi(y; x^T \beta, \sigma^2) \tilde p (d \beta, d \sigma^2)</code>
</p>

<p>where <code class="reqn">x</code> is a bivariate vector containing the dependent variable in <code>x</code> and a value of 1
for the intercept term.
The mixing measure <code class="reqn">\tilde p</code> has a Pitman-Yor process prior with strength <code class="reqn">\vartheta</code>,
discount parameter <code class="reqn">\alpha</code>. The location model assume a base measures <code class="reqn">P_0</code> specified as
</p>
<p style="text-align: center;"><code class="reqn">P_0(d \beta) = N(d \beta; m_0, S_0) .</code>
</p>

<p>while the location-scale model assume a base measures <code class="reqn">P_0</code> specified as
</p>
<p style="text-align: center;"><code class="reqn">P_0(d \beta, d \sigma^2) = N(d \beta; m_0, S_0) \times IGa(d \sigma^2; a_0, b_0).</code>
</p>

<p>Optional hyperpriors complete the model specification:
</p>
<p style="text-align: center;"><code class="reqn">m_0 \sim N(m_1, S_0 / k_1 ),\quad S_0 \sim IW(\nu_1, S_1),\quad b_0 \sim G(\tau_1, \zeta_1).</code>
</p>

<p><strong>Posterior simulation methods</strong>
</p>
<p>This generic function implements three types of MCMC algorithms for posterior simulation.
The default method is the importance conditional sampler <code>'ICS'</code> (Canale et al. 2019). Other options are
the marginal sampler <code>'MAR'</code> (algorithm 8 of Neal, 2000) and the slice sampler <code>'SLI'</code> (Kalli et al. 2011).
The importance conditional sampler performs an importance sampling step when updating the values of
individual parameters <code class="reqn">\theta</code>, which requires to sample <code>m_imp</code> values from a suitable
proposal. Large values of <code>m_imp</code> are known to improve the mixing of the posterior distribution
at the cost of increased running time (Canale et al. 2019). When updateing the individual parameter
<code class="reqn">\theta</code>, Algorithm 8 of Neal, 2000, requires to sample <code>m_marginal</code> values from the base
measure. <code>m_marginal</code> can be chosen arbitrarily. Two options are available for the slice sampler,
namely the dependent slice-efficient sampler (<code>slice_type = 'DEP'</code>), which is set as default, and the
independent slice-efficient sampler (<code>slice_type = 'INDEP'</code>) (Kalli et al. 2011). See Corradin et al. (to appear)
for more details.
</p>


<h3>Value</h3>

<p>A <code>BNPdens</code> class object containing the estimated density and
the cluster allocations for each iterations. The output contains also the data and
the grids. If <code>out_param = TRUE</code> the output
contains also the kernel specific parameters for each iteration. If <code>mcmc_dens = TRUE</code>, the
function returns also a realization from the posterior density for each iteration.
If <code>mean_dens = TRUE</code>, the output contains just the mean of the densities sampled at each iteration.
The output retuns also the number of iterations,
the number of burn-in iterations, the computational time and the type of model.
</p>


<h3>References</h3>

<p>Canale, A., Corradin, R., Nipoti, B. (2019), Importance conditional sampling for Bayesian nonparametric mixtures,
arXiv preprint, arXiv:1906.08147
</p>
<p>Corradin, R., Canale, A., Nipoti, B. (2021), BNPmix: An R Package for Bayesian Nonparametric Modeling via Pitman-Yor Mixtures,
Journal of Statistical Software, doi:10.18637/jss.v100.i15
</p>
<p>De Iorio, M., Mueller, P., Rosner, G.L., and MacEachern, S. (2004), An ANOVA Model for Dependent Random Measures,
Journal of the American Statistical Association 99, 205-215, doi:10.1198/016214504000000205
</p>
<p>Kalli, M., Griffin, J. E., and Walker, S. G. (2011), Slice sampling mixture models.
Statistics and Computing 21, 93-105, doi:10.1007/s11222-009-9150-y
</p>
<p>Neal, R. M. (2000), Markov Chain Sampling Methods for Dirichlet Process Mixture Models,
Journal of Computational and Graphical Statistics 9, 249-265, doi:10.2307/1390653
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_toy &lt;- c(rnorm(100, 3, 1), rnorm(100, 3, 1))
y_toy &lt;- c(x_toy[1:100] * 2 + 1, x_toy[101:200] * 6 + 1) + rnorm(200, 0, 1)
grid_x &lt;- c(0, 1, 2, 3, 4, 5)
grid_y &lt;- seq(0, 35, length.out = 50)
est_model &lt;- PYregression(y = y_toy, x = x_toy,
mcmc = list(niter = 200, nburn = 100),
output = list(grid_x = grid_x, grid_y = grid_y))
summary(est_model)
plot(est_model)

</code></pre>

<hr>
<h2 id='summary.BNPdens'>BNPdens summary method</h2><span id='topic+summary.BNPdens'></span>

<h3>Description</h3>

<p>The <code>summary.BNPdens</code> method provides summary information on <code>BNPdens</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BNPdens'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BNPdens_+3A_object">object</code></td>
<td>
<p>an object of class <code>BNPdens</code>;</p>
</td></tr>
<tr><td><code id="summary.BNPdens_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data_toy &lt;- c(rnorm(100, -3, 1), rnorm(100, 3, 1))
grid &lt;- seq(-7, 7, length.out = 50)
est_model &lt;- PYdensity(y = data_toy, mcmc = list(niter = 100,
                      nburn = 10, napprox = 10), output = list(grid = grid))
class(est_model)
summary(est_model)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
