<!DOCTYPE html><html><head><title>Help for package trustOptim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {trustOptim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binary'><p>Binary choice example</p></a></li>
<li><a href='#binary-data'><p>Sample simulated data for binary choice model in vignette</p></a></li>
<li><a href='#trust.optim'><p>Nonlinear optimizers using trust regions.</p></a></li>
<li><a href='#trustOptim'><p>Trust-region optimization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Trust Region Optimization for Nonlinear Functions with Sparse
Hessians</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.7.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Braun &lt;braunm@smu.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://braunm.github.io/trustOptim/">https://braunm.github.io/trustOptim/</a>,
<a href="https://github.com/braunm/trustOptim/">https://github.com/braunm/trustOptim/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/braunm/trustOptim/issues">https://github.com/braunm/trustOptim/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Trust region algorithm for nonlinear optimization. Efficient when
    the Hessian of the objective function is sparse (i.e., relatively few nonzero
    cross-partial derivatives). See Braun, M. (2014) &lt;<a href="https://doi.org/10.18637%2Fjss.v060.i04">doi:10.18637/jss.v060.i04</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL (&ge; 2.0)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.2.18), Rcpp (&ge; 1.0.3), methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.3.7.0)</td>
</tr>
<tr>
<td>Copyright:</td>
<td>(c) 2015-2021 Michael Braun</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-07 17:54:10 UTC; braunm</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Braun <a href="https://orcid.org/0000-0003-4774-2119"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-11 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binary'>Binary choice example</h2><span id='topic+binary'></span><span id='topic+binary.f'></span><span id='topic+binary.grad'></span><span id='topic+binary.hess'></span>

<h3>Description</h3>

<p>Functions for binary choice example in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary.f(P, data, priors, order.row = FALSE)

binary.grad(P, data, priors, order.row = FALSE)

binary.hess(P, data, priors, order.row = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_+3A_p">P</code></td>
<td>
<p>Numeric vector of length (N+1)*k.  First N*k elements are heterogeneous coefficients. The remaining k elements are population parameters.</p>
</td></tr>
<tr><td><code id="binary_+3A_data">data</code></td>
<td>
<p>List of data matrices Y and X, and choice count integer T</p>
</td></tr>
<tr><td><code id="binary_+3A_priors">priors</code></td>
<td>
<p>List of named matrices inv.Omega and inv.Sigma</p>
</td></tr>
<tr><td><code id="binary_+3A_order.row">order.row</code></td>
<td>
<p>Determines order of heterogeneous coefficients in
parameter vector. Affects sparsity pattern of Hessian. See vignette.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hessian is sparse, and returned as a dgcMatrix object
</p>


<h3>Value</h3>

<p>Log posterior density, gradient and Hessian.
</p>

<hr>
<h2 id='binary-data'>Sample simulated data for binary choice model in vignette</h2><span id='topic+binary-data'></span>

<h3>Description</h3>

<p>Simulated data.  See vignette.  Generated from data-raw/binary.R
</p>

<hr>
<h2 id='trust.optim'>Nonlinear optimizers using trust regions.</h2><span id='topic+trust.optim'></span>

<h3>Description</h3>

<p>Run nonlinear minimizer using trust region algorithm with conjugate
gradient search directions and quasi-Hessian updates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trust.optim(
  x,
  fn,
  gr,
  hs = NULL,
  method = c("SR1", "BFGS", "Sparse"),
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trust.optim_+3A_x">x</code></td>
<td>
<p>A numeric vector of starting values for the optimizer.</p>
</td></tr>
<tr><td><code id="trust.optim_+3A_fn">fn</code></td>
<td>
<p>An R function that takes <code>x</code> as its first argument.
Returns the value of the objective function at <code>x</code>.
Note that the optimizer will <em>minimize</em> <code>fn</code> (see
function.scale.factor under control)</p>
</td></tr>
<tr><td><code id="trust.optim_+3A_gr">gr</code></td>
<td>
<p>An R function that takes x as its first argument.  Returns a
numeric vector that is the gradient of <code>fn</code> at <code>x</code>. The length of the gradient must be the same as the length of <code>x</code>.  The user must supply this function.  If an analytic gradient is not available, and the method is <code>SR1</code> or <code>BFGS</code>, the user should consider a numerical approximation using finite differencing (see the numDeriv package).  Do not use a finite-differenced gradient with the <code>Sparse</code> method.  That will cause a world of hurt.</p>
</td></tr>
<tr><td><code id="trust.optim_+3A_hs">hs</code></td>
<td>
<p>An R function that takes x as its first argument.
It returns a Hessian matrix object of class <code>dgCMatrix</code> (see the <span class="pkg">Matrix</span> package).
This function is called only if the selected method is <code>Sparse</code>.</p>
</td></tr>
<tr><td><code id="trust.optim_+3A_method">method</code></td>
<td>
<p>Valid arguments are <code>SR1</code>,<code>BFGS</code>,and <code>Sparse</code>.</p>
</td></tr>
<tr><td><code id="trust.optim_+3A_control">control</code></td>
<td>
<p>A list containing control parameters for the optimizer.
See details.</p>
</td></tr>
<tr><td><code id="trust.optim_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code>, <code>gr</code> and <code>hs</code>.
All arguments must be named.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the following items:
</p>
<table>
<tr><td><code>fval</code></td>
<td>
<p>Value of the objective function</p>
</td></tr>
<tr><td><code>solution</code></td>
<td>
<p>Parameter vector at the optimum</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>Gradient at the optimum</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Estimate of the Hessian at the optimum (as class
<code>symmetricMatrix</code>, returned only for <code>Sparse</code> method).</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of iterations before stopping</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>A message describing the last state of the iterator</p>
</td></tr>
<tr><td><code>nnz</code></td>
<td>
<p>For the Sparse method only, the number of nonzero elements in the lower triangle of the Hessian</p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>The following sections explain how to use the package as a whole.
</p>


<h3>Control parameters</h3>

<p>The control list should include the following parameters.
</p>

<dl>
<dt>start.trust.radius</dt><dd><p>Initial radius of the trust region. Default is 5.  If the algorithm returns non-finite values of the objective function early in the process, try a lower number.</p>
</dd>
<dt>stop.trust.radius</dt><dd><p>Minimum radius of trust region.  Algorithm will terminate if radius is below this value.  This is because it may not be possible to get the norm of the gradient smaller than prec, and this is another way to get the algorithm to stop.</p>
</dd>
<dt>cg.tol</dt><dd><p>tolerance for the conjugate gradient algorithm that is used for the trust region subproblem.  Set it to something very small.  Default is sqrt(.Machine$double.eps)</p>
</dd>
<dt>prec</dt><dd><p>Precision for how close the norm of the gradient at the
solution should be to zero, before the algorithm halts.  It is possible that the algorithm
will not get that far, so it will also stop when the radius of the
trust region is smaller thanstop.trust.radius.  If the trust
region radius collapses, but the norm of the gradient really isn't
close to zero, then something terrible has happened.</p>
</dd>
<dt>report.freq</dt><dd><p>An integer. The frequency at which the algorithm
will display the current iteration number or function value, among
other things (see <code>report.level</code>).  Defaults to 1.</p>
</dd>
<dt>report.level</dt><dd><p>The amount of detail in each report.  Defaults to 2.</p>
</dd>
<dt>report.precision</dt><dd><p>The number of significant digits used in each
report. Defaults to 5.</p>
</dd>
<dt>report.header.freq</dt><dd><p>The number of lines of iterations before the report column headers are reprinted.  Defaults to 25.</p>
</dd>
<dt>maxit</dt><dd><p>Maximum number of iterations.  Defaults to 100.</p>
</dd>
<dt>contract.factor</dt><dd><p>When the algorithm decides to shrink the trust region, it will multiply the trust radius by this factor. Defaults to 0.5.</p>
</dd>
<dt>expand.factor</dt><dd><p>When the algorithm decides to expand the trust
region, it will multiply the algorithm by this factor. Defaults to 3.</p>
</dd>
<dt>contract.threshold</dt><dd><p>The algorithm with accept a proposed move if the ratio of the actual improvement in the objective function, to the predicted improvement from the trust region subproblem, is greater than this amount.  Otherwise, the trust region will contract.  Default is 0.25.</p>
</dd>
<dt>expand.threshold.ap</dt><dd><p>First criterion to determine if the trust region should expand.  If the ratio of the actual and proposed improvements in the objective function is less than this factor, the algorithm will consider expanding the trust region.  See <code>expand.threshold.radius</code>. Default is 0.8.</p>
</dd>
<dt>expand.threshold.radius</dt><dd><p>If the ratio of the actual and proposed improvement in the objective function is less than <code>expand.threshold.ap</code>, then, if the normed distance of the proposed move is greater than <code>expand.threshold.radius</code>, times the current trust region radius, the trust region will expand.  Default is 0.8.</p>
</dd>
<dt>function.scale.factor</dt><dd><p>The algorithm will minimize <code>fn</code> times this
factor. If you want to maximize <code>fn</code>, this value should be negative
(usually -1).  Default is 1.</p>
</dd>
<dt>precond.refresh.freq</dt><dd><p>Frequency at which the preconditioner
for the conjugate gradiate estimation of the trust region
subproblem is reestimated.  Preconditioners can help the convergence properties of the algorithm.  Default is 1.</p>
</dd>
<dt>preconditioner</dt><dd><p>ID for choice of preconditioner.  0 is the
identity matrix (default), For the <code>Sparse</code> method, 1 is a modified Cholesky preconditioner. For the <code>BFGS</code> method, 1 is the full Cholesky decomposition.  If you select 1 for the <code>SR1</code> method, the algorithm will use the identity preconditioner instead.</p>
</dd>
<dt>trust.iter</dt><dd><p>Maximum number of conjugate gradient iterations to run when solving the trust region subproblem.  A higher number will lead to more accurate solutions to the subproblem, but may also lead to longer run times. Defaults to 2000.</p>
</dd>
</dl>



<h3>Report levels</h3>

<p>The <code>report.level</code> control parameter determines how much information is displayed each time the algorithm reports the current state.  Possible values are
</p>

<dl>
<dt>&lt;=0</dt><dd><p>No information (a quiet run)</p>
</dd>
<dt>1</dt><dd><p>Current iteration number, and current value of the objective function.</p>
</dd>
<dt>2</dt><dd><p>Information from level 1, plus the current norm of the gradient and a status message.</p>
</dd>
<dt>3</dt><dd><p>Information from levels 1 and 2, plus the current normed radius of the trust region.</p>
</dd>
<dt>4</dt><dd><p>Information from levels 1, 2, and 3, plus information from each estimate of the trust region subproblem (number of conjugate gradient iterations and how/why the CG algorithm terminated).</p>
</dd>
</dl>

<p>Default level is 2.  Levels 3 and 4 are available primarily for debugging purposes.
</p>


<h3>Stopping criteria</h3>

<p>The algorithm will stop when one of the following three conditions are met:
</p>

<ul>
<li><p>The norm of the gradient, divided by the square root of the number of parameters, is less than <code>prec</code>.
</p>
</li>
<li><p>The trust region collapse to a radius smaller than machine precision
</p>
</li>
<li><p>The algorithm proposes zero or negative improvement in the objective function (should never happen)
</p>
</li>
<li><p>The number of iterations reaches the control parameter <code>maxit</code>
</p>
</li></ul>

<p>If the algorithm appears to have stopped prematurely (i.e., the norm of the gradient is still too large), then one might just restart the algorithm.  For the quasi-Newton algorithms (<code>SR1</code> and <code>BFGS</code>), this will refresh the Hessian, and might allow more progress to be made.
</p>


<h3>Estimating a sparse Hessian</h3>

<p>Sometimes estimating the Hessian is easy (e.g., you have an analytic representation, or you are using some kind of algorithmic differentiation software).  If you do not know the Hessian, but you do know the sparsity structure, try the <span class="pkg">sparseHessianFD</span> package. The routines in <span class="pkg">sparseHessianFD</span> compute the Hessian using finite differencing, but in a way that exploits the sparsity structure.  In many cases, this can be faster than constructing an analytic Hessian for a large problem (e.g., when the Hessian has a block-arrow structure with a large number of blocks).
</p>
<p>To use the <span class="pkg">sparseHessianFD</span> package, you need to provide the row and column indices of the non-zero elements of the lower triangle of the Hessian. This structure cannot change during the course of the trust.optim routine.  Also, you really should provide an analytic gradient.  <span class="pkg">sparseHessianFD</span> computes finite differences of the gradient, so if the gradient itself is finite-differenced, so much error is propagated through that the Hessians are nearly worthless close to the optimum.
</p>
<p>Of course, <span class="pkg">sparseHessianFD</span> is useful only for the <code>Sparse</code> method.  That said, one may still get decent performance using these routines even if the Hessian is sparse, if the problem is not too large.  Just treat the Hessian as if it were sparse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(binary)
N &lt;- length(binary$Y)
k &lt;- NROW(binary$X)
start &lt;- rep(0,(N+1)*k)
priors &lt;- list(inv.Sigma = diag(k), inv.Omega = diag(k))
opt &lt;- trust.optim(start, fn=binary.f,
                  gr = binary.grad,
                  hs = binary.hess,
                  method = "Sparse",
                  control = list(
                      report.precision=1L,
                      function.scale.factor=-1
                  ),
                  data=binary, priors=priors
                  )

## End(Not run)

</code></pre>

<hr>
<h2 id='trustOptim'>Trust-region optimization</h2><span id='topic+trustOptim'></span>

<h3>Description</h3>

<p>Nonlinear optimizers using trust regions, with methods
optimized for sparse Hessians.
</p>


<h3>Details</h3>

<p>Trust region algorithm for nonlinear optimization. In addition to being more stable and robust than optim, this package includes methods that are scalable and efficient (in terms of both speed and memory usage) when the Hessian is sparse.
</p>


<h3>References</h3>

<p>Braun, Michael.  2014.  trustOptim:  An R Package for Trust Region
Optimization with Sparse Hessians. Journal of Statistical Software 60(4),
1-16. www.jstatsoft.org/v60/i04/.
</p>
<p>Nocedal, Jorge, and Stephen J Wright. 2006. Numerical Optimization.
Second edition. Springer.
</p>
<p>Steihaug, Trond. 1983. The Conjugate Gradient Method and Trust
Regions in Large Scale Optimization. SIAM Journal on Numerical
Analysis 20(3), 626-637.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
