<!DOCTYPE html><html><head><title>Help for package bigQF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigQF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bigQF-package'>
<p>Quadratic Forms in Large Matrices</p></a></li>
<li><a href='#famSKAT'>
<p>Implicit matrix for family-based SKAT test</p></a></li>
<li><a href='#pQF'>
<p>Tail probabilities for quadratic forms</p></a></li>
<li><a href='#seigen'>
<p>Stochastic singular value decomposition</p></a></li>
<li><a href='#seqMetaExample'>
<p>Example data, from seqMeta package</p></a></li>
<li><a href='#sequence'>
<p>Simulated human DNA variant sequence</p></a></li>
<li><a href='#SKAT.example'>
<p>Data example from SKAT package</p></a></li>
<li><a href='#SKAT.matrixfree'>
<p>Make 'matrix-free' object for SKAT test</p></a></li>
<li><a href='#sparse.matrixfree'>
<p>Make 'matrix-free' object from (sparse) Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quadratic Forms in Large Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lumley</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lumley &lt;t.lumley@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A computationally-efficient leading-eigenvalue approximation to tail probabilities and quantiles of large quadratic forms, in particular for the Sequence Kernel Association Test (SKAT) used in genomics &lt;<a href="https://doi.org/10.1002%2Fgepi.22136">doi:10.1002/gepi.22136</a>&gt;. Also provides stochastic singular value decomposition for dense or sparse matrices.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tslumley/bigQF">https://github.com/tslumley/bigQF</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>svd, CompQuadForm, Matrix, stats, coxme</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, SKAT</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-23 03:04:42 UTC; tlum005</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-23 10:10:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='bigQF-package'>
Quadratic Forms in Large Matrices
</h2><span id='topic+bigQF-package'></span><span id='topic+bigQF'></span>

<h3>Description</h3>

<p>A computationally-efficient leading-eigenvalue approximation to tail probabilities and quantiles of large quadratic forms, in particular for the Sequence Kernel Association Test (SKAT) used in genomics &lt;doi:10.1002/gepi.22136&gt;. Also provides stochastic singular value decomposition for dense or sparse matrices.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bigQF</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Quadratic Forms in Large Matrices</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Thomas Lumley</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Thomas Lumley &lt;t.lumley@auckland.ac.nz&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> A computationally-efficient leading-eigenvalue approximation to tail probabilities and quantiles of large quadratic forms, in particular for the Sequence Kernel Association Test (SKAT) used in genomics &lt;doi:10.1002/gepi.22136&gt;. Also provides stochastic singular value decomposition for dense or sparse matrices.</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/tslumley/bigQF</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> svd, CompQuadForm, Matrix, stats, coxme</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, rmarkdown, SKAT</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
SKAT.example            Data example from SKAT package
SKAT.matrixfree         Make 'matrix-free' object for SKAT test
bigQF-package           Quadratic Forms in Large Matrices
famSKAT                 Implicit matrix for family-based SKAT test
pQF                     Tail probabilities for quadratic forms
seigen                  Stochastic singular value decomposition
seqMetaExample          Example data, from seqMeta package
sequence                Simulated human DNA variant sequence
sparse.matrixfree       Make 'matrix-free' object from (sparse) Matrix
</pre>
<p>This package computes tail probabilities for large quadratic forms, with
the motivation being the SKAT test used in DNA sequence association
studies.
</p>
<p>The true distribution is a linear combination of 1-df chi-squared
distributions, where the coefficients are the non-zero eigenvalues of
the matrix <code>A</code> defining the quadratic form <code class="reqn">z^TAz</code>.  The package uses an
approximation to the distribution consisting of the largest <code>neig</code> terms in the
linear combination plus the Satterthwaite approximation to the rest of
the linear combination. 
</p>
<p>The main function is <code><a href="#topic+pQF">pQF</a></code>, which has options for how to
compute the leading eigenvalues (Lanczos-type algorithm or stochastic
SVD) and how to compute the linear combination (inverting the
characteristic function or a saddlepoint approximation).  The Lanczos
algorithm is from the <code>svd</code> package; the stochastic SVD can be
called directly via <code><a href="#topic+ssvd">ssvd</a></code> or <code><a href="#topic+seigen">seigen</a></code>
</p>
<p>Given a square matrix, <code>pQF</code> uses it as <code>A</code>. If the input is a
non-square matrix <code>M</code>, then <code>A</code> is <code>crossprod(M)</code>. The
function can also be used matrix-free, given an object containing
functions to compute the product and transpose-product by <code>M</code>. This last option
is described in the <code>"matrix-free"</code> vignette. The matrix-free
algorithm also uses a randomised estimator to estimate
the trace of <code>crossprod(A)</code>. The function <code>sparse.matrixfree</code> constructs a object for
matrix-free use of <code>pQF</code> from a sparse Matrix object. The
algorithms are described in the Lumley et al (2018) reference.
</p>
<p>Finally, there are functions specifically for the SKAT family of genomic
tests. These take a genotype matrix and an adjustment model as arguments
and produce an object that contains the test statistic in its
<code>Q</code> component and which can be used as an argument to <code>pQF</code> to
extract p-values: <code><a href="#topic+SKAT.matrixfree">SKAT.matrixfree</a></code> and <code>famSKAT</code>. The
vignette <code>"Checking pQF vs SKAT"</code> compares <code>SKAT.matrixfree</code>
to the <code>SKAT</code> package and illustrates how it can be used
</p>


<h3>Author(s)</h3>

<p>Thomas Lumley
</p>
<p>Maintainer: Thomas Lumley &lt;t.lumley@auckland.ac.nz&gt;
</p>


<h3>References</h3>

<p>Tong Chen, Thomas Lumley (2019) Numerical evaluation of methods approximating the distribution of a large quadratic form in normal variables. Computational Statistics &amp; Data Analysis.  139: 75-81,
</p>
<p>Lumley et al. (2018) Sequence kernel association tests for large sets of markers: tail probabilities for large quadratic forms. Genet Epidemiol
. 2018 Sep;42(6):516-527. doi: 10.1002/gepi.22136
</p>
<p>Nathan Halko, Per-Gunnar Martinsson, Joel A. Tropp (2010) Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions. <a href="https://arxiv.org/abs/0909.4061">https://arxiv.org/abs/0909.4061</a>.
</p>
<p>Lee, S., with contributions from Larisa Miropolsky, and Wu, M. (2015). SKAT: SNP-Set (Sequence) Kernel Association Test. R package version 1.1.2.
</p>
<p>Lee, S., Wu, M. C., Cai, T., Li, Y., Boehnke, M., and Lin,
X. (2011). Rare-variant association testing for sequencing data with the
sequence kernel association test. American Journal of Human Genetics,
89:82-93.
</p>

<hr>
<h2 id='famSKAT'>
Implicit matrix for family-based SKAT test
</h2><span id='topic+famSKAT'></span><span id='topic+update.famSKAT_lmekin'></span><span id='topic+update.famSKAT_genesis'></span><span id='topic+famSKAT.lmekin'></span><span id='topic+famSKAT.GENESIS.nullMixedModel'></span>

<h3>Description</h3>

<p>Like <code>link{SKAT.matrixfree}</code> but for the family-based test of Chen and colleagues
</p>


<h3>Usage</h3>

<pre><code class='language-R'>famSKAT(G, model,...)
## S3 method for class 'lmekin'
famSKAT(G, model, kinship,  weights = function(maf) dbeta(maf, 1, 25),...)
## S3 method for class 'GENESIS.nullMixedModel'
famSKAT(G, model, threshold=1e-10,  weights = function(maf) dbeta(maf, 1, 25),...)
## S3 method for class 'famSKAT_lmekin'
update(object,G,...)
## S3 method for class 'famSKAT_genesis'
update(object,G,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="famSKAT_+3A_g">G</code></td>
<td>

<p>A 0/1/2 matrix whose columns are markers and whose rows are samples. Should be mostly zero.
</p>
</td></tr>
<tr><td><code id="famSKAT_+3A_model">model</code></td>
<td>

<p>Object representing a linear mixed model for covariate adjustment. Current methods are for class <code>lmekin</code> which must have been fitted with <code>x=TRUE</code>, and for the output of <code>fitNullMM</code> from the <code>GENESIS</code> package.
</p>
</td></tr>
<tr><td><code id="famSKAT_+3A_kinship">kinship</code></td>
<td>

<p>The sparse kinship matrix: the <code>model</code> will have used <code>2*kinship</code> in its <code>varlist</code> argument.
</p>
</td></tr>
<tr><td><code id="famSKAT_+3A_threshold">threshold</code></td>
<td>

<p>A threshold for setting elements of the phenotype precision matrix to exact zeros.
</p>
</td></tr>
<tr><td><code id="famSKAT_+3A_weights">weights</code></td>
<td>

<p>A weight function used in SKAT: the default is the standard one.
</p>
</td></tr>
<tr><td><code id="famSKAT_+3A_object">object</code></td>
<td>
<p>An existing <code>famSKAT</code> object to be updated with a new set of genotypes (eg for a new gene or genomic window), keeping the same phenotype and kinship structure.  Avoids recomputing the Cholesky square root of the phenotype variance matrix, which will often be a computational bottleneck.
</p>
</td></tr>
<tr><td><code id="famSKAT_+3A_...">...</code></td>
<td>
<p>for future expansion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("famSKAT","matrixfree")</code>
</p>


<h3>Note</h3>

<p>The matrix and test statistic both differ by a factor of <code>var(y)/2</code> from <code>SKAT.matrixfree</code> when used with unrelated individuals (because the Chen et al reference differs from the original SKAT paper by the same factor)
</p>


<h3>References</h3>

<p>Chen H, Meigs JM, Dupuis J (2013) Sequence Kernel Association Test for Quantitative Traits in Family Samples. Genet Epidemiol. 37(2): 196-204.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SKAT.matrixfree">SKAT.matrixfree</a></code>, <code><a href="#topic+pQF">pQF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seqMetaExample)

m&lt;-coxme::lmekin(y~sex+bmi+(1|id),data=pheno2,varlist=2*kins,
	x=TRUE,y=TRUE,method="REML")

#first gene
g1snps&lt;-c("1000001", "1000002", "1000003", "1000004", "1000005", "1000006", 
"1000007", "1000008", "1000009", "1000010", "1000012", "1000013", 
"1000014", "1000015")
Z2gene1&lt;-Z2[,g1snps]

f&lt;-famSKAT(Z2gene1, m, kins)
Q&lt;-f$Q()
all.equal(Q, 56681.209)
## correct p is 0.742756401
pQF(Q,f,neig=4)

## gene10
g10snps&lt;-as.character(1000017:1000036)
Z2gene10&lt;-Z2[,g10snps]
f10&lt;-update(f, Z2gene10)
Q10&lt;-f10$Q()
all.equal(Q10,164656.19)
pQF(Q10,f10,neig=4)


</code></pre>

<hr>
<h2 id='pQF'>
Tail probabilities for quadratic forms
</h2><span id='topic+pQF'></span>

<h3>Description</h3>

<p>Computes the upper tail probability for quadratic forms in standard Normal variables, using a leading-eigenvalue approximation that is feasible even for large matrices. Can take advantage of sparse matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pQF(x, M, method = c("ssvd", "lanczos", "satterthwaite"), neig = 100,
  tr2.sample.size = 500, q = NULL,
  convolution.method = c("saddlepoint", "integration"),
  remainder.underflow=c("warn","missing","error"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pQF_+3A_x">x</code></td>
<td>

<p>Vector of quantiles to compute tail probabilities
</p>
</td></tr>
<tr><td><code id="pQF_+3A_m">M</code></td>
<td>

<p>If <code>M</code> is square, it is the matrix in the quadratic form and is assumed to be symmetric. If it is not square, <code>crossprod(M)</code> is the matrix in the quadratic form, although this matrix is never formed explicitly. It can also be an object of class <code>"matrixfree"</code> to allow matrix-free multiplication for, eg, sparse matrices; see <code><a href="#topic+SKAT.matrixfree">SKAT.matrixfree</a></code> for an example.
</p>
</td></tr>
<tr><td><code id="pQF_+3A_method">method</code></td>
<td>
<p> Use stochastic SVD (&quot;ssvd&quot;) or a thick-restarted Lanczos algorithm (&quot;lanczos&quot;) to extract the leading eigenvalues, or use the naive Satterthwaite approximation (&quot;satterthwaite&quot;)</p>
</td></tr>
<tr><td><code id="pQF_+3A_neig">neig</code></td>
<td>

<p>Number of leading eigenvalues to use
</p>
</td></tr>
<tr><td><code id="pQF_+3A_tr2.sample.size">tr2.sample.size</code></td>
<td>

<p>When <code>M</code> is not square, a randomised estimator for the trace of <code>crossprod(M)^2</code> is used. This is the sample size. When <code>M</code> is of <code>"matrixfree"</code> and does not include the trace of crossprod(M) as a component, this sample size will also be used to compute that. See Hutchinson reference. </p>
</td></tr>
<tr><td><code id="pQF_+3A_q">q</code></td>
<td>

<p>Power iteration parameter for the stochastic SVD (see the Halko et al reference)
</p>
</td></tr>
<tr><td><code id="pQF_+3A_convolution.method">convolution.method</code></td>
<td>

<p>For either the &quot;ssvd&quot; or &quot;lanczos&quot; methods, how the convolution of the leading-eigenvalue terms is performed: by Kuonen's saddlepoint approximation or Davies' algorithm inverting the characteristic function
</p>
</td></tr>
<tr><td><code id="pQF_+3A_remainder.underflow">remainder.underflow</code></td>
<td>

<p>How should underflow of the remainder term (see Details) be handled? The default is a warning, with <code>"error"</code> an error is thrown, and with <code>"miss"</code> the return value will be <code>NaN</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Increasing <code>neig</code> or <code>q</code> will improve the accuracy of approximation. In simulated human sequence data, <code>neig=100</code> is satisfactory for 5000 samples and markers. Increasing <code>q</code> should help when the singular values of <code>M</code> decrease slowly.  The default sample size for the randomized trace estimator seems to be large enough.
</p>
<p>If the remainder term in the approximation has less than 1 degree of freedom it will be dropped, and <code>remainder.underflow</code> controls how this is handled. The approximation will then be anticonservative, but usually not seriously so. 
</p>
<p>In earlier versions, <code>method="satterthwaite"</code> rounded the number of
degrees of freedom up to the next integer; it now does not round.
</p>
<p>In the current version when <code>M</code> is of class <code>"matrix-free"</code>
and <code>method="ssvd"</code>, an improved estimator of the remainder term is
used. Instead of using Hutchinson's randomised trace estimator and
subtracting the known eigenvalues, we apply the randomised trace
estimator after projecting orthogonal to the known eigenvectors. After
more evaluation, the improvement is likely to be extended to the other
methods for rectangular matrices.
</p>
<p>By default, Davies's algorithm is run with a tolerance of <code>1e-9</code>. This can be changed by setting, eg,  <code>options(bigQF.davies.threshold=1e-12)</code>
</p>


<h3>Value</h3>

<p>Vector of upper tail probabilities
</p>


<h3>Author(s)</h3>

<p>Thomas Lumley
</p>


<h3>References</h3>

<p>Lumley et al. (2018) &quot;Sequence kernel association tests for large sets of markers: tail probabilities for large quadratic forms&quot; Genet Epidemiol. 2018 Sep;42(6):516-527. doi: 10.1002/gepi.22136
</p>
<p>Tong Chen, Thomas Lumley (2019) Numerical evaluation of methods approximating the distribution of a large quadratic form in normal variables. Computational Statistics &amp; Data Analysis.  139: 75-81,
</p>
<p>Thomas Lumley (2017) &quot;How to add chi-squareds&quot; <a href="https://notstatschat.rbind.io/2017/12/06/how-to-add-chi-squareds/">https://notstatschat.rbind.io/2017/12/06/how-to-add-chi-squareds/</a>
</p>
<p>Thomas Lumley (2016) &quot;Large quadratic forms&quot; <a href="https://notstatschat.rbind.io/2016/09/27/large-quadratic-forms/">https://notstatschat.rbind.io/2016/09/27/large-quadratic-forms/</a>
</p>
<p>Nathan Halko, Per-Gunnar Martinsson, Joel A. Tropp (2010) &quot;Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions&quot; <a href="https://arxiv.org/abs/0909.4061">https://arxiv.org/abs/0909.4061</a>.
</p>
<p>Hutchinson, M. F. (1990). A stochastic estimator of the trace of the influence matrix for Laplacian smoothing splines. Communications in Statistics - Simulation and Computation, 19(2):433-450.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssvd">ssvd</a></code>,<code><a href="#topic+SKAT.matrixfree">SKAT.matrixfree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sequence)
dim(sequence)

skat&lt;-SKAT.matrixfree(sequence)
skat$trace
pQF(c(33782471,7e7,1e8),skat, n=100)


# Don't run these; they take a few minutes
G&lt;-sequence
wuweights&lt;-function(maf) dbeta(maf,1,25)
tmp&lt;-wuweights(colMeans(G)/2)*t(G)
tildeGt&lt;-t(tmp-rowMeans(tmp))/sqrt(2)
sum(tildeGt^2)

pQF(c(33782471,7e7,1e8), tildeGt, n=100)

H&lt;-crossprod(tildeGt)
pQF(c(33782471,7e7,1e8), H, n=100)



</code></pre>

<hr>
<h2 id='seigen'>
Stochastic singular value decomposition
</h2><span id='topic+seigen'></span><span id='topic+ssvd'></span>

<h3>Description</h3>

<p>Extract the leading eigenvalues of a large matrix and their eigenvectors, using random projections. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssvd(M, n,U=FALSE, V=FALSE,q=3, p=10) 
seigen(M, n, only.values = TRUE, q = 3, symmetric = FALSE, spd = FALSE, p = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seigen_+3A_m">M</code></td>
<td>

<p>A square matrix
</p>
</td></tr>
<tr><td><code id="seigen_+3A_n">n</code></td>
<td>

<p>Number of eigenvalues to extract
</p>
</td></tr>
<tr><td><code id="seigen_+3A_u">U</code>, <code id="seigen_+3A_v">V</code></td>
<td>
<p>If <code>TRUE</code> return the left (respectively, right) singular vectors as well as the singular values</p>
</td></tr>
<tr><td><code id="seigen_+3A_only.values">only.values</code></td>
<td>

<p>If <code>TRUE</code>, only extract the eigenvalues, otherwise also extract corresponding eigenvectors
</p>
</td></tr>
<tr><td><code id="seigen_+3A_q">q</code></td>
<td>

<p>Number of power iterations to use in constructing the projection basis (zero or more)
</p>
</td></tr>
<tr><td><code id="seigen_+3A_symmetric">symmetric</code></td>
<td>

<p>If <code>TRUE</code>, assume the matrix is symmetric
</p>
</td></tr>
<tr><td><code id="seigen_+3A_spd">spd</code></td>
<td>

<p>If <code>TRUE</code>, assume the matrix is positive definite and use the Nystrom method to improve estimation. 
</p>
</td></tr>
<tr><td><code id="seigen_+3A_p">p</code></td>
<td>

<p>The oversampling parameter: number of extra dimensions above n for the random projection
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters p and q are as in the reference. Both functions use Algorithm 4.3 to construct a projection; <code>ssvd</code> then uses Algorithm 5.1. 
With <code>spd=TRUE</code>, <code>seigen</code> uses Algorithm  5.5, otherwise Algorithm 5.3
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>eigenvalues</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>matrix whose columns are the corresponding eigenvectors</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Unlike the Lanczos-type algorithms, this is accurate only for large matrices.
</p>


<h3>Author(s)</h3>

<p>Thomas Lumley
</p>


<h3>References</h3>

<p>Nathan Halko, Per-Gunnar Martinsson, Joel A. Tropp (2010) &quot;Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions&quot; <a href="https://arxiv.org/abs/0909.4061">https://arxiv.org/abs/0909.4061</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ssvd">ssvd</a></code>, <code><a href="base.html#topic+eigen">eigen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sequence)
G&lt;-sequence[1:1000,]
H&lt;-tcrossprod(G)
seigen(H,n=10,spd=TRUE,q=5)


eigen(H, symmetric=TRUE,only.values=TRUE)$values[1:10]

  
</code></pre>

<hr>
<h2 id='seqMetaExample'>
Example data, from seqMeta package
</h2><span id='topic+seqMetaExample'></span><span id='topic+Z1'></span><span id='topic+Z2'></span><span id='topic+pheno1'></span><span id='topic+pheno2'></span><span id='topic+kins'></span>

<h3>Description</h3>

<p>Contains simulated data for two cohorts taken from the seqMeta package. The individual genes are too small for this to be a good use of the leading-eigenvalue approximation, but the data at least allow basic numerical comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seqMetaExample)</code></pre>


<h3>Format</h3>

<p>This contains simulated data for two cohorts
</p>

<dl>
<dt><code>Z1</code>,<code>Z2</code></dt><dd>
<p>Genotype matrices for cohorts 1 and 2 respectively
</p>
</dd>
<dt><code>pheno1</code>,<code>pheno2</code></dt><dd>
<p>phenotype matrices for cohorts 1 and 2 respectively
</p>
</dd>
<dt>kins</dt><dd>
<p>The kinship matrix for cohort 2
</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/DavisBrian/seqMeta">https://github.com/DavisBrian/seqMeta</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(seqMetaExample)

m&lt;-coxme::lmekin(y~sex+bmi+(1|id),data=pheno2,varlist=2*kins,
	x=TRUE,y=TRUE,method="REML")

#first gene
g1snps&lt;-c("1000001", "1000002", "1000003", "1000004", "1000005", "1000006", 
"1000007", "1000008", "1000009", "1000010", "1000012", "1000013", 
"1000014", "1000015")
Z2gene1&lt;-Z2[,g1snps]

f&lt;-famSKAT(Z2gene1, m, kins)
Q&lt;-f$Q()
all.equal(Q, 56681.209)
## correct p is 0.742756401
pQF(Q,f,neig=4)


</code></pre>

<hr>
<h2 id='sequence'>
Simulated human DNA variant sequence
</h2><span id='topic+sequence'></span>

<h3>Description</h3>

<p>A matrix with number of copies of the minor allele for 4028 variants on 5000 people, simulated using the Markov Coalescent Simulator of Chen and coworkers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("sequence")</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:5000, 1:4028] 0 0 0 0 0 0 0 0 0 0 ...
</p>


<h3>Source</h3>

<p><a href="https://github.com/gchen98/macs">https://github.com/gchen98/macs</a>
</p>


<h3>References</h3>

<p>Gary K Chen, Paul Marjoram, and Jeffrey D. Wall (2009) Fast and flexible simulation of DNA sequence data Genome Research 19:136-142. <a href="http://genome.cshlp.org/content/19/1/136">http://genome.cshlp.org/content/19/1/136</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sequence)
summary(colMeans(sequence))
</code></pre>

<hr>
<h2 id='SKAT.example'>
Data example from SKAT package
</h2><span id='topic+SKAT.example'></span>

<h3>Description</h3>

<p>These data (probably synthetic) come from the SKAT package. The data set is too small for the leading-eigenvalue approximation to really make sense, but it provides some numerical comparison.  The SKAT Q statistic should match exactly, the p-values should be fairly close.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SKAT.example")</code></pre>


<h3>Format</h3>

<p>SKAT.example contains the following objects:
</p>

<dl>
<dt>Z</dt><dd><p>a numeric genotype matrix of 2000 individuals and 67 SNPs. 
Each row represents a different individual, and each column represents a different SNP marker. </p>
</dd>
<dt>X</dt><dd><p>a numeric matrix of 2 covariates. </p>
</dd>
<dt>y.c</dt><dd><p>a numeric vector of continuous phenotypes.</p>
</dd>
<dt>y.b</dt><dd><p>a numeric vector of binary phenotypes.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.hsph.harvard.edu/skat/">https://www.hsph.harvard.edu/skat/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SKAT.example)

skat1mf &lt;- SKAT.matrixfree(SKAT.example$Z)
Q&lt;-skat1mf$Q(SKAT.example$y.c)
all.equal(as.numeric(Q), 234803.786)
## correct value is 0.01874576
pQF(Q, skat1mf, neig=4, convolution.method="integration")

skat2mf &lt;- SKAT.matrixfree(SKAT.example$Z, model=lm(y.c~1, data=SKAT.example))
Q&lt;-skat2mf$Q()
all.equal(Q, 234803.786)
## correct value is 0.01874576
pQF(Q, skat2mf, neig=4, convolution.method="integration")

skat3mf &lt;- SKAT.matrixfree(SKAT.example$Z, model=lm(y.c~X, data=SKAT.example))
Q&lt;-skat3mf$Q()
all.equal(Q, 298041.542)
## correct value is 0.002877041
pQF(Q, skat3mf, neig=4, convolution.method="integration")


</code></pre>

<hr>
<h2 id='SKAT.matrixfree'>
Make 'matrix-free' object for SKAT test
</h2><span id='topic+SKAT.matrixfree'></span><span id='topic+SKAT.matrixfree.lm'></span><span id='topic+SKAT.matrixfree.glm'></span><span id='topic+SKAT.matrixfree.lmekin'></span>

<h3>Description</h3>

<p>'Matrix-free' or 'implicit' linear algebra uses a matrix only through the linear operations of multiplying by the matrix or its transpose. It's suitable for sparse matrices, and also for structured matrices that are not sparse but still have fast algorithms for multiplication.  The Sequence Kernel Association Test is typically performed on sparse genotype data, but the matrix involved in computations has been centered and is no longer sparse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SKAT.matrixfree(G,weights=function(maf) dbeta(maf,1,25), model=NULL,...)
## S3 method for class 'lm'
SKAT.matrixfree(G,weights=function(maf) dbeta(maf,1,25), model=NULL,...)
## S3 method for class 'glm'
SKAT.matrixfree(G,weights=function(maf) dbeta(maf,1,25), model=NULL,...)
## S3 method for class 'lmekin'
SKAT.matrixfree(G,weights=function(maf) dbeta(maf,1,25), model=NULL, kinship,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKAT.matrixfree_+3A_g">G</code></td>
<td>

<p>A 0/1/2 matrix whose columns are markers and whose rows are samples. Should be mostly zero.
</p>
</td></tr>
<tr><td><code id="SKAT.matrixfree_+3A_weights">weights</code></td>
<td>

<p>A weight function used in SKAT: the default is the standard one.
</p>
</td></tr>
<tr><td><code id="SKAT.matrixfree_+3A_model">model</code></td>
<td>

<p>A  linear model, generalised linear model, or <code>lmekin</code> object used for adjustment, or <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="SKAT.matrixfree_+3A_kinship">kinship</code></td>
<td>
<p>A (sparse) kinship matrix. The <code>model</code> will have used <code>2*kinship</code> in its
<code>varlist</code> argument.
</p>
</td></tr>
<tr><td><code id="SKAT.matrixfree_+3A_...">...</code></td>
<td>
<p>to keep CMD check happy</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the adjustment model is <code>NULL</code> the object contains the trace of the underlying quadratic form, if the adjustment model is not <code>NULL</code> the trace will be estimated using Hutchinson's randomised estimator inside <code><a href="#topic+pQF">pQF</a></code>.  The <code>lmekin</code> method calls <code><a href="#topic+famSKAT">famSKAT</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>matrixfree</code>
</p>


<h3>Author(s)</h3>

<p>Thomas Lumley
</p>


<h3>References</h3>

<p>Lee, S., with contributions from Larisa Miropolsky, and Wu, M. (2015). SKAT: SNP-Set (Sequence) Kernel Association Test. R package version 1.1.2.
</p>
<p>Lee, S., Wu, M. C., Cai, T., Li, Y., Boehnke, M., and Lin, X. (2011). Rare-variant association testing for sequencing data with the sequence kernel association test. American Journal of Human Genetics, 89:82-93.
</p>
<p>Wu, M. C., Kraft, P., Epstein, M. P., Taylor, D. M., Channock, S. J., Hunter, D. J., and Lin, X. (2010). Powerful SNP set analysis for case-control genome-wide association studies. American Journal of Human Genetics, 86:929-942.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pQF">pQF</a></code>
<code><a href="#topic+sparse.matrixfree">sparse.matrixfree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sequence)
skat&lt;-SKAT.matrixfree(sequence)
skat$trace
pQF(c(33782471,7e7,1e8), skat,n=100, tr2.sample.size=500)

data(SKAT.example)

skat1mf &lt;- SKAT.matrixfree(SKAT.example$Z)
(Q&lt;-skat1mf$Q(SKAT.example$y.c))
all.equal(as.numeric(Q), 234803.786)

## correct value is 0.01874576
pQF(Q, skat1mf, neig=4, convolution.method="integration")


skat3mf &lt;- SKAT.matrixfree(SKAT.example$Z, model=lm(y.c~X, data=SKAT.example))
(Q&lt;-skat3mf$Q())
all.equal(Q, 298041.542)

## correct value is 0.002877041
pQF(Q, skat3mf, neig=4, convolution.method="integration")


</code></pre>

<hr>
<h2 id='sparse.matrixfree'>
Make 'matrix-free' object from (sparse) Matrix
</h2><span id='topic+sparse.matrixfree'></span>

<h3>Description</h3>

<p>Packages a matrix (which will typically be a sparse Matrix) for 'matrix-free' or 'implicit' stochastic SVD. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse.matrixfree(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse.matrixfree_+3A_m">M</code></td>
<td>

<p>A matrix or Matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>'matrixfree'</code>, with components
</p>
<table>
<tr><td><code>mult</code></td>
<td>
<p>Function to multiply by <code>M</code></p>
</td></tr>
<tr><td><code>tmult</code></td>
<td>
<p>Function to multiply by <code>t(M)</code></p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>trace of <code>t(M)%*%M</code>, needed for <code><a href="#topic+pQF">pQF</a></code></p>
</td></tr>
<tr><td><code>ncol</code></td>
<td>
<p>dimensions of <code>M</code></p>
</td></tr>
<tr><td><code>nrow</code></td>
<td>
<p>dimensions of <code>M</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Lumley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pQF">pQF</a></code>,<code>link{seigen}</code>,<code><a href="#topic+ssvd">ssvd</a></code>, <code><a href="#topic+SKAT.matrixfree">SKAT.matrixfree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sequence)
Msp&lt;-sparse.matrixfree(sequence)
ssvd(Msp,n=10)


## this is slow, don't run it
svd(sequence,nu=0,nv=0)$d[1:10]



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
