<!DOCTYPE html><html><head><title>Help for package ClinicalUtilityRecal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ClinicalUtilityRecal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calCurvPlot'>
<p>Calibration Curve Plot</p></a></li>
<li><a href='#calWt'>
<p>Calibration Weights</p></a></li>
<li><a href='#constRecal'>
<p>Constrained Logistic Recalibration</p></a></li>
<li><a href='#cvRepWtTuning'>
<p>Repeated Cross Validation for Weight Tuning Parameter Selection</p></a></li>
<li><a href='#cvWtTuning'>
<p>Cross-validation for Selecting Weight Tuning Parameter</p></a></li>
<li><a href='#fakeData'>
<p>Dataset for Recalibration Purposes</p></a></li>
<li><a href='#nb'>
<p>Net Benefit</p></a></li>
<li><a href='#RAWgrid'>
<p>RAW grid for Cross Validation</p></a></li>
<li><a href='#snbRecalPlot'>
<p>Plot of Potential sNB Under Recalibration</p></a></li>
<li><a href='#stdRecal'>
<p>Standard Logistic Recalibration</p></a></li>
<li><a href='#wtRecal'>
<p>Weighted Logistic Recalibration</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Recalibration Methods for Improved Clinical Utility of Risk
Scores</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Anu Mishra</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anu Mishra &lt;anmishra@uw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Recalibrate risk scores (predicting binary outcomes) to improve clinical utility of risk score using weighted logistic or constrained logistic recalibration methods. Additionally, produces plots to assess the potential for recalibration to improve the clinical utility of a risk model. Methods are described in detail in Mishra, A. (2019) "Methods for Risk Markers that Incorporate Clinical Utility" <a href="http://hdl.handle.net/1773/44068">http://hdl.handle.net/1773/44068</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, caret, ggplot2, stats, cowplot, nloptr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-14 02:47:45 UTC; anu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-15 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calCurvPlot'>
Calibration Curve Plot
</h2><span id='topic+calCurvPlot'></span>

<h3>Description</h3>

<p>Flexible function for plotting the calibration curve for a risk score and different recalibrations of a risk score. Histograms of risk score and recalibrated risk scores can be plotted using argument &quot;hist==TRUE&quot;. Dotted guidelines for the risk threshold R are plotted and clinically releavant risk region [R_l, R_u] are plotted to help gauge calibration in clinically relevants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calCurvPlot(y,p,p.std=NULL,p.recal=NULL,
            stdPlot=FALSE, recalPlot=FALSE,
            xlim=c(0,1),ylim=c(0,1),
            label="Original Risk Score",
            label2 = "Standard Recalibrated Risk Score",
            label3 = "Weighted/Constrained Recalibrated Risk Score",
            legendLab = c("Orig.", "Std.", "Wt."),
            mainTitle="Calibration of Risk Score",
            hist=TRUE,ylimHist = c(0,0.5),
            r,rl = -Inf, ru = Inf)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calCurvPlot_+3A_y">y</code></td>
<td>
<p>Vector of binary outcomes, with 1 indicating event (case) and 0 indicating no event                 (controls)</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_p">p</code></td>
<td>
<p>Vector of risk score values</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_p.std">p.std</code></td>
<td>
<p>Vector of risk score values after standard logistic recalibration</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_p.recal">p.recal</code></td>
<td>
<p>Vector of risk score values after weighted/contratined logistic recalibration</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_stdplot">stdPlot</code></td>
<td>
<p>If TRUE plot calibration curve for standard logistic recalibrated risk score </p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_recalplot">recalPlot</code></td>
<td>
<p>If TRUE plot calibration curve for weighted/contratined recalibrated risk score </p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_xlim">xlim</code></td>
<td>
<p>Limits for x-axis</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_ylim">ylim</code></td>
<td>
<p>Limits for y-axis</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_label">label</code></td>
<td>
<p>Label for x-axis corresponding to p vector</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_label2">label2</code></td>
<td>
<p>Label for x-axis corresponding to p.std vector</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_label3">label3</code></td>
<td>
<p>Label for x-axis corresponding to p.recal vector</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_legendlab">legendLab</code></td>
<td>
<p>Label for legend</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_maintitle">mainTitle</code></td>
<td>
<p>Main title for plot</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_hist">hist</code></td>
<td>
<p>If true plot distribution of risk scores along with calibration curve</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_ylimhist">ylimHist</code></td>
<td>
<p>Limits for y-axis of histogram</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_r">r</code></td>
<td>
<p>Clinically relevant risk threshold used indicated with dotted line</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_rl">rl</code></td>
<td>
<p>Lower bound of clinically relevant region indicated with dotted-dashed line</p>
</td></tr>
<tr><td><code id="calCurvPlot_+3A_ru">ru</code></td>
<td>
<p>Upper bound of clinically relevant region indicated with dotted-dashed line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints calibration plot of risk model p, and optional histogram of risk score</p>


<h3>Author(s)</h3>

<p>Anu Mishra
</p>


<h3>References</h3>

<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("fakeData")

### get standard recalibrated risk score
stdRecal.res &lt;- stdRecal(y = fakeData$y,p = fakeData$p)
p.std &lt;- stdRecal.res$p.std

### Select tuning parameter lamba using 5-fold cross-validation repeated 25 times
grid &lt;- RAWgrid(r = 0.3,rl = -Inf,ru = Inf,p = fakeData$p,y = fakeData$y,
                cvParm = "lambda",rl.raw = 0.25,ru.raw = 0.35)
repCV &lt;- cvRepWtTuning(y = fakeData$y,p = fakeData$p,rl = -Inf,ru = Inf,r = 0.3,
                       kFold = 5,cvRep = 25,cvParm = "lambda",tuneSeq = grid,stdErrRule = TRUE)

## Implement weighted logistic recalibration
wtRecal.res &lt;- wtRecal(y = fakeData$y,p = fakeData$p,r = 0.3,rl = -Inf,ru = Inf,
                       lambda = repCV$cv.lambda,delta=1)
p.recal &lt;- wtRecal.res$p.wt

### Calibration curve of only original risk score with histogram
calCurvPlot(y=fakeData$y,p=fakeData$p,p.std=NULL,p.recal=NULL,
            stdPlot=FALSE, recalPlot=FALSE,
            xlim=c(0,1),ylim=c(0,1),
            label="Original Risk Score",
            label2 = "Standard Recalibrated Risk Score",
            label3 = "Weighted/Constrained Recalibrated Risk Score",
            legendLab = c("Orig.", "Std.", "Wt."),
            mainTitle="Calibration of Risk Score",
            hist=TRUE,ylimHist = c(0,0.5),
            r=0.3,rl = -Inf, ru = Inf)

### Calibration curve of only original, standard and weighted recalibrated risk score
calCurvPlot(fakeData$y,p=fakeData$p,p.std=p.std,p.recal=p.recal,
            stdPlot=TRUE, recalPlot=TRUE,
            xlim=c(0,1),ylim=c(0,1),
            label="Original Risk Score",
            label2 = "Standard Recalibrated Risk Score",
            label3 = "Weighted/Constrained Recalibrated Risk Score",
            legendLab = c("Orig.", "Std.", "Wt."),
            mainTitle="Calibration of Risk Score",
            hist=TRUE,ylimHist = c(0,0.5),
            r=0.3,rl = -Inf, ru = Inf)

## End(Not run)
</code></pre>

<hr>
<h2 id='calWt'>
Calibration Weights
</h2><span id='topic+calWt'></span>

<h3>Description</h3>

<p>Calculates observation weights used for weighted calibration method using LOESS smoother. Observations with predicted risks outside clinically relevant interval [Rl,Ru] are downweighted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calWt(rl,ru,p,y,r,lambda,delta,returnSmoothedEvent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calWt_+3A_rl">rl</code></td>
<td>

<p>Lower bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="calWt_+3A_ru">ru</code></td>
<td>

<p>Upper bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="calWt_+3A_p">p</code></td>
<td>

<p>Vector of risk score values</p>
</td></tr>
<tr><td><code id="calWt_+3A_y">y</code></td>
<td>

<p>Vector of binary outcomes, with 1 indicating event (cases) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code id="calWt_+3A_r">r</code></td>
<td>

<p>Clinically relevant risk threshold</p>
</td></tr>
<tr><td><code id="calWt_+3A_lambda">lambda</code></td>
<td>

<p>Tuning parameter for weights inside relevant region</p>
</td></tr>
<tr><td><code id="calWt_+3A_delta">delta</code></td>
<td>

<p>Weight assigned to observations outside relevant region
</p>
</td></tr>
<tr><td><code id="calWt_+3A_returnsmoothedevent">returnSmoothedEvent</code></td>
<td>

<p>If TRUE returns smoothed observed event rate used for calculationg weights
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes observation weights for weighted recalibration method. Observations with risk scores near a pre-defined clinically relevant risk threshold <code class="reqn">r</code> are given weights near 1, while observations far from the risk threshold are down-weighted.
</p>
<p>For observations with risk scores within a pre-defined clinically relevant region [R_l, R_u], the weighting function follows an exponential decay form with observations recieving smaller weights as they move farther from the clincally relevant risk threhsold. Distance is measured by the squared difference between the risk threshold and <code class="reqn">o(p_i)</code>, where <code class="reqn">o(p_i)</code> isa smoothed observed event rate,obtained via LOESS regression of <code class="reqn">y</code> on the risk scores <code class="reqn">p_i</code>.
</p>
<p>The amount of decay is set by the tuning parameter <code class="reqn">\lambda</code>, with larger lambda indicating little down-weighting applied. For observations outside the clinically relevant risk interval, a weight of <code class="reqn">delta</code> is assigned. An indicator type weight can be choosen by select large <code class="reqn">\lambda</code> (e.g <code class="reqn">\lambda=10</code>). Clinically relevant region can be [R_l, R_u] = [<code class="reqn">-\infty</code>,<code class="reqn">\infty</code>], and in these cases it is not necessary to specify <code class="reqn">delta</code>. See Mishra et al (2020) for functional form of weights and more details.</p>


<h3>Value</h3>



<table>
<tr><td><code>wt</code></td>
<td>
<p>Vector of weights, between 0 and 1, to be used for weighted recalibration</p>
</td></tr>
<tr><td><code>o</code></td>
<td>
<p>Vector of smoothed observed event rates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anu Mishra
</p>


<h3>References</h3>

<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)</p>


<h3>See Also</h3>

<p><code><a href="#topic+wtRecal">wtRecal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data
data(fakeData)

#exponential decay type weight
expWt &lt;- calWt(rl=-Inf,ru=Inf,p=fakeData$p,y=fakeData$y,r=0.2,
                lambda=0.05,delta=0.2,returnSmoothedEvent = TRUE)
plot(expWt$o,expWt$wt,xlab="Smoothed Observed Event Rate",
     ylab="Calibration Weight",ylim=c(0,1))


#indicator type weight
indWt &lt;- calWt(rl=0.1,ru=0.3,p=fakeData$p,y=fakeData$y,r=0.2,
                lambda=0.05,delta=0.2,returnSmoothedEvent = TRUE)
plot(indWt$o,indWt$wt,xlab="Smoothed Observed Event Rate",
    ylab="Calibration Weight",ylim=c(0,1))
</code></pre>

<hr>
<h2 id='constRecal'>
Constrained Logistic Recalibration
</h2><span id='topic+constRecal'></span>

<h3>Description</h3>

<p>When recalibrating a risk model, where the intended purpose of the risk model is to prescribe an intervention to those deemed at high risk, it is desirable to have good calibration at the clinically relevant threshold used to define high risk (i.e. threshold used to identify who recieves treatment). This can be achieved by maximizing the clinical utilty of a risk model, which should in turn produce good calibration near the clinical relevant risk threshold. This function realibrates risk scores (predicting binary outcome) by estimating the recalibration intercept and slope by maximizing the logistic likelihood over a restricted parameter space (Mishra et al. [2020]).
</p>
<p>The restricted space only includes recalibration parameters <code class="reqn">alpha_0</code> and <code class="reqn">alpha_1</code> that produce a recalibrated risk model with high sNB. The restricted parameter space is defined all <code class="reqn">alpha</code> parameters that result in a recalibrated risk score within one-standard-error of the maximum possible <code class="reqn">sNB</code>. See Mishra et al (2020), for full details</p>


<h3>Usage</h3>

<pre><code class='language-R'>constRecal(y,p,r,int=NULL,alphaLB=c(-10,0),
            alphaUB=c(10,10),ftol=1e-8,xtol=1e-4,maxeval=1e6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constRecal_+3A_y">y</code></td>
<td>

<p>Vector of binary outcomes, with 1 indicating event (case) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code id="constRecal_+3A_p">p</code></td>
<td>

<p>Vector of risk score values</p>
</td></tr>
<tr><td><code id="constRecal_+3A_r">r</code></td>
<td>

<p>Clinically relevant risk threshold</p>
</td></tr>
<tr><td><code id="constRecal_+3A_int">int</code></td>
<td>
<p>Two-dimensional vector of initial recalibration parameter (<code class="reqn">alpha</code>) values. If not specified the recalibration parameters estimated under standard logistic recalibration will be used</p>
</td></tr>
<tr><td><code id="constRecal_+3A_alphalb">alphaLB</code></td>
<td>
<p>Lower bound of box-contrained search space</p>
</td></tr>
<tr><td><code id="constRecal_+3A_alphaub">alphaUB</code></td>
<td>
<p>Upper bound of box-contrained search space</p>
</td></tr>
<tr><td><code id="constRecal_+3A_ftol">ftol</code></td>
<td>
<p>Controls tolerance of optimization procedure with respect to changes in sNB</p>
</td></tr>
<tr><td><code id="constRecal_+3A_xtol">xtol</code></td>
<td>
<p>Controls tolerance of optimization procedure with respect to changes in alpha</p>
</td></tr>
<tr><td><code id="constRecal_+3A_maxeval">maxeval</code></td>
<td>
<p>Maximum number of interations performed during optimization procedure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To solve this optimization problem the DIRECT optimization method is implemented via the NLOPTR package. See Jones et al (1993) and Ypma et al (2014) for full description of optimization method and implementation details. Note this is not a convex optimization problem, so a global optimizer is used.
</p>


<h3>Value</h3>

<table>
<tr><td><code>alpha</code></td>
<td>
<p>Recalibration parameters obtained from Constrained Logistic Recalibration</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Vector of binary outcomes, with 1 indicating event (case) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code>p.const</code></td>
<td>
<p>Vector of constrained logistic reclaibrated risk scores</p>
</td></tr>
<tr><td><code>snbLB</code></td>
<td>
<p>Lower bound used to define constraint region. The solution is constrained to the region where recalibration parameters result in risk model with <code class="reqn">sNB</code> greater or equal to this bound. This is one-standard error lower than the maximum <code class="reqn">sNB</code> </p>
</td></tr>
<tr><td><code>optimRes</code></td>
<td>
<p>Full output from the NLOPTR optimization routine</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anu Mishra
</p>


<h3>References</h3>

<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)
</p>
<p>Ypma, J., Borchers, H. W., Eddelbuettel, D., &amp; Ypma, M. J. (2020). Package ‘nloptr’.
</p>
<p>Ypma, J. (2014). Introduction to nloptr: an R interface to NLopt. Tech. rep.
</p>
<p>D. R. Jones, C. D. Perttunen, and B. E. Stuckmann, &quot;Lipschitzian optimization without the lipschitz constant,&quot; J. Optimization Theory and Applications, vol. 79, p. 157 (1993).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Load data ##
data(fakeData)

## Implementing standard logistic recalibration
stdRecal.res &lt;- stdRecal(y = fakeData$y,p = fakeData$p)
stdRecal.res$alpha #standard recalibration parameters
p.std &lt;- stdRecal.res$p.std

## Look at potential sNB under recalibration plot
snbRecalPlot(p = fakeData$p,p.std = p.std,y = fakeData$y,r = 0.3)

## Implementing constrained logistic recalibration
constRecal.res &lt;- constRecal(y = fakeData$y,p = fakeData$p,r = 0.3)
constRecal.res$alpha #constrained logistic recalibration parameters
p.recal &lt;- constRecal.res$p.const

## comparing standardized net benefit of the two
nb(y = fakeData$y,p = fakeData$p,r = 0.3)$snb #original
nb(y = stdRecal.res$y,p = stdRecal.res$p.std,r = 0.3)$snb #std recal
nb(y = constRecal.res$y,p = constRecal.res$p.const,r = 0.3)$snb #weighted

## Generate calibration plots

### Calibration curve of only original, standard and weighted recalibrated risk score
calCurvPlot(y=fakeData$y,p=fakeData$p,p.std=p.std,p.recal=p.recal,
            stdPlot=TRUE, recalPlot=TRUE,
            xlim=c(0,1),ylim=c(0,1),
            label="Original Risk Score",
            label2 = "Standard Recalibrated Risk Score",
            label3 = "Weighted/Constrained Recalibrated Risk Score",
            legendLab = c("Orig.", "Std.", "Wt."),
            mainTitle="Calibration of Risk Score",
            hist=TRUE,ylimHist = c(0,0.5),
            r=0.3,rl = -Inf, ru = Inf)


## End(Not run)
</code></pre>

<hr>
<h2 id='cvRepWtTuning'>
Repeated Cross Validation for Weight Tuning Parameter Selection
</h2><span id='topic+cvRepWtTuning'></span>

<h3>Description</h3>

<p>Calibration weights require specification of tuning parameter <code class="reqn">delta</code> or <code class="reqn">lambda</code>. Since a single round of cross-validation can be noisy, cross-validation can be repeated multiple times with independent random partitions and the results be averaged. This function implements a repeated K-fold cross-validation where tuning parameter <code class="reqn">labmda</code> or <code class="reqn">delta</code> is selected by maximizing standardized net benefit (sNB) (i.e. repeated <code><a href="#topic+cvWtTuning">cvWtTuning</a></code> procedure).
</p>
<p>A a &quot;one-standard error&quot; rule can be used for selecting tuning parameters. Under the “one-standard error&quot; rule the calibration weight tuning parameter (<code class="reqn">lambda</code> or <code class="reqn">delta</code>) is selected such that corresponding cross-validated sNB is within one-standard deviation of the maximum cross-validated sNB. This provides protection against overfitting the data and selecting a tuning parameter that is too extreme. If the &quot;one-standard error&quot; rule is not implemented, then the tuning parameter with the larged average cross-validted sNB (across folds and repetition) will be selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvRepWtTuning(y,p,r,rl,ru,kFold=5,cvRep=25,cvParm,tuneSeq,stdErrRule=TRUE,int.seed=11111)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvRepWtTuning_+3A_y">y</code></td>
<td>

<p>Vector of binary outcomes, with 1 indicating event (cases) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_p">p</code></td>
<td>

<p>Vector of risk score values</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_r">r</code></td>
<td>

<p>Clinically relevant risk threshold</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_rl">rl</code></td>
<td>

<p>Lower bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_ru">ru</code></td>
<td>

<p>Upper bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_kfold">kFold</code></td>
<td>

<p>Number of folds for cross-validation</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_cvrep">cvRep</code></td>
<td>

<p>Number of cross-validation repititions</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_cvparm">cvParm</code></td>
<td>

<p>Parameter to be selected via cross-validation. Can be either <code class="reqn">delta</code> the weight assigned to observations outside the clinically relevant region [R_l,R_u], or the <code class="reqn">lambda</code> tuning parameter controlling exponential decay within the clinically relevant region [R_l,R_u]</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_tuneseq">tuneSeq</code></td>
<td>

<p>Sequence of values of tuning parameters to perform cross-validation over</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_stderrrule">stdErrRule</code></td>
<td>

<p>Use &quot;one-standard&quot; error rule selecting tuning parameter</p>
</td></tr>
<tr><td><code id="cvRepWtTuning_+3A_int.seed">int.seed</code></td>
<td>

<p>Intial seed set for random splitting of data into K folds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To estimate the standard deviation of the cross-validated sNV, the dependence between the different partitions of cross-validation needs to be accounted for. Gelman (1992) give a variance estimator of convergence diagnostic statistic used when Markov Chain Monte Carlo with multiple chains are performed. The variance estimator accounts for both the variability of the statistic “within&quot; a single chain, and the variance of the statistic across, or “between&quot;, chains. Analogously, we can use this framework to estimate the “within&quot; repetition variance (i.e. variation in sNB from a single round of K-fold cross-validation) and the “between&quot; repetition variance. We denote the ‘within&quot; repetition variance as W and the “between&quot; repetition variance as B . We augment this formula slightly from that given in Gelman (1992) to account for the fact that as the number of cross-validation repetitions increases, the between-repetition variability should decrease. See Mishra et al (2020) for full expressions of B and W.</p>


<h3>Value</h3>

<table>
<tr><td><code>cv.sNB</code></td>
<td>
<p>Standardized net benefit (sNB) of tuning parameter selected via cross-validatoin </p>
</td></tr>
<tr><td><code>cv.RAW</code></td>
<td>
<p>Corresponding RAW value given cross-valiated selected tuning parameter</p>
</td></tr>
<tr><td><code>cv.lambda</code></td>
<td>
<p><code class="reqn">lambda</code> value selected via cross-validation if <code class="reqn">cvParm=lambda</code>, otherwise user specified <code class="reqn">lambda</code> value</p>
</td></tr>
<tr><td><code>cv.delta</code></td>
<td>
<p><code class="reqn">delta</code> value selected via cross-validation if <code class="reqn">cvParm=delta</code>, otherwise user specified <code class="reqn">lambda</code> value</p>
</td></tr>
<tr><td><code>avgCV.res</code></td>
<td>
<p>Averaged (across-replications) cross-validated sNB for sequence of tuning parameters</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>Estimate of &quot;with-in&quot; repetition variance. Will only return if stdErrRule==TRUE</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Estimate of &quot;between&quot; repetition variance. Will only return if stdErrRule==TRUE</p>
</td></tr>
<tr><td><code>fullList</code></td>
<td>
<p>List of cross-valiation results for all fold and repititions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anu Mishra</p>


<h3>References</h3>

<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)
</p>
<p>Friedman, J., Hastie, T., &amp; Tibshirani, R. (2001). The elements of statistical learning (Vol. 1, No. 10). New York: Springer series in statistics.
</p>
<p>Gelman, A., &amp; Rubin, D. B. (1992). Inference from iterative simulation using multiple sequences. Statistical science, 7(4), 457-472.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calWt">calWt</a></code>,
<code><a href="#topic+RAWgrid">RAWgrid</a></code>,
<code><a href="#topic+nb">nb</a></code>,
<code><a href="#topic+cvWtTuning">cvWtTuning</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Load data ##
## Not run: 
data(fakeData)

### Get grid of tuning parameters  ###
grid &lt;- RAWgrid(r = 0.3,rl = -Inf,ru = Inf,p = fakeData$p,y = fakeData$y,
                cvParm = "lambda",rl.raw = 0.25,ru.raw = 0.35)

### Implement repeated k-fold cross validation
repCV &lt;- cvRepWtTuning(y = fakeData$y,p = fakeData$p,rl = -Inf,ru = Inf,r = 0.3,
                       kFold = 5,cvRep = 25,cvParm = "lambda",tuneSeq = grid,stdErrRule = TRUE)

## cross-validation results
repCV$avgCV.res

## cross-validation selected lambda, RAW, and sNV
cv.lambda &lt;- repCV$cv.lambda
cv.RAW &lt;- repCV$cv.RAW
cv.RAW &lt;- repCV$cv.sNB

## End(Not run)
</code></pre>

<hr>
<h2 id='cvWtTuning'>
Cross-validation for Selecting Weight Tuning Parameter
</h2><span id='topic+cvWtTuning'></span>

<h3>Description</h3>

<p>Calibration weights require specification of tuning parameter <code class="reqn">delta</code> or <code class="reqn">lambda</code>. This function uses K-fold cross-validation to select tuning parameter used for calibration weights, with standardized net benfeit (sNB) as objective function. Either one of <code class="reqn">delta</code> or <code class="reqn">lambda</code> must be specificed. The sequence of tuning parameters can be obtained from the <code><a href="#topic+RAWgrid">RAWgrid</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvWtTuning(p,y,r,rl,ru,kFold=5,cvParm,tuneSeq,cv.seed=1111)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvWtTuning_+3A_y">y</code></td>
<td>

<p>Vector of binary outcomes, with 1 indicating event (cases) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code id="cvWtTuning_+3A_p">p</code></td>
<td>

<p>Vector of risk score values</p>
</td></tr>
<tr><td><code id="cvWtTuning_+3A_r">r</code></td>
<td>

<p>Clinically relevant risk threshold</p>
</td></tr>
<tr><td><code id="cvWtTuning_+3A_rl">rl</code></td>
<td>

<p>Lower bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="cvWtTuning_+3A_ru">ru</code></td>
<td>

<p>Upper bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="cvWtTuning_+3A_kfold">kFold</code></td>
<td>

<p>Number of folds for cross-validation</p>
</td></tr>
<tr><td><code id="cvWtTuning_+3A_cvparm">cvParm</code></td>
<td>

<p>Parameter to be selected via cross-validation. Can be either <code class="reqn">delta</code> the weight assigned to observations outside the clinically relevant region [R_l,R_u], or the <code class="reqn">lambda</code> tuning parameter controlling exponential decay within the clinically relevant region [R_l,R_u]</p>
</td></tr>
<tr><td><code id="cvWtTuning_+3A_tuneseq">tuneSeq</code></td>
<td>

<p>Sequence of values of tuning parameters to perform cross-validation over</p>
</td></tr>
<tr><td><code id="cvWtTuning_+3A_cv.seed">cv.seed</code></td>
<td>

<p>Intial seed set for random splitting of data into K folds</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>cv.res</code></td>
<td>
<p>Matrix containing sequence of tuning parameters and corresponding cross-validation sNB</p>
</td></tr>
<tr><td><code>cv.param</code></td>
<td>
<p>Value of tuning parameter selected via cross validation</p>
</td></tr>
<tr><td><code>cv.full</code></td>
<td>
<p>Matrix of cross-validation results for all folds</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note this function does not split data into training and validaion set, but performs the K-fold cross-validation procedure on all data included. We advise that a separate, validation subset should be split from the data used in this function.
</p>


<h3>Author(s)</h3>

<p>Anu Mishra
</p>


<h3>References</h3>

<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)</p>


<h3>See Also</h3>

<p><code><a href="#topic+calWt">calWt</a></code>,
<code><a href="#topic+RAWgrid">RAWgrid</a></code>,
<code><a href="#topic+nb">nb</a></code>,
<code><a href="#topic+cvRepWtTuning">cvRepWtTuning</a></code>
</p>

<hr>
<h2 id='fakeData'>
Dataset for Recalibration Purposes
</h2><span id='topic+fakeData'></span>

<h3>Description</h3>

<p>Simulated dataset that can be used for recalibration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fakeData")</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations on the following 2 variables.
</p>

<dl>
<dt><code>p</code></dt><dd><p>a numeric vector or risk scores bounded between 0 and 1</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector of indicator of events (cases) and non-events (control)</p>
</dd>
</dl>



<h3>Details</h3>

<p>See Mishra et al (2020) for description of simuation settings to generate data (simulation example 3).
</p>


<h3>References</h3>

<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fakeData)
</code></pre>

<hr>
<h2 id='nb'>
Net Benefit
</h2><span id='topic+nb'></span>

<h3>Description</h3>

<p>Estimates the net benefit and standardized net benefit of a risk score given a risk threshold R. Additionally estimates the standardized net benefit of a &quot;treat-all&quot; (everyone recieves intervention) treatment rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb(y, p, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb_+3A_y">y</code></td>
<td>

<p>Vector of binary outcomes, with 1 indicating event (case) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code id="nb_+3A_p">p</code></td>
<td>

<p>Vector of risk score values</p>
</td></tr>
<tr><td><code id="nb_+3A_r">r</code></td>
<td>

<p>Clinically relevant risk threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>nb</code></td>
<td>
<p>Net benefit of risk score <code class="reqn">p</code></p>
</td></tr>
<tr><td><code>snb</code></td>
<td>
<p>Standardized net benefit of risk score <code class="reqn">p</code>. Net benefit of <code class="reqn">p</code> dived by the prevalence</p>
</td></tr>
<tr><td><code>snb.all</code></td>
<td>
<p>Standardized net benefit of a decision rule where everyone recieves treatment </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anu Mishra </p>


<h3>References</h3>

<p>Pauker, S. G., &amp; Kassirer, J. P. (1980). The threshold approach to clinical decision making. New England Journal of Medicine, 302(20), 1109-1117.
</p>
<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)</p>

<hr>
<h2 id='RAWgrid'>
RAW grid for Cross Validation
</h2><span id='topic+RAWgrid'></span>

<h3>Description</h3>

<p>Tuning parameters for calibration weights may not be intutitive. Instead, relative average weight (RAW) can be used to find sensible tuning parameters. The RAW is the average weight of observations within the RAW region, <code class="reqn">[R_{l,RAW},R_{u,RAW}]</code>, divided by the average weight of observations outside RAW region.
</p>
<p>This function elicits a grid of tuning parameter <code class="reqn">lambda</code> or <code class="reqn">delta</code> given a sequence of relative average weights (RAW) values, to be used for cross-validation. One tuning parameter <code class="reqn">delta</code> or <code class="reqn">lambda</code> must be specified.
</p>
<p>Two clinically relevant lower and upper bound values must be specified. The first, <code class="reqn">[R_{l},R_{u}</code>, define the clinically relevant region used for the weighting function. The second, <code class="reqn">[R_{l,RAW},R_{u,RAW}]</code>, define the complemenatry regions used for defining relative average weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RAWgrid(r, rl, ru, p, y, rawSeq=seq(0.1,0.9,0.1), cvParm,
delta = NULL, lambda = NULL, rl.raw, ru.raw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RAWgrid_+3A_r">r</code></td>
<td>

<p>Clinically relevant risk threshold</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_rl">rl</code></td>
<td>

<p>Lower bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_ru">ru</code></td>
<td>

<p>Upper bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_p">p</code></td>
<td>

<p>Vector of risk score values</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_y">y</code></td>
<td>

<p>Vector of binary outcomes, with 1 indicating event (cases) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_rawseq">rawSeq</code></td>
<td>

<p>Sequence of relative average weights</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_cvparm">cvParm</code></td>
<td>

<p>Tuning parameter that will be selected via cross-validation. Can either be <code class="reqn">lambda</code> or <code class="reqn">delta</code>
</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_delta">delta</code></td>
<td>

<p>Calibration weight for observations outside clinically relevant region <code class="reqn">[R_l,R_u]</code>. Needs to be specified if cvParm=&quot;lambda&quot;, otherwise should be left blank, and function will generate a sequence of delta for cross-validaton.
</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_lambda">lambda</code></td>
<td>

<p>Tuning parameter for controlling exponential decay of calibration weights. Needs to be specified if cvParm=&quot;delta&quot;, otherwise should be left blank, and function will generate a sequence of lambda for cross-validaton.</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_rl.raw">rl.raw</code></td>
<td>

<p>Lower bound for defining the relative average weight region of interest
</p>
</td></tr>
<tr><td><code id="RAWgrid_+3A_ru.raw">ru.raw</code></td>
<td>

<p>Upper bound for defining the relative average weight region of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>rrWt.seq</code></td>
<td>
<p>Matrix containing the input RAW sequence, and corresponding weight tuning parameter lambda and weight value delta (with one fixed depending on cvParm selection). If 'NA' is returned there may be too few events within the weight clinically relevant RAW region, meaning that RAW value is not possible</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Event rate outside RAW interval, widen RAW intervalIf no or too cases are inside RAW interval [R_l,R_u], cross-validation procedure may not be stable, so this warning indicates RAW interval should widen to include more cases.
</p>


<h3>Author(s)</h3>

<p>Anu Mishra
</p>


<h3>References</h3>

<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)</p>


<h3>See Also</h3>

<p><code><a href="#topic+calWt">calWt</a></code>,
<code><a href="#topic+cvWtTuning">cvWtTuning</a></code>,
<code><a href="#topic+cvRepWtTuning">cvRepWtTuning</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Load data ##
data(fakeData)

### Get Grid of Tuning Parameters ###
grid &lt;- RAWgrid(r = 0.3,rl = -Inf,ru = Inf,p = fakeData$p,y = fakeData$y,
                cvParm = "lambda",delta=1,rl.raw = 0.25,ru.raw = 0.35)
</code></pre>

<hr>
<h2 id='snbRecalPlot'>
Plot of Potential sNB Under Recalibration
</h2><span id='topic+snbRecalPlot'></span>

<h3>Description</h3>

<p>Function for producing a graphical device to help assess the potential for recalibration to improve the clinical utility of a risk model.
</p>
<p>This function plots the sNB for a given risk score (p) and cost benefit ratio (R/1-R) against the threshold used to perscribe intervention. The peak of the curve estimates the maxmium possible sNB that can be obtained via recalibration. The estimated sNB of the original risk score and the recalibrated risk score under standard logistic recalibration are also plotted on the curves on the curves. The dotted lined  &quot;stdErrThresh&quot; controls. The plot includes a dotted horizontal line one standard error (or any number of standard errors, controlled by stdErrThresh) below the maximum, to help guage much room for improvement in sNB there is for original or standard recalibrated risk score from maximum possible sNB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snbRecalPlot(p,p.std,y,r,stdErrThresh=1,ylim=NULL,
              titlePlot = "Potential sNB Under Recalibration",risk.model.std=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snbRecalPlot_+3A_p">p</code></td>
<td>
<p>Vector of risk score values</p>
</td></tr>
<tr><td><code id="snbRecalPlot_+3A_p.std">p.std</code></td>
<td>
<p>Vector of risk score values after standard logistic recalibration</p>
</td></tr>
<tr><td><code id="snbRecalPlot_+3A_y">y</code></td>
<td>
<p>Vector of binary outcomes, with 1 indicating event (case) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code id="snbRecalPlot_+3A_r">r</code></td>
<td>
<p>Clinically relevant risk threshold</p>
</td></tr>
<tr><td><code id="snbRecalPlot_+3A_stderrthresh">stdErrThresh</code></td>
<td>
<p>Indicates how many standard errors line drawn below the maximum of the sNB curve should be</p>
</td></tr>
<tr><td><code id="snbRecalPlot_+3A_ylim">ylim</code></td>
<td>
<p>Y axis limits</p>
</td></tr>
<tr><td><code id="snbRecalPlot_+3A_titleplot">titlePlot</code></td>
<td>
<p>Title for plot</p>
</td></tr>
<tr><td><code id="snbRecalPlot_+3A_risk.model.std">risk.model.std</code></td>
<td>
<p>Plot standard error bars for sNB of plotted risk models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints plot of potential sNB of risk score p under recalibration</p>


<h3>Author(s)</h3>

<p>Anu Mishra
</p>


<h3>References</h3>

<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("fakeData")

### get standard recalibrated risk score
stdRecal.res &lt;- stdRecal(y = fakeData$y,p = fakeData$p)
p.std &lt;- stdRecal.res$p.std


## make plot
snbRecalPlot(p = fakeData$p,p.std = p.std,y = fakeData$y,r = 0.3)

## both original and std logistic recalibrated risk score are below 1 std err from maximum
## indicating that alternative recalibration methods could improve
</code></pre>

<hr>
<h2 id='stdRecal'>
Standard Logistic Recalibration
</h2><span id='topic+stdRecal'></span>

<h3>Description</h3>

<p>Produces recalibration intercept, slope and corresponding recalibrated risk scores using standard logistic rexalibration. Recalibration slope and intercept using logistic recalibration method, develop by Cox (1958), then used to calculated the recalibrated risk score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdRecal(y,p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdRecal_+3A_y">y</code></td>
<td>

<p>Vector of binary outcomes, with 1 indicating event (case) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code id="stdRecal_+3A_p">p</code></td>
<td>

<p>Vector of risk score values</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>stdRisk</code></td>
<td>
<p>Vector of recalibrated risks under standard logistic recalibration </p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Two-element vector containing logistic recalibration intercept and slope</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anu Mishra
</p>


<h3>References</h3>

<p>Cox, D. R. (1958). Two further applications of a model for binary regression. Biometrika, 45(3/4), 562-565.
</p>
<p>Harrell Jr, F. E. (2015). Regression modeling strategies: with applications to linear models, logistic and ordinal regression, and survival analysis. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data
data(fakeData)

res &lt;- stdRecal(p=fakeData$p, y =fakeData$y)
p.std &lt;- res$stdRecal
coef.dt &lt;- res$alpha
</code></pre>

<hr>
<h2 id='wtRecal'>
Weighted Logistic Recalibration
</h2><span id='topic+wtRecal'></span>

<h3>Description</h3>

<p>When recalibrating a risk model, where the intended purpose of the risk model is to prescribe an intervention to those deemed at high risk, it is desirable to have good calibration at the clinically relevant threshold used to define high risk (i.e. threshold used to identify who recieves treatment). This function realibrates risk scores (predicting binary outcome) using the weighted logistic recalibration method (Mishra et al. [2020]).
</p>
<p>Under this method, a recalibration intercept and slope are estimated via weighted logistic regression. Weights are constructed such that observations further from the clinically relevant risk threshold are down-weighted, meaning observations closer to the clinically relevant risk threshold have higher contribution to the risk threshold. The resulting estimated weighted recalibration slope and intercept are used to scale and shift the existing risk score, producing better calibrated risk scores near the risk threhold and potentially increaseing the net benefit of the risk score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtRecal(y,p,r,rl,ru,lambda,delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtRecal_+3A_y">y</code></td>
<td>

<p>Vector of binary outcomes, with 1 indicating event (case) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code id="wtRecal_+3A_p">p</code></td>
<td>

<p>Vector of risk score values</p>
</td></tr>
<tr><td><code id="wtRecal_+3A_r">r</code></td>
<td>

<p>Clinically relevant risk threshold</p>
</td></tr>
<tr><td><code id="wtRecal_+3A_rl">rl</code></td>
<td>

<p>Lower bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="wtRecal_+3A_ru">ru</code></td>
<td>

<p>Upper bound of clinically relevant region</p>
</td></tr>
<tr><td><code id="wtRecal_+3A_lambda">lambda</code></td>
<td>

<p>Tuning parameter for weights inside relevant region</p>
</td></tr>
<tr><td><code id="wtRecal_+3A_delta">delta</code></td>
<td>

<p>Weight assigned to observations outside relevant region
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>y</code></td>
<td>
<p>Vector of binary outcomes, with 1 indicating event (case) and 0 indicating no event (controls)</p>
</td></tr>
<tr><td><code>p.wt</code></td>
<td>
<p>Vector of weighted reclaibrated risk scores</p>
</td></tr>
<tr><td><code>alpha.wt</code></td>
<td>
<p>Weighted recalibration slope and intercept</p>
</td></tr>
<tr><td><code>wt</code></td>
<td>
<p>Calibration weights</p>
</td></tr>
<tr><td><code>wt.conv</code></td>
<td>
<p>Indicator of convergence of the weighted logistic regression model. 1 indicates model convergence, 0 indicates model did not converge</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Anu Mishra
</p>


<h3>References</h3>

<p>Mishra, A. (2019). Methods for Risk Markers that Incorporate Clinical Utility (Doctoral dissertation). (Available Upon Request)</p>


<h3>See Also</h3>

<p><code><a href="#topic+calWt">calWt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Load data ##
data(fakeData)

## Implement standard logistic recalibration
stdRecal.res &lt;- stdRecal(y = fakeData$y,p = fakeData$p)
stdRecal.res$alpha #standard recalibration parameters
p.std &lt;- stdRecal.res$p.std

## Look at potential sNB under recalibration plot
snbRecalPlot(p = fakeData$p,p.std = p.std,y = fakeData$y,r = 0.3)
## both original and std logistic recalibrated risk score are below 1 std err from maximum
## indicating that alternative recalibration methods could improve

### Get grid of tuning parameters  ###
## In this example keeping delta fixed, and selecting lambda

grid &lt;- RAWgrid(r = 0.3,rl = -Inf,ru = Inf,p = fakeData$p,y = fakeData$y,
                cvParm = "lambda",rl.raw = 0.25,ru.raw = 0.35)


### Select tuning parameter lamba using 5-fold cross-validation repeated 25 times
### with one standard error rule implemented

repCV &lt;- cvRepWtTuning(y = fakeData$y,p = fakeData$p,rl = -Inf,ru = Inf,r = 0.3,
                       kFold = 5,cvRep = 25,cvParm = "lambda",tuneSeq = grid,stdErrRule = TRUE)

## Implement weighted logistic recalibration
wtRecal.res &lt;- wtRecal(y = fakeData$y,p = fakeData$p,r = 0.3,rl = -Inf,ru = Inf,
                       lambda = repCV$cv.lambda,delta=1)
# note that delta here is set to 1 as a place holder, but not used since the clinically
# relevant region is [-Inf, Inf]
wtRecal.res$alpha.wt #weighted recalibration parameters
p.recal &lt;- wtRecal.res$p.wt

## comparing standardized net benefit of the two
nb(y = fakeData$y,p = fakeData$p,r = 0.3)$snb #original
nb(y = stdRecal.res$y,p = stdRecal.res$p.std,r = 0.3)$snb #std recal
nb(y = wtRecal.res$y,p = wtRecal.res$p.wt,r = 0.3)$snb #weighted

### Calibration curve of only original, standard and weighted recalibrated risk score
calCurvPlot(y = fakeData$y,p = fakeData$p,p.std=p.std,p.recal=p.recal,
            stdPlot=TRUE, recalPlot=TRUE,
            xlim=c(0,1),ylim=c(0,1),
            label="Original Risk Score",
            label2 = "Standard Recalibrated Risk Score",
            label3 = "Weighted/Constrained Recalibrated Risk Score",
            legendLab = c("Orig.", "Std.", "Wt."),
            mainTitle="Calibration of Risk Score",
            hist=TRUE,ylimHist = c(0,0.5),
            r=0.3,rl = -Inf, ru = Inf)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
