<!DOCTYPE html><html><head><title>Help for package digitalDLSorteR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {digitalDLSorteR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#barErrorPlot'><p>Generate bar error plots</p></a></li>
<li><a href='#barPlotCellTypes'><p>Bar plot of deconvoluted cell type proportions in bulk RNA-Seq samples</p></a></li>
<li><a href='#blandAltmanLehPlot'><p>Generate Bland-Altman agreement plots between predicted and expected cell</p>
type proportions from test data results</a></li>
<li><a href='#bulk.simul'><p>Get and set <code>bulk.simul</code> slot in a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#calculateEvalMetrics'><p>Calculate evaluation metrics for bulk RNA-Seq samples from test data</p></a></li>
<li><a href='#cell.names'><p>Get and set <code>cell.names</code> slot in a</p>
<code>ProbMatrixCellTypes</code> object</a></li>
<li><a href='#cell.types'><p>Get and set <code>cell.types</code> slot in a</p>
<code>DigitalDLSorterDNN</code> object</a></li>
<li><a href='#corrExpPredPlot'><p>Generate correlation plots between predicted and expected cell type</p>
proportions from test data</a></li>
<li><a href='#createDDLSobject'><p>Create a <code>DigitalDLSorter</code> object from single-cell RNA-seq</p>
and bulk RNA-seq data</a></li>
<li><a href='#deconv.data'><p>Get and set <code>deconv.data</code> slot in a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#deconv.results'><p>Get and set <code>deconv.results</code> slot in a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#deconvDDLSObj'><p>Deconvolute bulk gene expression samples (bulk RNA-Seq)</p></a></li>
<li><a href='#deconvDigitalDLSorter'><p>Deconvolute bulk RNA-Seq samples using a pre-trained DigitalDLSorter model</p></a></li>
<li><a href='#digitalDLSorteR'><p>digitalDLSorteR: an R package to deconvolute bulk RNA-Seq samples using</p>
single-cell RNA-Seq data and Deep Learning</a></li>
<li><a href='#DigitalDLSorter-class'><p>The DigitalDLSorter Class</p></a></li>
<li><a href='#DigitalDLSorterDNN-class'><p>The DigitalDLSorterDNN Class</p></a></li>
<li><a href='#distErrorPlot'><p>Generate box plots or violin plots to show how the errors are distributed</p></a></li>
<li><a href='#estimateZinbwaveParams'><p>Estimate the parameters of the ZINB-WaVE model to simulate new single-cell</p>
RNA-Seq expression profiles</a></li>
<li><a href='#features'><p>Get and set <code>features</code> slot in a</p>
<code>DigitalDLSorterDNN</code> object</a></li>
<li><a href='#generateBulkCellMatrix'><p>Generate training and test cell composition matrices</p></a></li>
<li><a href='#getProbMatrix'><p>Getter function for the cell composition matrix</p></a></li>
<li><a href='#installTFpython'><p>Install Python dependencies for digitalDLSorteR</p></a></li>
<li><a href='#listToDDLS'><p>Transform DigitalDLSorter-like list into an actual DigitalDLSorterDNN object</p></a></li>
<li><a href='#listToDDLSDNN'><p>Transform DigitalDLSorterDNN-like list into an actual DigitalDLSorterDNN</p>
object</a></li>
<li><a href='#loadDeconvData'><p>Load data to be deconvoluted into a DigitalDLSorter object</p></a></li>
<li><a href='#loadTrainedModelFromH5'><p>Load from an HDF5 file a trained Deep Neural Network model into a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#method'><p>Get and set <code>method</code> slot in a</p>
<code>ProbMatrixCellTypes</code> object</a></li>
<li><a href='#model'><p>Get and set <code>model</code> slot in a</p>
<code>DigitalDLSorterDNN</code> object</a></li>
<li><a href='#plots'><p>Get and set <code>plots</code> slot in a</p>
<code>ProbMatrixCellTypes</code> object</a></li>
<li><a href='#plotTrainingHistory'><p>Plot training history of a trained DigitalDLSorter Deep Neural Network model</p></a></li>
<li><a href='#preparingToSave'><p>Prepare <code>DigitalDLSorter</code> object to be saved as an RDA</p>
file</a></li>
<li><a href='#prob.cell.types'><p>Get and set <code>prob.cell.types</code> slot in a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#prob.matrix'><p>Get and set <code>prob.matrix</code> slot in a</p>
<code>ProbMatrixCellTypes</code> object</a></li>
<li><a href='#ProbMatrixCellTypes-class'><p>The Class ProbMatrixCellTypes</p></a></li>
<li><a href='#project'><p>Get and set <code>project</code> slot in a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#saveRDS'><p>Save <code>DigitalDLSorter</code> objects as RDS files</p></a></li>
<li><a href='#saveTrainedModelAsH5'><p>Save a trained <code>DigitalDLSorter</code> Deep Neural Network model</p>
to disk as an HDF5 file</a></li>
<li><a href='#set'><p>Get and set <code>set</code> slot in a</p>
<code>ProbMatrixCellTypes</code> object</a></li>
<li><a href='#set.list'><p>Get and set <code>set.list</code> slot in a</p>
<code>ProbMatrixCellTypes</code> object</a></li>
<li><a href='#showProbPlot'><p>Show distribution plots of the cell proportions generated by</p>
<code>generateBulkCellMatrix</code></a></li>
<li><a href='#simBulkProfiles'><p>Simulate training and test pseudo-bulk RNA-Seq profiles</p></a></li>
<li><a href='#simSCProfiles'><p>Simulate new single-cell RNA-Seq expression profiles using the ZINB-WaVE</p>
model parameters</a></li>
<li><a href='#single.cell.real'><p>Get and set <code>single.cell.real</code> slot in a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#single.cell.simul'><p>Get and set <code>single.cell.simul</code> slot in a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#test.deconv.metrics'><p>Get and set <code>test.deconv.metrics</code> slot in a</p>
<code>DigitalDLSorterDNN</code> object</a></li>
<li><a href='#test.metrics'><p>Get and set <code>test.metrics</code> slot in a</p>
<code>DigitalDLSorterDNN</code> object</a></li>
<li><a href='#test.pred'><p>Get and set <code>test.pred</code> slot in a</p>
<code>DigitalDLSorterDNN</code> object</a></li>
<li><a href='#trainDDLSModel'><p>Train Deep Neural Network model</p></a></li>
<li><a href='#trained.model'><p>Get and set <code>trained.model</code> slot in a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#training.history'><p>Get and set <code>training.history</code> slot in a</p>
<code>DigitalDLSorterDNN</code> object</a></li>
<li><a href='#zinb.params'><p>Get and set <code>zinb.params</code> slot in a</p>
<code>DigitalDLSorter</code> object</a></li>
<li><a href='#ZinbParametersModel-class'><p>The Class ZinbParametersModel</p></a></li>
<li><a href='#zinbwave.model'><p>Get and set <code>zinbwave.model</code> slot in a</p>
<code>ZinbParametersModel</code> object</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Deconvolution of Bulk RNA-Seq Data Based on Deep Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Diego Mañanes &lt;dmananesc@cnic.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Deconvolution of bulk RNA-Seq data using context-specific deconvolution models based on Deep Neural Networks using scRNA-Seq data as input. These models are able to make accurate estimates of the cell composition of bulk RNA-Seq samples from the same context using the advances provided by Deep Learning and the meaningful information provided by scRNA-Seq data. See Torroja and Sanchez-Cabo (2019) &lt;<a href="https://doi.org/10.3389%2Ffgene.2019.00978">doi:10.3389/fgene.2019.00978</a>&gt; for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://diegommcc.github.io/digitalDLSorteR/">https://diegommcc.github.io/digitalDLSorteR/</a>,
<a href="https://github.com/diegommcc/digitalDLSorteR">https://github.com/diegommcc/digitalDLSorteR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/diegommcc/digitalDLSorteR/issues">https://github.com/diegommcc/digitalDLSorteR/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, grr, Matrix, methods, tidyr, SingleCellExperiment,
SummarizedExperiment, zinbwave, stats, pbapply, S4Vectors,
dplyr, tools, reshape2, gtools, reticulate, keras, tensorflow,
ggplot2, ggpubr, scran, scuttle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, BiocParallel, rhdf5, DelayedArray,
DelayedMatrixStats, HDF5Array, testthat</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Python (&gt;= 2.7.0), TensorFlow
(https://www.tensorflow.org/)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AllClasses.R' 'AllGenerics.R' 'digitalDLSorteR.R'
'dnnModel.R' 'evalMetrics.R' 'loadData.R' 'simBulk.R'
'simSingleCell.R' 'utils.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-07 09:41:54 UTC; dmananes</td>
</tr>
<tr>
<td>Author:</td>
<td>Diego Mañanes <a href="https://orcid.org/0000-0001-7247-6794"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Carlos Torroja <a href="https://orcid.org/0000-0001-8914-3400"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Fatima Sanchez-Cabo
    <a href="https://orcid.org/0000-0003-1881-1664"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-07 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='barErrorPlot'>Generate bar error plots</h2><span id='topic+barErrorPlot'></span>

<h3>Description</h3>

<p>Generate bar error plots by cell type (<code>CellType</code>) or by number of
different cell types (<code>nCellTypes</code>) on test pseudo-bulk samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barErrorPlot(
  object,
  error = "MSE",
  by = "CellType",
  dispersion = "se",
  filter.sc = TRUE,
  title = NULL,
  angle = NULL,
  theme = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barErrorPlot_+3A_object">object</code></td>
<td>
<p><code>DigitalDLSorter</code> object with <code>trained.model</code> slot
containing metrics in <code>test.deconv.metrics</code> slot.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_error">error</code></td>
<td>
<p><code>'MAE'</code> or <code>'MSE'</code>.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_by">by</code></td>
<td>
<p>Variable used to display errors. Available options are:
<code>'nCellTypes'</code>, <code>'CellType'</code>.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_dispersion">dispersion</code></td>
<td>
<p>Standard error (<code>'se'</code>) or standard deviation
(<code>'sd'</code>). The former is the default.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_filter.sc">filter.sc</code></td>
<td>
<p>Boolean indicating whether single-cell profiles are filtered
out and only correlation of results associated with bulk samples are
displayed (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_angle">angle</code></td>
<td>
<p>Angle of ticks.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the mean and dispersion of the errors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> <code><a href="#topic+corrExpPredPlot">corrExpPredPlot</a></code>
<code><a href="#topic+distErrorPlot">distErrorPlot</a></code> <code><a href="#topic+blandAltmanLehPlot">blandAltmanLehPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(6)),
  from = c(1, 1, 1, 15, 15, 30),
  to = c(15, 15, 30, 50, 50, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 50,
  verbose = TRUE
)
# training of DDLS model
tensorflow::tf$compat$v1$disable_eager_execution()
DDLS &lt;- trainDDLSModel(
  object = DDLS,
  on.the.fly = TRUE,
  batch.size = 15,
  num.epochs = 5
)
# evaluation using test data
DDLS &lt;- calculateEvalMetrics(
  object = DDLS
)
# bar error plots
barErrorPlot(
  object = DDLS,
  error = "MSE",
  by = "CellType"
)
barErrorPlot(
  object = DDLS,
  error = "MAE",
  by = "nCellTypes"
)

## End(Not run)

</code></pre>

<hr>
<h2 id='barPlotCellTypes'>Bar plot of deconvoluted cell type proportions in bulk RNA-Seq samples</h2><span id='topic+barPlotCellTypes'></span><span id='topic+barPlotCellTypes+2CDigitalDLSorter-method'></span><span id='topic+barPlotCellTypes+2CANY-method'></span>

<h3>Description</h3>

<p>Bar plot of deconvoluted cell type proportions in bulk RNA-Seq samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barPlotCellTypes(
  data,
  colors = NULL,
  simplify = NULL,
  color.line = NA,
  x.label = "Bulk samples",
  rm.x.text = FALSE,
  title = "Results of deconvolution",
  legend.title = "Cell types",
  angle = 90,
  theme = NULL,
  ...
)

## S4 method for signature 'DigitalDLSorter'
barPlotCellTypes(
  data,
  colors = NULL,
  simplify = NULL,
  color.line = NA,
  x.label = "Bulk samples",
  rm.x.text = FALSE,
  title = "Results of deconvolution",
  legend.title = "Cell types",
  angle = 90,
  theme = NULL,
  name.data = NULL
)

## S4 method for signature 'ANY'
barPlotCellTypes(
  data,
  colors,
  color.line = NA,
  x.label = "Bulk samples",
  rm.x.text = FALSE,
  title = "Results of deconvolution",
  legend.title = "Cell types",
  angle = 90,
  theme = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barPlotCellTypes_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>deconv.results</code> slot or a data frame/matrix with cell types as
columns and samples as rows.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to be used.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_simplify">simplify</code></td>
<td>
<p>Type of simplification performed during deconvolution. Can be
<code>simpli.set</code> or <code>simpli.maj</code> (<code>NULL</code> by default). It is only
for <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> objects.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_color.line">color.line</code></td>
<td>
<p>Color of the border bars.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_x.label">x.label</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_rm.x.text">rm.x.text</code></td>
<td>
<p>Logical value indicating whether to remove x-axis ticks
(name of samples).</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_legend.title">legend.title</code></td>
<td>
<p>Title of the legend plot.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_angle">angle</code></td>
<td>
<p>Angle of text ticks.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_...">...</code></td>
<td>
<p>Other arguments for specific methods.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_name.data">name.data</code></td>
<td>
<p>If a <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> is given, name of
the element that stores the results in the <code>deconv.results</code> slot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the provided cell proportions represented as a
bar plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deconvDigitalDLSorter">deconvDigitalDLSorter</a></code>
<code><a href="#topic+deconvDDLSObj">deconvDDLSObj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matrix of simulated proportions (same estructure as deconvolution results)
deconvResults &lt;- gtools::rdirichlet(n = 20, alpha = c(1, 1, 1, 0.5, 0.1))
colnames(deconvResults) &lt;- paste("CellType", seq(ncol(deconvResults)))
rownames(deconvResults) &lt;- paste("BulkSample", seq(nrow(deconvResults)))
barPlotCellTypes(deconvResults)

# Using a DigitalDLSorter object
DDLS &lt;- DigitalDLSorter(deconv.results = list(Example = deconvResults))
barPlotCellTypes(DDLS)

</code></pre>

<hr>
<h2 id='blandAltmanLehPlot'>Generate Bland-Altman agreement plots between predicted and expected cell
type proportions from test data results</h2><span id='topic+blandAltmanLehPlot'></span>

<h3>Description</h3>

<p>Generate Bland-Altman agreement plots between predicted and expected cell
type proportions from test data results. The Bland-Altman agreement plots can
be displayed all mixed or split by cell type (<code>CellType</code>) or the number
of cell types present in samples (<code>nCellTypes</code>). See the <code>facet.by</code>
argument and examples for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blandAltmanLehPlot(
  object,
  colors,
  color.by = "CellType",
  facet.by = NULL,
  log.2 = FALSE,
  filter.sc = TRUE,
  density = TRUE,
  color.density = "darkblue",
  size.point = 0.05,
  alpha.point = 1,
  ncol = NULL,
  nrow = NULL,
  title = NULL,
  theme = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blandAltmanLehPlot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>trained.model</code> slot containing metrics in <code>test.deconv.metrics</code>
slot.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to be used. Only vectors with a number of
colors equal to or greater than the levels of <code>color.by</code> will be
accepted. By default a custom color list is used.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_color.by">color.by</code></td>
<td>
<p>Variable used to color data. Options are <code>nCellTypes</code>
and <code>CellType</code>.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_facet.by">facet.by</code></td>
<td>
<p>Variable used to display the data in different panels. If
<code>NULL</code>, the plot is not split into different panels. Options are
<code>nCellTypes</code> (by number of different cell types) and <code>CellType</code>
(by cell type).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_log.2">log.2</code></td>
<td>
<p>Whether to display the Bland-Altman agreement plot in log2 space
(<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_filter.sc">filter.sc</code></td>
<td>
<p>Boolean indicating whether single-cell profiles are filtered
out and only correlations of results associated with bulk samples are
displayed (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_density">density</code></td>
<td>
<p>Boolean indicating whether density lines must be displayed
(<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_color.density">color.density</code></td>
<td>
<p>Color of density lines if the <code>density</code> argument is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_size.point">size.point</code></td>
<td>
<p>Size of the points (0.1 by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_alpha.point">alpha.point</code></td>
<td>
<p>Alpha of the points (0.1 by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if <code>facet.by</code> is used.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows if <code>facet.by</code> is used.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_...">...</code></td>
<td>
<p>Additional argument for the <code>facet_wrap</code> function from
<span class="pkg">ggplot2</span> if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with Bland-Altman agreement plots between expected
and actual proportions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> <code><a href="#topic+corrExpPredPlot">corrExpPredPlot</a></code>
<code><a href="#topic+distErrorPlot">distErrorPlot</a></code> <code><a href="#topic+barErrorPlot">barErrorPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(6)),
  from = c(1, 1, 1, 15, 15, 30),
  to = c(15, 15, 30, 50, 50, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 50,
  verbose = TRUE
)
# training of DDLS model
tensorflow::tf$compat$v1$disable_eager_execution()
DDLS &lt;- trainDDLSModel(
  object = DDLS,
  on.the.fly = TRUE,
  batch.size = 15,
  num.epochs = 5
)
# evaluation using test data
DDLS &lt;- calculateEvalMetrics(
  object = DDLS
)
# Bland-Altman plot by cell type
blandAltmanLehPlot(
  object = DDLS,
  facet.by = "CellType",
  color.by = "CellType"
)
# Bland-Altman plot of all samples mixed
blandAltmanLehPlot(
  object = DDLS,
  facet.by = NULL,
  color.by = "CellType",
  alpha.point = 0.3,
  log2 = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='bulk.simul'>Get and set <code>bulk.simul</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+bulk.simul'></span><span id='topic+bulk.simul+2CDigitalDLSorter-method'></span><span id='topic+bulk.simul+3C-'></span><span id='topic+bulk.simul+3C-+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Get and set <code>bulk.simul</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bulk.simul(object, type.data = "both")

bulk.simul(object, type.data = "both") &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bulk.simul_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object.</p>
</td></tr>
<tr><td><code id="bulk.simul_+3A_type.data">type.data</code></td>
<td>
<p>Element of the list. Can be <code>'train'</code>, <code>'test'</code> or
<code>'both'</code> (the last by default).</p>
</td></tr>
<tr><td><code id="bulk.simul_+3A_value">value</code></td>
<td>
<p>List with two elements, train and test, each one being
a <code>SummarizedExperiment</code> object with simulated bulk
RNA-Seq samples.</p>
</td></tr>
</table>

<hr>
<h2 id='calculateEvalMetrics'>Calculate evaluation metrics for bulk RNA-Seq samples from test data</h2><span id='topic+calculateEvalMetrics'></span>

<h3>Description</h3>

<p>Calculate evaluation metrics for bulk RNA-seq samples from test data to
understand model performance. By default, absolute error (<code>AbsErr</code>),
proportional absolute error (<code>ppAbsErr</code>), squared error (<code>SqrErr</code>)
and proportional squared error (<code>ppSqrErr</code>) are calculated for each test
sample. In addition, each of these metrics is aggregated using their mean
values according to three criteria: each cell type (<code>CellType</code>),
probability bins in ranges of 0.1 (<code>pBin</code>) and number of different cell
types present in the sample <code>nCellTypes</code>. Finally, the process is
repeated only considering bulk samples (filtering out single-cell profiles
from the evaluation). The evaluation metrics will be available in the
<code>test.deconv.metrics</code> slot of the
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object (<code>trained.model</code> slot of
the <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateEvalMetrics(object, metrics = c("MAE", "MSE"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateEvalMetrics_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with a trained
model in the <code>trained.model</code> slot and the actual cell proportions of
pseudo-bulk samples in <code>prob.cell.matrix</code> slot.</p>
</td></tr>
<tr><td><code id="calculateEvalMetrics_+3A_metrics">metrics</code></td>
<td>
<p>Metrics used to evaluate the model performance. Mean absolute
error (<code>"MAE"</code>) and mean squared error (<code>"MSE"</code>) by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with the
<code>trained.model</code> slot containing a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object with the
<code>test.deconv.metrics</code> slot. The last contains the metrics calculated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distErrorPlot">distErrorPlot</a></code> <code><a href="#topic+corrExpPredPlot">corrExpPredPlot</a></code>
<code><a href="#topic+blandAltmanLehPlot">blandAltmanLehPlot</a></code> <code><a href="#topic+barErrorPlot">barErrorPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(6)),
  from = c(1, 1, 1, 15, 15, 30),
  to = c(15, 15, 30, 50, 50, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 50,
  verbose = TRUE
)
# training of DDLS model
tensorflow::tf$compat$v1$disable_eager_execution()
DDLS &lt;- trainDDLSModel(
  object = DDLS,
  on.the.fly = TRUE,
  batch.size = 15,
  num.epochs = 5
)
# evaluation using test data
DDLS &lt;- calculateEvalMetrics(
  object = DDLS
)

## End(Not run)

</code></pre>

<hr>
<h2 id='cell.names'>Get and set <code>cell.names</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object</h2><span id='topic+cell.names'></span><span id='topic+cell.names+2CProbMatrixCellTypes-method'></span><span id='topic+cell.names+3C-'></span><span id='topic+cell.names+3C-+2CProbMatrixCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>cell.names</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.names(object)

cell.names(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell.names_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="cell.names_+3A_value">value</code></td>
<td>
<p>Matrix containing the name of the pseudo-bulk samples to be
simulated as rows and the cells to be used to simulate them as columns
(<code>n.cell</code> argument)</p>
</td></tr>
</table>

<hr>
<h2 id='cell.types'>Get and set <code>cell.types</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object</h2><span id='topic+cell.types'></span><span id='topic+cell.types+2CDigitalDLSorterDNN-method'></span><span id='topic+cell.types+3C-'></span><span id='topic+cell.types+3C-+2CDigitalDLSorterDNN-method'></span>

<h3>Description</h3>

<p>Get and set <code>cell.types</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.types(object)

cell.types(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell.types_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
<tr><td><code id="cell.types_+3A_value">value</code></td>
<td>
<p>Vector with cell types considered by the Deep Neural Network
model.</p>
</td></tr>
</table>

<hr>
<h2 id='corrExpPredPlot'>Generate correlation plots between predicted and expected cell type
proportions from test data</h2><span id='topic+corrExpPredPlot'></span>

<h3>Description</h3>

<p>Generate correlation plot between predicted and expected cell type
proportions from test data. Correlation plots can be displayed all mixed or
split by cell type (<code>CellType</code>) or number of cell types present in the
samples (<code>nCellTypes</code>). See the <code>facet.by</code> argument and examples
for more information. Moreover, a user-selected correlation value is
displayed as an annotation on the plots. See the <code>corr</code> argument for
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrExpPredPlot(
  object,
  colors,
  facet.by = NULL,
  color.by = "CellType",
  corr = "both",
  filter.sc = TRUE,
  pos.x.label = 0.01,
  pos.y.label = 0.95,
  sep.labels = 0.15,
  size.point = 0.1,
  alpha.point = 1,
  ncol = NULL,
  nrow = NULL,
  title = NULL,
  theme = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrExpPredPlot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>trained.model</code> slot containing metrics in the
<code>test.deconv.metrics</code> slot of a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to be used. Only vectors with a number of
colors equal to or greater than the levels of <code>color.by</code> will be
accepted. By default, a custom color list is used.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_facet.by">facet.by</code></td>
<td>
<p>Variable used to display data in different panels. If
<code>NULL</code>, the plot is not split into different panels. Options are
<code>nCellTypes</code> (by number of different cell types) and <code>CellType</code>
(by cell type).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_color.by">color.by</code></td>
<td>
<p>Variable used to color data. Options are <code>nCellTypes</code>
and <code>CellType</code>.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_corr">corr</code></td>
<td>
<p>Correlation value displayed as an annotation on the plot.
Available metrics are Pearson's correlation coefficient (<code>'pearson'</code>)
and concordance correlation coefficient (<code>'ccc'</code>). The argument can be
<code>'pearson'</code>, <code>'ccc'</code> or <code>'both'</code> (by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_filter.sc">filter.sc</code></td>
<td>
<p>Boolean indicating whether single-cell profiles are filtered
out and only errors associated with pseudo-bulk samples are displayed
(<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_pos.x.label">pos.x.label</code></td>
<td>
<p>X-axis position of correlation annotations (0.95 by
default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_pos.y.label">pos.y.label</code></td>
<td>
<p>Y-axis position of correlation annotations (0.1 by
default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_sep.labels">sep.labels</code></td>
<td>
<p>Space separating annotations if <code>corr</code> is equal to
<code>'both'</code> (0.15 by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_size.point">size.point</code></td>
<td>
<p>Size of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_alpha.point">alpha.point</code></td>
<td>
<p>Alpha of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if <code>facet.by</code> is other than <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows if <code>facet.by</code> is different from <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <a href="ggplot2.html#topic+facet_wrap">facet_wrap</a> function
from <span class="pkg">ggplot2</span> if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the correlation plots between expected and
actual proportions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> <code><a href="#topic+distErrorPlot">distErrorPlot</a></code>
<code><a href="#topic+blandAltmanLehPlot">blandAltmanLehPlot</a></code> <code><a href="#topic+barErrorPlot">barErrorPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(6)),
  from = c(1, 1, 1, 15, 15, 30),
  to = c(15, 15, 30, 50, 50, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 50,
  verbose = TRUE
)
# training of DDLS model
tensorflow::tf$compat$v1$disable_eager_execution()
DDLS &lt;- trainDDLSModel(
  object = DDLS,
  on.the.fly = TRUE,
  batch.size = 15,
  num.epochs = 5
)
# evaluation using test data
DDLS &lt;- calculateEvalMetrics(
  object = DDLS
)
# correlations by cell type
corrExpPredPlot(
  object = DDLS,
  facet.by = "CellType",
  color.by = "CellType",
  corr = "both"
)
# correlations of all samples mixed
corrExpPredPlot(
  object = DDLS,
  facet.by = NULL,
  color.by = "CellType",
  corr = "ccc",
  pos.x.label = 0.2,
  alpha.point = 0.3
)

## End(Not run)

</code></pre>

<hr>
<h2 id='createDDLSobject'>Create a <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object from single-cell RNA-seq
and bulk RNA-seq data</h2><span id='topic+createDDLSobject'></span>

<h3>Description</h3>

<p>This function creates a <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object from
single-cell RNA-seq (<code>SingleCellExperiment</code> object) and
bulk RNA-seq data to be deconvoluted (<code>bulk.data</code> parameter)
as a <code>SummarizedExperiment</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createDDLSobject(
  sc.data,
  sc.cell.ID.column,
  sc.gene.ID.column,
  sc.cell.type.column,
  bulk.data,
  bulk.sample.ID.column,
  bulk.gene.ID.column,
  bulk.name.data = "Bulk.DT",
  filter.mt.genes = "^mt-",
  sc.filt.genes.cluster = TRUE,
  sc.min.mean.counts = 1,
  sc.n.genes.per.cluster = 300,
  top.n.genes = 2000,
  sc.log.FC = TRUE,
  sc.min.counts = 1,
  sc.min.cells = 1,
  bulk.min.counts = 1,
  bulk.min.samples = 1,
  shared.genes = TRUE,
  sc.name.dataset.h5 = NULL,
  sc.file.backend = NULL,
  sc.name.dataset.backend = NULL,
  sc.compression.level = NULL,
  sc.chunk.dims = NULL,
  sc.block.processing = FALSE,
  verbose = TRUE,
  project = "DigitalDLSorter-Project"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createDDLSobject_+3A_sc.data">sc.data</code></td>
<td>
<p>Single-cell RNA-seq profiles to be used as reference. If data
are provided from files, <code>single.cell.real</code> must be a vector of three
elements: single-cell counts, cells metadata and genes metadata. On the
other hand, If data are provided from a
<code>SingleCellExperiment</code> object, single-cell counts must
be present in the <code>assay</code> slot, cells metadata in the <code>colData</code>
slot, and genes metadata in the <code>rowData</code> slot.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.cell.id.column">sc.cell.ID.column</code></td>
<td>
<p>Name or number of the column in cells metadata
corresponding to cell names in expression matrix (single-cell RNA-seq
data).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.gene.id.column">sc.gene.ID.column</code></td>
<td>
<p>Name or number of the column in genes metadata
corresponding to the names used for features/genes (single-cell RNA-seq
data).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.cell.type.column">sc.cell.type.column</code></td>
<td>
<p>Name or column number corresponding to cell types
in cells metadata.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_bulk.data">bulk.data</code></td>
<td>
<p>Bulk transcriptomics data to be deconvoluted. It has to be
a <code>SummarizedExperiment</code> object.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_bulk.sample.id.column">bulk.sample.ID.column</code></td>
<td>
<p>Name or column number corresponding to sample
IDs in samples metadata (bulk transcriptomics data).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_bulk.gene.id.column">bulk.gene.ID.column</code></td>
<td>
<p>Name or number of the column in the genes metadata
corresponding to the names used for features/genes (bulk transcriptomics
data).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_bulk.name.data">bulk.name.data</code></td>
<td>
<p>Name of the bulk RNA-seq dataset (<code>"Bulk.DT"</code> by
default).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_filter.mt.genes">filter.mt.genes</code></td>
<td>
<p>Regular expression matching mitochondrial genes to
be ruled out (<code>^mt-</code> by default). If <code>NULL</code>, no filtering is
performed.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.filt.genes.cluster">sc.filt.genes.cluster</code></td>
<td>
<p>Whether to filter single-cell RNA-seq genes
according to a minimum threshold of non-zero average counts per cell type
(<code>sc.min.mean.counts</code>). <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.min.mean.counts">sc.min.mean.counts</code></td>
<td>
<p>Minimum non-zero average counts per cluster to
filter genes. 1 by default.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.n.genes.per.cluster">sc.n.genes.per.cluster</code></td>
<td>
<p>Top n genes with the highest logFC per cluster
(300 by default). See Details section for more details.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_top.n.genes">top.n.genes</code></td>
<td>
<p>Maximum number of genes used for downstream steps (2000
by default). In case the number of genes after filtering is greater than
<code>top.n.genes</code>, these genes will be set according to
variability across the whole single-cell dataset.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.log.fc">sc.log.FC</code></td>
<td>
<p>Whether to filter genes with a logFC less than 0.5 when
<code>sc.filt.genes.cluster = TRUE</code>.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.min.counts">sc.min.counts</code></td>
<td>
<p>Minimum gene counts to filter (1 by default; single-cell
RNA-seq data).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.min.cells">sc.min.cells</code></td>
<td>
<p>Minimum of cells with more than <code>min.counts</code> (1 by
default; single-cell RNA-seq data).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_bulk.min.counts">bulk.min.counts</code></td>
<td>
<p>Minimum gene counts to filter (1 by default; bulk
transcriptomics data).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_bulk.min.samples">bulk.min.samples</code></td>
<td>
<p>Minimum of samples with more than <code>min.counts</code>
(1 by default; bulk transcriptomics data).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_shared.genes">shared.genes</code></td>
<td>
<p>If set to <code>TRUE</code>, only genes present in both the
single-cell and spatial transcriptomics data will be retained for further
processing (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.name.dataset.h5">sc.name.dataset.h5</code></td>
<td>
<p>Name of the data set if HDF5 file is provided for
single-cell RNA-seq data.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.file.backend">sc.file.backend</code></td>
<td>
<p>Valid file path where to store the loaded for
single-cell RNA-seq data as HDF5 file. If provided, data are stored in a
HDF5 file as back-end using the <span class="pkg">DelayedArray</span> and <span class="pkg">HDF5Array</span>
packages instead of being loaded into RAM. This is suitable for situations
where you have large amounts of data that cannot be stored in memory. Note
that operations on these data will be performed by blocks (i.e subsets of
determined size), which may result in longer execution times. <code>NULL</code>
by default.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.name.dataset.backend">sc.name.dataset.backend</code></td>
<td>
<p>Name of the HDF5 file dataset to be used. Note
that it cannot exist. If <code>NULL</code> (by default), a random dataset name
will be generated.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.compression.level">sc.compression.level</code></td>
<td>
<p>The compression level used if
<code>sc.file.backend</code> is provided. It is an integer value between 0 (no
compression) and 9 (highest and slowest compression). See
<code>?<a href="HDF5Array.html#topic+getHDF5DumpCompressionLevel">getHDF5DumpCompressionLevel</a></code> from the
<span class="pkg">HDF5Array</span> package for more information.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.chunk.dims">sc.chunk.dims</code></td>
<td>
<p>Specifies dimensions that HDF5 chunk will have. If
<code>NULL</code>, the default value is a vector of two items: the number of
genes considered by <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object during the
simulation, and only one sample in order to increase read times in the
following steps. A larger number of columns written in each chunk may lead
to longer read times.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_sc.block.processing">sc.block.processing</code></td>
<td>
<p>Boolean indicating whether single-cell RNA-seq
data should be treated as blocks (only if data are provided as HDF5 file).
<code>FALSE</code> by default. Note that using this functionality is suitable for
cases where it is not possible to load data into RAM and therefore
execution times will be longer.</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
<tr><td><code id="createDDLSobject_+3A_project">project</code></td>
<td>
<p>Name of the project for <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code>
object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Filtering genes</strong>
</p>
<p>In order to reduce the number of dimensions used for subsequent steps,
<code>createSpatialDDLSobject</code> implements different strategies aimed at
removing useless genes for deconvolution: </p>
 <ul>
<li><p> Filtering at the
cell level: genes less expressed than a determined cutoff in N cells are
removed. See <code>sc.min.cells</code>/<code>bulk.min.samples</code> and
<code>sc.min.counts</code>/<code>bulk.min.counts</code> parameters. </p>
</li>
<li><p> Filtering at
the cluster level (only for scRNA-seq data): if
<code>sc.filt.genes.cluster == TRUE</code>, <code>createDDLSobject</code> sets a
cutoff of non-zero average counts per
cluster (<code>sc.min.mean.counts</code> parameter) and take only the
<code>sc.n.genes.per.cluster</code> genes with the highest logFC per cluster.
LogFCs are calculated using normalized logCPM of each cluster with respect to
the average in the whole dataset). Finally, if
the number of remaining genes is greater than <code>top.n.genes</code>, genes are
ranked based on variance and the <code>top.n.genes</code> most variable genes are
used for downstream analyses.</p>
</li></ul>

<p><strong>Single-cell RNA-seq data</strong>
</p>
<p>Single-cell RNA-seq data can be provided from files (formats allowed: tsv,
tsv.gz, mtx (sparse matrix) and hdf5) or a
<code>SingleCellExperiment</code> object. The data provided should
consist of three pieces of information: </p>
 <ul>
<li><p> Single-cell counts:
genes as rows and cells as columns. </p>
</li>
<li><p> Cells metadata: annotations
(columns) for each cell (rows). </p>
</li>
<li><p> Genes metadata: annotations (columns)
for each gene (rows). </p>
</li></ul>
<p> If the data is provided from files,
<code>single.cell.real</code> argument must be a vector of three elements ordered
so that the first file corresponds to the count matrix, the second to the
cells metadata and the last to the genes metadata. On the other hand, if the
data is provided as a <code>SingleCellExperiment</code> object, it
must contain single-cell counts in the <code>assay</code> slot, cells metadata in
the <code>colData</code> slot and genes metadata in the <code>rowData</code>. The data
must be provided without any transformation (e.g. log-transformation) and raw
counts are preferred.
</p>
<p><strong>Bulk transcriptomics data</strong>
</p>
<p>It must be a <code>SummarizedExperiment</code> object (or a list of
them if samples from different experiments are going to be deconvoluted)
containing the same information as the single-cell RNA-seq data: the count
matrix, samples metadata (with IDs is enough), and genes metadata. Please,
make sure the gene identifiers used in the bulk and single-cell
transcriptomics data are consistent.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with the single-cell
RNA-seq data provided loaded into the <code>single.cell.real</code> slot as a
<code>SingleCellExperiment</code> object. If bulk
transcriptomics data are provided, they will be stored in the
<code>deconv.data</code> slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code>
<code><a href="#topic+generateBulkCellMatrix">generateBulkCellMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # reproducibility
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(100, lambda = 5), nrow = 40, ncol = 30,
      dimnames = list(paste0("Gene", seq(40)), paste0("RHC", seq(30)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(30)),
    Cell_Type = sample(x = paste0("CellType", seq(4)), size = 30,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(40))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.min.cells = 0,
  sc.min.counts = 0,
  sc.log.FC = FALSE,
  sc.filt.genes.cluster = FALSE,
  project = "Simul_example"
)
  
</code></pre>

<hr>
<h2 id='deconv.data'>Get and set <code>deconv.data</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+deconv.data'></span><span id='topic+deconv.data+2CDigitalDLSorter-method'></span><span id='topic+deconv.data+3C-'></span><span id='topic+deconv.data+3C-+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Get and set <code>deconv.data</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconv.data(object, name.data = NULL)

deconv.data(object, name.data = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconv.data_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object.</p>
</td></tr>
<tr><td><code id="deconv.data_+3A_name.data">name.data</code></td>
<td>
<p>Name of the data. If <code>NULL</code> (by default), all
data contained in the <code>deconv.data</code> slot are returned.</p>
</td></tr>
<tr><td><code id="deconv.data_+3A_value">value</code></td>
<td>
<p>List whose names are the reference of the stored data.</p>
</td></tr>
</table>

<hr>
<h2 id='deconv.results'>Get and set <code>deconv.results</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+deconv.results'></span><span id='topic+deconv.results+2CDigitalDLSorter-method'></span><span id='topic+deconv.results+3C-'></span><span id='topic+deconv.results+3C-+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Get and set <code>deconv.results</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconv.results(object, name.data = NULL)

deconv.results(object, name.data = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconv.results_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object.</p>
</td></tr>
<tr><td><code id="deconv.results_+3A_name.data">name.data</code></td>
<td>
<p>Name of the data. If <code>NULL</code> (by default), all
results contained in the <code>deconv.results</code> slot are returned.</p>
</td></tr>
<tr><td><code id="deconv.results_+3A_value">value</code></td>
<td>
<p>List whose names are the reference of the stored results.</p>
</td></tr>
</table>

<hr>
<h2 id='deconvDDLSObj'>Deconvolute bulk gene expression samples (bulk RNA-Seq)</h2><span id='topic+deconvDDLSObj'></span>

<h3>Description</h3>

<p>Deconvolute bulk gene expression samples (bulk RNA-Seq). This function
requires a <code>DigitalDLSorter</code> object with a trained Deep Neural Network
model (<code><a href="#topic+trained.model">trained.model</a></code> slot) and the new bulk RNA-Seq samples to
be deconvoluted in the <code>deconv.data</code> slot. See
<code>?<a href="#topic+loadDeconvData">loadDeconvData</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconvDDLSObj(
  object,
  name.data = "Bulk.DT",
  normalize = TRUE,
  scaling = "standardize",
  simplify.set = NULL,
  simplify.majority = NULL,
  use.generator = FALSE,
  batch.size = 64,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconvDDLSObj_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>trained.data</code> and <code>deconv.data</code> slots.</p>
</td></tr>
<tr><td><code id="deconvDDLSObj_+3A_name.data">name.data</code></td>
<td>
<p>Name of the data stored in the <code>DigitalDLSorter</code>
object. If not provided, the first data set will be used.</p>
</td></tr>
<tr><td><code id="deconvDDLSObj_+3A_normalize">normalize</code></td>
<td>
<p>Normalize data before deconvolution (<code>TRUE</code> by
default).</p>
</td></tr>
<tr><td><code id="deconvDDLSObj_+3A_scaling">scaling</code></td>
<td>
<p>How to scale data before training. It may be:
<code>"standardize"</code> (values are centered around the mean with a unit
standard deviation) or <code>"rescale"</code> (values are shifted and rescaled so
that they end up ranging between 0 and 1). If <code>normalize = FALSE</code>,
data is not scaled.</p>
</td></tr>
<tr><td><code id="deconvDDLSObj_+3A_simplify.set">simplify.set</code></td>
<td>
<p>List specifying which cell types should be compressed
into a new label whose name will be the list item. See examples for
details. If provided, results are stored in a list with 'raw' and
'simpli.set' results.</p>
</td></tr>
<tr><td><code id="deconvDDLSObj_+3A_simplify.majority">simplify.majority</code></td>
<td>
<p>List specifying which cell types should be
compressed into the cell type with the highest proportion in each sample.
Unlike <code>simplify.set</code>, it allows to maintain the complexity of the
results while compressing the information, as no new labels are created. If
provided, the results are stored in a list with 'raw' and 'simpli.majority'
results.</p>
</td></tr>
<tr><td><code id="deconvDDLSObj_+3A_use.generator">use.generator</code></td>
<td>
<p>Boolean indicating whether to use generators for
prediction (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="deconvDDLSObj_+3A_batch.size">batch.size</code></td>
<td>
<p>Number of samples per batch. Only when <code>use.generator
= TRUE</code>.</p>
</td></tr>
<tr><td><code id="deconvDDLSObj_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended for users who have built a devonvolution model
using their own single-cell RNA-Seq data. If you want to use a pre-trained
model to deconvolute your samples, see <code>?<a href="#topic+deconvDigitalDLSorter">deconvDigitalDLSorter</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>deconv.results</code> slot. The resulting information is a data frame with
samples (<code class="reqn">i</code>) as rows and cell types (<code class="reqn">j</code>) as columns. Each entry
represents the proportion of <code class="reqn">j</code> cell type in <code class="reqn">i</code> sample. If
<code>simplify.set</code> or/and <code>simpplify.majority</code> are provided, the
<code>deconv.results</code> slot will contain a list with raw and simplified
results.
</p>


<h3>References</h3>

<p>Torroja, C. and Sánchez-Cabo, F. (2019). digitalDLSorter: A Deep
Learning algorithm to quantify immune cell populations based on scRNA-Seq
data. Frontiers in Genetics 10, 978. doi: <a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code>
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(6)),
  from = c(1, 1, 1, 15, 15, 30),
  to = c(15, 15, 30, 50, 50, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 50,
  verbose = TRUE
)
# training of DDLS model
tensorflow::tf$compat$v1$disable_eager_execution()
DDLS &lt;- trainDDLSModel(
  object = DDLS,
  on.the.fly = TRUE,
  batch.size = 15,
  num.epochs = 5
)
# simulating bulk RNA-Seq data
countsBulk &lt;- matrix(
  stats::rpois(100, lambda = sample(seq(4, 10), size = 100, replace = TRUE)),
  nrow = 40, ncol = 15,
  dimnames = list(paste0("Gene", seq(40)), paste0("Bulk", seq(15)))
)
seBulk &lt;- SummarizedExperiment(assay = list(counts = countsBulk))
DDLS &lt;- loadDeconvData(
  object = DDLS,
  data = seBulk,
  name.data = "Example"
)
# simplify arguments
simplify &lt;- list(CellGroup1 = c("CellType1", "CellType2", "CellType4"),
                 CellGroup2 = c("CellType3", "CellType5"))
DDLS &lt;- deconvDDLSObj(
  object = DDLS,
  name.data = "Example",
  simplify.set = simplify,
  simplify.majority = simplify
)

## End(Not run)
</code></pre>

<hr>
<h2 id='deconvDigitalDLSorter'>Deconvolute bulk RNA-Seq samples using a pre-trained DigitalDLSorter model</h2><span id='topic+deconvDigitalDLSorter'></span>

<h3>Description</h3>

<p>Deconvolute bulk gene expression samples (bulk RNA-Seq) to enumerate and
quantify the proportion of cell types present in a bulk sample using Deep
Neural Network models. This function is intended for users who want to use
pre-trained models integrated in the package. So far, the available models
allow to deconvolute the immune infiltration of breast cancer (using data from
Chung et al., 2017) and the immune infiltration of colorectal cancer (using
data from Li et al., 2017) samples. For the former, two models are available
at two different levels of specificity: specific cell types
(<code>breast.chung.specific</code>) and generic cell types
(<code>breast.chung.generic</code>). See <code>breast.chung.generic</code>,
<code>breast.chung.specific</code>, and <code>colorectal.li</code> documentation from the
<span class="pkg">digitalDLSorteRdata</span> package for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconvDigitalDLSorter(
  data,
  model = NULL,
  normalize = TRUE,
  scaling = "standardize",
  simplify.set = NULL,
  simplify.majority = NULL,
  use.generator = FALSE,
  batch.size = 64,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconvDigitalDLSorter_+3A_data">data</code></td>
<td>
<p>Matrix or data frame with bulk RNA-Seq samples with genes as rows
in SYMBOL notation and samples as columns.</p>
</td></tr>
<tr><td><code id="deconvDigitalDLSorter_+3A_model">model</code></td>
<td>
<p>Pre-trained DNN model to use to deconvolute <code>data</code>. Up to
now, the available models are intended to deconvolute samples from breast
cancer (<code>breast.chung.generic</code> and <code>breast.chung.specific</code>) and
colorectal cancer (<code>colorectal.li</code>). These pre-trained models are
stored in the <span class="pkg">digitalDLSorteRdata</span> package, so it must be installed
together with <span class="pkg">digitalDLSorteR</span> to use this function.</p>
</td></tr>
<tr><td><code id="deconvDigitalDLSorter_+3A_normalize">normalize</code></td>
<td>
<p>Normalize data before deconvolution (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="deconvDigitalDLSorter_+3A_scaling">scaling</code></td>
<td>
<p>How to scale data before training. It may be:
<code>"standardize"</code> (values are centered around the mean with a unit
standard deviation) or <code>"rescale"</code> (values are shifted and rescaled so
that they end up ranging between 0 and 1). If <code>normalize = FALSE</code>, data
is not scaled.</p>
</td></tr>
<tr><td><code id="deconvDigitalDLSorter_+3A_simplify.set">simplify.set</code></td>
<td>
<p>List specifying which cell types should be compressed into
a new label whose name will be the list name item. See examples and
vignettes for details.</p>
</td></tr>
<tr><td><code id="deconvDigitalDLSorter_+3A_simplify.majority">simplify.majority</code></td>
<td>
<p>List specifying which cell types should be compressed
into the cell type with the highest proportion in each sample. Unlike
<code>simplify.set</code>, this argument allows to maintain the complexity of the
results while compressing the information, as no new labels are created.</p>
</td></tr>
<tr><td><code id="deconvDigitalDLSorter_+3A_use.generator">use.generator</code></td>
<td>
<p>Boolean indicating whether to use generators for
prediction (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="deconvDigitalDLSorter_+3A_batch.size">batch.size</code></td>
<td>
<p>Number of samples per batch. Only when <code>use.generator
= TRUE</code>.</p>
</td></tr>
<tr><td><code id="deconvDigitalDLSorter_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended for users who want to use <span class="pkg">digitalDLSorteR</span> to
deconvolute their bulk RNA-Seq samples using pre-trained models. For users who
want to build their own models from other scRNA-Seq datasets, see the
<code><a href="#topic+createDDLSobject">createDDLSobject</a></code> and <code><a href="#topic+deconvDDLSObj">deconvDDLSObj</a></code>
functions.
</p>


<h3>Value</h3>

<p>A data frame with samples (<code class="reqn">i</code>) as rows and cell types (<code class="reqn">j</code>)
as columns. Each entry represents the predicted proportion of cell type
<code class="reqn">j</code> in sample <code class="reqn">i</code>.
</p>


<h3>References</h3>

<p>Chung, W., Eum, H. H., Lee, H. O., Lee, K. M., Lee, H. B., Kim, K.
T., et al. (2017). Single-cell RNA-seq enables comprehensive tumour and
immune cell profiling in primary breast cancer. Nat. Commun. 8 (1), 15081.
doi: <a href="https://doi.org/10.1038/ncomms15081">doi:10.1038/ncomms15081</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deconvDDLSObj">deconvDDLSObj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(6)),
  from = c(1, 1, 1, 15, 15, 30),
  to = c(15, 15, 30, 50, 50, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 50,
  verbose = TRUE
)
# training of DDLS model
tensorflow::tf$compat$v1$disable_eager_execution()
DDLS &lt;- trainDDLSModel(
  object = DDLS,
  on.the.fly = TRUE,
  batch.size = 15,
  num.epochs = 5
)
# simulating bulk RNA-Seq data
countsBulk &lt;- matrix(
  stats::rpois(100, lambda = sample(seq(4, 10), size = 100, replace = TRUE)),
  nrow = 40, ncol = 15,
  dimnames = list(paste0("Gene", seq(40)), paste0("Bulk", seq(15)))
)
# this is only an example. See vignettes to see how to use pre-trained models
# from the digitalDLSorteRmodels data package
results1 &lt;- deconvDigitalDLSorter(
  data = countsBulk,
  model = trained.model(DDLS),
  normalize = TRUE
)
# simplify arguments
simplify &lt;- list(CellGroup1 = c("CellType1", "CellType2", "CellType4"),
                 CellGroup2 = c("CellType3", "CellType5"))
# in this case the names of the list will be the new labels
results2 &lt;- deconvDigitalDLSorter(
  countsBulk,
  model = trained.model(DDLS),
  normalize = TRUE,
  simplify.set = simplify
)
# in this case the cell type with the highest proportion will be the new label
results3 &lt;- deconvDigitalDLSorter(
  countsBulk,
  model = trained.model(DDLS),
  normalize = TRUE,
  simplify.majority = simplify
)

## End(Not run)

</code></pre>

<hr>
<h2 id='digitalDLSorteR'>digitalDLSorteR: an R package to deconvolute bulk RNA-Seq samples using
single-cell RNA-Seq data and Deep Learning</h2><span id='topic+digitalDLSorteR'></span>

<h3>Description</h3>

<p><span class="pkg">digitalDLSorteR</span> is an R package that allows to deconvolute bulk RNA-Seq
data using context-specific deconvolution models based on single-cell RNA-Seq
data and Deep Neural Networks. These models are able to make accurate
estimates of the cell composition of bulk RNA-Seq samples from the same
context using the advances provided by Deep Learning and the meaningful
information provided by scRNA-Seq data. See Torroja and Sanchez-Cabo (2019)
(<a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a>) for more details.
</p>


<h3>Details</h3>

<p>The foundation of the method consists of a process that starts from
single-cell RNA-Seq data and, after a few steps, a Deep Neural Network (DNN)
model is trained with simulated pseudo-bulk RNA-Seq samples whose cell
composition is known. These trained models are able to deconvolute any bulk
RNA-Seq sample from the same biological context by determining the proportion
of present cell types. The main advantage is the possibility to build
deconvolution models trained with real data from certain biological
environments. For example, to quantify the proportion of tumor infiltrated
lymphocytes (TILs) in breast cancer, a specific model for this type of
samples can be obtained by using this package. This overcomes the limitation
of other methods, since stromal and immune cells may significantly change
their transcriptional profiles depending on tissue and disease context.
</p>
<p>The package can be used in two ways: deconvoluting bulk RNA-Seq samples using
pre-trained models available on the digitalDLSorteRmodels R package or
building your own models trained with your own single-cell RNA-Seq data.
These new models may be published to make them available for other users
working with similar data. So far, available models allow deconvoluting
breast and colorectal cancer samples. See vignettes and
<a href="https://diegommcc.github.io/digitalDLSorteR/">https://diegommcc.github.io/digitalDLSorteR/</a> for more details.
</p>

<hr>
<h2 id='DigitalDLSorter-class'>The DigitalDLSorter Class</h2><span id='topic+DigitalDLSorter-class'></span><span id='topic+DigitalDLSorter'></span>

<h3>Description</h3>

<p>The DigitalDLSorter object is the core of <code>digitalDLSorteR</code>. This object
stores different intermediate data resulting from the creation of new
context-specific deconvolution models from single-cell data. It is only used
in the case of building new deconvolution models. To deconvolute bulk samples
using pre-trained models, see <code><a href="#topic+deconvDigitalDLSorter">deconvDigitalDLSorter</a></code> function
and the package <span class="pkg">digitalDLSorteRdata</span>.
</p>


<h3>Details</h3>

<p>This object uses other classes to store the different types of data produced
during the process: </p>
 <ul>
<li> <p><code>SingleCellExperiment</code>
class for single-cell RNA-Seq data, using sparse matrix from the <span class="pkg">Matrix</span>
package (<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> class) or <code>HDF5Array</code> class in
the case of using HDF5 files as back-end (see below for more information).
</p>
</li>
<li> <p><code>ZinbModel</code> class with estimated parameters for the
simulation of new single-cell profiles. </p>
</li>
<li>
<p><code>SummarizedExperiment</code> class for large bulk RNA-Seq data
storage. </p>
</li>
<li> <p><code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> class for the
compositional cell matrices constructed during the process. See
<code>?<a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> for details. </p>
</li>
<li>
<p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> class to store the information
related to Deep Neural Network models. This step is performed using
<code>keras</code>. See <code>?<a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> for details. </p>
</li></ul>

<p><span class="pkg">digitalDLSorteR</span> can be used in two ways: to build new deconvolution
models from single-cell RNA-Seq data or to deconvolute bulk RNA-Seq samples
using pre-trained models available at <span class="pkg">digitalDLSorteRdata</span> package. If
you want to build new models, see <code><a href="#topic+createDDLSobject">createDDLSobject</a></code> function. On
the other hand, if you want to use pre-trained models, see
<code><a href="#topic+deconvDigitalDLSorter">deconvDigitalDLSorter</a></code> function.
</p>
<p>In order to provide a way to work with large amounts of data on
RAM-constrained machines, we provide the possibility to use HDF5 files as
back-end to store count matrices of both real/simulated single-cell and bulk
RNA-Seq profiles. For this, the package uses the <code>HDF5Array</code> and
<code>DelayedArray</code> classes from the homonymous packages.
</p>
<p>Once the Deep Neural Network model has been trained trained, it is possible
to save it as RDS or HDF5 files. Please see
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> for more details.
</p>


<h3>Slots</h3>


<dl>
<dt><code>single.cell.real</code></dt><dd><p>Real single-cell data stored in a
<code>SingleCellExperiment</code> object. The count matrix is stored as
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> or <code>HDF5Array</code> objects.</p>
</dd>
<dt><code>deconv.data</code></dt><dd><p>List of <code>SummarizedExperiment</code> objects
where it is possible to store new bulk RNA-Seq experiments for
deconvolution. The name of the entries corresponds to the name of the data
provided. See <code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code> for details.</p>
</dd>
<dt><code>zinb.params</code></dt><dd><p><code>ZinbModel</code> object with estimated
parameters for the simulation of new single-cell expression profiles.</p>
</dd>
<dt><code>single.cell.simul</code></dt><dd><p>Simulated single-cell expression profiles from the
ZINB-WaVE model.</p>
</dd>
<dt><code>prob.cell.types</code></dt><dd><p><code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> class with
cell composition matrices built for the simulation of pseudo-bulk RNA-Seq
profiles with known cell composition.</p>
</dd>
<dt><code>bulk.simul</code></dt><dd><p>A list of simulated train and test bulk RNA-Seq samples.
Each entry is a <code>SummarizedExperiment</code> object. The count
matrices can be stored as <code>HDF5Array</code> files using HDF5 files as
back-end in case of RAM limitations.</p>
</dd>
<dt><code>trained.model</code></dt><dd><p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object with all
the information related to the trained model. See
<code>?<a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> for more details.</p>
</dd>
<dt><code>deconv.results</code></dt><dd><p>Slot containing the deconvolution results of applying
the deconvolution model to the data present in the
<code><a href="#topic+deconv.data">deconv.data</a></code> slot. It is a list in which the names corresponds
to the data from which they come.</p>
</dd>
<dt><code>project</code></dt><dd><p>Name of the project.</p>
</dd>
<dt><code>version</code></dt><dd><p>Version of DigitalDLSorteR this object was built under.</p>
</dd>
</dl>

<hr>
<h2 id='DigitalDLSorterDNN-class'>The DigitalDLSorterDNN Class</h2><span id='topic+DigitalDLSorterDNN-class'></span><span id='topic+DigitalDLSorterDNN'></span>

<h3>Description</h3>

<p>The DigitalDLSorterDNN object stores all the information related to Deep
Neural Network models. It contains the trained model, the training history
and the results of prediction on test data. After running
<code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code>, it is possible to find the performance
evaluation of the model on test data (see <code>?<a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code>
for details).
</p>


<h3>Details</h3>

<p>The steps related to Deep Learning are carried out using the <span class="pkg">keras</span>
package which uses the R6 classes system. If you want to save the object as
an RDS file, <code>digitalDLSorteR</code> provides a <code>saveRDS</code> generic
function that transforms the model stored as an R6 object into a native valid
R object. Specifically, the model is converted into a list with the
architecture of the network and the weights learned during training. That is
the minimum information needed to use the model as predictor. If you want to
keep the optimizer state, see <code>?<a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code>. If you
want to store <code><a href="#topic+DigitalDLSorter">DigitalDLSorter</a></code> object on disk as an RDA file,
see <code>?<a href="#topic+preparingToSave">preparingToSave</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>Trained Deep Neural Network. This slot can contain an R6
<code>keras.engine.sequential.Sequential</code> object or a list with two
elements: the architecture of the model and the resulting weights after
training.</p>
</dd>
<dt><code>training.history</code></dt><dd><p>List with the evolution of the selected metrics during
training.</p>
</dd>
<dt><code>test.metrics</code></dt><dd><p>Performance of the model on test data.</p>
</dd>
<dt><code>test.pred</code></dt><dd><p>Deconvolution results on test data. Columns are cell types,
rows are samples and each entry corresponds to the proportion of this cell
type in this sample.</p>
</dd>
<dt><code>cell.types</code></dt><dd><p>Vector with cell types to deconvolute.</p>
</dd>
<dt><code>features</code></dt><dd><p>Vector with the features used during training. These features
will be used in subsequent predictions (the nomenclature used in new bulk
RNA-Seq samples must be the same).</p>
</dd>
<dt><code>test.deconv.metrics</code></dt><dd><p>Performance of the model on each sample of test
data compared to known cell proportions. This slot is used after
<code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> (see <code>?<a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code>
for more details).</p>
</dd>
</dl>

<hr>
<h2 id='distErrorPlot'>Generate box plots or violin plots to show how the errors are distributed</h2><span id='topic+distErrorPlot'></span>

<h3>Description</h3>

<p>Generate violin plots or box plots to show how the errors are distributed by
proportion bins of 0.1. Errors can be displayed all mixed or split by cell
type (<code>CellType</code>) or number of cell types present in the samples
(<code>nCellTypes</code>). See the <code>facet.by</code> argument and examples for more
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distErrorPlot(
  object,
  error,
  colors,
  x.by = "pBin",
  facet.by = NULL,
  color.by = "nCellTypes",
  filter.sc = TRUE,
  error.label = FALSE,
  pos.x.label = 4.6,
  pos.y.label = NULL,
  size.point = 0.1,
  alpha.point = 1,
  type = "violinplot",
  ylimit = NULL,
  nrow = NULL,
  ncol = NULL,
  title = NULL,
  theme = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distErrorPlot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>trained.model</code> slot containing metrics in the
<code>test.deconv.metrics</code> slot of a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_error">error</code></td>
<td>
<p>The error to be represented. Available errors are absolute error
(<code>'AbsErr'</code>), proportional absolute error (<code>'ppAbsErr'</code>), squared
error (<code>'SqrErr'</code>) and proportional squared error (<code>'ppSqrErr'</code>).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to be used. Only vectors with a number of
colors equal to or greater than the levels of <code>color.by</code> will be
accepted. By default, a custom color list is used.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_x.by">x.by</code></td>
<td>
<p>Variable used for the X-axis. When <code>facet.by</code> is not
<code>NULL</code>, the best choice is <code>pBin</code> (probability bins). The options
are <code>nCellTypes</code> (number of different cell types), <code>CellType</code>
(cell type) and <code>pBin</code>.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_facet.by">facet.by</code></td>
<td>
<p>Variable used to display data in different panels. If
<code>NULL</code>, the plot is not split into different panels. Options are
<code>nCellTypes</code> (number of different cell types) and <code>CellType</code>
(cell type).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_color.by">color.by</code></td>
<td>
<p>Variable used to color the data. Options are
<code>nCellTypes</code> and <code>CellType</code>.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_filter.sc">filter.sc</code></td>
<td>
<p>Boolean indicating whether single-cell profiles are filtered
out and only errors associated with pseudo-bulk samples are displayed
(<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_error.label">error.label</code></td>
<td>
<p>Boolean indicating whether to display the average error as
a plot annotation (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_pos.x.label">pos.x.label</code></td>
<td>
<p>X-axis position of error annotations.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_pos.y.label">pos.y.label</code></td>
<td>
<p>Y-axis position of error annotations.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_size.point">size.point</code></td>
<td>
<p>Size of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_alpha.point">alpha.point</code></td>
<td>
<p>Alpha of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_type">type</code></td>
<td>
<p>Type of plot: <code>'boxplot'</code> or <code>'violinplot'</code>. The latter
by default.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_ylimit">ylimit</code></td>
<td>
<p>Upper limit in Y-axis if it is required (<code>NULL</code> by
default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <a href="ggplot2.html#topic+facet_wrap">facet_wrap</a> function
from <span class="pkg">ggplot2</span> if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the representation of the desired errors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> <code><a href="#topic+corrExpPredPlot">corrExpPredPlot</a></code>
<code><a href="#topic+blandAltmanLehPlot">blandAltmanLehPlot</a></code> <code><a href="#topic+barErrorPlot">barErrorPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(6)),
  from = c(1, 1, 1, 15, 15, 30),
  to = c(15, 15, 30, 50, 50, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 50,
  verbose = TRUE
)
# training of DDLS model
tensorflow::tf$compat$v1$disable_eager_execution()
DDLS &lt;- trainDDLSModel(
  object = DDLS,
  on.the.fly = TRUE,
  batch.size = 15,
  num.epochs = 5
)
# evaluation using test data
DDLS &lt;- calculateEvalMetrics(
  object = DDLS
)
# representation, for more examples, see the vignettes
distErrorPlot(
  object = DDLS,
  error = "AbsErr",
  facet.by = "CellType",
  color.by = "nCellTypes",
  error.label = TRUE
)
distErrorPlot(
  object = DDLS,
  error = "AbsErr",
  x.by = "CellType",
  facet.by = NULL,
  filter.sc = FALSE,
  color.by = "CellType",
  error.label = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='estimateZinbwaveParams'>Estimate the parameters of the ZINB-WaVE model to simulate new single-cell
RNA-Seq expression profiles</h2><span id='topic+estimateZinbwaveParams'></span>

<h3>Description</h3>

<p>Estimate the parameters of the ZINB-WaVE model using a real single-cell
RNA-Seq data set as reference to simulate new single-cell profiles and
increase the signal of underrepresented cell types. This step is optional,
only is needed if the size of you dataset is too small or there are
underrepresented cell types in order to train the Deep Neural Network model
in a more balanced way. After this step, the <code><a href="#topic+simSCProfiles">simSCProfiles</a></code>
function will use the estimated parameters to simulate new single-cell
profiles. See <code>?<a href="#topic+simSCProfiles">simSCProfiles</a></code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateZinbwaveParams(
  object,
  cell.type.column,
  cell.ID.column,
  gene.ID.column,
  cell.cov.columns,
  gene.cov.columns,
  subset.cells = NULL,
  proportional = TRUE,
  set.type = "All",
  threads = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateZinbwaveParams_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with a
<code>single.cell.real</code> slot.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_cell.type.column">cell.type.column</code></td>
<td>
<p>Name or column number corresponding to the cell type
of each cell in cells metadata.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_cell.id.column">cell.ID.column</code></td>
<td>
<p>Name or column number corresponding to the cell names
of expression matrix in cells metadata.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_gene.id.column">gene.ID.column</code></td>
<td>
<p>Name or column number corresponding to the notation
used for features/genes in genes metadata.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_cell.cov.columns">cell.cov.columns</code></td>
<td>
<p>Name or column number(s) in cells metadata to be used
as covariates during model fitting (if no covariates are used, set to empty
or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_gene.cov.columns">gene.cov.columns</code></td>
<td>
<p>Name or column number(s) in genes metadata that will
be used as covariates during model fitting (if no covariates are used, set
to empty or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_subset.cells">subset.cells</code></td>
<td>
<p>Number of cells to fit the ZINB-WaVE model. Useful when
the original data set is too large to fit the model. Set a value according
to the original data set and the resources available on your computer. If
<code>NULL</code> (by default), all cells will be used. Must be an integer
greater than or equal to the number of cell types considered and less than
or equal to the total number of cells.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_proportional">proportional</code></td>
<td>
<p>If <code>TRUE</code>, the original cell type proportions in the
subset of cells generated by <code>subset.cells</code> will not be altered as far
as possible. If <code>FALSE</code>, all cell types will have the same number of
cells as far as possible (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_set.type">set.type</code></td>
<td>
<p>Cell type(s) to evaluate (<code>'All'</code> by default). It is
recommended fitting the model to all cell types rather than using only a
subset of them to capture the total variability present in the original
experiment even if only a subset of cell types is simulated.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_threads">threads</code></td>
<td>
<p>Number of threads used for estimation (1 by default). To set
up the parallel environment, the <span class="pkg">BiocParallel</span> package must be
installed.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ZINB-WaVE is a flexible model for zero-inflated count data. This function
carries out the model fit to real single-cell data modeling <code class="reqn">Y_{ij}</code> (the
count of feature <code class="reqn">j</code> for sample <code class="reqn">i</code>) as a random variable following a
zero-inflated negative binomial (ZINB) distribution. The estimated parameters
will be used for the simulation of new single-cell expression profiles by
sampling a negative binomial distribution and inserting dropouts from a
binomial distribution. To do so, <span class="pkg">digitalDLSorteR</span> uses the
<code><a href="zinbwave.html#topic+zinbFit">zinbFit</a></code> function from the <span class="pkg">zinbwave</span> package
(Risso et al., 2018). For more details about the model, see Risso et al.,
2018.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with <code>zinb.params</code>
slot containing a <code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object. This
object contains a slot with the estimated ZINB-WaVE parameters from the
real single-cell RNA-Se'q data.
</p>


<h3>References</h3>

<p>Risso, D., Perraudeau, F., Gribkova, S. et al. (2018). A general
and flexible method for signal extraction from single-cell RNA-seq data.
Nat Commun 9, 284. doi: <a href="https://doi.org/10.1038/s41467-017-02554-5">doi:10.1038/s41467-017-02554-5</a>.
</p>
<p>Torroja, C. and Sánchez-Cabo, F. (2019). digitalDLSorter: A Deep Learning
algorithm to quantify immune cell populations based on scRNA-Seq data.
Frontiers in Genetics 10, 978. doi: <a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simSCProfiles">simSCProfiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # reproducibility
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
DDLS &lt;- estimateZinbwaveParams(
  object = DDLS,
  cell.type.column = "Cell_Type",
  cell.ID.column = "Cell_ID",
  gene.ID.column = "Gene_ID",
  subset.cells = 2,
  verbose = TRUE
)

</code></pre>

<hr>
<h2 id='features'>Get and set <code>features</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object</h2><span id='topic+features'></span><span id='topic+features+2CDigitalDLSorterDNN-method'></span><span id='topic+features+3C-'></span><span id='topic+features+3C-+2CDigitalDLSorterDNN-method'></span>

<h3>Description</h3>

<p>Get and set <code>features</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>features(object)

features(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="features_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
<tr><td><code id="features_+3A_value">value</code></td>
<td>
<p>Vector with features (genes) considered by the Deep Neural
Network model.</p>
</td></tr>
</table>

<hr>
<h2 id='generateBulkCellMatrix'>Generate training and test cell composition matrices</h2><span id='topic+generateBulkCellMatrix'></span>

<h3>Description</h3>

<p>Generate training and test cell composition matrices for the simulation of
pseudo-bulk RNA-Seq samples with known cell composition using single-cell
expression profiles. The resulting <code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code>
object contains a matrix that determines the proportion of the different cell
types that will compose the simulated pseudo-bulk samples. In addition, this
object also contains other information relevant for the process. This
function does not simulate pseudo-bulk samples, this task is performed by the
<code><a href="#topic+simBulkProfiles">simBulkProfiles</a></code> or <code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code>
functions (see Documentation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateBulkCellMatrix(
  object,
  cell.ID.column,
  cell.type.column,
  prob.design,
  num.bulk.samples,
  n.cells = 100,
  train.freq.cells = 3/4,
  train.freq.bulk = 3/4,
  proportion.method = c(10, 5, 20, 15, 35, 15),
  prob.sparsity = 0.5,
  min.zero.prop = NULL,
  balanced.type.cells = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateBulkCellMatrix_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>single.cell.real</code> slot and, optionally, with <code>single.cell.simul</code>
slot.</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_cell.id.column">cell.ID.column</code></td>
<td>
<p>Name or column number corresponding to the cell names
of expression matrix in cells metadata.</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_cell.type.column">cell.type.column</code></td>
<td>
<p>Name or column number corresponding to the cell type
of each cell in cells metadata.</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_prob.design">prob.design</code></td>
<td>
<p>Data frame with the expected frequency ranges for each
cell type present in the experiment. This information can be estimated from
literature or from the single-cell experiment itself. This data frame must
be constructed by three columns with specific headings (see examples):
</p>
 <ul>
<li><p> A cell type column with the same name of the cell type
column in cells metadata (<code>cell.type.column</code>). If the name of the
column is not the same, the function will return an error. All cell types
must appear in the cells metadata. </p>
</li>
<li><p> A second column called
<code>'from'</code> with the start frequency for each cell type. </p>
</li>
<li><p> A third
column called <code>'to'</code> with the ending frequency for each cell type.</p>
</li></ul>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_num.bulk.samples">num.bulk.samples</code></td>
<td>
<p>Number of bulk RNA-Seq sample proportions (and thus
simulated bulk RNA-Seq samples) to be generated taking into account
training and test data. We recommend seting this value according to the
number of single-cell profiles available in
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object avoiding an excesive
re-sampling, but generating a large number of samples for better training.</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_n.cells">n.cells</code></td>
<td>
<p>Number of cells that will be aggregated in order to simulate
one bulk RNA-Seq sample (100 by default).</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_train.freq.cells">train.freq.cells</code></td>
<td>
<p>Proportion of cells used to simulate training
pseudo-bulk samples (2/3 by default).</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_train.freq.bulk">train.freq.bulk</code></td>
<td>
<p>Proportion of bulk RNA-Seq samples to the total number
(<code>num.bulk.samples</code>) used for the training set (2/3 by default).</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_proportion.method">proportion.method</code></td>
<td>
<p>Vector of six integers that determines the
proportions of bulk samples generated by the different methods (see Details
and Torroja and Sanchez-Cabo, 2019. for more information). This vector
represents proportions, so its entries must add up 100. By default, a
majority of random samples will be generated without using predefined
ranges.</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_prob.sparsity">prob.sparsity</code></td>
<td>
<p>It only affects the proportions generated by the first
method (Dirichlet distribution). It determines the probability of having
missing cell types in each simulated spot, as opposed to a mixture of all
cell types. A higher value for this parameter will result in more sparse
simulated samples.</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_min.zero.prop">min.zero.prop</code></td>
<td>
<p>This parameter controls the minimum number of cell types
that will be absent in each simulated spot. If <code>NULL</code> (by default),
this value will be half of the total number of different cell types, but
increasing it will result in more spots composed of fewer cell types. This
helps to create more sparse proportions and cover a wider range of
situations during model training.</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_balanced.type.cells">balanced.type.cells</code></td>
<td>
<p>Boolean indicating whether the training and test
cells will be split in a balanced way considering the cell types
(<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="generateBulkCellMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the available single-cell profiles are split into training and test
subsets (2/3 for training and 1/3 for test by default (see
<code>train.freq.cells</code>)) to avoid falsifying the results during model
evaluation. Next, <code>num.bulk.samples</code> bulk samples proportions are built
and the single-cell profiles to be used to simulate each pseudo-bulk RNA-Seq
sample are set, being 100 cells per bulk sample by default (see
<code>n.cells</code> argument). The proportions of training and test pseudo-bulk
samples are set by <code>train.freq.bulk</code> (2/3 for training and 1/3 for
testing by default). Finally, in order to avoid biases due to the composition
of the pseudo-bulk RNA-Seq samples, cell type proportions (<code class="reqn">w_1,...,w_k</code>,
where <code class="reqn">k</code> is the number of cell types available in single-cell profiles)
are randomly generated by using six different approaches:
</p>
 <ol>
<li><p> Cell proportions are randomly sampled from a truncated
uniform distribution with predefined limits according to a priori knowledge
of the abundance of each cell type (see <code>prob.design</code> argument). This
information can be inferred from the single-cell experiment itself or from
the literature. </p>
</li>
<li><p> A second set is generated by randomly permuting cell
type labels from a distribution generated by the previous method. </p>
</li>
<li><p> Cell
proportions are randomly sampled as by method 1 without replacement. </p>
</li>
<li>
<p>Using the last method for generating proportions, cell types labels are
randomly sampled. </p>
</li>
<li><p> Cell proportions are randomly sampled from a
Dirichlet distribution. </p>
</li>
<li><p> Pseudo-bulk RNA-Seq samples composed of the
same cell type are generated in order to provide 'pure' pseudo-bulk samples.</p>
</li></ol>

<p>If you want to inspect the distribution of cell type proportions generated by
each method during the process, they can be visualized by the
<code><a href="#topic+showProbPlot">showProbPlot</a></code> function (see Documentation).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>prob.cell.types</code> slot containing a <code>list</code> with two
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> objects (training and test). For
more information about the structure of this class, see
<code>?<a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code>.
</p>


<h3>References</h3>

<p>Torroja, C. and Sánchez-Cabo, F. (2019). digitalDLSorter: A Deep
Learning algorithm to quantify immune cell populations based on scRNA-Seq
data. Frontiers in Genetics 10, 978. doi: <a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simBulkProfiles">simBulkProfiles</a></code>
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # reproducibility
# simulated data
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10, 
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10, 
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(2)),
  from = c(1, 30),
  to = c(15, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 10,
  verbose = TRUE
)

</code></pre>

<hr>
<h2 id='getProbMatrix'>Getter function for the cell composition matrix</h2><span id='topic+getProbMatrix'></span>

<h3>Description</h3>

<p>Getter function for the cell composition matrix. This function allows to
access to the cell composition matrix of simulated training or test
pseudo-bulk RNA-Seq data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProbMatrix(object, type.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getProbMatrix_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>prob.cell.types</code> slot.</p>
</td></tr>
<tr><td><code id="getProbMatrix_+3A_type.data">type.data</code></td>
<td>
<p>Subset of data to e shown: <code>train</code> or <code>test</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object with the desired cell proportion matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateBulkCellMatrix">generateBulkCellMatrix</a></code>
</p>

<hr>
<h2 id='installTFpython'>Install Python dependencies for digitalDLSorteR</h2><span id='topic+installTFpython'></span>

<h3>Description</h3>

<p>This is a helper function to install Python dependencies needed: a Python
interpreter with TensorFlow Python library and its dependencies. It is
performed using the <span class="pkg">reticulate</span> package and the installer of the
<span class="pkg">tensorflow</span> R package. The available options are virtual or conda
environments. The new environment is called digitaldlsorter-env. In any case,
this installation can be manually done as it is explained in
<a href="https://diegommcc.github.io/digitalDLSorteR/articles/kerasIssues.html">https://diegommcc.github.io/digitalDLSorteR/articles/kerasIssues.html</a>,
but we recommend using this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installTFpython(conda = "auto", install.conda = FALSE, miniconda.path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="installTFpython_+3A_conda">conda</code></td>
<td>
<p>Path to a conda executable. Use <code>"auto"</code> (by default)
allows <span class="pkg">reticulate</span> to automatically find an appropriate conda binary.</p>
</td></tr>
<tr><td><code id="installTFpython_+3A_install.conda">install.conda</code></td>
<td>
<p>Boolean indicating if install miniconda automatically
using <span class="pkg">reticulate</span>. If <code>TRUE</code>, <code>conda</code> argument is ignored.
<code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="installTFpython_+3A_miniconda.path">miniconda.path</code></td>
<td>
<p>If <code>install.conda</code> is <code>TRUE</code>, you can set the
path where miniconda will be installed. If <code>NULL</code>, conda will find
automatically the proper place.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to make easier the installation of the requirements
needed to use <span class="pkg">digitalDLSorteR</span>. It will automatically install Miniconda
(if wanted, see Parameters) and create an environment called
'digitaldlsorter-env'. If you want to use other python/conda environment, see
<code>?tensorflow::use_condaenv</code> and/or the vignettes.
</p>


<h3>Value</h3>

<p>No return value, called for side effects: installation of conda
environment with a Python interpreter and Tensorflow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
notesInstallation &lt;- installTFpython(
  method = "auto", conda = "auto", install.conda = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='listToDDLS'>Transform DigitalDLSorter-like list into an actual DigitalDLSorterDNN object</h2><span id='topic+listToDDLS'></span>

<h3>Description</h3>

<p>Transform DigitalDLSorter-like list into an actual <code>DigitalDLSorter</code>
object. This function allows to generate the examples and the vignettes of
<span class="pkg">digitalDLSorteR</span> package as these are the data used. These data are
stored in the digitalDLSorteRdata package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listToDDLS(listTo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listToDDLS_+3A_listto">listTo</code></td>
<td>
<p>A list in which each element must correspond to each slot of an
<code>DigitalDLSorter</code> object. The names must be the same as the slot
names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DigitalDLSorter</code> object the data provided in the original list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+listToDDLSDNN">listToDDLSDNN</a></code>
</p>

<hr>
<h2 id='listToDDLSDNN'>Transform DigitalDLSorterDNN-like list into an actual DigitalDLSorterDNN
object</h2><span id='topic+listToDDLSDNN'></span>

<h3>Description</h3>

<p>Transform DigitalDLSorterDNN-like list into an actual
<code>DigitalDLSorterDNN</code> object. This function allows to use pre-trained
models in the <span class="pkg">digitalDLSorteR</span> package. These models are stored in the
digitalDLSorteRmodels package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listToDDLSDNN(listTo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listToDDLSDNN_+3A_listto">listTo</code></td>
<td>
<p>A list in which each element must correspond to each slot of an
<code>DigitalDLSorterDNN</code> object. The names must be the same as the slot
names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DigitalDLSorterDNN</code> object with the data provided in the
original list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+listToDDLS">listToDDLS</a></code>
</p>

<hr>
<h2 id='loadDeconvData'>Load data to be deconvoluted into a DigitalDLSorter object</h2><span id='topic+loadDeconvData'></span><span id='topic+loadDeconvData+2CDigitalDLSorter+2Ccharacter-method'></span><span id='topic+loadDeconvData+2CDigitalDLSorter+2CSummarizedExperiment-method'></span>

<h3>Description</h3>

<p>Load data to be deconvoluted. Data can be provided from a file path of a
tabulated text file (tsv and tsv.gz formats are accepted) or a
<code>SummarizedExperiment</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadDeconvData(object, data, name.data = NULL)

## S4 method for signature 'DigitalDLSorter,character'
loadDeconvData(object, data, name.data = NULL)

## S4 method for signature 'DigitalDLSorter,SummarizedExperiment'
loadDeconvData(object, data, name.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadDeconvData_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>trained.model</code> slot.</p>
</td></tr>
<tr><td><code id="loadDeconvData_+3A_data">data</code></td>
<td>
<p>File path where the data is stored or a
<code>SummarizedExperiment</code> object.</p>
</td></tr>
<tr><td><code id="loadDeconvData_+3A_name.data">name.data</code></td>
<td>
<p>Name under which the data is stored in the
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object. When <code>data</code> is a file
path and <code>name.data</code> is not provided, the base name of file will be
used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with <code>deconv.data</code>
slot with the new bulk-RNA-Seq samples loaded.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code>
<code><a href="#topic+deconvDDLSObj">deconvDDLSObj</a></code>
</p>

<hr>
<h2 id='loadTrainedModelFromH5'>Load from an HDF5 file a trained Deep Neural Network model into a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+loadTrainedModelFromH5'></span>

<h3>Description</h3>

<p>Load from an HDF5 file a trained Deep Neural Network model into a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object. Note that HDF5 file must be a
valid trained model (<span class="pkg">keras</span> object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadTrainedModelFromH5(object, file.path, reset.slot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadTrainedModelFromH5_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>trained.model</code> slot.</p>
</td></tr>
<tr><td><code id="loadTrainedModelFromH5_+3A_file.path">file.path</code></td>
<td>
<p>Valid file path where the model are stored.</p>
</td></tr>
<tr><td><code id="loadTrainedModelFromH5_+3A_reset.slot">reset.slot</code></td>
<td>
<p>Deletes <code>trained.slot</code> if it already exists. A new
<code><a href="#topic+DigitalDLSorterDNN">DigitalDLSorterDNN</a></code> object will be formed, but will not
contain other slots (<code>FALSE</code> by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with <code>trained.model</code>
slot with the new keras DNN model incorporated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code>
<code><a href="#topic+deconvDDLSObj">deconvDDLSObj</a></code> <code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code>
</p>

<hr>
<h2 id='method'>Get and set <code>method</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object</h2><span id='topic+method'></span><span id='topic+method+2CProbMatrixCellTypes-method'></span><span id='topic+method+3C-'></span><span id='topic+method+3C-+2CProbMatrixCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>method</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method(object)

method(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="method_+3A_value">value</code></td>
<td>
<p>Vector with names of cells present in the object.</p>
</td></tr>
</table>

<hr>
<h2 id='model'>Get and set <code>model</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object</h2><span id='topic+model'></span><span id='topic+model+2CDigitalDLSorterDNN-method'></span><span id='topic+model+3C-'></span><span id='topic+model+3C-+2CDigitalDLSorterDNN-method'></span>

<h3>Description</h3>

<p>Get and set <code>model</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model(object)

model(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
<tr><td><code id="model_+3A_value">value</code></td>
<td>
<p><code>keras.engine.sequential.Sequential</code> object with a
trained Deep Neural Network model.</p>
</td></tr>
</table>

<hr>
<h2 id='plots'>Get and set <code>plots</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object</h2><span id='topic+plots'></span><span id='topic+plots+2CProbMatrixCellTypes-method'></span><span id='topic+plots+3C-'></span><span id='topic+plots+3C-+2CProbMatrixCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>plots</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plots(object)

plots(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plots_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="plots_+3A_value">value</code></td>
<td>
<p>List of lists with plots showing the distribution of the cell
proportions generated by each method during the process.</p>
</td></tr>
</table>

<hr>
<h2 id='plotTrainingHistory'>Plot training history of a trained DigitalDLSorter Deep Neural Network model</h2><span id='topic+plotTrainingHistory'></span>

<h3>Description</h3>

<p>Plot training history of a trained DigitalDLSorter Deep Neural Network model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrainingHistory(
  object,
  title = "History of metrics during training",
  metrics = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrainingHistory_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>trained.model</code> slot.</p>
</td></tr>
<tr><td><code id="plotTrainingHistory_+3A_title">title</code></td>
<td>
<p>Title of plot.</p>
</td></tr>
<tr><td><code id="plotTrainingHistory_+3A_metrics">metrics</code></td>
<td>
<p>Metrics to be plotted. If <code>NULL</code> (by default), all
metrics available in the <code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object
will be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the progression of the selected metrics during
training.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code>
<code><a href="#topic+deconvDDLSObj">deconvDDLSObj</a></code>
</p>

<hr>
<h2 id='preparingToSave'>Prepare <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object to be saved as an RDA
file</h2><span id='topic+preparingToSave'></span>

<h3>Description</h3>

<p>Prepare a <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object that has a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object with a trained DNN model.
<code>keras</code> models cannot be stored natively as R objects (e.g. RData or RDS
files). By saving the structure as a JSON-like character object and the
weights as a list, it is possible to retrieve the model and make predictions.
<strong>Note:</strong> with this option, the state of optimizer is not saved, only
the architecture and weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preparingToSave(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preparingToSave_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with the
<code>trained.data</code> slot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to save the entire model as an HDF5 file with the
<code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code> function and to load it into a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with the
<code><a href="#topic+loadTrainedModelFromH5">loadTrainedModelFromH5</a></code> function.
</p>
<p>It is also possible to save a <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object as
an RDS file with the <code>saveRDS</code> function without any preparation.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> or
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object with its trained keras model
transformed from a <code>keras.engine.sequential.Sequential</code> class into a
<code>list</code> with the architecture as a JSON-like character object and the
weights as a list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveRDS">saveRDS</a></code> <code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code>
</p>

<hr>
<h2 id='prob.cell.types'>Get and set <code>prob.cell.types</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+prob.cell.types'></span><span id='topic+prob.cell.types+2CDigitalDLSorter-method'></span><span id='topic+prob.cell.types+3C-'></span><span id='topic+prob.cell.types+3C-+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Get and set <code>prob.cell.types</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob.cell.types(object, type.data = "both")

prob.cell.types(object, type.data = "both") &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob.cell.types_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object.</p>
</td></tr>
<tr><td><code id="prob.cell.types_+3A_type.data">type.data</code></td>
<td>
<p>Element of the list. Can be <code>'train'</code>, <code>'test'</code> or
<code>'both'</code> (the last by default).</p>
</td></tr>
<tr><td><code id="prob.cell.types_+3A_value">value</code></td>
<td>
<p>List with two elements, train and test, each one with a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='prob.matrix'>Get and set <code>prob.matrix</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object</h2><span id='topic+prob.matrix'></span><span id='topic+prob.matrix+2CProbMatrixCellTypes-method'></span><span id='topic+prob.matrix+3C-'></span><span id='topic+prob.matrix+3C-+2CProbMatrixCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>prob.matrix</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob.matrix(object)

prob.matrix(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob.matrix_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="prob.matrix_+3A_value">value</code></td>
<td>
<p>Matrix with cell types as columns and samples as
rows.</p>
</td></tr>
</table>

<hr>
<h2 id='ProbMatrixCellTypes-class'>The Class ProbMatrixCellTypes</h2><span id='topic+ProbMatrixCellTypes-class'></span><span id='topic+ProbMatrixCellTypes'></span>

<h3>Description</h3>

<p>The ProbMatrixCellTypes class is a data storage class that contains
information related to the cell composition matrices used for the simulation
of pseudo-bulk RNA-Seq samples. The matrix is stored in the
<code>prob.matrix</code> slot. The other of slots contain additional information
generated during the process and required in subsequent steps.
</p>


<h3>Details</h3>

<p>As described in Torroja and Sanchez-Cabo, 2019, the proportions are
constructed using six different methods in order to avoid biases due to the
composition of the simulated bulk samples. In <code>plots</code> slot, plots are
stored that visually represent the distribution of these probabilities in
order to provide a way to monitor the different sets of samples generated.
These plots can be shown using the <code><a href="#topic+showProbPlot">showProbPlot</a></code> function (see
<code>?<a href="#topic+showProbPlot">showProbPlot</a></code> for more details).
</p>


<h3>Slots</h3>


<dl>
<dt><code>prob.matrix</code></dt><dd><p>Matrix of cell proportions generated for the simulation of
bulk samples. Rows correspond to the bulk samples to be generated
(<code class="reqn">i</code>), columns are the cell types present in the provided single-cell
data (<code class="reqn">j</code>) and each entry is the proportion of <code class="reqn">j</code> cell type in
<code class="reqn">i</code> sample.</p>
</dd>
<dt><code>cell.names</code></dt><dd><p>Matrix containing the names of the cells that will make up
each simulated pseudo-bulk sample.</p>
</dd>
<dt><code>set.list</code></dt><dd><p>List of cells sorted according to the cell type they
belong to.</p>
</dd>
<dt><code>set</code></dt><dd><p>Vector containing the cell names present in the object.</p>
</dd>
<dt><code>plots</code></dt><dd><p>List of lists with plots showing the distribution of the cell
proportions generated by each method during the process. In each list,
<code>boxplot</code>, <code>violinplot</code>, <code>linesplot</code> or <code>ncelltypes</code>
can be found. Please see <code><a href="#topic+showProbPlot">showProbPlot</a></code> for more details.</p>
</dd>
<dt><code>type.data</code></dt><dd><p>Character with the type of data contained: training or test.</p>
</dd>
</dl>


<h3>References</h3>

<p>Torroja, C. and Sánchez-Cabo, F. (2019). digitalDLSorter: A Deep
Learning algorithm to quantify immune cell populations based on scRNA-Seq
data. Frontiers in Genetics 10, 978. doi: <a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a>
</p>

<hr>
<h2 id='project'>Get and set <code>project</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+project'></span><span id='topic+project+2CDigitalDLSorter-method'></span><span id='topic+project+3C-'></span><span id='topic+project+3C-+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Get and set <code>project</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(object)

project(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object.</p>
</td></tr>
<tr><td><code id="project_+3A_value">value</code></td>
<td>
<p>Character indicating the name of the project.</p>
</td></tr>
</table>

<hr>
<h2 id='saveRDS'>Save <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> objects as RDS files</h2><span id='topic+saveRDS'></span><span id='topic+saveRDS+2CsaveRDS-method'></span><span id='topic+saveRDS+2CDigitalDLSorterDNN-method'></span><span id='topic+saveRDS+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Save <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> and
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> objects as RDS files. <span class="pkg">keras</span>
models cannot be stored natively as R objects (e.g. RData or RDS files). By
saving the structure as a JSON-like character object and the weights as a
list, it is possible to retrieve the model and make predictions. If the
<code>trained.model</code> slot is empty, the function will behave as usual.
<strong>Note:</strong> with this option, the state of optimizer is not saved, only
the architecture and weights. It is possible to save the entire model as an
HDF5 file with the <code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code> function and to load it
into a <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with the
<code><a href="#topic+loadTrainedModelFromH5">loadTrainedModelFromH5</a></code> function. See documentation for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveRDS(
  object,
  file,
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S4 method for signature 'DigitalDLSorterDNN'
saveRDS(
  object,
  file,
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S4 method for signature 'DigitalDLSorter'
saveRDS(
  object,
  file,
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveRDS_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> or
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object to be saved</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_file">file</code></td>
<td>
<p>File path where the object will be saved</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_ascii">ascii</code></td>
<td>
<p>a logical.  If <code>TRUE</code> or <code>NA</code>, an ASCII
representation is written; otherwise (default), a binary one is used.
See the comments in the help for <code><a href="base.html#topic+save">save</a></code>.</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_version">version</code></td>
<td>
<p>the workspace format version to use.  <code>NULL</code>
specifies the current default version (3). The only other supported
value is 2, the default from <span class="rlang"><b>R</b></span> 1.4.0 to <span class="rlang"><b>R</b></span> 3.5.0.</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_compress">compress</code></td>
<td>
<p>a logical specifying whether saving to a named file is
to use <code>"gzip"</code> compression, or one of <code>"gzip"</code>,
<code>"bzip2"</code> or <code>"xz"</code> to indicate the type of compression to
be used.  Ignored if <code>file</code> is a connection.</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_refhook">refhook</code></td>
<td>
<p>a hook function for handling reference objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, saves a <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
as an RDS file on disk.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code>
<code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code>
</p>

<hr>
<h2 id='saveTrainedModelAsH5'>Save a trained <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> Deep Neural Network model
to disk as an HDF5 file</h2><span id='topic+saveTrainedModelAsH5'></span>

<h3>Description</h3>

<p>Save a trained <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> Deep Neural Network model
to disk as an HDF5 file. Note that this function does not save the
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object, but the trained keras model.
This is the alternative to the <code><a href="#topic+saveRDS">saveRDS</a></code> and
<code><a href="#topic+preparingToSave">preparingToSave</a></code> functions if you want to keep the state of the
optimizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveTrainedModelAsH5(object, file.path, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveTrainedModelAsH5_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>trained.model</code> slot.</p>
</td></tr>
<tr><td><code id="saveTrainedModelAsH5_+3A_file.path">file.path</code></td>
<td>
<p>Valid file path where to save the model to.</p>
</td></tr>
<tr><td><code id="saveTrainedModelAsH5_+3A_overwrite">overwrite</code></td>
<td>
<p>Overwrite file if it already exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, saves a keras DNN trained model as HDF5 file on
disk.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code>
<code><a href="#topic+loadTrainedModelFromH5">loadTrainedModelFromH5</a></code>
</p>

<hr>
<h2 id='set'>Get and set <code>set</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object</h2><span id='topic+set'></span><span id='topic+set+2CProbMatrixCellTypes-method'></span><span id='topic+set+3C-'></span><span id='topic+set+3C-+2CProbMatrixCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>set</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set(object)

set(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="set_+3A_value">value</code></td>
<td>
<p>Vector with names of cells present in the object.</p>
</td></tr>
</table>

<hr>
<h2 id='set.list'>Get and set <code>set.list</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object</h2><span id='topic+set.list'></span><span id='topic+set.list+2CProbMatrixCellTypes-method'></span><span id='topic+set.list+3C-'></span><span id='topic+set.list+3C-+2CProbMatrixCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>set.list</code> slot in a
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.list(object)

set.list(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.list_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="set.list_+3A_value">value</code></td>
<td>
<p>List of cells sorted according to the cell type to which they
belong.</p>
</td></tr>
</table>

<hr>
<h2 id='showProbPlot'>Show distribution plots of the cell proportions generated by
<code><a href="#topic+generateBulkCellMatrix">generateBulkCellMatrix</a></code></h2><span id='topic+showProbPlot'></span>

<h3>Description</h3>

<p>Show distribution plots of the cell proportions generated by
<code><a href="#topic+generateBulkCellMatrix">generateBulkCellMatrix</a></code>. These frequencies will determine the
proportion of different cell types used during the simulation of pseudo-bulk
RNA-Seq samples. There are 6 subsets of proportions generated by different
approaches that can be visualized in three ways: box plots, violin plots and
lines plots. You can also plot the probabilities based on the number of
different cell types present in the samples by setting <code>type.plot =
'nCellTypes'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showProbPlot(object, type.data, set, type.plot = "boxplot")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showProbPlot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>prob.cell.types</code> slot with <code>plot</code> slot.</p>
</td></tr>
<tr><td><code id="showProbPlot_+3A_type.data">type.data</code></td>
<td>
<p>Subset of data to show: <code>train</code> or <code>test</code>.</p>
</td></tr>
<tr><td><code id="showProbPlot_+3A_set">set</code></td>
<td>
<p>Integer determining which of the 6 different subsets to display.</p>
</td></tr>
<tr><td><code id="showProbPlot_+3A_type.plot">type.plot</code></td>
<td>
<p>Character determining which type of visualization to
display. It can be <code>'boxplot'</code>, <code>'violinplot'</code>, <code>'linesplot'</code> or
<code>'ncelltypes'</code>. See Description for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plots are only for diagnostic purposes. This is the reason because they
are generated without any parameter introduced by the user.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateBulkCellMatrix">generateBulkCellMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulating data
set.seed(123) # reproducibility
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(100, lambda = 5), nrow = 40, ncol = 30, 
      dimnames = list(paste0("Gene", seq(40)), paste0("RHC", seq(30)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(30)),
    Cell_Type = sample(x = paste0("CellType", seq(4)), size = 30, 
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(40))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrix &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(4)),
  from = c(1, 1, 1, 30),
  to = c(15, 15, 50, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrix,
  num.bulk.samples = 60
)
lapply(
  X = 1:6, FUN = function(x) {
      showProbPlot(
        DDLS,
        type.data = "train",
        set = x,
        type.plot = "boxplot"
      )
    }
  )
  
</code></pre>

<hr>
<h2 id='simBulkProfiles'>Simulate training and test pseudo-bulk RNA-Seq profiles</h2><span id='topic+simBulkProfiles'></span>

<h3>Description</h3>

<p>Simulate training and test pseudo-bulk RNA-Seq profiles using the cell
composition matrices generated by the <code><a href="#topic+generateBulkCellMatrix">generateBulkCellMatrix</a></code>
function. The samples are generated under the assumption that the expression
level of the <code class="reqn">i</code> gene in the <code class="reqn">j</code> bulk sample is given by the sum of
the expression levels of the cell types <code class="reqn">X_{ijk}</code> that make them up
weighted by the proportions of these <code class="reqn">k</code> cell types in each sample. In
practice, as described in Torroja and Sanchez-Cabo, 2019, these profiles are
generated by summing a number of cells of different cell types determined by
proportions from a matrix of known cell composition. The number of simulated
pseudo-bulk RNA-Seq samples and the number of cells composing each sample are
determined by <code><a href="#topic+generateBulkCellMatrix">generateBulkCellMatrix</a></code> (see Documentation)
<strong>Note:</strong> this step can be avoided by using the <code>on.the.fly</code>
argument in the <code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code> function. See
Documentation for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simBulkProfiles(
  object,
  type.data = "both",
  pseudobulk.function = "AddRawCount",
  file.backend = NULL,
  compression.level = NULL,
  block.processing = FALSE,
  block.size = 1000,
  chunk.dims = NULL,
  threads = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simBulkProfiles_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>single.cell.real</code>/<code>single.cell.simul</code> and <code>prob.cell.types</code>
slots.</p>
</td></tr>
<tr><td><code id="simBulkProfiles_+3A_type.data">type.data</code></td>
<td>
<p>Type of data to generate between <code>'train'</code>,
<code>'test'</code> or <code>'both'</code> (the last by default).</p>
</td></tr>
<tr><td><code id="simBulkProfiles_+3A_pseudobulk.function">pseudobulk.function</code></td>
<td>
<p>Function used to build pseudo-bulk samples. It may
be: </p>
 <ul>
<li> <p><code>"MeanCPM"</code>: single-cell profiles (raw counts) are
transformed into CPMs and cross-cell averages are calculated. Then,
<code>log2(CPM + 1)</code> is calculated. </p>
</li>
<li> <p><code>"AddCPM"</code>: single-cell
profiles (raw counts) are transformed into CPMs and are added up across
cells. Then, log-CPMs are calculated. </p>
</li>
<li> <p><code>"AddRawCount"</code>:
single-cell profiles (raw counts) are added up across cells. Then, log-CPMs
are calculated.</p>
</li></ul>
</td></tr>
<tr><td><code id="simBulkProfiles_+3A_file.backend">file.backend</code></td>
<td>
<p>Valid file path to store the simulated single-cell
expression profiles as an HDF5 file (<code>NULL</code> by default). If provided,
the data is stored in HDF5 files used as back-end by using the
<span class="pkg">DelayedArray</span>, <span class="pkg">HDF5Array</span> and <span class="pkg">rhdf5</span> packages instead of
loading all data into RAM memory. This is suitable for situations where you
have large amounts of data that cannot be loaded into memory. Note that
operations on this data will be performed in blocks (i.e subsets of
determined size) which may result in longer execution times.</p>
</td></tr>
<tr><td><code id="simBulkProfiles_+3A_compression.level">compression.level</code></td>
<td>
<p>The compression level used if <code>file.backend</code> is
provided. It is an integer value between 0 (no compression) and 9 (highest
and slowest compression). See
<code>?<a href="HDF5Array.html#topic+getHDF5DumpCompressionLevel">getHDF5DumpCompressionLevel</a></code> from the
<span class="pkg">HDF5Array</span> package for more information.</p>
</td></tr>
<tr><td><code id="simBulkProfiles_+3A_block.processing">block.processing</code></td>
<td>
<p>Boolean indicating whether the data should be
simulated in blocks (only if <code>file.backend</code> is used, <code>FALSE</code> by
default). This functionality is suitable for cases where is not possible to
load all data into memory and it leads to larger execution times.</p>
</td></tr>
<tr><td><code id="simBulkProfiles_+3A_block.size">block.size</code></td>
<td>
<p>Only if <code>block.processing = TRUE</code>. Number of
pseudo-bulk expression profiles that will be simulated in each iteration
during the process. Larger numbers result in higher memory usage but
shorter execution times. Set according to available computational resources
(1000 by default).</p>
</td></tr>
<tr><td><code id="simBulkProfiles_+3A_chunk.dims">chunk.dims</code></td>
<td>
<p>Specifies the dimensions that HDF5 chunk will have. If
<code>NULL</code>, the default value is a vector of two items: the number of
genes considered by <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object during the
simulation, and a single sample to reduce read times in the following
steps. A larger number of columns written in each chunk can lead to longer
read times.</p>
</td></tr>
<tr><td><code id="simBulkProfiles_+3A_threads">threads</code></td>
<td>
<p>Number of threads used during the simulation of pseudo-bulk
samples (1 by default). Set according to computational resources and avoid
it if <code>block.size</code> will be used.</p>
</td></tr>
<tr><td><code id="simBulkProfiles_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">digitalDLSorteR</span> allows the use of HDF5 files as back-end to store the
resulting data using the <span class="pkg">DelayedArray</span> and <span class="pkg">HDF5Array</span> packages.
This functionality allows to work without keeping the data loaded into RAM,
which could be of vital importance during some computationally heavy steps
such as neural network training on RAM-limited machines. You must provide a
valid file path in the <code>file.backend</code> argument to store the resulting
file with the '.h5' extension. The data will be accessible from R without
being loaded into memory. This option slightly slows down execution times, as
subsequent transformations of the data will be done in blocks rather than
using all the data. We recommend this option according to the computational
resources available and the number of pseudo-bulk samples to be generated.
</p>
<p>Note that if you use the <code>file.backend</code> argument with
<code>block.processing = FALSE</code>, all pseudo-bulk profiles will be simulated
in one step and, therefore, loaded into RAM. Then, the data will be written
to an HDF5 file. To avoid the RAM collapse, pseudo-bulk profiles can be
simulated and written to HDF5 files in blocks of <code>block.size</code> size by
setting <code>block.processing = TRUE</code>.
</p>
<p>It is possible to avoid this step by using the <code>on.the.fly</code> argument in
the <code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code> function. In this way, data is
generated 'on the fly' during the neural network training. For more details,
see <code>?<a href="#topic+trainDDLSModel">trainDDLSModel</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with <code>bulk.simul</code>
slot containing a list with one or two entries (depending on selected
<code>type.data</code> argument): <code>'train'</code> and <code>'test'</code>. Each entry
contains a <code><a href="SummarizedExperiment.html#topic+SummarizedExperiment">SummarizedExperiment</a></code> object
with simulated bulk samples in the <code>assay</code> slot, sample names in the
<code>colData</code> slot and feature names in the <code>rowData</code> slot.
</p>


<h3>References</h3>

<p>Fischer B, Smith M and Pau, G (2020). rhdf5: R Interface to HDF5.
R package version 2.34.0.
</p>
<p>Pagès H, Hickey P and Lun A (2020). DelayedArray: A unified framework for
working transparently with on-disk and in-memory array-like datasets. R
package version 0.16.0.
</p>
<p>Pagès H (2020). HDF5Array: HDF5 backend for DelayedArray objects. R package
version 1.18.0.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateBulkCellMatrix">generateBulkCellMatrix</a></code>
<code><a href="#topic+ProbMatrixCellTypes-class">ProbMatrixCellTypes</a></code>
<code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # reproducibility
# simulated data
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(2)),
  from = c(1, 30),
  to = c(15, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 10,
  verbose = TRUE
)
DDLS &lt;- simBulkProfiles(DDLS, verbose = TRUE)

</code></pre>

<hr>
<h2 id='simSCProfiles'>Simulate new single-cell RNA-Seq expression profiles using the ZINB-WaVE
model parameters</h2><span id='topic+simSCProfiles'></span>

<h3>Description</h3>

<p>Simulate single-cell expression profiles by randomly sampling from a negative
binomial distribution and inserting dropouts by sampling from a binomial
distribution using the ZINB-WaVE parameters estimated by the
<code><a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simSCProfiles(
  object,
  cell.ID.column,
  cell.type.column,
  n.cells,
  suffix.names = "_Simul",
  cell.types = NULL,
  file.backend = NULL,
  name.dataset.backend = NULL,
  compression.level = NULL,
  block.processing = FALSE,
  block.size = 1000,
  chunk.dims = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simSCProfiles_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>single.cell.real</code> and <code>zinb.params</code> slots.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_cell.id.column">cell.ID.column</code></td>
<td>
<p>Name or column number corresponding to the cell names
of expression matrix in cells metadata.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_cell.type.column">cell.type.column</code></td>
<td>
<p>Name or column number corresponding to the cell type
of each cell in cells metadata.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_n.cells">n.cells</code></td>
<td>
<p>Number of simulated cells generated per cell type (i.e. if you
have 10 different cell types in your dataset, if <code>n.cells = 100</code>, then
1000 cell profiles will be simulated).</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_suffix.names">suffix.names</code></td>
<td>
<p>Suffix used on simulated cells. This suffix must be
unique in the simulated cells, so make sure that this suffix does not
appear in the real cell names.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_cell.types">cell.types</code></td>
<td>
<p>Vector indicating the cell types to simulate. If
<code>NULL</code> (by default), <code>n.cells</code> single-cell profiles for all cell
types will be simulated.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_file.backend">file.backend</code></td>
<td>
<p>Valid file path to store the simulated single-cell
expression profiles as an HDF5 file (<code>NULL</code> by default). If provided,
the data is stored in HDF5 files used as back-end by using the
<span class="pkg">DelayedArray</span>, <span class="pkg">HDF5Array</span> and <span class="pkg">rhdf5</span> packages instead of
loading all data into RAM memory. This is suitable for situations where you
have large amounts of data that cannot be loaded into memory. Note that
operations on this data will be performed in blocks (i.e subsets of
determined size) which may result in longer execution times.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_name.dataset.backend">name.dataset.backend</code></td>
<td>
<p>Name of the dataset in HDF5 file to be used. Note
that it cannot exist. If <code>NULL</code> (by default), a random dataset name
will be used.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_compression.level">compression.level</code></td>
<td>
<p>The compression level used if <code>file.backend</code> is
provided. It is an integer value between 0 (no compression) and 9 (highest
and slowest compression). See
<code>?<a href="HDF5Array.html#topic+getHDF5DumpCompressionLevel">getHDF5DumpCompressionLevel</a></code> from the
<span class="pkg">HDF5Array</span> package for more information.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_block.processing">block.processing</code></td>
<td>
<p>Boolean indicating whether the data should be
simulated in blocks (only if <code>file.backend</code> is used, <code>FALSE</code> by
default). This functionality is suitable for cases where is not possible to
load all data into memory and it leads to larger execution times.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_block.size">block.size</code></td>
<td>
<p>Only if <code>block.processing = TRUE</code>. Number of
single-cell expression profiles that will be simulated in each iteration
during the process. Larger numbers result in higher memory usage but
shorter execution times. Set according to available computational resources
(1000 by default). Note that it cannot be greater than the total number of
simulated cells.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_chunk.dims">chunk.dims</code></td>
<td>
<p>Specifies the dimensions that HDF5 chunk will have. If
<code>NULL</code>, the default value is a vector of two items: the number of
genes considered by the ZINB-WaVE model during the simulation and a single
sample in order to reduce read times in the following steps. A larger
number of columns written in each chunk can lead to longer read times in
subsequent steps. Note that it cannot be greater than the dimensions of the
simulated matrix.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before this step, see <code>?<a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code>. As described in
Torroja and Sanchez-Cabo, 2019, this function simulates a given number of
transcriptional profiles for each cell type provided by randomly sampling
from a negative binomial distribution with <code class="reqn">\mu</code> and <code class="reqn">\theta</code>
estimated parameters and inserting dropouts by sampling from a binomial
distribution with probability pi. All parameters are estimated from
single-cell real data using the <code><a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code>
function. It uses the ZINB-WaVE model (Risso et al., 2018). For more details
about the model, see <code>?<a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code> and Risso et al.,
2018.
</p>
<p>The <code>file.backend</code> argument allows to create a HDF5 file with simulated
single-cell profiles to be used as back-end to work with data stored on disk
instead of loaded into RAM. If the <code>file.backend</code> argument is used with
<code>block.processing = FALSE</code>, all the single-cell profiles will be
simulated in one step and, therefore, loaded into in RAM memory. Then, data
will be written in HDF5 file. To avoid to collapse RAM memory if too many
single-cell profiles are simulated, single-cell profiles can be simulated and
written to HDF5 files in blocks of <code>block.size</code> size by setting
<code>block.processing = TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>single.cell.simul</code> slot containing a
<code>SingleCellExperiment</code> object with the simulated
single-cell expression profiles.
</p>


<h3>References</h3>

<p>Risso, D., Perraudeau, F., Gribkova, S. et al. (2018). A general
and flexible method for signal extraction from single-cell RNA-seq data.
Nat Commun 9, 284. doi: <a href="https://doi.org/10.1038/s41467-017-02554-5">doi:10.1038/s41467-017-02554-5</a>.
</p>
<p>Torroja, C. and Sánchez-Cabo, F. (2019). digitalDLSorter: A Deep Learning
algorithm to quantify immune cell populations based on scRNA-Seq data.
Frontiers in Genetics 10, 978. doi: <a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # reproducibility
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10, 
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10, 
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
DDLS &lt;- estimateZinbwaveParams(
  object = DDLS,
  cell.type.column = "Cell_Type",
  cell.ID.column = "Cell_ID",
  gene.ID.column = "Gene_ID", 
  subset.cells = 4,
  verbose = FALSE
)
DDLS &lt;- simSCProfiles(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  n.cells = 2,
  verbose = TRUE
)

</code></pre>

<hr>
<h2 id='single.cell.real'>Get and set <code>single.cell.real</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+single.cell.real'></span><span id='topic+single.cell.real+2CDigitalDLSorter-method'></span><span id='topic+single.cell.real+3C-'></span><span id='topic+single.cell.real+3C-+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Get and set <code>single.cell.real</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single.cell.real(object)

single.cell.real(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single.cell.real_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object.</p>
</td></tr>
<tr><td><code id="single.cell.real_+3A_value">value</code></td>
<td>
<p><code>SingleCellExperiment</code> object with real
single-cell profiles.</p>
</td></tr>
</table>

<hr>
<h2 id='single.cell.simul'>Get and set <code>single.cell.simul</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+single.cell.simul'></span><span id='topic+single.cell.simul+2CDigitalDLSorter-method'></span><span id='topic+single.cell.simul+3C-'></span><span id='topic+single.cell.simul+3C-+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Get and set <code>single.cell.simul</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single.cell.simul(object)

single.cell.simul(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single.cell.simul_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object.</p>
</td></tr>
<tr><td><code id="single.cell.simul_+3A_value">value</code></td>
<td>
<p><code>SingleCellExperiment</code> object with simulated
single-cell profiles.</p>
</td></tr>
</table>

<hr>
<h2 id='test.deconv.metrics'>Get and set <code>test.deconv.metrics</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object</h2><span id='topic+test.deconv.metrics'></span><span id='topic+test.deconv.metrics+2CDigitalDLSorterDNN-method'></span><span id='topic+test.deconv.metrics+3C-'></span><span id='topic+test.deconv.metrics+3C-+2CDigitalDLSorterDNN-method'></span>

<h3>Description</h3>

<p>Get and set <code>test.deconv.metrics</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.deconv.metrics(object, metrics = "All")

test.deconv.metrics(object, metrics = "All") &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.deconv.metrics_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
<tr><td><code id="test.deconv.metrics_+3A_metrics">metrics</code></td>
<td>
<p>Metrics to show (<code>'All'</code> by default)</p>
</td></tr>
<tr><td><code id="test.deconv.metrics_+3A_value">value</code></td>
<td>
<p>List with evaluation metrics used to assess the
performance of the model on each sample of test data.</p>
</td></tr>
</table>

<hr>
<h2 id='test.metrics'>Get and set <code>test.metrics</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object</h2><span id='topic+test.metrics'></span><span id='topic+test.metrics+2CDigitalDLSorterDNN-method'></span><span id='topic+test.metrics+3C-'></span><span id='topic+test.metrics+3C-+2CDigitalDLSorterDNN-method'></span>

<h3>Description</h3>

<p>Get and set <code>test.metrics</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.metrics(object)

test.metrics(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.metrics_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
<tr><td><code id="test.metrics_+3A_value">value</code></td>
<td>
<p>List object with the resulting metrics after prediction
on test data with the Deep Neural Network model.</p>
</td></tr>
</table>

<hr>
<h2 id='test.pred'>Get and set <code>test.pred</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object</h2><span id='topic+test.pred'></span><span id='topic+test.pred+2CDigitalDLSorterDNN-method'></span><span id='topic+test.pred+3C-'></span><span id='topic+test.pred+3C-+2CDigitalDLSorterDNN-method'></span>

<h3>Description</h3>

<p>Get and set <code>test.pred</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.pred(object)

test.pred(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.pred_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
<tr><td><code id="test.pred_+3A_value">value</code></td>
<td>
<p>Matrix object with the prediction results on test data.</p>
</td></tr>
</table>

<hr>
<h2 id='trainDDLSModel'>Train Deep Neural Network model</h2><span id='topic+trainDDLSModel'></span>

<h3>Description</h3>

<p>Train a Deep Neural Network model using the training data from
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object. In addition, the trained model
is evaluated with test data and prediction results are computed to determine
its performance (see <code>?<a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code>). Training and
evaluation can be performed using simulated profiles stored in the
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object or 'on the fly' by simulating the
pseudo-bulk profiles at the same time as the training/evaluation is performed
(see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trainDDLSModel(
  object,
  type.data.train = "bulk",
  type.data.test = "bulk",
  batch.size = 64,
  num.epochs = 60,
  num.hidden.layers = 2,
  num.units = c(200, 200),
  activation.fun = "relu",
  dropout.rate = 0.25,
  loss = "kullback_leibler_divergence",
  metrics = c("accuracy", "mean_absolute_error", "categorical_accuracy"),
  normalize = TRUE,
  scaling = "standardize",
  norm.batch.layers = TRUE,
  custom.model = NULL,
  shuffle = TRUE,
  use.generator = FALSE,
  on.the.fly = FALSE,
  pseudobulk.function = "AddRawCount",
  threads = 1,
  view.metrics.plot = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trainDDLSModel_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>single.cell.real</code>/<code>single.cell.simul</code>, <code>prob.cell.matrix</code>
and <code>bulk.simul</code> slots.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_type.data.train">type.data.train</code></td>
<td>
<p>Type of profiles to be used for training. It can be
<code>'both'</code>, <code>'single-cell'</code> or <code>'bulk'</code> (<code>'bulk'</code> by
default).</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_type.data.test">type.data.test</code></td>
<td>
<p>Type of profiles to be used for evaluation. It can be
<code>'both'</code>, <code>'single-cell'</code> or <code>'bulk'</code> (<code>'bulk'</code> by
default).</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_batch.size">batch.size</code></td>
<td>
<p>Number of samples per gradient update. If not specified,
<code>batch.size</code> will default to 64.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_num.epochs">num.epochs</code></td>
<td>
<p>Number of epochs to train the model (10 by default).</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_num.hidden.layers">num.hidden.layers</code></td>
<td>
<p>Number of hidden layers of the neural network (2 by
default). This number must be equal to the length of <code>num.units</code>
argument.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_num.units">num.units</code></td>
<td>
<p>Vector indicating the number of neurons per hidden layer
(<code>c(200, 200)</code> by default). The length of this vector must be equal to
<code>num.hidden.layers</code> argument.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_activation.fun">activation.fun</code></td>
<td>
<p>Activation function to use (<code>'relu'</code> by default).
See the
<a href="https://tensorflow.rstudio.com/reference/keras/activation_relu.html">keras
documentation</a> to know available activation functions.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_dropout.rate">dropout.rate</code></td>
<td>
<p>Float between 0 and 1 indicating the fraction of the
input neurons to drop in layer dropouts (0.25 by default). By default,
<span class="pkg">digitalDLSorteR</span> implements 1 dropout layer per hidden layer.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_loss">loss</code></td>
<td>
<p>Character indicating loss function selected for model training
(<code>'kullback_leibler_divergence'</code> by default). See the
<a href="https://tensorflow.rstudio.com/reference/keras/loss-functions.html">keras
documentation</a> to know available loss functions.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_metrics">metrics</code></td>
<td>
<p>Vector of metrics used to assess model performance during
training and evaluation (<code>c("accuracy", "mean_absolute_error",
  "categorical_accuracy")</code> by default). See the
<a href="https://tensorflow.rstudio.com/reference/keras/metric_binary_accuracy.html">keras
documentation</a> to know available performance metrics.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize data using logCPM (<code>TRUE</code> by
default). This parameter is only considered when the method used to
simulate mixed transcriptional profiles (<code>simMixedProfiles</code>
function) was <code>"AddRawCount"</code>. Otherwise, data were already
normalized.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_scaling">scaling</code></td>
<td>
<p>How to scale data before training. It may be:
<code>"standardize"</code> (values are centered around the mean with a unit
standard deviation) or <code>"rescale"</code> (values are shifted and rescaled so
that they end up ranging between 0 and 1).</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_norm.batch.layers">norm.batch.layers</code></td>
<td>
<p>Whether to include batch normalization layers
between each hidden dense layer (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_custom.model">custom.model</code></td>
<td>
<p>It allows to use a custom neural network. It must be a
<code>keras.engine.sequential.Sequential</code> object in which the number of
input neurons is equal to the number of considered features/genes, and the
number of output neurons is equal to the number of cell types considered
(<code>NULL</code> by default). If provided, the arguments related to the neural
network architecture will be ignored.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_shuffle">shuffle</code></td>
<td>
<p>Boolean indicating whether data will be shuffled (<code>TRUE</code>
by default). Note that if <code>bulk.simul</code> is not <code>NULL</code>, the data
already has been shuffled and <code>shuffle</code> will be ignored.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_use.generator">use.generator</code></td>
<td>
<p>Boolean indicating whether to use generators during
training and test. Generators are automatically used when <code>on.the.fly
  = TRUE</code> or HDF5 files are used, but it can be activated by the user on
demand (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_on.the.fly">on.the.fly</code></td>
<td>
<p>Boolean indicating whether data will be generated 'on the
fly' during training (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_pseudobulk.function">pseudobulk.function</code></td>
<td>
<p>Function used to build pseudo-bulk samples. It may
be: </p>
 <ul>
<li> <p><code>"MeanCPM"</code>: single-cell profiles (raw counts) are
transformed into CPMs and cross-cell averages are calculated. Then,
<code>log2(CPM + 1)</code> is calculated. </p>
</li>
<li> <p><code>"AddCPM"</code>: single-cell
profiles (raw counts) are transformed into CPMs and are added up across
cells. Then, log-CPMs are calculated. </p>
</li>
<li> <p><code>"AddRawCount"</code>:
single-cell profiles (raw counts) are added up across cells. Then, log-CPMs
are calculated.</p>
</li></ul>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_threads">threads</code></td>
<td>
<p>Number of threads used during simulation of pseudo-bulk
samples if <code>on.the.fly = TRUE</code> (1 by default).</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_view.metrics.plot">view.metrics.plot</code></td>
<td>
<p>Boolean indicating whether to show plots of loss and
metrics progression during training (<code>TRUE</code> by default). <span class="pkg">keras</span>
for R allows to see the progression of the model during training if you are
working in RStudio.</p>
</td></tr>
<tr><td><code id="trainDDLSModel_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicating whether to display model progression during
training and model architecture information (<code>TRUE</code> by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Keras/Tensorflow environment</strong>
</p>
<p>All Deep Learning related steps in the <span class="pkg">digitalDLSorteR</span> package are
performed by using the <span class="pkg">keras</span> package, an API in R for <span class="pkg">keras</span> in
Python available on CRAN. We recommend using the <code>installTFpython</code>
function included in the package.
</p>
<p><strong>Simulation of bulk RNA-Seq profiles 'on the fly'</strong>
</p>
<p><code>trainDDLSModel</code> allows to avoid storing bulk RNA-Seq
profiles by using <code>on.the.fly</code> argument. This functionality aims to
avoid exexcution times and memory usage of the <code>simBulkProfiles</code>
function, as the simulated pseudo-bulk profiles are built in each batch
during training/evaluation.
</p>
<p><strong>Neural network architecture</strong>
</p>
<p>By default, <code><a href="#topic+trainDDLSModel">trainDDLSModel</a></code> implements the
architecture selected in Torroja and Sánchez-Cabo, 2019. However, as the
default architecture may not produce good results depending on the dataset,
it is possible to change its parameters by using the corresponding argument:
number of hidden layers, number of neurons for each hidden layer, dropout
rate, activation function and loss function. For more customized models, it
is possible to provide a pre-built model in the <code>custom.model</code> argument
(a <code>keras.engine.sequential.Sequential</code> object) where it is necessary
that the number of input neurons is equal to the number of considered
features/genes and the number of output neurons is equal to the number of
considered cell types.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object with
<code>trained.model</code> slot containing a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object. For more information about
the structure of this class, see <code>?<a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code>.
</p>


<h3>References</h3>

<p>Torroja, C. and Sánchez-Cabo, F. (2019). digitalDLSorter: A Deep
Learning algorithm to quantify immune cell populations based on scRNA-Seq
data. Frontiers in Genetics 10, 978. doi: <a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotTrainingHistory">plotTrainingHistory</a></code>
<code><a href="#topic+deconvDigitalDLSorter">deconvDigitalDLSorter</a></code> <code><a href="#topic+deconvDDLSObj">deconvDDLSObj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123) # reproducibility
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
DDLS &lt;- createDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE, 
  sc.log.FC = FALSE
)
probMatrixValid &lt;- data.frame(
  Cell_Type = paste0("CellType", seq(2)),
  from = c(1, 30),
  to = c(15, 70)
)
DDLS &lt;- generateBulkCellMatrix(
  object = DDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  prob.design = probMatrixValid,
  num.bulk.samples = 30,
  verbose = TRUE
)
# training of DDLS model
tensorflow::tf$compat$v1$disable_eager_execution()
DDLS &lt;- trainDDLSModel(
  object = DDLS,
  on.the.fly = TRUE,
  batch.size = 12,
  num.epochs = 5
)

## End(Not run)

</code></pre>

<hr>
<h2 id='trained.model'>Get and set <code>trained.model</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+trained.model'></span><span id='topic+trained.model+2CDigitalDLSorter-method'></span><span id='topic+trained.model+3C-'></span><span id='topic+trained.model+3C-+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Get and set <code>trained.model</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trained.model(object)

trained.model(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trained.model_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object.</p>
</td></tr>
<tr><td><code id="trained.model_+3A_value">value</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='training.history'>Get and set <code>training.history</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object</h2><span id='topic+training.history'></span><span id='topic+training.history+2CDigitalDLSorterDNN-method'></span><span id='topic+training.history+3C-'></span><span id='topic+training.history+3C-+2CDigitalDLSorterDNN-method'></span>

<h3>Description</h3>

<p>Get and set <code>training.history</code> slot in a
<code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>training.history(object)

training.history(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="training.history_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorterDNN-class">DigitalDLSorterDNN</a></code> object.</p>
</td></tr>
<tr><td><code id="training.history_+3A_value">value</code></td>
<td>
<p><code>keras_training_history</code> object with the training history
of the Deep Neural Network model</p>
</td></tr>
</table>

<hr>
<h2 id='zinb.params'>Get and set <code>zinb.params</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object</h2><span id='topic+zinb.params'></span><span id='topic+zinb.params+2CDigitalDLSorter-method'></span><span id='topic+zinb.params+3C-'></span><span id='topic+zinb.params+3C-+2CDigitalDLSorter-method'></span>

<h3>Description</h3>

<p>Get and set <code>zinb.params</code> slot in a
<code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zinb.params(object)

zinb.params(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zinb.params_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DigitalDLSorter-class">DigitalDLSorter</a></code> object.</p>
</td></tr>
<tr><td><code id="zinb.params_+3A_value">value</code></td>
<td>
<p><code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object with a valid
<code>ZinbModel</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='ZinbParametersModel-class'>The Class ZinbParametersModel</h2><span id='topic+ZinbParametersModel-class'></span><span id='topic+ZinbParametersModel'></span>

<h3>Description</h3>

<p>The ZinbParametersModel class is a wrapper class of the
<code>ZinbModel</code> class from zinbwave package.
</p>


<h3>Details</h3>

<p>This is a wrapper class of the <code>ZinbModel</code> class. It
consists of only one slot (<code>zinbwave.mode</code>) that contains the
<code>ZinbModel</code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>zinbwave.model</code></dt><dd><p>A valid <code>ZinbModel</code> object.</p>
</dd>
</dl>


<h3>References</h3>

<p>Risso, D., Perraudeau, F., Gribkova, S. et al. (2018). A general
and flexible method for signal extraction from single-cell RNA-seq data.
Nat Commun 9, 284. doi: <a href="https://doi.org/10.1038/s41467-017-02554-5">doi:10.1038/s41467-017-02554-5</a>.
</p>

<hr>
<h2 id='zinbwave.model'>Get and set <code>zinbwave.model</code> slot in a
<code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object</h2><span id='topic+zinbwave.model'></span><span id='topic+zinbwave.model+2CZinbParametersModel-method'></span><span id='topic+zinbwave.model+3C-'></span><span id='topic+zinbwave.model+3C-+2CZinbParametersModel-method'></span>

<h3>Description</h3>

<p>Get and set <code>zinbwave.model</code> slot in a
<code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zinbwave.model(object)

zinbwave.model(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zinbwave.model_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object.</p>
</td></tr>
<tr><td><code id="zinbwave.model_+3A_value">value</code></td>
<td>
<p><code>ZinbModel</code> object with the estimated
parameters.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
