<!DOCTYPE html><html><head><title>Help for package SANple</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SANple}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SANple-package'><p>SANple: Fitting Common and Shared Atoms Nested Models via MCMC</p></a></li>
<li><a href='#.relabell'><p>Relabel clusters</p></a></li>
<li><a href='#estimate_clusters'><p>Estimate observational and distributional clusters</p></a></li>
<li><a href='#plot.SANmcmc'><p>Plotting MCMC output</p></a></li>
<li><a href='#print.SANclusters'><p>Print cluster summary</p></a></li>
<li><a href='#print.SANmcmc'><p>Print MCMC output</p></a></li>
<li><a href='#sample_CAM'><p>Sample CAM</p></a></li>
<li><a href='#sample_fiSAN'><p>Sample fiSAN</p></a></li>
<li><a href='#sample_fiSAN_sparsemix'><p>Sample fiSAN with sparse mixtures</p></a></li>
<li><a href='#sample_fSAN'><p>Sample fSAN</p></a></li>
<li><a href='#sample_fSAN_sparsemix'><p>Sample fSAN with sparse mixtures</p></a></li>
<li><a href='#traceplot'><p>Traceplot: plot MCMC chains</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Shared Atoms Nested Models via Markov Chains Monte Carlo</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-09</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laura D'Angelo &lt;laura.dangelo@live.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/laura-dangelo/SANple">https://github.com/laura-dangelo/SANple</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/laura-dangelo/SANple/issues">https://github.com/laura-dangelo/SANple/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate Bayesian nested mixture models via Markov Chain Monte Carlo methods. Specifically, the package implements the common atoms model (Denti et al., 2023), its finite version (D'Angelo et al., 2023), and a hybrid finite-infinite model. 
             All models use Gaussian mixtures with a normal-inverse-gamma prior distribution on the parameters. Additional functions are provided to help analyzing the results of the fitting procedure.  
             References:  
             Denti, Camerlenghi, Guindani, Mira (2023) &lt;<a href="https://doi.org/10.1080%2F01621459.2021.1933499">doi:10.1080/01621459.2021.1933499</a>&gt;,   
             D’Angelo, Canale, Yu, Guindani (2023) &lt;<a href="https://doi.org/10.1111%2Fbiom.13626">doi:10.1111/biom.13626</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, salso</td>
</tr>
<tr>
<td>Depends:</td>
<td>scales, RColorBrewer</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-09 15:12:10 UTC; francescodenti</td>
</tr>
<tr>
<td>Author:</td>
<td>Laura D'Angelo <a href="https://orcid.org/0000-0001-5034-7414"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Francesco Denti <a href="https://orcid.org/0000-0003-2978-4702"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-10 17:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='SANple-package'>SANple: Fitting Common and Shared Atoms Nested Models via MCMC</h2><span id='topic+SANple'></span><span id='topic+SANple-package'></span>

<h3>Description</h3>

<p>Estimate Bayesian nested mixture models via Markov Chain Monte Carlo methods. Specifically, the package implements the common atoms model (Denti et al., 2023), its finite version (D'Angelo et al., 2023), and a hybrid finite-infinite model. All models use Gaussian mixtures with a normal-inverse-gamma prior distribution on the parameters. Additional functions are provided to help analyzing the results of the fitting procedure. References: Denti, Camerlenghi, Guindani, Mira (2023) <a href="https://doi.org/10.1080/01621459.2021.1933499">doi:10.1080/01621459.2021.1933499</a>, D’Angelo, Canale, Yu, Guindani (2023) <a href="https://doi.org/10.1111/biom.13626">doi:10.1111/biom.13626</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Laura D'Angelo <a href="mailto:laura.dangelo@live.com">laura.dangelo@live.com</a> (<a href="https://orcid.org/0000-0001-5034-7414">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Francesco Denti <a href="mailto:francescodenti.personal@gmail.com">francescodenti.personal@gmail.com</a> (<a href="https://orcid.org/0000-0003-2978-4702">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/laura-dangelo/SANple">https://github.com/laura-dangelo/SANple</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/laura-dangelo/SANple/issues">https://github.com/laura-dangelo/SANple/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.relabell'>Relabel clusters</h2><span id='topic+.relabell'></span>

<h3>Description</h3>

<p>Relabel clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.relabell(ix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".relabell_+3A_ix">ix</code></td>
<td>
<p>vector of cluster labels</p>
</td></tr>
</table>

<hr>
<h2 id='estimate_clusters'>Estimate observational and distributional clusters</h2><span id='topic+estimate_clusters'></span>

<h3>Description</h3>

<p>Given the MCMC output, estimate the observational and distributional partitions using <code><a href="salso.html#topic+salso">salso::salso()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_clusters(object, burnin = NULL, ncores = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_clusters_+3A_object">object</code></td>
<td>
<p>object of class <code>SANmcmc</code> (the result of a call to <code><a href="#topic+sample_fiSAN">sample_fiSAN</a></code>, <code><a href="#topic+sample_fiSAN_sparsemix">sample_fiSAN_sparsemix</a></code>, 
<code><a href="#topic+sample_fSAN">sample_fSAN</a></code>, <code><a href="#topic+sample_fSAN_sparsemix">sample_fSAN_sparsemix</a></code>, or <code><a href="#topic+sample_CAM">sample_CAM</a></code>).</p>
</td></tr>
<tr><td><code id="estimate_clusters_+3A_burnin">burnin</code></td>
<td>
<p>the length of the burn-in to be discarded before estimating the clusters (default is 2/3 of the iterations).</p>
</td></tr>
<tr><td><code id="estimate_clusters_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to use, i.e., the number of simultaneous runs at any given time. A value of zero indicates to use all cores on the system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>SANclusters</code>. The object contains:
</p>
<p><code>est_oc</code> estimated partition at the observational level. It is an object of class <code>salso.estimate</code>.
</p>
<p><code>est_dc</code> estimated partition at the distributional level. It is an object of class <code>salso.estimate</code>.
</p>
<p><code>clus_means</code> cluster-specific sample means of the estimated partition.
</p>
<p><code>clus_vars</code> cluster-specific sample variances of the estimated partition.
</p>


<h3>See Also</h3>

<p><code><a href="salso.html#topic+salso">salso::salso()</a></code>, <code><a href="#topic+print.SANmcmc">print.SANmcmc</a></code>, <code><a href="#topic+plot.SANmcmc">plot.SANmcmc</a></code>, <code><a href="#topic+print.SANclusters">print.SANclusters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
y &lt;- c(rnorm(40,0,0.3), rnorm(20,5,0.3))
g &lt;- c(rep(1,30), rep(2, 30))
out &lt;- sample_fiSAN(nrep = 500, y = y, group = g, 
                    nclus_start = 2,
                    maxK = 20, maxL = 20,
                    beta = 1)
estimate_clusters(out)

</code></pre>

<hr>
<h2 id='plot.SANmcmc'>Plotting MCMC output</h2><span id='topic+plot.SANmcmc'></span>

<h3>Description</h3>

<p>Plot method for objects of class <code>SANmcmc</code>. 
The function displays two graphs, meant to analyze the estimated distributional and observational clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SANmcmc'
plot(
  x,
  type = c("boxplot", "ecdf", "scatter"),
  estimated_clusters = NULL,
  burnin = NULL,
  palette_brewed = FALSE,
  ncores = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SANmcmc_+3A_x">x</code></td>
<td>
<p>object of class <code>SANmcmc</code> (the result of a call to <code><a href="#topic+sample_fiSAN">sample_fiSAN</a></code>, <code><a href="#topic+sample_fiSAN_sparsemix">sample_fiSAN_sparsemix</a></code>, 
<code><a href="#topic+sample_fSAN">sample_fSAN</a></code>, <code><a href="#topic+sample_fSAN_sparsemix">sample_fSAN_sparsemix</a></code>, or <code><a href="#topic+sample_CAM">sample_CAM</a></code>).</p>
</td></tr>
<tr><td><code id="plot.SANmcmc_+3A_type">type</code></td>
<td>
<p>what type of plot should be drawn (only for the left-side plot). Possible types are &quot;boxplot&quot;, &quot;ecdf&quot;, and &quot;scatter&quot;.</p>
</td></tr>
<tr><td><code id="plot.SANmcmc_+3A_estimated_clusters">estimated_clusters</code></td>
<td>
<p>the output of a call to <code><a href="#topic+estimate_clusters">estimate_clusters</a></code> (optional). It can be used to speed up the function if the partition has already been computed. 
If <code>estimated_clusters = NULL</code>, the displayed partition is computed using <code><a href="#topic+estimate_clusters">estimate_clusters</a></code>.</p>
</td></tr>
<tr><td><code id="plot.SANmcmc_+3A_burnin">burnin</code></td>
<td>
<p>the length of the burn-in to be discarded (default is 2/3 of the iterations).</p>
</td></tr>
<tr><td><code id="plot.SANmcmc_+3A_palette_brewed">palette_brewed</code></td>
<td>
<p>(logical) the color palette to be used. Default is <code>R</code> base colors (<code>palette_brewed = FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.SANmcmc_+3A_ncores">ncores</code></td>
<td>
<p>if the partition is computed, the number of CPU cores to use to estimate the clusters, i.e., the number of simultaneous runs at any given time. A value of zero indicates to use all cores on the system.</p>
</td></tr>
<tr><td><code id="plot.SANmcmc_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be passed when <code>type = "scatter"</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function plots a summary of the fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.SANmcmc">print.SANmcmc</a></code>, <code><a href="#topic+estimate_clusters">estimate_clusters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
y &lt;- c(rnorm(40,0,0.3), rnorm(20,5,0.3))
g &lt;- c(rep(1,30), rep(2, 30))
out &lt;- sample_fiSAN(nrep = 500, y = y, group = g, 
                    nclus_start = 2,
                    maxK = 20, maxL = 20,
                    beta = 1)
plot(out, type = "ecdf", palette_brewed = TRUE)

</code></pre>

<hr>
<h2 id='print.SANclusters'>Print cluster summary</h2><span id='topic+print.SANclusters'></span>

<h3>Description</h3>

<p>Print the cluster-specific sample means and variances of the estimated observational and distributional partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SANclusters'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SANclusters_+3A_x">x</code></td>
<td>
<p>object of class <code>SANclusters</code> (the result of a call to <code><a href="#topic+estimate_clusters">estimate_clusters</a></code>)</p>
</td></tr>
<tr><td><code id="print.SANclusters_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function prints a summary of the estimated clusters.
</p>

<hr>
<h2 id='print.SANmcmc'>Print MCMC output</h2><span id='topic+print.SANmcmc'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>SANmcmc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SANmcmc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SANmcmc_+3A_x">x</code></td>
<td>
<p>object of class <code>SANmcmc</code> (the result of a call to <code><a href="#topic+sample_fiSAN">sample_fiSAN</a></code>, <code><a href="#topic+sample_fiSAN_sparsemix">sample_fiSAN_sparsemix</a></code>, 
<code><a href="#topic+sample_fSAN">sample_fSAN</a></code>, <code><a href="#topic+sample_fSAN_sparsemix">sample_fSAN_sparsemix</a></code>, or <code><a href="#topic+sample_CAM">sample_CAM</a></code>).</p>
</td></tr>
<tr><td><code id="print.SANmcmc_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function prints a summary of the fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_clusters">estimate_clusters</a></code>, <code><a href="#topic+plot.SANmcmc">plot.SANmcmc</a></code>
</p>

<hr>
<h2 id='sample_CAM'>Sample CAM</h2><span id='topic+sample_CAM'></span>

<h3>Description</h3>

<p><code>sample_CAM</code> is used to perform posterior inference under the common atoms model (CAM) of Denti et al. (2023) with Gaussian likelihood. 
The model uses Dirichlet process mixtures (DPM) at both the observational and distributional levels. 
The implemented algorithm is based on the nested slice sampler of Denti et al. (2023), based on the algorithm of Kalli, Griffin and Walker (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_CAM(nrep, y, group, 
           maxK = 50, maxL = 50, 
           m0 = 0, tau0 = 0.1, lambda0 = 3, gamma0 = 2,
           hyp_alpha1 = 1, hyp_alpha2 = 1,
           hyp_beta1 = 1, hyp_beta2 = 1,
           alpha = NULL, beta = NULL,
           warmstart = TRUE, nclus_start = NULL,
           mu_start = NULL, sigma2_start = NULL,
           M_start = NULL, S_start = NULL,
           alpha_start = NULL, beta_start = NULL,
           progress = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_CAM_+3A_nrep">nrep</code></td>
<td>
<p>Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_y">y</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_group">group</code></td>
<td>
<p>Vector of the same length of y indicating the group membership (numeric).</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_maxk">maxK</code></td>
<td>
<p>Maximum number of distributional clusters (default = 50).</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_maxl">maxL</code></td>
<td>
<p>Maximum number of observational clusters (default = 50).</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_m0">m0</code>, <code id="sample_CAM_+3A_tau0">tau0</code>, <code id="sample_CAM_+3A_lambda0">lambda0</code>, <code id="sample_CAM_+3A_gamma0">gamma0</code></td>
<td>
<p>Hyperparameters on <code class="reqn">(\mu, \sigma^2) \sim NIG(m_0, \tau_0, \lambda_0,\gamma_0)</code>. Default is (0, 0.1, 3, 2).</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_hyp_alpha1">hyp_alpha1</code>, <code id="sample_CAM_+3A_hyp_alpha2">hyp_alpha2</code></td>
<td>
<p>If a random <code class="reqn">\alpha</code> is used, (<code>hyp_alpha1</code>, <code>hyp_alpha2</code>) specify the hyperparameters. Default is (1,1).
The prior is <code class="reqn">\alpha</code> ~ Gamma(<code>hyp_alpha1</code>, <code>hyp_alpha2</code>).</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_hyp_beta1">hyp_beta1</code>, <code id="sample_CAM_+3A_hyp_beta2">hyp_beta2</code></td>
<td>
<p>If a random <code class="reqn">\beta</code> is used, (<code>hyp_beta1</code>, <code>hyp_beta2</code>) specify the hyperparameters. Default is (1,1).
The prior is <code class="reqn">\beta</code> ~ Gamma(<code>hyp_beta1</code>, <code>hyp_beta2</code>).</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_alpha">alpha</code></td>
<td>
<p>Distributional DP parameter if fixed (optional). The distribution is <code class="reqn">\pi\sim GEM (\alpha)</code>.</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_beta">beta</code></td>
<td>
<p>Observational DP parameter if fixed (optional). The distribution is <code class="reqn">\omega_k \sim GEM (\beta)</code>.</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_warmstart">warmstart</code>, <code id="sample_CAM_+3A_nclus_start">nclus_start</code></td>
<td>
<p>Initialization of the observational clustering. 
<code>warmstart</code> is logical parameter (default = <code>TRUE</code>) of whether a kmeans clustering should be used to initialize the chains.
An initial guess of the number of observational clusters can be passed via the <code>nclus_start</code> parameter (optional). Default is <code>nclus_start = min(c(maxL, 30))</code>.</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_mu_start">mu_start</code>, <code id="sample_CAM_+3A_sigma2_start">sigma2_start</code>, <code id="sample_CAM_+3A_m_start">M_start</code>, <code id="sample_CAM_+3A_s_start">S_start</code>, <code id="sample_CAM_+3A_alpha_start">alpha_start</code>, <code id="sample_CAM_+3A_beta_start">beta_start</code></td>
<td>
<p>Starting points of the MCMC chains (optional). 
<code>mu_start, sigma2_start</code> are vectors of length <code>maxL</code>. 
<code>M_start</code> is a vector of observational cluster allocation of length N.
<code>S_start</code> is a vector of observational cluster allocation of length J.
<code>alpha_start, alpha_start</code> are numeric.</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_progress">progress</code></td>
<td>
<p>show a progress bar? (logical, default TRUE).</p>
</td></tr>
<tr><td><code id="sample_CAM_+3A_seed">seed</code></td>
<td>
<p>set a fixed seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Data structure</strong>
</p>
<p>The common atoms mixture model is used to perform inference in nested settings, where the data are organized into <code class="reqn">J</code> groups. 
The data should be continuous observations <code class="reqn">(Y_1,\dots,Y_J)</code>, where each <code class="reqn">Y_j = (y_{1,j},\dots,y_{n_j,j})</code> 
contains the <code class="reqn">n_j</code> observations from group <code class="reqn">j</code>, for <code class="reqn">j=1,\dots,J</code>. 
The function takes as input the data as a numeric vector <code>y</code> in this concatenated form. Hence <code>y</code> should be a vector of length
<code class="reqn">n_1+\dots+n_J</code>. The <code>group</code> parameter is a numeric vector of the same size as <code>y</code> indicating the group membership for each
individual observation. 
Notice that with this specification the observations in the same group need not be contiguous as long as the correspondence between the variables
<code>y</code> and <code>group</code> is maintained.
</p>
<p><strong>Model</strong>
</p>
<p>The data are modeled using a univariate Gaussian likelihood, where both the mean and the variance are observational-cluster-specific, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">y_{i,j}\mid M_{i,j} = l \sim N(\mu_l,\sigma^2_l)</code>
</p>

<p>where <code class="reqn">M_{i,j} \in \{1,2,\dots\}</code> is the observational cluster indicator of observation <code class="reqn">i</code> in group <code class="reqn">j</code>.
The prior on the model parameters is a Normal-Inverse-Gamma distribution <code class="reqn">(\mu_l,\sigma^2_l)\sim NIG (m_0,\tau_0,\lambda_0,\gamma_0)</code>, 
i.e., <code class="reqn">\mu_l\mid\sigma^2_l \sim N(m_0, \sigma^2_l / \tau_0)</code>, <code class="reqn">1/\sigma^2_l \sim Gamma(\lambda_0, \gamma_0)</code> (shape, rate).
</p>
<p><strong>Clustering</strong>
</p>
<p>The model performs a clustering of both observations and groups. 
The clustering of groups (distributional clustering) is provided by the allocation variables <code class="reqn">S_j \in \{1,2,\dots\}</code>, with 
</p>
<p style="text-align: center;"><code class="reqn">Pr(S_j = k \mid \dots ) = \pi_k  \qquad \text{for } \: k = 1,2,\dots</code>
</p>

<p>The distribution of the probabilities is <code class="reqn"> \{\pi_k\}_{k=1}^{\infty} \sim GEM(\alpha)</code>, 
where GEM is the Griffiths-Engen-McCloskey distribution of parameter <code class="reqn">\alpha</code>, 
which characterizes the stick-breaking construction of the DP (Sethuraman, 1994). 
</p>
<p>The clustering of observations (observational clustering) is provided by the allocation variables <code class="reqn">M_{i,j} \in \{1,2,\dots\}</code>, with
</p>
<p style="text-align: center;"><code class="reqn"> Pr(M_{i,j} = l \mid S_j = k, \dots ) = \omega_{l,k} \qquad \text{for } \: k = 1,2,\dots \, ; \: l = 1,2,\dots </code>
</p>

<p>The distribution of the probabilities is <code class="reqn"> \{\omega_{l,k}\}_{l=1}^{\infty} \sim GEM(\beta)</code> for all <code class="reqn">k = 1,2,\dots</code>
</p>


<h3>Value</h3>

<p><code>sample_CAM</code> returns four objects:
</p>

<ul>
<li> <p><code>model</code>: name of the fitted model.
</p>
</li>
<li> <p><code>params</code>: list containing the data and the parameters used in the simulation. Details below.
</p>
</li>
<li> <p><code>sim</code>: list containing the simulated values (MCMC chains). Details below.
</p>
</li>
<li> <p><code>time</code>: total computation time.
</p>
</li></ul>

<p><strong>Data and parameters</strong>:
<code>params</code> is a list with the following components:
</p>

<dl>
<dt><code>nrep</code></dt><dd><p>Number of MCMC iterations.</p>
</dd>
<dt><code>y, group</code></dt><dd><p>Data and group vectors.</p>
</dd>
<dt><code>maxK, maxL</code></dt><dd><p>Maximum number of distributional and observational clusters.</p>
</dd>
<dt><code>m0, tau0, lambda0, gamma0</code></dt><dd><p>Model hyperparameters.</p>
</dd>
<dt>(<code>hyp_alpha1,hyp_alpha2</code>) or <code>alpha</code></dt><dd><p>Either the hyperparameters on <code class="reqn">\alpha</code> (if <code class="reqn">\alpha</code> random), or the value for <code class="reqn">\alpha</code> (if fixed).</p>
</dd>
<dt>(<code>hyp_beta1,hyp_beta2</code>) or <code>beta</code></dt><dd><p>Either the hyperparameters on <code class="reqn">\beta</code> (if <code class="reqn">\beta</code> random), or the value for <code class="reqn">\beta</code> (if fixed).</p>
</dd>
</dl>

<p><strong>Simulated values</strong>:
<code>sim</code> is a list with the following components:
</p>

<dl>
<dt><code>mu</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>).
Each row is a posterior sample of the mean parameter for each observational cluster <code class="reqn">(\mu_1,\dots\mu_L)</code>.</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>). 
Each row is a posterior sample of the variance parameter for each observational cluster <code class="reqn">(\sigma^2_1,\dots\sigma^2_L)</code>.</p>
</dd>
<dt><code>obs_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, n), with n = <code>length(y)</code>. 
Each row is a posterior sample of the observational cluster allocation variables <code class="reqn">(M_{1,1},\dots,M_{n_J,J})</code>. </p>
</dd>
<dt><code>distr_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, J), with J = <code>length(unique(group))</code>. 
Each row is a posterior sample of the distributional cluster allocation variables <code class="reqn">(S_1,\dots,S_J)</code>. </p>
</dd>
<dt><code>pi</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxK</code>). 
Each row is a posterior sample of the distributional cluster probabilities <code class="reqn">(\pi_1,\dots,\pi_{maxK})</code>.</p>
</dd>
<dt><code>omega</code></dt><dd><p>3-d array of size (<code>maxL</code>, <code>maxK</code>, <code>nrep</code>).
Each slice is a posterior sample of the observational cluster probabilities. 
In each slice, each column <code class="reqn">k</code> is a vector (of length <code>maxL</code>) observational cluster probabilities
<code class="reqn">(\omega_{1,k},\dots,\omega_{maxL,k})</code> for distributional cluster <code class="reqn">k</code>. </p>
</dd>
<dt><code>alpha</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\alpha</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>maxK</code></dt><dd><p>Vector of length <code>nrep</code> of the number of distributional DP components used by the slice sampler.</p>
</dd>
<dt><code>maxL</code></dt><dd><p>Vector of length <code>nrep</code> of the number of observational DP components used by the slice sampler.</p>
</dd>
</dl>



<h3>References</h3>

<p>Denti, F., Camerlenghi, F., Guindani, M., and Mira, A. (2023). A Common Atoms Model for the Bayesian Nonparametric Analysis of Nested Data. 
<em>Journal of the American Statistical Association</em>, 118(541), 405-416. &lt;doi:10.1080/01621459.2021.1933499&gt;
</p>
<p>Kalli, M., Griffin, J.E., and Walker, S.G. (2011). Slice Sampling Mixture Models, 
<em>Statistics and Computing</em>, 21, 93–105. &lt;doi:10.1007/s11222-009-9150-y&gt;
</p>
<p>Sethuraman, A.J. (1994). A Constructive Definition of Dirichlet Priors, <em>Statistica Sinica</em>, 4, 639–650.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
y &lt;- c(rnorm(40,0,0.3), rnorm(20,5,0.3))
g &lt;- c(rep(1,30), rep(2, 30))
plot(density(y[g==1]), xlim = c(-5,10))
lines(density(y[g==2]), col = 2)
out &lt;- sample_CAM(nrep = 500, y = y, group = g,
                  nclus_start = 2,
                  maxL = 20, maxK = 20)
out 

</code></pre>

<hr>
<h2 id='sample_fiSAN'>Sample fiSAN</h2><span id='topic+sample_fiSAN'></span>

<h3>Description</h3>

<p><code>sample_fiSAN</code> is used to perform posterior inference under the finite-infinite shared atoms nested (fiSAN) model with Gaussian likelihood. 
The model uses a Dirichlet process mixture prior at the distributional level, 
and Dirichlet mixture with an unknown number of components (following the specification of Frühwirth-Schnatter et al., 2021) at the observational level.
The algorithm for the nonparametric component is based on the slice sampler for DPM of Kalli, Griffin and Walker (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fiSAN(nrep, y, group, 
             maxK = 50, maxL = 50, 
             m0 = 0, tau0 = 0.1, lambda0 = 3, gamma0 = 2,
             hyp_alpha1 = 1, hyp_alpha2 = 1,
             hyp_beta1 = 6, hyp_beta2 = 3, 
             eps_beta = NULL,
             alpha = NULL, beta = NULL,
             warmstart = TRUE, nclus_start = NULL,
             mu_start = NULL, sigma2_start = NULL,
             M_start = NULL, S_start = NULL,
             alpha_start = NULL, beta_start = NULL,
             progress = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_fiSAN_+3A_nrep">nrep</code></td>
<td>
<p>Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_y">y</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_group">group</code></td>
<td>
<p>Vector of the same length of y indicating the group membership (numeric).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_maxk">maxK</code></td>
<td>
<p>Maximum number of distributional clusters <code class="reqn">K</code> (default = 50).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_maxl">maxL</code></td>
<td>
<p>Maximum number of observational clusters <code class="reqn">L</code> (default = 50).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_m0">m0</code>, <code id="sample_fiSAN_+3A_tau0">tau0</code>, <code id="sample_fiSAN_+3A_lambda0">lambda0</code>, <code id="sample_fiSAN_+3A_gamma0">gamma0</code></td>
<td>
<p>Hyperparameters on <code class="reqn">(\mu, \sigma^2) \sim NIG(m_0, \tau_0, \lambda_0,\gamma_0)</code>. Default is (0, 0.1, 3, 2).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_hyp_alpha1">hyp_alpha1</code>, <code id="sample_fiSAN_+3A_hyp_alpha2">hyp_alpha2</code></td>
<td>
<p>If a random <code class="reqn">\alpha</code> is used, (<code>hyp_alpha1</code>,<code>hyp_alpha2</code>) specify the hyperparameters (default = (1,1)).
The prior is <code class="reqn">\alpha</code> ~ Gamma(<code>hyp_alpha1</code>, <code>hyp_alpha2</code>).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_hyp_beta1">hyp_beta1</code>, <code id="sample_fiSAN_+3A_hyp_beta2">hyp_beta2</code>, <code id="sample_fiSAN_+3A_eps_beta">eps_beta</code></td>
<td>
<p>If a random <code class="reqn">\beta</code> is used, (<code>hyp_beta1</code>,<code>hyp_beta2</code>) specifies the hyperparameter (default = (6,3)). 
The prior is <code class="reqn">\beta\sim Gamma</code>(<code>hyp_beta1</code>, <code>hyp_beta2</code>). In this case, <code>eps_beta</code> is the tuning parameter of the MH step.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_alpha">alpha</code></td>
<td>
<p>Distributional DP parameter if fixed (optional). The distribution is <code class="reqn">\pi\sim GEM (\alpha)</code>.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_beta">beta</code></td>
<td>
<p>Observational Dirichlet parameter if fixed (optional). The distribution is Dirichlet( <code>rep(beta/maxL, maxL)</code> ).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_warmstart">warmstart</code>, <code id="sample_fiSAN_+3A_nclus_start">nclus_start</code></td>
<td>
<p>Initialization of the observational clustering. 
<code>warmstart</code> is logical parameter (default = <code>TRUE</code>) of whether a kmeans clustering should be used to initialize the chains.
An initial guess of the number of observational clusters can be passed via the <code>nclus_start</code> parameter (optional)</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_mu_start">mu_start</code>, <code id="sample_fiSAN_+3A_sigma2_start">sigma2_start</code>, <code id="sample_fiSAN_+3A_m_start">M_start</code>, <code id="sample_fiSAN_+3A_s_start">S_start</code>, <code id="sample_fiSAN_+3A_alpha_start">alpha_start</code>, <code id="sample_fiSAN_+3A_beta_start">beta_start</code></td>
<td>
<p>Starting points of the MCMC chains (optional). Default is <code>nclus_start = min(c(maxL, 30))</code>.
<code>mu_start, sigma2_start</code> are vectors of length <code>maxL</code>. 
<code>M_start</code> is a vector of observational cluster allocation of length N.
<code>S_start</code> is a vector of observational cluster allocation of length J.
<code>alpha_start, alpha_start</code> are numeric.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_progress">progress</code></td>
<td>
<p>show a progress bar? (logical, default TRUE).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_+3A_seed">seed</code></td>
<td>
<p>set a fixed seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Data structure</strong>
</p>
<p>The finite-infinite common atoms mixture model is used to perform inference in nested settings, where the data are organized into <code class="reqn">J</code> groups. 
The data should be continuous observations <code class="reqn">(Y_1,\dots,Y_J)</code>, where each <code class="reqn">Y_j = (y_{1,j},\dots,y_{n_j,j})</code> 
contains the <code class="reqn">n_j</code> observations from group <code class="reqn">j</code>, for <code class="reqn">j=1,\dots,J</code>. 
The function takes as input the data as a numeric vector <code>y</code> in this concatenated form. Hence <code>y</code> should be a vector of length
<code class="reqn">n_1+\dots+n_J</code>. The <code>group</code> parameter is a numeric vector of the same size as <code>y</code> indicating the group membership for each
individual observation. 
Notice that with this specification the observations in the same group need not be contiguous as long as the correspondence between the variables
<code>y</code> and <code>group</code> is maintained.
</p>
<p><strong>Model</strong>
</p>
<p>The data are modeled using a univariate Gaussian likelihood, where both the mean and the variance are observational-cluster-specific, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">y_{i,j}\mid M_{i,j} = l \sim N(\mu_l,\sigma^2_l)</code>
</p>

<p>where <code class="reqn">M_{i,j} \in \{1,\dots,L \}</code> is the observational cluster indicator of observation <code class="reqn">i</code> in group <code class="reqn">j</code>.
The prior on the model parameters is a Normal-Inverse-Gamma distribution <code class="reqn">(\mu_l,\sigma^2_l)\sim NIG (m_0,\tau_0,\lambda_0,\gamma_0)</code>, 
i.e., <code class="reqn">\mu_l\mid\sigma^2_l \sim N(m_0, \sigma^2_l / \tau_0)</code>, <code class="reqn">1/\sigma^2_l \sim Gamma(\lambda_0, \gamma_0)</code> (shape, rate).
</p>
<p><strong>Clustering</strong>
</p>
<p>The model performs a clustering of both observations and groups. 
The clustering of groups (distributional clustering) is provided by the allocation variables <code class="reqn">S_j \in \{1,2,\dots\}</code>, with 
</p>
<p style="text-align: center;"><code class="reqn">Pr(S_j = k \mid \dots ) = \pi_k  \qquad \text{for } \: k = 1,2,\dots</code>
</p>

<p>The distribution of the probabilities is <code class="reqn"> \{\pi_k\}_{k=1}^{\infty} \sim GEM(\alpha)</code>, 
where GEM is the Griffiths-Engen-McCloskey distribution of parameter <code class="reqn">\alpha</code>, 
which characterizes the stick-breaking construction of the DP (Sethuraman, 1994). 
</p>
<p>The clustering of observations (observational clustering) is provided by the allocation variables <code class="reqn">M_{i,j} \in \{1,\dots,L\}</code>, with
</p>
<p style="text-align: center;"><code class="reqn"> Pr(M_{i,j} = l \mid S_j = k, \dots ) = \omega_{l,k} \qquad \text{for } \: k = 1,2,\dots \, ; \: l = 1,\dots,L. </code>
</p>

<p>The distribution of the probabilities is <code class="reqn">(\omega_{1,k},\dots,\omega_{L,k})\sim Dirichlet_L(\beta/L,\dots,\beta/L)</code> for all <code class="reqn">k = 1,2,\dots</code>. 
Moreover, the dimension <code class="reqn">L</code> is random (see Frühwirth-Schnatter et al., 2021).
</p>


<h3>Value</h3>

<p><code>sample_fiSAN</code> returns four objects:
</p>

<ul>
<li> <p><code>model</code>: name of the fitted model.
</p>
</li>
<li> <p><code>params</code>: list containing the data and the parameters used in the simulation. Details below.
</p>
</li>
<li> <p><code>sim</code>: list containing the simulated values (MCMC chains). Details below.
</p>
</li>
<li> <p><code>time</code>: total computation time.
</p>
</li></ul>

<p><strong>Data and parameters</strong>:
<code>params</code> is a list with the following components:
</p>

<dl>
<dt><code>nrep</code></dt><dd><p>Number of MCMC iterations.</p>
</dd>
<dt><code>y, group</code></dt><dd><p>Data and group vectors.</p>
</dd>
<dt><code>maxK, maxL</code></dt><dd><p>Maximum number of distributional and observational clusters.</p>
</dd>
<dt><code>m0, tau0, lambda0, gamma0</code></dt><dd><p>Model hyperparameters.</p>
</dd>
<dt>(<code>hyp_alpha1,hyp_alpha2</code>) or <code>alpha</code></dt><dd><p>Either the hyperparameters on <code class="reqn">\alpha</code> (if <code class="reqn">\alpha</code> random), or the value for <code class="reqn">\alpha</code> (if fixed).</p>
</dd>
<dt>(<code>hyp_beta1, hyp_beta2, eps_beta</code>) or <code>beta</code></dt><dd><p>Either the hyperparameters on <code class="reqn">\beta</code> and MH step size (if <code class="reqn">\beta</code> random), or the value for <code class="reqn">\beta</code> (if fixed).</p>
</dd>
</dl>

<p><strong>Simulated values</strong>:
<code>sim</code> is a list with the following components:
</p>

<dl>
<dt><code>mu</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>).
Each row is a posterior sample of the mean parameter for each observational cluster <code class="reqn">(\mu_1,\dots\mu_L)</code>.</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>). 
Each row is a posterior sample of the variance parameter for each observational cluster <code class="reqn">(\sigma^2_1,\dots\sigma^2_L)</code>.</p>
</dd>
<dt><code>obs_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, n), with n = <code>length(y)</code>. 
Each row is a posterior sample of the observational cluster allocation variables <code class="reqn">(M_{1,1},\dots,M_{n_J,J})</code>. </p>
</dd>
<dt><code>distr_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, J), with J = <code>length(unique(group))</code>. 
Each row is a posterior sample of the distributional cluster allocation variables <code class="reqn">(S_1,\dots,S_J)</code>. </p>
</dd>
<dt><code>pi</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxK</code>). 
Each row is a posterior sample of the distributional cluster probabilities <code class="reqn">(\pi_1,\dots,\pi_{maxK})</code>.</p>
</dd>
<dt><code>omega</code></dt><dd><p>3-d array of size (<code>maxL</code>, <code>maxK</code>, <code>nrep</code>).
Each slice is a posterior sample of the observational cluster probabilities. 
In each slice, each column <code class="reqn">k</code> is a vector (of length <code>maxL</code>) observational cluster probabilities
<code class="reqn">(\omega_{1,k},\dots,\omega_{L,k})</code> for distributional cluster <code class="reqn">k</code>. </p>
</dd>
<dt><code>alpha</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\alpha</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>maxK</code></dt><dd><p>Vector of length <code>nrep</code> of the number of distributional DP components used by the slice sampler.</p>
</dd>
<dt><code>L_plus</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the number of observational clusters.</p>
</dd>
<dt><code>L</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the observational Dirichlet dimension.</p>
</dd>
</dl>



<h3>References</h3>

<p>Frühwirth-Schnatter, S., Malsiner-Walli, G. and Grün, B. (2021).
Generalized mixtures of finite mixtures and telescoping sampling. <em>Bayesian Analysis</em>, 16(4), 1279–1307. &lt;doi:10.1214/21-BA1294&gt;
</p>
<p>Kalli, M., Griffin, J.E., and Walker, S.G. (2011). Slice Sampling Mixture Models, 
<em>Statistics and Computing</em>, 21, 93–105. &lt;doi:10.1007/s11222-009-9150-y&gt;
</p>
<p>Sethuraman, A.J. (1994). A Constructive Definition of Dirichlet Priors, <em>Statistica Sinica</em>, 4, 639–650.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
y &lt;- c(rnorm(40,0,0.3), rnorm(20,5,0.3))
g &lt;- c(rep(1,30), rep(2, 30))
plot(density(y[g==1]), xlim = c(-5,10))
lines(density(y[g==2]), col = 2)
out &lt;- sample_fiSAN(nrep = 500, y = y, group = g, 
                    nclus_start = 2,
                    maxK = 20, maxL = 20,
                    beta = 1)
out 

</code></pre>

<hr>
<h2 id='sample_fiSAN_sparsemix'>Sample fiSAN with sparse mixtures</h2><span id='topic+sample_fiSAN_sparsemix'></span>

<h3>Description</h3>

<p><code>sample_fiSAN_sparsemix</code> is used to perform posterior inference under the finite-infinite shared atoms nested (fiSAN) model with Gaussian likelihood. 
The model uses a Dirichlet process mixture prior at the distributional level, 
and a sparse (overfitted) Dirichlet mixture (Malsiner-Walli et al., 2016) at the observational level.
The algorithm for the nonparametric component is based on the slice sampler for DPM of Kalli, Griffin and Walker (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fiSAN_sparsemix(nrep, y, group, 
                 maxK = 50, maxL = 50, 
                 m0 = 0, tau0 = 0.1, lambda0 = 3, gamma0 = 2,
                 hyp_alpha1 = 1, hyp_alpha2 = 1,
                 hyp_beta = 10, 
                 eps_beta = NULL, 
                 alpha = NULL, beta = NULL,
                 warmstart = TRUE, nclus_start = NULL,
                 mu_start = NULL, sigma2_start = NULL,
                 M_start = NULL, S_start = NULL,
                 alpha_start = NULL, beta_start = NULL,
                 progress = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_nrep">nrep</code></td>
<td>
<p>Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_y">y</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_group">group</code></td>
<td>
<p>Vector of the same length of y indicating the group membership (numeric).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_maxk">maxK</code></td>
<td>
<p>Maximum number of distributional clusters <code class="reqn">K</code> (default = 50).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_maxl">maxL</code></td>
<td>
<p>Maximum number of observational clusters <code class="reqn">L</code> (default = 50).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_m0">m0</code>, <code id="sample_fiSAN_sparsemix_+3A_tau0">tau0</code>, <code id="sample_fiSAN_sparsemix_+3A_lambda0">lambda0</code>, <code id="sample_fiSAN_sparsemix_+3A_gamma0">gamma0</code></td>
<td>
<p>Hyperparameters on <code class="reqn">(\mu, \sigma^2) \sim NIG(m_0, \tau_0, \lambda_0,\gamma_0)</code>. Default is (0, 0.1, 3, 2).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_hyp_alpha1">hyp_alpha1</code>, <code id="sample_fiSAN_sparsemix_+3A_hyp_alpha2">hyp_alpha2</code></td>
<td>
<p>If a random <code class="reqn">\alpha</code> is used, (<code>hyp_alpha1</code>,<code>hyp_alpha2</code>) specify the hyperparameters (default = (1,1)).
The prior is <code class="reqn">\alpha</code> ~ Gamma(<code>hyp_alpha1</code>, <code>hyp_alpha2</code>).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_hyp_beta">hyp_beta</code>, <code id="sample_fiSAN_sparsemix_+3A_eps_beta">eps_beta</code></td>
<td>
<p>If a random <code class="reqn">\beta</code> is used, <code>hyp_beta</code> specifies the hyperparameter (default = 10). 
The prior is <code class="reqn">\beta</code> ~ Gamma(<code>hyp_beta</code>, <code>hyp_beta*maxL</code>),
following Malsiner-Walli et al. (2016). In this case, <code>eps_beta</code> is the tuning parameter of the MH step.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_alpha">alpha</code></td>
<td>
<p>Distributional DP parameter if fixed (optional). The distribution is <code class="reqn">\pi\sim GEM (\alpha)</code>.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_beta">beta</code></td>
<td>
<p>Observational Dirichlet parameter if fixed (optional). The distribution is Dirichlet( <code>rep(beta, maxL)</code> ). Notice that beta should be small to ensure sparsity (e.g. beta = 0.01)</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_warmstart">warmstart</code>, <code id="sample_fiSAN_sparsemix_+3A_nclus_start">nclus_start</code></td>
<td>
<p>Initialization of the observational clustering. 
<code>warmstart</code> is logical parameter (default = <code>TRUE</code>) of whether a kmeans clustering should be used to initialize the chains.
An initial guess of the number of observational clusters can be passed via the <code>nclus_start</code> parameter (optional)</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_mu_start">mu_start</code>, <code id="sample_fiSAN_sparsemix_+3A_sigma2_start">sigma2_start</code>, <code id="sample_fiSAN_sparsemix_+3A_m_start">M_start</code>, <code id="sample_fiSAN_sparsemix_+3A_s_start">S_start</code>, <code id="sample_fiSAN_sparsemix_+3A_alpha_start">alpha_start</code>, <code id="sample_fiSAN_sparsemix_+3A_beta_start">beta_start</code></td>
<td>
<p>Starting points of the MCMC chains (optional). Default is <code>nclus_start = min(c(maxL, 30))</code>.
<code>mu_start, sigma2_start</code> are vectors of length <code>maxL</code>. 
<code>M_start</code> is a vector of observational cluster allocation of length N.
<code>S_start</code> is a vector of observational cluster allocation of length J.
<code>alpha_start, alpha_start</code> are numeric.</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_progress">progress</code></td>
<td>
<p>show a progress bar? (logical, default TRUE).</p>
</td></tr>
<tr><td><code id="sample_fiSAN_sparsemix_+3A_seed">seed</code></td>
<td>
<p>set a fixed seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Data structure</strong>
</p>
<p>The finite-infinite common atoms mixture model is used to perform inference in nested settings, where the data are organized into <code class="reqn">J</code> groups. 
The data should be continuous observations <code class="reqn">(Y_1,\dots,Y_J)</code>, where each <code class="reqn">Y_j = (y_{1,j},\dots,y_{n_j,j})</code> 
contains the <code class="reqn">n_j</code> observations from group <code class="reqn">j</code>, for <code class="reqn">j=1,\dots,J</code>. 
The function takes as input the data as a numeric vector <code>y</code> in this concatenated form. Hence <code>y</code> should be a vector of length
<code class="reqn">n_1+\dots+n_J</code>. The <code>group</code> parameter is a numeric vector of the same size as <code>y</code> indicating the group membership for each
individual observation. 
Notice that with this specification the observations in the same group need not be contiguous as long as the correspondence between the variables
<code>y</code> and <code>group</code> is maintained.
</p>
<p><strong>Model</strong>
</p>
<p>The data are modeled using a univariate Gaussian likelihood, where both the mean and the variance are observational-cluster-specific, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">y_{i,j}\mid M_{i,j} = l \sim N(\mu_l,\sigma^2_l)</code>
</p>

<p>where <code class="reqn">M_{i,j} \in \{1,\dots,L \}</code> is the observational cluster indicator of observation <code class="reqn">i</code> in group <code class="reqn">j</code>.
The prior on the model parameters is a Normal-Inverse-Gamma distribution <code class="reqn">(\mu_l,\sigma^2_l)\sim NIG (m_0,\tau_0,\lambda_0,\gamma_0)</code>, 
i.e., <code class="reqn">\mu_l\mid\sigma^2_l \sim N(m_0, \sigma^2_l / \tau_0)</code>, <code class="reqn">1/\sigma^2_l \sim Gamma(\lambda_0, \gamma_0)</code> (shape, rate).
</p>
<p><strong>Clustering</strong>
</p>
<p>The model performs a clustering of both observations and groups. 
The clustering of groups (distributional clustering) is provided by the allocation variables <code class="reqn">S_j \in \{1,2,\dots\}</code>, with 
</p>
<p style="text-align: center;"><code class="reqn">Pr(S_j = k \mid \dots ) = \pi_k  \qquad \text{for } \: k = 1,2,\dots</code>
</p>

<p>The distribution of the probabilities is <code class="reqn"> \{\pi_k\}_{k=1}^{\infty} \sim GEM(\alpha)</code>, 
where GEM is the Griffiths-Engen-McCloskey distribution of parameter <code class="reqn">\alpha</code>, 
which characterizes the stick-breaking construction of the DP (Sethuraman, 1994). 
</p>
<p>The clustering of observations (observational clustering) is provided by the allocation variables <code class="reqn">M_{i,j} \in \{1,\dots,L\}</code>, with
</p>
<p style="text-align: center;"><code class="reqn"> Pr(M_{i,j} = l \mid S_j = k, \dots ) = \omega_{l,k} \qquad \text{for } \: k = 1,2,\dots \, ; \: l = 1,\dots,L. </code>
</p>

<p>The distribution of the probabilities is <code class="reqn">(\omega_{1,k},\dots,\omega_{L,k})\sim Dirichlet_L(\beta,\dots,\beta)</code> for all <code class="reqn">k = 1,2,\dots</code>.
</p>


<h3>Value</h3>

<p><code>sample_fiSAN_sparsemix</code> returns four objects:
</p>

<ul>
<li> <p><code>model</code>: name of the fitted model.
</p>
</li>
<li> <p><code>params</code>: list containing the data and the parameters used in the simulation. Details below.
</p>
</li>
<li> <p><code>sim</code>: list containing the simulated values (MCMC chains). Details below.
</p>
</li>
<li> <p><code>time</code>: total computation time.
</p>
</li></ul>

<p><strong>Data and parameters</strong>:
<code>params</code> is a list with the following components:
</p>

<dl>
<dt><code>nrep</code></dt><dd><p>Number of MCMC iterations.</p>
</dd>
<dt><code>y, group</code></dt><dd><p>Data and group vectors.</p>
</dd>
<dt><code>maxK, maxL</code></dt><dd><p>Maximum number of distributional and observational clusters.</p>
</dd>
<dt><code>m0, tau0, lambda0, gamma0</code></dt><dd><p>Model hyperparameters.</p>
</dd>
<dt>(<code>hyp_alpha1,hyp_alpha2</code>) or <code>alpha</code></dt><dd><p>Either the hyperparameters on <code class="reqn">\alpha</code> (if <code class="reqn">\alpha</code> random), or the value for <code class="reqn">\alpha</code> (if fixed).</p>
</dd>
<dt>(<code>hyp_beta,eps_beta</code>) or <code>beta</code></dt><dd><p>Either the hyperparameter on <code class="reqn">\beta</code> and MH step size (if <code class="reqn">\beta</code> random), or the value for <code class="reqn">\beta</code> (if fixed).</p>
</dd>
</dl>

<p><strong>Simulated values</strong>:
<code>sim</code> is a list with the following components:
</p>

<dl>
<dt><code>mu</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>).
Each row is a posterior sample of the mean parameter for each observational cluster <code class="reqn">(\mu_1,\dots\mu_L)</code>.</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>). 
Each row is a posterior sample of the variance parameter for each observational cluster <code class="reqn">(\sigma^2_1,\dots\sigma^2_L)</code>.</p>
</dd>
<dt><code>obs_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, n), with n = <code>length(y)</code>. 
Each row is a posterior sample of the observational cluster allocation variables <code class="reqn">(M_{1,1},\dots,M_{n_J,J})</code>. </p>
</dd>
<dt><code>distr_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, J), with J = <code>length(unique(group))</code>. 
Each row is a posterior sample of the distributional cluster allocation variables <code class="reqn">(S_1,\dots,S_J)</code>. </p>
</dd>
<dt><code>pi</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxK</code>). 
Each row is a posterior sample of the distributional cluster probabilities <code class="reqn">(\pi_1,\dots,\pi_{maxK})</code>.</p>
</dd>
<dt><code>omega</code></dt><dd><p>3-d array of size (<code>maxL</code>, <code>maxK</code>, <code>nrep</code>).
Each slice is a posterior sample of the observational cluster probabilities. 
In each slice, each column <code class="reqn">k</code> is a vector (of length <code>maxL</code>) observational cluster probabilities
<code class="reqn">(\omega_{1,k},\dots,\omega_{L,k})</code> for distributional cluster <code class="reqn">k</code>. </p>
</dd>
<dt><code>alpha</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\alpha</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>maxK</code></dt><dd><p>Vector of length <code>nrep</code> of the number of distributional DP components used by the slice sampler.</p>
</dd>
</dl>



<h3>References</h3>

<p>Kalli, M., Griffin, J.E., and Walker, S.G. (2011). Slice Sampling Mixture Models, 
<em>Statistics and Computing</em>, 21, 93–105. &lt;doi:10.1007/s11222-009-9150-y&gt;
</p>
<p>Malsiner-Walli, G., Frühwirth-Schnatter, S. and Grün, B. (2016). 
Model-based clustering based on sparse finite Gaussian mixtures. Statistics and Computing 26, 303–324. &lt;doi:10.1007/s11222-014-9500-2&gt;
</p>
<p>Sethuraman, A.J. (1994). A Constructive Definition of Dirichlet Priors, <em>Statistica Sinica</em>, 4, 639–650.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
y &lt;- c(rnorm(40,0,0.3), rnorm(20,5,0.3))
g &lt;- c(rep(1,30), rep(2, 30))
plot(density(y[g==1]), xlim = c(-5,10))
lines(density(y[g==2]), col = 2)
out &lt;- sample_fiSAN_sparsemix(nrep = 500, y = y, group = g, 
                              nclus_start = 2,
                              maxK = 20, maxL = 20,
                              beta = 0.01)
out 

</code></pre>

<hr>
<h2 id='sample_fSAN'>Sample fSAN</h2><span id='topic+sample_fSAN'></span>

<h3>Description</h3>

<p><code>sample_fSAN</code> is used to perform posterior inference under the finite shared atoms nested (fSAN) model with Gaussian likelihood (originally proposed in D'Angelo et al., 2023). 
The model uses Dirichlet mixtures with an unknown number of components (following the specification of Frühwirth-Schnatter et al., 2021) at both the observational and distributional level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fSAN(nrep, y, group, 
            maxK = 50, maxL = 50, 
            m0 = 0, tau0 = 0.1, lambda0 = 3, gamma0 = 2,
            hyp_alpha1 = 6, hyp_alpha2 = 3, 
            hyp_beta1 = 6, hyp_beta2 = 3, 
            eps_alpha = NULL, eps_beta = NULL,
            alpha = NULL, beta = NULL,
            warmstart = TRUE, nclus_start = NULL,
            mu_start = NULL, sigma2_start = NULL,
            M_start = NULL, S_start = NULL,
            alpha_start = NULL, beta_start = NULL,
            progress = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_fSAN_+3A_nrep">nrep</code></td>
<td>
<p>Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_y">y</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_group">group</code></td>
<td>
<p>Vector of the same length of y indicating the group membership (numeric).</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_maxk">maxK</code></td>
<td>
<p>Maximum number of distributional clusters <code class="reqn">K</code> (default = 50).</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_maxl">maxL</code></td>
<td>
<p>Maximum number of observational clusters <code class="reqn">L</code> (default = 50).</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_m0">m0</code>, <code id="sample_fSAN_+3A_tau0">tau0</code>, <code id="sample_fSAN_+3A_lambda0">lambda0</code>, <code id="sample_fSAN_+3A_gamma0">gamma0</code></td>
<td>
<p>Hyperparameters on <code class="reqn">(\mu, \sigma^2) \sim NIG(m_0, \tau_0, \lambda_0,\gamma_0)</code>. Default is (0, 0.1, 3, 2).</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_hyp_alpha1">hyp_alpha1</code>, <code id="sample_fSAN_+3A_hyp_alpha2">hyp_alpha2</code>, <code id="sample_fSAN_+3A_eps_alpha">eps_alpha</code></td>
<td>
<p>If a random <code class="reqn">\alpha</code> is used, (<code>hyp_alpha1</code>,<code>hyp_alpha2</code>) specify the hyperparameters (default = (6,3)).
The prior is <code class="reqn">\alpha\sim Gamma</code>(<code>hyp_alpha1</code>, <code>hyp_alpha2</code>). In this case, <code>eps_alpha</code> is the tuning parameter of the MH step.</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_hyp_beta1">hyp_beta1</code>, <code id="sample_fSAN_+3A_hyp_beta2">hyp_beta2</code>, <code id="sample_fSAN_+3A_eps_beta">eps_beta</code></td>
<td>
<p>If a random <code class="reqn">\beta</code> is used, (<code>hyp_beta1</code>,<code>hyp_beta2</code>) specifies the hyperparameter (default = (6,3)). 
The prior is <code class="reqn">\beta\sim Gamma</code>(<code>hyp_beta1</code>, <code>hyp_beta2</code>). In this case, <code>eps_beta</code> is the tuning parameter of the MH step.</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_alpha">alpha</code></td>
<td>
<p>Distributional Dirichlet parameter if fixed (optional). The distribution is Dirichlet( <code>rep(alpha/maxK, maxK)</code> ).</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_beta">beta</code></td>
<td>
<p>Observational Dirichlet parameter if fixed (optional). The distribution is Dirichlet( <code>rep(beta/maxL, maxL)</code> ).</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_warmstart">warmstart</code>, <code id="sample_fSAN_+3A_nclus_start">nclus_start</code></td>
<td>
<p>Initialization of the observational clustering. 
<code>warmstart</code> is logical parameter (default = <code>TRUE</code>) of whether a kmeans clustering should be used to initialize the chains.
An initial guess of the number of observational clusters can be passed via the <code>nclus_start</code> parameter (optional). Default is <code>nclus_start = min(c(maxL, 30))</code>.</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_mu_start">mu_start</code>, <code id="sample_fSAN_+3A_sigma2_start">sigma2_start</code>, <code id="sample_fSAN_+3A_m_start">M_start</code>, <code id="sample_fSAN_+3A_s_start">S_start</code>, <code id="sample_fSAN_+3A_alpha_start">alpha_start</code>, <code id="sample_fSAN_+3A_beta_start">beta_start</code></td>
<td>
<p>Starting points of the MCMC chains (optional). 
<code>mu_start, sigma2_start</code> are vectors of length <code>maxL</code>. 
<code>M_start</code> is a vector of observational cluster allocation of length N.
<code>S_start</code> is a vector of observational cluster allocation of length J.
<code>alpha_start, alpha_start</code> are numeric.</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_progress">progress</code></td>
<td>
<p>show a progress bar? (logical, default TRUE.)</p>
</td></tr>
<tr><td><code id="sample_fSAN_+3A_seed">seed</code></td>
<td>
<p>set a fixed seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Data structure</strong>
</p>
<p>The finite common atoms mixture model is used to perform inference in nested settings, where the data are organized into <code class="reqn">J</code> groups. 
The data should be continuous observations <code class="reqn">(Y_1,\dots,Y_J)</code>, where each <code class="reqn">Y_j = (y_{1,j},\dots,y_{n_j,j})</code> 
contains the <code class="reqn">n_j</code> observations from group <code class="reqn">j</code>, for <code class="reqn">j=1,\dots,J</code>. 
The function takes as input the data as a numeric vector <code>y</code> in this concatenated form. Hence <code>y</code> should be a vector of length
<code class="reqn">n_1+\dots+n_J</code>. The <code>group</code> parameter is a numeric vector of the same size as <code>y</code> indicating the group membership for each
individual observation. 
Notice that with this specification the observations in the same group need not be contiguous as long as the correspondence between the variables
<code>y</code> and <code>group</code> is maintained.
</p>
<p><strong>Model</strong>
</p>
<p>The data are modeled using a univariate Gaussian likelihood, where both the mean and the variance are observational-cluster-specific, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">y_{i,j}\mid M_{i,j} = l \sim N(\mu_l,\sigma^2_l)</code>
</p>

<p>where <code class="reqn">M_{i,j} \in \{1,\dots,L \}</code> is the observational cluster indicator of observation <code class="reqn">i</code> in group <code class="reqn">j</code>.
The prior on the model parameters is a Normal-Inverse-Gamma distribution <code class="reqn">(\mu_l,\sigma^2_l)\sim NIG (m_0,\tau_0,\lambda_0,\gamma_0)</code>, 
i.e., <code class="reqn">\mu_l\mid\sigma^2_l \sim N(m_0, \sigma^2_l / \tau_0)</code>, <code class="reqn">1/\sigma^2_l \sim Gamma(\lambda_0, \gamma_0)</code> (shape, rate).
</p>
<p><strong>Clustering</strong>
</p>
<p>The model performs a clustering of both observations and groups. 
The clustering of groups (distributional clustering) is provided by the allocation variables <code class="reqn">S_j \in \{1,\dots,K\}</code>, with 
</p>
<p style="text-align: center;"><code class="reqn">Pr(S_j = k \mid \dots ) = \pi_k  \qquad \text{for } \: k = 1,\dots,K.</code>
</p>

<p>The distribution of the probabilities is <code class="reqn">(\pi_1,\dots,\pi_{K})\sim Dirichlet_K(\alpha/K,\dots,\alpha/K)</code>. 
Moreover, the dimension <code class="reqn">K</code> is random (see Frühwirth-Schnatter et al., 2021).
</p>
<p>The clustering of observations (observational clustering) is provided by the allocation variables <code class="reqn">M_{i,j} \in \{1,\dots,L\}</code>, with
</p>
<p style="text-align: center;"><code class="reqn"> Pr(M_{i,j} = l \mid S_j = k, \dots ) = \omega_{l,k} \qquad \text{for } \: k = 1,\dots,K \, ; \: l = 1,\dots,L. </code>
</p>

<p>The distribution of the probabilities is <code class="reqn">(\omega_{1,k},\dots,\omega_{L,k})\sim Dirichlet_L(\beta/L,\dots,\beta/L)</code> for all <code class="reqn">k = 1,\dots,K</code>. 
Moreover, the dimension <code class="reqn">L</code> is random (see Frühwirth-Schnatter et al., 2021).
</p>


<h3>Value</h3>

<p><code>sample_fSAN</code> returns four objects:
</p>

<ul>
<li> <p><code>model</code>: name of the fitted model.
</p>
</li>
<li> <p><code>params</code>: list containing the data and the parameters used in the simulation. Details below.
</p>
</li>
<li> <p><code>sim</code>: list containing the simulated values (MCMC chains). Details below.
</p>
</li>
<li> <p><code>time</code>: total computation time.
</p>
</li></ul>

<p><strong>Data and parameters</strong>:
<code>params</code> is a list with the following components:
</p>

<dl>
<dt><code>nrep</code></dt><dd><p>Number of MCMC iterations.</p>
</dd>
<dt><code>y, group</code></dt><dd><p>Data and group vectors.</p>
</dd>
<dt><code>maxK, maxL</code></dt><dd><p>Maximum number of distributional and observational clusters.</p>
</dd>
<dt><code>m0, tau0, lambda0, gamma0</code></dt><dd><p>Model hyperparameters.</p>
</dd>
<dt>(<code>hyp_alpha1, hyp_alpha2, eps_alpha</code>) or <code>alpha</code></dt><dd><p>Either the hyperparameters on <code class="reqn">\alpha</code> and MH step size (if <code class="reqn">\alpha</code> random), or the value for <code class="reqn">\alpha</code> (if fixed).</p>
</dd>
<dt>(<code>hyp_beta1, hyp_beta2, eps_beta</code>) or <code>beta</code></dt><dd><p>Either the hyperparameters on <code class="reqn">\beta</code> and MH step size (if <code class="reqn">\beta</code> random), or the value for <code class="reqn">\beta</code> (if fixed).</p>
</dd>
</dl>

<p><strong>Simulated values</strong>:
<code>sim</code> is a list with the following components:
</p>

<dl>
<dt><code>mu</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>).
Each row is a posterior sample of the mean parameter for each observational cluster <code class="reqn">(\mu_1,\dots\mu_L)</code>.</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>). 
Each row is a posterior sample of the variance parameter for each observational cluster <code class="reqn">(\sigma^2_1,\dots\sigma^2_L)</code>.</p>
</dd>
<dt><code>obs_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, n), with n = <code>length(y)</code>. 
Each row is a posterior sample of the observational cluster allocation variables <code class="reqn">(M_{1,1},\dots,M_{n_J,J})</code>. </p>
</dd>
<dt><code>distr_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, J), with J = <code>length(unique(group))</code>. 
Each row is a posterior sample of the distributional cluster allocation variables <code class="reqn">(S_1,\dots,S_J)</code>. </p>
</dd>
<dt><code>pi</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxK</code>). 
Each row is a posterior sample of the distributional cluster probabilities <code class="reqn">(\pi_1,\dots,\pi_{K})</code>.</p>
</dd>
<dt><code>omega</code></dt><dd><p>3-d array of size (<code>maxL</code>, <code>maxK</code>, <code>nrep</code>).
Each slice is a posterior sample of the observational cluster probabilities. 
In each slice, each column <code class="reqn">k</code> is a vector (of length <code>maxL</code>) observational cluster probabilities
<code class="reqn">(\omega_{1,k},\dots,\omega_{L,k})</code> for distributional cluster <code class="reqn">k</code>. </p>
</dd>
<dt><code>alpha</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\alpha</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\beta</code>.</p>
</dd>
<dt><code>K_plus</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the number of distributional clusters.</p>
</dd>
<dt><code>L_plus</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the number of observational clusters.</p>
</dd>
<dt><code>K</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the distributional Dirichlet dimension.</p>
</dd>
<dt><code>L</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the observational Dirichlet dimension.</p>
</dd>
</dl>



<h3>References</h3>

<p>D’Angelo, L., Canale, A., Yu, Z., and Guindani, M. (2023). 
Bayesian nonparametric analysis for the detection of spikes in noisy calcium imaging data. <em>Biometrics</em>, 79(2), 1370–1382. &lt;doi:10.1111/biom.13626&gt;
</p>
<p>Frühwirth-Schnatter, S., Malsiner-Walli, G. and Grün, B. (2021).
Generalized mixtures of finite mixtures and telescoping sampling. <em>Bayesian Analysis</em>, 16(4), 1279–1307. &lt;doi:10.1214/21-BA1294&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
y &lt;- c(rnorm(40,0,0.3), rnorm(20,5,0.3))
g &lt;- c(rep(1,30), rep(2, 30))
plot(density(y[g==1]), xlim = c(-5,10))
lines(density(y[g==2]), col = 2)
out &lt;- sample_fSAN(nrep = 500, y = y, group = g, 
                   nclus_start = 2,
                   maxK = 20, maxL = 20,
                   alpha = 1, beta = 1)
out 

</code></pre>

<hr>
<h2 id='sample_fSAN_sparsemix'>Sample fSAN with sparse mixtures</h2><span id='topic+sample_fSAN_sparsemix'></span>

<h3>Description</h3>

<p><code>sample_fSAN_sparsemix</code> is used to perform posterior inference under the finite shared atoms nested (fSAN) model with Gaussian likelihood (originally proposed in D'Angelo et al., 2023). 
The model uses overfitted (sparse) Dirichlet mixtures (Malsiner-Walli et al., 2016) at both the observational and distributional level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fSAN_sparsemix(nrep, y, group, 
               maxK = 50, maxL = 50, 
               m0 = 0, tau0 = 0.1, lambda0 = 3, gamma0 = 2,
               hyp_alpha = 10, hyp_beta = 10, 
               eps_alpha = NULL, eps_beta = NULL,
               alpha = NULL, beta = NULL,
               warmstart = TRUE, nclus_start = NULL,
               mu_start = NULL, sigma2_start = NULL, 
               M_start = NULL, S_start = NULL,
               alpha_start = NULL, beta_start = NULL,
               progress = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_fSAN_sparsemix_+3A_nrep">nrep</code></td>
<td>
<p>Number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_y">y</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_group">group</code></td>
<td>
<p>Vector of the same length of y indicating the group membership (numeric).</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_maxk">maxK</code></td>
<td>
<p>Maximum number of distributional clusters <code class="reqn">K</code> (default = 50).</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_maxl">maxL</code></td>
<td>
<p>Maximum number of observational clusters <code class="reqn">L</code> (default = 50).</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_m0">m0</code>, <code id="sample_fSAN_sparsemix_+3A_tau0">tau0</code>, <code id="sample_fSAN_sparsemix_+3A_lambda0">lambda0</code>, <code id="sample_fSAN_sparsemix_+3A_gamma0">gamma0</code></td>
<td>
<p>Hyperparameters on <code class="reqn">(\mu, \sigma^2) \sim NIG(m_0, \tau_0, \lambda_0,\gamma_0)</code>. Default is (0, 0.1, 3, 2).</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_hyp_alpha">hyp_alpha</code>, <code id="sample_fSAN_sparsemix_+3A_eps_alpha">eps_alpha</code></td>
<td>
<p>If a random <code class="reqn">\alpha</code> is used, <code>hyp_alpha</code> specifies the hyperparameter (default = 10).
The prior is <code class="reqn">\alpha</code> ~ Gamma(<code>hyp_alpha</code>, <code>hyp_alpha*maxK</code>),
following Malsiner-Walli et al. (2016). In this case, <code>eps_alpha</code> is the tuning parameter of the MH step.</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_hyp_beta">hyp_beta</code>, <code id="sample_fSAN_sparsemix_+3A_eps_beta">eps_beta</code></td>
<td>
<p>If a random <code class="reqn">\beta</code> is used, <code>hyp_beta</code> specifies the hyperparameter (default = 10). 
The prior is <code class="reqn">\beta</code> ~ Gamma(<code>hyp_beta</code>, <code>hyp_beta*maxL</code>),
following Malsiner-Walli et al. (2016). In this case, <code>eps_beta</code> is the tuning parameter of the MH step.</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_alpha">alpha</code></td>
<td>
<p>Distributional Dirichlet parameter if fixed (optional). The distribution is Dirichlet( <code>rep(alpha, maxK)</code> ).</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_beta">beta</code></td>
<td>
<p>Observational Dirichlet parameter if fixed (optional). The distribution is Dirichlet( <code>rep(beta, maxL)</code> ).</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_warmstart">warmstart</code>, <code id="sample_fSAN_sparsemix_+3A_nclus_start">nclus_start</code></td>
<td>
<p>Initialization of the observational clustering. 
<code>warmstart</code> is logical parameter (default = <code>TRUE</code>) of whether a kmeans clustering should be used to initialize the chains.
An initial guess of the number of observational clusters can be passed via the <code>nclus_start</code> parameter (optional)</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_mu_start">mu_start</code>, <code id="sample_fSAN_sparsemix_+3A_sigma2_start">sigma2_start</code>, <code id="sample_fSAN_sparsemix_+3A_m_start">M_start</code>, <code id="sample_fSAN_sparsemix_+3A_s_start">S_start</code>, <code id="sample_fSAN_sparsemix_+3A_alpha_start">alpha_start</code>, <code id="sample_fSAN_sparsemix_+3A_beta_start">beta_start</code></td>
<td>
<p>Starting points of the MCMC chains (optional). Default is <code>nclus_start = min(c(maxL, 30))</code>.
<code>mu_start, sigma2_start</code> are vectors of length <code>maxL</code>. 
<code>M_start</code> is a vector of observational cluster allocation of length N.
<code>S_start</code> is a vector of observational cluster allocation of length J.
<code>alpha_start, alpha_start</code> are numeric.</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_progress">progress</code></td>
<td>
<p>show a progress bar? (logical, default TRUE).</p>
</td></tr>
<tr><td><code id="sample_fSAN_sparsemix_+3A_seed">seed</code></td>
<td>
<p>set a fixed seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Data structure</strong>
</p>
<p>The overfitted mixture common atoms model is used to perform inference in nested settings, where the data are organized into <code class="reqn">J</code> groups. 
The data should be continuous observations <code class="reqn">(Y_1,\dots,Y_J)</code>, where each <code class="reqn">Y_j = (y_{1,j},\dots,y_{n_j,j})</code> 
contains the <code class="reqn">n_j</code> observations from group <code class="reqn">j</code>, for <code class="reqn">j=1,\dots,J</code>. 
The function takes as input the data as a numeric vector <code>y</code> in this concatenated form. Hence <code>y</code> should be a vector of length
<code class="reqn">n_1+\dots+n_J</code>. The <code>group</code> parameter is a numeric vector of the same size as <code>y</code> indicating the group membership for each
individual observation. 
Notice that with this specification the observations in the same group need not be contiguous as long as the correspondence between the variables
<code>y</code> and <code>group</code> is maintained.
</p>
<p><strong>Model</strong>
</p>
<p>The data are modeled using a univariate Gaussian likelihood, where both the mean and the variance are observational-cluster-specific, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">y_{i,j}\mid M_{i,j} = l \sim N(\mu_l,\sigma^2_l)</code>
</p>

<p>where <code class="reqn">M_{i,j} \in \{1,\dots,L \}</code> is the observational cluster indicator of observation <code class="reqn">i</code> in group <code class="reqn">j</code>.
The prior on the model parameters is a Normal-Inverse-Gamma distribution <code class="reqn">(\mu_l,\sigma^2_l)\sim NIG (m_0,\tau_0,\lambda_0,\gamma_0)</code>, 
i.e., <code class="reqn">\mu_l\mid\sigma^2_l \sim N(m_0, \sigma^2_l / \tau_0)</code>, <code class="reqn">1/\sigma^2_l \sim Gamma(\lambda_0, \gamma_0)</code> (shape, rate).
</p>
<p><strong>Clustering</strong>
</p>
<p>The model performs a clustering of both observations and groups. 
The clustering of groups (distributional clustering) is provided by the allocation variables <code class="reqn">S_j \in \{1,\dots,K\}</code>, with 
</p>
<p style="text-align: center;"><code class="reqn">Pr(S_j = k \mid \dots ) = \pi_k  \qquad \text{for } \: k = 1,\dots,K.</code>
</p>

<p>The distribution of the probabilities is <code class="reqn">(\pi_1,\dots,\pi_{K})\sim Dirichlet_K(\alpha,\dots,\alpha)</code>. 
</p>
<p>The clustering of observations (observational clustering) is provided by the allocation variables <code class="reqn">M_{i,j} \in \{1,\dots,L\}</code>, with
</p>
<p style="text-align: center;"><code class="reqn"> Pr(M_{i,j} = l \mid S_j = k, \dots ) = \omega_{l,k} \qquad \text{for } \: k = 1,\dots,K \, ; \: l = 1,\dots,L. </code>
</p>

<p>The distribution of the probabilities is <code class="reqn">(\omega_{1,k},\dots,\omega_{L,k})\sim Dirichlet_L(\beta,\dots,\beta)</code> for all <code class="reqn">k = 1,\dots,K</code>.
</p>


<h3>Value</h3>

<p><code>sample_fSAN_sparsemix</code> returns four objects:
</p>

<ul>
<li> <p><code>model</code>: name of the fitted model.
</p>
</li>
<li> <p><code>params</code>: list containing the data and the parameters used in the simulation. Details below.
</p>
</li>
<li> <p><code>sim</code>: list containing the simulated values (MCMC chains). Details below.
</p>
</li>
<li> <p><code>time</code>: total computation time.
</p>
</li></ul>

<p><strong>Data and parameters</strong>:
<code>params</code> is a list with the following components:
</p>

<dl>
<dt><code>nrep</code></dt><dd><p>Number of MCMC iterations.</p>
</dd>
<dt><code>y, group</code></dt><dd><p>Data and group vectors.</p>
</dd>
<dt><code>maxK, maxL</code></dt><dd><p>Maximum number of distributional and observational clusters.</p>
</dd>
<dt><code>m0, tau0, lambda0, gamma0</code></dt><dd><p>Model hyperparameters.</p>
</dd>
<dt>(<code>hyp_alpha,eps_alpha</code>) or <code>alpha</code></dt><dd><p>Either the hyperparameter on <code class="reqn">\alpha</code> and MH step size (if <code class="reqn">\alpha</code> random), or the value for <code class="reqn">\alpha</code> (if fixed).</p>
</dd>
<dt>(<code>hyp_beta,eps_beta</code>) or <code>beta</code></dt><dd><p>Either the hyperparameter on <code class="reqn">\beta</code> and MH step size (if <code class="reqn">\beta</code> random), or the value for <code class="reqn">\beta</code> (if fixed).</p>
</dd>
</dl>

<p><strong>Simulated values</strong>:
<code>sim</code> is a list with the following components:
</p>

<dl>
<dt><code>mu</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>).
Each row is a posterior sample of the mean parameter for each observational cluster <code class="reqn">(\mu_1,\dots\mu_L)</code>.</p>
</dd>
<dt><code>sigma2</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxL</code>). 
Each row is a posterior sample of the variance parameter for each observational cluster <code class="reqn">(\sigma^2_1,\dots\sigma^2_L)</code>.</p>
</dd>
<dt><code>obs_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, n), with n = <code>length(y)</code>. 
Each row is a posterior sample of the observational cluster allocation variables <code class="reqn">(M_{1,1},\dots,M_{n_J,J})</code>. </p>
</dd>
<dt><code>distr_cluster</code></dt><dd><p>Matrix of size (<code>nrep</code>, J), with J = <code>length(unique(group))</code>. 
Each row is a posterior sample of the distributional cluster allocation variables <code class="reqn">(S_1,\dots,S_J)</code>. </p>
</dd>
<dt><code>pi</code></dt><dd><p>Matrix of size (<code>nrep</code>, <code>maxK</code>). 
Each row is a posterior sample of the distributional cluster probabilities <code class="reqn">(\pi_1,\dots,\pi_{K})</code>.</p>
</dd>
<dt><code>omega</code></dt><dd><p>3-d array of size (<code>maxL</code>, <code>maxK</code>, <code>nrep</code>).
Each slice is a posterior sample of the observational cluster probabilities. 
In each slice, each column <code class="reqn">k</code> is a vector (of length <code>maxL</code>) observational cluster probabilities
<code class="reqn">(\omega_{1,k},\dots,\omega_{L,k})</code> for distributional cluster <code class="reqn">k</code>. </p>
</dd>
<dt><code>alpha</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\alpha</code>.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Vector of length <code>nrep</code> of posterior samples of the parameter <code class="reqn">\beta</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>D’Angelo, L., Canale, A., Yu, Z., and Guindani, M. (2023). 
Bayesian nonparametric analysis for the detection of spikes in noisy calcium imaging data. <em>Biometrics</em>, 79(2), 1370–1382. &lt;doi:10.1111/biom.13626&gt;
</p>
<p>Malsiner-Walli, G., Frühwirth-Schnatter, S. and Grün, B. (2016). 
Model-based clustering based on sparse finite Gaussian mixtures. Statistics and Computing 26, 303–324. &lt;doi:10.1007/s11222-014-9500-2&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
y &lt;- c(rnorm(40,0,0.3), rnorm(20,5,0.3))
g &lt;- c(rep(1,30), rep(2, 30))
plot(density(y[g==1]), xlim = c(-5,10))
lines(density(y[g==2]), col = 2)
out &lt;- sample_fSAN_sparsemix(nrep = 500, y = y, group = g, 
                             nclus_start = 2,
                             maxK = 20, maxL = 20,
                             alpha = 0.01, beta = 0.01)
out 

</code></pre>

<hr>
<h2 id='traceplot'>Traceplot: plot MCMC chains</h2><span id='topic+traceplot'></span>

<h3>Description</h3>

<p>Check the convergence of the MCMC through visual inspection of the chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot(object, params, 
          show_density = TRUE, 
          show_burnin = TRUE, 
          length_burnin = NULL, 
          show_convergence = TRUE, 
          trunc_plot = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot_+3A_object">object</code></td>
<td>
<p>object of class <code>SANmcmc</code> (the result of a call to <code><a href="#topic+sample_fiSAN">sample_fiSAN</a></code>, 
<code><a href="#topic+sample_fiSAN_sparsemix">sample_fiSAN_sparsemix</a></code>, <code><a href="#topic+sample_fSAN">sample_fSAN</a></code>, <code><a href="#topic+sample_fSAN_sparsemix">sample_fSAN_sparsemix</a></code>, or <code><a href="#topic+sample_CAM">sample_CAM</a></code>).</p>
</td></tr>
<tr><td><code id="traceplot_+3A_params">params</code></td>
<td>
<p>vector of strings with the names of the parameters to check.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_show_density">show_density</code></td>
<td>
<p>logical (default <code>TRUE</code>). Whether a kernel estimate of the density should be plotted. The burn-in is always discarded.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_show_burnin">show_burnin</code></td>
<td>
<p>logical (default <code>TRUE</code>). Whether the first part of the chains should be plotted in the traceplots.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_length_burnin">length_burnin</code></td>
<td>
<p>if <code>show_burnin = FALSE</code>, the length of the burn-in to be discarded.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_show_convergence">show_convergence</code></td>
<td>
<p>logical (default <code>TRUE</code>). Whether a superimposed red line of the cumulative mean should be plotted.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_trunc_plot">trunc_plot</code></td>
<td>
<p>integer (default = 10). For multidimensional parameters, the maximum number of components to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function displays the traceplots of the MCMC algorithm.
</p>


<h3>Note</h3>

<p>The function is not available for the observational weights <code class="reqn">\omega</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
y &lt;- c(rnorm(40,0,0.3), rnorm(20,5,0.3))
g &lt;- c(rep(1,30), rep(2, 30))
out &lt;- sample_fiSAN(nrep = 500, y = y, group = g, 
                    nclus_start = 2,
                    maxK = 20, maxL = 20,
                    beta = 1)
traceplot(out, params = c("mu", "sigma2"), trunc_plot = 2)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
