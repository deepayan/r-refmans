<!DOCTYPE html><html><head><title>Help for package expm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {expm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#balance'><p>Balance a Square Matrix via LAPACK's DGEBAL</p></a></li>
<li><a href='#expAtv'><p>Compute Matrix Exponential  exp(A t) * v  directly</p></a></li>
<li><a href='#expm'><p>Matrix Exponential</p></a></li>
<li><a href='#expm.Higham08'><p>Matrix Exponential [Higham 2008]</p></a></li>
<li><a href='#expmCond'><p>Exponential Condition Number of a Matrix</p></a></li>
<li><a href='#expmFrechet'><p>Frechet Derivative of the Matrix Exponential</p></a></li>
<li><a href='#logm'><p>Matrix Logarithm</p></a></li>
<li><a href='#matpow'><p>Matrix Power</p></a></li>
<li><a href='#matStig'><p>Stig's &quot;infamous&quot; Example Matrix</p></a></li>
<li><a href='#sqrtm'><p>Matrix Square Root</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matrix Exponential, Log, 'etc'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.999-9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-11</td>
</tr>
<tr>
<td>Contact:</td>
<td>expm-developers@lists.R-forge.R-project.org</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of the matrix exponential, logarithm, sqrt,
  and related quantities, using traditional and modern methods.</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RColorBrewer, sfsmisc, Rmpfr</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://R-Forge.R-project.org/projects/expm/">https://R-Forge.R-project.org/projects/expm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://R-forge.R-project.org/tracker/?atid=472&amp;group_id=107">https://R-forge.R-project.org/tracker/?atid=472&amp;group_id=107</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 09:19:42 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Christophe Dutang <a href="https://orcid.org/0000-0001-6732-1501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Vincent Goulet <a href="https://orcid.org/0000-0002-9315-5719"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Douglas Bates [ctb] (cosmetic clean up, in svn r42),
  David Firth [ctb] (expm(method= "PadeO" and "TaylorO")),
  Marina Shapira [ctb] (expm(method= "PadeO" and "TaylorO")),
  Michael Stadelmann [ctb] ("Higham08*" methods, see ?expm.Higham08...)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-11 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='balance'>Balance a Square Matrix via LAPACK's DGEBAL</h2><span id='topic+balance'></span><span id='topic+dgebal'></span>

<h3>Description</h3>

<p>Balance a square matrix via LAPACK's <code>DGEBAL</code>.
This is an <span class="rlang"><b>R</b></span> interface, mainly used for experimentation.
</p>
<p>This LAPACK routine is used internally for Eigenvalue decompositions,
but also, in Ward(1977)'s algorithm for the matrix exponential.
</p>
<p>The name <code>balance()</code> is preferred nowadays, and &ldquo;dgebal()&rdquo;
has been deprecated (finally, after 9 years ...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance(A, job = c("B", "N", "P", "S"))
## Deprecated now:
##   dgebal(A, job = c("B", "N", "P", "S"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance_+3A_a">A</code></td>
<td>
<p>a square (<code class="reqn">n\times n</code>) numeric matrix.</p>
</td></tr>
<tr><td><code id="balance_+3A_job">job</code></td>
<td>
<p>a one-letter string specifying the &lsquo;job&rsquo; for DGEBAL.
</p>

<dl>
<dt>P</dt><dd><p><b>P</b>ermutation</p>
</dd>
<dt>S</dt><dd><p><b>S</b>caling</p>
</dd>
<dt>B</dt><dd><p><b>B</b>oth permutation and scaling</p>
</dd>
<dt>N</dt><dd><p><b>N</b>one</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>An excerpt of the LAPACK documentation about DGEBAL(), describing the
result
</p>

<dl>
<dt>i1 (&quot;ILO&quot;)</dt><dd><p>(output) integer</p>
</dd>
<dt>i2 (&quot;IHI&quot;)</dt><dd><p>(output) integer<br />
<code>i1</code> and <code>i2</code> are set to integers such that on exit
<code>z[i,j] = 0</code> if <code class="reqn">i &gt; j</code> and <code class="reqn">j = 1,...,i1-1</code> or <code class="reqn">i = i2+1,...,n</code>.
</p>
<p>If <code>job = 'N'</code> or <code>'S'</code>, <code>i1 = 1</code> and <code>i2 = n</code>.</p>
</dd>
<dt>scale</dt><dd><p>(output) numeric vector of length <code>n</code>.
Details of the permutations and scaling factors applied to
<code>A</code>.  If <code>P[j]</code> is the index of the row and column interchanged
with row and column <code>j</code> and <code>D[j]</code> is the scaling factor
applied to row and column j, then
<code>scale[j] = P[j]</code> for <code class="reqn">j = 1,...,i1-1</code><br />
<code>         = D[j]</code> for <code class="reqn">j = i1,...,i2</code>,<br />
<code>         = P[j]</code> for <code class="reqn">j = i2+1,...,n</code>.
</p>
<p>The order in which the interchanges are made is <code>n</code> to <code>i2+1</code>,
then <code>1</code> to <code>i1-1</code>.</p>
</dd>
</dl>

<p>Look at the LAPACK documentation for more details.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>the transformation of matrix <code>A</code>, after permutation and
or scaling.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>numeric vector of length <code class="reqn">n</code>, containing the
permutation and/or scale vectors applied.</p>
</td></tr>
<tr><td><code>i1</code>, <code>i2</code></td>
<td>
<p>integers (length 1) in <code class="reqn">\{1,2,\dots,n\}</code>, denoted by
<code>ILO</code> and <code>IHI</code> respectively in the LAPACK
documentation.  Only relevant for <code>"P"</code> or <code>"B"</code>, they
describe where permutations and where scaling took place; see the
Details section.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>LAPACK Reference Manual
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code>, <code><a href="#topic+expm">expm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m4 &lt;- rbind(c(-1,-1, 0, 0),
            c( 0, 0,10,10),
            c( 0, 0,10, 0),
            c( 0,10, 0, 0))
(b4 &lt;- balance(m4))

## --- for testing and didactical reasons : ----
if(expm:::doExtras()) withAutoprint({
    sessionInfo()
    packageDescription("Matrix")
    "expm installed at"
    dirname(attr(packageDescription("expm"), "file"))
})

demo(balanceTst) # also defines the balanceTst() function
                # which in its tests ``defines'' what
                # the return value means, notably (i1,i2,scale)
</code></pre>

<hr>
<h2 id='expAtv'>Compute Matrix Exponential  exp(A t) * v  directly</h2><span id='topic+expAtv'></span><span id='topic+expmv'></span>

<h3>Description</h3>

<p>Compute <code class="reqn">\exp(A t) * v</code> directly, without  evaluating <code class="reqn">\exp(A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expAtv(A, v, t = 1,
       method = "Sidje98",
       rescaleBelow = 1e-6,
       tol = 1e-07, btol = 1e-07, m.max = 30, mxrej = 10,
       verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expAtv_+3A_a">A</code></td>
<td>
<p>n x n matrix</p>
</td></tr>
<tr><td><code id="expAtv_+3A_v">v</code></td>
<td>
<p>n - vector</p>
</td></tr>
<tr><td><code id="expAtv_+3A_t">t</code></td>
<td>
<p>number (scalar);</p>
</td></tr>
<tr><td><code id="expAtv_+3A_method">method</code></td>
<td>
<p>a string indicating the method to be used; there's only
one currently; we would like to add newer ones.</p>
</td></tr>
<tr><td><code id="expAtv_+3A_rescalebelow">rescaleBelow</code></td>
<td>
<p>if <code><a href="base.html#topic+norm">norm</a>(A,"I")</code> is smaller than <code>rescaleBelow</code>,
rescale <code>A</code> to norm 1 and <code>t</code> such that <code class="reqn">A t</code> remains
unchanged.  This step is in addition to Sidje's original algorithm
and easily seen to be necessary even in simple cases (e.g., <code class="reqn">n = 3</code>).</p>
</td></tr>
<tr><td><code id="expAtv_+3A_tol">tol</code>, <code id="expAtv_+3A_btol">btol</code></td>
<td>
<p>tolerances; these are tuning constants of the
&quot;Sidje1998&quot; method which the user should typically <em>not</em> change.</p>
</td></tr>
<tr><td><code id="expAtv_+3A_m.max">m.max</code>, <code id="expAtv_+3A_mxrej">mxrej</code></td>
<td>
<p>integer constants you should only change if you know what you're doing</p>
</td></tr>
<tr><td><code id="expAtv_+3A_verbose">verbose</code></td>
<td>
<p>flag indicating if the algorithm should be verbose..</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>eAtv</code></td>
<td>
<p>.....fixme...</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ravi Varadhan, Johns Hopkins University;
Martin Maechler (cosmetic, generalization to sparse matrices;
rescaling (see <code>rescaleBelow</code>).
</p>


<h3>References</h3>

<p>Roger B. Sidje (1998)
EXPOKIT: Software Package for Computing Matrix Exponentials.
<em>ACM - Transactions On Mathematical Software</em> <b>24</b>(1), 130&ndash;156.
</p>
<p>((NOT yet available!))<br />
Al-Mohy, A. and Higham, N. (2011).
Computing the Action of the Matrix Exponential, with an Application
to Exponential Integrators.
<em>SIAM Journal on Scientific Computing</em>, <b>33</b>(2), 488&ndash;511.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expm">expm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
source(system.file("demo", "exact-fn.R", package = "expm"))
##-&gt; rnilMat() ; xct10
set.seed(1)
(s5 &lt;- Matrix(m5 &lt;- rnilMat(5))); v &lt;- c(1,6:9)
(em5 &lt;- expm(m5))
r5  &lt;- expAtv(m5, v)
r5. &lt;- expAtv(s5, v)
stopifnot(all.equal(r5, r5., tolerance = 1e-14),
          all.equal(c(em5 %*% v), r5$eAtv))

v &lt;- 10:1
with(xct10, all.equal(expm(m), expm))
all.equal(c(xct10$expm %*% v),
          expAtv(xct10$m, v)$eAtv)
</code></pre>

<hr>
<h2 id='expm'>Matrix Exponential</h2><span id='topic+expm'></span><span id='topic+mexp'></span>

<h3>Description</h3>

<p>This function computes the exponential of a square matrix
<code class="reqn">A</code>, defined as the sum from <code class="reqn">r=0</code> to infinity of
<code class="reqn">A^r/r!</code>.
Several methods are provided. The Taylor series and Padé
approximation are very importantly combined with scaling and squaring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expm(x, method = c("Higham08.b", "Higham08",
                   "AlMohy-Hi09",
                   "Ward77", "PadeRBS", "Pade", "Taylor", "PadeO", "TaylorO",
                   "R_Eigen", "R_Pade", "R_Ward77", "hybrid_Eigen_Ward"),
     order = 8, trySym = TRUE, tol = .Machine$double.eps, do.sparseMsg = TRUE,
     preconditioning = c("2bal", "1bal", "buggy"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expm_+3A_x">x</code></td>
<td>
<p>a square matrix.</p>
</td></tr>
<tr><td><code id="expm_+3A_method">method</code></td>
<td>
<p><code>"Higham08.b"</code>, <code>"Ward77"</code>, <code>"Pade"</code> or
<code>"Taylor"</code>, etc;
The default is now <code>"Higham08.b"</code> which uses Higham's 2008
algorithm with <em>additional</em> balancing preconditioning,
see <code><a href="#topic+expm.Higham08">expm.Higham08</a></code>.
</p>
<p>The versions with &quot;*O&quot; call the
original Fortran code, whereas the first ones call the BLAS-using
and partly simplified newer code.<br />
<code>"R_Pade"</code> uses an <span class="rlang"><b>R</b></span>-code version of <code>"Pade"</code> for
didactical reasons, and<br />
<code>"R_Ward77"</code> uses an <span class="rlang"><b>R</b></span> version of <code>"Ward77"</code>, still based
on LAPACK's <code>dgebal</code>, see <span class="rlang"><b>R</b></span> interface <code><a href="#topic+dgebal">dgebal</a></code>.
This has enabled us to diagnose and fix the bug in the original
octave implementation of <code>"Ward77"</code>.
<code>"R_Eigen"</code> tries to diagonalise the matrix <code>x</code>, if not possible,
<code>"R_Eigen"</code> raises an error. <code>"hybrid_Eigen_Ward"</code> method also
tries to diagonalise the matrix <code>x</code>, if not possible, it uses
<code>"Ward77"</code> algorithm.
</p>
</td></tr>
<tr><td><code id="expm_+3A_order">order</code></td>
<td>
<p>an integer, the order of approximation to be used, for
the &quot;Pade&quot; and &quot;Taylor&quot; methods.  The best value for this depends on
machine precision (and slightly on <code>x</code>) but for the current
double precision arithmetic, one recommendation (and the Matlab
implementations) uses <code>order = 6</code> unconditionally;<br />
our default, <code>8</code>, is from Ward(1977, p.606)'s recommendation,
but also used for <code>"AlMohy-Hi09"</code> where a high order
<code>order=12</code> may be more appropriate (and slightly more expensive).</p>
</td></tr>
<tr><td><code id="expm_+3A_trysym">trySym</code></td>
<td>
<p>logical indicating if <code>method = "R_Eigen"</code> should use
<code><a href="base.html#topic+isSymmetric">isSymmetric</a>(x)</code> and take advantage for (almost)
symmetric matrices.</p>
</td></tr>
<tr><td><code id="expm_+3A_tol">tol</code></td>
<td>
<p>a given tolerance used to check if <code>x</code> is
computationally singular when <code>method = "hybrid_Eigen_Ward"</code>.</p>
</td></tr>
<tr><td><code id="expm_+3A_do.sparsemsg">do.sparseMsg</code></td>
<td>
<p>logical allowing a message about sparse to dense
coercion; setting it <code>FALSE</code> suppresses that message.</p>
</td></tr>
<tr><td><code id="expm_+3A_preconditioning">preconditioning</code></td>
<td>
<p>a string specifying which implementation of
Ward(1977) should be used when <code>method = "Ward77"</code>.

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential of a matrix is defined as the infinite Taylor series
</p>
<p style="text-align: center;"><code class="reqn">e^M = \sum_{k = 1}^\infty \frac{M^k}{k!}.</code>
</p>

<p>For the &quot;Pade&quot; and &quot;Taylor&quot; methods, there is an <code>"accuracy"</code>
attribute of the result.  It is an upper bound for the L2 norm of the
Cauchy error <code>expm(x, *, order + 10) - expm(x, *, order)</code>.
</p>
<p>Currently, only algorithms which are <em>&ldquo;<span class="rlang"><b>R</b></span>-code only&rdquo;</em> accept <em>sparse</em>
matrices (see the
<code><a href="Matrix.html#topic+sparseMatrix-class">sparseMatrix</a></code> class in package
<span class="pkg">Matrix</span>), i.e., currently only <code>"R_Eigen"</code> and
<code>"Higham08"</code>.
</p>


<h3>Value</h3>

<p>The matrix exponential of <code>x</code>.
</p>


<h3>Note</h3>

<p>For a good general discussion of the matrix exponential
problem, see Moler and van Loan (2003).
</p>


<h3>Author(s)</h3>

<p>The <code>"Ward77"</code> method:<br />
Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a>, and Christophe
Dutang, based on code translated by Doug Bates and Martin Maechler
from the implementation of the corresponding Octave function
contributed by A. Scottedward Hodel <a href="mailto:A.S.Hodel@eng.auburn.edu">A.S.Hodel@eng.auburn.edu</a>.
</p>
<p>The <code>"PadeRBS"</code> method:<br />
Roger B. Sidje, see the EXPOKIT reference.
</p>
<p>The <code>"PadeO"</code> and  <code>"TaylorO"</code> methods:<br />
Marina Shapira (U Oxford, UK) and David Firth (U Warwick, UK);
</p>
<p>The <code>"Pade"</code> and  <code>"Taylor"</code> methods are slight
modifications of the &quot;*O&quot; ([O]riginal versions) methods,
by Martin Maechler, using BLAS and LINPACK where possible.
</p>
<p>The <code>"hybrid_Eigen_Ward"</code> method by Christophe Dutang is a C
translation of <code>"R_Eigen"</code> method by Martin Maechler.
</p>
<p>The <code>"Higham08"</code> and <code>"Higham08.b"</code> (current default) were
written by Michael Stadelmann, see <code><a href="#topic+expm.Higham08">expm.Higham08</a></code>.
</p>
<p>The <code>"AlMohy-Hi09"</code> implementation (<span class="rlang"><b>R</b></span> code interfacing to
stand-alone C) was provided and donated by Drew Schmidt, U. Tennesse.
</p>


<h3>References</h3>

<p>Ward, R. C. (1977).  Numerical computation
of the matrix exponential with accuracy estimate.
<em>SIAM J. Num. Anal.</em> <b>14</b>, 600&ndash;610.
</p>
<p>Roger B. Sidje (1998).
EXPOKIT: Software package for computing matrix exponentials.
ACM - Transactions on Mathematical Software <b>24</b>(1), 130&ndash;156.
</p>
<p>Moler, C and van Loan, C (2003).  Nineteen dubious ways to compute
the exponential of a matrix, twenty-five years later.
<em>SIAM Review</em> <b>45</b>, 3&ndash;49.  At
<a href="https://doi.org/10.1137/S00361445024180">doi:10.1137/S00361445024180</a>
</p>
<p>Awad H. Al-Mohy and Nicholas J. Higham (2009)
A New Scaling and Squaring Algorithm for the Matrix Exponential.
<em>SIAM. J. Matrix Anal. &amp; Appl.</em>, <b>31</b>(3), 970&ndash;989.
</p>


<h3>See Also</h3>

<p>The package vignette for details on the algorithms and calling the
function from external packages.
</p>
<p><code><a href="#topic+expm.Higham08">expm.Higham08</a></code> for <code>"Higham08"</code>.
</p>
<p><code><a href="#topic+expAtv">expAtv</a>(A,v,t)</code> computes <code class="reqn">e^{At} v</code> (for scalar
<code class="reqn">t</code> and <code class="reqn">n</code>-vector <code class="reqn">v</code>) <em>directly</em> and more
efficiently than computing <code class="reqn">e^{At}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(-49, -64, 24, 31), 2, 2)
expm(x)
expm(x, method = "AlMohy-Hi09")
## ----------------------------
## Test case 1 from Ward (1977)
## ----------------------------
test1 &lt;- t(matrix(c(
    4, 2, 0,
    1, 4, 1,
    1, 1, 4), 3, 3))
expm(test1, method="Pade")
## Results on Power Mac G3 under Mac OS 10.2.8
##                    [,1]               [,2]               [,3]
## [1,] 147.86662244637000 183.76513864636857  71.79703239999643
## [2,] 127.78108552318250 183.76513864636877  91.88256932318409
## [3,] 127.78108552318204 163.67960172318047 111.96810624637124
## -- these agree with ward (1977, p608)

## Compare with the naive "R_Eigen" method:
try(
expm(test1, method="R_Eigen")
) ## platform depently, sometimes gives an error from solve
## or is accurate or one older result was
##                   [,1]                [,2]               [,3]
##[1,] 147.86662244637003  88.500223574029647 103.39983337000028
##[2,] 127.78108552318220 117.345806155250600  90.70416537273444
##[3,] 127.78108552318226  90.384173332156763 117.66579819582827
## -- hopelessly inaccurate in all but the first column.
##
## ----------------------------
## Test case 2 from Ward (1977)
## ----------------------------
test2 &lt;- t(matrix(c(
    29.87942128909879, .7815750847907159, -2.289519314033932,
    .7815750847907159, 25.72656945571064,  8.680737820540137,
   -2.289519314033932, 8.680737820540137,  34.39400925519054),
           3, 3))
expm(test2, method="Pade")
##                   [,1]               [,2]               [,3]
##[1,]   5496313853692357 -18231880972009844 -30475770808580828
##[2,] -18231880972009852  60605228702227024 101291842930256144
##[3,] -30475770808580840 101291842930256144 169294411240859072
## -- which agrees with Ward (1977) to 13 significant figures
expm(test2, method="R_Eigen")
##                   [,1]               [,2]               [,3]
##[1,]   5496313853692405 -18231880972009100 -30475770808580196
##[2,] -18231880972009160  60605228702221760 101291842930249376
##[3,] -30475770808580244 101291842930249200 169294411240850880
## -- in this case a very similar degree of accuracy.
##
## ----------------------------
## Test case 3 from Ward (1977)
## ----------------------------
test3 &lt;- t(matrix(c(
    -131, 19, 18,
    -390, 56, 54,
    -387, 57, 52), 3, 3))
expm(test3, method="Pade")
##                    [,1]                [,2]                [,3]
##[1,] -1.5096441587713636 0.36787943910439874 0.13533528117301735
##[2,] -5.6325707997970271 1.47151775847745725 0.40600584351567010
##[3,] -4.9349383260294299 1.10363831731417195 0.54134112675653534
## -- agrees to 10dp with Ward (1977), p608.
expm(test3, method="R_Eigen")
##                   [,1]               [,2]                [,3]
##[1,] -1.509644158796182 0.3678794391103086 0.13533528117547022
##[2,] -5.632570799902948 1.4715177585023838 0.40600584352641989
##[3,] -4.934938326098410 1.1036383173309319 0.54134112676302582
## -- in this case, a similar level of agreement with Ward (1977).
##
## ----------------------------
## Test case 4 from Ward (1977)
## ----------------------------
test4 &lt;-
    structure(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 1e-10,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 1, 0),
    .Dim = c(10, 10))
attributes(expm(test4, method="Pade"))
max(abs(expm(test4, method="Pade") - expm(test4, method="R_Eigen")))
##[1] 8.746826694186494e-08
## -- here mexp2 is accurate only to 7 d.p., whereas mexp
##    is correct to at least 14 d.p.
##
## Note that these results are achieved with the default
## settings order=8, method="Pade" -- accuracy could
## presumably be improved still further by some tuning
## of these settings.

##
## example of computationally singular matrix
##
m &lt;- matrix(c(0,1,0,0), 2,2)
try(
expm(m, m="R_Eigen")
)
## error since m is computationally singular
expm(m, m="hybrid")
## hybrid use the Ward77 method
</code></pre>

<hr>
<h2 id='expm.Higham08'>Matrix Exponential [Higham 2008]</h2><span id='topic+expm.Higham08'></span>

<h3>Description</h3>

<p>Calculation of matrix exponential <code class="reqn">e^A</code> with the &lsquo;Scaling &amp;
Squaring&rsquo; method with balancing.
</p>
<p>Implementation of Higham's Algorithm from his book (see references),
Chapter 10, Algorithm 10.20.
</p>
<p>The balancing option is an extra from Michael Stadelmann's Masters thesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expm.Higham08(A, balancing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expm.Higham08_+3A_a">A</code></td>
<td>
<p>square matrix, may be a <code>"<a href="Matrix.html#topic+sparseMatrix-class">sparseMatrix</a>"</code>,
currently only if <code>balancing</code> is false.</p>
</td></tr>
<tr><td><code id="expm.Higham08_+3A_balancing">balancing</code></td>
<td>
<p>logical indicating if balancing should happen (before
and after scaling and squaring).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm comprises the following steps
</p>

<dl>
<dt>0.</dt><dd><p>Balancing</p>
</dd>
<dt>1.</dt><dd><p>Scaling</p>
</dd>
<dt>2.</dt><dd><p>Padé-Approximation</p>
</dd>
<dt>3.</dt><dd><p>Squaring</p>
</dd>
<dt>4.</dt><dd><p>Reverse Balancing</p>
</dd>
</dl>



<h3>Value</h3>

<p>a matrix of the same dimension as <code>A</code>, the matrix exponential of <code>A</code>.
</p>


<h3>Note</h3>

<p><code>expm.Higham8()</code> no longer needs to be called directly; rather
<code>expm(A, "Higham8b")</code> and <code>expm(A, "Higham8")</code> correspond to
the two options of <code>balancing = TRUE || FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Stadelmann (final polish by Martin Maechler).
</p>


<h3>References</h3>

<p>Higham, Nicholas J. (2008).
<em>Functions of Matrices: Theory and Computation</em>;
SIAM (Society for Industrial and Applied Mathematics), Philadelphia, USA;
<a href="https://doi.org/10.1137/1.9780898717778">doi:10.1137/1.9780898717778</a>
</p>
<p>Michael Stadelmann (2009).
<em>Matrixfunktionen; Analyse und Implementierung</em>.
[in German] Master's thesis and Research Report 2009-12, SAM, ETH Zurich;
<a href="https://math.ethz.ch/sam/research/reports.html?year=2009">https://math.ethz.ch/sam/research/reports.html?year=2009</a>, or the
pdf directly at
<a href="https://www.sam.math.ethz.ch/sam_reports/reports_final/reports2009/2009-12.pdf">https://www.sam.math.ethz.ch/sam_reports/reports_final/reports2009/2009-12.pdf</a>.
</p>


<h3>See Also</h3>

<p>The other algorithms <code><a href="#topic+expm">expm</a>(x, method = *)</code>.
</p>
<p><code><a href="#topic+expmCond">expmCond</a></code>, to compute the exponential-<em>condition</em> number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The *same* examples as in ../expm.Rd  {FIXME} --
x &lt;- matrix(c(-49, -64, 24, 31), 2, 2)
expm.Higham08(x)

## ----------------------------
## Test case 1 from Ward (1977)
## ----------------------------
test1 &lt;- t(matrix(c(
    4, 2, 0,
    1, 4, 1,
    1, 1, 4), 3, 3))
expm.Higham08(test1)
##                    [,1]               [,2]               [,3]
## [1,] 147.86662244637000 183.76513864636857  71.79703239999643
## [2,] 127.78108552318250 183.76513864636877  91.88256932318409
## [3,] 127.78108552318204 163.67960172318047 111.96810624637124
## -- these agree with ward (1977, p608)


## ----------------------------
## Test case 2 from Ward (1977)
## ----------------------------
test2 &lt;- t(matrix(c(
    29.87942128909879, .7815750847907159, -2.289519314033932,
    .7815750847907159, 25.72656945571064,  8.680737820540137,
   -2.289519314033932, 8.680737820540137,  34.39400925519054),
           3, 3))
expm.Higham08(test2)
expm.Higham08(test2, balancing = FALSE)
##                   [,1]               [,2]               [,3]
##[1,]   5496313853692405 -18231880972009100 -30475770808580196
##[2,] -18231880972009160  60605228702221760 101291842930249376
##[3,] -30475770808580244 101291842930249200 169294411240850880
## -- in this case a very similar degree of accuracy.

## ----------------------------
## Test case 3 from Ward (1977)
## ----------------------------
test3 &lt;- t(matrix(c(
    -131, 19, 18,
    -390, 56, 54,
    -387, 57, 52), 3, 3))
expm.Higham08(test3)
expm.Higham08(test3, balancing = FALSE)
##                    [,1]                [,2]                [,3]
##[1,] -1.5096441587713636 0.36787943910439874 0.13533528117301735
##[2,] -5.6325707997970271 1.47151775847745725 0.40600584351567010
##[3,] -4.9349383260294299 1.10363831731417195 0.54134112675653534
## -- agrees to 10dp with Ward (1977), p608. ??? (FIXME)

## ----------------------------
## Test case 4 from Ward (1977)
## ----------------------------
test4 &lt;-
    structure(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 1e-10,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 1, 0),
    .Dim = c(10, 10))

E4 &lt;- expm.Higham08(test4)
Matrix(zapsmall(E4))

S4 &lt;- as(test4, "sparseMatrix") # some R based expm() methods work for sparse:
ES4 &lt;- expm.Higham08(S4, bal=FALSE)
stopifnot(all.equal(E4, unname(as.matrix(ES4))))
## NOTE: Need much larger sparse matrices for sparse arith to be faster!

##
## example of computationally singular matrix
##
m &lt;- matrix(c(0,1,0,0), 2,2)
eS &lt;- expm.Higham08(m)  # "works"  (hmm ...)
</code></pre>

<hr>
<h2 id='expmCond'>Exponential Condition Number of a Matrix</h2><span id='topic+expmCond'></span>

<h3>Description</h3>

<p>Compute the exponential condition number of a matrix, either with
approximation methods, or exactly and very slowly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expmCond(A, method = c("1.est", "F.est", "exact"),
         expm = TRUE, abstol = 0.1, reltol = 1e-6,
         give.exact = c("both", "1.norm", "F.norm"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expmCond_+3A_a">A</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="expmCond_+3A_method">method</code></td>
<td>
<p>a string; either compute 1-norm or F-norm
<em>approximations</em>, or compte these <em>exactly</em>.</p>
</td></tr>
<tr><td><code id="expmCond_+3A_expm">expm</code></td>
<td>
<p>logical indicating if the matrix exponential itself, which
is computed anyway, should be returned as well.</p>
</td></tr>
<tr><td><code id="expmCond_+3A_abstol">abstol</code>, <code id="expmCond_+3A_reltol">reltol</code></td>
<td>
<p>for <code>method = "F.est"</code>, numerical <code class="reqn">\ge 0</code>,
as <em>absolute</em> and <em>relative</em> error tolerance.</p>
</td></tr>
<tr><td><code id="expmCond_+3A_give.exact">give.exact</code></td>
<td>
<p>for <code>method = "exact"</code>, specify if only the
1-norm, the Frobenius norm, or both are to be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method = "exact"</code>, aka Kronecker-Sylvester algorithm, computes a
Kronecker matrix of dimension <code class="reqn">n^2 \times n^2</code> and
hence, with <code class="reqn">O(n^5)</code> complexity, is prohibitely slow for
non-small <code class="reqn">n</code>.  It computes the <em>exact</em> exponential-condition
numbers for both the Frobenius and/or the 1-norm, depending on
<code>give.exact</code>.
</p>
<p>The two other methods compute approximations, to these norms, i.e.,
<b>est</b>imate them, using algorithms from Higham, chapt.~3.4, both
with complexity <code class="reqn">O(n^3)</code>.
</p>



<h3>Value</h3>

<p>when <code>expm = TRUE</code>, for <code>method = "exact"</code>, a
<code><a href="base.html#topic+list">list</a></code> with components
</p>
<table>
<tr><td><code>expm</code></td>
<td>
<p>containing the matrix exponential, <code><a href="#topic+expm.Higham08">expm.Higham08</a>(A)</code>.</p>
</td></tr>
<tr><td><code>expmCond(F|1)</code></td>
<td>
<p>numeric scalar, (an approximation to) the (matrix
exponential) condition number, for either the 1-norm
(<code>expmCond1</code>) or the Frobenius-norm (<code>expmCondF</code>).</p>
</td></tr>
</table>
<p>When <code>expm</code> is false and <code>method</code> one of the approximations
(<code>"*.est"</code>), the condition number is returned directly (i.e.,
<code><a href="base.html#topic+numeric">numeric</a></code> of length one).
</p>


<h3>Author(s)</h3>

<p>Michael Stadelmann (final polish by Martin Maechler).
</p>


<h3>References</h3>

<p>Awad H. Al-Mohy and Nicholas J. Higham (2009).
<em>Computing Fréchet Derivative of the Matrix Exponential, with an application
to Condition Number Estimation</em>; MIMS EPrint 2008.26; Manchester
Institute for Mathematical Sciences, U. Manchester, UK.
<a href="https://eprints.maths.manchester.ac.uk/1218/01/covered/MIMS_ep2008_26.pdf">https://eprints.maths.manchester.ac.uk/1218/01/covered/MIMS_ep2008_26.pdf</a>
</p>
<p>Higham, N.~J. (2008).
<em>Functions of Matrices: Theory and Computation</em>;
Society for Industrial and Applied Mathematics, Philadelphia, PA, USA.
</p>
<p>Michael Stadelmann (2009) <em>Matrixfunktionen</em> ...
Master's thesis; see reference in <code><a href="#topic+expm.Higham08">expm.Higham08</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expm.Higham08">expm.Higham08</a></code> for the matrix exponential.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
(A &lt;- matrix(round(rnorm(3^2),1), 3,3))

eA &lt;- expm.Higham08(A)
stopifnot(all.equal(eA, expm::expm(A), tolerance= 1e-15))

C1 &lt;- expmCond(A, "exact")
C2 &lt;- expmCond(A, "1.est")
C3 &lt;- expmCond(A, "F.est")
all.equal(C1$expmCond1, C2$expmCond, tolerance= 1e-15)# TRUE
all.equal(C1$expmCondF, C3$expmCond)# relative difference of 0.001...
</code></pre>

<hr>
<h2 id='expmFrechet'>Frechet Derivative of the Matrix Exponential</h2><span id='topic+expmFrechet'></span>

<h3>Description</h3>

<p>Compute the Frechet (actually &lsquo;Fréchet&rsquo;) derivative of the
matrix exponential operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expmFrechet(A, E, method = c("SPS", "blockEnlarge"), expm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expmFrechet_+3A_a">A</code></td>
<td>
<p>square matrix (<code class="reqn">n \times n</code>).</p>
</td></tr>
<tr><td><code id="expmFrechet_+3A_e">E</code></td>
<td>
<p>the &ldquo;small Error&rdquo; matrix,
used in <code class="reqn">L(A,E) = f(A + E, A)</code></p>
</td></tr>
<tr><td><code id="expmFrechet_+3A_method">method</code></td>
<td>
<p>string specifying the method / algorithm; the default
<code>"SPS"</code> is &ldquo;Scaling + Pade + Squaring&rdquo; as in the
algorithm 6.4 below; otherwise see the &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="expmFrechet_+3A_expm">expm</code></td>
<td>
<p>logical indicating if the matrix exponential itself, which
is computed anyway, should be returned as well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of <code class="reqn">e^A</code> and the Exponential Frechet-Derivative
<code class="reqn">L(A,E)</code>.
</p>
<p>When <code>method = "SPS"</code> (by default), the
with the Scaling - Padé - Squaring Method is used, in
an R-Implementation of Al-Mohy and Higham (2009)'s Algorithm 6.4.
</p>

<dl>
<dt>Step 1:</dt><dd><p>Scaling (of A and E)</p>
</dd>
<dt>Step 2:</dt><dd><p>Padé-Approximation of <code class="reqn">e^A</code> and <code class="reqn">L(A,E)</code></p>
</dd>
<dt>Step 3:</dt><dd><p>Squaring (reversing step 1)</p>
</dd>
</dl>

<p><code>method = "blockEnlarge"</code> uses the matrix identity of

</p>
<p style="text-align: center;"><code class="reqn">f([A E ; 0 A ]) = [f(A) Df(A); 0 f(A)]</code>
</p>
<p> for the <code class="reqn">2n \times
    2n</code> block matrices where <code class="reqn">f(A) := expm(A)</code> and
<code class="reqn">Df(A) := L(A,E)</code>.  Note that <code>"blockEnlarge"</code> is much
simpler to implement but slower (CPU time is doubled for <code class="reqn">n = 100</code>).
</p>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>expm</code></td>
<td>
<p>if <code>expm</code> is true, the matrix exponential
(<code class="reqn">n \times n</code> matrix).</p>
</td></tr>
<tr><td><code>Lexpm</code></td>
<td>
<p>the Exponential-Frechet-Derivative <code class="reqn">L(A,E)</code>, a matrix
of the same dimension.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Stadelmann (final polish by Martin Maechler).</p>


<h3>References</h3>

<p>see <code><a href="#topic+expmCond">expmCond</a></code>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+expm.Higham08">expm.Higham08</a></code> for the matrix exponential.
<code><a href="#topic+expmCond">expmCond</a></code> for exponential condition number computations
which are based on <code>expmFrechet</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(A &lt;- cbind(1, 2:3, 5:8, c(9,1,5,3)))
E &lt;- matrix(1e-3, 4,4)
(L.AE &lt;- expmFrechet(A, E))
all.equal(L.AE, expmFrechet(A, E, "block"), tolerance = 1e-14) ## TRUE
</code></pre>

<hr>
<h2 id='logm'>Matrix Logarithm</h2><span id='topic+logm'></span>

<h3>Description</h3>

<p>This function computes the (principal) matrix logarithm of a square matrix.
A logarithm of a matrix <code class="reqn">A</code> is <code class="reqn">L</code> such that <code class="reqn">A= e^L</code>
(meaning <code>A == expm(L)</code>), see the documentation for the matrix
exponential, <code><a href="#topic+expm">expm</a></code>, which can be defined
as </p>
<p style="text-align: center;"><code class="reqn">e^L := \sum_{r=0}^\infty L^r/r! .</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>logm(x, method = c("Higham08", "Eigen"),
     tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logm_+3A_x">x</code></td>
<td>
<p>a square matrix.</p>
</td></tr>
<tr><td><code id="logm_+3A_method">method</code></td>
<td>
<p>a string specifying the algorithmic method to be used.
The default uses the algorithm by Higham(2008).
</p>
<p>The simple <code>"Eigen"</code> method tries to diagonalise the matrix
<code>x</code>; if that is not possible, it raises an error.
</p>
</td></tr>
<tr><td><code id="logm_+3A_tol">tol</code></td>
<td>
<p>a given tolerance used to check if <code>x</code> is
computationally singular when <code>method = "Eigen"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The exponential of a matrix is defined as the infinite Taylor series
</p>
<p style="text-align: center;"><code class="reqn">e^M = \sum_{k = 1}^\infty \frac{M^k}{k!}.</code>
</p>

<p>The matrix logarithm of <code class="reqn">A</code> is a matrix <code class="reqn">M</code> such that
<code class="reqn">exp(M) = A</code>. Note that there typically are an infinite number
number of such matrices, and we compute the <em>prinicipal</em> matrix
logarithm, see the references.
</p>
<p>Method <code>"Higham08"</code> works via &ldquo;<em>inverse</em> scaling and
squaring&rdquo;, and from the Schur decomposition, applying a matrix
square root computation.  It is somewhat slow but also works for
non-diagonalizable matrices.
</p>


<h3>Value</h3>

<p>A matrix &lsquo;as <code>x</code>&rsquo; with the matrix logarithm of <code>x</code>,
i.e., <code>all.equal( expm(logm(x)), x, tol)</code> is typically true for
quite small tolerance <code>tol</code>.
</p>


<h3>Author(s)</h3>

<p>Method <code>"Higham08"</code> was implemented by Michael Stadelmann as part of his
master thesis in mathematics, at ETH Zurich;
the <code>"Eigen"</code> method by Christophe Dutang.
</p>


<h3>References</h3>

<p>Higham, N.~J. (2008).
<em>Functions of Matrices: Theory and Computation</em>;
Society for Industrial and Applied Mathematics, Philadelphia, PA, USA.
</p>
<p>The Matrix Logarithm is very nicely defined by Wikipedia,
<a href="https://en.wikipedia.org/wiki/Matrix_logarithm">https://en.wikipedia.org/wiki/Matrix_logarithm</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expm">expm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- diag(2)
logm(m)
expm(logm(m))

## Here, logm() is barely defined, and Higham08 has needed an amendment
## in order for not to loop forever:
D0 &lt;- diag(x=c(1, 0.))
(L. &lt;- logm(D0))
stopifnot( all.equal(D0, expm(L.)) )

## A matrix for which clearly no logm(.) exists:
(m &lt;- cbind(1:2, 1))
(l.m &lt;- try(logm(m))) ## all NA {Warning in sqrt(S[ij, ij]) : NaNs produced}
## on r-patched-solaris-x86, additionally gives
##    Error in solve.default(X[ii, ii] + X[ij, ij], S[ii, ij] - sumU) :
##     system is computationally singular: reciprocal condition number = 0
##    Calls: logm ... logm.Higham08 -&gt; rootS -&gt; solve -&gt; solve -&gt; solve.default
if(!inherits(l.m, "try-error")) stopifnot(is.na(l.m))
## The "Eigen" method  ``works''  but wrongly :
expm(logm(m, "Eigen"))
</code></pre>

<hr>
<h2 id='matpow'>Matrix Power</h2><span id='topic++25+5E+25'></span><span id='topic+matpow'></span>

<h3>Description</h3>

<p>Compute the <code class="reqn">k</code>-th power of a matrix. Whereas <code>x^k</code> computes
<em>element wise</em> powers, <code>x %^% k</code> corresponds to <code class="reqn">k -
  1</code> matrix multiplications, <code>x %*% x %*% ... %*% x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %^% k
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matpow_+3A_x">x</code></td>
<td>
<p>a square <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="matpow_+3A_k">k</code></td>
<td>
<p>an integer, <code class="reqn">k \ge 0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code class="reqn">k</code> is coerced to integer using <code><a href="base.html#topic+as.integer">as.integer</a></code>.
</p>
<p>The algorithm uses <code class="reqn">O(log_2(k))</code> matrix
multiplications.
</p>


<h3>Value</h3>

<p>A matrix of the same dimension as <code>x</code>.
</p>


<h3>Note</h3>

<p>If you think you need <code>x^k</code> for <code class="reqn">k &lt; 0</code>, then consider
instead <code>solve(x %^% (-k))</code>.
</p>


<h3>Author(s)</h3>

<p>Based on an R-help posting of Vicente Canto Casasola, and
Vincent Goulet's C implementation in <span class="pkg">actuar</span>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic++25+2A+25">%*%</a></code> for matrix multiplication.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- cbind(1, 2 * diag(3)[,-1])
A
A %^% 2
stopifnot(identical(A, A %^% 1),
          A %^% 2 == A %*% A)
</code></pre>

<hr>
<h2 id='matStig'>Stig's &quot;infamous&quot; Example Matrix</h2><span id='topic+matStig'></span>

<h3>Description</h3>

<p>Stig Mortensen wrote on Oct 22, 2007 to the authors of the <span class="pkg">Matrix</span>
package with subject &ldquo;Strange result from expm&rdquo;.
There, he presented the following <code class="reqn">8 \times 8</code> matrix for
which the Matrix <code>expm()</code> gave a &ldquo;strange&rdquo; result.
As we later researched, the result indeed was wrong: the correct
entries were wrongly permuted.  The reason has been in the underlying
source code in Octave from which it had been ported to <span class="pkg">Matrix</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(matStig)</code></pre>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(matStig)

as(matStig, "sparseMatrix") # since that prints more nicely.

## For more compact printing:
op &lt;- options(digits = 4)

E1 &lt;- expm(matStig, "Ward77", preconditioning="buggy") # the wrong result
as(E1, "sparseMatrix")
str(E2 &lt;- expm(matStig, "Pade"))# the correct one (has "accuracy" attribute)
as(E2, "sparseMatrix")
attr(E2,"accuracy") &lt;- NULL   # don't want it below
E3 &lt;- expm(matStig, "R_Eigen")  # even that is fine here
all.equal(E1,E2) # not at all equal (rel.difference &gt;~= 1.)
stopifnot(all.equal(E3,E2)) # ==

##________ The "proof" that "Ward77" is wrong _________
M &lt;- matStig
Et1 &lt;- expm(t(M), "Ward77", precond= "buggy")
Et2 &lt;- expm(t(M), "Pade"); attr(Et2,"accuracy") &lt;- NULL
all.equal(Et1, t(E1)) # completely different (rel.diff ~ 1.7 (platform dep.))
stopifnot(all.equal(Et2, t(E2))) # the same (up to tolerance)

options(op)
</code></pre>

<hr>
<h2 id='sqrtm'>Matrix Square Root</h2><span id='topic+sqrtm'></span>

<h3>Description</h3>

<p>This function computes the matrix square root of a square matrix.
The sqrt of a matrix <code class="reqn">A</code> is <code class="reqn">S</code> such that <code class="reqn">A = S S</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrtm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrtm_+3A_x">x</code></td>
<td>
<p>a square matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix square root <code class="reqn">S</code> of <code class="reqn">M</code>, <code class="reqn">S = sqrtm(M)</code> is
defined as one (the &ldquo;principal&rdquo;) <code class="reqn">S</code> such that
<code class="reqn">S S = S^2 = M</code>, (in <span class="rlang"><b>R</b></span>, <code>all.equal( S %*% S , M )</code>).
</p>
<p>The method works from the Schur decomposition.
</p>


<h3>Value</h3>

<p>A matrix &lsquo;as <code>x</code>&rsquo; with the matrix sqrt of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Stadelmann wrote the first version.
</p>


<h3>References</h3>

<p>Higham, N.~J. (2008).
<em>Functions of Matrices: Theory and Computation</em>;
Society for Industrial and Applied Mathematics, Philadelphia, PA, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expm">expm</a></code>, <code><a href="#topic+logm">logm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- diag(2)
sqrtm(m) == m # TRUE

(m &lt;- rbind(cbind(1, diag(1:3)),2))
sm &lt;- sqrtm(m)
sm
zapsmall(sm %*% sm) # Zap entries ~= 2e-16
stopifnot(all.equal(m, sm %*% sm))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
