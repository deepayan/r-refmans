<!DOCTYPE html><html lang="en"><head><title>Help for package CFtime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CFtime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CFtime-package'><p>CFtime: working with CF Metadata Conventions &quot;time&quot; dimensions</p></a></li>
<li><a href='#+2B.CFTime'><p>Extend a CFTime object</p></a></li>
<li><a href='#+3D+3D.CFTime'><p>Equivalence of CFTime objects</p></a></li>
<li><a href='#as_timestamp'><p>Create a vector that represents CF timestamps</p></a></li>
<li><a href='#as.character.CFTime'><p>Return the timestamps contained in the <code>CFTime</code> instance.</p></a></li>
<li><a href='#bounds'><p>Bounds of the time offsets</p></a></li>
<li><a href='#CFCalendar'><p>Basic CF calendar</p></a></li>
<li><a href='#CFCalendar360'><p>360-day CF calendar</p></a></li>
<li><a href='#CFCalendar365'><p>365-day CF calendar</p></a></li>
<li><a href='#CFCalendar366'><p>366-day CF calendar</p></a></li>
<li><a href='#CFCalendarJulian'><p>Julian CF calendar</p></a></li>
<li><a href='#CFCalendarProleptic'><p>Proleptic Gregorian CF calendar</p></a></li>
<li><a href='#CFCalendarStandard'><p>Standard CF calendar</p></a></li>
<li><a href='#CFCalendarTAI'><p>International Atomic Time CF calendar</p></a></li>
<li><a href='#CFCalendarUTC'><p>Coordinated Universal Time CF calendar</p></a></li>
<li><a href='#CFfactor'><p>Create a factor from the offsets in a <code>CFTime</code> instance</p></a></li>
<li><a href='#CFfactor_coverage'><p>Coverage of time elements for each factor level</p></a></li>
<li><a href='#CFfactor_units'><p>Number of base time units in each factor level</p></a></li>
<li><a href='#CFTime'><p>CFTime class</p></a></li>
<li><a href='#CFtime-function'><p>Create a CFTime object</p></a></li>
<li><a href='#cut.CFTime'><p>Create a factor for a <code>CFTime</code> instance</p></a></li>
<li><a href='#definition'><p>Properties of a CFTime object</p></a></li>
<li><a href='#deprecated_functions'><p>Deprecated functions</p></a></li>
<li><a href='#indexOf'><p>Find the index of timestamps in the time series</p></a></li>
<li><a href='#is_complete'><p>Indicates if the time series is complete</p></a></li>
<li><a href='#length.CFTime'><p>The length of the offsets contained in the <code>CFTime</code> instance.</p></a></li>
<li><a href='#month_days'><p>Return the number of days in a month given a certain CF calendar</p></a></li>
<li><a href='#parse_timestamps'><p>Parse series of timestamps in CF format to date-time elements</p></a></li>
<li><a href='#range.CFTime'><p>Extreme time series values</p></a></li>
<li><a href='#slab'><p>Which time steps fall within two extreme values</p></a></li>
<li><a href='#slice'><p>Which time steps fall within two extreme values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Using CF-Compliant Calendars with Climate Projection Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Support for all calendars as specified in the Climate and Forecast 
    (CF) Metadata Conventions for climate and forecasting data. The CF Metadata 
    Conventions is widely used for distributing files with climate observations 
    or projections, including the Coupled Model Intercomparison Project (CMIP) 
    data used by climate change scientists and the Intergovernmental Panel on
    Climate Change (IPCC). This package specifically allows the user to work 
    with any of the CF-compliant calendars (many of which are not compliant with 
    POSIXt). The CF time coordinate is formally defined in the CF Metadata 
    Conventions document available at <a href="https://cfconventions.org/Data/cf-conventions/cf-conventions-1.12/cf-conventions.html#time-coordinate">https://cfconventions.org/Data/cf-conventions/cf-conventions-1.12/cf-conventions.html#time-coordinate</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ncdfCF, testthat (&ge; 3.0.0), stringr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pvanlaake/CFtime">https://github.com/pvanlaake/CFtime</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pvanlaake/CFtime/issues">https://github.com/pvanlaake/CFtime/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'api.R' 'CFCalendar.R' 'CFCalendar360.R' 'CFCalendar365.R'
'CFCalendar366.R' 'CFCalendarJulian.R' 'CFCalendarProleptic.R'
'CFCalendarStandard.R' 'CFCalendarTAI.R' 'CFCalendarUTC.R'
'CFtime-package.R' 'CFtime.R' 'deprecated.R' 'helpers.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-03 21:03:24 UTC; patrickvanlaake</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Van Laake [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Van Laake &lt;patrick@vanlaake.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-03 22:30:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='CFtime-package'>CFtime: working with CF Metadata Conventions &quot;time&quot; dimensions</h2><span id='topic+CFtime-package'></span>

<h3>Description</h3>

<p>Support for all calendars as specified in the Climate and Forecast
(CF) Metadata Conventions for climate and forecasting data. The CF Metadata
Conventions is widely used for distributing files with climate observations
or projections, including the Coupled Model Intercomparison Project (CMIP)
data used by climate change scientists and the Intergovernmental Panel on
Climate Change (IPCC). This package specifically allows the user to work
with any of the CF-compliant calendars (many of which are not compliant with
POSIXt). The CF time coordinate is formally defined in the
<a href="https://cfconventions.org/Data/cf-conventions/cf-conventions-1.12/cf-conventions.html#time-coordinate">CF Metadata Conventions document</a>.
</p>


<h3>Details</h3>

<p>The package can create a <a href="#topic+CFTime">CFTime</a> instance from scratch or, more commonly, it
can use the dimension attributes and dimension variable values from a netCDF
resource. The package does not actually do any of the reading and the user is
free to use their netCDF package of preference. The recommended package to
use (with any netCDF resources) is <a href="https://cran.r-project.org/package=ncdfCF">ncdfCF</a>.
<code>ncdfCF</code> will automatically use this package to manage the &quot;time&quot; dimension
of any netCDF resource. As with this package, it reads and interprets the
attributes of the resource to apply the CF Metadata Conventions, supporting
axes, auxiliary coordinate variables, coordinate reference systems, etc.
Alternatively, for more basic netCDF reading and writing, the two main options
are <a href="https://cran.r-project.org/package=RNetCDF">RNetCDF</a> and
<a href="https://cran.r-project.org/package=ncdf4">ncdf4</a>).
</p>
<p><strong>Create, modify, inquire</strong>
</p>

<ul>
<li> <p><code><a href="#topic+CFtime">CFtime()</a></code>: Create a <a href="#topic+CFTime">CFTime</a> instance
</p>
</li>
<li> <p><code><a href="#topic+properties">Properties</a></code> of the <code>CFTime</code> instance
</p>
</li>
<li> <p><code><a href="#topic+parse_timestamps">parse_timestamps()</a></code>: Parse a vector of character timestamps into <code>CFTime</code> elements
</p>
</li>
<li> <p><code><a href="#topic+CFtime-equivalent">Compare</a></code> two <code>CFTime</code> instances
</p>
</li>
<li> <p><code><a href="#topic+CFtime-merge">Merge</a></code> two <code>CFTime</code> instances or append additional time steps to a <code>CFTime</code> instance
</p>
</li>
<li> <p><code><a href="#topic+as_timestamp">as_timestamp()</a></code> and <code><a href="base.html#topic+format">format()</a></code>: Generate a vector of character or <code>POSIXct</code> timestamps from a <code>CFTime</code> instance
</p>
</li>
<li> <p><code><a href="base.html#topic+range">range()</a></code>: Timestamps of the two endpoints in the time series
</p>
</li>
<li> <p><code><a href="#topic+is_complete">is_complete()</a></code>: Does the <code>CFTime</code> instance have a complete time series between endpoints?
</p>
</li>
<li> <p><code><a href="#topic+month_days">month_days()</a></code>: How many days are there in a month using the calendar of the <code>CFTime</code> instance?
</p>
</li></ul>

<p><strong>Factors and coverage</strong>
</p>

<ul>
<li> <p><code><a href="#topic+CFfactor">CFfactor()</a></code> and <code><a href="#topic+cut">cut()</a></code>: Create factors for different time periods
</p>
</li>
<li> <p><code><a href="#topic+CFfactor_units">CFfactor_units()</a></code>: How many units of time are there in each factor level?
</p>
</li>
<li> <p><code><a href="#topic+CFfactor_coverage">CFfactor_coverage()</a></code>: How much data is available for each level of the factor?
</p>
</li></ul>

<p><strong>Filtering and selection</strong>
</p>

<ul>
<li> <p><code><a href="#topic+slab">slab()</a></code>: Logical vector of time steps between two extreme points.
</p>
</li>
<li> <p><code><a href="#topic+indexOf">indexOf()</a></code>: Index values in the time series of given timestamps, possibly with
fractional part for interpolation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Patrick Van Laake <a href="mailto:patrick@vanlaake.net">patrick@vanlaake.net</a> [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/pvanlaake/CFtime">https://github.com/pvanlaake/CFtime</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pvanlaake/CFtime/issues">https://github.com/pvanlaake/CFtime/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+2B.CFTime'>Extend a CFTime object</h2><span id='topic++2B.CFTime'></span><span id='topic+CFtime-merge'></span>

<h3>Description</h3>

<p>A <a href="#topic+CFTime">CFTime</a> instance can be extended with this operator, using values from
another <code>CFTime</code> instance, or a vector of numeric offsets or character
timestamps. If the values come from another <code>CFTime</code> instance, the calendars
of the two instances must be compatible If the calendars of the <code>CFTime</code>
instances are not compatible, an error is thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CFTime'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B2B.CFTime_+3A_e1">e1</code></td>
<td>
<p>Instance of the <code>CFTime</code> class.</p>
</td></tr>
<tr><td><code id="+2B2B.CFTime_+3A_e2">e2</code></td>
<td>
<p>Instance of the <code>CFTime</code> class with a calendar compatible with that
of argument <code>e1</code>, or a numeric vector with offsets from the origin of
argument <code>e1</code>, or a vector of <code>character</code> timestamps in ISO8601 or UDUNITS
format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting <code>CFTime</code> instance will have the offsets of the original
<code>CFTime</code> instance, appended with offsets from argument <code>e2</code> in the order that
they are specified. If the new sequence of offsets is not monotonically
increasing a warning is generated (the COARDS metadata convention requires
offsets to be monotonically increasing).
</p>
<p>There is no reordering or removal of duplicates. This is because the time
series are usually associated with a data set and the correspondence between
the data in the files and the <code>CFTime</code> instance is thus preserved. When
merging the data sets described by this time series, the order must be
identical to the merging here.
</p>
<p>Note that when adding multiple vectors of offsets to a <code>CFTime</code> instance, it
is more efficient to first concatenate the vectors and then do a final
addition to the <code>CFTime</code> instance. So avoid
<code>CFtime(definition, calendar, e1) + CFtime(definition, calendar, e2) + CFtime(definition, calendar, e3) + ...</code>
but rather do <code>CFtime(definition, calendar) + c(e1, e2, e3, ...)</code>. It is the
responsibility of the operator to ensure that the offsets of the different
data sets are in reference to the same calendar.
</p>
<p>Note also that <code>RNetCDF</code> and <code>ncdf4</code> packages both return the values of the
&quot;time&quot; dimension as a 1-dimensional array. You have to <code>dim(time_values) &lt;- NULL</code> to de-class the array to a vector before adding offsets to an existing
<code>CFtime</code> instance.
</p>
<p>Any bounds that were set will be removed. Use <code><a href="#topic+bounds">bounds()</a></code> to retrieve the
bounds of the individual <code>CFTime</code> instances and then set them again after
merging the two instances.
</p>


<h3>Value</h3>

<p>A <code>CFTime</code> object with the offsets of argument <code>e1</code> extended by the
values from argument <code>e2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- CFtime("days since 1850-01-01", "gregorian", 0:364)
e2 &lt;- CFtime("days since 1850-01-01 00:00:00", "standard", 365:729)
e1 + e2
</code></pre>

<hr>
<h2 id='+3D+3D.CFTime'>Equivalence of CFTime objects</h2><span id='topic++3D+3D.CFTime'></span><span id='topic+CFtime-equivalent'></span>

<h3>Description</h3>

<p>This operator can be used to test if two <a href="#topic+CFTime">CFTime</a> objects represent the same
CF-convention time coordinates. Two <code>CFTime</code> objects are considered equivalent
if they have an equivalent calendar and the same offsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CFTime'
e1 == e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B3D+2B3D.CFTime_+3A_e1">e1</code>, <code id="+2B3D+2B3D.CFTime_+3A_e2">e2</code></td>
<td>
<p>Instances of the <code>CFTime</code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the <code>CFTime</code> objects are equivalent, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- CFtime("days since 1850-01-01", "gregorian", 0:364)
e2 &lt;- CFtime("days since 1850-01-01 00:00:00", "standard", 0:364)
e1 == e2
</code></pre>

<hr>
<h2 id='as_timestamp'>Create a vector that represents CF timestamps</h2><span id='topic+as_timestamp'></span>

<h3>Description</h3>

<p>This function generates a vector of character strings or <code>POSIXct</code>s that
represent the date and time in a selectable combination for each offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_timestamp(t, format = NULL, asPOSIX = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_timestamp_+3A_t">t</code></td>
<td>
<p>The <code>CFTime</code> instance that contains the offsets to use.</p>
</td></tr>
<tr><td><code id="as_timestamp_+3A_format">format</code></td>
<td>
<p>character. A character string with either of the values &quot;date&quot;
or &quot;timestamp&quot;. If the argument is not specified, the format used is
&quot;timestamp&quot; if there is time information, &quot;date&quot; otherwise.</p>
</td></tr>
<tr><td><code id="as_timestamp_+3A_asposix">asPOSIX</code></td>
<td>
<p>logical. If <code>TRUE</code>, for &quot;standard&quot;, &quot;gregorian&quot; and
&quot;proleptic_gregorian&quot; calendars the output is a vector of <code>POSIXct</code> - for
other calendars an error will be thrown. Default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The character strings use the format <code style="white-space: pre;">&#8288;YYYY-MM-DDThh:mm:ssÂ±hhmm&#8288;</code>, depending on
the <code>format</code> specifier. The date in the string is not necessarily compatible
with <code>POSIXt</code> - in the <code style="white-space: pre;">&#8288;360_day&#8288;</code> calendar <code>2017-02-30</code> is valid and
<code>2017-03-31</code> is not.
</p>
<p>For the &quot;proleptic_gregorian&quot; calendar the output can also be generated as a
vector of <code>POSIXct</code> values by specifying <code>asPOSIX = TRUE</code>. The same is
possible for the &quot;standard&quot; and &quot;gregorian&quot; calendars but only if all
timestamps fall on or after 1582-10-15.
</p>


<h3>Value</h3>

<p>A character vector where each element represents a moment in time
according to the <code>format</code> specifier.
</p>


<h3>See Also</h3>

<p>The <a href="#topic+CFTime">CFTime</a> <code>format()</code> method gives greater flexibility through
the use of <code>strptime</code>-like format specifiers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("hours since 2020-01-01", "standard", seq(0, 24, by = 0.25))
as_timestamp(t, "timestamp")

t2 &lt;- CFtime("days since 2002-01-21", "standard", 0:20)
tail(as_timestamp(t2, asPOSIX = TRUE))

tail(as_timestamp(t2))

tail(as_timestamp(t2 + 1.5))
</code></pre>

<hr>
<h2 id='as.character.CFTime'>Return the timestamps contained in the <code>CFTime</code> instance.</h2><span id='topic+as.character.CFTime'></span>

<h3>Description</h3>

<p>Return the timestamps contained in the <code>CFTime</code> instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CFTime'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character.CFTime_+3A_x">x</code></td>
<td>
<p>The <code>CFTime</code> instance whose timestamps will be returned.</p>
</td></tr>
<tr><td><code id="as.character.CFTime_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The timestamps in the specified <code>CFTime</code> instance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("days since 1850-01-01", "julian", 0:364)
as.character(t)
</code></pre>

<hr>
<h2 id='bounds'>Bounds of the time offsets</h2><span id='topic+bounds'></span><span id='topic+bounds+3C-'></span>

<h3>Description</h3>

<p>CF-compliant netCDF files store time information as a single offset value for
each step along the dimension, typically centered on the valid interval of
the data (e.g. 12-noon for day data). Optionally, the lower and upper values
of the valid interval are stored in a so-called &quot;bounds&quot; variable, as an
array with two rows (lower and higher value) and a column for each offset.
With function <code style="white-space: pre;">&#8288;bounds()&lt;-&#8288;</code> those bounds can be set for a <code>CFTime</code> instance.
The bounds can be retrieved with the <code>bounds()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounds(x, format)

bounds(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bounds_+3A_x">x</code></td>
<td>
<p>A <code>CFTime</code> instance.</p>
</td></tr>
<tr><td><code id="bounds_+3A_format">format</code></td>
<td>
<p>Optional. A single string with format specifiers, see
<code><a href="base.html#topic+format">format()</a></code> for details.</p>
</td></tr>
<tr><td><code id="bounds_+3A_value">value</code></td>
<td>
<p>A <code>matrix</code> (or <code>array</code>) with dimensions (2, length(offsets))
giving the lower (first row) and higher (second row) bounds of each offset
(this is the format that the CF Metadata Conventions uses for storage in
netCDF files). Use <code>FALSE</code> to unset any previously set bounds, <code>TRUE</code> to
set regular bounds at mid-points between the offsets (which must be regular
as well).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If bounds have been set, an array of bounds values with dimensions
(2, length(offsets)). The first row gives the lower bound, the second row
the upper bound, with each column representing an offset of <code>x</code>. If the
<code>format</code> argument is specified, the bounds values are returned as strings
according to the format. <code>NULL</code> when no bounds have been set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("days since 2024-01-01", "standard", seq(0.5, by = 1, length.out = 366))
as_timestamp(t)[1:3]
bounds(t) &lt;- rbind(0:365, 1:366)
bounds(t)[, 1:3]
bounds(t, "%d-%b-%Y")[, 1:3]
</code></pre>

<hr>
<h2 id='CFCalendar'>Basic CF calendar</h2><span id='topic+CFCalendar'></span>

<h3>Description</h3>

<p>This class represents a basic CF calendar. It should not be
instantiated directly; instead, use one of the descendant classes.
</p>
<p>This internal class stores the information to represent date and time
values using the CF conventions. An instance is created by the exported
<a href="#topic+CFTime">CFTime</a> class, which also exposes the relevant properties of this class.
</p>
<p>The following calendars are supported:
</p>

<ul>
<li> <p><code><a href="#topic+CFCalendarStandard">gregorian\standard</a></code>, the international standard calendar for civil use.
</p>
</li>
<li> <p><code><a href="#topic+CFCalendarProleptic">proleptic_gregorian</a></code>, the standard calendar but extending before 1582-10-15
when the Gregorian calendar was adopted.
</p>
</li>
<li> <p><code><a href="#topic+CFCalendarTAI">tai</a></code>, International Atomic Time clock with dates expressed using the Gregorian calendar.
</p>
</li>
<li> <p><code><a href="#topic+CFCalendarUTC">utc</a></code>, Coordinated Universal Time clock with dates expressed using the Gregorian calendar.
</p>
</li>
<li> <p><code><a href="#topic+CFCalendarJulian">julian</a></code>, every fourth year is a leap year (so including the years 1700, 1800, 1900, 2100, etc).
</p>
</li>
<li> <p><code><a href="#topic+CFCalendar365">noleap\365_day</a></code>, all years have 365 days.
</p>
</li>
<li> <p><code><a href="#topic+CFCalendar366">all_leap\366_day</a></code>, all years have 366 days.
</p>
</li>
<li> <p><code><a href="#topic+CFCalendar360">360_day</a></code>, all years have 360 days, divided over 12 months of 30 days.
</p>
</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>name</code></dt><dd><p>Descriptive name of the calendar, as per the CF Metadata
Conventions.</p>
</dd>
<dt><code>definition</code></dt><dd><p>The string that defines the units and the origin, as
per the CF Metadata Conventions.</p>
</dd>
<dt><code>unit</code></dt><dd><p>The numeric id of the unit of the calendar.</p>
</dd>
<dt><code>origin</code></dt><dd><p><code>data.frame</code> with fields for the origin of the calendar.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>origin_date</code></dt><dd><p>(read-only) Character string with the date of the
calendar.</p>
</dd>
<dt><code>origin_time</code></dt><dd><p>(read-only) Character string with the time of the
calendar.</p>
</dd>
<dt><code>timezone</code></dt><dd><p>(read-only) Character string with the time zone of the
origin of the calendar.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFCalendar-new"><code>CFCalendar$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar-print"><code>CFCalendar$print()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar-valid_days"><code>CFCalendar$valid_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar-POSIX_compatible"><code>CFCalendar$POSIX_compatible()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar-is_compatible"><code>CFCalendar$is_compatible()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar-is_equivalent"><code>CFCalendar$is_equivalent()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar-parse"><code>CFCalendar$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar-offsets2time"><code>CFCalendar$offsets2time()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar-clone"><code>CFCalendar$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CFCalendar-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new CF calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar$new(nm, definition)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nm</code></dt><dd><p>The name of the calendar. This must follow the CF Metadata
Conventions.</p>
</dd>
<dt><code>definition</code></dt><dd><p>The string that defines the units and the origin, as
per the CF Metadata Conventions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CFCalendar-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print information about the calendar to the console.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Ignored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code>, invisibly.
</p>


<hr>
<a id="method-CFCalendar-valid_days"></a>



<h4>Method <code>valid_days()</code></h4>

<p>Indicate which of the supplied dates are valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar$valid_days(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>NULL</code>. A warning will be generated to the effect that a
descendant class should be used for this method.
</p>


<hr>
<a id="method-CFCalendar-POSIX_compatible"></a>



<h4>Method <code>POSIX_compatible()</code></h4>

<p>Indicate if the time series described using this calendar
can be safely converted to a standard date-time type (<code>POSIXct</code>,
<code>POSIXlt</code>, <code>Date</code>).
</p>
<p>Only the 'standard' calendar and the 'proleptic_gregorian' calendar
when all dates in the time series are more recent than 1582-10-15
(inclusive) can be safely converted, so this method returns <code>FALSE</code> by
default to cover the majority of cases.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar$POSIX_compatible(offsets)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>offsets</code></dt><dd><p>The offsets from the CFtime instance.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>FALSE</code> by default.
</p>


<hr>
<a id="method-CFCalendar-is_compatible"></a>



<h4>Method <code>is_compatible()</code></h4>

<p>This method tests if the <code>CFCalendar</code> instance in argument
<code>cal</code> is compatible with <code>self</code>, meaning that they are of the same
class and have the same unit. Calendars &quot;standard&quot;, and &quot;gregorian&quot; are
compatible, as are the pairs of &quot;365_day&quot; and &quot;no_leap&quot;, and &quot;366_day&quot;
and &quot;all_leap&quot;.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar$is_compatible(cal)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cal</code></dt><dd><p>Instance of a descendant of the <code>CFCalendar</code> class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> if the instance in argument <code>cal</code> is compatible with
<code>self</code>, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-CFCalendar-is_equivalent"></a>



<h4>Method <code>is_equivalent()</code></h4>

<p>This method tests if the <code>CFCalendar</code> instance in argument
<code>cal</code> is equivalent to <code>self</code>, meaning that they are of the same class,
have the same unit, and equivalent origins. Calendars &quot;standard&quot;, and
&quot;gregorian&quot; are equivalent, as are the pairs of &quot;365_day&quot; and
&quot;no_leap&quot;, and &quot;366_day&quot; and &quot;all_leap&quot;.
</p>
<p>Note that the origins need not be identical, but their parsed values
have to be. &quot;2000-01&quot; is parsed the same as &quot;2000-01-01 00:00:00&quot;, for
instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar$is_equivalent(cal)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cal</code></dt><dd><p>Instance of a descendant of the <code>CFCalendar</code> class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> if the instance in argument <code>cal</code> is equivalent to
<code>self</code>, <code>FALSE</code> otherwise.
</p>


<hr>
<a id="method-CFCalendar-parse"></a>



<h4>Method <code>parse()</code></h4>

<p>Parsing a vector of date-time character strings into parts.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar$parse(d)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>d</code></dt><dd><p>character. A character vector of date-times.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns year, month, day, hour, minute,
second, time zone, and offset. Invalid input data will appear as <code>NA</code>.
</p>


<hr>
<a id="method-CFCalendar-offsets2time"></a>



<h4>Method <code>offsets2time()</code></h4>

<p>Decompose a vector of offsets, in units of the calendar, to
their timestamp values. This adds a specified amount of time to the
origin of a <code>CFTime</code> object.
</p>
<p>This method may introduce inaccuracies where the calendar unit is
&quot;months&quot; or &quot;years&quot;, due to the ambiguous definition of these units.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar$offsets2time(offsets = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>offsets</code></dt><dd><p>Vector of numeric offsets to add to the origin of the
calendar.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns for the timestamp elements and as
many rows as there are offsets.
</p>


<hr>
<a id="method-CFCalendar-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://cfconventions.org/Data/cf-conventions/cf-conventions-1.12/cf-conventions.html#calendar
</p>

<hr>
<h2 id='CFCalendar360'>360-day CF calendar</h2><span id='topic+CFCalendar360'></span>

<h3>Description</h3>

<p>This class represents a CF calendar of 360 days per year, evenly
divided over 12 months of 30 days. This calendar is obviously not
compatible with the standard POSIXt calendar.
</p>
<p>This calendar supports dates before year 1 and includes the year 0.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CFCalendar">CFtime::CFCalendar</a></code> -&gt; <code>CFCalendar360</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFCalendar360-new"><code>CFCalendar360$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar360-valid_days"><code>CFCalendar360$valid_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar360-month_days"><code>CFCalendar360$month_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar360-leap_year"><code>CFCalendar360$leap_year()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar360-date2offset"><code>CFCalendar360$date2offset()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar360-offset2date"><code>CFCalendar360$offset2date()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar360-clone"><code>CFCalendar360$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="POSIX_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-POSIX_compatible'><code>CFtime::CFCalendar$POSIX_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_compatible'><code>CFtime::CFCalendar$is_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_equivalent"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_equivalent'><code>CFtime::CFCalendar$is_equivalent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="offsets2time"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-offsets2time'><code>CFtime::CFCalendar$offsets2time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="parse"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-parse'><code>CFtime::CFCalendar$parse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="print"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-print'><code>CFtime::CFCalendar$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CFCalendar360-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new CF calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar360$new(nm, definition)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nm</code></dt><dd><p>The name of the calendar. This must be &quot;360_day&quot;. This argument
is superfluous but maintained to be consistent with the initialization
methods of the parent and sibling classes.</p>
</dd>
<dt><code>definition</code></dt><dd><p>The string that defines the units and the origin, as
per the CF Metadata Conventions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new instance of this class.
</p>


<hr>
<a id="method-CFCalendar360-valid_days"></a>



<h4>Method <code>valid_days()</code></h4>

<p>Indicate which of the supplied dates are valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar360$valid_days(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>ymd</code> has rows
with <code>TRUE</code> for valid days and <code>FALSE</code> for invalid days, or <code>NA</code> where
the row in argument <code>ymd</code> has <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendar360-month_days"></a>



<h4>Method <code>month_days()</code></h4>

<p>Determine the number of days in the month of the calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar360$month_days(ymd = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector indicating the number of days in each month for the
dates supplied as argument <code>ymd</code>. If no dates are supplied, the number
of days per month for the calendar as a vector of length 12.
</p>


<hr>
<a id="method-CFCalendar360-leap_year"></a>



<h4>Method <code>leap_year()</code></h4>

<p>Indicate which years are leap years.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar360$leap_year(yr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>yr</code></dt><dd><p>Integer vector of years to test.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>yr</code>. Since this
calendar does not use leap days, all values will be <code>FALSE</code>, or <code>NA</code>
where argument <code>yr</code> is <code>NA</code>.
</p>


<hr>
<a id="method-CFCalendar360-date2offset"></a>



<h4>Method <code>date2offset()</code></h4>

<p>Calculate difference in days between a <code>data.frame</code> of time
parts and the origin.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar360$date2offset(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>data.frame</code>. Dates to calculate the difference for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector of a length equal to the number of rows in
argument <code>x</code> indicating the number of days between <code>x</code> and the <code>origin</code>,
or <code>NA</code> for rows in <code>x</code> with <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendar360-offset2date"></a>



<h4>Method <code>offset2date()</code></h4>

<p>Calculate date parts from day differences from the origin.
This only deals with days as these are impacted by the calendar.
Hour-minute-second timestamp parts are handled in <a href="#topic+CFCalendar">CFCalendar</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar360$offset2date(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Integer vector of days to add to the origin.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns 'year', 'month' and 'day' and as many
rows as the length of vector <code>x</code>.
</p>


<hr>
<a id="method-CFCalendar360-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar360$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CFCalendar365'>365-day CF calendar</h2><span id='topic+CFCalendar365'></span>

<h3>Description</h3>

<p>This class represents a CF calendar of 365 days per year, having
no leap days in any year. This calendar is not compatible with the standard
POSIXt calendar.
</p>
<p>This calendar supports dates before year 1 and includes the year 0.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CFCalendar">CFtime::CFCalendar</a></code> -&gt; <code>CFCalendar365</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFCalendar365-new"><code>CFCalendar365$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar365-valid_days"><code>CFCalendar365$valid_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar365-month_days"><code>CFCalendar365$month_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar365-leap_year"><code>CFCalendar365$leap_year()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar365-date2offset"><code>CFCalendar365$date2offset()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar365-offset2date"><code>CFCalendar365$offset2date()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar365-clone"><code>CFCalendar365$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="POSIX_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-POSIX_compatible'><code>CFtime::CFCalendar$POSIX_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_compatible'><code>CFtime::CFCalendar$is_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_equivalent"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_equivalent'><code>CFtime::CFCalendar$is_equivalent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="offsets2time"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-offsets2time'><code>CFtime::CFCalendar$offsets2time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="parse"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-parse'><code>CFtime::CFCalendar$parse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="print"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-print'><code>CFtime::CFCalendar$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CFCalendar365-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new CF calendar of 365 days per year.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar365$new(nm, definition)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nm</code></dt><dd><p>The name of the calendar. This must be &quot;365_day&quot; or &quot;noleap&quot;.</p>
</dd>
<dt><code>definition</code></dt><dd><p>The string that defines the units and the origin, as
per the CF Metadata Conventions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new instance of this class.
</p>


<hr>
<a id="method-CFCalendar365-valid_days"></a>



<h4>Method <code>valid_days()</code></h4>

<p>Indicate which of the supplied dates are valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar365$valid_days(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>ymd</code> has rows
with <code>TRUE</code> for valid days and <code>FALSE</code> for invalid days, or <code>NA</code> where
the row in argument <code>ymd</code> has <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendar365-month_days"></a>



<h4>Method <code>month_days()</code></h4>

<p>Determine the number of days in the month of the calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar365$month_days(ymd = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code>, optional, with dates parsed into their parts.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector indicating the number of days in each month for the
dates supplied as argument <code>ymd</code>. If no dates are supplied, the number
of days per month for the calendar as a vector of length 12.
</p>


<hr>
<a id="method-CFCalendar365-leap_year"></a>



<h4>Method <code>leap_year()</code></h4>

<p>Indicate which years are leap years.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar365$leap_year(yr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>yr</code></dt><dd><p>Integer vector of years to test.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>yr</code>. Since this
calendar does not use leap days, all values will be <code>FALSE</code>, or <code>NA</code>
where argument <code>yr</code> is <code>NA</code>.
</p>


<hr>
<a id="method-CFCalendar365-date2offset"></a>



<h4>Method <code>date2offset()</code></h4>

<p>Calculate difference in days between a <code>data.frame</code> of time
parts and the origin.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar365$date2offset(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>data.frame</code>. Dates to calculate the difference for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector of a length equal to the number of rows in
argument <code>x</code> indicating the number of days between <code>x</code> and the <code>origin</code>,
or <code>NA</code> for rows in <code>x</code> with <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendar365-offset2date"></a>



<h4>Method <code>offset2date()</code></h4>

<p>Calculate date parts from day differences from the origin. This
only deals with days as these are impacted by the calendar.
Hour-minute-second timestamp parts are handled in <a href="#topic+CFCalendar">CFCalendar</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar365$offset2date(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Integer vector of days to add to the origin.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns 'year', 'month' and 'day' and as many
rows as the length of vector <code>x</code>.
</p>


<hr>
<a id="method-CFCalendar365-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar365$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CFCalendar366'>366-day CF calendar</h2><span id='topic+CFCalendar366'></span>

<h3>Description</h3>

<p>This class represents a CF calendar of 366 days per year, having
leap days in every year. This calendar is not compatible with the standard
POSIXt calendar.
</p>
<p>This calendar supports dates before year 1 and includes the year 0.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CFCalendar">CFtime::CFCalendar</a></code> -&gt; <code>CFCalendar366</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFCalendar366-new"><code>CFCalendar366$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar366-valid_days"><code>CFCalendar366$valid_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar366-month_days"><code>CFCalendar366$month_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar366-leap_year"><code>CFCalendar366$leap_year()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar366-date2offset"><code>CFCalendar366$date2offset()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar366-offset2date"><code>CFCalendar366$offset2date()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendar366-clone"><code>CFCalendar366$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="POSIX_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-POSIX_compatible'><code>CFtime::CFCalendar$POSIX_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_compatible'><code>CFtime::CFCalendar$is_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_equivalent"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_equivalent'><code>CFtime::CFCalendar$is_equivalent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="offsets2time"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-offsets2time'><code>CFtime::CFCalendar$offsets2time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="parse"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-parse'><code>CFtime::CFCalendar$parse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="print"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-print'><code>CFtime::CFCalendar$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CFCalendar366-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new CF calendar of 366 days per year.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar366$new(nm, definition)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nm</code></dt><dd><p>The name of the calendar. This must be &quot;366_day&quot; or &quot;all_leap&quot;.</p>
</dd>
<dt><code>definition</code></dt><dd><p>The string that defines the units and the origin, as
per the CF Metadata Conventions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new instance of this class.
</p>


<hr>
<a id="method-CFCalendar366-valid_days"></a>



<h4>Method <code>valid_days()</code></h4>

<p>Indicate which of the supplied dates are valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar366$valid_days(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>ymd</code> has rows
with <code>TRUE</code> for valid days and <code>FALSE</code> for invalid days, or <code>NA</code> where
the row in argument <code>ymd</code> has <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendar366-month_days"></a>



<h4>Method <code>month_days()</code></h4>

<p>Determine the number of days in the month of the calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar366$month_days(ymd = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code>, optional, with dates parsed into their parts.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector indicating the number of days in each month for the
dates supplied as argument <code>ymd</code>. If no dates are supplied, the number
of days per month for the calendar as a vector of length 12.
</p>


<hr>
<a id="method-CFCalendar366-leap_year"></a>



<h4>Method <code>leap_year()</code></h4>

<p>Indicate which years are leap years.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar366$leap_year(yr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>yr</code></dt><dd><p>Integer vector of years to test.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>yr</code>. Since in
this calendar all years have a leap day, all values will be <code>TRUE</code>, or
<code>NA</code> where argument <code>yr</code> is <code>NA</code>.
</p>


<hr>
<a id="method-CFCalendar366-date2offset"></a>



<h4>Method <code>date2offset()</code></h4>

<p>Calculate difference in days between a <code>data.frame</code> of time
parts and the origin.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar366$date2offset(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>data.frame</code>. Dates to calculate the difference for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector of a length equal to the number of rows in
argument <code>x</code> indicating the number of days between <code>x</code> and the <code>origin</code>,
or <code>NA</code> for rows in <code>x</code> with <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendar366-offset2date"></a>



<h4>Method <code>offset2date()</code></h4>

<p>Calculate date parts from day differences from the origin. This
only deals with days as these are impacted by the calendar.
Hour-minute-second timestamp parts are handled in <a href="#topic+CFCalendar">CFCalendar</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar366$offset2date(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Integer vector of days to add to the origin.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns 'year', 'month' and 'day' and as many
rows as the length of vector <code>x</code>.
</p>


<hr>
<a id="method-CFCalendar366-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendar366$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CFCalendarJulian'>Julian CF calendar</h2><span id='topic+CFCalendarJulian'></span>

<h3>Description</h3>

<p>This class represents a Julian calendar of 365 days per year,
with every fourth year being a leap year of 366 days. The months and the
year align with the standard calendar. This calendar is not compatible with
the standard POSIXt calendar.
</p>
<p>This calendar starts on 1 January of year 1: 0001-01-01 00:00:00. Any dates
before this will generate an error.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CFCalendar">CFtime::CFCalendar</a></code> -&gt; <code>CFCalendarJulian</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFCalendarJulian-new"><code>CFCalendarJulian$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarJulian-valid_days"><code>CFCalendarJulian$valid_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarJulian-month_days"><code>CFCalendarJulian$month_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarJulian-leap_year"><code>CFCalendarJulian$leap_year()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarJulian-date2offset"><code>CFCalendarJulian$date2offset()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarJulian-offset2date"><code>CFCalendarJulian$offset2date()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarJulian-clone"><code>CFCalendarJulian$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="POSIX_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-POSIX_compatible'><code>CFtime::CFCalendar$POSIX_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_compatible'><code>CFtime::CFCalendar$is_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_equivalent"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_equivalent'><code>CFtime::CFCalendar$is_equivalent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="offsets2time"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-offsets2time'><code>CFtime::CFCalendar$offsets2time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="parse"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-parse'><code>CFtime::CFCalendar$parse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="print"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-print'><code>CFtime::CFCalendar$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CFCalendarJulian-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new CF calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarJulian$new(nm, definition)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nm</code></dt><dd><p>The name of the calendar. This must be &quot;julian&quot;. This argument
is superfluous but maintained to be consistent with the initialization
methods of the parent and sibling classes.</p>
</dd>
<dt><code>definition</code></dt><dd><p>The string that defines the units and the origin, as
per the CF Metadata Conventions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new instance of this class.
</p>


<hr>
<a id="method-CFCalendarJulian-valid_days"></a>



<h4>Method <code>valid_days()</code></h4>

<p>Indicate which of the supplied dates are valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarJulian$valid_days(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>ymd</code> has rows
with <code>TRUE</code> for valid days and <code>FALSE</code> for invalid days, or <code>NA</code> where
the row in argument <code>ymd</code> has <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendarJulian-month_days"></a>



<h4>Method <code>month_days()</code></h4>

<p>Determine the number of days in the month of the calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarJulian$month_days(ymd = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code>, optional, with dates parsed into their parts.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector indicating the number of days in each month for the
dates supplied as argument <code>ymd</code>. If no dates are supplied, the number
of days per month for the calendar as a vector of length 12, for a
regular year without a leap day.
</p>


<hr>
<a id="method-CFCalendarJulian-leap_year"></a>



<h4>Method <code>leap_year()</code></h4>

<p>Indicate which years are leap years.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarJulian$leap_year(yr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>yr</code></dt><dd><p>Integer vector of years to test.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>yr</code>. <code>NA</code> is
returned where elements in argument <code>yr</code> are <code>NA</code>.
</p>


<hr>
<a id="method-CFCalendarJulian-date2offset"></a>



<h4>Method <code>date2offset()</code></h4>

<p>Calculate difference in days between a <code>data.frame</code> of time
parts and the origin.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarJulian$date2offset(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>data.frame</code>. Dates to calculate the difference for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector of a length equal to the number of rows in
argument <code>x</code> indicating the number of days between <code>x</code> and the origin
of the calendar, or <code>NA</code> for rows in <code>x</code> with <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendarJulian-offset2date"></a>



<h4>Method <code>offset2date()</code></h4>

<p>Calculate date parts from day differences from the origin. This
only deals with days as these are impacted by the calendar.
Hour-minute-second timestamp parts are handled in <a href="#topic+CFCalendar">CFCalendar</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarJulian$offset2date(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Integer vector of days to add to the origin.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns 'year', 'month' and 'day' and as many
rows as the length of vector <code>x</code>.
</p>


<hr>
<a id="method-CFCalendarJulian-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarJulian$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CFCalendarProleptic'>Proleptic Gregorian CF calendar</h2><span id='topic+CFCalendarProleptic'></span>

<h3>Description</h3>

<p>This class represents a standard CF calendar, but with the
Gregorian calendar extended backwards to before the introduction of the
Gregorian calendar. This calendar is compatible with the standard POSIXt
calendar, but note that daylight savings time is not considered.
</p>
<p>This calendar includes dates 1582-10-14 to 1582-10-05 (the gap between the
Gregorian and Julian calendars, which is observed by the standard
calendar), and extends to years before the year 1, including year 0.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CFCalendar">CFtime::CFCalendar</a></code> -&gt; <code>CFCalendarProleptic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFCalendarProleptic-new"><code>CFCalendarProleptic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarProleptic-valid_days"><code>CFCalendarProleptic$valid_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarProleptic-month_days"><code>CFCalendarProleptic$month_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarProleptic-leap_year"><code>CFCalendarProleptic$leap_year()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarProleptic-POSIX_compatible"><code>CFCalendarProleptic$POSIX_compatible()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarProleptic-date2offset"><code>CFCalendarProleptic$date2offset()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarProleptic-offset2date"><code>CFCalendarProleptic$offset2date()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarProleptic-clone"><code>CFCalendarProleptic$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_compatible'><code>CFtime::CFCalendar$is_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_equivalent"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_equivalent'><code>CFtime::CFCalendar$is_equivalent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="offsets2time"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-offsets2time'><code>CFtime::CFCalendar$offsets2time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="parse"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-parse'><code>CFtime::CFCalendar$parse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="print"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-print'><code>CFtime::CFCalendar$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CFCalendarProleptic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new CF calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarProleptic$new(nm, definition)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nm</code></dt><dd><p>The name of the calendar. This must be &quot;proleptic_gregorian&quot;.
This argument is superfluous but maintained to be consistent with the
initialization methods of the parent and sibling classes.</p>
</dd>
<dt><code>definition</code></dt><dd><p>The string that defines the units and the origin, as
per the CF Metadata Conventions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new instance of this class.
</p>


<hr>
<a id="method-CFCalendarProleptic-valid_days"></a>



<h4>Method <code>valid_days()</code></h4>

<p>Indicate which of the supplied dates are valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarProleptic$valid_days(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>ymd</code> has rows
with <code>TRUE</code> for valid days and <code>FALSE</code> for invalid days, or <code>NA</code> where
the row in argument <code>ymd</code> has <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendarProleptic-month_days"></a>



<h4>Method <code>month_days()</code></h4>

<p>Determine the number of days in the month of the calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarProleptic$month_days(ymd = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code>, optional, with dates parsed into their parts.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector indicating the number of days in each month for
the dates supplied as argument <code>ymd</code>. If no dates are supplied, the
number of days per month for the calendar as a vector of length 12, for
a regular year without a leap day.
</p>


<hr>
<a id="method-CFCalendarProleptic-leap_year"></a>



<h4>Method <code>leap_year()</code></h4>

<p>Indicate which years are leap years.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarProleptic$leap_year(yr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>yr</code></dt><dd><p>Integer vector of years to test.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>yr</code>. <code>NA</code> is
returned where elements in argument <code>yr</code> are <code>NA</code>.
</p>


<hr>
<a id="method-CFCalendarProleptic-POSIX_compatible"></a>



<h4>Method <code>POSIX_compatible()</code></h4>

<p>Indicate if the time series described using this calendar
can be safely converted to a standard date-time type (<code>POSIXct</code>,
<code>POSIXlt</code>, <code>Date</code>).
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarProleptic$POSIX_compatible(offsets)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>offsets</code></dt><dd><p>The offsets from the CFtime instance.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code>.
</p>


<hr>
<a id="method-CFCalendarProleptic-date2offset"></a>



<h4>Method <code>date2offset()</code></h4>

<p>Calculate difference in days between a <code>data.frame</code> of time
parts and the origin.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarProleptic$date2offset(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>data.frame</code>. Dates to calculate the difference for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector of a length equal to the number of rows in
argument <code>x</code> indicating the number of days between <code>x</code> and the <code>origin</code>,
or <code>NA</code> for rows in <code>x</code> with <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendarProleptic-offset2date"></a>



<h4>Method <code>offset2date()</code></h4>

<p>Calculate date parts from day differences from the origin. This
only deals with days as these are impacted by the calendar.
Hour-minute-second timestamp parts are handled in <a href="#topic+CFCalendar">CFCalendar</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarProleptic$offset2date(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Integer vector of days to add to the origin.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns 'year', 'month' and 'day' and as many
rows as the length of vector <code>x</code>.
</p>


<hr>
<a id="method-CFCalendarProleptic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarProleptic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CFCalendarStandard'>Standard CF calendar</h2><span id='topic+CFCalendarStandard'></span>

<h3>Description</h3>

<p>This class represents a standard calendar of 365 or 366 days per
year. This calendar is compatible with the standard POSIXt calendar for
periods after the introduction of the Gregorian calendar, 1582-10-15
00:00:00. The calendar starts at 0001-01-01 00:00:00, e.g. the start of the
Common Era.
</p>
<p>Note that this calendar, despite its name, is not the same as that used in
ISO8601 or many computer systems for periods prior to the introduction of
the Gregorian calendar. Use of the &quot;proleptic_gregorian&quot; calendar is
recommended for periods before or straddling the introduction date, as that
calendar is compatible with POSIXt on most OSes.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CFCalendar">CFtime::CFCalendar</a></code> -&gt; <code>CFCalendarStandard</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFCalendarStandard-new"><code>CFCalendarStandard$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarStandard-valid_days"><code>CFCalendarStandard$valid_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarStandard-is_gregorian_date"><code>CFCalendarStandard$is_gregorian_date()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarStandard-POSIX_compatible"><code>CFCalendarStandard$POSIX_compatible()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarStandard-month_days"><code>CFCalendarStandard$month_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarStandard-leap_year"><code>CFCalendarStandard$leap_year()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarStandard-date2offset"><code>CFCalendarStandard$date2offset()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarStandard-offset2date"><code>CFCalendarStandard$offset2date()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarStandard-clone"><code>CFCalendarStandard$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_compatible'><code>CFtime::CFCalendar$is_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_equivalent"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_equivalent'><code>CFtime::CFCalendar$is_equivalent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="offsets2time"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-offsets2time'><code>CFtime::CFCalendar$offsets2time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="parse"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-parse'><code>CFtime::CFCalendar$parse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="print"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-print'><code>CFtime::CFCalendar$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CFCalendarStandard-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new CF calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarStandard$new(nm, definition)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nm</code></dt><dd><p>The name of the calendar. This must be &quot;standard&quot; or
&quot;gregorian&quot; (deprecated).</p>
</dd>
<dt><code>definition</code></dt><dd><p>The string that defines the units and the origin, as
per the CF Metadata Conventions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new instance of this class.
</p>


<hr>
<a id="method-CFCalendarStandard-valid_days"></a>



<h4>Method <code>valid_days()</code></h4>

<p>Indicate which of the supplied dates are valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarStandard$valid_days(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>ymd</code> has rows
with <code>TRUE</code> for valid days and <code>FALSE</code> for invalid days, or <code>NA</code> where
the row in argument <code>ymd</code> has <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendarStandard-is_gregorian_date"></a>



<h4>Method <code>is_gregorian_date()</code></h4>

<p>Indicate which of the supplied dates are in the Gregorian
part of the calendar, e.g. 1582-10-15 or after.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarStandard$is_gregorian_date(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>ymd</code> has rows
with <code>TRUE</code> for days in the Gregorian part of the calendar and <code>FALSE</code>
otherwise, or <code>NA</code> where the row in argument <code>ymd</code> has <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendarStandard-POSIX_compatible"></a>



<h4>Method <code>POSIX_compatible()</code></h4>

<p>Indicate if the time series described using this calendar
can be safely converted to a standard date-time type (<code>POSIXct</code>,
<code>POSIXlt</code>, <code>Date</code>). This is only the case if all offsets are for
timestamps fall on or after the start of the Gregorian calendar,
1582-10-15 00:00:00.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarStandard$POSIX_compatible(offsets)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>offsets</code></dt><dd><p>The offsets from the CFtime instance.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code>.
</p>


<hr>
<a id="method-CFCalendarStandard-month_days"></a>



<h4>Method <code>month_days()</code></h4>

<p>Determine the number of days in the month of the calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarStandard$month_days(ymd = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code>, optional, with dates parsed into their parts.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector indicating the number of days in each month for the
dates supplied as argument <code>ymd</code>. If no dates are supplied, the number
of days per month for the calendar as a vector of length 12, for a
regular year without a leap day.
</p>


<hr>
<a id="method-CFCalendarStandard-leap_year"></a>



<h4>Method <code>leap_year()</code></h4>

<p>Indicate which years are leap years.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarStandard$leap_year(yr)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>yr</code></dt><dd><p>Integer vector of years to test.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>yr</code>. <code>NA</code> is
returned where elements in argument <code>yr</code> are <code>NA</code>.
</p>


<hr>
<a id="method-CFCalendarStandard-date2offset"></a>



<h4>Method <code>date2offset()</code></h4>

<p>Calculate difference in days between a <code>data.frame</code> of time
parts and the origin.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarStandard$date2offset(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p><code>data.frame</code>. Dates to calculate the difference for.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Integer vector of a length equal to the number of rows in
argument <code>x</code> indicating the number of days between <code>x</code> and the origin
of the calendar, or <code>NA</code> for rows in <code>x</code> with <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendarStandard-offset2date"></a>



<h4>Method <code>offset2date()</code></h4>

<p>Calculate date parts from day differences from the origin. This
only deals with days as these are impacted by the calendar.
Hour-minute-second timestamp parts are handled in <a href="#topic+CFCalendar">CFCalendar</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarStandard$offset2date(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Integer vector of days to add to the origin.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns 'year', 'month' and 'day' and as many
rows as the length of vector <code>x</code>.
</p>


<hr>
<a id="method-CFCalendarStandard-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarStandard$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CFCalendarTAI'>International Atomic Time CF calendar</h2><span id='topic+CFCalendarTAI'></span>

<h3>Description</h3>

<p>This class represents a calendar based on the International
Atomic Time. Validity is from 1958 onwards, with dates represented using
the Gregorian calendar. Given that this &quot;calendar&quot; is based on a universal
clock, the concepts of leap second, time zone and daylight savings time do
not apply.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CFCalendar">CFtime::CFCalendar</a></code> -&gt; <code><a href="#topic+CFCalendarProleptic">CFtime::CFCalendarProleptic</a></code> -&gt; <code>CFCalendarTAI</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFCalendarTAI-valid_days"><code>CFCalendarTAI$valid_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarTAI-clone"><code>CFCalendarTAI$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_compatible'><code>CFtime::CFCalendar$is_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_equivalent"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_equivalent'><code>CFtime::CFCalendar$is_equivalent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="offsets2time"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-offsets2time'><code>CFtime::CFCalendar$offsets2time()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="parse"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-parse'><code>CFtime::CFCalendar$parse()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="print"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-print'><code>CFtime::CFCalendar$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="POSIX_compatible"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-POSIX_compatible'><code>CFtime::CFCalendarProleptic$POSIX_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="date2offset"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-date2offset'><code>CFtime::CFCalendarProleptic$date2offset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="initialize"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-initialize'><code>CFtime::CFCalendarProleptic$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="leap_year"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-leap_year'><code>CFtime::CFCalendarProleptic$leap_year()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="month_days"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-month_days'><code>CFtime::CFCalendarProleptic$month_days()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="offset2date"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-offset2date'><code>CFtime::CFCalendarProleptic$offset2date()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CFCalendarTAI-valid_days"></a>



<h4>Method <code>valid_days()</code></h4>

<p>Indicate which of the supplied dates are valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarTAI$valid_days(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. If present, the <code>tz</code> column is checked for
illegal time zone offsets. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>ymd</code> has rows
with <code>TRUE</code> for valid days and <code>FALSE</code> for invalid days, or <code>NA</code> where
the row in argument <code>ymd</code> has <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendarTAI-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarTAI$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CFCalendarUTC'>Coordinated Universal Time CF calendar</h2><span id='topic+CFCalendarUTC'></span>

<h3>Description</h3>

<p>This class represents a calendar based on the Coordinated
Universal Time. Validity is from 1972 onwards, with dates represented using
the Gregorian calendar, up to the present (so future timestamps are not
allowed). Leap seconds are considered in all calculations. Also, time zone
information is irrelevant and may not be given.
</p>
<p>In general, the calendar should use a unit of time of a second. Minute,
hour and day are allowed but discouraged. Month and year as time unit are
not allowed as there is no practical way to maintain leap second accuracy.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+CFCalendar">CFtime::CFCalendar</a></code> -&gt; <code><a href="#topic+CFCalendarProleptic">CFtime::CFCalendarProleptic</a></code> -&gt; <code>CFCalendarUTC</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFCalendarUTC-new"><code>CFCalendarUTC$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarUTC-valid_days"><code>CFCalendarUTC$valid_days()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarUTC-parse"><code>CFCalendarUTC$parse()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarUTC-offsets2time"><code>CFCalendarUTC$offsets2time()</code></a>
</p>
</li>
<li> <p><a href="#method-CFCalendarUTC-clone"><code>CFCalendarUTC$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_compatible"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_compatible'><code>CFtime::CFCalendar$is_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="is_equivalent"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-is_equivalent'><code>CFtime::CFCalendar$is_equivalent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendar" data-id="print"><a href='../../CFtime/html/CFCalendar.html#method-CFCalendar-print'><code>CFtime::CFCalendar$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="POSIX_compatible"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-POSIX_compatible'><code>CFtime::CFCalendarProleptic$POSIX_compatible()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="date2offset"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-date2offset'><code>CFtime::CFCalendarProleptic$date2offset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="leap_year"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-leap_year'><code>CFtime::CFCalendarProleptic$leap_year()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="month_days"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-month_days'><code>CFtime::CFCalendarProleptic$month_days()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CFtime" data-topic="CFCalendarProleptic" data-id="offset2date"><a href='../../CFtime/html/CFCalendarProleptic.html#method-CFCalendarProleptic-offset2date'><code>CFtime::CFCalendarProleptic$offset2date()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CFCalendarUTC-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new CF UTC calendar.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarUTC$new(nm, definition)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nm</code></dt><dd><p>The name of the calendar. This must be &quot;utc&quot;.</p>
</dd>
<dt><code>definition</code></dt><dd><p>The string that defines the units and the origin, as
per the CF Metadata Conventions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CFCalendarUTC-valid_days"></a>



<h4>Method <code>valid_days()</code></h4>

<p>Indicate which of the supplied dates are valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarUTC$valid_days(ymd)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ymd</code></dt><dd><p><code>data.frame</code> with dates parsed into their parts in columns
<code>year</code>, <code>month</code> and <code>day</code>. Any other columns are disregarded.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Logical vector with the same length as argument <code>ymd</code> has rows
with <code>TRUE</code> for valid days and <code>FALSE</code> for invalid days, or <code>NA</code> where
the row in argument <code>ymd</code> has <code>NA</code> values.
</p>


<hr>
<a id="method-CFCalendarUTC-parse"></a>



<h4>Method <code>parse()</code></h4>

<p>Parsing a vector of date-time character strings into parts.
This includes any leap seconds. Time zone indications are not allowed.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarUTC$parse(d)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>d</code></dt><dd><p>character. A character vector of date-times.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns year, month, day, hour, minute,
second, time zone, and offset. Invalid input data will appear as <code>NA</code>.
Note that the time zone is always &quot;+0000&quot; and is included to maintain
compatibility with results from other calendars.
</p>


<hr>
<a id="method-CFCalendarUTC-offsets2time"></a>



<h4>Method <code>offsets2time()</code></h4>

<p>Decompose a vector of offsets, in units of the calendar, to
their timestamp values. This adds a specified amount of time to the
origin of a <code>CFTime</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarUTC$offsets2time(offsets)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>offsets</code></dt><dd><p>Vector of numeric offsets to add to the origin of the
calendar.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>data.frame</code> with columns for the timestamp elements and as
many rows as there are offsets.
</p>


<hr>
<a id="method-CFCalendarUTC-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFCalendarUTC$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CFfactor'>Create a factor from the offsets in a <code>CFTime</code> instance</h2><span id='topic+CFfactor'></span>

<h3>Description</h3>

<p>With this function a factor can be generated for the time series, or a part
thereof, contained in the <a href="#topic+CFTime">CFTime</a> instance. This is specifically interesting
for creating factors from the date part of the time series that aggregate the
time series into longer time periods (such as month) that can then be used to
process daily CF data sets using, for instance, <code>tapply()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFfactor(t, period = "month", era = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CFfactor_+3A_t">t</code></td>
<td>
<p>An instance of the <code>CFTime</code> class whose offsets will be used to
construct the factor.</p>
</td></tr>
<tr><td><code id="CFfactor_+3A_period">period</code></td>
<td>
<p>character. A character string with one of the values &quot;year&quot;,
&quot;season&quot;, &quot;quarter&quot;, &quot;month&quot; (the default), &quot;dekad&quot; or &quot;day&quot;.</p>
</td></tr>
<tr><td><code id="CFfactor_+3A_era">era</code></td>
<td>
<p>numeric or list, optional. Vector of years for which to
construct the factor, or a list whose elements are each a vector of years.
If <code>era</code> is not specified, the factor will use the entire time series for
the factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factor will respect the calendar that the time series is built on. For
<code>period</code>s longer than a day this will result in a factor where the calendar
is no longer relevant (because calendars impacts days, not dekads, months,
quarters, seasons or years).
</p>
<p>The factor will be generated in the order of the offsets of the <code>CFTime</code>
instance. While typical CF-compliant data sources use ordered time series
there is, however, no guarantee that the factor is ordered as multiple
<code>CFTime</code> objects may have been merged out of order. For most processing with
a factor the ordering is of no concern.
</p>
<p>If the <code>era</code> parameter is specified, either as a vector of years to include
in the factor, or as a list of such vectors, the factor will only consider
those values in the time series that fall within the list of years, inclusive
of boundary values. Other values in the factor will be set to <code>NA</code>. The years
need not be contiguous, within a single vector or among the list items, or in
order.
</p>
<p>The following periods are supported by this function:
</p>

<ul>
<li> <p><code>year</code>, the year of each offset is returned as &quot;YYYY&quot;.
</p>
</li>
<li> <p><code>season</code>, the meteorological season of each offset is returned as
&quot;Sx&quot;, with x being 1-4, preceeded by &quot;YYYY&quot; if no <code>era</code> is
specified. Note that December dates are labeled as belonging to the
subsequent year, so the date &quot;2020-12-01&quot; yields &quot;2021S1&quot;. This implies
that for standard CMIP files having one or more full years of data the
first season will have data for the first two months (January and
February), while the final season will have only a single month of data
(December).
</p>
</li>
<li> <p><code>quarter</code>, the calendar quarter of each offset is returned as &quot;Qx&quot;,
with x being 1-4, preceeded by &quot;YYYY&quot; if no <code>era</code> is specified.
</p>
</li>
<li> <p><code>month</code>, the month of each offset is returned as &quot;01&quot; to
&quot;12&quot;, preceeded by &quot;YYYY-&quot; if no <code>era</code> is specified. This is the default
period.
</p>
</li>
<li> <p><code>dekad</code>, ten-day periods are returned as
&quot;Dxx&quot;, where xx runs from &quot;01&quot; to &quot;36&quot;, preceeded by &quot;YYYY&quot; if no <code>era</code>
is specified. Each month is subdivided in dekads as follows: 1- days 01 -
10; 2- days 11 - 20; 3- remainder of the month.
</p>
</li>
<li> <p><code>day</code>, the month and day of each offset are returned as &quot;MM-DD&quot;,
preceeded by &quot;YYYY-&quot; if no <code>era</code> is specified.
</p>
</li></ul>

<p>It is not possible to create a factor for a period that is shorter than the
temporal resolution of the source data set from which the <code>t</code> argument
derives. As an example, if the source data set has monthly data, a dekad or
day factor cannot be created.
</p>
<p>Creating factors for other periods is not supported by this function. Factors
based on the timestamp information and not dependent on the calendar can
trivially be constructed from the output of the <code><a href="#topic+as_timestamp">as_timestamp()</a></code> function.
</p>
<p>For non-era factors the attribute 'CFTime' of the result contains a <code>CFTime</code>
instance that is valid for the result of applying the factor to a data set
that the <code>t</code> argument is associated with. In other words, if <code>CFTime</code>
instance 'At' describes the temporal dimension of data set 'A' and a factor
'Af' is generated like <code>Af &lt;- CFfactor(At)</code>, then <code>Bt &lt;- attr(Af, "CFTime")</code>
describes the temporal dimension of the result of, say,
<code>B &lt;- apply(A, 1:2, tapply, Af, FUN)</code>. The 'CFTime' attribute is <code>NULL</code> for
era factors.
</p>


<h3>Value</h3>

<p>If <code>era</code> is a single vector or not specified, a factor with a
length equal to the number of offsets in <code>t</code>. If <code>era</code> is a list, a list
with the same number of elements and names as <code>era</code>, each containing a
factor. Elements in the factor will be set to <code>NA</code> for time series values
outside of the range of specified years.
</p>
<p>The factor, or factors in the list, have attributes 'period', 'era' and
'CFTime'. Attribute 'period' holds the value of the <code>period</code> argument.
Attribute 'era' indicates the number of years that are included in the
era, or -1 if no <code>era</code> is provided. Attribute 'CFTime' holds an
instance of <code>CFTime</code> that has the same definition as <code>t</code>, but with offsets
corresponding to the mid-point of non-era factor levels; if the <code>era</code>
argument is specified, attribute 'CFTime' is <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cut">cut()</a></code> creates a non-era factor for arbitrary cut points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("days since 1949-12-01", "360_day", 19830:54029)

# Create a dekad factor for the whole time series
f &lt;- CFfactor(t, "dekad")

# Create three monthly factors for early, mid and late 21st century eras
ep &lt;- CFfactor(t, era = list(early = 2021:2040, mid = 2041:2060, late = 2061:2080))
</code></pre>

<hr>
<h2 id='CFfactor_coverage'>Coverage of time elements for each factor level</h2><span id='topic+CFfactor_coverage'></span>

<h3>Description</h3>

<p>This function calculates the number of time elements, or the relative
coverage, in each level of a factor generated by <code><a href="#topic+CFfactor">CFfactor()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFfactor_coverage(t, f, coverage = "absolute")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CFfactor_coverage_+3A_t">t</code></td>
<td>
<p>An instance of <a href="#topic+CFTime">CFTime</a>.</p>
</td></tr>
<tr><td><code id="CFfactor_coverage_+3A_f">f</code></td>
<td>
<p>factor or list. A factor or a list of factors derived from the
parameter <code>t</code>. The factor or list thereof should generally be generated by
the function <code><a href="#topic+CFfactor">CFfactor()</a></code>.</p>
</td></tr>
<tr><td><code id="CFfactor_coverage_+3A_coverage">coverage</code></td>
<td>
<p>&quot;absolute&quot; or &quot;relative&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>f</code> is a factor, a numeric vector with a length equal to the
number of levels in the factor, indicating the number of units from the
time series in <code>t</code> contained in each level of the factor when
<code>coverage = "absolute"</code> or the proportion of units present relative to the
maximum number when <code>coverage = "relative"</code>. If <code>f</code> is a list of factors, a
list with each element a numeric vector as above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("days since 2001-01-01", "365_day", 0:364)
f &lt;- CFfactor(t, "dekad")
CFfactor_coverage(t, f, "absolute")
</code></pre>

<hr>
<h2 id='CFfactor_units'>Number of base time units in each factor level</h2><span id='topic+CFfactor_units'></span>

<h3>Description</h3>

<p>Given a factor as returned by <code><a href="#topic+CFfactor">CFfactor()</a></code> and the <a href="#topic+CFTime">CFTime</a> instance from
which the factor was derived, this function will return a numeric vector with
the number of time units in each level of the factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFfactor_units(t, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CFfactor_units_+3A_t">t</code></td>
<td>
<p>An instance of <code>CFTime</code>.</p>
</td></tr>
<tr><td><code id="CFfactor_units_+3A_f">f</code></td>
<td>
<p>A factor or a list of factors derived from the
parameter <code>t</code>. The factor or list thereof should generally be generated by
the function <code><a href="#topic+CFfactor">CFfactor()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of this function is useful to convert between absolute and
relative values. Climate change anomalies, for instance, are usually computed
by differencing average values between a future period and a baseline period.
Going from average values back to absolute values for an aggregate period
(which is typical for temperature and precipitation, among other variables)
is easily done with the result of this function, without having to consider
the specifics of the calendar of the data set.
</p>
<p>If the factor <code>f</code> is for an era (e.g. spanning multiple years and the
levels do not indicate the specific year), then the result will indicate the
number of time units of the period in a regular single year. In other words,
for an era of 2041-2060 and a monthly factor on a standard calendar with a
<code>days</code> unit, the result will be <code>c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)</code>.
Leap days are thus only considered for the <code style="white-space: pre;">&#8288;366_day&#8288;</code> and <code>all_leap</code> calendars.
</p>
<p>Note that this function gives the number of time units in each level of the
factor - the actual number of data points in the <code>cf</code> instance per factor
level may be different. Use <code><a href="#topic+CFfactor_coverage">CFfactor_coverage()</a></code> to determine the actual
number of data points or the coverage of data points relative to the factor
level.
</p>


<h3>Value</h3>

<p>If <code>f</code> is a factor, a numeric vector with a length equal to the
number of levels in the factor, indicating the number of time units in each
level of the factor. If <code>f</code> is a list of factors, a list with each element
a numeric vector as above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("days since 2001-01-01", "365_day", 0:364)
f &lt;- CFfactor(t, "dekad")
CFfactor_units(t, f)
</code></pre>

<hr>
<h2 id='CFTime'>CFTime class</h2><span id='topic+CFTime'></span>

<h3>Description</h3>

<p>This class manages the &quot;time&quot; dimension of netCDF files that
follow the CF Metadata Conventions, and its productive use in R.
</p>
<p>The class has a field <code>cal</code> which holds a specific calendar from the
allowed types (9 named calendars are currently supported). The calendar is
also implemented as a (hidden) class which converts netCDF file encodings to
timestamps as character strings, and vice-versa. Bounds information (the
period of time over which a timestamp is valid) is used when defined in the
netCDF file.
</p>
<p>Additionally, this class has functions to ease use of the netCDF &quot;time&quot;
information when processing data from netCDF files. Filtering and indexing of
time values is supported, as is the generation of factors.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>cal</code></dt><dd><p>The calendar of this <code>CFTime</code> instance, a descendant of the
<a href="#topic+CFCalendar">CFCalendar</a> class.</p>
</dd>
<dt><code>offsets</code></dt><dd><p>A numeric vector of offsets from the origin of the
calendar.</p>
</dd>
<dt><code>resolution</code></dt><dd><p>The average number of time units between offsets.</p>
</dd>
<dt><code>bounds</code></dt><dd><p>Optional, the bounds for the offsets. If not set, it is the
logical value <code>FALSE</code>. If set, it is the logical value <code>TRUE</code> if the
bounds are regular with respect to the regularly spaced offsets (e.g.
successive bounds are contiguous and at mid-points between the
offsets); otherwise a <code>matrix</code> with columns for <code>offsets</code> and low
values in the first row, high values in the second row. Use
<code>get_bounds()</code> to get bounds values when they are regularly spaced.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>unit</code></dt><dd><p>(read-only) The unit string of the calendar and time series.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CFTime-new"><code>CFTime$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-print"><code>CFTime$print()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-range"><code>CFTime$range()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-as_timestamp"><code>CFTime$as_timestamp()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-format"><code>CFTime$format()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-indexOf"><code>CFTime$indexOf()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-get_bounds"><code>CFTime$get_bounds()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-set_bounds"><code>CFTime$set_bounds()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-equidistant"><code>CFTime$equidistant()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-slice"><code>CFTime$slice()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-POSIX_compatible"><code>CFTime$POSIX_compatible()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-cut"><code>CFTime$cut()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-factor"><code>CFTime$factor()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-factor_units"><code>CFTime$factor_units()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-factor_coverage"><code>CFTime$factor_coverage()</code></a>
</p>
</li>
<li> <p><a href="#method-CFTime-clone"><code>CFTime$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CFTime-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new instance of this class.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$new(definition, calendar, offsets = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>definition</code></dt><dd><p>Character string of the units and origin of the
calendar.</p>
</dd>
<dt><code>calendar</code></dt><dd><p>Character string of the calendar to use. Must be one of
the values permitted by the CF Metadata Conventions. If <code>NULL</code>, the
&quot;standard&quot; calendar will be used.</p>
</dd>
<dt><code>offsets</code></dt><dd><p>Numeric or character vector, optional. When numeric, a
vector of offsets from the origin in the time series. When a character
vector of length 2 or more, timestamps in ISO8601 or UDUNITS format.
When a character string, a timestamp in ISO8601 or UDUNITS format and
then a time series will be generated with a separation between steps
equal to the unit of measure in the definition, inclusive of the
definition timestamp. The unit of measure of the offsets is defined by
the <code>definition</code> argument.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CFTime-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print a summary of the <code>CFTime</code> object to the console.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Ignored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code> invisibly.
</p>


<hr>
<a id="method-CFTime-range"></a>



<h4>Method <code>range()</code></h4>

<p>This method returns the first and last timestamp of the time
series as a vector. Note that the offsets do not have to be sorted.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$range(format = "", bounds = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>format</code></dt><dd><p>Value of &quot;date&quot; or &quot;timestamp&quot;. Optionally, a
character string that specifies an alternate format.</p>
</dd>
<dt><code>bounds</code></dt><dd><p>Logical to indicate if the extremes from the bounds should
be used, if set. Defaults to <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Vector of two character strings that represent the starting and
ending timestamps in the time series. If a <code>format</code> is supplied, that
format will be used. Otherwise, if all of the timestamps in the time
series have a time component of <code>00:00:00</code> the date of the timestamp is
returned, otherwise the full timestamp (without any time zone
information).
</p>


<hr>
<a id="method-CFTime-as_timestamp"></a>



<h4>Method <code>as_timestamp()</code></h4>

<p>This method generates a vector of character strings or
<code>POSIXct</code>s that represent the date and time in a selectable combination
for each offset.
</p>
<p>The character strings use the format <code style="white-space: pre;">&#8288;YYYY-MM-DDThh:mm:ssÂ±hhmm&#8288;</code>,
depending on the <code>format</code> specifier. The date in the string is not
necessarily compatible with <code>POSIXt</code> - in the <code style="white-space: pre;">&#8288;360_day&#8288;</code> calendar
<code>2017-02-30</code> is valid and <code>2017-03-31</code> is not.
</p>
<p>For the &quot;proleptic_gregorian&quot; calendar the output can also be generated
as a vector of <code>POSIXct</code> values by specifying <code>asPOSIX = TRUE</code>. The
same is possible for the &quot;standard&quot; and &quot;gregorian&quot; calendars but only
if all timestamps fall on or after 1582-10-15. If <code>asPOSIX = TRUE</code> is
specified while the calendar does not support it, an error will be
generated.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$as_timestamp(format = NULL, asPOSIX = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>format</code></dt><dd><p>character. A character string with either of the values
&quot;date&quot; or &quot;timestamp&quot;. If the argument is not specified, the format
used is &quot;timestamp&quot; if there is time information, &quot;date&quot; otherwise.</p>
</dd>
<dt><code>asPOSIX</code></dt><dd><p>logical. If <code>TRUE</code>, for &quot;standard&quot;, &quot;gregorian&quot; and
&quot;proleptic_gregorian&quot; calendars the output is a vector of <code>POSIXct</code> -
for other calendars an error will be thrown. Default value is <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A character vector where each element represents a moment in
time according to the <code>format</code> specifier.
</p>


<hr>
<a id="method-CFTime-format"></a>



<h4>Method <code>format()</code></h4>

<p>Format timestamps using a specific format string, using the
specifiers defined for the <code><a href="base.html#topic+strptime">base::strptime()</a></code> function, with
limitations. The only supported specifiers are <code style="white-space: pre;">&#8288;bBdeFhHImMpRSTYz%&#8288;</code>.
Modifiers <code>E</code> and <code>O</code> are silently ignored. Other specifiers, including
their percent sign, are copied to the output as if they were adorning
text.
</p>
<p>The formatting is largely oblivious to locale. The reason for this is
that certain dates in certain calendars are not POSIX-compliant and the
system functions necessary for locale information thus do not work
consistently. The main exception to this is the (abbreviated) names of
months (<code>bB</code>), which could be useful for pretty printing in the local
language. For separators and other locale-specific adornments, use
local knowledge instead of depending on system locale settings; e.g.
specify <code style="white-space: pre;">&#8288;%m/%d/%Y&#8288;</code> instead of <code style="white-space: pre;">&#8288;%D&#8288;</code>.
</p>
<p>Week information, including weekday names, is not supported at all as a
&quot;week&quot; is not defined for non-standard CF calendars and not generally
useful for climate projection data. If you are working with observed
data and want to get pretty week formats, use the <code><a href="#topic+as_timestamp">as_timestamp()</a></code>
method to generate <code>POSIXct</code> timestamps (observed data generally uses a
&quot;standard&quot; calendar) and then use the <code><a href="base.html#topic+format">base::format()</a></code> function which
supports the full set of specifiers.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$format(format)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>format</code></dt><dd><p>A character string with <code>strptime</code> format specifiers. If
omitted, the most economical format will be used: a full timestamp when
time information is available, a date otherwise.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of character strings with a properly formatted
timestamp. Any format specifiers not recognized or supported will be
returned verbatim.
</p>


<hr>
<a id="method-CFTime-indexOf"></a>



<h4>Method <code>indexOf()</code></h4>

<p>Find the index in the time series for each timestamp given
in argument <code>x</code>. Values of <code>x</code> that are before the earliest value in
the time series will be returned as <code>0</code>; values of <code>x</code> that are after
the latest values in the time series will be returned as
<code>.Machine$integer.max</code>. Alternatively, when <code>x</code> is a numeric vector of
index values, return the valid indices of the same vector, with the
side effect being the attribute &quot;CFTime&quot; associated with the result.
</p>
<p>Matching also returns index values for timestamps that fall between two
elements of the time series - this can lead to surprising results when
time series elements are positioned in the middle of an interval (as
the CF Metadata Conventions instruct us to &quot;reasonably assume&quot;): a time
series of days in January would be encoded in a netCDF file as
<code>c("2024-01-01 12:00:00", "2024-01-02 12:00:00", "2024-01-03 12:00:00", ...)</code>
so <code>x &lt;- c("2024-01-01", "2024-01-02", "2024-01-03")</code> would
result in <code style="white-space: pre;">&#8288;(NA, 1, 2)&#8288;</code> (or <code style="white-space: pre;">&#8288;(NA, 1.5, 2.5)&#8288;</code> with <code>method = "linear"</code>)
because the date values in <code>x</code> are at midnight. This situation is
easily avoided by ensuring that this <code>CFTime</code> instance has bounds set
(use <code>bounds(y) &lt;- TRUE</code> as a proximate solution if bounds are not
stored in the netCDF file). See the Examples.
</p>
<p>If bounds are set, the indices are taken from those bounds. Returned
indices may fall in between bounds if the latter are not contiguous,
with the exception of the extreme values in <code>x</code>.
</p>
<p>Values of <code>x</code> that are not valid timestamps according to the calendar
of this <code>CFTime</code> instance will be returned as <code>NA</code>.
</p>
<p><code>x</code> can also be a numeric vector of index values, in which case the
valid values in <code>x</code> are returned. If negative values are passed, the
positive counterparts will be excluded and then the remainder returned.
Positive and negative values may not be mixed. Using a numeric vector
has the side effect that the result has the attribute &quot;CFTime&quot;
describing the temporal dimension of the slice. If index values outside
of the range of <code>self</code> are provided, an error will be thrown.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$indexOf(x, method = "constant")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Vector of character, POSIXt or Date values to find indices for,
or a numeric vector.</p>
</dd>
<dt><code>method</code></dt><dd><p>Single value of &quot;constant&quot; or &quot;linear&quot;. If <code>"constant"</code> or
when bounds are set on <code>self</code>, return the index value for each
match. If <code>"linear"</code>, return the index value with any fractional value.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric vector giving indices into the &quot;time&quot; dimension of the
dataset associated with <code>self</code> for the values of <code>x</code>. If there is at
least 1 valid index, then attribute &quot;CFTime&quot; contains an instance of
<code>CFTime</code> that describes the dimension of filtering the dataset
associated with <code>self</code> with the result of this function, excluding any
<code>NA</code>, <code>0</code> and <code>.Machine$integer.max</code> values.
</p>


<hr>
<a id="method-CFTime-get_bounds"></a>



<h4>Method <code>get_bounds()</code></h4>

<p>Return bounds.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$get_bounds(format)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>format</code></dt><dd><p>A string specifying a format for output, optional.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An array with dims(2, length(offsets)) with values for the
bounds. <code>NULL</code> if the bounds have not been set.
</p>


<hr>
<a id="method-CFTime-set_bounds"></a>



<h4>Method <code>set_bounds()</code></h4>

<p>Set the bounds of the <code>CFTime</code> instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$set_bounds(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>The bounds to set, in units of the offsets. Either a matrix
<code style="white-space: pre;">&#8288;(2, length(self$offsets))&#8288;</code> or a single logical value.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>self</code> invisibly.
This method returns <code>TRUE</code> if the time series has uniformly distributed
time steps between the extreme values, <code>FALSE</code> otherwise. First test
without sorting; this should work for most data sets. If not, only then
offsets are sorted. For most data sets that will work but for implied
resolutions of month, season, year, etc based on a &quot;days&quot; or finer
calendar unit this will fail due to the fact that those coarser units
have a variable number of days per time step, in all calendars except for
<code style="white-space: pre;">&#8288;360_day&#8288;</code>. For now, an approximate solution is used that should work in
all but the most non-conformal exotic arrangements.
</p>


<hr>
<a id="method-CFTime-equidistant"></a>



<h4>Method <code>equidistant()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CFTime$equidistant()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if all time steps are equidistant, <code>FALSE</code> otherwise, or
<code>NA</code> if no offsets have been set.
</p>


<hr>
<a id="method-CFTime-slice"></a>



<h4>Method <code>slice()</code></h4>

<p>Given a vector of character timestamps, return a logical
vector of a length equal to the number of time steps in the time series
with values <code>TRUE</code> for those time steps that fall between the two
extreme values of the vector values, <code>FALSE</code> otherwise.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$slice(extremes, closed = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>extremes</code></dt><dd><p>Character vector of timestamps that represent the
time period of interest. The extreme values are selected. Badly
formatted timestamps are silently dropped.</p>
</dd>
<dt><code>closed</code></dt><dd><p>Is the right side closed, i.e. included in the result?
Default is <code>FALSE</code>. A specification of <code style="white-space: pre;">&#8288;c("2022-01-01", "2023-01-01)&#8288;</code>
will thus include all time steps that fall in the year 2022 when
<code>closed = FALSE</code> but include <code>2023-01-01</code> if that exact value is
present in the time series.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A logical vector with a length equal to the number of time steps
in <code>self</code> with values <code>TRUE</code> for those time steps that fall between the
extreme values, <code>FALSE</code> otherwise.
</p>
<p>An attribute 'CFTime' will have the same definition as <code>self</code> but with
offsets corresponding to the time steps falling between the two
extremes. If there are no values between the extremes, the attribute is
<code>NULL</code>.
</p>


<hr>
<a id="method-CFTime-POSIX_compatible"></a>



<h4>Method <code>POSIX_compatible()</code></h4>

<p>Can the time series be converted to POSIXt?
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$POSIX_compatible()</pre></div>



<h5>Returns</h5>

<p><code>TRUE</code> if the calendar support coversion to POSIXt, <code>FALSE</code>
otherwise.
</p>


<hr>
<a id="method-CFTime-cut"></a>



<h4>Method <code>cut()</code></h4>

<p>Create a factor for a <code>CFTime</code> instance.
</p>
<p>When argument <code>breaks</code> is one of <code style="white-space: pre;">&#8288;"year", "season", "quarter", "month", "dekad", "day"&#8288;</code>, a factor is generated like by <code><a href="#topic+CFfactor">CFfactor()</a></code>. When
<code>breaks</code> is a vector of character timestamps a factor is produced with
a level for every interval between timestamps. The last timestamp,
therefore, is only used to close the interval started by the
pen-ultimate timestamp - use a distant timestamp (e.g. <code>range(x)[2]</code>)
to ensure that all offsets to the end of the CFTime time series are
included, if so desired. The last timestamp will become the upper bound
in the <code>CFTime</code> instance that is returned as an attribute to this
function so a sensible value for the last timestamp is advisable.
</p>
<p>This method works similar to <code><a href="base.html#topic+cut.POSIXt">base::cut.POSIXt()</a></code> but there are some
differences in the arguments: for <code>breaks</code> the set of options is
different and no preceding integer is allowed, <code>labels</code> are always
assigned using values of <code>breaks</code>, and the interval is always
left-closed.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$cut(breaks)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>breaks</code></dt><dd><p>A character string of a factor period (see <code><a href="#topic+CFfactor">CFfactor()</a></code> for
a description), or a character vector of timestamps that conform to the
calendar of <code>x</code>, with a length of at least 2. Timestamps must be given
in ISO8601 format, e.g. &quot;2024-04-10 21:31:43&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A factor with levels according to the <code>breaks</code> argument, with
attributes 'period', 'era' and 'CFTime'. When <code>breaks</code> is a factor
period, attribute 'period' has that value, otherwise it is '&quot;day&quot;'.
When <code>breaks</code> is a character vector of timestamps, attribute 'CFTime'
holds an instance of <code>CFTime</code> that has the same definition as <code>x</code>, but
with (ordered) offsets generated from the <code>breaks</code>. Attribute 'era'
is always -1.
</p>


<hr>
<a id="method-CFTime-factor"></a>



<h4>Method <code>factor()</code></h4>

<p>Generate a factor for the offsets, or a part thereof. This is
specifically interesting for creating factors from the date part of the
time series that aggregate the time series into longer time periods (such
as month) that can then be used to process daily CF data sets using, for
instance, <code>tapply()</code>.
</p>
<p>The factor will respect the calendar that the time series is built on.
</p>
<p>The factor will be generated in the order of the offsets. While typical
CF-compliant data sources use ordered time series there is, however, no
guarantee that the factor is ordered. For most processing with a factor
the ordering is of no concern.
</p>
<p>If the <code>era</code> parameter is specified, either as a vector of years to
include in the factor, or as a list of such vectors, the factor will only
consider those values in the time series that fall within the list of
years, inclusive of boundary values. Other values in the factor will be
set to <code>NA</code>. The years need not be contiguous, within a single vector or
among the list items, or in order.
</p>
<p>The following periods are supported by this method:
</p>

<ul>
<li> <p><code>year</code>, the year of each offset is returned as &quot;YYYY&quot;.
</p>
</li>
<li> <p><code>season</code>, the meteorological season of each offset is returned as
&quot;Sx&quot;, with x being 1-4, preceeded by &quot;YYYY&quot; if no <code>era</code> is
specified. Note that December dates are labeled as belonging to the
subsequent year, so the date &quot;2020-12-01&quot; yields &quot;2021S1&quot;. This implies
that for standard CMIP files having one or more full years of data the
first season will have data for the first two months (January and
February), while the final season will have only a single month of data
(December).
</p>
</li>
<li> <p><code>quarter</code>, the calendar quarter of each offset is returned as &quot;Qx&quot;,
with x being 1-4, preceeded by &quot;YYYY&quot; if no <code>era</code> is specified.
</p>
</li>
<li> <p><code>month</code>, the month of each offset is returned as &quot;01&quot; to
&quot;12&quot;, preceeded by &quot;YYYY-&quot; if no <code>era</code> is specified. This is the default
period.
</p>
</li>
<li> <p><code>dekad</code>, ten-day periods are returned as
&quot;Dxx&quot;, where xx runs from &quot;01&quot; to &quot;36&quot;, preceeded by &quot;YYYY&quot; if no <code>era</code>
is specified. Each month is subdivided in dekads as follows: 1- days 01 -
10; 2- days 11 - 20; 3- remainder of the month.
</p>
</li>
<li> <p><code>day</code>, the month and day of each offset are returned as &quot;MM-DD&quot;,
preceeded by &quot;YYYY-&quot; if no <code>era</code> is specified.
</p>
</li></ul>

<p>It is not possible to create a factor for a period that is shorter than
the temporal resolution of the calendar. As an example, if the calendar
has a monthly unit, a dekad or day factor cannot be created.
</p>
<p>Creating factors for other periods is not supported by this method.
Factors based on the timestamp information and not dependent on the
calendar can trivially be constructed from the output of the
<code><a href="#topic+as_timestamp">as_timestamp()</a></code> function.
</p>
<p>For non-era factors the attribute 'CFTime' of the result contains a
<code>CFTime</code> instance that is valid for the result of applying the factor to
a resource that this instance is associated with. In other words, if
<code>CFTime</code> instance 'At' describes the temporal dimension of resource 'A'
and a factor 'Af' is generated from <code>Af &lt;- At$factor()</code>, then
<code>Bt &lt;- attr(Af, "CFTime")</code> describes the temporal dimension of the result
of, say, <code>B &lt;- apply(A, 1:2, tapply, Af, FUN)</code>. The 'CFTime' attribute is
<code>NULL</code> for era factors.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$factor(period = "month", era = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>period</code></dt><dd><p>character. A character string with one of the values
&quot;year&quot;, &quot;season&quot;, &quot;quarter&quot;, &quot;month&quot; (the default), &quot;dekad&quot; or &quot;day&quot;.</p>
</dd>
<dt><code>era</code></dt><dd><p>numeric or list, optional. Vector of years for which to
construct the factor, or a list whose elements are each a vector of
years. If <code>era</code> is not specified, the factor will use the entire time
series for the factor.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If <code>era</code> is a single vector or not specified, a factor with a
length equal to the number of offsets in this instance. If <code>era</code> is a
list, a list with the same number of elements and names as <code>era</code>,
each containing a factor. Elements in the factor will be set to <code>NA</code>
for time series values outside of the range of specified years.
</p>
<p>The factor, or factors in the list, have attributes 'period', 'era'
and 'CFTime'. Attribute 'period' holds the value of the <code>period</code>
argument. Attribute 'era' indicates the number of years that are
included in the era, or -1 if no <code>era</code> is provided. Attribute
'CFTime' holds an instance of <code>CFTime</code> that has the same definition as
this instance, but with offsets corresponding to the mid-point of
non-era factor levels; if the <code>era</code> argument is specified,
attribute 'CFTime' is <code>NULL</code>.
</p>


<hr>
<a id="method-CFTime-factor_units"></a>



<h4>Method <code>factor_units()</code></h4>

<p>Given a factor as produced by <code>CFTime$factor()</code>, this method
will return a numeric vector with the number of time units in each
level of the factor.
</p>
<p>The result of this method is useful to convert between absolute and
relative values. Climate change anomalies, for instance, are usually
computed by differencing average values between a future period and a
baseline period. Going from average values back to absolute values for
an aggregate period (which is typical for temperature and
precipitation, among other variables) is easily done with the result of
this method, without having to consider the specifics of the calendar
of the data set.
</p>
<p>If the factor <code>f</code> is for an era (e.g. spanning multiple years and the
levels do not indicate the specific year), then the result will
indicate the number of time units of the period in a regular single
year. In other words, for an era of 2041-2060 and a monthly factor on a
standard calendar with a <code>days</code> unit, the result will be
<code>c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)</code>. Leap days are thus
only considered for the <code style="white-space: pre;">&#8288;366_day&#8288;</code> and <code>all_leap</code> calendars.
</p>
<p>Note that this function gives the number of time units in each level of
the factor - the actual number of data points in the time series per
factor level may be different. Use <code><a href="#topic+CFfactor_coverage">CFfactor_coverage()</a></code> to determine
the actual number of data points or the coverage of data points
relative to the factor level.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$factor_units(f)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>f</code></dt><dd><p>A factor or a list of factors derived from the method
<code>CFTime$factor()</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If <code>f</code> is a factor, a numeric vector with a length equal to the
number of levels in the factor, indicating the number of time units in
each level of the factor. If <code>f</code> is a list of factors, a list with each
element a numeric vector as above.
</p>


<hr>
<a id="method-CFTime-factor_coverage"></a>



<h4>Method <code>factor_coverage()</code></h4>

<p>Calculate the number of time elements, or the relative
coverage, in each level of a factor generated by <code>CFTime$factor()</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$factor_coverage(f, coverage = "absolute")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>f</code></dt><dd><p>A factor or a list of factors derived from the method
<code>CFTime$factor()</code>.</p>
</dd>
<dt><code>coverage</code></dt><dd><p>&quot;absolute&quot; or &quot;relative&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If <code>f</code> is a factor, a numeric vector with a length equal to the
number of levels in the factor, indicating the number of units from the
time series contained in each level of the factor when
<code>coverage = "absolute"</code> or the proportion of units present relative to the
maximum number when <code>coverage = "relative"</code>. If <code>f</code> is a list of factors, a
list with each element a numeric vector as above.
</p>


<hr>
<a id="method-CFTime-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CFTime$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://cfconventions.org/Data/cf-conventions/cf-conventions-1.12/cf-conventions.html#time-coordinate
</p>

<hr>
<h2 id='CFtime-function'>Create a CFTime object</h2><span id='topic+CFtime-function'></span><span id='topic+CFtime'></span>

<h3>Description</h3>

<p>This function creates an instance of the <a href="#topic+CFTime">CFTime</a> class. The arguments to the
call are typically read from a CF-compliant data file with climatological
observations or climate projections. Specification of arguments can also be
made manually in a variety of combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFtime(definition, calendar = "standard", offsets = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CFtime-function_+3A_definition">definition</code></td>
<td>
<p>A character string describing the time coordinate.</p>
</td></tr>
<tr><td><code id="CFtime-function_+3A_calendar">calendar</code></td>
<td>
<p>A character string describing the calendar to use with the
time dimension definition string. Default value is &quot;standard&quot;.</p>
</td></tr>
<tr><td><code id="CFtime-function_+3A_offsets">offsets</code></td>
<td>
<p>Numeric or character vector, optional. When numeric, a vector
of offsets from the origin in the time series. When a character vector of
length 2 or more, timestamps in ISO8601 or UDUNITS format. When a character
string, a timestamp in ISO8601 or UDUNITS format and then a time series
will be generated with a separation between steps equal to the unit of
measure in the definition, inclusive of the definition timestamp. The unit
of measure of the offsets is defined by the time series definition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of the <code>CFTime</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CFtime("days since 1850-01-01", "julian", 0:364)

CFtime("hours since 2023-01-01", "360_day", "2023-01-30T23:00")
</code></pre>

<hr>
<h2 id='cut.CFTime'>Create a factor for a <code>CFTime</code> instance</h2><span id='topic+cut.CFTime'></span><span id='topic+cut'></span>

<h3>Description</h3>

<p>Method for <code><a href="base.html#topic+cut">base::cut()</a></code> applied to <a href="#topic+CFTime">CFTime</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CFTime'
cut(x, breaks, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut.CFTime_+3A_x">x</code></td>
<td>
<p>An instance of <code>CFTime</code>.</p>
</td></tr>
<tr><td><code id="cut.CFTime_+3A_breaks">breaks</code></td>
<td>
<p>A character string of a factor period (see <code><a href="#topic+CFfactor">CFfactor()</a></code> for a
description), or a character vector of timestamps that conform to the
calendar of <code>x</code>, with a length of at least 2. Timestamps must be given in
ISO8601 format, e.g. &quot;2024-04-10 21:31:43&quot;.</p>
</td></tr>
<tr><td><code id="cut.CFTime_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>breaks</code> is one of <code style="white-space: pre;">&#8288;"year", "season", "quarter", "month", "dekad", "day"&#8288;</code> a factor is generated like by <code><a href="#topic+CFfactor">CFfactor()</a></code>.
</p>
<p>When <code>breaks</code> is a vector of character timestamps a factor is produced with a
level for every interval between timestamps. The last timestamp, therefore,
is only used to close the interval started by the pen-ultimate timestamp -
use a distant timestamp (e.g. <code>range(x)[2]</code>) to ensure that all offsets to
the end of the CFTime time series are included, if so desired. The last
timestamp will become the upper bound in the <code>CFTime</code> instance that is
returned as an attribute to this function so a sensible value for the last
timestamp is advisable.
</p>
<p>This method works similar to <code><a href="base.html#topic+cut.POSIXt">base::cut.POSIXt()</a></code> but there are some
differences in the arguments: for <code>breaks</code> the set of options is different
and no preceding integer is allowed, <code>labels</code> are always assigned using
values of <code>breaks</code>, and the interval is always left-closed.
</p>


<h3>Value</h3>

<p>A factor with levels according to the <code>breaks</code> argument, with
attributes 'period', 'era' and 'CFTime'. When <code>breaks</code> is a factor
period, attribute 'period' has that value, otherwise it is '&quot;day&quot;'. When
<code>breaks</code> is a character vector of timestamps, attribute 'CFTime' holds an
instance of <code>CFTime</code> that has the same definition as <code>x</code>, but with (ordered)
offsets generated from the <code>breaks</code>. Attribute 'era' is always -1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CFfactor">CFfactor()</a></code> produces a factor for several fixed periods, including
for eras.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- CFtime("days since 2021-01-01", "365_day", 0:729)
breaks &lt;- c("2022-02-01", "2021-12-01", "2023-01-01")
cut(x, breaks)
</code></pre>

<hr>
<h2 id='definition'>Properties of a CFTime object</h2><span id='topic+definition'></span><span id='topic+properties'></span><span id='topic+calendar'></span><span id='topic+unit'></span><span id='topic+origin'></span><span id='topic+timezone'></span><span id='topic+offsets'></span><span id='topic+resolution'></span>

<h3>Description</h3>

<p>These functions return the properties of an instance of the
<a href="#topic+CFTime">CFTime</a> class. The properties are all read-only, but offsets can be added
using the <code>+</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>definition(t)

calendar(t)

unit(t)

origin(t)

timezone(t)

offsets(t)

resolution(t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="definition_+3A_t">t</code></td>
<td>
<p>An instance of <code>CFTime</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>calendar()</code> and <code>unit()</code> return a character string.
<code>origin()</code> returns a data frame of timestamp elements with a single row
of data. <code>timezone()</code> returns the calendar time zone as a character
string. <code>offsets()</code> returns a vector of offsets or <code>NULL</code> if no offsets
have been set.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>definition()</code>: The definition string of the <code>CFTime</code> instance.
</p>
</li>
<li> <p><code>calendar()</code>: The calendar of the <code>CFTime</code> instance.
</p>
</li>
<li> <p><code>unit()</code>: The unit of the <code>CFTime</code> instance.
</p>
</li>
<li> <p><code>origin()</code>: The origin of the <code>CFTime</code> instance in timestamp elements.
</p>
</li>
<li> <p><code>timezone()</code>: The time zone of the calendar of the <code>CFTime</code> instance as a character string.
</p>
</li>
<li> <p><code>offsets()</code>: The offsets of the <code>CFTime</code> instance as a numeric vector.
</p>
</li>
<li> <p><code>resolution()</code>: The average separation between the offsets in the <code>CFTime</code> instance.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("days since 1850-01-01", "julian", 0:364)
definition(t)
calendar(t)
unit(t)
timezone(t)
origin(t)
offsets(t)
resolution(t)
</code></pre>

<hr>
<h2 id='deprecated_functions'>Deprecated functions</h2><span id='topic+deprecated_functions'></span><span id='topic+CFtimestamp'></span><span id='topic+CFmonth_days'></span><span id='topic+CFcomplete'></span><span id='topic+CFsubset'></span><span id='topic+CFparse'></span>

<h3>Description</h3>

<p>These functions are deprecated and should no longer be used in new code. The
below table gives the replacement function to use instead. The function
arguments of the replacement function are the same as those of the deprecated
function if no arguments are given in the table.</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>Deprecated function</strong> </td><td style="text-align: left;"> <strong>Replacement function</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   CFcomplete() </td><td style="text-align: left;"> <code><a href="#topic+is_complete">is_complete()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   CFmonth_days() </td><td style="text-align: left;"> <code><a href="#topic+month_days">month_days()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   CFparse() </td><td style="text-align: left;"> <code><a href="#topic+parse_timestamps">parse_timestamps()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   CFrange() </td><td style="text-align: left;"> <code><a href="base.html#topic+range">range()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   CFsubset() </td><td style="text-align: left;"> <code><a href="#topic+slab">slab()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   CFtimestamp() </td><td style="text-align: left;"> <code><a href="#topic+as_timestamp">as_timestamp()</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>CFtimestamp(t, format = NULL, asPOSIX = FALSE)

CFmonth_days(t, x = NULL)

CFcomplete(x)

CFsubset(x, extremes)

CFparse(t, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deprecated_functions_+3A_t">t</code>, <code id="deprecated_functions_+3A_x">x</code>, <code id="deprecated_functions_+3A_format">format</code>, <code id="deprecated_functions_+3A_asposix">asPOSIX</code>, <code id="deprecated_functions_+3A_extremes">extremes</code></td>
<td>
<p>See replacement functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See replacement functions.
</p>

<hr>
<h2 id='indexOf'>Find the index of timestamps in the time series</h2><span id='topic+indexOf'></span>

<h3>Description</h3>

<p>Find the index in the time series for each timestamp given in argument <code>x</code>.
Values of <code>x</code> that are before the earliest value in <code>y</code> will be returned as
<code>0</code>; values of <code>x</code> that are after the latest values in <code>y</code> will be returned
as <code>.Machine$integer.max</code>. Alternatively, when <code>x</code> is a numeric vector of
index values, return the valid indices of the same vector, with the side
effect being the attribute &quot;CFTime&quot; associated with the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexOf(x, y, method = "constant")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indexOf_+3A_x">x</code></td>
<td>
<p>Vector of <code>character</code>, <code>POSIXt</code> or <code>Date</code> values to find indices
for, or a numeric vector.</p>
</td></tr>
<tr><td><code id="indexOf_+3A_y">y</code></td>
<td>
<p><a href="#topic+CFTime">CFTime</a> instance.</p>
</td></tr>
<tr><td><code id="indexOf_+3A_method">method</code></td>
<td>
<p>Single value of &quot;constant&quot; or &quot;linear&quot;. If <code>"constant"</code> or when
bounds are set on argument <code>y</code>, return the index value for each match. If
<code>"linear"</code>, return the index value with any fractional value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Timestamps can be provided as vectors of character strings, <code>POSIXct</code> or
<code>Date.</code>
</p>
<p>Matching also returns index values for timestamps that fall between two
elements of the time series - this can lead to surprising results when time
series elements are positioned in the middle of an interval (as the CF
Metadata Conventions instruct us to &quot;reasonably assume&quot;): a time series of
days in January would be encoded in a netCDF file as
<code>c("2024-01-01 12:00:00", "2024-01-02 12:00:00", "2024-01-03 12:00:00", ...)</code>
so <code>x &lt;- c("2024-01-01", "2024-01-02", "2024-01-03")</code> would result in
<code style="white-space: pre;">&#8288;(NA, 1, 2)&#8288;</code> (or <code style="white-space: pre;">&#8288;(NA, 1.5, 2.5)&#8288;</code> with <code>method = "linear"</code>) because the date
values in <code>x</code> are at midnight. This situation is easily avoided by ensuring
that <code>y</code> has bounds set (use <code>bounds(y) &lt;- TRUE</code> as a proximate solution if
bounds are not stored in the netCDF file). See the Examples.
</p>
<p>If bounds are set, the indices are taken from those bounds. Returned indices
may fall in between bounds if the latter are not contiguous, with the
exception of the extreme values in <code>x</code>.
</p>
<p>Values of <code>x</code> that are not valid timestamps according to the calendar of <code>y</code>
will be returned as <code>NA</code>.
</p>
<p><code>x</code> can also be a numeric vector of index values, in which case the valid
values in <code>x</code> are returned. If negative values are passed, the positive
counterparts will be excluded and then the remainder returned. Positive and
negative values may not be mixed. Using a numeric vector has the side effect
that the result has the attribute &quot;CFTime&quot; describing the temporal dimension
of the slice. If index values outside of the range of <code>y</code> (<code>1:length(y)</code>) are
provided, an error will be thrown.
</p>


<h3>Value</h3>

<p>A numeric vector giving indices into the &quot;time&quot; dimension of the
data set associated with <code>y</code> for the values of <code>x</code>. If there is at least 1
valid index, then attribute &quot;CFTime&quot; contains an instance of <code>CFTime</code> that
describes the dimension of filtering the data set associated with <code>y</code> with
the result of this function, excluding any <code>NA</code>, <code>0</code> and
<code>.Machine$integer.max</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("days since 2020-01-01", "360_day", 1440:1799 + 0.5)
as_timestamp(cf)[1:3]
x &lt;- c("2024-01-01", "2024-01-02", "2024-01-03")
indexOf(x, cf)
indexOf(x, cf, method = "linear")

bounds(cf) &lt;- TRUE
indexOf(x, cf)

# Non-existent calendar day in a `360_day` calendar
x &lt;- c("2024-03-30", "2024-03-31", "2024-04-01")
indexOf(x, cf)

# Numeric x
indexOf(c(29, 30, 31), cf)
</code></pre>

<hr>
<h2 id='is_complete'>Indicates if the time series is complete</h2><span id='topic+is_complete'></span>

<h3>Description</h3>

<p>This function indicates if the time series is complete, meaning that the time
steps are equally spaced and there are thus no gaps in the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_complete(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_complete_+3A_x">x</code></td>
<td>
<p>An instance of the <a href="#topic+CFTime">CFTime</a> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives exact results for time series where the nominal
<em>unit of separation</em> between observations in the time series is exact in
terms of the calendar unit. As an example, for a calendar unit of &quot;days&quot; where the
observations are spaced a fixed number of days apart the result is exact, but
if the same calendar unit is used for data that is on a monthly basis, the
<em>assessment</em> is approximate because the number of days per month is variable
and dependent on the calendar (the exception being the <code style="white-space: pre;">&#8288;360_day&#8288;</code> calendar,
where the assessment is exact). The <em>result</em> is still correct in most cases
(including all CF-compliant data sets that the developers have seen) although
there may be esoteric constructions of CFTime and offsets that trip up this
implementation.
</p>


<h3>Value</h3>

<p>logical. <code>TRUE</code> if the time series is complete, with no gaps;
<code>FALSE</code> otherwise. If no offsets have been added to the <code>CFTime</code> instance,
<code>NA</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("days since 1850-01-01", "julian", 0:364)
is_complete(t)
</code></pre>

<hr>
<h2 id='length.CFTime'>The length of the offsets contained in the <code>CFTime</code> instance.</h2><span id='topic+length.CFTime'></span>

<h3>Description</h3>

<p>The length of the offsets contained in the <code>CFTime</code> instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CFTime'
length(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="length.CFTime_+3A_x">x</code></td>
<td>
<p>The <code>CFTime</code> instance whose length will be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of offsets in the specified <code>CFTime</code> instance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("days since 1850-01-01", "julian", 0:364)
length(t)
</code></pre>

<hr>
<h2 id='month_days'>Return the number of days in a month given a certain CF calendar</h2><span id='topic+month_days'></span>

<h3>Description</h3>

<p>Given a vector of dates as strings in ISO 8601 or UDUNITS format and a
<a href="#topic+CFTime">CFTime</a> object, this function will return a vector of the same length as the
dates, indicating the number of days in the month according to the calendar
specification. If no vector of days is supplied, the function will return an
integer vector of length 12 with the number of days for each month of the
calendar (disregarding the leap day for <code>standard</code> and <code>julian</code> calendars).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>month_days(t, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="month_days_+3A_t">t</code></td>
<td>
<p>The <code>CFtime</code> instance to use.</p>
</td></tr>
<tr><td><code id="month_days_+3A_x">x</code></td>
<td>
<p>character. An optional vector of dates as strings with format
<code>YYYY-MM-DD</code>. Any time part will be silently ingested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector indicating the number of days in each month for the vector
of dates supplied as argument <code style="white-space: pre;">&#8288;x. Invalidly specified dates will result in an &#8288;</code>NA' value. If no dates are supplied, the number of days per month for
the calendar as a vector of length 12.
</p>


<h3>See Also</h3>

<p>When working with factors generated by <code><a href="#topic+CFfactor">CFfactor()</a></code>, it is usually
better to use <code><a href="#topic+CFfactor_units">CFfactor_units()</a></code> as that will consider leap days for
non-era factors. <code><a href="#topic+CFfactor_units">CFfactor_units()</a></code> can also work with other time periods
and calendar units, such as &quot;hours per month&quot;, or &quot;days per season&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- c("2021-11-27", "2021-12-10", "2022-01-14", "2022-02-18")
t &lt;- CFtime("days since 1850-01-01", "standard")
month_days(t, dates)

t &lt;- CFtime("days since 1850-01-01", "360_day")
month_days(t, dates)

t &lt;- CFtime("days since 1850-01-01", "all_leap")
month_days(t, dates)

month_days(t)
</code></pre>

<hr>
<h2 id='parse_timestamps'>Parse series of timestamps in CF format to date-time elements</h2><span id='topic+parse_timestamps'></span>

<h3>Description</h3>

<p>This function will parse a vector of timestamps in ISO8601 or UDUNITS format
into a data frame with columns for the elements of the timestamp: year,
month, day, hour, minute, second, time zone. Those timestamps that could not
be parsed or which represent an invalid date in the indicated <code>CFtime</code>
instance will have <code>NA</code> values for the elements of the offending timestamp
(which will generate a warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_timestamps(t, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_timestamps_+3A_t">t</code></td>
<td>
<p>An instance of <code>CFTime</code> to use when parsing the date.</p>
</td></tr>
<tr><td><code id="parse_timestamps_+3A_x">x</code></td>
<td>
<p>Vector of character strings representing timestamps in
ISO8601 extended or UDUNITS broken format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supported formats are the <em>broken timestamp</em> format from the UDUNITS
library and ISO8601 <em>extended</em>, both with minor changes, as suggested by the
CF Metadata Conventions. In general, the format is <code style="white-space: pre;">&#8288;YYYY-MM-DD hh:mm:ss.sss hh:mm&#8288;</code>. The year can be from 1 to 4 digits and is interpreted literally, so
<code>79-10-24</code> is the day Mount Vesuvius erupted and destroyed Pompeii, not
<code>1979-10-24</code>. The year and month are mandatory, all other fields are
optional. There are defaults for all missing values, following the UDUNITS
and CF Metadata Conventions. Leading zeros can be omitted in the UDUNITS
format, but not in the ISO8601 format. The optional fractional part can have
as many digits as the precision calls for and will be applied to the smallest
specified time unit. In the result of this function, if the fraction is
associated with the minute or the hour, it is converted into a regular
<code>hh:mm:ss.sss</code> format, i.e. any fraction in the result is always associated
with the second, rounded down to milli-second accuracy. The separator between
the date and the time can be a single whitespace character or a <code>T</code>.
</p>
<p>The time zone is optional and should have at least the hour or <code>Z</code> if
present, the minute is optional. The time zone hour can have an optional
sign. In the UDUNITS format the separator between the time and the time zone
must be a single whitespace character, in ISO8601 there is no separation
between the time and the timezone. Time zone names are not supported (as
neither UDUNITS nor ISO8601 support them) and will cause parsing to fail when
supplied, with one exception: the designator &quot;UTC&quot; is silently dropped (i.e.
interpreted as &quot;00:00&quot;).
</p>
<p>Currently only the extended formats (with separators between the elements)
are supported. The vector of timestamps may have any combination of ISO8601
and UDUNITS formats.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with constituent elements of the parsed timestamps in
numeric format. The columns are year, month, day, hour, minute, second
(with an optional fraction), time zone (character string), and the
corresponding offset value from the origin. Invalid input data will appear
as <code>NA</code> - if this is the case, a warning message will be displayed - other
missing information on input will use default values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("days since 0001-01-01", "proleptic_gregorian")

# This will have `NA`s on output and generate a warning
timestamps &lt;- c("2012-01-01T12:21:34Z", "12-1-23", "today",
                "2022-08-16T11:07:34.45-10", "2022-08-16 10.5+04")
parse_timestamps(t, timestamps)
</code></pre>

<hr>
<h2 id='range.CFTime'>Extreme time series values</h2><span id='topic+range.CFTime'></span>

<h3>Description</h3>

<p>Character representation of the extreme values in the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CFTime'
range(x, format = "", bounds = FALSE, ..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="range.CFTime_+3A_x">x</code></td>
<td>
<p>An instance of the <a href="#topic+CFTime">CFTime</a> class.</p>
</td></tr>
<tr><td><code id="range.CFTime_+3A_format">format</code></td>
<td>
<p>A character string with format specifiers, optional. If it is
missing or an empty string, the most economical ISO8601 format is chosen:
&quot;date&quot; when no time information is present in <code>x</code>, &quot;timestamp&quot; otherwise.
Otherwise a suitable format specifier can be provided.</p>
</td></tr>
<tr><td><code id="range.CFTime_+3A_bounds">bounds</code></td>
<td>
<p>Logical to indicate if the extremes from the bounds should be
used, if set. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="range.CFTime_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="range.CFTime_+3A_na.rm">na.rm</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of two character representations of the extremes of the time
series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("days since 1850-01-01", "julian", 0:364)
range(cf)
range(cf, "%Y-%b-%e")
</code></pre>

<hr>
<h2 id='slab'>Which time steps fall within two extreme values</h2><span id='topic+slab'></span>

<h3>Description</h3>

<p>Avoid using this function, use <code><a href="#topic+slice">slice()</a></code> instead. This function will be
deprecated in the near future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slab(x, extremes, rightmost.closed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slab_+3A_x">x</code>, <code id="slab_+3A_extremes">extremes</code>, <code id="slab_+3A_rightmost.closed">rightmost.closed</code></td>
<td>
<p>See <code>slice()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code>slice()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("hours since 2023-01-01 00:00:00", "standard", 0:23)
slab(t, c("2022-12-01", "2023-01-01 03:00"))
</code></pre>

<hr>
<h2 id='slice'>Which time steps fall within two extreme values</h2><span id='topic+slice'></span>

<h3>Description</h3>

<p>Given two extreme character timestamps, return a logical vector of a length
equal to the number of time steps in the <a href="#topic+CFTime">CFTime</a> instance with values <code>TRUE</code>
for those time steps that fall between the two extreme values, <code>FALSE</code>
otherwise. This can be used to select slices from the time series in reading
or analysing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(x, extremes, rightmost.closed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_+3A_x">x</code></td>
<td>
<p>The <code>CFTime</code> instance to operate on.</p>
</td></tr>
<tr><td><code id="slice_+3A_extremes">extremes</code></td>
<td>
<p>Character vector of two timestamps that represent the
extremes of the time period of interest. The timestamps must be in
increasing order. The timestamps need not fall in the range of the time
steps in argument 'x.</p>
</td></tr>
<tr><td><code id="slice_+3A_rightmost.closed">rightmost.closed</code></td>
<td>
<p>Is the larger extreme value included in the result?
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If bounds were set these will be preserved.
</p>


<h3>Value</h3>

<p>A logical vector with a length equal to the number of time steps in
<code>x</code> with values <code>TRUE</code> for those time steps that fall between the two
extreme values, <code>FALSE</code> otherwise. The earlier timestamp is included, the
later timestamp is excluded. A specification of <code>c("2022-01-01", "2023-01-01")</code>
will thus include all time steps that fall in the year 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- CFtime("hours since 2023-01-01 00:00:00", "standard", 0:23)
slice(t, c("2022-12-01", "2023-01-01 03:00"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
