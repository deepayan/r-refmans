<!DOCTYPE html><html><head><title>Help for package CFtime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CFtime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CFtime-package'><p>CFtime: working with CF Metadata Conventions &quot;time&quot; dimensions</p></a></li>
<li><a href='#+2B+2CCFtime+2CCFtime-method'><p>Merge two CFtime objects</p></a></li>
<li><a href='#+2B+2CCFtime+2Cnumeric-method'><p>Extend a CFtime object with additional offsets</p></a></li>
<li><a href='#+3D+3D+2CCFtime+2CCFtime-method'><p>Equivalence of CFtime objects</p></a></li>
<li><a href='#CFcomplete'><p>Indicates if the time series is complete</p></a></li>
<li><a href='#CFdefinition'><p>Properties of a CFtime object</p></a></li>
<li><a href='#CFfactor'><p>Create a factor from the offsets in an CFtime instance</p></a></li>
<li><a href='#CFfactor_coverage'><p>Coverage of time elements for each factor level</p></a></li>
<li><a href='#CFfactor_units'><p>Number of base time units in each factor level</p></a></li>
<li><a href='#CFmonth_days'><p>Return the number of days in a month given a certain CF calendar</p></a></li>
<li><a href='#CFparse'><p>Parse series of timestamps in CF format to date-time elements</p></a></li>
<li><a href='#CFrange'><p>Extreme time series values</p></a></li>
<li><a href='#CFsubset'><p>Which time steps fall within two extreme values</p></a></li>
<li><a href='#CFtime'><p>Create a CFtime object</p></a></li>
<li><a href='#CFtime-class'><p>CF Metadata Conventions time representation</p></a></li>
<li><a href='#CFtimestamp'><p>Create a vector that represents CF timestamps</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Using CF-Compliant Calendars with Climate Projection Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Support for all calendars as specified in the Climate and Forecast 
    (CF) Metadata Conventions for climate and forecasting data. The CF Metadata 
    Conventions is widely used for distributing files with climate observations 
    or projections, including the Coupled Model Intercomparison Project (CMIP) 
    data used by climate change scientists and the Intergovernmental Panel on
    Climate Change (IPCC). This package specifically allows the user to work 
    with any of the CF-compliant calendars (many of which are not compliant with 
    POSIXt). The CF time coordinate is formally defined in the CF Metadata 
    Conventions document available at <a href="https://cfconventions.org/Data/cf-conventions/cf-conventions-1.10/cf-conventions.html#time-coordinate">https://cfconventions.org/Data/cf-conventions/cf-conventions-1.10/cf-conventions.html#time-coordinate</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ncdf4, RNetCDF, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pvanlaake/CFtime">https://github.com/pvanlaake/CFtime</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pvanlaake/CFtime/issues">https://github.com/pvanlaake/CFtime/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-28 10:28:22 UTC; patrickvanlaake</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Van Laake [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Van Laake &lt;patrick@vanlaake.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 11:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='CFtime-package'>CFtime: working with CF Metadata Conventions &quot;time&quot; dimensions</h2><span id='topic+CFtime-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Support for all calendars as specified in the Climate and Forecast
(CF) Metadata Conventions for climate and forecasting data. The CF Metadata
Conventions is widely used for distributing files with climate observations
or projections, including the Coupled Model Intercomparison Project (CMIP)
data used by climate change scientists and the Intergovernmental Panel on
Climate Change (IPCC). This package specifically allows the user to work
with any of the CF-compliant calendars (many of which are not compliant with
POSIXt). The CF time coordinate is formally defined in the
<a href="https://cfconventions.org/Data/cf-conventions/cf-conventions-1.10/cf-conventions.html#time-coordinate">CF Metadata Conventions document</a>.
</p>


<h3>Details</h3>

<p>The package can create a <code>CFtime</code> instance from scratch or, more commonly, it
can use the dimension attributes and dimension variable values from a NetCDF
resource. The package does not actually do any of the reading and the user is
free to use their NetCDF package of preference (with the two main options
being <a href="https://cran.r-project.org/package=RNetCDF">RNetCDF</a> and
<a href="https://cran.r-project.org/package=ncdf4">ncdf4</a>).
</p>
<p><strong>Create, modify, inquire</strong>
</p>

<ul>
<li> <p><code><a href="#topic+CFtime">CFtime()</a></code>: Create a CFtime instance
</p>
</li>
<li> <p><code><a href="#topic+CFproperties">Properties</a></code> of the CFtime instance
</p>
</li>
<li> <p><code><a href="#topic+CFparse">CFparse()</a></code>: Parse a vector of character timestamps into CFtime elements
</p>
</li>
<li> <p><code><a href="#topic+CFtime-equivalent">Compare</a></code> two CFtime instances
</p>
</li>
<li> <p><code><a href="#topic+CFtime-merge">Merge</a></code> two CFtime instances
</p>
</li>
<li> <p><code><a href="#topic+CFtime-append">Append</a></code> additional time steps to a CFtime instance
</p>
</li>
<li> <p><code><a href="#topic+CFtimestamp">CFtimestamp()</a></code>: Generate a vector of character or <code>POSIXct</code> timestamps from a CFtime instance
</p>
</li>
<li> <p><code><a href="#topic+CFrange">CFrange()</a></code>: Timestamps of the two endpoints in the time series
</p>
</li>
<li> <p><code><a href="#topic+CFcomplete">CFcomplete()</a></code>: Does the CFtime instance have a complete time series between endpoints?
</p>
</li>
<li> <p><code><a href="#topic+CFmonth_days">CFmonth_days()</a></code>: How many days are there in a month using the CFtime calendar?
</p>
</li></ul>

<p><strong>Factors and coverage</strong>
</p>

<ul>
<li> <p><code><a href="#topic+CFfactor">CFfactor()</a></code>: Create factors for different time periods
</p>
</li>
<li> <p><code><a href="#topic+CFfactor_units">CFfactor_units()</a></code>: How many units of time are there in each factor level?
</p>
</li>
<li> <p><code><a href="#topic+CFfactor_coverage">CFfactor_coverage()</a></code>: How much data is available for each level of the factor?
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Patrick Van Laake <a href="mailto:patrick@vanlaake.net">patrick@vanlaake.net</a> [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/pvanlaake/CFtime">https://github.com/pvanlaake/CFtime</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pvanlaake/CFtime/issues">https://github.com/pvanlaake/CFtime/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+2B+2CCFtime+2CCFtime-method'>Merge two CFtime objects</h2><span id='topic++2B+2CCFtime+2CCFtime-method'></span><span id='topic+CFtime-merge'></span>

<h3>Description</h3>

<p>Two <code>CFtime</code> instances can be merged into one with this operator, provided
that the units and calendars of the datums of the two instances are
equivalent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CFtime,CFtime'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B+2B2CCFtime+2B2CCFtime-method_+3A_e1">e1</code>, <code id="+2B2B+2B2CCFtime+2B2CCFtime-method_+3A_e2">e2</code></td>
<td>
<p>CFtime. Instances of the <code>CFtime</code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the origins of the two datums are not identical, the earlier origin is
preserved and the offsets of the later origin are updated in the resulting
CFtime instance.
</p>
<p>The order of the two parameters is indirectly significant. The resulting
<code>CFtime</code> instance will have the offsets of both instances in the order that
they are specified. There is no reordering or removal of duplicates. This is
because the time series are usually associated with a data set and the
correspondence between the data in the files and the CFtime instance is thus
preserved. When merging the data sets described by this time series, the
order must be identical to the merging here.
</p>


<h3>Value</h3>

<p>A <code>CFtime</code> object with a set of offsets composed of the offsets of
the instances of <code>CFtime</code> that the operator operates on. If the datum units
or calendars of the <code>CFtime</code> instances are not equivalent, an error is
thrown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- CFtime("days since 1850-01-01", "gregorian", 0:364)
e2 &lt;- CFtime("days since 1850-01-01 00:00:00", "standard", 365:729)
e1 + e2
</code></pre>

<hr>
<h2 id='+2B+2CCFtime+2Cnumeric-method'>Extend a CFtime object with additional offsets</h2><span id='topic++2B+2CCFtime+2Cnumeric-method'></span><span id='topic+CFtime-append'></span>

<h3>Description</h3>

<p>A <code>CFtime</code> instance can be extended by adding additional offsets using this
operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CFtime,numeric'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B+2B2CCFtime+2B2Cnumeric-method_+3A_e1">e1</code></td>
<td>
<p>CFtime. Instance of the <code>CFtime</code> class.</p>
</td></tr>
<tr><td><code id="+2B2B+2B2CCFtime+2B2Cnumeric-method_+3A_e2">e2</code></td>
<td>
<p>numeric. Vector of offsets to be added to the <code>CFtime</code> instance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting <code>CFtime</code> instance will have its offsets in the order that they
are added, meaning that the offsets from the <code>CFtime</code> instance come first and
those from the numeric vector follow. There is no reordering or removal of
duplicates. This is because the time series are usually associated with a
data set and the correspondence between the two is thus preserved, if and
only if the data sets are merged in the same order.
</p>
<p>Note that when adding multiple vectors of offsets to a <code>CFtime</code> instance, it
is more efficient to first concatenate the vectors and then do a final
addition to the <code>CFtime</code> instance. So avoid <code>CFtime(definition, calendar, e1) + CFtime(definition, calendar, e2) + CFtime(definition, calendar, e3) + ...</code>
but rather do <code>CFtime(definition, calendar, e1) + c(e2, e3, ...)</code>. It is the
responsibility of the operator to ensure that the offsets of the different
data sets are in reference to the same datum.
</p>
<p>Negative offsets will generate an error.
</p>


<h3>Value</h3>

<p>A <code>CFtime</code> object with offsets composed of the <code>CFtime</code> instance and
the numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- CFtime("days since 1850-01-01", "gregorian", 0:364)
e2 &lt;- 365:729
e1 + e2
</code></pre>

<hr>
<h2 id='+3D+3D+2CCFtime+2CCFtime-method'>Equivalence of CFtime objects</h2><span id='topic++3D+3D+2CCFtime+2CCFtime-method'></span><span id='topic+CFtime-equivalent'></span>

<h3>Description</h3>

<p>This operator can be used to test if two <code>CFtime</code> objects represent the same
CF-convention time coordinates. Two <code>CFtime</code> objects are considered equivalent
if they have an equivalent datum and the same offsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'CFtime,CFtime'
e1 == e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B3D+2B3D+2B2CCFtime+2B2CCFtime-method_+3A_e1">e1</code>, <code id="+2B3D+2B3D+2B2CCFtime+2B2CCFtime-method_+3A_e2">e2</code></td>
<td>
<p>CFtime. Instances of the <code>CFtime</code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the <code>CFtime</code> objects are equivalent, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- CFtime("days since 1850-01-01", "gregorian", 0:364)
e2 &lt;- CFtime("days since 1850-01-01 00:00:00", "standard", 0:364)
e1 == e2
</code></pre>

<hr>
<h2 id='CFcomplete'>Indicates if the time series is complete</h2><span id='topic+CFcomplete'></span>

<h3>Description</h3>

<p>This function indicates if the time series is complete, meaning that the time
steps are equally spaced and there are thus no gaps in the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFcomplete(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFcomplete_+3A_x">x</code></td>
<td>
<p>An instance of the <code>CFtime</code> class</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives exact results for time series where the nominal
<em>unit of separation</em> between observations in the time series is exact in terms of the
datum unit. As an example, for a datum unit of &quot;days&quot; where the observations
are spaced a fixed number of days apart the result is exact, but if the same
datum unit is used for data that is on monthly a basis, the <em>assessment</em> is
approximate because the number of days per month is variable and dependent on
the calendar (the exception being the <code style="white-space: pre;">&#8288;360_day&#8288;</code> calendar, where the
assessment is exact). The <em>result</em> is still correct in most cases (including
all CF-compliant data sets that the developers have seen) although
there may be esoteric constructions of CFtime and offsets that trip up this
implementation.
</p>


<h3>Value</h3>

<p>logical. <code>TRUE</code> if the time series is complete, with no gaps;
<code>FALSE</code> otherwise. If no offsets have been added to the CFtime instance,
<code>NA</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("days since 1850-01-01", "julian", 0:364)
CFcomplete(cf)
</code></pre>

<hr>
<h2 id='CFdefinition'>Properties of a CFtime object</h2><span id='topic+CFdefinition'></span><span id='topic+CFproperties'></span><span id='topic+CFcalendar'></span><span id='topic+CFunit'></span><span id='topic+CForigin'></span><span id='topic+CFtimezone'></span><span id='topic+CFoffsets'></span><span id='topic+CFresolution'></span>

<h3>Description</h3>

<p>These functions return the properties of an instance of the
<code>CFtime</code> class. The properties are all read-only, but offsets can be added
using the <code>+</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFdefinition(cf)

CFcalendar(cf)

CFunit(cf)

CForigin(cf)

CFtimezone(cf)

CFoffsets(cf)

CFresolution(cf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFdefinition_+3A_cf">cf</code></td>
<td>
<p>CFtime. An instance of <code>CFtime</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>CFcalendar()</code> and <code>CFunit()</code> return an atomic character string.
<code>CForigin()</code> returns a data frame of timestamp elements with a single row
of data. <code>CFtimezone()</code> returns the datum time zone as an atomic character
string. <code>CFoffsets()</code> returns a vector of offsets or <code>NULL</code> if no offsets
have been set.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>CFdefinition()</code>: The definition string of the CFtime instance
</p>
</li>
<li> <p><code>CFcalendar()</code>: The calendar of the CFtime instance
</p>
</li>
<li> <p><code>CFunit()</code>: The unit of the CFtime instance
</p>
</li>
<li> <p><code>CForigin()</code>: The origin of the CFtime instance in timestamp elements
</p>
</li>
<li> <p><code>CFtimezone()</code>: The time zone of the datum of the CFtime instance as a character string
</p>
</li>
<li> <p><code>CFoffsets()</code>: The offsets of the CFtime instance as a vector
</p>
</li>
<li> <p><code>CFresolution()</code>: The average separation between the offsets in the CFtime instance
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("days since 1850-01-01", "julian", 0:364)
CFdefinition(cf)
CFcalendar(cf)
CFunit(cf)
CFtimezone(cf)
CForigin(cf)
CFoffsets(cf)
CFresolution(cf)
</code></pre>

<hr>
<h2 id='CFfactor'>Create a factor from the offsets in an CFtime instance</h2><span id='topic+CFfactor'></span>

<h3>Description</h3>

<p>With this function a factor can be generated for the time series, or a part
thereof, contained in the <code>CFtime</code> instance. This is specifically interesting
for creating factors from the date part of the time series that aggregate the
time series into longer time periods (such as month) that can then be used to
process daily CF data sets using, for instance, <code>tapply()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFfactor(cf, period = "month", epoch = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFfactor_+3A_cf">cf</code></td>
<td>
<p>CFtime. An atomic instance of the <code>CFtime</code> class whose offsets will
be used to construct the factor.</p>
</td></tr>
<tr><td><code id="CFfactor_+3A_period">period</code></td>
<td>
<p>character. An atomic character string with one of the values
&quot;year&quot;, &quot;season&quot;, &quot;month&quot; (the default), &quot;dekad&quot; or &quot;day&quot;.</p>
</td></tr>
<tr><td><code id="CFfactor_+3A_epoch">epoch</code></td>
<td>
<p>numeric or list, optional. Vector of years for which to construct
the factor, or a list whose elements are each a vector of years. If <code>epoch</code>
is not specified, the factor will use the entire time series for the
factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factor will respect the calendar of the datum that the time series is
built on. For <code>period</code>s longer than a day this will result in a factor where
the calendar is no longer relevant (because calendars impacts days, not
dekads, months or seasons).
</p>
<p>The factor will be generated in the order of the offsets of the <code>CFtime</code>
instance. While typical CF-compliant data sources use ordered time series
there is, however, no guarantee that the factor is ordered as multiple <code>CFtime</code>
objects may have been merged out of order.
</p>
<p>If the <code>epoch</code> parameter is specified, either as a vector of years to include
in the factor, or as a list of such vectors, the factor will only consider
those values in the time series that fall within the list of years, inclusive
of boundary values. Other values in the factor will be set to <code>NA</code>. The years
need not be contiguous, within a single vector or among the list items, or in
order.
</p>
<p>The following periods are supported by this function:
</p>

<ul>
<li> <p><code>year</code>, the year of each offset is returned as &quot;YYYY&quot;.
</p>
</li>
<li> <p><code>season</code>, the meteorological season of each offset is returned as
&quot;DJF&quot;, &quot;MAM&quot;, &quot;JJA&quot; or &quot;SON&quot;, preceeded by &quot;YYYY-&quot; if no <code>epoch</code> is
specified. Note that December dates are labeled as belonging to the
subsequent year, so the date &quot;2020-12-01&quot; yields &quot;2021-DJF&quot;. This implies
that for standard CMIP files having one or more full years of data the
first season will have data for the first two months (January and
February), while the final season will have only a single month of data
(December).
</p>
</li>
<li> <p><code>month</code>, the month of each offset is returned as &quot;01&quot; to
&quot;12&quot;, preceeded by &quot;YYYY-&quot; if no <code>epoch</code> is specified. This is the default
period.
</p>
</li>
<li> <p><code>dekad</code>, ten-day periods are returned as
&quot;Dxx&quot;, where xx runs from &quot;01&quot; to &quot;36&quot;, preceeded by &quot;YYYY&quot; if no <code>epoch</code>
is specified. Each month is subdivided in dekads as follows: 1- days 01 -
10; 2- days 11 - 20; 3- remainder of the month.
</p>
</li>
<li> <p><code>day</code>, the month and day of each offset are returned as &quot;MM-DD&quot;,
preceeded by &quot;YYYY-&quot; if no <code>epoch</code> is specified.
</p>
</li></ul>

<p>It is not possible to create a factor for a period that is shorter than the
temporal resolution of the source data set from which the <code>cf</code> argument
derives. As an example, if the source data set has monthly data, a dekad or
day factor cannot be created.
</p>
<p>Creating factors for other periods is not supported by this function. Factors
based on the timestamp information and not dependent on the calendar can
trivially be constructed from the output of the <code><a href="#topic+CFtimestamp">CFtimestamp()</a></code> function.
</p>


<h3>Value</h3>

<p>If <code>epoch</code> is a single vector or not specified, a factor with a
length equal to the number of offsets in <code>cf</code>. If <code>epoch</code> is a list, a
list with the same number of elements and names as <code>epoch</code>, each containing
a factor. Elements in the factor will be set to <code>NA</code> for time series values
outside of the range of specified years.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("days since 1949-12-01", "360_day", 19830:54029)

# Create a dekad factor for the whole time series
f &lt;- CFfactor(cf, "dekad")

# Create three monthly factors for early, mid and late 21st century epochs
ep &lt;- CFfactor(cf, epoch = list(early = 2021:2040, mid = 2041:2060, late = 2061:2080))
</code></pre>

<hr>
<h2 id='CFfactor_coverage'>Coverage of time elements for each factor level</h2><span id='topic+CFfactor_coverage'></span>

<h3>Description</h3>

<p>This function calculates the number of time elements, or the relative
coverage, in each level of a factor generated by <code><a href="#topic+CFfactor">CFfactor()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFfactor_coverage(cf, f, coverage = "absolute")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFfactor_coverage_+3A_cf">cf</code></td>
<td>
<p>CFtime. An instance of CFtime.</p>
</td></tr>
<tr><td><code id="CFfactor_coverage_+3A_f">f</code></td>
<td>
<p>factor or list. A factor or a list of factors derived from the
parameter <code>cf</code>. The factor or list thereof should generally be generated by
the function <code><a href="#topic+CFfactor">CFfactor()</a></code>.</p>
</td></tr>
<tr><td><code id="CFfactor_coverage_+3A_coverage">coverage</code></td>
<td>
<p>&quot;absolute&quot; or &quot;relative&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>f</code> is a factor, a numeric vector with a length equal to the
number of levels in the factor, indicating the number of units from the
time series in <code>cf</code> contained in each level of the factor when
<code>coverage = "absolute"</code> or the proportion of units present relative to the
maximum number when <code>coverage = "relative"</code>. If <code>f</code> is a list of factors, a
list with each element a numeric vector as above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("days since 2001-01-01", "365_day", 0:364)
f &lt;- CFfactor(cf, "dekad")
CFfactor_coverage(cf, f, "absolute")
</code></pre>

<hr>
<h2 id='CFfactor_units'>Number of base time units in each factor level</h2><span id='topic+CFfactor_units'></span>

<h3>Description</h3>

<p>Given a factor as returned by <code><a href="#topic+CFfactor">CFfactor()</a></code> and the <code>CFtime</code> instance from
which the factor was derived, this function will return a numeric vector with
the number of time units in each level of the factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFfactor_units(cf, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFfactor_units_+3A_cf">cf</code></td>
<td>
<p>CFtime. An instance of CFtime.</p>
</td></tr>
<tr><td><code id="CFfactor_units_+3A_f">f</code></td>
<td>
<p>factor or list. A factor or a list of factors derived from the
parameter <code>cf</code>. The factor or list thereof should generally be generated by
the function <code><a href="#topic+CFfactor">CFfactor()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of this function is useful to convert between absolute and
relative values. Climate change anomalies, for instance, are usually computed
by differencing average values between a future period and a baseline period.
Going from average values back to absolute values for an aggregate period
(which is typical for temperature and precipitation, among other variables)
is easily done with the result of this function, without having to consider
the specifics of the calendar of the data set.
</p>
<p>If the factor <code>f</code> is for an epoch (e.g. spanning multiple years and the
levels do not indicate the specific year), then the result will indicate the
number of time units of the period in a regular single year. In other words,
for an epoch of 2041-2060 and a monthly factor on a standard calendar with a
<code>days</code> unit, the result will be <code>c(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)</code>.
Leap days are thus only considered for the <code style="white-space: pre;">&#8288;366_day&#8288;</code> and <code>all_leap</code> calendars.
</p>
<p>Note that this function gives the number of time units in each level of the
factor - the actual number of data points in the <code>cf</code> instance per factor
level may be different. Use <code><a href="#topic+CFfactor_coverage">CFfactor_coverage()</a></code> to determine the actual
number of data points or the coverage of data points relative to the factor
level.
</p>


<h3>Value</h3>

<p>If <code>f</code> is a factor, a numeric vector with a length equal to the
number of levels in the factor, indicating the number of time units in each
level of the factor. If <code>f</code> is a list of factors, a list with each element
a numeric vector as above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("days since 2001-01-01", "365_day", 0:364)
f &lt;- CFfactor(cf, "dekad")
CFfactor_units(cf, f)
</code></pre>

<hr>
<h2 id='CFmonth_days'>Return the number of days in a month given a certain CF calendar</h2><span id='topic+CFmonth_days'></span>

<h3>Description</h3>

<p>Given a vector of dates as strings in ISO 8601 or UDUNITS format and a <code>CFtime</code> object,
this function will return a vector of the same length as the dates,
indicating the number of days in the month according to the calendar
specification. If no vector of days is supplied, the function will return an
integer vector of length 12 with the number of days for each month of the
calendar (disregarding the leap day for <code>standard</code> and <code>julian</code> calendars).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFmonth_days(cf, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFmonth_days_+3A_cf">cf</code></td>
<td>
<p>CFtime. The CFtime definition to use.</p>
</td></tr>
<tr><td><code id="CFmonth_days_+3A_x">x</code></td>
<td>
<p>character. An optional vector of dates as strings with format
<code>YYYY-MM-DD</code>. Any time part will be silently ingested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector indicating the number of days in each month for the vector
of dates supplied as a parameter to the function. If no dates are supplied,
the number of days per month for the calendar as a vector of length 12.
Invalidly specified dates will result in an <code>NA</code> value.
</p>


<h3>See Also</h3>

<p>When working with factors generated by <code><a href="#topic+CFfactor">CFfactor()</a></code>, it is usually
better to use <code><a href="#topic+CFfactor_units">CFfactor_units()</a></code> as that will consider leap days for
non-epoch factors. <code><a href="#topic+CFfactor_units">CFfactor_units()</a></code> can also work with other time periods
and datum units, such as &quot;hours per month&quot;, or &quot;days per season&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- c("2021-11-27", "2021-12-10", "2022-01-14", "2022-02-18")
cf &lt;- CFtime("days since 1850-01-01", "standard")
CFmonth_days(cf, dates)

cf &lt;- CFtime("days since 1850-01-01", "360_day")
CFmonth_days(cf, dates)

cf &lt;- CFtime("days since 1850-01-01", "all_leap")
CFmonth_days(cf, dates)

CFmonth_days(cf)
</code></pre>

<hr>
<h2 id='CFparse'>Parse series of timestamps in CF format to date-time elements</h2><span id='topic+CFparse'></span>

<h3>Description</h3>

<p>This function will parse a vector of timestamps in ISO8601 or UDUNITS format
into a data frame with columns for the elements of the timestamp: year,
month, day, hour, minute, second, time zone. Those timestamps that could not
be parsed or which represent an invalid date in the indicated <code>CFtime</code>
instance will have <code>NA</code> values for the elements of the offending timestamp
(which will generate a warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFparse(cf, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFparse_+3A_cf">cf</code></td>
<td>
<p>CFtime. An instance of <code>CFtime</code> indicating the CF calendar and
datum to use when parsing the date.</p>
</td></tr>
<tr><td><code id="CFparse_+3A_x">x</code></td>
<td>
<p>character. Vector of character strings representing timestamps in
ISO8601 extended or UDUNITS broken format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supported formats are the <em>broken timestamp</em> format from the UDUNITS
library and ISO8601 <em>extended</em>, both with minor changes, as suggested by the
CF Metadata Conventions. In general, the format is <code style="white-space: pre;">&#8288;YYYY-MM-DD hh:mm:ss.sss hh:mm&#8288;</code>. The year can be from 1 to 4 digits and is interpreted literally, so
<code>79-10-24</code> is the day Mount Vesuvius erupted and destroyed Pompeii, not
<code>1979-10-24</code>. The year and month are mandatory, all other fields are
optional. There are defaults for all missing values, following the UDUNITS
and CF Metadata Conventions. Leading zeros can be omitted in the UDUNITS
format, but not in the ISO8601 format. The optional fractional part can have
as many digits as the precision calls for and will be applied to the smallest
specified time unit. In the result of this function, if the fraction is
associated with the minute or the hour, it is converted into a regular
<code>hh:mm:ss.sss</code> format, i.e. any fraction in the result is always associated
with the second, rounded down to milli-second accuracy. The time zone is
optional and should have at least the hour or <code>Z</code> if present, the minute is
optional. The time zone hour can have an optional sign. The separator between
the date and the time can be a single whitespace character or a <code>T</code>; in the
UDUNITS format the separator between the time and the time zone must be a
single whitespace character.
</p>
<p>Currently only the extended formats (with separators between the elements)
are supported. The vector of timestamps may have any combination of ISO8601
and UDUNITS formats.
</p>
<p>Timestamps that are prior to the datum are not allowed. The corresponding row
in the result will have <code>NA</code> values.
</p>


<h3>Value</h3>

<p>A data frame with constituent elements of the parsed timestamps in
numeric format. The columns are year, month, day, hour, minute, second
(with an optional fraction), time zone (character string), and the
corresponding offset value from the datum. Invalid input data will appear
as <code>NA</code> - if this is the case, a warning message will be displayed - other
missing information on input will use default values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("days since 0001-01-01", "proleptic_gregorian")

# This will have `NA`s on output and generate a warning
timestamps &lt;- c("2012-01-01T12:21:34Z", "12-1-23", "today",
                "2022-08-16T11:07:34.45-10", "2022-08-16 10.5+04")
CFparse(cf, timestamps)
</code></pre>

<hr>
<h2 id='CFrange'>Extreme time series values</h2><span id='topic+CFrange'></span><span id='topic+CFrange+2CCFtime-method'></span>

<h3>Description</h3>

<p>Character representation of the extreme values in the time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFrange(x)

## S4 method for signature 'CFtime'
CFrange(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFrange_+3A_x">x</code></td>
<td>
<p>An instance of the <code>CFtime</code> class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character. Vector of two character representations of the extremes of the time series.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>CFrange(CFtime)</code>: Extreme values of the time series
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("days since 1850-01-01", "julian", 0:364)
CFrange(cf)
</code></pre>

<hr>
<h2 id='CFsubset'>Which time steps fall within two extreme values</h2><span id='topic+CFsubset'></span>

<h3>Description</h3>

<p>Given two extreme character timestamps, return a logical vector of a length
equal to the number of time steps in the CFtime instance with values <code>TRUE</code>
for those time steps that fall between the two extreme values, <code>FALSE</code>
otherwise. This can be used to select slices from the time series in reading
or analysing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFsubset(x, extremes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFsubset_+3A_x">x</code></td>
<td>
<p>CFtime. The time series to operate on.</p>
</td></tr>
<tr><td><code id="CFsubset_+3A_extremes">extremes</code></td>
<td>
<p>character. Vector of two timestamps that represent the
extremes of the time period of interest. The timestamps must be in
increasing order. The timestamps need not fall in the range of the time
steps in the CFtime stance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector with a length equal to the number of time steps in
<code>x</code> with values <code>TRUE</code> for those time steps that fall between the two
extreme values, <code>FALSE</code> otherwise. The earlier timestamp is included, the
later timestamp is excluded. A specification of <code>c("2022-01-01", "2023-01-01")</code>
will thus include all time steps that fall in the year 2022.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("hours since 2023-01-01 00:00:00", "standard", 0:23)
CFsubset(cf, c("2022-12-01", "2023-01-01 03:00"))
</code></pre>

<hr>
<h2 id='CFtime'>Create a CFtime object</h2><span id='topic+CFtime'></span>

<h3>Description</h3>

<p>This function creates an instance of the <code>CFtime</code> class. The arguments to
the call are typically read from a CF-compliant data file with climatological
observations or climate projections. Specification of arguments can also be
made manually in a variety of combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFtime(definition, calendar = "standard", offsets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFtime_+3A_definition">definition</code></td>
<td>
<p>character. An atomic string describing the time coordinate
of a CF-compliant data file.</p>
</td></tr>
<tr><td><code id="CFtime_+3A_calendar">calendar</code></td>
<td>
<p>character. An atomic string describing the calendar to use
with the time dimension definition string. Default value is &quot;standard&quot;.</p>
</td></tr>
<tr><td><code id="CFtime_+3A_offsets">offsets</code></td>
<td>
<p>numeric or character, optional. When numeric, a vector of
offsets from the origin in the time series. When a character vector,
timestamps in ISO8601 or UDUNITS format. When an atomic character string, a
timestamp in ISO8601 or UDUNITS format and then a time series will be
generated with a separation between steps equal to the unit of measure in
the definition, inclusive of the definition timestamp. The unit of measure
of the offsets is defined by the time series definition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of the <code>CFtime</code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CFtime("days since 1850-01-01", "julian", 0:364)

CFtime("hours since 2023-01-01", "360_day", "2023-01-30T23:00")
</code></pre>

<hr>
<h2 id='CFtime-class'>CF Metadata Conventions time representation</h2><span id='topic+CFtime-class'></span>

<h3>Description</h3>

<p>CF Metadata Conventions time representation
</p>


<h3>Value</h3>

<p>An object of class CFtime.
</p>


<h3>Slots</h3>


<dl>
<dt><code>datum</code></dt><dd><p>CFdatum. The atomic origin upon which the <code>offsets</code> are based.</p>
</dd>
<dt><code>resolution</code></dt><dd><p>numeric. The average number of time units between offsets.</p>
</dd>
<dt><code>offsets</code></dt><dd><p>numeric. A vector of offsets from the datum.</p>
</dd>
</dl>

<hr>
<h2 id='CFtimestamp'>Create a vector that represents CF timestamps</h2><span id='topic+CFtimestamp'></span>

<h3>Description</h3>

<p>This function generates a vector of character strings or <code>POSIXct</code>s that
represent the date and time in a selectable combination for each offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFtimestamp(cf, format = NULL, asPOSIX = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFtimestamp_+3A_cf">cf</code></td>
<td>
<p>CFtime. The <code>CFtime</code> instance that contains the offsets to use.</p>
</td></tr>
<tr><td><code id="CFtimestamp_+3A_format">format</code></td>
<td>
<p>character. An atomic string with either of the values &quot;date&quot; or
&quot;timestamp&quot;. If the argument is not specified, the format used is
&quot;timestamp&quot; if there is time information, &quot;date&quot; otherwise.</p>
</td></tr>
<tr><td><code id="CFtimestamp_+3A_asposix">asPOSIX</code></td>
<td>
<p>logical. If <code>TRUE</code>, for &quot;standard&quot;, &quot;gregorian&quot; and
&quot;proleptic_gregorian&quot; calendars the output is a vector of <code>POSIXct</code> - for
other calendars the result is <code>NULL</code>. Default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The character strings use the format <code style="white-space: pre;">&#8288;YYYY-MM-DDThh:mm:ssÂ±hh:mm&#8288;</code>, depending
on the <code>format</code> specifier. The date in the string is not necessarily
compatible with <code>POSIXt</code> - in the <code style="white-space: pre;">&#8288;360_day&#8288;</code> calendar <code>2017-02-30</code> is valid
and <code>2017-03-31</code> is not.
</p>
<p>For the &quot;standard&quot;, &quot;gregorian&quot; and &quot;proleptic_gregorian&quot; calendars the
output can also be generated as a vector of <code>POSIXct</code> values by specifying
<code>asPOSIX = TRUE</code>.
</p>


<h3>Value</h3>

<p>A character vector where each element represents a moment in time
according to the <code>format</code> specifier. Time zone information is not
represented.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cf &lt;- CFtime("hours since 2020-01-01", "standard", seq(0, 24, by = 0.25))
CFtimestamp(cf, "timestamp")

cf2 &lt;- CFtime("days since 2002-01-21", "standard", 0:20)
tail(CFtimestamp(cf2, asPOSIX = TRUE))

tail(CFtimestamp(cf2))

tail(CFtimestamp(cf2 + 1.5))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
