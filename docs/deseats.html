<!DOCTYPE html><html lang="en"><head><title>Help for package deseats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {deseats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#deseats-package'><p>Deseasonalize Time Series</p></a></li>
<li><a href='#animate'><p>Automatic Creation of Animations</p></a></li>
<li><a href='#animate+2Cdeseats-method'><p>Animate Locally Weighted Regression Results</p></a></li>
<li><a href='#arma_to_ar'><p>AR Representation of an ARMA Model</p></a></li>
<li><a href='#arma_to_ma'><p>MA Representation of an ARMA Model</p></a></li>
<li><a href='#autoplot+2Cdecomp-method'><p>Plot Method for Decomposition Results in the Style of ggplot2</p></a></li>
<li><a href='#autoplot+2Cdeseats_fc-method'><p><code>ggplot2</code> Plot Method for Class <code>"deseats_fc"</code></p></a></li>
<li><a href='#autoplot+2Chfilter-method'><p><code>ggplot2</code> Plot Method for the Results of a Hamilton Filter</p></a></li>
<li><a href='#BV4.1'><p>Trend and Seasonality Estimation Using the Berlin Procedure 4.1</p></a></li>
<li><a href='#bwidth_confint'><p>Bootstrapping Confidence Intervals for Locally Weighted Regression Bandwidths</p></a></li>
<li><a href='#bwidth+2Cdeseats-method'><p>Retrieve the Used Bandwidth from an Estimation Object</p></a></li>
<li><a href='#CIVLABOR'><p>Monthly Civilian Labor Force Level in the USA</p></a></li>
<li><a href='#CONSUMPTION'><p>Quarterly Real Final Consumption Expenditure for Australia</p></a></li>
<li><a href='#COVID'><p>Daily Confirmed New COVID-19 Cases in Germany</p></a></li>
<li><a href='#create.gain'><p>Create Gain Function from a Linear Time Series Filter</p></a></li>
<li><a href='#DEATHS'><p>Monthly Deaths in Germany</p></a></li>
<li><a href='#deseats'><p>Locally Weighted Regression for Trend and Seasonality in Equidistant Time</p>
Series under Short Memory</a></li>
<li><a href='#ENERGY'><p>Monthly Total Production and Distribution of Electricity, Gas, Steam, and Air Conditioning for Germany</p></a></li>
<li><a href='#EXPENDITURES'><p>Quarterly Personal Consumption Expenditures in the USA</p></a></li>
<li><a href='#expo'><p>Automatic Creation of Animations</p></a></li>
<li><a href='#expo+2Cdeseats_fc-method'><p>Exponentiate <code>deseats</code> Forecasts</p></a></li>
<li><a href='#fitted+2Chfilter-method'><p>Fitted Components of the Hamilton Filter</p></a></li>
<li><a href='#gain'><p>Gain Function Generic</p></a></li>
<li><a href='#gain+2Cdeseats-method'><p>Obtain gain function values for DeSeaTS Trend and Detrend Filters</p></a></li>
<li><a href='#GDP'><p>Quarterly US GDP</p></a></li>
<li><a href='#hA_calc'><p>Calculation of Theoretically Optimal Bandwidth and Its Components</p></a></li>
<li><a href='#hamilton_filter'><p>Time Series Filtering Using the Hamilton Filter</p></a></li>
<li><a href='#HOUSES'><p>Monthly New One Family Houses Sold in the USA</p></a></li>
<li><a href='#LIVEBIRTHS'><p>Monthly Live Births in Germany</p></a></li>
<li><a href='#llin_decomp'><p>Decomposition of Time Series Using Local Linear Regression</p></a></li>
<li><a href='#lm_decomp'><p>Decomposition of Time Series Using Linear Regression</p></a></li>
<li><a href='#ma_decomp'><p>Decomposition of Time Series Using Moving Averages</p></a></li>
<li><a href='#measures'><p>Forecasting Accuracy Measure Calculation</p></a></li>
<li><a href='#NOLABORFORCE'><p>Monthly Number of US Persons Not in the Labor Force</p></a></li>
<li><a href='#order_poly'><p>Smoothing Option Generics</p></a></li>
<li><a href='#order_poly+2Csmoothing_options-method'><p>Retrieve or Set Smoothing Options</p></a></li>
<li><a href='#plot+2Cdecomp-method'><p>Plot Method for Decomposition Results in the Style of Base R Plots</p></a></li>
<li><a href='#plot+2Cdeseats_fc-method'><p>Plot Method for Class <code>"deseats_fc"</code></p></a></li>
<li><a href='#plot+2Chfilter-method'><p>Plot Method for the Results of a Hamilton Filter</p></a></li>
<li><a href='#predict+2Cs_semiarma-method'><p>Point and Interval Forecasts for Seasonal Semi-ARMA Models</p></a></li>
<li><a href='#RAINFALL'><p>Monthly Average Rainfall in Germany</p></a></li>
<li><a href='#read_ts'><p>Read in a Dataset Directly as an Object of Class <code>"ts"</code> or <code>"mts"</code></p></a></li>
<li><a href='#RETAIL'><p>Monthly Total Volume of Retail Trade in Germany</p></a></li>
<li><a href='#runDecomposition'><p>Shiny App for Decomposing Seasonal Time Series</p></a></li>
<li><a href='#s_semiarma'><p>Fitting of a Seasonal Semiparametric ARMA Model</p></a></li>
<li><a href='#SAVINGS'><p>Quarterly Savings of Private Households in Germany</p></a></li>
<li><a href='#seasonplot'><p>Creation of Seasonal Plots</p></a></li>
<li><a href='#seasonplot_gg'><p>Creation of Seasonal Plots in the Style of ggplot2</p></a></li>
<li><a href='#select_bwidth'><p>Optimal Bandwidth Estimation for Locally Weighted Regression in Equidistant</p>
Time Series under Short Memory</a></li>
<li><a href='#set_options'><p>Specification of Smoothing Options</p></a></li>
<li><a href='#show+2Cdeseats-method'><p>Printing of <code>deseats</code> Function Results</p></a></li>
<li><a href='#show+2Cs_semiarma-method'><p>Show Method for Objects of Class <code>"s_semiarma"</code></p></a></li>
<li><a href='#show+2Csmoothing_options-method'><p>Show Method for Smoothing Options</p></a></li>
<li><a href='#SUNSHINE'><p>Monthly Hours of Sunshine in Germany</p></a></li>
<li><a href='#TEMPERATURE'><p>Monthly Average Temperature in Germany</p></a></li>
<li><a href='#trend'><p>Obtain Estimated Components of a Time Series</p></a></li>
<li><a href='#trend+2Cdecomp-method'><p>Obtain Individual Components of a Decomposed Time Series</p></a></li>
<li><a href='#zoo_to_ts'><p>Time Series Object Conversion from <code>"zoo"</code> to <code>"ts"</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data-Driven Locally Weighted Regression for Trend and
Seasonality in TS</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominik Schulz &lt;dominik.schulz@uni-paderborn.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Various methods for the identification of trend and seasonal
  components in time series (TS) are provided. Among them is a data-driven locally
  weighted regression approach with automatically selected bandwidth for
  equidistant short-memory time series. The approach is a
  combination / extension of the algorithms by
  Feng (2013) &lt;<a href="https://doi.org/10.1080%2F02664763.2012.740626">doi:10.1080/02664763.2012.740626</a>&gt; and Feng, Y., Gries, T.,
  and Fritz, M. (2020) &lt;<a href="https://doi.org/10.1080%2F10485252.2020.1759598">doi:10.1080/10485252.2020.1759598</a>&gt; and a brief
  description of this new method is provided in the package documentation.
  Furthermore, the package allows its users to apply the base model of the
  Berlin procedure, version 4.1, as described in Speth (2004) <a href="https://www.destatis.de/DE/Methoden/Saisonbereinigung/BV41-methodenbericht-Heft3_2004.pdf?__blob=publicationFile">https://www.destatis.de/DE/Methoden/Saisonbereinigung/BV41-methodenbericht-Heft3_2004.pdf?__blob=publicationFile</a>.
  Permission to include this procedure was kindly provided by the Federal
  Statistical Office of Germany.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.6), ggplot2, stats, graphics, animation, utils,
shiny, tools, zoo, future, furrr, future.apply, progressr,
purrr, rlang, tidyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>badger, knitr, rmarkdown, smoots, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AttachMessage.R' 'RcppExports.R' 'generics.R'
'helper_functions.R' 'subplot_functions.R'
'accuracy_measures.R' 'class-smoothing_options.R'
'class-decomp.R' 'class-deseats.R' 'class-s_semiarma.R'
'class-bv41.R' 'class-hfilter.R' 'class-lmdecomp.R'
'class-madecomp.R' 'class-llindecomp.R' 'data_documentation.R'
'fitting_functions.R' 'runDecomposition.R' 'class-deseats_fc.R'
'forecasting_functions.R' 'bwidth_bootstrap.R'
'gain_function.R' 'linear_filters.R' 'ts_conversion.R'
'hA_calc.R' 'arima_no_warn.R' 'deseats-package.R'
'seasonplot.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-10 11:16:49 UTC; Dominik Schulz</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuanhua Feng [aut] (Paderborn University, Germany),
  Dominik Schulz [aut, cre] (Paderborn University, Germany)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-12 10:50:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='deseats-package'>Deseasonalize Time Series</h2><span id='topic+deseats-package'></span>

<h3>Description</h3>

<p>A library of decomposition methods for equidistant time series with 
trend and seasonality.
</p>


<h3>Details</h3>

<p><code>deseats</code> is an R package for the decomposition of equidistant time 
series with trend and seasonality. First and foremost, an own algorithm 
for bandwidth selection in locally weighted regression of such time series 
(with short-range dependence) is implemented that is based on both the 
algorithms by Feng (2013) and Feng et al. (2020). For comparison,
a simplified version of the BV4.1 (Berlin Procedure 4.1, Speth, 2004), is 
implemented as well that allows to implement the BV4.1 base model (trend 
component + seasonality component + irregular component) without any 
of the additional BV4.1 components (such as the calendar component). 
Permission to include the BV4.1 base model procedure was kindly provided by 
the Federal Statistical Office of Germany.
</p>


<h3>Main Functions</h3>

<p>The main functions of the package are:
</p>

<dl>
<dt><code><a href="#topic+deseats">deseats</a></code>:</dt><dd><p>locally weighted regression with automatically 
selected bandwidth for decomposition,</p>
</dd>
<dt><code><a href="#topic+BV4.1">BV4.1</a></code>:</dt><dd><p>BV4.1 base model for decomposition,</p>
</dd>
<dt><code><a href="#topic+lm_decomp">lm_decomp</a></code>:</dt><dd><p>ordinary least squares for decomposition,</p>
</dd>
<dt><code><a href="#topic+llin_decomp">llin_decomp</a></code>:</dt><dd><p>local linear regression for decomposition,</p>
</dd>
<dt><code><a href="#topic+ma_decomp">ma_decomp</a></code>:</dt><dd><p>moving averages for decomposition,</p>
</dd>
<dt><code><a href="#topic+hamilton_filter">hamilton_filter</a></code>:</dt><dd><p>the time series filter by Hamilton.</p>
</dd>
</dl>



<h3>Datasets</h3>

<p>The package includes a few datasets. Follow the corresponding links to the 
documentation of the datasets to find additional information including the 
sources.
</p>

<dl>
<dt><code><a href="#topic+CIVLABOR">CIVLABOR</a></code>:</dt><dd><p>civilian labor force level in the USA.</p>
</dd>
<dt><code><a href="#topic+CONSUMPTION">CONSUMPTION</a></code>:</dt><dd><p>real final consumption expenditure for Australia.</p>
</dd>
<dt><code><a href="#topic+COVID">COVID</a></code>:</dt><dd><p>new COVID-19 cases in Germany.</p>
</dd>
<dt><code><a href="#topic+DEATHS">DEATHS</a></code>:</dt><dd><p>recorded number of deaths in Germany.</p>
</dd>
<dt><code><a href="#topic+ENERGY">ENERGY</a></code>:</dt><dd><p>production and distribution of electricity, gas, steam and air conditioning in Germany.</p>
</dd>
<dt><code><a href="#topic+EXPENDITURES">EXPENDITURES</a></code>:</dt><dd><p>consumption expenditures in the USA.</p>
</dd>
<dt><code><a href="#topic+GDP">GDP</a></code>:</dt><dd><p>GDP of the USA.</p>
</dd>
<dt><code><a href="#topic+HOUSES">HOUSES</a></code>:</dt><dd><p>new one family houses sold in the USA.</p>
</dd>
<dt><code><a href="#topic+LIVEBIRTHS">LIVEBIRTHS</a></code>:</dt><dd><p>recorded number of livebirths in Germany.</p>
</dd>
<dt><code><a href="#topic+NOLABORFORCE">NOLABORFORCE</a></code>:</dt><dd><p>number of persons in the USA not belonging 
to the labor force.</p>
</dd>
<dt><code><a href="#topic+RAINFALL">RAINFALL</a></code>:</dt><dd><p>average amount of rain in Germany.</p>
</dd>
<dt><code><a href="#topic+RETAIL">RETAIL</a></code>:</dt><dd><p>Retail sale volume in Germany.</p>
</dd>
<dt><code><a href="#topic+SAVINGS">SAVINGS</a></code>:</dt><dd><p>savings of private households in Germany.</p>
</dd>
<dt><code><a href="#topic+SUNSHINE">SUNSHINE</a></code>:</dt><dd><p>average hours of sunshine in Germany.</p>
</dd>
<dt><code><a href="#topic+TEMPERATURE">TEMPERATURE</a></code>:</dt><dd><p>average temperature in Germany.</p>
</dd>
</dl>



<h3>License</h3>

<p>The package is distributed under the General Public License v3
([GPL-3](https://tldrlegal.com/license/gnu-general-public-license-v3-(gpl-3))).
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li>
<li><p> Yuanhua Feng (Department of Economics, Paderborn
University), <br />
Author
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Feng, Y. (2013). An iterative plug-in algorithm for decomposing seasonal 
time series using the Berlin Method. Journal of Applied Statistics, 40(2): 
266-281. DOI: 10.1080/02664763.2012.740626.
</p>
</li>
<li><p>Feng, Y., Gries. T, and Fritz, M. (2020). Data-driven local polynomial 
for the trend and its derivatives in economic time series. Journal of 
Nonparametric Statistics, 32(2): 510-533. DOI: 10.1080/10485252.2020.1759598.
</p>
</li>
<li><p>Speth, H.-T. (2004). Komponentenzerlegung und Saisonbereinigung ökonomischer 
Zeitreihen mit dem Verfahren BV4.1. Methodenberichte 3. Statistisches 
Bundesamt. URL: https://www.destatis.de/DE/Methoden/Saisonbereinigung/BV41-methodenbericht-Heft3_2004.pdf?__blob=publicationFile.
</p>
</li></ul>


<hr>
<h2 id='animate'>Automatic Creation of Animations</h2><span id='topic+animate'></span>

<h3>Description</h3>

<p>A generic that is the basis for methods that allow the user to create 
specific animations on-the-fly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="animate_+3A_object">object</code></td>
<td>
<p>the input object.</p>
</td></tr>
<tr><td><code id="animate_+3A_...">...</code></td>
<td>
<p>currently of no use; included for future compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A generic that can be extended by methods to automatically create animations 
based on certain objects.
</p>


<h3>Value</h3>

<p>This generic does not return anything and is just the basis for more 
sophisticated methods.
</p>

<hr>
<h2 id='animate+2Cdeseats-method'>Animate Locally Weighted Regression Results</h2><span id='topic+animate+2Cdeseats-method'></span>

<h3>Description</h3>

<p>The results of locally weighted regression results
acquired through decomposition of seasonal time series 
via the function <code><a href="#topic+deseats">deseats</a></code> can be 
animated automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'deseats'
animate(
  object,
  col.obs = "grey74",
  col.fit = "red",
  col.weights = "#00D40E",
  col.window = "deepskyblue4",
  col.spot = "orange",
  save = NULL,
  xlab = "Time",
  ylab1 = "Estimated trend + seasonality",
  ylab2 = "Active kernel weights",
  main = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="animate+2B2Cdeseats-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"deseats"</code>.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_col.obs">col.obs</code></td>
<td>
<p>the color to use for the observations.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_col.fit">col.fit</code></td>
<td>
<p>the color to use for the fitted values.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_col.weights">col.weights</code></td>
<td>
<p>the color to use for the active kernel weights.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_col.window">col.window</code></td>
<td>
<p>the color to use for the window defined through the
bandwidth</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_col.spot">col.spot</code></td>
<td>
<p>the color to highlight the estimation time point.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_save">save</code></td>
<td>
<p>whether to save the animation or not; for <code>NULL</code>,
it will not be saved; to save it in the current working directory, use 
either <code>save = "PDF"</code> or <code>save = "HTML"</code>, which also specifies 
the file format.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_xlab">xlab</code></td>
<td>
<p>the label for the x-axis.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_ylab1">ylab1</code></td>
<td>
<p>the label for the y-axis on the left-hand side.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_ylab2">ylab2</code></td>
<td>
<p>the label for the second y-axis on the right-hand side.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_main">main</code></td>
<td>
<p>the plot title.</p>
</td></tr>
<tr><td><code id="animate+2B2Cdeseats-method_+3A_...">...</code></td>
<td>
<p>currently without use; implemented for possible future 
compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+deseats">deseats</a></code> estimation results are automatically animated 
through this method. It shows the observed series together with fitted
values (trend + seasonality), the smoothing window, the fitted values from 
the local regression, and the active kernel weights.
</p>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
### Creating the animation might take a while
Xt &lt;- log(EXPENDITURES)
smoothing_options &lt;- set_options(order_poly = 3)
est &lt;- deseats(Xt, smoothing_options = smoothing_options)
animate(est)


</code></pre>

<hr>
<h2 id='arma_to_ar'>AR Representation of an ARMA Model</h2><span id='topic+arma_to_ar'></span>

<h3>Description</h3>

<p>Calculate the coefficients of the infinite-order AR-representation
of a given ARMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_to_ar(ar = numeric(0), ma = numeric(0), max_i = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_to_ar_+3A_ar">ar</code></td>
<td>
<p>a numeric vector with the AR parameters of the ARMA model;
should be ordered from <code class="reqn">a_1</code> to <code class="reqn">a_p</code> (see Details).</p>
</td></tr>
<tr><td><code id="arma_to_ar_+3A_ma">ma</code></td>
<td>
<p>a numeric vector with the MA parameters of the ARMA model;
should be ordered from <code class="reqn">b_1</code> to <code class="reqn">b_q</code> (see Details).</p>
</td></tr>
<tr><td><code id="arma_to_ar_+3A_max_i">max_i</code></td>
<td>
<p>a single numeric value that indicates how many coefficients
should be returned; returned will be <code>max_i + 1</code> coefficients (the
coefficient for index 0 is also returned as the first value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider an ARMA model
</p>
<p style="text-align: center;"><code class="reqn">X_t = a_1 X_{t-1} + ... + a_p X_{t-p} + b_1 \epsilon_{t-1} + ... + b_q \epsilon_{t-q} + \epsilon_t,</code>
</p>

<p>where <code class="reqn">a_1, ..., a_p</code> and <code class="reqn">b_1, ..., b_q</code> are its real-valued 
coefficients. The function <code>arma_to_ar()</code> uses these coefficients as 
input to calculate the coefficients of the truncated infinite-order 
AR-representation of the model defined through these coefficients. Note that 
the stationarity and invertibility of the model defined through the provided 
coefficients is not being checked.
</p>
<p>NOTE:
</p>
<p>This function implements C++ code by means
of the <code><a href="Rcpp.html#topic+Rcpp-package">Rcpp</a></code> and
<code>RcppArmadillo</code> packages for
better performance.
</p>


<h3>Value</h3>

<p>A numeric vector is returned.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ar &lt;- c(1.2, -0.4)
ma &lt;- c(0.5)
arma_to_ar(ar = ar, ma = ma, max_i = 100)

</code></pre>

<hr>
<h2 id='arma_to_ma'>MA Representation of an ARMA Model</h2><span id='topic+arma_to_ma'></span>

<h3>Description</h3>

<p>Calculate the coefficients of the infinite-order MA-representation
of a given ARMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_to_ma(ar = numeric(0), ma = numeric(0), max_i = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_to_ma_+3A_ar">ar</code></td>
<td>
<p>a numeric vector with the AR parameters of the ARMA model;
should be ordered from <code class="reqn">a_1</code> to <code class="reqn">a_p</code> (see Details).</p>
</td></tr>
<tr><td><code id="arma_to_ma_+3A_ma">ma</code></td>
<td>
<p>a numeric vector with the MA parameters of the ARMA model;
should be ordered from <code class="reqn">b_1</code> to <code class="reqn">b_q</code> (see Details).</p>
</td></tr>
<tr><td><code id="arma_to_ma_+3A_max_i">max_i</code></td>
<td>
<p>a single numeric value that indicates how many coefficients
should be returned; returned will be <code>max_i + 1</code> coefficients (the
coefficient for index 0 is also returned as the first value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider an ARMA model
</p>
<p style="text-align: center;"><code class="reqn">X_t = a_1 X_{t-1} + ... + a_p X_{t-p} + b_1 \epsilon_{t-1} + ... + b_q \epsilon_{t-q} + \epsilon_t,</code>
</p>

<p>where <code class="reqn">a_1, ..., a_p</code> and <code class="reqn">b_1, ..., b_q</code> are its real-valued 
coefficients. The function <code>arma_to_ar()</code> uses these coefficients as 
input to calculate the coefficients of the truncated infinite-order 
MA-representation of the model defined through these coefficients. Note that 
the stationarity and invertibility of the model defined through the provided 
coefficients is not being checked.
</p>
<p>NOTE:
</p>
<p>This function implements C++ code by means
of the <code><a href="Rcpp.html#topic+Rcpp-package">Rcpp</a></code> and
<code>RcppArmadillo</code> packages for
better performance.
</p>


<h3>Value</h3>

<p>A numeric vector is returned.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ar &lt;- c(1.2, -0.4)
ma &lt;- c(0.5)
arma_to_ma(ar = ar, ma = ma, max_i = 100)

</code></pre>

<hr>
<h2 id='autoplot+2Cdecomp-method'>Plot Method for Decomposition Results in the Style of ggplot2</h2><span id='topic+autoplot+2Cdecomp-method'></span>

<h3>Description</h3>

<p>This is method for producing various plots of the decomposition results
returned by this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'decomp'
autoplot(object, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot+2B2Cdecomp-method_+3A_object">object</code></td>
<td>
<p>an object returned by the function <code><a href="#topic+deseats">deseats</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot+2B2Cdecomp-method_+3A_which">which</code></td>
<td>
<p>various plots can be selected either via a keyword or a number; 
enter <code>"facets"</code> or <code>1</code> to show a facet plot of the estimated
time series components; enter <code>"observations"</code> or <code>2</code> to show the
input time series; enter <code>"fitted"</code> or <code>3</code> to show the observations 
alongside the estimated trend with seasonality; enter <code>"detailed_fit"</code> or
<code>4</code> to show the observations together with the fitted values and the trend;
enter <code>"trend_season"</code> or <code>5</code> to show the observations together with 
the trend and with the seasonality (the latter shown around the series mean);
enter <code>"residuals"</code> or 
<code>6</code> to plot the both detrended and seasonally adjusted series; use 
<code>7</code> or <code>"deseasonalized"</code> to show the seasonally adjusted 
series; enter <code>8</code> or <code>"detrended"</code> to plot the detrended 
series; the 
default is <code>which = NULL</code> which then lets you select a plot 
interactively in the R console.</p>
</td></tr>
<tr><td><code id="autoplot+2B2Cdecomp-method_+3A_...">...</code></td>
<td>
<p>no purpose and only implemented for compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create predefined standard plots of the decomposition objects returned by the 
<code>deseats</code> package, e.g. returned by the function <code><a href="#topic+deseats">deseats</a></code>. 
Plots are created in the ggplot2 plot style. The type of plot can be chosen 
either interactively from the console, or the argument <code>which</code> can be 
used to directly  select the kind of plot to create (see also the description
of the argument <code>which</code>) within the function call.
</p>
<p>If plot type 5 (<code>which = 5</code>) is selected, the estimated 
seasonality will be displayed around the mean of the observations by default.
Setting the additional argument <code>s_around</code> to some other value, will lead 
to the seasonality being displayed around that constant value.
</p>


<h3>Value</h3>

<p>A ggplot2-graphic object is returned, i.e. an object of classes 
<code>"gg"</code> and <code>"ggplot"</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
Xt &lt;- log(EXPENDITURES)
est &lt;- deseats(Xt)
autoplot(est, which = 3)


</code></pre>

<hr>
<h2 id='autoplot+2Cdeseats_fc-method'><code>ggplot2</code> Plot Method for Class <code>"deseats_fc"</code></h2><span id='topic+autoplot+2Cdeseats_fc-method'></span>

<h3>Description</h3>

<p>Create <code>ggplot2</code> R plots for forecasting objects of class 
<code>"deseats_fc"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'deseats_fc'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot+2B2Cdeseats_fc-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"deseats_fc"</code>, for example generated by a 
call to <code><a href="#topic+predict+2Cs_semiarma-method">predict,s_semiarma-method</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot+2B2Cdeseats_fc-method_+3A_...">...</code></td>
<td>
<p>currently without use; implemented for compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a plot method to visualize the forecasting results for a Seasonal 
Semi-ARMA model. Common plot arguments can be implemented to change the 
appearance.
</p>


<h3>Value</h3>

<p>This method returns a <code>ggplot2</code> plot object, i.e. an object of classes 
<code>"gg"</code> and <code>"ggplot"</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
est &lt;- s_semiarma(log(EXPENDITURES))
fc &lt;- predict(est, n.ahead = 4)
fc_e &lt;- expo(fc)
autoplot(fc_e)


</code></pre>

<hr>
<h2 id='autoplot+2Chfilter-method'><code>ggplot2</code> Plot Method for the Results of a Hamilton Filter</h2><span id='topic+autoplot+2Chfilter-method'></span>

<h3>Description</h3>

<p>Visualize the results of an applied Hamilton filter in the style of 
<code>ggplot2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hfilter'
autoplot(object, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot+2B2Chfilter-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"hfilter"</code>, as returned by the function 
<code><a href="#topic+hamilton_filter">hamilton_filter</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot+2B2Chfilter-method_+3A_which">which</code></td>
<td>
<p>either a string or a number can be entered to select a 
plot type from the function call; options are (1) a facet plot of the 
components, (2) the observed time series, (3) the observations together 
with the fitted values, and (4) the residuals; for <code>which = NULL</code>, 
the plot type can be selected interactively in the console.</p>
</td></tr>
<tr><td><code id="autoplot+2B2Chfilter-method_+3A_...">...</code></td>
<td>
<p>currently without use, implemented for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This method returns a <code>ggplot2</code> plot object, i.e. an object of classes 
<code>"gg"</code> and <code>"ggplot"</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>est &lt;- hamilton_filter(log(EXPENDITURES))
autoplot(est, which = 3, col = c(1, 6))
autoplot(est, which = 4)

</code></pre>

<hr>
<h2 id='BV4.1'>Trend and Seasonality Estimation Using the Berlin Procedure 4.1</h2><span id='topic+BV4.1'></span>

<h3>Description</h3>

<p>Economic data can be decomposed into a trend, a seasonal and a remainder 
component using the Berlin procedure  4.1 (German: Berliner Verfahren 
4.1), as used by the National Statistical Office of Germany. Currently with 
this version of the R package, only the trend and seasonal components can be 
estimated following BV4.1. All further 
component estimations, for example the estimation of the
calendar component, of the official procedure BV4.1 are not yet implemented. 
The function supports quarterly and monthly data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BV4.1(yt, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BV4.1_+3A_yt">yt</code></td>
<td>
<p>a time series object of class <code>ts</code> or an object that can be 
converted into such an object with <code><a href="stats.html#topic+as.ts">as.ts</a></code>.</p>
</td></tr>
<tr><td><code id="BV4.1_+3A_type">type</code></td>
<td>
<p>a single character value that indicates, whether the data was
quarterly (<code>"quarterly"</code>) or monthly (<code>"monthly"</code>) observed; the 
default is <code>"monthly"</code>; if a time series object is passed to <code>yt</code>,
the value for this argument will be automatically selected according to the 
frequency in <code>yt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BV4.1 base model is as follows:
</p>
<p>trend and seasonality are estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + s(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series with <code class="reqn">t=1,...n</code>, <code class="reqn">x_t = t / n</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth trend function, 
<code class="reqn">s(x_t)</code> is a (slowly changing) seasonal component with 
seasonal period <code class="reqn">p_s</code> and <code class="reqn">\epsilon_t</code> are stationary errors 
with <code class="reqn">E(\epsilon_t) = 0</code> that are furthermore assumed to be independent 
but identically distributed (i.i.d.).
</p>
<p>It is assumed that <code class="reqn">m</code> and <code class="reqn">s</code> can be approximated locally by a
polynomial of
small order and by a trigonometric polynomial, respectively. Through locally
weighted regression, <code class="reqn">m</code> and <code class="reqn">s</code> can therefore be estimated 
suitably.
</p>
<p>The advantage of the Berlin Procedure 4.1 (BV4.1) is that it makes use of
fixed filters based on locally weighted regression (both with a weighted 
mixture of local linear and local cubic components for the trend) at all 
observation time points. Thus, BV4.1 results in fixed weighting matrices 
both for the trend estimation step and for the seasonality estimation step 
that can be immediately applied to all economic time series. 
Those matrices are saved internally in the package and when applying 
<code><a href="#topic+BV4.1">BV4.1</a></code>, 
only weighted sums of the observations (with already obtained weights) have 
to be obtained at all time points. Thus, this procedure is quite fast.
</p>
<p>Permission to include the BV4.1 base model procedure was kindly provided by 
the Federal Statistical Office of Germany.
</p>


<h3>Value</h3>

<p>An S4 object with the following elements is returned.
</p>

<dl>
<dt><code>decomp</code></dt><dd><p>An object of class <code>"mts"</code> that consists of the
decomposed time series data.</p>
</dd>
<dt><code>frequency</code></dt><dd><p>the frequency of the time series.</p>
</dd>
<dt><code>ts_name</code></dt><dd><p>the object name of the initially provided time series object.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Speth, H.-T. (2004). Komponentenzerlegung und Saisonbereinigung ökonomischer 
Zeitreihen mit dem Verfahren BV4.1. Methodenberichte 3. Statistisches 
Bundesamt. URL: https://www.destatis.de/DE/Methoden/Saisonbereinigung/BV41-methodenbericht-Heft3_2004.pdf?__blob=publicationFile.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
Xt &lt;- log(EXPENDITURES)
est &lt;- BV4.1(Xt)
est

</code></pre>

<hr>
<h2 id='bwidth_confint'>Bootstrapping Confidence Intervals for Locally Weighted Regression Bandwidths</h2><span id='topic+bwidth_confint'></span>

<h3>Description</h3>

<p>A stationary block bootstrap is applied to resample from a time 
series that was decomposed into a trend, a seasonal component and a 
remainder by means of data-driven local polynomial regression with 
automatically selected bandwidth. Bandwidth re-estimation from each 
bootstrapped sample results in confidence bounds for the 
bandwidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bwidth_confint(
  nonpar_model,
  blocklen = NULL,
  npaths = 1000,
  parallel = TRUE,
  num_cores = future::availableCores() - 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bwidth_confint_+3A_nonpar_model">nonpar_model</code></td>
<td>
<p>the object with the nonparametric trend and seasonality
estimation results returned by for example the function 
<code><a href="#topic+deseats">deseats</a></code>.</p>
</td></tr>
<tr><td><code id="bwidth_confint_+3A_blocklen">blocklen</code></td>
<td>
<p>a numerical vector of length one that indicates the average 
block length to be drawn from the detrended series; the default is 
<code>NULL</code>, which means <code>8</code> for quarterly and <code>24</code> for monthly 
data; selecting a suitable expected blocklength and checking the sensitivity 
of the blocklength are left for the user.</p>
</td></tr>
<tr><td><code id="bwidth_confint_+3A_npaths">npaths</code></td>
<td>
<p>a numeric vector of length one that indicates the number of
bootstrap paths; the default is <code>npaths = 1000</code>.</p>
</td></tr>
<tr><td><code id="bwidth_confint_+3A_parallel">parallel</code></td>
<td>
<p>a logical vector of length one that indicates whether or 
not to employ parallel programming for the resampling and the subsequently 
data-driven bandwidth estimations from the bootstrapped samples; the default 
is <code>patrallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="bwidth_confint_+3A_num_cores">num_cores</code></td>
<td>
<p>a numeric vector of length one that indicates the number of
CPU cores to use for parallel programming, if <code>parallel = TRUE</code>; the 
default is <code>num_cores = future::availableCores() - 1</code>.</p>
</td></tr>
<tr><td><code id="bwidth_confint_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code><a href="#topic+deseats">deseats</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence bounds for the bandwidth in local polynomial regression 
for identifying the trend in a trend-stationary short-memory time 
series are obtained via a block bootstrap, which ensures that no 
specific model assumptions are required for the detrended series.
</p>
<p>This function makes use of the <code>future</code> parallel programming 
framework to ensure exactly the same results regardless of whether
sequential or parallel programming, and then also regardless of
the number of workers, is employed.
</p>


<h3>Value</h3>

<p>A list with the following elements is returned.
</p>

<dl>
<dt><code>conf</code></dt><dd><p>A vector with named elements that gives the original 
bandwidth estimate as well as the bootstrapped bounds of the 95 and 
99 percent confidence intervals of the bandwidth.</p>
</dd>
<dt><code>bwidth_estimates</code></dt><dd><p>a vector with all the obtained bandwidths 
for the bootstrapped series.</p>
</dd>
<dt><code>se_bwidth</code></dt><dd><p>the sample standard deviation of 
<code>bwidth_estimates</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
xt &lt;- log(EXPENDITURES)
est &lt;- deseats(xt, set_options(order_poly = 3))
conf &lt;- bwidth_confint(est, npaths = 200, num_cores = 2)
conf


</code></pre>

<hr>
<h2 id='bwidth+2Cdeseats-method'>Retrieve the Used Bandwidth from an Estimation Object</h2><span id='topic+bwidth+2Cdeseats-method'></span><span id='topic+bwidth+2Cs_semiarma-method'></span>

<h3>Description</h3>

<p>If either <code><a href="#topic+deseats">deseats</a></code> or <code><a href="#topic+s_semiarma">s_semiarma</a></code> are 
used to fit a model to time series data, this method retrieves 
the applied bandwidth from the output object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'deseats'
bwidth(object)

## S4 method for signature 's_semiarma'
bwidth(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bwidth+2B2Cdeseats-method_+3A_object">object</code></td>
<td>
<p>an object either of class <code>"deseats"</code> or 
<code>"s_semiarma"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When applying <code><a href="#topic+deseats">deseats</a></code> or <code>link{s_semiarma}</code>,
one approach is to let the functions automatically choose a 
bandwidth for locally weighted regression. Using this method,
the applied bandwidth can be retrieved.
</p>


<h3>Value</h3>

<p>A numeric vector of length one that represents the bandwidth used in the
smoothing procedure is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Xt &lt;- log(EXPENDITURES)
smoothing_options &lt;- set_options(order_poly = 3)
est &lt;- deseats(Xt, smoothing_options = smoothing_options)
bwidth(est)


</code></pre>

<hr>
<h2 id='CIVLABOR'>Monthly Civilian Labor Force Level in the USA</h2><span id='topic+CIVLABOR'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly observed civilian labor force
level in the USA (in millions of persons) from January 1948 to December 2019. 
The object contains 864 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIVLABOR
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 864.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the Federal Reserve Bank of 
St. Louis (accessed: 2022-09-01) and then transformed into a time series
object using R.
</p>
<p><a href="https://fred.stlouisfed.org/series/LNU01000000">https://fred.stlouisfed.org/series/LNU01000000</a>
</p>

<hr>
<h2 id='CONSUMPTION'>Quarterly Real Final Consumption Expenditure for Australia</h2><span id='topic+CONSUMPTION'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the quarterly real final consumption 
expenditure (in thousands of domestic currency) from the third quarter of 1959 
to the last quarter in  2019. The object contains 242 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CONSUMPTION
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> with 242 rows and 1 columns.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the Federal Reserve Bank 
of St. Louis
(accessed: 2023-09-26) and 
then transformed into a time series
object using R. 
</p>
<p><a href="https://fred.stlouisfed.org/series/NCRNSAXDCAUQ">https://fred.stlouisfed.org/series/NCRNSAXDCAUQ</a>
</p>

<hr>
<h2 id='COVID'>Daily Confirmed New COVID-19 Cases in Germany</h2><span id='topic+COVID'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the daily confirmed new COVID-19 cases
in Germany (in thousands of cases) from June 2021 to November 2021.
The object contains 183 observations. The time series object is created 
as a time series object with frequency 7, i.e. the time unit is in calendar 
weeks of the year 2021 and not in years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COVID
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 183.
</p>


<h3>Source</h3>

<p>The data was obtained from the COVID-19 Data Hub 
(accessed: 2023-09-25) and 
then transformed into a time series
object using R. 
</p>
<p><a href="https://covid19datahub.io/">https://covid19datahub.io/</a>
</p>

<hr>
<h2 id='create.gain'>Create Gain Function from a Linear Time Series Filter</h2><span id='topic+create.gain'></span>

<h3>Description</h3>

<p>This function takes a coefficient series of a linear
time series filter as an input and then returns the 
corresponding gain function as an R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.gain(filter.coefs = c(1), zero.at = ceiling(length(filter.coefs)/2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.gain_+3A_filter.coefs">filter.coefs</code></td>
<td>
<p>a numeric vector with the filter coefficients ordered 
by coefficient index; see details for more info.</p>
</td></tr>
<tr><td><code id="create.gain_+3A_zero.at">zero.at</code></td>
<td>
<p>a numeric vector of length one that indicates the position 
of the coefficient for the present observation in <code>filter.coefs</code>;
by default, the position is in the middle or just below the midpoint.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a functional. The function returns a function that 
represents the gain function for the input filter 
<code>filter.coefs</code>. The returned function only has the 
argument <code>lambda</code>, which is the frequency for which 
the value of the gain function should be obtained.
</p>
<p>Let <code class="reqn">(y_t)</code> be the input series and <code class="reqn">(c_j)</code> the linear filter; 
then the element <code class="reqn">c_j</code> is the weight assigned to <code class="reqn">y_{t-j}</code>. The 
corresponding index <code class="reqn">j</code> is important for the order of the argument
<code>filter.coefs</code>.
</p>


<h3>Value</h3>

<p>The function returns a &quot;gain function&quot; function that has the numeric 
argument <code>lambda</code> only that represents frequencies to calculate 
the values of the gain function for.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Moving average with smoothing over three values
a &lt;- 1 / 3
gain_ma &lt;- create.gain(rep(a, 3))
lambda &lt;- seq(0, 0.5, 0.001)
GF &lt;- gain_ma(lambda)
plot(lambda, GF, type = "l")



# First differences filter
b &lt;- c(1, -1)
gain_diff &lt;- create.gain(b)
lambda &lt;- seq(0, 0.5, 0.001)
GF2 &lt;- gain_diff(lambda)
plot(lambda, GF2, type = "l")


# For a fully data-driven local linear trend + 
# trigonometric polynomial seasonality
# (Note: we get various filters for different observation time points)

xt &lt;- EXPENDITURES
est &lt;- deseats(log(xt), set_options(order_poly = 3))
ws &lt;- est@weights[, , "Combined"]
l &lt;- (length(ws[, 1]) - 1) / 2

lambda &lt;- seq(0, 0.5, 0.001)
mat &lt;- matrix(0, ncol = length(lambda), nrow = l + 1)
colF &lt;- colorRampPalette(c("deepskyblue4", "deepskyblue"))
cols &lt;- colF(l)

for (j in 1:(l + 1)) {

  gainF &lt;- create.gain(ws[j, ], zero.at = j)
  mat[j, ] &lt;- gainF(lambda)

}

matplot(lambda, t(mat), type = paste0(rep("l", l + 1), collapse = ""),
        lty = rep(1, l + 1), col = cols)
title(
  main = paste0(
    "Gain functions for the applied data-driven locally weighted ",
    "regression\napproach at boundary points and the first interior ",
    "point"
  )
)

# Same example as before but not for the trend but for the detrending filters
# (Note: we get various filters for different observation time points)

ll &lt;- l * 2 + 1
mat2 &lt;- mat

for (j in 1:(l + 1)) {

  zero.vec &lt;- rep(0, ll)
  zero.vec[[j]] &lt;- 1
  gainF &lt;- create.gain(zero.vec - ws[j, ], zero.at = j)
  mat2[j, ] &lt;- gainF(lambda)

}

matplot(lambda, t(mat2), type = paste0(rep("l", l + 1), collapse = ""),
        lty = rep(1, l + 1), col = cols)
title(
  main = paste0(
    "Gain functions for the applied data-driven detrending filter\n",
    "at boundary points and the first interior ",
    "point"
  )
)


</code></pre>

<hr>
<h2 id='DEATHS'>Monthly Deaths in Germany</h2><span id='topic+DEATHS'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly observed deaths in Germany
(in thousands of cases) from January 1990 to April 2022. The object 
contains 388 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEATHS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 388.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank &quot;Genesis&quot; of the National 
Statistical Office of Germany (accessed: 2022-07-21) and then transformed into 
a time series object using R.
</p>
<p><a href="https://www-genesis.destatis.de/genesis/online?operation=abruftabelleBearbeiten&amp;levelindex=2&amp;levelid=1658407055248&amp;auswahloperation=abruftabelleAuspraegungAuswaehlen&amp;auswahlverzeichnis=ordnungsstruktur&amp;auswahlziel=werteabruf&amp;code=12613-0005&amp;auswahltext=&amp;werteabruf=Werteabruf#abreadcrumb">https://www-genesis.destatis.de/genesis/online?operation=abruftabelleBearbeiten&amp;levelindex=2&amp;levelid=1658407055248&amp;auswahloperation=abruftabelleAuspraegungAuswaehlen&amp;auswahlverzeichnis=ordnungsstruktur&amp;auswahlziel=werteabruf&amp;code=12613-0005&amp;auswahltext=&amp;werteabruf=Werteabruf#abreadcrumb</a>
</p>

<hr>
<h2 id='deseats'>Locally Weighted Regression for Trend and Seasonality in Equidistant Time 
Series under Short Memory</h2><span id='topic+deseats'></span>

<h3>Description</h3>

<p>Simultaneously estimate the trend and the 
seasonality via locally weighted regression in an equidistant time series 
under short memory. The default setting uses an iterative plug-in algorithm 
for identifying the asymptotically globally optimal bandwidth for smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deseats(
  y,
  smoothing_options = set_options(),
  bwidth_start = NULL,
  inflation_rate = c("optimal", "naive"),
  correction_factor = FALSE,
  autocor = TRUE,
  drop = NULL,
  error_model = c("free", "ARMA"),
  nar_lim = c(0, 3),
  nma_lim = c(0, 3),
  arma_mean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deseats_+3A_y">y</code></td>
<td>
<p>a numerical vector or a time series object of class <code>ts</code> or 
that can be transformed with <code><a href="stats.html#topic+as.ts">as.ts</a></code> to an object of class 
<code>ts</code>; for these observations, trend and seasonality will be obtained.</p>
</td></tr>
<tr><td><code id="deseats_+3A_smoothing_options">smoothing_options</code></td>
<td>
<p>an S4 object of class <code>smoothing_options</code>, which 
is returned by the function <code><a href="#topic+set_options">set_options</a></code>; it 
includes details about the
options to consider in the locally weighted regression such as the order of
polynomial and the bandwidth for smoothing among others.</p>
</td></tr>
<tr><td><code id="deseats_+3A_bwidth_start">bwidth_start</code></td>
<td>
<p>a single numeric value that is only relevant if the slot
<code>bwidth</code> in <code>smoothing_options</code> is set to <code>NA</code>; 
as the bandwidth will then
be selected automatically, <code>bwidth_start</code> sets the initial bandwidth for 
the algorithm; the default, <code>bwidth_start = NULL</code>, corresponds to 
<code>bwidth_start = 0.1</code> for a local linear trend and to 
<code>bwidth_start = 0.2</code> for a local cubic trend.</p>
</td></tr>
<tr><td><code id="deseats_+3A_inflation_rate">inflation_rate</code></td>
<td>
<p>a character vector of length one that indicates, which inflation rate 
to use in the bandwidth selection; for a local linear trend, we have 
<code>inflation_rate = "optimal"</code> as the default, for a local cubic trend
it is <code>inflation_rate = "naive"</code>, which correspond to inflation rates
of 5/7 and 9/13, respectively.</p>
</td></tr>
<tr><td><code id="deseats_+3A_correction_factor">correction_factor</code></td>
<td>
<p>A logical vector of length one; theoretically, a 
larger bandwidth to estimate the sum of autocovariances from residuals of 
pilot trend and seasonality estimates is advisable than for estimating trend
and seasonality; for <code>correction_factor = TRUE</code>, this is implemented;
for <code>error_model = "ARMA"</code>, <code>correction_factor = FALSE</code> is 
enforced; the default is <code>correction_factor = FALSE</code>, because it was
found that setting this argument to <code>TRUE</code> often overestimates the 
bandwidth.</p>
</td></tr>
<tr><td><code id="deseats_+3A_autocor">autocor</code></td>
<td>
<p>a logical vector of length one; indicates whether to consider
autocorrelated errors (<code>TRUE</code>) or independent but identically 
distributed errors (<code>FALSE</code>); the default is <code>autocor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="deseats_+3A_drop">drop</code></td>
<td>
<p>a numeric vector of length one that indicates the proportion of 
the observations to not include at each boundary in the bandwidth estimation 
process, if a bandwidth is selected automatically; the default is 
<code>drop = NULL</code>, which corresponds to <code>drop = 0.05</code> for a 
local linear trend and to <code>drop = 0.1</code> for a local cubic trend.</p>
</td></tr>
<tr><td><code id="deseats_+3A_error_model">error_model</code></td>
<td>
<p>a character vector of length one that indicates whether
for <code>autocor = TRUE</code> the sum of autocovariances of the errors is 
obtained purely nonparametrically (<code>"free"</code>) or whether an
autoregressive moving-average (ARMA) model is assumed <code>"ARMA"</code>; the
default is <code>error_model = "free"</code>.</p>
</td></tr>
<tr><td><code id="deseats_+3A_nar_lim">nar_lim</code></td>
<td>
<p>only valid for <code>error_model = "ARMA"</code>; set the minimum and 
maximum AR order to check via the BIC in each iteration of the algorithm via 
a two-element vector.</p>
</td></tr>
<tr><td><code id="deseats_+3A_nma_lim">nma_lim</code></td>
<td>
<p>only valid for <code>error_model = "ARMA"</code>; set the minimum and
maximum MA order to check via the BIC in each iteration of the algorithm via
a two-element vector.</p>
</td></tr>
<tr><td><code id="deseats_+3A_arma_mean">arma_mean</code></td>
<td>
<p>only valid for <code>error_model = "ARMA"</code>; decide whether to 
include an estimate of the mean in the ARMA fitting for the detrended series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trend and seasonality are estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + s(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series with <code class="reqn">t=1,...n</code>, <code class="reqn">x_t = t / n</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function, <code class="reqn">s(x_t)</code> is a (slowly changing) seasonal component with 
seasonal period <code class="reqn">p_s</code> and <code class="reqn">\epsilon_t</code> are stationary errors 
with <code class="reqn">E(\epsilon_t) = 0</code> and short-range dependence (see for example also 
Feng, 2013, for a similar model, where the stochastic term is however i.i.d.).
</p>
<p>It is assumed that <code class="reqn">m</code> and <code class="reqn">s</code> can be approximated locally by a polynomial of
small order and by a trigonometric polynomial, respectively. Through locally
weighted regression, <code class="reqn">m</code> and <code class="reqn">s</code> can therefore be estimated given 
a suitable bandwidth.
</p>
<p>The iterative-plug-in (IPI) algorithm, which numerically minimizes the
asymptotic mean squared error (AMISE) to select a bandwidth is 
an extension of Feng (2013) to the case with short-range dependence in the 
errors. To achieve this goal, the error variance in the AMISE in Feng (2013) 
is replaced by the sum of autocovariances of the error process and this 
quantity is being estimated using a slightly adjusted version of the 
Bühlmann (1996) algorithm. This procedure is similar to the method described 
in Feng, Gries and Fritz (2020), 
where data-driven local polynomial regression with an automatically selected 
bandwidth is used to estimate the trend according to a model without 
seasonality and where the same adjusted Bühlmann (1996) algorithm is 
considered to estimate the sum of autocovariances in the error process.
</p>
<p>Define <code class="reqn">I[m^{(k)}] = \int_{c_b}^{d_b} [m^{(k)}(x)]^2 dx</code>, <code class="reqn">\beta_{(k)} = \int_{-1}^{1} u^k
K(u) du</code>
and <code class="reqn">R(K) = \int_{-1}^{1} K^{2}(u) du</code>, where <code class="reqn">p</code> is the order of the (local) polynomial 
considered for <code class="reqn">m</code>,
<code class="reqn">k = p + 1</code> is the order of the asymptotically equivalent kernel <code class="reqn">K</code> 
for estimating <code class="reqn">m</code>, <code class="reqn">0 \leq c_{b}&lt; d_{b} \leq 1</code>, and
<code class="reqn">c_f</code> is the variance factor, i.e. the sum of autocovariances divided by 
<code class="reqn">2\pi</code>.
</p>
<p>Furthermore, we define
</p>
<p style="text-align: center;"><code class="reqn">C_{1} = \frac{I[m^{(k)}] \beta_{(k)}^2}{(k!)^2}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">C_{2} = \frac{2 \pi c_{f} (d_b - c_b)[R(K) + (p_s - 1) R(W)]}{nh}</code>
</p>

<p>with <code class="reqn">h</code> being the bandwidth, <code class="reqn">n</code> being the number of
observations and <code class="reqn">W</code> being the weighting function considered in the 
weighted least squares approach, for example a second-order kernel function 
with support on <code class="reqn">[-1,1]</code>. The AMISE is then
</p>
<p style="text-align: center;"><code class="reqn">AMISE(h) = h^{2k}C_{1} + C_{2}.</code>
</p>

<p>The function calculates suitable estimates for <code class="reqn">c_f</code>, the variance
factor, and <code class="reqn">I[m^{(k)}]</code> over different iterations. In each
iteration, a bandwidth is obtained in accordance with the AMISE that once
more serves as an input for the following iteration. The process repeats
until either convergence or the 40th iteration is reached. For further
details on the asymptotic theory or the algorithm, please consult Feng,
Gries and Fritz (2020) or Feng et al. (2019).
</p>
<p>To apply the function, only few arguments are needed: a data input <code>y</code>,
an object with smoothing options <code>smoothing_options</code> returned by 
<code><a href="#topic+set_options">set_options</a></code> and 
a starting value for the relative bandwidth
<code>bwidth_start</code>. Aside from <code>y</code>, each argument has a default setting.
By default, a local linear trend is considered. In some cases, a local cubic 
trend may, however, be more suitable. For more specific information on the input arguments
consult the section <em>Arguments</em>.
</p>
<p>When applying the function, an optimal bandwidth is obtained based on the
IPI algorithm proposed by Feng, Gries and Fritz (2020). In a second step,
the nonparametric trend of the series and the seasonality are calculated with 
respect to the chosen bandwidth.
</p>
<p>Note that with this function <code class="reqn">m(x_t)</code> and <code class="reqn">s(x_t)</code> can be 
estimated without a parametric
model assumption for the error series. Thus, after estimating and removing
the trend and the seasonality, any suitable parametric model, e.g. an 
ARMA(<code class="reqn">p,q</code>) model for <code>errors = "autocor"</code>, can be fitted to the 
residuals (see <code><a href="stats.html#topic+arima">arima</a></code>).
</p>
<p>Usually, a local cubic trend (<code>smoothing_options = set_options(order_poly = 3)</code>)
gives more suitable results. Moreover, if the resulting bandwidth is too large, 
adjustments to the arguments <code>inflation_rate</code> and <code>drop</code> should be
tried first in that order before any other changes 
to the input arguments.
</p>
<p>The default print method for this function delivers key numbers such as the 
bandwidth considered for smoothing.
</p>
<p>NOTE:
</p>
<p>This function implements C++ code by means
of the <code><a href="Rcpp.html#topic+Rcpp-package">Rcpp</a></code> and
<code>RcppArmadillo</code> packages for
better performance.
</p>


<h3>Value</h3>

<p>The function returns and S4 object with the following elements (access them 
via <code>@</code>):
</p>

<dl>
<dt><code>boundary_method</code></dt><dd><p>the applied boundary method.</p>
</dd>
<dt><code>bwidth</code></dt><dd><p>the globally applied bandwidth in the smoothing process; if not 
if no input is given in the function call, this is the automatically selected 
optimal bandwidth.</p>
</dd>
<dt><code>decomp</code></dt><dd><p>An object of class <code>"mts"</code> that consists of the
decomposed time series data.</p>
</dd>
<dt><code>frequency</code></dt><dd><p>the frequency of the time series.</p>
</dd>
<dt><code>kernel_fun</code></dt><dd><p>the second-order kernel function considered for weighting.</p>
</dd>
<dt><code>order_poly</code></dt><dd><p>the order of polynomial considered locally for the trend.</p>
</dd>
<dt><code>order_poly</code></dt><dd><p>the order of polynomial considered locally for the trend.</p>
</dd>
<dt><code>sum_autocov</code></dt><dd><p>the estimated sum of autocovariances.</p>
</dd>
<dt><code>ts_name</code></dt><dd><p>the object name of the initially provided time series object.</p>
</dd>
<dt><code>weights_wfun</code></dt><dd><p>a matrix that gives the weights of the weighting 
function <code class="reqn">K</code> at each estimation time point; ; if 
<code class="reqn">n</code> is the length of the given time series and <code class="reqn">b</code> is the applied 
(relative) bandwidth, then the first row of the weighting system gives the 
weighting function weights when estimating at <code class="reqn">t=1</code>, the second row gives 
the weights when estimating at <code class="reqn">t=2</code> and so on for all left-hand side 
boundary points 
until the middle row, which contains the 
weights used at all interior points; the rows following the middle row contain
the weights for right-hand side boundary points (the rows are ordered
chronologically)</p>
</dd>
<dt><code>weights</code></dt><dd><p>an array with many slices that represent the weighting 
systems for various filters; each slice is a matrix, which gives the weighting 
system to estimate a component, for example trend + seasonality, as a weighted 
average from the given time series; if 
<code class="reqn">n</code> is the length of the given time series and <code class="reqn">b</code> is the applied 
(relative) bandwidth, then the first row of the weighting system gives the 
weights to obtain estimates at <code class="reqn">t=1</code>, the second row gives the weights to 
obtain estimates at <code class="reqn">t=2</code> and so on for all left-hand side boundary points 
until the middle row, which contains the 
weights used at all interior points; the rows following the middle row contain
the weights for right-hand side boundary points (the rows are ordered
chronologically); 
the slice names are <code>"Trend"</code>, <code>"Season"</code> and <code>"Combined"</code>,
where <code>"Combined"</code> are the weights to estimate trend + seasonality 
combined.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li>
<li><p> Yuanhua Feng (Department of Economics, Paderborn
University), <br />
Author
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Bühlmann, P. (1996). Locally Adaptive Lag-Window Spectral Estimation.
Journal of Time Series Analysis, 17(3): 247-270. 
DOI: 10.1111/j.1467-9892.1996.tb00275.x.
</p>
</li>
<li><p>Feng, Y. (2013). An iterative plug-in algorithm for decomposing seasonal 
time series using the Berlin Method. Journal of Applied Statistics, 40(2): 
266-281. DOI: 10.1080/02664763.2012.740626.
</p>
</li>
<li><p>Feng, Y., Gries. T, and Fritz, M. (2020). Data-driven local polynomial 
for the trend and its derivatives in economic time series. Journal of 
Nonparametric Statistics, 32(2): 510-533. DOI: 10.1080/10485252.2020.1759598.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
Xt &lt;- log(EXPENDITURES)
smoothing_options &lt;- set_options(order_poly = 3)
est &lt;- deseats(Xt, smoothing_options = smoothing_options)
est
plot(est, which = 1)


</code></pre>

<hr>
<h2 id='ENERGY'>Monthly Total Production and Distribution of Electricity, Gas, Steam, and Air Conditioning for Germany</h2><span id='topic+ENERGY'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly production and distribution 
of electricity gas steam, and air conditioning for Germany (Index 2015 = 100) 
from January 1991 
to June 2023. The object contains 390 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ENERGY
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> with 390 rows and 1 columns.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the Federal Reserve Bank 
of St. Louis
(accessed: 2023-10-11) and 
then transformed into a time series
object using R. 
</p>
<p><a href="https://fred.stlouisfed.org/series/DEUPREND401IXOBM">https://fred.stlouisfed.org/series/DEUPREND401IXOBM</a>
</p>

<hr>
<h2 id='EXPENDITURES'>Quarterly Personal Consumption Expenditures in the USA</h2><span id='topic+EXPENDITURES'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the quarterly observed personal
consumption expenditures in the USA in trillions of dollars from the
first quarter of 1947 to the last quarter of 2019. The object contains
292 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EXPENDITURES
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 292.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the Federal Reserve Bank of 
St. Louis (accessed: 2022-07-15) and then transformed into a time series
object using R.
</p>
<p><a href="https://fred.stlouisfed.org/series/NA000349Q">https://fred.stlouisfed.org/series/NA000349Q</a>
</p>

<hr>
<h2 id='expo'>Automatic Creation of Animations</h2><span id='topic+expo'></span>

<h3>Description</h3>

<p>A generic that is the basis for methods that allow the user to exponentiate 
certain results quickly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expo_+3A_object">object</code></td>
<td>
<p>the input object.</p>
</td></tr>
<tr><td><code id="expo_+3A_...">...</code></td>
<td>
<p>currently of no use; included for future compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A generic that can be extended by methods to exponentiate the numeric 
information in certain objects.
</p>


<h3>Value</h3>

<p>This generic does not return anything and is just the basis for more 
sophisticated methods.
</p>

<hr>
<h2 id='expo+2Cdeseats_fc-method'>Exponentiate <code>deseats</code> Forecasts</h2><span id='topic+expo+2Cdeseats_fc-method'></span>

<h3>Description</h3>

<p>Exponentiate, i.e. as act of retransformation, (point and interval) forecasts 
obtained via the <code>deseats</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'deseats_fc'
expo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expo+2B2Cdeseats_fc-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"deseats_fc"</code>.</p>
</td></tr>
<tr><td><code id="expo+2B2Cdeseats_fc-method_+3A_...">...</code></td>
<td>
<p>currently without purpose; included for compatibility only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"deseats_fc"</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
est &lt;- s_semiarma(log(EXPENDITURES), set_options(order_poly = 3))
fc &lt;- predict(est, n.ahead = 8)
fc2 &lt;- expo(fc)
fc2


</code></pre>

<hr>
<h2 id='fitted+2Chfilter-method'>Fitted Components of the Hamilton Filter</h2><span id='topic+fitted+2Chfilter-method'></span><span id='topic+residuals+2Chfilter-method'></span>

<h3>Description</h3>

<p>Obtain either fitted values or residuals from a fitted Hamilton filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hfilter'
fitted(object, ...)

## S4 method for signature 'hfilter'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted+2B2Chfilter-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"hfilter"</code>, i.e. generated by a 
call to <code><a href="#topic+hamilton_filter">hamilton_filter</a></code>.</p>
</td></tr>
<tr><td><code id="fitted+2B2Chfilter-method_+3A_...">...</code></td>
<td>
<p>currently without further use; implemented for compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obtain the fitted and the residual values from the result of a fitted 
Hamilton filter. The name of the method indicates, what is returned.
</p>


<h3>Value</h3>

<p>A time series object of class <code>"ts"</code> is returned.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>est &lt;- hamilton_filter(log(EXPENDITURES))
residuals(est)
fitted(est)

</code></pre>

<hr>
<h2 id='gain'>Gain Function Generic</h2><span id='topic+gain'></span>

<h3>Description</h3>

<p>Gain Function Generic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gain(object, lambda = seq(0, 0.5, 1e-04), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gain_+3A_object">object</code></td>
<td>
<p>an input object; for the linear filters considered in this 
object, gain function values should be obtained.</p>
</td></tr>
<tr><td><code id="gain_+3A_lambda">lambda</code></td>
<td>
<p>a vector of frequencies (from 0 to 0.5) for which 
to obtain the gain function.</p>
</td></tr>
<tr><td><code id="gain_+3A_...">...</code></td>
<td>
<p>currently without use; for possible future compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A standard generic function. The purpose is to build various methods 
to instantaneously obtain gain function values for linear filters of 
different decomposition objects.
</p>
<p>A generic that can be extended by methods to automatically obtain gain 
function values of linear filters described in certain objects.
</p>


<h3>Value</h3>

<p>This generic does not return anything and is just the basis for more 
sophisticated methods.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>


<hr>
<h2 id='gain+2Cdeseats-method'>Obtain gain function values for DeSeaTS Trend and Detrend Filters</h2><span id='topic+gain+2Cdeseats-method'></span>

<h3>Description</h3>

<p>Obtain gain function values for DeSeaTS Trend and Detrend Filters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'deseats'
gain(object, lambda = seq(0, 0.5, 1e-04), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gain+2B2Cdeseats-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"deseats"</code>.</p>
</td></tr>
<tr><td><code id="gain+2B2Cdeseats-method_+3A_lambda">lambda</code></td>
<td>
<p>a numeric vector with the frequencies at which to get 
the gain function values.</p>
</td></tr>
<tr><td><code id="gain+2B2Cdeseats-method_+3A_...">...</code></td>
<td>
<p>no current purpose for this ellipsis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The various filters obtained via <code><a href="#topic+deseats">deseats</a></code> (represented by 
the returned weighting systems) have a representation in the frequency 
domain. Using this method, those gain function values can be easily 
obtained.
</p>


<h3>Value</h3>

<p>A list is returned. Each element represents gain function values 
at the specified frequencies <code>lambda</code> for the filter defined 
through the element name.
</p>

<dl>
<dt><code>gain_trend</code></dt><dd><p>gain function values for the trend filter.</p>
</dd>
<dt><code>gain_detrend</code></dt><dd><p>gain function values for the detrending filter.</p>
</dd>
<dt><code>gain_season</code></dt><dd><p>gain function values for the seasonality filter.</p>
</dd>
<dt><code>gain_deseason</code></dt><dd><p>gain function values for the seasonal 
adjustment filter.</p>
</dd>
<dt><code>gain_comb</code></dt><dd><p>gain function values for the trend + seasonality 
filter.</p>
</dd>
<dt><code>gain_decomb</code></dt><dd><p>gain function values for the detrending + seasonal 
adjustment filter.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
xt &lt;- log(EXPENDITURES)
est &lt;- deseats(xt)

lambda &lt;- seq(0, 0.5, 0.01)
gain_values &lt;- gain(est, lambda = lambda)
m &lt;- length(gain_values$gain_trend[, 1])
k &lt;- (m - 1) / 2
colF &lt;- colorRampPalette(c("deepskyblue4", "deepskyblue"))
cols &lt;- colF(m)

matplot(lambda, t(gain_values$gain_decomb[1:(k + 1), ]), 
 type = paste0(rep("l", k + 1), collapse = ""),
 col = cols, lty = rep(1, k + 1))
title("Gain functions of the combined detrend and deseasonalization filters")

matplot(lambda, t(gain_values$gain_trend[1:(k + 1), ]), 
 type = paste0(rep("l", k + 1), collapse = ""),
 col = cols, lty = rep(1, k + 1))
title("Gain functions of the trend filters")

matplot(lambda, t(gain_values$gain_deseason[1:(k + 1), ]), 
 type = paste0(rep("l", k + 1), collapse = ""),
 col = cols, lty = rep(1, k + 1))
title("Gain functions of the seasonal adjustment filters")
 

</code></pre>

<hr>
<h2 id='GDP'>Quarterly US GDP</h2><span id='topic+GDP'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the quarterly US GDP
(in billions of USD) from the first quarter of 1947 to the last quarter in 
2019. The object contains 292 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GDP
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> with 292 rows and 1 columns.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the Federal Reserve Bank 
of St. Louis
(accessed: 2023-09-25) and 
then transformed into a time series
object using R. 
</p>
<p><a href="https://fred.stlouisfed.org/series/NA000334Q">https://fred.stlouisfed.org/series/NA000334Q</a>
</p>

<hr>
<h2 id='hA_calc'>Calculation of Theoretically Optimal Bandwidth and Its Components</h2><span id='topic+hA_calc'></span>

<h3>Description</h3>

<p>Allows to calculate the theoretically optimal bandwidth for estimating
the trend and the seasonality in an equidistant time series with short-range 
dependence using locally weighted regression, if the trend function 
and the exact ARMA dependence structure of the errors are known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hA_calc(
  m,
  arma = list(ar = NULL, ma = NULL, sd_e = 1),
  p = c(1, 3),
  mu = c(0, 1, 2, 3),
  frequ = c(4, 12),
  n = 300,
  cb = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hA_calc_+3A_m">m</code></td>
<td>
<p>an expression that defines the trend function in terms of <code>x</code>,
where <code>x</code> is the rescaled time on the interval <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="hA_calc_+3A_arma">arma</code></td>
<td>
<p>a list with the elements <code>ar</code>, <code>ma</code> and <code>sd_e</code>;
<code>ar</code> is a numeric vector with the AR-coefficients, <code>ma</code> is a numeric 
vector with the MA-coefficients and <code>sd_e</code> is the innovation standard 
deviation.</p>
</td></tr>
<tr><td><code id="hA_calc_+3A_p">p</code></td>
<td>
<p>the order of polynomial to use locally for the trend estimation.</p>
</td></tr>
<tr><td><code id="hA_calc_+3A_mu">mu</code></td>
<td>
<p>the smoothness parameter of the second-order kernel function used 
in the weighting process.</p>
</td></tr>
<tr><td><code id="hA_calc_+3A_frequ">frequ</code></td>
<td>
<p>the frequency of the theoretical time series (4 for quarterly and
12 for monthly time series).</p>
</td></tr>
<tr><td><code id="hA_calc_+3A_n">n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="hA_calc_+3A_cb">cb</code></td>
<td>
<p>the part of observations to drop at each boundary.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For simulation studies of the function <code><a href="#topic+deseats">deseats</a></code> one may be 
interested in obtaining the theoretically optimal bandwidth for local 
regression first for a given theoretical process (from which realizations 
will be drawn in the simulation). This function assists in obtaining this 
theoretical bandwidth.
</p>


<h3>Value</h3>

<p>This function returns a list with various elements. See the documentation of 
<code><a href="#topic+deseats">deseats</a></code> to understand, what each quantity signifies.
</p>

<dl>
<dt><code>b</code></dt><dd><p>This is the theoretical quantity <code class="reqn">\beta_{(k)}</code>.</p>
</dd>
<dt><code>hA</code></dt><dd><p>The theoretically asymptotically optimal global bandwidth for 
locally weighted regression applied to the theoretical time series under 
consideration.</p>
</dd>
<dt><code>Imk</code></dt><dd><p>This is the theoretical quantity <code class="reqn">I[m^{(k)}]</code>.</p>
</dd>
<dt><code>RK</code></dt><dd><p>This is the theoretical quantity <code class="reqn">R(K)</code>.</p>
</dd>
<dt><code>RW</code></dt><dd><p>This is the theoretical quantity <code class="reqn">R(W)</code>.</p>
</dd>
<dt><code>sum_autocov</code></dt><dd><p>This is the theoretical quantity <code class="reqn">2\pi c_f</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
arma &lt;- list(ar = 0.8, sd_e = 0.01)
m_f &lt;- expression(13.1 + 3.1 * x + (dnorm(x / 0.15 - 0.5 / 0.15) / 0.15) / 4)
n &lt;- 500
p &lt;- 1
mu &lt;- 1
frequ &lt;- 4
cb &lt;- 0.05

hA_calc(
 m = m_f,
 arma = arma, 
 p = p,
 mu = mu,
 frequ = frequ,
 n = n,
 cb = cb
)

t &lt;- 1:n
xt &lt;- t / n
mxt &lt;- 13.1 + 3.1 * xt + dnorm(xt, mean = 0.5, sd = 0.15) / 4

S2 &lt;- rep(c(0, 1, 0, 0), length.out = n)
S3 &lt;- rep(c(0, 0, 1, 0), length.out = n)
S4 &lt;- rep(c(0, 0, 0, 1), length.out = n)
sxt &lt;- -0.5 + 0.25 * S2 + 0.5 * S3 + 1.25 * S4

set.seed(123)
et &lt;- arima.sim(model = list(ar = 0.8), sd = 0.01, n = n)
yt &lt;- ts(mxt + sxt + et, frequency = frequ)
plot(yt)

est &lt;- deseats(yt)
est@bwidth
est@sum_autocov


</code></pre>

<hr>
<h2 id='hamilton_filter'>Time Series Filtering Using the Hamilton Filter</h2><span id='topic+hamilton_filter'></span>

<h3>Description</h3>

<p>A stationary remainder is obtained from a univariate time series using the 
filter proposed by Hamilton. The filter is capable of estimating the trend 
together with the seasonality in a series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hamilton_filter(yt, h = NULL, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hamilton_filter_+3A_yt">yt</code></td>
<td>
<p>a time series object of class <code>ts</code> or an object that can be 
transformed to that class using <code><a href="stats.html#topic+as.ts">as.ts</a></code>.</p>
</td></tr>
<tr><td><code id="hamilton_filter_+3A_h">h</code></td>
<td>
<p>the backwards time skip for the first regressor; the default is 
the seasonal period in <code>yt</code> multiplied by 2.</p>
</td></tr>
<tr><td><code id="hamilton_filter_+3A_p">p</code></td>
<td>
<p>the number of regressors; the default is the seasonal period in
<code>yt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implement the filter by Hamilton (2018) to decompose a time series.
</p>


<h3>Value</h3>

<p>A list with the following elements is returned.
</p>

<dl>
<dt>decomp</dt><dd><p>an object of class <code>"mts"</code> that consists of the
decomposed time series data.</p>
</dd>
<dt>ts_name</dt><dd><p>the object name of the initially provided time series object.</p>
</dd>
<dt>frequency</dt><dd><p>the frequency of the time series.</p>
</dd>
<dt>regression_output</dt><dd><p>an object of class <code>"lm"</code>, i.e. basic regression
output.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hamilton, J. D. (2018). Why You Should Never Use the Hodrick-Prescott Filter.
The Review of Economics and Statistics, 100(5): 831–843.
DOI: 10.1162/rest_a_00706.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>est &lt;- hamilton_filter(log(EXPENDITURES))
est

</code></pre>

<hr>
<h2 id='HOUSES'>Monthly New One Family Houses Sold in the USA</h2><span id='topic+HOUSES'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly new one family houses sold in 
the USA (in thousands of units) from January 1985 
to December 2005. The object contains 252 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HOUSES
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> with 252 rows and 1 columns.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the Federal Reserve Bank 
of St. Louis
(accessed: 2023-09-30) and 
then transformed into a time series
object using R. 
</p>
<p><a href="https://fred.stlouisfed.org/series/HSN1FNSA">https://fred.stlouisfed.org/series/HSN1FNSA</a>
</p>

<hr>
<h2 id='LIVEBIRTHS'>Monthly Live Births in Germany</h2><span id='topic+LIVEBIRTHS'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly observed live births in Germany
(in thousands of cases) from January 1995 to March 2023. The object 
contains 339 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LIVEBIRTHS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 339.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank &quot;Genesis&quot; of the National 
Statistical Office of Germany (accessed: 2023-06-15) and then transformed into 
a time series object using R.
</p>
<p><a href="https://www-genesis.destatis.de/genesis/online?operation=previous&amp;levelindex=4&amp;levelid=1686843345946&amp;levelid=1686843308009&amp;step=3#abreadcrumb">https://www-genesis.destatis.de/genesis/online?operation=previous&amp;levelindex=4&amp;levelid=1686843345946&amp;levelid=1686843308009&amp;step=3#abreadcrumb</a>
</p>

<hr>
<h2 id='llin_decomp'>Decomposition of Time Series Using Local Linear Regression</h2><span id='topic+llin_decomp'></span>

<h3>Description</h3>

<p>Trend and seasonality are modelled in a two-step approach, where first the 
trend is being estimated using local linear regression and then the 
seasonality is being estimated using various local linear regressions as 
well. In both cases a manually selected bandwidth is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llin_decomp(
  yt,
  bwidth_trend = 4,
  bwidth_season = 5,
  kernel_par = 1,
  boundary_method = c("extend", "shorten"),
  season = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llin_decomp_+3A_yt">yt</code></td>
<td>
<p>a time series object of class <code>"ts"</code> or an object that can be 
transformed to that class using <code><a href="stats.html#topic+as.ts">as.ts</a></code>.</p>
</td></tr>
<tr><td><code id="llin_decomp_+3A_bwidth_trend">bwidth_trend</code></td>
<td>
<p>half of the absolute bandwidth (in years); represents the 
amount of data to use around the estimation time point to consider 
for trend smoothing.</p>
</td></tr>
<tr><td><code id="llin_decomp_+3A_bwidth_season">bwidth_season</code></td>
<td>
<p>half of the absolute bandwidth (in years); represents the
amount of data (only from the same quarter, month, etc.) to use around the 
estimation time point for the seasonality estimation.</p>
</td></tr>
<tr><td><code id="llin_decomp_+3A_kernel_par">kernel_par</code></td>
<td>
<p>the smoothness parameter for the second-order kernel function 
used in the weighting process; for <code>kernel_par = 0</code> a uniform kernel 
is used, for <code>kernel_par = 1</code> an epanechnikov kernel, and so on.</p>
</td></tr>
<tr><td><code id="llin_decomp_+3A_boundary_method">boundary_method</code></td>
<td>
<p>a single character value; it indicates, what bandwidth 
method to use at boundary points; for <code>"extend"</code>, the default, the 
smoothing window around boundary points will be extended towards the center of 
the data; for <code>"shorten"</code>, the window width will keep decreasing at 
boundary points when approaching the very first and the very last observation.</p>
</td></tr>
<tr><td><code id="llin_decomp_+3A_season">season</code></td>
<td>
<p>the seasonal period in <code>yt</code>; by default, the seasonal 
period is obtained automatically from <code>yt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apply local linear regression to estimate trend and seasonality 
in a given time series <code class="reqn">y_t</code>. Assume that <code class="reqn">y_t</code> follows an additive 
component model with trend and seasonality components. First, a local linear 
regression with a first (absolute) bandwidth is conducted to estimate the trend 
from the series. If the seasonal period is <code class="reqn">s</code>, then afterwards <code class="reqn">s</code> 
local linear regressions (for each individual seasonal subseries of the 
detrended series) are conducted with a second (absolute) bandwidth to obtain 
seasonality estimates.
</p>


<h3>Value</h3>

<p>An S4 object with the following elements is returned.
</p>

<dl>
<dt>decomp</dt><dd><p>an object of class <code>"mts"</code> that consists of the
decomposed time series data.</p>
</dd>
<dt>ts_name</dt><dd><p>the object name of the initially provided time series object.</p>
</dd>
<dt>frequency</dt><dd><p>the frequency of the time series.</p>
</dd>
<dt>bwidth_trend</dt><dd><p>the same as the input argument <code>bwidth_trend</code>.</p>
</dd>
<dt>bwidth_season</dt><dd><p>the same as the input argument <code>bwidth_season</code>.</p>
</dd>
<dt>boundary_method</dt><dd><p>the same as the input argument <code>boundary_method</code>.</p>
</dd>
<dt>kernel_par</dt><dd><p>the same as the input argument <code>kernel_par</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>est &lt;- llin_decomp(log(EXPENDITURES), bwidth_trend = 4, bwidth_season = 28)
est

</code></pre>

<hr>
<h2 id='lm_decomp'>Decomposition of Time Series Using Linear Regression</h2><span id='topic+lm_decomp'></span>

<h3>Description</h3>

<p>Trend and seasonality are simultaneously modelled by considering a polynomial
for the trend and a polynomial in the seasonality (via dummy variables and 
their interactions with time) for the different time units (e.g. months).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_decomp(yt, order_poly = 1, order_poly_s = 1, season = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm_decomp_+3A_yt">yt</code></td>
<td>
<p>a time series object of class <code>"ts"</code> or an object that can be 
transformed to that class using <code><a href="stats.html#topic+as.ts">as.ts</a></code>.</p>
</td></tr>
<tr><td><code id="lm_decomp_+3A_order_poly">order_poly</code></td>
<td>
<p>the order of the polynomial considered for the trend; the
default is <code>order_poly = 1</code>.</p>
</td></tr>
<tr><td><code id="lm_decomp_+3A_order_poly_s">order_poly_s</code></td>
<td>
<p>the order of the polynomial considered for the 
seasonality; the default is <code>order_poly_s = 1</code>.</p>
</td></tr>
<tr><td><code id="lm_decomp_+3A_season">season</code></td>
<td>
<p>the seasonal period in <code>yt</code>; by default, the seasonal 
period is obtained automatically from <code>yt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apply ordinary least squares to estimate trend and seasonality simultaneously
in a given time series. This a global approach in contrast to for example 
<code><a href="#topic+deseats">deseats</a></code>, which is a local estimation method.
</p>


<h3>Value</h3>

<p>An S4 object with the following elements is returned.
</p>

<dl>
<dt>decomp</dt><dd><p>an object of class <code>"mts"</code> that consists of the
decomposed time series data.</p>
</dd>
<dt>ts_name</dt><dd><p>the object name of the initially provided time series object.</p>
</dd>
<dt>frequency</dt><dd><p>the frequency of the time series.</p>
</dd>
<dt>regression_output</dt><dd><p>an object of class <code>"lm"</code>, i.e. basic regression
output; the time variable <code>t</code> used in the regression is encoded as 
<code>seq_along(yt)</code>; the dummy variable <code>S2</code> encodes 
the first observation time point (and the yearly corresponding time points) as 
<code>-1</code> and the second observation time point (and the yearly corresponding 
time points) as <code>1</code>, the dummy variable <code>S3</code> does the same but has 
instead for the third observation time point (and the yearly corresponding 
time points) a <code>1</code>, and so on.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>est &lt;- lm_decomp(log(EXPENDITURES), order_poly = 3, order_poly_s = 2)
est

</code></pre>

<hr>
<h2 id='ma_decomp'>Decomposition of Time Series Using Moving Averages</h2><span id='topic+ma_decomp'></span>

<h3>Description</h3>

<p>Trend and seasonality are modelled in a two-step approach, where first the 
trend is being estimated using moving averages and then trend + seasonality 
are being estimated using moving averages. The difference is then the 
estimated seasonality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma_decomp(yt, k_trend = 4, k_season = 5, season = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ma_decomp_+3A_yt">yt</code></td>
<td>
<p>a time series object of class <code>"ts"</code> or an object that can be 
transformed to that class using <code><a href="stats.html#topic+as.ts">as.ts</a></code>.</p>
</td></tr>
<tr><td><code id="ma_decomp_+3A_k_trend">k_trend</code></td>
<td>
<p>the complete absolute bandwidth (in years); represents the data 
of how many years to use around the estimation time point to consider 
for trend smoothing.</p>
</td></tr>
<tr><td><code id="ma_decomp_+3A_k_season">k_season</code></td>
<td>
<p>the complete absolute bandwidth (in years); represents the data 
of how many years (only from the same quarter, month, etc.) to use around the 
estimation time point for trend + seasonality 
smoothing.</p>
</td></tr>
<tr><td><code id="ma_decomp_+3A_season">season</code></td>
<td>
<p>the seasonal period in <code>yt</code>; by default, the seasonal 
period is obtained automatically from <code>yt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apply moving averages to estimate trend and seasonality 
in a given time series. This approach results in missings <code>NA</code> at 
boundary points.
</p>


<h3>Value</h3>

<p>An S4 object with the following elements is returned.
</p>

<dl>
<dt>decomp</dt><dd><p>an object of class <code>"mts"</code> that consists of the
decomposed time series data.</p>
</dd>
<dt>ts_name</dt><dd><p>the object name of the initially provided time series object.</p>
</dd>
<dt>frequency</dt><dd><p>the frequency of the time series.</p>
</dd>
<dt>k_trend</dt><dd><p>the same as the input argument <code>k_trend</code>.</p>
</dd>
<dt>k_season</dt><dd><p>the same as the input argument <code>k_season</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>est &lt;- ma_decomp(log(EXPENDITURES), k_trend = 6, k_season = 7)
est

</code></pre>

<hr>
<h2 id='measures'>Forecasting Accuracy Measure Calculation</h2><span id='topic+measures'></span>

<h3>Description</h3>

<p>Given point forecasts and observations, calculate various forecasting 
accuracy measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measures(preds, obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="measures_+3A_preds">preds</code></td>
<td>
<p>the point predictions for the test data period.</p>
</td></tr>
<tr><td><code id="measures_+3A_obs">obs</code></td>
<td>
<p>the observation series (training data and test data)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given one-step-ahead rolling forecasts as well as the whole series of given 
observations (training together with test data), different forecasting 
accuracy measures (MAE, RMSE, Pearson's correlation, MASE, RMSSE) are being 
calculated.
</p>


<h3>Value</h3>

<p>A named vector with the obtained criteria values is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xt &lt;- EXPENDITURES
xt_in &lt;- window(xt, end = c(2017, 4))
yt &lt;- log(xt_in)
est &lt;- s_semiarma(yt, set_options(order_poly = 3), inflation_rate = "optimal")
fc_results &lt;- predict(est, n.ahead = 8, expo = TRUE)
point_fc &lt;- fc_results@pred
measures(point_fc, xt)


</code></pre>

<hr>
<h2 id='NOLABORFORCE'>Monthly Number of US Persons Not in the Labor Force</h2><span id='topic+NOLABORFORCE'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly observed number of persons in
the USA that do not belong to the labor force (in millions of persons)
from January 1990 to December 2019. 
The object contains 360 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOLABORFORCE
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 360.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the Federal Reserve Bank of 
St. Louis (accessed: 2023-06-15) and then transformed into a time series
object using R.
</p>
<p><a href="https://fred.stlouisfed.org/series/LNU05000000">https://fred.stlouisfed.org/series/LNU05000000</a>
</p>

<hr>
<h2 id='order_poly'>Smoothing Option Generics</h2><span id='topic+order_poly'></span><span id='topic+order_poly+3C-'></span><span id='topic+season'></span><span id='topic+season+3C-'></span><span id='topic+kernel_fun'></span><span id='topic+kernel_fun+3C-'></span><span id='topic+bwidth'></span><span id='topic+bwidth+3C-'></span><span id='topic+boundary_method'></span><span id='topic+boundary_method+3C-'></span>

<h3>Description</h3>

<p>Various generics that can be used write methods to either retrieve or set 
smoothing options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_poly(object)

order_poly(object) &lt;- value

season(object, ...)

season(object) &lt;- value

kernel_fun(object)

kernel_fun(object) &lt;- value

bwidth(object)

bwidth(object) &lt;- value

boundary_method(object)

boundary_method(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_poly_+3A_object">object</code></td>
<td>
<p>an object from which to either retrieve options or in which to set 
an option.</p>
</td></tr>
<tr><td><code id="order_poly_+3A_value">value</code></td>
<td>
<p>the value to set the corresponding option to.</p>
</td></tr>
<tr><td><code id="order_poly_+3A_...">...</code></td>
<td>
<p>without use; implemented for possible future compatibility only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>order_poly</code>, <code>season</code>, <code>kernel_fun</code>, <code>bwidth</code>, and
<code>boundary_method</code> can be used to retrieve the order of polynomial,
the seasonal frequency, the kernel function setting, the bandwidth and
the boundary method from an object with smoothing options. The corresponding
generics beginning with <code>&lt;-</code> are useful to set such options instead.
</p>
<p>The generics themselves are without a direct purpose.
</p>
<p>Generics that can be extended by methods to set or obtain settings (e.g.
smoothing options) in certain objects.
</p>


<h3>Value</h3>

<p>These generics do not return anything and are just the basis for more 
sophisticated methods.
</p>

<hr>
<h2 id='order_poly+2Csmoothing_options-method'>Retrieve or Set Smoothing Options</h2><span id='topic+order_poly+2Csmoothing_options-method'></span><span id='topic+order_poly+3C-+2Csmoothing_options-method'></span><span id='topic+season+2Csmoothing_options-method'></span><span id='topic+season+3C-+2Csmoothing_options-method'></span><span id='topic+kernel_fun+2Csmoothing_options-method'></span><span id='topic+kernel_fun+3C-+2Csmoothing_options-method'></span><span id='topic+bwidth+2Csmoothing_options-method'></span><span id='topic+bwidth+3C-+2Csmoothing_options-method'></span><span id='topic+boundary_method+2Csmoothing_options-method'></span><span id='topic+boundary_method+3C-+2Csmoothing_options-method'></span>

<h3>Description</h3>

<p>Retrieve smoothing options from or set them in an object 
of class <code>"smoothing_options"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'smoothing_options'
order_poly(object)

## S4 replacement method for signature 'smoothing_options'
order_poly(object) &lt;- value

## S4 method for signature 'smoothing_options'
season(object)

## S4 replacement method for signature 'smoothing_options'
season(object) &lt;- value

## S4 method for signature 'smoothing_options'
kernel_fun(object)

## S4 replacement method for signature 'smoothing_options'
kernel_fun(object) &lt;- value

## S4 method for signature 'smoothing_options'
bwidth(object)

## S4 replacement method for signature 'smoothing_options'
bwidth(object) &lt;- value

## S4 method for signature 'smoothing_options'
boundary_method(object)

## S4 replacement method for signature 'smoothing_options'
boundary_method(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_poly+2B2Csmoothing_options-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"smoothing_options"</code>.</p>
</td></tr>
<tr><td><code id="order_poly+2B2Csmoothing_options-method_+3A_value">value</code></td>
<td>
<p>the value to set the corresponding option to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Various methods are provided to either retrieve smoothing option
settings from an object of class <code>"smoothing_options"</code> or 
to adjust them within such an object.
</p>


<h3>Value</h3>

<p>The methods without <code>&lt;-</code> return the corresponding settings in the supplied 
object. The methods with <code>&lt;-</code> set the corresponding option in the 
provided object.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>opts &lt;- set_options()
opts
order_poly(opts)
order_poly(opts) &lt;- 3
opts

</code></pre>

<hr>
<h2 id='plot+2Cdecomp-method'>Plot Method for Decomposition Results in the Style of Base R Plots</h2><span id='topic+plot+2Cdecomp-method'></span>

<h3>Description</h3>

<p>This is method for producing various plots of the decomposition results
returned by this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'decomp'
plot(x, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Cdecomp-method_+3A_x">x</code></td>
<td>
<p>an object returned by the function <code><a href="#topic+deseats">deseats</a></code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cdecomp-method_+3A_which">which</code></td>
<td>
<p>various plots can be selected either via a keyword or a number; 
enter <code>"facets"</code> or <code>1</code> to show a facet plot of the estimated
time series components; enter <code>"observations"</code> or <code>2</code> to show the
input time series; enter <code>"fitted"</code> or <code>3</code> to show the observations 
alongside the estimated trend with seasonality; enter <code>"detailed_fit"</code> or
<code>4</code> to show the observations together with the fitted values and the trend;
enter <code>"trend_season"</code> or <code>5</code> to show the observations together with 
the trend and with the seasonality (the latter shown around the series mean);
enter <code>"residuals"</code> or 
<code>6</code> to plot the both detrended and seasonally adjusted series; use 
<code>7</code> or <code>"deseasonalized"</code> to show the seasonally adjusted 
series; enter <code>8</code> or <code>"detrended"</code> to plot the detrended 
series; the 
default is <code>which = NULL</code> which then lets you select a plot 
interactively in the R console.</p>
</td></tr>
<tr><td><code id="plot+2B2Cdecomp-method_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code><a href="stats.html#topic+plot.ts">plot.ts</a></code> or 
<code><a href="graphics.html#topic+matplot">matplot</a></code> (depending on whether only one time series
or multiple time series are shown in the plot).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create predefined standard plots of the decomposition objects returned by the 
<code>deseats</code> package, e.g. returned by the function <code><a href="#topic+deseats">deseats</a></code>. 
Plots are created in the base R plot style. The type of plot can be chosen 
either interactively from the console, or the argument <code>which</code> can be 
used to directly  select the kind of plot to create (see also the description
of the argument <code>which</code>) within the function call.
</p>
<p>If plot type 5 (<code>which = 5</code>) is selected, the estimated 
seasonality will be displayed around the mean of the observations by default.
Setting the additional argument <code>s_around</code> to some other value, will lead 
to the seasonality being displayed around that constant value.
</p>


<h3>Value</h3>

<p>A graphic is created in the plots windows, the function itself, however,
returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Xt &lt;- log(EXPENDITURES)
est &lt;- deseats(Xt)
plot(est, which = 3)

</code></pre>

<hr>
<h2 id='plot+2Cdeseats_fc-method'>Plot Method for Class <code>"deseats_fc"</code></h2><span id='topic+plot+2Cdeseats_fc-method'></span>

<h3>Description</h3>

<p>Create basic R plots for forecasting objects of class <code>"deseats_fc"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'deseats_fc'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Cdeseats_fc-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>"deseats_fc"</code>, for example generated by a 
call to <code><a href="#topic+predict+2Cs_semiarma-method">predict,s_semiarma-method</a></code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cdeseats_fc-method_+3A_y">y</code></td>
<td>
<p>currently without use; for compatibility only.</p>
</td></tr>
<tr><td><code id="plot+2B2Cdeseats_fc-method_+3A_...">...</code></td>
<td>
<p>further arguments of <code><a href="stats.html#topic+plot.ts">plot.ts</a></code> to adjust 
for example the axis limits via <code>xlim</code> and <code>ylim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a plot method to visualize the forecasting results for a Seasonal 
Semi-ARMA model. Common plot arguments can be implemented to change the 
appearance.
</p>


<h3>Value</h3>

<p>This method returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
est &lt;- s_semiarma(log(EXPENDITURES))
fc &lt;- predict(est, n.ahead = 4)
fc_e &lt;- expo(fc)
plot(fc_e)


</code></pre>

<hr>
<h2 id='plot+2Chfilter-method'>Plot Method for the Results of a Hamilton Filter</h2><span id='topic+plot+2Chfilter-method'></span>

<h3>Description</h3>

<p>Visualize the results of an applied Hamilton filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hfilter'
plot(x, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Chfilter-method_+3A_x">x</code></td>
<td>
<p>an object of class <code>"hfilter"</code>, as returned by the function 
<code><a href="#topic+hamilton_filter">hamilton_filter</a></code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Chfilter-method_+3A_which">which</code></td>
<td>
<p>either a string or a number can be entered to select a 
plot type from the function call; options are (1) a facet plot of the 
components, (2) the observed time series, (3) the observations together 
with the fitted values, and (4) the residuals; for <code>which = NULL</code>, 
the plot type can be selected interactively in the console.</p>
</td></tr>
<tr><td><code id="plot+2B2Chfilter-method_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code><a href="stats.html#topic+plot.ts">plot.ts</a></code> or 
<code><a href="graphics.html#topic+matplot">matplot</a></code> (depending on whether only one time series
or multiple time series are shown in the plot).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>est &lt;- hamilton_filter(log(EXPENDITURES))
plot(est, which = 3, col = c(1, 6))
plot(est, which = 4)

</code></pre>

<hr>
<h2 id='predict+2Cs_semiarma-method'>Point and Interval Forecasts for Seasonal Semi-ARMA Models</h2><span id='topic+predict+2Cs_semiarma-method'></span>

<h3>Description</h3>

<p>Obtain point and interval forecasts based on fitted Seasonal Semi-ARMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 's_semiarma'
predict(
  object,
  n.ahead = 1,
  intervals = TRUE,
  alpha = c(0.95, 0.99),
  method = c("norm", "boot"),
  bootMethod = c("simple", "advanced"),
  npaths = 5000,
  quant.type = 8,
  expo = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"s_semiarma"</code>.</p>
</td></tr>
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_n.ahead">n.ahead</code></td>
<td>
<p>a numeric vector of length one that represents the forecasting horizon; assume that <code>object</code> is based on 
observations at time points <code class="reqn">t=1,2,\dots,n</code>; forecasts are then obtained for time 
points <code class="reqn">t=n+1,n+2,\dots,n+\code{n.ahead}</code>; the default is <code>n.ahead = 1</code>.</p>
</td></tr>
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_intervals">intervals</code></td>
<td>
<p>a logical vector of length one that indicates whether or not 
forecasting intervals should be obtained; the default is <code>intervals = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector of variable length that indicates the confidence levels
at which to obtain forecasting intervals; the default is <code>alpha = c(0.95, 0.99)</code>,
i.e. confidence levels of 95 and 99 percent.</p>
</td></tr>
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_method">method</code></td>
<td>
<p>a character vector that indicates the method used to obtain forecasting
intervals; available are theoretical intervals based on the assumption of normal 
innovations (<code>"norm"</code>) and intervals through a bootstrap (<code>"boot"</code>); 
the default is <code>method = "norm"</code>.</p>
</td></tr>
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_bootmethod">bootMethod</code></td>
<td>
<p>a character vector that allows the user to select a bootstrap 
procedure for the forecasting intervals when <code>method = "boot"</code> is selected;
the default <code>bootMethod = "simple"</code> simulates future observations by resampling
the obtained residuals; the second approach <code>bootMethod = "advanced"</code> also 
considers the variation in the ARMA coefficient estimates by simulating and 
reestimating complete ARMA paths upon which forecasts are obtained 
(see also the B-ARMARoots algorithm in Lu and Wang, 2020); the second approach
is often time-consuming.</p>
</td></tr>
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_npaths">npaths</code></td>
<td>
<p>the number of paths to simulate, if the forecasting intervals 
are obtained via a bootstrap.</p>
</td></tr>
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_quant.type">quant.type</code></td>
<td>
<p>the method to obtain sample quantiles from the simulated
forecasting errors; see also the argument <code>type</code> of the function 
<code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_expo">expo</code></td>
<td>
<p>a logical vector of length one; indicates whether the forecasting 
results should be exponentiated at the end; the default is <code>expo = FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict+2B2Cs_semiarma-method_+3A_...">...</code></td>
<td>
<p>only for comparability with the standard <code>predict</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume a Seasonal Semi-ARMA model was fitted using <code><a href="#topic+s_semiarma">s_semiarma</a></code>.
Pass the resulting object to this method, in order to obtain point and 
interval forecasts.
</p>


<h3>Value</h3>

<p>A list with the following elements is returned.
</p>

<dl>
<dt><code>pred</code></dt><dd><p>the obtained point forecasts.</p>
</dd>
<dt><code>interv</code></dt><dd><p>the obtained forecasting intervals.</p>
</dd>
<dt><code>obs</code></dt><dd><p>the observation series.</p>
</dd>
<dt><code>ts_name</code></dt><dd><p>the name of the observation series object.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
xt &lt;- log(EXPENDITURES)
est &lt;- s_semiarma(xt)
predict(est, n.ahead = 10)


</code></pre>

<hr>
<h2 id='RAINFALL'>Monthly Average Rainfall in Germany</h2><span id='topic+RAINFALL'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly observed average rainfall
in Germany (in mm) from January 1881 to August 2023.
The object contains 1712 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RAINFALL
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 1712.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the 
German Weather Service (DWD) (accessed: 2023-09-25) and 
then transformed into a time series
object using R. 
</p>
<p><a href="https://www.dwd.de/DE/leistungen/zeitreihen/zeitreihen.html#buehneTop">https://www.dwd.de/DE/leistungen/zeitreihen/zeitreihen.html#buehneTop</a>
</p>

<hr>
<h2 id='read_ts'>Read in a Dataset Directly as an Object of Class <code>"ts"</code> or <code>"mts"</code></h2><span id='topic+read_ts'></span>

<h3>Description</h3>

<p>Allows the user to read in a data file directly as a <code>"ts"</code> or 
<code>"mts"</code> object, where a time point column in the data file is 
immediately used to set starting points and frequency of the time 
series automatically correctly. Works for equidistant observation time 
points, e.g. quarterly or monthly observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ts(
  file,
  time_column = 1,
  sep = ",",
  dec = ".",
  header = TRUE,
  time_format = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_ts_+3A_file">file</code></td>
<td>
<p>a data file name given as a string (including the file ending);
the file should have at least two columns: one time column and at least one or 
multiple columns for time series observations; alternatively, a data frame 
can be passed to this argument.</p>
</td></tr>
<tr><td><code id="read_ts_+3A_time_column">time_column</code></td>
<td>
<p>a number that indicates which column in the dataset is 
the variable with the time points; by default, the first column is assumed to 
contain the information on time points.</p>
</td></tr>
<tr><td><code id="read_ts_+3A_sep">sep</code></td>
<td>
<p>the separation symbol between the dataset columns.</p>
</td></tr>
<tr><td><code id="read_ts_+3A_dec">dec</code></td>
<td>
<p>the decimal symbol in the dataset.</p>
</td></tr>
<tr><td><code id="read_ts_+3A_header">header</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>; does the dataset have a row 
with headers at the beginning?</p>
</td></tr>
<tr><td><code id="read_ts_+3A_time_format">time_format</code></td>
<td>
<p>with the default <code>NULL</code>, standard date formats will 
be tried to transform the time points column into a date object; if the 
formatting of the time column is unusual, the formatting can be specified 
here as a string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data file is internally read into R as a <code>"zoo"</code> object and then 
transformed into a <code>"ts"</code> object using <code><a href="#topic+zoo_to_ts">zoo_to_ts</a></code>. This 
happens without the user noticing. The result is an immediate transformation 
of the input data into an object of class <code>"ts"</code> or <code>"mts"</code> for 
the user.
</p>


<h3>Value</h3>

<p>An object of class <code>"ts"</code> or <code>"mts"</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Create an example data file
a &lt;- 1:12
b &lt;- 21:32
tp &lt;- seq(from = as.Date("2020-01-01"), to = as.Date("2020-12-01"), by = "month")
df &lt;- data.frame(
 Time = tp,
 a = a,
 b = b
)

file &lt;- file.path(tempdir(), "ExampleFile.csv")

write.table(df, file = file, quote = FALSE, sep = ",",
 row.names = FALSE, col.names = TRUE)
 
### Use the function to read in the data
xt &lt;- read_ts(file)
xt


</code></pre>

<hr>
<h2 id='RETAIL'>Monthly Total Volume of Retail Trade in Germany</h2><span id='topic+RETAIL'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly total volume of retail trade 
in Germany (Index 2015 = 100)
from January 1991 
to December 2019. The object contains 348 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RETAIL
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> with 348 rows and 1 columns.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the Federal Reserve Bank 
of St. Louis
(accessed: 2023-10-11) and 
then transformed into a time series
object using R. 
</p>
<p><a href="https://fred.stlouisfed.org/series/DEUSLRTTO01IXOBM">https://fred.stlouisfed.org/series/DEUSLRTTO01IXOBM</a>
</p>

<hr>
<h2 id='runDecomposition'>Shiny App for Decomposing Seasonal Time Series</h2><span id='topic+runDecomposition'></span>

<h3>Description</h3>

<p>A shiny app is started that allows its user to run some of the decomposition
approaches of this package interactively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runDecomposition()
</code></pre>


<h3>Details</h3>

<p>Time series data can be uploaded to the app and then decomposed using 
some of the approaches implemented in this package. The decomposition 
is immediately visualized within the app, so that the user can assess the
suitability of the decomposition graphically. The decomposed data can then be 
saved in CSV format.
</p>


<h3>Value</h3>

<p>This function returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>


<hr>
<h2 id='s_semiarma'>Fitting of a Seasonal Semiparametric ARMA Model</h2><span id='topic+s_semiarma'></span>

<h3>Description</h3>

<p>Fit a seasonal semiparametric autoregressive moving-average 
(S-Semi-ARMA) model to a univariate time series. The estimation is 
in two steps: firstly, the series is detrended and seasonally adjusted using the
function <code><a href="#topic+deseats">deseats</a></code>. Then an ARMA model is fitted to the 
residuals using <code><a href="stats.html#topic+arima">arima</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_semiarma(
  yt,
  smoothing_options = set_options(),
  arma_options = list(ar_order = NULL, ma_order = NULL),
  bwidth_start = 0.2,
  inflation_rate = c("optimal", "naive"),
  correction_factor = FALSE,
  drop = NULL,
  error_model = c("free", "ARMA"),
  nar_lim = c(0, 3),
  nma_lim = c(0, 3),
  arma_mean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s_semiarma_+3A_yt">yt</code></td>
<td>
<p>a numerical vector or a time series object of class <code>ts</code> or 
that can be transformed with <code><a href="stats.html#topic+as.ts">as.ts</a></code> to an object of class 
<code>ts</code>; for these observations, trend and seasonality will be obtained.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_smoothing_options">smoothing_options</code></td>
<td>
<p>an S4 object of class <code>smoothing_options</code>, which 
is returned by the function <code><a href="#topic+set_options">set_options</a></code>; it 
includes details about the
options to consider in the locally weighted regression, such as the order of
polynomial and the bandwidth for smoothing among others, for the nonparametric
part of the model; the nonparametric model is fitted using 
<code><a href="#topic+deseats">deseats</a></code>.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_arma_options">arma_options</code></td>
<td>
<p>a list with the two elements <code>ar_order</code> and 
<code>ma_order</code> that indicates the AR and MA orders to consider for the 
parametric part of the model.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_bwidth_start">bwidth_start</code></td>
<td>
<p>a single numeric value that is only relevant if the slot
<code>bwidth</code> in <code>smoothing_options</code> is set to <code>NA</code>; 
as the bandwidth will then
be selected automatically, <code>bwidth_start</code> sets the initial bandwidth for 
the algorithm.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_inflation_rate">inflation_rate</code></td>
<td>
<p>a character vector of length one that indicates, which inflation rate 
to use in the bandwidth selection; for a local linear trend, we have 
<code>inflation_rate = "optimal"</code> as the default, for a local cubic trend
it is <code>inflation_rate = "naive"</code>, which correspond to inflation rates
of 5/7 and 9/13, respectively.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_correction_factor">correction_factor</code></td>
<td>
<p>A logical vector of length one; theoretically, a 
larger bandwidth to estimate the sum of autocovariances from residuals of 
pilot trend and seasonality estimates is advisable than for estimating trend
and seasonality; for <code>correction_factor = TRUE</code>, this is implemented;
for <code>error_model = "ARMA"</code>, <code>correction_factor = FALSE</code> is 
enforced; the default is <code>correction_factor = FALSE</code>, because it was
found that setting this argument to <code>TRUE</code> often overestimates the 
bandwidth.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_drop">drop</code></td>
<td>
<p>a numeric vector of length one that indicates the proportion of 
the observations to not include at each boundary in the bandwidth estimation 
process, if a bandwidth is selected automatically; the default is 
<code>drop = 0.1</code>.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_error_model">error_model</code></td>
<td>
<p>a character vector of length one that indicates whether
for <code>autocor = TRUE</code> the sum of autocovariances of the errors is 
obtained purely nonparametrically (<code>"free"</code>) or whether an
autoregressive moving-average (ARMA) model is assumed <code>"ARMA"</code>; the
default is <code>error_model = "free"</code>.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_nar_lim">nar_lim</code></td>
<td>
<p>only valid for <code>error_model = "ARMA"</code>; set the minimum and 
maximum AR order to check via the BIC in each iteration of the algorithm via 
a two-element vector.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_nma_lim">nma_lim</code></td>
<td>
<p>only valid for <code>error_model = "ARMA"</code>; set the minimum and
maximum MA order to check via the BIC in each iteration of the algorithm via
a two-element vector.</p>
</td></tr>
<tr><td><code id="s_semiarma_+3A_arma_mean">arma_mean</code></td>
<td>
<p>only valid for <code>error_model = "ARMA"</code>; decide whether to 
include an estimate of the mean in the ARMA fitting for the detrended series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For information on the nonparametric regression step, see 
<code><a href="#topic+deseats">deseats</a></code>. After the trend and the seasonality have 
been removed from the data, an autoregressive moving-average (ARMA) model
is fitted to the residuals either with orders selected by the Bayesian
information criterion (BIC) or with manually selected orders. The ARMA
model is fitted using <code><a href="stats.html#topic+arima">arima</a></code>.
</p>
<p>All function arguments except for <code>arma_options</code> are identical to 
those in <code><a href="#topic+deseats">deseats</a></code>. If all elements in 
<code>arma_options</code> are set to <code>NULL</code>, the ARMA model orders are 
selected for <code class="reqn">p, q</code> from <code>nar_lim[[1]]</code> and <code>nma_lim[[1]]</code> up
until <code>nar_lim[[2]]</code> and <code>nma_lim[[2]]</code> according to the BIC.
</p>


<h3>Value</h3>

<p>The function returns and S4 object with the following elements (access them 
via <code>@</code>):
</p>

<dl>
<dt><code>decomp</code></dt><dd><p>an object of class <code>"mts"</code> that includes the 
observed time series and its estimated components.</p>
</dd>
<dt><code>nonpar_model</code></dt><dd><p>an object of class <code>"deseats"</code>; this is 
the result of applying <code><a href="#topic+deseats">deseats</a></code>.</p>
</dd>
<dt><code>par_model</code></dt><dd><p>an object of class <code>"Arima"</code>; the result of 
applying <code><a href="stats.html#topic+arima">arima</a></code> to the residuals of the nonparametric 
estimation step.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li>
<li><p> Yuanhua Feng (Department of Economics, Paderborn
University), <br />
Author
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
Xt &lt;- log(EXPENDITURES)
est &lt;- s_semiarma(Xt)
est


</code></pre>

<hr>
<h2 id='SAVINGS'>Quarterly Savings of Private Households in Germany</h2><span id='topic+SAVINGS'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the quarterly observed savings of
private households in Germany
(in billions of EUR) from January 1991 to December 2019. The object 
contains 116 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SAVINGS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 116.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank &quot;Genesis&quot; of the National 
Statistical Office of Germany (accessed: 2023-06-15) and then transformed into 
a time series object using R.
</p>
<p><a href="https://www-genesis.destatis.de/genesis/online?operation=abruftabelleBearbeiten&amp;levelindex=1&amp;levelid=1686857137066&amp;auswahloperation=abruftabelleAuspraegungAuswaehlen&amp;auswahlverzeichnis=ordnungsstruktur&amp;auswahlziel=werteabruf&amp;code=81000-0010&amp;auswahltext=&amp;werteabruf=Werteabruf#abreadcrumb">https://www-genesis.destatis.de/genesis/online?operation=abruftabelleBearbeiten&amp;levelindex=1&amp;levelid=1686857137066&amp;auswahloperation=abruftabelleAuspraegungAuswaehlen&amp;auswahlverzeichnis=ordnungsstruktur&amp;auswahlziel=werteabruf&amp;code=81000-0010&amp;auswahltext=&amp;werteabruf=Werteabruf#abreadcrumb</a>
</p>

<hr>
<h2 id='seasonplot'>Creation of Seasonal Plots</h2><span id='topic+seasonplot'></span>

<h3>Description</h3>

<p>Simplified seasonal plot creation of time series in order to identify 
seasonal patterns more easily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonplot(
  x,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  labels = TRUE,
  colorpalette = NULL,
  rm_xticks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seasonplot_+3A_x">x</code></td>
<td>
<p>a time series object of class <code>"ts"</code>.</p>
</td></tr>
<tr><td><code id="seasonplot_+3A_xlab">xlab</code></td>
<td>
<p>a label for the plot's x-axis.</p>
</td></tr>
<tr><td><code id="seasonplot_+3A_ylab">ylab</code></td>
<td>
<p>a label for the plot's y-axis.</p>
</td></tr>
<tr><td><code id="seasonplot_+3A_main">main</code></td>
<td>
<p>a title for the plot.</p>
</td></tr>
<tr><td><code id="seasonplot_+3A_labels">labels</code></td>
<td>
<p>whether or not to show tick labels.</p>
</td></tr>
<tr><td><code id="seasonplot_+3A_colorpalette">colorpalette</code></td>
<td>
<p>a color palette (either a numeric or character vector) that 
gives an alternative color palette to use for the subseries.</p>
</td></tr>
<tr><td><code id="seasonplot_+3A_rm_xticks">rm_xticks</code></td>
<td>
<p>whether to remove x-axis ticks and tick labels; the default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a seasonal plot of the provided time series object. The
series is split into different subseries, each reflecting one season, and then 
these subseries are plotted together. This helps identifying possible seasonal
patterns in the data.
</p>


<h3>Value</h3>

<p>The function does not return anything, however a plot is created in the plot 
window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seasonplot(TEMPERATURE, xlab = "Degrees Celsius", 
 main = "Seasonal plot of German temperature data")

</code></pre>

<hr>
<h2 id='seasonplot_gg'>Creation of Seasonal Plots in the Style of ggplot2</h2><span id='topic+seasonplot_gg'></span>

<h3>Description</h3>

<p>Simplified seasonal plot creation of time series objects in order to
identify seasonal patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonplot_gg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seasonplot_gg_+3A_x">x</code></td>
<td>
<p>a time series object of class <code>"ts"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns an plot object in the style of <code>ggplot2</code>. The plot
can therefore be adjusted easily using common <code>ggplot2</code> syntax.
</p>


<h3>Value</h3>

<p>The function returns a <code>ggplot2</code> plot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seasonplot_gg(TEMPERATURE) +
 ggplot2::ylab("Degrees Celsius") +
 ggplot2::ggtitle("Seasonal plot of German temperature data")

</code></pre>

<hr>
<h2 id='select_bwidth'>Optimal Bandwidth Estimation for Locally Weighted Regression in Equidistant 
Time Series under Short Memory</h2><span id='topic+select_bwidth'></span>

<h3>Description</h3>

<p>Optimal Bandwidth Estimation for Locally Weighted Regression in Equidistant 
Time Series under Short Memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_bwidth(
  y,
  smoothing_options = set_options(),
  bwidth_start = NULL,
  inflation_rate = c("optimal", "naive"),
  correction_factor = FALSE,
  autocor = TRUE,
  drop = NULL,
  error_model = c("free", "ARMA"),
  nar_lim = c(0, 3),
  nma_lim = c(0, 3),
  arma_mean = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_bwidth_+3A_y">y</code></td>
<td>
<p>a numerical vector or a time series object of class <code>ts</code> or 
that can be transformed with <code><a href="stats.html#topic+as.ts">as.ts</a></code> to an object of class 
<code>ts</code>; for these observations, trend and seasonality will be obtained.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_smoothing_options">smoothing_options</code></td>
<td>
<p>an S4 object of class <code>smoothing_options</code>, which 
is returned by the function <code><a href="#topic+set_options">set_options</a></code>; it 
includes details about the
options to consider in the locally weighted regression such as the order of
polynomial and the bandwidth for smoothing among others.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_bwidth_start">bwidth_start</code></td>
<td>
<p>a single numeric value that is only relevant if the slot
<code>bwidth</code> in <code>smoothing_options</code> is set to <code>NA</code>; 
as the bandwidth will then
be selected automatically, <code>bwidth_start</code> sets the initial bandwidth for 
the algorithm; the default, <code>bwidth_start = NULL</code>, corresponds to 
<code>bwidth_start = 0.1</code> for a local linear trend and to 
<code>bwidth_start = 0.2</code> for a local cubic trend.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_inflation_rate">inflation_rate</code></td>
<td>
<p>a character vector of length one that indicates, which inflation rate 
to use in the bandwidth selection; for a local linear trend, we have 
<code>inflation_rate = "optimal"</code> as the default, for a local cubic trend
it is <code>inflation_rate = "naive"</code>, which correspond to inflation rates
of 5/7 and 9/13, respectively.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_correction_factor">correction_factor</code></td>
<td>
<p>A logical vector of length one; theoretically, a 
larger bandwidth to estimate the sum of autocovariances from residuals of 
pilot trend and seasonality estimates is advisable than for estimating trend
and seasonality; for <code>correction_factor = TRUE</code>, this is implemented; 
the default is <code>correction_factor = FALSE</code>, because it was found 
that setting this argument to <code>TRUE</code> often overestimates the 
bandwidth.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_autocor">autocor</code></td>
<td>
<p>a logical vector of length one; indicates whether to consider
autocorrelated errors (<code>TRUE</code>) or independent but identically 
distributed errors (<code>FALSE</code>); the default is <code>autocor = TRUE</code>.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_drop">drop</code></td>
<td>
<p>a numeric vector of length one that indicates the proportion of 
the observations to not include at each boundary in the bandwidth estimation 
process, if a bandwidth is selected automatically; the default is 
<code>drop = NULL</code>, which corresponds to <code>drop = 0.05</code> for a 
local linear trend and to <code>drop = 0.1</code> for a local cubic trend.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_error_model">error_model</code></td>
<td>
<p>a character vector of length one that indicates whether
for <code>autocor = TRUE</code> the sum of autocovariances of the errors is 
obtained purely nonparametrically (<code>"free"</code>) or whether an
autoregressive moving-average (ARMA) model is assumed <code>"ARMA"</code>; the
default is <code>error_model = "free"</code>.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_nar_lim">nar_lim</code></td>
<td>
<p>only valid for <code>error_model = "ARMA"</code>; set the minimum and 
maximum AR order to check via the BIC in each iteration of the algorithm via 
a two-element vector.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_nma_lim">nma_lim</code></td>
<td>
<p>only valid for <code>error_model = "ARMA"</code>; set the minimum and
maximum MA order to check via the BIC in each iteration of the algorithm via
a two-element vector.</p>
</td></tr>
<tr><td><code id="select_bwidth_+3A_arma_mean">arma_mean</code></td>
<td>
<p>only valid for <code>error_model = "ARMA"</code>; decide whether to 
include an estimate of the mean in the ARMA fitting for the detrended series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further details in the documentation of the function 
<code><a href="#topic+deseats">deseats</a></code>, where this function is applied internally
by default to select an optimal bandwidth.
</p>


<h3>Value</h3>

<p>The function returns a list with different components:
</p>

<dl>
<dt><code>bopt</code></dt><dd><p>the obtained optimal bandwidth.</p>
</dd>
<dt><code>bwidths</code></dt><dd><p>the obtained bandwidth for each iteration of the 
IPI-algorithm.</p>
</dd>
<dt><code>Imk</code></dt><dd><p>the final estimate of <code class="reqn">I[m^{(k)}]</code>.</p>
</dd>
<dt><code>sum_autocov</code></dt><dd><p>the final estimate of the sum of autocovariances.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li>
<li><p> Yuanhua Feng (Department of Economics, Paderborn
University), <br />
Author
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Feng, Y. (2013). An iterative plug-in algorithm for decomposing seasonal 
time series using the Berlin Method. Journal of Applied Statistics, 40(2): 
266-281. DOI: 10.1080/02664763.2012.740626.
</p>
</li>
<li><p>Feng, Y., Gries. T, and Fritz, M. (2020). Data-driven local polynomial 
for the trend and its derivatives in economic time series. Journal of 
Nonparametric Statistics, 32(2): 510-533. DOI: 10.1080/10485252.2020.1759598.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Xt &lt;- log(EXPENDITURES)
select_bwidth(Xt)

</code></pre>

<hr>
<h2 id='set_options'>Specification of Smoothing Options</h2><span id='topic+set_options'></span>

<h3>Description</h3>

<p>Set the smoothing specifications for locally weighted regression for
identifying the trend and the seasonality in an equidistant time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_options(
  order_poly = 1,
  season = NA_real_,
  kernel_fun = "epanechnikov",
  bwidth = NA_real_,
  boundary_method = "extend"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_options_+3A_order_poly">order_poly</code></td>
<td>
<p>the order of the local polynomials used for estimating the
smooth nonparametric trend; the default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="set_options_+3A_season">season</code></td>
<td>
<p>the frequency of observations per time unit, for example per 
year; set to <code>12</code> for monthly data and to <code>4</code> for quarterly data
and so on; the default is <code>NA_real_</code>, which leads to an automated 
frequency selection for time series objects in smoothing functions; if 
the argument is set to <code>NA_real_</code> and the observations used for smoothing 
are not formatted as time series objects, the frequency <code>1</code> will be 
used.</p>
</td></tr>
<tr><td><code id="set_options_+3A_kernel_fun">kernel_fun</code></td>
<td>
<p>the weighting function to consider; supported are four
second-order kernel functions with compact support on <code class="reqn">[-1, 1]</code>; enter
<code>"uniform"</code> for the uniform kernel, <code>"epanechnikov"</code> for the 
Epanechnikov kernel, <code>"bisquare"</code> for the bisquare kernel or 
<code>"triweight"</code> for the triweight kernel; the default is 
<code>"epanechnikov"</code>.</p>
</td></tr>
<tr><td><code id="set_options_+3A_bwidth">bwidth</code></td>
<td>
<p>a numeric value that indicates the relative bandwidth to 
consider in the smoothing process; the default is <code>NA</code>, which then
triggers a data-driven selection of an globally optimal bandwidth when
the output of this function is passed to a smoothing function.</p>
</td></tr>
<tr><td><code id="set_options_+3A_boundary_method">boundary_method</code></td>
<td>
<p>a single character value; it indicates, what bandwidth 
method to use at boundary points; for <code>"extend"</code>, the default, the 
smoothing window around boundary points will be extended towards the center of 
the data; for <code>"shorten"</code>, the window width will keep decreasing at 
boundary points when approaching the very first and the very last observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"smoothing_options"</code> is created that contains 
all required information to conduct a locally weighted regression for 
decomposing a seasonal time series. The information include the order 
of the trend polynomials, the frequency of the observed series, the 
second-order kernel function to use in the weighting process, the 
(relative) bandwidth to employ, and the boundary method for the bandwidth.
</p>


<h3>Value</h3>

<p>The function returns an S4 object with the following elements (access via 
<code>@</code>):
</p>

<dl>
<dt>order_poly</dt><dd><p>identical to the input argument with that name; please see 
the description of that input argument.</p>
</dd>
<dt>season</dt><dd><p>identical to the input argument with that name; please see 
the description of that input argument.</p>
</dd>
<dt>kernel_fun</dt><dd><p>identical to the input argument with that name; please see 
the description of that input argument.</p>
</dd>
<dt>bwidth</dt><dd><p>identical to the input argument with that name; please see 
the description of that input argument.</p>
</dd>
<dt>boundary_method</dt><dd><p>identical to the input argument with that name; please 
see the description of that input argument.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>


<hr>
<h2 id='show+2Cdeseats-method'>Printing of <code>deseats</code> Function Results</h2><span id='topic+show+2Cdeseats-method'></span>

<h3>Description</h3>

<p>Print results of the function <code>deseats</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'deseats'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2Cdeseats-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"deseats"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After trend and seasonality in a time series have been estimated using the
function <code>deseats</code>, basic estimation results can be easily printed to 
the console.
</p>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>

<hr>
<h2 id='show+2Cs_semiarma-method'>Show Method for Objects of Class <code>"s_semiarma"</code></h2><span id='topic+show+2Cs_semiarma-method'></span>

<h3>Description</h3>

<p>Print results of the function <code><a href="#topic+s_semiarma">s_semiarma</a></code> to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 's_semiarma'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2Cs_semiarma-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"s_semiarma"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this method to create a nice looking overview of the contents of 
objects of class <code>"s_semiarma"</code>.
</p>


<h3>Value</h3>

<p>This method returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>


<hr>
<h2 id='show+2Csmoothing_options-method'>Show Method for Smoothing Options</h2><span id='topic+show+2Csmoothing_options-method'></span>

<h3>Description</h3>

<p>Show smoothing settings in an object of class <code>"smoothing_options"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'smoothing_options'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2Csmoothing_options-method_+3A_object">object</code></td>
<td>
<p>an object of class <code>"smoothing_options"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a special printing method for objects object of class 
<code>"smoothing_options"</code>. Calling this method shows a nice looking 
overview of the saved smoothing settings.
</p>


<h3>Value</h3>

<p>This method returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts &lt;- set_options()
opts

</code></pre>

<hr>
<h2 id='SUNSHINE'>Monthly Hours of Sunshine in Germany</h2><span id='topic+SUNSHINE'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly observed hours of sunshine
in Germany from January 1951 to August 2023.
The object contains 872 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SUNSHINE
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 872.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the 
German Weather Service (DWD) (accessed: 2023-09-25) and 
then transformed into a time series
object using R. 
</p>
<p><a href="https://www.dwd.de/DE/leistungen/zeitreihen/zeitreihen.html#buehneTop">https://www.dwd.de/DE/leistungen/zeitreihen/zeitreihen.html#buehneTop</a>
</p>

<hr>
<h2 id='TEMPERATURE'>Monthly Average Temperature in Germany</h2><span id='topic+TEMPERATURE'></span>

<h3>Description</h3>

<p>A <code>ts</code> object that contains the monthly observed average temperature
in Germany (in degrees Celsius) from January 1881 to August 2023.
The object contains 1712 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TEMPERATURE
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code> of length 1712.
</p>


<h3>Source</h3>

<p>The data was obtained from the databank of the 
German Weather Service (DWD) (accessed: 2023-09-25) and 
then transformed into a time series
object using R. 
</p>
<p><a href="https://www.dwd.de/DE/leistungen/zeitreihen/zeitreihen.html#buehneTop">https://www.dwd.de/DE/leistungen/zeitreihen/zeitreihen.html#buehneTop</a>
</p>

<hr>
<h2 id='trend'>Obtain Estimated Components of a Time Series</h2><span id='topic+trend'></span><span id='topic+deseasonalize'></span><span id='topic+detrend'></span>

<h3>Description</h3>

<p>Obtain estimated components, such as the estimated trend, the seasonally 
adjusted series, and so on from an estimation object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trend(object, ...)

deseasonalize(object, ...)

detrend(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trend_+3A_object">object</code></td>
<td>
<p>the estimation object.</p>
</td></tr>
<tr><td><code id="trend_+3A_...">...</code></td>
<td>
<p>currently without use; included for future compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generics that can be extended by methods to obtain (estimated) time series
components from certain estimation objects.
</p>


<h3>Value</h3>

<p>These generics do not return anything and are just the basis for more 
sophisticated methods.
</p>

<hr>
<h2 id='trend+2Cdecomp-method'>Obtain Individual Components of a Decomposed Time Series</h2><span id='topic+trend+2Cdecomp-method'></span><span id='topic+season+2Cdecomp-method'></span><span id='topic+fitted+2Cdecomp-method'></span><span id='topic+residuals+2Cdecomp-method'></span><span id='topic+deseasonalize+2Cdecomp-method'></span><span id='topic+detrend+2Cdecomp-method'></span>

<h3>Description</h3>

<p>The provided methods work for decomposition objects created 
within this package. They allow the user to retrieve individual
components among the estimated ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'decomp'
trend(object, ...)

## S4 method for signature 'decomp'
season(object, ...)

## S4 method for signature 'decomp'
fitted(object, ...)

## S4 method for signature 'decomp'
residuals(object, ...)

## S4 method for signature 'decomp'
deseasonalize(object, ...)

## S4 method for signature 'decomp'
detrend(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trend+2B2Cdecomp-method_+3A_object">object</code></td>
<td>
<p>the estimation / decomposition object, for example 
of class <code>"deseats"</code>.</p>
</td></tr>
<tr><td><code id="trend+2B2Cdecomp-method_+3A_...">...</code></td>
<td>
<p>without further use; implemented for compatibility only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apply these functions directly to an estimation object, i.e. 
the result of a decomposition of a seasonal time series, in order 
to retrieve individual estimated components.
</p>


<h3>Value</h3>

<p>These methods return time series objects of class <code>"ts"</code> that represent
the corresponding estimated component in the time series originally used in
the estimation process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Xt &lt;- log(EXPENDITURES)
smoothing_options &lt;- set_options(order_poly = 3)
est &lt;- deseats(Xt, smoothing_options = smoothing_options)
trend_e &lt;- trend(est)           # Trend estimates
season_e &lt;- season(est)         # Seasonality estimates
trend_season_e &lt;- fitted(est)   # Trend + seasonality estimates
resid_e &lt;- residuals(est)       # Residuals (observ. - trend - seasonality)
ts_adj &lt;- deseasonalize(est)    # Seasonally adjusted series
ts_notrend &lt;- detrend(est)      # Detrended series


</code></pre>

<hr>
<h2 id='zoo_to_ts'>Time Series Object Conversion from <code>"zoo"</code> to <code>"ts"</code></h2><span id='topic+zoo_to_ts'></span>

<h3>Description</h3>

<p>Allows for the conversion of time series objects of class <code>"zoo"</code>
to time series objects of class <code>"ts"</code>. This is only suitable, if
the time series is observed in regular time intervals (monthly, quarterly,
yearly, etc.). The correct observation time points are then kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoo_to_ts(xt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zoo_to_ts_+3A_xt">xt</code></td>
<td>
<p>a time series object of class <code>"zoo"</code> with equidistant 
observation time points (monthly, quarterly, yearly, etc.).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An equidistant time series object of class <code>"zoo"</code> is transformed to
class <code>"ts"</code>. This is particularly useful, since most functions of this
package work with objects of class <code>"ts"</code> only.
</p>


<h3>Value</h3>

<p>An object of class <code>"ts"</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create example zoo-object
tp &lt;- seq(from = as.Date("2020-01-01"), to = as.Date("2020-10-01"), by = "month")
xt &lt;- zoo::zoo(1:10, order.by = tp)
xt

# Transform into ts-object
yt &lt;- zoo_to_ts(xt)
yt

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
