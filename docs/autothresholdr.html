<!DOCTYPE html><html><head><title>Help for package autothresholdr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {autothresholdr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auto_thresh'><p>Automatically threshold an array of non-negative integers.</p></a></li>
<li><a href='#masked_arr'><p>Masked array class.</p></a></li>
<li><a href='#mean_stack_thresh'><p>Threshold every image frame in an image stack based on their mean.</p></a></li>
<li><a href='#med_stack_thresh'><p>Threshold every image frame in a stack based on their median.</p></a></li>
<li><a href='#stack_threshed_img'><p>Stack-thresholded image class.</p></a></li>
<li><a href='#th'><p>Automatically found threshold class.</p></a></li>
<li><a href='#threshed_arr'><p>Thresholded array class.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An R Port of the 'ImageJ' Plugin 'Auto Threshold'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rory Nolan &lt;rorynoolan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for automatically finding appropriate thresholds
    for numerical data, with special functions for thresholding images.
    Provides the 'ImageJ' 'Auto Threshold' plugin functionality to R
    users. See <a href="https://imagej.net/plugins/auto-threshold">https://imagej.net/plugins/auto-threshold</a> and Landini et
    al.  (2017) &lt;<a href="https://doi.org/10.1111%2Fjmi.12474">doi:10.1111/jmi.12474</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rorynolan.github.io/autothresholdr/">https://rorynolan.github.io/autothresholdr/</a>,
<a href="https://github.com/rorynolan/autothresholdr#readme">https://github.com/rorynolan/autothresholdr#readme</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rorynolan/autothresholdr/issues">https://github.com/rorynolan/autothresholdr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 1.9.3), ijtiff (&ge; 2.2), magrittr (&ge; 1.5),
purrr, Rcpp (&ge; 1.0.11), rlang (&ge; 0.3.3), stats, strex (&ge;
1.4.1), stringr (&ge; 1.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, ggplot2, knitr, rmarkdown, spelling, styler (&ge;
1.3.2), testthat (&ge; 3.0), utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.11)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-13 05:28:35 UTC; rorynolan</td>
</tr>
<tr>
<td>Author:</td>
<td>Rory Nolan <a href="https://orcid.org/0000-0002-5239-4043"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, trl],
  Luis Alvarez <a href="https://orcid.org/0000-0003-1316-1906"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sergi Padilla-Parra
    <a href="https://orcid.org/0000-0002-8010-9481"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb, ths],
  Gabriel Landini <a href="https://orcid.org/0000-0002-9689-0989"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 06:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auto_thresh'>Automatically threshold an array of non-negative integers.</h2><span id='topic+auto_thresh'></span><span id='topic+auto_thresh_mask'></span><span id='topic+auto_thresh_apply_mask'></span><span id='topic+mask'></span><span id='topic+apply_mask'></span>

<h3>Description</h3>

<p>These functions apply the ImageJ &quot;Auto Threshold&quot; plugin's image thresholding
methods. The available methods are &quot;IJDefault&quot;, &quot;Huang&quot;, &quot;Huang2&quot;,
&quot;Intermodes&quot;, &quot;IsoData&quot;, &quot;Li&quot;, &quot;MaxEntropy&quot;, &quot;Mean&quot;, &quot;MinErrorI&quot;, &quot;Minimum&quot;,
&quot;Moments&quot;, &quot;Otsu&quot;, &quot;Percentile&quot;, &quot;RenyiEntropy&quot;, &quot;Shanbhag&quot;, &quot;Triangle&quot; and
&quot;Yen&quot;. Read about them at <a href="https://imagej.net/plugins/auto-threshold">https://imagej.net/plugins/auto-threshold</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_thresh(
  int_arr,
  method,
  ignore_black = FALSE,
  ignore_white = FALSE,
  ignore_na = FALSE
)

auto_thresh_mask(
  int_arr,
  method,
  ignore_black = FALSE,
  ignore_white = FALSE,
  ignore_na = FALSE
)

auto_thresh_apply_mask(
  int_arr,
  method,
  fail = NA,
  ignore_black = FALSE,
  ignore_white = FALSE,
  ignore_na = FALSE
)

mask(
  int_arr,
  method,
  ignore_black = FALSE,
  ignore_white = FALSE,
  ignore_na = FALSE
)

apply_mask(
  int_arr,
  method,
  fail = NA,
  ignore_black = FALSE,
  ignore_white = FALSE,
  ignore_na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_thresh_+3A_int_arr">int_arr</code></td>
<td>
<p>An array (or vector) of non-negative <em>integers</em>.</p>
</td></tr>
<tr><td><code id="auto_thresh_+3A_method">method</code></td>
<td>
<p>The name of the thresholding method you wish to use. The
available methods are <code>"IJDefault"</code>, <code>"Huang"</code>, <code>"Huang2"</code>, <code>"Intermodes"</code>,
<code>"IsoData"</code>, <code>"Li"</code>, <code>"MaxEntropy"</code>, <code>"Mean"</code>, <code>"MinErrorI"</code>, <code>"Minimum"</code>,
<code>"Moments"</code>, <code>"Otsu"</code>, <code>"Percentile"</code>, <code>"RenyiEntropy"</code>, <code>"Shanbhag"</code>,
<code>"Triangle"</code> and <code>"Yen"</code>. Partial matching is performed i.e. <code>method = "h"</code>
is enough to get you <code>"Huang"</code> and <code>method = "in"</code> is enough to get you
<code>"Intermodes"</code>. To perform <em>manual</em> thresholding (where you set the
threshold yourself), supply the threshold here as a number e.g. <code>method = 3</code>; so note that this would <em>not</em> select the third method in the above
list of methods.</p>
</td></tr>
<tr><td><code id="auto_thresh_+3A_ignore_black">ignore_black</code></td>
<td>
<p>Ignore black pixels/elements (zeros) when performing the
thresholding?</p>
</td></tr>
<tr><td><code id="auto_thresh_+3A_ignore_white">ignore_white</code></td>
<td>
<p>Ignore white pixels when performing the thresholding? If
set to <code>TRUE</code>, the function makes a good guess as to what the white
(saturated) value would be (see 'Details'). If this is set to a number, all
pixels with value greater than or equal to that number are ignored.</p>
</td></tr>
<tr><td><code id="auto_thresh_+3A_ignore_na">ignore_na</code></td>
<td>
<p>This should be <code>TRUE</code> if <code>NA</code>s in <code>int_arr</code> should be
ignored or <code>FALSE</code> if you want the presence of <code>NA</code>s in <code>int_arr</code> to throw
an error.</p>
</td></tr>
<tr><td><code id="auto_thresh_+3A_fail">fail</code></td>
<td>
<p>When using <code>auto_thresh_apply_mask()</code>, to what value do you wish
to set the pixels which fail to exceed the threshold? <code>fail = 'saturate'</code>
sets them to saturated value (see &quot;Details&quot;). <code>fail = 'zero'</code> sets them to
zero. You can also specify directly here a natural number (must be between
<code>0</code> and <code>2^16 - 1</code>) to use.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>Values greater than or equal to the found threshold
<em>pass</em> the thresholding and values less than the threshold <em>fail</em>
the thresholding.
</p>
</li>
<li><p>For <code>ignore_white = TRUE</code>, if the maximum value in the array is one of
<code>2^8-1</code>, <code>2^12-1</code>, <code>2^16-1</code> or <code>2^32-1</code>, then those max values are ignored.
That's because they're the white values in 8, 12, 16 and 32-bit images
respectively (and these are the common image bit sizes to work with). This
guesswork has to be done because <code>R</code> does not know how many bits the image
was on disk. This guess is very unlikely to be wrong, and if it is, the
consequences are negligible anyway. If you're very concerned, then just
specify the white value as an integer in this <code>ignore_white</code> argument.
</p>
</li>
<li><p>If you have set <code>ignore_black = TRUE</code> and/or <code>ignore_white = TRUE</code> but
you are still getting error/warning messages telling you to try them, then
your chosen method is not working for the given array, so you should try a
different method.
</p>
</li>
<li><p>For a given array, if all values are less than <code>2^8</code>, saturated value
is <code>2^8 - 1</code>, otherwise, if all values are less than <code>2^16</code>, the saturated
value is <code>2^16 - 1</code>, otherwise the saturated value is <code>2^32-1</code>.
</p>
</li>
<li><p>For the <code><a href="#topic+auto_thresh">auto_thresh()</a></code> function, if you pass <code>int_arr</code> as a data frame
with column names <code>value</code> and <code>n</code>, that's the same as passing an integer
array having <code>n</code> entries of each <code>value</code>. For this form of <code>int_arr</code>,
<code>ignore_white</code> and <code>ignore_black</code> are irrelevant.
</p>
</li></ul>



<h3>Value</h3>

<p><code>auto_thresh()</code> returns an object of class <a href="#topic+th">th</a> containing the
threshold value. Pixels exceeding this threshold pass the thresholding,
pixels at or below this level fail.
</p>
<p><code>auto_thresh_mask()</code> returns an object of class <a href="#topic+masked_arr">masked_arr</a> which is a
binarized version of the input, with a value of <code>TRUE</code> at points which
exceed the threshold and <code>FALSE</code> at those which do not.
</p>
<p><code>auto_thresh_apply_mask()</code> returns and object of class <a href="#topic+threshed_arr">threshed_arr</a> which
is the original input masked by the threshold, i.e. all points not
exceeding the threshold are set to a user-defined value (default <code>NA</code>).
</p>
<p><code>mask()</code> is the same as <code>auto_thresh_mask()</code> and <code>apply_mask()</code> is the same
as <code>auto_thresh_apply_mask()</code>.
</p>


<h3>Acknowledgements</h3>

<p>Gabriel Landini coded all of these functions in
Java. These java functions were then translated to C++.
</p>


<h3>References</h3>

 <ul>
<li><p>Huang, L-K &amp; Wang, M-J J (1995), &quot;Image
thresholding by minimizing the measure of fuzziness&quot;, Pattern Recognition
28(1): 41-51 </p>
</li>
<li><p>Prewitt, JMS &amp; Mendelsohn, ML (1966), &quot;The analysis of
cell images&quot;, Annals of the New York Academy of Sciences 128: 1035-1053
</p>
</li>
<li><p>Ridler, TW &amp; Calvard, S (1978), &quot;Picture thresholding using an
iterative selection method&quot;, IEEE Transactions on Systems, Man and
Cybernetics 8: 630-632 </p>
</li>
<li><p>Li, CH &amp; Lee, CK (1993), &quot;Minimum Cross
Entropy Thresholding&quot;, Pattern Recognition 26(4): 617-625 </p>
</li>
<li><p>Li, CH &amp;
Tam, PKS (1998), &quot;An Iterative Algorithm for Minimum Cross Entropy
Thresholding&quot;, Pattern Recognition Letters 18(8): 771-776 </p>
</li>
<li><p>Sezgin, M
&amp; Sankur, B (2004), &quot;Survey over Image Thresholding Techniques and
Quantitative Performance Evaluation&quot;, Journal of Electronic Imaging 13(1):
146-165 </p>
</li>
<li><p>Kapur, JN; Sahoo, PK &amp; Wong, ACK (1985), &quot;A New Method for
Gray-Level Picture Thresholding Using the Entropy of the Histogram&quot;,
Graphical Models and Image Processing 29(3): 273-285 </p>
</li>
<li><p>Glasbey, CA
(1993), &quot;An analysis of histogram-based thresholding algorithms&quot;, CVGIP:
Graphical Models and Image Processing 55: 532-537 </p>
</li>
<li><p>Kittler, J &amp;
Illingworth, J (1986), &quot;Minimum error thresholding&quot;, Pattern Recognition
19: 41-47 </p>
</li>
<li><p>Prewitt, JMS &amp; Mendelsohn, ML (1966), &quot;The analysis of
cell images&quot;, Annals of the New York Academy of Sciences 128: 1035-1053
</p>
</li>
<li><p>Tsai, W (1985), &quot;Moment-preserving thresholding: a new approach&quot;,
Computer Vision, Graphics, and Image Processing 29: 377-393 </p>
</li>
<li><p>Otsu, N
(1979), &quot;A threshold selection method from gray-level histograms&quot;, IEEE
Trans. Sys., Man., Cyber. 9: 62-66, doi:10.1109/TSMC.1979.4310076
</p>
</li>
<li><p>Doyle, W (1962), &quot;Operation useful for similarity-invariant pattern
recognition&quot;, Journal of the Association for Computing Machinery 9:
259-267, doi:10.1145/321119.321123 </p>
</li>
<li><p>Kapur, JN; Sahoo, PK &amp; Wong, ACK
(1985), &quot;A New Method for Gray-Level Picture Thresholding Using the Entropy
of the Histogram&quot;, Graphical Models and Image Processing 29(3): 273-285
</p>
</li>
<li><p>Shanbhag, Abhijit G. (1994), &quot;Utilization of information measure as a
means of image thresholding&quot;, Graph. Models Image Process. (Academic Press,
Inc.) 56 (5): 414&ndash;419, ISSN 1049-9652 </p>
</li>
<li><p>Zack GW, Rogers WE, Latt SA
(1977), &quot;Automatic measurement of sister chromatid exchange frequency&quot;, J.
Histochem. Cytochem. 25 (7): 74153, PMID 70454 </p>
</li>
<li><p>Yen JC, Chang FJ,
Chang S (1995), &quot;A New Criterion for Automatic Multilevel Thresholding&quot;,
IEEE Trans. on Image Processing 4 (3): 370-378, ISSN 1057-7149,
doi:10.1109/83.366472 </p>
</li>
<li><p>Sezgin, M &amp; Sankur, B (2004), &quot;Survey over
Image Thresholding Techniques and Quantitative Performance Evaluation&quot;,
Journal of Electronic Imaging 13(1): 146-165 </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
img_location &lt;- system.file("extdata", "eg.tif", package = "autothresholdr")
img &lt;- ijtiff::read_tif(img_location)
auto_thresh(img, "huang")
img_value_count &lt;- magrittr::set_names(as.data.frame(table(img)),
                                      c("value", "n"))
print(head(img_value_count))
auto_thresh(img_value_count, "Huang")
auto_thresh(img, "tri")
auto_thresh(img, "Otsu")
auto_thresh(img, 9)
mask &lt;- auto_thresh_mask(img, "huang")
ijtiff::display(mask[, , 1, 1])
masked &lt;- auto_thresh_apply_mask(img, "huang")
ijtiff::display(masked[, , 1, 1])
masked &lt;- auto_thresh_apply_mask(img, 25)
ijtiff::display(masked[, , 1, 1])

</code></pre>

<hr>
<h2 id='masked_arr'>Masked array class.</h2><span id='topic+masked_arr'></span>

<h3>Description</h3>

<p>A <em>mask</em> of an array with respect to a given threshold is found by taking the
original array and setting all elements falling below the threshold to
<code>FALSE</code> and the others to <code>TRUE</code>. An object of class <a href="#topic+masked_arr">masked_arr</a> has the
attribute <code>thresh</code> detailing the threshold value that was applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>masked_arr(arr, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="masked_arr_+3A_arr">arr</code></td>
<td>
<p>An array of logicals (the mask).</p>
</td></tr>
<tr><td><code id="masked_arr_+3A_thresh">thresh</code></td>
<td>
<p>The threshold. Either a scalar or an object of class <a href="#topic+th">th</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>masked_arr</code>.
</p>

<hr>
<h2 id='mean_stack_thresh'>Threshold every image frame in an image stack based on their mean.</h2><span id='topic+mean_stack_thresh'></span>

<h3>Description</h3>

<p>An <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> is a 4-dimensional array indexed by
<code>img[y, x, channel, frame]</code>. For each channel (which consists of a stack of
frames), this function finds a threshold based on the sum all of the frames,
uses this to create a mask and then applies this mask to every frame in the
stack (so for a given pillar in the image stack, either all the pixels
therein are thresholded away or all are untouched, where pillar <code style="white-space: pre;">&#8288;x,y&#8288;</code> of
channel <code>ch</code> is <code>img[y, x, ch, ]</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_stack_thresh(
  img,
  method,
  fail = NA,
  ignore_black = FALSE,
  ignore_white = FALSE,
  ignore_na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_stack_thresh_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="mean_stack_thresh_+3A_method">method</code></td>
<td>
<p>The name of the thresholding method you wish to use. The
available methods are <code>"IJDefault"</code>, <code>"Huang"</code>, <code>"Huang2"</code>, <code>"Intermodes"</code>,
<code>"IsoData"</code>, <code>"Li"</code>, <code>"MaxEntropy"</code>, <code>"Mean"</code>, <code>"MinErrorI"</code>, <code>"Minimum"</code>,
<code>"Moments"</code>, <code>"Otsu"</code>, <code>"Percentile"</code>, <code>"RenyiEntropy"</code>, <code>"Shanbhag"</code>,
<code>"Triangle"</code> and <code>"Yen"</code>. Partial matching is performed i.e. <code>method = "h"</code>
is enough to get you <code>"Huang"</code> and <code>method = "in"</code> is enough to get you
<code>"Intermodes"</code>. To perform <em>manual</em> thresholding (where you set the
threshold yourself), supply the threshold here as a number e.g. <code>method = 3.8</code> (so note that this would <em>not</em> select the third method in the
above list of methods). This manual threshold will then be used to
threshold the sum stack to create a 2D mask and then this mask will be
applied to all frames in the stack. If you want a different method for each
channel, specify this parameter as a vector or list, one element per
channel.</p>
</td></tr>
<tr><td><code id="mean_stack_thresh_+3A_fail">fail</code></td>
<td>
<p>When using <code>auto_thresh_apply_mask()</code>, to what value do you wish
to set the pixels which fail to exceed the threshold? <code>fail = 'saturate'</code>
sets them to saturated value (see 'Details'). <code>fail = 'zero'</code> sets them to
zero. You can also specify directly here a natural number (must be between
<code>0</code> and <code>2^16 - 1</code>) to use.</p>
</td></tr>
<tr><td><code id="mean_stack_thresh_+3A_ignore_black">ignore_black</code></td>
<td>
<p>Ignore black pixels/elements (zeros) when performing the
thresholding?</p>
</td></tr>
<tr><td><code id="mean_stack_thresh_+3A_ignore_white">ignore_white</code></td>
<td>
<p>Ignore white pixels when performing the thresholding? If
set to <code>TRUE</code>, the function makes a good guess as to what the white
(saturated) value would be (see 'Details'). If this is set to a number, all
pixels with value greater than or equal to that number are ignored.</p>
</td></tr>
<tr><td><code id="mean_stack_thresh_+3A_ignore_na">ignore_na</code></td>
<td>
<p>This should be <code>TRUE</code> if <code>NA</code>s in <code>int_arr</code> should be
ignored or <code>FALSE</code> if you want the presence of <code>NA</code>s in <code>int_arr</code> to throw
an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's called <code>mean_stack_thresh()</code> and not <code>sum_stack_thresh()</code> because its
easier for people to visualize the mean of an image series than to visualize
the sum, but for the sake of this procedure, both are equivalent, except for
the fact that the thresholding routine invoked inside this function prefers
integers, which we get by using a sum but not by using a mean.
</p>
<ul>
<li><p> Values greater than or equal to the found threshold
<em>pass</em> the thresholding and values less than the threshold <em>fail</em>
the thresholding.
</p>
</li>
<li><p>For <code>ignore_white = TRUE</code>, if the maximum value in the array is one of
<code>2^8-1</code>, <code>2^16-1</code> or <code>2^32-1</code>, then those max values are ignored.
That's because they're the white values in 8, 16 and 32-bit images
respectively (and these are the common image bit sizes to work with). This
guesswork has to be done because <code>R</code> does not know how many bits the image
was on disk. This guess is very unlikely to be wrong, and if it is, the
consequences are negligible anyway. If you're very concerned, then just
specify the white value as an integer in this <code>ignore_white</code> argument.
</p>
</li>
<li><p>If you have set <code>ignore_black = TRUE</code> and/or <code>ignore_white = TRUE</code> but
you are still getting error/warning messages telling you to try them, then
your chosen method is not working for the given array, so you should try a
different method.
</p>
</li>
<li><p> For a given array, if all values are less than <code>2^8</code>, saturated value
is <code>2^8 - 1</code>, otherwise, saturated value is <code>2^16 - 1</code>. </p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+stack_threshed_img">stack_threshed_img</a> which is the thresholded
image (an array in the style of an <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>).
Pillars not exceeding the threshold are set to the <code>fail</code> value (default
<code>NA</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif",
  package = "autothresholdr"
))
ijtiff::display(img[, , 1, 1])
img_thresh_mask &lt;- mean_stack_thresh(img, "Otsu")
ijtiff::display(img_thresh_mask[, , 1, 1])
ijtiff::display(img[, , 1, 1])
img_thresh_mask &lt;- mean_stack_thresh(img, "Huang")
ijtiff::display(img_thresh_mask[, , 1, 1])

</code></pre>

<hr>
<h2 id='med_stack_thresh'>Threshold every image frame in a stack based on their median.</h2><span id='topic+med_stack_thresh'></span>

<h3>Description</h3>

<p>An <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> is a 4-dimensional array indexed by
<code>img[y, x, channel, frame]</code>. For each channel (which consists of a stack of
frames), this function finds a threshold based on all of the frames, then
takes the median of all the frames in the stack image, uses this to create a
mask with the found threshold and then applies this mask to every frame in
the stack (so for a given pillar in the image stack, either all the pixels
therein are thresholded away or all are untouched, where pillar <code style="white-space: pre;">&#8288;x,y&#8288;</code> of
channel <code>ch</code> is <code>img[y, x, ch, ]</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>med_stack_thresh(
  img,
  method,
  fail = NA,
  ignore_black = FALSE,
  ignore_white = FALSE,
  ignore_na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="med_stack_thresh_+3A_img">img</code></td>
<td>
<p>A 3-dimensional array (the image stack, possibly a time-series of
images) where the <code class="reqn">n</code>th slice is the <code class="reqn">n</code>th image in the stack.</p>
</td></tr>
<tr><td><code id="med_stack_thresh_+3A_method">method</code></td>
<td>
<p>The name of the thresholding method you wish to use. The
available methods are <code>"IJDefault"</code>, <code>"Huang"</code>, <code>"Huang2"</code>, <code>"Intermodes"</code>,
<code>"IsoData"</code>, <code>"Li"</code>, <code>"MaxEntropy"</code>, <code>"Mean"</code>, <code>"MinErrorI"</code>, <code>"Minimum"</code>,
<code>"Moments"</code>, <code>"Otsu"</code>, <code>"Percentile"</code>, <code>"RenyiEntropy"</code>, <code>"Shanbhag"</code>,
<code>"Triangle"</code> and <code>"Yen"</code>. Partial matching is performed i.e. <code>method = "h"</code>
is enough to get you <code>"Huang"</code> and <code>method = "in"</code> is enough to get you
<code>"Intermodes"</code>. To perform <em>manual</em> thresholding (where you set the
threshold yourself), supply the threshold here as a number e.g. <code>method = 3</code> (so note that this would <em>not</em> select the third method in the above
list of methods). This manual threshold will then be used to threshold the
median stack to create a 2D mask and then this mask will be applied to all
frames in the stack. If you want a different method for each channel,
specify this parameter as a vector or list, one element per channel.</p>
</td></tr>
<tr><td><code id="med_stack_thresh_+3A_fail">fail</code></td>
<td>
<p>When using <code>auto_thresh_apply_mask()</code>, to what value do you wish
to set the pixels which fail to exceed the threshold? <code>fail = 'saturate'</code>
sets them to saturated value (see 'Details'). <code>fail = 'zero'</code> sets them to
zero. You can also specify directly here a natural number (must be between
<code>0</code> and <code>2^32 - 1</code>) to use.</p>
</td></tr>
<tr><td><code id="med_stack_thresh_+3A_ignore_black">ignore_black</code></td>
<td>
<p>Ignore black pixels/elements (zeros) when performing the
thresholding?</p>
</td></tr>
<tr><td><code id="med_stack_thresh_+3A_ignore_white">ignore_white</code></td>
<td>
<p>Ignore white pixels when performing the thresholding? If
set to <code>TRUE</code>, the function makes a good guess as to what the white
(saturated) value would be (see 'Details').</p>
</td></tr>
<tr><td><code id="med_stack_thresh_+3A_ignore_na">ignore_na</code></td>
<td>
<p>This should be <code>TRUE</code> if <code>NA</code>s in <code>int_arr</code> should be
ignored or <code>FALSE</code> if you want the presence of <code>NA</code>s in <code>int_arr</code> to throw
an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<ul>
<li><p> Values greater than or equal to the found threshold
<em>pass</em> the thresholding and values less than the threshold <em>fail</em>
the thresholding.
</p>
</li>
<li><p>For <code>ignore_white = TRUE</code>, if the maximum value in the array is one of
<code>2^8-1</code>, <code>2^16-1</code> or <code>2^32-1</code>, then those max values are ignored.
That's because they're the white values in 8, 16 and 32-bit images
respectively (and these are the common image bit sizes to work with). This
guesswork has to be done because <code>R</code> does not know how many bits the image
was on disk. This guess is very unlikely to be wrong, and if it is, the
consequences are negligible anyway. If you're very concerned, then just
specify the white value as an integer in this <code>ignore_white</code> argument.
</p>
</li>
<li><p>If you have set <code>ignore_black = TRUE</code> and/or <code>ignore_white = TRUE</code> but
you are still getting error/warning messages telling you to try them, then
your chosen method is not working for the given array, so you should try a
different method.
</p>
</li>
<li><p> For a given array, if all values are less than <code>2^8</code>, saturated value
is <code>2^8 - 1</code>, otherwise, saturated value is <code>2^16 - 1</code>. </p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+stack_threshed_img">stack_threshed_img</a> which is the thresholded
image (an array in the style of an <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>).
Pillars not exceeding the threshold are set to the <code>fail</code> value (default
<code>NA</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif",
  package = "autothresholdr"
))
ijtiff::display(img[, , 1, 1])
img_thresh_mask &lt;- med_stack_thresh(img, "Otsu")
ijtiff::display(img_thresh_mask[, , 1, 1])
ijtiff::display(img[, , 1, 1])
img_thresh_mask &lt;- med_stack_thresh(img, "Triangle")
ijtiff::display(img_thresh_mask[, , 1, 1])

</code></pre>

<hr>
<h2 id='stack_threshed_img'>Stack-thresholded image class.</h2><span id='topic+stack_threshed_img'></span>

<h3>Description</h3>

<p>A stack-thresholded array is an array which has had stack-thresholding
applied to it. See <code><a href="#topic+mean_stack_thresh">mean_stack_thresh()</a></code>. It has 3 necessary attributes:
</p>
 <ul>
<li> <p><code>thresh</code> is the threshold that was applied. This is either a
number or an object of class <a href="#topic+th">th</a>. Values in the original array which were
less than this value are deemed to have failed the thresholding. </p>
</li>
<li>
<p><code>fail_value</code> is the value to which elements of the array which failed the
thresholding were set. This could be something like <code>0</code> or <code>NA</code>.  </p>
</li>
<li>
<p><code>stack_thresh_method</code> details which stacked-thresholding method was employed;
this is either <code>"mean"</code> or <code>"median"</code>. </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>stack_threshed_img(img, thresh, fail_value, stack_thresh_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_threshed_img_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="stack_threshed_img_+3A_thresh">thresh</code></td>
<td>
<p>The threshold that was used. Either a number or an object of
class <a href="#topic+th">th</a>.</p>
</td></tr>
<tr><td><code id="stack_threshed_img_+3A_fail_value">fail_value</code></td>
<td>
<p>The value to which elements of the array which failed the
thresholding were set.</p>
</td></tr>
<tr><td><code id="stack_threshed_img_+3A_stack_thresh_method">stack_thresh_method</code></td>
<td>
<p>This must be set to either <code>"mean"</code> or <code>"median"</code>
to tell which stacked-thresholding method was employed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>stack_threshed_img</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+threshed_arr">threshed_arr</a>, <code><a href="#topic+mean_stack_thresh">mean_stack_thresh()</a></code>, <code><a href="#topic+med_stack_thresh">med_stack_thresh()</a></code>.
</p>

<hr>
<h2 id='th'>Automatically found threshold class.</h2><span id='topic+th'></span>

<h3>Description</h3>

<p>A threshold found automatically via <code><a href="#topic+auto_thresh">auto_thresh()</a></code>. It is a number (the
value of the threshold) with 4 attributes: </p>
<ul>
<li> <p><code>ignore_black</code> is
<code>TRUE</code> if black values were ignored during the thresholding and <code>FALSE</code>
otherwise. </p>
</li>
<li> <p><code>ignore_white</code> is <code>TRUE</code> if white values were ignored during
the thresholding and <code>FALSE</code> otherwise. </p>
</li>
<li> <p><code>ignore_na</code> is <code>TRUE</code> if <code>NA</code>s
were ignored during the thresholding and <code>FALSE</code> otherwise. </p>
</li>
<li>
<p><code>autothresh_method</code> details which automatic thresholding method was used.</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>th(thresh, ignore_black, ignore_white, ignore_na, autothresh_method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="th_+3A_thresh">thresh</code></td>
<td>
<p>A scalar. The threshold.</p>
</td></tr>
<tr><td><code id="th_+3A_ignore_black">ignore_black</code></td>
<td>
<p><code>TRUE</code> if black values were ignored during the
thresholding and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="th_+3A_ignore_white">ignore_white</code></td>
<td>
<p><code>TRUE</code> if white values were ignored during the
thresholding and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="th_+3A_ignore_na">ignore_na</code></td>
<td>
<p><code>TRUE</code> if <code>NA</code> values were ignored during the thresholding
and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="th_+3A_autothresh_method">autothresh_method</code></td>
<td>
<p>The name of the automatic thresholding method used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>th</code>.
</p>

<hr>
<h2 id='threshed_arr'>Thresholded array class.</h2><span id='topic+threshed_arr'></span>

<h3>Description</h3>

<p>A thresholded array is an array which has had a threshold applied to it. It
has an attribute <code>thresh</code> which is the threshold that was applied which can
be a number or an object of class <a href="#topic+th">th</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshed_arr(arr, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshed_arr_+3A_arr">arr</code></td>
<td>
<p>The thresholded array (<em>not</em> the original array).</p>
</td></tr>
<tr><td><code id="threshed_arr_+3A_thresh">thresh</code></td>
<td>
<p>The threshold that was used. Either a number or an object of
class <a href="#topic+th">th</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The term 'array' is used loosely here in that vectors and matrices qualify as
arrays.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+threshed_arr">threshed_arr</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+stack_threshed_img">stack_threshed_img</a>, <code><a href="#topic+apply_mask">apply_mask()</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
