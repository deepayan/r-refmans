<!DOCTYPE html><html lang="en"><head><title>Help for package avar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {avar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adis_av'><p>Allan variance of IMU Data from an ADIS 16405 sensor</p></a></li>
<li><a href='#av_ar1'><p>Calculate Theoretical Allan Variance for Stationary First-Order Autoregressive</p>
(AR1) Process</a></li>
<li><a href='#av_dr'><p>Calculate Theoretical Allan Variance for Drift Process</p></a></li>
<li><a href='#av_qn'><p>Calculate Theoretical Allan Variance for Stationary Quantization Noise Process</p></a></li>
<li><a href='#av_rw'><p>Calculate Theoretical Allan Variance for Random Walk Process</p></a></li>
<li><a href='#av_wn'><p>Calculate Theoretical Allan Variance for Stationary White Noise Process</p></a></li>
<li><a href='#avar'><p>Compute the Empirical Allan Variance</p></a></li>
<li><a href='#avar_mo_cpp'><p>Compute Maximal-Overlap Allan Variance using Means</p></a></li>
<li><a href='#avar_to_cpp'><p>Compute Tau-Overlap Allan Variance</p></a></li>
<li><a href='#avlr'><p>Computes the Allan Variance Linear Regression estimator</p></a></li>
<li><a href='#boostrap_ci_avlr'><p>Compute bootstrap confidence intervals for the AVLR estimator</p></a></li>
<li><a href='#covmat_ar1blocks'><p>Calculate Theoretical Covariance Matrix of AR(1) Blocks Process</p></a></li>
<li><a href='#covmat_bi'><p>Calculate Theoretical Covariance Matrix of Bias-Instability Process</p></a></li>
<li><a href='#covmat_nswn'><p>Calculate Theoretical Covariance Matrix of Non-Stationary White Noise Process</p></a></li>
<li><a href='#fit_avlr'><p>Internal function to the Allan Variance Linear Regression estimator</p></a></li>
<li><a href='#imar_av'><p>Allan variance of IMU Data from IMAR Gyroscopes</p></a></li>
<li><a href='#is.whole'><p>Integer Check</p></a></li>
<li><a href='#kvh1750_av'><p>Allan variance of IMU Data from a KVH1750 IMU  sensor</p></a></li>
<li><a href='#ln200_av'><p>Allan variance of IMU Data from a LN200 sensor</p></a></li>
<li><a href='#MOAV'><p>Non-stationary Maximal-overlapping Allan Variance</p></a></li>
<li><a href='#navchip_av'><p>Allan variance of IMU Data from a navchip sensor</p></a></li>
<li><a href='#NOAV'><p>Non-stationary Non-overlapping Allan Variance</p></a></li>
<li><a href='#plot.avar'><p>Plot Allan Deviation</p></a></li>
<li><a href='#plot.avlr'><p>Plot the AVLR with the Allan Variance</p></a></li>
<li><a href='#plot.imu_avar'><p>Plot Allan Variance based on IMU Data</p></a></li>
<li><a href='#plot.imu_avlr'><p>Plot the AVLR with the Allan Deviation for IMU</p></a></li>
<li><a href='#print.avar'><p>Prints Allan Variance</p></a></li>
<li><a href='#print.avlr'><p>Print avlr object</p></a></li>
<li><a href='#print.imu_avlr'><p>Print imu_avlr object</p></a></li>
<li><a href='#summary.avar'><p>Summary Allan Variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Allan Variance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-29</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Guerrier &lt;stef.guerrier@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the allan variance and allan variance linear regression estimator for latent time series models. More details about the method can be found, for example, in Guerrier, S., Molinari, R., &amp; Stebler, Y. (2016) &lt;<a href="https://doi.org/10.1109%2FLSP.2016.2541867">doi:10.1109/LSP.2016.2541867</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stats, simts</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SMAC-Group/avar">https://github.com/SMAC-Group/avar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SMAC-Group/avar/issues">https://github.com/SMAC-Group/avar/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-29 15:10:58 UTC; lionel</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Guerrier [aut, cre],
  James Balamuta [aut],
  Gaetan Bakalli [aut],
  Roberto Molinari [aut],
  Justin Lee [aut],
  Ahmed Radi [aut],
  Haotian Xu [aut],
  Yuming Zhang [aut],
  Nathanael Claussen [aut],
  Lionel Voirol [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-29 15:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='adis_av'>Allan variance of IMU Data from an ADIS 16405 sensor</h2><span id='topic+adis_av'></span>

<h3>Description</h3>

<p>This data set contains Allan variance of gyroscope and accelerometer data from an ADIS 16405 sensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adis_av
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;avar&quot;: A list containing the computed Allan variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data comes from Department of Geomatics Engineering, University of Calgary.
</p>

<hr>
<h2 id='av_ar1'>Calculate Theoretical Allan Variance for Stationary First-Order Autoregressive
(AR1) Process</h2><span id='topic+av_ar1'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical allan variance for stationary
first-order autoregressive (AR1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_ar1(n, phi, sigma2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="av_ar1_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> value for the size of the cluster.</p>
</td></tr>
<tr><td><code id="av_ar1_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> value for the autocorrection parameter <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code id="av_ar1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> indicating the theoretical allan variance for AR1 process.
</p>


<h3>Note</h3>

<p>This function is based on the calculation of the theoretical allan variance
for stationary AR1 process raised in &quot;Allan Variance of Time Series Models for
Measurement Data&quot; by Nien Fan Zhang, 2008, Metrologia, 45(5): 549.
This calculation is fundamental and necessary for the study in &quot;A Study of the Allan Variance
for Constant-Mean Non-Stationary Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>av1 = av_ar1(n = 5, phi = 0.9, sigma2 = 1)
av2 = av_ar1(n = 8, phi = 0.5, sigma2 = 2)
</code></pre>

<hr>
<h2 id='av_dr'>Calculate Theoretical Allan Variance for Drift Process</h2><span id='topic+av_dr'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical allan variance for
drift process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_dr(delta, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="av_dr_+3A_delta">delta</code></td>
<td>
<p>A <code>double</code> value for the noise parameter <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="av_dr_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> value for the size of the cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> indicating the theoretical allan variance for the drift
process.
</p>


<h3>Note</h3>

<p>This function is based on the calculation of the theoretical allan variance
for drift process raised in &quot;Allan Variance of Time Series Models for
Measurement Data&quot; by Nien Fan Zhang, 2008, Metrologia, 45(5): 549.
This calculation is fundamental and necessary for the study in &quot;A Study of the Allan Variance
for Constant-Mean Non-Stationary Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>av1 = av_dr(delta = 1, n = 5)
av2 = av_dr(delta = 2, n = 8)
</code></pre>

<hr>
<h2 id='av_qn'>Calculate Theoretical Allan Variance for Stationary Quantization Noise Process</h2><span id='topic+av_qn'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical allan variance for stationary
quantization noise process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_qn(Q2, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="av_qn_+3A_q2">Q2</code></td>
<td>
<p>A <code>double</code> value for the noise parameter <code class="reqn">Q^2</code>.</p>
</td></tr>
<tr><td><code id="av_qn_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> value for the size of the cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> indicating the theoretical allan variance for the quantization noise
process.
</p>


<h3>Note</h3>

<p>This function is based on the calculation of the theoretical allan variance
for stationary quantization noise process raised in &quot;Allan Variance of Time Series Models for
Measurement Data&quot; by Nien Fan Zhang, 2008, Metrologia, 45(5): 549.
This calculation is fundamental and necessary for the study in &quot;A Study of the Allan Variance
for Constant-Mean Non-Stationary Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>av1 = av_qn(Q2 = 1, n = 5)
av2 = av_qn(Q2 = 2, n = 8)
</code></pre>

<hr>
<h2 id='av_rw'>Calculate Theoretical Allan Variance for Random Walk Process</h2><span id='topic+av_rw'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical allan variance for
random walk process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_rw(omega2, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="av_rw_+3A_omega2">omega2</code></td>
<td>
<p>A <code>double</code> value for the noise parameter <code class="reqn">\omega ^2</code>.</p>
</td></tr>
<tr><td><code id="av_rw_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> value for the size of the cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> indicating the theoretical allan variance for the random walk
process.
</p>


<h3>Note</h3>

<p>This function is based on the calculation of the theoretical allan variance
for random walk process raised in &quot;Allan Variance of Time Series Models for
Measurement Data&quot; by Nien Fan Zhang, 2008, Metrologia, 45(5): 549.
This calculation is fundamental and necessary for the study in &quot;A Study of the Allan Variance
for Constant-Mean Non-Stationary Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>av1 = av_rw(omega2 = 1, n = 5)
av2 = av_rw(omega2 = 2, n = 8)
</code></pre>

<hr>
<h2 id='av_wn'>Calculate Theoretical Allan Variance for Stationary White Noise Process</h2><span id='topic+av_wn'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical allan variance for stationary
white noise process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_wn(sigma2, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="av_wn_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code>.</p>
</td></tr>
<tr><td><code id="av_wn_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> value for the size of the cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> indicating the theoretical allan variance for the white noise
process.
</p>


<h3>Note</h3>

<p>This function is based on the calculation of the theoretical allan variance
for stationary white noise process raised in &quot;Allan Variance of Time Series Models for
Measurement Data&quot; by Nien Fan Zhang, 2008, Metrologia, 45(5): 549.
This calculation is fundamental and necessary for the study in &quot;A Study of the Allan Variance
for Constant-Mean Non-Stationary Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>av1 = av_wn(sigma2 = 1, n = 5)
av2 = av_wn(sigma2 = 2, n = 8)
</code></pre>

<hr>
<h2 id='avar'>Compute the Empirical Allan Variance</h2><span id='topic+avar'></span><span id='topic+avar.default'></span><span id='topic+avar.imu'></span>

<h3>Description</h3>

<p>This function estimates the Allan variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avar(x, type = "mo", ...)

## Default S3 method:
avar(x, type = "mo", freq = 1, ...)

## S3 method for class 'imu'
avar(x, type = "mo", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avar_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> of time series observations or an <code>imu</code> object.</p>
</td></tr>
<tr><td><code id="avar_+3A_type">type</code></td>
<td>
<p>A <code>string</code> containing either <code>"mo"</code> for Maximal Overlap or <code>"to"</code> for Tau Overlap.</p>
</td></tr>
<tr><td><code id="avar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decomposition and the amount of time it takes to perform this function depends on whether you are using
the Maximal Overlap or the Tau Overlap.
</p>


<h3>Value</h3>

<p>If the input <code>x</code> is a <code>vec</code>, then the function returns a <code>list</code> that contains:
</p>

<ul>
<li><p> &quot;levels&quot;: The averaging time at each level.
</p>
</li>
<li><p> &quot;allan&quot;: The estimated Allan variance.
</p>
</li>
<li><p> &quot;type&quot;: Type of estimator (<code>mo</code> or <code>to</code>).
</p>
</li></ul>

<p>If the input <code>x</code> is an <code>imu</code> object, then the function returns a <code>list</code> that contains:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;avar&quot;: A list containing the computed Allan variance based on the data.
</p>
</li></ul>



<h3>Maximal Overlap Allan Variance</h3>

<p>Given <code class="reqn">N</code> equally spaced samples with averaging time <code class="reqn">\tau = n\tau _0</code>,
we define <code class="reqn">n</code> as an integer such that <code class="reqn"> 1 \le n \le \frac{N}{2}</code>.
Therefore, <code class="reqn">n</code> can be selected from <code class="reqn">\left\{ {n|n &lt; \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}</code>
Based on the latter, we have <code class="reqn">M = N - 2n</code> levels of decomposition.
The Maximal-overlap estimator is given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{{2\left( {N - 2k + 1} \right)}}\sum\limits_{t = 2k}^N {{{\left[ {{{\bar Y}_t}\left( k \right) - {{\bar Y}_{t - k}}\left( k \right)} \right]}^2}} </code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn"> {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} </code>
</p>
<p>.
</p>


<h3>Tau-Overlap Allan Variance</h3>

<p>Given <code class="reqn">N</code> equally spaced samples with averaging time <code class="reqn">\tau = n\tau _0</code>,
we define <code class="reqn">n</code> as an integer such that <code class="reqn"> 1 \le n \le \frac{N}{2}</code>.
Therefore, <code class="reqn">n</code> can be selected from <code class="reqn">\left\{ {n|n &lt; \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}</code>
Based on the latter, we have <code class="reqn">m = \left\lfloor {\frac{{N - 1}}{n}} \right\rfloor  - 1</code> levels of decomposition.
The tau-overlap estimator is given by:
</p>
<p>where <code class="reqn"> {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} </code>.
</p>


<h3>References</h3>

<p>Long-Memory Processes, the Allan Variance and Wavelets, D. B. Percival and P. Guttorp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
Xt = rnorm(10000)
av_mat_mo = avar(Xt, type = "mo", freq = 100)
av_mat_tau = avar(Xt, type = "to")

</code></pre>

<hr>
<h2 id='avar_mo_cpp'>Compute Maximal-Overlap Allan Variance using Means</h2><span id='topic+avar_mo_cpp'></span>

<h3>Description</h3>

<p>Computation of Maximal-Overlap Allan Variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avar_mo_cpp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avar_mo_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">N</code> equally spaced samples with averaging time <code class="reqn">\tau = n\tau _0</code>,
where <code class="reqn">n</code> is an integer such that <code class="reqn"> 1 \le n \le \frac{N}{2}</code>.
Therefore, <code class="reqn">n</code> is able to be selected from <code class="reqn">\left\{ {n|n &lt; \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}</code>
Then, <code class="reqn">M = N - 2n</code> samples exist.
The Maximal-overlap estimator is given by:
<code class="reqn">\frac{1}{{2\left( {N - 2k + 1} \right)}}\sum\limits_{t = 2k}^N {{{\left[ {{{\bar Y}_t}\left( k \right) - {{\bar Y}_{t - k}}\left( k \right)} \right]}^2}} </code>
</p>
<p>where <code class="reqn"> {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} </code>.
</p>


<h3>Value</h3>

<p>av A <code>list</code> that contains:
</p>

<ul>
<li><p>&quot;clusters&quot;The size of the cluster
</p>
</li>
<li><p>&quot;allan&quot;The Allan variance
</p>
</li>
<li><p>&quot;errors&quot;The error associated with the variance estimation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>


<h3>References</h3>

<p>Long-Memory Processes, the Allan Variance and Wavelets, D. B. Percival and P. Guttorp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)
N = 100000
white.noise = rnorm(N, 0, 2)
random.walk = cumsum(0.1*rnorm(N, 0, 2))
combined.ts = white.noise+random.walk
av_mat = avar_mo_cpp(combined.ts)

</code></pre>

<hr>
<h2 id='avar_to_cpp'>Compute Tau-Overlap Allan Variance</h2><span id='topic+avar_to_cpp'></span>

<h3>Description</h3>

<p>Computation of Tau-Overlap Allan Variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avar_to_cpp(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avar_to_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">N</code> equally spaced samples with averaging time <code class="reqn">\tau = n\tau _0</code>,
where <code class="reqn">n</code> is an integer such that <code class="reqn"> 1 \le n \le \frac{N}{2}</code>.
Therefore, <code class="reqn">n</code> is able to be selected from <code class="reqn">\left\{ {n|n &lt; \left\lfloor {{{\log }_2}\left( N \right)} \right\rfloor } \right\}</code>
Then, a sampling of <code class="reqn">m = \left\lfloor {\frac{{N - 1}}{n}} \right\rfloor  - 1</code> samples exist.
The tau-overlap estimator is given by:
</p>
<p>where <code class="reqn"> {{\bar y}_t}\left( \tau  \right) = \frac{1}{\tau }\sum\limits_{i = 0}^{\tau  - 1} {{{\bar y}_{t - i}}} </code>.
</p>


<h3>Value</h3>

<p>av A <code>matrix</code> that contains:
</p>

<ul>
<li><p>Col 1The size of the cluster
</p>
</li>
<li><p>Col 2The Allan variance
</p>
</li>
<li><p>Col 3The error associated with the variance estimation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>JJB
</p>


<h3>References</h3>

<p>Long-Memory Processes, the Allan Variance and Wavelets, D. B. Percival and P. Guttorp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)
N = 100000
white.noise = rnorm(N, 0, 2)
random.walk = cumsum(0.1*rnorm(N, 0, 2))
combined.ts = white.noise+random.walk
av_mat = avar_to_cpp(combined.ts)

</code></pre>

<hr>
<h2 id='avlr'>Computes the Allan Variance Linear Regression estimator</h2><span id='topic+avlr'></span><span id='topic+avlr.default'></span><span id='topic+avlr.imu_avar'></span>

<h3>Description</h3>

<p>Estimate the parameters of time series models based on the Allan Variance Linear Regression (AVLR) approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avlr(x, ...)

## Default S3 method:
avlr(
  x,
  qn = NULL,
  wn = NULL,
  rw = NULL,
  dr = NULL,
  ci = FALSE,
  B = 100,
  alpha = 0.05,
  ...
)

## S3 method for class 'imu_avar'
avlr(
  x,
  qn_gyro = NULL,
  wn_gyro = NULL,
  rw_gyro = NULL,
  dr_gyro = NULL,
  qn_acc = NULL,
  wn_acc = NULL,
  rw_acc = NULL,
  dr_acc = NULL,
  B = 100,
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="avlr_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> of time series observations or an <code>imu</code> object.</p>
</td></tr>
<tr><td><code id="avlr_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="avlr_+3A_qn">qn</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Quantization Noise (QN) should be computed.</p>
</td></tr>
<tr><td><code id="avlr_+3A_wn">wn</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a White Noise (WN) should be computed.</p>
</td></tr>
<tr><td><code id="avlr_+3A_rw">rw</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Random Wakk (RW) should be computed.</p>
</td></tr>
<tr><td><code id="avlr_+3A_dr">dr</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Drift (DR) should be computed.</p>
</td></tr>
<tr><td><code id="avlr_+3A_ci">ci</code></td>
<td>
<p>A <code>boolean</code> to compute parameter confidence intervals.</p>
</td></tr>
<tr><td><code id="avlr_+3A_b">B</code></td>
<td>
<p>A <code>double</code> for the number of bootstrap replicates to compute the parameter confidence intervals.</p>
</td></tr>
<tr><td><code id="avlr_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> defining the level of the confidence interval (1 - 'alpha').</p>
</td></tr>
<tr><td><code id="avlr_+3A_qn_gyro">qn_gyro</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Quantization Noise (QN) should be computed for the gyroscope component.</p>
</td></tr>
<tr><td><code id="avlr_+3A_wn_gyro">wn_gyro</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a White Noise (WN) should be computed for the gyroscope component.</p>
</td></tr>
<tr><td><code id="avlr_+3A_rw_gyro">rw_gyro</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Random Wakk (RW) should be computed for the gyroscope component.</p>
</td></tr>
<tr><td><code id="avlr_+3A_dr_gyro">dr_gyro</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Drift (DR) should be computed for the gyroscope component.</p>
</td></tr>
<tr><td><code id="avlr_+3A_qn_acc">qn_acc</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Quantization Noise (QN) should be computed for the accelerometer component.</p>
</td></tr>
<tr><td><code id="avlr_+3A_wn_acc">wn_acc</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a White Noise (WN) should be computed for the accelerometer component.</p>
</td></tr>
<tr><td><code id="avlr_+3A_rw_acc">rw_acc</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Random Wakk (RW) should be computed for the accelerometer component.</p>
</td></tr>
<tr><td><code id="avlr_+3A_dr_acc">dr_acc</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Drift (DR) should be computed for the accelerometer component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the input <code>x</code> is a <code>vec</code>, then the function returns a <code>list</code> that contains:
</p>

<ul>
<li><p> &quot;estimates&quot;: The estimated value of the parameters.
</p>
</li>
<li><p> &quot;implied_ad&quot;: The Allan deviation implied by the estimated parameters.
</p>
</li>
<li><p> &quot;implied_ad_decomp&quot;: The Allan deviation implied by the estimated parameters for each individual model (if more than one is specified).
</p>
</li>
<li><p> &quot;av&quot;: The <code>avar</code> object computed from the provided data.
</p>
</li></ul>

<p>If the input <code>x</code> is of the class <code>imu_avar</code>, then the function returns a <code>list</code> that contains:
</p>

<ul>
<li><p> &quot;gyro&quot;: The estimation results correseponding to the gyroscope component.
</p>
</li>
<li><p> &quot;acc&quot;: The estimation results correseponding to the accelerometer component.
</p>
</li>
<li><p> &quot;imu_av&quot;: The <code>imu_avar</code> object computed based on the IMU data.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)

N = 100000
Xt = rnorm(N) + cumsum(rnorm(N, 0, 3e-3))

av = avar(Xt)
plot(av)

# Input time series
fit = avlr(Xt, wn = 1:8, rw = 11:15)
fit

# Input directly Allan variance
fit = avlr(av, wn = 1:8, rw = 11:15)
fit

# Plot functions
plot(fit)
plot(fit, decomp = TRUE)
plot(fit, decomp = TRUE, show_scales = TRUE)

</code></pre>

<hr>
<h2 id='boostrap_ci_avlr'>Compute bootstrap confidence intervals for the AVLR estimator</h2><span id='topic+boostrap_ci_avlr'></span>

<h3>Description</h3>

<p>Compute bootstrap confidence intervals for the AVLR estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boostrap_ci_avlr(model, B, n, qn, wn, rw, dr, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boostrap_ci_avlr_+3A_model">model</code></td>
<td>
<p>A <code>ts.model</code> object that was estimated with the avlr function.</p>
</td></tr>
<tr><td><code id="boostrap_ci_avlr_+3A_b">B</code></td>
<td>
<p>A <code>double</code> for the number of bootsrap replicates to compute the confidence intervals.</p>
</td></tr>
<tr><td><code id="boostrap_ci_avlr_+3A_n">n</code></td>
<td>
<p>A <code>double</code> with the sample size.</p>
</td></tr>
<tr><td><code id="boostrap_ci_avlr_+3A_qn">qn</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Quantization Noise (QN) was computed.</p>
</td></tr>
<tr><td><code id="boostrap_ci_avlr_+3A_wn">wn</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a White Noise (WN) was computed.</p>
</td></tr>
<tr><td><code id="boostrap_ci_avlr_+3A_rw">rw</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Random Wakk (RW) was computed.</p>
</td></tr>
<tr><td><code id="boostrap_ci_avlr_+3A_dr">dr</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Drift (DR) was computed.</p>
</td></tr>
<tr><td><code id="boostrap_ci_avlr_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> defining the level of the confidence interval (1 - 'alpha').</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> that contains:
</p>

<ul>
<li><p> &quot;ci&quot;: The 1-<code>alpha</code> confidence intervals.
</p>
</li>
<li><p> &quot;sd&quot;: The standard deviation of the estimated parameters.
</p>
</li></ul>


<hr>
<h2 id='covmat_ar1blocks'>Calculate Theoretical Covariance Matrix of AR(1) Blocks Process</h2><span id='topic+covmat_ar1blocks'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical covariance matrix of
a non-stationary AR(1) blocks process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmat_ar1blocks(n_total, n_block, phi, sigma2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covmat_ar1blocks_+3A_n_total">n_total</code></td>
<td>
<p>An <code>integer</code> indicating the length of the whole AR(1) blocks process.</p>
</td></tr>
<tr><td><code id="covmat_ar1blocks_+3A_n_block">n_block</code></td>
<td>
<p>An <code>integer</code> indicating the length of each block of the AR(1) blocks process.</p>
</td></tr>
<tr><td><code id="covmat_ar1blocks_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> value for the autocorrection parameter <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code id="covmat_ar1blocks_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The theoretical covariance <code>matrix</code> of the AR(1) blocks process.
</p>


<h3>Note</h3>

<p>This function helps calculate the theoretical covariance matrix of a non-stationary
process, AR(1) blocks. It is helpful to calculate the theoretical allan variance of
non-stationary processes, which can be used to compare with the theoretical allan variance
of stationary processes as shown in &quot;A Study of the Allan Variance for Constant-Mean Non-Stationary
Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>covmat1 = covmat_ar1blocks(n_total = 1000, n_block = 10,
phi = 0.9, sigma2 = 1)
covmat2 = covmat_ar1blocks(n_total = 800, n_block = 20,
phi = 0.5, sigma2 = 2)
</code></pre>

<hr>
<h2 id='covmat_bi'>Calculate Theoretical Covariance Matrix of Bias-Instability Process</h2><span id='topic+covmat_bi'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical covariance matrix of a bias-instability
process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmat_bi(sigma2, n_total, n_block)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covmat_bi_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code>.</p>
</td></tr>
<tr><td><code id="covmat_bi_+3A_n_total">n_total</code></td>
<td>
<p>An <code>integer</code> indicating the length of the whole bias-instability process.</p>
</td></tr>
<tr><td><code id="covmat_bi_+3A_n_block">n_block</code></td>
<td>
<p>An <code>integer</code> indicating the length of each block of the bias-instability
process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The theoretical covariance <code>matrix</code> of the bias-instability process.
</p>


<h3>Note</h3>

<p>This function helps calculate the theoretical covariance matrix of a non-stationary
process, bias-instability. It is helpful to calculate the theoretical allan variance of
non-stationary processes, which can be used to compare with the theoretical allan variance
of stationary processes as shown in &quot;A Study of the Allan Variance for Constant-Mean Non-Stationary
Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>covmat1 = covmat_bi(sigma2 = 1, n_total = 1000, n_block = 10)
covmat2 = covmat_bi(sigma2 = 2, n_total = 800, n_block = 20)
</code></pre>

<hr>
<h2 id='covmat_nswn'>Calculate Theoretical Covariance Matrix of Non-Stationary White Noise Process</h2><span id='topic+covmat_nswn'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical covariance matrix of a non-stationary
white noise process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covmat_nswn(sigma2, n_total)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covmat_nswn_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code>.</p>
</td></tr>
<tr><td><code id="covmat_nswn_+3A_n_total">n_total</code></td>
<td>
<p>An <code>integer</code> indicating the length of the whole non-stationary white noise
process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The theoretical covariance <code>matrix</code> of the non-stationary white noise process.
</p>


<h3>Note</h3>

<p>This function helps calculate the theoretical covariance matrix of a non-stationary
process, non-stationary white noise. It is helpful to calculate the theoretical allan variance of
non-stationary processes, which can be used to compare with the theoretical allan variance
of stationary processes as shown in &quot;A Study of the Allan Variance for Constant-Mean Non-Stationary
Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>covmat1 = covmat_nswn(sigma2 = 1, n_total = 1000)
covmat2 = covmat_nswn(sigma2 = 2, n_total = 800)
</code></pre>

<hr>
<h2 id='fit_avlr'>Internal function to the Allan Variance Linear Regression estimator</h2><span id='topic+fit_avlr'></span>

<h3>Description</h3>

<p>Estimate the parameters of time series models based on the Allan Variance Linear Regression (AVLR) approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_avlr(qn, wn, rw, dr, ad, scales)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_avlr_+3A_qn">qn</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Quantization Noise (QN) should be computed.</p>
</td></tr>
<tr><td><code id="fit_avlr_+3A_wn">wn</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a White Noise (WN) should be computed.</p>
</td></tr>
<tr><td><code id="fit_avlr_+3A_rw">rw</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Random Wakk (RW) should be computed.</p>
</td></tr>
<tr><td><code id="fit_avlr_+3A_dr">dr</code></td>
<td>
<p>A <code>vec</code> specifying on which scales the parameters of a Drift (DR) should be computed.</p>
</td></tr>
<tr><td><code id="fit_avlr_+3A_ad">ad</code></td>
<td>
<p>A <code>vec</code> of the Allan variance.</p>
</td></tr>
<tr><td><code id="fit_avlr_+3A_scales">scales</code></td>
<td>
<p>A <code>vec</code> of the scales.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the estimated parameters.
</p>

<hr>
<h2 id='imar_av'>Allan variance of IMU Data from IMAR Gyroscopes</h2><span id='topic+imar_av'></span>

<h3>Description</h3>

<p>This data set contains Allan variance of IMAR gyroscopes data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imar_av
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;avar&quot;: A list containing the computed Allan variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data comes from Geodetic Engineering Laboratory (TOPO) and Swiss Federal Institute of Technology Lausanne (EPFL).
</p>

<hr>
<h2 id='is.whole'>Integer Check</h2><span id='topic+is.whole'></span>

<h3>Description</h3>

<p>Checks whether the submitted value is an integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.whole(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.whole_+3A_x">x</code></td>
<td>
<p>A <code>numeric</code> value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>boolean</code> value indicating whether the value is an integer or not.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.whole(2.3)
is.whole(4)
is.whole(c(1,2,3))
is.whole(c(.4,.5,.6))
is.whole(c(7,.8,9))
</code></pre>

<hr>
<h2 id='kvh1750_av'>Allan variance of IMU Data from a KVH1750 IMU  sensor</h2><span id='topic+kvh1750_av'></span>

<h3>Description</h3>

<p>This data set contains Allan variance of gyroscope and accelerometer data from an KVH1750 sensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kvh1750_av
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;avar&quot;: A list containing the computed Allan variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data comes from Department of Geomatics Engineering, University of Calgary.
</p>

<hr>
<h2 id='ln200_av'>Allan variance of IMU Data from a LN200 sensor</h2><span id='topic+ln200_av'></span>

<h3>Description</h3>

<p>This data set contains Allan variance of LN200 gyroscope and accelerometer data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ln200_av
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;avar&quot;: A list containing the computed Allan variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data comes from Geodetic Engineering Laboratory (TOPO) and Swiss Federal Institute of Technology Lausanne (EPFL).
</p>

<hr>
<h2 id='MOAV'>Non-stationary Maximal-overlapping Allan Variance</h2><span id='topic+MOAV'></span>

<h3>Description</h3>

<p>Calculation of the theoretical Maximal-overlapping Allan variance for constant-mean non-stationary time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOAV(n, covmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MOAV_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> indicating the length of each vector of consecutive observations considered for the average.</p>
</td></tr>
<tr><td><code id="MOAV_+3A_covmat">covmat</code></td>
<td>
<p>A <code>matrix</code> indicating the T-by-T covariance matrix of the time series with length T.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculation of Maximal-overlapping Allan variance is based on the definition on &quot;A Study of the Allan Variance for Constant-Mean Non-Stationary Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
Here n is an integer larger than 1 and smaller than <code class="reqn">floor\left(log_2 \left(dim\left(covmat\right)[1]\right)\right)-1</code>.
</p>


<h3>Value</h3>

<p>A <code>field &lt;numeric&gt;</code> that is the theoretical Maximal-overlapping Allan variance for constant-mean non-stationary time series data.
</p>


<h3>Author(s)</h3>

<p>Haotian Xu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)
Xt = arima.sim(n = 100, list(ar = 0.3))
avar(Xt, type = "to")

a = matrix(rep(0, 1000^2), nrow = 1000)
for (i in 1:1000){
  a[,i] = seq(from = 1 - i, length.out = 1000)
}
a.diag = diag(a)
a[upper.tri(a,diag=TRUE)] = 0
a = a + t(a) + diag(a.diag)
covmat = 0.3^a
sapply(1:8, function(y){MOAV(2^y, covmat)})

</code></pre>

<hr>
<h2 id='navchip_av'>Allan variance of IMU Data from a navchip sensor</h2><span id='topic+navchip_av'></span>

<h3>Description</h3>

<p>This data set contains Allan variance of gyroscope and accelerometer data from a navchip sensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>navchip_av
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;avar&quot;: A list containing the computed Allan variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data of the navchip sensor comes from Geodetic Engineering Laboratory (TOPO) and Swiss Federal Institute of Technology Lausanne (EPFL).
</p>

<hr>
<h2 id='NOAV'>Non-stationary Non-overlapping Allan Variance</h2><span id='topic+NOAV'></span>

<h3>Description</h3>

<p>Calculation of the theoretical Non-overlapping Allan variance for constant-mean non-stationary time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOAV(n, covmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NOAV_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> indicating the length of each vector of consecutive observations considered for the average.</p>
</td></tr>
<tr><td><code id="NOAV_+3A_covmat">covmat</code></td>
<td>
<p>A <code>matrix</code> indicating the T-by-T covariance matrix of the time series with length T.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculation of Non-overlapping Allan variance is based on the definition on &quot;A Study of the Allan Variance for Constant-Mean Non-Stationary Processes&quot; by Xu et al., 2017, IEEE Signal Processing Letters, 24(8): 1257–1260.
Here n is an integer larger than 1 and smaller than <code class="reqn">floor\left(log_2 \left(dim\left(covmat\right)[1]\right)\right)-1</code>.
</p>


<h3>Value</h3>

<p>A <code>field &lt;numeric&gt;</code> that is the theoretical Non-overlapping Allan variance for constant-mean non-stationary time series data.
</p>


<h3>Author(s)</h3>

<p>Haotian Xu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)
Xt = arima.sim(n = 100, list(ar = 0.3))
avar(Xt, type = "to")

a = matrix(rep(0, 1000^2), nrow = 1000)
for (i in 1:1000){
  a[,i] = seq(from = 1 - i, length.out = 1000)
}
a.diag = diag(a)
a[upper.tri(a,diag=TRUE)] = 0
a = a + t(a) + diag(a.diag)
covmat = 0.3^a
sapply(1:8, function(y){NOAV(2^y, covmat)})


</code></pre>

<hr>
<h2 id='plot.avar'>Plot Allan Deviation</h2><span id='topic+plot.avar'></span>

<h3>Description</h3>

<p>Displays a plot of Allan variance with its corresponding pointwise confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'avar'
plot(
  x,
  units = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  col_ad = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  legend_position = NULL,
  ci_ad = NULL,
  point_cex = NULL,
  point_pch = NULL,
  text_legend_cex = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.avar_+3A_x">x</code></td>
<td>
<p>An <code>avar</code> object.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_units">units</code></td>
<td>
<p>A <code>string</code> that specifies the units of time plotted on the x axis.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_col_ad">col_ad</code></td>
<td>
<p>A <code>string</code> that specifies the color of the line allan variance line.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the shaded area covered by the confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_nb_ticks_x">nb_ticks_x</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_nb_ticks_y">nb_ticks_y</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_legend_position">legend_position</code></td>
<td>
<p>A <code>string</code> that specifies the position of the legend (use <code>legend_position = NA</code> to remove legend).</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_ci_ad">ci_ad</code></td>
<td>
<p>A <code>boolean</code> that determines whether to plot the confidence interval shaded area.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_point_cex">point_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of each symbol to be plotted.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_point_pch">point_pch</code></td>
<td>
<p>A <code>double</code> that specifies the symbol type to be plotted.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_text_legend_cex">text_legend_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of the legend text.</p>
</td></tr>
<tr><td><code id="plot.avar_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the Allan deviation and relative confidence interval for each scale.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier, Nathanael Claussen and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)
Xt = rnorm(10000)
av = avar(Xt)

plot(av)
plot(av, main = "Simulated white noise", xlab = "Scales")
plot(av, units = "sec", legend_position = "topright")
plot(av, col_ad = "darkred", col_ci = "pink")

</code></pre>

<hr>
<h2 id='plot.avlr'>Plot the AVLR with the Allan Variance</h2><span id='topic+plot.avlr'></span>

<h3>Description</h3>

<p>Displays a plot of the Allan variance (AV) with the CI values and the AV implied by the estimated parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'avlr'
plot(
  x,
  decomp = FALSE,
  units = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  col_ad = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  legend_position = NULL,
  ci_ad = NULL,
  point_cex = NULL,
  point_pch = NULL,
  show_scales = FALSE,
  text_legend_cex = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.avlr_+3A_x">x</code></td>
<td>
<p>An <code>avlr</code> object.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_decomp">decomp</code></td>
<td>
<p>A <code>boolean</code> that determines whether the contributions of each individual model are plotted.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_units">units</code></td>
<td>
<p>A <code>string</code> that specifies the units of time plotted on the x axis.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_col_ad">col_ad</code></td>
<td>
<p>A <code>string</code> that specifies the color of the line allan variance line.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the shaded area covered by the confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_nb_ticks_x">nb_ticks_x</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_nb_ticks_y">nb_ticks_y</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_legend_position">legend_position</code></td>
<td>
<p>A <code>string</code> that specifies the position of the legend (use <code>legend_position = NA</code> to remove legend).</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_ci_ad">ci_ad</code></td>
<td>
<p>A <code>boolean</code> that determines whether to plot the confidence interval shaded area.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_point_cex">point_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of each symbol to be plotted.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_point_pch">point_pch</code></td>
<td>
<p>A <code>double</code> that specifies the symbol type to be plotted.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_show_scales">show_scales</code></td>
<td>
<p>A <code>boolean</code> that specifies if the scales used for each process should be plotted.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_text_legend_cex">text_legend_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of the legend text.</p>
</td></tr>
<tr><td><code id="plot.avlr_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of Allan deviation and relative confidence intervals for each scale.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)

N = 100000
Xt = rnorm(N) + cumsum(rnorm(N, 0, 3e-3))
av = avlr(Xt, wn = 1:7, rw = 12:15)

plot.avlr(av)
plot.avlr(av, decomp = TRUE, main = "Simulated white noise", xlab = "Scales")
plot.avlr(av, units = "sec", legend_position = "topright")
plot.avlr(av, col_ad = "darkred", col_ci = "pink")
plot.avlr(av, decomp = TRUE, show_scales = TRUE)

</code></pre>

<hr>
<h2 id='plot.imu_avar'>Plot Allan Variance based on IMU Data</h2><span id='topic+plot.imu_avar'></span>

<h3>Description</h3>

<p>Displays a plot of Allan variance based on IMU data with its corresponding pointwise confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imu_avar'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  col_ad = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  ci_ad = NULL,
  point_pch = NULL,
  point_cex = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.imu_avar_+3A_x">x</code></td>
<td>
<p>An <code>avar</code> object.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_col_ad">col_ad</code></td>
<td>
<p>A <code>string</code> that specifies the color of the line allan variance line.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the shaded area covered by the confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_nb_ticks_x">nb_ticks_x</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_nb_ticks_y">nb_ticks_y</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_ci_ad">ci_ad</code></td>
<td>
<p>A <code>boolean</code> that determines whether to plot the confidence interval shaded area.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_point_pch">point_pch</code></td>
<td>
<p>A <code>double</code> that specifies the symbol type to be plotted.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_point_cex">point_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of each symbol to be plotted.</p>
</td></tr>
<tr><td><code id="plot.imu_avar_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the Allan deviation and relative confidence interval for each scale.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier and Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("navchip_av")
plot(navchip_av)
</code></pre>

<hr>
<h2 id='plot.imu_avlr'>Plot the AVLR with the Allan Deviation for IMU</h2><span id='topic+plot.imu_avlr'></span>

<h3>Description</h3>

<p>Displays a plot of the Allan variance (AV) with the CI values and the AV implied by the estimated parameters for the IMU.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imu_avlr'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  col_ad = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  ci_ad = NULL,
  point_pch = NULL,
  point_cex = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.imu_avlr_+3A_x">x</code></td>
<td>
<p>An <code>avlr</code> object.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_col_ad">col_ad</code></td>
<td>
<p>A <code>string</code> that specifies the color of the line allan variance line.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the shaded area covered by the confidence intervals.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_nb_ticks_x">nb_ticks_x</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_nb_ticks_y">nb_ticks_y</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_ci_ad">ci_ad</code></td>
<td>
<p>A <code>boolean</code> that determines whether to plot the confidence interval shaded area.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_point_pch">point_pch</code></td>
<td>
<p>A <code>double</code> that specifies the symbol type to be plotted.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_point_cex">point_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of each symbol to be plotted.</p>
</td></tr>
<tr><td><code id="plot.imu_avlr_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of Allan deviation and relative confidence intervals for each scale.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(navchip_av)
navchip_avlr = avlr(navchip_av, wn_gyro = 1:20, rw_gyro = 1:20, wn_acc = 1:20, rw_acc = 1:20)
plot(navchip_avlr)

</code></pre>

<hr>
<h2 id='print.avar'>Prints Allan Variance</h2><span id='topic+print.avar'></span>

<h3>Description</h3>

<p>Displays the information on the output of the 'avar()' function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'avar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.avar_+3A_x">x</code></td>
<td>
<p>A <code>avar</code> object.</p>
</td></tr>
<tr><td><code id="print.avar_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>console output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
Xt = rnorm(10000)
out = avar(Xt)
print(out)

</code></pre>

<hr>
<h2 id='print.avlr'>Print avlr object</h2><span id='topic+print.avlr'></span>

<h3>Description</h3>

<p>Displays information about the avlr object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'avlr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.avlr_+3A_x">x</code></td>
<td>
<p>A <code>avlr</code> object</p>
</td></tr>
<tr><td><code id="print.avlr_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text output via print
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)

N = 100000
Xt = rnorm(N) + cumsum(rnorm(N, 0, 3e-3))

fit = avlr(Xt, wn = 1:7, rw = 12:15)
print(fit)

</code></pre>

<hr>
<h2 id='print.imu_avlr'>Print imu_avlr object</h2><span id='topic+print.imu_avlr'></span>

<h3>Description</h3>

<p>Displays information about the avlr object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imu_avlr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.imu_avlr_+3A_x">x</code></td>
<td>
<p>A <code>avlr</code> object</p>
</td></tr>
<tr><td><code id="print.imu_avlr_+3A_...">...</code></td>
<td>
<p>Other arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text output via print
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(navchip_av)
navchip_avlr = avlr(navchip_av, wn_gyro = 1:20, rw_gyro = 1:20, wn_acc = 1:20, rw_acc = 1:20)
print(navchip_avlr)

</code></pre>

<hr>
<h2 id='summary.avar'>Summary Allan Variance</h2><span id='topic+summary.avar'></span>

<h3>Description</h3>

<p>Displays the summary table of the output of the 'avar()' function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'avar'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.avar_+3A_object">object</code></td>
<td>
<p>A <code>avar</code> object.</p>
</td></tr>
<tr><td><code id="summary.avar_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.
A <code>table</code> that contains:
</p>

<ul>
<li><p> &quot;Time&quot;: The averaging time at each level.
</p>
</li>
<li><p> &quot;AVar&quot;: The estimated Allan variance.
</p>
</li>
<li><p> &quot;ADev&quot;: The estimated Allan deviation.
</p>
</li>
<li><p> &quot;Lower CI&quot;: The lower bound of the confidence interval for the Allan deviation (ADev).
</p>
</li>
<li><p> &quot;Upper CI&quot;: The upper bound of the confidence interval for the Allan deviation (ADev).
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
Xt = rnorm(10000)
out = avar(Xt)
summary(out)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
