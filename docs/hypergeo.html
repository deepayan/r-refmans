<!DOCTYPE html><html><head><title>Help for package hypergeo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hypergeo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buhring'><p>Evaluation of the hypergeometric function using Buhring's method</p></a></li>
<li><a href='#complex_gamma'>
<p>Gamma function for complex arguments</p></a></li>
<li><a href='#f15.3.1'><p>Hypergeometric function using Euler's integral representation</p></a></li>
<li><a href='#f15.3.10'><p>Transformations of the hypergeometric function</p></a></li>
<li><a href='#f15.3.3'><p>Various transformation formulae for the hypergeometric function</p></a></li>
<li><a href='#f15.5.1'>
<p>Hypergeometric functions via direct numerical integration</p></a></li>
<li><a href='#genhypergeo'><p>The generalized hypergeometric function</p></a></li>
<li><a href='#gosper'><p>Evaluation of the hypergeometric function using Gosper's method</p></a></li>
<li><a href='#hypergeo'><p>The hypergeometric function</p></a></li>
<li><a href='#hypergeo_A_nonpos_int'><p>Hypergeometric functions for integer arguments</p></a></li>
<li><a href='#hypergeo_contfrac'><p>Continued fraction expansion of the hypergeometric function</p></a></li>
<li><a href='#hypergeo_cover1'><p>Hypergeometric functions for special values of the parameters</p></a></li>
<li><a href='#hypergeo_powerseries'><p>The hypergeometric function as determined by power series</p></a></li>
<li><a href='#hypergeo-package'>
<p>The hypergeometric function</p></a></li>
<li><a href='#i15.3.6'><p>Helper functions</p></a></li>
<li><a href='#is.nonpos'><p>Various utilities</p></a></li>
<li><a href='#residue'><p>Evaluation of the hypergeometric function using the residue theorem</p></a></li>
<li><a href='#shanks'><p>Evaluation of the hypergeometric function using Shanks's method</p></a></li>
<li><a href='#wolfram'><p>Various functions taken from the Wolfram Functions Site</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>The Gauss Hypergeometric Function</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>elliptic (&ge; 1.3-5), contfrac (&ge; 1.1-9), deSolve</td>
</tr>
<tr>
<td>Description:</td>
<td>The Gaussian hypergeometric function for complex numbers.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-04-06 23:00:52 UTC; rhankin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-04-07 07:45:22</td>
</tr>
</table>
<hr>
<h2 id='buhring'>Evaluation of the hypergeometric function using Buhring's method</h2><span id='topic+buhring'></span><span id='topic+buhring_eqn11'></span><span id='topic+buhring_eqn12'></span><span id='topic+buhring_eqn5_factors'></span><span id='topic+buhring_eqn5_series'></span><span id='topic+hypergeo_buhring'></span><span id='topic+buhring_eqn12'></span>

<h3>Description</h3>

<p>Expansion of the hypergeometric function
using the residue theorem; useful for when the primary argument is close
to the critical points <code class="reqn">1/2\pm i\sqrt{3}/2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo_buhring(A,B,C,z,z0=1/2,tol=0,maxiter=2000,use11=TRUE)
buhring_eqn11(n,S,A,B,C,z0=1/2)
buhring_eqn12(n,S,A,B,C,z0=1/2)
buhring_eqn5_factors(A,B,C,z,z0=1/2)
buhring_eqn5_series(S,A,B,C,z,z0=1/2,use11=FALSE,tol=0,maxiter=2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buhring_+3A_a">A</code>, <code id="buhring_+3A_b">B</code>, <code id="buhring_+3A_c">C</code></td>
<td>
<p>Parameters (real)</p>
</td></tr>
<tr><td><code id="buhring_+3A_s">S</code></td>
<td>
<p>Parameter taken to be either <code>A</code> or <code>B</code></p>
</td></tr>
<tr><td><code id="buhring_+3A_n">n</code></td>
<td>
<p>Term to calculate in <code>buhring_eqn11()</code> or
<code>buhring_eqn12()</code></p>
</td></tr>
<tr><td><code id="buhring_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="buhring_+3A_z0">z0</code></td>
<td>
<p>Centre of circle of non-convergence; series expressed in
powers of <code class="reqn">1/\left(z-z_0\right)^n</code></p>
</td></tr>
<tr><td><code id="buhring_+3A_tol">tol</code>, <code id="buhring_+3A_maxiter">maxiter</code></td>
<td>
<p>tolerance and maximum number of iterations (as
in <code>hypergeo()</code>)</p>
</td></tr>
<tr><td><code id="buhring_+3A_use11">use11</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to use
<code>buhring_eqn11()</code> and <code>FALSE</code> meaning to use <code>buhring_eqn12()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are direct transcriptions of Buhring 1987.  The basic
idea is to expand the hypergeometric function in powers of
<code class="reqn">(z-z_0)^{-1}</code>.
</p>
<p>Functions <code>buhring_eqn11()</code> and <code>buhring_eqn12()</code> return the
coefficients <code class="reqn">d_n</code> given by equations 11 and 12 of Buhring
1987.  
</p>
<p>The series do not converge satisfactorily near the critical points due
to some sort of numerical instability.  But they seem to work OK if
<code class="reqn">|z-1/2|</code> is large.
</p>


<h3>Note</h3>

<p>There is some issue which prevents the series from converging correctly,
also sometimes the sequence converges to a demponstrably incorrect
value. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

 

<ul>
<li><p> W. Buhring 1987.  &ldquo;An analytic continuation of the
hypergeometric series&rdquo;, <em>Siam J. Math. Anal.</em> 18(3)
</p>
</li></ul>



<h3>See Also</h3>

<p><code>residue</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# should be identical:
buhring_eqn11(n=0:10,S=1/2,A=1/2,B=1/3,C=pi)
buhring_eqn12(n=0:10,S=1/2,A=1/2,B=1/3,C=pi)
# but differ in one element


a &lt;- hypergeo(1/2,1/3,4,1+8i,maxiter=90)
b &lt;- hypergeo_buhring(1/2,1/3,4,1+8i,maxiter=90)
# should be identical but are not 


# following command fails due to numerical instability:
## Not run: 
hypergeo_buhring(1/2,1/3,pi,z=1/2 + 1i*sqrt(3)/2)

## End(Not run)

</code></pre>

<hr>
<h2 id='complex_gamma'>
Gamma function for complex arguments
</h2><span id='topic+complex_gamma'></span><span id='topic+complex_factorial'></span><span id='topic+lanczos'></span>

<h3>Description</h3>

<p>Gamma and factorial functions for complex arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complex_gamma(z, log = FALSE)
complex_factorial(z, log = FALSE)
lanczos(z,log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complex_gamma_+3A_z">z</code></td>
<td>
<p>Primary argument, a complex vector</p>
</td></tr>
<tr><td><code id="complex_gamma_+3A_log">log</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return the
function value and <code>TRUE</code> meaning to return its logarithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method follows that of Lanczos, coefficients identical to those of the GSL
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>References</h3>

<p>Lanczos, C. 1964. &ldquo;A precision approximation of the gamma
function&rdquo;. <em>Journal of the society for industrial and applied
mathematics series B</em>, Volume 1, pp86-96
</p>
<p>M. Galassi et al, GNU Scientific Library Reference Manual (3rd Ed.), ISBN 0954612078. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
complex_gamma(5)  # should be 4!=24

complex_gamma(1+1i)   # takes complex arguments

complex_gamma(-5/2) + sqrt(pi)*8/15  # should be small

z &lt;- pi + 1i*sqrt(2)
complex_gamma(z+1)-z*complex_gamma(z)   # should be small


complex_gamma(z)*complex_gamma(1-z) - pi/sin(pi*z)  # small


</code></pre>

<hr>
<h2 id='f15.3.1'>Hypergeometric function using Euler's integral representation</h2><span id='topic+f15.3.1'></span><span id='topic+hypergeo_integral'></span>

<h3>Description</h3>

<p>Hypergeometric function using Euler's integral representation, evaluated
using numerical contour integrals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f15.3.1(A, B, C, z, h = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f15.3.1_+3A_a">A</code>, <code id="f15.3.1_+3A_b">B</code>, <code id="f15.3.1_+3A_c">C</code></td>
<td>
<p>Parameters</p>
</td></tr>
<tr><td><code id="f15.3.1_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="f15.3.1_+3A_h">h</code></td>
<td>
<p>specification for the path to be taken; see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>h</code> specifies the path to be taken (the path has to
avoid the point <code class="reqn">1/z</code>).  If <code>h</code> is real and of length 1, the
path taken comprises two straight lines: one from <code class="reqn">0</code> to
<code class="reqn">0.5+hi</code> and one from <code class="reqn">0.5+hi</code> to <code class="reqn">1</code> (if <code class="reqn">h=0</code> the
integration is performed over a single segment).
</p>
<p>Otherwise, the integration is performed over <code>length(h)+1</code>
segments: <code class="reqn">0</code> to <code>h[1]</code>, then <code>h[i]</code> to <code>h[i+1]</code>
for <code class="reqn">1\leq i\leq n-1</code> and finally <code>h[n]</code> to 1.
</p>
<p>See examples and notes sections below.
</p>


<h3>Note</h3>

<p>The Mellin-Barnes form is not yet coded up.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo">hypergeo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# For |z| &lt;1 the path can be direct:
f15.3.1(2,1,2,-1/2) -2/3

# cf identity 07.23.03.0046.01 of Hypergeometric2F1.pdf with b=1




f &lt;- function(h){f15.3.1(1,2,3, z=2, h=h)}

# Winding number [around 1/z] matters:
f(0.5)
f(c(1-1i, 1+1i, -2i))

# Accuracy isn't too bad; compare numerical to analytical result :
f(0.5) - (-1+1i*pi/2)

</code></pre>

<hr>
<h2 id='f15.3.10'>Transformations of the hypergeometric function</h2><span id='topic+f15.1.1'></span><span id='topic+f15.3.10'></span><span id='topic+f15.3.10_a'></span><span id='topic+f15.3.10_b'></span><span id='topic+f15.3.11'></span><span id='topic+f15.3.11_bit1'></span><span id='topic+f15.3.11_bit2_a'></span><span id='topic+f15.3.11_bit2_b'></span><span id='topic+f15.3.12'></span><span id='topic+f15.3.12_bit1'></span><span id='topic+f15.3.12_bit2_a'></span><span id='topic+f15.3.12_bit2_b'></span><span id='topic+f15.3.13'></span><span id='topic+f15.3.13_14'></span><span id='topic+f15.3.13_a'></span><span id='topic+f15.3.13_b'></span><span id='topic+f15.3.14'></span><span id='topic+f15.3.14_bit1_a'></span><span id='topic+f15.3.14_bit1_b'></span><span id='topic+f15.3.14_bit2'></span><span id='topic+f15.3.10_11_12'></span>

<h3>Description</h3>

<p>Transformations of the hypergeometric function detailed in AMS-55, page
559-560.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f15.3.10       (A, B,    z, tol = 0, maxiter = 2000, method = "a")
f15.3.10_a     (A, B,    z, tol = 0, maxiter = 2000              )
f15.3.10_b     (A, B,    z, tol = 0, maxiter = 2000              )
f15.3.11       (A, B, m, z, tol = 0, maxiter = 2000, method = "a")
f15.3.11_bit1  (A, B, m, z, tol = 0                              )
f15.3.11_bit2_a(A, B, m, z, tol = 0, maxiter = 2000              )
f15.3.11_bit2_b(A, B, m, z, tol = 0, maxiter = 2000              )
f15.3.12       (A, B, m, z, tol = 0, maxiter = 2000, method = "a")
f15.3.12_bit1  (A, B, m, z, tol = 0                              )
f15.3.12_bit2_a(A, B, m, z, tol = 0, maxiter = 2000              )
f15.3.12_bit2_b(A, B, m, z, tol = 0, maxiter = 2000              )
f15.3.13       (A, C,    z, tol = 0, maxiter = 2000, method = "a")
f15.3.13_a     (A, C,    z, tol = 0, maxiter = 2000              )
f15.3.13_b     (A, C,    z, tol = 0, maxiter = 2000              )
f15.3.14       (A, C, m, z, tol = 0, maxiter = 2000, method = "a")
f15.3.14_bit1_a(A, C, m, z, tol = 0, maxiter = 2000              )
f15.3.14_bit1_b(A, C, m, z, tol = 0, maxiter = 2000              )
f15.3.14_bit2  (A, C, m, z, tol = 0                              )
f15.3.13_14    (A, C, m, z, tol = 0, maxiter = 2000, method = "a")
f15.3.10_11_12 (A, B, m, z, tol = 0, maxiter = 2000, method = "a")
f15.1.1        (A, B, C, z, tol = 0, maxiter = 2000              )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f15.3.10_+3A_a">A</code>, <code id="f15.3.10_+3A_b">B</code>, <code id="f15.3.10_+3A_c">C</code></td>
<td>
<p>Parameters of the hypergeometric function</p>
</td></tr>
<tr><td><code id="f15.3.10_+3A_m">m</code></td>
<td>
<p>Integer linking <code>A</code>, <code>B</code>, <code>C</code> as set out in
AMS-55, page 559,560</p>
</td></tr>
<tr><td><code id="f15.3.10_+3A_z">z</code></td>
<td>
<p>primary complex argument</p>
</td></tr>
<tr><td><code id="f15.3.10_+3A_tol">tol</code>, <code id="f15.3.10_+3A_maxiter">maxiter</code></td>
<td>
<p>numerical parameters</p>
</td></tr>
<tr><td><code id="f15.3.10_+3A_method">method</code></td>
<td>
<p>Length 1 character vector specifying the method.  See details</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Naming scheme (functions and arguments) follows AMS-55, pages 559-560.
</p>
<p>The <code>method</code> argument to (eg) <code>f15.3.14()</code> specifies whether
to use <code>psigamma()</code> directly (method &ldquo;<code>a</code>&rdquo;), or the
recurrence 6.3.5 (method &ldquo;<code>b</code>&rdquo;).  Press et al recommend
method &ldquo;<code>b</code>&rdquo;, presumably on the grounds of execution speed.
I'm not so sure (method &ldquo;<code>a</code>&rdquo; seems to be more accurate in
the sense that it returns values closer to those of Maple).
</p>
<p>Method &ldquo;<code>c</code>&rdquo; means to use a totally dull, slow, direct (but
clearly correct) summation, for the purposes of debugging.  This is
only used for the functions documented under <code>wolfram.Rd</code>
</p>
<p>Functions <code>f15.3.13_14()</code> and <code>f15.3.10_11_12()</code> are
convenience wrappers.  For example, function <code>f15.3.13_14()</code>
dispatches to either <code>f15.3.13()</code> or <code>f15.3.14()</code> depending on
the value of <code>m</code>.
</p>


<h3>Note</h3>

<p>These functions are not really designed to be called by the user: use
<code>hypergeo()</code> instead, or <code>hypergeo_cover[123]()</code> for
specific cases.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo">hypergeo</a></code>,<code><a href="#topic+wolfram">wolfram</a></code>,<code><a href="#topic+hypergeo_cover1">hypergeo_cover1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
f15.3.10_11_12(A=1.1, B=pi, m= +3, z=.1+.1i)
f15.3.10_11_12(A=1.1, B=pi, m= -3, z=.1+.1i)

</code></pre>

<hr>
<h2 id='f15.3.3'>Various transformation formulae for the hypergeometric function</h2><span id='topic+f15.3.3'></span><span id='topic+f15.3.4'></span><span id='topic+f15.3.5'></span><span id='topic+f15.3.6'></span><span id='topic+f15.3.7'></span><span id='topic+f15.3.8'></span><span id='topic+f15.3.9'></span>

<h3>Description</h3>

<p>Transformations of the hypergeometric function: equations 15.3.3 to 15.3.9
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f15.3.3(A, B, C, z, tol = 0, maxiter = 2000)
f15.3.4(A, B, C, z, tol = 0, maxiter = 2000)
f15.3.5(A, B, C, z, tol = 0, maxiter = 2000)
f15.3.6(A, B, C, z, tol = 0, maxiter = 2000)
f15.3.7(A, B, C, z, tol = 0, maxiter = 2000)
f15.3.8(A, B, C, z, tol = 0, maxiter = 2000)
f15.3.9(A, B, C, z, tol = 0, maxiter = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f15.3.3_+3A_a">A</code>, <code id="f15.3.3_+3A_b">B</code>, <code id="f15.3.3_+3A_c">C</code></td>
<td>
<p>Parameters of the hypergeometric function</p>
</td></tr>
<tr><td><code id="f15.3.3_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="f15.3.3_+3A_tol">tol</code>, <code id="f15.3.3_+3A_maxiter">maxiter</code></td>
<td>
<p>parameters passed to <code>genhypergeo()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The naming scheme follows that of Abramowitz and Stegun
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. &ldquo;Handbook of
mathematical functions&rdquo;.  New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo">hypergeo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f15.3.4(1.1,2.2,3.4,-1+0.1i)
</code></pre>

<hr>
<h2 id='f15.5.1'>
Hypergeometric functions via direct numerical integration
</h2><span id='topic+f15.5.1'></span><span id='topic+f15.5.1'></span><span id='topic+hypergeo_press'></span><span id='topic+hypergeo_func'></span><span id='topic+to_real'></span><span id='topic+to_complex'></span><span id='topic+complex_ode'></span><span id='topic+semicircle'></span><span id='topic+semidash'></span><span id='topic+straight'></span><span id='topic+straightdash'></span>

<h3>Description</h3>

<p>The hypergeometric function may be evaluated using Gauss's
differential equation 15.5.1: 
</p>
<p style="text-align: center;"><code class="reqn">z(1-z)w''+(c-(a+b+1)z)w'-abw=0</code>
</p>

<p>using a start value away from the three singular points.  This page
documents a suite of related functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo_press(A,B,C,z, ...)
f15.5.1(A, B, C, z, startz, u, udash, give=FALSE, ...)
hypergeo_func(Time, State, Pars, u, udash)
to_real(o)
to_complex(p)
complex_ode(y, times, func, parms=NA, method=NULL, u, udash, ...)
semicircle(t,z0,z1,clockwise=TRUE)
semidash(t,z0,z1,clockwise=TRUE)
straight(t,z0,z1)
straightdash(t,z0,z1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f15.5.1_+3A_a">A</code>, <code id="f15.5.1_+3A_b">B</code>, <code id="f15.5.1_+3A_c">C</code>, <code id="f15.5.1_+3A_z">z</code></td>
<td>
<p>Standard parameters for the hypergeometric function</p>
</td></tr>
<tr><td><code id="f15.5.1_+3A_u">u</code>, <code id="f15.5.1_+3A_udash">udash</code></td>
<td>
<p>Functions to specify the path of integration, and its
derivative</p>
</td></tr>
<tr><td><code id="f15.5.1_+3A_give">give</code></td>
<td>
<p>In function <code>f15.5.1()</code>, Boolean with <code>TRUE</code>
meaning to return extra information from <code>ode()</code> and default
<code>FALSE</code> meaning to return only the evaluated function</p>
</td></tr>
<tr><td><code id="f15.5.1_+3A_startz">startz</code></td>
<td>
<p>In function <code>f15.5.1(</code>, the start position of the path</p>
</td></tr>
<tr><td><code id="f15.5.1_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>ode()</code></p>
</td></tr>
<tr><td><code id="f15.5.1_+3A_o">o</code>, <code id="f15.5.1_+3A_p">p</code></td>
<td>
<p>Real and complex objects to be coerced to each other in
<code>to_real()</code> and <code>to_complex()</code></p>
</td></tr>
<tr><td><code id="f15.5.1_+3A_y">y</code>, <code id="f15.5.1_+3A_times">times</code>, <code id="f15.5.1_+3A_func">func</code>, <code id="f15.5.1_+3A_parms">parms</code>, <code id="f15.5.1_+3A_method">method</code></td>
<td>
<p>In function <code>complex_ode()</code>,
arguments matching those of <code>ode()</code></p>
</td></tr>
<tr><td><code id="f15.5.1_+3A_t">t</code>, <code id="f15.5.1_+3A_z0">z0</code>, <code id="f15.5.1_+3A_z1">z1</code>, <code id="f15.5.1_+3A_clockwise">clockwise</code></td>
<td>
<p>Arguments for the standard path functions
<code>semicircle()</code> et seq: <code>u</code> is the primary argument
(real, <code class="reqn">0\leq u\leq 1</code>); <code>z0</code> and <code>z1</code> are
the start and end points of the path; and <code>clockwise</code> is
Boolean, indicating whether the path proceeds clockwise or not</p>
</td></tr>
<tr><td><code id="f15.5.1_+3A_time">Time</code>, <code id="f15.5.1_+3A_state">State</code>, <code id="f15.5.1_+3A_pars">Pars</code></td>
<td>
<p>arguments matchin those of standard examples
in the <code>deSolve</code> package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>hypergeo_press()</code> is the most user-friendly of the
functions documented here.  It performs integration of Gauss's ODE,
along a straight line path from the start-point to <code>z</code>.  It follows
Press et al's suggestion of start-point.
</p>
<p>Function <code>f15.5.1()</code> is a little more flexible in that it allows
the user to choose a start point and an integration path.
</p>
<p>Function <code>complex_ode()</code> is a complex generalization of
<code>ode()</code> of package <span class="pkg">deSolve</span>; function <code>hypergeo_func</code>
is an internal function, designed for use with <code>complex_ode()</code>,
that specifies the Gauss ODE which is satisified by the hypergeometric
function.
</p>
<p>Functions <code>to_real()</code> and <code>to_complex()</code> are internal
functions which coerce from real to complex and back; they are needed
because <code>ode()</code> deals only with real values.
</p>
<p>Functions <code>semicircle()</code> and <code>straight()</code> are helper
functions which specify straight or semicircular paths from <code>z0</code>
to <code>z1</code>; note that <code>f(0)=z0</code> and <code>f(1)=z1</code>.  Functions
<code>semidash()</code> and <code>straightdash()</code> provide the differential
of the path.
</p>


<h3>Note</h3>

<p>Accuracy is low compared with the other methods in the package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>References</h3>

<p>W. H. Press et al.  1997. <em>Numerical Recipes in C</em>.  Cambridge
University Press, Second Edition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo_residue">hypergeo_residue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hypergeo_press(A=pi,B=sqrt(2),C=1.4,z=1-2i)
hypergeo      (A=pi,B=sqrt(2),C=1.4,z=1-2i)


jj1 &lt;- 
f15.5.1(
    A=1.1, B=2.2, C=3.3, z=3+0.5i, startz=0.5,
        u    =function(u){semicircle(u,0.5,3+0.5i,FALSE)},
        udash=function(u){semidash(u,0.5,3+0.5i,FALSE)}
        )

jj2 &lt;-
f15.5.1(
    A=1.1, B=2.2, C=3.3, z=3+0.5i, startz=0.5,
        u    =function(u){semicircle(u,0.5,3+0.5i,TRUE)},
        udash=function(u){semidash(u,0.5,3+0.5i,TRUE)}
        )



jj3 &lt;- hypergeo(    A=1.1, B=2.2, C=3.3, z=3+0.5i)
## First one agrees with jj3=hypergeo(...), the second one does not 


# Now try the Airy Ai function;  satisfies f'' =  zf:

pars &lt;- c(kay = 1+1i, ell = 0.1+0.2i)  # not actually used
airy_ai_func &lt;- function(Time, State, Pars, u, udash) {
    with(as.list(c(to_complex(State), to_complex(Pars))), {

      z &lt;- u(Time)
      dz &lt;- udash(Time)
        
      dF &lt;- Fdash*dz
      dFdash &lt;-  z*F*dz # could use kay and ell from pars here if necessary
        
        ## coerce back to real:
        out &lt;- to_real(c(dF,dFdash))
        names(out) &lt;- names(State)
        return(list(out))
    })
}

complex_ode(
    y     = c(F = 1/3^(2/3)/gamma(2/3), Fdash= -1/3^(1/3)/gamma(1/3)),
    times = seq(0,1,by=0.1),
    func  = airy_ai_func,
    parms = pars,
    u     = function(t){straight(t,0,1)},
    udash = function(t){straightdash(t,0,1)}
)

# Look at the last line for the value at 1.
# compare gsl: Ai(1) = 0.1352924 ; Ai'(1) = -0.1591474

# ...although in this case there is actually a hypergeometric series
#  representation:

f &lt;- function(z){
    return(
        +genhypergeo(U=NULL,L=2/3,z^3/9)/3^(2/3)/gamma(2/3)
        -genhypergeo(U=NULL,L=4/3,z^3/9)/3^(1/3)/gamma(1/3)*z
        ) 
}

f(1)

</code></pre>

<hr>
<h2 id='genhypergeo'>The generalized hypergeometric function</h2><span id='topic+genhypergeo'></span><span id='topic+genhypergeo_series'></span><span id='topic+genhypergeo_contfrac'></span>

<h3>Description</h3>

<p>The generalized hypergeometric function, using either the series
expansion or the continued fraction expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genhypergeo(U, L, z, tol=0, maxiter=2000, check_mod=TRUE,
    polynomial=FALSE, debug=FALSE, series=TRUE)
genhypergeo_series(U, L, z, tol=0, maxiter=2000, check_mod=TRUE,
    polynomial=FALSE, debug=FALSE) 
genhypergeo_contfrac(U, L, z, tol = 0, maxiter = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genhypergeo_+3A_u">U</code>, <code id="genhypergeo_+3A_l">L</code></td>
<td>
<p>Upper and lower arguments respectively (real or complex)</p>
</td></tr>
<tr><td><code id="genhypergeo_+3A_z">z</code></td>
<td>
<p>Primary complex argument (see notes)</p>
</td></tr>
<tr><td><code id="genhypergeo_+3A_tol">tol</code></td>
<td>
<p>tolerance with default zero meaning to iterate until
additional terms to not change the partial sum</p>
</td></tr>
<tr><td><code id="genhypergeo_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations to perform</p>
</td></tr>
<tr><td><code id="genhypergeo_+3A_check_mod">check_mod</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to check
that the modulus of <code>z</code> is less than 1</p>
</td></tr>
<tr><td><code id="genhypergeo_+3A_polynomial">polynomial</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
evaluate the series until converged, or return a warning; and
<code>TRUE</code> meaning to return the sum of <code>maxiter</code> terms,
whether or not converged.  This is useful when either <code>A</code>
or <code>B</code> is a nonpositive integer in which case the hypergeometric
function is a polynomial</p>
</td></tr>
<tr><td><code id="genhypergeo_+3A_debug">debug</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return debugging
information and default <code>FALSE</code> meaning to return just the
evaluate</p>
</td></tr> 
<tr><td><code id="genhypergeo_+3A_series">series</code></td>
<td>
<p>In function <code>genhypergeo()</code>, Boolean argument with
default <code>TRUE</code> meaning to return the result of
<code>genhypergeo_series()</code> and <code>FALSE</code> the result of
<code>genhypergeo_contfrac()</code></p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Function <code>genhypergeo()</code> is a wrapper for functions
<code>genhypergeo_series()</code> and <code>genhypergeo_contfrac()</code>.
</p>
<p>Function <code>genhypergeo_series()</code> is the workhorse for the whole
package; every call to <code>hypergeo()</code> uses this function except for
the (apparently rare&mdash;but see the examples section) cases where
continued fractions are used.
</p>
<p>The generalized hypergeometric function [here <code>genhypergeo()</code>]
appears from time to time in the literature (eg Mathematica) as
</p>
<p style="text-align: center;"><code class="reqn">F(U,L;z) = \sum_{n=0}^\infty\frac{(u_1)_n(u_2)_n\ldots
      (u_i)_n}{(l_1)_n(l_2)_n\ldots
      (l_j)_n}\cdot\frac{z^n}{n!}</code>
</p>
<p> where
<code class="reqn">U=\left(u_1,\ldots,u_i\right)</code> and
<code class="reqn">L=\left(l_1,\ldots,l_i\right)</code> are the
&ldquo;upper&rdquo; and &ldquo;lower&rdquo; vectors respectively.  The
radius of convergence of this formula is 1.
</p>
<p>For the Confluent Hypergeometric function, use <code>genhypergeo()</code> with
length-1 vectors for arguments <code>U</code> and <code>V</code>.
</p>
<p>For the <code class="reqn">{}_0\!F_1</code> function (ie no &ldquo;upper&rdquo; arguments), use
<code>genhypergeo(NULL,L,x)</code>.
</p>
<p>See documentation for <code>genhypergeo_contfrac()</code> for details of
the continued fraction representation.
</p>


<h3>Note</h3>

<p>The radius of convergence for the series is 1 but under some
circumstances, analytic continuation defines a function over the whole
complex plane (possibly cut along <code class="reqn">(1,\infty)</code>).  Further
work would be required to implement this.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo">hypergeo</a></code>,<code><a href="#topic+genhypergeo_contfrac">genhypergeo_contfrac</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
genhypergeo(U=c(1.1,0.2,0.3), L=c(10.1,pi*4), check_mod=FALSE, z=1.12+0.2i)
genhypergeo(U=c(1.1,0.2,0.3), L=c(10.1,pi*4),z=4.12+0.2i,series=FALSE)

</code></pre>

<hr>
<h2 id='gosper'>Evaluation of the hypergeometric function using Gosper's method</h2><span id='topic+hypergeo_gosper'></span>

<h3>Description</h3>

<p>Evaluation of the hypergeometric function using Gosper's method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo_gosper(A, B, C, z, tol = 0, maxiter = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gosper_+3A_a">A</code>, <code id="gosper_+3A_b">B</code>, <code id="gosper_+3A_c">C</code></td>
<td>
<p>Parameters (real or complex)</p>
</td></tr>
<tr><td><code id="gosper_+3A_z">z</code></td>
<td>
<p>Complex argument</p>
</td></tr>
<tr><td><code id="gosper_+3A_tol">tol</code></td>
<td>
<p>tolerance (passed to <code>GCF()</code>)</p>
</td></tr>
<tr><td><code id="gosper_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gosper provides a three-term recurrence which converges when <code class="reqn">z</code> is
close to a critical point.
</p>
<p>Bill Gosper asserts that the recursion holds for values of <code class="reqn">z</code> which
are inside the cardioid <code>(sqrt(8)*cos(t)-2*cos(2t),
sqrt(8)*sin(t)-2*sin(2t))</code> (see examples section).
</p>
<p>It is suggested that the recursion should only be used when the
auxiliary parameters A, B,C are all <code class="reqn">\le 12</code> in absolute
value.
</p>


<h3>Author(s)</h3>

<p>R code by Robin K. S. Hankin, transcribed from maxima code posted by
Richard Fateman, who credited Bill Gosper
</p>


<h3>References</h3>

<p>Original email was archived at
<code>https://www.ma.utexas.edu/pipermail/maxima/2006/000126.html</code> but
does not appear there now; and the wayback machine doesn't find it
either.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo_contfrac">hypergeo_contfrac</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

hypergeo_gosper(1.1,5.1,3.1,crit())

# Compare MMA: -0.192225 + 0.692328 I

t &lt;- seq(from=0,to=2i*pi,len=100)
plot(exp(t)*(sqrt(8)-exp(t)),asp=1,type='l')
points(crit())


</code></pre>

<hr>
<h2 id='hypergeo'>The hypergeometric function</h2><span id='topic+hypergeo'></span>

<h3>Description</h3>

<p>The Hypergeometric and generalized hypergeometric functions as defined
by Abramowitz and Stegun.    Function <code>hypergeo()</code> is the user
interface to the majority of the package functionality; it dispatches to
one of a number of subsidiary functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo(A, B, C, z, tol = 0, maxiter=2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypergeo_+3A_a">A</code>, <code id="hypergeo_+3A_b">B</code>, <code id="hypergeo_+3A_c">C</code></td>
<td>
<p>Parameters for <code>hypergeo()</code></p>
</td></tr>
<tr><td><code id="hypergeo_+3A_z">z</code></td>
<td>
<p>Primary argument, complex</p>
</td></tr>
<tr><td><code id="hypergeo_+3A_tol">tol</code></td>
<td>
<p>absolute tolerance; default value of zero means to continue
iterating until the result does not change to machine precision;
strictly positive values give less accuracy but faster evaluation</p>
</td></tr>
<tr><td><code id="hypergeo_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer specifying maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hypergeometric function as defined by Abramowitz and Stegun,
equation 15.1.1, page 556 is
</p>
<p style="text-align: center;"><code class="reqn"> {}_2F_1(a,b;c;z) =
    \sum_{n=0}^\infty\frac{(a)_n(b)_n}{(c)_n}\cdot\frac{z^n}{n!}</code>
</p>

<p>where
<code class="reqn">(a)_n=a(a+1)\ldots(a+n-1)=\Gamma(a+n)/\Gamma(a)</code>
is the Pochammer symbol (6.1.22, page 256).
</p>
<p>Function <code>hypergeo()</code> is the front-end for a rather unwieldy set
of back-end functions which are called when the parameters <code>A</code>,
<code>B</code>, <code>C</code> take certain values.
</p>
<p>The general case (that is, when the parameters do not fall into a
&ldquo;special&rdquo; category), is handled by <code>hypergeo_general()</code>.
This applies whichever of the transformations given on page 559 gives
the smallest modulus for the argument <code>z</code>.
</p>
<p>Sometimes <code>hypergeo_general()</code> and all the transformations on
page 559 fail to converge, in which case <code>hypergeo()</code> uses the
continued fraction expansion <code>hypergeo_contfrac()</code>.
</p>
<p>If this fails, the function uses integration via <code>f15.3.1()</code>.
</p>


<h3>Note</h3>

<p>Abramowitz and Stegun state:
</p>
<p>&ldquo;The radius of convergence of the Gauss hypergeometric series
<code class="reqn">\ldots</code> is <code class="reqn">\left|z\right|=1</code>&rdquo; (AMS-55, section
15.1, page 556).
</p>
<p>This reference book gives the correct radius of convergence; use the
ratio test to verify it.  Thus if <code class="reqn">|z|&gt;1</code>, the hypergeometric series
will diverge and function <code>genhypergeo()</code> will fail to converge.
</p>
<p>However, the hypergeometric function is defined over the whole of the
complex plane, so analytic continuation may be used if appropriate cut
lines are used.  A cut line must join <code class="reqn">z=1</code> to (complex) infinity;
it is conventional for it to follow the real axis in a positive
direction from <code class="reqn">z=1</code> but other choices are possible.
</p>
<p>Note that in using the package one sometimes draws a
&ldquo;full precision not achieved&rdquo; warning from <code>gamma()</code>; and
complex arguments are not allowed.  I would suggest either ignoring the
warning (the error of <code>gamma()</code> is unlikely to be large) or to use
one of the bespoke functions such as <code>f15.3.4()</code> and tolerate the
slower convergence, although this is not always possible.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Abramowitz and Stegun 1955.
<em>Handbook of mathematical functions with formulas, 
graphs and mathematical tables</em> (AMS-55).
National Bureau of Standards</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo_powerseries">hypergeo_powerseries</a></code>,
<code><a href="#topic+hypergeo_contfrac">hypergeo_contfrac</a></code>, <code><a href="#topic+genhypergeo">genhypergeo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#  equation 15.1.3, page 556:
f1 &lt;- function(x){-log(1-x)/x}
f2 &lt;- function(x){hypergeo(1,1,2,x)}
f3 &lt;- function(x){hypergeo(1,1,2,x,tol=1e-10)}
x &lt;- seq(from = -0.6,to=0.6,len=14)
f1(x)-f2(x)
f1(x)-f3(x)  # Note tighter tolerance

# equation 15.1.7, p556:
g1 &lt;- function(x){log(x + sqrt(1+x^2))/x}
g2 &lt;- function(x){hypergeo(1/2,1/2,3/2,-x^2)}
g1(x)-g2(x)  # should be small 
abs(g1(x+0.1i) - g2(x+0.1i))  # should have small modulus.

# Just a random call, verified by Maple [ Hypergeom([],[1.22],0.9087) ]:
genhypergeo(NULL,1.22,0.9087)


# Little test of vectorization (warning: inefficient):
hypergeo(A=1.2+matrix(1:10,2,5)/10, B=1.4, C=1.665, z=1+2i)


# following calls test for former bugs:
hypergeo(1,2.1,4.1,1+0.1i)
hypergeo(1.1,5,2.1,1+0.1i)
hypergeo(1.9, 2.9, 1.9+2.9+4,1+0.99i) # c=a+b+4; hypergeo_cover1()


</code></pre>

<hr>
<h2 id='hypergeo_A_nonpos_int'>Hypergeometric functions for integer arguments</h2><span id='topic+hypergeo_A_nonpos_int'></span><span id='topic+hypergeo_AorB_nonpos_int'></span>

<h3>Description</h3>

<p>Hypergeometric functions for A and/or B being integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo_A_nonpos_int(A, B, C, z, tol = 0)
hypergeo_AorB_nonpos_int(A, B, C, z, tol = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypergeo_A_nonpos_int_+3A_a">A</code>, <code id="hypergeo_A_nonpos_int_+3A_b">B</code>, <code id="hypergeo_A_nonpos_int_+3A_c">C</code></td>
<td>
<p>Parameters for the hypergeometric function</p>
</td></tr>
<tr><td><code id="hypergeo_A_nonpos_int_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="hypergeo_A_nonpos_int_+3A_tol">tol</code></td>
<td>
<p>tolerance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;point&rdquo; of these functions is that if A and C (or B and C)
are identical nonpositive integers, a warning needs to be given
because the function is defined as the appropriate limit and one needs
to be sure that both A and C approach that limit at the same speed.
</p>
<p>Function <code>hypergeo_AorB_nonpos_int()</code> is a convenience wrapper
for <code>hypergeo_A_nonpos_int()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo">hypergeo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
jjR1 &lt;- hypergeo(-4, pi, 2.2 , 1+6i)
jjR2 &lt;- hypergeo(pi, -4, 2.2 , 1+6i)  # former bug
jjM &lt;- 3464.1890402837334002-353.94143580568566281i  # value given by Mathematica 


</code></pre>

<hr>
<h2 id='hypergeo_contfrac'>Continued fraction expansion of the hypergeometric function</h2><span id='topic+hypergeo_contfrac'></span><span id='topic+genhypergeo_contfrac_single'></span>

<h3>Description</h3>

<p>Continued fraction expansion of the hypergeometric and generalized
hypergeometric functions using continued fraction expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo_contfrac(A, B, C, z, tol = 0, maxiter = 2000)
genhypergeo_contfrac_single(U, L, z, tol = 0, maxiter = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypergeo_contfrac_+3A_a">A</code>, <code id="hypergeo_contfrac_+3A_b">B</code>, <code id="hypergeo_contfrac_+3A_c">C</code></td>
<td>
<p>Parameters (real or complex)</p>
</td></tr>
<tr><td><code id="hypergeo_contfrac_+3A_u">U</code>, <code id="hypergeo_contfrac_+3A_l">L</code></td>
<td>
<p>In function <code>genhypergeo_contfrac()</code>, upper and lower
arguments as in <code>genhypergeo()</code></p>
</td></tr> 
<tr><td><code id="hypergeo_contfrac_+3A_z">z</code></td>
<td>
<p>Complex argument</p>
</td></tr>
<tr><td><code id="hypergeo_contfrac_+3A_tol">tol</code></td>
<td>
<p>tolerance (passed to <code>GCF()</code>)</p>
</td></tr>
<tr><td><code id="hypergeo_contfrac_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are included in the package in the interests of
completeness, but it is not clear when it is advantageous to use
continued fraction form rather than the series form.
</p>


<h3>Note</h3>

<p>The continued fraction expression is the RHS identity 07.23.10.0001.01 of
<code>Hypergeometric2F1.pdf</code>.
</p>
<p>The function sometimes fails to converge to the correct value but no
warning is given.
</p>
<p>Function <code>genhypergeo_contfrac()</code> is documented under
<code>genhypergeo.Rd</code>. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>
</li>
<li> <p><a href="http://functions.wolfram.com/Hypergeometric2F1.pdf">http://functions.wolfram.com/Hypergeometric2F1.pdf</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+genhypergeo">genhypergeo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>hypergeo_contfrac(0.3 , 0.6 , 3.3 , 0.1+0.3i)
# Compare Maple: 1.0042808294775511972+0.17044041575976110947e-1i

genhypergeo_contfrac_single(U=0.2 , L=c(9.9,2.7,8.7) , z=1+10i)
# (powerseries does not converge)
# Compare Maple: 1.0007289707983569879 + 0.86250714217251837317e-2i

</code></pre>

<hr>
<h2 id='hypergeo_cover1'>Hypergeometric functions for special values of the parameters</h2><span id='topic+hypergeo_cover1'></span><span id='topic+hypergeo_cover2'></span><span id='topic+hypergeo_cover3'></span>

<h3>Description</h3>

<p>Hypergeometric functions for special values of the parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo_cover1(A, B, m, z, tol = 0, maxiter = 2000, method = "a", give = FALSE)
hypergeo_cover2(A, C, m, z, tol = 0, maxiter = 2000, method = "a", give = FALSE)
hypergeo_cover3(A, n, m, z, tol = 0, maxiter = 2000, method = "a", give = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypergeo_cover1_+3A_a">A</code>, <code id="hypergeo_cover1_+3A_b">B</code>, <code id="hypergeo_cover1_+3A_c">C</code></td>
<td>
<p>parameters for the hypergeometric function</p>
</td></tr>
<tr><td><code id="hypergeo_cover1_+3A_m">m</code>, <code id="hypergeo_cover1_+3A_n">n</code></td>
<td>
<p>Integers (positive or negative)</p>
</td></tr>
<tr><td><code id="hypergeo_cover1_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="hypergeo_cover1_+3A_tol">tol</code>, <code id="hypergeo_cover1_+3A_maxiter">maxiter</code></td>
<td>
<p>Numerical arguments passed to <code>genhypergeo()</code></p>
</td></tr>
<tr><td><code id="hypergeo_cover1_+3A_method">method</code></td>
<td>
<p>Method, passed to <code>f15.3.10()</code> (qv)</p>
</td></tr>
<tr><td><code id="hypergeo_cover1_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return the choice of
helper function used (eg <code>f15.3.7()</code>), and default <code>FALSE</code>
meaning to return the hypergeometric function's value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions deal with the exceptional cases listed on page
559-560.
</p>

<ul>
<li><p> Function <code>hypergeo_cover1()</code> deals with the case
<code class="reqn">C=A+B\pm m,m=0,1,2,\ldots</code>
</p>
</li>
<li><p> Function <code>hypergeo_cover2()</code> deals with the case
<code class="reqn">B=A\pm m,m=0,1,2,\ldots</code>
</p>
</li>
<li><p> Function <code>hypergeo_cover3()</code> deals with the case
<code class="reqn">C-A=0,-1,-2,\ldots</code> [elementary] and
<code class="reqn">C-A=1,2,\ldots</code> [not covered by AMS-55]
</p>
</li></ul>



<h3>Note</h3>

<p>Function <code>hypergeo_cover3()</code> is required because the
&ldquo;limiting process&rdquo; mentioned on p560, just after 15.3.14, is
not explicit.  Which is why it dispatches to
<code>w07.23.06.0026.01()</code> and <code>w07.23.06.0031.01()</code>,
documented at <code>wolfram</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo">hypergeo</a></code>,<code><a href="#topic+f15.3.10">f15.3.10</a></code>,<code><a href="#topic+wolfram">wolfram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Test hypergeo_cover1():
jjR &lt;- hypergeo(pi,pi/2,3*pi/2-4, z=0.1+0.2i)
jjM &lt;- 0.53745229690249593045 + 1.8917456473240515664i


# Test hypergeo_cover2():
jjM &lt;- -0.15888831928748121465e-5 + 0.40339599711492215912e-4i
jjR &lt;- hypergeo(pi,pi+2, 1.1 , 1+10i)  # This is 15.3.13
stopifnot(Mod(jjR-jjM)&lt;1e-10)


# Test hypergeo_cover3()
jjM &lt;- -0.24397135980533720308e-1 + 0.28819643319432922231i
jjR &lt;- hypergeo(pi, 1.4, pi+4, 1+6i)
stopifnot(Mod(jjR-jjM)&lt;1e-10)

</code></pre>

<hr>
<h2 id='hypergeo_powerseries'>The hypergeometric function as determined by power series</h2><span id='topic+hypergeo_powerseries'></span><span id='topic+hypergeo_taylor'></span><span id='topic+hypergeo_general'></span>

<h3>Description</h3>

<p>The hypergeometric function as determined by infinite
(<code>hypergeo_powerseries()</code>) or finite (<code>hypergeo_taylor()</code>)
power series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo_powerseries(A, B, C, z, tol = 0, maxiter = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypergeo_powerseries_+3A_a">A</code>, <code id="hypergeo_powerseries_+3A_b">B</code>, <code id="hypergeo_powerseries_+3A_c">C</code></td>
<td>
<p>Parameters of the hypergeometric function</p>
</td></tr>
<tr><td><code id="hypergeo_powerseries_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="hypergeo_powerseries_+3A_tol">tol</code>, <code id="hypergeo_powerseries_+3A_maxiter">maxiter</code></td>
<td>
<p>Numerical arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>hypergeo_powerseries()</code> is the primary decision-making
function of the package.  It is this function that detects degenerate
cases of the three parameters and dispatches accordingly.
Non-degenerate cases are sent to function <code>hypergeo_general()</code>.
</p>
<p>Function <code>hypergeo_taylor()</code> deals with cases where the
hypergeometric function is a polynomial.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

 
<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo">hypergeo</a></code>,<code><a href="#topic+genhypergeo">genhypergeo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

jjR &lt;- hypergeo(pi,-4,2.2,1+5i)
jjM &lt;- 1670.8287595795885335 - 204.81995157365381258i


</code></pre>

<hr>
<h2 id='hypergeo-package'>
The hypergeometric function
</h2><span id='topic+hypergeo-package'></span>

<h3>Description</h3>

<p>The hypergeometric function for the whole complex plane
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> hypergeo</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2008-04-16</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The front end function of the package is <code>hypergeo()</code>: depending on
the value of the parameters, this executes one or more of many
sub-functions.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>
<p>Maintainer: &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hypergeo(1.1,2.3,1.9 , 1+6i)

options(showHGcalls = TRUE)    # any non-null value counts as TRUE
hypergeo(4.1, 3.1, 5.1, 1+1i)  # shows trace back
options(showHGcalls = FALSE)   # reset


</code></pre>

<hr>
<h2 id='i15.3.6'>Helper functions</h2><span id='topic+i15.3.6'></span><span id='topic+i15.3.7'></span><span id='topic+i15.3.8'></span><span id='topic+i15.3.9'></span><span id='topic+j15.3.6'></span><span id='topic+j15.3.7'></span><span id='topic+j15.3.8'></span><span id='topic+j15.3.9'></span>

<h3>Description</h3>

<p>Helper functions for equations 15.3.6-15.3.9
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i15.3.6(A, B, C)
i15.3.7(A, B, C)
i15.3.8(A, B, C)
i15.3.9(A, B, C)
j15.3.6(A, B, C)
j15.3.7(A, B, C)
j15.3.8(A, B, C)
j15.3.9(A, B, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="i15.3.6_+3A_a">A</code>, <code id="i15.3.6_+3A_b">B</code>, <code id="i15.3.6_+3A_c">C</code></td>
<td>
<p>Parameters of the hypergeometric function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are named for their equation numbers in Abramowitz and
Stegun.
</p>
<p>Functions <code>i15.3.?()</code> return the factors at the beginning of
equations 15.3.6-9.  These functions return zero if the denominator is
infinite (because it includes a gamma function of a nonpositive
integer). 
</p>
<p>Functions <code>j15.3.?()</code> check for the appropriate
arguments of the gamma function being nonpositive integers.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypergeo">hypergeo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>i15.3.6(1.1, 3.2, pi)
</code></pre>

<hr>
<h2 id='is.nonpos'>Various utilities</h2><span id='topic+is.nonpos'></span><span id='topic+is.near_integer'></span><span id='topic+is.zero'></span><span id='topic+isgood'></span><span id='topic+thingfun'></span><span id='topic+crit'></span><span id='topic+lpham'></span>

<h3>Description</h3>

<p>Various utilities needing nonce functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.near_integer(i, tol=getOption("tolerance"))
is.nonpos(i)
is.zero(i)
isgood(x, tol)
thingfun(z, complex=FALSE)
crit(...)
lpham(x,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.nonpos_+3A_i">i</code></td>
<td>
<p>Numerical vector of suspected integers</p>
</td></tr>
<tr><td><code id="is.nonpos_+3A_tol">tol</code></td>
<td>
<p>Tolerance</p>
</td></tr>
<tr><td><code id="is.nonpos_+3A_x">x</code></td>
<td>
<p>Argument to <code>isgood()</code> and <code>lpham()</code></p>
</td></tr>
<tr><td><code id="is.nonpos_+3A_z">z</code></td>
<td>
<p>Complex vector</p>
</td></tr>
<tr><td><code id="is.nonpos_+3A_complex">complex</code></td>
<td>
<p>In function <code>thingfun()</code>, Boolean with default
<code>FALSE</code> meaning to return the modulus of the transforms and
<code>TRUE</code> meaning to return the complex values themselves</p>
</td></tr>
<tr><td><code id="is.nonpos_+3A_n">n</code></td>
<td>
<p>second argument to <code>lpham()</code></p>
</td></tr>
<tr><td><code id="is.nonpos_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Function <code>is.near_integer(i)</code> returns <code>TRUE</code> if
<code>i</code> is &ldquo;near&rdquo; [that is, within <code>tol</code>] an integer;
if the option is unset then <code>1e-11</code> is used.
</p>
</li>
<li><p> Function <code>is.nonpos()</code> returns <code>TRUE</code> if <code>i</code> is
near a nonpositive integer
</p>
</li>
<li><p> Function <code>is.zero()</code> returns <code>TRUE</code> if <code>i</code> is,
er, near zero
</p>
</li>
<li><p> Function <code>isgood()</code> checks for all elements of <code>x</code>
having absolute values less than <code>tol</code>
</p>
</li>
<li><p> Function <code>thingfun()</code> transforms input vector <code>z</code> by
each of the six members of the anharmonic group, viewed as a
subgroup of the Mobius group of functions.  It returns a real
six-column matrix with columns being the modulus of
<code class="reqn">z,z/(z-1),1-z,1/z,1/(1-z),1-1/z</code>.  These six columns
correspond to the primary argument in equations 15.3.3 to 15.3.9,
p551 of AMS-55
</p>
</li>
<li><p> Function <code>crit()</code> returns the two critical points,
<code class="reqn">\frac{1}{2}\pm\frac{\sqrt{3}i}{2}</code>.  These
points have unit modulus as do their six transforms by
<code>thingfun()</code>
</p>
</li>
<li><p> Function <code>lpham()</code> returns the log of the Pochhammer
function
<code class="reqn">log\left(\Gamma(x+n)/\Gamma(x)\right)</code>
</p>
</li></ul>



<h3>Note</h3>

<p>Function <code>isgood()</code> uses zero as the default tolerance (argument
<code>tol</code> passed in from <code>hypergeo()</code>);
compare the different meaning of <code>tol</code> used in
<code>is.near_integer()</code>.
</p>
<p>Here, &ldquo;integer&rdquo; means one of the sequence <code class="reqn">0,\pm 1,\pm
  2,\ldots</code> [ie <em>not</em> the Gaussian integers].
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is.near_integer(-3)

is.zero(4)
</code></pre>

<hr>
<h2 id='residue'>Evaluation of the hypergeometric function using the residue theorem</h2><span id='topic+hypergeo_residue'></span><span id='topic+hypergeo_residue_general'></span><span id='topic+hypergeo_residue_close_to_crit_single'></span><span id='topic+hypergeo_residue_close_to_crit_multiple'></span>

<h3>Description</h3>

<p>Expansion of the hypergeometric function
using the residue theorem; useful for when the primary argument is close
to the critical points <code class="reqn">1/2\pm i\sqrt{3}/2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo_residue_general(A, B, C, z, r, O=z, tol=0, maxiter=2000)
hypergeo_residue_close_to_crit_single(A, B, C, z, strategy='A', tol=0, maxiter=2000)
hypergeo_residue_close_to_crit_multiple(A, B, C, z, strategy='A', tol=0, maxiter=2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residue_+3A_a">A</code>, <code id="residue_+3A_b">B</code>, <code id="residue_+3A_c">C</code></td>
<td>
<p>Parameters (real or complex)</p>
</td></tr>
<tr><td><code id="residue_+3A_z">z</code></td>
<td>
<p>Complex argument</p>
</td></tr>
<tr><td><code id="residue_+3A_tol">tol</code>, <code id="residue_+3A_maxiter">maxiter</code></td>
<td>
<p>tolerance and maximum number of iterations (passed to <code>hypergeo()</code>)</p>
</td></tr>
<tr><td><code id="residue_+3A_r">r</code>, <code id="residue_+3A_o">O</code></td>
<td>
<p>Radius and center of circle to integrate over</p>
</td></tr>
<tr><td><code id="residue_+3A_strategy">strategy</code></td>
<td>
<p>Indicates which strategy to use.  Strategy &lsquo;A&rsquo;
means to use the critical point as the centre of the circle and
strategy &lsquo;B&rsquo; means to use <code class="reqn">z</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are not really intended for the user; <code>hypergeo()</code>
uses <code>hypergeo_residue_close_to_crit_multiple()</code> when
<code class="reqn">\left|z-c\right|</code> is less than <code class="reqn">0.1</code> (hardwired) for
<code class="reqn">c</code> being either of the two critical points.  Infinite regress is
avoided because the contour is always more than this distance from the
critical points.
</p>
<p>These functions use the residue theorem
<code class="reqn">f\left(z_0\right)=\oint_C\frac{f(z)\,dz}{z-z_0}</code> to evaluate the hypergeometric function near the two
critical points <code class="reqn">1/2\pm i\sqrt{3}/2</code>.  These
points are problematic because all of the transformations listed under
<code>thingfun()</code> take the points either to themselves or each other.
</p>
<p>At these points the ratio of successive terms in the hypergeometric
series tends to one and thus numerical summation is difficult.
</p>
<p>The hypergeometric function, however, is not at all badly behaved near
these critical points (see examples); but OTOH there do not seem to be
any identities for the hypergeometric function at these points.
</p>
<p>I have not investigated in detail whether strategy &lsquo;A&rsquo; or
&lsquo;B&rsquo; is better.  I would expect that &lsquo;A&rsquo; is faster but
&lsquo;B&rsquo; more accurate, on the grounds that &lsquo;A&rsquo; uses a contour
whose closest approach to the critical point is further than that of
&lsquo;B&rsquo;; but &lsquo;B&rsquo; uses a contour which does not vary in
distance from <code class="reqn">z</code>.
</p>
<p>But both seem to be fairly accurate and fairly fast, and I have not
systematically investigated the pros and cons.
</p>


<h3>Note</h3>

<p>The residue theorem appears to be absurdly accurate for numerical evaluation
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

 

<ul>
<li><p> W. Buhring 1987.  &ldquo;An analytic continuation of the
hypergeometric series&rdquo;, <em>Siam J. Math. Anal.</em> 18(3)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+buhring">buhring</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- 1/2-sqrt(3)/2i
c2 &lt;- 1/2+sqrt(3)/2i

a1_R &lt;- hypergeo(1/2,1/3,pi,c1)
a1_M &lt;- 1.0154051314906669 + 0.0544835896509068i

x &lt;- y &lt;- seq(from=-0.1,to=0.1,len=100)
elliptic::view(x,y,hypergeo(1/2,1,1/3,outer(x,1i*y,"+")))

</code></pre>

<hr>
<h2 id='shanks'>Evaluation of the hypergeometric function using Shanks's method</h2><span id='topic+shanks'></span><span id='topic+hypergeo_shanks'></span><span id='topic+genhypergeo_shanks'></span>

<h3>Description</h3>

<p>Evaluation of the hypergeometric function using Shanks transformation of
successive sums
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergeo_shanks(A,B,C,z,maxiter=20)
genhypergeo_shanks(U,L,z,maxiter=20)
shanks(Last,This,Next)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shanks_+3A_a">A</code>, <code id="shanks_+3A_b">B</code>, <code id="shanks_+3A_c">C</code></td>
<td>
<p>Parameters (real or complex)</p>
</td></tr>
<tr><td><code id="shanks_+3A_u">U</code>, <code id="shanks_+3A_l">L</code></td>
<td>
<p>Upper and lower vectors</p>
</td></tr>
<tr><td><code id="shanks_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="shanks_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="shanks_+3A_last">Last</code>, <code id="shanks_+3A_this">This</code>, <code id="shanks_+3A_next">Next</code></td>
<td>
<p>Three successive convergents</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Shanks transformation of successive partial sums is
</p>
<p style="text-align: center;"><code class="reqn">S(n)=\frac{A_{n+1}A_{n-1}-A_n^2}{A_{n+1}-2A_n+A_{n-1}}</code>
</p>

<p>and if the <code class="reqn">A_n</code> tend to a limit then the sequence <code class="reqn">S(n)</code>
often converges more rapidly than <code class="reqn">A_n</code>.  However, the denominator
is susceptible to catastrophic rounding under fixed-precision
arithmetic and it is difficult to know when to stop iterating.
</p>


<h3>Note</h3>

<p>The 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

 

<ul>
<li><p> Shanks, D. (1955). &ldquo;Non-linear transformation of
divergent and slowly convergent sequences&rdquo;, <em>Journal of
Mathematics and Physics</em> 34:1-42
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+buhring">buhring</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
hypergeo_shanks(1/2,1/3,pi,z= 0.1+0.2i)
</code></pre>

<hr>
<h2 id='wolfram'>Various functions taken from the Wolfram Functions Site</h2><span id='topic+wolfram'></span><span id='topic+w07.23.06.0026.01'></span><span id='topic+w07.23.06.0026.01_bit1'></span><span id='topic+w07.23.06.0026.01_bit2'></span><span id='topic+w07.23.06.0026.01_bit3_a'></span><span id='topic+w07.23.06.0026.01_bit3_b'></span><span id='topic+w07.23.06.0026.01_bit3_c'></span><span id='topic+w07.23.06.0029.01'></span><span id='topic+w07.23.06.0031.01'></span><span id='topic+w07.23.06.0031.01_bit1'></span><span id='topic+w07.23.06.0031.01_bit2'></span>

<h3>Description</h3>

<p>Various functions taken from the Wolfram Functions Site
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w07.23.06.0026.01(A, n, m, z, tol = 0, maxiter = 2000, method = "a")
w07.23.06.0026.01_bit1(A, n, m, z, tol = 0)
w07.23.06.0026.01_bit2(A, n, m, z, tol = 0, maxiter = 2000)
w07.23.06.0026.01_bit3_a(A, n, m, z, tol = 0)
w07.23.06.0026.01_bit3_b(A, n, m, z, tol = 0)
w07.23.06.0026.01_bit3_c(A, n, m, z, tol = 0)
w07.23.06.0029.01(A, n, m, z, tol = 0, maxiter = 2000)
w07.23.06.0031.01(A, n, m, z, tol = 0, maxiter = 2000)
w07.23.06.0031.01_bit1(A, n, m, z, tol = 0, maxiter = 2000)
w07.23.06.0031.01_bit2(A, n, m, z, tol = 0, maxiter = 2000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wolfram_+3A_a">A</code></td>
<td>
<p>Parameter of hypergeometric function</p>
</td></tr>
<tr><td><code id="wolfram_+3A_m">m</code>, <code id="wolfram_+3A_n">n</code></td>
<td>
<p>Integers</p>
</td></tr>
<tr><td><code id="wolfram_+3A_z">z</code></td>
<td>
<p>Primary complex argument</p>
</td></tr>
<tr><td><code id="wolfram_+3A_tol">tol</code>, <code id="wolfram_+3A_maxiter">maxiter</code></td>
<td>
<p>Numerical arguments as per <code>genhypergeo()</code></p>
</td></tr>
<tr><td><code id="wolfram_+3A_method">method</code></td>
<td>
<p>Character, specifying method to  be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>method</code> argument is described at <code>f15.3.10</code>.  All
functions' names follow the conventions in
<code>Hypergeometric2F1.pdf</code>.
</p>

<ul>
<li><p> Function <code>w07.23.06.0026.01(A, n, m, z)</code> returns
<code class="reqn">{}_2F_1(A,A+n,A+m,z)</code> where <code class="reqn">m</code> and
<code class="reqn">n</code> are nonnegative integers with <code class="reqn">m\geq n</code>.
</p>
</li>
<li><p> Function <code>w07.23.06.0029.01(A, n, m, z)</code> returns
<code class="reqn">{}_2F_1(A,A+n,A-m,z)</code>.
</p>
</li>
<li><p> Function <code>w07.23.06.0031.01(A, n, m, z)</code> returns
<code class="reqn">{}_2F_1(A,A+n,A+m,z)</code> with <code class="reqn">m\leq
    n</code>. 
</p>
</li></ul>
 


<h3>Note</h3>

<p>These functions use the <code>psigamma()</code> function which does not yet
take complex arguments; this means that complex values for <code>A</code>
are not supported.  I'm working on it.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="http://functions.wolfram.com/Hypergeometric2F1.pdf">http://functions.wolfram.com/Hypergeometric2F1.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+f15.3.10">f15.3.10</a></code>,<code><a href="#topic+hypergeo">hypergeo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Here we catch some answers from Maple (jjM) and compare it with R's:


jjM &lt;- 0.95437201847068289095 + 0.80868687461954479439i # Maple's answer
jjR &lt;- w07.23.06.0026.01(A=1.1 , n=1 , m=4 , z=1+1i) 
# [In practice, one would type 'hypergeo(1.1, 2.1, 5.1, 1+1i)']

stopifnot(Mod(jjM - jjR) &lt; 1e-10)


jjM &lt;- -0.25955090546083991160e-3 - 0.59642767921444716242e-3i
jjR &lt;- w07.23.06.0029.01(A=4.1 , n=1 , m=1 , z=1+4i)
# [In practice, one would type 'hypergeo(4.1, 3.1, 5.1, 1+1i)']

stopifnot(Mod(jjM - jjR) &lt; 1e-15)

jjM &lt;- 0.33186808222278923715e-1 - 0.40188208572232037363e-1i
jjR &lt;- w07.23.06.0031.01(6.7,2,1,2+1i)
# [In practice, one would type 'hypergeo(6.7, 8.7, 7.7, 2+1i)']
stopifnot(Mod(jjM - jjR) &lt; 1e-10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
