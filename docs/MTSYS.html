<!DOCTYPE html><html><head><title>Help for package MTSYS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MTSYS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc_cofactor'><p>Function to calculate a cofactor matrix</p></a></li>
<li><a href='#calc_M_hat'><p>Function to estimate M value (M hat) for a family of T methods.</p></a></li>
<li><a href='#calc_overall_predicton_eta'><p>Function to calculate overall prediction eta for the T method</p></a></li>
<li><a href='#diagnosis'><p>Function to predict a diagnosis for a family of Mahalanobis-Taguchi (MT)</p>
methods</a></li>
<li><a href='#diagnosis.MT'><p>Diagnosis method for the Mahalanobis-Taguchi (MT) method</p></a></li>
<li><a href='#diagnosis.MTA'><p>Diagnosis method for the Mahalanobis-Taguchi Adjoint (MTA) method</p></a></li>
<li><a href='#diagnosis.RT'><p>Diagnosis method for the Recognition-Taguchi (RT) method</p></a></li>
<li><a href='#forecasting'><p>Function to predict a forecasting for a family of Taguchi (T) methods</p></a></li>
<li><a href='#forecasting.T1'><p>Forecasting method for the T1 method</p></a></li>
<li><a href='#forecasting.Ta'><p>Forecasting method for the Ta method</p></a></li>
<li><a href='#forecasting.Tb'><p>Forecasting method for the Tb method</p></a></li>
<li><a href='#general_diagnosis.MT'><p>General function to implement a diagnosis method for a family of</p>
Mahalanobis-Taguchi (MT) methods</a></li>
<li><a href='#general_forecasting.T'><p>General function to implement a forecasting method for a family of Taguchi (T)</p>
methods</a></li>
<li><a href='#general_MT'><p>General function to generate a unit space for a family of</p>
Mahalanobis-Taguchi (MT) methods</a></li>
<li><a href='#general_T'><p>General function to generate a prediction expression for a family of Taguchi</p>
(T) methods</a></li>
<li><a href='#generates_dimensionality_reduction_function'><p>Function to generate a data transformation function for the</p>
Recognition-Taguchi (RT) method</a></li>
<li><a href='#generates_model'><p>Wrapper function to generate a model for a family of Taguchi (T) methods</p></a></li>
<li><a href='#generates_normalization_function'><p>Function to generate the data normalization function</p></a></li>
<li><a href='#generates_transformation_functions_T1'><p>Function to generate data transformation functions for the T1 methods</p></a></li>
<li><a href='#generates_transformation_functions_Tb'><p>Function to generate data transformation functions for the Tb methods</p></a></li>
<li><a href='#generates_unit_space'><p>Wrapper function to generate a unit space for a family of</p>
Mahalanobis-Taguchi (MT) methods</a></li>
<li><a href='#MT'><p>Function to generate a unit space for the Mahalanobis-Taguchi (MT) method</p></a></li>
<li><a href='#MTA'><p>Function to generate a unit space for the Mahalanobis-Taguchi Adjoint (MTA)</p>
method</a></li>
<li><a href='#RT'><p>Function to generate a unit space for the Recognition-Taguchi (RT) method</p></a></li>
<li><a href='#T1'><p>Function to generate a prediction expression for the two-sided Taguchi (T1)</p>
method</a></li>
<li><a href='#Ta'><p>Function to generate a prediction expression for the Ta method</p></a></li>
<li><a href='#Tb'><p>Function to generate a prediction expression for the Tb method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods in Mahalanobis-Taguchi (MT) System</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-07-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Mahalanobis-Taguchi (MT) system is a collection of multivariate
    analysis methods developed for the field of quality engineering. MT system
    consists of two families depending on their purpose. One is a family of
    Mahalanobis-Taguchi (MT) methods (in the broad sense) for diagnosis (see
    Woodall, W. H., Koudelik, R., Tsui, K. L., Kim, S. B., Stoumbos, Z. G., and
    Carvounis, C. P. (2003) &lt;<a href="https://doi.org/10.1198%2F004017002188618626">doi:10.1198/004017002188618626</a>&gt;) and the other is a
    family of Taguchi (T) methods for forecasting (see Kawada, H., and Nagata, Y.
    (2015) &lt;<a href="https://doi.org/10.17929%2Ftqs.1.12">doi:10.17929/tqs.1.12</a>&gt;). The MT package contains three basic methods
    for the family of MT methods and one basic method for the family of T
    methods. The MT method (in the narrow sense), the Mahalanobis-Taguchi
    Adjoint (MTA) methods, and the Recognition-Taguchi (RT) method are for the
    MT method and the two-sided Taguchi (T1) method is for the family of T
    methods. In addition, the Ta and Tb methods, which are the improved versions
    of the T1 method, are included.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/okayaa/MTSYS">https://github.com/okayaa/MTSYS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/okayaa/MTSYS/issues">https://github.com/okayaa/MTSYS/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-09-10 12:11:17 UTC; OKAYAA</td>
</tr>
<tr>
<td>Author:</td>
<td>Akifumi Okayama [aut, cre],
  Masato Ohkubo [ctb],
  Yasushi Nagata [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Akifumi Okayama &lt;akifumi.okayama@akane.waseda.jp&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-09-10 16:44:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc_cofactor'>Function to calculate a cofactor matrix</h2><span id='topic+calc_cofactor'></span>

<h3>Description</h3>

<p><code>calc_cofactor</code> calculates a cofactor matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_cofactor(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_cofactor_+3A_data">data</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). All data 
should be continuous values and should not have missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>calc_cofactor</code> returns a cofactor matrix of size p x p.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MTA">MTA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset                            
iris_versicolor &lt;- iris[61:100, -5] 
                            
calc_cofactor(cov(iris_versicolor))
 
</code></pre>

<hr>
<h2 id='calc_M_hat'>Function to estimate M value (M hat) for a family of T methods.</h2><span id='topic+calc_M_hat'></span>

<h3>Description</h3>

<p><code>calc_M_hat</code> estimates M values (M hat) for the T method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_M_hat(X, beta_hat, eta_hat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_M_hat_+3A_x">X</code></td>
<td>
<p>Matrix with n rows (samples) and q columns (variables). The
independent variable data after the data transformation. All data
should be continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="calc_M_hat_+3A_beta_hat">beta_hat</code></td>
<td>
<p>Vector with length q. Estimated proportionality constants
between each independent variable and the dependent
variable.</p>
</td></tr>
<tr><td><code id="calc_M_hat_+3A_eta_hat">eta_hat</code></td>
<td>
<p>Vector with length q. Estimated squared signal-to-noise ratios
(S/N) coresponding to <code>beta_hat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with length n. Estimated M values (M hat).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_T">general_T</a></code> and <code><a href="#topic+general_forecasting.T">general_forecasting.T</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The value of the dependent variable of the following samples mediates
# in the stackloss dataset.
stackloss_center &lt;- stackloss[c(9, 10, 11, 20, 21), ]

# The following samples are data other than the unit space data and the test
# data.
stackloss_signal &lt;- stackloss[-c(2, 9, 10, 11, 12, 19, 20, 21), ]

# The following settings are same as the T1 method.
model &lt;- general_T(unit_space_data = stackloss_center,
                   signal_space_data = stackloss_signal,
                   generates_transform_functions =
                                       generates_transformation_functions_T1,
                   includes_transformed_data = TRUE)

modified_eta_hat &lt;- model$eta_hat
modified_eta_hat[3] &lt;- 0

(modified_M_hat &lt;- calc_M_hat(model$X, model$beta_hat, modified_eta_hat))

</code></pre>

<hr>
<h2 id='calc_overall_predicton_eta'>Function to calculate overall prediction eta for the T method</h2><span id='topic+calc_overall_predicton_eta'></span>

<h3>Description</h3>

<p><code>calc_M_hat</code> calculates the overall prediction eta for the T method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_overall_predicton_eta(M, M_hat, subtracts_V_e = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_overall_predicton_eta_+3A_m">M</code></td>
<td>
<p>Vector with length n. The (true) value of the dependent
variable after the data trasformation.</p>
</td></tr>
<tr><td><code id="calc_overall_predicton_eta_+3A_m_hat">M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data trasformation.</p>
</td></tr>
<tr><td><code id="calc_overall_predicton_eta_+3A_subtracts_v_e">subtracts_V_e</code></td>
<td>
<p>If <code>TRUE</code>, then the error variance is subtracted in
the numerator when calculating <code>eta_hat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. Overall prediction eta which is used to measure the
estimation accuracy.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_T">general_T</a></code> and <code><a href="#topic+general_forecasting.T">general_forecasting.T</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The value of the dependent variable of the following samples mediates
# in the stackloss dataset.
stackloss_center &lt;- stackloss[c(9, 10, 11, 20, 21), ]

# The following samples are data other than the unit space data and the test
# data.
stackloss_signal &lt;- stackloss[-c(2, 9, 10, 11, 12, 19, 20, 21), ]

# The following settings are same as the T1 method.
model &lt;- general_T(unit_space_data = stackloss_center,
                   signal_space_data = stackloss_signal,
                   generates_transform_functions =
                                       generates_transformation_functions_T1,
                   subtracts_V_e = TRUE,
                   includes_transformed_data = TRUE)

modified_eta_hat &lt;- model$eta_hat
modified_eta_hat[3] &lt;- 0

modified_M_hat &lt;- calc_M_hat(model$X, model$beta_hat, modified_eta_hat)

(modified_overall_predicton_eta &lt;-
                            calc_overall_predicton_eta(model$M,
                                                       modified_M_hat,
                                                       subtracts_V_e = TRUE))

</code></pre>

<hr>
<h2 id='diagnosis'>Function to predict a diagnosis for a family of Mahalanobis-Taguchi (MT)
methods</h2><span id='topic+diagnosis'></span>

<h3>Description</h3>

<p><code>diagnosis</code> is a generic function. For details, see
<code><a href="#topic+diagnosis.MT">diagnosis.MT</a></code>, <code><a href="#topic+diagnosis.MTA">diagnosis.MTA</a></code>,
<code><a href="#topic+diagnosis.RT">diagnosis.RT</a></code> or <code><a href="#topic+general_diagnosis.MT">general_diagnosis.MT</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosis(unit_space, newdata, threshold, includes_transformed_newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnosis_+3A_unit_space">unit_space</code></td>
<td>
<p>Object generated as a unit space.</p>
</td></tr>
<tr><td><code id="diagnosis_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The
data are used to calculate the desired distances from the
unit space. All data should be continuous values and should
not have missing values.</p>
</td></tr>
<tr><td><code id="diagnosis_+3A_threshold">threshold</code></td>
<td>
<p>Numeric specifying the threshold value to classify each
sample into positive (<code>TRUE</code>) or negative
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="diagnosis_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
for <code>newdata</code> are included in a
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>Vector with length n. Distances from the unit space to each
sample.</p>
</td></tr>
<tr><td><code>le_threshold</code></td>
<td>
<p>Vector with length n. Logical values indicating the
distance of each sample is less than or equal to the
threhold value (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>Numeric value to classify the sample into positive or
negative.</p>
</td></tr>
<tr><td><code>unit_space</code></td>
<td>
<p>Object passed by <code>unit_space</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+diagnosis.MT">diagnosis.MT</a></code>, <code><a href="#topic+diagnosis.MTA">diagnosis.MTA</a></code>, and
<code><a href="#topic+diagnosis.RT">diagnosis.RT</a></code>
</p>

<hr>
<h2 id='diagnosis.MT'>Diagnosis method for the Mahalanobis-Taguchi (MT) method</h2><span id='topic+diagnosis.MT'></span>

<h3>Description</h3>

<p><code>diagnosis.MT</code> (via <code><a href="#topic+diagnosis">diagnosis</a></code>) calculates the
mahalanobis distance based on the unit space generated by <code><a href="#topic+MT">MT</a></code>
or <code><a href="#topic+generates_unit_space">generates_unit_space</a></code>(..., method = &quot;MT&quot;) and classifies
each sample into positive (<code>TRUE</code>) or negative (<code>FALSE</code>) by
comparing the values with the set threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MT'
diagnosis(unit_space, newdata, threshold = 4,
  includes_transformed_newdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnosis.MT_+3A_unit_space">unit_space</code></td>
<td>
<p>Object of class &quot;MT&quot; generated by <code><a href="#topic+MT">MT</a></code> or
<code><a href="#topic+generates_unit_space">generates_unit_space</a></code>(..., method = &quot;MT&quot;).</p>
</td></tr>
<tr><td><code id="diagnosis.MT_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The
data are used to calculate the desired distances from the
unit space. All data should be continuous values and should
not have missing values.</p>
</td></tr>
<tr><td><code id="diagnosis.MT_+3A_threshold">threshold</code></td>
<td>
<p>Numeric specifying the threshold value to classify each
sample into positive (<code>TRUE</code>) or negative
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="diagnosis.MT_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
for <code>newdata</code> are included in a
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>diagnosis.MT</code> (via <code><a href="#topic+diagnosis">diagnosis</a></code>) returns a list
containing the following components:
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>Vector with length n. Distances from the unit space to each
sample.</p>
</td></tr>
<tr><td><code>le_threshold</code></td>
<td>
<p>Vector with length n. Logical values indicating the
distance of each sample is less than or equal to the
threhold value (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>Numeric value to classify the sample into positive or
negative.</p>
</td></tr>
<tr><td><code>unit_space</code></td>
<td>
<p>Object of class &quot;MT&quot; passed by <code>unit_space</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation. q equals p.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taguchi, G. (1995). Pattern Recognition and Quality Engineering (1).
<em>Journal of Quality Engineering Society, 3</em>(2), 2-5. (In Japanese)
</p>
<p>Taguchi, G., Wu, Y., &amp; Chodhury, S. (2000).
<em>Mahalanobis-Taguchi System.</em> McGraw-Hill Professional.
</p>
<p>Taguchi, G., &amp; Jugulum, R. (2002). <em>The Mahalanobis-Taguchi strategy:
A pattern technology system.</em> John Wiley &amp; Sons.
</p>
<p>Woodall, W. H., Koudelik, R., Tsui, K. L., Kim, S. B., Stoumbos, Z. G., &amp;
Carvounis, C. P. (2003). A review and analysis of the Mahalanobis-Taguchi
system. <em>Technometrics, 45</em>(1), 1-15.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_diagnosis.MT">general_diagnosis.MT</a></code> and <code><a href="#topic+MT">MT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset
iris_versicolor &lt;- iris[61:100, -5]

unit_space_MT &lt;- MT(unit_space_data = iris_versicolor,
                    includes_transformed_data = TRUE)

# 10 data for each kind (setosa, versicolor, virginica) in the iris dataset
iris_test &lt;- iris[c(1:10, 51:60, 101:111), -5]

diagnosis_MT &lt;- diagnosis(unit_space = unit_space_MT,
                          newdata = iris_test,
                          threshold = 4,
                          includes_transformed_newdata = TRUE)

(diagnosis_MT$distance)
(diagnosis_MT$le_threshold)

</code></pre>

<hr>
<h2 id='diagnosis.MTA'>Diagnosis method for the Mahalanobis-Taguchi Adjoint (MTA) method</h2><span id='topic+diagnosis.MTA'></span>

<h3>Description</h3>

<p><code>diagnosis.MTA</code> (via <code><a href="#topic+diagnosis">diagnosis</a></code>) calculates the distance
based on the unit space generated by <code><a href="#topic+MTA">MTA</a></code> or
<code><a href="#topic+generates_unit_space">generates_unit_space</a></code>(..., method = &quot;MTA&quot;) and classifies each
sample into positive (<code>TRUE</code>) or negative (<code>FALSE</code>) by comparing
the values with the set threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MTA'
diagnosis(unit_space, newdata, threshold,
  includes_transformed_newdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnosis.MTA_+3A_unit_space">unit_space</code></td>
<td>
<p>Object of class &quot;MTA&quot; generated by <code><a href="#topic+MTA">MTA</a></code> or
<code><a href="#topic+generates_unit_space">generates_unit_space</a></code>(..., method = &quot;MTA&quot;).</p>
</td></tr>
<tr><td><code id="diagnosis.MTA_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The
data are used to calculate the desired distances from the
unit space. All data should be continuous values and should
not have missing values.</p>
</td></tr>
<tr><td><code id="diagnosis.MTA_+3A_threshold">threshold</code></td>
<td>
<p>Numeric specifying the threshold value to classify each
sample into positive (<code>TRUE</code>) or negative
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="diagnosis.MTA_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
for <code>newdata</code> are included in a
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>diagnosis.MTA</code> (via <code><a href="#topic+diagnosis">diagnosis</a></code>) returns a list
containing the following components:
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>Vector with length n. Distances from the unit space to each
sample.</p>
</td></tr>
<tr><td><code>le_threshold</code></td>
<td>
<p>Vector with length n. Logical values indicating the
distance of each sample is less than or equal to the
threhold value (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>Numeric value to classify the sample into positive or
negative.</p>
</td></tr>
<tr><td><code>unit_space</code></td>
<td>
<p>Object of class &quot;MTA&quot; passed by <code>unit_space</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation. q equals p.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taguchi, G. &amp; Kanetaka, T. (2002). <em>Engineering Technical Development
in MT System - Lecture on Applied Quality.</em> Japanese Standards
Association. (In Japanese)
</p>
<p>Taguchi, G., &amp; Jugulum, R. (2002). <em>The Mahalanobis-Taguchi strategy:
A pattern technology system.</em> John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_diagnosis.MT">general_diagnosis.MT</a></code> and <code><a href="#topic+MTA">MTA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset
iris_versicolor &lt;- iris[61:100, -5]

unit_space_MTA &lt;- MTA(unit_space_data = iris_versicolor,
                      includes_transformed_data = TRUE)

# 10 data for each kind (setosa, versicolor, virginica) in the iris dataset
iris_test &lt;- iris[c(1:10, 51:60, 101:111), -5]

diagnosis_MTA &lt;- diagnosis(unit_space = unit_space_MTA,
                           newdata = iris_test,
                           threshold = 0.5,
                           includes_transformed_newdata = TRUE)

(diagnosis_MTA$distance)
(diagnosis_MTA$le_threshold)

</code></pre>

<hr>
<h2 id='diagnosis.RT'>Diagnosis method for the Recognition-Taguchi (RT) method</h2><span id='topic+diagnosis.RT'></span>

<h3>Description</h3>

<p><code>diagnosis.RT</code> (via <code><a href="#topic+diagnosis">diagnosis</a></code>) calculates the
distance based on the unit space generated by <code><a href="#topic+RT">RT</a></code> or
<code><a href="#topic+generates_unit_space">generates_unit_space</a></code>(..., method = &quot;RT&quot;) and classifies each
sample into positive (<code>TRUE</code>) or negative (<code>FALSE</code>) by comparing
the values with the set threshold value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RT'
diagnosis(unit_space, newdata, threshold,
  includes_transformed_newdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnosis.RT_+3A_unit_space">unit_space</code></td>
<td>
<p>Object of class &quot;RT&quot; generated by <code><a href="#topic+RT">RT</a></code> or
<code><a href="#topic+generates_unit_space">generates_unit_space</a></code>(..., method = &quot;RT&quot;).</p>
</td></tr>
<tr><td><code id="diagnosis.RT_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The
data are used to calculate the desired distances from the
unit space. All data should be continuous values and should
not have missing values.</p>
</td></tr>
<tr><td><code id="diagnosis.RT_+3A_threshold">threshold</code></td>
<td>
<p>Numeric specifying the threshold value to classify each
sample into positive (<code>TRUE</code>) or negative (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="diagnosis.RT_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
for <code>newdata</code> are included in a
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>diagnosis.RT</code> (via <code><a href="#topic+diagnosis">diagnosis</a></code>) returns a list
containing the following components:
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>Vector with length n. Distances from the unit space to each
sample.</p>
</td></tr>
<tr><td><code>le_threshold</code></td>
<td>
<p>Vector with length n. Logical values indicating the
distance of each sample is less than or equal to the
threhold value (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>Numeric value to classify the sample into positive or
negative.</p>
</td></tr>
<tr><td><code>unit_space</code></td>
<td>
<p>Object of class &quot;RT&quot; passed by <code>unit_space</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation. q is always
2.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taguchi, G. (2006). Objective Function and Generic Function (11).
<em>Journal of Quality Engineering Society, 14</em>(2), 5-9. (In Japanese)
</p>
<p>Huda, F., Kajiwara, I., Hosoya, N., &amp; Kawamura, S. (2013). Bolt loosening
analysis and diagnosis by non-contact laser excitation vibration tests.
<em>Mechanical systems and signal processing, 40</em>(2), 589-604.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_diagnosis.MT">general_diagnosis.MT</a></code> and <code><a href="#topic+RT">RT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset
iris_versicolor &lt;- iris[61:100, -5]

unit_space_RT &lt;- RT(unit_space_data = iris_versicolor,
                    includes_transformed_data = TRUE)

# 10 data for each kind (setosa, versicolor, virginica) in the iris dataset
iris_test &lt;- iris[c(1:10, 51:60, 101:111), -5]

diagnosis_RT &lt;- diagnosis(unit_space = unit_space_RT,
                          newdata = iris_test,
                          threshold = 0.2,
                          includes_transformed_newdata = TRUE)

(diagnosis_RT$distance)
(diagnosis_RT$le_threshold)

</code></pre>

<hr>
<h2 id='forecasting'>Function to predict a forecasting for a family of Taguchi (T) methods</h2><span id='topic+forecasting'></span>

<h3>Description</h3>

<p><code>forecasting</code> is a generic function. For details, see
<code><a href="#topic+forecasting.T1">forecasting.T1</a></code>, <code><a href="#topic+forecasting.Ta">forecasting.Ta</a></code>,
<code><a href="#topic+forecasting.Tb">forecasting.Tb</a></code> or <code><a href="#topic+general_forecasting.T">general_forecasting.T</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecasting(model, newdata, includes_transformed_newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecasting_+3A_model">model</code></td>
<td>
<p>Object generated as a model.</p>
</td></tr>
<tr><td><code id="forecasting_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The
Data to be estimated. All data should be continuous values
and should not have missing values.</p>
</td></tr>
<tr><td><code id="forecasting_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
for <code>newdata</code> are included in a
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data trasformation.</p>
</td></tr>
<tr><td><code>y_hat</code></td>
<td>
<p>Vector with length n. The estimated values after the inverse
transformation from <code>M_hat</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Object passed by <code>model</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+forecasting.T1">forecasting.T1</a></code>, <code><a href="#topic+forecasting.Ta">forecasting.Ta</a></code>, and
<code><a href="#topic+forecasting.Tb">forecasting.Tb</a></code>
</p>

<hr>
<h2 id='forecasting.T1'>Forecasting method for the T1 method</h2><span id='topic+forecasting.T1'></span>

<h3>Description</h3>

<p><code>forecasting.T1</code> (via <code><a href="#topic+forecasting">forecasting</a></code>) estimates the dependent
values based on the T1 model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'T1'
forecasting(model, newdata, includes_transformed_newdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecasting.T1_+3A_model">model</code></td>
<td>
<p>Object of class &quot;T1&quot; generated by <code><a href="#topic+T1">T1</a></code> or
<code><a href="#topic+generates_model">generates_model</a></code>(..., method = &quot;T1&quot;).</p>
</td></tr>
<tr><td><code id="forecasting.T1_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The
Data to be estimated. All data should be continuous values
and should not have missing values.</p>
</td></tr>
<tr><td><code id="forecasting.T1_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
for <code>newdata</code> are included in a
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data transformation.</p>
</td></tr>
<tr><td><code>y_hat</code></td>
<td>
<p>Vector with length n. The estimated values after the inverse
transformation from <code>M_hat</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Object of class &quot;T1&quot; passed by <code>model</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation. q equals p.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taguchi, G. (2006). Objective Function and Generic Function (12).
<em>Journal of Quality Engineering Society, 14</em>(3), 5-9. (In Japanese)
</p>
<p>Inou, A., Nagata, Y., Horita, K., &amp; Mori, A. (2012). Prediciton Accuracies
of Improved Taguchi's T Methods Compared to those of Multiple Regresssion
Analysis. <em>Journal of the Japanese Society for Quality Control,
42</em>(2), 103-115. (In Japanese)
</p>
<p>Kawada, H., &amp; Nagata, Y. (2015). An application of a generalized inverse
regression estimator to Taguchi's T-Method. <em>Total Quality Science,
1</em>(1), 12-21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_forecasting.T">general_forecasting.T</a></code> and <code><a href="#topic+T1">T1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The value of the dependent variable of the following samples mediates
# in the stackloss dataset.
stackloss_center &lt;- stackloss[c(9, 10, 11, 20, 21), ]

# The following samples are data other than the unit space data and the test
# data.
stackloss_signal &lt;- stackloss[-c(2, 9, 10, 11, 12, 19, 20, 21), ]

model_T1 &lt;- T1(unit_space_data = stackloss_center,
               signal_space_data = stackloss_signal,
               subtracts_V_e = TRUE,
               includes_transformed_data = TRUE)

# The following test samples are chosen casually.
stackloss_test &lt;- stackloss[c(2, 12, 19), -4]

forecasting_T1 &lt;- forecasting(model = model_T1,
                              newdata = stackloss_test,
                              includes_transformed_newdata = TRUE)

(forecasting_T1$y_hat) # Estimated values
(stackloss[c(2, 12, 19), 4]) # True values

</code></pre>

<hr>
<h2 id='forecasting.Ta'>Forecasting method for the Ta method</h2><span id='topic+forecasting.Ta'></span>

<h3>Description</h3>

<p><code>forecasting.Ta</code> (via <code><a href="#topic+forecasting">forecasting</a></code>) estimates the dependent
values based on the Ta model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Ta'
forecasting(model, newdata, includes_transformed_newdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecasting.Ta_+3A_model">model</code></td>
<td>
<p>Object of class &quot;Ta&quot; generated by <code><a href="#topic+Ta">Ta</a></code> or
<code><a href="#topic+generates_model">generates_model</a></code>(..., method = &quot;Ta&quot;).</p>
</td></tr>
<tr><td><code id="forecasting.Ta_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The
Data to be estimated. All data should be continuous values
and should not have missing values.</p>
</td></tr>
<tr><td><code id="forecasting.Ta_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
for <code>newdata</code> are included in a
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data transformation.</p>
</td></tr>
<tr><td><code>y_hat</code></td>
<td>
<p>Vector with length n. The estimated values after the inverse
transformation from <code>M_hat</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Object of class &quot;Ta&quot; passed by <code>model</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation. q equals p.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Inou, A., Nagata, Y., Horita, K., &amp; Mori, A. (2012). Prediciton Accuracies
of Improved Taguchi's T Methods Compared to those of Multiple Regresssion
Analysis. <em>Journal of the Japanese Society for Quality Control,
42</em>(2), 103-115. (In Japanese)
</p>
<p>Kawada, H., &amp; Nagata, Y. (2015). An application of a generalized inverse
regression estimator to Taguchi's T-Method. <em>Total Quality Science,
1</em>(1), 12-21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_forecasting.T">general_forecasting.T</a></code> and <code><a href="#topic+Ta">Ta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model_Ta &lt;- Ta(sample_data = stackloss[-c(2, 12, 19), ],
               subtracts_V_e = TRUE,
               includes_transformed_data = TRUE)

forecasting_Ta &lt;- forecasting(model = model_Ta,
                              newdata = stackloss[c(2, 12, 19), -4],
                              includes_transformed_newdata = TRUE)

(forecasting_Ta$y_hat) # Estimated values
(stackloss[c(2, 12, 19), 4]) # True values

</code></pre>

<hr>
<h2 id='forecasting.Tb'>Forecasting method for the Tb method</h2><span id='topic+forecasting.Tb'></span>

<h3>Description</h3>

<p><code>forecasting.Tb</code> (via <code><a href="#topic+forecasting">forecasting</a></code>) estimates the dependent
values based on the Tb model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Tb'
forecasting(model, newdata, includes_transformed_newdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecasting.Tb_+3A_model">model</code></td>
<td>
<p>Object of class &quot;Tb&quot; generated by <code><a href="#topic+Tb">Tb</a></code> or
<code><a href="#topic+generates_model">generates_model</a></code>(..., method = &quot;Tb&quot;).</p>
</td></tr>
<tr><td><code id="forecasting.Tb_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The
Data to be estimated. All data should be continuous values
and should not have missing values.</p>
</td></tr>
<tr><td><code id="forecasting.Tb_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
for <code>newdata</code> are included in a
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data transformation.</p>
</td></tr>
<tr><td><code>y_hat</code></td>
<td>
<p>Vector with length n. The estimated values after the inverse
transformation from <code>M_hat</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Object of class &quot;Tb&quot; passed by <code>model</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation. q equals p.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Inou, A., Nagata, Y., Horita, K., &amp; Mori, A. (2012). Prediciton Accuracies
of Improved Taguchi's T Methods Compared to those of Multiple Regresssion
Analysis. <em>Journal of the Japanese Society for Quality Control,
42</em>(2), 103-115. (In Japanese)
</p>
<p>Kawada, H., &amp; Nagata, Y. (2015). An application of a generalized inverse
regression estimator to Taguchi's T-Method. <em>Total Quality Science,
1</em>(1), 12-21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_forecasting.T">general_forecasting.T</a></code> and <code><a href="#topic+Tb">Tb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model_Tb &lt;- Tb(sample_data = stackloss[-c(2, 12, 19), ],
               subtracts_V_e = TRUE,
               includes_transformed_data = TRUE)

forecasting_Tb &lt;- forecasting(model = model_Tb,
                              newdata = stackloss[c(2, 12, 19), -4],
                              includes_transformed_newdata = TRUE)

(forecasting_Tb$y_hat) # Estimated values
(stackloss[c(2, 12, 19), 4]) # True values

</code></pre>

<hr>
<h2 id='general_diagnosis.MT'>General function to implement a diagnosis method for a family of 
Mahalanobis-Taguchi (MT) methods</h2><span id='topic+general_diagnosis.MT'></span>

<h3>Description</h3>

<p><code>general_diagnosis.MT</code> is the general function that implements a 
diagnosis method for a family of Mahalanobis-Taguchi (MT) methods. Each 
diagnosis method of a family of MT methods can be implemented by setting 
the parameters of this function appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general_diagnosis.MT(unit_space, newdata, threshold,
  includes_transformed_newdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="general_diagnosis.MT_+3A_unit_space">unit_space</code></td>
<td>
<p>Object generated as a unit space.</p>
</td></tr>
<tr><td><code id="general_diagnosis.MT_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The 
data are used to calculate the desired distances from the 
unit space. All data should be continuous values and should 
not have missing values.</p>
</td></tr>
<tr><td><code id="general_diagnosis.MT_+3A_threshold">threshold</code></td>
<td>
<p>Numeric specifying the threshold value to classify each 
sample into positive (<code>TRUE</code>) or negative 
(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="general_diagnosis.MT_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data 
for <code>newdata</code> are included in a 
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>distance</code></td>
<td>
<p>Vector with length n. Distances from the unit space to each 
sample.</p>
</td></tr>
<tr><td><code>le_threshold</code></td>
<td>
<p>Vector with length n. Logical values indicating the 
distance of each sample is less than or equal to the 
threhold value (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>Numeric value to classify the sample into positive or 
negative. </p>
</td></tr>
<tr><td><code>unit_space</code></td>
<td>
<p>Object passed by <code>unit_space</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of independent variables after the data transformation. 
According to the data transoformation function, q may be equal to p.</p>
</td></tr>  
<tr><td><code>x</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the 
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+diagnosis.MT">diagnosis.MT</a></code>, <code><a href="#topic+diagnosis.MTA">diagnosis.MTA</a></code>, and 
<code><a href="#topic+diagnosis.RT">diagnosis.RT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>                          
# 40 data for versicolor in the iris dataset                            
iris_versicolor &lt;- iris[61:100, -5] 

# The following settings are same as the MT method.                          
unit_space &lt;- general_MT(unit_space_data = iris_versicolor, 
                         generates_transform_function = 
                                            generates_normalization_function,
                         calc_A = function(x) solve(cor(x)),  
                         includes_transformed_data = TRUE)

# 10 data for each kind (setosa, versicolor, virginica) in the iris dataset                         
iris_test &lt;- iris[c(1:10, 51:60, 101:111), -5]
                         
diagnosis &lt;- general_diagnosis.MT(unit_space = unit_space, 
                                  newdata = iris_test, 
                                  threshold = 4,
                                  includes_transformed_newdata = TRUE)
                              
(diagnosis$distance)
(diagnosis$le_threshold)                          

</code></pre>

<hr>
<h2 id='general_forecasting.T'>General function to implement a forecasting method for a family of Taguchi (T)
methods</h2><span id='topic+general_forecasting.T'></span>

<h3>Description</h3>

<p><code>general_forecasting.T</code> is the general function that implements a
forecasting method for a family of Taguchi (T) methods. Each forecasting
method of a family of T methods can be implemented by setting the
parameters of this function appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general_forecasting.T(model, newdata, includes_transformed_newdata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="general_forecasting.T_+3A_model">model</code></td>
<td>
<p>Object generated as a model.</p>
</td></tr>
<tr><td><code id="general_forecasting.T_+3A_newdata">newdata</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables). The
data are used to calculate the desired distances from the
unit space. All data should be continuous values and should
not have missing values.</p>
</td></tr>
<tr><td><code id="general_forecasting.T_+3A_includes_transformed_newdata">includes_transformed_newdata</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
for <code>newdata</code> are included in a
return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data trasformation.</p>
</td></tr>
<tr><td><code>y_hat</code></td>
<td>
<p>Vector with length n. The estimated values after the inverse
transformation from <code>M_hat</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Object passed by <code>model</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples for <code>newdata</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If <code>includes_transformed_newdata</code> is <code>TRUE</code>, then the
transformed data for <code>newdata</code> are included.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+forecasting.T1">forecasting.T1</a></code>, <code><a href="#topic+forecasting.Ta">forecasting.Ta</a></code>, and
<code><a href="#topic+forecasting.Tb">forecasting.Tb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The value of the dependent variable of the following samples mediates
# in the stackloss dataset.
stackloss_center &lt;- stackloss[c(9, 10, 11, 20, 21), ]

# The following samples are data other than the unit space data and the test
# data.
stackloss_signal &lt;- stackloss[-c(2, 9, 10, 11, 12, 19, 20, 21), ]

# The following settings are same as the T1 method.
model &lt;- general_T(unit_space_data = stackloss_center,
                   signal_space_data = stackloss_signal,
                   generates_transform_functions =
                                       generates_transformation_functions_T1,
                   subtracts_V_e = TRUE,
                   includes_transformed_data = TRUE)

# The following test samples are chosen casually.
stackloss_test &lt;- stackloss[c(2, 12, 19), -4]

forecasting &lt;- general_forecasting.T(model = model,
                                     newdata = stackloss_test,
                                     includes_transformed_newdata = TRUE)

(forecasting$y_hat) # Estimated values
(stackloss[c(2, 12, 19), 4]) # True values

</code></pre>

<hr>
<h2 id='general_MT'>General function to generate a unit space for a family of 
Mahalanobis-Taguchi (MT) methods</h2><span id='topic+general_MT'></span>

<h3>Description</h3>

<p><code>general_MT</code> is a (higher-order) general function that generates a unit 
space for a family of Mahalanobis-Taguchi (MT) methods. Each MT method can 
be implemented by setting the parameters of this function appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general_MT(unit_space_data, calc_A, generates_transform_function,
  includes_transformed_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="general_MT_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables).
Data to generate the unit space. All data should be 
continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="general_MT_+3A_calc_a">calc_A</code></td>
<td>
<p>Function that returns A in a quadratic form x'Ax. <code>calc_A</code> 
takes the transformed data as an (only) argument.</p>
</td></tr>
<tr><td><code id="general_MT_+3A_generates_transform_function">generates_transform_function</code></td>
<td>
<p>Function that takes <code>unit_space_data</code> 
as an (only) argument and returns a 
data transformation function. The data 
transformation function takes data as 
an (only) argument and returns the 
transformed data.</p>
</td></tr>
<tr><td><code id="general_MT_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data 
are included in a return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>q x q matrix calculated by <code>calc_A</code>.</p>
</td></tr>
<tr><td><code>calc_A</code></td>
<td>
<p>Function passed by <code>calc_A</code>.</p>
</td></tr>
<tr><td><code>transforms_data</code></td>
<td>
<p>Data transformation function generated from 
<code>generates_transform_function</code> based on 
<code>unit_space_data</code>.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>Vector with length n. Distances from the unit space to each 
sample.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of independent variables after the data transformation. 
According to the data transoformation function, q may be equal to p.</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the 
transformed data are included.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MT">MT</a></code>, <code><a href="#topic+MTA">MTA</a></code> and <code><a href="#topic+RT">RT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset                            
iris_versicolor &lt;- iris[61:100, -5] 

# The following settings are same as the MT method.                          
unit_space &lt;- general_MT(unit_space_data = iris_versicolor, 
                         generates_transform_function = 
                                            generates_normalization_function,
                         calc_A = function(x) solve(cor(x)),  
                         includes_transformed_data = TRUE)
                         
(unit_space$distance)

</code></pre>

<hr>
<h2 id='general_T'>General function to generate a prediction expression for a family of Taguchi
(T) methods</h2><span id='topic+general_T'></span>

<h3>Description</h3>

<p><code>general_T</code> is a (higher-order) general function that generates a
prediction expression for a family of Taguchi (T) methods. Each T method
can be implemented by setting the parameters of this function appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>general_T(unit_space_data, signal_space_data, generates_transform_functions,
  subtracts_V_e = TRUE, includes_transformed_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="general_T_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and (p + 1) columns
(variables). The 1 ~ p th columns are independent
variables and the (p + 1) th column is a dependent
variable. Underlying data to obtain a representative
point for the normalization of the
<code>signal_space_data</code>. All data should be
continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="general_T_+3A_signal_space_data">signal_space_data</code></td>
<td>
<p>Matrix with m rows (samples) and (p + 1) columns
(variables). The 1 ~ p th columns are independent
variables and the (p + 1) th column is a dependent
variable. Underlying data to generate a prediction
expression. All data should be continuous values
and should not have missing values.</p>
</td></tr>
<tr><td><code id="general_T_+3A_generates_transform_functions">generates_transform_functions</code></td>
<td>
<p>A function that takes the
<code>unit_space_data</code> as an (only)
argument and returns a list containing
three functions. A data transformation
function for independent variables is
the first component, a data
transformation function for a
dependent variable is the second
component, and an inverse function of
the data transformation function for a
dependent variable is the third
component. The data transformation
function for independent variables
takes independent variable data (a
matrix of p columns) as an (only)
argument and returns the transformed
independent variable data. The data
transformation function for a
dependent variable takes dependent
variable data (a vector) as an (only)
argument and returns the transformed
dependent variable data. The inverse
function of the data transformation
for a dependent variable takes the
transformed dependent variable data (a
vector) as an (only) argument and
returns the untransformed dependent
variable data.</p>
</td></tr>
<tr><td><code id="general_T_+3A_subtracts_v_e">subtracts_V_e</code></td>
<td>
<p>If <code>TRUE</code>, then the error variance is subtracted in
the numerator when calculating <code>eta_hat</code>.</p>
</td></tr>
<tr><td><code id="general_T_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
are included in a return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>beta_hat</code></td>
<td>
<p>Vector with length q. Estimated proportionality constants
between each independent variable and the dependent
variable.</p>
</td></tr>
<tr><td><code>subtracts_V_e</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then <code>eta_hat</code> was
calculated without subtracting the error variance in
the numerator.</p>
</td></tr>
<tr><td><code>eta_hat</code></td>
<td>
<p>Vector with length q. Estimated squared signal-to-noise
ratios (S/N) coresponding to <code>beta_hat</code>.</p>
</td></tr>
<tr><td><code>M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data transformation for
<code>signal_space_data</code>.</p>
</td></tr>
<tr><td><code>overall_prediction_eta</code></td>
<td>
<p>Numeric. The overall squared signal-to-noise
ratio (S/N).</p>
</td></tr>
<tr><td><code>transforms_independent_data</code></td>
<td>
<p>Data transformation function generated
from <code>generates_transform_functions</code>
based on <code>unit_space_data</code>. The
function for independent variables takes
independent variable data (a matrix of p
columns) as an (only) argument and
returns the transformed independent
variable data.</p>
</td></tr>
<tr><td><code>transforms_dependent_data</code></td>
<td>
<p>Data transformation function generated in
<code>generates_transform_functions</code> based
on the <code>unit_space_data</code>. The
function for a dependent variable takes
dependent variable data (a vector) as an
(only) argument and returns the
transformed dependent variable data.</p>
</td></tr>
<tr><td><code>inverses_transformed_dependent_data</code></td>
<td>
<p>Inverse function generated in the
<code>generates_transform_functions</code>
based on <code>unit_space_data</code>.
The function of the takes the
transformed dependent variable
data (a vector) as an (only)
argument and returns the
dependent variable data inversed
from the transformed dependent
variable data.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The number of samples for <code>signal_space_data</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of independent variables after the data transformation.
According to the data transoformation function, q may be equal to
p.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the
independent variable data after the data transformation for the
<code>signal_space_data</code> are included.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the (true)
value of the dependent variable after the data transformation for
the <code>signal_space_data</code> are included.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+T1">T1</a></code>, <code><a href="#topic+Ta">Ta</a></code>, and <code><a href="#topic+Tb">Tb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The value of the dependent variable of the following samples mediates
# in the stackloss dataset.
stackloss_center &lt;- stackloss[c(9, 10, 11, 20, 21), ]

# The following samples are data other than the unit space data and the test
# data.
stackloss_signal &lt;- stackloss[-c(2, 9, 10, 11, 12, 19, 20, 21), ]

# The following settings are same as the T1 method.
model &lt;- general_T(unit_space_data = stackloss_center,
                   signal_space_data = stackloss_signal,
                   generates_transform_functions =
                                       generates_transformation_functions_T1,
                   subtracts_V_e = TRUE,
                   includes_transformed_data = TRUE)

(model$M_hat)

</code></pre>

<hr>
<h2 id='generates_dimensionality_reduction_function'>Function to generate a data transformation function for the
Recognition-Taguchi (RT) method</h2><span id='topic+generates_dimensionality_reduction_function'></span>

<h3>Description</h3>

<p><code>generates_dimensionality_reduction_function</code> returns the data
transformation function for the Recognition-Taguchi (RT) method based on
the <code>unit_space_data</code>. The function reduces the dimensionality of data
into 2 synthetic variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generates_dimensionality_reduction_function(unit_space_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generates_dimensionality_reduction_function_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables).
Data to generate the unit space. All data should be
continuous values and should not have missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function is returned which takes an n x p matrix as an (only)
argument and returns a dimensionality-reduced n x 2 data frame with
named columns; Y_1 and Y_2.
</p>


<h3>References</h3>

<p>Taguchi, G. (2006). Objective Function and Generic Function (11).
<em>Journal of Quality Engineering Society, 14</em>(2), 5-9. (In Japanese)
</p>
<p>Huda, F., Kajiwara, I., Hosoya, N., &amp; Kawamura, S. (2013). Bolt loosening
analysis and diagnosis by non-contact laser excitation vibration tests.
<em>Mechanical systems and signal processing, 40</em>(2), 589-604.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RT">RT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset
iris_versicolor &lt;- iris[61:100, -5]

reduces_dimensionality &lt;-
                 generates_dimensionality_reduction_function(iris_versicolor)

is.function(reduces_dimensionality) # TRUE

</code></pre>

<hr>
<h2 id='generates_model'>Wrapper function to generate a model for a family of Taguchi (T) methods</h2><span id='topic+generates_model'></span>

<h3>Description</h3>

<p><code>generates_model</code> generates a model for a family of Taguchi (MT) methods.
The model of <code><a href="#topic+T1">T1</a></code> method, <code><a href="#topic+Ta">Ta</a></code> method or the
<code><a href="#topic+Tb">Tb</a></code> method can be generated by passing a method name
(character) into a parameter <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generates_model(unit_space_data, signal_space_data, sample_data,
  method = c("T1", "Ta", "Tb"), subtracts_V_e = TRUE,
  includes_transformed_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generates_model_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Used only for the T1 method. Matrix with n rows
(samples) and (p + 1) columns (variables). The 1 ~ p
th columns are independent variables and the (p + 1)
th column is a dependent variable. Underlying data
to obtain a representative point for the
normalization of <code>signal_space_data</code>. All data
should be continuous values and should not have
missing values.</p>
</td></tr>
<tr><td><code id="generates_model_+3A_signal_space_data">signal_space_data</code></td>
<td>
<p>Used only for the T1 method. Matrix with m rows
(samples) and (p + 1) columns (variables). The
1 ~ p th columns are independent variables and the
(p + 1) th column is a dependent variable.
Underlying data to generate a prediction
expression. All data should be continuous values
and should not have missing values.</p>
</td></tr>
<tr><td><code id="generates_model_+3A_sample_data">sample_data</code></td>
<td>
<p>Used for the Ta and the Tb methods. Matrix with n rows
(samples) and (p + 1) columns (variables). The 1 ~ p th
columns are independent variables and the (p + 1) th
column is a dependent variable. All data should be
continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="generates_model_+3A_method">method</code></td>
<td>
<p>Character to designate a method. Currently, &quot;MT&quot;, &quot;MTA&quot;, and
&quot;RT&quot; are available.</p>
</td></tr>
<tr><td><code id="generates_model_+3A_subtracts_v_e">subtracts_V_e</code></td>
<td>
<p>If <code>TRUE</code>, then the error variance is subtracted in
the numerator when calculating <code>eta_hat</code>.</p>
</td></tr>
<tr><td><code id="generates_model_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
are included in a return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A returned object depends on the selected method. See <code><a href="#topic+T1">T1</a></code>,
<code><a href="#topic+Ta">Ta</a></code> or <code><a href="#topic+Tb">Tb</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+T1">T1</a></code>, <code><a href="#topic+Ta">Ta</a></code>, <code><a href="#topic+Tb">Tb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The value of the dependent variable of the following samples mediates
# in the stackloss dataset.
stackloss_center &lt;- stackloss[c(9, 10, 11, 20, 21), ]

# The following samples are data other than the unit space data and the test
# data.
stackloss_signal &lt;- stackloss[-c(2, 9, 10, 11, 12, 19, 20, 21), ]

# The following test samples are chosen casually.
stackloss_test &lt;- stackloss[c(2, 12, 19), -4]

# T1 method
model_T1 &lt;- generates_model(unit_space_data = stackloss_center,
                            signal_space_data = stackloss_signal,
                            method = "T1",
                            subtracts_V_e = TRUE)

forecasting_T1 &lt;- forecasting(model = model_T1,
                              newdata = stackloss_test)

(forecasting_T1$y_hat)

# Ta method
model_Ta &lt;- generates_model(sample_data =
                                   rbind(stackloss_center, stackloss_signal),
                            method = "Ta",
                            subtracts_V_e = TRUE)

forecasting_Ta &lt;- forecasting(model = model_Ta,
                              newdata = stackloss_test)

(forecasting_Ta$y_hat)

# Tb method
model_Tb &lt;- generates_model(sample_data =
                                   rbind(stackloss_center, stackloss_signal),
                            method = "Tb",
                            subtracts_V_e = TRUE)

forecasting_Tb &lt;- forecasting(model = model_Tb,
                              newdata = stackloss_test)

(forecasting_Tb$y_hat)

</code></pre>

<hr>
<h2 id='generates_normalization_function'>Function to generate the data normalization function</h2><span id='topic+generates_normalization_function'></span>

<h3>Description</h3>

<p><code>generates_normalization_function</code> returns the data normalization
function. The data normalization function is generated based on
<code>unit_space_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generates_normalization_function(unit_space_data, unit_space_center,
  unit_space_scale, is_scaled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generates_normalization_function_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables).
Data to generate the unit space. All data should be
continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="generates_normalization_function_+3A_unit_space_center">unit_space_center</code></td>
<td>
<p>Vector with length p. The values are subtrahends in
normalization. If missing, the mean for each
column of <code>unit_space_data</code> is used for
normalization.</p>
</td></tr>
<tr><td><code id="generates_normalization_function_+3A_unit_space_scale">unit_space_scale</code></td>
<td>
<p>Vector with length p. The values are divisors in
normalization. If missing and <code>is_scaled</code> is
<code>TRUE</code>, then the unbiased standard deviation
for each column of <code>unit_space_data</code> is used
for normalization.</p>
</td></tr>
<tr><td><code id="generates_normalization_function_+3A_is_scaled">is_scaled</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default value), normalization is
conducted by subtracting <code>unit_space_center</code> and
dividing by <code>unit_space_scale</code>. If <code>FALSE</code>,
normalization is conducted by subtracting
<code>unit_space_center</code> only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function is returned which takes an n x p matrix as an (only)
argument and returns a normalized n x p matrix. The normalization
is conducted based on <code>unit_space_data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MT">MT</a></code> and <code><a href="#topic+MTA">MTA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset
iris_versicolor &lt;- iris[61:100, -5]

normalizes_data &lt;- generates_normalization_function(iris_versicolor)

is.function(normalizes_data) # TRUE

</code></pre>

<hr>
<h2 id='generates_transformation_functions_T1'>Function to generate data transformation functions for the T1 methods</h2><span id='topic+generates_transformation_functions_T1'></span>

<h3>Description</h3>

<p><code>generates_transformation_functions_T1</code> is the argument for the 
parameter <code>generates_transform_functions</code> in <code>genera_T</code>, which 
is used in the T1 method. In addtion, the Ta method also uses this function 
for the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generates_transformation_functions_T1(unit_space_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generates_transformation_functions_T1_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and (p + 1) columns 
(variables). Data to generate the unit space. All 
data should be continuous values and should not have 
missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>generates_transformation_functions_T1</code> returns a list 
containing three functions. For the first component, the data 
transformation function for independent variables is a function 
that subtracts the mean of each independent variable. For the 
second component, the data transformation function for a dependent 
variable is a function that subtracts the mean of a dependent 
variable. For the third component, the inverse function of the data 
transformation function for a dependent variable is a function that 
adds the mean of a dependent variable. The mean used is the mean of 
the <code>unit_space_data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+T1">T1</a></code> and <code><a href="#topic+Ta">Ta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
# The value of the dependent variable of the following samples mediates  
# in the stackloss dataset.
stackloss_center &lt;- stackloss[c(9, 10, 11, 20, 21), ] 
      
tmp &lt;- generates_transformation_functions_T1(stackloss_center)
mean_subtraction_function &lt;- tmp[[1]]
subtracts_M_0 &lt;- tmp[[2]]
adds_M_0 &lt;- tmp[[3]] 

is.function(mean_subtraction_function) # TRUE
is.function(subtracts_M_0) # TRUE
is.function(adds_M_0) # TRUE

</code></pre>

<hr>
<h2 id='generates_transformation_functions_Tb'>Function to generate data transformation functions for the Tb methods</h2><span id='topic+generates_transformation_functions_Tb'></span>

<h3>Description</h3>

<p><code>generates_transformation_functions_Tb</code> is the argument for the 
parameter <code>generates_transform_functions</code> in <code>genera_T</code>, which 
is used in the Tb method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generates_transformation_functions_Tb(sample_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generates_transformation_functions_Tb_+3A_sample_data">sample_data</code></td>
<td>
<p>Matrix with n rows (samples) and (p + 1) columns 
(variables). The Tb method uses all data to generate the 
unit space. All data should be continuous values and 
should not have missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>generates_transformation_functions_Tb</code> returns a list 
containing three functions. For the first component, the data 
transformation function for independent variables is a function 
that subtracts the center of each independent variable. The center 
is determined in a specific manner for the Tb method. The center 
consists of each sample value which maximizes the signal-to-noise 
ratio (S/N) per independent variable. The values are determined 
independently so that different samples may be selected for 
different variables. For the second component, the data 
transformation function for a dependent variable is a function that 
subtracts the dependent variable of the sample which maximizes the 
S/N per independent variable. For the third component, the inverse 
function of the data transformation function for a dependent 
variable is a function that adds the weighted mean of a dependent 
variable. The weighted mean is calculated based on the S/N and the 
frequency of being selected in independent variables.
</p>


<h3>References</h3>

<p>Inou, A., Nagata, Y., Horita, K., &amp; Mori, A. (2012). Prediciton Accuracies 
of Improved Taguchi's T Methods Compared to those of Multiple Regresssion 
Analysis. <em>Journal of the Japanese Society for Quality Control, 
42</em>(2), 103-115. (In Japanese) 
</p>
<p>Kawada, H., &amp; Nagata, Y. (2015). An application of a generalized inverse 
regression estimator to Taguchi's T-Method. <em>Total Quality Science, 
1</em>(1), 12-21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tb">Tb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The value of the dependent variable of the following samples mediates  
# in the stackloss dataset.
stackloss_center &lt;- stackloss[c(9, 10, 11, 20, 21), ] 
    
tmp &lt;- generates_transformation_functions_Tb(stackloss_center)
center_subtraction_function &lt;- tmp[[1]]
subtracts_ys &lt;- tmp[[2]]
adds_M_0 &lt;- tmp[[3]] 

is.function(center_subtraction_function) # TRUE
is.function(subtracts_ys) # TRUE
is.function(adds_M_0) # TRUE

</code></pre>

<hr>
<h2 id='generates_unit_space'>Wrapper function to generate a unit space for a family of
Mahalanobis-Taguchi (MT) methods</h2><span id='topic+generates_unit_space'></span>

<h3>Description</h3>

<p><code>generates_unit_space</code> generates a unit space for a family of
Mahalanobis-Taguchi (MT) methods. The unit space of <code><a href="#topic+MT">MT</a></code> method,
<code><a href="#topic+MTA">MTA</a></code> method or <code><a href="#topic+RT">RT</a></code> method can be generated by
passing a method name (character) into a parameter <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generates_unit_space(unit_space_data, method = c("MT", "MTA", "RT"),
  includes_transformed_data = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generates_unit_space_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables).
Data to generate the unit space. All data should be
continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="generates_unit_space_+3A_method">method</code></td>
<td>
<p>Character to designate a method. Currently, &quot;MT&quot;, &quot;MTA&quot;, and
&quot;RT&quot; are available.</p>
</td></tr>
<tr><td><code id="generates_unit_space_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
are included in a return object.</p>
</td></tr>
<tr><td><code id="generates_unit_space_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+solve">solve</a></code> for computing the inverse of
the correlation matrix in <code><a href="#topic+MT">MT</a></code> and <code><a href="#topic+RT">RT</a></code>
method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A returned object depends on the selected method. See <code><a href="#topic+MT">MT</a></code>,
<code><a href="#topic+MTA">MTA</a></code> or <code><a href="#topic+RT">RT</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MT">MT</a></code>, <code><a href="#topic+MTA">MTA</a></code>, <code><a href="#topic+RT">RT</a></code>, and
<code><a href="base.html#topic+solve">solve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset
iris_versicolor &lt;- iris[61:100, -5]

# 10 data for each kind (setosa, versicolor, virginica) in the iris dataset
iris_test &lt;- iris[c(1:10, 51:60, 101:111), -5]

# MT method
unit_space_MT &lt;- generates_unit_space(unit_space_data = iris_versicolor,
                                      method = "MT")

diagnosis_MT &lt;- diagnosis(unit_space = unit_space_MT,
                          newdata = iris_test,
                          threshold = 4)

(diagnosis_MT$distance)
(diagnosis_MT$le_threshold)

# MTA method
unit_space_MTA &lt;- generates_unit_space(unit_space_data = iris_versicolor,
                                       method = "MTA")

diagnosis_MTA &lt;- diagnosis(unit_space = unit_space_MTA,
                           newdata = iris_test,
                           threshold = 0.5)

(diagnosis_MTA$distance)
(diagnosis_MTA$le_threshold)

# RT method
unit_space_RT &lt;- generates_unit_space(unit_space_data = iris_versicolor,
                                      method = "RT")

diagnosis_RT &lt;- diagnosis(unit_space = unit_space_RT,
                          newdata = iris_test,
                          threshold = 0.2)

(diagnosis_RT$distance)
(diagnosis_RT$le_threshold)

</code></pre>

<hr>
<h2 id='MT'>Function to generate a unit space for the Mahalanobis-Taguchi (MT) method</h2><span id='topic+MT'></span>

<h3>Description</h3>

<p><code>MT</code> generates a unit space for the Mahalanobis-Taguchi (MT) method. In
<code><a href="#topic+general_MT">general_MT</a></code>, the inversed correlation matrix is used for A and
the data are normalized based on <code>unit_space_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MT(unit_space_data, includes_transformed_data = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MT_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables).
Data to generate the unit space. All data should be
continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="MT_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
are included in a return object.</p>
</td></tr>
<tr><td><code id="MT_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+solve">solve</a></code> for computing the inverse of
the correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MT</code> returns an object of S3 <a href="base.html#topic+class">class</a> &quot;MT&quot;. An object
of class &quot;MT&quot; is a list containing the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>p x p (q x q) matrix. Inversed correlation matrix of
<code>unit_space_data</code> (the transformed data).</p>
</td></tr>
<tr><td><code>calc_A</code></td>
<td>
<p><code>function(x) solve(cor(x), ...)</code>.</p>
</td></tr>
<tr><td><code>transforms_data</code></td>
<td>
<p>Function to be generated from
<code><a href="#topic+generates_normalization_function">generates_normalization_function</a></code> based
on <code>unit_space_data</code>.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>Vector with length n. Distances from the unit space to each
sample.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation. q is equal
to p.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the
transformed data are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taguchi, G. (1995). Pattern Recognition and Quality Engineering (1).
<em>Journal of Quality Engineering Society, 3</em>(2), 2-5. (In Japanese)
</p>
<p>Taguchi, G., Wu, Y., &amp; Chodhury, S. (2000).
<em>Mahalanobis-Taguchi System.</em> McGraw-Hill Professional.
</p>
<p>Taguchi, G., &amp; Jugulum, R. (2002). <em>The Mahalanobis-Taguchi strategy:
A pattern technology system.</em> John Wiley &amp; Sons.
</p>
<p>Woodall, W. H., Koudelik, R., Tsui, K. L., Kim, S. B., Stoumbos, Z. G., &amp;
Carvounis, C. P. (2003). A review and analysis of the Mahalanobis-Taguchi
system. <em>Technometrics, 45</em>(1), 1-15.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+solve">solve</a></code>, <code><a href="#topic+general_MT">general_MT</a></code>,
<code><a href="#topic+generates_normalization_function">generates_normalization_function</a></code>, and
<code><a href="#topic+diagnosis.MT">diagnosis.MT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset
iris_versicolor &lt;- iris[61:100, -5]

unit_space_MT &lt;- MT(unit_space_data = iris_versicolor,
                    includes_transformed_data = TRUE)

# The following tol is a parameter passed to solve function.
unit_space_MT &lt;- MT(unit_space_data = iris_versicolor,
                    includes_transformed_data = TRUE,
                    tol = 1e-9)

(unit_space_MT$distance)

</code></pre>

<hr>
<h2 id='MTA'>Function to generate a unit space for the Mahalanobis-Taguchi Adjoint (MTA)
method</h2><span id='topic+MTA'></span>

<h3>Description</h3>

<p><code>MTA</code> generates a unit space for the Mahalanobis-Taguchi Adjoint (MTA)
method. In <code><a href="#topic+general_MT">general_MT</a></code>, cofactor matrix is used for A and
the data are normalized based on <code>unit_space_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MTA(unit_space_data, includes_transformed_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MTA_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables).
Data to generate the unit space. All data should be
continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="MTA_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
are included in a return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>MTA</code> returns an object of S3 <a href="base.html#topic+class">class</a> &quot;MTA&quot;. An
object of class &quot;MTA&quot; is a list containing the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>p x p (q x q) matrix. Cofactor matrix of <code>unit_space_data</code>
(the transformed data).</p>
</td></tr>
<tr><td><code>calc_A</code></td>
<td>
<p><code>calc_cofactor</code>.</p>
</td></tr>
<tr><td><code>transforms_data</code></td>
<td>
<p>Function to be generated from the
<code><a href="#topic+generates_normalization_function">generates_normalization_function</a></code> based
on the <code>unit_space_data</code>.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>Vector with length n. Distances from the unit space to each
sample.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation. q equals p.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the
transformed data are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taguchi, G. &amp; Kanetaka, T. (2002). <em>Engineering Technical Development
in MT System - Lecture on Applied Quality.</em> Japanese Standards
Association. (In Japanese)
</p>
<p>Taguchi, G., &amp; Jugulum, R. (2002). <em>The Mahalanobis-Taguchi strategy:
A pattern technology system.</em> John Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_cofactor">calc_cofactor</a></code>, <code><a href="#topic+general_MT">general_MT</a></code>,
<code><a href="#topic+generates_normalization_function">generates_normalization_function</a></code>, and
<code><a href="#topic+diagnosis.MT">diagnosis.MT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset
iris_versicolor &lt;- iris[61:100, -5]

unit_space_MTA &lt;- MTA(unit_space_data = iris_versicolor,
                      includes_transformed_data = TRUE)

(unit_space_MTA$distance)

</code></pre>

<hr>
<h2 id='RT'>Function to generate a unit space for the Recognition-Taguchi (RT) method</h2><span id='topic+RT'></span>

<h3>Description</h3>

<p><code>RT</code> generates a unit space for the Recognition-Taguchi (RT) method. In
<code><a href="#topic+general_MT">general_MT</a></code>, the inversed correlation matrix is used for A and
the data are transformed by the function to be generated by
<code><a href="#topic+generates_dimensionality_reduction_function">generates_dimensionality_reduction_function</a></code> based on
<code>unit_space_data</code>. In the transformation, the p variables in
<code>unit_space_data</code> are reduced into 2 synthetic variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RT(unit_space_data, includes_transformed_data = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RT_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and p columns (variables).
Data to generate the unit space. All data should be
continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="RT_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
are included in a return object.</p>
</td></tr>
<tr><td><code id="RT_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+solve">solve</a></code> for computing the inverse of
the correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>RT</code> returns an object of S3 <a href="base.html#topic+class">class</a> &quot;RT&quot;. An
object of class &quot;RT&quot; is a list containing the following components:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>2 x 2 matrix. Inversed correlation matrix of the transformed
<code>unit_space_data</code>.</p>
</td></tr>
<tr><td><code>calc_A</code></td>
<td>
<p><code>function(x) solve(cor(x), ...)</code>.</p>
</td></tr>
<tr><td><code>transforms_data</code></td>
<td>
<p>Function to be generated from
<code><a href="#topic+generates_dimensionality_reduction_function">generates_dimensionality_reduction_function</a></code>
based on <code>unit_space_data</code>.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>Vector with length n. Distances from the unit space to each
sample.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of samples.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of variables after the data transformation. q is always
2.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the
transformed data are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taguchi, G. (2006). Objective Function and Generic Function (11).
<em>Journal of Quality Engineering Society, 14</em>(2), 5-9. (In Japanese)
</p>
<p>Huda, F., Kajiwara, I., Hosoya, N., &amp; Kawamura, S. (2013). Bolt loosening
analysis and diagnosis by non-contact laser excitation vibration tests.
<em>Mechanical systems and signal processing, 40</em>(2), 589-604.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+solve">solve</a></code>, <code><a href="#topic+general_MT">general_MT</a></code>,
<code><a href="#topic+generates_dimensionality_reduction_function">generates_dimensionality_reduction_function</a></code>, and
<code><a href="#topic+diagnosis.MT">diagnosis.MT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40 data for versicolor in the iris dataset
iris_versicolor &lt;- iris[61:100, -5]

unit_space_RT &lt;- RT(unit_space_data = iris_versicolor,
                    includes_transformed_data = TRUE)

# The following "tol" is a parameter passed to the solve function.
unit_space_RT &lt;- RT(unit_space_data = iris_versicolor,
                    includes_transformed_data = TRUE,
                    tol = 1e-9)

(unit_space_RT$distance)

</code></pre>

<hr>
<h2 id='T1'>Function to generate a prediction expression for the two-sided Taguchi (T1)
method</h2><span id='topic+T1'></span>

<h3>Description</h3>

<p><code>T1</code> generates a prediction expression for the two-sided Taguchi (T1)
method. In <code><a href="#topic+general_T">general_T</a></code>, the data are normalized by subtracting
the mean and without scaling based on <code>unit_space_data</code>. The sample
data should be divided into 2 datasets in advance. One is for the unit
space and the other is for the signal space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T1(unit_space_data, signal_space_data, subtracts_V_e = TRUE,
  includes_transformed_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T1_+3A_unit_space_data">unit_space_data</code></td>
<td>
<p>Matrix with n rows (samples) and (p + 1) columns
(variables). The 1 ~ p th columns are independent
variables and the (p + 1) th column is a dependent
variable. Underlying data to obtain a representative
point for the normalization of the
<code>signal_space_data</code>. All data should be
continuous values and should not have missing values.</p>
</td></tr>
<tr><td><code id="T1_+3A_signal_space_data">signal_space_data</code></td>
<td>
<p>Matrix with m rows (samples) and (p + 1) columns
(variables). The 1 ~ p th columns are independent
variables and the (p + 1) th column is a dependent
variable. Underlying data to generate a prediction
expression. All data should be continuous values
and should not have missing values.</p>
</td></tr>
<tr><td><code id="T1_+3A_subtracts_v_e">subtracts_V_e</code></td>
<td>
<p>If <code>TRUE</code>, then the error variance is subtracted in
the numerator when calculating <code>eta_hat</code>.</p>
</td></tr>
<tr><td><code id="T1_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
are included in a return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>beta_hat</code></td>
<td>
<p>Vector with length q. Estimated proportionality constants
between each independent variable and the dependent
variable.</p>
</td></tr>
<tr><td><code>subtracts_V_e</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then <code>eta_hat</code> was
calculated without subtracting the error variance in
the numerator.</p>
</td></tr>
<tr><td><code>eta_hat</code></td>
<td>
<p>Vector with length q. Estimated squared signal-to-noise
ratios (S/N) coresponding to <code>beta_hat</code>.</p>
</td></tr>
<tr><td><code>M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data transformation for <code>signal_space_data</code>.</p>
</td></tr>
<tr><td><code>overall_prediction_eta</code></td>
<td>
<p>Numeric. The overall squared signal-to-noise
ratio (S/N).</p>
</td></tr>
<tr><td><code>transforms_independent_data</code></td>
<td>
<p>Data transformation function generated
from <code>generates_transform_functions</code>
based on the <code>unit_space_data</code>. The
function for independent variables takes
independent variable data (a matrix of p
columns) as an (only) argument and
returns the transformed independent
variable data.</p>
</td></tr>
<tr><td><code>transforms_dependent_data</code></td>
<td>
<p>Data transformation function generated from
<code>generates_transform_functions</code> based
on the <code>unit_space_data</code>. The
function for a dependent variable takes
dependent variable data (a vector) as an
(only) argument and returns the
transformed dependent variable data.</p>
</td></tr>
<tr><td><code>inverses_dependent_data</code></td>
<td>
<p>Data transformation function generated
from <code>generates_transform_functions</code>
based on the <code>unit_space_data</code>. The
function of the takes the transformed
dependent variable data (a vector) as an
(only) argument and returns the dependent
variable data inversed from the transformed
dependent variable data.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The number of samples for <code>signal_space_data</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of independent variables after the data transformation.
q equals p.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the
independent variable data after the data transformation for the
<code>signal_space_data</code> are included.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the (true)
value of the dependent variable after the data transformation for
the <code>signal_space_data</code> are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Taguchi, G. (2006). Objective Function and Generic Function (12).
<em>Journal of Quality Engineering Society, 14</em>(3), 5-9. (In Japanese)
</p>
<p>Inou, A., Nagata, Y., Horita, K., &amp; Mori, A. (2012). Prediciton Accuracies
of Improved Taguchi's T Methods Compared to those of Multiple Regresssion
Analysis. <em>Journal of the Japanese Society for Quality Control,
42</em>(2), 103-115. (In Japanese)
</p>
<p>Kawada, H., &amp; Nagata, Y. (2015). An application of a generalized inverse
regression estimator to Taguchi's T-Method. <em>Total Quality Science,
1</em>(1), 12-21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_T">general_T</a></code>,
<code><a href="#topic+generates_transformation_functions_T1">generates_transformation_functions_T1</a></code>, and
<code><a href="#topic+forecasting.T1">forecasting.T1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The value of the dependent variable of the following samples mediates
# in the stackloss dataset.
stackloss_center &lt;- stackloss[c(9, 10, 11, 20, 21), ]

# The following samples are data other than the unit space data and the test
# data.
stackloss_signal &lt;- stackloss[-c(2, 9, 10, 11, 12, 19, 20, 21), ]

model_T1 &lt;- T1(unit_space_data = stackloss_center,
               signal_space_data = stackloss_signal,
               subtracts_V_e = TRUE,
               includes_transformed_data = TRUE)

(model_T1$M_hat)

</code></pre>

<hr>
<h2 id='Ta'>Function to generate a prediction expression for the Ta method</h2><span id='topic+Ta'></span>

<h3>Description</h3>

<p><code>Ta</code> generates a prediction expression for the Ta method. In
<code><a href="#topic+general_T">general_T</a></code>, the data are normalized by subtracting the mean
and without scaling based on <code>sample_data</code>. The sample data are not
divided into 2 datasets. All the sample data are used for both unit space
and signal space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ta(sample_data, subtracts_V_e = TRUE, includes_transformed_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ta_+3A_sample_data">sample_data</code></td>
<td>
<p>Matrix with n rows (samples) and (p + 1) columns
(variables). The 1 ~ p th columns are independent
variables and the (p + 1) th column is a dependent
variable. All data should be continuous values and
should not have missing values.</p>
</td></tr>
<tr><td><code id="Ta_+3A_subtracts_v_e">subtracts_V_e</code></td>
<td>
<p>If <code>TRUE</code>, then the error variance is subtracted in
the numerator when calculating <code>eta_hat</code>.</p>
</td></tr>
<tr><td><code id="Ta_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
are included in a return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>beta_hat</code></td>
<td>
<p>Vector with length q. Estimated proportionality constants
between each independent variable and the dependent
variable.</p>
</td></tr>
<tr><td><code>subtracts_V_e</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then <code>eta_hat</code> was
calculated without subtracting the error variance in
the numerator.</p>
</td></tr>
<tr><td><code>eta_hat</code></td>
<td>
<p>Vector with length q. Estimated squared signal-to-noise
ratios (S/N) coresponding to <code>beta_hat</code>.</p>
</td></tr>
<tr><td><code>M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data transformation for <code>sample_data</code>.</p>
</td></tr>
<tr><td><code>overall_prediction_eta</code></td>
<td>
<p>Numeric. The overall squared signal-to-noise
ratio (S/N).</p>
</td></tr>
<tr><td><code>transforms_independent_data</code></td>
<td>
<p>Data transformation function generated
from <code>generates_transform_functions</code>
based on the <code>unit_space_data</code>. The
function for independent variables takes
independent variable data (a matrix of p
columns) as an (only) argument and
returns the transformed independent
variable data.</p>
</td></tr>
<tr><td><code>transforms_dependent_data</code></td>
<td>
<p>Data transformation function generated from
<code>generates_transform_functions</code> based
on the <code>unit_space_data</code>. The
function for a dependent variable takes
dependent variable data (a vector) as an
(only) argument and returns the
transformed dependent variable data.</p>
</td></tr>
<tr><td><code>inverses_dependent_data</code></td>
<td>
<p>Data transformation function generated
from <code>generates_transform_functions</code>
based on the <code>unit_space_data</code>. The
function of the takes the transformed
dependent variable data (a vector) as an
(only) argument and returns the dependent
variable data inversed from the transformed
dependent variable data.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The number of samples for <code>sample_data</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of independent variables after the data transformation.
q equals p.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the
independent variable data after the data transformation for the
<code>sample_data</code> are included.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the (true)
value of the dependent variable after the data transformation for
the <code>sample_data</code> are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Inou, A., Nagata, Y., Horita, K., &amp; Mori, A. (2012). Prediciton Accuracies
of Improved Taguchi's T Methods Compared to those of Multiple Regresssion
Analysis. <em>Journal of the Japanese Society for Quality Control,
42</em>(2), 103-115. (In Japanese)
</p>
<p>Kawada, H., &amp; Nagata, Y. (2015). An application of a generalized inverse
regression estimator to Taguchi's T-Method. <em>Total Quality Science,
1</em>(1), 12-21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_T">general_T</a></code>,
<code><a href="#topic+generates_transformation_functions_T1">generates_transformation_functions_T1</a></code>, and
<code><a href="#topic+forecasting.Ta">forecasting.Ta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model_Ta &lt;- Ta(sample_data = stackloss[-c(2, 12, 19), ],
               subtracts_V_e = TRUE,
               includes_transformed_data = TRUE)

(model_Ta$M_hat)

</code></pre>

<hr>
<h2 id='Tb'>Function to generate a prediction expression for the Tb method</h2><span id='topic+Tb'></span>

<h3>Description</h3>

<p><code>Tb</code> generates a prediction expression for the Tb method. In
<code><a href="#topic+general_T">general_T</a></code>, the data are normalized by subtracting the center
and without scaling based on <code>sample_data</code>. The center is determined
by the specific way for the Tb method. For details, please see
<code><a href="#topic+generates_transformation_functions_Tb">generates_transformation_functions_Tb</a></code>. All the sample data
are used for both unit space and signal space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tb(sample_data, subtracts_V_e = TRUE, includes_transformed_data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tb_+3A_sample_data">sample_data</code></td>
<td>
<p>Matrix with n rows (samples) and (p + 1) columns
(variables). The 1 ~ p th columns are independent
variables and the (p + 1) th column is a dependent
variable. All data should be continuous values and
should not have missing values.</p>
</td></tr>
<tr><td><code id="Tb_+3A_subtracts_v_e">subtracts_V_e</code></td>
<td>
<p>If <code>TRUE</code>, then the error variance is subtracted in
the numerator when calculating <code>eta_hat</code>.</p>
</td></tr>
<tr><td><code id="Tb_+3A_includes_transformed_data">includes_transformed_data</code></td>
<td>
<p>If <code>TRUE</code>, then the transformed data
are included in a return object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components is returned.
</p>
<table>
<tr><td><code>beta_hat</code></td>
<td>
<p>Vector with length q. Estimated proportionality constants
between each independent variable and the dependent
variable.</p>
</td></tr>
<tr><td><code>subtracts_V_e</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then <code>eta_hat</code> was
calculated without subtracting the error variance in
the numerator.</p>
</td></tr>
<tr><td><code>eta_hat</code></td>
<td>
<p>Vector with length q. Estimated squared signal-to-noise
ratios (S/N) coresponding to <code>beta_hat</code>.</p>
</td></tr>
<tr><td><code>M_hat</code></td>
<td>
<p>Vector with length n. The estimated values of the dependent
variable after the data transformation for <code>sample_data</code>.</p>
</td></tr>
<tr><td><code>overall_prediction_eta</code></td>
<td>
<p>Numeric. The overall squared signal-to-noise
ratio (S/N).</p>
</td></tr>
<tr><td><code>transforms_independent_data</code></td>
<td>
<p>Data transformation function generated
from <code>generates_transform_functions</code>
based on the <code>unit_space_data</code>. The
function for independent variables takes
independent variable data (a matrix of p
columns) as an (only) argument and
returns the transformed independent
variable data.</p>
</td></tr>
<tr><td><code>transforms_dependent_data</code></td>
<td>
<p>Data transformation function generated from
<code>generates_transform_functions</code> based
on the <code>unit_space_data</code>. The
function for a dependent variable takes
dependent variable data (a vector) as an
(only) argument and returns the
transformed dependent variable data.</p>
</td></tr>
<tr><td><code>inverses_dependent_data</code></td>
<td>
<p>Data transformation function generated
from <code>generates_transform_functions</code>
based on the <code>unit_space_data</code>. The
function of the takes the transformed
dependent variable data (a vector) as an
(only) argument and returns the dependent
variable data inversed from the transformed
dependent variable data.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The number of samples for <code>sample_data</code>.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>The number of independent variables after the data transformation.
q equals p.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the
independent variable data after the data transformation for the
<code>sample_data</code> are included.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>If <code>includes_transformed_data</code> is <code>TRUE</code>, then the (true)
value of the dependent variable after the data transformation for
the <code>sample_data</code> are included.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Inou, A., Nagata, Y., Horita, K., &amp; Mori, A. (2012). Prediciton Accuracies
of Improved Taguchi's T Methods Compared to those of Multiple Regresssion
Analysis. <em>Journal of the Japanese Society for Quality Control,
42</em>(2), 103-115. (In Japanese)
</p>
<p>Kawada, H., &amp; Nagata, Y. (2015). An application of a generalized inverse
regression estimator to Taguchi's T-Method. <em>Total Quality Science,
1</em>(1), 12-21.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+general_T">general_T</a></code>,
<code><a href="#topic+generates_transformation_functions_Tb">generates_transformation_functions_Tb</a></code>, and
<code><a href="#topic+forecasting.Tb">forecasting.Tb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model_Tb &lt;- Tb(sample_data = stackloss[-c(2, 12, 19), ],
               subtracts_V_e = TRUE,
               includes_transformed_data = TRUE)

(model_Tb$M_hat)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
