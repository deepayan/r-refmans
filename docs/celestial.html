<!DOCTYPE html><html><head><title>Help for package celestial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {celestial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#celestial-package'>
<p>Collection of Common Astronomical Conversion Routines and Functions</p></a></li>
<li><a href='#car2sph'>
<p>Transforms 3D cartesian coordinates to spherical coordinates</p></a></li>
<li><a href='#cosdist'>
<p>Cosmological distance calculations</p></a></li>
<li><a href='#cosgrow'>
<p>Cosmological growth and evolution calculations</p></a></li>
<li><a href='#coshalo'>
<p>Virial halo conversion functions</p></a></li>
<li><a href='#cosmap'>
<p>Cosmological Mapping Functions</p></a></li>
<li><a href='#Cosmology+20Reference+20Sets'>
<p>Cosmology parameter data included in celestial package.</p></a></li>
<li><a href='#cosNFW'>
<p>Navarro Frenk and White profile</p></a></li>
<li><a href='#cosorb'>
<p>Orbital functions</p></a></li>
<li><a href='#cosvar'>
<p>Driver &amp; Robotham (2010) cosmic variance calculator</p></a></li>
<li><a href='#cosvol'>
<p>Cosmological volume calculator</p></a></li>
<li><a href='#deg2dms'>
<p>Convert decimal degrees to dms format.</p></a></li>
<li><a href='#deg2hms'>
<p>Convert decimal degrees to hms format.</p></a></li>
<li><a href='#dms2deg'>
<p>Convert DMS to degrees format.</p></a></li>
<li><a href='#getpixscale'>
<p>Get Pixel Scale</p></a></li>
<li><a href='#hms2deg'>
<p>Convert hms to degrees format.</p></a></li>
<li><a href='#IAUID'>
<p>IAU name creator.</p></a></li>
<li><a href='#planck'>
<p>Planck's Law and Related Functions</p></a></li>
<li><a href='#Sky+20Coordinate+20Matching'>
<p>Sky matching</p></a></li>
<li><a href='#skyarea'>
<p>Exact angular area calculator</p></a></li>
<li><a href='#skyproj'>
<p>Tan Gnomonic and Sine Orthographic Projection System WCS Solver Functions</p></a></li>
<li><a href='#sph2car'>
<p>Transforms 3D spherical coordinates to cartesian coordinates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Collection of Common Astronomical Conversion Routines and
Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-11-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron Robotham</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron Robotham &lt;aaron.robotham@uwa.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains a number of common astronomy conversion routines, particularly the HMS and degrees schemes, which can be fiddly to convert between on mass due to the textural nature of the former. It allows users to coordinate match datasets quickly. It also contains functions for various cosmological calculations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.00), RANN, NISTunits, pracma</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-29 01:56:32 UTC; aaron</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-11-29 05:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='celestial-package'>
Collection of Common Astronomical Conversion Routines and Functions
</h2><span id='topic+celestial-package'></span><span id='topic+celestial'></span>

<h3>Description</h3>

<p>Various functions for converting between commonly used coordinate systems in astronomy and making cosmological calculations.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> celestial</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-11-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.00), RANN, NISTunits, pracma</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>There are a number of functions included, but the most useful for astronomy conversions are the decimal degrees to DMS/HMS formats used at many telescopes: deg2dms, deg2hms, dms2deg, hms2deg. It also contains functions for various cosmological calculations (i.e. distance, volume and age for different cosmologies and redshifts).
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>
<p>Maintainer: Aaron Robotham &lt;aaron.robotham@uwa.edu.au&gt;
</p>

<hr>
<h2 id='car2sph'>
Transforms 3D cartesian coordinates to spherical coordinates
</h2><span id='topic+car2sph'></span>

<h3>Description</h3>

<p>Transforms 3D cartesian coordinates to spherical coordinates. The user can choose to return the spherical coordinates in degrees or radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>car2sph(x, y, z, deg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="car2sph_+3A_x">x</code></td>
<td>

<p>x values, can also contain a matrix of x, y and z (in that order).
</p>
</td></tr>
<tr><td><code id="car2sph_+3A_y">y</code></td>
<td>

<p>y values.
</p>
</td></tr>
<tr><td><code id="car2sph_+3A_z">z</code></td>
<td>

<p>z values
</p>
</td></tr>
<tr><td><code id="car2sph_+3A_deg">deg</code></td>
<td>

<p>Should degrees be returned (default) or radians.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a low level function that is used for plot transformations.
</p>


<h3>Value</h3>

<p>A data.frame is returned containing the columns long (longitude), lat (latitude) and radius.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sph2car">sph2car</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(car2sph(x=1,y=1,z=0,deg=TRUE))
</code></pre>

<hr>
<h2 id='cosdist'>
Cosmological distance calculations
</h2><span id='topic+cosdist'></span><span id='topic+cosdistz'></span><span id='topic+cosdista'></span><span id='topic+cosdistCoDist'></span><span id='topic+cosdistLumDist'></span><span id='topic+cosdistAngDist'></span><span id='topic+cosdistAngDist12'></span><span id='topic+cosdistCoDistTran'></span><span id='topic+cosdistCoDist12ang'></span><span id='topic+cosdistDistMod'></span><span id='topic+cosdistAngScale'></span><span id='topic+cosdistAngSize'></span><span id='topic+cosdistAngArea'></span><span id='topic+cosdistCoVol'></span><span id='topic+cosdistHubTime'></span><span id='topic+cosdistUniAgeNow'></span><span id='topic+cosdistUniAgeAtz'></span><span id='topic+cosdistTravelTime'></span><span id='topic+cosdistRelError'></span><span id='topic+cosdistCrit'></span><span id='topic+cosdistCoDist12ang'></span><span id='topic+cosdistLumDist12ang'></span><span id='topic+cosdistAngDist12ang'></span><span id='topic+cosdistzem12ang'></span><span id='topic+cosdistzeff12ang'></span><span id='topic+cosdistzeff'></span>

<h3>Description</h3>

<p>These functions allow comoving, angular size and luminosity distances to be calculated for a given redshift, it can also return look back time. They use curvature correctly, calculated internally using the relation OmegaM+OmegaL+OmegaR+OmegaK=1, but by default they assume a flat Universe where only OmegaM needs to be specified and OmegaR=0 (so no radiation pressure at any epoch).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosdist(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1, wprime = 0,
age=FALSE, ref, error=FALSE)
cosdistz(z=1)
cosdistzeff(zref = 1, zem = 2)
cosdista(z=1)
cosdistCoDist(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistLumDist(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistAngDist(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistAngDist12(z1=1, z2=2, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0,
w0 = -1, wprime = 0, ref)
cosdistCoDistTran(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistCoDist12ang(z1=1, z2=2, ang=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, w0 = -1, wprime = 0, inunit='deg', ref) 
cosdistLumDist12ang(z1=1, z2=2, ang=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, w0 = -1, wprime = 0, inunit='deg', ref)
cosdistAngDist12ang(z1=1, z2=2, ang=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, w0 = -1, wprime = 0, inunit='deg', ref)
cosdistzem12ang(z1=1, z2=2, ang=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, w0 = -1, wprime = 0, inunit='deg', ref)
cosdistzeff12ang(z1=1, z2=2, ang=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, w0 = -1, wprime = 0, inunit='deg', ref)
cosdistDistMod(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistAngScale(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistAngSize(z=1, Size=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1,
wprime=0, Dim=1, Dist='Co',  outunit='deg', ref)
cosdistAngArea(z=1, Size=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1,
wprime=0, Dim=2, Dist='Co',  outunit='deg2', ref)
cosdistCoVol(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistHubTime(H0=100)
cosdistUniAgeNow(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistUniAgeAtz(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistTravelTime(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1,
wprime = 0, ref)
cosdistRelError(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1, wprime = 0,
ref)
cosdistCrit(z_lens=1, z_source=2, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0,
w0 = -1, wprime = 0, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosdist_+3A_z">z</code></td>
<td>

<p>Cosmological redshift, where z must be &gt; -1 (can be a vector).
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_h0">H0</code></td>
<td>

<p>Hubble constant as defined at z=0 (default is H0=100 (km/s)/Mpc).
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_omegam">OmegaM</code></td>
<td>

<p>Omega matter (default is 0.3).
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_omegal">OmegaL</code></td>
<td>

<p>Omega Lambda (default is for a flat Universe with OmegaL = 1-OmegaM-OmegaR = 0.7).
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_omegar">OmegaR</code></td>
<td>

<p>Omega Radiation (default is 0, but OmegaM/3400 is typical).
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_w0">w0</code></td>
<td>

<p>The value of dark energy equation of state at z=0. See <code><a href="#topic+cosgrow">cosgrow</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_wprime">wprime</code></td>
<td>

<p>The evolution term that governs how the dark energy equation of state evolves with redshift. See <code><a href="#topic+cosgrow">cosgrow</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_age">age</code></td>
<td>

<p>Flag for cosdist function to return age or not- this slows calculation, so is by default turned off.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_ref">ref</code></td>
<td>

<p>The name of a reference cosmology to use, one of 137 / 737 / Planck / Planck13 / Planck15 / Planck18 / WMAP / WMAP9 / WMAP7 / WMAP5 / WMAP3 / WMAP1 / Millennium / GiggleZ. Planck = Planck18 and WMAP = WMAP9. The usage is case insensitive, so wmap9 is an allowed input. This overrides any other settings for H0, OmegaM and OmegaL. If OmegaR is missing from the reference set then it is inherited from the function input (0 by default). See <code><a href="#topic+cosref">cosref</a></code> for details.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_error">error</code></td>
<td>

<p>Flag for cosdist to calculate the relative error for distance/age values.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_z1">z1</code></td>
<td>

<p>Redshift for object 1, where z1 must be &gt; -1 (can be a vector) and less than z2.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_z2">z2</code></td>
<td>

<p>Redshift for object 2, where z2 must be &gt; -1 (can be a vector) and greater than z1.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_zref">zref</code></td>
<td>

<p>Redshift for the reference object, i.e. the object that we caste as the observer of another object at zem.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_zem">zem</code></td>
<td>

<p>Redshift for the emitting  object, i.e. the object that we caste as being observed by another object at zref.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_z_lens">z_lens</code></td>
<td>

<p>Redshift, where z_lens must be &gt; -1 (can be a vector) and z_lens &lt; z_source.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_z_source">z_source</code></td>
<td>

<p>Redshift, where z_source must be &gt; -1 (can be a vector) and z_lens &lt; z_source.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_ang">ang</code></td>
<td>

<p>The observed angular separation between object 1 and object 2 in degrees.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_size">Size</code></td>
<td>

<p>The 1D size of the object (i.e. diameter or total length) in Mpc. Either comoving or angular, as specified by <span class="option">Dist</span>. For cosdistAngArea this is always taken to be the diameter of either projected or 3D object.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_dim">Dim</code></td>
<td>

<p>Specifies whether the object being considered is 1D (a line) 2D (e.g. a face on galaxy) or 3D (e.g. dark matter halo). This makes a very small modification to the geometry used (tan of 1D/2D and sin for 3D), but is only noticeable for large structures at low redshifts.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_dist">Dist</code></td>
<td>

<p>Determines the distance type, i.e. angular / physical distances (Ang) or with respect to comoving distances (Co).
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_inunit">inunit</code></td>
<td>

<p>The units of angular coordinate provided for <span class="option">ang</span>. Allowed options are deg for degrees, amin for arc minutes, asec for arc seconds, and rad for radians.
</p>
</td></tr>
<tr><td><code id="cosdist_+3A_outunit">outunit</code></td>
<td>

<p>For <code>cosdistAngSize</code> units of angular coordinate output. Allowed options are deg for degress (default), amin for arc minutes, asec for arc seconds, and rad for radians.
</p>
<p>For <code>cosdistAngArea</code> units of angular area output. Allowed options are deg2 for square degrees (default), amin2 for square arc minutes, asec2 for square arc seconds and rad2 or sr for steradians.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions are largely based on D. W. Hogg et al. 1999 and Wright et al. 2006.
</p>
<p>Negative value of z&gt; -1 are allowed, which produces future predictions based on present day cosmology.
</p>
<p>cosdistAngDist12 is only available for OmegaK&gt;=0.
</p>


<h3>Value</h3>

<table>
<tr><td><code>cosdist</code></td>
<td>
<p>Returns a data.frame (even if only 1 redshift if requested) with the following columns:</p>
</td></tr>
</table>

<table>
<tr>
 <td style="text-align: left;">
z       </td><td style="text-align: left;"> Requested redshift</td>
</tr>
<tr>
 <td style="text-align: left;">
a       </td><td style="text-align: left;"> Universe expansion factor, as given by a=1/(1+z)</td>
</tr>
<tr>
 <td style="text-align: left;">
CoDist  </td><td style="text-align: left;"> Line-of-sight (i.e. radial) comoving distance in units of Mpc</td>
</tr>
<tr>
 <td style="text-align: left;">
LumDist </td><td style="text-align: left;"> Luminosity distance in units of Mpc</td>
</tr>
<tr>
 <td style="text-align: left;">
AngDist </td><td style="text-align: left;"> Angular diameter distance in units of Mpc</td>
</tr>
<tr>
 <td style="text-align: left;">
CoDistTran  </td><td style="text-align: left;"> Transverse comoving distance in units of Mpc</td>
</tr>
<tr>
 <td style="text-align: left;">
DistMod </td><td style="text-align: left;"> The distance modulus used where AbsMag = ApMag - DistMod, and DistMod = 5log10(LumDist)+25 in units of mag</td>
</tr>
<tr>
 <td style="text-align: left;">
AngScale </td><td style="text-align: left;"> Physical projected scale of an object at z in units of kpc/arcsec</td>
</tr>
<tr>
 <td style="text-align: left;">
CoVol </td><td style="text-align: left;"> Comoving volume of Universe within z in units of Gpc^3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If age=TRUE is set then additional age-related information is calculated for each z as extra columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
HubTime </td><td style="text-align: left;"> Approximate Hubble age of the Universe in units of Gyrs</td>
</tr>
<tr>
 <td style="text-align: left;">
UniAgeNow  </td><td style="text-align: left;"> Age of the Universe now in units of Gyrs</td>
</tr>
<tr>
 <td style="text-align: left;">
UniAgeAtz  </td><td style="text-align: left;"> Age of the Universe at the specified redshift (z) in units of Gyrs</td>
</tr>
<tr>
 <td style="text-align: left;">
TravelTime </td><td style="text-align: left;"> Light travel time from the specified redshift (AKA look back time) in units of Gyrs</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If error=TRUE is set then the relative error for distance/age values is calculated for each z as an extra column:
</p>

<table>
<tr>
 <td style="text-align: left;">
RelError </td><td style="text-align: left;"> Relative error of the distance/age integrals (this is the main source of error in the calculations)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The outputs of the standalone functions are:
</p>
<table>
<tr><td><code>cosdistz</code></td>
<td>
<p>Returns the input redshift (only included for clarity).</p>
</td></tr>
<tr><td><code>cosdistzeff</code></td>
<td>
<p>Returns the apparent redshift that the object at zref will observe the object at zem for the Universe age that zref is observed to have now. This is given by <code class="reqn">(1+zem)/(1+zref)</code>.</p>
</td></tr>
<tr><td><code>cosdista</code></td>
<td>
<p>Returns the Universe expansion factor, as given by <code class="reqn">a=1/(1+z)</code>.</p>
</td></tr>
<tr><td><code>cosdistCoDist</code></td>
<td>
<p>Returns the line-of-sight (i.e. radial) comoving distance in units of Mpc. For a flat Universe (OmegaK=0) this is exactly the samething as the transverse comoving distance, and by extension it is also the proper motion distance.</p>
</td></tr>
<tr><td><code>cosdistLumDist</code></td>
<td>
<p>Returns the luminosity distance in units of Mpc.</p>
</td></tr>
<tr><td><code>cosdistAngDist</code></td>
<td>
<p>Returns the angular diameter distance in units of Mpc.</p>
</td></tr>
<tr><td><code>cosdistAngDist12</code></td>
<td>
<p>Returns the radial angular diameter distance separation in units of Mpc between objects at <span class="option">z1</span> and <span class="option">z2</span> that have small angular separations on sky.</p>
</td></tr>
<tr><td><code>cosdistCoDistTran</code></td>
<td>
<p>Returns the transverse comoving distance in units of Mpc. This is equivilant to the proper motion distance for all values of Universe curvature (OmegaK !=0), and is the same thing as the line-of-sight comoving distance for a flat Universe (OmegaK=0).</p>
</td></tr>
<tr><td><code>cosdistCoDist12ang</code></td>
<td>
<p>Returns the total comoving distance in units of Mpc between objects at <span class="option">z1</span> and <span class="option">z2</span> with a separation <span class="option">ang</span>. This works for curved cosmologies (i.e. OmegaK!=0) and for large radial and tangential separations. For small separations at a certain value of z for both objects the result is very similar to cosdistCoDistTran(z)*sin(ang*pi/180). This function was mostly extracted from Eqn 3.19 in Peacock (1999).</p>
</td></tr>
<tr><td><code>cosdistLumDist12ang</code></td>
<td>
<p>Returns the total luminosity distance in units of Mpc between objects at <span class="option">z1</span> and <span class="option">z2</span> with a separation <span class="option">ang</span>. This is equal to cosdistCoDist12ang*(1+zeff), where zeff is the apparent redshift that the object at z1 will observe the object at z2 for the Universe age that z1 is observed to have now. See <code>cosdistCoDist12ang</code> for details.</p>
</td></tr>
<tr><td><code>cosdistAngDist12ang</code></td>
<td>
<p>Returns the total angular diameter distance in units of Mpc between objects at <span class="option">z1</span> and <span class="option">z2</span> with a separation <span class="option">ang</span>. This is equal to cosdistCoDist12ang/(1+zeff), where zeff is the apparent redshift that the object at z1 will observe the object at z2 for the Universe age that z1 is observed to have now. See <code>cosdistCoDist12ang</code> for details.</p>
</td></tr>
<tr><td><code>cosdistzem12ang</code></td>
<td>
<p>Returns the apparent redshift that the object at <span class="option">z1</span> would observe the object at <span class="option">z2</span> to be for our current Universe age. See <code>cosdistCoDist12ang</code> for details.</p>
</td></tr>
<tr><td><code>cosdistzeff12ang</code></td>
<td>
<p>Returns the apparent redshift that the object at <span class="option">z1</span> would observe the object at <span class="option">z2</span> to be for the Universe age that z1 is observed to have now. See <code>cosdistCoDist12ang</code> for details.</p>
</td></tr>
<tr><td><code>cosdistDistMod</code></td>
<td>
<p>Returns the distance modulus used where AbsMag = ApMag - DistMod, and DistMod = 5log10(LumDist)+25 in units of mag.</p>
</td></tr>
<tr><td><code>cosdistAngScale</code></td>
<td>
<p>Returns the physical projected scale of an object at z in units of kpc/arcsec.</p>
</td></tr>
<tr><td><code>cosdistAngSize</code></td>
<td>
<p>Returns the angular size (length or diameter) of an object (by default in degrees).</p>
</td></tr>
<tr><td><code>cosdistAngArea</code></td>
<td>
<p>Returns the angular area of an object (by default degrees^2), taking the specified Size to be the diameter.</p>
</td></tr>
<tr><td><code>cosdistCoVol</code></td>
<td>
<p>Returns the comoving volume of Universe within z in units of Gpc^3.</p>
</td></tr>
<tr><td><code>cosdistHubTime</code></td>
<td>
<p>Returns the approximate Hubble age of the Universe in units of Gyrs.</p>
</td></tr>
<tr><td><code>cosdistUniAgeNow</code></td>
<td>
<p>Returns the age of the Universe now in units of Gyrs.</p>
</td></tr>
<tr><td><code>cosdistUniAgeAtz</code></td>
<td>
<p>Returns the age of the Universe at the specified redshift (z) in units of Gyrs.</p>
</td></tr>
<tr><td><code>cosdistTravelTime</code></td>
<td>
<p>Returns the light travel time from the specified redshift (AKA look back time) in units of Gyrs.</p>
</td></tr>
<tr><td><code>cosdistRelError</code></td>
<td>
<p>Returns the relative error of the distance/age integrals (this is the main source of error in the calculations).</p>
</td></tr>
<tr><td><code>cosdistCrit</code></td>
<td>
<p>Returns the critical surface mass density, SigmaC (see also <code><a href="#topic+cosNFW">cosNFW</a></code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>References</h3>

<p>Based on the equations in:
</p>
<p>Davis T.M. &amp; Lineweaver, Charles H., 2004, PASA, 21, 97
</p>
<p>Hogg D.W., 1999, arXiv, 9905116
</p>
<p>Liske J., 2000, MNRAS, 319, 557L
</p>
<p>Peacock J.A., 1999, Cosmological Physics, Cambridge University Press
</p>
<p>Wright E.L., 2006, PASP, 118, 1711
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosvol">cosvol</a></code>, <code><a href="#topic+cosmap">cosmap</a></code>, <code><a href="#topic+cosgrow">cosgrow</a></code>, <code><a href="#topic+cosref">cosref</a></code>, <code><a href="#topic+cosNFW">cosNFW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cosdist(0.3,70,age=TRUE)
cosdist(0.3,70,age=TRUE,ref='Planck')
cosdistz(0.3)
cosdista(0.3)
cosdistCoDist(0.3,70)
cosdistLumDist(0.3,70)
cosdistAngDist(0.3,70)
cosdistAngDist12(0.3,0.5,70)
cosdistCoDistTran(0.3,70)
cosdistCoDist12ang(0,2,10)
cosdistDistMod(0.3,70)
cosdistAngScale(0.3,70)
cosdistAngSize(0.3,1,70)
cosdistCoVol(0.3,70)
cosdistHubTime(70)
cosdistUniAgeNow(0.3,70)
cosdistUniAgeAtz(0.3,70)
cosdistTravelTime(0.3,70)
cosdistRelError(0.3)
cosdistCrit(0.3,0.5,70)
cosdistzeff(1,2)
cosdistzem12ang(1,2)
cosdistzeff12ang(1,2)

#A check of the comoving separation between objects function:

cosdistCoDistTran(2,OmegaM = 0.3, OmegaL=1)*sin(pi/180)
cosdistCoDist12ang(2,2,ang=1,OmegaM=0.3,OmegaL=1)

#Very close, however cosdistCoDist12ang lets us go further:

cosdistCoDist12ang(1,2,ang=10,OmegaM=0.3,OmegaL=1)
cosdistCoDist12ang(2,2,ang=180,OmegaM=0.3,OmegaL=1)

#The second number should be be the same as:

cosdistCoDist(2,OmegaM=0.3,OmegaL=1)*2

#Example 1 by John Peacock for EDS Universe (answer should be nearly 3):

cosdistzem12ang(3,4,56.4,H0=100,OmegaM=1,OmegaL=0)

#Example 2 by John Peacock for EDS Universe (answer should be nearly 2995 Mpc/h):

cosdistCoDist12ang(3,4,56.4,H0=100,OmegaM=1,OmegaL=0)

#Example 3 by John Peacock for Milne Universe (answer should be nearly 5294 Mpc/h):

cosdistCoDist12ang(3,4,56,H0=100,OmegaM=0,OmegaL=0)

#Example 4 by John Peacock for Milne Universe (answer should be nearly 4.846):

cosdistzeff12ang(3,4,56,H0=100,OmegaM=0,OmegaL=0)

#Example 5 by John Peacock for Milne Universe (answer should be nearly 364 Mpc/h):

cosdistAngDist12ang(3,4,56,H0=100,OmegaM=0,OmegaL=0)

#Nice plot of distance estimates:

redshifts=seq(0,3,by=0.01)
plot(redshifts, cosdistCoDist(redshifts, ref='planck'), type='l', col='darkgreen',
xlab='Redshift / z', ylab='Distance / Mpc')
lines(redshifts, cosdistLumDist(redshifts, ref='planck'), col='red')
lines(redshifts, cosdistAngDist(redshifts, ref='planck'), col='blue')
legend('topleft', legend=c('Comoving Distance', 'Luminosity Distance', 'Angular Diameter Distance'),
col=c('darkgreen', 'red', 'blue'),lty=1)

plot(redshifts, cosdistTravelTime(redshifts, ref='planck'), type='l',
xlab='Redshift / z', ylab='Light travel time / Yrs')

#Actual time example (Figure 1 of Davis &amp; Lineweaver 2004)
zseq=10^seq(-2,6,len=1e3)-1
dists=cosdistCoDist(zseq, ref='737')*0.00326
times=cosdistTravelTime(zseq, ref='737')
plot(dists, times, type='l', xlab='Comoving Distance / Glyr',
ylab='Time / Gyr')
abline(v=0, h=0, lty=1)
abline(h=c(min(times), max(times)), lty=2)
abline(v=c(min(dists), max(dists)), lty=2)

#Conformal time example (Figure 1 of Davis &amp; Lineweaver 2004):
#Mpc to Glyr conversion is 0.00326

zseq=10^seq(-2,6,len=1e3)-1
dists=cosdistCoDist(zseq, ref='737')*0.00326
plot(dists, dists, type='l',
xlab='Comoving Distance / Glyr', ylab='Conformal Time / Gyr')
abline(v=0, h=0, lty=1)
abline(h=c(min(dists), max(dists)), lty=2)
abline(v=c(min(dists), max(dists)), lty=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='cosgrow'>
Cosmological growth and evolution calculations
</h2><span id='topic+cosgrow'></span><span id='topic+cosgrowz'></span><span id='topic+cosgrowa'></span><span id='topic+cosgrowOmegaM'></span><span id='topic+cosgrowOmegaL'></span><span id='topic+cosgrowOmegaR'></span><span id='topic+cosgrowOmegaK'></span><span id='topic+cosgrowDecelq'></span><span id='topic+cosgrowH'></span><span id='topic+cosgrowCoVel'></span><span id='topic+cosgrowPecVel'></span><span id='topic+cosgrowFactor'></span><span id='topic+cosgrowRate'></span><span id='topic+cosgrowSigma8'></span><span id='topic+cosgrowFactorApprox'></span><span id='topic+cosgrowRateApprox'></span><span id='topic+cosgrowSigma8Approx'></span><span id='topic+cosgrowRhoCrit'></span><span id='topic+cosgrowRhoMean'></span><span id='topic+cosgrowEoSwDE'></span><span id='topic+cosgrowRhoDE'></span><span id='topic+cosgrowDeltaVir'></span>

<h3>Description</h3>

<p>These functions allow various properties of the expansion of the Universe to be calculated: e.g. OmegaM/OmegaL/OmegaR/OmegaK for ay redshift, growth rate and growth factor, sigma8, and RhoCrit and RhoMean. They use curvature correctly, calculated internally using the relation OmegaM+OmegaL+OmegaR+OmegaK=1, but by default they assume a flat Universe where only OmegaM needs to be specified and OmegaR=0 (so no radiation pressure at any epoch).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cosgrow(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0 = -1, wprime = 0,
  Sigma8=0.8, fSigma8=FALSE, Dist='Co',
  Mass='Msun', ref)
  cosgrowz(z = 1)
  cosgrowa(z = 1)
  cosgrowH(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0,
  ref)
  cosgrowCoVel(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1,
  wprime=0, ref)
  cosgrowPecVel(z=1, zob=1)
  cosgrowOmegaM(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0, ref)
  cosgrowOmegaL(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0, ref)
  cosgrowOmegaR(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0, ref)
  cosgrowOmegaK(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0, ref)
  cosgrowDecelq(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0, ref)
  cosgrowEoSwDE(z=1, w0=-1, wprime=0)
  cosgrowRhoDE(z=1,w0=-1, wprime=0, rhoDE=1)
  cosgrowFactor(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0, ref)
  cosgrowRate(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0,
  Sigma8=0.8, fSigma8=FALSE, ref)
  cosgrowSigma8(z=1, OmegaM=0.3,OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0,
  Sigma8=0.8, ref)
  cosgrowFactorApprox(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0,
  ref)
  cosgrowRateApprox(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0,
  Sigma8=0.8, fSigma8=FALSE, ref)
  cosgrowSigma8Approx(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1, wprime=0,
  Sigma8=0.8, ref)
  cosgrowRhoCrit(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1,
  wprime=0, Dist='Co', Mass='Msun', ref)
  cosgrowRhoMean(z=1, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, w0=-1,
  wprime=0, Dist='Co', Mass='Msun', ref)
  cosgrowDeltaVir(z=1, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosgrow_+3A_z">z</code></td>
<td>

<p>Cosmological redshift, where z must be &gt; -1 (can be a vector).
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_zob">zob</code></td>
<td>

<p>Observed redshift, where z must be &gt; -1 (can be a vector). Essentially a combination of the cosmological redshift <span class="option">z</span> and the peculiar velocity of the objects with respect to this.
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_h0">H0</code></td>
<td>

<p>Hubble constant as defined at z=0 (default is H0=100 (km/s)/Mpc).
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_omegam">OmegaM</code></td>
<td>

<p>Omega matter (default is 0.3).
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_omegal">OmegaL</code></td>
<td>

<p>Omega Lambda (default is for a flat Universe with OmegaL = 1-OmegaM-OmegaR = 0.7).
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_omegar">OmegaR</code></td>
<td>

<p>Omega Radiation (default is 0, but ~OmegaM/3400 is typical).
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_w0">w0</code></td>
<td>

<p>The value of dark energy equation of state at z=0.
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_wprime">wprime</code></td>
<td>

<p>The evolution term that governs how the dark energy equation of state evolves with redshift.
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_rhode">rhoDE</code></td>
<td>

<p>The z=0 reference energy density for dark energy.
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_sigma8">Sigma8</code></td>
<td>

<p>The value of Sigma8 to use if fsigma8=TRUE (by default this is a reasonable 0.8 for simplicity).
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_fsigma8">fSigma8</code></td>
<td>

<p>Logical to express whether the growth rate of structure calculated by cosgrow, cosgrowRate or cosgrowRateApprox is given as f*Sigma8 (TRUE) or simply f (FALSE). This is useful for redshift space distortion comparisons (RSD), since RSD strictly measures f*Sigma8.
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_dist">Dist</code></td>
<td>

<p>Determines the distance type, i.e. whether the Rho critical energy or mean mass densities are calculated with respect to angular / physical distances (Ang), with respect to comoving distances (Co) or with respect to physical metres (m).
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_mass">Mass</code></td>
<td>

<p>Determines the mass type, i.e. whether Rho critical energy or mean mass densities are calculated with respect to solar masses (Msun) or with respect to kilograms (kg).
</p>
</td></tr>
<tr><td><code id="cosgrow_+3A_ref">ref</code></td>
<td>

<p>The name of a reference cosmology to use, one of 137 / 737 / Planck / Planck13 / Planck15 / Planck18 / WMAP / WMAP9 / WMAP7 / WMAP5 / WMAP3 / WMAP1 / Millennium / GiggleZ. Planck = Planck18 and WMAP = WMAP9. The usage is case insensitive, so wmap9 is an allowed input. See <code><a href="#topic+cosref">cosref</a></code> for details. This overrides any other settings for H0/ OmegaM and OmegaL. If ref=137 or ref=737 no specific Sigma8 is assumed, instead Sigma8 is set to whatever the input value is set to (by default this is 0.8).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The above functions are heavily based on the equations in Hamilton A.J.S., 2001, MNRAS 322 419 and Lahav O., et al., 1991, MNRAS, 251, 136.
</p>
<p>Negative value of z&gt; -1 are allowed, which produces future predictions based on present day cosmology.
</p>
<p>The approximation routines are generally accurate to sub 1 percent, and since they do not involve numerical integration they are substantially faster when computing large grids of numbers, i.e. they are recommended for plots, since the accuracy is sub the line width.
</p>


<h3>Value</h3>

<table>
<tr><td><code>cosgrow</code></td>
<td>
<p>Returns a data.frame (even if only 1 redshift if requested) with the following parameters evaluated at the respective redshift/s:</p>
</td></tr>
</table>

<table>
<tr>
 <td style="text-align: left;">
z       </td><td style="text-align: left;"> Requested redshift</td>
</tr>
<tr>
 <td style="text-align: left;">
a       </td><td style="text-align: left;"> Universe expansion factor, as given by a=1/(1+z)</td>
</tr>
<tr>
 <td style="text-align: left;">
H       </td><td style="text-align: left;"> Hubble expansion rate in units of (km/s)/Mpc</td>
</tr>
<tr>
 <td style="text-align: left;">
CoVel   </td><td style="text-align: left;"> Cosmological recession velocity in units of km/s</td>
</tr>
<tr>
 <td style="text-align: left;">
OmegaM  </td><td style="text-align: left;"> Omega Matter</td>
</tr>
<tr>
 <td style="text-align: left;">
OmegaL  </td><td style="text-align: left;"> Omega Lambda</td>
</tr>
<tr>
 <td style="text-align: left;">
OmegaR  </td><td style="text-align: left;"> Omega Radiation</td>
</tr>
<tr>
 <td style="text-align: left;">
OmegaK  </td><td style="text-align: left;"> Omega K(c)urvature</td>
</tr>
<tr>
 <td style="text-align: left;">
Decelq  </td><td style="text-align: left;"> Traditional deceleration parameter q</td>
</tr>
<tr>
 <td style="text-align: left;">
Factor  </td><td style="text-align: left;"> Exact growth factor (g, see cosgrowFactor below for details)</td>
</tr>
<tr>
 <td style="text-align: left;">
Rate    </td><td style="text-align: left;"> Exact growth rate (f or f*Sigma8, see cosgrowRate below for details)</td>
</tr>
<tr>
 <td style="text-align: left;">
Sigma8  </td><td style="text-align: left;"> Power spectrum fluctuation amplitude on the scale 8 Mpc/z</td>
</tr>
<tr>
 <td style="text-align: left;">
RhoCrit </td><td style="text-align: left;"> Critical energy density of the Universe at z, where <code class="reqn">\rho_{crit}=(3.H(z)^2)/(8.\pi.G)</code>, in units of <code class="reqn">M_{\odot}/Mpc^3</code></td>
</tr>
<tr>
 <td style="text-align: left;">
RhoMean </td><td style="text-align: left;"> Mean mass density of the Universe at z, where <code class="reqn">\rho_{mean}=\rho_{crit}.\Omega_{M}(z)</code>, in units of <code class="reqn">M_{\odot}/Mpc^3</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The outputs of the standalone functions are:
</p>
<table>
<tr><td><code>cosgrowz</code></td>
<td>
<p>Returns the input redshift (only included for clarity).</p>
</td></tr>
<tr><td><code>cosgrowa</code></td>
<td>
<p>Returns the Universe expansion factor, as given by a=1/(1+z).</p>
</td></tr>
<tr><td><code>cosgrowH</code></td>
<td>
<p>Returns the value of the Hubble expansion rate at z, in units of km/s/Mpc.</p>
</td></tr>
<tr><td><code>cosgrowCoVel</code></td>
<td>
<p>Returns the value of the cosmological recession velocity of the object in units of km/s.</p>
</td></tr>
<tr><td><code>cosgrowPecVel</code></td>
<td>
<p>Returns the value of the peculiar velocity of the object in units of km/s.</p>
</td></tr>
<tr><td><code>cosgrowOmegaM</code></td>
<td>
<p>Returns the value of Omega Matter at z.</p>
</td></tr>
<tr><td><code>cosgrowOmegaL</code></td>
<td>
<p>Returns the value of Omega Lambda at z.</p>
</td></tr>
<tr><td><code>cosgrowOmegaR</code></td>
<td>
<p>Returns the value of Omega Radiation at z.</p>
</td></tr>
<tr><td><code>cosgrowOmegaK</code></td>
<td>
<p>Returns the value of Omega K(c)urvature at z.</p>
</td></tr>
<tr><td><code>cosgrowDecelq</code></td>
<td>
<p>Returns the traditional deceleration parameter q, given by q=OmegaM/2+Omegar-OmegaL.</p>
</td></tr>
<tr><td><code>cosgrowEoSwDE</code></td>
<td>
<p>Returns w for the dark energy equation of state, where <code class="reqn">P=w.\rho_{DE}.c^2</code> and <code class="reqn">w=w_0+2.w'.(1-1/(1+z))</code>, as described in Wright (2006).</p>
</td></tr>
<tr><td><code>cosgrowRhoDE</code></td>
<td>
<p>Returns the energy density for dark energy, given by <code class="reqn">\rho_{DE}.e^{-6.w'.(1-1/(1 + z))}/(1 + z)^{-(3 + 3.w_0 + 6.w')}</code>, as described in Wright (2006)..</p>
</td></tr>
<tr><td><code>cosgrowFactor</code></td>
<td>
<p>Returns the exact value of the growth factor (typically referred to as 'g' in the astronomy literature), at z. This is defined such that it equals 1 at z=Inf and is less than 1 at lower z.</p>
</td></tr>
<tr><td><code>cosgrowRate</code></td>
<td>
<p>Returns either the true (typically referred to as 'f' in the astronomy literature) or RSD type (f*Sigma8) value of the growth rate of structure, at z. This is defined such that it equals 1 at z=Inf and is less than 1 at lower z.</p>
</td></tr>
<tr><td><code>cosgrowSigma8</code></td>
<td>
<p>Returns the power spectrum fluctuation amplitude on the scale 8 Mpc/z at z, and is unitless.</p>
</td></tr>
<tr><td><code>cosgrowFactorApprox</code></td>
<td>
<p>Returns the approximate value of the growth factor (typically referred to as 'g' in the astronomy literature), at z. This is defined such that it equals 1 at z=Inf and is less than 1 at lower z.</p>
</td></tr>
<tr><td><code>cosgrowRateApprox</code></td>
<td>
<p>Returns either the approximate true (typically referred to as 'f' in the astronomy literature) or approximate RSD type (f*Sigma8) value of the growth rate of structure, at z. This is defined such that it equals 1 at z=Inf and is less than 1 at lower z.</p>
</td></tr>
<tr><td><code>cosgrowSigma8Approx</code></td>
<td>
<p>Returns the approximate power spectrum fluctuation amplitude on the scale 8 Mpc/z at z, and is unitless.</p>
</td></tr>
<tr><td><code>cosgrowRhoCrit</code></td>
<td>
<p>Returns the critical energy density of the Universe at z, where <code class="reqn">\rho_{crit}=(3.H(z)^2)/(8.\pi.G)</code>, in units of <code class="reqn">M_{\odot}/Mpc^3</code>.</p>
</td></tr>
<tr><td><code>cosgrowRhoMean</code></td>
<td>
<p>Returns the mean mass density of the Universe at z, where <code class="reqn">\rho_{mean}=\rho_{crit}.\Omega_{M}(z)</code>, in units of <code class="reqn">M_{\odot}/Mpc^3</code>.</p>
</td></tr>
<tr><td><code>cosgrowDeltaVir</code></td>
<td>
<p>Returns the delta-critical virial radius overdensity criterion for a range of flat Universes with varying OmegaM. Taken from Eqn. 6 of Bryan &amp; Norman (1998).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The difference between RhoCrit and RhoMean at z=0 is simply RhoMean=RhoCrit*OmegaM. Corrected for 1/(1+z)^3 RhoMean stays constant with redshift (as it should- to first order we do not gain or lose mass within a comoving volume).
</p>
<p>The growth rate and growth factor does not make use of OmegaR in the cosgrow function, hence OmegaR cannot be provided in the individual functions. This is because correctly accounting for the effect of radiation pressure before the surface of last scattering (z~1100) on the growth rate of structure is highly complex, and beyond the scope of this package. In the case of cosgrow, even if OmegaR is specified it is, in effect, set to zero when making growth factor and rate calculations.
</p>
<p>The evolution of the dark matter equation of state (w) is parameterised as described in Wright (2006).
</p>
<p>It is important to remember that H is in physical units for both the numerator and denominator (i.e. 'proper' at a given redshift, so the units are km/s / pMpc). To ask the question &quot;is the Universe accelerating?&quot; is to really ask &quot;is the expansion factor accelerating?&quot;. This requires the denominator to be in comoving units (so rescaling for proper distances today) and measuring the differential with time or redshift. You will only find an accelerating Universe when dividing H(z)/(1+z)! See the examples to see how we can find this location, and that it is consistent with the start of acceleration calculated from the decleration parameter (q) directly.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>References</h3>

<p>Based on the equations in:
</p>
<p>Bryan &amp; Norman, 1998, ApJ, 495, 80
</p>
<p>Davis T.M. &amp; Lineweaver, Charles H., 2004, PASA, 21, 97
</p>
<p>Davis T.M. &amp; Scrimgeour M.I., 2014, MNRAS, 442, 1117
</p>
<p>Hamilton A.J.S., 2001, MNRAS 322 419
</p>
<p>Lahav O., et al., 1991, MNRAS, 251, 136
</p>
<p>Peacock J.A., 1999, Cosmological Physics, Cambridge University Press
</p>
<p>Wright E.L., 2006, PASP, 118, 1711
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosvol">cosvol</a></code>, <code><a href="#topic+cosmap">cosmap</a></code>,  <code><a href="#topic+cosdist">cosdist</a></code>, <code><a href="#topic+cosref">cosref</a></code>, <code><a href="#topic+coshalo">coshalo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  cosgrow(0.3)
  cosgrow(0.3,ref='Planck')
  cosgrowz(0.3)
  cosgrowa(0.3)
  cosgrowH(0.3)
  cosgrowCoVel(0.3)
  cosgrowPecVel(0.3,0.31)
  cosgrowOmegaM(0.3)
  cosgrowOmegaL(0.3)
  cosgrowOmegaK(0.3)
  sum(cosgrowOmegaM(0.3)+cosgrowOmegaL(0.3)+cosgrowOmegaK(0.3)) #Still 1.
  cosgrowDecelq(0.3)
  cosgrowEoSwDE(0.3)
  cosgrowFactor(0.3)
  cosgrowFactorApprox(0.3) #Approximation better than 1% for reasonable cosmologies.
  cosgrowRate(0.3)
  cosgrowRateApprox(0.3) #Approximation better than 1% for reasonable cosmologies.
  cosgrowRhoCrit(0.3)
  cosgrowRhoMean(0.3)
  cosgrowRhoMean(0)-cosgrowRhoMean(2,Dist='Ang')/(1+2)^3 #Mass is conserved in co-vol
  cosgrowRhoMean(0)-cosgrowRhoMean(10,Dist='Co') #Mass is conserved in co-vol
  
  # Various recessional velocities (see Figure 2 of Davis &amp; Lineweaver 2004):
  
  plot(10^seq(-1,4,by=0.01), cosgrowCoVel(10^seq(-1,4,by=0.01), ref='planck')
  /299792.458, type='l', log='x', xlab='z', ylab='Cosmological Recession Velocity / c')
  lines(10^seq(-1,4,by=0.01), cosgrowPecVel(0,10^seq(-1,4,by=0.01))/299792.458, col='red')
  lines(10^seq(-1,4,by=0.01), 10^seq(-1,4,by=0.01), col='blue')
  abline(h=1,v=1.5,lty=2)
  legend('topleft', legend=c('GR', 'SR', 'Approx (cz)', 'Superluminal'), lty=c(1,1,1,2),
  col=c('black','red','blue','black'))
  
  # Comparison of the various energy densities that make up the Universe for Planck 2013:
  
  plot(cosdistUniAgeAtz(10^seq(-3,4.9,by=0.1), ref='Planck')*1e9,
  cosgrowRhoCrit(10^seq(-3,4.9,by=0.1), ref='Planck', Dist='m', Mass='kg')*
  cosgrowOmegaR(10^seq(-3,4.9,by=0.1), ref='Planck'), type='l',log='xy',
  xlab='Years since Universe formed', ylab=expression('Energy Density'*(kg/m^3)))
  
  lines(cosdistUniAgeAtz(10^seq(-3,4.9,by=0.1), ref='Planck')*1e9,
  cosgrowRhoCrit(10^seq(-3,4.9,by=0.1), ref='Planck', Dist='m', Mass='kg')*
  cosgrowOmegaM(10^seq(-3,4.9,by=0.1), ref='Planck'), col='red')
  
  lines(cosdistUniAgeAtz(10^seq(-3,4.9,by=0.1), ref='Planck')*1e9,
  cosgrowRhoCrit(10^seq(-3,4.9,by=0.1), ref='Planck', Dist='m', Mass='kg')*
  cosgrowOmegaL(10^seq(-3,4.9,by=0.1), ref='Planck'), col='blue')

  abline(v=cosdistUniAgeAtz(0.33,ref='Planck')*1e9,lty=2) # Matter = Vacuum
  abline(v=cosdistUniAgeAtz(3391,ref='Planck')*1e9,lty=2) # Matter = Radiation
  
  legend('topright', legend=c('Radiation Energy Density', 'Matter Energy Density',
  'Vacuum Energy Density'), lty=1, col=c('black','red','blue'))
  
  # Where's the acceleration?
  plot(seq(0,2,len=1e3),cosgrowH(seq(0,2,len=1e3)),type='l',xlab='z',
  ylab='H(z) / km/s / pMpc')
  # There it is!
  plot(seq(0,2,len=1e3),cosgrowH(seq(0,2,len=1e3))/(1+seq(0,2,len=1e3)),
  type='l',xlab='z',ylab='H(z) / km/s / cMpc')
  #When does it start accelerating?
  accel.loc=which.min(abs(cosgrowDecelq(seq(0,2,len=1e3))))
  abline(v=seq(0,2,len=1e3)[accel.loc],lty=2)
</code></pre>

<hr>
<h2 id='coshalo'>
Virial halo conversion functions
</h2><span id='topic+coshalo'></span><span id='topic+coshaloMvirToSigma'></span><span id='topic+coshaloSigmaToMvir'></span><span id='topic+coshaloMvirToRvir'></span><span id='topic+coshaloRvirToMvir'></span><span id='topic+coshaloSigmaToRvir'></span><span id='topic+coshaloRvirToSigma'></span><span id='topic+coshaloSigmaToTvir'></span>

<h3>Description</h3>

<p>All 6 Virial parameter conversion functions. Each can map precisely to the other as a one paramter function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coshaloMvirToSigma(Mvir=1e+12, z=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, Rho='crit', Dist='Co', DeltaVir=200, Munit=1, Lunit=1e6, Vunit=1e3, Dim=3, ref)
coshaloSigmaToMvir(Sigma=230, z=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, Rho='crit', Dist='Co', DeltaVir=200, Munit=1, Lunit=1e6, Vunit=1e3, Dim=3, ref)
coshaloMvirToRvir(Mvir=1e12, z=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, Rho='crit', Dist='Co', DeltaVir=200, Munit=1, Lunit=1e6, Vunit=1e3, Dim=3, ref)
coshaloRvirToMvir(Rvir=162.635, z=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, Rho='crit', Dist='Co', DeltaVir=200, Munit=1, Lunit=1e6, Vunit=1e3, Dim=3, ref)
coshaloSigmaToRvir(Sigma=230, z=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, Rho='crit', Dist='Co', DeltaVir=200, Munit=1, Lunit=1e6, Vunit=1e3, Dim=3, ref)
coshaloRvirToSigma(Rvir=162.635, z=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, Rho='crit', Dist='Co', DeltaVir=200, Munit=1, Lunit=1e6, Vunit=1e3, Dim=3, ref)
coshaloSigmaToTvir(Sigma=230, Vunit=1e3, Tunit='K', Type='halo', Dim=3) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coshalo_+3A_mvir">Mvir</code></td>
<td>

<p>Mass within virial radius in units of 'Munit'.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_sigma">Sigma</code></td>
<td>

<p>Velocity dispersion (3D) within virial radius in units of 'Vunit'. For coshaloSigmaToTvir the Sigma input should be the virial Sigma which can be found by setting DeltaVir='get' in the the other coshalo functions.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_rvir">Rvir</code></td>
<td>

<p>Virial radius (3D) in units of 'Lunit'.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_z">z</code></td>
<td>

<p>Cosmological redshift, where z must be &gt; -1 (can be a vector).
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_h0">H0</code></td>
<td>

<p>Hubble constant as defined at z=0 (default is H0=100 (km/s)/Mpc).
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_omegam">OmegaM</code></td>
<td>

<p>Omega Matter (default is 0.3).
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_omegal">OmegaL</code></td>
<td>

<p>Omega Lambda (default is for a flat Universe with OmegaL = 1-OmegaM = 0.7).
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_omegar">OmegaR</code></td>
<td>

<p>Omega Radiation (default is 0, but OmegaM/3400 is typical).
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_rho">Rho</code></td>
<td>

<p>Set whether the critical energy density is used (crit) or the mean mass density (mean).
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_dist">Dist</code></td>
<td>

<p>Determines the distance type, i.e. whether the Rho critical energy or mean mass densities are calculated with respect to angular / physical distances (Ang) or with respect to comoving distances (Co). In effect this means Rvir values are either angular / physical (Ang) or comoving (Co). It does not affect Mvir &lt;-&gt; Sigma conversions, but does affect Mvir &lt;-&gt; Rvir and Rvir &lt;-&gt; Sigma. 
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_deltavir">DeltaVir</code></td>
<td>

<p>Desired overdensity of the halo with respect to Rho. If set to 'get' it will estimate the required DeltaVir for a virial collapse using the <code><a href="#topic+cosgrowDeltaVir">cosgrowDeltaVir</a></code> function.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_munit">Munit</code></td>
<td>

<p>Base mass unit in multiples of Msun.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_lunit">Lunit</code></td>
<td>

<p>Base length unit in multiples of parsecs.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_vunit">Vunit</code></td>
<td>

<p>Base velocity unit in multiples of m/s.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_type">Type</code></td>
<td>

<p>Specify the 'halo' or 'gas' temperature to be computed.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_tunit">Tunit</code></td>
<td>

<p>Specify the output temperature to be Kelvin ('K'), 'eV' or 'keV'.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_dim">Dim</code></td>
<td>

<p>The dimensional type for the halo (either the 2 or 3). 3 (default) means quantities are intrinsic 3D values. 2 means quantities are for projected systems (i.e. radius and velocity dispersion are compressed). From comparisons to simulations (so NFW, c~5 halos) Rvir[proj]=Rvir[3D]/1.37 and Sigma[proj]=Sigma[3D]/sqrt(3). The former has dependence on the halo profile (so is approximate), whereas the latter is a dimensionality argument that should hold for any virialised system. Note that for projected systems Sigma is measured along one dimension: the line-of-site.
</p>
</td></tr>
<tr><td><code id="coshalo_+3A_ref">ref</code></td>
<td>

<p>The name of a reference cosmology to use, one of 137 / 737 / Planck / Planck13 / Planck15 / Planck18 / WMAP / WMAP9 / WMAP7 / WMAP5 / WMAP3 / WMAP1 / Millennium / GiggleZ. Planck = Planck18 and WMAP = WMAP9. The usage is case insensitive, so wmap9 is an allowed input. See <code><a href="#topic+cosref">cosref</a></code> for details. This overrides any other settings for H0/ OmegaM and OmegaL.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions allow for various analytic conversions between the 3 major properties related to virial radius: the mass, velocity dispresion and size. The default properties calculate properties for 1e12 Msun halos and assume masses in Msun, velocities in km/s and distances in Kpc.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coshaloMvirToSigma</code></td>
<td>
<p>Outputs approximate velocity dispersion (in units of Vunit) given mass (this is exactly the escape velocity at Rvir).</p>
</td></tr>
<tr><td><code>coshaloSigmaToMvir</code></td>
<td>
<p>Outputs mass (in units of Munit) given velocity dispersion.</p>
</td></tr>
<tr><td><code>coshaloMvirToRvir</code></td>
<td>
<p>Outputs radius (in units of Lunit) given mass.</p>
</td></tr>
<tr><td><code>coshaloRvirToMvir</code></td>
<td>
<p>Outputs mass (in units of Munit) given radius.</p>
</td></tr>
<tr><td><code>coshaloSigmaToRvir</code></td>
<td>
<p>Outputs radius (in units of Lunit) given velocity dispersion.</p>
</td></tr>
<tr><td><code>coshaloRvirToSigma</code></td>
<td>
<p>Outputs approximate velocity dispersion (in units of Vunit) given radius (this is exactly the escape velocity at Rvir).</p>
</td></tr>
<tr><td><code>coshaloSigmaToTvir</code></td>
<td>
<p>Output temperture (in units of Tunit) given velocity dispersion. Based on Eqns. 3/7/8/9 of Bryan &amp; Norman (1998).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham, Chris Power
</p>


<h3>References</h3>

<p>coshaloSigmaToTvir based on the equations in:
</p>
<p>Bryan &amp; Norman, 1998, ApJ, 495, 80
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosvol">cosvol</a></code>, <code><a href="#topic+cosmap">cosmap</a></code>,  <code><a href="#topic+cosdist">cosdist</a></code>, <code><a href="#topic+cosgrow">cosgrow</a></code>, <code><a href="#topic+cosNFW">cosNFW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coshaloMvirToSigma(1e13) # Velocity in km/s
coshaloMvirToSigma(1e13, Vunit=1) # Velocity in m/s
coshaloSigmaToMvir(coshaloMvirToSigma(1e13, Vunit=1),Vunit=1)
coshaloMvirToRvir(1e13) #Radius in kpc
coshaloSigmaToRvir(coshaloMvirToSigma(1e13, Vunit=1),Vunit=1)

#Some sanity checks

rho_crit200=cosgrowRhoCrit(z=0)*200 #200 times rho critical at z=0
rho_mean200=cosgrowRhoMean(z=0)*200 #200 times rho mean at z=0
#For a 10^12 Msun/h halo, the radius in Mpc/h where the contained density equals rho_crit*200
rad_crit200=(1e12/rho_crit200*3/4/pi)^(1/3)
coshaloMvirToRvir(1e12,Lunit=1e6)-rad_crit200 # ~0 as expected
#For a 10^12 Msun/h halo, the radius in Mpc/h where the contained density equals rho_crit*200
rad_mean200=(1e12/rho_mean200*3/4/pi)^(1/3) # ~0 as expected
coshaloMvirToRvir(1e12,Lunit=1e6,Rho='mean')-rad_mean200
</code></pre>

<hr>
<h2 id='cosmap'>
Cosmological Mapping Functions
</h2><span id='topic+cosmap'></span><span id='topic+cosmapval'></span><span id='topic+cosmapfunc'></span>

<h3>Description</h3>

<p>Functions for mapping from one arbitrary cosmological parameter to another. This includes the provision of a generic interpolation function and another exact value lookup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosmapval(val=50, cosparam="CoVol", H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0,
w0=-1, wprime=0, Sigma8=0.8, fSigma8=FALSE, zrange=c(-0.99,100), res=100, iter=8,
out='cos', degen='lo', ref)
cosmapfunc(cosparamx="CoVol", cosparamy="z", H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR,
OmegaR=0, w0=-1, wprime=0, Sigma8=0.8, fSigma8=FALSE, zrange=c(0,20), step='z', res=100,
degen='lo', ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosmap_+3A_val">val</code></td>
<td>

<p>The value/s to be mapped from parameter cosparamx to parameter cosparamy (this can be a vector or a single number).
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_cosparam">cosparam</code></td>
<td>

<p>Cosmological parameter, must be one of: z, a, CoDist, LumDist, CoDistTran, DistMod, CoVol, UniAgeAtz, TravelTime (see <code><a href="#topic+cosdist">cosdist</a></code> help for further description of these) H, CoVel, OmegaM, OmegaL, OmegaK, Factor, Rate, RhoCrit (see <code><a href="#topic+cosgrow">cosgrow</a></code> help for further description of these). Note that AngDist and AngSize are not an option for cosparam due to degenerate redshift solutions causing problems with the approxfun mapping.
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_cosparamx">cosparamx</code></td>
<td>

<p>Cosmological parameter, must be one of: z, a, CoDist, LumDist, CoDistTran, DistMod, CoVol, UniAgeAtz, TravelTime (see <code><a href="#topic+cosdist">cosdist</a></code> help for further description of these) H, CoVel, OmegaM, OmegaL, OmegaK, Factor, Rate, RhoCrit (see <code><a href="#topic+cosgrow">cosgrow</a></code> help for further description of these). Note that AngDist and AngSize are not an option for cosparamx due to degenerate redshift solutions causing problems with the approxfun mapping.
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_cosparamy">cosparamy</code></td>
<td>

<p>Cosmological parameter, must be one of: z, a, CoDist, LumDist, AngDist, CoDistTran, DistMod, AngSize CoVol, UniAgeAtz, TravelTime (see <code><a href="#topic+cosdist">cosdist</a></code> help for further description of these) H, CoVel, OmegaM, OmegaL, OmegaK, Factor, Rate, RhoCrit (see <code><a href="#topic+cosgrow">cosgrow</a></code> help for further description of these).
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_h0">H0</code></td>
<td>

<p>Hubble constant as defined at z=0 (default is H0=100 (km/s)/Mpc).
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_omegam">OmegaM</code></td>
<td>

<p>Omega matter (default is 0.3).
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_omegal">OmegaL</code></td>
<td>

<p>Omega Lambda (default is for a flat Universe with OmegaL = 1-OmegaM = 0.7).
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_omegar">OmegaR</code></td>
<td>

<p>Omega Radiation (default is 0, but OmegaM/3400 is typical).
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_w0">w0</code></td>
<td>

<p>The value of dark energy equation of state at z=0. See <code><a href="#topic+cosgrow">cosgrow</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_wprime">wprime</code></td>
<td>

<p>The evolution term that governs how the dark energy equation of state evolves with redshift. See <code><a href="#topic+cosgrow">cosgrow</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_sigma8">Sigma8</code></td>
<td>

<p>The value of Sigma8 to use if fsigma8=TRUE (by default this is a reasonable 0.8 for simplicity).
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_fsigma8">fSigma8</code></td>
<td>

<p>Logical to express whether the growth rate of structure calculated by cosgrow, cosgrowRate or cosgrowRateApprox is given as f*Sigma8 (TRUE) or simply f (FALSE). This is useful for redshift space distortion comparisons (RSD), since RSD strictly measures f*Sigma8.
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_zrange">zrange</code></td>
<td>

<p>Lower and upper z limits that the approxfun mapping is generated over (increase range if default is not sufficient, and decrease if it is wasteful, i.e. the possible redshift window is known to be quite narrow).
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_step">step</code></td>
<td>

<p>The type of stepping used. Allowed values are 'z' (uniform stepping in z), 'logz' (uniform stepping in log10(1+z) and expansion factor 'a' (uniform stepping in a=1/(1+z)). Default is z. For mappings using time (UniAgeNow, UniAgeAtz, TravelTime) or comoving quantities (CoDist, CoDistTran, CoVol) or distance modulus (DistMod) 'a' or 'logz' map the numeric range more uniformly. This is because a and log10(1+z) are approximately linear in light travel time (positive and negative correlation respectively), and typically they have better behaviour than stepping uniformly in z directly.
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_res">res</code></td>
<td>

<p>The resolution of steps. Larger numbers will be more accurate, but will be slower to compute.
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_iter">iter</code></td>
<td>

<p>The number of iterations to make when calculating the exact location of a given cosmological parameter when using cosmapval.  
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_out">out</code></td>
<td>

<p>Either out='cos', in which case the output is a data.frame containing the output of <code><a href="#topic+cosdist">cosdist</a></code> and <code><a href="#topic+cosgrow">cosgrow</a></code> for the specified input vaue, or out='z', in which case the output is a vector of the corresponding redshift (z) values.
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_degen">degen</code></td>
<td>

<p>In cases where solutions are degenerate (multiple y solutions for a single x), this specifies whether to calculate the lower y solution (degen='lo'), or the higher y solutions (degen='hi').
</p>
</td></tr>
<tr><td><code id="cosmap_+3A_ref">ref</code></td>
<td>

<p>The name of a reference cosmology to use, one of 137 / 737 / Planck / Planck13 / Planck15 / Planck18 / WMAP / WMAP9 / WMAP7 / WMAP5 / WMAP3 / WMAP1 / Millennium / GiggleZ. Planck = Planck18 and WMAP = WMAP9. The usage is case insensitive, so wmap9 is an allowed input. See <code><a href="#topic+cosref">cosref</a></code> for details. This overrides any other settings for H0/ OmegaM and OmegaL. If ref=137 or ref=737 no specific Sigma8 is assumed, instead Sigma8 is set to whatever the input value is set to (by default this is 0.8).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default zrange and res should be sufficient for most reasonable cosmologies if the approximate redshift location of the region to be mapped is entirely unknown.
</p>
<p>Predictions into the future are possible if val is set to negative (distance and volume parameters) or below their present day value (age and growth parameters). However, many potential values are outside of the asymptotic limits, e.g. using the default 737 cosmology H is tending to 83.666, i.e. it will fail if you request H=83 but work if your resuest H=84.
</p>
<p>The default res and iter for cosmapval is appropriate for most mappings with -0.99 &lt; z &lt; 100 using a fiducial 737 cosmology. If this proves insufficient (this should be obvious from error column) then increase both of these. Overall accuracy goes as res^iter.
</p>


<h3>Value</h3>

<p>If out='cos', cosmapval contains the concatenation of the cosdist (with age=TRUE and error=TRUE) and cosgrow functions for parameter 'cosparam' at value 'val'. The 'z' and 'a' columns are only included once (from the output of cosdist). See <code><a href="#topic+cosdist">cosdist</a></code> and <code><a href="#topic+cosgrow">cosgrow</a></code> for information on the cosdist and cosgrow outputs. If out='z', then cosmapval merely returns the corresponding redshifts.
</p>
<p>The cosmapval output (when out='cos') includes an additional final column named 'MapError' which gives the approximate relative error of the values returned compared to the desired lookup location. Smaller is obviously better, but at the cost of computational time.
</p>
<p>cosmapfunc uses base R approxfun to map cosparamx onto cosparamy between zrange[1] and zrange[2] in uniform steps of expansion factor (a=1/(1+z)). cosmofunc returns the output function created by approxfun.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>References</h3>

<p>Based on the equations in:
</p>
<p>Hogg D.W., 1999, arXiv, 9905116
</p>
<p>Wright E.L., 2006, PASP, 118, 1711
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosdist">cosdist</a></code>, <code><a href="#topic+cosvol">cosvol</a></code>, <code><a href="#topic+cosgrow">cosgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tempfunc=cosmapfunc('CoVol', 'UniAgeAtz')
tempfunc(50)

cosmapval(50:60, 'CoVol')

#A future prediction:

cosmapval(59, 'H', H0=70)

## End(Not run)
</code></pre>

<hr>
<h2 id='Cosmology+20Reference+20Sets'>
Cosmology parameter data included in celestial package.
</h2><span id='topic+cosref'></span>

<h3>Description</h3>

<p>cosref:   Cosmology H0 / OmegaM / OmegaL / OmegaR (via OmegaM/zeq) and Sigma8 parameters taken from Planck (13/15/18), WMAP (1/3/5/9), Millennium Simulation and GiggleZ. Not all of these exist for each source, so NA values are used in these cases.
</p>
<p>For Planck we use the second column of the main cosmology table, which does no use external data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cosref)
</code></pre>


<h3>Details</h3>

<p>The included data is a table of the following cosmological parameters:
</p>

<table>
<tr>
 <td style="text-align: left;">
Ref         </td><td style="text-align: left;">  H0    </td><td style="text-align: left;">  OmegaM </td><td style="text-align: left;">  OmegaL </td><td style="text-align: left;">  OmegaR        </td><td style="text-align: left;">  Sigma8  </td>
</tr>
<tr>
 <td style="text-align: left;">
737         </td><td style="text-align: left;">  70.0  </td><td style="text-align: left;">  0.300  </td><td style="text-align: left;">  0.700  </td><td style="text-align: left;">  NA            </td><td style="text-align: left;">  NA      </td>
</tr>
<tr>
 <td style="text-align: left;">
137         </td><td style="text-align: left;">  100.0 </td><td style="text-align: left;">  0.300  </td><td style="text-align: left;">  0.700  </td><td style="text-align: left;">  NA            </td><td style="text-align: left;">  NA      </td>
</tr>
<tr>
 <td style="text-align: left;">
Planck      </td><td style="text-align: left;">  68.4  </td><td style="text-align: left;">  0.301  </td><td style="text-align: left;">  0.699  </td><td style="text-align: left;">  8.985075e-05  </td><td style="text-align: left;">  0.793   </td>
</tr>
<tr>
 <td style="text-align: left;">
Planck18    </td><td style="text-align: left;">  68.4  </td><td style="text-align: left;">  0.301  </td><td style="text-align: left;">  0.699  </td><td style="text-align: left;">  8.985075e-05  </td><td style="text-align: left;">  0.793   </td>
</tr>
<tr>
 <td style="text-align: left;">
Planck15    </td><td style="text-align: left;">  67.8  </td><td style="text-align: left;">  0.308  </td><td style="text-align: left;">  0.692  </td><td style="text-align: left;">  9.150327e-05  </td><td style="text-align: left;">  0.815   </td>
</tr>
<tr>
 <td style="text-align: left;">
Planck13    </td><td style="text-align: left;">  67.3  </td><td style="text-align: left;">  0.315  </td><td style="text-align: left;">  0.685  </td><td style="text-align: left;">  9.289295e-05  </td><td style="text-align: left;">  0.829   </td>
</tr>
<tr>
 <td style="text-align: left;"> 
WMAP        </td><td style="text-align: left;">  69.7  </td><td style="text-align: left;">  0.288  </td><td style="text-align: left;">  0.712  </td><td style="text-align: left;">  8.780488e-05  </td><td style="text-align: left;">  0.817   </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP9       </td><td style="text-align: left;">  69.7  </td><td style="text-align: left;">  0.288  </td><td style="text-align: left;">  0.712  </td><td style="text-align: left;">  8.780488e-05  </td><td style="text-align: left;">  0.817   </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP7       </td><td style="text-align: left;">  70.4  </td><td style="text-align: left;">  0.275  </td><td style="text-align: left;">  0.725  </td><td style="text-align: left;">  8.569648e-05  </td><td style="text-align: left;">  0.816   </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP5       </td><td style="text-align: left;">  70.5  </td><td style="text-align: left;">  0.274  </td><td style="text-align: left;">  0.726  </td><td style="text-align: left;">  8.45679e-05   </td><td style="text-align: left;">  0.812   </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP3       </td><td style="text-align: left;">  70.4  </td><td style="text-align: left;">  0.268  </td><td style="text-align: left;">  0.732  </td><td style="text-align: left;">  NA            </td><td style="text-align: left;">  0.776   </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP1       </td><td style="text-align: left;">  72.0  </td><td style="text-align: left;">  0.290  </td><td style="text-align: left;">  0.710  </td><td style="text-align: left;">  NA            </td><td style="text-align: left;">  0.900   </td>
</tr>
<tr>
 <td style="text-align: left;">
Millennium  </td><td style="text-align: left;">  73.0  </td><td style="text-align: left;">  0.250  </td><td style="text-align: left;">  0.750  </td><td style="text-align: left;">  NA            </td><td style="text-align: left;">  0.900   </td>
</tr>
<tr>
 <td style="text-align: left;">
GiggleZ     </td><td style="text-align: left;">  70.5  </td><td style="text-align: left;">  0.273  </td><td style="text-align: left;">  0.727  </td><td style="text-align: left;">  NA            </td><td style="text-align: left;">  0.812   </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>References</h3>


<table>
<tr>
 <td style="text-align: left;">
Name        </td><td style="text-align: left;">  Full Reference                                </td><td style="text-align: left;">  arXiv Refence   </td>
</tr>
<tr>
 <td style="text-align: left;">
737         </td><td style="text-align: left;">  Simplified concordance cosomology             </td><td style="text-align: left;">  NA              </td>
</tr>
<tr>
 <td style="text-align: left;">
137         </td><td style="text-align: left;">  Simplified concordance cosomology             </td><td style="text-align: left;">  NA              </td>
</tr>
<tr>
 <td style="text-align: left;">
Planck 18   </td><td style="text-align: left;">  Planck Collaboration, 2018, arXiv, 1807.06209 </td><td style="text-align: left;">  arxiv:1807.06209 </td>
</tr>
<tr>
 <td style="text-align: left;">
Planck 15   </td><td style="text-align: left;">  Planck Collaboration, 2015, arXiv, 1502.01589 </td><td style="text-align: left;">  arxiv:1502.01589 </td>
</tr>
<tr>
 <td style="text-align: left;">
Planck 13   </td><td style="text-align: left;">  Planck Collaboration, 2014, A&amp;A, 571, 16      </td><td style="text-align: left;">  arXiv:1303.5076v3 </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP9	      </td><td style="text-align: left;">  Hinshaw G., et al., 2013, ApJS, 208, 19       </td><td style="text-align: left;">  arXiv:1212.5226v3 </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP7	      </td><td style="text-align: left;">  Komatsu E., et al., 2010, ApJS, 192, 18       </td><td style="text-align: left;">  arXiv:1001.4538v3 </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP5	      </td><td style="text-align: left;">  Komatsu E., et al., 2009, ApJS, 180, 306      </td><td style="text-align: left;">  arXiv:0803.0547v2 </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP3	      </td><td style="text-align: left;">  Spergel D. N., et al., 2007, ApJS, 170, 377   </td><td style="text-align: left;">  arXiv:astro-ph/0603449v2 </td>
</tr>
<tr>
 <td style="text-align: left;">
WMAP1	      </td><td style="text-align: left;">  Spergel D. N., et al., 2003, ApJS, 148, 175   </td><td style="text-align: left;">  arXiv:astro-ph/0302209v3 </td>
</tr>
<tr>
 <td style="text-align: left;">
Millennium  </td><td style="text-align: left;">	Springel V., et al., 2005, Nature, 435, 629   </td><td style="text-align: left;">  arXiv:astro-ph/0504097v2 </td>
</tr>
<tr>
 <td style="text-align: left;">
GiggleZ	    </td><td style="text-align: left;">  Poole G. B., et al., 2015, MNRAS, 449, 1454   </td><td style="text-align: left;">  arXiv:1407.0390v1 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+cosvol">cosvol</a></code>, <code><a href="#topic+cosmap">cosmap</a></code>,  <code><a href="#topic+cosdist">cosdist</a></code>, <code><a href="#topic+cosgrow">cosgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cosref)
cosref[cosref[,'Ref']=='Planck',]
</code></pre>

<hr>
<h2 id='cosNFW'>
Navarro Frenk and White profile
</h2><span id='topic+cosNFW'></span><span id='topic+cosNFWmass_c'></span><span id='topic+cosNFWmass_Rmax'></span><span id='topic+cosNFWvcirc'></span><span id='topic+cosNFWvesc'></span><span id='topic+cosNFWsigma'></span><span id='topic+cosNFWsigma_mean'></span><span id='topic+cosNFWgamma'></span><span id='topic+cosNFWduffym2c'></span>

<h3>Description</h3>

<p>Density and total mass values for Navaro Frenk and White (NFW) profiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosNFW(Rad=0, Rho0=2.412e15, Rs=0.03253)
cosNFWmass_c(Rho0=2.412e15, Rs=0.03253, c=5, Munit = 1, Lunit = 1e+06)
cosNFWmass_Rmax(Rho0=2.412e15, Rs=0.03253, Rmax=0.16265, Munit = 1, Lunit = 1e+06)
cosNFWvcirc(Rad = 0.16264, Mvir = 1e+12, c = 5, f = Inf, z = 0, H0 = 100, OmegaM = 0.3,
OmegaL = 1 - OmegaM - OmegaR, OmegaR = 0, Rho = "crit", Dist = "Co", DeltaVir = 200,
Munit = 1, Lunit = 1e+06, Vunit = 1000, ref)
cosNFWvesc(Rad = 0.16264, Mvir = 1e+12, c = 5, f = Inf, z = 0, H0 = 100, OmegaM = 0.3,
OmegaL = 1 - OmegaM - OmegaR, OmegaR = 0, Rho = "crit", Dist = "Co", DeltaVir = 200,
Munit = 1, Lunit = 1e+06, Vunit = 1000, ref)
cosNFWsigma(Rad=0.03253, Rs=0.03253, c=5, z = 0, H0 = 100, OmegaM = 0.3,
OmegaL = 1-OmegaM-OmegaR, OmegaR=0, Rho = "crit", DeltaVir = 200, Munit = 1,
Lunit = 1e+06, Vunit = 1000, ref)
cosNFWsigma_mean(Rad=0.03253, Rs=0.03253, c=5, z = 0, H0 = 100, OmegaM = 0.3,
OmegaL = 1-OmegaM-OmegaR, OmegaR=0, Rho = "crit", DeltaVir = 200, Munit = 1,
Lunit = 1e+06, Vunit = 1000, ref)
cosNFWgamma(Rad=0.03253, Rs=0.03253, c=5, SigmaC=1, z = 0, H0 = 100,
OmegaM = 0.3, OmegaL = 1-OmegaM-OmegaR, OmegaR=0, Rho = "crit", DeltaVir = 200,
Munit = 1, Lunit = 1e+06, Vunit = 1000, ref)
cosNFWduffym2c(M=2e12, z = 0, H0 = 100, OmegaM = 0.3, OmegaL = 1-OmegaM-OmegaR,
OmegaR=0, Rho = "crit", A=6.71, B=-0.091, C=-0.44, Munit = 1, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosNFW_+3A_mvir">Mvir</code></td>
<td>

<p>Mass within virial radius in units of 'Munit'.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_rad">Rad</code></td>
<td>

<p>Radius at which to calculate output in units of 'Lunit'. Either this is a 3D radius (cosNFW) or a projected 2D radius (cosNFWsigma/cosNFWsigma_mean).
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_rho0">Rho0</code></td>
<td>

<p>The normalising factor.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_rs">Rs</code></td>
<td>

<p>The NFW profile scale radius, where Rs=Rmax/c, in units of 'Munit'.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_c">c</code></td>
<td>

<p>The NFW profile concentration parameter, where c=Rmax/Rs.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_f">f</code></td>
<td>

<p>The NFW profile truncation radius in units of <span class="option">Rmax</span>.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_rmax">Rmax</code></td>
<td>

<p>The NFW profile Rmax parameter, where Rmax=Rs*c, in units of 'Lunit'.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_sigmac">SigmaC</code></td>
<td>

<p>The critical surface mass density (when SigmaC=1 we compute the excess surface density / ESD). See <code><a href="#topic+cosdistCrit">cosdistCrit</a></code> for general computation given source and lens redshifts.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_m">M</code></td>
<td>

<p>The halo mass required for computing the Duffy (2008) mass to concentration conversion in units of 'Munit'. Here the halo mass required for input is the 200 times overdense with respect to critical variation.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_z">z</code></td>
<td>

<p>Cosmological redshift, where z must be &gt; -1 (can be a vector).
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_h0">H0</code></td>
<td>

<p>Hubble constant as defined at z=0 (default is H0=100 (km/s)/Mpc).
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_omegam">OmegaM</code></td>
<td>

<p>Omega matter (default is 0.3).
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_omegal">OmegaL</code></td>
<td>

<p>Omega Lambda (default is for a flat Universe with OmegaL = 1-OmegaM = 0.7).
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_omegar">OmegaR</code></td>
<td>

<p>Omega Radiation (default is 0, but OmegaM/3400 is typical).
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_rho">Rho</code></td>
<td>

<p>Set whether the critical energy density is used (crit) or the mean mass density (mean).
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_dist">Dist</code></td>
<td>

<p>Determines the distance type, i.e. whether the Rho critical energy or mean mass densities are calculated with respect to angular / physical distances (Ang) or with respect to comoving distances (Co). In effect this means Rvir values are either angular / physical (Ang) or comoving (Co). It does not affect Mvir &lt;-&gt; Sigma conversions, but does affect Mvir &lt;-&gt; Rvir and Rvir &lt;-&gt; Sigma.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_deltavir">DeltaVir</code></td>
<td>

<p>Desired overdensity of the halo with respect to Rho.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_munit">Munit</code></td>
<td>

<p>Base mass unit in multiples of Msun.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_lunit">Lunit</code></td>
<td>

<p>Base length unit in multiples of parsecs.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_vunit">Vunit</code></td>
<td>

<p>Base velocity unit in multiples of m/s.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_a">A</code></td>
<td>

<p>Parameter used for Duffy mass to concentration relation.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_b">B</code></td>
<td>

<p>Parameter used for Duffy mass to concentration relation.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_c">C</code></td>
<td>

<p>Parameter used for Duffy mass to concentration relation.
</p>
</td></tr>
<tr><td><code id="cosNFW_+3A_ref">ref</code></td>
<td>

<p>The name of a reference cosmology to use, one of 137 / 737 / Planck / Planck13 / Planck15 / Planck18 / WMAP / WMAP9 / WMAP7 / WMAP5 / WMAP3 / WMAP1 / Millennium / GiggleZ. Planck = Planck18 and WMAP = WMAP9. The usage is case insensitive, so wmap9 is an allowed input. See <code><a href="#topic+cosref">cosref</a></code> for details. This overrides any other settings for H0/ OmegaM and OmegaL.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions calculate various aspects of the NFW profile.
</p>


<h3>Value</h3>

<table>
<tr><td><code>cosNFW</code></td>
<td>
<p>Returns the instantaneous NFW profile density.</p>
</td></tr>
<tr><td><code>cosNFWmass_c</code></td>
<td>
<p>Returns the total mass given Rs and c in Msun/h.</p>
</td></tr>
<tr><td><code>cosNFWmass_Rmax</code></td>
<td>
<p>Returns the total mass given Rs and Rmax in Msun/h.</p>
</td></tr>
<tr><td><code>cosNFWvcirc</code></td>
<td>
<p>Returns the circular Keplarian orbit velocity for a given radius assuming an NFW halo potential.</p>
</td></tr>
<tr><td><code>cosNFWvesc</code></td>
<td>
<p>Returns the minimum escape (or unbinding) velocity for a given radius assuming an NFW halo potential.</p>
</td></tr>
<tr><td><code>cosNFWsigma</code></td>
<td>
<p>Returns the line-of-sight surface mass density at Rad (Eqn. 11 of Wright &amp; Brainerd, 2000).</p>
</td></tr>
<tr><td><code>cosNFWsigma_mean</code></td>
<td>
<p>Returns the means surface mass density within Rad (Eqn. 13 of Wright &amp; Brainerd, 2000).</p>
</td></tr>
<tr><td><code>cosNFWgamma</code></td>
<td>
<p>Returns the radial dependence of the weak lensing shear (Eqn. 12 of Wright &amp; Brainerd, 2000).</p>
</td></tr>
<tr><td><code>cosNFWduffym2c</code></td>
<td>
<p>Returns the Duffy et al (2008) predicted concentration for a given halo mass.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>References</h3>

<p>Duffy A.R., et al., 2008, MNRAS, 390L
</p>
<p>Navarro J.F., Frenk C.S., White Simon D.M., 1996, ApJ, 462
</p>
<p>Wright C.O. &amp; Brainerd T.G., 2000, ApJ, 534
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosvol">cosvol</a></code>, <code><a href="#topic+cosmap">cosmap</a></code>,  <code><a href="#topic+cosdist">cosdist</a></code>, <code><a href="#topic+cosgrow">cosgrow</a></code>, <code><a href="#topic+coshalo">coshalo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#What difference do we see if we use the rad_mean200 radius rather than rad_crit200

rad_crit200=coshaloMvirToRvir(1e12,Lunit=1e6)
rad_mean200=coshaloMvirToRvir(1e12,Lunit=1e6,Rho='mean')
cosNFWmass_Rmax(Rmax=rad_crit200) #By construction we should get ~10^12 Msun/h
cosNFWmass_Rmax(Rmax=rad_mean200) #For the same profile this is a factor 1.31 larger

#Shear checks:

plot(10^seq(-2,2,by=0.1), cosNFWgamma(10^seq(-2,2,by=0.1),Rs=0.2,c=10), type='l',
log='xy', xlab='R/Rs', ylab='ESD')
legend('topright', legend=c('Rs=0.2','c=10'))

#How do critical, mean 200 and 500 masses evolve with redshift? Let's see:

zseq=10^seq(-2, 1, by=0.1)
con=seq(2, 20, by=0.01)
concol=rainbow(length(con), start=0, end=5/6)
rad_crit200=coshaloMvirToRvir(1, z=zseq, Rho='crit', DeltaVir=200, ref='Planck15')
rad_crit500=coshaloMvirToRvir(1, z=zseq, Rho='crit', DeltaVir=500, ref='Planck15')
rad_mean200=coshaloMvirToRvir(1, z=zseq, Rho='mean', DeltaVir=200, ref='Planck15')
rad_mean500=coshaloMvirToRvir(1, z=zseq, Rho='mean', DeltaVir=500, ref='Planck15')
rad_vir=coshaloMvirToRvir(1, z=zseq, Rho='crit', DeltaVir='get', ref='Planck15')

plot(1, 1, type='n', xlim=c(0.01,10), ylim=c(0.8,1.55), xlab='Redshift',
ylab='M200c / M500c', log='x')
for(i in 1:length(con)){
lines(zseq, cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_crit200)/
cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_crit500), col=concol[i])
}

plot(1, 1, type='n', xlim=c(0.01,10), ylim=c(0.8,1.55), xlab='Redshift',
ylab='M200m / M500m', log='x')
for(i in 1:length(con)){
lines(zseq, cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_mean200)/
cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_mean500), col=concol[i])
}

plot(1, 1, type='n', xlim=c(0.01,10), ylim=c(0.8,1.55), xlab='Redshift',
ylab='M200m / M200c',log='x')
for(i in 1:length(con)){
lines(zseq, cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_mean200)/
cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_crit200), col=concol[i])
}

plot(1, 1, type='n', xlim=c(0.01,10), ylim=c(0.8,1.55), xlab='Redshift',
ylab='M500m / M500c', log='x')
for(i in 1:length(con)){
lines(zseq, cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_mean500)/
cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_crit500), col=concol[i])
}

plot(1, 1, type='n', xlim=c(0.01,10), ylim=c(0.8,1.55), xlab='Redshift',
ylab='Mvir / M200c',log='x')
for(i in 1:length(con)){
lines(zseq, cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_vir)/
cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_crit200), col=concol[i])
}

plot(1, 1, type='n', xlim=c(0.01,10), ylim=c(0.8,1.55), xlab='Redshift',
ylab='Mvir / M200m',log='x')
for(i in 1:length(con)){
lines(zseq, cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_vir)/
cosNFWmass_Rmax(Rho0=1, Rs=rad_crit200[1]/con[i], Rmax=rad_mean200), col=concol[i])
}

plot(zseq, rad_crit200/rad_crit500, type='l', xlim=c(0.01,10), ylim=c(0.8,1.55),
xlab='Redshift', ylab='R200 / R500', log='x')

plot(zseq, rad_mean200/rad_crit200, type='l', xlim=c(0.01,10), ylim=c(0.8,1.55), 
xlab='Redshift', ylab='Rm / Rc', log='x')

plot(zseq, rad_vir/rad_crit200, type='l', xlim=c(0.01,10), ylim=c(0.8,1.55), 
xlab='Redshift', ylab='Rvir / R200c', log='x')

plot(zseq, rad_vir/rad_mean200, type='l', xlim=c(0.01,10), ylim=c(0.8,1.55), 
xlab='Redshift', ylab='Rvir / R200c', log='x')

#R200m and R200c go either side of Rvir, so by cosmic conspiracy the mean is nearly flat:

plot(zseq, 2*rad_vir/(rad_mean200+rad_crit200), type='l', xlim=c(0.01,10),
ylim=c(0.8,1.55), xlab='Redshift', ylab='2Rvir / (R200c+R200m)', log='x')

#To check Vcirc and Vesc for a 10^12 Msun halo:

plot(0:400, cosNFWvcirc(0:400,f=1,Lunit=1e3), type='l', lty=1, xlab='R / kpc',
ylab='V / km/s', ylim=c(0,500))
lines(0:400, cosNFWvesc(0:400,f=1,Lunit=1e3), lty=2)
legend('topright', legend=c('Vel-Circ','Vel-Escape'), lty=c(1,2))
abline(v=coshaloMvirToRvir(Lunit=1e3), lty=3)

</code></pre>

<hr>
<h2 id='cosorb'>
Orbital functions
</h2><span id='topic+cosorbVisViva'></span><span id='topic+cosorbFreeFall'></span><span id='topic+cosorbRocheRad'></span><span id='topic+cosorbRocheSize'></span>

<h3>Description</h3>

<p>A variety of obital analysis functions. These are useful for setting up initial conditions for merging systems etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cosorbVisViva(M=1e12, Rad=162.635, SemiMajRad=162.635, Munit=1, Lunit=1e3, Vunit=1)
  cosorbFreeFall(M1=1e12, M2=1, Rad=162.635, Munit=1, Lunit=1e3, Vunit=1, Tunit=1e9)
  cosorbRocheRad(M1=1e12, M2=1e10, Size=35.03865, Rfac=2.44)
  cosorbRocheSize(M1=1e12, M2=1e10, Rad=396.8294, Rfac=2.44)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosorb_+3A_m">M</code></td>
<td>

<p>Mass in units of 'Munit'.
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_m1">M1</code></td>
<td>

<p>Mass of primary body in units of 'Munit'.
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_m2">M2</code></td>
<td>

<p>Mass of secondary body in units of 'Munit'.
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_rad">Rad</code></td>
<td>

<p>Separation between bodies in units of 'Lunit' (for cosorbRocheSize this is in arbitrary units).
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_semimajrad">SemiMajRad</code></td>
<td>

<p>The semi major radius of the orbit (a &gt; 0 for ellipses, a = Rad for circles, 1/a = 0 for parabolas, and a &lt; 0 for hyperbolas).
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_size">Size</code></td>
<td>

<p>The size radius of the secondary object. Inside of this radius the object is bound to the secondary, outside of this radius the object is stripped by the primary.
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_rfac">Rfac</code></td>
<td>

<p>The Roche factor. Approximately taken to be 2.44, but in reality it varies depending on the shape of the potentials etc.
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_munit">Munit</code></td>
<td>

<p>Base mass unit in multiples of Msun.
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_lunit">Lunit</code></td>
<td>

<p>Base length unit in multiples of parsecs.
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_vunit">Vunit</code></td>
<td>

<p>Base velocity unit in multiples of km/s.
</p>
</td></tr>
<tr><td><code id="cosorb_+3A_tunit">Tunit</code></td>
<td>

<p>Base time unit in multiples of years.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions allow for various analytic conversions between the 3 major properties related to virial radius: the mass, velocity dispresion and size. The default properties calculate properties for 1e12 Msun halos and assume masses in Msun, velocities in km/s and distances in Kpc.
</p>


<h3>Value</h3>

<p>cosorbVisViva function gives the required velocity in units of Vunit to create the specified orbit.
</p>
<p>cosorbFreeFall function gives the free fall time to static initial velocity separated bodies..
</p>
<p>cosorbRocheRad function gives the orbital radius at which the secondary will become stripped within a specified bound radius.
</p>
<p>cosorbRocheSize function gives the limiting bound radius of the secondary for a given system.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham, Chris Power
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosvol">cosvol</a></code>, <code><a href="#topic+cosmap">cosmap</a></code>,  <code><a href="#topic+cosdist">cosdist</a></code>, <code><a href="#topic+cosgrow">cosgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  cosorbVisViva(M=1e15, Rad=1, Lunit=1e6)
  cosorbFreeFall(M1=1e15, M2=1, Rad=1, Lunit=1e6)
  cosorbRocheRad(M1=1e12, M2=1e12, Size=162.635, Rfac=2.44)
  cosorbRocheSize(M1=1e12, M2=1e12, Rad=396.8294, Rfac=2.44)
</code></pre>

<hr>
<h2 id='cosvar'>
Driver &amp; Robotham (2010) cosmic variance calculator
</h2><span id='topic+cosvar'></span><span id='topic+cosvarcar'></span><span id='topic+cosvarsph'></span><span id='topic+cosvararea'></span>

<h3>Description</h3>

<p>The main cosmic variance calculator function taken from Driver &amp; Robotham (2010).
cosvarcar is an interface to the Cartesian coordinate version, whilst cosvarsph is
a utility interface to give approximate cosmic variance for astronomy survey regions
(usually defined by RA, Dec and redshift limits).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosvarcar(aside = 50, bside = 50, cside = 50, regions = 1)
cosvarsph(long = c(129, 141), lat = c(-2, 3), zmax = 1, zmin = 0, regions = 1,
inunit='deg', sep=":")
cosvararea(area=60, zmax=1, zmin=0, regions=1, inunit='deg2')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosvar_+3A_aside">aside</code></td>
<td>

<p>The aside (shortest projected side) of the Cartesian box, must be defined using 737 cosmology.
</p>
</td></tr>
<tr><td><code id="cosvar_+3A_bside">bside</code></td>
<td>

<p>The bside (longest projects side) of the Cartesian box, must be defined using 737 cosmology.
</p>
</td></tr>
<tr><td><code id="cosvar_+3A_cside">cside</code></td>
<td>

<p>The cside (radial side) of the Cartesian box, must be defined using 737 cosmology.
</p>
</td></tr>
<tr><td><code id="cosvar_+3A_regions">regions</code></td>
<td>

<p>How many well separated regions of this size will there be? The geometry provided is just for a single region, i.e. we reduce the single region CV by 1/sqrt(regions).
</p>
</td></tr>
<tr><td><code id="cosvar_+3A_long">long</code></td>
<td>

<p>Upper and lower longitude (RA) limits of interest in units of inunit. If of length 1 then the number specified is assumed to be the upper limit and the lower limit is set to 0.
</p>
</td></tr>
<tr><td><code id="cosvar_+3A_lat">lat</code></td>
<td>

<p>Upper and lower latitude (Dec) limits of interest in units of inunit. If of length 1 then the number specified is assumed to be the upper limit and the lower limit is set to 0.
</p>
</td></tr>
<tr><td><code id="cosvar_+3A_zmax">zmax</code></td>
<td>

<p>Maximum redshift of comoving cone.
</p>
</td></tr>
<tr><td><code id="cosvar_+3A_zmin">zmin</code></td>
<td>

<p>Minimum redshift of comoving cone.
</p>
</td></tr>
<tr><td><code id="cosvar_+3A_inunit">inunit</code></td>
<td>


<table>
<tr>
 <td style="text-align: left;">
cosvarsph </td><td style="text-align: left;"> The units of angular coordinate provided for long and lat (see <code><a href="#topic+skyarea">skyarea</a></code>). </td>
</tr>
<tr>
 <td style="text-align: left;">
cosvararea </td><td style="text-align: left;"> The units of angular area provided (see <code><a href="#topic+cosvol">cosvol</a></code>). </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</td></tr>
<tr><td><code id="cosvar_+3A_sep">sep</code></td>
<td>

<p>When inunit='sex', sep defines the type of separator used for the HMS and DMS strings (i.e. H:M:S and D:M:S would be sep=':', which is the default). See <code><a href="#topic+hms2deg">hms2deg</a></code> and <code><a href="#topic+dms2deg">dms2deg</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="cosvar_+3A_area">area</code></td>
<td>

<p>Sky area in units of innunit (default is square degrees)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use the empircally motivated cosmic variance percentage formula provided in Driver &amp; Robotham (2010) Eqn 4.
</p>
<p>cosvarsph is a 'best effort' approximation of the comoving box subtended by the specified spherical coordinates using the following conversions:
</p>
<p>CoDistLow = cosdistCoDist(z=zmin,H0=70,OmegaM=0.3)
</p>
<p>CoDistHigh = cosdistCoDist(z=zmax,H0=70,OmegaM=0.3)
</p>
<p>cside=CoDistHigh-CoDistLow
</p>
<p>area=skyarea(long = long, lat = lat, inunit = inunit, outunit='deg2')[1]
</p>
<p>volume=cosvol(area=area, zmax = zmax, zmin=zmin, H0 = 70, OmegaM = 0.3, inunit='deg2')[1]
</p>
<p>aside=cos(mean(lat)*pi/180)*(abs(diff(long))/360)*(CoDistLow+cside/2)
</p>
<p>bside=(abs(diff(long))/180)*(CoDistLow+cside/2)
</p>
<p>scale=sqrt(volume*1e9/(aside*bside*cside))
</p>
<p>aside=aside*scale
</p>
<p>bside=bside*scale
</p>
<p>return(cosvarcar(aside=aside, bside=bside, cside=cside, subsets=subsets))
</p>
<p>cosvararea is a simplifed version of cosvarsph, where the assumption is that aside=bside (so the aspect ratio on the sky is 1:1).
</p>


<h3>Value</h3>

<p>The output is the approximate percentage cosmic (or sample) variance that is expected for the volume specified.
</p>


<h3>Note</h3>

<p>Many people get upset at the term 'cosmic variance' and prefer 'sample variance'. Whilst I am sympathetic to the argument, more astronomers are familiar with the former term.
</p>
<p>These cosmic variance estimates are defined using SDSS at z~0.1, caveats abound at higher redshifts, but these numbers should serve as a reasonably conservative (i.e. pessimistic) upper limit.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham and Simon Driver
</p>


<h3>References</h3>

<p>Driver S.P. &amp; Robotham A.S.G., 2010, MNRAS, 407, 2131
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosvol">cosvol</a></code>, <code><a href="#topic+skyarea">skyarea</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Approximate CV of the GAMA equatorial regions:
cosvarsph(long=12, lat=5, zmax=0.5)*1/sqrt(3)
#Or using the GAMA sexigesimal coordinates (should be the same):
cosvarsph(long = c('11:36:0','12:24:0'), lat = c('-2:0:0','3:0:0'), zmax=0.5,
inunit='sex')*1/sqrt(3)
#Approximate CV of the SDSS:
cosvarsph(long=150, lat=100, zmax=0.3)
</code></pre>

<hr>
<h2 id='cosvol'>
Cosmological volume calculator
</h2><span id='topic+cosvol'></span>

<h3>Description</h3>

<p>Given the sky area, two redshifts and the cosmology, this function calculates the comoving volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosvol(area=60, zmax=1, zmin=0, H0=100, OmegaM=0.3, OmegaL=1-OmegaM-OmegaR, OmegaR=0,
w0=-1, wprime=0, inunit = "deg2", ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosvol_+3A_area">area</code></td>
<td>

<p>Sky area in units of innunit (default is square degrees)
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_zmax">zmax</code></td>
<td>

<p>Maximum cosmological redshift of comoving cone.
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_zmin">zmin</code></td>
<td>

<p>Minimum cosmological redshift of comoving cone.
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_h0">H0</code></td>
<td>

<p>Hubble constant as defined at z=0 (default is H0=100 (km/s)/Mpc)
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_omegam">OmegaM</code></td>
<td>

<p>Omega Matter (default is 0.3).
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_omegal">OmegaL</code></td>
<td>

<p>Omega Lambda (default is for a flat Universe with OmegaL = 1-OmegaM-OmegaR = 0.7).
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_omegar">OmegaR</code></td>
<td>

<p>Omega Radiation (default is 0, but OmegaM/3400 is typical).
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_w0">w0</code></td>
<td>

<p>The value of dark energy equation of state at z=0. See <code><a href="#topic+cosgrow">cosgrow</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_wprime">wprime</code></td>
<td>

<p>The evolution term that governs how the dark energy equation of state evolves with redshift. See <code><a href="#topic+cosgrow">cosgrow</a></code> for more details.
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_inunit">inunit</code></td>
<td>

<p>The units of angular area provided. Allowed options are deg2 for square degrees, amin2 for square arc minutes, asec2 for square arc seconds and rad2 or sr for steradians.
</p>
</td></tr>
<tr><td><code id="cosvol_+3A_ref">ref</code></td>
<td>

<p>The name of a reference cosmology to use, one of 137 / 737 / Planck / Planck13 / Planck15 / Planck18 / WMAP / WMAP9 / WMAP7 / WMAP5 / WMAP3 / WMAP1 / Millennium / GiggleZ. Planck = Planck18 and WMAP = WMAP9. The usage is case insensitive, so wmap9 is an allowed input. See <code><a href="#topic+cosref">cosref</a></code> for details. This overrides any other settings for H0/ OmegaM and OmegaL.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3 element vector. The first element (voltot) specifies the comoving volume of the requested cone segment in Gpc^3, the second element (volmeanz) specifies the mean redshift when mass is uniformly distributed in the volume, the third element (volmedz) specifies the median redshift when mass is uniformly distributed in the volume.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>References</h3>

<p>Based on the equations in:
</p>
<p>Hogg D.W., 1999, arXiv, 9905116
</p>
<p>Wright E.L., 2006, PASP, 118, 1711
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosdist">cosdist</a></code>,<code><a href="#topic+skyarea">skyarea</a></code>, <code><a href="#topic+cosmap">cosmap</a></code>, <code><a href="#topic+cosgrow">cosgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Approximate volume of the GAMA survey (area given in skyarea example, zmax is approx
#limit of main galaxy sample):
TotalGAMAvol=cosvol(293.82,0.6)[1]
print(paste('The GAMA survey volume is ~',round(TotalGAMAvol,2),'Gpc^3'))

#Approximate volume of SDSS (area given for DR7, zmax is approx limit of main galaxy sample):
TotalSDSSvol=cosvol(8423,0.3)[1]
print(paste('The SDSS survey volume is ~',round(TotalSDSSvol,2),'Gpc^3'))

#Change of reference cosmology
cosvol(293.82,0.6,ref='Planck')
</code></pre>

<hr>
<h2 id='deg2dms'>
Convert decimal degrees to dms format.
</h2><span id='topic+deg2dms'></span>

<h3>Description</h3>

<p>Convert decimal degrees to dms (degrees, minutes, seconds) format. This is probably most useful for declination conversion, since dms is fairly standard method of presenting declination coordinates. The decimal degrees=d+m/60+s/3600. Degrees should range from -90 to +90.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg2dms(deg, type='mat', sep=':', digits=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deg2dms_+3A_deg">deg</code></td>
<td>

<p>The decimal degrees you are converting. All deg values should be -90&lt;=deg&lt;=90
</p>
</td></tr>
<tr><td><code id="deg2dms_+3A_type">type</code></td>
<td>

<p>The output type desired. If 'mat' then the output is a 3 column data.frame where column 1 is the degree, column 2 is the minutes and column 3 is the seconds. If 'cat' then the output is a single vector of strings where the separator is defined by the 'sep' argument.
</p>
</td></tr>
<tr><td><code id="deg2dms_+3A_sep">sep</code></td>
<td>

<p>Defines the type of separator used when type='cat'. Any value other than 'DMS' and 'dms' is used for all separations, so the default ':' would produce an output like 3:34:45.5. If set to 'dms' or 'DMS' then the output is of the format 3d34m45.5s and 3D34M45.5s resepctively.
</p>
</td></tr>
<tr><td><code id="deg2dms_+3A_digits">digits</code></td>
<td>

<p>The digits to print for angular seconds. See <code><a href="base.html#topic+formatC">formatC</a></code> for details on how digits is parsed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns degrees, minutes and seconds if type='mat'. If type='cat' then a vector of strings with separators defined by the 'sep' argument.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dms2deg">dms2deg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(deg2dms(12.345))
print(deg2dms(12.345,type='cat',sep=':'))
print(deg2dms(12.345,type='cat',sep='dms'))
print(deg2dms(12.345,type='cat',sep='DMS'))
</code></pre>

<hr>
<h2 id='deg2hms'>
Convert decimal degrees to hms format.
</h2><span id='topic+deg2hms'></span>

<h3>Description</h3>

<p>Convert decimal degrees to hms (hours, minutes, seconds) format. This is probably most useful for right-ascension (RA) conversion, since hms is fairly standard method of presenting RA coordinates. The decimal degrees=15*h+15*m/60+15*s/3600 (i.e. there are 24 hours in 360 degrees). Degrees should range from 0 to 360.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg2hms(deg, type='mat', sep=':', digits=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deg2hms_+3A_deg">deg</code></td>
<td>

<p>The decimal degrees you are converting. All deg values should be 0&lt;=d&lt;=360.
</p>
</td></tr>
<tr><td><code id="deg2hms_+3A_type">type</code></td>
<td>

<p>The output type desired. If 'mat' then the output is a 3 column data.frame where column 1 is the degree, column 2 is the minutes and column 3 is the seconds. If 'cat' then the output is a single vector of strings where the separator is defined by the 'sep' argument.
</p>
</td></tr>
<tr><td><code id="deg2hms_+3A_sep">sep</code></td>
<td>

<p>Defines the type of separator used when type='cat'. Any value other than 'DMS' and 'dms' is used for all separations, so the default ':' would produce an output like 3:34:45.5. If set to 'hms' or 'HMS' then the output is of the format 3h34m45.5s and 3H34M45.5s resepctively.
</p>
</td></tr>
<tr><td><code id="deg2hms_+3A_digits">digits</code></td>
<td>

<p>The digits to print for angular seconds. See <code><a href="base.html#topic+formatC">formatC</a></code> for details on how digits is parsed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns degrees, minutes and seconds if type='mat'. If type='cat' then a vector of strings with separators defined by the 'sep' argument.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hms2deg">hms2deg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deg2hms(123.456)
deg2hms(123.456,type='cat',sep=':')
deg2hms(123.456,type='cat',sep='hms')
deg2hms(123.456,type='cat',sep='HMS')
</code></pre>

<hr>
<h2 id='dms2deg'>
Convert DMS to degrees format.
</h2><span id='topic+dms2deg'></span>

<h3>Description</h3>

<p>Convert DMS (degrees, minutes, seconds) to degrees format. This is probably most useful for declination conversion, since dms is fairly standard method of presenting declination coordinates. The decimal degrees=d+m/60+s/3600. Degrees should range from -90 to +90. Degrees and minutes should be integer and seconds can be decimal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dms2deg(d,m,s,sign='d',sep=':')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dms2deg_+3A_d">d</code></td>
<td>

<p>The integer number of degrees you are converting. If it is not integer then the floor of the number is taken. This can contain the sign of the declination when sign='d', but must be all positive if the sign argument is specified (this is required if d contains any 0s, see below). If sign is specified, all d values should be 0&lt;=d&lt;=90, otherwise d values should be 0&lt;=d&lt;=90.
</p>
</td></tr>
<tr><td><code id="dms2deg_+3A_m">m</code></td>
<td>

<p>The integer number of minutes you are converting. If it is not integer then the floor of the number is taken. All m values should be 0&lt;=m&lt;60.
</p>
</td></tr>
<tr><td><code id="dms2deg_+3A_s">s</code></td>
<td>

<p>The decimal number of seconds you are converting. All s values should be 0&lt;=s&lt;60.
</p>
</td></tr>
<tr><td><code id="dms2deg_+3A_sign">sign</code></td>
<td>

<p>The sign of the declination. The default 'd' inherits the sign of the d argument. This is ambiguous when d is 0 since the sign of +/-0 is taken to be 0. If d contains any 0s, you must supply a vector of the same length as d with +ve or -ve values (e.g. +/- 1), the sign of these value will be taken as the sign for the declination.
</p>
</td></tr>
<tr><td><code id="dms2deg_+3A_sep">sep</code></td>
<td>

<p>Defines the type of separator used when 'd' is a vector of strings. Any value other than 'DMS' and 'dms' is used for all separations, so the default ':' would be for an input like 3:34:45.5. If set to 'dms' or 'DMS' then the output is of the format 3d34m45.5s and 3D34M45.5s resepctively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value of decimal degrees.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg2dms">deg2dms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(dms2deg(70,45,19,-1))
print(dms2deg('-70:45:19'))
print(dms2deg('-70d45m19s',sep='dms'))
print(dms2deg(c('-70D45M19S','3D5M15S'),sep='DMS'))
</code></pre>

<hr>
<h2 id='getpixscale'>
Get Pixel Scale
</h2><span id='topic+getpixscale'></span>

<h3>Description</h3>

<p>Given a <code>FITSio</code> of <code>astro</code> header, calculate the image pixel scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getpixscale(header, CD1_1 = 1, CD1_2 = 0, CD2_1 = 0, CD2_2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getpixscale_+3A_header">header</code></td>
<td>

<p>Full FITS header in table or vector format. Legal table format headers are provided by the <code>read.fitshdr</code> function or the <span class="option">hdr</span> list output of <code>read.fits</code> in the astro package; the <span class="option">hdr</span> output of <code>readFITS</code> in the <code>FITSio</code> package or the <span class="option">header</span> output of <code>magcutoutWCS</code>. Missing header keywords are printed out and other header option arguments are used in these cases. See <code><a href="#topic+xy2radec">xy2radec</a></code>.
</p>
</td></tr>
<tr><td><code id="getpixscale_+3A_cd1_1">CD1_1</code></td>
<td>

<p>FITS header CD1_1 for the Tan Gnomonic projection system. Change in RA-Tan in degrees along x-Axis.
</p>
</td></tr>
<tr><td><code id="getpixscale_+3A_cd1_2">CD1_2</code></td>
<td>

<p>FITS header CD1_2 for the Tan Gnomonic projection system. Change in RA-Tan in degrees along y-Axis.
</p>
</td></tr>
<tr><td><code id="getpixscale_+3A_cd2_1">CD2_1</code></td>
<td>

<p>FITS header CD2_1 for the Tan Gnomonic projection system. Change in Dec-Tan in degrees along x-Axis.
</p>
</td></tr>
<tr><td><code id="getpixscale_+3A_cd2_2">CD2_2</code></td>
<td>

<p>FITS header CD2_2 for the Tan Gnomonic projection system. Change in Dec-Tan in degrees along y-Axis.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases users will simply provide a valid header to find the WCS, but you can enter the <span class="option">CD</span> values explicitly. Calculating the pixel scale from the latter is almost trivial, but the option is there for the curious/lazy.
</p>


<h3>Value</h3>

<p>Numeric scalar; the image pixscale in asec/pixel (so typically a value of 0.1-0.5 for modern survey instruments).
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#The answer should be almost exactly 0.2 asec/pixel:

#Using FITSio and ProFit packages
image = readFITS(system.file("extdata", 'KiDS/G266035fitim.fits', package="ProFit"))
getpixscale(image$hdr)
#Using astro package
image = read.fits(system.file("extdata", 'KiDS/G266035fitim.fits', package="ProFit"))
getpixscale(image$hdr[[1]])

## End(Not run)
</code></pre>

<hr>
<h2 id='hms2deg'>
Convert hms to degrees format.
</h2><span id='topic+hms2deg'></span>

<h3>Description</h3>

<p>Convert hms (hours, minutes, seconds) to degrees format. This is probably most useful for right ascension (RA) conversion, since hms is fairly standard method of presenting RA coordinates. The decimal degrees=15*h+15*m/60+15*s/3600. Should range between 0 and 24 hours. Hours and minutes should be integer and seconds can be decimal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hms2deg(h,m,s,sep=':')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hms2deg_+3A_h">h</code></td>
<td>

<p>The integer number of hours you are converting. If it is not integer then the floor of the number is taken. All m values should be 0&lt;=h&lt;=24.
</p>
</td></tr>
<tr><td><code id="hms2deg_+3A_m">m</code></td>
<td>

<p>The integer number of minutes you are converting. If it is not integer then the floor of the number is taken. All m values should be 0&lt;=m&lt;60.
</p>
</td></tr>
<tr><td><code id="hms2deg_+3A_s">s</code></td>
<td>

<p>The decimal number of seconds you are converting. All s values should be 0&lt;=s&lt;60.
</p>
</td></tr>
<tr><td><code id="hms2deg_+3A_sep">sep</code></td>
<td>

<p>Defines the type of separator used when 'h' is a vector of strings. Any value other than 'HMS' and 'hms' is used for all separations, so the default ':' would be for an input like 3:34:45.5. If set to 'hms' or 'HMS' then the output is of the format 3h34m45.5s and 3H34M45.5s resepctively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value of decimal degrees.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg2hms">deg2hms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hms2deg(12,10,36)
hms2deg('12:10:36')
hms2deg('12h10m36s',sep='hms')
hms2deg(c('12H10M36S','3H4M10S'),sep='HMS')
</code></pre>

<hr>
<h2 id='IAUID'>
IAU name creator.
</h2><span id='topic+IAUID'></span>

<h3>Description</h3>

<p>Creates IAU legal names for objects given coordinates, name and epoch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IAUID(ra, dec, name = "GAMA", epoch = "J")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IAUID_+3A_ra">ra</code></td>
<td>

<p>Right Ascension in decimal degrees.
</p>
</td></tr>
<tr><td><code id="IAUID_+3A_dec">dec</code></td>
<td>

<p>Declination in decimal degrees.
</p>
</td></tr>
<tr><td><code id="IAUID_+3A_name">name</code></td>
<td>

<p>Name to be appended to IAU designation as a string.
</p>
</td></tr>
<tr><td><code id="IAUID_+3A_epoch">epoch</code></td>
<td>

<p>Epoch, i.e. 'J' (default) or 'B'. Enter as a string.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text string that outputs an IAU legal name for an object.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IAUID(123.45,67.89,'GAMA','J')
</code></pre>

<hr>
<h2 id='planck'>
Planck's Law and Related Functions
</h2><span id='topic+planck'></span><span id='topic+cosplanck'></span><span id='topic+cosplanckLawRadFreq'></span><span id='topic+cosplanckLawRadWave'></span><span id='topic+cosplanckLawEnFreq'></span><span id='topic+cosplanckLawEnWave'></span><span id='topic+cosplanckLawRadFreqN'></span><span id='topic+cosplanckLawRadWaveN'></span><span id='topic+cosplanckPeakFreq'></span><span id='topic+cosplanckPeakWave'></span><span id='topic+cosplanckSBLawRad'></span><span id='topic+cosplanckSBLawRad_sr'></span><span id='topic+cosplanckSBLawEn'></span><span id='topic+cosplanckLawRadPhotEnAv'></span><span id='topic+cosplanckLawRadPhotN'></span><span id='topic+cosplanckCMBTemp'></span>

<h3>Description</h3>

<p>Functions related to Planck's Law of thermal radiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosplanckLawRadFreq(nu,Temp=2.725)
cosplanckLawRadWave(lambda,Temp=2.725)
cosplanckLawEnFreq(nu,Temp=2.725)
cosplanckLawEnWave(lambda,Temp=2.725)
cosplanckLawRadFreqN(nu,Temp=2.725)
cosplanckLawRadWaveN(lambda,Temp=2.725)
cosplanckPeakFreq(Temp=2.725)
cosplanckPeakWave(Temp=2.725)
cosplanckSBLawRad(Temp=2.725)
cosplanckSBLawRad_sr(Temp=2.725)
cosplanckSBLawEn(Temp=2.725)
cosplanckLawRadPhotEnAv(Temp=2.725)
cosplanckLawRadPhotN(Temp=2.725)
cosplanckCMBTemp(z,Temp=2.725)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="planck_+3A_nu">nu</code></td>
<td>

<p>The frequency of radiation in Hertz (Hz).
</p>
</td></tr>
<tr><td><code id="planck_+3A_lambda">lambda</code></td>
<td>

<p>The wavelength of radiation in metres (m).
</p>
</td></tr>
<tr><td><code id="planck_+3A_temp">Temp</code></td>
<td>

<p>The absolute temperature of the system in Kelvin (K).
</p>
</td></tr>
<tr><td><code id="planck_+3A_z">z</code></td>
<td>

<p>Redshift, where z must be &gt; -1 (can be a vector).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions with <code>Rad</code> in the name are related the spectral radiance form of Planck's Law (typically designated I or B), whilst those with <code>En</code> are related to the spectral energy density form of Planck's Law (u), where <code class="reqn">u=4\pi I/c</code>.
</p>
<p>To calculate the number of photons in a mode we simply use <code class="reqn">E=h\nu=h c / \lambda</code>.
</p>
<p>Below h is the Planck constant, <code class="reqn">k_B</code> is the Boltzmann constant, c is the speed-of-light in a vacuum and <code class="reqn">\sigma</code> is the Stefan-Boltzmann constant.
</p>
<p><code>cosplanckLawRadFreq</code> is the spectral radiance per unit frequency version of Planck's Law, defined as:
</p>
<p style="text-align: center;"><code class="reqn">B_\nu(\nu,T) = I_\nu(\nu,T) = \frac{2 h \nu^3}{c^2} \frac{1}{e^{h \nu / k_B T}-1}</code>
</p>

<p><code>cosplanckLawRadWave</code> is the spectral radiance per unit wavelength version of Planck's Law, defined as:
</p>
<p style="text-align: center;"><code class="reqn">B_\lambda(\lambda,T) = I_\lambda(\lambda,T) = \frac{2 h c^2}{\lambda^5} \frac{1}{e^{h c / \lambda k_B T}-1}</code>
</p>

<p><code>cosplanckLawRadFreqN</code> is the number of photons per unit frequency, defined as:
</p>
<p style="text-align: center;"><code class="reqn">B_\nu(\nu,T) = I_\nu(\nu,T) = \frac{2 \nu^2}{c^2} \frac{1}{e^{h \nu / k_B T}-1}</code>
</p>

<p><code>cosplanckLawRadWaveN</code> is the number of photons per unit wavelength, defined as:
</p>
<p style="text-align: center;"><code class="reqn">B_\lambda(\lambda,T) = I_\lambda(\lambda,T) = \frac{2 c}{\lambda^4} \frac{1}{e^{h c / \lambda k_B T}-1}</code>
</p>

<p><code>cosplanckLawEnFreq</code> is the spectral energy density per unit frequency version of Planck's Law, defined as:
</p>
<p style="text-align: center;"><code class="reqn">u_\nu(\nu,T) = \frac{8 \pi h \nu^3}{c^3} \frac{1}{e^{h\nu/k_B T}-1}</code>
</p>

<p><code>cosplanckLawEnWave</code> is the spectral energy density per unit wavelength version of Planck's Law, defined as:
</p>
<p style="text-align: center;"><code class="reqn">u_\lambda(\lambda,T) = \frac{8 \pi h c}{\lambda^5} \frac{1}{e^{h c / \lambda k_B T}-1}</code>
</p>

<p><code>cosplanckPeakFreq</code> gives the location in frequency of the peak of <code class="reqn">I_\nu(\nu,T)</code>, defined as:
</p>
<p style="text-align: center;"><code class="reqn">\nu_{peak} = 2.821 k_B T</code>
</p>

<p><code>cosplanckPeakWave</code> gives the location in wavelength of the peak of <code class="reqn">I_\lambda(\lambda,T)</code>, defined as:
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{peak} = 4.965 k_B T</code>
</p>

<p><code>cosplanckSBLawRad</code> gives the emissive power (or radiant exitance) version of the Stefan-Boltzmann Law, defined as:
</p>
<p style="text-align: center;"><code class="reqn">j^* = \sigma T^4</code>
</p>

<p><code>cosplanckSBLawRad_sr</code> gives the spectral radiance version of the Stefan-Boltzmann Law, defined as:
</p>
<p style="text-align: center;"><code class="reqn">L = \sigma T^4/\pi</code>
</p>

<p><code>cosplanckSBLawEn</code> gives the energy density version of the Stefan-Boltzmann Law, defined as:
</p>
<p style="text-align: center;"><code class="reqn">\epsilon = 4 \sigma T^4 / c</code>
</p>

<p>Notice that <code class="reqn">j^*</code> and L merely differ by a factor of <code class="reqn">\pi</code>, i.e. L is per steradian.
</p>
<p><code>cosplanckLawRadPhotEnAv</code> gives the average energy of the emitted black body photon, defined as:
</p>
<p style="text-align: center;"><code class="reqn">&lt;E_{phot}&gt; = 3.729282 \times 10^{-23} T</code>
</p>

<p><code>cosplanckLawRadPhotN</code> gives the total number of photons produced by black body per metre squared per second per steradian, defined as:
</p>
<p style="text-align: center;"><code class="reqn">N_{phot} = 1.5205 \times 10^{15} T^3 / \pi</code>
</p>

<p>Various confidence building sanity checks of how to use these functions are given in the Examples below.
</p>


<h3>Value</h3>

<p>Planck's Law in terms of spectral radiance:
</p>
<table>
<tr><td><code>cosplanckLawRadFreq</code></td>
<td>

<p>The power per steradian per metre squared per unit frequency for a black body (W.sr<code class="reqn">^{-1}</code>.m<code class="reqn">^{-2}</code>.Hz<code class="reqn">^{-1}</code>).
</p>
</td></tr>
<tr><td><code>cosplanckLawRadWave</code></td>
<td>

<p>The power per steradian per metre squared per unit wavelength for a black body (W.sr<code class="reqn">^{-1}</code>.m<code class="reqn">^{-2}</code>.m<code class="reqn">^{-1}</code>).
</p>
</td></tr>
</table>
<p>Planck's Law in terms of spectral energy density:
</p>
<table>
<tr><td><code>cosplanckLawEnFreq</code></td>
<td>

<p>The energy per metre cubed per unit frequency for a black body (J.m<code class="reqn">^{-3}</code>.Hz<code class="reqn">^{-1}</code>).
</p>
</td></tr>
<tr><td><code>cosplanckLawEnWave</code></td>
<td>

<p>The energy per metre cubed per unit wavelength for a black body (J.m<code class="reqn">^{-3}</code>.m<code class="reqn">^{-1}</code>).
</p>
</td></tr>
</table>
<p>Photon counts:
</p>
<table>
<tr><td><code>cosplanckLawRadFreqN</code></td>
<td>

<p>The number of photons per steradian per metre squared per second per unit frequency for a black body (photons.sr<code class="reqn">^{-1}</code>.m<code class="reqn">^{-2}</code>.s<code class="reqn">^{-1}</code>.Hz<code class="reqn">^{-1}</code>).
</p>
</td></tr>
<tr><td><code>cosplanckLawRadWaveN</code></td>
<td>

<p>The number of photonsper steradian per metre squared per second per unit wavelength for a black body (photons.sr<code class="reqn">^{-1}</code>.m<code class="reqn">^{-2}</code>.s<code class="reqn">^{-1}</code>.m<code class="reqn">^{-1}</code>).
</p>
</td></tr>
</table>
<p>Peak locations (via Wien's displacement law):
</p>
<table>
<tr><td><code>cosplanckPeakFreq</code></td>
<td>

<p>The frequency location of the radiation peak for a black body as found in <code>cosplanckLawRadFreq</code>.
</p>
</td></tr>
<tr><td><code>cosplanckPeakWave</code></td>
<td>

<p>The wavelength location of the radiation peak for a black body as found in <code>cosplanckLawRadWave</code>.
</p>
</td></tr>
</table>
<p>Stefan-Boltzmann Law:
</p>
<table>
<tr><td><code>cosplanckSBLawRad</code></td>
<td>

<p>Total energy radiated per metre squared per second across all wavelengths for a black body (W.m<code class="reqn">^{-2}</code>). This is the emissive power version of the Stefan-Boltzmann Law.
</p>
</td></tr>
<tr><td><code>cosplanckSBLawRad_sr</code></td>
<td>

<p>Total energy radiated per metre squared per second per steradian across all wavelengths for a black body (W.m<code class="reqn">^{-2}</code>.sr<code class="reqn">^{-1}</code>). This is the radiance version of the Stefan-Boltzmann Law.
</p>
</td></tr>
<tr><td><code>cosplanckSBLawEn</code></td>
<td>

<p>Total energy per metre cubed across all wavelengths for a black body (J.m<code class="reqn">^{-3}</code>). This is the energy density version of the Stefan-Boltzmann Law.
</p>
</td></tr>
</table>
<p>Photon properties:
</p>
<table>
<tr><td><code>cosplanckLawRadPhotEnAv</code></td>
<td>

<p>Average black body photon energy (J).
</p>
</td></tr>
<tr><td><code>cosplanckLawRadPhotN</code></td>
<td>

<p>Total number of photons produced by black body per metre squared per second per steradian (m<code class="reqn">^{-2}</code>.s<code class="reqn">^{-1}</code>.sr<code class="reqn">^{-1}</code>).
</p>
</td></tr>
</table>
<p>Cosmic Microwave Background:
</p>
<table>
<tr><td><code>cosplanckCMBTemp</code></td>
<td>

<p>The temperaure of the CMB at redshift z.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>References</h3>

<p>Marr J.M., Wilkin F.P., 2012, AmJPh, 80, 399
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosgrow">cosgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Classic example for different temperature stars:

waveseq=10^seq(-7,-5,by=0.01)
plot(waveseq, cosplanckLawRadWave(waveseq,5000),
log='x', type='l', xlab=expression(Wavelength / m),
ylab=expression('Spectral Radiance' / W*sr^{-1}*m^{-2}*m^{-1}), col='blue')
lines(waveseq, cosplanckLawRadWave(waveseq,4000), col='green')
lines(waveseq, cosplanckLawRadWave(waveseq,3000), col='red')
legend('topright', legend=c('3000K','4000K','5000K'), col=c('red','green','blue'), lty=1)

#CMB now:

plot(10^seq(9,12,by=0.01), cosplanckLawRadFreq(10^seq(9,12,by=0.01)),
log='x', type='l', xlab=expression(Frequency / Hz),
ylab=expression('Spectral Radiance' / W*sr^{-1}*m^{-2}*Hz^{-1}))
abline(v=cosplanckPeakFreq(),lty=2)

plot(10^seq(-4,-1,by=0.01), cosplanckLawRadWave(10^seq(-4,-1,by=0.01)),
log='x', type='l', xlab=expression(Wavelength / m),
ylab=expression('Spectral Radiance' / W*sr^{-1}*m^{-2}*m^{-1}))
abline(v=cosplanckPeakWave(),lty=2)

#CMB at surface of last scattering:

TempLastScat=cosplanckCMBTemp(1100) #Note this is still much cooler than our Sun!

plot(10^seq(12,15,by=0.01), cosplanckLawRadFreq(10^seq(12,15,by=0.01),TempLastScat),
log='x', type='l', xlab=expression(Frequency / Hz),
ylab=expression('Spectral Radiance' / W*sr^{-1}*m^{-2}*Hz^{-1}))
abline(v=cosplanckPeakFreq(TempLastScat),lty=2)

plot(10^seq(-7,-4,by=0.01), cosplanckLawRadWave(10^seq(-7,-4,by=0.01),TempLastScat),
log='x', type='l', xlab=expression(Wavelength / m),
ylab=expression('Spectral Radiance' / W*sr^{-1}*m^{-2}*m^{-1}))
abline(v=cosplanckPeakWave(TempLastScat),lty=2)

#Exact number of photons produced by black body:

cosplanckLawRadPhotN()

#We can get pretty much the correct answer through direct integration, i.e.:

integrate(cosplanckLawRadFreqN,1e8,1e12)
integrate(cosplanckLawRadWaveN,1e-4,1e-1)

#Stefan-Boltzmann Law:

cosplanckSBLawRad_sr()

#We can get (almost, some rounding is off) the same answer by multiplying
#the total number of photons produced by a black body per metre squared per
#second per steradian by the average photon energy:

cosplanckLawRadPhotEnAv()*cosplanckLawRadPhotN()

</code></pre>

<hr>
<h2 id='Sky+20Coordinate+20Matching'>
Sky matching
</h2><span id='topic+coordmatch'></span><span id='topic+coordmatchsing'></span><span id='topic+internalclean'></span>

<h3>Description</h3>

<p>These functions allows the user to match a reference set of sky coordinates against a comparison set of sky coordinates. The match radius can be varied per source (all matches per source are given within this radius), and mutual best matches are also extracted. <code>coordmatch</code> should be used for finding multiple matches and <code>coordmatchsing</code> should be used when trying to find matches around a single source. <code>internalclean</code> is a utility function that will remove closely duplicated objects via some <span class="option">tiebreak</span> criterion, and is probably only of interest to advanced users trying to clean catalogues that were produced from overlapping frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordmatch(coordref, coordcompare, rad = 2, inunitref = "deg", inunitcompare = "deg",
radunit = "asec", sep = ":", kstart = 10, ignoreexact = FALSE, ignoreinternal=FALSE,
matchextra = FALSE, smallapprox=FALSE)
coordmatchsing(RAref,Decref, coordcompare, rad=2, inunitref = "deg",
inunitcompare="deg", radunit='asec', sep = ":", ignoreexact=FALSE, smallapprox=FALSE)
internalclean(RA, Dec, rad=2, tiebreak, decreasing = FALSE, inunit="deg", radunit='asec',
sep = ":")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_coordref">coordref</code></td>
<td>

<p>For coordmatch this is the reference dataset, i.e. you want to find matches for each object in this catalogue. A minimum two column matrix or data.frame, where column one is the RA and column two the Dec. See <span class="option">matchextra</span>.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_coordcompare">coordcompare</code></td>
<td>

<p>The comparison dataset, i.e. you want to find objects in this catalogue that match locations in coordref. A minimum two column matrix or data.frame, where column one is the RA and column two the Dec. If <span class="option">coordcompare</span> is not provided then it is set to <span class="option">coordref</span> automatically. Since this means the user is doing a single table internal match <span class="option">ignoreinternal</span> is automatically set to TRUE (but this can be overridden). See <span class="option">matchextra</span>.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_raref">RAref</code></td>
<td>

<p>For <code>coordmatchsing</code> this is the reference RA for the single object of interest.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_decref">Decref</code></td>
<td>

<p>For <code>coordmatchsing</code> this is the reference Dec for the single object of interest.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_ra">RA</code></td>
<td>

<p>For <code>internalclean</code> this is a vector of right ascensions for internal cleaning. If <span class="option">RA</span> is a two column structure then the second column is taken to be <span class="option">Dec</span>.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_dec">Dec</code></td>
<td>

<p>For <code>internalclean</code> this is a vector of declinations for internal cleaning. If <span class="option">RA</span> is a two column structure then the second column is taken to be <span class="option">Dec</span>. 
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_rad">rad</code></td>
<td>

<p>The matching radius to use. If this is length one then the same radius is used for all objects, otherwise it must be the same length as the number of rows in coordref.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_tiebreak">tiebreak</code></td>
<td>

<p>For <code>internalclean</code> this is a vector of values to determine the preferred source, e.g. something like magnitude of distance to the centre of the origin frame. By default smaller values are considered better, but this can be flipped by setting <span class="option">decreasing</span>=TRUE. If <span class="option">tiebreak</span> is not provided then the first source that appears is considered the better object in the cleaned catalogue.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_decreasing">decreasing</code></td>
<td>

<p>Determines whether smaller (<span class="option">decreasing</span>=FALSE) or larger (<span class="option">decreasing</span>=TRUE) <span class="option">tiebreak</span> values are considered preferable.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_inunitref">inunitref</code></td>
<td>

<p>The units of angular coordinate provided for coordref / RAref / Decref. Allowed options are deg for degress, rad for radians and sex for sexigesimal (i.e. HMS for RA and DMS for Deg).
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_inunitcompare">inunitcompare</code></td>
<td>

<p>The units of angular coordinate provided for coordcompare. Allowed options are deg for degress, rad for radians and sex for sexigesimal (i.e. HMS for RA and DMS for Deg).
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_inunit">inunit</code></td>
<td>

<p>The units of angular coordinate provided for <span class="option">RA</span> and <span class="option">Dec</span> in <code>internalclean</code>. Allowed options are deg for degress, rad for radians and sex for sexigesimal (i.e. HMS for RA and DMS for Deg).  
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_radunit">radunit</code></td>
<td>

<p>The unit type for the radius specified. Allowed options are deg for degress, amin for arc minutes, asec for arc seconds and rad for radians.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_sep">sep</code></td>
<td>

<p>If inunitref, inunitcompare or inunit is set to 'sex' then sep defines the separation type as detailed in <code><a href="#topic+hms2deg">hms2deg</a></code> and <code><a href="#topic+dms2deg">dms2deg</a></code>.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_kstart">kstart</code></td>
<td>

<p>The number of matching nodes to attempt initial. The code iterates until all matches within the specified radius (rad) have been found, but it works faster if the kstart is close to the maximum number of matches for any coordref object.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_ignoreexact">ignoreexact</code></td>
<td>

<p>Should exact matches be ignored in the output? If TRUE then 0 separation ID matches are set to 0 and the separation is NA. This might be helpful when matching the same table against itself, where you have no interest in finding object matches with respect to themselves.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_ignoreinternal">ignoreinternal</code></td>
<td>

<p>Should identical row matches be ignored in the output? If TRUE then exact row ID matches are set to 0 and the separation is NA. The bestmatch output will ignore these trivial matchesw also. This only makes sense if <span class="option">coordref</span> and <span class="option">coordcompare</span> are the same table and you are trying to do an internal table match where you do not want the trivial result of rows matching to themselves. Automatically switches to TRUE if <span class="option">coordcompare</span> is not provided. 
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_matchextra">matchextra</code></td>
<td>

<p>Should extra columns in <span class="option">coordref</span> and <span class="option">coordcompare</span> be used as part of the N-D match? Extra columns beyond the requried RA and Dec can be provided and these will be used as part of the N-D match. The meaning of <span class="option">rad</span> in this case is not trivial of course since the match is done within a hyper-sphere. When the extra columns have the same value <span class="option">rad</span> can still be interpretted as an angular coordinate match. These extra columns should be appropriately scaled, e.g. you might want to make a 2 arcsec match with an extra magnitude column. In this case even if two objects sit on top of each other on sky, they cannot differ by more than 2 mag in flux to be a match.
</p>
</td></tr>
<tr><td><code id="Sky+2B20Coordinate+2B20Matching_+3A_smallapprox">smallapprox</code></td>
<td>

<p>Should the small angle approximation of asin(a/b) = a/b be used? If TRUE then some computations may be much faster, since asin is an expensive computation to make for lots of near matches.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For coordmatch the main matching is done using nn2 that comes as part of the RANN package. coordmatch adds a large amount of sky coordinate oriented functionality beyond the simple implementation of nn2. For single object matches coordmatchsing should be used since it is substantially faster in this regime (making use of direct dot products).
</p>
<p><span class="option">ignoreexact</span> is more strict in a sense since all objects exactly matching are ignored, whereas with <span class="option">ignoreinternal</span> only identical row IDs are interpretted as being the same object.
</p>


<h3>Value</h3>

<p>The output of coordmatch is a list containing:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>The full matrix of matching IDs. The rows are ordered identically to <span class="option">coordref</span>, and the ID value is the row position in <span class="option">coordcompare</span> for the match.</p>
</td></tr>
<tr><td><code>sep</code></td>
<td>
<p>The full matrix of matching separations in the same units as <span class="option">radunit</span>. The rows are ordered identically to <span class="option">coordref</span>, and the sep value is the separation for each matrix location in the ID list object.</p>
</td></tr>
<tr><td><code>Nmatch</code></td>
<td>
<p>Nmatch is a vector giving the total number of matches for each <span class="option">coordref</span> row.</p>
</td></tr>
<tr><td><code>bestmatch</code></td>
<td>
<p>A three column data.frame giving the best matching IDs. Only objects with at least one match are listed. Column 1 (refID) gives the row position from <span class="option">coordref</span> and column 2 (compareID) gives the corresponding best matching row position in <span class="option">coordcompare</span>. Column 3 (sep) gives the separation between the matched ref and compare positions in the same units as radunit.</p>
</td></tr>
</table>
<p>The output of coordmatchsing is a list containing:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>The full vector of matching IDs. The ID values are the row positions in <span class="option">coordcompare</span> for the match.</p>
</td></tr>
<tr><td><code>sep</code></td>
<td>
<p>The full vector of matching separations in the same units as <span class="option">radunit</span>. The sep value is the separation for each vector location in the ID list object.</p>
</td></tr>
<tr><td><code>Nmatch</code></td>
<td>
<p>Total number of matches within the specified radius.</p>
</td></tr>
<tr><td><code>bestmatch</code></td>
<td>
<p>The best matching ID, where the ID value is the row position in <span class="option">coordcompare</span> for the match.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hms2deg">hms2deg</a></code>, <code><a href="#topic+dms2deg">dms2deg</a></code>, <code><a href="#topic+sph2car">sph2car</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(666)

#Here we make objects in a virtual 1 square degree region

mocksky=cbind(runif(1e3), runif(1e3))

#Now we match to find all objects within an arc minute, ignoring self matches

mockmatches=coordmatch(mocksky, mocksky, ignoreexact=TRUE, rad=1, radunit='amin')

#Now we match to find all objects with varying match radii, ignoring self matches

mockmatchesvary=coordmatch(mocksky, mocksky, ignoreexact=TRUE, rad=seq(0,1,length=1e3),
radunit='amin')

#We can do this also by using the internal table match mode:

mockmatchesvary2=coordmatch(mocksky, rad=seq(0,1,length=1e3), radunit='amin')

#Check that this looks the same (should be identical with all zeroes):

summary(mockmatchesvary$bestmatch-mockmatchesvary2$bestmatch)

</code></pre>

<hr>
<h2 id='skyarea'>
Exact angular area calculator
</h2><span id='topic+skyarea'></span>

<h3>Description</h3>

<p>This function takes a survey geometry defined by RA (long) and Dec (latitude) limits and calculates the exact angular area covered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skyarea(long = c(129, 141), lat = c(-2, 3), inunit = "deg", outunit = "deg2", sep=":")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skyarea_+3A_long">long</code></td>
<td>

<p>Upper and lower longitude (RA) limits of interest in units of inunit. If of length 1 then the number specified is assumed to be the upper limit and the lower limit is set to 0.
</p>
</td></tr>
<tr><td><code id="skyarea_+3A_lat">lat</code></td>
<td>

<p>Upper and lower latitude (Dec) limits of interest in units of inunit. If of length 1 then the number specified is assumed to be the upper limit and the lower limit is set to 0.
</p>
</td></tr>
<tr><td><code id="skyarea_+3A_inunit">inunit</code></td>
<td>

<p>The units of angular coordinate provided. Allowed options are deg for degress, amin for arc minutes, asec for arc seconds, rad for radians and sex for sexigesimal (i.e. HMS for RA and DMS for Deg).
</p>
</td></tr>
<tr><td><code id="skyarea_+3A_outunit">outunit</code></td>
<td>

<p>The units of angular area desired. Allowed options are deg2 for square degrees, amin2 for square arc minutes, asec2 for square arc seconds and rad2 or sr for steradians.
</p>
</td></tr>
<tr><td><code id="skyarea_+3A_sep">sep</code></td>
<td>

<p>When inunit='sex', sep defines the type of separator used for the HMS and DMS strings (i.e. H:M:S and D:M:S would be sep=':', which is the default). See <code><a href="#topic+hms2deg">hms2deg</a></code> and <code><a href="#topic+dms2deg">dms2deg</a></code> for more details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two value vector. First value is the sky area covered in units of outunit (named area), second value is the fraction of the celestial sphere covered by the specified geometry (named areafrac).
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cosvol">cosvol</a></code>, <code><a href="#topic+hms2deg">hms2deg</a></code>, <code><a href="#topic+dms2deg">dms2deg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#The GAMA survey areas:
G02area=skyarea(c(30.2,38.8),c(-10.25,-3.72))
G09area=skyarea(c(129,141),c(-2,3))
G12area=skyarea(c(174,186),c(-3,2))
G15area=skyarea(c(211.5,223.5),c(-2,3))
G23area=skyarea(c(338.1,351.9),c(-35,-30))

#Total GAMA survey area:
TotalGAMAarea=G02area+G09area+G12area+G15area+G23area
paste('The GAMA survey area is',round(TotalGAMAarea['area'],2),'sq. deg.')

#Future TACs note: this is less than 1% of the sky ;-)
paste('The GAMA survey area is',round(TotalGAMAarea['areafrac']*100,2),'% of the sky')
</code></pre>

<hr>
<h2 id='skyproj'>
Tan Gnomonic and Sine Orthographic Projection System WCS Solver Functions
</h2><span id='topic+tanproj'></span><span id='topic+sinproj'></span><span id='topic+radec2xy'></span><span id='topic+xy2radec'></span><span id='topic+gnomonic'></span><span id='topic+orthographic'></span>

<h3>Description</h3>

<p>Converts RA/Dec (degrees) to x/y (pixels) position using the Tan Gnomonic or Sine Orthographic projection systems, and vice-versa.
Translations adapted from: http://mathworld.wolfram.com/GnomonicProjection.html and http://mathworld.wolfram.com/OrthographicProjection.html.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radec2xy(RA, Dec, header, CRVAL1 = 0, CRVAL2 = 0, CRPIX1 = 0, CRPIX2 = 0, CD1_1 = 1,
CD1_2 = 0, CD2_1 = 0, CD2_2 = 1, CTYPE1 = 'RA--TAN', CTYPE2 = 'DEC--TAN')
xy2radec(x, y, header, CRVAL1 = 0, CRVAL2 = 0, CRPIX1 = 0, CRPIX2 = 0, CD1_1 = 1,
CD1_2 = 0, CD2_1 = 0, CD2_2 = 1, CTYPE1 = 'RA--TAN', CTYPE2 = 'DEC--TAN')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skyproj_+3A_ra">RA</code></td>
<td>

<p>Vector or matrix; target right ascension in degrees. If matrix then the first column will be used as RA and the second column as Dec.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_dec">Dec</code></td>
<td>

<p>Vector; target declination in degrees. Ignored if <span class="option">RA</span> is a matrix.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_x">x</code></td>
<td>

<p>Vector or matrix; target x-pixel. If Matrix then the first column will be used as the x-axis and the second column as y-axis.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_y">y</code></td>
<td>

<p>Vector; target y-pixel. Ignored if <span class="option">x</span> is a matrix.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_crval1">CRVAL1</code></td>
<td>

<p>FITS header CRVAL1 for the <span class="option">CTYPE1</span> projection system. This is the RA in degrees at the location of <span class="option">CRPIX1</span>.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_crval2">CRVAL2</code></td>
<td>

<p>FITS header CRVAL2 for the <span class="option">CTYPE2</span> projection system. This is the Dec in degrees at the location of <span class="option">CRPIX2</span>.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_crpix1">CRPIX1</code></td>
<td>

<p>FITS header CRPIX1 for the <span class="option">CTYPE1</span> projection system. This is the x pixel value at the location of <span class="option">CRVAL1</span>.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_crpix2">CRPIX2</code></td>
<td>

<p>FITS header CRPIX2 for the <span class="option">CTYPE2</span> projection system. This is the y pixel value at the location of <span class="option">CRVAL2</span>.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_cd1_1">CD1_1</code></td>
<td>

<p>FITS header CD1_1 for the <span class="option">CTYPE1</span> projection system. Change in <span class="option">CTYPE1</span> in degrees along x-Axis.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_cd1_2">CD1_2</code></td>
<td>

<p>FITS header CD1_2 for the <span class="option">CTYPE1</span> projection system. Change in <span class="option">CTYPE1</span> in degrees along y-Axis.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_cd2_1">CD2_1</code></td>
<td>

<p>FITS header CD2_1 for the <span class="option">CTYPE2</span> projection system. Change in <span class="option">CTYPE2</span> in degrees along x-Axis.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_cd2_2">CD2_2</code></td>
<td>

<p>FITS header CD2_2 for the <span class="option">CTYPE2</span> projection system. Change in <span class="option">CTYPE2</span> in degrees along y-Axis.
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_ctype1">CTYPE1</code></td>
<td>

<p>The RA projection system type. Either 'RA&ndash;TAN' for Tan Gnomonic (default), or 'RA&ndash;SIN' for Sine Orthographic. 'RA&ndash;NCP' is approximated by Sine Orthographic with a warning. Over-ridden by the FITS header.  
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_ctype2">CTYPE2</code></td>
<td>

<p>The DEC projection system type. Either 'DEC&ndash;TAN' for Tan Gnomonic (default), or 'DEC&ndash;SIN' for Sine Orthographic. 'DEC&ndash;NCP' is approximated by Sine Orthographic with a warning. Over-ridden by the FITS header.  
</p>
</td></tr>
<tr><td><code id="skyproj_+3A_header">header</code></td>
<td>

<p>Full FITS header in table or vector format. Legal table format headers are provided by the <code>read.fitshdr</code> function or the <span class="option">hdr</span> list output of <code>read.fits</code> in the <code>astro</code> package). Also the <span class="option">hdr</span> output of <code>readFITS</code> in the <code>FITSio</code> package provides legal vector format inputs. If a header is provided then key words will be taken from here as a priority. Missing header keywords are printed out and other header option arguments are used in these cases.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions encode the standard FITS Tan Gnomonic and Sine Orthographic projection systems for solving an image WCS (covering most moden imaging and radio data). They do not deal with higher order polynomial distortion terms.
</p>


<h3>Value</h3>

<table>
<tr><td><code>radec2xy</code></td>
<td>

<p>Returns a two column matrix with columns x and y.
</p>
</td></tr>
<tr><td><code>xy2radec</code></td>
<td>

<p>Returns a two column matrix with columns RA and Dec (in degrees).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>References</h3>

<p>http://mathworld.wolfram.com/GnomonicProjection.html
http://mathworld.wolfram.com/OrthographicProjection.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg2dms">deg2dms</a></code>, <code><a href="#topic+deg2hms">deg2hms</a></code>, <code><a href="#topic+dms2deg">dms2deg</a></code>, <code><a href="#topic+hms2deg">hms2deg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A simple example:

radec2xy(10, 20)
xy2radec(radec2xy(10, 20))
xy2radec(radec2xy(10, 20, CTYPE1='RA--SIN', CTYPE2='DEC--SIN'),
CTYPE1='RA--SIN',CTYPE2='DEC--SIN')

#A more complicated example, where we transform and rotate large amounts:

exdata_start=expand.grid(1:10,21:30)
plot(exdata_start)
exradec=radec2xy(exdata_start, CRVAL1=20, CRPIX1=100, CRVAL2=30, CRPIX2=130, CD1_1=0.1,
CD1_2=-0.05, CD2_1=0.05, CD2_2=0.1)
plot(exradec)
exdata_end=xy2radec(exradec, CRVAL1=20, CRPIX1=100, CRVAL2=30, CRPIX2=130, CD1_1=0.1,
CD1_2=-0.05, CD2_1=0.05, CD2_2=0.1)
plot(exdata_start,cex=2)
points(exdata_end,col='red')

#The residuals should be very small (in the noice of double precision arithmetic):

plot(density(exdata_start[,1]-exdata_end[,1]))
lines(density(exdata_start[,2]-exdata_end[,2]),col='red')
</code></pre>

<hr>
<h2 id='sph2car'>
Transforms 3D spherical coordinates to cartesian coordinates
</h2><span id='topic+sph2car'></span>

<h3>Description</h3>

<p>Transforms 3D spherical coordinates to cartesian coordinates. The user can choose to input the spherical coordinates in degrees or radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph2car(long, lat, radius = 1, deg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sph2car_+3A_long">long</code></td>
<td>

<p>Longitude values, can also contain a matrix of long, lat and radius (in that order).
</p>
</td></tr>
<tr><td><code id="sph2car_+3A_lat">lat</code></td>
<td>

<p>Latitude values.
</p>
</td></tr>
<tr><td><code id="sph2car_+3A_radius">radius</code></td>
<td>

<p>Radius values.
</p>
</td></tr>
<tr><td><code id="sph2car_+3A_deg">deg</code></td>
<td>

<p>Specifies if input is in degrees (default) or radians.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a low level function that is used for plot transformations.
</p>


<h3>Value</h3>

<p>A data.frame is returned containing the columns x, y and z.
</p>


<h3>Author(s)</h3>

<p>Aaron Robotham
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coordmatch">coordmatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(sph2car(45,0,sqrt(2),deg=TRUE))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
