<!DOCTYPE html><html lang="en"><head><title>Help for package redistmetrics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {redistmetrics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#by_plan'><p>Shorten District by Plan vector</p></a></li>
<li><a href='#comp_bc'><p>Calculate Boyce Clark Ratio</p></a></li>
<li><a href='#comp_box_reock'><p>Calculate Box Reock Compactness</p></a></li>
<li><a href='#comp_ch'><p>Calculate Convex Hull Compactness</p></a></li>
<li><a href='#comp_edges_rem'><p>Calculate Edges Removed Compactness</p></a></li>
<li><a href='#comp_fh'><p>Calculate Fryer Holden Compactness</p></a></li>
<li><a href='#comp_frac_kept'><p>Calculate Fraction Kept Compactness</p></a></li>
<li><a href='#comp_log_st'><p>Calculate Log Spanning Tree Compactness</p></a></li>
<li><a href='#comp_lw'><p>Calculate Length Width Compactness</p></a></li>
<li><a href='#comp_polsby'><p>Calculate Polsby Popper Compactness</p></a></li>
<li><a href='#comp_reock'><p>Calculate Reock Compactness</p></a></li>
<li><a href='#comp_schwartz'><p>Calculate Schwartzberg Compactness</p></a></li>
<li><a href='#comp_skew'><p>Calculate Skew Compactness</p></a></li>
<li><a href='#comp_x_sym'><p>Calculate X Symmetry Compactness</p></a></li>
<li><a href='#comp_y_sym'><p>Calculate Y Symmetry Compactness</p></a></li>
<li><a href='#compet_talisman'><p>Compute Talismanic Redistricting Competitiveness Metric</p></a></li>
<li><a href='#dist_euc'><p>Calculate Euclidean Distances</p></a></li>
<li><a href='#dist_ham'><p>Calculate Hamming Distances</p></a></li>
<li><a href='#dist_info'><p>Calculate Variation of Information Distances</p></a></li>
<li><a href='#dist_man'><p>Calculate Manhattan Distances</p></a></li>
<li><a href='#inc_pairs'><p>Count Incumbent Pairings</p></a></li>
<li><a href='#list_fn'><p>Return Functions Matching a Prefix</p></a></li>
<li><a href='#nh'><p>New Hampshire Election and Demographic Data</p></a></li>
<li><a href='#nh_m'><p>Redistricting Plans for New Hampshire as <code>matrix</code></p></a></li>
<li><a href='#nh_map'><p>New Hampshire Election and Demographic Data as a <code>redist_map</code></p></a></li>
<li><a href='#nh_plans'><p>Redistricting Plans for New Hampshire as <code>redist_plans</code></p></a></li>
<li><a href='#part_bias'><p>Calculate Partisan Bias</p></a></li>
<li><a href='#part_decl'><p>Calculate Declination</p></a></li>
<li><a href='#part_decl_simple'><p>Calculate Simplified Declination</p></a></li>
<li><a href='#part_dseats'><p>Calculate Democratic Seats</p></a></li>
<li><a href='#part_dvs'><p>Calculate Democratic Vote Share</p></a></li>
<li><a href='#part_egap'><p>Calculate Efficiency Gap</p></a></li>
<li><a href='#part_egap_ep'><p>Calculate Efficiency Gap (Equal Population Assumption)</p></a></li>
<li><a href='#part_lop_wins'><p>Calculate Lopsided Wins</p></a></li>
<li><a href='#part_mean_median'><p>Calculate Mean Median Score</p></a></li>
<li><a href='#part_resp'><p>Calculate Responsiveness</p></a></li>
<li><a href='#part_rmd'><p>Calculate Ranked Marginal Deviation</p></a></li>
<li><a href='#part_sscd'><p>Calculate Smoothed Seat Count Deviation</p></a></li>
<li><a href='#part_tau_gap'><p>Calculate Tau Gap</p></a></li>
<li><a href='#prep_perims'><p>Prep Polsby Popper Perimeter Tibble</p></a></li>
<li><a href='#seg_dissim'><p>Compute Dissimilarity Index</p></a></li>
<li><a href='#splits_admin'><p>Compute Number of Administrative Units Split</p></a></li>
<li><a href='#splits_count'><p>Count the Number of Splits in Each Administrative Unit</p></a></li>
<li><a href='#splits_district_fuzzy'><p>Fuzzy Splits by District (Experimental)</p></a></li>
<li><a href='#splits_multi'><p>Compute Number of Administrative Units Split More than Once</p></a></li>
<li><a href='#splits_sub_admin'><p>Compute Number of Sub-Administrative Units Split</p></a></li>
<li><a href='#splits_total'><p>Count the Total Splits in Each Plan</p></a></li>
<li><a href='#tally'><p>Tally a Column by District</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Redistricting Metrics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Reliable and flexible tools for scoring redistricting plans using 
  common measures and metrics. These functions provide key direct access to 
  tools useful for non-simulation analyses of redistricting plans, such as for 
  measuring compactness or partisan fairness. Tools are designed to work with 
  the 'redist' package seamlessly.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, Rcpp, vctrs, cli, foreach, doParallel, magrittr, dplyr,
rlang, geos, wk</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0), ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppThread</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://alarm-redist.org/redistmetrics/">http://alarm-redist.org/redistmetrics/</a>,
https::/github.com/alarm-redist/redistmetrics/</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alarm-redist/redistmetrics/issues">https://github.com/alarm-redist/redistmetrics/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 18:44:59 UTC; chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher T. Kenny [aut, cre],
  Cory McCartan [aut],
  Ben Fifield [aut],
  Kosuke Imai [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher T. Kenny &lt;christopherkenny@fas.harvard.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='by_plan'>Shorten District by Plan vector</h2><span id='topic+by_plan'></span>

<h3>Description</h3>

<p>If <code>x</code> is repeated for each district, it returns a plan level value. Otherwise
it returns <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_plan(x, ndists)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="by_plan_+3A_x">x</code></td>
<td>
<p>summary statistic at the district level</p>
</td></tr>
<tr><td><code id="by_plan_+3A_ndists">ndists</code></td>
<td>
<p>numeric. Number of districts. Estimated as the gcd of the unique
run length encodings if missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x or plan level subset of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>by_plan(letters)
by_plan(rep(letters, each = 2))

</code></pre>

<hr>
<h2 id='comp_bc'>Calculate Boyce Clark Ratio</h2><span id='topic+comp_bc'></span>

<h3>Description</h3>

<p>Calculate Boyce Clark Ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_bc(plans, shp, epsg = 3857, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_bc_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_bc_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_bc_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_bc_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Boyce, R., &amp; Clark, W. 1964. The Concept of Shape in Geography.
Geographical Review, 54(4), 561-572.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_bc(plans = nh$r_2020, shp = nh)

# Or many plans:

# slower, beware!
comp_bc(plans = nh_m[, 3:5], shp = nh)


</code></pre>

<hr>
<h2 id='comp_box_reock'>Calculate Box Reock Compactness</h2><span id='topic+comp_box_reock'></span>

<h3>Description</h3>

<p>Box reock is the ratio of the area of the district by the area of the minimum
bounding box (of any rotation). Scores are bounded between 0 and 1, where 1 is
most compact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_box_reock(plans, shp, epsg = 3857, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_box_reock_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_box_reock_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_box_reock_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_box_reock_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' data(nh)
data(nh_m)
# For a single plan:
comp_box_reock(plans = nh$r_2020, shp = nh)

# Or many plans:

# slower, beware!
comp_box_reock(plans = nh_m[, 3:5], shp = nh)

</code></pre>

<hr>
<h2 id='comp_ch'>Calculate Convex Hull Compactness</h2><span id='topic+comp_ch'></span>

<h3>Description</h3>

<p>Calculate Convex Hull Compactness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_ch(plans, shp, epsg = 3857, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_ch_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_ch_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_ch_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_ch_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_ch(plans = nh$r_2020, shp = nh)

# Or many plans:
comp_ch(plans = nh_m[, 3:5], shp = nh)

</code></pre>

<hr>
<h2 id='comp_edges_rem'>Calculate Edges Removed Compactness</h2><span id='topic+comp_edges_rem'></span>

<h3>Description</h3>

<p>Calculate Edges Removed Compactness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_edges_rem(plans, shp, adj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_edges_rem_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_edges_rem_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_edges_rem_+3A_adj">adj</code></td>
<td>
<p>Zero-indexed adjacency list. Not required if a <code>redist_map</code> is supplied for <code>shp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Matthew P. Dube and Jesse Tyler Clark. 2016.
Beyond the circle: Measuring district compactness using graph theory. In
Annual Meeting of the Northeastern Political Science Association
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_edges_rem(plans = nh$r_2020, shp = nh, nh$adj)

# Or many plans:
comp_edges_rem(plans = nh_m[, 3:5], shp = nh, nh$adj)

</code></pre>

<hr>
<h2 id='comp_fh'>Calculate Fryer Holden Compactness</h2><span id='topic+comp_fh'></span>

<h3>Description</h3>

<p>Calculate Fryer Holden Compactness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_fh(plans, shp, total_pop, epsg = 3857, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_fh_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_fh_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_fh_+3A_total_pop">total_pop</code></td>
<td>
<p>A numeric vector with the population for every observation.</p>
</td></tr>
<tr><td><code id="comp_fh_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_fh_+3A_ncores">ncores</code></td>
<td>
<p>TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Fryer R, Holden R. 2011. Measuring the Compactness of Political Districting Plans.
Journal of Law and Economics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_fh(plans = nh$r_2020, shp = nh, total_pop = pop)

# Or many plans:
comp_fh(plans = nh_m[, 3:5], shp = nh, pop)

</code></pre>

<hr>
<h2 id='comp_frac_kept'>Calculate Fraction Kept Compactness</h2><span id='topic+comp_frac_kept'></span>

<h3>Description</h3>

<p>Calculate Fraction Kept Compactness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_frac_kept(plans, shp, adj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_frac_kept_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_frac_kept_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_frac_kept_+3A_adj">adj</code></td>
<td>
<p>Zero-indexed adjacency list. Not required if a <code>redist_map</code> is supplied for <code>shp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Matthew P. Dube and Jesse Tyler Clark. 2016.
Beyond the circle: Measuring district compactness using graph theory. In
Annual Meeting of the Northeastern Political Science Association
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_frac_kept(plans = nh$r_2020, shp = nh, nh$adj)

# Or many plans:
comp_frac_kept(plans = nh_m[, 3:5], shp = nh, nh$adj)

</code></pre>

<hr>
<h2 id='comp_log_st'>Calculate Log Spanning Tree Compactness</h2><span id='topic+comp_log_st'></span>

<h3>Description</h3>

<p>Calculate Log Spanning Tree Compactness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_log_st(plans, shp, counties = NULL, adj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_log_st_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_log_st_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_log_st_+3A_counties">counties</code></td>
<td>
<p>column name in shp containing counties</p>
</td></tr>
<tr><td><code id="comp_log_st_+3A_adj">adj</code></td>
<td>
<p>Zero-indexed adjacency list. Not required if a <code>redist_map</code> is supplied for <code>shp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Cory McCartan and Kosuke Imai. 2020.
Sequential Monte Carlo for Sampling Balanced and Compact Redistricting Plans.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_log_st(plans = nh$r_2020, shp = nh, counties = county, adj = nh$adj)

# Or many plans:
comp_log_st(plans = nh_m[, 3:5], shp = nh, counties = county, adj = nh$adj)

</code></pre>

<hr>
<h2 id='comp_lw'>Calculate Length Width Compactness</h2><span id='topic+comp_lw'></span>

<h3>Description</h3>

<p>Calculate Length Width Compactness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_lw(plans, shp, epsg = 3857, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_lw_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_lw_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_lw_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_lw_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Harris, Curtis C. 1964. “A scientific method of districting”.
Behavioral Science 3(9), 219–225.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_lw(plans = nh$r_2020, shp = nh)

# Or many plans:

# slower, beware!
comp_lw(plans = nh_m[, 3:5], shp = nh)


</code></pre>

<hr>
<h2 id='comp_polsby'>Calculate Polsby Popper Compactness</h2><span id='topic+comp_polsby'></span>

<h3>Description</h3>

<p>Calculate Polsby Popper Compactness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_polsby(
  plans,
  shp,
  use_Rcpp,
  perim_path,
  perim_df,
  epsg = 3857,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_polsby_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_polsby_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_polsby_+3A_use_rcpp">use_Rcpp</code></td>
<td>
<p>If <code>TRUE</code> (the default for more than 8 plans), precompute boundaries
shared by each pair of units and use them to quickly compute the compactness score.</p>
</td></tr>
<tr><td><code id="comp_polsby_+3A_perim_path">perim_path</code></td>
<td>
<p>Path to perimeter tibble saved by <code>prep_perims()</code></p>
</td></tr>
<tr><td><code id="comp_polsby_+3A_perim_df">perim_df</code></td>
<td>
<p>Tibble of perimeters from <code>prep_perims()</code></p>
</td></tr>
<tr><td><code id="comp_polsby_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_polsby_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Cox, E. 1927. A Method of Assigning Numerical and Percentage Values to the
Degree of Roundness of Sand Grains. Journal of Paleontology, 1(3), 179-183.
</p>
<p>Polsby, Daniel D., and Robert D. Popper. 1991. “The Third Criterion:
Compactness as a procedural safeguard against partisan gerrymandering.”
Yale Law &amp; Policy Review 9 (2): 301–353.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_polsby(plans = nh$r_2020, shp = nh)

# Or many plans:
comp_polsby(plans = nh_m[, 3:5], shp = nh)

</code></pre>

<hr>
<h2 id='comp_reock'>Calculate Reock Compactness</h2><span id='topic+comp_reock'></span>

<h3>Description</h3>

<p>Calculate Reock Compactness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_reock(plans, shp, epsg = 3857, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_reock_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_reock_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_reock_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_reock_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Reock, E. 1961. A Note: Measuring Compactness as a Requirement of Legislative
Apportionment. Midwest Journal of Political Science, 5(1), 70-74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_reock(plans = nh$r_2020, shp = nh)

# Or many plans:
comp_reock(plans = nh_m[, 3:5], shp = nh)

</code></pre>

<hr>
<h2 id='comp_schwartz'>Calculate Schwartzberg Compactness</h2><span id='topic+comp_schwartz'></span>

<h3>Description</h3>

<p>Calculate Schwartzberg Compactness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_schwartz(
  plans,
  shp,
  use_Rcpp,
  perim_path,
  perim_df,
  epsg = 3857,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_schwartz_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_schwartz_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_schwartz_+3A_use_rcpp">use_Rcpp</code></td>
<td>
<p>Logical. Use Rcpp?</p>
</td></tr>
<tr><td><code id="comp_schwartz_+3A_perim_path">perim_path</code></td>
<td>
<p>path to perimeter tibble saved by <code>prep_perims()</code></p>
</td></tr>
<tr><td><code id="comp_schwartz_+3A_perim_df">perim_df</code></td>
<td>
<p>tibble of perimeters from <code>prep_perims()</code></p>
</td></tr>
<tr><td><code id="comp_schwartz_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_schwartz_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Schwartzberg, Joseph E. 1966. Reapportionment, Gerrymanders, and the Notion
of Compactness. Minnesota Law Review. 1701.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_schwartz(plans = nh$r_2020, shp = nh)

# Or many plans:
comp_schwartz(plans = nh_m[, 3:5], shp = nh)

</code></pre>

<hr>
<h2 id='comp_skew'>Calculate Skew Compactness</h2><span id='topic+comp_skew'></span>

<h3>Description</h3>

<p>Skew is defined as the ratio of the radii of the largest inscribed circle with
the smallest bounding circle. Scores are bounded between 0 and 1, where 1 is
most compact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_skew(plans, shp, epsg = 3857, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_skew_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_skew_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_skew_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_skew_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>S.N. Schumm. 1963. Sinuosity of alluvial rivers on the Great Plains.
Bulletin of the Geological Society of America, 74. 1089-1100.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
comp_skew(plans = nh$r_2020, shp = nh)

# Or many plans:

# slower, beware!
comp_skew(plans = nh_m[, 3:5], shp = nh)

</code></pre>

<hr>
<h2 id='comp_x_sym'>Calculate X Symmetry Compactness</h2><span id='topic+comp_x_sym'></span>

<h3>Description</h3>

<p>X symmetry is the overlapping area of a shape and its projection over the
x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_x_sym(plans, shp, epsg = 3857, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_x_sym_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_x_sym_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_x_sym_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_x_sym_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Aaron Kaufman, Gary King, and Mayya Komisarchik. 2021.
How to Measure Legislative District Compactness If You Only Know it When You See It.
American Journal of Political Science. 65, 3. Pp. 533-550.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' data(nh)
data(nh_m)
# For a single plan:
comp_x_sym(plans = nh$r_2020, shp = nh)

# Or many plans:

# slower, beware!
comp_x_sym(plans = nh_m[, 3:5], shp = nh)


</code></pre>

<hr>
<h2 id='comp_y_sym'>Calculate Y Symmetry Compactness</h2><span id='topic+comp_y_sym'></span>

<h3>Description</h3>

<p>Y symmetry is the overlapping area of a shape and its projection over the
y-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_y_sym(plans, shp, epsg = 3857, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp_y_sym_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="comp_y_sym_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="comp_y_sym_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="comp_y_sym_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Aaron Kaufman, Gary King, and Mayya Komisarchik. 2021.
How to Measure Legislative District Compactness If You Only Know it When You See It.
American Journal of Political Science. 65, 3. Pp. 533-550.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' data(nh)
data(nh_m)
# For a single plan:
comp_y_sym(plans = nh$r_2020, shp = nh)

# Or many plans:

# slower, beware!
comp_y_sym(plans = nh_m[, 3:5], shp = nh)


</code></pre>

<hr>
<h2 id='compet_talisman'>Compute Talismanic Redistricting Competitiveness Metric</h2><span id='topic+compet_talisman'></span>

<h3>Description</h3>

<p>Compute Talismanic Redistricting Competitiveness Metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compet_talisman(plans, shp, rvote, dvote, alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compet_talisman_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="compet_talisman_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="compet_talisman_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
<tr><td><code id="compet_talisman_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="compet_talisman_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scaling value</p>
</td></tr>
<tr><td><code id="compet_talisman_+3A_beta">beta</code></td>
<td>
<p>Numeric scaling value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Wendy K. Tam Cho and Yan Y. Liu
Toward a Talismanic Redistricting Tool.
Election Law Journal. 15, 4. Pp. 351-366.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
compet_talisman(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
compet_talisman(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='dist_euc'>Calculate Euclidean Distances</h2><span id='topic+dist_euc'></span>

<h3>Description</h3>

<p>Calculate Euclidean Distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_euc(plans, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_euc_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="dist_euc_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of plan distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan (distance is trivial, 0):
dist_euc(plans = nh$r_2020)

# Or many plans:
dist_euc(plans = nh_m[, 3:5])

</code></pre>

<hr>
<h2 id='dist_ham'>Calculate Hamming Distances</h2><span id='topic+dist_ham'></span>

<h3>Description</h3>

<p>Calculate Hamming Distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_ham(plans, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_ham_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="dist_ham_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of plan distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan (distance is trivial, 0):
dist_ham(plans = nh$r_2020)

# Or many plans:
dist_ham(plans = nh_m[, 3:5])

</code></pre>

<hr>
<h2 id='dist_info'>Calculate Variation of Information Distances</h2><span id='topic+dist_info'></span>

<h3>Description</h3>

<p>Calculate Variation of Information Distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_info(plans, shp, total_pop, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_info_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="dist_info_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="dist_info_+3A_total_pop">total_pop</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="dist_info_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of plan distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan (distance is trivial, 0):
dist_info(plans = nh$r_2020, shp = nh, total_pop = pop)

# Or many plans:
dist_info(plans = nh_m[, 3:5], shp = nh, total_pop = pop)

</code></pre>

<hr>
<h2 id='dist_man'>Calculate Manhattan Distances</h2><span id='topic+dist_man'></span>

<h3>Description</h3>

<p>Calculate Manhattan Distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_man(plans, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_man_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="dist_man_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of plan distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan (distance is trivial, 0):
dist_man(plans = nh$r_2020)

# Or many plans:
dist_man(plans = nh_m[, 3:5])

</code></pre>

<hr>
<h2 id='inc_pairs'>Count Incumbent Pairings</h2><span id='topic+inc_pairs'></span>

<h3>Description</h3>

<p>Count the number of incumbents paired with at least one other incumbent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inc_pairs(plans, shp, inc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inc_pairs_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="inc_pairs_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="inc_pairs_+3A_inc">inc</code></td>
<td>
<p>Unqouted name of logical column in <code>shp</code> indicating where incumbents live.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of number of incumbents paired
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# Use incumbent data:
fake_inc &lt;- rep(FALSE, nrow(nh))
fake_inc[3:4] &lt;- TRUE

# For a single plan:
inc_pairs(plans = nh$r_2020, shp = nh, inc = fake_inc)

# Or many plans:
inc_pairs(plans = nh_m[, 3:5], shp = nh, inc = fake_inc)

</code></pre>

<hr>
<h2 id='list_fn'>Return Functions Matching a Prefix</h2><span id='topic+list_fn'></span>

<h3>Description</h3>

<p>This package uses prefixes for each function that correspond to the type of measure.
This function returns the functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_fn(prefix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_fn_+3A_prefix">prefix</code></td>
<td>
<p>character prefix of functions to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list_fn('part_')
</code></pre>

<hr>
<h2 id='nh'>New Hampshire Election and Demographic Data</h2><span id='topic+nh'></span>

<h3>Description</h3>

<p>This data set contains demographic, election, and geographic information for
the 326 voting tabulation districts in New Hampshire in 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nh")
</code></pre>


<h3>Format</h3>

<p>A tibble with 326 rows and 45 columns
</p>

<ul>
<li><p> GEOID20: 2020 VTD GEOID
</p>
</li>
<li><p> state: state name
</p>
</li>
<li><p> county: county name
</p>
</li>
<li><p> vtd: VTD portion of GEOID
</p>
</li>
<li><p> pop: total population
</p>
</li>
<li><p> pop_hisp: Hispanic population
</p>
</li>
<li><p> pop_white: White, not Hispanic population
</p>
</li>
<li><p> pop_black: Black, not Hispanic population
</p>
</li>
<li><p> pop_aian: American Indian and Alaska Native, not Hispanic population
</p>
</li>
<li><p> pop_asian: Asian, not Hispanic population
</p>
</li>
<li><p> pop_nhpi: Native Hawaiian and Pacific Islander, not Hispanic population
</p>
</li>
<li><p> pop_other: other race, not Hispanic population
</p>
</li>
<li><p> pop_two: multi-race, not Hispanic population
</p>
</li>
<li><p> vap: total voting-age population
</p>
</li>
<li><p> vap_hisp: Hispanic voting-age population
</p>
</li>
<li><p> vap_white: White, not Hispanic voting-age population
</p>
</li>
<li><p> vap_black: Black, not Hispanic voting-age population
</p>
</li>
<li><p> vap_aian: American Indian and Alaska Native, not Hispanic voting-age population
</p>
</li>
<li><p> vap_asian: Asian, not Hispanic voting-age population
</p>
</li>
<li><p> vap_nhpi: Native Hawaiian and Pacific Islander, not Hispanic voting-age population
</p>
</li>
<li><p> vap_other: other race, not Hispanic voting-age population
</p>
</li>
<li><p> vap_two: multi-race, not Hispanic voting-age population
</p>
</li>
<li><p> pre_16_rep_tru: Votes for Republican president 2016
</p>
</li>
<li><p> pre_16_dem_cli: Votes for Democratic president 2016
</p>
</li>
<li><p> uss_16_rep_ayo: Votes for Republican senate 2016
</p>
</li>
<li><p> uss_16_dem_has: Votes for Democratic senate 2016
</p>
</li>
<li><p> gov_16_rep_sun: Votes for Republican governor 2016
</p>
</li>
<li><p> gov_16_dem_van: Votes for Democratic governor 2016
</p>
</li>
<li><p> gov_18_rep_sun: Votes for Republican governor 2018
</p>
</li>
<li><p> gov_18_dem_kel: Votes for Democratic governor 2018
</p>
</li>
<li><p> pre_20_dem_bid: Votes for Democratic president 2020
</p>
</li>
<li><p> pre_20_rep_tru: Votes for Republican president 2020
</p>
</li>
<li><p> uss_20_dem_sha: Votes for Democratic senate 2020
</p>
</li>
<li><p> uss_20_rep_mes: Votes for Republican senate 2020
</p>
</li>
<li><p> gov_20_dem_fel: Votes for Democratic governor 2020
</p>
</li>
<li><p> gov_20_rep_sun: Votes for Republican governor 2020
</p>
</li>
<li><p> arv_16: Average Republican vote 2016
</p>
</li>
<li><p> adv_16: Average Democratic vote 2016
</p>
</li>
<li><p> arv_18: Average Republican vote 2018
</p>
</li>
<li><p> adv_18: Average Democratic vote 2018
</p>
</li>
<li><p> arv_20: Average Republican vote 2020
</p>
</li>
<li><p> adv_20: Average Democratic vote 2020
</p>
</li>
<li><p> nrv: Normal Republican vote
</p>
</li>
<li><p> ndv: Normal Democratic vote
</p>
</li>
<li><p> geometry: sf geometry, simplified for size using rmapshaper
</p>
</li>
<li><p> r_2020: Republican proposed plan for 2020 Congressional districts
</p>
</li>
<li><p> d_2020: Democratic proposed plan for 2020 Congressional districts
</p>
</li>
<li><p> adj: zero-indexed adjacency graph
</p>
</li></ul>



<h3>References</h3>

<p>Voting and Election Science Team, 2020, &quot;2020 Precinct-Level Election Results&quot;,
https://doi.org/10.7910/DVN/K7760H, Harvard Dataverse, V23
</p>
<p>Voting and Election Science Team, 2018, &quot;2016 Precinct-Level Election Results&quot;,
https://doi.org/10.7910/DVN/NH5S2I, Harvard Dataverse, V71
</p>
<p>Voting and Election Science Team, 2019, &quot;2018 Precinct-Level Election Results&quot;,
https://doi.org/10.7910/DVN/UBKYRU, Harvard Dataverse, V48
</p>
<p>Kenny &amp; McCartan (2021, Aug. 10). ALARM Project: 2020 Redistricting Data Files.
Retrieved from <a href="https://github.com/alarm-redist/census-2020/">https://github.com/alarm-redist/census-2020/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
</code></pre>

<hr>
<h2 id='nh_m'>Redistricting Plans for New Hampshire as <code>matrix</code></h2><span id='topic+nh_m'></span>

<h3>Description</h3>

<p>This data set contains two reference plans (<code>d_2020</code> and <code>r_2020</code>) and
50 simulated plans for New Hampshire, based on 2020 demographics, simulated at
a population tolerance of 0.05%.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nh_m")
</code></pre>


<h3>Format</h3>

<p>A matrix with 52 columns and 326 rows where each column is a plan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh_m)
</code></pre>

<hr>
<h2 id='nh_map'>New Hampshire Election and Demographic Data as a <code>redist_map</code></h2><span id='topic+nh_map'></span>

<h3>Description</h3>

<p>This data set contains demographic, election, and geographic information for
the 326 voting tabulation districts in New Hampshire in 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nh_map")
</code></pre>


<h3>Format</h3>

<p>A redist_map with 326 rows and 45 columns
</p>

<ul>
<li><p> GEOID20: 2020 VTD GEOID
</p>
</li>
<li><p> state: state name
</p>
</li>
<li><p> county: county name
</p>
</li>
<li><p> vtd: VTD portion of GEOID
</p>
</li>
<li><p> pop: total population
</p>
</li>
<li><p> pop_hisp: Hispanic population
</p>
</li>
<li><p> pop_white: White, not Hispanic population
</p>
</li>
<li><p> pop_black: Black, not Hispanic population
</p>
</li>
<li><p> pop_aian: American Indian and Alaska Native, not Hispanic population
</p>
</li>
<li><p> pop_asian: Asian, not Hispanic population
</p>
</li>
<li><p> pop_nhpi: Native Hawaiian and Pacific Islander, not Hispanic population
</p>
</li>
<li><p> pop_other: other race, not Hispanic population
</p>
</li>
<li><p> pop_two: multi-race, not Hispanic population
</p>
</li>
<li><p> vap: total voting-age population
</p>
</li>
<li><p> vap_hisp: Hispanic voting-age population
</p>
</li>
<li><p> vap_white: White, not Hispanic voting-age population
</p>
</li>
<li><p> vap_black: Black, not Hispanic voting-age population
</p>
</li>
<li><p> vap_aian: American Indian and Alaska Native, not Hispanic voting-age population
</p>
</li>
<li><p> vap_asian: Asian, not Hispanic voting-age population
</p>
</li>
<li><p> vap_nhpi: Native Hawaiian and Pacific Islander, not Hispanic voting-age population
</p>
</li>
<li><p> vap_other: other race, not Hispanic voting-age population
</p>
</li>
<li><p> vap_two: multi-race, not Hispanic voting-age population
</p>
</li>
<li><p> pre_16_rep_tru: Votes for Republican president 2016
</p>
</li>
<li><p> pre_16_dem_cli: Votes for Democratic president 2016
</p>
</li>
<li><p> uss_16_rep_ayo: Votes for Republican senate 2016
</p>
</li>
<li><p> uss_16_dem_has: Votes for Democratic senate 2016
</p>
</li>
<li><p> gov_16_rep_sun: Votes for Republican governor 2016
</p>
</li>
<li><p> gov_16_dem_van: Votes for Democratic governor 2016
</p>
</li>
<li><p> gov_18_rep_sun: Votes for Republican governor 2018
</p>
</li>
<li><p> gov_18_dem_kel: Votes for Democratic governor 2018
</p>
</li>
<li><p> pre_20_dem_bid: Votes for Democratic president 2020
</p>
</li>
<li><p> pre_20_rep_tru: Votes for Republican president 2020
</p>
</li>
<li><p> uss_20_dem_sha: Votes for Democratic senate 2020
</p>
</li>
<li><p> uss_20_rep_mes: Votes for Republican senate 2020
</p>
</li>
<li><p> gov_20_dem_fel: Votes for Democratic governor 2020
</p>
</li>
<li><p> gov_20_rep_sun: Votes for Republican governor 2020
</p>
</li>
<li><p> arv_16: Average Republican vote 2016
</p>
</li>
<li><p> adv_16: Average Democratic vote 2016
</p>
</li>
<li><p> arv_18: Average Republican vote 2018
</p>
</li>
<li><p> adv_18: Average Democratic vote 2018
</p>
</li>
<li><p> arv_20: Average Republican vote 2020
</p>
</li>
<li><p> adv_20: Average Democratic vote 2020
</p>
</li>
<li><p> nrv: Normal Republican vote
</p>
</li>
<li><p> ndv: Normal Democratic vote
</p>
</li>
<li><p> r_2020: Republican proposed plan for 2020 Congressional districts
</p>
</li>
<li><p> d_2020: Democratic proposed plan for 2020 Congressional districts
</p>
</li>
<li><p> adj: zero-indexed adjacency graph
</p>
</li>
<li><p> geometry: sf geometry, simplified for size using rmapshaper
</p>
</li></ul>



<h3>References</h3>

<p>Voting and Election Science Team, 2020, &quot;2020 Precinct-Level Election Results&quot;,
https://doi.org/10.7910/DVN/K7760H, Harvard Dataverse, V23
</p>
<p>Voting and Election Science Team, 2018, &quot;2016 Precinct-Level Election Results&quot;,
https://doi.org/10.7910/DVN/NH5S2I, Harvard Dataverse, V71
</p>
<p>Voting and Election Science Team, 2019, &quot;2018 Precinct-Level Election Results&quot;,
https://doi.org/10.7910/DVN/UBKYRU, Harvard Dataverse, V48
</p>
<p>Kenny &amp; McCartan (2021, Aug. 10). ALARM Project: 2020 Redistricting Data Files.
Retrieved from <a href="https://github.com/alarm-redist/census-2020/">https://github.com/alarm-redist/census-2020/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh_map)
</code></pre>

<hr>
<h2 id='nh_plans'>Redistricting Plans for New Hampshire as <code>redist_plans</code></h2><span id='topic+nh_plans'></span>

<h3>Description</h3>

<p>This data set contains two reference plans (<code>d_2020</code> and <code>r_2020</code>) and
50 simulated plans for New Hampshire, based on 2020 demographics, simulated at
a population tolerance of 0.05%.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("nh_plans")
</code></pre>


<h3>Format</h3>

<p>A redist_plans with 104 rows and 3 columns
</p>

<ul>
<li><p> draw: factor identifying the reference plans (<code>d_2020</code> and <code>r_2020</code>) and 50 simulted plans
</p>
</li>
<li><p> district: district number (<code>1</code> or <code>2</code>)
</p>
</li>
<li><p> total_pop: total population in the district
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(nh_plans)
</code></pre>

<hr>
<h2 id='part_bias'>Calculate Partisan Bias</h2><span id='topic+part_bias'></span>

<h3>Description</h3>

<p>Calculate Partisan Bias
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_bias(plans, shp, dvote, rvote, v = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_bias_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_bias_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_bias_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_bias_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
<tr><td><code id="part_bias_+3A_v">v</code></td>
<td>
<p>vote share to calculate bias at. Numeric. Default is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Jonathan N. Katz, Gary King, and Elizabeth Rosenblatt. 2020.
Theoretical Foundations and Empirical Evaluations of Partisan Fairness in District-Based Democracies.
American Political Science Review, 114, 1, Pp. 164-178.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_bias(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_bias(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_decl'>Calculate Declination</h2><span id='topic+part_decl'></span>

<h3>Description</h3>

<p>Calculate Declination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_decl(plans, shp, dvote, rvote, normalize = TRUE, adjust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_decl_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_decl_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_decl_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_decl_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
<tr><td><code id="part_decl_+3A_normalize">normalize</code></td>
<td>
<p>Default is TRUE Translate score to an angle?</p>
</td></tr>
<tr><td><code id="part_decl_+3A_adjust">adjust</code></td>
<td>
<p>Default is TRUE. Applies a correction to increase cross-size comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Gregory S. Warrington. 2018. &quot;Quantifying Gerrymandering Using the Vote Distribution.&quot;
Election Law Journal: Rules, Politics, and Policy. Pp. 39-57.http://doi.org/10.1089/elj.2017.0447
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_decl(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_decl(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_decl_simple'>Calculate Simplified Declination</h2><span id='topic+part_decl_simple'></span>

<h3>Description</h3>

<p>Calculate Simplified Declination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_decl_simple(plans, shp, dvote, rvote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_decl_simple_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_decl_simple_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_decl_simple_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_decl_simple_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Jonathan N. Katz, Gary King, and Elizabeth Rosenblatt. 2020.
Theoretical Foundations and Empirical Evaluations of Partisan Fairness in District-Based Democracies.
American Political Science Review, 114, 1, Pp. 164-178.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_decl_simple(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_decl_simple(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_dseats'>Calculate Democratic Seats</h2><span id='topic+part_dseats'></span>

<h3>Description</h3>

<p>Calculate Democratic Seats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_dseats(plans, shp, dvote, rvote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_dseats_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_dseats_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_dseats_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_dseats_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_dseats(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_dseats(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_dvs'>Calculate Democratic Vote Share</h2><span id='topic+part_dvs'></span>

<h3>Description</h3>

<p>Calculate Democratic Vote Share
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_dvs(plans, shp, dvote, rvote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_dvs_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_dvs_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_dvs_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_dvs_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_dvs(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_dvs(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_egap'>Calculate Efficiency Gap</h2><span id='topic+part_egap'></span>

<h3>Description</h3>

<p>Calculate Efficiency Gap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_egap(plans, shp, dvote, rvote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_egap_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_egap_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_egap_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_egap_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Nicholas O. Stephanopoulos. 2015.
Partisan Gerrymandering and the Efficiency Gap.
The University of Chicago Law Review, 82, Pp. 831-900.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_egap(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_egap(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_egap_ep'>Calculate Efficiency Gap (Equal Population Assumption)</h2><span id='topic+part_egap_ep'></span>

<h3>Description</h3>

<p>Calculate Efficiency Gap (Equal Population Assumption)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_egap_ep(plans, shp, dvote, rvote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_egap_ep_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_egap_ep_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_egap_ep_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_egap_ep_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Nicholas O. Stephanopoulos. 2015.
Partisan Gerrymandering and the Efficiency Gap.
The University of Chicago Law Review, 82, Pp. 831-900.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_egap_ep(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_egap_ep(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_lop_wins'>Calculate Lopsided Wins</h2><span id='topic+part_lop_wins'></span>

<h3>Description</h3>

<p>Calculate Lopsided Wins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_lop_wins(plans, shp, dvote, rvote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_lop_wins_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_lop_wins_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_lop_wins_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_lop_wins_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Samuel S.-H. Wang. 2016. &quot;Three Tests for Practical Evaluation of Partisan Gerrymandering.&quot;
Stanford Law Review, 68, Pp. 1263 - 1321.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_lop_wins(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_lop_wins(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_mean_median'>Calculate Mean Median Score</h2><span id='topic+part_mean_median'></span>

<h3>Description</h3>

<p>Calculate Mean Median Score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_mean_median(plans, shp, dvote, rvote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_mean_median_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_mean_median_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_mean_median_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_mean_median_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Michael D. McDonald and Robin E. Best. 2015.
Unfair Partisan Gerrymanders in Politics and Law: A Diagnostic Applied to Six Cases.
Election Law Journal: Rules, Politics, and Policy. 14. 4. Pp. 312-330.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# zero for the two district case:
# For a single plan:
part_mean_median(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_mean_median(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_resp'>Calculate Responsiveness</h2><span id='topic+part_resp'></span>

<h3>Description</h3>

<p>Calculate Responsiveness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_resp(plans, shp, dvote, rvote, v = 0.5, bandwidth = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_resp_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_resp_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_resp_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_resp_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
<tr><td><code id="part_resp_+3A_v">v</code></td>
<td>
<p>vote share to calculate bias at. Numeric. Default is 0.5.</p>
</td></tr>
<tr><td><code id="part_resp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Defaults to 0.01. A value between 0 and 1 for the step size to estimate the slope.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Jonathan N. Katz, Gary King, and Elizabeth Rosenblatt. 2020.
Theoretical Foundations and Empirical Evaluations of Partisan Fairness in District-Based Democracies.
American Political Science Review, 114, 1, Pp. 164-178.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_resp(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_resp(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_rmd'>Calculate Ranked Marginal Deviation</h2><span id='topic+part_rmd'></span>

<h3>Description</h3>

<p>Calculate Ranked Marginal Deviation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_rmd(plans, shp, dvote, rvote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_rmd_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_rmd_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_rmd_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_rmd_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Gregory Herschlag, Han Sung Kang, Justin Luo, Christy Vaughn Graves, Sachet Bangia,
Robert Ravier &amp; Jonathan C. Mattingly (2020) Quantifying Gerrymandering in North Carolina,
Statistics and Public Policy, 7:1, 30-38, DOI: 10.1080/2330443X.2020.1796400
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_rmd(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_rmd(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_sscd'>Calculate Smoothed Seat Count Deviation</h2><span id='topic+part_sscd'></span>

<h3>Description</h3>

<p>Calculate Smoothed Seat Count Deviation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_sscd(plans, shp, dvote, rvote)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_sscd_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_sscd_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_sscd_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_sscd_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Gregory Herschlag, Han Sung Kang, Justin Luo, Christy Vaughn Graves, Sachet Bangia,
Robert Ravier &amp; Jonathan C. Mattingly (2020) Quantifying Gerrymandering in North Carolina,
Statistics and Public Policy, 7:1, 30-38, DOI: 10.1080/2330443X.2020.1796400
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_sscd(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_sscd(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='part_tau_gap'>Calculate Tau Gap</h2><span id='topic+part_tau_gap'></span>

<h3>Description</h3>

<p>Calculate Tau Gap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_tau_gap(plans, shp, dvote, rvote, tau = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_tau_gap_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="part_tau_gap_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="part_tau_gap_+3A_dvote">dvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
<tr><td><code id="part_tau_gap_+3A_rvote">rvote</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
<tr><td><code id="part_tau_gap_+3A_tau">tau</code></td>
<td>
<p>A non-negative numeric for calculating Tau Gap. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Gregory S. Warrington. 2018. &quot;Quantifying Gerrymandering Using the Vote Distribution.&quot;
Election Law Journal: Rules, Politics, and Policy. Pp. 39-57.http://doi.org/10.1089/elj.2017.0447
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
part_tau_gap(plans = nh$r_2020, shp = nh, rvote = nrv, dvote = ndv)

# Or many plans:
part_tau_gap(plans = nh_m[, 3:5], shp = nh, rvote = nrv, dvote = ndv)

</code></pre>

<hr>
<h2 id='prep_perims'>Prep Polsby Popper Perimeter Tibble</h2><span id='topic+prep_perims'></span>

<h3>Description</h3>

<p>Replaces <code>redist.prep.polsbypopper</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_perims(shp, epsg = 3857, perim_path, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prep_perims_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="prep_perims_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
<tr><td><code id="prep_perims_+3A_perim_path">perim_path</code></td>
<td>
<p>A path to save an rds</p>
</td></tr>
<tr><td><code id="prep_perims_+3A_ncores">ncores</code></td>
<td>
<p>Integer number of cores to use. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble of perimeters and lengths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
prep_perims(nh)

</code></pre>

<hr>
<h2 id='seg_dissim'>Compute Dissimilarity Index</h2><span id='topic+seg_dissim'></span>

<h3>Description</h3>

<p>Compute Dissimilarity Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg_dissim(plans, shp, group_pop, total_pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seg_dissim_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="seg_dissim_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="seg_dissim_+3A_group_pop">group_pop</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with group population.</p>
</td></tr>
<tr><td><code id="seg_dissim_+3A_total_pop">total_pop</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with total population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>References</h3>

<p>Douglas Massey and Nancy Denton. 1987.
The Dimensions of Social Segregation. Social Forces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
seg_dissim(plans = nh$r_2020, shp = nh, group_pop = vap_hisp, total_pop = vap)

# Or many plans:
seg_dissim(plans = nh_m[, 3:5], shp = nh, group_pop = vap_hisp, total_pop = vap)

</code></pre>

<hr>
<h2 id='splits_admin'>Compute Number of Administrative Units Split</h2><span id='topic+splits_admin'></span>

<h3>Description</h3>

<p>Compute Number of Administrative Units Split
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_admin(plans, shp, admin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_admin_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="splits_admin_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="splits_admin_+3A_admin">admin</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with numeric identifiers for administrative units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
splits_admin(plans = nh$r_2020, shp = nh, admin = county)

# Or many plans:
splits_admin(plans = nh_m[, 3:5], shp = nh, admin = county)

</code></pre>

<hr>
<h2 id='splits_count'>Count the Number of Splits in Each Administrative Unit</h2><span id='topic+splits_count'></span>

<h3>Description</h3>

<p>Tallies the number of unique administrative unit-districts. An unsplit administrative
unit will return an entry of 1, while each additional administrative unit-district
adds 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_count(plans, shp, admin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_count_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="splits_count_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="splits_count_+3A_admin">admin</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with numeric identifiers for administrative units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
splits_count(plans = nh$r_2020, shp = nh, admin = county)

# Or many plans:
splits_count(plans = nh_m[, 3:5], shp = nh, admin = county)

</code></pre>

<hr>
<h2 id='splits_district_fuzzy'>Fuzzy Splits by District (Experimental)</h2><span id='topic+splits_district_fuzzy'></span>

<h3>Description</h3>

<p>Not all relevant geographies nest neatly into Census blocks, including communities
of interest or neighborhood. For these cases, this provides a tabulation by district of
the number of splits. As some geographies can be split multiple times, the
sum of these splits may not reflect the total number of splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_district_fuzzy(plans, shp, nbr, thresh = 0.01, epsg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_district_fuzzy_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="splits_district_fuzzy_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame with an <code>sf</code> geometry column.</p>
</td></tr>
<tr><td><code id="splits_district_fuzzy_+3A_nbr">nbr</code></td>
<td>
<p>Geographic neighborhood, community, or other unit to check splits for.</p>
</td></tr>
<tr><td><code id="splits_district_fuzzy_+3A_thresh">thresh</code></td>
<td>
<p>Percent as decimal of an area to trim away. Default is .01, which is 1%.</p>
</td></tr>
<tr><td><code id="splits_district_fuzzy_+3A_epsg">epsg</code></td>
<td>
<p>Numeric EPSG code to use to project the shapefile, if needed. Default is 3857.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beware, this requires a <code>nbr</code> shape input and will be slower than checking splits in cases where
administrative unit nests cleanly into the geographies represented by <code>shp</code>.
</p>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)

# toy example,
# suppose we care about the splits of the counties and they don't nest
nh_cty &lt;- nh %&gt;% dplyr::group_by(county) %&gt;% dplyr::summarize()

# For a single plan:
splits_district_fuzzy(plans = nh$r_2020, shp = nh, nbr = nh_cty)

# Or many plans:
splits_district_fuzzy(plans = nh_m[, 3:5], shp = nh, nbr = nh_cty)
</code></pre>

<hr>
<h2 id='splits_multi'>Compute Number of Administrative Units Split More than Once</h2><span id='topic+splits_multi'></span>

<h3>Description</h3>

<p>Compute Number of Administrative Units Split More than Once
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_multi(plans, shp, admin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_multi_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="splits_multi_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="splits_multi_+3A_admin">admin</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with numeric identifiers for administrative units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
splits_multi(plans = nh$r_2020, shp = nh, admin = county)

# Or many plans:
splits_multi(plans = nh_m[, 3:5], shp = nh, admin = county)

</code></pre>

<hr>
<h2 id='splits_sub_admin'>Compute Number of Sub-Administrative Units Split</h2><span id='topic+splits_sub_admin'></span>

<h3>Description</h3>

<p>Compute Number of Sub-Administrative Units Split
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_sub_admin(plans, shp, sub_admin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_sub_admin_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="splits_sub_admin_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="splits_sub_admin_+3A_sub_admin">sub_admin</code></td>
<td>
<p>Unqouted name of column in shp with numeric identifiers for subsidiary administrative units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector. Can be shaped into a district-by-plan matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
splits_sub_admin(plans = nh$r_2020, shp = nh, sub_admin = county)

# Or many plans:
splits_sub_admin(plans = nh_m[, 3:5], shp = nh, sub_admin = county)

</code></pre>

<hr>
<h2 id='splits_total'>Count the Total Splits in Each Plan</h2><span id='topic+splits_total'></span>

<h3>Description</h3>

<p>Counts the total number of administrative splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_total(plans, shp, admin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_total_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="splits_total_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="splits_total_+3A_admin">admin</code></td>
<td>
<p>Unqouted name of column in <code>shp</code> with numeric identifiers for administrative units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)
# For a single plan:
splits_total(plans = nh$r_2020, shp = nh, admin = county)

# Or many plans:
splits_total(plans = nh_m[, 3:5], shp = nh, admin = county)

</code></pre>

<hr>
<h2 id='tally'>Tally a Column by District</h2><span id='topic+tally'></span>

<h3>Description</h3>

<p>Helper function to aggregate a vector by district. Can be used to calculate
total population, group percentages, and more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tally(plans, shp, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tally_+3A_plans">plans</code></td>
<td>
<p>A <code>redist_plans</code> object or plans_matrix where each row indicates a district assignment and each column is a plan.</p>
</td></tr>
<tr><td><code id="tally_+3A_shp">shp</code></td>
<td>
<p>A <code>redist_map</code> object, tibble, or data frame containing other columns.</p>
</td></tr>
<tr><td><code id="tally_+3A_x">x</code></td>
<td>
<p>The numeric vector to tally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the tallies. Can be shaped into a
district-by-plan matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nh)
data(nh_m)

tally(nh_m, nh, pop) # total population
tally(nh_m, nh, vap_hisp) / tally(nh_m, nh, vap) # HVAP

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
