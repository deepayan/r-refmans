<!DOCTYPE html><html lang="en-GB"><head><title>Help for package geometry</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geometry}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bary2cart'><p>Conversion of Barycentric to Cartesian coordinates</p></a></li>
<li><a href='#cart2bary'><p>Conversion of Cartesian to Barycentric coordinates.</p></a></li>
<li><a href='#cart2pol'><p>Transform Cartesian coordinates to polar or cylindrical coordinates.</p></a></li>
<li><a href='#cart2sph'><p>Transform Cartesian to spherical coordinates</p></a></li>
<li><a href='#convhulln'><p>Compute smallest convex hull that encloses a set of points</p></a></li>
<li><a href='#delaunayn'><p>Delaunay triangulation in N dimensions</p></a></li>
<li><a href='#distmesh2d'><p>A simple mesh generator for non-convex regions</p></a></li>
<li><a href='#distmeshnd'><p>A simple mesh generator for non-convex regions in n-D space</p></a></li>
<li><a href='#dot'><p>Compute the dot product of two vectors</p></a></li>
<li><a href='#entry.value'><p>Retrieve or set a list of array element values</p></a></li>
<li><a href='#extprod3d'><p>Compute external- or &lsquo;cross&rsquo;- product of 3D vectors.</p></a></li>
<li><a href='#feasible.point'><p>Find point in intersection of convex hulls</p></a></li>
<li><a href='#halfspacen'><p>Compute halfspace intersection about a point</p></a></li>
<li><a href='#inhulln'><p>Test if points lie in convex hull</p></a></li>
<li><a href='#intersectn'><p>Compute convex hull of intersection of two sets of points</p></a></li>
<li><a href='#matmax'><p>Row-wise matrix functions</p></a></li>
<li><a href='#mesh.dcircle'><p>Circle distance function</p></a></li>
<li><a href='#mesh.diff'><p>Difference, union and intersection operation on  two regions</p></a></li>
<li><a href='#mesh.drectangle'><p>Rectangle distance function</p></a></li>
<li><a href='#mesh.dsphere'><p>Sphere distance function</p></a></li>
<li><a href='#mesh.hunif'><p>Uniform desired edge length</p></a></li>
<li><a href='#pol2cart'><p>Transform polar or cylindrical coordinates to Cartesian coordinates.</p></a></li>
<li><a href='#polyarea'><p>Determines area of a polygon by triangle method.</p></a></li>
<li><a href='#rbox'><p>Generate various point distributions</p></a></li>
<li><a href='#sph2cart'><p>Transform spherical coordinates to Cartesian coordinates</p></a></li>
<li><a href='#surf.tri'><p>Find surface triangles from tetrahedral mesh</p></a></li>
<li><a href='#tetramesh'><p>Render tetrahedron mesh (3D)</p></a></li>
<li><a href='#to.mesh3d'><p>Convert convhulln object to RGL mesh</p></a></li>
<li><a href='#trimesh'><p>Display triangles mesh (2D)</p></a></li>
<li><a href='#tsearch'><p>Search for the enclosing Delaunay convex hull</p></a></li>
<li><a href='#tsearchn'><p>Search for the enclosing Delaunay convex hull</p></a></li>
<li><a href='#Unique'><p>Extract Unique Rows</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Mesh Generation and Surface Tessellation</td>
</tr>
<tr>
<td>Description:</td>
<td>Makes the 'Qhull' library <a href="http://www.qhull.org">http://www.qhull.org</a>
    available in R, in a similar manner as in Octave and MATLAB. Qhull
    computes convex hulls, Delaunay triangulations, halfspace
    intersections about a point, Voronoi diagrams, furthest-site
    Delaunay triangulations, and furthest-site Voronoi diagrams. It
    runs in 2D, 3D, 4D, and higher dimensions. It implements the
    Quickhull algorithm for computing the convex hull. Qhull does not
    support constrained Delaunay triangulations, or mesh generation of
    non-convex objects, but the package does include some R functions
    that allow for this.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://davidcsterratt.github.io/geometry/">https://davidcsterratt.github.io/geometry/</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-08</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidcsterratt/geometry/issues">https://github.com/davidcsterratt/geometry/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magic, Rcpp, lpSolve, linprog</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, testthat, rgl, R.matlab, interp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-08 18:21:07 UTC; dcs</td>
</tr>
<tr>
<td>Author:</td>
<td>Jean-Romain Roussel [cph, ctb] (wrote tsearch function with QuadTrees),
  C. B. Barber [cph],
  Kai Habel [cph, aut],
  Raoul Grasman [cph, aut],
  Robert B. Gramacy [cph, aut],
  Pavlo Mozharovskyi [cph, aut],
  David C. Sterratt <a href="https://orcid.org/0000-0001-9092-9099"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cph, aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David C. Sterratt &lt;david.c.sterratt@ed.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-08 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bary2cart'>Conversion of Barycentric to Cartesian coordinates</h2><span id='topic+bary2cart'></span>

<h3>Description</h3>

<p>Given the barycentric coordinates of one or more points with
respect to a simplex, compute the Cartesian coordinates of these
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bary2cart(X, Beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bary2cart_+3A_x">X</code></td>
<td>
<p>Reference simplex in <code class="reqn">N</code> dimensions represented by a
<code class="reqn">N+1</code>-by-<code class="reqn">N</code> matrix</p>
</td></tr>
<tr><td><code id="bary2cart_+3A_beta">Beta</code></td>
<td>
<p><code class="reqn">M</code> points in barycentric coordinates with
respect to the simplex <code>X</code> represented by a
<code class="reqn">M</code>-by-<code class="reqn">N+1</code> matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">M</code>-by-<code class="reqn">N</code> matrix in which each row is the
Cartesian coordinates of corresponding row of <code>Beta</code>
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cart2bary">cart2bary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define simplex in 2D (i.e. a triangle)
X &lt;- rbind(c(0, 0),
           c(0, 1),
           c(1, 0))
## Cartesian cooridinates of points
beta &lt;- rbind(c(0, 0.5, 0.5),
              c(0.1, 0.8, 0.1))
## Plot triangle and points
trimesh(rbind(1:3), X)
text(X[,1], X[,2], 1:3) # Label vertices
P &lt;- bary2cart(X, beta)
points(P)
</code></pre>

<hr>
<h2 id='cart2bary'>Conversion of Cartesian to Barycentric coordinates.</h2><span id='topic+cart2bary'></span>

<h3>Description</h3>

<p>Given the Cartesian coordinates of one or more points, compute
the barycentric coordinates of these points with respect to a
simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cart2bary(X, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cart2bary_+3A_x">X</code></td>
<td>
<p>Reference simplex in <code class="reqn">N</code> dimensions represented by a
<code class="reqn">N+1</code>-by-<code class="reqn">N</code> matrix</p>
</td></tr>
<tr><td><code id="cart2bary_+3A_p">P</code></td>
<td>
<p><code class="reqn">M</code>-by-<code class="reqn">N</code> matrix in which each row is the Cartesian
coordinates of a point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a reference simplex in <code class="reqn">N</code> dimensions represented by a
<code class="reqn">N+1</code>-by-<code class="reqn">N</code> matrix an arbitrary point <code class="reqn">P</code> in
Cartesian coordinates, represented by a 1-by-<code class="reqn">N</code> row vector, can be
written as
</p>
<p style="text-align: center;"><code class="reqn">P = \beta X</code>
</p>

<p>where <code class="reqn">\beta</code> is an <code class="reqn">N+1</code> vector of the barycentric coordinates.
A criterion on <code class="reqn">\beta</code> is that
</p>
<p style="text-align: center;"><code class="reqn">\sum_i\beta_i = 1</code>
</p>

<p>Now partition the simplex into its first <code class="reqn">N</code> rows <code class="reqn">X_N</code> and
its <code class="reqn">N+1</code>th row <code class="reqn">X_{N+1}</code>. Partition the barycentric
coordinates into the first <code class="reqn">N</code> columns <code class="reqn">\beta_N</code> and the
<code class="reqn">N+1</code>th column <code class="reqn">\beta_{N+1}</code>. This allows us to write
</p>
<p style="text-align: center;"><code class="reqn">P_{N+1} - X_{N+1} = \beta_N X_N + \beta_{N+1} X_{N+1} - X_{N+1}</code>
</p>

<p>which can be written
</p>
<p style="text-align: center;"><code class="reqn">P_{N+1} - X_{N+1} = \beta_N(X_N - 1_N X_{N+1})</code>
</p>

<p>where <code class="reqn">1_N</code> is an <code class="reqn">N</code>-by-1 matrix of ones.  We can then solve
for <code class="reqn">\beta_N</code>:
</p>
<p style="text-align: center;"><code class="reqn">\beta_N = (P_{N+1} - X_{N+1})(X_N - 1_N X_{N+1})^{-1}</code>
</p>

<p>and compute
</p>
<p style="text-align: center;"><code class="reqn">\beta_{N+1} = 1 - \sum_{i=1}^N\beta_i</code>
</p>

<p>This can be generalised for multiple values of
<code class="reqn">P</code>, one per row.
</p>


<h3>Value</h3>

<p><code class="reqn">M</code>-by-<code class="reqn">N+1</code> matrix in which each row is the
barycentric coordinates of corresponding row of <code>P</code>. If the
simplex is degenerate a warning is issued and the function returns
<code>NULL</code>.
</p>


<h3>Note</h3>

<p>Based on the Octave function by David Bateman.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bary2cart">bary2cart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define simplex in 2D (i.e. a triangle)
X &lt;- rbind(c(0, 0),
           c(0, 1),
           c(1, 0))
## Cartesian coordinates of points
P &lt;- rbind(c(0.5, 0.5),
           c(0.1, 0.8))
## Plot triangle and points
trimesh(rbind(1:3), X)
text(X[,1], X[,2], 1:3) # Label vertices
points(P)
cart2bary(X, P)
</code></pre>

<hr>
<h2 id='cart2pol'>Transform Cartesian coordinates to polar or cylindrical coordinates.</h2><span id='topic+cart2pol'></span>

<h3>Description</h3>

<p>The inputs <code>x</code>, <code>y</code> (, and <code>z</code>) must be the same shape, or
scalar.  If called with a single matrix argument then each row of <code>C</code>
represents the Cartesian coordinate (<code>x</code>, <code>y</code> (, <code>z</code>)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cart2pol(x, y = NULL, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cart2pol_+3A_x">x</code></td>
<td>
<p>x-coordinates or matrix with three columns</p>
</td></tr>
<tr><td><code id="cart2pol_+3A_y">y</code></td>
<td>
<p>y-coordinates (optional, if <code>x</code>) is a matrix</p>
</td></tr>
<tr><td><code id="cart2pol_+3A_z">z</code></td>
<td>
<p>z-coordinates (optional, if <code>x</code>) is a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix <code>P</code> where each row represents one
polar/(cylindrical) coordinate (<code>theta</code>, <code>r</code>, (,
<code>z</code>)).
</p>


<h3>Author(s)</h3>

<p>Kai Habel
</p>
<p>David Sterratt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pol2cart">pol2cart</a></code>, <code><a href="#topic+cart2sph">cart2sph</a></code>,
<code><a href="#topic+sph2cart">sph2cart</a></code>
</p>

<hr>
<h2 id='cart2sph'>Transform Cartesian to spherical coordinates</h2><span id='topic+cart2sph'></span>

<h3>Description</h3>

<p>If called with a single matrix argument then each row of <code>c</code>
represents the Cartesian coordinate (<code>x</code>, <code>y</code>, <code>z</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cart2sph(x, y = NULL, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cart2sph_+3A_x">x</code></td>
<td>
<p>x-coordinates or matrix with three columns</p>
</td></tr>
<tr><td><code id="cart2sph_+3A_y">y</code></td>
<td>
<p>y-coordinates (optional, if <code>x</code>) is a matrix</p>
</td></tr>
<tr><td><code id="cart2sph_+3A_z">z</code></td>
<td>
<p>z-coordinates (optional, if <code>x</code>) is a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with columns:
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>the angle relative to the positive x-axis</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>the angle relative to the xy-plane</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>the distance to the origin <code>(0, 0, 0)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kai Habel
</p>
<p>David Sterratt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sph2cart">sph2cart</a></code>, <code><a href="#topic+cart2pol">cart2pol</a></code>,
<code><a href="#topic+pol2cart">pol2cart</a></code>
</p>

<hr>
<h2 id='convhulln'>Compute smallest convex hull that encloses a set of points</h2><span id='topic+convhulln'></span>

<h3>Description</h3>

<p>Returns information about the smallest convex complex of a set of
input points in <code class="reqn">N</code>-dimensional space (the convex hull of the
points). By default, indices to points forming the facets of the
hull are returned; optionally normals to the facets and the
generalised surface area and volume can be returned. This function
interfaces the <a href="http://www.qhull.org">Qhull</a> library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convhulln(
  p,
  options = "Tv",
  output.options = NULL,
  return.non.triangulated.facets = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convhulln_+3A_p">p</code></td>
<td>
<p>An <code class="reqn">M</code>-by-<code class="reqn">N</code> matrix. The rows of <code>p</code>
represent <code class="reqn">M</code> points in <code class="reqn">N</code>-dimensional space.</p>
</td></tr>
<tr><td><code id="convhulln_+3A_options">options</code></td>
<td>
<p>String containing extra options for the underlying
Qhull command; see details below and Qhull documentation at
<a href="../doc/qhull/html/qconvex.html#synopsis">../doc/qhull/html/qconvex.html#synopsis</a>.</p>
</td></tr>
<tr><td><code id="convhulln_+3A_output.options">output.options</code></td>
<td>
<p>String containing Qhull options to generate
extra output. Currently <code>n</code> (normals) and <code>FA</code>
(generalised areas and volumes) are supported; see
&lsquo;Value&rsquo; for details. If <code>output.options</code> is
<code>TRUE</code>, select all supported options.</p>
</td></tr>
<tr><td><code id="convhulln_+3A_return.non.triangulated.facets">return.non.triangulated.facets</code></td>
<td>
<p>logical defining whether the
output facets should be triangulated; <code>FALSE</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default (<code>return.non.triangulated.facets</code> is
<code>FALSE</code>), return an <code class="reqn">M</code>-by-<code class="reqn">N</code> matrix in which each
row contains the indices of the points in <code>p</code> forming an
<code class="reqn">N-1</code>-dimensional facet. e.g In 3 dimensions, there are 3
indices in each row describing the vertices of 2-dimensional
triangles.
</p>
<p>If <code>return.non.triangulated.facets</code> is <code>TRUE</code> then the
number of columns equals the maximum number of vertices in a
facet, and each row defines a polygon corresponding to a facet
of the convex hull with its vertices followed by <code>NA</code>s
until the end of the row.
</p>
<p>If the <code>output.options</code> or <code>options</code> argument contains
<code>FA</code> or <code>n</code>, return a list with class <code>convhulln</code>
comprising the named elements:
</p>

<dl>
<dt><code>p</code></dt><dd><p>The points passed to <code>convnhulln</code></p>
</dd>
<dt><code>hull</code></dt><dd><p>The convex hull, represented as a matrix indexing <code>p</code>, as
described above</p>
</dd>
<dt><code>area</code></dt><dd><p>If <code>FA</code> is specified, the generalised area of
the hull. This is the surface area of a 3D hull or the length of
the perimeter of a 2D hull.
See <a href="../doc/qhull/html/qh-optf.html#FA">../doc/qhull/html/qh-optf.html#FA</a>.</p>
</dd>
<dt><code>vol</code></dt><dd><p>If <code>FA</code> is specified, the generalised volume of
the hull. This is volume of a 3D hull or the area of a 2D hull.
See <a href="../doc/qhull/html/qh-optf.html#FA">../doc/qhull/html/qh-optf.html#FA</a>. </p>
</dd>
<dt><code>normals</code></dt><dd><p>If <code>n</code> is specified, this is a matrix
hyperplane normals with offsets. See <a href="../doc/qhull/html/qh-opto.html#n">../doc/qhull/html/qh-opto.html#n</a>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This function was originally a port of the
<a href="https://octave.org/">Octave</a> convhulln function written
by Kai Habel.
</p>
<p>See further notes in <code><a href="#topic+delaunayn">delaunayn</a></code>.
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman, Robert B. Gramacy, Pavlo Mozharovskyi and
David Sterratt <a href="mailto:david.c.sterratt@ed.ac.uk">david.c.sterratt@ed.ac.uk</a>
</p>


<h3>References</h3>

<p><cite>Barber, C.B., Dobkin, D.P., and Huhdanpaa, H.T.,
&ldquo;The Quickhull algorithm for convex hulls,&rdquo; <em>ACM
Trans. on Mathematical Software,</em> Dec 1996.</cite>
</p>
<p><a href="http://www.qhull.org">http://www.qhull.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersectn">intersectn</a></code>, <code><a href="#topic+delaunayn">delaunayn</a></code>,
<code><a href="#topic+surf.tri">surf.tri</a></code>, <code><a href="interp.html#topic+convex.hull">convex.hull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Points in a sphere
ps &lt;- matrix(rnorm(3000), ncol=3)
ps &lt;- sqrt(3)*ps/drop(sqrt((ps^2) %*% rep(1, 3)))
ts.surf &lt;- t(convhulln(ps))  # see the qhull documentations for the options
## Not run: 
rgl::triangles3d(ps[ts.surf,1],ps[ts.surf,2],ps[ts.surf,3],col="blue",alpha=.2)
for(i in 1:(8*360)) rgl::view3d(i/8)

## End(Not run)

## Square
pq &lt;- rbox(0, C=0.5, D=2)
# Return indices only
convhulln(pq)
# Return convhulln object with normals, generalised area and volume
ch &lt;- convhulln(pq, output.options=TRUE)
plot(ch)

## Cube
pc &lt;- rbox(0, C=0.5, D=3)
# Return indices of triangles on surface
convhulln(pc)
# Return indices of squares on surface
convhulln(pc, return.non.triangulated.facets=TRUE)
</code></pre>

<hr>
<h2 id='delaunayn'>Delaunay triangulation in N dimensions</h2><span id='topic+delaunayn'></span>

<h3>Description</h3>

<p>The Delaunay triangulation is a tessellation of the convex hull of
the points such that no <code class="reqn">N</code>-sphere defined by the <code class="reqn">N</code>-
triangles contains any other points from the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delaunayn(p, options = NULL, output.options = NULL, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delaunayn_+3A_p">p</code></td>
<td>
<p>An <code class="reqn">M</code>-by-<code class="reqn">N</code> matrix whose rows represent <code class="reqn">M</code>
points in <code class="reqn">N</code>-dimensional space.</p>
</td></tr>
<tr><td><code id="delaunayn_+3A_options">options</code></td>
<td>
<p>String containing extra control options for the
underlying Qhull command; see the Qhull documentation
(<a href="../doc/qhull/html/qdelaun.html">../doc/qhull/html/qdelaun.html</a>) for the available
options.
</p>
<p>The <code>Qbb</code> option is always passed to Qhull. The remaining
default options are <code>Qcc Qc Qt Qz</code> for <code class="reqn">N&lt;4</code> and
<code>Qcc Qc Qt Qx</code> for <code class="reqn">N&gt;=4</code>. If neither of the <code>QJ</code>
or <code>Qt</code> options are supplied, the <code>Qt</code> option is
passed to Qhull. The <code>Qt</code> option ensures all Delaunay
regions are simplical (e.g., triangles in 2D). See
<a href="../doc/qhull/html/qdelaun.html">../doc/qhull/html/qdelaun.html</a> for more details. Contrary
to the Qhull documentation, no degenerate (zero area) regions
are returned with the <code>Qt</code> option since the R function
removes them from the triangulation.
</p>
<p><em>If <code>options</code> is specified, the default options are
overridden.</em> It is recommended to use <code>output.options</code> for
options controlling the outputs.</p>
</td></tr>
<tr><td><code id="delaunayn_+3A_output.options">output.options</code></td>
<td>
<p>String containing Qhull options to control
output. Currently <code>Fn</code> (neighbours) and <code>Fa</code> (areas)
are supported. Causes an object of  return value for details. If
<code>output.options</code> is <code>TRUE</code>, select all supported
options.</p>
</td></tr>
<tr><td><code id="delaunayn_+3A_full">full</code></td>
<td>
<p>Deprecated and will be removed in a future release.
Adds options <code>Fa</code> and <code>Fn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output.options</code> is <code>NULL</code> (the default),
return the Delaunay triangulation as a matrix with <code class="reqn">M</code> rows
and <code class="reqn">N+1</code> columns in which each row contains a set of
indices to the input points <code>p</code>. Thus each row describes a
simplex of dimension <code class="reqn">N</code>, e.g. a triangle in 2D or a
tetrahedron in 3D.
</p>
<p>If the <code>output.options</code> argument is <code>TRUE</code> or is a
string containing <code>Fn</code> or <code>Fa</code>, return a list with
class <code>delaunayn</code> comprising the named elements:
</p>

<dl>
<dt><code>tri</code></dt><dd><p>The Delaunay triangulation described above</p>
</dd>
<dt><code>areas</code></dt><dd><p>If <code>TRUE</code> or if <code>Fa</code> is specified, an
<code class="reqn">M</code>-dimensional vector containing the generalised area of
each simplex (e.g. in 2D the areas of triangles; in 3D the volumes
of tetrahedra). See <a href="../doc/qhull/html/qh-optf.html#Fa">../doc/qhull/html/qh-optf.html#Fa</a>.</p>
</dd>
<dt><code>neighbours</code></dt><dd><p>If <code>TRUE</code> or if <code>Fn</code> is specified,
a list of neighbours of each simplex. Note that a negative number
corresponds to &quot;facet&quot; (=&quot;edge&quot; in 2D or &quot;face&quot; in 3D) that has no
neighbour, as will be the case for some simplices on the boundary
of the triangulation.
See <a href="../doc/qhull/html/qh-optf.html#Fn">../doc/qhull/html/qh-optf.html#Fn</a></p>
</dd>
</dl>



<h3>Note</h3>

<p>This function interfaces the Qhull library and is a port
from Octave (<a href="https://octave.org/">https://octave.org/</a>) to R. Qhull computes
convex hulls, Delaunay triangulations, halfspace intersections
about a point, Voronoi diagrams, furthest-site Delaunay
triangulations, and furthest-site Voronoi diagrams. It runs in
2D, 3D, 4D, and higher dimensions. It implements the
Quickhull algorithm for computing the convex hull. Qhull handles
round-off errors from floating point arithmetic. It computes
volumes, surface areas, and approximations to the convex
hull. See the Qhull documentation included in this distribution
(the doc directory <a href="../doc/qhull/index.html">../doc/qhull/index.html</a>).
</p>
<p>Qhull does not support constrained Delaunay triangulations, triangulation
of non-convex surfaces, mesh generation of non-convex objects, or
medium-sized inputs in 9D and higher. A rudimentary algorithm for mesh
generation in non-convex regions using Delaunay triangulation is
implemented in <a href="#topic+distmesh2d">distmesh2d</a> (currently only 2D).
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman and Robert B. Gramacy; based on the
corresponding Octave sources of Kai Habel.
</p>


<h3>References</h3>

<p><cite>Barber, C.B., Dobkin, D.P., and Huhdanpaa, H.T.,
&ldquo;The Quickhull algorithm for convex hulls,&rdquo; <em>ACM Trans. on
Mathematical Software,</em> Dec 1996.</cite>
</p>
<p><a href="http://www.qhull.org">http://www.qhull.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>, <code><a href="#topic+convhulln">convhulln</a></code>,
<code><a href="#topic+surf.tri">surf.tri</a></code>, <code><a href="#topic+distmesh2d">distmesh2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example delaunayn
d &lt;- c(-1,1)
pc &lt;- as.matrix(rbind(expand.grid(d,d,d),0))
tc &lt;- delaunayn(pc)

# example tetramesh
## Not run: 
rgl::view3d(60)
rgl::light3d(120,60)
tetramesh(tc,pc, alpha=0.9)

## End(Not run)

tc1 &lt;- delaunayn(pc, output.options="Fa")
## sum of generalised areas is total volume of cube
sum(tc1$areas)

</code></pre>

<hr>
<h2 id='distmesh2d'>A simple mesh generator for non-convex regions</h2><span id='topic+distmesh2d'></span>

<h3>Description</h3>

<p>An unstructured simplex requires a choice of mesh points (vertex nodes) and
a triangulation.  This is a simple and short algorithm that improves the
quality of a mesh by relocating the mesh points according to a relaxation
scheme of forces in a truss structure. The topology of the truss is reset
using Delaunay triangulation. A (sufficiently smooth) user supplied signed
distance function (<code>fd</code>) indicates if a given node is inside or
outside the region. Points outside the region are projected back to the
boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distmesh2d(
  fd,
  fh,
  h0,
  bbox,
  p = NULL,
  pfix = array(0, dim = c(0, 2)),
  ...,
  dptol = 0.001,
  ttol = 0.1,
  Fscale = 1.2,
  deltat = 0.2,
  geps = 0.001 * h0,
  deps = sqrt(.Machine$double.eps) * h0,
  maxiter = 1000,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distmesh2d_+3A_fd">fd</code></td>
<td>
<p>Vectorized signed distance function, for example
<code><a href="#topic+mesh.dcircle">mesh.dcircle</a></code> or <code><a href="#topic+mesh.diff">mesh.diff</a></code>, accepting
an <code>n</code>-by-<code>2</code> matrix, where <code>n</code> is arbitrary, as
the first argument.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_fh">fh</code></td>
<td>
<p>Vectorized function, for example
<code><a href="#topic+mesh.hunif">mesh.hunif</a></code>, that returns desired edge length as a
function of position.  Accepts an <code>n</code>-by-<code>2</code> matrix,
where <code>n</code> is arbitrary, as its first argument.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_h0">h0</code></td>
<td>
<p>Initial distance between mesh nodes. (Ignored of
<code>p</code> is supplied)</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_bbox">bbox</code></td>
<td>
<p>Bounding box <code>cbind(c(xmin,xmax), c(ymin,ymax))</code></p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_p">p</code></td>
<td>
<p>An <code>n</code>-by-<code>2</code> matrix. The rows of <code>p</code>
represent locations of starting mesh nodes.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_pfix">pfix</code></td>
<td>
<p><code>nfix</code>-by-2 matrix with fixed node positions.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_...">...</code></td>
<td>
<p>parameters to be passed to <code>fd</code> and/or <code>fh</code></p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_dptol">dptol</code></td>
<td>
<p>Algorithm stops when all node movements are smaller
than <code>dptol</code></p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_ttol">ttol</code></td>
<td>
<p>Controls how far the points can move (relatively)
before a retriangulation with <code><a href="#topic+delaunayn">delaunayn</a></code>.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_fscale">Fscale</code></td>
<td>
<p>&ldquo;Internal pressure&rdquo; in the edges.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_deltat">deltat</code></td>
<td>
<p>Size of the time step in Euler's method.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_geps">geps</code></td>
<td>
<p>Tolerance in the geometry evaluations.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_deps">deps</code></td>
<td>
<p>Stepsize <code class="reqn">\Delta x</code> in numerical derivative
computation for distance function.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum iterations.</p>
</td></tr>
<tr><td><code id="distmesh2d_+3A_plot">plot</code></td>
<td>
<p>logical.  If <code>TRUE</code> (default), the mesh is
plotted as it is generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of original Matlab software of Per-Olof Persson.
</p>
<p>Excerpt (modified) from the reference below:
</p>
<p>&lsquo;The algorithm is based on a mechanical analogy between a triangular
mesh and a 2D truss structure. In the physical model, the edges of the
Delaunay triangles of a set of points correspond to bars of a truss. Each
bar has a force-displacement relationship <code class="reqn">f(\ell, \ell_{0})</code>
depending on its current length <code class="reqn">\ell</code> and its unextended length
<code class="reqn">\ell_{0}</code>.&rsquo;
</p>
<p>&lsquo;External forces on the structure come at the boundaries, on which
external forces have normal orientations. These external forces are just
large enough to prevent nodes from moving outside the boundary. The
position of the nodes are the unknowns, and are found by solving for a
static force equilibrium. The hope is that (when <code>fh = function(p)
return(rep(1,nrow(p)))</code>), the lengths of all the bars at equilibrium will
be nearly equal, giving a well-shaped triangular mesh.&rsquo;
</p>
<p>See the references below for all details. Also, see the comments in the
source file.
</p>


<h3>Value</h3>

<p><code>n</code>-by-<code>2</code> matrix with node positions.
</p>


<h3>Wishlist </h3>

 <ul>
<li><p> Implement in C/Fortran
</p>
</li>
<li><p> Implement an <code>n</code>D version as provided in the Matlab
package </p>
</li>
<li><p> Translate other functions of the Matlab package </p>
</li></ul>



<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>References</h3>

<p><a href="http://persson.berkeley.edu/distmesh/">http://persson.berkeley.edu/distmesh/</a>
</p>
<p><cite>P.-O. Persson, G. Strang, A Simple Mesh Generator in MATLAB. SIAM
Review, Volume 46 (2), pp. 329-345, June 2004</cite>
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>, <code><a href="#topic+delaunayn">delaunayn</a></code>,
<code><a href="#topic+mesh.dcircle">mesh.dcircle</a></code>, <code><a href="#topic+mesh.drectangle">mesh.drectangle</a></code>,
<code><a href="#topic+mesh.diff">mesh.diff</a></code>, <code><a href="#topic+mesh.union">mesh.union</a></code>,
<code><a href="#topic+mesh.intersect">mesh.intersect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# examples distmesh2d
fd &lt;- function(p, ...) sqrt((p^2)%*%c(1,1)) - 1
     # also predefined as `mesh.dcircle'
fh &lt;- function(p,...)  rep(1,nrow(p))
bbox &lt;- matrix(c(-1,1,-1,1),2,2)
p &lt;- distmesh2d(fd,fh,0.2,bbox, maxiter=100)
    # this may take a while:
    # press Esc to get result of current iteration

# example with non-convex region
fd &lt;- function(p, ...) mesh.diff(p , mesh.drectangle, mesh.dcircle, radius=.3)
     # fd defines difference of square and circle

p &lt;- distmesh2d(fd,fh,0.05,bbox,radius=0.3,maxiter=4)
p &lt;- distmesh2d(fd,fh,0.05,bbox,radius=0.3, maxiter=10)
     # continue on previous mesh
</code></pre>

<hr>
<h2 id='distmeshnd'>A simple mesh generator for non-convex regions in n-D space</h2><span id='topic+distmeshnd'></span>

<h3>Description</h3>

<p>An unstructured simplex requires a choice of mesh points (vertex nodes) and
a triangulation.  This is a simple and short algorithm that improves the
quality of a mesh by relocating the mesh points according to a relaxation
scheme of forces in a truss structure. The topology of the truss is reset
using Delaunay triangulation. A (sufficiently smooth) user supplied signed
distance function (<code>fd</code>) indicates if a given node is inside or
outside the region. Points outside the region are projected back to the
boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distmeshnd(
  fdist,
  fh,
  h,
  box,
  pfix = array(dim = c(0, ncol(box))),
  ...,
  ptol = 0.001,
  ttol = 0.1,
  deltat = 0.1,
  geps = 0.1 * h,
  deps = sqrt(.Machine$double.eps) * h
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distmeshnd_+3A_fdist">fdist</code></td>
<td>
<p>Vectorized signed distance function, for example
<code><a href="#topic+mesh.dsphere">mesh.dsphere</a></code>, accepting an <code>m</code>-by-<code>n</code>
matrix, where <code>m</code> is arbitrary, as the first argument.</p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_fh">fh</code></td>
<td>
<p>Vectorized function, for example <code><a href="#topic+mesh.hunif">mesh.hunif</a></code>,
that returns desired edge length as a function of position.
Accepts an <code>m</code>-by-<code>n</code> matrix, where <code>n</code> is
arbitrary, as its first argument.</p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_h">h</code></td>
<td>
<p>Initial distance between mesh nodes.</p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_box">box</code></td>
<td>
<p><code>2</code>-by-<code>n</code> matrix that specifies the bounding box.
(See <a href="#topic+distmesh2d">distmesh2d</a> for an example.)</p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_pfix">pfix</code></td>
<td>
<p><code>nfix</code>-by-2 matrix with fixed node positions.</p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_...">...</code></td>
<td>
<p>parameters that are passed to <code>fdist</code> and <code>fh</code></p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_ptol">ptol</code></td>
<td>
<p>Algorithm stops when all node movements are smaller than
<code>dptol</code></p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_ttol">ttol</code></td>
<td>
<p>Controls how far the points can move (relatively) before a
retriangulation with <code><a href="#topic+delaunayn">delaunayn</a></code>.</p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_deltat">deltat</code></td>
<td>
<p>Size of the time step in Euler's method.</p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_geps">geps</code></td>
<td>
<p>Tolerance in the geometry evaluations.</p>
</td></tr>
<tr><td><code id="distmeshnd_+3A_deps">deps</code></td>
<td>
<p>Stepsize <code class="reqn">\Delta x</code> in numerical derivative computation for
distance function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of original Matlab software of Per-Olof Persson.
</p>
<p>Excerpt (modified) from the reference below:
</p>
<p>&lsquo;The algorithm is based on a mechanical analogy between a triangular
mesh and a n-D truss structure. In the physical model, the edges of the
Delaunay triangles of a set of points correspond to bars of a truss. Each
bar has a force-displacement relationship <code class="reqn">f(\ell, \ell_{0})</code>
depending on its current length <code class="reqn">\ell</code> and its unextended length
<code class="reqn">\ell_{0}</code>.&rsquo;
</p>
<p>&lsquo;External forces on the structure come at the boundaries, on which
external forces have normal orientations. These external forces are just
large enough to prevent nodes from moving outside the boundary. The
position of the nodes are the unknowns, and are found by solving for a
static force equilibrium. The hope is that (when <code>fh = function(p)
return(rep(1,nrow(p)))</code>), the lengths of all the bars at equilibrium will
be nearly equal, giving a well-shaped triangular mesh.&rsquo;
</p>
<p>See the references below for all details. Also, see the comments in the
source file of <code>distmesh2d</code>.
</p>


<h3>Value</h3>

<p><code>m</code>-by-<code>n</code> matrix with node positions.
</p>


<h3>Wishlist </h3>

 <ul>
<li><p> Implement in C/Fortran </p>
</li>
<li><p> Translate
other functions of the Matlab package </p>
</li></ul>



<h3>Author(s)</h3>

<p>Raoul Grasman; translated from original Matlab sources of Per-Olof
Persson.
</p>


<h3>References</h3>

<p><a href="http://persson.berkeley.edu/distmesh/">http://persson.berkeley.edu/distmesh/</a>
</p>
<p><cite>P.-O. Persson, G. Strang, A Simple Mesh Generator in MATLAB. SIAM
Review, Volume 46 (2), pp. 329-345, June 2004</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmesh2d">distmesh2d</a></code>, <code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>,
<code><a href="#topic+delaunayn">delaunayn</a></code>, <code><a href="#topic+mesh.dsphere">mesh.dsphere</a></code>,
<code><a href="#topic+mesh.hunif">mesh.hunif</a></code>,<br /> <code><a href="#topic+mesh.diff">mesh.diff</a></code>,
<code><a href="#topic+mesh.union">mesh.union</a></code>, <code><a href="#topic+mesh.intersect">mesh.intersect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# examples distmeshnd
require(rgl)

fd = function(p, ...) sqrt((p^2)%*%c(1,1,1)) - 1
     # also predefined as `mesh.dsphere'
fh = function(p,...)  rep(1,nrow(p))
     # also predefined as `mesh.hunif'
bbox = matrix(c(-1,1),2,3)
p = distmeshnd(fd,fh,0.2,bbox, maxiter=100)
    # this may take a while:
    # press Esc to get result of current iteration

## End(Not run)

</code></pre>

<hr>
<h2 id='dot'>Compute the dot product of two vectors</h2><span id='topic+dot'></span>

<h3>Description</h3>

<p>If <code>x</code> and <code>y</code> are matrices, calculate the dot-product
along the first non-singleton dimension.  If the optional argument
<code>d</code> is given, calculate the dot-product along this
dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dot(x, y, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dot_+3A_x">x</code></td>
<td>
<p>Matrix of vectors</p>
</td></tr>
<tr><td><code id="dot_+3A_y">y</code></td>
<td>
<p>Matrix of vectors</p>
</td></tr>
<tr><td><code id="dot_+3A_d">d</code></td>
<td>
<p>Dimension along which to calculate the dot product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with length of <code>d</code>th dimension
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='entry.value'>Retrieve or set a list of array element values</h2><span id='topic+entry.value'></span><span id='topic+entry.value+3C-'></span>

<h3>Description</h3>

<p><code>entry.value</code> retrieves or sets the values in an array <code>a</code> at the
positions indicated by the rows of a matrix <code>idx</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entry.value(a, idx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="entry.value_+3A_a">a</code></td>
<td>
<p>An array.</p>
</td></tr>
<tr><td><code id="entry.value_+3A_idx">idx</code></td>
<td>
<p>Numerical matrix with the same number of columns as the number
of dimensions of <code>a</code>.  Each row indices a cell in <code>a</code> of which
the value is to be retrieved or set.</p>
</td></tr>
<tr><td><code id="entry.value_+3A_value">value</code></td>
<td>
<p>An array of length <code>nrow(idx)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>entry.value(a,idx)</code> returns a vector of values at the
indicated cells.  <code>entry.value(a,idx) &lt;- val</code> changes the indicated
cells of <code>a</code> to <code>val</code>.
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = array(1:(4^4),c(4,4,4,4))
entry.value(a,cbind(1:4,1:4,1:4,1:4))
entry.value(a,cbind(1:4,1:4,1:4,1:4)) &lt;- 0

entry.value(a, as.matrix(expand.grid(1:4,1:4,1:4,1:4)))
     # same as `c(a[1:4,1:4,1:4,1:4])' which is same as `c(a)'

</code></pre>

<hr>
<h2 id='extprod3d'>Compute external- or &lsquo;cross&rsquo;- product of 3D vectors.</h2><span id='topic+extprod3d'></span>

<h3>Description</h3>

<p>Computes the external product
</p>
<p style="text-align: center;"><code class="reqn"> \left(x_2 y_3 - x_3 y_2,\;
             x_3 y_1 - x_1 y_3,\;
             x_1 y_2 - x_2 y_1 \right) </code>
</p>

<p>of the 3D vectors in <b>x</b> and <b>y</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extprod3d(x, y, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extprod3d_+3A_x">x</code></td>
<td>
<p><code>n</code>-by-3 matrix. Each row is one <b>x</b>-vector</p>
</td></tr>
<tr><td><code id="extprod3d_+3A_y">y</code></td>
<td>
<p><code>n</code>-by-3 matrix. Each row is one <b>y</b>-vector</p>
</td></tr>
<tr><td><code id="extprod3d_+3A_drop">drop</code></td>
<td>
<p>logical. If <code>TRUE</code> and if the inputs are one row
matrices or vectors, then delete the dimensions of the array
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>n</code> is greater than 1 or <code>drop</code> is
<code>FALSE</code>, <code>n</code>-by-3 matrix; if <code>n</code> is 1 and
<code>drop</code> is <code>TRUE</code>, a vector of length 3.
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+drop">drop</a></code>
</p>

<hr>
<h2 id='feasible.point'>Find point in intersection of convex hulls</h2><span id='topic+feasible.point'></span>

<h3>Description</h3>

<p>Find point that lies somewhere in interesction of two convex
hulls. If such a point does not exist, return <code>NA</code>. The
feasible point is found using a linear program similar to the one
suggested at <a href="../doc/qhull/html/qhalf.html#notes">../doc/qhull/html/qhalf.html#notes</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feasible.point(ch1, ch2, tol = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feasible.point_+3A_ch1">ch1</code></td>
<td>
<p>First convex hull with normals</p>
</td></tr>
<tr><td><code id="feasible.point_+3A_ch2">ch2</code></td>
<td>
<p>Second convex hull with normals</p>
</td></tr>
<tr><td><code id="feasible.point_+3A_tol">tol</code></td>
<td>
<p>The point must be at least this far within the facets
of both convex hulls</p>
</td></tr>
</table>

<hr>
<h2 id='halfspacen'>Compute halfspace intersection about a point</h2><span id='topic+halfspacen'></span>

<h3>Description</h3>

<p>Compute halfspace intersection about a point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halfspacen(p, fp, options = "Tv")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="halfspacen_+3A_p">p</code></td>
<td>
<p>An <code class="reqn">M</code>-by-<code class="reqn">N+1</code> matrix. Each row of <code>p</code>
represents a halfspace by a <code class="reqn">N</code>-dimensional normal to a
hyperplane and the offset of the hyperplane.</p>
</td></tr>
<tr><td><code id="halfspacen_+3A_fp">fp</code></td>
<td>
<p>A &ldquo;feasible&rdquo; point that is within the space
contained within all the halfspaces.</p>
</td></tr>
<tr><td><code id="halfspacen_+3A_options">options</code></td>
<td>
<p>String containing extra options, separated by
spaces, for the underlying Qhull command; see Qhull
documentation at <a href="../doc/qhull/html/qhalf.html">../doc/qhull/html/qhalf.html</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">N</code>-column matrix containing the intersection
points of the hyperplanes <a href="../doc/qhull/html/qhalf.html">../doc/qhull/html/qhalf.html</a>.
</p>


<h3>Note</h3>

<p><code>halfspacen</code> was introduced in geometry 0.4.0, and is
still under development. It is worth checking results for
unexpected behaviour.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>References</h3>

<p><cite>Barber, C.B., Dobkin, D.P., and Huhdanpaa, H.T.,
&ldquo;The Quickhull algorithm for convex hulls,&rdquo; <em>ACM
Trans. on Mathematical Software,</em> Dec 1996.</cite>
</p>
<p><a href="http://www.qhull.org">http://www.qhull.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convhulln">convhulln</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- rbox(0, C=0.5)  # Generate points on a unit cube centered around the origin
ch &lt;- convhulln(p, "n") # Generate convex hull, including normals to facets, with "n" option
# Intersections of half planes
# These points should be the same as the orginal points
pn &lt;- halfspacen(ch$normals, c(0, 0, 0)) 

</code></pre>

<hr>
<h2 id='inhulln'>Test if points lie in convex hull</h2><span id='topic+inhulln'></span>

<h3>Description</h3>

<p>Tests if a set of points lies within a convex hull, returning a
boolean vector in which each element is <code>TRUE</code> if the
corresponding point lies within the hull and <code>FALSE</code> if it
lies outwith the hull or on one of its facets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inhulln(ch, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inhulln_+3A_ch">ch</code></td>
<td>
<p>Convex hull produced using <code><a href="#topic+convhulln">convhulln</a></code></p>
</td></tr>
<tr><td><code id="inhulln_+3A_p">p</code></td>
<td>
<p>An <code class="reqn">M</code>-by-<code class="reqn">N</code> matrix of points to test. The rows
of <code>p</code> represent <code class="reqn">M</code> points in <code class="reqn">N</code>-dimensional
space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean vector with <code class="reqn">M</code> elements
</p>


<h3>Note</h3>

<p><code>inhulln</code> was introduced in geometry 0.4.0, and is
still under development. It is worth checking results for
unexpected behaviour.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convhulln">convhulln</a></code>, <code>point.in.polygon</code> in <span class="pkg">sp</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- cbind(c(-1, -1, 1), c(-1, 1, -1))
ch &lt;- convhulln(p)
## First point should be in the hull; last two outside
inhulln(ch, rbind(c(-0.5, -0.5),
                  c( 1  ,  1),
                  c(10  ,  0)))

## Test hypercube
p &lt;- rbox(D=4, B=1)
ch &lt;- convhulln(p)
tp &lt;-  cbind(seq(-1.9, 1.9, by=0.2), 0, 0, 0)
pin &lt;- inhulln(ch, tp)
## Points on x-axis should be in box only betw,een -1 and 1
pin == (tp[,1] &lt; 1 &amp; tp[,1] &gt; -1)
</code></pre>

<hr>
<h2 id='intersectn'>Compute convex hull of intersection of two sets of points</h2><span id='topic+intersectn'></span>

<h3>Description</h3>

<p>Compute convex hull of intersection of two sets of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectn(
  ps1,
  ps2,
  tol = 0,
  return.chs = TRUE,
  options = "Tv",
  fp = NULL,
  autoscale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intersectn_+3A_ps1">ps1</code></td>
<td>
<p>First set of points</p>
</td></tr>
<tr><td><code id="intersectn_+3A_ps2">ps2</code></td>
<td>
<p>Second set of points</p>
</td></tr>
<tr><td><code id="intersectn_+3A_tol">tol</code></td>
<td>
<p>Tolerance used to determine if a feasible point lies
within the convex hulls of both points and to round off the
points generated by the halfspace intersection, which sometimes
produces points very close together.</p>
</td></tr>
<tr><td><code id="intersectn_+3A_return.chs">return.chs</code></td>
<td>
<p>If <code>TRUE</code> (default) return the convex hulls
of the first and second sets of points, as well as the convex
hull of the intersection.</p>
</td></tr>
<tr><td><code id="intersectn_+3A_options">options</code></td>
<td>
<p>Options passed to <code><a href="#topic+halfspacen">halfspacen</a></code>. By
default this is <code>Tv</code>.</p>
</td></tr>
<tr><td><code id="intersectn_+3A_fp">fp</code></td>
<td>
<p>Coordinates of feasible point, i.e. a point known to lie
in the hulls of <code>ps1</code> and <code>ps2</code>. The feasible point is
required for <code><a href="#topic+halfspacen">halfspacen</a></code> to find the intersection.
<code>intersectn</code> tries to find the feasible point automatically
using the linear program in <code><a href="#topic+feasible.point">feasible.point</a></code>, but
currently the linear program fails on some examples where there
is an obvious solution. This option overrides the automatic
search for a feasible point</p>
</td></tr>
<tr><td><code id="intersectn_+3A_autoscale">autoscale</code></td>
<td>
<p><em>Experimental in v0.4.2</em> Automatically scale
the points to lie in a sensible numeric range. May help to
correct some numerical issues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing named elements: <code>ch1</code>, the convex
hull of the first set of points, with volumes, areas and normals
(see <code><a href="#topic+convhulln">convhulln</a></code>; <code>ch2</code>, the convex hull of the
first set of points, with volumes, areas and normals; <code>ps</code>,
the intersection points of convex hulls <code>ch1</code> and
<code>ch2</code>; and <code>ch</code>, the convex hull of the intersection
points, with volumes, areas and normals.
</p>


<h3>Note</h3>

<p><code>intersectn</code> was introduced in geometry 0.4.0, and is
still under development. It is worth checking results for
unexpected behaviour.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convhulln">convhulln</a></code>, <code><a href="#topic+halfspacen">halfspacen</a></code>,
<code><a href="#topic+inhulln">inhulln</a></code>, <code><a href="#topic+feasible.point">feasible.point</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two overlapping boxes
ps1 &lt;- rbox(0, C=0.5)
ps2 &lt;- rbox(0, C=0.5) + 0.5
out &lt;- intersectn(ps1, ps2)
message("Volume of 1st convex hull: ", out$ch1$vol)
message("Volume of 2nd convex hull: ", out$ch2$vol)
message("Volume of intersection convex hull: ", out$ch$vol)
</code></pre>

<hr>
<h2 id='matmax'>Row-wise matrix functions</h2><span id='topic+matmax'></span><span id='topic+matmin'></span><span id='topic+matsort'></span><span id='topic+matorder'></span>

<h3>Description</h3>

<p>Compute maximum or minimum of each row, or sort each row of a matrix, or a
set of (equal length) vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matmax(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matmax_+3A_...">...</code></td>
<td>
<p>A numeric matrix or a set of numeric vectors (that are
column-wise bind together into a matrix with <code>cbind</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matmin</code> and <code>matmax</code> return a vector of length
<code>nrow(cbind(...))</code>.  <code>matsort</code> returns a matrix of dimension
<code>dim(cbind(...))</code> with in each row of <code>cbind(...)</code> sorted.
<code>matsort(x)</code> is a lot faster than, e.g., <code>t(apply(x,1,sort))</code>,
if <code>x</code> is tall (i.e., <code>nrow(x)</code>&gt;&gt;<code>ncol(x)</code> and
<code>ncol(x)</code>&lt;30. If <code>ncol(x)</code>&gt;30 then <code>matsort</code> simply calls
'<code>t(apply(x,1,sort))</code>'.  <code>matorder</code> returns a permutation which
rearranges its first argument into ascending order, breaking ties by
further arguments.
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example(Unique)

</code></pre>

<hr>
<h2 id='mesh.dcircle'>Circle distance function</h2><span id='topic+mesh.dcircle'></span>

<h3>Description</h3>

<p>Signed distance from points <code>p</code> to boundary of circle to
allow easy definition of regions in <code><a href="#topic+distmesh2d">distmesh2d</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.dcircle(p, radius = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh.dcircle_+3A_p">p</code></td>
<td>
<p>A matrix with 2 columns (3 in <code>mesh.dsphere</code>), each row
representing a point in the plane.</p>
</td></tr>
<tr><td><code id="mesh.dcircle_+3A_radius">radius</code></td>
<td>
<p>radius of circle</p>
</td></tr>
<tr><td><code id="mesh.dcircle_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nrow(p)</code> containing the signed
distances to the circle
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman; translated from original Matlab sources of Per-Olof
Persson.
</p>


<h3>References</h3>

<p><a href="http://persson.berkeley.edu/distmesh/">http://persson.berkeley.edu/distmesh/</a>
</p>
<p><cite>P.-O. Persson, G. Strang, A Simple Mesh Generator in MATLAB. SIAM
Review, Volume 46 (2), pp. 329-345, June 2004</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmesh2d">distmesh2d</a></code>, <code><a href="#topic+mesh.drectangle">mesh.drectangle</a></code>,
<code><a href="#topic+mesh.diff">mesh.diff</a></code>, <code><a href="#topic+mesh.intersect">mesh.intersect</a></code>,
<code><a href="#topic+mesh.union">mesh.union</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example(distmesh2d)
</code></pre>

<hr>
<h2 id='mesh.diff'>Difference, union and intersection operation on  two regions</h2><span id='topic+mesh.diff'></span><span id='topic+mesh.union'></span><span id='topic+mesh.intersect'></span>

<h3>Description</h3>

<p>Compute the signed distances from points <code>p</code> to a region
defined by the difference, union or intersection of regions
specified by the functions <code>regionA</code> and <code>regionB</code>.
<code>regionA</code> and <code>regionB</code> must accept a matrix <code>p</code>
with 2 columns as their first argument, and must return a vector
of length <code>nrow(p)</code> containing the signed distances of the
supplied points in <code>p</code> to their respective regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.diff(p, regionA, regionB, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh.diff_+3A_p">p</code></td>
<td>
<p>A matrix with 2 columns (3 in <code>mesh.dsphere</code>), each row
representing a point in the plane.</p>
</td></tr>
<tr><td><code id="mesh.diff_+3A_regiona">regionA</code></td>
<td>
<p>vectorized function describing region A in the
union / intersection / difference</p>
</td></tr>
<tr><td><code id="mesh.diff_+3A_regionb">regionB</code></td>
<td>
<p>vectorized function describing region B in the
union / intersection / difference</p>
</td></tr>
<tr><td><code id="mesh.diff_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>regionA</code> and
<code>regionB</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nrow(p)</code> containing the signed
distances to the boundary of the region.
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman; translated from original Matlab sources of Per-Olof
Persson.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmesh2d">distmesh2d</a></code>, <code><a href="#topic+mesh.dcircle">mesh.dcircle</a></code>,
<code><a href="#topic+mesh.drectangle">mesh.drectangle</a></code> <code><a href="#topic+mesh.dsphere">mesh.dsphere</a></code>
</p>

<hr>
<h2 id='mesh.drectangle'>Rectangle distance function</h2><span id='topic+mesh.drectangle'></span>

<h3>Description</h3>

<p>Signed distance from points <code>p</code> to boundary of rectangle to
allow easy definition of regions in <code><a href="#topic+distmesh2d">distmesh2d</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.drectangle(p, x1 = -1/2, y1 = -1/2, x2 = 1/2, y2 = 1/2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh.drectangle_+3A_p">p</code></td>
<td>
<p>A matrix with 2 columns, each row representing a point in
the plane.</p>
</td></tr>
<tr><td><code id="mesh.drectangle_+3A_x1">x1</code></td>
<td>
<p>lower left corner of rectangle</p>
</td></tr>
<tr><td><code id="mesh.drectangle_+3A_y1">y1</code></td>
<td>
<p>lower left corner of rectangle</p>
</td></tr>
<tr><td><code id="mesh.drectangle_+3A_x2">x2</code></td>
<td>
<p>upper right corner of rectangle</p>
</td></tr>
<tr><td><code id="mesh.drectangle_+3A_y2">y2</code></td>
<td>
<p>upper right corner of rectangle</p>
</td></tr>
<tr><td><code id="mesh.drectangle_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length <code>nrow(p)</code> containing the signed distances
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman; translated from original Matlab sources of Per-Olof
Persson.
</p>


<h3>References</h3>

<p><a href="http://persson.berkeley.edu/distmesh/">http://persson.berkeley.edu/distmesh/</a>
</p>
<p><cite>P.-O. Persson, G. Strang, A Simple Mesh Generator in MATLAB. SIAM
Review, Volume 46 (2), pp. 329-345, June 2004</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmesh2d">distmesh2d</a></code>, <code><a href="#topic+mesh.drectangle">mesh.drectangle</a></code>,
<code><a href="#topic+mesh.diff">mesh.diff</a></code>, <code><a href="#topic+mesh.intersect">mesh.intersect</a></code>,
<code><a href="#topic+mesh.union">mesh.union</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(distmesh2d)
</code></pre>

<hr>
<h2 id='mesh.dsphere'>Sphere distance function</h2><span id='topic+mesh.dsphere'></span>

<h3>Description</h3>

<p>Signed distance from points <code>p</code> to boundary of sphere to
allow easy definition of regions in <code><a href="#topic+distmeshnd">distmeshnd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.dsphere(p, radius = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh.dsphere_+3A_p">p</code></td>
<td>
<p>A matrix with 2 columns (3 in <code>mesh.dsphere</code>), each row
representing a point in the plane.</p>
</td></tr>
<tr><td><code id="mesh.dsphere_+3A_radius">radius</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
<tr><td><code id="mesh.dsphere_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>nrow(p)</code> containing the signed
distances to the sphere
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman; translated from original Matlab sources of Per-Olof
Persson.
</p>


<h3>References</h3>

<p><a href="http://persson.berkeley.edu/distmesh/">http://persson.berkeley.edu/distmesh/</a>
</p>
<p><cite>P.-O. Persson, G. Strang, A Simple Mesh Generator in MATLAB. SIAM
Review, Volume 46 (2), pp. 329-345, June 2004</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmeshnd">distmeshnd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example(distmeshnd)
</code></pre>

<hr>
<h2 id='mesh.hunif'>Uniform desired edge length</h2><span id='topic+mesh.hunif'></span>

<h3>Description</h3>

<p>Uniform desired edge length function of position to allow easy
definition of regions when passed as the <code>fh</code> argument of
<code><a href="#topic+distmesh2d">distmesh2d</a></code> or <code><a href="#topic+distmeshnd">distmeshnd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh.hunif(p, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mesh.hunif_+3A_p">p</code></td>
<td>
<p>A <code>n</code>-by-<code>m</code> matrix, each row representing a
point in an <code>m</code>-dimensional space.</p>
</td></tr>
<tr><td><code id="mesh.hunif_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of ones of length <code>n</code>.
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman; translated from original Matlab sources of Per-Olof
Persson.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distmesh2d">distmesh2d</a></code> and <code><a href="#topic+distmeshnd">distmeshnd</a></code>.
</p>

<hr>
<h2 id='pol2cart'>Transform polar or cylindrical coordinates to Cartesian coordinates.</h2><span id='topic+pol2cart'></span>

<h3>Description</h3>

<p>The inputs <code>theta</code>, <code>r</code>, (and <code>z</code>) must be the same shape, or
scalar.  If called with a single matrix argument then each row of <code>P</code>
represents the polar/(cylindrical) coordinate (<code>theta</code>, <code>r</code>
(, <code>z</code>)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pol2cart(theta, r = NULL, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pol2cart_+3A_theta">theta</code></td>
<td>
<p>describes the angle relative to the positive x-axis.</p>
</td></tr>
<tr><td><code id="pol2cart_+3A_r">r</code></td>
<td>
<p>is the distance to the z-axis (0, 0, z).</p>
</td></tr>
<tr><td><code id="pol2cart_+3A_z">z</code></td>
<td>
<p>(optional) is the z-coordinate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix <code>C</code> where each row represents one Cartesian
coordinate (<code>x</code>, <code>y</code> (, <code>z</code>)).
</p>


<h3>Author(s)</h3>

<p>Kai Habel
</p>
<p>David Sterratt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cart2pol">cart2pol</a></code>, <code><a href="#topic+sph2cart">sph2cart</a></code>,
<code><a href="#topic+cart2sph">cart2sph</a></code>
</p>

<hr>
<h2 id='polyarea'>Determines area of a polygon by triangle method.</h2><span id='topic+polyarea'></span>

<h3>Description</h3>

<p>Determines area of a polygon by triangle method.  The variables
<code>x</code> and <code>y</code> define the vertex pairs, and must therefore
have the same shape.  They can be either vectors or arrays.  If
they are arrays then the columns of <code>x</code> and <code>y</code> are
treated separately and an area returned for each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyarea(x, y, d = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polyarea_+3A_x">x</code></td>
<td>
<p>X coordinates of vertices.</p>
</td></tr>
<tr><td><code id="polyarea_+3A_y">y</code></td>
<td>
<p>Y coordinates of vertices.</p>
</td></tr>
<tr><td><code id="polyarea_+3A_d">d</code></td>
<td>
<p>Dimension of array to work along.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the optional <code>dim</code> argument is given, then <code>polyarea</code>
works along this dimension of the arrays <code>x</code> and <code>y</code>.
</p>


<h3>Value</h3>

<p>Area(s) of polygon(s).
</p>


<h3>Author(s)</h3>

<p>David Sterratt based on the octave sources by David M. Doolin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 1, 3, 3, 1)
y &lt;- c(1, 3, 3, 1, 1)
polyarea(x, y)
polyarea(cbind(x, x), cbind(y, y)) ##  c(4, 4)
polyarea(cbind(x, x), cbind(y, y), 1) ##  c(4, 4)
polyarea(rbind(x, x), rbind(y, y), 2) ##  c(4, 4)
</code></pre>

<hr>
<h2 id='rbox'>Generate various point distributions</h2><span id='topic+rbox'></span>

<h3>Description</h3>

<p>Default is corners of a hypercube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbox(n = 3000, D = 3, B = 0.5, C = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbox_+3A_n">n</code></td>
<td>
<p>number of random points in hypercube</p>
</td></tr>
<tr><td><code id="rbox_+3A_d">D</code></td>
<td>
<p>number of dimensions of hypercube</p>
</td></tr>
<tr><td><code id="rbox_+3A_b">B</code></td>
<td>
<p>bounding box coordinate - faces will be <code>-B</code> and <code>B</code> from origin</p>
</td></tr>
<tr><td><code id="rbox_+3A_c">C</code></td>
<td>
<p>add a unit hypercube to the output - faces will be <code>-C</code> and <code>C</code> from origin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of points
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>

<hr>
<h2 id='sph2cart'>Transform spherical coordinates to Cartesian coordinates</h2><span id='topic+sph2cart'></span>

<h3>Description</h3>

<p>The inputs <code>theta</code>, <code>phi</code>, and <code>r</code> must be the same
shape, or scalar.  If called with a single matrix argument then
each row of <code>S</code> represents the spherical coordinate
(<code>theta</code>, <code>phi</code>, <code>r</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph2cart(theta, phi = NULL, r = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sph2cart_+3A_theta">theta</code></td>
<td>
<p>describes the angle relative to the positive x-axis.</p>
</td></tr>
<tr><td><code id="sph2cart_+3A_phi">phi</code></td>
<td>
<p>is the angle relative to the xy-plane.</p>
</td></tr>
<tr><td><code id="sph2cart_+3A_r">r</code></td>
<td>
<p>is the distance to the origin <code>(0, 0, 0)</code>.
</p>
<p>If only a single return argument is requested then return a matrix
<code>C</code> where each row represents one Cartesian coordinate
(<code>x</code>, <code>y</code>, <code>z</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kai Habel
</p>
<p>David Sterratt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cart2sph">cart2sph</a></code>, <code><a href="#topic+pol2cart">pol2cart</a></code>, <code><a href="#topic+cart2pol">cart2pol</a></code>
</p>

<hr>
<h2 id='surf.tri'>Find surface triangles from tetrahedral mesh</h2><span id='topic+surf.tri'></span>

<h3>Description</h3>

<p>Find surface triangles from tetrahedral mesh typically obtained
with <code><a href="#topic+delaunayn">delaunayn</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surf.tri(p, t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surf.tri_+3A_p">p</code></td>
<td>
<p>An <code>n</code>-by-<code>3</code> matrix. The rows of <code>p</code> represent
<code>n</code> points in <code>dim</code>-dimensional space.</p>
</td></tr>
<tr><td><code id="surf.tri_+3A_t">t</code></td>
<td>
<p>Matrix with 4 columns, interpreted as output of
<code><a href="#topic+delaunayn">delaunayn</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>surf.tri</code> and <code><a href="#topic+convhulln">convhulln</a></code> serve a similar purpose in 3D,
but <code>surf.tri</code> also works for non-convex meshes obtained e.g. with
<code><a href="#topic+distmeshnd">distmeshnd</a></code>.  It also does not produce currently unavoidable
diagnostic output on the console as <code>convhulln</code> does at the Rterm
console&ndash;i.e., <code>surf.tri</code> is silent.
</p>


<h3>Value</h3>

<p>An <code>m</code>-by-<code>3</code> index matrix of which each row defines a
triangle. The indices refer to the rows in <code>p</code>.
</p>


<h3>Note</h3>

<p><code>surf.tri</code> was based on Matlab code for mesh of Per-Olof Persson
(<a href="http://persson.berkeley.edu/distmesh/">http://persson.berkeley.edu/distmesh/</a>).
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>See Also</h3>

<p><code><a href="interp.html#topic+tri.mesh">tri.mesh</a></code>, <code><a href="#topic+convhulln">convhulln</a></code>,
<code><a href="#topic+surf.tri">surf.tri</a></code>, <code><a href="#topic+distmesh2d">distmesh2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# more extensive example of surf.tri

# url's of publically available data:
data1.url = "http://neuroimage.usc.edu/USCPhantom/mesh_data.bin"
data2.url = "http://neuroimage.usc.edu/USCPhantom/CT_PCS_trans.bin"

meshdata = R.matlab::readMat(url(data1.url))
elec = R.matlab::readMat(url(data2.url))$eeg.ct2pcs/1000
brain = meshdata$mesh.brain[,c(1,3,2)]
scalp = meshdata$mesh.scalp[,c(1,3,2)]
skull = meshdata$mesh.skull[,c(1,3,2)]
tbr = t(surf.tri(brain, delaunayn(brain)))
tsk = t(surf.tri(skull, delaunayn(skull)))
tsc = t(surf.tri(scalp, delaunayn(scalp)))
rgl::triangles3d(brain[tbr,1], brain[tbr,2], brain[tbr,3],col="gray")
rgl::triangles3d(skull[tsk,1], skull[tsk,2], skull[tsk,3],col="white", alpha=0.3)
rgl::triangles3d(scalp[tsc,1], scalp[tsc,2], scalp[tsc,3],col="#a53900", alpha=0.6)
rgl::view3d(-40,30,.4,zoom=.03)
lx = c(-.025,.025); ly = -c(.02,.02);
rgl::spheres3d(elec[,1],elec[,3],elec[,2],radius=.0025,col='gray')
rgl::spheres3d( lx, ly,.11,radius=.015,col="white")
rgl::spheres3d( lx, ly,.116,radius=.015*.7,col="brown")
rgl::spheres3d( lx, ly,.124,radius=.015*.25,col="black")

## End(Not run)

</code></pre>

<hr>
<h2 id='tetramesh'>Render tetrahedron mesh (3D)</h2><span id='topic+tetramesh'></span>

<h3>Description</h3>

<p><code>tetramesh(T, X, col)</code> uses the <a href="rgl.html#topic+rgl">rgl</a> package to
display the tetrahedrons defined in the m-by-4 matrix T as mesh.
Each row of <code>T</code> specifies a tetrahedron by giving the 4
indices of its points in <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tetramesh(T, X, col = grDevices::heat.colors(nrow(T)), clear = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tetramesh_+3A_t">T</code></td>
<td>
<p>T is a <code>m</code>-by-3 matrix in trimesh and <code>m</code>-by-4 in
tetramesh. A row of <code>T</code> contains indices into <code>X</code> of the vertices
of a triangle/tetrahedron. <code>T</code> is usually the output of delaunayn.</p>
</td></tr>
<tr><td><code id="tetramesh_+3A_x">X</code></td>
<td>
<p>X is an n-by-2/n-by-3 matrix. The rows of X represent <code>n</code>
points in 2D/3D space.</p>
</td></tr>
<tr><td><code id="tetramesh_+3A_col">col</code></td>
<td>
<p>The tetrahedron colour. See rgl documentation for details.</p>
</td></tr>
<tr><td><code id="tetramesh_+3A_clear">clear</code></td>
<td>
<p>Should the current rendering device be cleared?</p>
</td></tr>
<tr><td><code id="tetramesh_+3A_...">...</code></td>
<td>
<p>Parameters to the rendering device. See the <a href="rgl.html#topic+rgl">rgl</a>
package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trimesh">trimesh</a></code>, <code><a href="rgl.html#topic+rgl">rgl</a></code>, <code><a href="#topic+delaunayn">delaunayn</a></code>,
<code><a href="#topic+convhulln">convhulln</a></code>, <code><a href="#topic+surf.tri">surf.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example delaunayn
d = c(-1,1)
pc = as.matrix(rbind(expand.grid(d,d,d),0))
tc = delaunayn(pc)

# example tetramesh
clr = rep(1,3) %o% (1:nrow(tc)+1)
rgl::view3d(60,fov=20)
rgl::light3d(270,60)
tetramesh(tc,pc,alpha=0.7,col=clr)

## End(Not run)
</code></pre>

<hr>
<h2 id='to.mesh3d'>Convert convhulln object to RGL mesh</h2><span id='topic+to.mesh3d'></span>

<h3>Description</h3>

<p>Convert convhulln object to RGL mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.mesh3d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to.mesh3d_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+convhulln">convhulln</a></code> object</p>
</td></tr>
<tr><td><code id="to.mesh3d_+3A_...">...</code></td>
<td>
<p>Arguments to <code><a href="rgl.html#topic+qmesh3d">qmesh3d</a></code> or
<code><a href="rgl.html#topic+tmesh3d">tmesh3d</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="rgl.html#topic+mesh3d">mesh3d</a></code> object, which can be displayed
in RGL with <code><a href="rgl.html#topic+dot3d">dot3d</a></code>, <code><a href="rgl.html#topic+wire3d">wire3d</a></code>
or <code><a href="rgl.html#topic+shade3d">shade3d</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+as.mesh3d">as.mesh3d</a></code>
</p>

<hr>
<h2 id='trimesh'>Display triangles mesh (2D)</h2><span id='topic+trimesh'></span>

<h3>Description</h3>

<p><code>trimesh(T, p)</code> displays the triangles defined in the m-by-3
matrix <code>T</code> and points <code>p</code> as a mesh.  Each row of
<code>T</code> specifies a triangle by giving the 3 indices of its
points in <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimesh(T, p, p2, add = FALSE, axis = FALSE, boxed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimesh_+3A_t">T</code></td>
<td>
<p>T is a <code>m</code>-by-3 matrix. A row of <code>T</code> contains
indices into <code>X</code> of the vertices of a triangle. <code>T</code> is
usually the output of <code><a href="#topic+delaunayn">delaunayn</a></code>.</p>
</td></tr>
<tr><td><code id="trimesh_+3A_p">p</code></td>
<td>
<p>A vector or a matrix.</p>
</td></tr>
<tr><td><code id="trimesh_+3A_p2">p2</code></td>
<td>
<p>if <code>p</code> is not a matrix <code>p</code> and <code>p2</code> are bind to a
matrix with <code>cbind</code>.</p>
</td></tr>
<tr><td><code id="trimesh_+3A_add">add</code></td>
<td>
<p>Add to existing plot in current active device?</p>
</td></tr>
<tr><td><code id="trimesh_+3A_axis">axis</code></td>
<td>
<p>Draw axes?</p>
</td></tr>
<tr><td><code id="trimesh_+3A_boxed">boxed</code></td>
<td>
<p>Plot box?</p>
</td></tr>
<tr><td><code id="trimesh_+3A_...">...</code></td>
<td>
<p>Parameters to the rendering device. See the <a href="rgl.html#topic+rgl">rgl</a>
package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tetramesh">tetramesh</a></code>, <code><a href="rgl.html#topic+rgl">rgl</a></code>,
<code><a href="#topic+delaunayn">delaunayn</a></code>, <code><a href="#topic+convhulln">convhulln</a></code>,
<code><a href="#topic+surf.tri">surf.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example trimesh
p = cbind(x=rnorm(30), y=rnorm(30))
tt = delaunayn(p)
trimesh(tt,p)
</code></pre>

<hr>
<h2 id='tsearch'>Search for the enclosing Delaunay convex hull</h2><span id='topic+tsearch'></span>

<h3>Description</h3>

<p>For <code>t &lt;- delaunay(cbind(x, y))</code>, where <code>(x, y)</code> is a 2D set of
points, <code>tsearch(x, y, t, xi, yi)</code> finds the index in <code>t</code>
containing the points <code>(xi, yi)</code>.  For points outside the convex hull
the index is <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsearch(x, y, t, xi, yi, bary = FALSE, method = "quadtree")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsearch_+3A_x">x</code></td>
<td>
<p>X-coordinates of triangulation points</p>
</td></tr>
<tr><td><code id="tsearch_+3A_y">y</code></td>
<td>
<p>Y-coordinates of triangulation points</p>
</td></tr>
<tr><td><code id="tsearch_+3A_t">t</code></td>
<td>
<p>Triangulation, e.g. produced by <code>t &lt;-
delaunayn(cbind(x, y))</code></p>
</td></tr>
<tr><td><code id="tsearch_+3A_xi">xi</code></td>
<td>
<p>X-coordinates of points to test</p>
</td></tr>
<tr><td><code id="tsearch_+3A_yi">yi</code></td>
<td>
<p>Y-coordinates of points to test</p>
</td></tr>
<tr><td><code id="tsearch_+3A_bary">bary</code></td>
<td>
<p>If <code>TRUE</code> return barycentric coordinates as well
as index of triangle.</p>
</td></tr>
<tr><td><code id="tsearch_+3A_method">method</code></td>
<td>
<p>One of <code>"quadtree"</code> or <code>"orig"</code>. The
Quadtree algorithm is much faster and new from version
0.4.0. The <code>orig</code> option uses the tsearch algorithm adapted
from Octave code. Its use is deprecated and it may be removed
from a future version of the package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>bary</code> is <code>FALSE</code>, the index in <code>t</code> containing the points 
<code>(xi, yi)</code>.  For points outside the convex hull the index is <code>NA</code>. 
If <code>bary</code> is <code>TRUE</code>, a list containing: 
</p>

<dl>
<dt>list(&quot;idx&quot;)</dt><dd><p>the index in <code>t</code> containing the points <code>(xi, yi)</code></p>
</dd>
<dt>list(&quot;p&quot;)</dt><dd><p>a 3-column matrix containing the barycentric coordinates with 
respect to the enclosing triangle of each point <code>(xi, yi)</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The original Octave function is Copyright (C) 2007-2012
David Bateman
</p>


<h3>Author(s)</h3>

<p>Jean-Romain Roussel (Quadtree algorithm), David Sterratt (Octave-based implementation)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsearchn">tsearchn</a></code>, <code><a href="#topic+delaunayn">delaunayn</a></code>
</p>

<hr>
<h2 id='tsearchn'>Search for the enclosing Delaunay convex hull</h2><span id='topic+tsearchn'></span>

<h3>Description</h3>

<p>For <code>t = delaunayn(x)</code>, where <code>x</code> is a set of points in <code class="reqn">N</code>
dimensions, <code>tsearchn(x, t, xi)</code> finds the index in <code>t</code>
containing the points <code>xi</code>. For points outside the convex hull,
<code>idx</code> is <code>NA</code>. <code>tsearchn</code> also returns the barycentric
coordinates <code>p</code> of the enclosing triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsearchn(x, t, xi, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsearchn_+3A_x">x</code></td>
<td>
<p>An <code class="reqn">N</code>-column matrix, in which each row represents a
point in <code class="reqn">N</code>-dimensional space.</p>
</td></tr>
<tr><td><code id="tsearchn_+3A_t">t</code></td>
<td>
<p>A matrix with <code class="reqn">N+1</code> columns. A row of <code>t</code>
contains indices into <code>x</code> of the vertices of an
<code class="reqn">N</code>-dimensional simplex. <code>t</code> is usually the output of
delaunayn.</p>
</td></tr>
<tr><td><code id="tsearchn_+3A_xi">xi</code></td>
<td>
<p>An <code class="reqn">M</code>-by-<code class="reqn">N</code> matrix. The rows of <code>xi</code>
represent <code class="reqn">M</code> points in <code class="reqn">N</code>-dimensional space whose
positions in the mesh are being sought.</p>
</td></tr>
<tr><td><code id="tsearchn_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is <code>NA</code> and the <code>t</code> is a
<code>delaunayn</code> object produced by
<code><a href="#topic+delaunayn">delaunayn</a></code> with the <code>full</code> option, then use the
Qhull library to perform the search. Please note that this is
experimental in geometry version 0.4.0 and is only partly tested
for 3D hulls, and does not yet work for hulls of 4 dimensions and
above.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt><code>idx</code></dt><dd><p>An <code class="reqn">M</code>-long vector containing the indices
of the row of <code>t</code> in which each point in <code>xi</code> is found.</p>
</dd>
<dt><code>p</code></dt><dd><p>An <code class="reqn">M</code>-by-<code class="reqn">N+1</code> matrix containing the
barycentric coordinates with respect to the enclosing simplex
of each point in <code>xi</code>.</p>
</dd></dl>



<h3>Note</h3>

<p>Based on the Octave function Copyright (C) 2007-2012 David
Bateman.
</p>


<h3>Author(s)</h3>

<p>David Sterratt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsearch">tsearch</a></code>, <code><a href="#topic+delaunayn">delaunayn</a></code>
</p>

<hr>
<h2 id='Unique'>Extract Unique Rows</h2><span id='topic+Unique'></span>

<h3>Description</h3>

<p>&lsquo;Unique&rsquo; returns a vector, data frame or array like 'x' but with
duplicate elements removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Unique(X, rows.are.sets = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Unique_+3A_x">X</code></td>
<td>
<p>Numerical matrix.</p>
</td></tr>
<tr><td><code id="Unique_+3A_rows.are.sets">rows.are.sets</code></td>
<td>
<p>If &lsquo;<code>TRUE</code>&rsquo;, rows are treated as sets -
i.e., to define uniqueness, the order of the rows does not matter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the same number of columns as <code>x</code>, with the unique
rows in <code>x</code> sorted according to the columns of <code>x</code>. If
<code>rows.are.sets = TRUE</code> the rows are also sorted.
</p>


<h3>Note</h3>

<p>&lsquo;<code>Unique</code>&rsquo; is (under circumstances) much quicker than the
more generic base function &lsquo;<code>unique</code>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# `Unique' is faster than `unique'
x = matrix(sample(1:(4*8),4*8),ncol=4)
y = x[sample(1:nrow(x),3000,TRUE), ]
gc(); system.time(unique(y))
gc(); system.time(Unique(y))

#
z = Unique(y)
x[matorder(x),]
z[matorder(z),]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
