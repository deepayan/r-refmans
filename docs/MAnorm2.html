<!DOCTYPE html><html lang="en"><head><title>Help for package MAnorm2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MAnorm2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aovBioCond'><p>Perform a Moderated Analysis of Variance on <code>bioCond</code> Objects</p></a></li>
<li><a href='#bioCond'><p>Create a <code>bioCond</code> Object to Group ChIP-seq Samples</p></a></li>
<li><a href='#checkCountTable'><p>Check the Regularity of a Count Table</p></a></li>
<li><a href='#checkIndex'><p>Check the Validity of an Index Vector</p></a></li>
<li><a href='#cmbBioCond'><p>Combine a Set of <code>bioCond</code> Objects into a Single <code>bioCond</code></p></a></li>
<li><a href='#diffTest'><p>Generic Differential Test</p></a></li>
<li><a href='#distBioCond'><p>Quantify the Distance between Each Pair of Samples in a <code>bioCond</code></p></a></li>
<li><a href='#estimateD0'><p>Workhorse Function for Estimating Number of Prior Degrees of Freedom</p></a></li>
<li><a href='#estimateD0Robust'><p>Estimate Number of Prior Degrees of Freedom in a Robust Manner</p></a></li>
<li><a href='#estimatePriorDf'><p>Assess the Goodness of Fit of Mean-Variance Curves</p></a></li>
<li><a href='#estimatePriorDfRobust'><p>Assess the Goodness of Fit of Mean-Variance Curves in a Robust Manner</p></a></li>
<li><a href='#estimateSizeFactors'><p>Estimate Size Factors of ChIP-seq Samples</p></a></li>
<li><a href='#estimateVarRatio'><p>Estimate Relative Variance Ratio Factors of <code>bioCond</code> Objects</p></a></li>
<li><a href='#estParamHyperChIP'><p>The Parameter Estimation Framework of HyperChIP</p></a></li>
<li><a href='#extendMeanVarCurve'><p>Extend the Application Scope of a Mean-Variance Curve</p></a></li>
<li><a href='#fitMeanVarCurve'><p>Fit a Mean-Variance Curve</p></a></li>
<li><a href='#H3K27Ac'><p>ChIP-seq Samples for H3K27Ac in Human Lymphoblastoid Cell Lines</p></a></li>
<li><a href='#intervalMeans'><p>Deduce the Sample Mean Signal Intensity</p></a></li>
<li><a href='#intervalVars'><p>Sample Variance of Replicated Signal Intensities</p></a></li>
<li><a href='#inv.trigamma'><p>Inversion of Trigamma Function</p></a></li>
<li><a href='#isSymPosDef'><p>Is a Real Matrix Symmetric and Positive Definite?</p></a></li>
<li><a href='#MA.pcc'><p>Deduce Pearson Correlation Coefficient between M &amp; A Values</p></a></li>
<li><a href='#MAnorm2'><p>MAnorm2: a Package for Normalizing and Comparing ChIP-seq Samples</p></a></li>
<li><a href='#MAplot'><p>Generic MA Plotting</p></a></li>
<li><a href='#MAplot.bioCond'><p>Create an MA Plot on Two <code>bioCond</code> Objects</p></a></li>
<li><a href='#MAplot.diffBioCond'><p>Create an MA Plot on Results of Comparing Two <code>bioCond</code> Objects</p></a></li>
<li><a href='#mean_var_logwinf'><p>Expectation and Variance of Log Winsorized <em>F</em> Distribution</p></a></li>
<li><a href='#meanVarLocalFit'><p>Fit Mean-Variance Trend by Local Regression</p></a></li>
<li><a href='#meanVarParaFit'><p>Parametrically Fit a Mean-Variance Curve</p></a></li>
<li><a href='#mvcID.new'><p>Create a New Unique ID for a Mean-Variance Curve</p></a></li>
<li><a href='#normalize'><p>Perform MA Normalization on a Set of ChIP-seq Samples</p></a></li>
<li><a href='#normalizeBySizeFactors'><p>Normalize ChIP-seq Samples by Their Size Factors</p></a></li>
<li><a href='#normBioCond'><p>Perform MA Normalization on a Set of <code>bioCond</code> Objects</p></a></li>
<li><a href='#normBioCondBySizeFactors'><p>Normalize <code>bioCond</code> Objects by Their Size Factors</p></a></li>
<li><a href='#normCoef'><p>Deduce MA Normalization Coefficients</p></a></li>
<li><a href='#plot.aovBioCond'><p>Plot an <code>aovBioCond</code> Object</p></a></li>
<li><a href='#plot.matrix'><p>Visualize a Matrix of Numeric Values</p></a></li>
<li><a href='#plot.varTestBioCond'><p>Plot a <code>varTestBioCond</code> Object</p></a></li>
<li><a href='#plotMeanVarCurve'><p>Plot a Mean-Variance Curve</p></a></li>
<li><a href='#plotMVC'><p>Plot a Mean-Variance Curve on a Single <code>bioCond</code> Object</p></a></li>
<li><a href='#print.bioCond'><p>Print a <code>bioCond</code> Object</p></a></li>
<li><a href='#print.summaryBioCond'><p>Print a <code>summaryBioCond</code> Object</p></a></li>
<li><a href='#scaleMeanVarCurve'><p>Scale a Mean-Variance Curve</p></a></li>
<li><a href='#scaleMeanVarCurveRobust'><p>Scale a Mean-Variance Curve in a Robust Manner</p></a></li>
<li><a href='#setMeanVarCurve'><p>Set the Mean-Variance Curve of a Set of <code>bioCond</code> Objects</p></a></li>
<li><a href='#setPriorDf'><p>Set the Number of Prior Degrees of Freedom of Mean-Variance Curves</p></a></li>
<li><a href='#setPriorDfRobust'><p>The Robust Counterpart of <code>setPriorDf</code></p></a></li>
<li><a href='#setPriorDfVarRatio'><p>Set the Number of Prior Degrees of Freedom and Variance Ratio Factors</p></a></li>
<li><a href='#setWeight'><p>Set the Weights of Signal Intensities Contained in a <code>bioCond</code></p></a></li>
<li><a href='#summary.bioCond'><p>Summarize a <code>bioCond</code> Object</p></a></li>
<li><a href='#util.trigamma'><p>Utility Trigamma Function</p></a></li>
<li><a href='#varRatio'><p>Compare Variance Ratio Factors of Two <code>bioCond</code> Objects</p></a></li>
<li><a href='#varTestBioCond'><p>Call Hypervariable and Invariant Intervals for a <code>bioCond</code></p></a></li>
<li><a href='#vstBioCond'><p>Apply a Variance-Stabilizing Transformation to a <code>bioCond</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Normalizing and Comparing ChIP-seq Samples</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Chromatin immunoprecipitation followed by high-throughput
    sequencing (ChIP-seq) is the premier technology for profiling genome-wide
    localization of chromatin-binding proteins, including transcription
    factors and histones with various modifications.
    This package provides a robust method for normalizing ChIP-seq
    signals across individual samples or groups of samples. It also designs
    a self-contained system of statistical models for calling differential
    ChIP-seq signals between two or more biological conditions as well as
    for calling hypervariable ChIP-seq signals across samples. Refer to
    Tu et al. (2021) &lt;<a href="https://doi.org/10.1101%2Fgr.262675.120">doi:10.1101/gr.262675.120</a>&gt; and
    Chen et al. (2022) &lt;<a href="https://doi.org/10.1186%2Fs13059-022-02627-9">doi:10.1186/s13059-022-02627-9</a>&gt;
    for associated statistical details.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tushiqi/MAnorm2">https://github.com/tushiqi/MAnorm2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tushiqi/MAnorm2/issues">https://github.com/tushiqi/MAnorm2/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, methods, locfit (&ge; 1.5.9), scales (&ge;
0.3.0), statmod (&ge; 1.4.34)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gplots (&ge; 3.0.1), DescTools (&ge; 0.99.24), knitr, rmarkdown</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-28</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-28 08:17:07 UTC; Administrator</td>
</tr>
<tr>
<td>Author:</td>
<td>Shiqi Tu <a href="https://orcid.org/0000-0003-3534-5714"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shiqi Tu &lt;tushiqi@picb.ac.cn&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-28 09:30:39 UTC</td>
</tr>
</table>
<hr>
<h2 id='aovBioCond'>Perform a Moderated Analysis of Variance on <code>bioCond</code> Objects</h2><span id='topic+aovBioCond'></span>

<h3>Description</h3>

<p>Given a set of <code><a href="#topic+bioCond">bioCond</a></code> objects with which a mean-variance
curve is associated, <code>aovBioCond</code> performs a one-way ANOVA-like
analysis on them. More specifically, it separately tests for each genomic
interval the null hypothesis that mean signal intensity in the interval
remains invariant across all the biological conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aovBioCond(conds, min.var = 0, df.prior = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aovBioCond_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects on which the analysis
of variance is to be performed. They must be associated with the same
mean-variance curve (i.e., they must have the same <code>"mvcID"</code>; see
also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="aovBioCond_+3A_min.var">min.var</code></td>
<td>
<p>Lower bound of variances read from the mean-variance
curve. Any variance read from the curve less than <code>min.var</code> will be
adjusted to this value. It's primarily used for safely getting the prior
variances and taking into account the practical significance of a signal
variation.</p>
</td></tr>
<tr><td><code id="aovBioCond_+3A_df.prior">df.prior</code></td>
<td>
<p>Number of prior degrees of freedom associated with the
mean-variance curve. Must be non-negative.
Can be set to <code>Inf</code> (see &quot;Details&quot;).
By default, <code>aovBioCond</code> checks if all the <code>bioCond</code>s in
<code>conds</code> have the same <code>"df.prior"</code> component, and uses it as
the number of prior degrees of freedom if yes (an error is raised
otherwise).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>aovBioCond</code> adopts the modeling strategy implemented in <code>limma</code>
(see &quot;References&quot;), except that each interval has its own prior variance,
which is read from the mean-variance curve associated with the
<code><a href="#topic+bioCond">bioCond</a></code> objects. Technically, this function calculates a
moderated <em>F</em> statistic for each genomic interval to test the null
hypothesis. The moderated <em>F</em> statistic is simply the <em>F</em>
statistic from an ordinary one-way
ANOVA with its denominator (i.e., sample variance) replaced
by posterior variance, which is defined to be a weighted average of sample
and prior variances, with the weights being proportional to their respective
numbers of degrees of freedom.
This method of incorporating the prior information
increases the statistical power for the tests.
</p>
<p>Two extreme values can be specified for the argument <code>df.prior</code>
(number of degrees of freedom associated with the prior variances),
representing two distinct
cases: when it's set to <code>0</code>, the prior information won't be used at
all, and the tests reduce to ordinary F tests in one-way ANOVA; when it's
set to <code>Inf</code>, the denominators of moderated F statistics are simply the
prior variances, and these F statistics reduce to following a scaled
chi-squared distribution. Other values of <code>df.prior</code> represent
intermediate cases. To be noted, the number of prior degrees of freedom is
automatically estimated for each
mean-variance curve by a specifically designed statistical method
(see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> and
<code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code>) and, by default, <code>aovBioCond</code> uses the
estimation result to perform the tests. It's highly not recommended
to specify <code>df.prior</code> explicitly when calling <code>aovBioCond</code>, unless
you know what you are really doing. Besides, <code>aovBioCond</code> won't adjust
variance ratio factors of the provided <code>bioCond</code>s based on the
specified number of prior degrees of freedom (see
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for a description of variance ratio factor).
</p>
<p>Note also that, if <code>df.prior</code> is set to <code>0</code>, of the
<code>bioCond</code> objects in <code>conds</code> there must be at least one that
contains two or more ChIP-seq
samples. Otherwise, there is no way to measure the variance associated with
each interval, and an error is raised.
</p>
<p>Considering the practical significance of this analysis, which is to select
genomic intervals with differential ChIP-seq signals between at least one
pair of the biological conditions, those intervals not occupied by any of
the <code>bioCond</code>
objects in <code>conds</code> may be filtered out before making the selections.
Thus, the statistical power of the tests could potentially be improved by
re-adjusting <em>p</em>-values of the remaining intervals.
</p>


<h3>Value</h3>

<p><code>aovBioCond</code> returns an object of <code><a href="base.html#topic+class">class</a></code>
<code>c("aovBioCond", "data.frame")</code>, recording the test results for
each genomic interval by each row. The data frame consists of the
following variables:
</p>

<dl>
<dt><code>conds.mean</code></dt><dd><p>Mean signal intensity at the interval
across biological conditions.</p>
</dd>
<dt><code>between.ms</code></dt><dd><p>Between-condition mean of squares as from
an ordinary one-way ANOVA.</p>
</dd>
<dt><code>within.ms</code></dt><dd><p>Within-condition mean of squares as from
an ordinary one-way ANOVA.</p>
</dd>
<dt><code>prior.var</code></dt><dd><p>Prior variance deduced by reading from the
mean-variance curve associated with the <code><a href="#topic+bioCond">bioCond</a></code>
objects in <code>conds</code>.</p>
</dd>
<dt><code>posterior.var</code></dt><dd><p>A weighted average of <code>within.ms</code>
and <code>prior.var</code>, with the weights being proportional to their
respective numbers of degrees of freedom.</p>
</dd>
<dt><code>mod.f</code></dt><dd><p>Moderated <em>F</em> statistic, which is the ratio
of <code>between.ms</code> to <code>posterior.var</code>.</p>
</dd>
<dt><code>pval</code></dt><dd><p><em>P</em>-value for the statistical significance
of this moderated F statistic.</p>
</dd>
<dt><code>padj</code></dt><dd><p><em>P</em>-value adjusted for multiple testing with
the <code>"BH"</code> method (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>), which
controls false discovery rate.</p>
</dd>
</dl>

<p>Row names of the returned data frame inherit from those of
<code>conds[[1]]$norm.signal</code>. Besides, several attributes are added to
the returned object:
</p>

<dl>
<dt><code>bioCond.names</code></dt><dd><p>Names of the <code>bioCond</code> objects in
<code>conds</code>.</p>
</dd>
<dt><code>mean.var.curve</code></dt><dd><p>A function representing the
mean-variance curve. It accepts a vector of mean signal intensities
and returns the corresponding prior variances. Note that this
function has incorporated the <code>min.var</code> argument.</p>
</dd>
<dt><code>df</code></dt><dd><p>A length-4 vector giving the numbers of degrees of
freedom of <code>between.ms</code>, <code>within.ms</code>, <code>prior.var</code> and
<code>posterior.var</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Smyth, G.K., <em>Linear models and empirical bayes methods for
assessing differential expression in microarray experiments.</em> Stat Appl
Genet Mol Biol, 2004. <strong>3</strong>: p. Article3.
</p>
<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing groups of
ChIP-seq samples.</em> Genome Res, 2021. <strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve for
a set of <code>bioCond</code> objects; <code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code> for
setting the mean-variance curve of a set of <code>bioCond</code>s;
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for estimating number of prior degrees of
freedom as well as adjusting variance ratio factors accordingly.
</p>
<p><code><a href="#topic+plot.aovBioCond">plot.aovBioCond</a></code> for creating a plot to demonstrate an
<code>aovBioCond</code> object; <code><a href="#topic+diffTest.bioCond">diffTest</a></code> for
calling differential intervals between two <code>bioCond</code> objects;
<code><a href="#topic+varTestBioCond">varTestBioCond</a></code> for calling hypervariable and invariant
intervals across ChIP-seq samples contained in a <code>bioCond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Call differential genomic intervals among GM12890, GM12891 and GM12892
## cell lines.

# Perform MA normalization and construct bioConds to represent the cell
# lines.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Variations in ChIP-seq signals across biological replicates of a cell line
# are generally of a low level, and their relationship with the mean signal
# intensities is expected to be well modeled by the presumed parametric
# form.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
summary(conds[[1]])
plotMeanVarCurve(conds, subset = "occupied")

# Perform a moderated ANOVA on these cell lines.
res &lt;- aovBioCond(conds)
head(res)
plot(res, padj = 1e-6)

</code></pre>

<hr>
<h2 id='bioCond'>Create a <code>bioCond</code> Object to Group ChIP-seq Samples</h2><span id='topic+bioCond'></span>

<h3>Description</h3>

<p><code>bioCond</code> creates an object which represents a biological condition,
given a set of ChIP-seq samples belonging to the condition. Such objects,
once created, can be supplied to <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> to fit the
mean-variance trend, and subsequently to
<code><a href="#topic+diffTest.bioCond">diffTest</a></code> for calling differential
ChIP-seq signals between two conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bioCond(
  norm.signal,
  occupancy = NULL,
  occupy.num = 1,
  name = "NA",
  weight = NULL,
  strMatrix = NULL,
  meta.info = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bioCond_+3A_norm.signal">norm.signal</code></td>
<td>
<p>A matrix or data frame of normalized signal intensities,
where each row should represent a genomic interval and each column a
sample.</p>
</td></tr>
<tr><td><code id="bioCond_+3A_occupancy">occupancy</code></td>
<td>
<p>A matrix or data frame of logical values with the same
dimension as of <code>norm.signal</code>, marking the occupancy status of each
interval in each sample. This argument is only used to derive the
occupancy status of each interval in the biological condition.
By default, each interval is
considered to be occupied by each sample.</p>
</td></tr>
<tr><td><code id="bioCond_+3A_occupy.num">occupy.num</code></td>
<td>
<p>For each interval, the minimum number of samples occupying
it required for the interval to be considered as occupied by the
biological condition (see also &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="bioCond_+3A_name">name</code></td>
<td>
<p>A character scalar specifying the name of the biological
condition. Used only for demonstration.</p>
</td></tr>
<tr><td><code id="bioCond_+3A_weight">weight</code></td>
<td>
<p>A matrix or data frame specifying the relative precisions of
signal intensities in <code>norm.signal</code>. Must have the same number of
columns as <code>norm.signal</code>. A vector is interpreted as a matrix
having a single row. Note that rows of <code>weight</code> are recycled if
necessary. By default, the same weight is assigned to each measurement
in <code>norm.signal</code>.</p>
</td></tr>
<tr><td><code id="bioCond_+3A_strmatrix">strMatrix</code></td>
<td>
<p>An optional list of symmetric matrices specifying directly
the structure matrix of each genomic interval. Elements of it are
recycled if necessary.
This argument, if set, overrides the <code>weight</code>
argument. See &quot;Details&quot; and <code><a href="#topic+setWeight">setWeight</a></code> for information
about structure matrix.</p>
</td></tr>
<tr><td><code id="bioCond_+3A_meta.info">meta.info</code></td>
<td>
<p>Optional extra information (e.g., genomic coordinates
of intervals). If set, the supplied argument is stored in the
<code>meta.info</code> field of returned <code>bioCond</code>, and shall never be
used by other tools in <code>MAnorm2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To call this function, one typically needs to first perform an MA
normalization on raw read counts of ChIP-seq samples by using
<code><a href="#topic+normalize">normalize</a></code>.
</p>
<p>The function will assign an indicator to each genomic interval (stored in
the <code>occupancy</code> field of the returned object; see also &quot;Value&quot;),
marking if the interval is occupied by this biological condition.
The argument <code>occupy.num</code> controls the minimum number of samples that
occupy an interval required for the interval to be determined as occupied by
the condition. Notably, the occupancy states of genomic intervals may matter
when fitting a mean-variance curve, as one may choose to use only the
occupied intervals to fit the curve (see also
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).
</p>
<p>For signal intensities of each genomic interval, <code>weight</code> specifies
their relative precisions corresponding to different ChIP-seq samples in
<code>norm.signal</code>. Intrinsically, the weights will be used to construct the
structure matrices of the created <code>bioCond</code>. Alternatively, one
can specify <code>strMatrix</code> directly when calling the function. To be
noted, MAnorm2 uses a structure matrix to model the relative variances of
signal intensities of a genomic interval as well as the correlations among
them, by considering them to be associated with a covariance matrix
proportional to the structure matrix. See <code><a href="#topic+setWeight">setWeight</a></code> for
a detailed description of structure matrix.
</p>


<h3>Value</h3>

<p><code>bioCond</code> returns an object of <code><a href="base.html#topic+class">class</a></code>
<code>"bioCond"</code>, representing the biological condition to which the
supplied ChIP-seq samples belong.
</p>
<p>In detail, an object of class <code>"bioCond"</code> is a list containing at
least the following fields:
</p>

<dl>
<dt><code>name</code></dt><dd><p>Name of the biological condition.</p>
</dd>
<dt><code>norm.signal</code></dt><dd><p>A matrix of normalized signal
intensities of ChIP-seq samples belonging to the condition.</p>
</dd>
<dt><code>occupancy</code></dt><dd><p>A logical vector marking the occupancy
status of each genomic interval.</p>
</dd>
<dt><code>meta.info</code></dt><dd><p>The <code>meta.info</code> argument (only present
when it is supplied).</p>
</dd>
<dt><code>strMatrix</code></dt><dd><p>Structure matrices associated with the
genomic intervals.</p>
</dd>
<dt><code>sample.mean</code></dt><dd><p>A vector of observed mean signal
intensities of genomic intervals.</p>
</dd>
<dt><code>sample.var</code></dt><dd><p>A vector recording the observed variance of
signal intensities of each genomic interval.</p>
</dd>
</dl>

<p>Note that the <code>sample.mean</code> and <code>sample.var</code> fields
are calculated by applying the
GLS (generalized least squares) estimation to the signal intensities of
each genomic interval, considering them as having
a common mean and a covariance matrix proportional to the corresponding
structure matrix. Specifically, the <code>sample.var</code> field times the
corresponding structure matrices gives an unbiased estimate of the
covariance matrix associated with each interval (see
<code><a href="#topic+setWeight">setWeight</a></code> for details).
</p>
<p>Besides, a <code>fit.info</code> field will be added to <code>bioCond</code> objects
once you have fitted a mean-variance curve for them (see
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for details).
</p>
<p>There are also other fields used internally for fitting the
mean-variance trend and calling differential intervals between
conditions. These fields should never be modified directly.
</p>


<h3>Warning</h3>

<p>Among all the fields contained in a <code>bioCond</code> object,
only <code>name</code> and <code>meta.info</code> are subject to free modifications;
The <code>strMatrix</code> field must be modified through
<code><a href="#topic+setWeight">setWeight</a></code>.
</p>


<h3>References</h3>

<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing
groups of ChIP-seq samples.</em> Genome Res, 2021.
<strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code> for performing an MA normalization on
ChIP-seq samples; <code><a href="#topic+normalizeBySizeFactors">normalizeBySizeFactors</a></code> for normalizing
ChIP-seq samples based on their size factors; <code><a href="#topic+setWeight">setWeight</a></code>
for modifying the structure matrices of a <code>bioCond</code> object.
</p>
<p><code><a href="#topic+normBioCond">normBioCond</a></code> for performing an MA normalization on
<code>bioCond</code> objects; <code><a href="#topic+normBioCondBySizeFactors">normBioCondBySizeFactors</a></code> for
normalizing <code>bioCond</code> objects based on their size factors;
<code><a href="#topic+cmbBioCond">cmbBioCond</a></code> for combining a set of <code>bioCond</code>
objects into a single one; <code><a href="#topic+MAplot.bioCond">MAplot.bioCond</a></code> for creating
an MA plot on two <code>bioCond</code> objects; <code><a href="#topic+summary.bioCond">summary.bioCond</a></code>
for summarizing a <code>bioCond</code>.
</p>
<p><code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for modeling
the mean-variance dependence across intervals in <code>bioCond</code> objects;
<code><a href="#topic+diffTest.bioCond">diffTest</a></code> for comparing two
<code>bioCond</code> objects; <code><a href="#topic+aovBioCond">aovBioCond</a></code> for comparing multiple
<code>bioCond</code> objects; <code><a href="#topic+varTestBioCond">varTestBioCond</a></code> for calling
hypervariable and invariant intervals across ChIP-seq samples contained
in a <code>bioCond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Construct a bioCond object for the GM12891 cell line.

# Apply MA normalization to the ChIP-seq samples of GM12891.
norm &lt;- normalize(H3K27Ac, 5:6, 10:11)

# Call the constructor and optionally attach some meta information to the
# resulting bioCond, such as the coordinates of genomic intervals.
GM12891 &lt;- bioCond(norm[5:6], norm[10:11], name = "GM12891",
                   meta.info = norm[1:3])

# Alternatively, you may assign different weights to the replicate samples
# for estimating the mean signal intensities of genomic intervals in this
# cell line. Here the weight of the 2nd replicate is reduced to half the
# weight of the 1st one.
GM12891_2 &lt;- bioCond(norm[5:6], norm[10:11], name = "GM12891",
                     weight = c(1, 0.5))

# Equivalently, you can achieve the same effect by setting the strMatrix
# parameter.
GM12891_3 &lt;- bioCond(norm[5:6], norm[10:11], name = "GM12891",
                     strMatrix = list(diag(c(1, 2))))

</code></pre>

<hr>
<h2 id='checkCountTable'>Check the Regularity of a Count Table</h2><span id='topic+checkCountTable'></span>

<h3>Description</h3>

<p>Check the Regularity of a Count Table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCountTable(counts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkCountTable_+3A_counts">counts</code></td>
<td>
<p>A matrix consisting of read counts. Objects of other
types are coerced to a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function raises an error once the regularity check process
fails. It returns <code>NULL</code> otherwise.
</p>

<hr>
<h2 id='checkIndex'>Check the Validity of an Index Vector</h2><span id='topic+checkIndex'></span>

<h3>Description</h3>

<p>Check the Validity of an Index Vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIndex(index, ns, var.name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkIndex_+3A_index">index</code></td>
<td>
<p>An index vector for subsetting columns of a data frame.</p>
</td></tr>
<tr><td><code id="checkIndex_+3A_ns">ns</code></td>
<td>
<p>A character vector of variable names in the data frame.</p>
</td></tr>
<tr><td><code id="checkIndex_+3A_var.name">var.name</code></td>
<td>
<p>The index variable name. Simply used to generate potential
error messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The regularized index vector if it's valid. Otherwise, an error is
raised.
</p>

<hr>
<h2 id='cmbBioCond'>Combine a Set of <code>bioCond</code> Objects into a Single <code>bioCond</code></h2><span id='topic+cmbBioCond'></span>

<h3>Description</h3>

<p>Given a list of <code><a href="#topic+bioCond">bioCond</a></code> objects, <code>cmbBioCond</code> combines
them into a single <code>bioCond</code>, by treating each <code>bioCond</code> as an
individual ChIP-seq sample. This function is primarily used to handle
ChIP-seq samples associated with a hierarchical structure (see &quot;Details&quot;
for an example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmbBioCond(
  conds,
  occupy.num = 1,
  name = "NA",
  weight = NULL,
  strMatrix = NULL,
  meta.info = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cmbBioCond_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects to be combined.</p>
</td></tr>
<tr><td><code id="cmbBioCond_+3A_occupy.num">occupy.num</code></td>
<td>
<p>For each interval, the minimum number of <code>bioCond</code>s
occupying it required for the interval to be considered as occupied by
the newly constructed <code>bioCond</code>.</p>
</td></tr>
<tr><td><code id="cmbBioCond_+3A_name">name</code></td>
<td>
<p>Name of the constructed biological condition, used only for
demonstrating a <code>bioCond</code> object.</p>
</td></tr>
<tr><td><code id="cmbBioCond_+3A_weight">weight</code></td>
<td>
<p>A matrix or data frame specifying the relative precisions of
signal intensities of the constructed <code>bioCond</code>. Must have the same
number of columns as the number of <code>bioCond</code>s in <code>conds</code>. A
vector is interpreted as a matrix having a single row. Note that rows
of <code>weight</code> are recycled if necessary. By default, the same weight
is assigned to each measurement in the constructed <code>bioCond</code>.</p>
</td></tr>
<tr><td><code id="cmbBioCond_+3A_strmatrix">strMatrix</code></td>
<td>
<p>An optional list of symmetric matrices specifying directly
the structure matrix of each genomic interval in the constructed
<code>bioCond</code>. Elements of it are recycled if necessary. This argument,
if set, overrides the <code>weight</code> argument. See <code><a href="#topic+bioCond">bioCond</a></code>
and <code><a href="#topic+setWeight">setWeight</a></code> for a detailed description of structure
matrix.</p>
</td></tr>
<tr><td><code id="cmbBioCond_+3A_meta.info">meta.info</code></td>
<td>
<p>Optional extra information about the <code>bioCond</code> to be
created. If set, the supplied argument is stored in the <code>meta.info</code>
field of returned <code>bioCond</code>, and shall never be used by other tools
in <code>MAnorm2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technically, <code>cmbBioCond</code> treats each <code><a href="#topic+bioCond">bioCond</a></code> object in
<code>conds</code> as a ChIP-seq sample, taking the <code>sample.mean</code> and
<code>occupancy</code> fields stored in each <code>bioCond</code> to represent its
signal intensities and occupancy indicators, respectively. Then, by grouping
these &quot;samples&quot;, a new <code>bioCond</code> object is constructed following the
exact routine as described in <code><a href="#topic+bioCond">bioCond</a></code>. See
<code><a href="#topic+bioCond">bioCond</a></code> also for a description of the structure of a
<code>bioCond</code> object.
</p>
<p>Notably, ChIP-seq samples contained in these <code>bioCond</code> objects to be
combined are supposed to have been normalized to the same level, so that
these <code>bioCond</code>s are comparable to each other. For this purpose, you
may choose to normalize the ChIP-seq samples involved all together via
<code><a href="#topic+normalize">normalize</a></code>, or to normalize the <code>bioCond</code> objects to be
combined via <code><a href="#topic+normBioCond">normBioCond</a></code>.
</p>
<p><code>cmbBioCond</code> is primarily used to deal with ChIP-seq samples sorted
into a hierarchical structure. For example, suppose ChIP-seq samples are
available for multiple male and female individuals, where each individual
is associated with several replicates. To call differential ChIP-seq signals
between males and females, two <code>bioCond</code> objects representing these two
conditions need to be created. One way to do that is to select one ChIP-seq
sample as representative for each individual, and group male and female
samples, respectively. Alternatively, to leverage all available ChIP-seq
samples, a <code>bioCond</code> object could be constructed for each individual,
consisting of the samples of him (her). Then, the <code>bioCond</code>s of
male and female can be separately created by grouping the corresponding
individuals. See also &quot;Examples&quot; below.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+bioCond">bioCond</a></code> object, created by combining all the
supplied <code>bioCond</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object from a
set of ChIP-seq samples; <code><a href="#topic+normalize">normalize</a></code> for performing an MA
normalization on ChIP-seq samples; <code><a href="#topic+normBioCond">normBioCond</a></code> for
normalizing a set of <code>bioCond</code>s; <code><a href="#topic+setWeight">setWeight</a></code> for
modifying the structure matrices of a <code>bioCond</code> object.
</p>
<p><code><a href="#topic+MAplot.bioCond">MAplot.bioCond</a></code> for creating an MA plot on two
<code>bioCond</code> objects; <code><a href="#topic+summary.bioCond">summary.bioCond</a></code> for
summarizing a <code>bioCond</code>.
</p>
<p><code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for modeling
the mean-variance dependence across intervals in <code>bioCond</code> objects;
<code><a href="#topic+diffTest.bioCond">diffTest</a></code> for comparing two
<code>bioCond</code> objects; <code><a href="#topic+aovBioCond">aovBioCond</a></code> for comparing multiple
<code>bioCond</code> objects; <code><a href="#topic+varTestBioCond">varTestBioCond</a></code> for calling
hypervariable and invariant intervals across ChIP-seq samples contained
in a <code>bioCond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Construct two bioConds comprised of the male and female individuals,
## respectively.

# First, normalize ChIP-seq samples separately for each individual (i.e.,
# cell line).
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)

# Then, construct separately a bioCond for each individual, and perform MA
# normalization on the resulting bioConds. Genomic intervals in sex
# chromosomes are not allowed to be common peak regions, since the
# individuals are of different genders.
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Finally, group individuals into bioConds based on their genders.
female &lt;- cmbBioCond(conds[c(1, 3)], name = "female")
male &lt;- cmbBioCond(conds[2], name = "male")
summary(female)
summary(male)

</code></pre>

<hr>
<h2 id='diffTest'>Generic Differential Test</h2><span id='topic+diffTest'></span><span id='topic+diffTest.bioCond'></span>

<h3>Description</h3>

<p><code>diffTest</code> is a generic function used to perform a differential test
(or multiple differential tests) between two R objects, usually of the same
type. Described in this page is the method designed for comparing two
<code><a href="#topic+bioCond">bioCond</a></code> objects. This method is typically used to call genomic
intervals with differentially represented ChIP-seq signals between two
biological conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffTest(x, y, ...)

## S3 method for class 'bioCond'
diffTest(x, y, min.var = 0, df.prior = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffTest_+3A_x">x</code>, <code id="diffTest_+3A_y">y</code></td>
<td>
<p><code>x</code> is any R object for which a <code>diffTest</code> method has
been defined. For the method for class <code>"<a href="#topic+bioCond">bioCond</a>"</code>, <code>x</code>
and <code>y</code> are two <code>bioCond</code> objects to be compared. They must be
associated with the same mean-variance curve (i.e., they must have the
same <code>"mvcID"</code>; see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="diffTest_+3A_...">...</code></td>
<td>
<p>Arguments passed to specific methods or from other methods.</p>
</td></tr>
<tr><td><code id="diffTest_+3A_min.var">min.var</code></td>
<td>
<p>Lower bound of variances read from the mean-variance
curve. Any variance read from the curve less than <code>min.var</code> will be
adjusted to this value. It's primarily used for safely getting the prior
variances and taking into account the practical significance of a signal
difference.</p>
</td></tr>
<tr><td><code id="diffTest_+3A_df.prior">df.prior</code></td>
<td>
<p>Number of prior degrees of freedom associated with the
mean-variance curve.
Must be non-negative. Can be set to <code>Inf</code> (see &quot;Details&quot;).
By default, <code>diffTest</code> checks if <code>x</code> and <code>y</code> have the
same <code>"df.prior"</code> component, and uses it as the number of prior
degrees of freedom if yes (an error is raised otherwise).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method for calling differential genomic intervals between two
<code><a href="#topic+bioCond">bioCond</a></code> objects adopts the modeling strategy implemented in
<code>limma</code> (see &quot;References&quot;), except that each interval has its own prior
variance, which is read from the mean-variance curve associated with the
<code>bioCond</code>s. Technically, the final estimate of variance for an
individual interval is a weighted average between its prior and observed
variances, with the weights being proportional to their respective numbers
of degrees of freedom.
</p>
<p>Two extreme values can be specified for the argument <code>df.prior</code>
(number of degrees of freedom associated with the prior variances),
representing two distinct cases: when it is set to <code>0</code>, the final
variance estimate for an individual interval is
simply deduced from the signal intensities observed in it, and the
statistical test reduces to the ordinary two-sample t-test; when it is set
to <code>Inf</code>, the final variance estimate is simply read from the
mean-variance curve. Other values of <code>df.prior</code> represent intermediate
cases. To be noted, the number of prior degrees of freedom is automatically
estimated for each mean-variance curve by a specifically designed
statistical method (see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> and
<code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code>) and, by
default, <code>diffTest</code> uses the estimation result to perform the
differential tests. It's highly not recommended to specify <code>df.prior</code>
explicitly when calling <code>diffTest</code>, unless you know what you are really
doing. Besides, <code>diffTest</code> won't adjust variance ratio factors of
the two <code>bioCond</code>s being compared based on the specified number of
prior degrees of freedom (see <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for a
description of variance ratio factor).
</p>
<p>Note also that, if <code>df.prior</code> is set to <code>0</code>, of the
two <code>bioCond</code> objects being compared there must be at least one that
contains two or more samples. Otherwise, there is no way to measure the
variance associated with each interval,
and an error is raised.
</p>
<p>Considering the practical significance of differential ChIP-seq signals,
those genomic intervals not occupied by either of the conditions
may be filtered
out before selecting differential ones. Thus, the statistical power for
detecting differential intervals could potentially be increased by
re-adjusting
<em>p</em>-values of the remaining intervals (see &quot;Examples&quot; below).
</p>


<h3>Value</h3>

<p>This method returns an object of <code><a href="base.html#topic+class">class</a></code>
<code>c("diffBioCond", "data.frame")</code>, recording the test results for
each genomic interval by each row. The data frame consists of the
following variables:
</p>

<dl>
<dt><code>x.mean, y.mean</code></dt><dd><p>Mean signal intensities of the two
conditions, respectively. <code>"x"</code> and <code>"y"</code> in the variable
names are replaced by the corresponding actual condition names.</p>
</dd>
<dt><code>Mval</code></dt><dd><p>Difference in mean signal intensity between the
two conditions. An <code>Mval</code> of <code>1</code> indicates a twofold
change in normalized read count.</p>
</dd>
<dt><code>Mval.se</code></dt><dd><p>Standard error associated with the
<code>Mval</code>.</p>
</dd>
<dt><code>Mval.t</code></dt><dd><p>The ratio of <code>Mval</code> to <code>Mval.se</code>.</p>
</dd>
<dt><code>pval</code></dt><dd><p>Two sided <em>p</em>-value for the statistical
significance of this signal difference.</p>
</dd>
<dt><code>padj</code></dt><dd><p><em>P</em>-value adjusted for multiple testing with
the <code>"BH"</code> method (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>), which
controls false discovery rate.</p>
</dd>
</dl>

<p>Row names of the returned data frame inherit from those of
<code>x$norm.signal</code>. Besides, an attribute named <code>"Mval.se.df"</code> is
added to the returned object, which is a positive numeric giving the
total number of degrees of freedom associated with the standard errors.
</p>


<h3>References</h3>

<p>Smyth, G.K., <em>Linear models and empirical bayes methods for
assessing differential expression in microarray experiments.</em> Stat Appl
Genet Mol Biol, 2004. <strong>3</strong>: p. Article3.
</p>
<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing groups of
ChIP-seq samples.</em> Genome Res, 2021. <strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve for
a set of <code>bioCond</code> objects; <code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code> for
setting the mean-variance curve of a set of <code>bioCond</code>s;
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for estimating number of prior degrees of
freedom as well as adjusting variance ratio factors accordingly.
</p>
<p><code><a href="#topic+MAplot.diffBioCond">MAplot.diffBioCond</a></code> for creating an MA plot on results of
comparing two <code>bioCond</code> objects; <code><a href="#topic+aovBioCond">aovBioCond</a></code> for
comparing multiple <code>bioCond</code> objects; <code><a href="#topic+varTestBioCond">varTestBioCond</a></code>
for calling hypervariable and invariant intervals across ChIP-seq
samples contained in a <code>bioCond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Make a comparison between GM12891 and GM12892 cell lines.

# Perform MA normalization and construct bioConds to represent the two cell
# lines.
norm &lt;- normalize(H3K27Ac, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Variations in ChIP-seq signals across biological replicates of a cell line
# are generally of a low level, and their relationship with the mean signal
# intensities is expected to be well modeled by the presumed parametric
# form.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
summary(conds[[1]])
plotMeanVarCurve(conds, subset = "occupied")

# Perform differential tests between the two cell lines.
res1 &lt;- diffTest(conds[[1]], conds[[2]])
head(res1)
MAplot(res1, padj = 0.001)
abline(h = 0, lwd = 2, lty = 5, col = "green3")

## Make a comparison between GM12891 and GM12892 cell lines using only their
## first replicates.

# Perform MA normalization and construct bioConds to represent the two cell
# lines.
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
norm &lt;- normalize(H3K27Ac, c(5, 7), c(10, 12),
                  common.peak.regions = autosome)
conds &lt;- list(GM12891 = bioCond(norm[5], norm[10], name = "GM12891"),
              GM12892 = bioCond(norm[7], norm[12], name = "GM12892"))

# Construct a "blind" bioCond that treats the two samples as replicates and
# fit a mean-variance curve accordingly. Only common peak regions of the two
# samples are considered to be occupied by the "blind" bioCond, and only
# these regions are used for fitting the mean-variance curve. This setting
# is for capturing underlying non-differential intervals as accurately as
# possible and avoiding over-estimation of prior variances (i.e., variances
# read from a mean-variance curve).
conds$blind &lt;- bioCond(norm[c(5, 7)], norm[c(10, 12)], occupy.num = 2,
                       name = "blind")
conds &lt;- fitMeanVarCurve(conds, method = "parametric",
                         occupy.only = TRUE, init.coef = c(0.1, 10))
summary(conds[[1]])
summary(conds[[2]])
summary(conds[[3]])
plotMeanVarCurve(conds, subset = "occupied")

# Perform differential tests between the two cell lines.
res2 &lt;- diffTest(conds[[1]], conds[[2]])
head(res2)
MAplot(res2, pval = 0.01)
abline(h = 0, lwd = 2, lty = 5, col = "green3")

# Inspect only the test results of the genomic intervals that are occupied
# by at least one of the two bioConds having been compared. Note the
# globally increased statistical power.
res3 &lt;- res2[conds[[1]]$occupancy | conds[[2]]$occupancy, ]
res3$padj &lt;- p.adjust(res3$pval, method = "BH")
boxplot(list(all = res2$padj, occupied = res3$padj), ylab = "Adj. p-value")

## Examine the consistency of results between the two differential analyses.

# Theoretically, t-statistics resulting from the two differential analyses
# are not directly comparable to each other, since they have different
# numbers of degrees of freedom. Here we map these t-statistics to the
# standard normal distribution in such a manner that the resulting
# z-statistics correspond to the same p-values as do the original
# t-statistics.
z1 &lt;- qnorm(res1$pval / 2)
z1[res1$Mval &gt; 0] &lt;- -z1[res1$Mval &gt; 0]
z2 &lt;- qnorm(res2$pval / 2)
z2[res2$Mval &gt; 0] &lt;- -z2[res2$Mval &gt; 0]

# Check the correlation between z-statistics from the two differential
# analyses.
cor(z1, z2)
cor(z1, z2, method = "sp")

## Make a comparison between the male and female genders by treating each
## individual (i.e., cell line) as a replicate.

# First perform the MA normalization and construct bioConds to represent
# individuals.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Group individuals into bioConds based on their genders.
female &lt;- cmbBioCond(conds[c(1, 3)], name = "female")
male &lt;- cmbBioCond(conds[2], name = "male")

# The dependence of variance of ChIP-seq signal intensity across individuals
# on the mean signal intensity is not as regular as in the case for modeling
# biological replicates of cell lines. Better use the local regression to
# adaptively capture the mean-variance trend.
genders &lt;- list(female = female, male = male)
genders &lt;- fitMeanVarCurve(genders, method = "local", occupy.only = FALSE)
genders &lt;- estimatePriorDf(genders, occupy.only = TRUE)
summary(genders$female)
summary(genders$male)
plotMeanVarCurve(genders, subset = "all")

# Perform differential tests between the two genders.
res &lt;- diffTest(genders[[1]], genders[[2]])
head(res)
MAplot(res, pval = 0.01)
abline(h = 0, lwd = 2, lty = 5, col = "green3")

# Examine the distribution of p-values in Y chromosome.
hist(res$pval[H3K27Ac$chrom == "chrY"], col = "red",
     main = "P-values in Y chromosome")

</code></pre>

<hr>
<h2 id='distBioCond'>Quantify the Distance between Each Pair of Samples in a <code>bioCond</code></h2><span id='topic+distBioCond'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+bioCond">bioCond</a></code> object, <code>distBioCond</code> deduces, for each
pair of samples contained in it, the average absolute difference in signal
intensities of genomic intervals between them. Specifically, the function
calculates a weighted minkowski (i.e., <em>p</em>-norm) distance between each
pair of vectors of signal intensities, with the weights being inversely
proportional to variances of individual intervals (see also
&quot;Details&quot;). <code>distBioCond</code> returns a <code><a href="stats.html#topic+dist">dist</a></code> object
recording the deduced average <code class="reqn">|M|</code> values. The object effectively
quantifies the distance between each pair of samples and can be passed to
<code><a href="stats.html#topic+hclust">hclust</a></code> to perform a clustering analysis (see
&quot;Examples&quot; below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distBioCond(
  x,
  subset = NULL,
  method = c("prior", "posterior", "none"),
  min.var = 0,
  p = 2,
  diag = FALSE,
  upper = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distBioCond_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+bioCond">bioCond</a></code> object.</p>
</td></tr>
<tr><td><code id="distBioCond_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of genomic intervals to
be used for deducing the distances between samples of <code>x</code>. In
practice, you may want to use only the intervals associated with large
variations across the samples to calculate the distances, as such
intervals are most helpful for distinguishing between the samples (see
<code><a href="#topic+varTestBioCond">varTestBioCond</a></code> and &quot;Examples&quot; below).</p>
</td></tr>
<tr><td><code id="distBioCond_+3A_method">method</code></td>
<td>
<p>A character string indicating the method to be used for
calculating the variances of individual intervals. Must be one of
<code>"prior"</code> (default), <code>"posterior"</code> and <code>"none"</code>. Can be
abbreviated. Note that the <code>"none"</code> method does not consider the
mean-variance trend associated with <code>x</code> (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="distBioCond_+3A_min.var">min.var</code></td>
<td>
<p>Lower bound of variances read from the mean-variance
curve associated with <code>x</code>. Any variance read from the curve less
than <code>min.var</code> will be adjusted to this value. It's primarily used
for safely reading positive values from the curve and taking into
account the practical significance of a signal variation. Ignored if
<code>method</code> is set to <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="distBioCond_+3A_p">p</code></td>
<td>
<p>The power used to calculate the <em>p</em>-norm distance between
each pair of samples (see &quot;Details&quot; for the specific formula).
Any positive real could be
specified, though setting <code>p</code> to a value other than 1
and 2 makes little sense. The default corresponds to the Euclidean
distance.</p>
</td></tr>
<tr><td><code id="distBioCond_+3A_diag">diag</code>, <code id="distBioCond_+3A_upper">upper</code></td>
<td>
<p>Two arguments to be passed to
<code><a href="stats.html#topic+as.dist">as.dist</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variance of signal intensity varies considerably
across genomic intervals, due to
the heteroscedasticity inherent to count data as well as most of their
transformations. On this account, separately scaling the signal intensities
of each interval in a <code><a href="#topic+bioCond">bioCond</a></code> should lead to a more
reasonable measure of distances between its samples.
Suppose that <code class="reqn">X</code> and <code class="reqn">Y</code> are two vectors of signal intensities
representing two samples of a <code>bioCond</code> and that <code class="reqn">xi</code>, <code class="reqn">yi</code>
are their <code class="reqn">i</code>th elements corresponding to the <code class="reqn">i</code>th interval.
<code>distBioCond</code> calculates the distance between <code class="reqn">X</code> and <code class="reqn">Y</code> as
follows: </p>
<p style="text-align: center;"><code class="reqn">d(X, Y) = (sum(wi * |yi - xi| ^ p) / sum(wi)) ^ (1 / p)</code>
</p>

<p>where <code class="reqn">wi</code> is the reciprocal of the scaled variance (see below)
of interval <code class="reqn">i</code>, and <code class="reqn">p</code> defaults to 2.
Since the weights of intervals are normalized to have a sum of 1,
the resulting distance could be interpreted as an average absolute
difference in signal intensities of intervals between the two samples.
</p>
<p>Since there typically exists a clear mean-variance dependence across genomic
intervals, <code>distBioCond</code> takes advantage of the mean-variance curve
associated with the <code>bioCond</code> to improve estimates of variances of
individual intervals. By default, prior variances, which are the ones read
from the curve, are used to deduce the weights of intervals for calculating
the distances. Alternatively, one can choose to use posterior variances of
intervals by setting <code>method</code> to <code>"posterior"</code>, which are weighted
averages of prior and observed variances, with the weights being
proportional to their respective numbers of degrees of freedom (see
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for details). Since the observed variances of
intervals are associated with large uncertainty when the total number of
samples is small, it is not recommended to use posterior variances in such
cases. To be noted, if <code>method</code> is set to <code>"none"</code>,
<code>distBioCond</code> will consider all genomic intervals to be associated with
a constant variance. In this case, neither the prior variance nor the
observed variance of each interval is used
to deduce its weight for calculating the distances.
This method is particularly suited to <code>bioCond</code> objects
that have gone through a variance-stabilizing transformation (see
<code><a href="#topic+vstBioCond">vstBioCond</a></code> for details and &quot;Examples&quot; below) as well as
<code>bioCond</code>s whose structure matrices have been specifically
designed (see below and &quot;References&quot; also).
</p>
<p>Another point deserving special attention is that <code>distBioCond</code> has
considered the possibility that
genomic intervals in the supplied <code>bioCond</code>
are associated with different structure matrices. In order to objectively
compare signal variation levels between genomic intervals,
<code>distBioCond</code> further scales the variance of each interval
(deduced by using whichever method is selected) by
multiplying it with the geometric mean of diagonal
elements of the interval's structure matrix. See <code><a href="#topic+bioCond">bioCond</a></code> and
<code><a href="#topic+setWeight">setWeight</a></code> for a detailed description of structure matrix.
</p>
<p>Given a set of <code>bioCond</code> objects,
<code>distBioCond</code> could also be used to quantify the distance between
each pair of them, by first combining the <code>bioCond</code>s into a
single <code>bioCond</code> and fitting a mean-variance curve for
it (see <code><a href="#topic+cmbBioCond">cmbBioCond</a></code> and &quot;Examples&quot; below).
</p>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+dist">dist</a></code> object quantifying the distance between
each pair of samples of <code>x</code>.
</p>


<h3>References</h3>

<p>Law, C.W., et al., <em>voom: Precision weights unlock linear
model analysis tools for RNA-seq read counts.</em> Genome Biol, 2014.
<strong>15</strong>(2): p. R29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve;
<code><a href="#topic+cmbBioCond">cmbBioCond</a></code> for combining a set of <code>bioCond</code> objects
into a single one; <code><a href="stats.html#topic+hclust">hclust</a></code> for performing a
hierarchical clustering on a <code><a href="stats.html#topic+dist">dist</a></code> object;
<code><a href="#topic+vstBioCond">vstBioCond</a></code> for applying a variance-stabilizing
transformation to signal intensities of samples of a <code>bioCond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Cluster a set of ChIP-seq samples from different cell lines (i.e.,
## individuals).

# Perform MA normalization and construct a bioCond.
norm &lt;- normalize(H3K27Ac, 4:8, 9:13)
cond &lt;- bioCond(norm[4:8], norm[9:13], name = "all")

# Fit a mean-variance curve.
cond &lt;- fitMeanVarCurve(list(cond), method = "local",
                        occupy.only = FALSE)[[1]]
plotMeanVarCurve(list(cond), subset = "all")

# Measure the distance between each pair of samples and accordingly perform
# a hierarchical clustering. Note that biological replicates of each cell
# line are clustered together.
d1 &lt;- distBioCond(cond, method = "prior")
plot(hclust(d1, method = "average"), hang = -1)

# Measure the distances using only hypervariable genomic intervals. Note the
# change of scale of the distances.
res &lt;- varTestBioCond(cond)
f &lt;- res$fold.change &gt; 1 &amp; res$pval &lt; 0.05
d2 &lt;- distBioCond(cond, subset = f, method = "prior")
plot(hclust(d2, method = "average"), hang = -1)

# Apply a variance-stabilizing transformation and associate a constant
# function with the resulting bioCond as its mean-variance curve.
vst_cond &lt;- vstBioCond(cond)
vst_cond &lt;- setMeanVarCurve(list(vst_cond), function(x)
                            rep_len(1, length(x)), occupy.only = FALSE,
                            method = "constant prior")[[1]]
plotMeanVarCurve(list(vst_cond), subset = "all")

# Repeat the clustering analyses on the VSTed bioCond.
d3 &lt;- distBioCond(vst_cond, method = "none")
plot(hclust(d3, method = "average"), hang = -1)
res &lt;- varTestBioCond(vst_cond)
f &lt;- res$fold.change &gt; 1 &amp; res$pval &lt; 0.05
d4 &lt;- distBioCond(vst_cond, subset = f, method = "none")
plot(hclust(d4, method = "average"), hang = -1)

## Cluster a set of individuals.

# Perform MA normalization and construct bioConds to represent individuals.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
conds &lt;- normBioCond(conds)

# Group the individuals into a single bioCond and fit a mean-variance curve
# for it.
cond &lt;- cmbBioCond(conds, name = "all")
cond &lt;- fitMeanVarCurve(list(cond), method = "local",
                        occupy.only = FALSE)[[1]]
plotMeanVarCurve(list(cond), subset = "all")

# Measure the distance between each pair of individuals and accordingly
# perform a hierarchical clustering. Note that GM12891 and GM12892 are
# actually a couple and they are clustered together.
d1 &lt;- distBioCond(cond, method = "prior")
plot(hclust(d1, method = "average"), hang = -1)

# Measure the distances using only hypervariable genomic intervals. Note the
# change of scale of the distances.
res &lt;- varTestBioCond(cond)
f &lt;- res$fold.change &gt; 1 &amp; res$pval &lt; 0.05
d2 &lt;- distBioCond(cond, subset = f, method = "prior")
plot(hclust(d2, method = "average"), hang = -1)

</code></pre>

<hr>
<h2 id='estimateD0'>Workhorse Function for Estimating Number of Prior Degrees of Freedom</h2><span id='topic+estimateD0'></span>

<h3>Description</h3>

<p><code>estimateD0</code> underlies other interface functions for assessing
the goodness of fit of an unadjusted mean-variance curve (or a set of
unadjusted mean-variance curves).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateD0(z, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateD0_+3A_z">z</code></td>
<td>
<p>A list of which each element is a vector of FZ statistics
corresponding to a <code><a href="#topic+bioCond">bioCond</a></code> object (see also &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="estimateD0_+3A_m">m</code></td>
<td>
<p>A vector of numbers of replicates in <code>bioCond</code>
objects. Must correspond to <code>z</code> one by one in the same
order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code><a href="#topic+bioCond">bioCond</a></code> object with replicate samples, a vector of
FZ statistics can be deduced from the unadjusted mean-variance curve
associated with it. More specifically, for each genomic interval in a
<code>bioCond</code> with replicate samples, its FZ statistic is defined to be
<code class="reqn">log(t_hat / v0)</code>, where <code class="reqn">t_hat</code> is the observed variance of signal
intensities of the interval, and <code class="reqn">v0</code> is the interval's prior variance
read from the corresponding mean-variance curve.
</p>
<p>Theoretically, each FZ statistic follows a scaled Fisher's Z distribution
plus a constant (since the mean-variance curve is not adjusted yet), and we
can use the sample variance (plus a constant) of the FZ statistics
of each single <code>bioCond</code> to get an estimate of
<code class="reqn">trigamma(d0 / 2)</code>,
where <code class="reqn">d0</code> is the number of prior degrees of freedom
(see also <code><a href="base.html#topic+trigamma">trigamma</a></code>).
</p>
<p>The final estimate of <code class="reqn">trigamma(d0 / 2)</code> is a weighted mean of estimates
across <code>bioCond</code> objects, with the weights being their respective
numbers of genomic intervals minus 1 that
are used to deduce the FZ statistics.
This should be appropriate, as Fisher's Z distribution is roughly normal
(see also &quot;References&quot;). The weighted mean is similar to the pooled sample
variance in an ANOVA analysis.
</p>
<p>Finally, an estimate of <code class="reqn">d0</code> can be obtained by taking the inverse of
<code class="reqn">trigamma</code> function, which is achieved by applying Newton iteration
to it. Note that <code class="reqn">d0</code> is considered to be infinite if the estimated
<code class="reqn">trigamma(d0 / 2)</code> is less than or equal to 0.
</p>


<h3>Value</h3>

<p>The estimated number of prior degrees of freedom. Note that the
function returns <code>NA</code> if there are not sufficient genomic intervals
for estimating it.
</p>


<h3>References</h3>

<p>Smyth, G.K., <em>Linear models and empirical bayes methods for
assessing differential expression in microarray experiments.</em> Stat Appl
Genet Mol Biol, 2004. <strong>3</strong>: p. Article3.
</p>
<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing groups of
ChIP-seq samples.</em> Genome Res, 2021. <strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve;
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for an interface to estimating the
number of prior degrees of freedom on <code>bioCond</code> objects;
<code><a href="#topic+varRatio">varRatio</a></code> for a description of variance ratio factor;
<code><a href="#topic+scaleMeanVarCurve">scaleMeanVarCurve</a></code> for estimating the variance ratio factor
for adjusting a mean-variance curve (or a set of curves).
</p>
<p><code><a href="#topic+estimateD0Robust">estimateD0Robust</a></code> and <code><a href="#topic+scaleMeanVarCurveRobust">scaleMeanVarCurveRobust</a></code>
for estimating number of prior degrees of freedom and variance ratio
factor <em>in a robust manner</em>, respectively.
</p>

<hr>
<h2 id='estimateD0Robust'>Estimate Number of Prior Degrees of Freedom in a Robust Manner</h2><span id='topic+estimateD0Robust'></span>

<h3>Description</h3>

<p><code>estimateD0Robust</code> underlies other interface functions for estimating
the number of prior degrees of freedom associated with an unadjusted
mean-variance curve (or a set of unadjusted mean-variance curves)
<em>in a robust manner</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateD0Robust(
  z,
  m,
  p_low = 0.01,
  p_up = 0.1,
  d0_low = 0.001,
  d0_up = 1e+06,
  eps = d0_low,
  nw = gauss.quad(128, kind = "legendre")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateD0Robust_+3A_z">z</code></td>
<td>
<p>A list of which each element is a vector of FZ statistics
corresponding to a <code><a href="#topic+bioCond">bioCond</a></code> object (see also &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="estimateD0Robust_+3A_m">m</code></td>
<td>
<p>A vector of numbers of replicates in <code>bioCond</code>
objects. Must correspond to <code>z</code> one by one in the same
order.</p>
</td></tr>
<tr><td><code id="estimateD0Robust_+3A_p_low">p_low</code>, <code id="estimateD0Robust_+3A_p_up">p_up</code></td>
<td>
<p>Lower- and upper-tail probabilities for Winsorizing the
FZ statistics associated with each <code>bioCond</code>.</p>
</td></tr>
<tr><td><code id="estimateD0Robust_+3A_d0_low">d0_low</code>, <code id="estimateD0Robust_+3A_d0_up">d0_up</code></td>
<td>
<p>Positive reals specifying the lower and upper bounds
of estimated <code class="reqn">d0</code> (i.e., number of prior degrees of freedom).
<code>Inf</code> is <em>not</em> allowed.
</p>
<p>During the estimation process, if <code class="reqn">d0</code> is sure to be less than
or equal to <code>d0_low</code>, it will be considered as 0, and if it is
sure to be larger than or equal to <code>d0_up</code>, it will be considered
as positive infinity.</p>
</td></tr>
<tr><td><code id="estimateD0Robust_+3A_eps">eps</code></td>
<td>
<p>The required numeric precision for estimating <code class="reqn">d0</code>.</p>
</td></tr>
<tr><td><code id="estimateD0Robust_+3A_nw">nw</code></td>
<td>
<p>A list containing <code>nodes</code> and <code>weights</code> variables for
calculating the definite integral of a function <code>f</code> over the
interval <code>[-1, 1]</code>, which is approximated by
<code>sum(nw$weights * f(nw$nodes))</code>. By default,
a set of Gauss-Legendre nodes along with the corresponding weights
calculated by <code><a href="statmod.html#topic+gauss.quad">gauss.quad</a></code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code><a href="#topic+bioCond">bioCond</a></code> object with replicate samples, a vector of
FZ statistics can be deduced from the unadjusted mean-variance curve
associated with it. More specifically, for each genomic interval in a
<code>bioCond</code> with replicate samples, its FZ statistic is defined to be
<code class="reqn">log(t_hat / v0)</code>, where <code class="reqn">t_hat</code> is the observed variance of signal
intensities of the interval, and <code class="reqn">v0</code> is the interval's prior variance
read from the corresponding mean-variance curve.
</p>
<p>Theoretically, each FZ statistic follows a scaled Fisher's Z distribution
plus a constant (since the mean-variance curve is not adjusted yet),
and we derive a robust estimation of <code class="reqn">d0</code> (i.e., number of prior
degrees of freedom) by
Winsorizing the FZ statistics of each <code>bioCond</code> and matching the
resulting sample variance with the theoretical variance of the Winsorized
distribution, which is calculated by using numerical integration (see
also &quot;References&quot;). Since the theoretical variance has no compact forms
regarding <code class="reqn">d0</code>, the matching procedure is achieved by using the method
of bisection.
</p>
<p>Inspired by the ordinary (non-robust) routine for estimating <code class="reqn">d0</code>, we
derive the final estimate of <code class="reqn">d0</code> by separately applying the function
<code class="reqn">trigamma(x / 2)</code> to the estimated <code class="reqn">d0</code> from each
<code>bioCond</code>, taking a weighted average across the results, and applying
the inverse of the function (achieved by using Newton iteration;
see also <code><a href="base.html#topic+trigamma">trigamma</a></code>). Here the
weights are the numbers of genomic intervals (in the <code>bioCond</code>s) minus
1 that are used to calculate FZ statistics.
</p>


<h3>Value</h3>

<p>The estimated number of prior degrees of freedom. Note that the
function returns <code>NA</code> if there are not sufficient genomic intervals
for estimating it.
</p>


<h3>References</h3>

<p>Phipson, B., et al., <em>Robust Hyperparameter Estimation
Protects against Hypervariable Genes and Improves Power to Detect
Differential Expression.</em> Annals of Applied Statistics, 2016.
<strong>10</strong>(2): p. 946-963.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve;
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> for an interface to <em>robustly</em>
estimating the number of prior degrees of freedom on <code>bioCond</code>
objects; <code><a href="#topic+varRatio">varRatio</a></code> for a description of variance ratio
factor; <code><a href="#topic+scaleMeanVarCurveRobust">scaleMeanVarCurveRobust</a></code> for <em>robustly</em>
estimating the variance ratio factor
for adjusting a mean-variance curve (or a set of curves).
</p>
<p><code><a href="#topic+estimateD0">estimateD0</a></code> and <code><a href="#topic+scaleMeanVarCurve">scaleMeanVarCurve</a></code>
for the ordinary (non-robust) routines for estimating number of prior
degrees of freedom and variance ratio factor, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Private functions involved.

# For generating random FZ statistics with outliers. Note that the argument
# scaling controls how extreme outliers are.
rFZ &lt;- function(n, var.ratio, m, d0, p_low, p_up, scaling) {
    z &lt;- list()
    p_low &lt;- p_low * 0.9
    p_up &lt;- p_up * 0.9
    for (i in 1:length(n)) {
        x &lt;- rf(n[i], m[i] - 1, d0)
        q_low &lt;- qf(p_low, m[i] - 1, d0, lower.tail = TRUE)
        q_up &lt;- qf(p_up, m[i] - 1, d0, lower.tail = FALSE)
        f &lt;- x &lt; q_low
        x[f] &lt;- x[f] / runif(sum(f), 1, scaling)
        f &lt;- x &gt; q_up
        x[f] &lt;- x[f] * runif(sum(f), 1, scaling)
        z[[i]] &lt;- log(var.ratio[i]) + log(x)
    }
    z
}

# Settings.
n &lt;- c(30000, 40000)
var.ratio &lt;- c(1.2, 2.5)
m &lt;- c(2, 3)
d0 &lt;- 17
p_low &lt;- 0.01
p_up &lt;- 0.1

# Compare estimation results from ordinary (non-robust) and robust routines.
# Case 1: no outliers.
set.seed(100)
scaling &lt;- 1
z &lt;- rFZ(n, var.ratio, m, d0, p_low, p_up, scaling)
res1 &lt;- estimateD0(z, m)
res1
scaleMeanVarCurve(z[1], m[1], res1)
scaleMeanVarCurve(z[2], m[2], res1)
res2 &lt;- estimateD0Robust(z, m, p_low, p_up)
res2
scaleMeanVarCurveRobust(z[1], m[1], res2, p_low, p_up)
scaleMeanVarCurveRobust(z[2], m[2], res2, p_low, p_up)

# Case 2: moderate outliers.
scaling &lt;- 3
z &lt;- rFZ(n, var.ratio, m, d0, p_low, p_up, scaling)
res1 &lt;- estimateD0(z, m)
res1
scaleMeanVarCurve(z[1], m[1], res1)
scaleMeanVarCurve(z[2], m[2], res1)
res2 &lt;- estimateD0Robust(z, m, p_low, p_up)
res2
scaleMeanVarCurveRobust(z[1], m[1], res2, p_low, p_up)
scaleMeanVarCurveRobust(z[2], m[2], res2, p_low, p_up)

# Case 3: extreme outliers.
scaling &lt;- 10
z &lt;- rFZ(n, var.ratio, m, d0, p_low, p_up, scaling)
res1 &lt;- estimateD0(z, m)
res1
scaleMeanVarCurve(z[1], m[1], res1)
scaleMeanVarCurve(z[2], m[2], res1)
res2 &lt;- estimateD0Robust(z, m, p_low, p_up)
res2
scaleMeanVarCurveRobust(z[1], m[1], res2, p_low, p_up)
scaleMeanVarCurveRobust(z[2], m[2], res2, p_low, p_up)

## End(Not run)

</code></pre>

<hr>
<h2 id='estimatePriorDf'>Assess the Goodness of Fit of Mean-Variance Curves</h2><span id='topic+estimatePriorDf'></span>

<h3>Description</h3>

<p>Given a set of <code><a href="#topic+bioCond">bioCond</a></code> objects of which each has been
associated with a mean-variance curve, <code>estimatePriorDf</code> derives a
common number of
prior degrees of freedom assessing the overall goodness of fit of the
mean-variance curves and accordingly adjusts the variance ratio factor of
each of the <code>bioCond</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePriorDf(
  conds,
  occupy.only = TRUE,
  return.d0 = FALSE,
  no.rep.rv = NULL,
  .call = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimatePriorDf_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects, of which each has a
<code>fit.info</code> field describing its mean-variance curve (see also
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="estimatePriorDf_+3A_occupy.only">occupy.only</code></td>
<td>
<p>A logical scalar. If it is <code>TRUE</code> (default), only
occupied intervals are used to estimate the number of
prior degrees of freedom and adjust the variance ratio factors.
Otherwise, all intervals are used (see also &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="estimatePriorDf_+3A_return.d0">return.d0</code></td>
<td>
<p>A logical scalar. If set to <code>TRUE</code>, the function
simply returns the estimated number of prior degrees of freedom.</p>
</td></tr>
<tr><td><code id="estimatePriorDf_+3A_no.rep.rv">no.rep.rv</code></td>
<td>
<p>A positive real specifying the variance ratio factor of
those <code>bioCond</code>s without replicate samples, if any. By default,
it's set to the geometric mean of variance ratio factors of the other
<code>bioCond</code>s.</p>
</td></tr>
<tr><td><code id="estimatePriorDf_+3A_.call">.call</code></td>
<td>
<p>Never care about this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>estimatePriorDf</code> borrows part of the modeling strategy implemented in
<code>limma</code> (see &quot;References&quot;). For each <code><a href="#topic+bioCond">bioCond</a></code> object, the
predicted variances from its mean-variance curve serve as the prior
variances associated with individual intervals.
The common number of prior degrees of freedom
of the supplied <code>bioCond</code>s
quantifies the confidence we have on the associated mean-variance curves.
Intuitively, the closer the observed mean-variance points are
to the curves, the more prior degrees of freedom there will be.
See <code><a href="#topic+estimateD0">estimateD0</a></code> for technical details about the estimation of
number of prior degrees of freedom.
</p>
<p>According to the estimated number of prior degrees of freedom,
<code>estimatePriorDf</code>
separately adjusts the variance ratio factor of each <code>bioCond</code>.
Intrinsically, this process is to scale the mean-variance curve of each
<code>bioCond</code> so that it passes the &quot;middle&quot; of the observed mean-variance
points. See <code><a href="#topic+scaleMeanVarCurve">scaleMeanVarCurve</a></code> for technical details of
scaling a mean-variance curve.
</p>
<p>ChIP-seq signals located in non-occupied intervals result primarily from
background noise, and are therefore associated with less data regularity
than signals in occupied intervals. Involving non-occupied intervals in the
estimation process may result in an under-estimated number of prior degrees
of freedom. Thus, the recommended usage is to set <code>occupy.only</code> to
<code>TRUE</code> (i.e., the default).
</p>
<p>In most cases, the estimation of number of prior degrees of freedom
is automatically
handled when fitting or setting a mean-variance curve, and you don't need to
call this function explicitly (see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> and
<code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code>). See &quot;Examples&quot;
below for a practical application of this function. Note also that there is
a <em>robust</em> version of this function that uses Winsorized statistics to
protect the estimation procedure against potential outliers (see
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> for details).
</p>


<h3>Value</h3>

<p>By default, <code>estimatePriorDf</code> returns the argument list of
<code><a href="#topic+bioCond">bioCond</a></code> objects,
with the estimated number of prior degrees of
freedom substituted for the <code>"df.prior"</code> component of each of them.
Besides, their <code>"ratio.var"</code> components have been adjusted
accordingly, and an attribute named <code>"no.rep.rv"</code> is added to the
list if it's ever been used as the variance ratio factor of the
<code>bioCond</code>s without replicate samples. A special case is that the
estimated number of prior degrees of freedom is 0. In this case,
<code>estimatePriorDf</code> won't adjust existing variance ratio factors,
and you may want to use <code><a href="#topic+setPriorDfVarRatio">setPriorDfVarRatio</a></code> to
explicitly specify variance ratio factors.
</p>
<p>If <code>return.d0</code> is set to <code>TRUE</code>, <code>estimatePriorDf</code> simply
returns the estimated number of prior degrees of freedom.
</p>


<h3>References</h3>

<p>Smyth, G.K., <em>Linear models and empirical bayes methods for
assessing differential expression in microarray experiments.</em> Stat Appl
Genet Mol Biol, 2004. <strong>3</strong>: p. Article3.
</p>
<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing groups of
ChIP-seq samples.</em> Genome Res, 2021. <strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve and
using a <code>fit.info</code> field to characterize it;
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> for a <em>robust</em> version of
<code>estimatePriorDf</code>;
<code><a href="#topic+setPriorDf">setPriorDf</a></code> for setting the number of
prior degrees of freedom and accordingly
adjusting the variance ratio factors of a set of <code>bioCond</code>s;
<code><a href="#topic+diffTest.bioCond">diffTest</a></code> for calling differential
intervals between two <code>bioCond</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Fit a mean-variance curve treating each gender as a biological condition,
## and each individual (i.e., cell line) a replicate.

# First perform the MA normalization and construct bioConds to represent
# individuals.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Group individuals into bioConds based on their genders.
female &lt;- cmbBioCond(conds[c(1, 3)], name = "female")
male &lt;- cmbBioCond(conds[2], name = "male")

# The dependence of variance of ChIP-seq signal intensity across individuals
# on the mean signal intensity is typically not as regular as could be well
# modeled by an explicit parametric form. Better use the local regression to
# adaptively capture the mean-variance trend.
genders &lt;- list(female = female, male = male)
genders1 &lt;- fitMeanVarCurve(genders, method = "local", occupy.only = TRUE)
genders2 &lt;- fitMeanVarCurve(genders, method = "local", occupy.only = FALSE)

# Suppose the local regression is performed using only the occupied genomic
# intervals as input. Good chances are that the extrapolation algorithm
# implemented in the regression method will produce over-estimated variances
# for the non-occupied intervals.
plotMeanVarCurve(genders1, subset = "all")
plotMeanVarCurve(genders2, subset = "all")
plotMeanVarCurve(genders1, subset = "non-occupied")
plotMeanVarCurve(genders2, subset = "non-occupied")

# On the other hand, applying the local regression on all genomic intervals
# may considerably reduce the estimated number of prior degrees of freedom
# associated with the fitted mean-variance curve, as ChIP-seq signals in the
# non-occupied intervals are generally of less data regularity compared with
# those in the occupied intervals.
summary(genders1$female)
summary(genders2$female)

# To split the difference, fit the mean-variance curve on all genomic
# intervals and re-estimate the number of prior degrees of freedom using
# only the occupied intervals, which is also the most recommended strategy
# in practice.
genders3 &lt;- estimatePriorDf(genders2, occupy.only = TRUE)
plotMeanVarCurve(genders3, subset = "all")
plotMeanVarCurve(genders3, subset = "non-occupied")
summary(genders3$female)

</code></pre>

<hr>
<h2 id='estimatePriorDfRobust'>Assess the Goodness of Fit of Mean-Variance Curves in a Robust Manner</h2><span id='topic+estimatePriorDfRobust'></span>

<h3>Description</h3>

<p>Given a set of <code><a href="#topic+bioCond">bioCond</a></code> objects of which each has been
associated with a mean-variance curve, <code>estimatePriorDfRobust</code>
derives a common number of prior degrees of freedom assessing the
overall goodness of fit of the mean-variance curves and accordingly
adjusts the variance ratio factor of each of the <code>bioCond</code>s.
Compared with <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code>, the underlying methods
of <code>estimatePriorDfRobust</code> for parameter estimation are
<em>robust</em> to outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePriorDfRobust(
  conds,
  occupy.only = TRUE,
  p_low = 0.01,
  p_up = 0.1,
  d0_low = 0.001,
  d0_up = 1e+06,
  eps = d0_low,
  nw = gauss.quad(128, kind = "legendre"),
  return.d0 = FALSE,
  no.rep.rv = NULL,
  .call = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimatePriorDfRobust_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects, of which each has a
<code>fit.info</code> field describing its mean-variance curve (see also
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="estimatePriorDfRobust_+3A_occupy.only">occupy.only</code></td>
<td>
<p>A logical scalar. If it is <code>TRUE</code> (default), only
occupied intervals are used to estimate the number of
prior degrees of freedom and adjust the variance ratio factors.
Otherwise, all intervals are used.</p>
</td></tr>
<tr><td><code id="estimatePriorDfRobust_+3A_p_low">p_low</code>, <code id="estimatePriorDfRobust_+3A_p_up">p_up</code></td>
<td>
<p>Lower- and upper-proportions of extreme values to be
Winsorized (see &quot;References&quot;). Each of them must be strictly larger than
0, and their sum must be strictly smaller than 1.</p>
</td></tr>
<tr><td><code id="estimatePriorDfRobust_+3A_d0_low">d0_low</code>, <code id="estimatePriorDfRobust_+3A_d0_up">d0_up</code></td>
<td>
<p>Positive reals specifying the lower and upper bounds
of estimated <code class="reqn">d0</code> (i.e., number of prior degrees of freedom).
<code>Inf</code> is <em>not</em> allowed.
</p>
<p>During the estimation process, if <code class="reqn">d0</code> is sure to be less than
or equal to <code>d0_low</code>, it will be considered as 0, and if it is
sure to be larger than or equal to <code>d0_up</code>, it will be considered
as positive infinity.</p>
</td></tr>
<tr><td><code id="estimatePriorDfRobust_+3A_eps">eps</code></td>
<td>
<p>The required numeric precision for estimating <code class="reqn">d0</code>.</p>
</td></tr>
<tr><td><code id="estimatePriorDfRobust_+3A_nw">nw</code></td>
<td>
<p>A list containing <code>nodes</code> and <code>weights</code> variables for
calculating the definite integral of a function <code>f</code> over the
interval <code>[-1, 1]</code>, which is approximated by
<code>sum(nw$weights * f(nw$nodes))</code>. By default,
a set of Gauss-Legendre nodes along with the corresponding weights
calculated by <code><a href="statmod.html#topic+gauss.quad">gauss.quad</a></code> is used.</p>
</td></tr>
<tr><td><code id="estimatePriorDfRobust_+3A_return.d0">return.d0</code></td>
<td>
<p>A logical scalar. If set to <code>TRUE</code>, the function
simply returns the estimated <code class="reqn">d0</code>.</p>
</td></tr>
<tr><td><code id="estimatePriorDfRobust_+3A_no.rep.rv">no.rep.rv</code></td>
<td>
<p>A positive real specifying the variance ratio factor of
those <code>bioCond</code>s without replicate samples, if any. By default,
it's set to the geometric mean of variance ratio factors of the other
<code>bioCond</code>s.</p>
</td></tr>
<tr><td><code id="estimatePriorDfRobust_+3A_.call">.call</code></td>
<td>
<p>Never care about this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The core function of <code>estimatePriorDfRobust</code> is very similar to that
of <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code>, except that the former estimates the
number of prior degrees of freedom and variance ratio factors
<em>in a robust manner</em> (see also &quot;References&quot;).
</p>
<p>Unlike <code>estimatePriorDf</code>, you need to call explicitly
<code>estimatePriorDfRobust</code> if you are intended to perform <em>robust</em>
parameter estimation after associating a mean-variance curve with a set of
<code><a href="#topic+bioCond">bioCond</a></code> objects (via <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for
example; see &quot;Examples&quot; below).
</p>


<h3>Value</h3>

<p>By default, <code>estimatePriorDfRobust</code> returns
the argument list of <code><a href="#topic+bioCond">bioCond</a></code> objects,
with the estimated number of prior degrees of
freedom substituted for the <code>"df.prior"</code> component of each of them.
Besides, their <code>"ratio.var"</code> components have been adjusted
accordingly, and an attribute named <code>"no.rep.rv"</code> is added to the
list if it's ever been used as the variance ratio factor of the
<code>bioCond</code>s without replicate samples. A special case is that the
estimated number of prior degrees of freedom is 0. In this case,
<code>estimatePriorDfRobust</code> won't adjust existing variance ratio
factors, and you may want to use <code><a href="#topic+setPriorDfVarRatio">setPriorDfVarRatio</a></code> to
explicitly specify variance ratio factors.
</p>
<p>If <code>return.d0</code> is set to <code>TRUE</code>, <code>estimatePriorDfRobust</code>
simply returns the estimated number of prior degrees of freedom.
</p>


<h3>References</h3>

<p>Tukey, J.W., <em>The future of data analysis.</em> The annals of
mathematical statistics, 1962. <strong>33</strong>(1): p. 1-67.
</p>
<p>Phipson, B., et al., <em>Robust Hyperparameter Estimation
Protects against Hypervariable Genes and Improves Power to Detect
Differential Expression.</em> Annals of Applied Statistics, 2016.
<strong>10</strong>(2): p. 946-963.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve and
using a <code>fit.info</code> field to characterize it;
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for the ordinary (non-robust) version of
<code>estimatePriorDfRobust</code>; <code><a href="#topic+setPriorDfRobust">setPriorDfRobust</a></code> for setting
the number of prior degrees of freedom and accordingly adjusting the
variance ratio factors of a set of <code>bioCond</code>s
<em>in a robust manner</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Estimate parameters regarding the associated mean-variance curve in a
## robust manner. Here we treat each cell line (i.e., individual) as a
## biological condition.

# Perform MA normalization and construct bioConds to represent cell lines.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Fit a mean-variance curve by using the parametric method.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)

# Estimate the associated number of prior degrees of freedom and variance
# ratio factors in a robust manner.
conds2 &lt;- estimatePriorDfRobust(conds, occupy.only = TRUE)

# In this case, there is little difference in estimation results between the
# ordinary routine and the robust one.
sapply(conds, function(x) c(x$fit.info$df.prior, x$fit.info$ratio.var))
sapply(conds2, function(x) c(x$fit.info$df.prior, x$fit.info$ratio.var))

</code></pre>

<hr>
<h2 id='estimateSizeFactors'>Estimate Size Factors of ChIP-seq Samples</h2><span id='topic+estimateSizeFactors'></span>

<h3>Description</h3>

<p>Given a table of raw read counts from ChIP-seq experiments,
<code>estimateSizeFactors</code> returns estimated size factors representing
relative sequencing depths of the ChIP-seq samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateSizeFactors(counts, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateSizeFactors_+3A_counts">counts</code></td>
<td>
<p>A matrix or data frame consisting of read counts. Each row
represents an observation (typically a genomic interval) and each column
a ChIP-seq sample. Objects of other types are coerced to a matrix.</p>
</td></tr>
<tr><td><code id="estimateSizeFactors_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the estimation process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilizes the median ratio strategy to deduce size factors
(see &quot;References&quot; for details). It's primarily for being used by the MA
normalization process to select an optimal baseline sample, and in most
cases you don't need to call this function directly. It may help, however,
when you want to specify the baseline sample by your own criterion.
</p>


<h3>Value</h3>

<p><code>estimateSizeFactors</code> returns a numeric vector specifying the
size factors.
</p>


<h3>References</h3>

<p>Anders, S. and W. Huber, <em>Differential expression analysis
for sequence count data.</em> Genome Biol, 2010. <strong>11</strong>(10): p. R106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code> for the MA normalization process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

# Use all the genomic intervals.
estimateSizeFactors(H3K27Ac[4:8])

# Use only the genomic intervals occupied by all the ChIP-seq samples.
estimateSizeFactors(H3K27Ac[4:8], subset = apply(H3K27Ac[9:13], 1, all))

</code></pre>

<hr>
<h2 id='estimateVarRatio'>Estimate Relative Variance Ratio Factors of <code>bioCond</code> Objects</h2><span id='topic+estimateVarRatio'></span>

<h3>Description</h3>

<p>Given a set of <code><a href="#topic+bioCond">bioCond</a></code> objects assumed to be associated with
the same mean-variance curve, <code>estimateVarRatio</code>
robustly estimates their relative variance ratio factors, by selecting one
of the <code>bioCond</code>s as the base condition and comparing the others to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateVarRatio(
  conds,
  base.cond = NULL,
  subset = NULL,
  invariant = NULL,
  no.rep.rv = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateVarRatio_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects.</p>
</td></tr>
<tr><td><code id="estimateVarRatio_+3A_base.cond">base.cond</code></td>
<td>
<p>An optional positive integer or character name indexing the
base <code>bioCond</code> in <code>conds</code>. Note that the base condition must
contain replicate samples. By default, the base <code>bioCond</code> is
automatically selected by measuring the variation levels of the
<code>bioCond</code>s (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="estimateVarRatio_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying the subset of intervals to be
used for measuring the variation levels. Defaults to the intervals
occupied by all the <code>bioCond</code>s.
Ignored if <code>base.cond</code> is specified.</p>
</td></tr>
<tr><td><code id="estimateVarRatio_+3A_invariant">invariant</code></td>
<td>
<p>An optional non-negative real specifying the upper bound
of difference in mean signal intensity
for a genomic interval to be treated
as invariant between two <code>bioCond</code> objects. By default, intervals
occupied by both <code>bioCond</code>s are treated as invariant between them.
Note that <code>estimateVarRatio</code> uses exactly the invariant intervals
to compare the variance ratio factors of two <code>bioCond</code>s.</p>
</td></tr>
<tr><td><code id="estimateVarRatio_+3A_no.rep.rv">no.rep.rv</code></td>
<td>
<p>A positive real specifying the (relative) variance ratio
factor of those <code>bioCond</code>s without replicate samples, if any. By
default, it's set to be the geometric mean of variance ratio factors of
the other <code>bioCond</code>s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technically, <code>estimateVarRatio</code> uses 1 as the (relative) variance ratio
factor of the base <code><a href="#topic+bioCond">bioCond</a></code>, and estimates the variance ratio
factors of the other <code>bioCond</code>s by separately comparing each of them to
the base. Refer to <code><a href="#topic+varRatio">varRatio</a></code> for details about comparing the
variance ratio factors of two <code>bioCond</code>s by using their invariant
genomic intervals.
</p>
<p>If the base <code>bioCond</code> is not explicitly specified by users,
<code>estimateVarRatio</code> will measure the variation level of each
<code>bioCond</code> containing replicate samples. Technically, the variation
levels are calculated by applying the median ratio strategy to the observed
variances of the <code>bioCond</code>s. This process is rather similar to the one
for estimating size factors of ChIP-seq samples (see also
<code><a href="#topic+estimateSizeFactors">estimateSizeFactors</a></code>). After that, the <code>bioCond</code> whose
variation level is closest to 1 is selected as the base (with the exception
that, if there are only two <code>bioCond</code>s that contain replicate samples,
the function will always use the <code>bioCond</code> with the lower variation
level as the base, for avoiding potential uncertainty in selection results
due to limited numerical precision).
</p>


<h3>Value</h3>

<p>A named vector of the estimated relative variance ratio factors,
with the names being those of the corresponding <code><a href="#topic+bioCond">bioCond</a></code>
objects. Besides, the following attributes are associated with the
vector:
</p>

<dl>
<dt><code>var.level</code></dt><dd><p>Variation levels of the <code>bioCond</code>
objects. Present only when the base <code>bioCond</code> is automatically
selected by the function.</p>
</dd>
<dt><code>base.cond</code></dt><dd><p>Name of the base <code>bioCond</code>.</p>
</dd>
<dt><code>no.rep.rv</code></dt><dd><p>Variance ratio factor of the <code>bioCond</code>s
with no replicate samples. Present only when it's ever been used.</p>
</dd>
</dl>



<h3>References</h3>

<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing
groups of ChIP-seq samples.</em> Genome Res, 2021.
<strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve for
a set of <code>bioCond</code> objects; <code><a href="#topic+varRatio">varRatio</a></code> for a formal
description of variance ratio factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Estimate the relative variance ratio factors of cell lines.

# Perform the MA normalization and construct bioConds to represent cell
# lines.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Automatically select the base bioCond.
estimateVarRatio(conds)

# Explicitly specify the base bioCond.
estimateVarRatio(conds, base.cond = "GM12891")

</code></pre>

<hr>
<h2 id='estParamHyperChIP'>The Parameter Estimation Framework of HyperChIP</h2><span id='topic+estParamHyperChIP'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+bioCond">bioCond</a></code> object with which a mean-variance curve has
been associated, <code>estParamHyperChIP</code> estimates the related parameters
(i.e., the number of prior degrees of freedom and the variance ratio factor)
by following the framework designed in HyperChIP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estParamHyperChIP(
  cond,
  occupy.only = TRUE,
  prob = 0.1,
  subset = NULL,
  p_low = 0.01,
  p_up = 0.1,
  return.d0 = FALSE,
  .call = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estParamHyperChIP_+3A_cond">cond</code></td>
<td>
<p>A <code><a href="#topic+bioCond">bioCond</a></code> object with which a mean-variance curve
been associated (see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="estParamHyperChIP_+3A_occupy.only">occupy.only</code></td>
<td>
<p>A logical scalar. If it is <code>TRUE</code> (default),
only occupied genomic intervals are used for the parameter estimation
process. Otherwise, all intervals are used.</p>
</td></tr>
<tr><td><code id="estParamHyperChIP_+3A_prob">prob</code></td>
<td>
<p>The proportion of the intervals with the lowest (observed) mean
signal intensities that shall be used in the subsequent Winsorization
procedure (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="estParamHyperChIP_+3A_subset">subset</code></td>
<td>
<p>Alternatively, you can set this argument to a logical vector
to directly specify the intervals to be used in the Winsorization
procedure. This option overrides <code>occupy.only</code> and <code>prob</code>.</p>
</td></tr>
<tr><td><code id="estParamHyperChIP_+3A_p_low">p_low</code>, <code id="estParamHyperChIP_+3A_p_up">p_up</code></td>
<td>
<p>Lower- and upper-proportions of extreme values to be
Winsorized (see &quot;References&quot;). Each of them must be strictly larger than
0, and their sum must be strictly smaller than 1.</p>
</td></tr>
<tr><td><code id="estParamHyperChIP_+3A_return.d0">return.d0</code></td>
<td>
<p>A logical scalar. If set to <code>TRUE</code>, the function
simply returns the estimated number of prior degrees of freedom.</p>
</td></tr>
<tr><td><code id="estParamHyperChIP_+3A_.call">.call</code></td>
<td>
<p>Never care about this argument.</p>
</td></tr>
<tr><td><code id="estParamHyperChIP_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technically, <code>estParamHyperChIP</code> first derives a lower quantile of the
observed mean signal intensities in different genomic intervals based on the
<code>prob</code> argument. It then selects the intervals whose mean intensities
are less than or equal to the quantile. Finally, it applies the
Winsorization technique to the selected intervals to finish the parameter
estimation (see also &quot;References&quot;), by using the
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> function as the underlying engine.
</p>
<p><code>estParamHyperChIP</code> is primarily designed for coordinating with
<code><a href="#topic+varTestBioCond">varTestBioCond</a></code> to call hypervariable and lowly variable
intervals across samples. See &quot;Examples&quot; for the workflow of a
standard HyperChIP analysis.
</p>


<h3>Value</h3>

<p>By default, <code>estParamHyperChIP</code> returns the argument
<code><a href="#topic+bioCond">bioCond</a></code> object, whose
<code>"df.prior"</code> and <code>"ratio.var"</code> components
have been updated. If <code>return.d0</code> is set to <code>TRUE</code>,
it simply returns the estimated number of prior degrees of freedom.
</p>


<h3>References</h3>

<p>Tukey, J.W., <em>The future of data analysis.</em> The annals of
mathematical statistics, 1962. <strong>33</strong>(1): p. 1-67.
</p>
<p>Phipson, B., et al., <em>Robust Hyperparameter Estimation
Protects against Hypervariable Genes and Improves Power to Detect
Differential Expression.</em> Annals of Applied Statistics, 2016.
<strong>10</strong>(2): p. 946-963.
</p>
<p>Chen, H., et al., <em>HyperChIP: identification of hypervariable signals
across ChIP-seq or ATAC-seq samples.</em> Genome Biol, 2022.
<strong>23</strong>(1): p. 62.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve and
using a <code>fit.info</code> field to characterize it;
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> for estimating the number of
prior degrees of freedom and adjusting the variance ratio factors of
a set of <code>bioCond</code>s <em>in a robust manner</em>;
<code><a href="#topic+varTestBioCond">varTestBioCond</a></code>
for calling hypervariable and invariant intervals across ChIP-seq
samples contained in a <code>bioCond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Treat all the samples as independent and perform a HyperChIP analysis.

# Use a pseudo-reference profile as baseline in the MA normalization
# process.
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
norm &lt;- normalize(H3K27Ac, 4:8, 9:13, baseline = "pseudo-reference",
                  common.peak.regions = autosome)
plot(attr(norm, "MA.cor"), symbreaks = TRUE, margins = c(8, 8))

# Construct a bioCond.
cond &lt;- bioCond(norm[4:8], norm[9:13], occupy.num = 1,
                name = "all")

# Fit a mean-variance curve by using local regression.
cond &lt;- fitMeanVarCurve(list(cond), method = "local",
                        occupy.only = TRUE, args.lp = list(nn = 1))[[1]]
summary(cond)

# Apply the parameter estimation framework of HyperChIP.
cond &lt;- estParamHyperChIP(cond)
summary(cond)

# Perform statistical tests and visualize the results.
res &lt;- varTestBioCond(cond)
head(res)
hist(res$pval, breaks = 100, col = "red")
plot(res)

</code></pre>

<hr>
<h2 id='extendMeanVarCurve'>Extend the Application Scope of a Mean-Variance Curve</h2><span id='topic+extendMeanVarCurve'></span>

<h3>Description</h3>

<p><code>extendMeanVarCurve</code> associates the mean-variance curve of a
<code><a href="#topic+bioCond">bioCond</a></code> object with a set of other <code>bioCond</code>s.
This function is called most often when ChIP-seq samples stored in some
<code>bioCond</code>s have a low data regularity (due to, for example, a bad data
quality), and you don't want to include them for fitting a
mean-variance curve (see &quot;Examples&quot; below and also
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extendMeanVarCurve(
  conds,
  base.cond,
  occupy.only = TRUE,
  no.rep.rv = NULL,
  invariant = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extendMeanVarCurve_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects.</p>
</td></tr>
<tr><td><code id="extendMeanVarCurve_+3A_base.cond">base.cond</code></td>
<td>
<p>An extra <code>bioCond</code> object, from which the
mean-variance curve is obtained.</p>
</td></tr>
<tr><td><code id="extendMeanVarCurve_+3A_occupy.only">occupy.only</code></td>
<td>
<p>A logical scalar. If it is <code>TRUE</code> (default), only
occupied intervals are used to estimate variance ratio factors (see also
&quot;Details&quot;). Otherwise, all intervals are used.</p>
</td></tr>
<tr><td><code id="extendMeanVarCurve_+3A_no.rep.rv">no.rep.rv</code></td>
<td>
<p>A positive real specifying the variance ratio factor of
no-replicate conditions, if any. By default, it's set to be the
variance ratio factor of <code>base.cond</code>.</p>
</td></tr>
<tr><td><code id="extendMeanVarCurve_+3A_invariant">invariant</code></td>
<td>
<p>An optional non-negative real specifying the upper bound
of difference in mean signal intensity
for a genomic interval to be treated
as invariant between two conditions.
By default, intervals occupied by both
conditions are treated as invariant between them. Note that this
argument is only used when the number of prior degrees of freedom of
<code>base.cond</code> is 0 (see also &quot;Details&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technically, <code>extendMeanVarCurve</code> associates the mean-variance curve of
<code>base.cond</code> as well as its number of prior degrees of freedom to each
<code><a href="#topic+bioCond">bioCond</a></code> object in <code>conds</code>. Then, for each <code>bioCond</code>
in <code>conds</code>, its variance ratio factor is estimated accordingly (see
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for details). Note that, if the inherited
number of prior degrees of freedom is 0, the regular routine for estimating
variance ratio factors does not apply.
In this case, <code>extendMeanVarCurve</code>
utilizes an alternative strategy to estimate the variance ratio factor of
each <code>bioCond</code> via comparing it with the <code>base.cond</code> (see
<code><a href="#topic+varRatio">varRatio</a></code> for details).
</p>
<p>As mentioned, the prior df of each <code>bioCond</code> in
<code>conds</code> is inherited from <code>base.cond</code>. Now that there are
new <code>bioCond</code> objects that are associated with the same mean-variance
curve as is <code>base.cond</code>, you may want to re-assess its goodness of fit
incorporating these new datasets. See &quot;Examples&quot; below for using
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> to re-estimate the number of
prior degrees of freedom.
</p>
<p>Another scenario where <code>extendMeanVarCurve</code> could be useful is when
each of two <code>bioCond</code> objects to be compared has only one ChIP-seq
sample. To make it possible to estimate the variances of individual genomic
intervals, a simple solution is to treat the two samples as if they were
replicates. Thus, a mean-variance curve can be fitted accordingly and then
be associated with the two <code>bioCond</code> objects. See &quot;Examples&quot;
for a complete routine for
calling differential intervals between two conditions
with no replicate samples at all. Notably, this method is most suited when
the two conditions being compared are close. Otherwise, the method may lead
to an over-conserved <em>p</em>-value calculation.
</p>


<h3>Value</h3>

<p><code>extendMeanVarCurve</code> returns the argument list of
<code><a href="#topic+bioCond">bioCond</a></code> objects, each of which has an added (updated)
<code>fit.info</code> field constructed based on the mean-variance curve
associated with <code>base.cond</code>.
</p>
<p>Specifically, each returned <code>bioCond</code> inherits all the components
of its <code>fit.info</code> field from <code>base.cond</code> except the
<code>calls</code> and <code>ratio.var</code> (see <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>
for a detailed description of the structure of a <code>fit.info</code> field).
All the returned <code>bioCond</code>s will have a record of this function
call, and their variance ratio factors are
separately estimated.
</p>
<p>Besides, an attribute named <code>"no.rep.rv"</code> will be added to the
returned list if it's ever been used as the variance ratio factor
of the <code>bioCond</code>s without replicate samples.
</p>


<h3>Note</h3>

<p>You must normalize the <code><a href="#topic+bioCond">bioCond</a></code> objects in <code>conds</code>
together with the <code>base.cond</code> to the same level before invoking
this extension process. See
<code><a href="#topic+normalize">normalize</a></code> and <code><a href="#topic+normBioCond">normBioCond</a></code> for performing
MA normalization on ChIP-seq samples and <code>bioCond</code> objects,
respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object from a
set of ChIP-seq samples; <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a
mean-variance curve;
<code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code> for setting the mean-variance
curve of a set of <code>bioCond</code>s; <code><a href="#topic+plotMeanVarCurve">plotMeanVarCurve</a></code> for
plotting a mean-variance curve.
</p>
<p><code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for estimating number of prior degrees of
freedom and the corresponding variance ratio factors;
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> for a <em>robust</em> version of
<code>estimatePriorDf</code>;
<code><a href="#topic+varRatio">varRatio</a></code> for comparing the variance ratio factors of
two <code>bioCond</code>s.
</p>
<p><code><a href="#topic+distBioCond">distBioCond</a></code> for robustly measuring the distance between
each pair of ChIP-seq samples of a <code>bioCond</code> by considering its
mean-variance trend;
<code><a href="#topic+vstBioCond">vstBioCond</a></code> for applying a variance-stabilizing
transformation to signal intensities of samples in a <code>bioCond</code>.
</p>
<p><code><a href="#topic+diffTest.bioCond">diffTest</a></code> for calling differential
intervals between two <code>bioCond</code> objects; <code><a href="#topic+aovBioCond">aovBioCond</a></code>
for calling differential intervals across multiple <code>bioCond</code>s;
<code><a href="#topic+varTestBioCond">varTestBioCond</a></code> for calling hypervariable and invariant
intervals across ChIP-seq samples contained in a <code>bioCond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Fit a mean-variance curve based on the GM12891 cell line and associate
## the resulting curve with the other two cell lines.

# Perform the MA normalization and construct bioConds to represent cell
# lines.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Fit a mean-variance curve using only the GM12891 bioCond.
conds[2] &lt;- fitMeanVarCurve(conds[2], method = "parametric",
                            occupy.only = TRUE)
summary(conds[[2]])
plotMeanVarCurve(conds[2], subset = "occupied")

# Associate the resulting curve with the other two bioConds.
conds[c(1, 3)] &lt;- extendMeanVarCurve(conds[c(1, 3)], conds[[2]],
                                     occupy.only = TRUE)
summary(conds[[1]])
summary(conds[[3]])
plotMeanVarCurve(conds[3], subset = "occupied")

# Re-estimate number of prior degrees of freedom using all the bioConds,
# though the estimation result doesn't change in this example. But note the
# change of variance ratio factor of the bioCond without replicates (i.e.,
# GM12890).
conds2 &lt;- estimatePriorDf(conds, occupy.only = TRUE)
summary(conds2[[1]])

## Make a comparison between GM12891 and GM12892 cell lines using only their
## first replicates.

# Perform MA normalization and construct bioConds to represent the two cell
# lines.
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
norm &lt;- normalize(H3K27Ac, c(5, 7), c(10, 12),
                  common.peak.regions = autosome)
conds &lt;- list(GM12891 = bioCond(norm[5], norm[10], name = "GM12891"),
              GM12892 = bioCond(norm[7], norm[12], name = "GM12892"))

# Construct a "blind" bioCond that treats the two samples as replicates and
# fit a mean-variance curve accordingly. Only common peak regions of the two
# samples are considered to be occupied by the "blind" bioCond, and only
# these intervals are used for fitting the mean-variance curve. This setting
# is for capturing underlying non-differential intervals as accurately as
# possible and avoiding over-estimation of prior variances (i.e., variances
# read from a mean-variance curve).
conds$blind &lt;- bioCond(norm[c(5, 7)], norm[c(10, 12)], occupy.num = 2,
                       name = "blind")
conds[3] &lt;- fitMeanVarCurve(conds[3], method = "parametric",
                            occupy.only = TRUE, init.coef = c(0.1, 10))
summary(conds[[3]])
plotMeanVarCurve(conds[3], subset = "occupied")

# Associate the resulting mean-variance curve with the two cell lines.
conds[1:2] &lt;- extendMeanVarCurve(conds[1:2], conds[[3]])
summary(conds[[1]])
summary(conds[[2]])

# Perform differential tests between the two cell lines.
res &lt;- diffTest(conds[[1]], conds[[2]])
head(res)
MAplot(res, pval = 0.01)
abline(h = 0, lwd = 2, lty = 5, col = "green3")

</code></pre>

<hr>
<h2 id='fitMeanVarCurve'>Fit a Mean-Variance Curve</h2><span id='topic+fitMeanVarCurve'></span>

<h3>Description</h3>

<p>Given a set of <code><a href="#topic+bioCond">bioCond</a></code> objects, <code>fitMeanVarCurve</code>
robustly fits a curve capturing the mean-variance dependence across
the genomic intervals contained in them, by iteratively detecting outliers
and removing them from a regression procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitMeanVarCurve(
  conds,
  ratio.var = estimateVarRatio(conds),
  method = c("parametric fit", "local regression"),
  occupy.only = TRUE,
  range.residual = c(1e-04, 15),
  max.iter = 50,
  init.coef = NULL,
  args.lp = list(nn = 0.7),
  args.locfit = list(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitMeanVarCurve_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects, of which at least one
should contain replicate samples.</p>
</td></tr>
<tr><td><code id="fitMeanVarCurve_+3A_ratio.var">ratio.var</code></td>
<td>
<p>A vector giving the initial variance ratio factors of the
<code>bioCond</code>s. Elements are recycled if necessary. By default, it's
estimated by calling <code><a href="#topic+estimateVarRatio">estimateVarRatio</a></code>. See also
&quot;Variance Ratio Factor&quot; below.</p>
</td></tr>
<tr><td><code id="fitMeanVarCurve_+3A_method">method</code></td>
<td>
<p>A character string indicating the method to be used for
fitting the curve. Either <code>"parametric fit"</code> (default) or
<code>"local regression"</code>. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="fitMeanVarCurve_+3A_occupy.only">occupy.only</code></td>
<td>
<p>A logical value. If set to <code>FALSE</code>, all the genomic
intervals contained in the <code>bioCond</code>s are used to fit the curve. By
default, only the occupied intervals are used. See also
&quot;Methods for Fitting a Mean-Variance Curve&quot; below.</p>
</td></tr>
<tr><td><code id="fitMeanVarCurve_+3A_range.residual">range.residual</code></td>
<td>
<p>A length-two vector specifying the range of residuals
of non-outliers.</p>
</td></tr>
<tr><td><code id="fitMeanVarCurve_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iteration times allowed during the
fitting procedure.</p>
</td></tr>
<tr><td><code id="fitMeanVarCurve_+3A_init.coef">init.coef</code></td>
<td>
<p>An optional length-two vector specifying the initial
coefficients for applying the parametric fitting scheme. Only used when
<code>method</code> is <code>"parametric fit"</code>.
</p>
<p>In practice, chances are that <code>init.coef</code> is strictly required
for the fitting process to go smoothly, as the underlying algorithm
may fail to deduce a proper setting of initial coefficients (see
&quot;Examples&quot; below). In this case, try setting <code>init.coef</code> to
<code>c(0.1, 10)</code>, which is expected to suit most practical datasets.</p>
</td></tr>
<tr><td><code id="fitMeanVarCurve_+3A_args.lp">args.lp</code></td>
<td>
<p>A named list of extra arguments to <code><a href="locfit.html#topic+lp">lp</a></code>.
Only used when <code>method</code> is set to <code>"local regression"</code>. Note
the default value (see &quot;Methods for Fitting a Mean-Variance Curve&quot; below
for an explanation).</p>
</td></tr>
<tr><td><code id="fitMeanVarCurve_+3A_args.locfit">args.locfit</code></td>
<td>
<p>A named list of extra arguments to
<code><a href="locfit.html#topic+locfit">locfit</a></code>. Only used when <code>method</code> is set to
<code>"local regression"</code>. Note that, due to the internal
implementation, the argument <code>subset</code> to
<code><a href="locfit.html#topic+locfit">locfit</a></code> mustn't be specified in it.</p>
</td></tr>
<tr><td><code id="fitMeanVarCurve_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print processing messages during fitting the
mean-variance curve?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a regression of the variance of ChIP-seq signal
intensity across replicate samples, using the mean intensity as the only
predictor. Each genomic interval contained in each of the supplied
<code><a href="#topic+bioCond">bioCond</a></code>s that consists of two or more ChIP-seq samples serves
as an observation for the regression (the sample mean and sample variance of
the interval's signal intensities in the <code>bioCond</code> are used as the
predictor value and response, respectively).
</p>
<p>Note that <code>bioCond</code> objects must be normalized to the same level before
a mean-variance curve could be fitted for them. You can choose to either
normalize the involved ChIP-seq samples all together (see
<code><a href="#topic+normalize">normalize</a></code>) or perform the normalization at the level of
<code>bioCond</code> objects (see <code><a href="#topic+normBioCond">normBioCond</a></code> and also &quot;Examples&quot;
below).
</p>


<h3>Value</h3>

<p><code>fitMeanVarCurve</code> returns the argument list of
<code><a href="#topic+bioCond">bioCond</a></code> objects, each of which has an added (updated)
<code>fit.info</code> field describing its mean-variance dependence. The field
is itself a list consisting of the following components:
</p>

<dl>
<dt><code>calls</code></dt><dd><p>The two function calls for associating a mean
variance curve with this <code>bioCond</code> and estimating the related
parameters, respectively. The latter is only present if you have
made an explicit call to some function (e.g.,
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code>) for performing the parameter
estimation.</p>
</dd>
<dt><code>method</code></dt><dd><p>Method used for fitting the mean-variance
curve.</p>
</dd>
<dt><code>predict</code></dt><dd><p>A function representing the fitted curve,
which accepts a vector of means and returns the predicted
variances.</p>
</dd>
<dt><code>mvcID</code></dt><dd><p>ID of the fitted mean-variance curve.</p>
</dd>
<dt><code>df.prior</code></dt><dd><p>Number of prior degrees of freedom
assessing the goodness of fit of the mean-variance curve.</p>
</dd>
<dt><code>ratio.var</code></dt><dd><p>Variance ratio factor of this
<code>bioCond</code>.</p>
</dd>
</dl>

<p>Each <code>bioCond</code> object in the returned list has the same values of
all these components but the <code>ratio.var</code>.
</p>
<p><code>mvcID</code> is used to label each fitted mean-variance curve. Each
call to <code>fitMeanVarCurve</code> results in a unique ID. Thus we assert
that different <code>bioCond</code> objects are associated with the same
mean-variance curve if and only if they have the same <code>mvcID</code>. This
is useful if you are to
call differential intervals between two conditions
via <code><a href="#topic+diffTest.bioCond">diffTest</a></code>, which requires the two
<code>bioCond</code> objects being compared are associated with the same
mean-variance curve.
</p>
<p>Besides, if there exist <code>bioCond</code> objects that contain only one
ChIP-seq sample, an attribute named <code>"no.rep.rv"</code> will be added to
the returned list, recording the variance ratio factor of no-replicate
conditions. Note that the method for estimating the variance ratio
factor of no-replicate conditions is specifically designed (see
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for details).
</p>


<h3>Variance Ratio Factor</h3>

<p><code>fitMeanVarCurve</code> applies a regression
process to the observed means and variances of signal intensities of
genomic intervals. The regression result serves as a model capturing the
mean-variance trend across intervals.
Notably, each genomic interval in each
<code><a href="#topic+bioCond">bioCond</a></code> object that contains replicate samples serves as
an observation point for the regression.
</p>
<p>Variance ratio factor is designed to account for the global difference
in variation level of signal intensities between conditions. Each
<code>bioCond</code> has its own variance ratio factor, and method has been
developed to robustly estimate the relative (scaled) variance ratio
factors of a given set of <code>bioCond</code>s
(see <code><a href="#topic+estimateVarRatio">estimateVarRatio</a></code> for details).
Technically, observed variances from each <code>bioCond</code> are
scaled based on the corresponding (relative) variance ratio factor, so
that the scaled variances from different <code>bioCond</code>s are comparable
to each other. Finally, the scaled variances from all the provided
<code>bioCond</code>s are pooled together constituting the vector of responses
for the regression process. Note that the variance ratio factors will be
adjusted afterwards, according to the fitted mean-variance curve and its
goodness of fit (see &quot;Assessing Goodness of Fit&quot; below).
</p>


<h3>Methods for Fitting a Mean-Variance Curve</h3>

<p>There are currently two
candidate methods for performing the regression:
<code>"parametric fit"</code> (default) and <code>"local regression"</code>.
Besides, the argument <code>occupy.only</code> controls whether to use all
genomic intervals or only the occupied ones for the regression process.
</p>
<p>Typically, ChIP-seq signal intensities at
non-occupied intervals are much
lower than those at occupied ones. Accordingly, variation levels of the
former are significantly higher than the latter (provided that a log
transformation has been applied to raw read counts before performing
the normalization, which is the default setting of
<code><a href="#topic+normalize">normalize</a></code>). This is because,
for the genomic intervals having
a low-level abundance of ChIP-seq reads, only a little fluctuation of
read count could give rise to a dramatic fold change. If a mean-variance
scatter plot is drawn mapping all genomic intervals to a plane, the
points corresponding to non-occupied intervals will be largely separated
from those of occupied intervals.
</p>
<p>In practice, the ChIP-seq signals located in
non-occupied intervals result
primarily from background noise and therefore have much lower
signal-to-noise ratios than those in occupied intervals. As a result,
signals observed in the two types of intervals
almost always have distinct
data characteristics from one another. In particular, the mean-variance
dependence associated with non-occupied intervals is not as regular as
observed from occupied intervals. In light of these observations, the
recommended setting of <code>occupy.only</code> may be different across calls
of <code>fitMeanVarCurve</code> depending on the exact <code>method</code> chosen
for performing the regression. See the following for details.
</p>
<p>For the method of <code>"parametric fit"</code>, it adopts the parametric form
of <code class="reqn">var = c1 + c2 / (2 ^ mean)</code>, where <code class="reqn">c1</code> and <code class="reqn">c2</code> are
coefficients to be estimated. More specifically, it fits a gamma-family
generalized linear model with the identity link. The form is
deduced by assuming a quadratic mean-variance relationship for raw read
counts and applying the delta method to log2 transformation (see also
&quot;References&quot;). When using this method, one typically sets
<code>occupy.only</code> to <code>TRUE</code> (the default). Otherwise, the
GLM fitting procedure may fail to estimate the coefficients, or the
estimation results may be significantly biased towards the
characteristics of ChIP-seq signals at non-occupied intervals (which is
undesired since these signals are mostly background noises). Note also
that applying this method is most recommended when ChIP-seq samples
within each single <code><a href="#topic+bioCond">bioCond</a></code> are associated with a low level
of signal variation (e.g., when these samples are biological replicates
of a cell line; see also &quot;Examples&quot; below),
since in such cases ChIP-seq data should be of high regularity
and, thus, the parametric form could be safely expected to hold.
Moreover, as the variation level across ChIP-seq samples increases,
the possibility becomes higher that the GLM fitting procedure fails.
</p>
<p>For the method of <code>"local regression"</code>, it directly passes the
observed means and scaled variances to the <code><a href="locfit.html#topic+locfit">locfit</a></code>
function, specifying the <code>family</code> to be <code>"gamma"</code>. When using
this method, setting <code>occupy.only</code> to <code>TRUE</code> almost certainly
leads to an exaggerated variance prediction for small signal intensities
(due to the underlying algorithm for extrapolation)
and, thus, a reduction in statistical power for detecting differential
intervals between conditions. On the other hand,
involving non-occupied intervals
in the fitting process might result in an underestimated number of prior
degrees of freedom (see &quot;Assessing Goodness of Fit&quot; below). This is
because the ChIP-seq signals located in non-occupied intervals generally
have low signal-to-noise ratios, and are therefore associated with less
data regularity than the signals in occupied intervals. One way to
compensate that is to re-estimate the prior df using
only the occupied intervals after fitting the mean-variance curve (see
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> and &quot;Examples&quot; below), which is also the
most recommended strategy for employing a local regression. Note also
that smoothness of the resulting curve could be adjusted by modifying
the <code>nn</code> variable in <code>args.lp</code> (see also
<code><a href="locfit.html#topic+lp">lp</a></code>). By default, <code>nn=0.7</code> is adopted, which
is also the default setting of <code><a href="locfit.html#topic+lp">lp</a></code> at the time of
developing this package.
</p>


<h3>Iteration Scheme for a Robust Regression</h3>

<p>Whichever method is
selected, <code>fitMeanVarCurve</code> adopts an iteration scheme to enhance
the robustness of fitting the mean-variance trend. More specifically,
it iteratively detects and removes outliers from a regression procedure.
The process converges as soon as the set of outliers fixes.
Residual of each observation is calculated as the ratio of its observed
variance to the fitted one, and those observations with a residual
falling outside <code>range.residual</code> shall be considered as outliers.
The default value of <code>range.residual</code> works well for chi-squared
distributions with a broad range of numbers of degrees of freedom (see
also &quot;References&quot;).
</p>


<h3>Assessing Goodness of Fit</h3>

<p>Each fitted mean-variance curve is
associated with a quantity assessing its goodness of fit, which is the
number of prior degrees of freedom. Roughly speaking, the closer the
observed mean-variance points are to the curve, the larger the resulting
prior df of the curve, and we get more confidence in the curve.
To be noted, the initial variance ratio factors for scaling the sample
variances from different <code><a href="#topic+bioCond">bioCond</a></code> objects will be adjusted
according to the estimated prior df (based on the
underlying distributional theory).
These adjusted variance ratio factors are
exactly the ones stored in the returned <code>bioCond</code> objects.
See <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for details about estimating prior
df and accordingly adjusting variance ratio factors.
Note also that <code>fitMeanVarCurve</code>
uses exactly the set of intervals that
are utilized for fitting the mean-variance curve to estimate the prior
df and adjust the variance ratio factors (the set is controlled by the
argument <code>occupy.only</code>; see also
&quot;Methods for Fitting a Mean-Variance Curve&quot; above).
</p>
<p>Prior df is primarily used for the following
differential analysis. We call a variance read from a mean-variance
curve a prior one. In cases where you use
<code><a href="#topic+diffTest.bioCond">diffTest</a></code> to call differential intervals
between two <code>bioCond</code>s, the final variance estimate associated
with each individual interval is obtained by averaging its observed
and prior variances, weighted by their respective numbers of degrees
of freedom.
</p>


<h3>Extending the Application Scope of a Mean-Variance Curve</h3>

<p>With a
set of <code><a href="#topic+bioCond">bioCond</a></code> objects at hand, you might want to use only
part of them to fit the mean-variance curve.
For example, suppose ChIP-seq samples
stored in some <code>bioCond</code> objects are associated with a low data
regularity (due to, e.g., bad sample qualities), and you don't
want to include these samples when fitting the curve. One way to work
around it is to exclude the <code>bioCond</code> objects from the fitting
process, extend the application scope of the fitted curve (via
<code><a href="#topic+extendMeanVarCurve">extendMeanVarCurve</a></code>) so that it applies to the excluded
<code>bioCond</code>s as well, and (optionally) re-assess the overall goodness
of fit via <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> (see also the &quot;Examples&quot;
given for <code><a href="#topic+extendMeanVarCurve">extendMeanVarCurve</a></code>).
</p>
<p>There is another scenario where extending a mean-variance curve could be
useful. In practice, chances are that only one ChIP-seq sample is
available for each of two conditions to be compared. To make the
analysis possible, one way is to treat the two samples as replicates and
fit a mean-variance curve accordingly. The fitted curve can then be
associated with the two conditions each containing a single sample (via
<code><a href="#topic+extendMeanVarCurve">extendMeanVarCurve</a></code>),
and differential intervals between them
can be subsequently called following a regular routine (see &quot;Examples&quot;
provided in <code><a href="#topic+extendMeanVarCurve">extendMeanVarCurve</a></code>).
To be noted, this method is most suited when the two
conditions being compared are close. Otherwise, the method may lead to
an over-conserved <em>p</em>-value calculation.
</p>


<h3>References</h3>

<p>Smyth, G.K., <em>Linear models and empirical bayes methods for assessing
differential expression in microarray experiments.</em> Stat Appl Genet Mol
Biol, 2004. <strong>3</strong>: p. Article3.
</p>
<p>Anders, S. and W. Huber, <em>Differential expression analysis for sequence
count data.</em> Genome Biol, 2010. <strong>11</strong>(10): p. R106.
</p>
<p>Law, C.W., et al., <em>voom: Precision weights unlock linear model
analysis tools for RNA-seq read counts.</em> Genome Biol, 2014.
<strong>15</strong>(2): p. R29.
</p>
<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing groups of
ChIP-seq samples.</em> Genome Res, 2021. <strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object from a
set of ChIP-seq samples; <code><a href="#topic+normalize">normalize</a></code> for performing an MA
normalization on ChIP-seq samples; <code><a href="#topic+normalizeBySizeFactors">normalizeBySizeFactors</a></code>
for normalizing ChIP-seq samples based on their size factors;
<code><a href="#topic+normBioCond">normBioCond</a></code> for performing an MA normalization on
<code>bioCond</code> objects; <code><a href="#topic+normBioCondBySizeFactors">normBioCondBySizeFactors</a></code> for
normalizing <code>bioCond</code> objects based on their size factors.
</p>
<p><code><a href="#topic+estimateVarRatio">estimateVarRatio</a></code> for estimating the relative variance
ratio factors of a set of <code>bioCond</code>s; <code><a href="#topic+varRatio">varRatio</a></code> for a
formal description of variance ratio factor;
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for estimating the number of prior degrees
of freedom as well as adjusting variance ratio factors accordingly;
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> for a <em>robust</em> version of
<code>estimatePriorDf</code>.
</p>
<p><code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code> for setting the mean-variance curve of a
set of <code>bioCond</code> objects; <code><a href="#topic+extendMeanVarCurve">extendMeanVarCurve</a></code> for
extending the application scope of a fitted mean-variance curve to the
<code>bioCond</code>s not used to fit it; <code><a href="#topic+plotMeanVarCurve">plotMeanVarCurve</a></code> for
plotting a mean-variance curve.
</p>
<p><code><a href="#topic+distBioCond">distBioCond</a></code> for robustly measuring the distances between
ChIP-seq samples in a <code>bioCond</code> by considering its mean-variance
trend; <code><a href="#topic+vstBioCond">vstBioCond</a></code> for applying a variance-stabilizing
transformation to signal intensities of samples in a <code>bioCond</code>.
</p>
<p><code><a href="#topic+diffTest.bioCond">diffTest</a></code> for calling differential
intervals between two <code>bioCond</code> objects; <code><a href="#topic+aovBioCond">aovBioCond</a></code>
for calling differential intervals across multiple <code>bioCond</code>s;
<code><a href="#topic+varTestBioCond">varTestBioCond</a></code> for calling hypervariable and invariant
intervals across ChIP-seq samples contained in a <code>bioCond</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Fit a mean-variance curve treating each cell line (i.e., individual) as a
## biological condition.

# Perform the MA normalization and construct bioConds to represent cell
# lines.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Variations in ChIP-seq signals across biological replicates of a cell line
# are generally of a low level, and their relationship with the mean signal
# intensities is expected to be well modeled by the presumed parametric
# form.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
summary(conds[[1]])
plotMeanVarCurve(conds, subset = "occupied")

## Not run: 
# Sometimes the parametric fitting algorithm cannot automatically deduce
# proper starting values for estimating the coefficients.
fitMeanVarCurve(conds[3], method = "parametric", occupy.only = TRUE)

## End(Not run)

# In such cases, explicitly specify the initial values of the coefficients.
fitMeanVarCurve(conds[3], method = "parametric", occupy.only = TRUE,
                init.coef = c(0.1, 10))

## Fit a mean-variance curve treating each gender as a biological condition,
## and each individual a replicate.

# Group individuals into bioConds based on their genders.
female &lt;- cmbBioCond(conds[c(1, 3)], name = "female")
male &lt;- cmbBioCond(conds[2], name = "male")

# The dependence of variance of ChIP-seq signal intensity across individuals
# on the mean signal intensity is not as regular as in the case for modeling
# biological replicates of cell lines. Better use the local regression to
# adaptively capture the mean-variance trend.
genders &lt;- list(female = female, male = male)
genders1 &lt;- fitMeanVarCurve(genders, method = "local", occupy.only = TRUE)
genders2 &lt;- fitMeanVarCurve(genders, method = "local", occupy.only = FALSE)

# Suppose the local regression is performed using only the occupied genomic
# intervals as input. Good chances are that the extrapolation algorithm
# implemented in the regression method will produce over-estimated variances
# for the non-occupied intervals.
plotMeanVarCurve(genders1, subset = "all")
plotMeanVarCurve(genders2, subset = "all")
plotMeanVarCurve(genders1, subset = "non-occupied")
plotMeanVarCurve(genders2, subset = "non-occupied")

# On the other hand, applying the local regression on all genomic intervals
# may considerably reduce the estimated number of prior degrees of freedom
# associated with the fitted mean-variance curve, as ChIP-seq signals in the
# non-occupied intervals are generally of less data regularity compared with
# those in the occupied intervals.
summary(genders1$female)
summary(genders2$female)

# To split the difference, fit the mean-variance curve on all genomic
# intervals and re-estimate the number of prior degrees of freedom using
# only the occupied intervals, which is also the most recommended strategy
# in practice.
genders3 &lt;- estimatePriorDf(genders2, occupy.only = TRUE)
plotMeanVarCurve(genders3, subset = "all")
plotMeanVarCurve(genders3, subset = "non-occupied")
summary(genders3$female)

</code></pre>

<hr>
<h2 id='H3K27Ac'>ChIP-seq Samples for H3K27Ac in Human Lymphoblastoid Cell Lines</h2><span id='topic+H3K27Ac'></span>

<h3>Description</h3>

<p>Benefiting from the associated ChIP-seq samples, this dataset profiles
H3K27Ac levels along the whole genome for multiple human
lymphoblastoid cell lines, each derived from a separate person.
Specifically, a set of genomic intervals of around the same size (2 kb)
has been systematically selected to thoroughly cover the part of the genome
that is enriched with reads in at least one of the ChIP-seq samples. And
for each of these intervals, this dataset records its raw read count and
enrichment status in each of the samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H3K27Ac
</code></pre>


<h3>Format</h3>

<p><code>H3K27Ac</code> is a data frame that records the features of 73,828
non-overlapping genomic intervals regarding the H3K27Ac ChIP-seq signals
in multiple human lymphoblastoid cell lines. It contains the following
variables:
</p>

<dl>
<dt><code>chrom, start, end</code></dt><dd><p>Genomic coordinate of each interval.
Note that these coordinates are 0-based and correspond to the hg19
genome assembly.</p>
</dd>
<dt><code>cellLine_H3K27Ac_num.read_cnt</code></dt><dd><p>Each variable whose name
is of this form records the number of reads from a ChIP-seq sample
that fall within each genomic interval. For example,
<code>GM12891_H3K27Ac_2.read_cnt</code> corresponds to the 2nd
biological replicate of a ChIP-seq experiment that targets H3K27Ac
in a cell line named GM12891.</p>
</dd>
<dt><code>cellLine_H3K27Ac_num.occupancy</code></dt><dd><p>Each variable whose
name is of this form records the enrichment status of each genomic
interval in a ChIP-seq sample. An enrichment status of 1 indicates
that the interval is enriched with reads in the sample; an
enrichment status of 0 indicates otherwise. In practice, enrichment
status of a genomic interval in a certain ChIP-seq sample could be
determined by its overlap with the peaks (see &quot;References&quot; below) of
the sample. Note also that variables of this class correspond to the
variables of raw read counts one by one.</p>
</dd>
</dl>

<p>Each cell line derives from a separate individual of the Caucasian
population. Use <code>attr(H3K27Ac, "metaInfo")</code> to get a data frame
that records meta information about the involved individuals.
</p>


<h3>Source</h3>

<p>Raw sequencing data were obtained from Kasowski et al., 2013 (see
&quot;References&quot; below). Adapters and low-sequencing-quality bases were
trimmed from 3' ends of reads using <code>trim_galore</code>. The
resulting reads were then aligned to the hg19 reference genome
by <code>bowtie</code>. <code>MACS</code> was utilized to call peaks
for each ChIP-seq sample.
</p>
<p>Finally, <code>MAnorm2_utils</code> was exploited to integrate the alignment
results as well as peaks of ChIP-seq samples into this regular
table. <code>MAnorm2_utils</code> is specifically designed to create input
tables of <code>MAnorm2</code>.
See the <a href="https://github.com/tushiqi/MAnorm2_utils">home page of
MAnorm2_utils</a> for more information about it. It has also been uploaded
to the <a href="https://pypi.org/">PyPI repository</a> as a Python package.
</p>


<h3>References</h3>

<p>Zhang, Y., et al., <em>Model-based analysis of ChIP-Seq (MACS).</em> Genome
Biol, 2008. <strong>9</strong>(9): p. R137.
</p>
<p>Kasowski, M., et al., <em>Extensive variation in chromatin states across
humans.</em> Science, 2013. <strong>342</strong>(6159): p. 750-2.
</p>

<hr>
<h2 id='intervalMeans'>Deduce the Sample Mean Signal Intensity</h2><span id='topic+intervalMeans'></span>

<h3>Description</h3>

<p>Given a matrix of normalized signal intensities and the inverse of the
corresponding structure matrices, <code>intervalMeans</code> returns the sample
mean signal intensity of each genomic interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervalMeans(x, inv.strMatrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intervalMeans_+3A_x">x</code></td>
<td>
<p>A matrix of normalized signal intensities, where each row
represents an interval and each column a sample.</p>
</td></tr>
<tr><td><code id="intervalMeans_+3A_inv.strmatrix">inv.strMatrix</code></td>
<td>
<p>A list of inversed structure matrices corresponding
to the intervals. Elements of it are recycled if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the sample mean signal intensities.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating an R object representing a
biological condition, and <code><a href="#topic+setWeight">setWeight</a></code> for modifying the
structure matrices of such an object.
</p>

<hr>
<h2 id='intervalVars'>Sample Variance of Replicated Signal Intensities</h2><span id='topic+intervalVars'></span>

<h3>Description</h3>

<p>Given a matrix of normalized signal intensities and the inverse of the
corresponding structure matrices, <code>intervalVars</code> returns the sample
variance of signal intensities of each genomic interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervalVars(x, inv.strMatrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intervalVars_+3A_x">x</code></td>
<td>
<p>A matrix of normalized signal intensities, where each row
represents an interval and each column a sample.</p>
</td></tr>
<tr><td><code id="intervalVars_+3A_inv.strmatrix">inv.strMatrix</code></td>
<td>
<p>A list of inversed structure matrices corresponding
to the intervals. Elements of it are recycled if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the sample variances.
</p>


<h3>Note</h3>

<p>For the <code class="reqn">i</code>th interval, <code class="reqn">ti * Si</code> is the covariance matrix
of the signal intensities of the interval, where <code class="reqn">ti</code> is a scalar
quantifying the variation level of these signal intensities (under this
biological condition), and <code class="reqn">Si</code> is the interval's structure
matrix (under this biological condition). <code>intervalVars</code> returns
exactly the sample estimate of each <code class="reqn">ti</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating an R object representing a
biological condition, and <code><a href="#topic+setWeight">setWeight</a></code> for modifying the
structure matrices of such an object.
</p>

<hr>
<h2 id='inv.trigamma'>Inversion of Trigamma Function</h2><span id='topic+inv.trigamma'></span>

<h3>Description</h3>

<p><code>inv.trigamma</code> implements the Newton iteration for solving, given
<code>x</code>, the equation for <code>y</code>: <code><a href="base.html#topic+trigamma">trigamma</a>(y) = x</code>.
See appendix of the <code>limma</code> paper (see &quot;References&quot;) for a theoretical
deduction of the method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv.trigamma(x, eps = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv.trigamma_+3A_x">x</code></td>
<td>
<p>A positive numeric scalar.</p>
</td></tr>
<tr><td><code id="inv.trigamma_+3A_eps">eps</code></td>
<td>
<p>The required precision of the solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The solution, which is also a positive numeric scalar.
</p>


<h3>References</h3>

<p>Smyth, G.K., <em>Linear models and empirical bayes methods for
assessing differential expression in microarray experiments.</em> Stat Appl
Genet Mol Biol, 2004. <strong>3</strong>: p. Article3.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+trigamma">trigamma</a></code> for the trigamma function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- trigamma(1:6)
vapply(x, inv.trigamma, numeric(1))

</code></pre>

<hr>
<h2 id='isSymPosDef'>Is a Real Matrix Symmetric and Positive Definite?</h2><span id='topic+isSymPosDef'></span>

<h3>Description</h3>

<p><code>isSymPosDef</code> checks if a real matrix is symmetric and positive
definite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSymPosDef(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isSymPosDef_+3A_x">x</code></td>
<td>
<p>A real matrix.</p>
</td></tr>
<tr><td><code id="isSymPosDef_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="base.html#topic+isSymmetric">isSymmetric</a></code> for deciding
on matrix symmetry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is both symmetric and positive definite.
<code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+isSymmetric">isSymmetric</a></code> for testing if a matrix is
symmetric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 0.5, 0.5, 2), nrow = 2)
isSymPosDef(x)

# Not positive definite.
x &lt;- matrix(c(1, 0.5, 0.5, 0.2), nrow = 2)
isSymPosDef(x)

</code></pre>

<hr>
<h2 id='MA.pcc'>Deduce Pearson Correlation Coefficient between M &amp; A Values</h2><span id='topic+MA.pcc'></span>

<h3>Description</h3>

<p>Deduce Pearson Correlation Coefficient between M &amp; A Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MA.pcc(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MA.pcc_+3A_x">x</code>, <code id="MA.pcc_+3A_y">y</code></td>
<td>
<p>Two numeric vectors representing the signal intensities of two
samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Safely deduced PCC between <code>(x + y)</code> and <code>(y - x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Private functions involved.

MA.pcc(1:4, 1:4 + c(1, 2, 4, 9))

# The robustness.
MA.pcc(1, 0)
MA.pcc(1:4, 2:5)

## End(Not run)

</code></pre>

<hr>
<h2 id='MAnorm2'>MAnorm2: a Package for Normalizing and Comparing ChIP-seq Samples</h2><span id='topic+MAnorm2'></span>

<h3>Description</h3>

<p><code>MAnorm2</code> provides a robust method for normalizing ChIP-seq signals
across individual samples or groups of samples. It also designs a
self-contained system of statistical models for calling differential
ChIP-seq signals between two or more biological conditions as well as
for calling hypervariable ChIP-seq signals across samples.
</p>


<h3>Details</h3>

<p>For a typical differential analysis between two biological conditions
starting with raw read counts, the standard workflow is to
sequentially call <code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+bioCond">bioCond</a></code>,
<code><a href="#topic+normBioCond">normBioCond</a></code>,
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>, and <code><a href="#topic+diffTest.bioCond">diffTest</a></code>
(see the following sections for a rough description of each of these
functions).
Examples given for <code><a href="#topic+diffTest.bioCond">diffTest</a></code> provide
specific demonstrations.
<code>MAnorm2</code> is also capable of calling differential ChIP-seq signals
across multiple
biological conditions. See the section below titled &quot;Comparing ChIP-seq
Signals across Multiple Conditions&quot;.
</p>
<p>For a hypervariable ChIP-seq analysis
starting with raw read counts, the standard workflow is to
sequentially call <code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+bioCond">bioCond</a></code>,
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>, <code><a href="#topic+estParamHyperChIP">estParamHyperChIP</a></code>, and
<code><a href="#topic+varTestBioCond">varTestBioCond</a></code>.
Examples given for <code><a href="#topic+estParamHyperChIP">estParamHyperChIP</a></code> provide a
specific demonstration.
</p>
<p>The following sections classify the majority of <code>MAnorm2</code> functions
into different utilities. Basically, these sections also represent the order
in which the functions are supposed to be called for a
differential/hypervariable
analysis. For a complete list of <code>MAnorm2</code> functions, use
<code>library(help = "MAnorm2")</code>.
</p>


<h3>Normalizing ChIP-seq Signals across Individual Samples</h3>


<dl>
<dt><code><a href="#topic+normalize">normalize</a></code></dt><dd><p>Perform MA Normalization on a Set of
ChIP-seq Samples</p>
</dd>
<dt><code><a href="#topic+normalizeBySizeFactors">normalizeBySizeFactors</a></code></dt><dd><p>Normalize ChIP-seq
Samples by Their Size Factors</p>
</dd>
<dt><code><a href="#topic+estimateSizeFactors">estimateSizeFactors</a></code></dt><dd><p>Estimate Size Factors of
ChIP-seq Samples</p>
</dd>
<dt><code><a href="#topic+MAplot.default">MAplot.default</a></code></dt><dd><p>Create an MA Plot on
Two Individual ChIP-seq Samples</p>
</dd>
</dl>



<h3>Creating <code>bioCond</code> Objects to Represent Biological Conditions</h3>


<dl>
<dt><code><a href="#topic+bioCond">bioCond</a></code></dt><dd><p>Create a <code>bioCond</code> Object to
Group ChIP-seq Samples</p>
</dd>
<dt><code><a href="#topic+setWeight">setWeight</a></code></dt><dd><p>Set the Weights of Signal Intensities
Contained in a <code>bioCond</code></p>
</dd>
<dt><code><a href="#topic+normBioCond">normBioCond</a></code></dt><dd><p>Perform MA Normalization on a Set
of <code>bioCond</code> Objects</p>
</dd>
<dt><code><a href="#topic+normBioCondBySizeFactors">normBioCondBySizeFactors</a></code></dt><dd><p>Normalize
<code>bioCond</code> Objects by Their Size Factors</p>
</dd>
<dt><code><a href="#topic+cmbBioCond">cmbBioCond</a></code></dt><dd><p>Combine a Set of <code>bioCond</code>
Objects into a Single <code>bioCond</code></p>
</dd>
<dt><code><a href="#topic+MAplot.bioCond">MAplot.bioCond</a></code></dt><dd><p>Create an MA Plot on Two
<code>bioCond</code> Objects</p>
</dd>
<dt><code><a href="#topic+summary.bioCond">summary.bioCond</a></code></dt><dd><p>Summarize a <code>bioCond</code>
Object</p>
</dd>
</dl>



<h3>Modeling Mean-Variance Trend</h3>


<dl>
<dt><code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code></dt><dd><p>Fit a Mean-Variance Curve</p>
</dd>
<dt><code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code></dt><dd><p>Set the Mean-Variance Curve
of a Set of <code>bioCond</code> Objects</p>
</dd>
<dt><code><a href="#topic+extendMeanVarCurve">extendMeanVarCurve</a></code></dt><dd><p>Extend the Application
Scope of a Mean-Variance Curve</p>
</dd>
<dt><code><a href="#topic+plotMeanVarCurve">plotMeanVarCurve</a></code></dt><dd><p>Plot a Mean-Variance Curve</p>
</dd>
<dt><code><a href="#topic+plotMVC">plotMVC</a></code></dt><dd><p>Plot a Mean-Variance Curve on a
Single <code>bioCond</code> Object</p>
</dd>
<dt><code><a href="#topic+estimateVarRatio">estimateVarRatio</a></code></dt><dd><p>Estimate Relative Variance
Ratio Factors of <code>bioCond</code> Objects</p>
</dd>
<dt><code><a href="#topic+varRatio">varRatio</a></code></dt><dd><p>Compare Variance Ratio Factors of
Two <code>bioCond</code> Objects</p>
</dd>
<dt><code><a href="#topic+distBioCond">distBioCond</a></code></dt><dd><p>Quantify the Distance between
Each Pair of Samples in a <code>bioCond</code></p>
</dd>
<dt><code><a href="#topic+vstBioCond">vstBioCond</a></code></dt><dd><p>Apply a Variance-Stabilizing
Transformation to a <code>bioCond</code></p>
</dd>
</dl>



<h3>Assessing the Goodness of Fit of Mean-Variance Curves</h3>


<dl>
<dt><code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code></dt><dd><p>Assess the Goodness of Fit of
Mean-Variance Curves</p>
</dd>
<dt><code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code></dt><dd><p>Assess the Goodness of
Fit of Mean-Variance Curves in a Robust Manner</p>
</dd>
<dt><code><a href="#topic+setPriorDf">setPriorDf</a></code></dt><dd><p>Set the Number of Prior Degrees of
Freedom of Mean-Variance Curves</p>
</dd>
<dt><code><a href="#topic+setPriorDfRobust">setPriorDfRobust</a></code></dt><dd><p>The Robust Counterpart of
<code>setPriorDf</code></p>
</dd>
<dt><code><a href="#topic+setPriorDfVarRatio">setPriorDfVarRatio</a></code></dt><dd><p>Set the Number of Prior
Degrees of Freedom and Variance Ratio Factors</p>
</dd>
<dt><code><a href="#topic+estParamHyperChIP">estParamHyperChIP</a></code></dt><dd><p>The Parameter Estimation
Framework of HyperChIP</p>
</dd>
</dl>



<h3>Calling Differential ChIP-seq Signals between Two Conditions</h3>


<dl>
<dt><code><a href="#topic+diffTest.bioCond">diffTest.bioCond</a></code></dt><dd><p>Compare Two
<code>bioCond</code> Objects</p>
</dd>
<dt><code><a href="#topic+MAplot.diffBioCond">MAplot.diffBioCond</a></code></dt><dd><p>Create an MA Plot on
Results of Comparing Two <code>bioCond</code> Objects</p>
</dd>
</dl>



<h3>Comparing ChIP-seq Signals across Multiple Conditions</h3>


<dl>
<dt><code><a href="#topic+aovBioCond">aovBioCond</a></code></dt><dd><p>Perform a Moderated Analysis of
Variance on <code>bioCond</code> Objects</p>
</dd>
<dt><code><a href="#topic+plot.aovBioCond">plot.aovBioCond</a></code></dt><dd><p>Plot an <code>aovBioCond</code>
Object</p>
</dd>
<dt><code><a href="#topic+varTestBioCond">varTestBioCond</a></code></dt><dd><p>Call Hypervariable and
Invariant Intervals for a <code>bioCond</code></p>
</dd>
<dt><code><a href="#topic+plot.varTestBioCond">plot.varTestBioCond</a></code></dt><dd><p>Plot a
<code>varTestBioCond</code> Object</p>
</dd>
</dl>



<h3>Author and Maintainer</h3>

<p>Shiqi Tu &lt;<a href="mailto:tushiqi@picb.ac.cn">tushiqi@picb.ac.cn</a>&gt;
</p>


<h3>References</h3>

<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing
groups of ChIP-seq samples.</em> Genome Res, 2021.
<strong>31</strong>(1): p. 131-145.
</p>
<p>Chen, H., et al., <em>HyperChIP for identifying hypervariable signals
across ChIP/ATAC-seq samples.</em> bioRxiv, 2021: p. 2021.07.27.453915.
</p>

<hr>
<h2 id='MAplot'>Generic MA Plotting</h2><span id='topic+MAplot'></span><span id='topic+MAplot.default'></span>

<h3>Description</h3>

<p><code>MAplot</code> is a generic function used to produce an MA plot. Described
here is the default method for plotting on (normalized) signal intensities
of two ChIP-seq samples (see also <code><a href="#topic+normalize">normalize</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAplot(x, ...)

## Default S3 method:
MAplot(
  x,
  y,
  occupy.x,
  occupy.y,
  col = NULL,
  pch = NULL,
  ylim = c(-6, 6),
  xlab = "A value",
  ylab = "M value",
  args.legend = list(x = "topright", legend = c("common", "y specific", "x specific",
    "others")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAplot_+3A_x">x</code>, <code id="MAplot_+3A_y">y</code></td>
<td>
<p><code>x</code> is any R object for which a <code>MAplot</code> method has
been defined. For the default method, <code>x</code> and <code>y</code> are two
numeric vectors representing signal intensities of the 1st and 2nd
samples, respectively.</p>
</td></tr>
<tr><td><code id="MAplot_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to specific methods for the S3 generic.
For the default method, <code>...</code> represents further arguments to be
passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="MAplot_+3A_occupy.x">occupy.x</code>, <code id="MAplot_+3A_occupy.y">occupy.y</code></td>
<td>
<p>Two logical vectors of occupancy indicators of the
two samples.</p>
</td></tr>
<tr><td><code id="MAplot_+3A_col">col</code>, <code id="MAplot_+3A_pch">pch</code></td>
<td>
<p>Optional length-4 vectors specifying the colors and point
characters of 4 types of genomic intervals: common peak regions, peak
regions specific to the 2nd sample, peak regions specific to the 1st
sample, and the others. Elements are recycled if necessary.</p>
</td></tr>
<tr><td><code id="MAplot_+3A_ylim">ylim</code></td>
<td>
<p>A length-two vector specifying the plotting range of Y-axis
(i.e., the M value). Each M value falling outside the range will be
shrunk to the corresponding limit. Setting the option to <code>NULL</code>
to suppress this behavior.</p>
</td></tr>
<tr><td><code id="MAplot_+3A_xlab">xlab</code>, <code id="MAplot_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the X and Y axes.</p>
</td></tr>
<tr><td><code id="MAplot_+3A_args.legend">args.legend</code></td>
<td>
<p>A list of arguments to be passed to
<code><a href="graphics.html#topic+legend">legend</a></code>. You may want to modify the default to
incorporate actual sample names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the default method, <code>MAplot</code> returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>While it's not strictly required, one typically normalizes the signal
intensities (using <code><a href="#topic+normalize">normalize</a></code>) prior to calling this
function.
</p>
<p>Given the typically large number of points to draw, you may want to
use <code><a href="scales.html#topic+alpha">alpha</a></code> to adjust color transparency if you
intend to specify <code>col</code> explicitly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code> for performing an MA normalization on
ChIP-seq samples; <code><a href="#topic+MAplot.bioCond">MAplot.bioCond</a></code> for creating an MA plot
on <code><a href="#topic+bioCond">bioCond</a></code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Create MA scatter plots on normalized ChIP-seq samples.

# Perform MA normalization directly on all ChIP-seq samples. Exclude the
# genomic intervals in sex chromosomes from common peak regions, since these
# samples are from different genders.
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
norm &lt;- normalize(H3K27Ac, 4:8, 9:13, common.peak.regions = autosome)

# MA plot on two samples from the same individual.
legend &lt;- c("common", "GM12891_2 specific", "GM12891_1 specific", "others")
MAplot(norm[[5]], norm[[6]], norm[[10]], norm[[11]],
       args.legend = list(x = "topright", legend = legend),
       main = "GM12891_rep1 vs. GM12891_rep2")
abline(h = 0, lwd = 2, lty = 5)

# MA plot on two samples from different individuals.
legend &lt;- c("common", "GM12891_1 specific", "GM12890_1 specific", "others")
MAplot(norm[[4]], norm[[5]], norm[[9]], norm[[10]],
       args.legend = list(x = "topright", legend = legend),
       main = "GM12890_rep1 vs. GM12891_rep1")
abline(h = 0, lwd = 2, lty = 5)

</code></pre>

<hr>
<h2 id='MAplot.bioCond'>Create an MA Plot on Two <code>bioCond</code> Objects</h2><span id='topic+MAplot.bioCond'></span>

<h3>Description</h3>

<p>Given two <code><a href="#topic+bioCond">bioCond</a></code> objects, the function draws an MA plot,
which is a scatter plot with signal intensity differences between the two
conditions against the average signal intensities across conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bioCond'
MAplot(
  x,
  y,
  col = NULL,
  pch = NULL,
  ylim = c(-6, 6),
  xlab = "A value",
  ylab = "M value",
  plot.legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAplot.bioCond_+3A_x">x</code>, <code id="MAplot.bioCond_+3A_y">y</code></td>
<td>
<p>Two <code><a href="#topic+bioCond">bioCond</a></code> objects.</p>
</td></tr>
<tr><td><code id="MAplot.bioCond_+3A_col">col</code>, <code id="MAplot.bioCond_+3A_pch">pch</code></td>
<td>
<p>Optional length-4 vectors specifying the colors and point
characters of 4 types of genomic intervals: common peak regions, peak
regions specific to the 2nd condition, peak regions specific to the 1st
condition, and the others. Elements are
recycled if necessary.</p>
</td></tr>
<tr><td><code id="MAplot.bioCond_+3A_ylim">ylim</code></td>
<td>
<p>A length-two vector specifying the plotting range of Y-axis
(i.e., the M value). Each M value falling outside the range will be
shrunk to the corresponding limit. Setting the option to <code>NULL</code>
to suppress this behavior.</p>
</td></tr>
<tr><td><code id="MAplot.bioCond_+3A_xlab">xlab</code>, <code id="MAplot.bioCond_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the X and Y axes.</p>
</td></tr>
<tr><td><code id="MAplot.bioCond_+3A_plot.legend">plot.legend</code></td>
<td>
<p>A logical value indicating whether to add a legend.</p>
</td></tr>
<tr><td><code id="MAplot.bioCond_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genomic intervals are classified based on
the <code>occupancy</code> field in each of
the two <code><a href="#topic+bioCond">bioCond</a></code> objects. See <code><a href="#topic+bioCond">bioCond</a></code> for a full
description of the structure of a <code>bioCond</code> object.
</p>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>


<h3>Note</h3>

<p>While it's not strictly required, ChIP-seq samples contained in the
two <code><a href="#topic+bioCond">bioCond</a></code> objects are expected to have been normalized
prior to calling this function. These samples could be normalized all
together before being classified into biological conditions (via
<code><a href="#topic+normalize">normalize</a></code>). Alternatively, normalization can also be
performed at the level of <code>bioCond</code> objects (via
<code><a href="#topic+normBioCond">normBioCond</a></code>).
</p>
<p>Given the typically large number of points to draw, you may want to
use <code><a href="scales.html#topic+alpha">alpha</a></code> to adjust color transparency if you
intend to specify <code>col</code> explicitly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+MAplot.default">MAplot.default</a></code> for producing an MA plot on normalized
signal intensities of two ChIP-seq samples; <code><a href="#topic+normalize">normalize</a></code> for
performing an MA normalization on ChIP-seq samples;
<code><a href="#topic+normBioCond">normBioCond</a></code> for normalizing a set of <code>bioCond</code>
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Create MA scatter plots for the comparisons between individuals.

# Perform the MA normalization and construct bioConds to represent
# individuals.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# MA plots on pairs of individuals.
MAplot(conds[[1]], conds[[2]], main = "GM12890 vs. GM12891")
abline(h = 0, lwd = 2, lty = 5)
MAplot(conds[[1]], conds[[3]], main = "GM12890 vs. GM12892")
abline(h = 0, lwd = 2, lty = 5)
MAplot(conds[[2]], conds[[3]], main = "GM12891 vs. GM12892")
abline(h = 0, lwd = 2, lty = 5)

</code></pre>

<hr>
<h2 id='MAplot.diffBioCond'>Create an MA Plot on Results of Comparing Two <code>bioCond</code> Objects</h2><span id='topic+MAplot.diffBioCond'></span>

<h3>Description</h3>

<p>This method produces an MA plot demonstrating the results of comparing two
<code><a href="#topic+bioCond">bioCond</a></code> objects. More specifically, it draws a scatter plot
consisting of the genomic intervals having been compared,
and those intervals with
differential ChIP-seq signals between the two conditions are explicitly
indicated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffBioCond'
MAplot(
  x,
  padj = NULL,
  pval = NULL,
  col = alpha(c("black", "red"), 0.1),
  pch = 20,
  ylim = c(-6, 6),
  xlab = "A value",
  ylab = "M value",
  args.legend = list(x = "topright"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MAplot.diffBioCond_+3A_x">x</code></td>
<td>
<p>An object of class <code>"diffBioCond"</code>, typically obtained by
passing two <code><a href="#topic+bioCond">bioCond</a></code> objects to
<code><a href="#topic+diffTest.bioCond">diffTest</a></code>.</p>
</td></tr>
<tr><td><code id="MAplot.diffBioCond_+3A_padj">padj</code>, <code id="MAplot.diffBioCond_+3A_pval">pval</code></td>
<td>
<p>Cutoff of adjusted/raw <em>p</em>-value for selecting
differential intervals.
Only one of the two arguments is effectively used;
<code>pval</code> is ignored if <code>padj</code> is specified. The default is
equivalent to setting <code>padj</code> to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="MAplot.diffBioCond_+3A_col">col</code>, <code id="MAplot.diffBioCond_+3A_pch">pch</code></td>
<td>
<p>Optional length-2 vectors specifying the colors and point
characters of non-differential and differential intervals, respectively.
Elements are recycled if necessary.</p>
</td></tr>
<tr><td><code id="MAplot.diffBioCond_+3A_ylim">ylim</code></td>
<td>
<p>A length-two vector specifying the plotting range of Y-axis
(i.e., the M value). Each M value falling outside the range will be
shrunk to the corresponding limit. Setting the option to <code>NULL</code>
to suppress this behavior.</p>
</td></tr>
<tr><td><code id="MAplot.diffBioCond_+3A_xlab">xlab</code>, <code id="MAplot.diffBioCond_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the X and Y axes.</p>
</td></tr>
<tr><td><code id="MAplot.diffBioCond_+3A_args.legend">args.legend</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="MAplot.diffBioCond_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve given a
list of <code>bioCond</code> objects;
<code><a href="#topic+diffTest.bioCond">diffTest</a></code> for making a comparison
between two <code>bioCond</code> objects; <code><a href="scales.html#topic+alpha">alpha</a></code> for
adjusting color transparency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Make a comparison between GM12891 and GM12892 cell lines and create an MA
## plot on the comparison results.

# Perform MA normalization and construct bioConds to represent the two cell
# lines.
norm &lt;- normalize(H3K27Ac, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Variations in ChIP-seq signals across biological replicates of a cell line
# are generally of a low level, and their relationship with the mean signal
# intensities is expected to be well modeled by the presumed parametric
# form.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
summary(conds[[1]])
plotMeanVarCurve(conds, subset = "occupied")

# Perform differential tests between the two cell lines.
res &lt;- diffTest(conds[[1]], conds[[2]])
head(res)

# Visualize the overall test results.
MAplot(res, padj = 0.001)
abline(h = 0, lwd = 2, lty = 5, col = "green3")

</code></pre>

<hr>
<h2 id='mean_var_logwinf'>Expectation and Variance of Log Winsorized <em>F</em> Distribution</h2><span id='topic+mean_var_logwinf'></span>

<h3>Description</h3>

<p><code>mean_var_logwinf</code> calculates the expectation and
variance of a log Winsorized <em>F</em> distribution by
appealing to methods for numerical integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_var_logwinf(
  df1,
  df2,
  p_low = 0.01,
  p_up = 0.1,
  nw = gauss.quad(128, kind = "legendre")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_var_logwinf_+3A_df1">df1</code>, <code id="mean_var_logwinf_+3A_df2">df2</code></td>
<td>
<p>Vectors of numbers of numerator and denominator degrees of
freedom. <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="mean_var_logwinf_+3A_p_low">p_low</code>, <code id="mean_var_logwinf_+3A_p_up">p_up</code></td>
<td>
<p>Vectors of lower- and upper-tail probabilities for
Winsorizing. Each element must be strictly larger than 0, and each pair
of <code>p_low</code> and <code>p_up</code> must have a sum strictly smaller than 1.
</p>
<p>Note that <code>df1</code>,
<code>df2</code>, <code>p_low</code>, and <code>p_up</code> are recycled to align with the
longest of them.</p>
</td></tr>
<tr><td><code id="mean_var_logwinf_+3A_nw">nw</code></td>
<td>
<p>A list containing <code>nodes</code> and <code>weights</code> variables for
calculating the definite integral of a function <code>f</code> over the
interval <code>[-1, 1]</code>, which is approximated by
<code>sum(nw$weights * f(nw$nodes))</code>. By default,
<code>mean_var_logwinf</code> uses
a set of Gauss-Legendre nodes along with the corresponding weights
calculated by <code><a href="statmod.html#topic+gauss.quad">gauss.quad</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements exactly the same method described in
Phipson et al., 2016 (see &quot;References&quot;).
</p>


<h3>Value</h3>

<p>A list consisting of the following components:
</p>

<dl>
<dt><code>mu</code></dt><dd><p>Vector of expectations.</p>
</dd>
<dt><code>v</code></dt><dd><p>Vector of variances.</p>
</dd>
</dl>



<h3>References</h3>

<p>Phipson, B., et al., <em>Robust Hyperparameter Estimation
Protects against Hypervariable Genes and Improves Power to Detect
Differential Expression.</em> Annals of Applied Statistics, 2016.
<strong>10</strong>(2): p. 946-963.
</p>


<h3>See Also</h3>

<p><code><a href="statmod.html#topic+gauss.quad">gauss.quad</a></code> for calculating nodes and
weights for Gaussian quadrature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Derive the expectation and variance of a log Winsorized F distribution by
# simulation.
random_logwinf &lt;- function(n, df1, df2, p_low, p_up) {
    x &lt;- rf(n, df1, df2)
    q_low &lt;- qf(p_low, df1, df2, lower.tail = TRUE)
    q_up &lt;- qf(p_up, df1, df2, lower.tail = FALSE)
    x[x &lt; q_low] &lt;- q_low
    x[x &gt; q_up] &lt;- q_up
    x &lt;- log(x)
    c(mean(x), var(x))
}

# Set parameters.
n &lt;- 10000
df1 &lt;- 2
df2 &lt;- 2 ^ (0:10)
p_low &lt;- 0.01
p_up &lt;- 0.1

# Compare simulation results with those from numerical integration.
set.seed(100)
res1 &lt;- vapply(df2, function(x) random_logwinf(n, df1, x, p_low, p_up),
               numeric(2))
res2 &lt;- mean_var_logwinf(df1, df2, p_low, p_up)

# Compare mean.
plot(0:10, res1[1, ], type = "l", lwd = 2, col = "red", xlab = "Log2(df2)",
     ylab = "Mean")
lines(0:10, res2$mu, lty = 5, lwd = 2, col = "blue")
legend("topright", c("Simulation", "Numerical integration"), lty = c(1, 5),
       lwd = 2, col = c("red", "blue"))

# Compare variance.
plot(0:10, res1[2, ], type = "l", lwd = 2, col = "red", xlab = "Log2(df2)",
     ylab = "Var")
lines(0:10, res2$v, lty = 5, lwd = 2, col = "blue")
legend("topright", c("Simulation", "Numerical integration"), lty = c(1, 5),
       lwd = 2, col = c("red", "blue"))

# When df2 is Inf.
random_logwinf(n, df1, Inf, p_low, p_up)
mean_var_logwinf(df1, Inf, p_low, p_up)

</code></pre>

<hr>
<h2 id='meanVarLocalFit'>Fit Mean-Variance Trend by Local Regression</h2><span id='topic+meanVarLocalFit'></span>

<h3>Description</h3>

<p><code>meanVarLocalFit</code> fits a mean-variance curve by applying a robust,
gamma-family local regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanVarLocalFit(
  x,
  y,
  weight,
  range.residual = c(1e-04, 15),
  max.iter = 50,
  args.lp = list(),
  args.locfit = list(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanVarLocalFit_+3A_x">x</code>, <code id="meanVarLocalFit_+3A_y">y</code></td>
<td>
<p>Two numeric vectors of (sample) means and sample variances,
respectively.</p>
</td></tr>
<tr><td><code id="meanVarLocalFit_+3A_weight">weight</code></td>
<td>
<p>An optional vector of weights to be used in the fitting
procedure. It's typically used when sample variances in <code>y</code> are
associated with different numbers of degrees of freedom.</p>
</td></tr>
<tr><td><code id="meanVarLocalFit_+3A_range.residual">range.residual</code></td>
<td>
<p>A length-two vector specifying the range of residuals
of non-outliers.</p>
</td></tr>
<tr><td><code id="meanVarLocalFit_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iteration times allowed during the
fitting procedure.</p>
</td></tr>
<tr><td><code id="meanVarLocalFit_+3A_args.lp">args.lp</code></td>
<td>
<p>A named list of extra arguments to <code><a href="locfit.html#topic+lp">lp</a></code>.</p>
</td></tr>
<tr><td><code id="meanVarLocalFit_+3A_args.locfit">args.locfit</code></td>
<td>
<p>A named list of extra arguments to
<code><a href="locfit.html#topic+locfit">locfit</a></code>.</p>
</td></tr>
<tr><td><code id="meanVarLocalFit_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print processing messages about iteratively
fitting the mean-variance curve?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>meanVarLocalFit</code> iteratively detects outliers and applies the local
regression procedure to non-outliers. The procedure converges as soon as the
set of outlier points fixes.
</p>


<h3>Value</h3>

<p>A prediction function which accepts a vector of means and returns
the predicted variances.
</p>


<h3>Note</h3>

<p>Due to the internal implementation, the argument <code>subset</code> to
<code><a href="locfit.html#topic+locfit">locfit</a></code> mustn't be specified in <code>args.locfit</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meanVarParaFit">meanVarParaFit</a></code> for parametrically fitting a
mean-variance curve; <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for an interface to
modeling the mean-variance dependence on <code><a href="#topic+bioCond">bioCond</a></code> objects;
<code><a href="#topic+plotMeanVarCurve">plotMeanVarCurve</a></code> for plotting a mean-variance curve.
</p>

<hr>
<h2 id='meanVarParaFit'>Parametrically Fit a Mean-Variance Curve</h2><span id='topic+meanVarParaFit'></span>

<h3>Description</h3>

<p><code>meanVarParaFit</code> fits a mean-variance curve by applying a robust,
gamma-family <code><a href="stats.html#topic+glm">glm</a></code> regression, taking advantage of the
form: <code class="reqn">var = c1 + c2 / (2 ^ mean)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanVarParaFit(
  x,
  y,
  weight,
  range.residual = c(1e-04, 15),
  max.iter = 50,
  init.coef = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanVarParaFit_+3A_x">x</code></td>
<td>
<p>Two numeric vectors of (sample) means and sample variances,
respectively.</p>
</td></tr>
<tr><td><code id="meanVarParaFit_+3A_y">y</code></td>
<td>
<p>Two numeric vectors of (sample) means and sample variances,
respectively.</p>
</td></tr>
<tr><td><code id="meanVarParaFit_+3A_weight">weight</code></td>
<td>
<p>An optional vector of weights to be used in the fitting
procedure. It's typically used when sample variances in <code>y</code> are
associated with different numbers of degrees of freedom.</p>
</td></tr>
<tr><td><code id="meanVarParaFit_+3A_range.residual">range.residual</code></td>
<td>
<p>A length-two vector specifying the range of residuals
of non-outliers.</p>
</td></tr>
<tr><td><code id="meanVarParaFit_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iteration times allowed during the
fitting procedure.</p>
</td></tr>
<tr><td><code id="meanVarParaFit_+3A_init.coef">init.coef</code></td>
<td>
<p>An optional length-two vector specifying the initial
values of the coefficients.</p>
</td></tr>
<tr><td><code id="meanVarParaFit_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print processing messages about iteratively
fitting the mean-variance curve?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>meanVarParaFit</code> iteratively detects outliers and fits a generalized
linear model on non-outliers. The procedure converges as soon as the set of
outlier points fixes.
</p>
<p>See &quot;References&quot; for the theoretical foundation of the parametric form.
</p>


<h3>Value</h3>

<p>A prediction function which accepts a vector of means and returns
the predicted variances, with an attribute named <code>"coefficients"</code>
attached.
</p>


<h3>References</h3>

<p>Robinson, M.D. and G.K. Smyth, <em>Small-sample estimation of negative
binomial dispersion, with applications to SAGE data.</em> Biostatistics, 2008.
<strong>9</strong>(2): p. 321-32.
</p>
<p>Love, M.I., W. Huber, and S. Anders, <em>Moderated estimation of fold
change and dispersion for RNA-seq data with DESeq2.</em> Genome Biol, 2014.
<strong>15</strong>(12): p. 550.
</p>
<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing groups of
ChIP-seq samples.</em> Genome Res, 2021. <strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meanVarLocalFit">meanVarLocalFit</a></code> for using local regression to fit
a mean-variance curve; <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for an interface
to modeling the mean-variance dependence on <code><a href="#topic+bioCond">bioCond</a></code>
objects; <code><a href="#topic+plotMeanVarCurve">plotMeanVarCurve</a></code> for plotting a mean-variance
curve.
</p>

<hr>
<h2 id='mvcID.new'>Create a New Unique ID for a Mean-Variance Curve</h2><span id='topic+mvcID.new'></span>

<h3>Description</h3>

<p>To achieve that different calls of <code>mvcID.new</code> generate distinct IDs,
the function returns the current time via <code><a href="base.html#topic+Sys.time">Sys.time</a></code>,
appended by a randomly generated serial number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvcID.new(n = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvcID.new_+3A_n">n</code></td>
<td>
<p>Length of the serial number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character scalar representing the created ID.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Private functions involved.

mvcID.new()
mvcID.new()
Sys.sleep(1.1)
mvcID.new()

## End(Not run)

</code></pre>

<hr>
<h2 id='normalize'>Perform MA Normalization on a Set of ChIP-seq Samples</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Given read counts from a set of ChIP-seq samples in a set of genomic
intervals as well as the signal enrichment states of these intervals in each
of the samples, this
function converts the read counts into signal intensities more of a
continuous variable, and normalizes these signal intensities through linear
transformations so that the normalized signal intensities in each genomic
interval are comparable across samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(
  x,
  count,
  occupancy,
  baseline = NULL,
  subset = NULL,
  interval.size = FALSE,
  offset = 0.5,
  convert = NULL,
  common.peak.regions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>A data frame containing the read count and occupancy indicator
variables. Each row should represent a genomic interval.
Objects of other types are coerced to a data frame.</p>
</td></tr>
<tr><td><code id="normalize_+3A_count">count</code></td>
<td>
<p>Either an integer vector or a character vector that indexes the
read count variables in <code>x</code> to be normalized. Each of these
variables represents a ChIP-seq sample. Elements of <code>count</code> must be
unique.</p>
</td></tr>
<tr><td><code id="normalize_+3A_occupancy">occupancy</code></td>
<td>
<p>Either an integer or character vector indexing occupancy
indicator variables in <code>x</code>. Must correspond to <code>count</code> one by
one with the same order. These variables are interpreted as logical,
where <code>TRUE</code> indicates being occupied by peaks (i.e.,
showing an enrichment for reads) of the corresponding ChIP-seq sample.</p>
</td></tr>
<tr><td><code id="normalize_+3A_baseline">baseline</code></td>
<td>
<p>Either an integer scalar or a character scalar referring to
the baseline sample. Must be an element of <code>count</code> if specified. By
default, the baseline is automatically selected by the function (see
&quot;Details&quot;).
</p>
<p>A special option for this argument is <code>"pseudo-reference"</code>, in
which case the function constructs a pseudo ChIP-seq sample as baseline
by &quot;averaging&quot; the samples to be normalized (see &quot;Details&quot;). This option
is especially recommended when the number of samples to be normalized is
large (e.g., &gt;5).</p>
</td></tr>
<tr><td><code id="normalize_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying the subset of intervals to be
used for estimating size factors and selecting the baseline (see
&quot;Details&quot; and <code><a href="#topic+estimateSizeFactors">estimateSizeFactors</a></code>). Defaults to the
intervals occupied by all the samples.
Ignored if <code>baseline</code> is specified.</p>
</td></tr>
<tr><td><code id="normalize_+3A_interval.size">interval.size</code></td>
<td>
<p>A numeric vector of interval sizes or a logical scalar
to specify whether to use interval sizes for converting read counts into
signal intensities (see &quot;Details&quot;).
If set to <code>TRUE</code>, the function will look for the <code>"start"</code> and
<code>"end"</code> variables in <code>x</code>, and use them to calculate interval
sizes.
By default, interval sizes are not used.</p>
</td></tr>
<tr><td><code id="normalize_+3A_offset">offset</code></td>
<td>
<p>The offset value used for converting read counts
into signal intensities (see &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="normalize_+3A_convert">convert</code></td>
<td>
<p>An optional function specifying the way that read counts are
converted into signal intensities. It should accept a vector of read
counts and return the corresponding signal intensities. If set,
<code>interval.size</code> and <code>offset</code> are ignored.</p>
</td></tr>
<tr><td><code id="normalize_+3A_common.peak.regions">common.peak.regions</code></td>
<td>
<p>An optional logical vector specifying the
intervals that could possibly be common peak regions for each pair of
samples. By default, for each pair of samples, all the intervals
occupied by both samples are considered as their common peak regions.
See &quot;Details&quot; for an application of this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first determines a baseline ChIP-seq sample from the given set.
The baseline could either be specified by the user or automatically selected
by the function. In the latter case, the function deduces the size factor of
each sample using <code><a href="#topic+estimateSizeFactors">estimateSizeFactors</a></code>, and selects the sample
as baseline whose <code class="reqn">log2</code> size factor is closest to 0 (with the exception
that, if there are only two samples to be normalized, the function will
always use the sample with the smaller size factor as baseline, for avoiding
potential uncertainty in selection results due to limited numerical
precision). A special case is setting the <code>baseline</code> argument to
<code>"pseudo-reference"</code>, in which case the function constructs a pseudo
ChIP-seq sample as baseline. Technically, for an individual genomic interval
in the pseudo sample, the function derives its signal intensity (rather than
read count; see below) by taking the average across those samples that
occupy it, and it is considered to be a peak region as long as it is
occupied by any of the samples to be normalized. We don't need to care about
the signal intensities of those intervals that are not occupied by any
sample, since they are never used in the normalization process (see below).
Using such a pseudo sample as baseline is especially recommended when the
number of samples to be normalized is large, for avoiding computation
artifacts resulting from an arbitrary selection of baseline sample.
</p>
<p>Then, the function converts each read count into a signal intensity through
the equation <code class="reqn">log2(count + offset)</code>, or
<code class="reqn">log2(count / intervalSize + offset)</code> if sizes of the genomic intervals
are provided. To be noted, while the interval sizes (either specified by
users or calculated from the data frame) are considered as number of base
pairs, the <code class="reqn">intervalSize</code> variable used in the latter equation has a
unit of kilo base pairs (so that 0.5 still serves as a generally
appropriate offset).
</p>
<p>In most cases, simply using the former equation is recommended. You may,
however, want to involve the interval sizes when ChIP-seq samples to be
classified into the same biological condition are associated with a large
variation (e.g., when they are from different individuals; see also
<code><a href="#topic+bioCond">bioCond</a></code>). Besides, the goodness of fit of mean-variance curve
(see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>) could serve as one of the
principles for selecting an appropriate converting equation.
</p>
<p>The <code>convert</code> argument serves as an optional function for converting
read counts into signal intensities. The function is expected to operate on
the read count vector of each sample, and should return the converted signal
intensities. <code>convert</code> is barely used, exceptions including applying a
variance stabilizing transformation or shrinking potential outlier counts.
</p>
<p>Finally, the function normalizes each ChIP-seq sample to the baseline.
Basically, it applies a linear transformation to the signal intensities of
each non-baseline sample, so that M and A values calculated from common peak
regions (the genomic intervals occupied by both the sample to be normalized
and the baseline) are not correlated. The argument
<code>common.peak.regions</code> can be used to narrow down the set of intervals
that could possibly be considered as common peak regions. You may, for
example, use it to remove the intervals located on sex chromosomes from
common peak regions when the involved ChIP-seq samples come from different
genders (see also &quot;Examples&quot; below).
</p>


<h3>Value</h3>

<p><code>normalize</code> returns the provided data frame, with the read
counts replaced by the corresponding normalized signal intensities.
Besides, the following attributes are added to the data frame:
</p>

<dl>
<dt><code>size.factor</code></dt><dd><p>Size factors of the specified read count
variables. Only present when <code>baseline</code> is not explicitly
specified by the user.</p>
</dd>
<dt><code>baseline</code></dt><dd><p>Name of the read count variable used as the
baseline sample or <code>"pseudo-reference"</code> if the <code>baseline</code>
argument is specified so.</p>
</dd>
<dt><code>norm.coef</code></dt><dd><p>A data frame recording the linear
transformation coefficients of each sample as well as the number of
common peak regions between each sample and the baseline.</p>
</dd>
<dt><code>MA.cor</code></dt><dd><p>A real matrix recording the Pearson
correlation coefficient between M &amp; A values calculated from common
peak regions of each pair of samples. The upper and lower triangles
of this matrix are deduced from raw and normalized signal
intensities, respectively. Note that M values are always calculated
as the column sample minus the row sample.</p>
</dd>
</dl>



<h3>References</h3>

<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing
groups of ChIP-seq samples.</em> Genome Res, 2021.
<strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalizeBySizeFactors">normalizeBySizeFactors</a></code> for normalizing ChIP-seq
samples based on their size factors; <code><a href="#topic+estimateSizeFactors">estimateSizeFactors</a></code>
for estimating size factors of ChIP-seq samples;
<code><a href="#topic+MAplot.default">MAplot</a></code> for creating an
MA plot on normalized signal intensities of two samples;
<code><a href="#topic+bioCond">bioCond</a></code> for creating an object to represent a biological
condition given a set of normalized ChIP-seq samples, and
<code><a href="#topic+normBioCond">normBioCond</a></code> for performing an MA normalization on such
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Perform MA normalization on the whole set of ChIP-seq samples once for
## all.

# Exclude the genomic intervals in sex chromosomes from the common peak
# regions, since the ChIP-seq samples to be normalized are associated with
# different genders.
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
norm &lt;- normalize(H3K27Ac, 4:8, 9:13, common.peak.regions = autosome)

# Inspect the normalization effects.
attributes(norm)[5:8]
plot(attr(norm, "MA.cor"), symbreaks = TRUE, margins = c(8, 8))
MAplot(norm[[4]], norm[[5]], norm[[9]], norm[[10]],
       main = "GM12890_rep1 vs. GM12891_rep1")
abline(h = 0, lwd = 2, lty = 5)

## Alternatively, apply MA normalization first within each cell line, and
## then normalize across cell lines. In practice, this strategy is more
## recommended than the aforementioned one.

# Normalize samples separately for each cell line.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)

# Construct separately a bioCond object for each cell line, and perform MA
# normalization on the resulting bioConds. Genomic intervals in sex
# chromosomes are not allowed to be common peak regions, since the cell
# lines are from different genders.
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Inspect the normalization effects.
attributes(conds)
plot(attr(conds, "MA.cor"), symbreaks = TRUE, margins = c(8, 8))
MAplot(conds[[1]], conds[[2]], main = "GM12890 vs. GM12891")
abline(h = 0, lwd = 2, lty = 5)

</code></pre>

<hr>
<h2 id='normalizeBySizeFactors'>Normalize ChIP-seq Samples by Their Size Factors</h2><span id='topic+normalizeBySizeFactors'></span>

<h3>Description</h3>

<p>Given read counts from a set of ChIP-seq samples in a set of
genomic intervals, this function normalizes the counts using size factors
of the samples, and converts the normalized read counts into normalized
signal intensities more of a continuous variable.
The function can also be used to normalize RNA-seq
samples, in which case each genomic interval refers to a gene. In fact, the
normalization method implemented in this function is most suited to RNA-seq
datasets. See <code><a href="#topic+normalize">normalize</a></code> for a more robust method for
normalizing ChIP-seq samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeBySizeFactors(
  x,
  count,
  subset = NULL,
  interval.size = FALSE,
  offset = 0.5,
  convert = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalizeBySizeFactors_+3A_x">x</code></td>
<td>
<p>A data frame containing the read count variables. Each row should
represent a genomic interval or a gene.
Objects of other types are coerced to a data frame.</p>
</td></tr>
<tr><td><code id="normalizeBySizeFactors_+3A_count">count</code></td>
<td>
<p>A vector of either integers or characters indexing the read
count variables in <code>x</code> to be normalized. Each of these variables
represents a ChIP-seq/RNA-seq sample. Elements of <code>count</code> must be
unique.</p>
</td></tr>
<tr><td><code id="normalizeBySizeFactors_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying the subset of intervals or genes
to be used for estimating size factors. For ChIP-seq samples, you may
want to use only the intervals occupied by all the samples to estimate
their size factors (see &quot;Examples&quot; below). By default, all genomic
intervals or genes are used.</p>
</td></tr>
<tr><td><code id="normalizeBySizeFactors_+3A_interval.size">interval.size</code></td>
<td>
<p>A numeric vector of interval sizes or a logical scalar
to specify
whether to use interval sizes for converting normalized read counts into
normalized signal intensities (see &quot;Details&quot;).
If set to <code>TRUE</code>, the function will look for the <code>"start"</code> and
<code>"end"</code> variables in <code>x</code>, and use them to calculate interval
sizes. By default, interval sizes are not used.
</p>
<p>In cases of analyzing RNA-seq samples, interval sizes, if used, should
be the corresponding gene lengths (or sums of exon lengths).</p>
</td></tr>
<tr><td><code id="normalizeBySizeFactors_+3A_offset">offset</code></td>
<td>
<p>The offset value used for converting normalized read counts
into normalized signal intensities (see &quot;Details&quot;). The default value
is suited to most cases. If you are analyzing RNA-seq samples and
intended to use gene lengths, however, a smaller offset value
(e.g., 0.01) is recommended.</p>
</td></tr>
<tr><td><code id="normalizeBySizeFactors_+3A_convert">convert</code></td>
<td>
<p>An optional function specifying the way that normalized read
counts are converted into normalized signal intensities. It should
accept a vector of inputs and return a vector of the corresponding
signal intensities. If set, <code>interval.size</code> and <code>offset</code> are
ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first estimates the size factor of each sample specified,
which quantifies the sample's relative sequencing depth. Technically, the
function applies the median ratio method to the raw read counts, which is
originally devised to normalize RNA-seq samples (see &quot;References&quot;). Then,
normalized read counts are deduced by dividing the raw counts of each sample
by its size factor.
</p>
<p>These normalized read counts are then converted into normalized signal
intensities more of a continuous variable. By default, the function uses
the equation <code class="reqn">log2(normCnt + offset)</code>, or
<code class="reqn">log2(normCnt / intervalSize + offset)</code> if interval sizes
(or gene lengths) are provided. To be noted, while the interval sizes
(either specified by users or calculated from the data frame) are considered
as number of base pairs, the <code class="reqn">intervalSize</code> variable used in the latter
equation has a unit of kilo base pairs.
In this case, 0.5 still serves as a generally appropriate offset for
ChIP-seq samples. For RNA-seq samples, however, a smaller offset value
(e.g., 0.01) should be adopted.
</p>
<p>In most cases, simply using the former equation is recommended. You may,
however, want to involve the interval sizes (or gene lengths) when the
samples to
be classified into the same biological condition are associated with a large
variation (e.g., when they are from different individuals; see also
<code><a href="#topic+bioCond">bioCond</a></code>). Besides, the goodness of fit of mean-variance curve
(see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>) could serve as one of the
principles for selecting an appropriate converting equation.
</p>
<p>The <code>convert</code> argument serves as an optional function for converting
normalized read counts into normalized signal intensities. The function is
expected to operate on the vector of normalized counts of each sample, and
should return the converted signal intensities.
<code>convert</code> is barely used, exceptions including applying a
variance stabilizing transformation or shrinking potential outliers.
</p>


<h3>Value</h3>

<p><code>normalizeBySizeFactors</code> returns the provided data frame, with
the read counts replaced by the corresponding normalized signal
intensities. Besides, an attribute named <code>"size.factor"</code> is added
to the data frame, recording the size factor of each specified sample.
</p>


<h3>References</h3>

<p>Anders, S. and W. Huber, <em>Differential expression analysis
for sequence count data.</em> Genome Biol, 2010. <strong>11</strong>(10): p. R106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code> for performing an MA normalization on
ChIP-seq samples; <code><a href="#topic+estimateSizeFactors">estimateSizeFactors</a></code> for estimating size
factors of ChIP-seq/RNA-seq samples;
<code><a href="#topic+MAplot.default">MAplot</a></code> for creating an MA plot on
normalized signal intensities of two samples;
<code><a href="#topic+bioCond">bioCond</a></code> for creating an object to represent a biological
condition given a set of normalized samples, and
<code><a href="#topic+normBioCondBySizeFactors">normBioCondBySizeFactors</a></code> for normalizing such
objects based on their size factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Normalize directly the whole set of ChIP-seq samples by their size
## factors.

# Use only the genomic intervals that are occupied by all the ChIP-seq
# samples to be normalized to estimate the size factors.
norm &lt;- normalizeBySizeFactors(H3K27Ac, 4:8,
                               subset = apply(H3K27Ac[9:13], 1, all))

# Inspect the normalization effects.
attr(norm, "size.factor")
MAplot(norm[[4]], norm[[5]], norm[[9]], norm[[10]],
       main = "GM12890_rep1 vs. GM12891_rep1")
abline(h = 0, lwd = 2, lty = 5)

## Alternatively, perform the normalization first within each cell line, and
## then normalize across cell lines. In practice, this strategy is more
## recommended than the aforementioned one.

# Normalize samples separately for each cell line.
norm &lt;- normalizeBySizeFactors(H3K27Ac, 4)
norm &lt;- normalizeBySizeFactors(norm, 5:6,
                               subset = apply(norm[10:11], 1, all))
norm &lt;- normalizeBySizeFactors(norm, 7:8,
                               subset = apply(norm[12:13], 1, all))

# Construct separately a bioCond object for each cell line, and normalize
# the resulting bioConds by their size factors.
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
conds &lt;- normBioCondBySizeFactors(conds)

# Inspect the normalization effects.
attr(conds, "size.factor")
MAplot(conds[[1]], conds[[2]], main = "GM12890 vs. GM12891")
abline(h = 0, lwd = 2, lty = 5)

</code></pre>

<hr>
<h2 id='normBioCond'>Perform MA Normalization on a Set of <code>bioCond</code> Objects</h2><span id='topic+normBioCond'></span>

<h3>Description</h3>

<p>Given a list of <code><a href="#topic+bioCond">bioCond</a></code> objects, <code>normBioCond</code> performs
an MA normalization on the signal intensities stored in them so that these
objects are comparable to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normBioCond(conds, baseline = NULL, subset = NULL, common.peak.regions = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normBioCond_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects to be normalized.</p>
</td></tr>
<tr><td><code id="normBioCond_+3A_baseline">baseline</code></td>
<td>
<p>A positive integer or character name indexing the baseline
<code>bioCond</code> in <code>conds</code>.
By default, the baseline is automatically selected by estimating the
size factor of each <code>bioCond</code> (see <code><a href="#topic+normalize">normalize</a></code> and
<code><a href="#topic+estimateSizeFactors">estimateSizeFactors</a></code> for details). Note that
<code>normBioCond</code> treats the signal intensities contained in the
supplied <code>bioCond</code>s as in the scale of <code class="reqn">log2</code> read counts,
which is consistent with the default behavior of
<code><a href="#topic+normalize">normalize</a></code>. Note also that <code>baseline</code> can be set to
<code>"pseudo-reference"</code> as in <code><a href="#topic+normalize">normalize</a></code>. And we
recommend using this setting when the number of <code>bioCond</code>s to be
normalized is large (e.g., &gt;5).</p>
</td></tr>
<tr><td><code id="normBioCond_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying the subset of intervals to be
used for estimating size factors and selecting the baseline.
Defaults to the intervals occupied by all the <code>bioCond</code> objects.
Ignored if <code>baseline</code> is specified.</p>
</td></tr>
<tr><td><code id="normBioCond_+3A_common.peak.regions">common.peak.regions</code></td>
<td>
<p>An optional logical vector specifying the
intervals that could possibly be considered as common peak regions for
each pair of <code>bioCond</code>
objects. See also <code><a href="#topic+normalize">normalize</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technically, <code>normBioCond</code> treats each <code><a href="#topic+bioCond">bioCond</a></code> object as
a ChIP-seq sample. It extracts the <code>sample.mean</code> and <code>occupancy</code>
variables stored in each <code>bioCond</code> to represent its signal intensities
and occupancy indicators, respectively. See <code><a href="#topic+bioCond">bioCond</a></code> for a
description of the structure of a <code>bioCond</code> object.
</p>
<p>Next, MA normalization on these <code>bioCond</code> objects is performed exactly
as described in <code><a href="#topic+normalize">normalize</a></code>. Specifically, we get a linear
transformation for each <code>bioCond</code> object, which is subsequently applied
to each of the ChIP-seq samples contained in it.
</p>
<p><code>normBioCond</code> is an effort to reduce potential biases introduced by the
MA normalization process. The idea comes from the principle that the more
similar two samples are to each other, the fewer biases are expected to
introduce when normalizing them. With this function, instead of performing
an overall normalization on all the ChIP-seq samples involved, you may
choose to first perform a normalization within each biological condition,
and then normalize between the resulting <code>bioCond</code> objects (see
&quot;Examples&quot; below).
</p>


<h3>Value</h3>

<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects with normalized signal
intensities, corresponding to the argument <code>conds</code>. To be noted,
information about the mean-variance dependence stored in the original
<code>bioCond</code> objects, if any, will be removed from the returned
<code>bioCond</code>s. You can re-fit a mean-variance curve for them by, for
example, calling <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>. Note also that the
original structure matrices are retained for each <code>bioCond</code> in the
returned list (see <code><a href="#topic+setWeight">setWeight</a></code> for a detailed description
of structure matrix).
</p>
<p>Besides, the following attributes are added to the list describing the
MA normalization performed:
</p>

<dl>
<dt><code>size.factor</code></dt><dd><p>Size factors of provided <code>bioCond</code>
objects. Only present when <code>baseline</code> is not explicitly
specified by the user.</p>
</dd>
<dt><code>baseline</code></dt><dd><p>Condition name of the <code>bioCond</code> object
used as baseline or <code>"pseudo-reference"</code> if the <code>baseline</code>
argument is specified so.</p>
</dd>
<dt><code>norm.coef</code></dt><dd><p>A data frame recording the MA normalization
coefficients for each <code>bioCond</code>.</p>
</dd>
<dt><code>MA.cor</code></dt><dd><p>A real matrix recording the Pearson correlation
coefficient between M &amp; A values calculated from common peak regions
of each pair of <code>bioCond</code> objects. The upper and lower triangle
of the matrix are deduced from raw and normalized signal
intensities, respectively. Note that M values are always calculated
as the column <code>bioCond</code> minus the row one.</p>
</dd>
</dl>



<h3>References</h3>

<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing
groups of ChIP-seq samples.</em> Genome Res, 2021.
<strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code> for performing an MA normalization on
ChIP-seq samples; <code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code>
object; <code><a href="#topic+normBioCondBySizeFactors">normBioCondBySizeFactors</a></code> for normalizing
<code>bioCond</code> objects based on their size factors;
<code><a href="#topic+cmbBioCond">cmbBioCond</a></code> for combining a set of <code>bioCond</code>
objects into a single one; <code><a href="#topic+MAplot.bioCond">MAplot.bioCond</a></code> for
creating an MA plot on two normalized <code>bioCond</code> objects;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for modeling the mean-variance dependence
across intervals in <code>bioCond</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Apply MA normalization first within each cell line, and then normalize
## across cell lines.

# Normalize samples separately for each cell line.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)

# Construct separately a bioCond object for each cell line, and perform MA
# normalization on the resulting bioConds. Genomic intervals in sex
# chromosomes are not allowed to be common ones, since the cell lines are
# from different genders.
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Inspect the normalization effects.
attributes(conds)
plot(attr(conds, "MA.cor"), symbreaks = TRUE, margins = c(8, 8))
MAplot(conds[[1]], conds[[2]], main = "GM12890 vs. GM12891")
abline(h = 0, lwd = 2, lty = 5)

</code></pre>

<hr>
<h2 id='normBioCondBySizeFactors'>Normalize <code>bioCond</code> Objects by Their Size Factors</h2><span id='topic+normBioCondBySizeFactors'></span>

<h3>Description</h3>

<p>Given a list of <code><a href="#topic+bioCond">bioCond</a></code> objects,
<code>normBioCondBySizeFactors</code> normalizes the signal intensities stored in
them based on their respective size factors, so that these <code>bioCond</code>s
become comparable to each other. Note that the normalization method
implemented in this function is most suited to the <code>bioCond</code>s comprised
of RNA-seq samples. See <code><a href="#topic+normBioCond">normBioCond</a></code> for a more robust method
for normalizing the <code>bioCond</code>s consisting of ChIP-seq samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normBioCondBySizeFactors(conds, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normBioCondBySizeFactors_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects to be normalized.</p>
</td></tr>
<tr><td><code id="normBioCondBySizeFactors_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying the subset of intervals or
genes to be used for estimating size factors.
Defaults to the intervals/genes occupied
by all the <code>bioCond</code> objects. See <code><a href="#topic+normalize">normalize</a></code> and
<code><a href="#topic+bioCond">bioCond</a></code> for more information about occupancy states of
intervals/genes in a biological condition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technically, <code>normBioCondBySizeFactors</code> considers each
<code><a href="#topic+bioCond">bioCond</a></code> object to be a single ChIP-seq/RNA-seq sample. It
treats the <code>sample.mean</code> variable of each <code>bioCond</code> as in the
scale of log2 read count, and applies the median ratio strategy to estimate
their respective size factors (see &quot;References&quot;). Finally, each
<code>bioCond</code> object is normalized by subtracting its log2 size factor
from each of its samples.
</p>
<p>The idea of <code>normBioCondBySizeFactors</code> comes from the principle that
the more similar a set of samples are to each other, the fewer biases are
expected to introduce when normalizing them. With this function, instead of
performing an overall normalization on all the samples involved, you may
choose to first normalize the samples within each biological condition, and
then perform a normalization between the resulting <code>bioCond</code> objects
(see &quot;Examples&quot; below).
</p>


<h3>Value</h3>

<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects with normalized signal
intensities, corresponding to the argument <code>conds</code>. To be noted,
information about the mean-variance dependence stored in the original
<code>bioCond</code> objects, if any, will be removed from the returned
<code>bioCond</code>s. You can re-fit a mean-variance curve for them by, for
example, calling <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>. Note also that the
original structure matrices are retained for each <code>bioCond</code> in the
returned list (see <code><a href="#topic+setWeight">setWeight</a></code> for a detailed description
of structure matrix).
</p>
<p>Besides, an attribute named <code>"size.factor"</code> is added to the
returned list, recording the size factor of each <code>bioCond</code> object.
</p>


<h3>References</h3>

<p>Anders, S. and W. Huber, <em>Differential expression analysis
for sequence count data.</em> Genome Biol, 2010. <strong>11</strong>(10): p. R106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalizeBySizeFactors">normalizeBySizeFactors</a></code> for normalizing
ChIP-seq/RNA-seq samples based on their size factors;
<code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+normBioCond">normBioCond</a></code> for performing an MA normalization on
<code>bioCond</code> objects; <code><a href="#topic+cmbBioCond">cmbBioCond</a></code> for combining a set of
<code>bioCond</code> objects into a single one; <code><a href="#topic+MAplot.bioCond">MAplot.bioCond</a></code>
for creating an MA plot on two normalized <code>bioCond</code> objects;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for modeling the mean-variance dependence
across intervals in <code>bioCond</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## First perform a normalization within each cell line, and then normalize
## across cell lines.

# Normalize samples separately for each cell line.
norm &lt;- normalizeBySizeFactors(H3K27Ac, 4)
norm &lt;- normalizeBySizeFactors(norm, 5:6,
                               subset = apply(norm[10:11], 1, all))
norm &lt;- normalizeBySizeFactors(norm, 7:8,
                               subset = apply(norm[12:13], 1, all))

# Construct separately a bioCond object for each cell line, and normalize
# the resulting bioConds by their size factors.
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
conds &lt;- normBioCondBySizeFactors(conds)

# Inspect the normalization effects.
attr(conds, "size.factor")
MAplot(conds[[1]], conds[[2]], main = "GM12890 vs. GM12891")
abline(h = 0, lwd = 2, lty = 5)

</code></pre>

<hr>
<h2 id='normCoef'>Deduce MA Normalization Coefficients</h2><span id='topic+normCoef'></span>

<h3>Description</h3>

<p>Deduce MA Normalization Coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normCoef(baseline, to.norm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normCoef_+3A_baseline">baseline</code></td>
<td>
<p>A numeric vector representing the baseline signal intensity.</p>
</td></tr>
<tr><td><code id="normCoef_+3A_to.norm">to.norm</code></td>
<td>
<p>A numeric vector representing the sample to be normalized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>c(slope, intercept)</code>
</p>

<hr>
<h2 id='plot.aovBioCond'>Plot an <code>aovBioCond</code> Object</h2><span id='topic+plot.aovBioCond'></span>

<h3>Description</h3>

<p>Given an <code><a href="#topic+aovBioCond">aovBioCond</a></code> object, which records the results of
calling differential genomic intervals across a set of <code><a href="#topic+bioCond">bioCond</a></code>
objects, this method creates a scatter plot of
<code>(conds.mean, log10(between.ms))</code> pairs from all genomic intervals,
marking specifically the ones that show a statistical significance. See
<code><a href="#topic+aovBioCond">aovBioCond</a></code> for a description of the two variables and the
associated hypothesis testing. The mean-variance curve associated with the
<code>bioCond</code> objects is also added to the plot, serving as a baseline to
which the <code>between.ms</code> variable of each interval could be compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aovBioCond'
plot(
  x,
  padj = NULL,
  pval = NULL,
  col = alpha(c("black", "red"), 0.04),
  pch = 20,
  xlab = "Mean",
  ylab = "log10(Var)",
  args.legend = list(x = "bottomleft"),
  args.lines = list(col = "green3", lwd = 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.aovBioCond_+3A_x">x</code></td>
<td>
<p>An object of class <code>"aovBioCond"</code>, typically a returned
value from <code><a href="#topic+aovBioCond">aovBioCond</a></code>.</p>
</td></tr>
<tr><td><code id="plot.aovBioCond_+3A_padj">padj</code>, <code id="plot.aovBioCond_+3A_pval">pval</code></td>
<td>
<p>Cutoff of adjusted/raw <em>p</em>-value for selecting
significant intervals. Only one of the two arguments is effectively
used; <code>pval</code> is ignored if <code>padj</code> is specified. The default is
equivalent to setting <code>padj</code> to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="plot.aovBioCond_+3A_col">col</code>, <code id="plot.aovBioCond_+3A_pch">pch</code></td>
<td>
<p>Optional length-2 vectors specifying the colors and point
characters of non-significant and significant intervals, respectively.
Elements are recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot.aovBioCond_+3A_xlab">xlab</code>, <code id="plot.aovBioCond_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the X and Y axes.</p>
</td></tr>
<tr><td><code id="plot.aovBioCond_+3A_args.legend">args.legend</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.aovBioCond_+3A_args.lines">args.lines</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plot.aovBioCond_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve for
a set of <code>bioCond</code> objects; <code><a href="#topic+aovBioCond">aovBioCond</a></code> for
calling differential intervals across multiple <code>bioCond</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Call differential genomic intervals among GM12890, GM12891 and GM12892
## cell lines and visualize the overall analysis results.

# Perform MA normalization and construct bioConds to represent the cell
# lines.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Variations in ChIP-seq signals across biological replicates of a cell line
# are generally of a low level, and their relationship with the mean signal
# intensities is expected to be well modeled by the presumed parametric
# form.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
summary(conds[[1]])
plotMeanVarCurve(conds, subset = "occupied")

# Perform a moderated ANOVA on these cell lines.
res &lt;- aovBioCond(conds)
head(res)

# Visualize the overall analysis results.
plot(res, padj = 1e-6)

</code></pre>

<hr>
<h2 id='plot.matrix'>Visualize a Matrix of Numeric Values</h2><span id='topic+plot.matrix'></span>

<h3>Description</h3>

<p>This method draws a heat map to demonstrate a numeric matrix, using
<code>gplots::<a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> as the underlying engine. Note that
the method retains the original (unscaled) values in the matrix, as well as
the orders of rows and columns of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
plot(
  x,
  breaks = 101,
  symbreaks = FALSE,
  col = NULL,
  low = "blue",
  mid = "white",
  high = "red",
  na.color = "black",
  lmat = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.matrix_+3A_x">x</code></td>
<td>
<p>The matrix of numeric values to be plotted.</p>
</td></tr>
<tr><td><code id="plot.matrix_+3A_breaks">breaks</code></td>
<td>
<p>Either a numeric vector indicating the splitting points for
binning <code>x</code> into colors, or an integer number of break points to be
used, in which case the break points will be spaced equally across the
data range.</p>
</td></tr>
<tr><td><code id="plot.matrix_+3A_symbreaks">symbreaks</code></td>
<td>
<p>Logical value indicating whether the break points should be
made symmetric about 0. Ignored if <code>breaks</code> is specified as a
numeric vector.</p>
</td></tr>
<tr><td><code id="plot.matrix_+3A_col">col</code></td>
<td>
<p>Colors used for the heat map. Must have a length equal to the
number of break points minus 1. By default, colors are generated by
<code><a href="gplots.html#topic+colorpanel">colorpanel</a></code>.</p>
</td></tr>
<tr><td><code id="plot.matrix_+3A_low">low</code>, <code id="plot.matrix_+3A_mid">mid</code>, <code id="plot.matrix_+3A_high">high</code></td>
<td>
<p>Arguments to be passed to
<code><a href="gplots.html#topic+colorpanel">colorpanel</a></code> to generate colors. Ignored if
<code>col</code> is explicitly specified. Note that setting <code>mid</code> to
<code>NA</code> suppresses the usage of this argument.</p>
</td></tr>
<tr><td><code id="plot.matrix_+3A_na.color">na.color</code></td>
<td>
<p>Color to be used for missing (<code>NA</code>) values.</p>
</td></tr>
<tr><td><code id="plot.matrix_+3A_lmat">lmat</code></td>
<td>
<p>Position matrix for the layout of color key and heat map. To be
passed to <code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code>. By default, the color key
lies above the heat map.</p>
</td></tr>
<tr><td><code id="plot.matrix_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned from <code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="gplots.html#topic+colorpanel">colorpanel</a></code> for generating a sequence of
colors that varies smoothly; <code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code> for drawing
a heat map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
x &lt;- matrix(rnorm(30, sd = 2), nrow = 5)
x[2, 5] &lt;- NA

# Use the default setting.
plot(x)

# Use break points symmetric about 0.
plot(x, symbreaks = TRUE)

</code></pre>

<hr>
<h2 id='plot.varTestBioCond'>Plot a <code>varTestBioCond</code> Object</h2><span id='topic+plot.varTestBioCond'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+varTestBioCond">varTestBioCond</a></code> object, which records the results of
calling hypervariable and invariant genomic intervals
across ChIP-seq samples of
a <code><a href="#topic+bioCond">bioCond</a></code> object, this method creates a scatter plot of
observed <code>(mean, log10(variance))</code> pairs
from all genomic intervals, marking
specifically the ones that have a significantly large or small variance.
Besides, the mean-variance curve associated with the <code>bioCond</code> is also
added to the plot, serving as a baseline to which each observed variance
could be compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varTestBioCond'
plot(
  x,
  padj = NULL,
  pval = NULL,
  col = alpha(c("black", "red"), 0.04),
  pch = 20,
  xlab = "Mean",
  ylab = "log10(Var)",
  args.legend = list(x = "bottomleft"),
  args.lines = list(col = "green3", lwd = 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.varTestBioCond_+3A_x">x</code></td>
<td>
<p>An object of class <code>"varTestBioCond"</code>, typically a returned
value from <code><a href="#topic+varTestBioCond">varTestBioCond</a></code>.</p>
</td></tr>
<tr><td><code id="plot.varTestBioCond_+3A_padj">padj</code>, <code id="plot.varTestBioCond_+3A_pval">pval</code></td>
<td>
<p>Cutoff of adjusted/raw <em>p</em>-value for selecting
significant intervals. Only one of the two arguments is effectively
used; <code>pval</code> is ignored if <code>padj</code> is specified. The default is
equivalent to setting <code>padj</code> to <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="plot.varTestBioCond_+3A_col">col</code>, <code id="plot.varTestBioCond_+3A_pch">pch</code></td>
<td>
<p>Optional length-2 vectors specifying the colors and point
characters of non-significant and significant intervals, respectively.
Elements are recycled if necessary.</p>
</td></tr>
<tr><td><code id="plot.varTestBioCond_+3A_xlab">xlab</code>, <code id="plot.varTestBioCond_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the X and Y axes.</p>
</td></tr>
<tr><td><code id="plot.varTestBioCond_+3A_args.legend">args.legend</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.varTestBioCond_+3A_args.lines">args.lines</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plot.varTestBioCond_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Those genomic intervals considered to be significant are actually the ones
that significantly deviate from the mean-variance curve in the plot. See
<code><a href="#topic+varTestBioCond">varTestBioCond</a></code> for technical details of the associated
hypothesis testing.
</p>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object from a
set of ChIP-seq samples; <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a
mean-variance curve; <code><a href="#topic+varTestBioCond">varTestBioCond</a></code> for calling
hypervariable and invariant intervals across ChIP-seq samples
contained in a <code>bioCond</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Call hypervariable and invariant genomic intervals across biological
## replicates of the GM12891 cell line.

# Perform MA normalization and construct a bioCond to represent GM12891.
norm &lt;- normalize(H3K27Ac, 5:6, 10:11)
GM12891 &lt;- bioCond(norm[5:6], norm[10:11], name = "GM12891")

# Fit a mean-variance curve for GM12891 using the parametric method.
GM12891 &lt;- fitMeanVarCurve(list(GM12891), method = "parametric",
                           occupy.only = TRUE)[[1]]
summary(GM12891)
plotMeanVarCurve(list(GM12891), subset = "occupied")

# Assess the observed variances of ChIP-seq signal intensities in GM12891.
res &lt;- varTestBioCond(GM12891)
head(res)

# Inspect only the test results of occupied genomic intervals.
res &lt;- res[GM12891$occupancy, ]
res$padj &lt;- p.adjust(res$pval, method = "BH")
plot(res, col = scales::alpha(c("black", "red"), c(0.04, 0.5)))

</code></pre>

<hr>
<h2 id='plotMeanVarCurve'>Plot a Mean-Variance Curve</h2><span id='topic+plotMeanVarCurve'></span>

<h3>Description</h3>

<p>Given a list of <code><a href="#topic+bioCond">bioCond</a></code> objects associated with a common
mean-variance curve, <code>plotMeanVarCurve</code> draws a scatter plot of
observed <code>(mean, log10(variance))</code> pairs from the genomic intervals
contained in them. It also adds the mean-variance curve to the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMeanVarCurve(
  conds,
  subset = c("all", "occupied", "non-occupied"),
  col = alpha("blue", 0.02),
  pch = 20,
  xlab = "Mean",
  ylab = "log10(Var)",
  args.legend = list(x = "bottomleft"),
  args.lines = list(col = "red", lwd = 2),
  only.add.line = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMeanVarCurve_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects with which a
mean-variance curve has been associated.</p>
</td></tr>
<tr><td><code id="plotMeanVarCurve_+3A_subset">subset</code></td>
<td>
<p>A character string indicating the subset of genomic intervals
used for the scatter plot (see &quot;Details&quot;). Must be one of <code>"all"</code>
(default), <code>"occupied"</code>, or <code>"non-occupied"</code>.
Can be abbreviated.</p>
</td></tr>
<tr><td><code id="plotMeanVarCurve_+3A_col">col</code>, <code id="plotMeanVarCurve_+3A_pch">pch</code></td>
<td>
<p>Optional vectors specifying the color and point character for
genomic intervals in each <code>bioCond</code>. Elements are recycled if
necessary.</p>
</td></tr>
<tr><td><code id="plotMeanVarCurve_+3A_xlab">xlab</code>, <code id="plotMeanVarCurve_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the X and Y axes.</p>
</td></tr>
<tr><td><code id="plotMeanVarCurve_+3A_args.legend">args.legend</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plotMeanVarCurve_+3A_args.lines">args.lines</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plotMeanVarCurve_+3A_only.add.line">only.add.line</code></td>
<td>
<p>A logical value. If set to <code>TRUE</code>, only the
mean-variance curve is added to the current plot.</p>
</td></tr>
<tr><td><code id="plotMeanVarCurve_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All <code><a href="#topic+bioCond">bioCond</a></code> objects supplied in <code>conds</code> should be
associated with the same mean-variance curve. Thus, they must have the same
<code>"mvcID"</code> (see <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for the data structure
stored in a <code>bioCond</code> object describing its fit of mean-variance
trend). Typically, <code>conds</code> is a returned value from
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>, <code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code> or
<code><a href="#topic+extendMeanVarCurve">extendMeanVarCurve</a></code>.
</p>
<p>Notably, to make the observed variance of each genomic interval in each
<code>bioCond</code> object comparable to the mean-variance curve, all variance
values used for the scatter plot have been adjusted for the variance ratio
factor specific to each <code>bioCond</code>. See <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>
and <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for a description of variance ratio
factor. Note also that there is a function named <code><a href="#topic+plotMVC">plotMVC</a></code>
that is specifically designed for plotting a mean-variance curve on a
single <code>bioCond</code>. This function scales mean-variance curve by the
associated variance ratio factor and leaves observed variances unadjusted.
</p>
<p>By default, each genomic interval in each <code>bioCond</code> object that
contains replicate samples provides one point for the scatter plot. Setting
<code>subset</code> to <code>"occupied"</code> (<code>"non-occupied"</code>) makes the
function use only those intervals occupied (not occupied) by their
<code>bioCond</code>s to draw the plot (see <code><a href="#topic+normalize">normalize</a></code> and
<code><a href="#topic+bioCond">bioCond</a></code> for more information about occupancy states of
genomic intervals).
</p>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing
groups of ChIP-seq samples.</em> Genome Res, 2021.
<strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve given a
list of <code>bioCond</code> objects; <code><a href="#topic+extendMeanVarCurve">extendMeanVarCurve</a></code> for
extending the application scope of a fitted mean-variance curve to
additional <code>bioCond</code> objects; <code><a href="#topic+varRatio">varRatio</a></code> for a formal
description of variance ratio factor; <code><a href="#topic+plotMVC">plotMVC</a></code> for plotting
a mean-variance curve on a single <code>bioCond</code> object;
<code><a href="#topic+normalize">normalize</a></code> for using
occupancy states of genomic intervals to normalize ChIP-seq samples;
<code><a href="scales.html#topic+alpha">alpha</a></code> for adjusting color transparency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Fit and plot a mean-variance curve for GM12891 and GM12892 cell lines.

# Perform the MA normalization and construct bioConds to represent
# individuals.
norm &lt;- normalize(H3K27Ac, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Fit mean-variance trend based on the presumed parametric form.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
summary(conds[[1]])

# Plot the fitted mean-variance curve.
plotMeanVarCurve(conds, subset = "occupied")

# Use different colors for the two bioConds, to see if the mean-variance
# points from the two cell lines mix uniformly with each other.
plotMeanVarCurve(conds, subset = "occupied",
                 col = scales::alpha(c("blue", "green3"), 0.02))

</code></pre>

<hr>
<h2 id='plotMVC'>Plot a Mean-Variance Curve on a Single <code>bioCond</code> Object</h2><span id='topic+plotMVC'></span>

<h3>Description</h3>

<p>Given an individual <code><a href="#topic+bioCond">bioCond</a></code> object associated with a
mean-variance curve, <code>plotMVC</code> draws a scatter plot of
observed <code>(mean, log10(variance))</code> pairs from the genomic intervals
contained in the <code>bioCond</code>. It also adds the mean-variance curve to
the plot. Notably, unlike <code><a href="#topic+plotMeanVarCurve">plotMeanVarCurve</a></code>, here the observed
variances used for plotting are not adjusted but the mean-variance curve is
scaled based on the associated variance ratio factor (see
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> and <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for a
description of variance ratio factor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMVC(
  cond,
  subset = c("all", "occupied", "non-occupied"),
  col = alpha("blue", 0.02),
  pch = 20,
  add = FALSE,
  xlab = "Mean",
  ylab = "log10(Var)",
  args.lines = list(col = "red", lwd = 2),
  only.add.line = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMVC_+3A_cond">cond</code></td>
<td>
<p>An individual <code><a href="#topic+bioCond">bioCond</a></code> object with which a
mean-variance curve has been associated.</p>
</td></tr>
<tr><td><code id="plotMVC_+3A_subset">subset</code></td>
<td>
<p>A character string indicating the subset of genomic intervals
used for the scatter plot. Must be one of <code>"all"</code>
(default), <code>"occupied"</code>, or <code>"non-occupied"</code>.
Can be abbreviated.</p>
</td></tr>
<tr><td><code id="plotMVC_+3A_col">col</code>, <code id="plotMVC_+3A_pch">pch</code></td>
<td>
<p>Optional vectors specifying the colors and point characters
of the genomic intervals in <code>cond</code>, respectively. Elements are
recycled to match the total number of intervals and are then subject to
the subsetting operation specified by <code>subset</code>.</p>
</td></tr>
<tr><td><code id="plotMVC_+3A_add">add</code></td>
<td>
<p>Whether to add points to existing graphics (by calling
<code><a href="graphics.html#topic+points">points</a></code>) or to create new graphics (by calling
<code><a href="graphics.html#topic+plot">plot</a></code>)?</p>
</td></tr>
<tr><td><code id="plotMVC_+3A_xlab">xlab</code>, <code id="plotMVC_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the X and Y axes.</p>
</td></tr>
<tr><td><code id="plotMVC_+3A_args.lines">args.lines</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plotMVC_+3A_only.add.line">only.add.line</code></td>
<td>
<p>A logical value. If set to <code>TRUE</code>, only the
mean-variance curve is added to existing graphics.</p>
</td></tr>
<tr><td><code id="plotMVC_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>
or <code><a href="graphics.html#topic+points">points</a></code>, depending on the setting of
<code>add</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing
groups of ChIP-seq samples.</em> Genome Res, 2021.
<strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve on a
list of <code>bioCond</code> objects; <code><a href="#topic+varRatio">varRatio</a></code> for a formal
description of variance ratio factor; <code><a href="#topic+plotMeanVarCurve">plotMeanVarCurve</a></code>
for plotting a mean-variance curve on a list of <code>bioCond</code> objects;
<code><a href="scales.html#topic+alpha">alpha</a></code> for adjusting color transparency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Fit and plot a mean-variance curve for the GM12892 cell line (i.e.,
## individual).

# Perform the MA normalization and construct a bioCond to represent GM12892.
norm &lt;- normalize(H3K27Ac, 7:8, 12:13)
GM12892 &lt;- bioCond(norm[7:8], norm[12:13], name = "GM12892")

# Fit a mean-variance curve by using the parametric method.
GM12892 &lt;- fitMeanVarCurve(list(GM12892), method = "parametric",
                           occupy.only = TRUE, init.coef = c(0.1, 10))[[1]]

# Draw a mean-variance scatter plot with adjusting observed variances.
plotMeanVarCurve(list(GM12892), subset = "occupied")

# Draw a mean-variance scatter plot with scaling the mean-variance curve.
plotMVC(GM12892, subset = "occupied")

</code></pre>

<hr>
<h2 id='print.bioCond'>Print a <code>bioCond</code> Object</h2><span id='topic+print.bioCond'></span>

<h3>Description</h3>

<p>This function prints its argument, which is a <code><a href="#topic+bioCond">bioCond</a></code> object,
and returns it invisibly (via <code><a href="base.html#topic+invisible">invisible</a>(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bioCond'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bioCond_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+bioCond">bioCond</a></code> object.</p>
</td></tr>
<tr><td><code id="print.bioCond_+3A_...">...</code></td>
<td>
<p>Arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <code><a href="base.html#topic+print">print</a></code> method for the
<code>"<a href="#topic+bioCond">bioCond</a>"</code> class.
</p>


<h3>Value</h3>

<p>The function returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Print bioConds that correspond to individuals.

# Perform the MA normalization and construct bioConds to represent
# individuals.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Print these bioConds.
print(conds[[1]])
print(conds[[2]])
print(conds[[3]])

</code></pre>

<hr>
<h2 id='print.summaryBioCond'>Print a <code>summaryBioCond</code> Object</h2><span id='topic+print.summaryBioCond'></span>

<h3>Description</h3>

<p>This function prints the <code><a href="#topic+summary.bioCond">summary</a></code> result of a
<code><a href="#topic+bioCond">bioCond</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summaryBioCond'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summaryBioCond_+3A_x">x</code></td>
<td>
<p>An object of class <code>"summaryBioCond"</code>, typically obtained by
passing a <code><a href="#topic+bioCond">bioCond</a></code> object to the
<code><a href="#topic+summary.bioCond">summary</a></code> function.</p>
</td></tr>
<tr><td><code id="print.summaryBioCond_+3A_...">...</code></td>
<td>
<p>Arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <code><a href="base.html#topic+print">print</a></code> method for the
<code>"summaryBioCond"</code> class.
</p>


<h3>Value</h3>

<p>The function returns <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+summary.bioCond">summary.bioCond</a></code> for summarizing a <code>bioCond</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Print summary results of bioConds that correspond to individuals.

# Perform the MA normalization and construct bioConds to represent
# individuals.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Print summary results of these bioConds.
print(summary(conds[[1]]))
print(summary(conds[[2]]))
print(summary(conds[[3]]))

# Print summary results of these bioConds after fitting a mean-variance
# curve for them.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
print(summary(conds[[1]]))
print(summary(conds[[2]]))
print(summary(conds[[3]]))

</code></pre>

<hr>
<h2 id='scaleMeanVarCurve'>Scale a Mean-Variance Curve</h2><span id='topic+scaleMeanVarCurve'></span>

<h3>Description</h3>

<p><code>scaleMeanVarCurve</code> underlies other interface functions for estimating
the variance ratio factor of an unadjusted mean-variance curve (or a set of
unadjusted mean-variance curves).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleMeanVarCurve(z, m, d0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaleMeanVarCurve_+3A_z">z</code></td>
<td>
<p>A list of which each element is a vector of FZ statistics
corresponding to a <code><a href="#topic+bioCond">bioCond</a></code> object (see also &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="scaleMeanVarCurve_+3A_m">m</code></td>
<td>
<p>A vector of numbers of replicates in <code>bioCond</code>
objects. Must correspond to <code>z</code> one by one in the same
order.</p>
</td></tr>
<tr><td><code id="scaleMeanVarCurve_+3A_d0">d0</code></td>
<td>
<p>A positive real specifying the number of
prior degrees of freedom of the
mean-variance curve(s). <code>Inf</code> is allowed. Note that <code>d0</code> is
typically estimated via <code><a href="#topic+estimateD0">estimateD0</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code><a href="#topic+bioCond">bioCond</a></code> object with replicate samples, a vector of
FZ statistics can be deduced from the unadjusted mean-variance curve
associated with it. More specifically, for each genomic interval in a
<code>bioCond</code> with replicate samples, its FZ statistic is defined to be
<code class="reqn">log(t_hat / v0)</code>, where <code class="reqn">t_hat</code> is the observed variance of signal
intensities of the interval, and <code class="reqn">v0</code> is the interval's prior variance
read from the corresponding mean-variance curve.
</p>
<p>Theoretically, each FZ statistic follows a scaled Fisher's Z distribution
plus a constant (since the mean-variance curve is not adjusted yet), and we
can use the sample mean (plus a constant that depends on the number of
prior degrees
of freedom) of the FZ statistics of each single <code>bioCond</code> to get
an estimate of log variance ratio factor.
</p>
<p>The final estimate of log variance ratio factor is a weighted mean of
estimates across <code>bioCond</code> objects, with the weights being their
respective numbers of genomic intervals that are used to calculate
FZ statistics.
This should be appropriate, as Fisher's Z distribution is roughly normal
(see also &quot;References&quot;). The weighted mean is actually a plain (unweighted)
mean across all the involved genomic intervals.
</p>
<p>Finally, we get an estimate of variance ratio factor by taking an
exponential.
</p>


<h3>Value</h3>

<p>The estimated variance ratio factor for adjusting the mean-variance
curve(s). Note that the function returns <code>NA</code> if there are not
sufficient genomic intervals for estimating it.
</p>


<h3>References</h3>

<p>Smyth, G.K., <em>Linear models and empirical bayes methods for
assessing differential expression in microarray experiments.</em> Stat Appl
Genet Mol Biol, 2004. <strong>3</strong>: p. Article3.
</p>
<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing groups of
ChIP-seq samples.</em> Genome Res, 2021. <strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve;
<code><a href="#topic+varRatio">varRatio</a></code> for a formal description of variance ratio
factor; <code><a href="#topic+estimateD0">estimateD0</a></code> for estimating the number of prior
degrees of freedom associated with a mean-variance curve (or a set
of curves); <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for an interface to
estimating the number of prior degrees of freedom on <code>bioCond</code>
objects as well as adjusting their mean-variance curve(s) accordingly.
</p>
<p><code><a href="#topic+estimateD0Robust">estimateD0Robust</a></code> and <code><a href="#topic+scaleMeanVarCurveRobust">scaleMeanVarCurveRobust</a></code>
for estimating number of prior degrees of freedom and variance ratio
factor <em>in a robust manner</em>, respectively.
</p>

<hr>
<h2 id='scaleMeanVarCurveRobust'>Scale a Mean-Variance Curve in a Robust Manner</h2><span id='topic+scaleMeanVarCurveRobust'></span>

<h3>Description</h3>

<p><code>scaleMeanVarCurveRobust</code> underlies other interface functions for
estimating the variance ratio factor of an unadjusted mean-variance curve
(or a set of unadjusted mean-variance curves)
<em>in a robust manner</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleMeanVarCurveRobust(
  z,
  m,
  d0,
  p_low = 0.01,
  p_up = 0.1,
  nw = gauss.quad(128, kind = "legendre")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaleMeanVarCurveRobust_+3A_z">z</code></td>
<td>
<p>A list of which each element is a vector of FZ statistics
corresponding to a <code><a href="#topic+bioCond">bioCond</a></code> object (see also &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="scaleMeanVarCurveRobust_+3A_m">m</code></td>
<td>
<p>A vector of numbers of replicates in <code>bioCond</code>
objects. Must correspond to <code>z</code> one by one in the same
order.</p>
</td></tr>
<tr><td><code id="scaleMeanVarCurveRobust_+3A_d0">d0</code></td>
<td>
<p>A positive real specifying the number of prior degrees of freedom
of the mean-variance curve(s). <code>Inf</code> is allowed. Note that
<code>d0</code> could be robustly estimated by <code><a href="#topic+estimateD0Robust">estimateD0Robust</a></code>.</p>
</td></tr>
<tr><td><code id="scaleMeanVarCurveRobust_+3A_p_low">p_low</code>, <code id="scaleMeanVarCurveRobust_+3A_p_up">p_up</code></td>
<td>
<p>Lower- and upper-tail probabilities for Winsorizing the
FZ statistics associated with each <code>bioCond</code>.</p>
</td></tr>
<tr><td><code id="scaleMeanVarCurveRobust_+3A_nw">nw</code></td>
<td>
<p>A list containing <code>nodes</code> and <code>weights</code> variables for
calculating the definite integral of a function <code>f</code> over the
interval <code>[-1, 1]</code>, which is approximated by
<code>sum(nw$weights * f(nw$nodes))</code>. By default,
a set of Gauss-Legendre nodes along with the corresponding weights
calculated by <code><a href="statmod.html#topic+gauss.quad">gauss.quad</a></code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code><a href="#topic+bioCond">bioCond</a></code> object with replicate samples, a vector of
FZ statistics can be deduced from the unadjusted mean-variance curve
associated with it. More specifically, for each genomic interval in a
<code>bioCond</code> with replicate samples, its FZ statistic is defined to be
<code class="reqn">log(t_hat / v0)</code>, where <code class="reqn">t_hat</code> is the observed variance of signal
intensities of the interval, and <code class="reqn">v0</code> is the interval's prior variance
read from the corresponding mean-variance curve.
</p>
<p>Theoretically, each FZ statistic follows a scaled Fisher's Z distribution
plus a constant (since the mean-variance curve is not adjusted yet),
and we derive a robust estimation of log variance ratio factor by
Winsorizing the FZ statistics of each <code>bioCond</code> and matching the
resulting sample mean with the theoretical expectation of the Winsorized
distribution, which is calculated by using numerical integration (see
also &quot;References&quot;).
</p>
<p>The final estimate of log variance ratio factor is a weighted mean of
estimates across <code>bioCond</code> objects, with the weights being their
respective numbers of genomic intervals that are used to calculate
FZ statistics.
</p>
<p>Finally, we get an estimate of variance ratio factor by taking an
exponential.
</p>


<h3>Value</h3>

<p>The estimated variance ratio factor for adjusting the mean-variance
curve(s). Note that the function returns <code>NA</code> if there are not
sufficient genomic intervals for estimating it.
</p>


<h3>References</h3>

<p>Phipson, B., et al., <em>Robust Hyperparameter Estimation
Protects against Hypervariable Genes and Improves Power to Detect
Differential Expression.</em> Annals of Applied Statistics, 2016.
<strong>10</strong>(2): p. 946-963.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve;
<code><a href="#topic+varRatio">varRatio</a></code> for a formal description of variance ratio
factor; <code><a href="#topic+estimateD0Robust">estimateD0Robust</a></code>
for estimating the number of prior degrees of freedom associated with
a mean-variance curve (or a set of curves) <em>in a robust manner</em>;
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> for an interface to <em>robustly</em>
estimating the number of prior degrees of freedom on <code>bioCond</code>
objects as well as <em>robustly</em> adjusting their mean-variance
curve(s) accordingly.
</p>
<p><code><a href="#topic+estimateD0">estimateD0</a></code> and <code><a href="#topic+scaleMeanVarCurve">scaleMeanVarCurve</a></code>
for the ordinary (non-robust) routines for estimating number of prior
degrees of freedom and variance ratio factor, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Refer to "Examples" given in the help page for the function
# estimateD0Robust.

</code></pre>

<hr>
<h2 id='setMeanVarCurve'>Set the Mean-Variance Curve of a Set of <code>bioCond</code> Objects</h2><span id='topic+setMeanVarCurve'></span>

<h3>Description</h3>

<p>Given a set of <code><a href="#topic+bioCond">bioCond</a></code> objects, <code>setMeanVarCurve</code>
associates a common mean-variance curve with each of them, assesses the
overall goodness of fit by estimating the
number of prior degrees of freedom, and
accordingly estimates their variance ratio factors
(see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMeanVarCurve(
  conds,
  predict,
  occupy.only = TRUE,
  method = "NA",
  ratio.var = estimateVarRatio(conds),
  .call = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setMeanVarCurve_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects, of which at least one
should contain replicate samples.</p>
</td></tr>
<tr><td><code id="setMeanVarCurve_+3A_predict">predict</code></td>
<td>
<p>A function representing the mean-variance curve to be
associated with the <code>bioCond</code>s. It should accept a vector of means
and return the predicted variances.</p>
</td></tr>
<tr><td><code id="setMeanVarCurve_+3A_occupy.only">occupy.only</code></td>
<td>
<p>A logical scalar. If it is <code>TRUE</code> (default), only
occupied intervals are used to estimate the number of prior degrees of
freedom and the variance ratio factors. Otherwise, all intervals are
used.</p>
</td></tr>
<tr><td><code id="setMeanVarCurve_+3A_method">method</code></td>
<td>
<p>A character string giving the method for fitting the
mean-variance curve. Used only for constructing the <code>fit.info</code>
fields (see &quot;Value&quot; below).</p>
</td></tr>
<tr><td><code id="setMeanVarCurve_+3A_ratio.var">ratio.var</code></td>
<td>
<p>Backup variance ratio factors of the <code>bioCond</code>s. Only
used when the estimated number of prior degrees of freedom is 0, which
in practice rarely happens.</p>
</td></tr>
<tr><td><code id="setMeanVarCurve_+3A_.call">.call</code></td>
<td>
<p>Never care about this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specific behavior of this function is pretty much the same as
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>, except that the mean-variance curve is
directly specified by users rather than fitted based on the observed
means and variances. Refer to <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for a detailed
description of related terms.
</p>
<p>Interestingly, if a positive constant function is supplied as the
mean-variance curve, the resulting statistical model will be rather similar
to the one implemented in the <code>limma</code> package (see also &quot;References&quot;).
Notably, using a constant function as the mean-variance curve is
particularly suited to <code>bioCond</code> objects
that have gone through a variance-stabilizing transformation (see
<code><a href="#topic+vstBioCond">vstBioCond</a></code> for details and &quot;Examples&quot; below) as well as
<code>bioCond</code>s whose structure matrices have been specifically
designed (see &quot;References&quot;).
</p>


<h3>Value</h3>

<p><code>setMeanVarCurve</code> returns the argument list of
<code><a href="#topic+bioCond">bioCond</a></code> objects, each of which has an added (updated)
<code>fit.info</code> field constructed based on the supplied
mean-variance curve. The field is itself a list consisting of the
following components:
</p>

<dl>
<dt><code>calls</code></dt><dd><p>The two function calls for associating a mean
variance curve with this <code>bioCond</code> and estimating the related
parameters, respectively. The latter is only present if you have
made an explicit call to some function
(e.g., <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code>) for performing the parameter
estimation.</p>
</dd>
<dt><code>method</code></dt><dd><p>Method used for fitting the mean-variance
curve.</p>
</dd>
<dt><code>predict</code></dt><dd><p>The supplied mean-variance function.</p>
</dd>
<dt><code>mvcID</code></dt><dd><p>ID of the mean-variance curve.</p>
</dd>
<dt><code>df.prior</code></dt><dd><p>Number of prior degrees of freedom
assessing the goodness of fit of the mean-variance curve.</p>
</dd>
<dt><code>ratio.var</code></dt><dd><p>Variance ratio factor of this
<code>bioCond</code>.</p>
</dd>
</dl>

<p>Each <code>bioCond</code> object in the returned list has the same values of
all these components but the <code>ratio.var</code>. <code>mvcID</code> is
automatically generated by the function to label the supplied
mean-variance curve. Each call to <code>setMeanVarCurve</code> results in a
unique <code>mvcID</code>.
</p>
<p>Besides, if there exist <code>bioCond</code> objects that contain only one
ChIP-seq sample, an attribute named <code>"no.rep.rv"</code> will be added to
the returned list, recording the variance ratio factor of no-replicate
conditions.
</p>


<h3>References</h3>

<p>Smyth, G.K., <em>Linear models and empirical bayes methods for
assessing differential expression in microarray experiments.</em> Stat Appl
Genet Mol Biol, 2004. <strong>3</strong>: p. Article3.
</p>
<p>Law, C.W., et al., <em>voom: Precision weights unlock linear model
analysis tools for RNA-seq read counts.</em> Genome Biol, 2014.
<strong>15</strong>(2): p. R29.
</p>
<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing groups of
ChIP-seq samples.</em> Genome Res, 2021. <strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object from a
set of ChIP-seq samples; <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a
mean-variance curve for a set of <code>bioCond</code> objects;
<code><a href="#topic+estimateVarRatio">estimateVarRatio</a></code> for estimating the relative variance
ratio factors of a set of <code>bioCond</code>s; <code><a href="#topic+varRatio">varRatio</a></code> for a
formal description of variance ratio factor;
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for estimating the number of prior degrees
of freedom and the corresponding variance ratio factors;
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> for a <em>robust</em> version of
<code>estimatePriorDf</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Perform differential analysis on bioConds that have gone through a
## variance-stabilizing transformation.

# Perform MA normalization and construct bioConds to represent cell lines
# (i.e., individuals).
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Fit a mean-variance curve.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
plotMeanVarCurve(conds, subset = "occupied")

# Apply a variance-stabilizing transformation.
vst_conds &lt;- list(GM12890 = vstBioCond(conds$GM12890))
vst.func &lt;- attr(vst_conds$GM12890, "vst.func")
temp &lt;- matrix(vst.func(as.numeric(conds$GM12891$norm.signal)),
               nrow = nrow(norm))
vst_conds$GM12891 &lt;- bioCond(temp, norm[10:11], name = "GM12891")
temp &lt;- matrix(vst.func(as.numeric(conds$GM12892$norm.signal)),
               nrow = nrow(norm))
vst_conds$GM12892 &lt;- bioCond(temp, norm[12:13], name = "GM12892")

# Associate a constant function with the resulting bioConds as their
# mean-variance curve.
vst_conds &lt;- setMeanVarCurve(vst_conds, function(x) rep_len(1, length(x)),
                             occupy.only = TRUE, method = "constant prior")
plotMeanVarCurve(vst_conds, subset = "occupied")

# Make a comparison between GM12891 and GM12892.
res1 &lt;- diffTest(conds$GM12891, conds$GM12892)
res2 &lt;- diffTest(vst_conds$GM12891, vst_conds$GM12892)

# Examine the consistency of analysis results between using ordinary and
# VSTed signal intensities. Here we map p-values together with observed
# directions of signal changes to the standard normal distribution.
z1 &lt;- qnorm(res1$pval / 2)
z1[res1$Mval &gt; 0] &lt;- -z1[res1$Mval &gt; 0]
z2 &lt;- qnorm(res2$pval / 2)
z2[res2$Mval &gt; 0] &lt;- -z2[res2$Mval &gt; 0]
plot(z1, z2, xlab = "Ordinary", ylab = "VSTed")
abline(a = 0, b = 1, lwd = 2, lty = 5, col = "red")
cor(z1, z2)
cor(z1, z2, method = "sp")

# Simultaneously compare GM12890, GM12891 and GM12892 cell lines.
res1 &lt;- aovBioCond(conds)
res2 &lt;- aovBioCond(vst_conds)

# Examine the consistency of analysis results between using ordinary and
# VSTed signal intensities by mapping p-values to the standard normal
# distribution.
z1 &lt;- qnorm(res1$pval, lower.tail = FALSE)
z1[z1 == Inf] &lt;- 39
z2 &lt;- qnorm(res2$pval, lower.tail = FALSE)
z2[z2 == Inf] &lt;- 39
plot(z1, z2, xlab = "Ordinary", ylab = "VSTed")
abline(a = 0, b = 1, lwd = 2, lty = 5, col = "red")
cor(z1, z2)
cor(z1, z2, method = "sp")

</code></pre>

<hr>
<h2 id='setPriorDf'>Set the Number of Prior Degrees of Freedom of Mean-Variance Curves</h2><span id='topic+setPriorDf'></span>

<h3>Description</h3>

<p>Given a set of <code><a href="#topic+bioCond">bioCond</a></code> objects of which each has been
associated with a mean-variance curve, <code>setPriorDf</code> assigns a
common number of prior degrees of freedom to all the <code>bioCond</code>s
and accordingly adjusts their variance ratio factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPriorDf(conds, d0, occupy.only = TRUE, no.rep.rv = NULL, .call = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPriorDf_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects, of which each has a
<code>fit.info</code> field describing its mean-variance curve (see also
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="setPriorDf_+3A_d0">d0</code></td>
<td>
<p>A non-negative real specifying the number of prior degrees of
freedom. <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="setPriorDf_+3A_occupy.only">occupy.only</code></td>
<td>
<p>A logical scalar. If it is <code>TRUE</code> (default), only
occupied intervals are used to adjust the variance ratio factors.
Otherwise, all intervals are used.</p>
</td></tr>
<tr><td><code id="setPriorDf_+3A_no.rep.rv">no.rep.rv</code></td>
<td>
<p>A positive real specifying the variance ratio factor of
those <code>bioCond</code>s without replicate samples, if any. By default,
it's set to the geometric mean of variance ratio factors of the other
<code>bioCond</code>s.</p>
</td></tr>
<tr><td><code id="setPriorDf_+3A_.call">.call</code></td>
<td>
<p>Never care about this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specific behavior of this function is pretty much the same as
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code>, except that
the number of prior degrees of freedom is
directly specified by users rather than estimated based on the observed
data. Refer to <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for more information.
</p>
<p>Note also that there is a <em>robust</em> version of this function that uses
Winsorized statistics to derive variance ratio factors (see
<code><a href="#topic+setPriorDfRobust">setPriorDfRobust</a></code> for details).
</p>


<h3>Value</h3>

<p><code>setPriorDf</code> returns the argument list of
<code><a href="#topic+bioCond">bioCond</a></code> objects, with the specified
number of prior degrees of
freedom substituted for the <code>"df.prior"</code> component of each of them.
Besides, their <code>"ratio.var"</code> components have been adjusted
accordingly, and an attribute named <code>"no.rep.rv"</code> is added to the
list if it's ever been used as the variance ratio factor of the
<code>bioCond</code>s without replicate samples.
</p>
<p>To be noted, if the specified number of prior degrees of freedom is 0,
<code>setPriorDf</code> won't adjust existing variance ratio factors.
In this case, you may want to use <code><a href="#topic+setPriorDfVarRatio">setPriorDfVarRatio</a></code> to
explicitly specify variance ratio factors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve and
using a <code>fit.info</code> field to characterize it;
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for estimating the number of prior
degrees of freedom and adjusting the variance ratio factors of a set of
<code>bioCond</code>s;
<code><a href="#topic+setPriorDfRobust">setPriorDfRobust</a></code> for a <em>robust</em> version of
<code>setPriorDf</code>;
<code><a href="#topic+diffTest.bioCond">diffTest</a></code> for calling
differential intervals between two <code>bioCond</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Fit a mean-variance curve for the GM12892 cell line (i.e., individual)
## and set the number of prior degrees of freedom of the curve to Inf.

# Perform the MA normalization and construct a bioCond to represent GM12892.
norm &lt;- normalize(H3K27Ac, 7:8, 12:13)
GM12892 &lt;- bioCond(norm[7:8], norm[12:13], name = "GM12892")

# Variations in ChIP-seq signals across biological replicates of a cell line
# are generally of a low level, and typically their relationship with the
# mean signal intensities could be well modeled by the presumed parametric
# form.
GM12892 &lt;- fitMeanVarCurve(list(GM12892), method = "parametric",
                           occupy.only = TRUE, init.coef = c(0.1, 10))[[1]]

# In the vast majority of cases for modeling biological replicates of cell
# lines, the associated variance structure is so regular that variances of
# individual genomic intervals could be reliably estimated by fully
# depending on the mean-variance curve.
GM12892_2 &lt;- setPriorDf(list(GM12892), Inf, occupy.only = TRUE)[[1]]

# The resulting model makes few differences from the original one, though.
# This is because MAnorm2 will adaptively deduce a large number of prior
# degrees of freedom for the mean-variance curve if the underlying variance
# structure is of high regularity. In practice, we recommend leaving the
# specification of prior df to the estimation method implemented in MAnorm2
# all the time.
summary(GM12892)
summary(GM12892_2)

</code></pre>

<hr>
<h2 id='setPriorDfRobust'>The Robust Counterpart of <code>setPriorDf</code></h2><span id='topic+setPriorDfRobust'></span>

<h3>Description</h3>

<p>Given a set of <code><a href="#topic+bioCond">bioCond</a></code> objects of which each has been
associated with a mean-variance curve, <code>setPriorDfRobust</code> assigns
a common number of prior degrees of freedom to all of them
and accordingly adjusts their variance ratio factors
<em>in a robust manner</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPriorDfRobust(
  conds,
  d0,
  occupy.only = TRUE,
  p_low = 0.01,
  p_up = 0.1,
  nw = gauss.quad(128, kind = "legendre"),
  no.rep.rv = NULL,
  .call = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPriorDfRobust_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects, of which each has a
<code>fit.info</code> field describing its mean-variance curve (see also
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="setPriorDfRobust_+3A_d0">d0</code></td>
<td>
<p>A non-negative real specifying the number of prior degrees of
freedom. <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="setPriorDfRobust_+3A_occupy.only">occupy.only</code></td>
<td>
<p>A logical scalar. If it is <code>TRUE</code> (default), only
occupied intervals are used to adjust the variance ratio factors.
Otherwise, all intervals are used.</p>
</td></tr>
<tr><td><code id="setPriorDfRobust_+3A_p_low">p_low</code></td>
<td>
<p>Lower- and upper-proportions of extreme values to be
Winsorized (see &quot;References&quot;). Each of them must be strictly larger than
0, and their sum must be strictly smaller than 1.</p>
</td></tr>
<tr><td><code id="setPriorDfRobust_+3A_p_up">p_up</code></td>
<td>
<p>Lower- and upper-proportions of extreme values to be
Winsorized (see &quot;References&quot;). Each of them must be strictly larger than
0, and their sum must be strictly smaller than 1.</p>
</td></tr>
<tr><td><code id="setPriorDfRobust_+3A_nw">nw</code></td>
<td>
<p>A list containing <code>nodes</code> and <code>weights</code> variables for
calculating the definite integral of a function <code>f</code> over the
interval <code>[-1, 1]</code>, which is approximated by
<code>sum(nw$weights * f(nw$nodes))</code>. By default,
a set of Gauss-Legendre nodes along with the corresponding weights
calculated by <code><a href="statmod.html#topic+gauss.quad">gauss.quad</a></code> is used.</p>
</td></tr>
<tr><td><code id="setPriorDfRobust_+3A_no.rep.rv">no.rep.rv</code></td>
<td>
<p>A positive real specifying the variance ratio factor of
those <code>bioCond</code>s without replicate samples, if any. By default,
it's set to the geometric mean of variance ratio factors of the other
<code>bioCond</code>s.</p>
</td></tr>
<tr><td><code id="setPriorDfRobust_+3A_.call">.call</code></td>
<td>
<p>Never care about this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specific behavior of this function is pretty much the same as
<code><a href="#topic+setPriorDf">setPriorDf</a></code>, except that this function adjusts variance
ratio factors in a manner that is <em>robust</em> to potential outliers
(see also &quot;References&quot;).
</p>


<h3>Value</h3>

<p><code>setPriorDfRobust</code> returns the argument list of
<code><a href="#topic+bioCond">bioCond</a></code> objects, with the specified
number of prior degrees of
freedom substituted for the <code>"df.prior"</code> component of each of them.
Besides, their <code>"ratio.var"</code> components have been adjusted
accordingly, and an attribute named <code>"no.rep.rv"</code> is added to the
list if it's ever been used as the variance ratio factor of the
<code>bioCond</code>s without replicate samples.
</p>
<p>To be noted, if the specified number of prior degrees of freedom is 0,
<code>setPriorDfRobust</code> won't adjust existing variance ratio factors.
In this case, you may want to use <code><a href="#topic+setPriorDfVarRatio">setPriorDfVarRatio</a></code> to
explicitly specify variance ratio factors.
</p>


<h3>References</h3>

<p>Tukey, J.W., <em>The future of data analysis.</em> The annals of
mathematical statistics, 1962. <strong>33</strong>(1): p. 1-67.
</p>
<p>Phipson, B., et al., <em>Robust Hyperparameter Estimation
Protects against Hypervariable Genes and Improves Power to Detect
Differential Expression.</em> Annals of Applied Statistics, 2016.
<strong>10</strong>(2): p. 946-963.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve and
using a <code>fit.info</code> field to characterize it;
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> for estimating the number of
prior degrees of freedom and adjusting the variance ratio factors of
a set of <code>bioCond</code>s <em>in a robust manner</em>;
<code><a href="#topic+setPriorDf">setPriorDf</a></code> for the ordinary (non-robust) version of
<code>setPriorDfRobust</code>;
<code><a href="#topic+diffTest.bioCond">diffTest</a></code> for calling
differential intervals between two <code>bioCond</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Fit a mean-variance curve for the GM12892 cell line (i.e., individual)
## and set the number of prior degrees of freedom of the curve to Inf.

# Perform the MA normalization and construct a bioCond to represent GM12892.
norm &lt;- normalize(H3K27Ac, 7:8, 12:13)
GM12892 &lt;- bioCond(norm[7:8], norm[12:13], name = "GM12892")

# Fit a mean-variance curve by using the parametric method.
GM12892 &lt;- fitMeanVarCurve(list(GM12892), method = "parametric",
                           occupy.only = TRUE, init.coef = c(0.1, 10))[[1]]

# Set the number of prior degrees of freedom to Inf.
GM12892_2 &lt;- setPriorDf(list(GM12892), Inf, occupy.only = TRUE)[[1]]

# Use the robust version of setPriorDf.
GM12892_3 &lt;- setPriorDfRobust(list(GM12892), Inf, occupy.only = TRUE)[[1]]

# In this case, there is little difference in estimated variance ratio
# factor between the ordinary routine and the robust one.
summary(GM12892_2)
summary(GM12892_3)

</code></pre>

<hr>
<h2 id='setPriorDfVarRatio'>Set the Number of Prior Degrees of Freedom and Variance Ratio Factors</h2><span id='topic+setPriorDfVarRatio'></span>

<h3>Description</h3>

<p>Given a set of <code><a href="#topic+bioCond">bioCond</a></code> objects of which each has been
associated with a mean-variance curve, <code>setPriorDfVarRatio</code> assigns
a common number of prior degrees of freedom to all of them
and sets their variance ratio factors based on user-provided values.
There are few scenarios where you need to call this function
(see &quot;Details&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPriorDfVarRatio(
  conds,
  d0 = 0,
  ratio.var = estimateVarRatio(conds),
  .call = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setPriorDfVarRatio_+3A_conds">conds</code></td>
<td>
<p>A list of <code><a href="#topic+bioCond">bioCond</a></code> objects, of which each has a
<code>fit.info</code> field describing its mean-variance curve (see also
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="setPriorDfVarRatio_+3A_d0">d0</code></td>
<td>
<p>A non-negative real specifying the number of prior degrees of
freedom. Specifying a value other than 0 will lead to a warning
(see also &quot;Details&quot;).</p>
</td></tr>
<tr><td><code id="setPriorDfVarRatio_+3A_ratio.var">ratio.var</code></td>
<td>
<p>A vector giving the variance ratio factors of the
<code>bioCond</code>s. Elements are recycled if necessary. By default, it's
estimated by calling <code><a href="#topic+estimateVarRatio">estimateVarRatio</a></code>.</p>
</td></tr>
<tr><td><code id="setPriorDfVarRatio_+3A_.call">.call</code></td>
<td>
<p>Never care about this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, the only reason for which you need to call this function is that
you don't want to borrow information between genomic intervals to improve
variance estimation. Therefore, this function should be in principle called
always with the default value (i.e., 0) for <code>d0</code>, in which case you
can still account for potential differences in global within-group
variability between groups of samples. Otherwise, you should empirically
estimate <code>d0</code> via, for example, <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> or
<code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code>.
</p>
<p>There are two typical scenarios in which you don't want to borrow
information between genomic intervals. In the first one, the estimated
<code>d0</code> derived by <code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code> is 0 because the
underlying variance structure is highly irregular. In the second one, there
are sufficient replicate samples (e.g., &gt;7 profiles in each group) such that
observed variances alone could provide reliable variance estimates.
</p>


<h3>Value</h3>

<p>The argument list of
<code><a href="#topic+bioCond">bioCond</a></code> objects, with updated <code>"df.prior"</code> and
<code>"ratio.var"</code> components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve and
using a <code>fit.info</code> field to characterize it;
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> and <code><a href="#topic+estimatePriorDfRobust">estimatePriorDfRobust</a></code>
for estimating the number of prior degrees of freedom and adjusting
the variance ratio factors of a set of <code>bioCond</code>s;
<code><a href="#topic+setPriorDf">setPriorDf</a></code> and <code><a href="#topic+setPriorDfRobust">setPriorDfRobust</a></code>
for setting the number of prior degrees of freedom and accordingly
adjusting the variance ratio factors of a set of <code>bioCond</code>s.
</p>

<hr>
<h2 id='setWeight'>Set the Weights of Signal Intensities Contained in a <code>bioCond</code></h2><span id='topic+setWeight'></span>

<h3>Description</h3>

<p><code>setWeight</code> modifies the relative precisions of signal intensities
stored in a <code><a href="#topic+bioCond">bioCond</a></code> object. One typically uses this function
in the form of <code>x &lt;- setWeight(x, weight)</code>, where <code>x</code> is a
<code>bioCond</code> object and <code>weight</code> is a matrix of positive weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setWeight(x, weight = NULL, strMatrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setWeight_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+bioCond">bioCond</a></code> object.</p>
</td></tr>
<tr><td><code id="setWeight_+3A_weight">weight</code></td>
<td>
<p>A matrix or data frame specifying the relative precisions of
signal intensities contained in <code>x</code>. Must have the same number of
columns as <code>x$norm.signal</code>. A vector is interpreted as a matrix
having a single row. Note that rows of <code>weight</code> are recycled if
necessary. By default, the same weight is assigned to each measurement
in <code>x$norm.signal</code>.</p>
</td></tr>
<tr><td><code id="setWeight_+3A_strmatrix">strMatrix</code></td>
<td>
<p>An optional list of symmetric matrices specifying directly
the structure matrix of each genomic interval. Elements of it are
recycled if necessary.
This argument, if set, overrides the <code>weight</code>
argument. See &quot;Details&quot; for more information about structure matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each genomic interval in a <code><a href="#topic+bioCond">bioCond</a></code> object, MAnorm2 models
the signal intensities of it as having a common mean and a covariance
matrix proportional to the interval's structure matrix. Put it formally,
<code class="reqn">cov(Xi | ti) = ti * Si</code>, where <code class="reqn">Xi</code> is
the vector of signal intensities of the <code class="reqn">i</code>th interval, <code class="reqn">ti</code> is a
positive scalar quantifying the variation level of this interval and
<code class="reqn">Si</code> is a symmetric matrix denoting the interval's structure matrix.
</p>
<p>Naturally, assuming there are no correlations between ChIP-seq samples,
each <code class="reqn">Si</code> is a diagonal matrix, with its diagonal elements being the
reciprocal of the corresponding weights.
</p>
<p>The structure matrices will be used to derive the sample mean and sample
variance (i.e., estimate of <code class="reqn">ti</code>) of signal intensities of each
interval, using the GLS (generalized least squares) estimation. See also
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for modeling their relationship across
intervals.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+bioCond">bioCond</a></code> object with an updated <code>strMatrix</code>
field. To be noted, information about the mean-variance dependence of
the original <code>bioCond</code> object, if any, will be removed in the
returned <code>bioCond</code>. You can re-fit it by, for example, calling
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>.
</p>


<h3>Warning</h3>

<p>Do not directly modify the <code>strMatrix</code> field in a
<code><a href="#topic+bioCond">bioCond</a></code> object. Instead, use this function.
</p>


<h3>References</h3>

<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing
groups of ChIP-seq samples.</em> Genome Res, 2021.
<strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object based on
normalized signal intensities; <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting
the mean-variance trend across genomic intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Set the weights of replicate ChIP-seq samples in a bioCond.

# Construct a bioCond object for the GM12891 cell line. By default, all the
# ChIP-seq samples belonging to the bioCond have the same weight for
# estimating the mean signal intensities of genomic intervals in the cell
# line.
norm &lt;- normalize(H3K27Ac, 5:6, 10:11)
GM12891 &lt;- bioCond(norm[5:6], norm[10:11], name = "GM12891")

# Now we set the weight of the 2nd sample to half of the 1st one.
GM12891_2 &lt;- setWeight(GM12891, weight = c(1, 0.5))

# Equivalently, you can achieve the same effect by setting the strMatrix
# parameter.
GM12891_3 &lt;- setWeight(GM12891, strMatrix = list(diag(c(1, 2))))

</code></pre>

<hr>
<h2 id='summary.bioCond'>Summarize a <code>bioCond</code> Object</h2><span id='topic+summary.bioCond'></span>

<h3>Description</h3>

<p>The method produces an object that summarizes the data and fit information
of mean-variance dependence (if available) stored in a <code><a href="#topic+bioCond">bioCond</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bioCond'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bioCond_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+bioCond">bioCond</a></code> object.</p>
</td></tr>
<tr><td><code id="summary.bioCond_+3A_...">...</code></td>
<td>
<p>Arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the <code><a href="base.html#topic+summary">summary</a></code> method for the
<code>"<a href="#topic+bioCond">bioCond</a>"</code> class.
</p>


<h3>Value</h3>

<p>The method returns an object of class <code>"summaryBioCond"</code>, for
which a specialized <code><a href="base.html#topic+print">print</a></code> method has been defined.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object.
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve on
<code>bioCond</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Summarize bioConds that correspond to individuals.

# Perform the MA normalization and construct bioConds to represent
# individuals.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Summarize these bioConds.
summary(conds[[1]])
summary(conds[[2]])
summary(conds[[3]])
str(summary(conds[[3]]))

# Summarize these bioConds after fitting a mean-variance curve for them.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
summary(conds[[1]])
summary(conds[[2]])
summary(conds[[3]])
str(summary(conds[[3]]))

</code></pre>

<hr>
<h2 id='util.trigamma'>Utility Trigamma Function</h2><span id='topic+util.trigamma'></span>

<h3>Description</h3>

<p><code>util.trigamma</code> is essentially the same as the
<code><a href="base.html#topic+trigamma">trigamma</a></code> function but is for being consistent with the
<code><a href="#topic+inv.trigamma">inv.trigamma</a></code> function at very small or very large input
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>util.trigamma(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="util.trigamma_+3A_y">y</code></td>
<td>
<p>A positive numeric scalar. <code>Inf</code> is allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive numeric scalar, which is essentially the same as
<code><a href="base.html#topic+trigamma">trigamma</a>(y)</code> but could be a little different at very
small or very large <code>y</code> values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inv.trigamma">inv.trigamma</a></code> for an implementation of the inversion
of the <code><a href="base.html#topic+trigamma">trigamma</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trigamma(1:6)
vapply(1:6, util.trigamma, numeric(1))

trigamma(1e-4)
util.trigamma(1e-4)

trigamma(1e8)
util.trigamma(1e8)

trigamma(Inf)
util.trigamma(Inf)

</code></pre>

<hr>
<h2 id='varRatio'>Compare Variance Ratio Factors of Two <code>bioCond</code> Objects</h2><span id='topic+varRatio'></span>

<h3>Description</h3>

<p>Given two <code><a href="#topic+bioCond">bioCond</a></code> objects, <code>varRatio</code> robustly estimates
the ratio between their variance ratio factors, assuming they are
associated with the same mean-variance curve and using the genomic intervals
expected to have invariant signal intensities across the two biological
conditions (see &quot;Details&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varRatio(cond1, cond2, invariant = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varRatio_+3A_cond1">cond1</code>, <code id="varRatio_+3A_cond2">cond2</code></td>
<td>
<p>Two <code><a href="#topic+bioCond">bioCond</a></code> objects.</p>
</td></tr>
<tr><td><code id="varRatio_+3A_invariant">invariant</code></td>
<td>
<p>An optional non-negative real specifying the upper bound
of difference in mean signal intensity for a genomic interval to be
treated as invariant between <code>cond1</code> and <code>cond2</code>. By default,
intervals occupied by both conditions are treated as invariant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MAnorm2 models ChIP-seq samples as grouped by biological conditions. It
constructs a <code><a href="#topic+bioCond">bioCond</a></code> object to represent each biological
condition, which contains a set of ChIP-seq samples belonging to the
condition.
</p>
<p>Given multiple <code>bioCond</code> objects, MAnorm2 could fit a single curve to
model the mean-variance dependence across genomic intervals.
Each genomic interval in
each <code>bioCond</code> object that contains replicate samples serves as an
observation for the fitting process.
</p>
<p>To account for the global difference in variation level of signal
intensities between two conditions, MAnorm2 involves a &quot;variance ratio
factor&quot; for each condition. Specifically, given two <code>bioCond</code>
objects associated with the same mean-variance curve
(say condition 1 and 2), we have
</p>
<p style="text-align: center;"><code class="reqn">cov(Xi,1 | vi) = (r1 * vi) * Si,1</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">cov(Xi,2 | vi) = (r2 * vi) * Si,2</code>
</p>

<p>for any genomic interval <code class="reqn">i</code> that is <em>not</em>
differentially represented between the two conditions. Here, <code class="reqn">Xi,j</code>
is the vector of signal intensities of interval <code class="reqn">i</code>
in condition <code class="reqn">j</code>,
<code class="reqn">rj</code> is the variance ratio factor (a scalar) of condition <code class="reqn">j</code>,
<code class="reqn">vi</code> is the unscaled variance (a scalar) of signal intensities in
interval <code class="reqn">i</code>, and <code class="reqn">Si,j</code> is the structure matrix of interval <code class="reqn">i</code>
in condition <code class="reqn">j</code> (see <code><a href="#topic+bioCond">bioCond</a></code> and <code><a href="#topic+setWeight">setWeight</a></code>
for a detailed description of structure matrix).
</p>
<p>Under this formulation, <code>varRatio</code> estimates the ratio of the
variance ratio factor of <code>cond2</code> to that of <code>cond1</code>, using the
intervals with invariant signal intensities across the two conditions. The
argument <code>invariant</code> controls the set of such intervals.
By default, intervals
occupied by both conditions constitute the set. Alternatively, giving
<code>invariant</code> a non-negative value
specifies these intervals to be invariant
that have a difference in average signal intensity between the two
conditions less than or equal to the value.
</p>
<p>In most cases, you don't need to call this function directly. It's typically
used by <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance trend on a
set of <code>bioCond</code> objects.
</p>


<h3>Value</h3>

<p>The estimated ratio of the variance ratio factor of <code>cond2</code> to
that of <code>cond1</code>. Note that the function returns <code>NA</code> if there
are not sufficient invariant intervals for estimating it.
</p>


<h3>References</h3>

<p>Tu, S., et al., <em>MAnorm2 for quantitatively comparing
groups of ChIP-seq samples.</em> Genome Res, 2021.
<strong>31</strong>(1): p. 131-145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+setWeight">setWeight</a></code> for a detailed description of structure matrix;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve given a
set of <code>bioCond</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Compare variance ratio factor between cell lines.

# Perform the MA normalization and construct bioConds to represent cell
# lines.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Compare the variance ratio factor of GM12892 to that of GM12891.
varRatio(conds$GM12891, conds$GM12892)

# Such a comparison is only possible when both bioConds have replicate
# samples.
varRatio(conds$GM12891, conds$GM12890)

</code></pre>

<hr>
<h2 id='varTestBioCond'>Call Hypervariable and Invariant Intervals for a <code>bioCond</code></h2><span id='topic+varTestBioCond'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+bioCond">bioCond</a></code> object with which a mean-variance curve is
associated (see <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>), <code>varTestBioCond</code> tests
for each genomic interval if the observed variation of its signal intensity
across ChIP-seq samples in the <code>bioCond</code> is significantly greater or
less than is implied by the curve. This function is typically used
in combination with <code><a href="#topic+estParamHyperChIP">estParamHyperChIP</a></code> to call hypervariable
and invariant intervals in a <code>bioCond</code> (see also &quot;Examples&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varTestBioCond(cond, min.var = 0, df.prior = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varTestBioCond_+3A_cond">cond</code></td>
<td>
<p>A <code><a href="#topic+bioCond">bioCond</a></code> object with which a mean-variance curve
has been associated (see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="varTestBioCond_+3A_min.var">min.var</code></td>
<td>
<p>Lower bound of variances read from the mean-variance
curve. Any variance read from the curve less than <code>min.var</code> will be
adjusted to this value. It's primarily used for safely getting the prior
variances and taking into account the practical significance of a signal
variation.</p>
</td></tr>
<tr><td><code id="varTestBioCond_+3A_df.prior">df.prior</code></td>
<td>
<p>Number of prior degrees of freedom associated with the
mean-variance curve. Must be positive.
Can be set to <code>Inf</code> (see &quot;Details&quot;).
The default value should be used in most cases, which is extracted from
the <code>"df.prior"</code> component of <code>cond</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>varTestBioCond</code> adopts the modeling strategy implemented in
<code>limma</code> (see &quot;References&quot;),
except that each genomic interval has its own
prior variance, which is read from the mean-variance curve associated with
the <code><a href="#topic+bioCond">bioCond</a></code> object. The argument <code>df.prior</code> could be
used to specify the common number of degrees of freedom of all the prior
variances, which also effectively assesses the overall goodness of fit of
the mean-variance curve. Technically, <code>varTestBioCond</code> uses
the ratio of the observed variance of each interval to its prior variance as
key statistic, which under the null hypothesis follows an <em>F</em>
distribution, with
its two numbers of degrees of freedom being those of the two variances,
respectively.
(Hence the statistic follows a scaled chi-squared distribution when the
prior df is <code>Inf</code>.) To be noted, the prior df can be empirically
estimated for each
mean-variance curve by specifically designed statistical methods
(see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>, <code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code>,
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code>, and <code><a href="#topic+estParamHyperChIP">estParamHyperChIP</a></code>)
and, by default, the function uses the
estimation result to perform the tests. It's highly not recommended to
specify <code>df.prior</code> explicitly when calling <code>varTestBioCond</code>,
unless you know what you are really doing. Besides, <code>varTestBioCond</code>
won't adjust the variance ratio factor of the provided <code>bioCond</code> based
on the specified prior df (see <code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code>
for a description of variance ratio factor).
</p>
<p>Any <code>bioCond</code> object passed to <code>varTestBioCond</code> must contain at
least two ChIP-seq samples; the observed variances of individual
genomic intervals cannot be calculated otherwise.
Besides, a mean-variance curve must be associated with the <code>bioCond</code>
for deducing the prior variances before
<code>varTestBioCond</code> could work. Notably, when fitting a mean-variance
curve for a <code>bioCond</code> object to be passed to <code>varTestBioCond</code>,
it's recommended to pass it alone to <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> (not
involving other <code>bioCond</code> objects). Also, if you have set
<code>occupy.only</code> to <code>TRUE</code> when calling
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>, you should accordingly inspect only the test
results of those genomic intervals that are occupied by the <code>bioCond</code>,
and should re-adjust
<em>p</em>-values within this set of intervals (see &quot;Examples&quot; below).
</p>
<p><code>varTestBioCond</code> can also be used to call hypervariable and invariant
intervals across biological conditions, by first combining multiple
<code>bioCond</code> objects into a single one (see &quot;Examples&quot; below). Note that
ChIP-seq samples in those <code>bioCond</code>s to be combined must be first
normalized to the same level (see <code><a href="#topic+cmbBioCond">cmbBioCond</a></code> for details).
</p>


<h3>Value</h3>

<p>This function returns an object of <code><a href="base.html#topic+class">class</a></code>
<code>c("varTestBioCond", "data.frame")</code>, recording the test results for
each genomic interval by each row. The data frame consists of the
following variables:
</p>

<dl>
<dt><code>observed.mean</code></dt><dd><p>Sample mean of the observed signal
intensities.</p>
</dd>
<dt><code>observed.var</code></dt><dd><p>Sample variance of the observed signal
intensities.</p>
</dd>
<dt><code>prior.var</code></dt><dd><p>Prior variance corresponding to the
observed mean signal intensity.</p>
</dd>
<dt><code>fold.change</code></dt><dd><p>Ratio of <code>observed.var</code> to
<code>prior.var</code>.</p>
</dd>
<dt><code>pval</code></dt><dd><p>Two sided <em>p</em>-value for the statistical
significance of this fold change.</p>
</dd>
<dt><code>padj</code></dt><dd><p><em>P</em>-value adjusted for multiple testing with
the <code>"BH"</code> method (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>), which
controls false discovery rate.</p>
</dd>
</dl>

<p>Row names of the returned data frame inherit from those of
<code>cond$norm.signal</code>. Besides, several attributes are added to the
returned object:
</p>

<dl>
<dt><code>bioCond.name</code></dt><dd><p>Name of the <code><a href="#topic+bioCond">bioCond</a></code>
object.</p>
</dd>
<dt><code>mean.var.curve</code></dt><dd><p>A function representing the
mean-variance curve. It accepts a vector of mean signal intensities
and returns the corresponding prior variances. Note that this
function has incorporated variance ratio factor of the
<code>bioCond</code> and the <code>min.var</code> argument.</p>
</dd>
<dt><code>df</code></dt><dd><p>A length-2 vector giving the numbers of degrees of
freedom of the observed and prior variances.</p>
</dd>
</dl>



<h3>References</h3>

<p>Smyth, G.K., <em>Linear models and empirical bayes methods for
assessing differential expression in microarray experiments.</em> Stat Appl
Genet Mol Biol, 2004. <strong>3</strong>: p. Article3.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve for
a set of <code>bioCond</code> objects; <code><a href="#topic+setMeanVarCurve">setMeanVarCurve</a></code> for
setting the mean-variance curve of a set of <code>bioCond</code>s;
<code><a href="#topic+estimatePriorDf">estimatePriorDf</a></code> for estimating number of prior degrees of
freedom as well as adjusting variance ratio factors accordingly;
<code><a href="#topic+estParamHyperChIP">estParamHyperChIP</a></code> for applying the parameter estimation
framework of HyperChIP;
<code><a href="#topic+cmbBioCond">cmbBioCond</a></code> for combining multiple <code>bioCond</code>s
into a single one.
</p>
<p><code><a href="#topic+plot.varTestBioCond">plot.varTestBioCond</a></code> for creating a plot to demonstrate a
<code>varTestBioCond</code> object; <code><a href="#topic+diffTest.bioCond">diffTest</a></code>
for calling differential intervals between two <code>bioCond</code> objects;
<code><a href="#topic+aovBioCond">aovBioCond</a></code> for calling differential intervals across
multiple <code>bioCond</code>s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scales)
data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Call hypervariable and invariant genomic intervals across biological
## replicates of the GM12891 cell line.

# Perform MA normalization and construct a bioCond to represent GM12891.
norm &lt;- normalize(H3K27Ac, 5:6, 10:11)
GM12891 &lt;- bioCond(norm[5:6], norm[10:11], name = "GM12891")

# Fit a mean-variance curve for GM12891 using the parametric method.
GM12891 &lt;- fitMeanVarCurve(list(GM12891), method = "parametric",
                           occupy.only = TRUE)[[1]]
summary(GM12891)
plotMeanVarCurve(list(GM12891), subset = "occupied")

# Assess the observed variances of ChIP-seq signal intensities in GM12891.
res &lt;- varTestBioCond(GM12891)
head(res)

# Inspect only the test results of occupied genomic intervals.
res &lt;- res[GM12891$occupancy, ]
res$padj &lt;- p.adjust(res$pval, method = "BH")
plot(res, padj = 0.2, col = alpha(c("black", "red"), c(0.04, 0.5)))

## Call hypervariable and invariant genomic intervals across cell lines.

# Perform MA normalization and construct bioConds to represent cell lines.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))

# Normalize the cell lines.
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Combine the cell lines into a single bioCond and use local regression to
# adaptively capture the mean-variance trend. Only genomic intervals that
# are occupied by each of the cell lines are considered to be occupied by
# the combined bioCond, which is for avoiding over-estimation of the prior
# variances.
LCLs &lt;- cmbBioCond(conds, occupy.num = length(conds),
                   name = "lymphoblastoid_cell_lines")
LCLs &lt;- fitMeanVarCurve(list(LCLs), method = "local",
                        occupy.only = FALSE)[[1]]
LCLs &lt;- estimatePriorDf(list(LCLs), occupy.only = TRUE)[[1]]
summary(LCLs)
plotMeanVarCurve(list(LCLs), subset = "all")

# Assess the observed variances of ChIP-seq signal intensities across these
# cell lines.
res &lt;- varTestBioCond(LCLs)
head(res)
plot(res, pval = 0.01, col = alpha(c("black", "red"), c(0.04, 0.5)))

# Non-occupied intervals are occupied by some of the cell lines but not all
# of them. These intervals tend to be more variable across the cell lines
# and more significant in the tests than occupied intervals.
f &lt;- !(LCLs$occupancy)
wilcox.test(res$fold.change[f], res$fold.change[!f],
            alternative = "greater")
wilcox.test(res$pval[f], res$pval[!f], alternative = "less")

# Intervals in Y chromosome tend to be more variable across the cell lines
# and more significant in the tests than the other intervals, since the cell
# lines are of different genders.
f &lt;- H3K27Ac$chrom == "chrY"
wilcox.test(res$fold.change[f], res$fold.change[!f],
            alternative = "greater")
wilcox.test(res$pval[f], res$pval[!f], alternative = "less")

# Make a comparison with HyperChIP.
LCLs2 &lt;- estParamHyperChIP(LCLs, occupy.only = FALSE, prob = 0.1)
summary(LCLs)
summary(LCLs2)
res2 &lt;- varTestBioCond(LCLs2)
hist(res$pval, breaks = 100, col = "red")
hist(res2$pval, breaks = 100, col = "red")

</code></pre>

<hr>
<h2 id='vstBioCond'>Apply a Variance-Stabilizing Transformation to a <code>bioCond</code></h2><span id='topic+vstBioCond'></span>

<h3>Description</h3>

<p>Given a <code><a href="#topic+bioCond">bioCond</a></code> object with which a mean-variance curve is
associated, <code>vstBioCond</code> deduces a variance-stabilizing transformation
(VST) based on the curve, and applies it to the signal intensities of
samples contained in the <code>bioCond</code>, so that variances of individual
genomic intervals are comparable between each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vstBioCond(x, min.var = 0, integrate.func = integrate, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vstBioCond_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+bioCond">bioCond</a></code> object with which a mean-variance curve
has been associated (see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>).</p>
</td></tr>
<tr><td><code id="vstBioCond_+3A_min.var">min.var</code></td>
<td>
<p>Lower bound of variances read from the mean-variance
curve. Any variance read from the curve less than <code>min.var</code> will be
adjusted to this value. It's primarily used for safely reading positive
values from the curve and taking into account the practical significance
of a signal variation.</p>
</td></tr>
<tr><td><code id="vstBioCond_+3A_integrate.func">integrate.func</code></td>
<td>
<p>A function for quadrature of functions of one
variable. Any function passed to this argument must mimic the behavior
of <code><a href="stats.html#topic+integrate">integrate</a></code> (the default argument). See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="vstBioCond_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>integrate.func</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vstBioCond</code> deduces the VST by applying the standard delta method to
the mean-variance curve associated with the <code><a href="#topic+bioCond">bioCond</a></code> object. To
be noted, applying the VST to the <code>bioCond</code> retains its structure
matrices. More specifically, the transformed signal intensities of each
genomic interval will have a covariance matrix
approximately proportional to its
structure matrix in the <code>bioCond</code>. See <code><a href="#topic+setWeight">setWeight</a></code> for a
detailed description of structure matrix.
</p>
<p>Technically, applying the VST requires the quadrature of a one-variable
function, which in <code>vstBioCond</code> is achieved numerically. One can
specify the numerical integration routine used by <code>vstBioCond</code> via the
argument <code>integrate.func</code>, as long as the provided function mimics the
behavior of <code><a href="stats.html#topic+integrate">integrate</a></code>. Specifically, supposing the
first three arguments to the function are <code>f</code>, <code>a</code> and <code>b</code>,
then <code>ret$value</code> should be the integral of <code>f</code> from <code>a</code> to
<code>b</code>, where <code>ret</code> is the object returned from the function. See
<code><a href="stats.html#topic+integrate">integrate</a></code> for details.
</p>
<p>One of the applications of applying a VST to a <code>bioCond</code> is for
clustering the samples contained in it. Since variances of transformed
signals are comparable across genomic intervals,
performing a clustering analysis
on the transformed data is expected to give more reliable results than those
from the original signals. Notably, to apply a clustering analysis to the
VSTed signals, one typically passes the returned object from
<code>vstBioCond</code> to <code><a href="#topic+distBioCond">distBioCond</a></code> setting the <code>method</code>
argument to <code>"none"</code>, by which you can get a <code><a href="stats.html#topic+dist">dist</a></code>
object recording the distance between each pair of samples of the
<code>bioCond</code>. This procedure is specifically designed to handle VSTed
<code>bioCond</code>s and has considered the possibility that different genomic
intervals may be associated with different structure matrices (see
<code><a href="#topic+distBioCond">distBioCond</a></code> for details). The resulting
<code><a href="stats.html#topic+dist">dist</a></code> object can then be passed to
<code><a href="stats.html#topic+hclust">hclust</a></code> to perform a hierarchical clustering (see
also &quot;Examples&quot;).
</p>
<p>From this perspective, <code>vstBioCond</code> could also be used to cluster a set
of <code>bioCond</code> objects, by first combining them into a single
<code>bioCond</code> and fitting a mean-variance curve for it (see &quot;Examples&quot;
below and also <code><a href="#topic+cmbBioCond">cmbBioCond</a></code>).
</p>


<h3>Value</h3>

<p><code>vstBioCond</code> returns a <code><a href="#topic+bioCond">bioCond</a></code> object with an
extra attribute named <code>"vst.func"</code>, which represents the VST
applied to <code>x</code>. Signal intensities contained in the returned
<code>bioCond</code> are obtained by applying the VST to the signal
intensities in <code>x</code>.
</p>
<p>The returned <code>bioCond</code> has the same biological condition name and
occupancy states of genomic intervals as <code>x</code>. Besides, the
structure matrix of each interval
in the returned <code>bioCond</code> inherits
from <code>x</code> as well, since performing the designed VST approximately
retains the original structure matrices (see &quot;Details&quot;).
</p>
<p>The <code>vst.func</code> attribute is a function that accepts a vector of
signal intensities and returns the VSTed signals. To be noted,
<code>vst.func</code> has been scaled so that the resulting transformed
signals in the returned <code>bioCond</code> have a similar numerical range
and variation level to the signal intensities in <code>x</code>.
More specifically, the <code>sample.mean</code> and <code>sample.var</code> fields
of the returned <code>bioCond</code> have the same arithmetic mean and
geometric mean as <code>x$sample.mean</code> and <code>x$sample.var</code>,
respectively. See <code><a href="#topic+bioCond">bioCond</a></code> for a detailed description
of these fields.
</p>
<p>Note also that, in principle, applying the <code>vst.func</code> to any
<code>bioCond</code> object that is associated with the same mean-variance
curve as is <code>x</code> (i.e., has the same <code>mvcID</code> as that of
<code>x</code>; see also <code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code>) effectively stabilizes
the variances of its signal intensities across genomic intervals.
For future reference, the <code>vst.func</code> itself has an
attribute named <code>"mvcID"</code> recording the <code>mvcID</code> of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bioCond">bioCond</a></code> for creating a <code>bioCond</code> object;
<code><a href="#topic+fitMeanVarCurve">fitMeanVarCurve</a></code> for fitting a mean-variance curve;
<code><a href="stats.html#topic+integrate">integrate</a></code> for a numerical integration routine;
<code><a href="#topic+setWeight">setWeight</a></code> for a detailed description of structure matrix;
<code><a href="#topic+cmbBioCond">cmbBioCond</a></code> for combining a set of <code>bioCond</code> objects
into a single one; <code><a href="#topic+distBioCond">distBioCond</a></code> for robustly measuring the
distances between samples in a <code>bioCond</code>;
<code><a href="stats.html#topic+hclust">hclust</a></code> for performing a hierarchical clustering on
a <code><a href="stats.html#topic+dist">dist</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(H3K27Ac, package = "MAnorm2")
attr(H3K27Ac, "metaInfo")

## Cluster a set of ChIP-seq samples from different cell lines (i.e.,
## individuals).

# Perform MA normalization and construct a bioCond.
norm &lt;- normalize(H3K27Ac, 4:8, 9:13)
cond &lt;- bioCond(norm[4:8], norm[9:13], name = "all")

# Fit a mean-variance curve.
cond &lt;- fitMeanVarCurve(list(cond), method = "local",
                        occupy.only = FALSE)[[1]]
plotMeanVarCurve(list(cond), subset = "all")

# Apply a variance-stabilizing transformation and associate a constant
# function with the resulting bioCond as its mean-variance curve.
vst_cond &lt;- vstBioCond(cond)
vst_cond &lt;- setMeanVarCurve(list(vst_cond), function(x)
                            rep_len(1, length(x)), occupy.only = FALSE,
                            method = "constant prior")[[1]]
plotMeanVarCurve(list(vst_cond), subset = "all")

# Measure the distance between each pair of samples and accordingly perform
# a hierarchical clustering. Note that biological replicates of each cell
# line are clustered together.
d1 &lt;- distBioCond(vst_cond, method = "none")
plot(hclust(d1, method = "average"), hang = -1)

# Measure the distances using only hypervariable genomic intervals. Note the
# change of scale of the distances.
res &lt;- varTestBioCond(vst_cond)
f &lt;- res$fold.change &gt; 1 &amp; res$pval &lt; 0.05
d2 &lt;- distBioCond(vst_cond, subset = f, method = "none")
plot(hclust(d2, method = "average"), hang = -1)

## Cluster a set of individuals.

# Perform MA normalization and construct bioConds to represent individuals.
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
conds &lt;- normBioCond(conds)

# Group the individuals into a single bioCond and fit a mean-variance curve
# for it.
cond &lt;- cmbBioCond(conds, name = "all")
cond &lt;- fitMeanVarCurve(list(cond), method = "local",
                        occupy.only = FALSE)[[1]]
plotMeanVarCurve(list(cond), subset = "all")

# Apply a variance-stabilizing transformation and associate a constant
# function with the resulting bioCond as its mean-variance curve.
vst_cond &lt;- vstBioCond(cond)
vst_cond &lt;- setMeanVarCurve(list(vst_cond), function(x)
                            rep_len(1, length(x)), occupy.only = FALSE,
                            method = "constant prior")[[1]]
plotMeanVarCurve(list(vst_cond), subset = "all")

# Measure the distance between each pair of individuals and accordingly
# perform a hierarchical clustering. Note that GM12891 and GM12892 are
# actually a couple and they are clustered together.
d1 &lt;- distBioCond(vst_cond, method = "none")
plot(hclust(d1, method = "average"), hang = -1)

# Measure the distances using only hypervariable genomic intervals. Note the
# change of scale of the distances.
res &lt;- varTestBioCond(vst_cond)
f &lt;- res$fold.change &gt; 1 &amp; res$pval &lt; 0.05
d2 &lt;- distBioCond(vst_cond, subset = f, method = "none")
plot(hclust(d2, method = "average"), hang = -1)

## Perform differential analysis on bioConds that have gone through a
## variance-stabilizing transformation.

# Perform MA normalization and construct bioConds to represent cell lines
# (i.e., individuals).
norm &lt;- normalize(H3K27Ac, 4, 9)
norm &lt;- normalize(norm, 5:6, 10:11)
norm &lt;- normalize(norm, 7:8, 12:13)
conds &lt;- list(GM12890 = bioCond(norm[4], norm[9], name = "GM12890"),
              GM12891 = bioCond(norm[5:6], norm[10:11], name = "GM12891"),
              GM12892 = bioCond(norm[7:8], norm[12:13], name = "GM12892"))
autosome &lt;- !(H3K27Ac$chrom %in% c("chrX", "chrY"))
conds &lt;- normBioCond(conds, common.peak.regions = autosome)

# Fit a mean-variance curve.
conds &lt;- fitMeanVarCurve(conds, method = "parametric", occupy.only = TRUE)
plotMeanVarCurve(conds, subset = "occupied")

# Apply a variance-stabilizing transformation.
vst_conds &lt;- list(GM12890 = vstBioCond(conds$GM12890))
vst.func &lt;- attr(vst_conds$GM12890, "vst.func")
temp &lt;- matrix(vst.func(as.numeric(conds$GM12891$norm.signal)),
               nrow = nrow(norm))
vst_conds$GM12891 &lt;- bioCond(temp, norm[10:11], name = "GM12891")
temp &lt;- matrix(vst.func(as.numeric(conds$GM12892$norm.signal)),
               nrow = nrow(norm))
vst_conds$GM12892 &lt;- bioCond(temp, norm[12:13], name = "GM12892")

# Associate a constant function with the resulting bioConds as their
# mean-variance curve.
vst_conds &lt;- setMeanVarCurve(vst_conds, function(x) rep_len(1, length(x)),
                             occupy.only = TRUE, method = "constant prior")
plotMeanVarCurve(vst_conds, subset = "occupied")

# Make a comparison between GM12891 and GM12892.
res1 &lt;- diffTest(conds$GM12891, conds$GM12892)
res2 &lt;- diffTest(vst_conds$GM12891, vst_conds$GM12892)

# Examine the consistency of analysis results between using ordinary and
# VSTed signal intensities. Here we map p-values together with observed
# directions of signal changes to the standard normal distribution.
z1 &lt;- qnorm(res1$pval / 2)
z1[res1$Mval &gt; 0] &lt;- -z1[res1$Mval &gt; 0]
z2 &lt;- qnorm(res2$pval / 2)
z2[res2$Mval &gt; 0] &lt;- -z2[res2$Mval &gt; 0]
plot(z1, z2, xlab = "Ordinary", ylab = "VSTed")
abline(a = 0, b = 1, lwd = 2, lty = 5, col = "red")
cor(z1, z2)
cor(z1, z2, method = "sp")

# Simultaneously compare GM12890, GM12891 and GM12892 cell lines.
res1 &lt;- aovBioCond(conds)
res2 &lt;- aovBioCond(vst_conds)

# Examine the consistency of analysis results between using ordinary and
# VSTed signal intensities by mapping p-values to the standard normal
# distribution.
z1 &lt;- qnorm(res1$pval, lower.tail = FALSE)
z1[z1 == Inf] &lt;- 39
z2 &lt;- qnorm(res2$pval, lower.tail = FALSE)
z2[z2 == Inf] &lt;- 39
plot(z1, z2, xlab = "Ordinary", ylab = "VSTed")
abline(a = 0, b = 1, lwd = 2, lty = 5, col = "red")
cor(z1, z2)
cor(z1, z2, method = "sp")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
