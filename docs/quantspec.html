<!DOCTYPE html><html><head><title>Help for package quantspec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quantspec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#quantspec-package'><p>Quantile-Based Spectral Analysis of Time Series</p></a></li>
<li><a href='#.computeCoherency'><p>Workhorse function for <code>getCoherency-SmoothedPG</code>.</p></a></li>
<li><a href='#.computeSdNaive'><p>Workhorse function for <code>getSdNaive-SmoothedPG</code>.</p></a></li>
<li><a href='#BootPos-class'><p>Class for Generation of Bootstrapped Replications of a Time Series.</p></a></li>
<li><a href='#ClippedCov-class'><p>Class to calculate copula covariances from a time series with given levels.</p>
</p>
<p>Calculates for each combination of levels <code class="reqn">(\tau_1,\tau_2)</code></p>
and for all <code class="reqn">k &lt; \code{maxLag}</code> the copula covariances
<code class="reqn">Cov(1_{X_0 &lt; \tau_1},1_{X_k &lt; \tau_2})</code>
and writes it to <code>values[k]</code> from its superclass <code>LagOperator</code>.</a></li>
<li><a href='#ClippedCov-constructor'><p>Create an instance of the <code>ClippedCov</code> class.</p></a></li>
<li><a href='#ClippedFT-class'><p>Class for Fourier transform of the clipped time series.</p></a></li>
<li><a href='#ClippedFT-constructor'><p>Create an instance of the <code>ClippedFT</code> class.</p></a></li>
<li><a href='#closest.pos'><p>Positions of elements which are closest to some reference elements.</p></a></li>
<li><a href='#data-sp500'><p>S&amp;P 500: Standard and Poor's 500 stock index, 2007&ndash;2010</p></a></li>
<li><a href='#data-wheatprices'><p>Beveridge's Wheat Price Index (detrended and demeaned), 1500&ndash;1869</p></a></li>
<li><a href='#FreqRep-class'><p>Class for Frequency Representation.</p></a></li>
<li><a href='#frequenciesValidator'><p>Validates if frequencies are Fourier frequencies from</p>
<code class="reqn">[0,\pi]</code>.</a></li>
<li><a href='#generics-accessors'><p>Generic functions for accessing attributes of objects</p></a></li>
<li><a href='#generics-associations'><p>Generic functions for accessing associations of objects</p></a></li>
<li><a href='#generics-functions'><p>Generic functions for implementation of methods of a class</p></a></li>
<li><a href='#getB-FreqRep'><p>Get <code>B</code> from a <code>FreqRep</code> object.</p></a></li>
<li><a href='#getB-LagOperator'><p>Get <code>B</code> from a <code>LagOperator</code> object.</p></a></li>
<li><a href='#getBootPos-FreqRep'><p>Get associated <code>BootPos</code> from a</p>
<code>FreqRep</code>.</a></li>
<li><a href='#getBootPos-LagOperator'><p>Get associated <code>BootPos</code> from a</p>
<code>LagOperator</code>.</a></li>
<li><a href='#getBw-KernelWeight'><p>Get attribute <code>bw</code> (bandwidth / scaling parameter used for smoothing)</p>
from a <code>KernelWeight</code>.</a></li>
<li><a href='#getBw-LagKernelWeight'><p>Get attribute <code>bw</code> (bandwidth / scaling parameter used for smoothing)</p>
from a <code>LagKernelWeight</code>.</a></li>
<li><a href='#getCoherency-QuantileSD'><p>Compute quantile coherency from a quantile spectral density kernel</p></a></li>
<li><a href='#getCoherency-SmoothedPG'><p>Compute quantile coherency from a smoothed quantile periodogram.</p></a></li>
<li><a href='#getCoherencySdNaive-SmoothedPG'><p>Get estimates for the standard deviation of the coherency computed from</p>
smoothed quantile periodogram.</a></li>
<li><a href='#getDescr-Weight'><p>Get attribute <code>descr</code> from a <code>Weight</code>.</p></a></li>
<li><a href='#getFreqRep-QuantilePG'><p>Get associated <code>FreqRep</code> from a</p>
<code>QuantilePG</code>.</a></li>
<li><a href='#getFrequencies-FreqRep'><p>Get attribute <code>frequencies</code> from a <code>FreqRep</code>.</p></a></li>
<li><a href='#getFrequencies-QSpecQuantity'><p>Get attribute <code>frequencies</code> from a <code>QSpecQuantity</code>.</p></a></li>
<li><a href='#getIsRankBased-FreqRep'><p>Get <code>isRankBased</code> from a <code>FreqRep</code> object</p></a></li>
<li><a href='#getIsRankBased-LagOperator'><p>Get <code>isRankBased</code> from a <code>LagOperator</code> object</p></a></li>
<li><a href='#getLagOperator-LagEstimator'><p>Get associated <code>LagOperator</code> from a <code>LagEstimator</code>.</p></a></li>
<li><a href='#getLevels-FreqRep'><p>Get attribute <code>levels</code> from a <code>FreqRep</code>.</p></a></li>
<li><a href='#getLevels-LagOperator'><p>Get attribute <code>levels</code> from a <code>LagOperator</code>.</p></a></li>
<li><a href='#getLevels-QSpecQuantity'><p>Get attribute <code>levels</code> from a <code>QSpecQuantity</code>.</p></a></li>
<li><a href='#getMaxLag-LagOperator'><p>Get <code>maxLag</code> from a <code>LagOperator</code> object.</p></a></li>
<li><a href='#getMeanPG-QuantileSD'><p>Get <code>meanPG</code> from a quantile spectral density kernel</p></a></li>
<li><a href='#getN-QuantileSD'><p>Get <code>N</code> from a quantile spectral density kernel</p></a></li>
<li><a href='#getParallel-QRegEstimator'><p>Get <code>getParallel</code> from a <code>QRegEstimator</code> object</p></a></li>
<li><a href='#getPointwiseCIs-LagEstimator'><p>Get pointwise confidence intervals for the quantile spectral density kernel</p></a></li>
<li><a href='#getPointwiseCIs-SmoothedPG'><p>Get pointwise confidence intervals for the quantile spectral density kernel,</p>
quantile coherency or quantile coherence.</a></li>
<li><a href='#getPositions-MovingBlocks'><p>Get Positions for the Moving Blocks Bootstrap.</p></a></li>
<li><a href='#getQuantilePG-QuantileSD'><p>Get associated <code>QuantilePG</code> from a <code>QuantileSD</code>.</p></a></li>
<li><a href='#getQuantilePG-SmoothedPG'><p>Get associated <code>QuantilePG</code> from a <code>SmoothedPG</code>.</p></a></li>
<li><a href='#getQuantileSD-IntegrQuantileSD'><p>Get associated <code>getQuantileSD</code> from an</p>
<code>IntegrQuantileSD</code>.</a></li>
<li><a href='#getR-QuantileSD'><p>Get <code>R</code> from a quantile spectral density kernel</p></a></li>
<li><a href='#getSdBoot-LagEstimator'><p>Get bootstrap estimates for the standard deviation of the lag-window type</p>
estimator.</a></li>
<li><a href='#getSdBoot-SmoothedPG'><p>Get bootstrap estimates for the standard deviation of the smoothed quantile</p>
periodogram.</a></li>
<li><a href='#getSdNaive-LagEstimator'><p>Get estimates for the standard deviation of the lagEstimator derived from</p>
the asymptotics (see Birr et al (2015))</a></li>
<li><a href='#getSdNaive-SmoothedPG'><p>Get estimates for the standard deviation of the smoothed quantile</p>
periodogram.</a></li>
<li><a href='#getStdError-QuantileSD'><p>Get <code>stdError</code> from a quantile spectral density kernel</p></a></li>
<li><a href='#getTs-QuantileSD'><p>Get <code>ts</code> from a quantile spectral density kernel</p></a></li>
<li><a href='#getType-QuantileSD'><p>Get <code>type</code> from a quantile spectral density kernel</p></a></li>
<li><a href='#getValues-FreqRep'><p>Get values from a frequency representation.</p></a></li>
<li><a href='#getValues-IntegrQuantileSD'><p>Get values from a simulated integrated quantile spectral density kernel</p></a></li>
<li><a href='#getValues-KernelWeight'><p>Get values from a weight object determined by a kernel function <code>W</code> and</p>
a bandwidth <code>b</code>.</a></li>
<li><a href='#getValues-LagEstimator'><p>Get values from a lag-window type estimator.</p></a></li>
<li><a href='#getValues-LagKernelWeight'><p>Get values from a weight object determined by a kernel function <code>W</code> and</p>
a bandwidth <code>bw</code>.</a></li>
<li><a href='#getValues-LagOperator'><p>Get attribute <code>values</code> from a <code>LagOperator</code>.</p></a></li>
<li><a href='#getValues-QuantilePG'><p>Get values from a quantile periodogram.</p></a></li>
<li><a href='#getValues-QuantileSD'><p>Get values from a quantile spectral density kernel</p></a></li>
<li><a href='#getValues-SmoothedPG'><p>Get values from a smoothed quantile periodogram.</p></a></li>
<li><a href='#getValues-SpecDistrWeight'><p>Get values from a weight object of type <code>SpecDistrWeight</code></p></a></li>
<li><a href='#getW-KernelWeight'><p>Get attribute <code>W</code> (kernel used for smoothing) from a <code>KernelWeight</code>.</p></a></li>
<li><a href='#getW-LagKernelWeight'><p>Get attribute <code>W</code> (kernel used for smoothing) from a <code>LagKernelWeight</code>.</p></a></li>
<li><a href='#getWeight-LagEstimator'><p>Get associated <code>Weight</code> from a <code>LagEstimator</code>.</p></a></li>
<li><a href='#getWeight-SmoothedPG'><p>Get associated <code>Weight</code> from a <code>SmoothedPG</code>.</p></a></li>
<li><a href='#getWnj-KernelWeight'><p>Get attribute <code>Wnj</code> from a <code>QSpecQuantity</code>.</p></a></li>
<li><a href='#getY-FreqRep'><p>Get <code>Y</code> from a <code>FreqRep</code> object.</p></a></li>
<li><a href='#increasePrecision-QuantileSD'><p>Increase the precision of a <code>QuantileSD</code></p></a></li>
<li><a href='#IntegrQuantileSD-class'><p>Class for a simulated integrated quantile (i. e., Laplace or copula)</p>
density kernel.</a></li>
<li><a href='#IntegrQuantileSD-constructor'><p>Create an instance of the <code>IntegrQuantileSD</code> class.</p></a></li>
<li><a href='#is.wholenumber'><p>Checks whether <code>x</code> contains integer numbers.</p></a></li>
<li><a href='#kernels'><p>Kernel function.</p></a></li>
<li><a href='#KernelWeight-class'><p>Class for Brillinger-type Kernel weights.</p></a></li>
<li><a href='#KernelWeight-constructor'><p>Create an instance of the <code>KernelWeight</code> class.</p></a></li>
<li><a href='#LagEstimator-class'><p>Class for a lag-window type estimator.</p></a></li>
<li><a href='#LagEstimator-constructor'><p>Create an instance of the <code>LagEstimator</code> class.</p></a></li>
<li><a href='#LagKernelWeight-class'><p>Class for lag window generators</p></a></li>
<li><a href='#LagKernelWeight-constructor'><p>Create an instance of the <code>LagKernelWeight</code> class.</p></a></li>
<li><a href='#LagOperator-class'><p>Interface Class to access different types of operators on time series.</p></a></li>
<li><a href='#lenTS'><p>Validates if <code>Y</code> is of an appropriate type for a time series and</p>
returns the length of the time series.</a></li>
<li><a href='#MovingBlocks-class'><p>Class for Moving Blocks Bootstrap implementation.</p></a></li>
<li><a href='#MovingBlocks-constructor'><p>Create an instance of the <code>MovingBlocks</code> class.</p></a></li>
<li><a href='#plot-FreqRep'><p>Plot the values of the <code>FreqRep</code>.</p></a></li>
<li><a href='#plot-IntegrQuantileSD'><p>Plot the values of the <code>IntegrQuantileSD</code>.</p></a></li>
<li><a href='#plot-KernelWeight'><p>Plot the values of the <code>KernelWeight</code>.</p></a></li>
<li><a href='#plot-LagEstimator'><p>Plot the values of a <code>LagEstimator</code>.</p></a></li>
<li><a href='#plot-LagKernelWeight'><p>Plot the values of the <code>LagKernelWeight</code>.</p></a></li>
<li><a href='#plot-LagOperator'><p>Plot the values of the <code>LagOperator</code>.</p></a></li>
<li><a href='#plot-QuantilePG'><p>Plot the values of the <code>QuantilePG</code>.</p></a></li>
<li><a href='#plot-QuantileSD'><p>Plot the values of the <code>QuantileSD</code>.</p></a></li>
<li><a href='#plot-SmoothedPG'><p>Plot the values of a <code>SmoothedPG</code>.</p></a></li>
<li><a href='#plot-SpecDistrWeight'><p>Plot the values of the <code>SpecDistrWeight</code>.</p></a></li>
<li><a href='#QRegEstimator-class'><p>Class for quantile regression-based estimates in the harmonic linear model.</p></a></li>
<li><a href='#QRegEstimator-constructor'><p>Create an instance of the <code>QRegEstimator</code> class.</p></a></li>
<li><a href='#QSpecQuantity-class'><p>Class for a Quantile Spectral Estimator.</p></a></li>
<li><a href='#QuantilePG-class'><p>Class for a quantile (i. e., Laplace or copula) periodogram.</p></a></li>
<li><a href='#QuantilePG-constructor'><p>Create an instance of the <code>QuantilePG</code> class.</p></a></li>
<li><a href='#QuantileSD-class'><p>Class for a simulated quantile (i. e., Laplace or copula)</p>
density kernel.</a></li>
<li><a href='#QuantileSD-constructor'><p>Create an instance of the <code>QuantileSD</code> class.</p></a></li>
<li><a href='#quantspec-defunct'><p>Defunct functions in package quantspec</p></a></li>
<li><a href='#SmoothedPG-class'><p>Class for a smoothed quantile periodogram.</p></a></li>
<li><a href='#SmoothedPG-constructor'><p>Create an instance of the <code>SmoothedPG</code> class.</p></a></li>
<li><a href='#SpecDistrWeight-class'><p>Class for weights to estimate integrated spectral density kernels.</p></a></li>
<li><a href='#SpecDistrWeight-constructor'><p>Create an instance of the <code>SpecDistrWeight</code> class.</p></a></li>
<li><a href='#timeSeriesValidator'><p>Validates if <code>Y</code> is of an appropriate type and converts to a numeric.</p></a></li>
<li><a href='#ts-models'><p>Functions to simulate from the time series models in Kley et. al (2016).</p></a></li>
<li><a href='#ts-models-AR1'><p>Simulation of an AR(1) time series.</p></a></li>
<li><a href='#ts-models-AR2'><p>Simulation of an AR(2) time series.</p></a></li>
<li><a href='#ts-models-ARCH1'><p>Simulation of an ARCH(1) time series.</p></a></li>
<li><a href='#ts-models-QAR1'><p>Simulation of an QAR(1) time series.</p></a></li>
<li><a href='#Weight-class'><p>Interface Class to access different types of weighting functions.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2-3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-07-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantile-Based Spectral Analysis of Time Series</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stats4</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, graphics, quantreg, abind, zoo, snowfall, Rcpp (&ge;
0.11.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to determine, smooth and plot quantile periodograms for
    univariate and multivariate time series. See Kley (2016) &lt;<a href="https://doi.org/10.18637%2Fjss.v070.i03">doi:10.18637/jss.v070.i03</a>&gt;
    for a description and tutorial.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/tobiaskley/quantspec">http://github.com/tobiaskley/quantspec</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/tobiaskley/quantspec/issues">http://github.com/tobiaskley/quantspec/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Class-BootPos.R' 'generics.R' 'Class-LagOperator.R'
'Class-ClippedCov.R' 'Class-QSpecQuantity.R' 'aux-functions.R'
'Class-FreqRep.R' 'Class-ClippedFT.R' 'Class-QuantileSD.R'
'Class-IntegrQuantileSD.R' 'Class-Weight.R'
'Class-KernelWeight.R' 'Class-LagEstimator.R' 'kernels.R'
'Class-LagKernelWeight.R' 'Class-MovingBlocks.R'
'Class-QRegEstimator.R' 'Class-QuantilePG.R'
'Class-SmoothedPG.R' 'Class-SpecDistrWeight.R' 'RcppExports.R'
'data.R' 'deprecated.R' 'models.R' 'quantspec-package.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-14 18:15:05 UTC; tk18582</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Kley [aut, cre],
  Stefan Birr [ctb] (Contributions to lag window estimation)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Kley &lt;tobias.kley@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-14 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='quantspec-package'>Quantile-Based Spectral Analysis of Time Series</h2><span id='topic+quantspec-package'></span><span id='topic+quantspec'></span>

<h3>Description</h3>

<p>Methods to determine, smooth and plot quantile
periodograms for univariate and (since v1.2-0) multivariate time series.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> quantspec
   </td>
</tr>
<tr>
 <td style="text-align: left;"> Type:    </td><td style="text-align: left;"> Package
   </td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;"> 1.2-2
   </td>
</tr>
<tr>
 <td style="text-align: left;"> Date:    </td><td style="text-align: left;"> 2020-04-22
   </td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 2)
 </td>
</tr>

</table>



<h3>Contents</h3>

<p>The <span class="pkg">quantspec</span> package contains a hierachy of S4 classes with
corresponding methods and functions serving as constructors. The following
class diagrams provide an overview on the structure of the package. In the
first and second class diagram the classes implementing the estimators are
shown. In the first diagram the classes related to periodogram-based
estimation are displayed:  
</p>
<p><img src="../help/figures/main-mv.png" width=960 alt="main-mv.png" />

</p>
<p>In the second diagram the classes related to lag window-based
estimation are displayed:
</p>
<p><img src="../help/figures/main2-mv.png" width=768 alt="main2-mv.png" />

</p>
<p>In the third class diagram the classes implementing model quantities are
displayed. A relation to the &ldquo;empirical classes&rdquo; is given via the fact that
the quantile spectral densities are computed by simulation of quantile
periodograms and a common abstract superclass <code>QSpecQuantity</code> which
is used to provide a common interface to quantile spectral quantities.
</p>
<p><img src="../help/figures/csd-mv.png" width=768 alt="csd-mv.png" />

</p>
<p>Besides the object-oriented design a few
auxiliary functions exists. They serve as parameters or are mostly for
internal use. A more detailed description of the framework can be found in
the paper on the package (Kley, 2016).
</p>


<h3>Organization of the source code / files in the <code>/R</code> folder</h3>

<p>All of the source code related to the specification of a certain class is
contained in a file named <code>Class-[Name_of_the_class].R</code>. This includes,
in the following order,
</p>

<ol>
<li><p> all roxygen <code>@include</code> to insure the correctly generated
collate for the DESCRIPTION file.
</p>
</li>
<li> <p><code>\setClass</code> preceded by a meaningful roxygen documentation.
</p>
</li>
<li><p> specification of an <code>initialize</code> method, where appropriate.
</p>
</li>
<li><p> all accessor and mutator method (i. e., getter and setter); first
the ones returning attributes of the object, then the ones returning
associated objects.
</p>
</li>
<li><p> constructors; use generics if there is more than one of them.
</p>
</li>
<li> <p><code>show</code> and <code>plot</code> methods.
</p>
</li></ol>



<h3>Coding Conventions</h3>

<p>To improve readability of the software and documentation this package was
written in the spirit of the &ldquo;Coding conventions of the Java Programming
Language&rdquo; (Oracle, 2015). In particular, the naming conventions for classes
and methods have been adopted, where &ldquo;Class names should be nouns, in mixed
case with the first letter of each internal word capitalized.&rdquo; and
&ldquo;Methods should be verbs, in mixed case with the first letter lowercase,
with the first letter of each internal word capitalized.&rdquo;
</p>


<h3>Naming Conventions for the Documentation</h3>

<p>To reflect the structure of the contents of the package in the documentation
file, the following system for naming of the sections is adopted:
</p>

<ul>
<li><p> Documentation of an S4 class is named as the name of the class
followed by &ldquo;-class&rdquo;. [cf. <code><a href="#topic+QuantilePG-class">QuantilePG-class</a></code>]
</p>
</li>
<li><p> Documentation of a constructor for an S4-class is named as
the name of the class followed by &ldquo;-constructor&rdquo;.
[cf. <code><a href="#topic+QuantilePG-constructor">QuantilePG-constructor</a></code>]
</p>
</li>
<li><p> Documentation of a method dispaching to an object of a certain
S4 class is named by the name of the method, followed by &ldquo;-&rdquo;,
followed by the name of the Class.
[cf. <code><a href="#topic+getValues-QuantilePG">getValues-QuantilePG</a></code>]
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tobias Kley
</p>


<h3>References</h3>

<p>Kley, T. (2014a). Quantile-Based Spectral Analysis: Asymptotic Theory and
Computation. Ph.D. Dissertation, Ruhr University Bochum.
<a href="https://hss-opus.ub.ruhr-uni-bochum.de/opus4/frontdoor/index/index/docId/3894">https://hss-opus.ub.ruhr-uni-bochum.de/opus4/frontdoor/index/index/docId/3894</a>.
</p>
<p>Kley, T. (2016). Quantile-Based Spectral Analysis in an Object-Oriented
Framework and a Reference Implementation in R: The quantspec Package.
Journal of Statistical Software, <b>70</b>(3), 1&ndash;27.
</p>
<p>Dette, H., Hallin, M., Kley, T. &amp; Volgushev, S. (2015).
Of Copulas, Quantiles, Ranks and Spectra: an <code class="reqn">L_1</code>-approach to
spectral analysis. <em>Bernoulli</em>, <b>21</b>(2), 781&ndash;831.
[cf. <a href="http://arxiv.org/abs/1111.7205">http://arxiv.org/abs/1111.7205</a>]
</p>
<p>Kley, T., Volgushev, S., Dette, H. &amp; Hallin, M. (2016).
Quantile Spectral Processes: Asymptotic Analysis and Inference.
<em>Bernoulli</em>, <b>22</b>(3), 1770&ndash;1807.
[cf. <a href="http://arxiv.org/abs/1401.8104">http://arxiv.org/abs/1401.8104</a>]
</p>
<p>Barunik, J. &amp; Kley, T. (2019).
Quantile Coherency: A General Measure for Dependence between Cyclical
Economic Variables. <em>Econometrics Journal</em>, <b>22</b>, 131&ndash;152. 
[cf. <a href="http://arxiv.org/abs/1510.06946">http://arxiv.org/abs/1510.06946</a>]
</p>
<p>Oracle (2015). Coding conventions of the Java Programming Language.
<a href="http://www.oracle.com/technetwork/java/codeconvtoc-136057.html">http://www.oracle.com/technetwork/java/codeconvtoc-136057.html</a>.
Accessed 2015-03-25.
</p>

<hr>
<h2 id='.computeCoherency'>Workhorse function for <code><a href="#topic+getCoherency-SmoothedPG">getCoherency-SmoothedPG</a></code>.</h2><span id='topic+.computeCoherency'></span>

<h3>Description</h3>

<p>C++ implementation to increase performance.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id=".computeCoherency_+3A_v">V</code></td>
<td>
<p>a 3-dimensional array of complex numbers; dimensions are
<code>[N, K1, K2]</code>, where <code>N</code> frequencies are
<code class="reqn">\omega_j := 2\pi j/N</code> for <code class="reqn">j=0,\ldots,N</code>.</p>
</td></tr>
<tr><td><code id=".computeCoherency_+3A_w">W</code></td>
<td>
<p>a vector of length <code>W</code> of length <code>N</code> used for smoothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array with complex numbers
<code class="reqn">\sigma(\tau_1, \tau_2, \omega_j</code> as defined in
Kley et. al (2016), p. 26.
</p>


<h3>References</h3>

<p>Barunik, J. &amp; Kley, T. (2019).
Quantile Coherency: A General Measure for Dependence Between Cyclical
Economic Variables. Econometrics Journal, 22, 131&ndash;152.
<a href="http://arxiv.org/abs/1401.8104">http://arxiv.org/abs/1401.8104</a>.
</p>

<hr>
<h2 id='.computeSdNaive'>Workhorse function for <code><a href="#topic+getSdNaive-SmoothedPG">getSdNaive-SmoothedPG</a></code>.</h2><span id='topic+.computeSdNaive'></span>

<h3>Description</h3>

<p>C++ implementation to increase performance.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id=".computeSdNaive_+3A_v">V</code></td>
<td>
<p>a 3-dimensional array of complex numbers; dimensions are
<code>[N, K1, K2]</code>, where <code>N</code> frequencies are
<code class="reqn">\omega_j := 2\pi j/N</code> for <code class="reqn">j=0,\ldots,N</code>.</p>
</td></tr>
<tr><td><code id=".computeSdNaive_+3A_w">W</code></td>
<td>
<p>a vector of length <code>W</code> of length <code>N</code> used for smoothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array with complex numbers
<code class="reqn">\sigma(\tau_1, \tau_2, \omega_j</code> as defined in
Kley et. al (2016), p. 26.
</p>


<h3>References</h3>

<p>Dette, H., Hallin, M., Kley, T. &amp; Volgushev, S. (2015).
Of Copulas, Quantiles, Ranks and Spectra: an <code class="reqn">L_1</code>-approach to
spectral analysis. <em>Bernoulli</em>, <b>21</b>(2), 781&ndash;831.
[cf. <a href="http://arxiv.org/abs/1111.7205">http://arxiv.org/abs/1111.7205</a>]
</p>

<hr>
<h2 id='BootPos-class'>Class for Generation of Bootstrapped Replications of a Time Series.</h2><span id='topic+BootPos-class'></span><span id='topic+BootPos'></span>

<h3>Description</h3>

<p><code>BootPos</code> is an S4 class that provides a common interface
to different algorithms that can be used for implementation of a block
bootstrap procedure in the time domain.
</p>


<h3>Details</h3>

<p>After initialization the bootstrapping can be performed by applying
<code>getPositions</code> to the object.
</p>
<p>Different block bootstraps are implemented by creating a subclass together
with a <code>getPositions</code> method that contains the implementation of the
block resampling procedure.
</p>
<p>Currently the following implementations are available:
</p>

<ul>
<li> <p><code><a href="#topic+MovingBlocks">MovingBlocks</a></code> and <code><a href="#topic+getPositions-MovingBlocks">getPositions-MovingBlocks</a></code>.
</p>
</li></ul>



<h3>Slots</h3>


<dl>
<dt><code>l</code></dt><dd><p>the (expected) block length for the block bootstrap methods</p>
</dd>
<dt><code>N</code></dt><dd><p>number of available observations to bootstrap from</p>
</dd>
</dl>


<h3>References</h3>

<p>Lahiri, S. N. (1999). Theoretical Comparisons of Block Bootstrap Methods.
<em>The Annals of Statistics</em>, <b>27</b>(1), 386&ndash;404.
</p>

<hr>
<h2 id='ClippedCov-class'>Class to calculate copula covariances from a time series with given levels.
Calculates for each combination of levels <code class="reqn">(\tau_1,\tau_2)</code> 
and for all <code class="reqn">k &lt; \code{maxLag}</code> the copula covariances
<code class="reqn">Cov(1_{X_0 &lt; \tau_1},1_{X_k &lt; \tau_2})</code>
and writes it to <code>values[k]</code> from its superclass <code><a href="#topic+LagOperator">LagOperator</a></code>.</h2><span id='topic+ClippedCov-class'></span><span id='topic+ClippedCov'></span>

<h3>Description</h3>

<p>For each lag <code>k = 0, ..., maxLag</code> and combination of levels
<code class="reqn">(\tau_1, \tau_2)</code> from <code>levels.1 x levels.2</code> the
statistic
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n} \sum_{t=1}^{n-k} ( I\{\hat F_n(Y_t) \leq \tau_1\} - \tau_1) ( I\{\hat F_n(Y_{t+k}) \leq \tau_2\} - \tau_2)</code>
</p>

<p>is determined and stored to the array <code>values</code>.
</p>


<h3>Details</h3>

<p>Currently, the implementation of this class allows only for the analysis of
univariate time series.
</p>

<hr>
<h2 id='ClippedCov-constructor'>Create an instance of the <code><a href="#topic+ClippedCov">ClippedCov</a></code> class.</h2><span id='topic+ClippedCov-constructor'></span><span id='topic+clippedCov'></span>

<h3>Description</h3>

<p>Create an instance of the <code><a href="#topic+ClippedCov">ClippedCov</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clippedCov(
  Y,
  maxLag = length(Y) - 1,
  levels.1 = c(0.5),
  levels.2 = levels.1,
  isRankBased = TRUE,
  B = 0,
  l = 0,
  type.boot = c("none", "mbb")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClippedCov-constructor_+3A_y">Y</code></td>
<td>
<p>Time series to calculate the copula covariance from</p>
</td></tr>
<tr><td><code id="ClippedCov-constructor_+3A_maxlag">maxLag</code></td>
<td>
<p>maximum lag between observations that should be used</p>
</td></tr>
<tr><td><code id="ClippedCov-constructor_+3A_levels.1">levels.1</code></td>
<td>
<p>a vector of numerics that determines the level of clipping</p>
</td></tr>
<tr><td><code id="ClippedCov-constructor_+3A_levels.2">levels.2</code></td>
<td>
<p>a vector of numerics that determines the level of clipping</p>
</td></tr>
<tr><td><code id="ClippedCov-constructor_+3A_isrankbased">isRankBased</code></td>
<td>
<p>If true the time series is first transformed to pseudo data;
currently only rank-based estimation is possible.</p>
</td></tr>
<tr><td><code id="ClippedCov-constructor_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="ClippedCov-constructor_+3A_l">l</code></td>
<td>
<p>(expected) length of blocks</p>
</td></tr>
<tr><td><code id="ClippedCov-constructor_+3A_type.boot">type.boot</code></td>
<td>
<p>A flag to choose a method for the block bootstrap; currently
two options are implemented: <code>"none"</code> and <code>"mbb"</code>
which means to do a moving blocks  bootstrap with <code>B</code>
and <code>l</code> as specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code>ClippedCov</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LagOperator">LagOperator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ccf &lt;- clippedCov(rnorm(200), maxLag = 25, levels.1 = c(0.1,0.5,0.9))
dim(getValues(ccf))
#print values for levels (.5,.5)
plot(ccf, maxLag = 20)
</code></pre>

<hr>
<h2 id='ClippedFT-class'>Class for Fourier transform of the clipped time series.</h2><span id='topic+ClippedFT-class'></span><span id='topic+ClippedFT'></span>

<h3>Description</h3>

<p><code>ClippedFT</code> is an S4 class that implements the necessary
calculations to determine the Fourier transform of the clipped time
series. As a subclass to <code><a href="#topic+FreqRep">FreqRep</a></code> it inherits
slots and methods defined there; it servers as a frequency representation of
a time series as described in Kley et. al (2016) for univariate time series
and in Barunik &amp; Kley (2015) for multivariate time series.
</p>


<h3>Details</h3>

<p>For each frequency <code class="reqn">\omega</code> from <code>frequencies</code> and level <code>q</code>
from <code>levels</code> the statistic
</p>
<p style="text-align: center;"><code class="reqn">\sum_{t=0}^{n-1} I\{Y_{t,i} \leq q\} \mbox{e}^{-\mbox{i} \omega t}</code>
</p>

<p>is determined and stored to the array <code>values</code>. Internally the methods
<code><a href="stats.html#topic+mvfft">mvfft</a></code> and <code><a href="stats.html#topic+fft">fft</a></code> are used to achieve
good performance.
</p>
<p>Note that, all remarks made in the documentation of the super-class
<code><a href="#topic+FreqRep">FreqRep</a></code> apply.
</p>


<h3>References</h3>

<p>Kley, T., Volgushev, S., Dette, H. &amp; Hallin, M. (2016).
Quantile Spectral Processes: Asymptotic Analysis and Inference.
<em>Bernoulli</em>, <b>22</b>(3), 1770&ndash;1807.
[cf. <a href="http://arxiv.org/abs/1401.8104">http://arxiv.org/abs/1401.8104</a>]
</p>
<p>Barunik, J. &amp; Kley, T. (2015).
Quantile Cross-Spectral Measures of Dependence between Economic Variables.
[preprint available from the authors]
</p>


<h3>See Also</h3>

<p>For an example see <code><a href="#topic+FreqRep">FreqRep</a></code>.
</p>

<hr>
<h2 id='ClippedFT-constructor'>Create an instance of the <code><a href="#topic+ClippedFT">ClippedFT</a></code> class.</h2><span id='topic+ClippedFT-constructor'></span><span id='topic+clippedFT'></span>

<h3>Description</h3>

<p>The parameter <code>type.boot</code> can be set to choose a block bootstrapping
procedure. If <code>"none"</code> is chosen, a moving blocks bootstrap with
<code>l=lenTS(Y)</code> and <code>N=lenTS(Y)</code> would be done. Note that in that
case one would also chose <code>B=0</code> which means that <code>getPositions</code>
would never be called. If <code>B&gt;0</code> then each bootstrap replication would
be the undisturbed time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clippedFT(
  Y,
  frequencies = 2 * pi/lenTS(Y) * 0:(lenTS(Y) - 1),
  levels = 0.5,
  isRankBased = TRUE,
  B = 0,
  l = 0,
  type.boot = c("none", "mbb")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClippedFT-constructor_+3A_y">Y</code></td>
<td>
<p>A <code>matrix</code> of real numbers containing the time series from
which to determine the quantile periodogram as columns, or a
<code>ts</code> object or a <code>zoo</code> object.</p>
</td></tr>
<tr><td><code id="ClippedFT-constructor_+3A_frequencies">frequencies</code></td>
<td>
<p>A vector containing frequencies at which to determine the
quantile periodogram.</p>
</td></tr>
<tr><td><code id="ClippedFT-constructor_+3A_levels">levels</code></td>
<td>
<p>A vector of length <code>K</code> containing the levels at which the
<code><a href="#topic+ClippedFT">ClippedFT</a></code> frequency representation is to be
determined.</p>
</td></tr>
<tr><td><code id="ClippedFT-constructor_+3A_isrankbased">isRankBased</code></td>
<td>
<p>If true the time series is first transformed to pseudo
data [cf. <code><a href="#topic+FreqRep">FreqRep</a></code>].</p>
</td></tr>
<tr><td><code id="ClippedFT-constructor_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="ClippedFT-constructor_+3A_l">l</code></td>
<td>
<p>(expected) length of blocks</p>
</td></tr>
<tr><td><code id="ClippedFT-constructor_+3A_type.boot">type.boot</code></td>
<td>
<p>A flag to choose a method for the block bootstrap; currently
two options are implemented: <code>"none"</code> and <code>"mbb"</code>
which means to do a moving blocks  bootstrap with <code>B</code>
and <code>l</code> as specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code>ClippedFT</code>.
</p>


<h3>See Also</h3>

<p>For an example see <code><a href="#topic+FreqRep">FreqRep</a></code>.
</p>

<hr>
<h2 id='closest.pos'>Positions of elements which are closest to some reference elements.</h2><span id='topic+closest.pos'></span>

<h3>Description</h3>

<p>For two vectors <code>X</code> and <code>Y</code> a vector of indices <code>I</code> is returned,
such that <code>length(Y)</code> and <code>length(I)</code> coincide and <code>X[I[j]]</code>
is an element of <code>X</code> which has minimal distance to <code>Y[j]</code>, for all
<code>j=1,...,length(Y)</code>.
In case that there are multiple elements with minimal distance, the smallest
index (the index of the first element with minimal distance) is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest.pos(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closest.pos_+3A_x">X</code></td>
<td>
<p>Vector of elements among which to find the closest one for each
element in <code>Y</code>.</p>
</td></tr>
<tr><td><code id="closest.pos_+3A_y">Y</code></td>
<td>
<p>Vector of elements for which to find the clostest element in <code>X</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of same length as <code>X</code>, with indices indicating
which element in <code>Y</code> is closest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(1,2,3)
closest.pos(X1, 1.7)
closest.pos(X1, c(1.3,2.2))

X2 &lt;- c(2,1,3)
closest.pos(X2, 1.5)
</code></pre>

<hr>
<h2 id='data-sp500'>S&amp;P 500: Standard and Poor's 500 stock index, 2007&ndash;2010</h2><span id='topic+data-sp500'></span><span id='topic+sp500'></span>

<h3>Description</h3>

<p>Contains the returns of the S&amp;P 500 stock index for the years 2007&ndash;2010.
The returns were computed as <code>(Adjusted.Close-Open)/Open</code>.
</p>


<h3>Format</h3>

<p>A univariate time series with 1008 observations; a <code>zoo</code> object
</p>


<h3>Details</h3>

<p>The data was downloaded from the Yahoo! Finance Website.
</p>


<h3>References</h3>

<p>Yahoo! Finance Website
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(sp500)
</code></pre>

<hr>
<h2 id='data-wheatprices'>Beveridge's Wheat Price Index (detrended and demeaned), 1500&ndash;1869</h2><span id='topic+data-wheatprices'></span><span id='topic+wheatprices'></span>

<h3>Description</h3>

<p>Contains a detrended and demeaned version of the well-known Beveridge Wheat
Price Index which gives annual price data from 1500 to 1869, averaged over
many locations in western and central Europe [cf. Beveridge (1921)].
The index series <code class="reqn">x_t</code> was detrended as proposed by Granger (1964), p. 21, by
letting
</p>
<p style="text-align: center;"><code class="reqn">y_t := \frac{x_t}{\sum_{j=-15}^{15} x_{t+j}},</code>
</p>

<p>where <code class="reqn">x_t := x_1, t &lt; 1</code> and <code class="reqn">x_t := x_n, t &gt; n</code>.
The time series in the data set is also demeaned by letting
</p>
<p style="text-align: center;"><code class="reqn">z_t := y_t - n^{-1} \sum_{t=1}^n y_t.</code>
</p>



<h3>Format</h3>

<p>A univariate time series <code class="reqn">(z_t)</code> with 370 observations; a <code>ts</code> object.
</p>


<h3>Details</h3>

<p>The index data cited in Beveridge's paper was taken from <code>bev</code> in the
<code>tseries</code> package.
</p>


<h3>References</h3>

<p>Beveridge, W. H. (1921). Weather and Harvest Cycles. <em>The Economic Journal</em>,
31(124):429&ndash;452.
</p>
<p>Granger, C. W. J. (1964). <em>Spectral Analysis of Economic Time Series</em>.
Princeton University Press, Princeton, NJ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(wheatprices)
</code></pre>

<hr>
<h2 id='FreqRep-class'>Class for Frequency Representation.</h2><span id='topic+FreqRep-class'></span><span id='topic+FreqRep'></span>

<h3>Description</h3>

<p><code>FreqRep</code> is an S4 class that encapsulates, for a multivariate time
series <code class="reqn">(Y_{t,i})_{t=0,\ldots,n-1}</code>,
<code class="reqn">i=1,\ldots,d</code>
the data structures for the storage of a frequency representation. Examples
of such frequency representations include
</p>

<ul>
<li><p> the Fourier transformation of the clipped time series
<code class="reqn">(\{I\{Y_{t,i} \leq q\})</code>, or
</p>
</li>
<li><p> the weighted <code class="reqn">L_1</code>-projection of <code class="reqn">(Y_{t,i})</code> onto an harmonic
basis.
</p>
</li></ul>

<p>Examples are realized by implementing a sub-class to
<code>FreqRep</code>.
Currently, implementations for the two examples mentioned above are available:
<code><a href="#topic+ClippedFT">ClippedFT</a></code> and
<code><a href="#topic+QRegEstimator">QRegEstimator</a></code>.
</p>


<h3>Details</h3>

<p>It is always an option to base the calculations on the pseudo data
<code class="reqn">R_{t,n,i} / n</code> where <code class="reqn">R_{t,n,i}</code> denotes the rank of
<code class="reqn">Y_{t,i}</code> among <code class="reqn">(Y_{t,i})_{t=0,\ldots,n-1}</code>.
</p>
<p>To allow for a block bootstrapping procedure a number of <code>B</code> estimates
determined from bootstrap replications of the time series which are yield by
use of a <code><a href="#topic+BootPos">BootPos</a></code>-object can be stored on initialization.
</p>
<p>The data in the frequency domain is stored in the array <code>values</code>, which
has dimensions <code>(J,P,K,B+1)</code>, where <code>J</code> is the number of
<code>frequencies</code>, <code>P</code> is the dimension of the time series,
<code>K</code> is the number of <code>levels</code> and <code>B</code> is
the number of bootstrap replications requested on intialization.
In particular, <code>values[j,i,k,1]</code> corresponds to the time series' frequency
representation with <code>frequencies[j]</code>, dimension <code>i</code> and <code>levels[k]</code>, while
<code>values[j,i,k,b+1]</code> is the for the same, but determined from the
<code>b</code>th block bootstrapped replicate of the time series.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Y</code></dt><dd><p>The time series of which the frequency representation is to be determined.</p>
</dd>
<dt><code>frequencies</code></dt><dd><p>The frequencies for which the frequency representation will
be determined. On initalization
<code><a href="#topic+frequenciesValidator">frequenciesValidator</a></code> is called, so that it
will always be a vector of reals from <code class="reqn">[0,\pi]</code>.
Also, only Fourier frequencies of the form
<code class="reqn">2\pi j / n</code> with integers <code class="reqn">j</code> and <code class="reqn">n</code>
the <code>length(Y)</code> are allowed.</p>
</dd>
<dt><code>levels</code></dt><dd><p>The levels for which the frequency representation will be
determined. If the flag <code>isRankBased</code> is set to <code>FALSE</code>,
then it can be any vector of reals. If <code>isRankBased</code> is set
to <code>TRUE</code>, then it has to be from <code class="reqn">[0,1]</code>.</p>
</dd>
<dt><code>values</code></dt><dd><p>The array holding the determined frequency representation. Use a
<code>getValues</code> method of the relevant subclass to access it.</p>
</dd>
<dt><code>isRankBased</code></dt><dd><p>A flag that is <code>FALSE</code> if the determined <code>values</code>
are based on the original time series and <code>TRUE</code> if it
is based on the pseudo data as described in the Details
section of this topic.</p>
</dd>
<dt><code>positions.boot</code></dt><dd><p>An object of type <code><a href="#topic+BootPos">BootPos</a></code>,
that is used to determine the block bootstrapped
replicates of the time series.</p>
</dd>
<dt><code>B</code></dt><dd><p>Number of bootstrap replications to perform.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>Y       &lt;- rnorm(32)
freq    &lt;- 2*pi*c(0:31)/32 
levels  &lt;- c(0.25,0.5,0.75)
cFT     &lt;- clippedFT(Y, freq, levels)

plot(cFT)

# Get values for all Fourier frequencies and all levels available.
V.all    &lt;- getValues(cFT)

# Get values for every second frequency available
V.coarse &lt;- getValues(cFT, frequencies = 2*pi*c(0:15)/16, levels = levels)

# Trying to get values on a finer grid of frequencies than available will
# yield a warning and then all values with frequencies closest to that finer
# grid.
V.fine   &lt;- getValues(cFT, frequencies = 2*pi*c(0:63)/64, levels = levels)

# Finally, get values for the available Fourier frequencies from [0,pi] and
# only for tau=0.25
V.part   &lt;- getValues(cFT, frequencies = 2*pi*c(0:16)/32, levels = c(0.25))

# Alternatively this can be phrased like this:
V.part.alt &lt;- getValues(cFT, frequencies = freq[freq &lt;= pi], levels = c(0.25))
</code></pre>

<hr>
<h2 id='frequenciesValidator'>Validates if frequencies are Fourier frequencies from
<code class="reqn">[0,\pi]</code>.</h2><span id='topic+frequenciesValidator'></span>

<h3>Description</h3>

<p>Validation of the parameter <code>freq</code> is perfomed in six steps:
</p>

<ol>
<li><p> Throw an error if parameter is not a vector or not numeric.
</p>
</li>
<li><p> Transform each element <code class="reqn">\omega</code> of the vector to
<code class="reqn">[0,2\pi)</code>, by replacing it with
<code class="reqn">\omega \, \mbox{mod} \, 2\pi</code>.
</p>
</li>
<li><p> Check whether all elements <code class="reqn">\omega</code> of the vector are
Fourier frequency <code class="reqn">2 \pi j / T</code>, <code class="reqn">j \in Z</code>.
If this is not
the case issue a warning and round each frequency to the next
Fourier frequency of the mentioned type; the smaller one, if
there are two.
</p>
</li>
<li><p> Transform each element <code class="reqn">\omega</code> with
<code class="reqn">\pi &lt; \omega &lt; 2\pi</code> of the vector to
<code class="reqn">[0,\pi]</code>, by replacing it with
<code class="reqn">2\pi - \omega</code>.
</p>
</li>
<li><p> Check for doubles and remove all but the first appearance.
</p>
</li>
<li><p> Sort in ascending order.
</p>
</li></ol>

<p>Any subset of the six steps can be chosen, but 1 should almost always be
among the steps to be performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frequenciesValidator(freq, N, steps = 1:6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frequenciesValidator_+3A_freq">freq</code></td>
<td>
<p>the vector of frequencies to be validated.</p>
</td></tr>
<tr><td><code id="frequenciesValidator_+3A_n">N</code></td>
<td>
<p>the base of the Fourier frequencies against which the values in
<code>freq</code> will be compared.</p>
</td></tr>
<tr><td><code id="frequenciesValidator_+3A_steps">steps</code></td>
<td>
<p>a vector containing a subset of 1,2,3,4,5,6, indicating
which of the steps are to be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of Fourier frequencies that is yield by the
transformations described above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freq &lt;- 2*pi*c(3,2,5,8,9)/10

res &lt;- frequenciesValidator(freq, N=10, steps=1:3)
res * 10 / (2*pi) # Returns: [1] 3 2 5 8 9

res &lt;- frequenciesValidator(freq, N=10, steps=1:4)
res * 10 / (2*pi) # Returns: [1] 3 2 5 2 1

res &lt;- frequenciesValidator(freq, N=10, steps=1:5)
res * 10 / (2*pi) # Returns: [1] 3 2 5 1

res &lt;- frequenciesValidator(freq, N=10, steps=1:6)
res * 10 / (2*pi) # Returns: [1] 1 2 3 5
</code></pre>

<hr>
<h2 id='generics-accessors'>Generic functions for accessing attributes of objects</h2><span id='topic+generics-accessors'></span><span id='topic+getY'></span><span id='topic+getValues'></span><span id='topic+getCoherency'></span><span id='topic+getIsRankBased'></span><span id='topic+getB'></span><span id='topic+getLagOperator'></span><span id='topic+getMaxLag'></span><span id='topic+getParallel'></span><span id='topic+getFrequencies'></span><span id='topic+getLevels'></span><span id='topic+getMeanPG'></span><span id='topic+getStdError'></span><span id='topic+getN'></span><span id='topic+getR'></span><span id='topic+getType'></span><span id='topic+getTs'></span><span id='topic+getCoherencySdNaive'></span><span id='topic+getSdNaive'></span><span id='topic+getSdBoot'></span><span id='topic+getPointwiseCIs'></span><span id='topic+getDescr'></span><span id='topic+getW'></span><span id='topic+getBw'></span><span id='topic+getWnj'></span>

<h3>Description</h3>

<p>These generic functions are needed to access the objects' attributes.
Note that the naming convention <code>getAttribute</code> was applied, where
<code>attribute</code> is the name of the attribute/slot of the class of the
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getY(object, ...)

getValues(object, ...)

getCoherency(object, ...)

getIsRankBased(object, ...)

getB(object, ...)

getLagOperator(object, ...)

getMaxLag(object, ...)

getParallel(object, ...)

getFrequencies(object, ...)

getLevels(object, ...)

getMeanPG(object, ...)

getStdError(object, ...)

getN(object, ...)

getR(object, ...)

getType(object, ...)

getTs(object, ...)

getCoherencySdNaive(object, ...)

getSdNaive(object, ...)

getSdBoot(object, ...)

getPointwiseCIs(object, ...)

getDescr(object, ...)

getW(object, ...)

getBw(object, ...)

getWnj(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generics-accessors_+3A_object">object</code></td>
<td>
<p>object from which to get the value</p>
</td></tr>
<tr><td><code id="generics-accessors_+3A_...">...</code></td>
<td>
<p>optional parameters; for documentation see the documentation of
the methods to each of the generic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For an overview on the classes of the framework, and all of their
attributes, see the class diagrams in the package description
[cf. <code><a href="#topic+quantspec-package">quantspec-package</a></code>].
</p>

<hr>
<h2 id='generics-associations'>Generic functions for accessing associations of objects</h2><span id='topic+generics-associations'></span><span id='topic+getQuantilePG'></span><span id='topic+getBootPos'></span><span id='topic+getFreqRep'></span><span id='topic+getQuantileSD'></span><span id='topic+getWeight'></span>

<h3>Description</h3>

<p>These generic functions are needed to access the objects' associated objects.
Note that the naming convention <code>getAssociatedObject</code> was applied, where
<code>AssociatedObject</code> is the name of the class of the associated object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQuantilePG(object, ...)

getBootPos(object, ...)

getFreqRep(object, ...)

getQuantileSD(object, ...)

getWeight(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generics-associations_+3A_object">object</code></td>
<td>
<p>object from which to get the associated object</p>
</td></tr>
<tr><td><code id="generics-associations_+3A_...">...</code></td>
<td>
<p>optional parameters; for documentation see the documentation of
the methods to each of the generic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For an overview on the classes of the framework, and all
associations, see the class diagrams in the package description
[cf. <code><a href="#topic+quantspec-package">quantspec-package</a></code>].
</p>

<hr>
<h2 id='generics-functions'>Generic functions for implementation of methods of a class</h2><span id='topic+generics-functions'></span><span id='topic+increasePrecision'></span><span id='topic+getPositions'></span>

<h3>Description</h3>

<p>These generic functions need to be defined to allow for the automatic
dispaching mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>increasePrecision(object, ...)

getPositions(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generics-functions_+3A_object">object</code></td>
<td>
<p>specifies the object from which the method is to be applied.</p>
</td></tr>
<tr><td><code id="generics-functions_+3A_...">...</code></td>
<td>
<p>optional parameters; for documentation see the documentation of
the methods to the generic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For an overview on the classes of the framework, and all of their
methods, see the class diagrams in the package description
[cf. <code><a href="#topic+quantspec-package">quantspec-package</a></code>].
</p>

<hr>
<h2 id='getB-FreqRep'>Get <code>B</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code> object.</h2><span id='topic+getB-FreqRep'></span><span id='topic+getB+2CFreqRep-method'></span>

<h3>Description</h3>

<p>Get <code>B</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FreqRep'
getB(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getB-FreqRep_+3A_object">object</code></td>
<td>
<p><code>FreqRep</code> of which to get the <code>B</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>B</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getB-LagOperator'>Get <code>B</code> from a <code><a href="#topic+LagOperator">LagOperator</a></code> object.</h2><span id='topic+getB-LagOperator'></span><span id='topic+getB+2CLagOperator-method'></span>

<h3>Description</h3>

<p>Get <code>B</code> from a <code><a href="#topic+LagOperator">LagOperator</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagOperator'
getB(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getB-LagOperator_+3A_object">object</code></td>
<td>
<p><code>LagOperator</code> of which to get the <code>B</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>B</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getBootPos-FreqRep'>Get associated <code><a href="#topic+BootPos">BootPos</a></code> from a
<code><a href="#topic+FreqRep">FreqRep</a></code>.</h2><span id='topic+getBootPos-FreqRep'></span><span id='topic+getBootPos+2CFreqRep-method'></span>

<h3>Description</h3>

<p>Get associated <code><a href="#topic+BootPos">BootPos</a></code> from a
<code><a href="#topic+FreqRep">FreqRep</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FreqRep'
getBootPos(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBootPos-FreqRep_+3A_object">object</code></td>
<td>
<p><code>FreqRep</code> from which to get the
<code><a href="#topic+BootPos">BootPos</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+BootPos">BootPos</a></code> object associated.
</p>

<hr>
<h2 id='getBootPos-LagOperator'>Get associated <code><a href="#topic+BootPos">BootPos</a></code> from a
<code><a href="#topic+LagOperator">LagOperator</a></code>.</h2><span id='topic+getBootPos-LagOperator'></span><span id='topic+getBootPos+2CLagOperator-method'></span>

<h3>Description</h3>

<p>Get associated <code><a href="#topic+BootPos">BootPos</a></code> from a
<code><a href="#topic+LagOperator">LagOperator</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagOperator'
getBootPos(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBootPos-LagOperator_+3A_object">object</code></td>
<td>
<p><code>LagOperator</code> from which to get the
<code><a href="#topic+BootPos">BootPos</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+BootPos">BootPos</a></code> object associated.
</p>

<hr>
<h2 id='getBw-KernelWeight'>Get attribute <code>bw</code> (bandwidth / scaling parameter used for smoothing)
from a <code>KernelWeight</code>.</h2><span id='topic+getBw-KernelWeight'></span><span id='topic+getBw+2CKernelWeight-method'></span>

<h3>Description</h3>

<p>Get attribute <code>bw</code> (bandwidth / scaling parameter used for smoothing)
from a <code>KernelWeight</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KernelWeight'
getBw(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBw-KernelWeight_+3A_object">object</code></td>
<td>
<p><code>KernelWeight</code> from which to get the bandwidth <code>bw</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>bw</code> attribute.
</p>

<hr>
<h2 id='getBw-LagKernelWeight'>Get attribute <code>bw</code> (bandwidth / scaling parameter used for smoothing)
from a <code>LagKernelWeight</code>.</h2><span id='topic+getBw-LagKernelWeight'></span><span id='topic+getBw+2CLagKernelWeight-method'></span>

<h3>Description</h3>

<p>Get attribute <code>bw</code> (bandwidth / scaling parameter used for smoothing)
from a <code>LagKernelWeight</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagKernelWeight'
getBw(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBw-LagKernelWeight_+3A_object">object</code></td>
<td>
<p><code>LagKernelWeight</code> from which to get the bandwidth <code>bw</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>bw</code> attribute.
</p>

<hr>
<h2 id='getCoherency-QuantileSD'>Compute quantile coherency from a quantile spectral density kernel</h2><span id='topic+getCoherency-QuantileSD'></span><span id='topic+getCoherency+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>Returns quantile coherency defined as
</p>
<p style="text-align: center;"><code class="reqn">\frac{f^{j_1, j_2}(\omega; \tau_1, \tau_2)}{(f^{j_1, j_1}(\omega; \tau_1, \tau_1) f^{j_2, j_2}(\omega; \tau_2, \tau_2))^{1/2}}</code>
</p>

<p>where <code class="reqn">f^{j_1, j_2}(\omega; \tau_1, \tau_2)</code> is the quantile spectral density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
getCoherency(
  object,
  frequencies = 2 * pi * (0:(object@N - 1))/object@N,
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@values)[2]),
  d2 = 1:(dim(object@values)[4])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoherency-QuantileSD_+3A_object">object</code></td>
<td>
<p><code>QuantileSD</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getCoherency-QuantileSD_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the values</p>
</td></tr>
<tr><td><code id="getCoherency-QuantileSD_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getCoherency-QuantileSD_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getCoherency-QuantileSD_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
data; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getCoherency-QuantileSD_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the mechanism of selecting frequencies, dimensions and/or levels see,
for example, <code><a href="#topic+getValues-QuantileSD">getValues-QuantileSD</a></code>.
</p>


<h3>Value</h3>

<p>Returns data from the coherency as defined in the details.
</p>


<h3>See Also</h3>

<p>For examples on how to use this function go to <code><a href="#topic+QuantileSD">QuantileSD</a></code>.
</p>

<hr>
<h2 id='getCoherency-SmoothedPG'>Compute quantile coherency from a smoothed quantile periodogram.</h2><span id='topic+getCoherency-SmoothedPG'></span><span id='topic+getCoherency+2CSmoothedPG-method'></span>

<h3>Description</h3>

<p>Returns quantile coherency defined as
</p>
<p style="text-align: center;"><code class="reqn">\frac{G^{j_1, j_2}(\omega; \tau_1, \tau_2)}{(G^{j_1, j_1}(\omega; \tau_1, \tau_1) G^{j_2, j_2}(\omega; \tau_2, \tau_2))^{1/2}}</code>
</p>

<p>where <code class="reqn">G^{j_1, j_2}(\omega; \tau_1, \tau_2)</code> is the smoothed quantile
periodogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothedPG'
getCoherency(
  object,
  frequencies = 2 * pi * (0:(lenTS(object@qPG@freqRep@Y) -
    1))/lenTS(object@qPG@freqRep@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@values)[2]),
  d2 = 1:(dim(object@values)[4])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoherency-SmoothedPG_+3A_object">object</code></td>
<td>
<p><code>SmoothedPG</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getCoherency-SmoothedPG_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the values</p>
</td></tr>
<tr><td><code id="getCoherency-SmoothedPG_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getCoherency-SmoothedPG_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getCoherency-SmoothedPG_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
data; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getCoherency-SmoothedPG_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the mechanism of selecting frequencies, dimensions and/or levels see,
for example, <code><a href="#topic+getValues-SmoothedPG">getValues-SmoothedPG</a></code>.
</p>


<h3>Value</h3>

<p>Returns data from the array <code>values</code> that's a slot of
<code>object</code>.
</p>


<h3>See Also</h3>

<p>An example on how to use this function is analogously to the example given in
<code><a href="#topic+getValues-QuantilePG">getValues-QuantilePG</a></code>.
</p>

<hr>
<h2 id='getCoherencySdNaive-SmoothedPG'>Get estimates for the standard deviation of the coherency computed from
smoothed quantile periodogram.</h2><span id='topic+getCoherencySdNaive-SmoothedPG'></span><span id='topic+getCoherencySdNaive+2CSmoothedPG-method'></span>

<h3>Description</h3>

<p>Determines and returns an array of dimension <code>[J,K1,K2]</code>,
where <code>J=length(frequencies)</code>, <code>K1=length(levels.1)</code>, and
<code>K2=length(levels.2))</code>. Whether
available or not, boostrap repetitions are ignored by this procedure.
At position <code>(j,k1,k2)</code>
the returned value is the standard deviation estimated corresponding to
<code>frequencies[j]</code>, <code>levels.1[k1]</code> and <code>levels.2[k2]</code> that are
closest to the
<code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothedPG'
getCoherencySdNaive(
  object,
  frequencies = 2 * pi * (0:(lenTS(object@qPG@freqRep@Y) -
    1))/lenTS(object@qPG@freqRep@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@values)[2]),
  d2 = 1:(dim(object@values)[4]),
  type = c("1", "2"),
  impl = c("R", "C")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCoherencySdNaive-SmoothedPG_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SmoothedPG">SmoothedPG</a></code> of which to get the estimates for the
standard deviation.</p>
</td></tr>
<tr><td><code id="getCoherencySdNaive-SmoothedPG_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the result</p>
</td></tr>
<tr><td><code id="getCoherencySdNaive-SmoothedPG_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getCoherencySdNaive-SmoothedPG_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getCoherencySdNaive-SmoothedPG_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
data; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getCoherencySdNaive-SmoothedPG_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
<tr><td><code id="getCoherencySdNaive-SmoothedPG_+3A_type">type</code></td>
<td>
<p>can be &quot;1&quot;, where cov(Z, Conj(Z)) is subtracted, or &quot;2&quot;, where
it's not</p>
</td></tr>
<tr><td><code id="getCoherencySdNaive-SmoothedPG_+3A_impl">impl</code></td>
<td>
<p>choose &quot;R&quot; or &quot;C&quot; for one of the two implementations available</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If not only one, but multiple time series are under study, the dimension of
the returned vector is of dimension <code>[J,P,K1,P,K2]</code>, where <code>P</code>
denotes the dimension of the time series.
</p>
<p>Requires that the <code><a href="#topic+SmoothedPG">SmoothedPG</a></code> is available at all Fourier
frequencies from <code class="reqn">(0,\pi]</code>. If this is not the case the missing
values are imputed by taking one that is available and has a frequency
that is closest to the missing Fourier frequency; <code>closest.pos</code> is used
to determine which one this is.
</p>
<p>A precise definition on how the standard deviations of the smoothed quantile
periodogram are estimated is given in Barunik and Kley (2015). The estimate
returned is denoted by
<code class="reqn">\sigma(\tau_1, \tau_2; \omega)</code> on p. 26 of
the arXiv preprint.
</p>
<p>Note the &ldquo;standard deviation&rdquo; estimated here is not the square root of the
complex-valued variance. It's real part is the square root of the variance
of the real part of the estimator and the imaginary part is the square root
of the imaginary part of the variance of the estimator.
</p>


<h3>Value</h3>

<p>Returns the estimate described above.
</p>


<h3>References</h3>

<p>Kley, T., Volgushev, S., Dette, H. &amp; Hallin, M. (2016).
Quantile Spectral Processes: Asymptotic Analysis and Inference.
<em>Bernoulli</em>, <b>22</b>(3), 1770&ndash;1807.
[cf. <a href="http://arxiv.org/abs/1401.8104">http://arxiv.org/abs/1401.8104</a>]
</p>
<p>Barunik, J. &amp; Kley, T. (2015).
Quantile Cross-Spectral Measures of Dependence between Economic Variables.
[preprint available from the authors]
</p>

<hr>
<h2 id='getDescr-Weight'>Get attribute <code>descr</code> from a <code>Weight</code>.</h2><span id='topic+getDescr-Weight'></span><span id='topic+getDescr+2CWeight-method'></span>

<h3>Description</h3>

<p>Get attribute <code>descr</code> from a <code>Weight</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Weight'
getDescr(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDescr-Weight_+3A_object">object</code></td>
<td>
<p><code>Weight</code> from which to get the <code>descr</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>descr</code> attribute.
</p>

<hr>
<h2 id='getFreqRep-QuantilePG'>Get associated <code><a href="#topic+FreqRep">FreqRep</a></code> from a
<code><a href="#topic+QuantilePG">QuantilePG</a></code>.</h2><span id='topic+getFreqRep-QuantilePG'></span><span id='topic+getFreqRep+2CQuantilePG-method'></span>

<h3>Description</h3>

<p>Get associated <code><a href="#topic+FreqRep">FreqRep</a></code> from a
<code><a href="#topic+QuantilePG">QuantilePG</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantilePG'
getFreqRep(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFreqRep-QuantilePG_+3A_object">object</code></td>
<td>
<p><code>QuantilePG</code> from which to get the
<code><a href="#topic+FreqRep">FreqRep</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+FreqRep">FreqRep</a></code> object associated.
</p>

<hr>
<h2 id='getFrequencies-FreqRep'>Get attribute <code>frequencies</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code>.</h2><span id='topic+getFrequencies-FreqRep'></span><span id='topic+getFrequencies+2CFreqRep-method'></span>

<h3>Description</h3>

<p>Get attribute <code>frequencies</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FreqRep'
getFrequencies(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFrequencies-FreqRep_+3A_object">object</code></td>
<td>
<p><code>FreqRep</code> from which to get the
<code>frequencies</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>frequencies</code> attribute, as a vector of real numbers.
</p>

<hr>
<h2 id='getFrequencies-QSpecQuantity'>Get attribute <code>frequencies</code> from a <code>QSpecQuantity</code>.</h2><span id='topic+getFrequencies-QSpecQuantity'></span><span id='topic+getFrequencies+2CQSpecQuantity-method'></span>

<h3>Description</h3>

<p>Get attribute <code>frequencies</code> from a <code>QSpecQuantity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QSpecQuantity'
getFrequencies(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFrequencies-QSpecQuantity_+3A_object">object</code></td>
<td>
<p><code>QSpecQuantity</code> from which to get the <code>frequencies</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the frequencies attribute, as a vector of real numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qPG  &lt;- quantilePG(rnorm(10), levels.1=c(0.25,0.5))
freq &lt;- getFrequencies(qPG)
</code></pre>

<hr>
<h2 id='getIsRankBased-FreqRep'>Get <code>isRankBased</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code> object</h2><span id='topic+getIsRankBased-FreqRep'></span><span id='topic+getIsRankBased+2CFreqRep-method'></span>

<h3>Description</h3>

<p>Get <code>isRankBased</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FreqRep'
getIsRankBased(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIsRankBased-FreqRep_+3A_object">object</code></td>
<td>
<p><code>FreqRep</code> of which to get the <code>isRankBased</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>isRankBased</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getIsRankBased-LagOperator'>Get <code>isRankBased</code> from a <code><a href="#topic+LagOperator">LagOperator</a></code> object</h2><span id='topic+getIsRankBased-LagOperator'></span><span id='topic+getIsRankBased+2CLagOperator-method'></span>

<h3>Description</h3>

<p>Get <code>isRankBased</code> from a <code><a href="#topic+LagOperator">LagOperator</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagOperator'
getIsRankBased(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIsRankBased-LagOperator_+3A_object">object</code></td>
<td>
<p><code>LagOperator</code> of which to get the <code>isRankBased</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>isRankBased</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getLagOperator-LagEstimator'>Get associated <code><a href="#topic+LagOperator">LagOperator</a></code> from a <code><a href="#topic+LagEstimator">LagEstimator</a></code>.</h2><span id='topic+getLagOperator-LagEstimator'></span><span id='topic+getLagOperator+2CLagEstimator-method'></span>

<h3>Description</h3>

<p>Get associated <code><a href="#topic+LagOperator">LagOperator</a></code> from a <code><a href="#topic+LagEstimator">LagEstimator</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagEstimator'
getLagOperator(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLagOperator-LagEstimator_+3A_object">object</code></td>
<td>
<p><code>LagEstimator</code> from which to get the <code>LagOperator</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+LagOperator">LagOperator</a></code> object associated.
</p>

<hr>
<h2 id='getLevels-FreqRep'>Get attribute <code>levels</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code>.</h2><span id='topic+getLevels-FreqRep'></span><span id='topic+getLevels+2CFreqRep-method'></span>

<h3>Description</h3>

<p>Get attribute <code>levels</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FreqRep'
getLevels(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLevels-FreqRep_+3A_object">object</code></td>
<td>
<p><code>FreqRep</code> from which to get the
<code>levels</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>levels</code> attribute, as a vector of real numbers.
</p>

<hr>
<h2 id='getLevels-LagOperator'>Get attribute <code>levels</code> from a <code>LagOperator</code>.</h2><span id='topic+getLevels-LagOperator'></span><span id='topic+getLevels+2CLagOperator-method'></span>

<h3>Description</h3>

<p>If the optional parameter <code>j</code> is supplied, then the <code>j</code>th vector of
levels will be returned, a list with all vectors otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagOperator'
getLevels(object, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLevels-LagOperator_+3A_object">object</code></td>
<td>
<p><code>LagOperator</code> from which to get the <code>levels</code>.</p>
</td></tr>
<tr><td><code id="getLevels-LagOperator_+3A_j">j</code></td>
<td>
<p>Index pointing to a set of levels in the list; optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns levels attribute, as a vector of real numbers.
</p>

<hr>
<h2 id='getLevels-QSpecQuantity'>Get attribute <code>levels</code> from a <code>QSpecQuantity</code>.</h2><span id='topic+getLevels-QSpecQuantity'></span><span id='topic+getLevels+2CQSpecQuantity-method'></span>

<h3>Description</h3>

<p>If the optional parameter <code>j</code> is supplied, then the <code>j</code>th vector of
levels will be returned, a list with all vectors otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QSpecQuantity'
getLevels(object, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLevels-QSpecQuantity_+3A_object">object</code></td>
<td>
<p><code>QSpecQuantity</code> from which to get the <code>levels</code>.</p>
</td></tr>
<tr><td><code id="getLevels-QSpecQuantity_+3A_j">j</code></td>
<td>
<p>Index pointing to a set of levels in the list; optional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns levels attribute, as a vector of real numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qPG         &lt;- quantilePG(rnorm(10), levels.1=c(0.25,0.5))
levels.list &lt;- getLevels(qPG)
levels.1    &lt;- getLevels(qPG,1)
</code></pre>

<hr>
<h2 id='getMaxLag-LagOperator'>Get <code>maxLag</code> from a <code><a href="#topic+LagOperator">LagOperator</a></code> object.</h2><span id='topic+getMaxLag-LagOperator'></span><span id='topic+getMaxLag+2CLagOperator-method'></span>

<h3>Description</h3>

<p>Get <code>maxLag</code> from a <code><a href="#topic+LagOperator">LagOperator</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagOperator'
getMaxLag(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMaxLag-LagOperator_+3A_object">object</code></td>
<td>
<p><code>LagOperator</code> of which to get the <code>maxLag</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>maxLag</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getMeanPG-QuantileSD'>Get <code>meanPG</code> from a quantile spectral density kernel</h2><span id='topic+getMeanPG-QuantileSD'></span><span id='topic+getMeanPG+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>The selection mechanism for frequencies and levels operates in the same way
as described in <code><a href="#topic+getValues-QuantileSD">getValues-QuantileSD</a></code>. The format of the
output is also described there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
getMeanPG(
  object,
  frequencies = 2 * pi * (0:(getN(object) - 1))/getN(object),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@values)[2]),
  d2 = 1:(dim(object@values)[4])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMeanPG-QuantileSD_+3A_object">object</code></td>
<td>
<p><code>QuantileSD</code> of which to get the <code>meanPG</code></p>
</td></tr>
<tr><td><code id="getMeanPG-QuantileSD_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the <code>meanPG</code></p>
</td></tr>
<tr><td><code id="getMeanPG-QuantileSD_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the <code>meanPG</code></p>
</td></tr>
<tr><td><code id="getMeanPG-QuantileSD_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the <code>meanPG</code></p>
</td></tr>
<tr><td><code id="getMeanPG-QuantileSD_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
<code>meanPG</code>; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getMeanPG-QuantileSD_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the array <code>meanPG</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getN-QuantileSD'>Get <code>N</code> from a quantile spectral density kernel</h2><span id='topic+getN-QuantileSD'></span><span id='topic+getN+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>Get <code>N</code> from a quantile spectral density kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
getN(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getN-QuantileSD_+3A_object">object</code></td>
<td>
<p><code>QuantileSD</code> of which to get the <code>N</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>N</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getParallel-QRegEstimator'>Get <code>getParallel</code> from a <code><a href="#topic+QRegEstimator">QRegEstimator</a></code> object</h2><span id='topic+getParallel-QRegEstimator'></span><span id='topic+getParallel+2CQRegEstimator-method'></span>

<h3>Description</h3>

<p>Get <code>getParallel</code> from a <code><a href="#topic+QRegEstimator">QRegEstimator</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QRegEstimator'
getParallel(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParallel-QRegEstimator_+3A_object">object</code></td>
<td>
<p><code>QRegEstimator</code> of which to get the <code>parallel</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>parallel</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getPointwiseCIs-LagEstimator'>Get pointwise confidence intervals for the quantile spectral density kernel</h2><span id='topic+getPointwiseCIs-LagEstimator'></span><span id='topic+getPointwiseCIs+2CLagEstimator-method'></span>

<h3>Description</h3>

<p>Returns a list of two arrays <code>lowerCIs</code> and <code>upperCIs</code> that contain
the upper and lower limits for a level <code>1-alpha</code> confidence interval of
the copula spectral density kernel. Each array is of dimension <code>[J,K1,K2]</code>,
where <code>J=length(frequencies)</code>, <code>K1=length(levels.1)</code>, and
<code>K2=length(levels.2))</code>.
At position <code>(j,k1,k2)</code> the real (imaginary) part of the returned values
are the bounds of the confidence interval for the the real (imaginary) part
of the quantile spectrum, which corresponds to
<code>frequencies[j]</code>, <code>levels.1[k1]</code> and <code>levels.2[k2]</code> closest
to the Fourier frequencies, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagEstimator'
getPointwiseCIs(
  object,
  frequencies = 2 * pi * (0:(length(object@Y) - 1))/length(object@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  alpha = 0.1,
  type = c("naive.sd", "boot.sd", "boot.full")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPointwiseCIs-LagEstimator_+3A_object">object</code></td>
<td>
<p><code>LagEstimator</code> of which to get the confidence intervals</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-LagEstimator_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the result</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-LagEstimator_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-LagEstimator_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-LagEstimator_+3A_alpha">alpha</code></td>
<td>
<p>the level of the confidence interval; must be from <code class="reqn">(0,1)</code></p>
</td></tr>
<tr><td><code id="getPointwiseCIs-LagEstimator_+3A_type">type</code></td>
<td>
<p>a flag indicating which type of confidence interval should be
returned; can only take one values at the moment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only one <code>type</code> of confidence interval is
available:
</p>

<ul>
<li> <p><code>"naive.sd"</code>: confidence intervals based on the asymptotic
normality of the lag-window estimator; standard deviations
are estimated using <code><a href="#topic+getSdNaive">getSdNaive</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a named list of two arrays <code>lowerCIS</code> and <code>upperCIs</code>
containing the lower and upper bounds for the confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lagEst &lt;- lagEstimator(rnorm(2^10), levels.1=0.5)
CI.upper &lt;- Re(getPointwiseCIs(lagEst)$upperCIs[,1,1])
CI.lower &lt;- Re(getPointwiseCIs(lagEst)$lowerCIs[,1,1])
freq = 2*pi*(0:1023)/1024
plot(x = freq, y = rep(0.25/(2*pi),1024),
   ylim=c(min(CI.lower), max(CI.upper)),
   type="l", col="red") # true spectrum
lines(x = freq, y = CI.upper)
lines(x = freq, y = CI.lower)
</code></pre>

<hr>
<h2 id='getPointwiseCIs-SmoothedPG'>Get pointwise confidence intervals for the quantile spectral density kernel,
quantile coherency or quantile coherence.</h2><span id='topic+getPointwiseCIs-SmoothedPG'></span><span id='topic+getPointwiseCIs+2CSmoothedPG-method'></span>

<h3>Description</h3>

<p>Returns a list of two arrays <code>lowerCIs</code> and <code>upperCIs</code> that contain
the upper and lower limits for a level <code>1-alpha</code> confidence interval of
the quantity of interest. Each array is of dimension <code>[J,K1,K2]</code> if a
univariate time series is being analysed or of dimension <code>[J,D1,K1,D2,K2]</code>,
where <code>J=length(frequencies)</code>, <code>D1=length(d1)</code>, <code>D2=length(d2)</code>,
<code>K1=length(levels.1)</code>, and <code>K2=length(levels.2))</code>.
At position <code>(j,k1,k2)</code> or <code>(j,i1,k1,i2,k2)</code> the real (imaginary)
part of the returned values are the bounds of the confidence interval for the
the real (imaginary) part of the quantity under anlysis, which corresponds to
<code>frequencies[j]</code>, <code>d1[i1]</code>, <code>d2[i2]</code>, <code>levels.1[k1]</code> and
<code>levels.2[k2]</code> closest to the Fourier frequencies, <code>levels.1</code> and
<code>levels.2</code> available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used
to determine what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothedPG'
getPointwiseCIs(
  object,
  quantity = c("spectral density", "coherency", "coherence"),
  frequencies = 2 * pi * (0:(lenTS(object@qPG@freqRep@Y) -
    1))/lenTS(object@qPG@freqRep@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@values)[2]),
  d2 = 1:(dim(object@values)[4]),
  alpha = 0.1,
  type = c("naive.sd", "boot.sd", "boot.full")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPointwiseCIs-SmoothedPG_+3A_object">object</code></td>
<td>
<p><code>SmoothedPG</code> of which to get the confidence intervals</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-SmoothedPG_+3A_quantity">quantity</code></td>
<td>
<p>a flag indicating for which the pointwise confidence bands
will be determined. Can take one of the possible values
discussed above.</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-SmoothedPG_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the result</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-SmoothedPG_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-SmoothedPG_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-SmoothedPG_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
data; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-SmoothedPG_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
<tr><td><code id="getPointwiseCIs-SmoothedPG_+3A_alpha">alpha</code></td>
<td>
<p>the level of the confidence interval; must be from <code class="reqn">(0,1)</code></p>
</td></tr>
<tr><td><code id="getPointwiseCIs-SmoothedPG_+3A_type">type</code></td>
<td>
<p>a flag indicating which type of confidence interval should be
returned; can take one of the three values discussed above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, pointwise confidence bands for two different <code>quantity</code>
are implemented:
</p>

<ul>
<li> <p><code>"spectral density"</code>: confidence intervals for the quantile spectral
density as described in Kley et. al (2016) for the univariate case and
in Barunik and Kley (2015) for the multivariate case.
</p>
</li>
<li> <p><code>"coherency"</code>: confidence intervals for the quantile coherency as
described in Barunik and Kley (2015).
</p>
</li></ul>

<p>Currently, three different <code>type</code>s of confidence intervals are
available:
</p>

<ul>
<li> <p><code>"naive.sd"</code>: confidence intervals based on the asymptotic
normality of the smoothed quantile periodogram; standard deviations
are estimated using <code><a href="#topic+getSdNaive">getSdNaive</a></code>.
</p>
</li>
<li> <p><code>"boot.sd"</code>: confidence intervals based on the asymptotic
normality of the smoothed quantile periodogram; standard deviations
are estimated using <code><a href="#topic+getSdBoot">getSdBoot</a></code>.
</p>
</li>
<li> <p><code>"boot.full"</code>: confidence intervals determined by estimating the
quantiles of he distribution of the smoothed quantile periodogram,
by the empirical quantiles of the sample of bootstrapped
replications.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a named list of two arrays <code>lowerCIS</code> and <code>upperCIs</code>
containing the lower and upper bounds for the confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sPG &lt;- smoothedPG(rnorm(2^10), levels.1=0.5)
CI.upper &lt;- Re(getPointwiseCIs(sPG)$upperCIs[,1,1])
CI.lower &lt;- Re(getPointwiseCIs(sPG)$lowerCIs[,1,1])
freq = 2*pi*(0:1023)/1024
plot(x = freq, y = rep(0.25/(2*pi),1024),
   ylim=c(min(CI.lower), max(CI.upper)),
   type="l", col="red") # true spectrum
lines(x = freq, y = CI.upper)
lines(x = freq, y = CI.lower)
</code></pre>

<hr>
<h2 id='getPositions-MovingBlocks'>Get Positions for the Moving Blocks Bootstrap.</h2><span id='topic+getPositions-MovingBlocks'></span><span id='topic+getPositions+2CMovingBlocks-method'></span>

<h3>Description</h3>

<p>Get Positions for the Moving Blocks Bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MovingBlocks'
getPositions(object, B = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPositions-MovingBlocks_+3A_object">object</code></td>
<td>
<p>a <code>MovingBlocks</code> object; used to specify the parameters
<code>N</code>, <code>l</code> and the type of the bootstrap.</p>
</td></tr>
<tr><td><code id="getPositions-MovingBlocks_+3A_b">B</code></td>
<td>
<p>Number of independent repetitions to bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of dimension <code>[N,B]</code> where each column gives the
positions in which to reorder the observations to yield one
bootstrap replication.
</p>

<hr>
<h2 id='getQuantilePG-QuantileSD'>Get associated <code><a href="#topic+QuantilePG">QuantilePG</a></code> from a <code><a href="#topic+QuantileSD">QuantileSD</a></code>.</h2><span id='topic+getQuantilePG-QuantileSD'></span><span id='topic+getQuantilePG+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>Get associated <code><a href="#topic+QuantilePG">QuantilePG</a></code> from a <code><a href="#topic+QuantileSD">QuantileSD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
getQuantilePG(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQuantilePG-QuantileSD_+3A_object">object</code></td>
<td>
<p><code>QuantileSD</code> from which to get the
<code><a href="#topic+QuantilePG">QuantilePG</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+QuantilePG">QuantilePG</a></code> object associated.
</p>

<hr>
<h2 id='getQuantilePG-SmoothedPG'>Get associated <code><a href="#topic+QuantilePG">QuantilePG</a></code> from a <code><a href="#topic+SmoothedPG">SmoothedPG</a></code>.</h2><span id='topic+getQuantilePG-SmoothedPG'></span><span id='topic+getQuantilePG+2CSmoothedPG-method'></span>

<h3>Description</h3>

<p>Get associated <code><a href="#topic+QuantilePG">QuantilePG</a></code> from a <code><a href="#topic+SmoothedPG">SmoothedPG</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothedPG'
getQuantilePG(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQuantilePG-SmoothedPG_+3A_object">object</code></td>
<td>
<p><code>SmoothedPG</code> from which to get the <code><a href="#topic+QuantilePG">QuantilePG</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+QuantilePG">QuantilePG</a></code> object associated.
</p>

<hr>
<h2 id='getQuantileSD-IntegrQuantileSD'>Get associated <code><a href="#topic+getQuantileSD">getQuantileSD</a></code> from an
<code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code>.</h2><span id='topic+getQuantileSD-IntegrQuantileSD'></span><span id='topic+getQuantileSD+2CIntegrQuantileSD-method'></span>

<h3>Description</h3>

<p>Get associated <code><a href="#topic+getQuantileSD">getQuantileSD</a></code> from an
<code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IntegrQuantileSD'
getQuantileSD(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getQuantileSD-IntegrQuantileSD_+3A_object">object</code></td>
<td>
<p><code>IntegrQuantileSD</code> from which to get the
<code><a href="#topic+getQuantileSD">getQuantileSD</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+getQuantileSD">getQuantileSD</a></code> object associated.
</p>

<hr>
<h2 id='getR-QuantileSD'>Get <code>R</code> from a quantile spectral density kernel</h2><span id='topic+getR-QuantileSD'></span><span id='topic+getR+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>Get <code>R</code> from a quantile spectral density kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
getR(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getR-QuantileSD_+3A_object">object</code></td>
<td>
<p><code>QuantileSD</code> of which to get the <code>R</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>R</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getSdBoot-LagEstimator'>Get bootstrap estimates for the standard deviation of the lag-window type
estimator.</h2><span id='topic+getSdBoot-LagEstimator'></span><span id='topic+getSdBoot+2CLagEstimator-method'></span>

<h3>Description</h3>

<p>Determines and returns an array of dimension <code>[J,K1,K2]</code>,
where <code>J=length(frequencies)</code>, <code>K1=length(levels.1)</code>, and
<code>K2=length(levels.2))</code>.
At position <code>(j,k1,k2)</code> the real part of the returned value is the
standard deviation estimated from the real parts of the bootstrap
replications and the imaginary part of the returned value is the standard
deviation estimated from the imaginary part of the bootstrap replications.
The estimate is determined from those bootstrap replicates of the estimator
that have
<code>frequencies[j]</code>, <code>levels.1[k1]</code> and <code>levels.2[k2]</code> closest
to the <code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagEstimator'
getSdBoot(
  object,
  frequencies = 2 * pi * (0:(length(object@lagOp@Y) - 1))/length(object@lagOp@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSdBoot-LagEstimator_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+LagEstimator">LagEstimator</a></code> of which to get the bootstrap
estimates for the standard deviation.</p>
</td></tr>
<tr><td><code id="getSdBoot-LagEstimator_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the result</p>
</td></tr>
<tr><td><code id="getSdBoot-LagEstimator_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getSdBoot-LagEstimator_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires that the <code><a href="#topic+LagEstimator">LagEstimator</a></code> is available at all Fourier
frequencies from <code class="reqn">(0,\pi]</code>. If this is not the case the missing
values are imputed by taking one that is available and has a frequency
that is closest to the missing Fourier frequency; <code>closest.pos</code> is used
to determine which one this is.
</p>
<p>If there are no bootstrap replicates available (i. e., <code>B == 0</code>) an
error is returned.
</p>
<p>Note the &ldquo;standard deviation&rdquo; estimated here is not the square root of the
complex-valued variance. It's real part is the square root of the variance
of the real part of the estimator and the imaginary part is the square root
of the imaginary part of the variance of the estimator.
</p>


<h3>Value</h3>

<p>Returns the estimate described above.
</p>

<hr>
<h2 id='getSdBoot-SmoothedPG'>Get bootstrap estimates for the standard deviation of the smoothed quantile
periodogram.</h2><span id='topic+getSdBoot-SmoothedPG'></span><span id='topic+getSdBoot+2CSmoothedPG-method'></span>

<h3>Description</h3>

<p>Determines and returns an array of dimension <code>[J,K1,K2]</code>,
where <code>J=length(frequencies)</code>, <code>K1=length(levels.1)</code>, and
<code>K2=length(levels.2))</code>.
At position <code>(j,k1,k2)</code> the real part of the returned value is the
standard deviation estimated from the real parts of the bootstrap
replications and the imaginary part of the returned value is the standard
deviation estimated from the imaginary part of the bootstrap replications.
The estimate is determined from those bootstrap replicates of the estimator
that have
<code>frequencies[j]</code>, <code>levels.1[k1]</code> and <code>levels.2[k2]</code> closest
to the <code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothedPG'
getSdBoot(
  object,
  frequencies = 2 * pi * (0:(lenTS(object@qPG@freqRep@Y) -
    1))/lenTS(object@qPG@freqRep@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSdBoot-SmoothedPG_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SmoothedPG">SmoothedPG</a></code> of which to get the bootstrap estimates for the
standard deviation.</p>
</td></tr>
<tr><td><code id="getSdBoot-SmoothedPG_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the result</p>
</td></tr>
<tr><td><code id="getSdBoot-SmoothedPG_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getSdBoot-SmoothedPG_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires that the <code><a href="#topic+SmoothedPG">SmoothedPG</a></code> is available at all Fourier
frequencies from <code class="reqn">(0,\pi]</code>. If this is not the case the missing
values are imputed by taking one that is available and has a frequency
that is closest to the missing Fourier frequency; <code>closest.pos</code> is used
to determine which one this is.
</p>
<p>If there are no bootstrap replicates available (i. e., <code>B == 0</code>) an
error is returned.
</p>
<p>Note the &ldquo;standard deviation&rdquo; estimated here is not the square root of the
complex-valued variance. It's real part is the square root of the variance
of the real part of the estimator and the imaginary part is the square root
of the imaginary part of the variance of the estimator.
</p>


<h3>Value</h3>

<p>Returns the estimate described above.
</p>

<hr>
<h2 id='getSdNaive-LagEstimator'>Get estimates for the standard deviation of the lagEstimator derived from
the asymptotics (see Birr et al (2015))</h2><span id='topic+getSdNaive-LagEstimator'></span><span id='topic+getSdNaive+2CLagEstimator-method'></span>

<h3>Description</h3>

<p>Determines and returns an array of dimension <code>[J,K1,K2]</code>,
where <code>J=length(frequencies)</code>, <code>K1=length(levels.1)</code>, and
<code>K2=length(levels.2))</code>.
At position <code>(j,k1,k2)</code> the returned value is the standard deviation 
estimated corresponding to <code>frequencies[j]</code>, <code>levels.1[k1]</code> and 
<code>levels.2[k2]</code> that are closest to the <code>frequencies</code>, <code>levels.1</code>
and <code>levels.2</code> available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is 
used to determine what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagEstimator'
getSdNaive(
  object,
  frequencies = 2 * pi * (0:(length(object@Y) - 1))/length(object@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSdNaive-LagEstimator_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+LagEstimator">LagEstimator</a></code> of which to get the estimates for the
standard deviation.</p>
</td></tr>
<tr><td><code id="getSdNaive-LagEstimator_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the result</p>
</td></tr>
<tr><td><code id="getSdNaive-LagEstimator_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getSdNaive-LagEstimator_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires that the <code><a href="#topic+LagEstimator">LagEstimator</a></code> is available at all Fourier
frequencies from <code class="reqn">(0,\pi]</code>. If this is not the case the missing
values are imputed by taking one that is available and has a frequency
that is closest to the missing Fourier frequency; <code>closest.pos</code> is used
to determine which one this is.
</p>
<p>Note the &ldquo;standard deviation&rdquo; estimated here is not the square root of the
complex-valued variance. It's real part is the square root of the variance
of the real part of the estimator and the imaginary part is the square root
of the imaginary part of the variance of the estimator.
</p>


<h3>Value</h3>

<p>Returns the estimate described above.
</p>

<hr>
<h2 id='getSdNaive-SmoothedPG'>Get estimates for the standard deviation of the smoothed quantile
periodogram.</h2><span id='topic+getSdNaive-SmoothedPG'></span><span id='topic+getSdNaive+2CSmoothedPG-method'></span>

<h3>Description</h3>

<p>Determines and returns an array of dimension <code>[J,K1,K2]</code>,
where <code>J=length(frequencies)</code>, <code>K1=length(levels.1)</code>, and
<code>K2=length(levels.2))</code>. Whether
available or not, boostrap repetitions are ignored by this procedure.
At position <code>(j,k1,k2)</code>
the returned value is the standard deviation estimated corresponding to
<code>frequencies[j]</code>, <code>levels.1[k1]</code> and <code>levels.2[k2]</code> that are
closest to the
<code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothedPG'
getSdNaive(
  object,
  frequencies = 2 * pi * (0:(lenTS(object@qPG@freqRep@Y) -
    1))/lenTS(object@qPG@freqRep@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@values)[2]),
  d2 = 1:(dim(object@values)[4]),
  impl = c("R", "C")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSdNaive-SmoothedPG_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SmoothedPG">SmoothedPG</a></code> of which to get the estimates for the
standard deviation.</p>
</td></tr>
<tr><td><code id="getSdNaive-SmoothedPG_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the result</p>
</td></tr>
<tr><td><code id="getSdNaive-SmoothedPG_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getSdNaive-SmoothedPG_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the result</p>
</td></tr>
<tr><td><code id="getSdNaive-SmoothedPG_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
data; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getSdNaive-SmoothedPG_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
<tr><td><code id="getSdNaive-SmoothedPG_+3A_impl">impl</code></td>
<td>
<p>choose &quot;R&quot; or &quot;C&quot; for one of the two implementations available</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If not only one, but multiple time series are under study, the dimension of
the returned vector is of dimension <code>[J,P,K1,P,K2,B+1]</code>, where <code>P</code>
denotes the dimension of the time series. 
</p>
<p>Requires that the <code><a href="#topic+SmoothedPG">SmoothedPG</a></code> is available at all Fourier
frequencies from <code class="reqn">(0,\pi]</code>. If this is not the case the missing
values are imputed by taking one that is available and has a frequency
that is closest to the missing Fourier frequency; <code>closest.pos</code> is used
to determine which one this is.
</p>
<p>A precise definition on how the standard deviations of the smoothed quantile
periodogram are estimated is given in Barunik&amp;Kley (2015).
</p>
<p>Note the &ldquo;standard deviation&rdquo; estimated here is not the square root of the
complex-valued variance. It's real part is the square root of the variance
of the real part of the estimator and the imaginary part is the square root
of the imaginary part of the variance of the estimator.
</p>


<h3>Value</h3>

<p>Returns the estimate described above.
</p>


<h3>References</h3>

<p>Dette, H., Hallin, M., Kley, T. &amp; Volgushev, S. (2015).
Of Copulas, Quantiles, Ranks and Spectra: an <code class="reqn">L_1</code>-approach to
spectral analysis. <em>Bernoulli</em>, <b>21</b>(2), 781&ndash;831.
[cf. <a href="http://arxiv.org/abs/1111.7205">http://arxiv.org/abs/1111.7205</a>]
</p>

<hr>
<h2 id='getStdError-QuantileSD'>Get <code>stdError</code> from a quantile spectral density kernel</h2><span id='topic+getStdError-QuantileSD'></span><span id='topic+getStdError+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>The selection mechanism for frequencies and levels operates in the same way
as described in <code><a href="#topic+getValues-QuantileSD">getValues-QuantileSD</a></code>. The format of the
output is also described there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
getStdError(
  object,
  frequencies = 2 * pi * (0:(object@N - 1))/object@N,
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@values)[2]),
  d2 = 1:(dim(object@values)[4])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStdError-QuantileSD_+3A_object">object</code></td>
<td>
<p><code>QuantileSD</code> of which to get the <code>stdError</code></p>
</td></tr>
<tr><td><code id="getStdError-QuantileSD_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the <code>stdError</code></p>
</td></tr>
<tr><td><code id="getStdError-QuantileSD_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the <code>stdError</code></p>
</td></tr>
<tr><td><code id="getStdError-QuantileSD_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the <code>stdError</code></p>
</td></tr>
<tr><td><code id="getStdError-QuantileSD_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
<code>stdError</code>; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getStdError-QuantileSD_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the array <code>stdError</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getTs-QuantileSD'>Get <code>ts</code> from a quantile spectral density kernel</h2><span id='topic+getTs-QuantileSD'></span><span id='topic+getTs+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>Get <code>ts</code> from a quantile spectral density kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
getTs(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTs-QuantileSD_+3A_object">object</code></td>
<td>
<p><code>QuantileSD</code> of which to get the <code>ts</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>ts</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='getType-QuantileSD'>Get <code>type</code> from a quantile spectral density kernel</h2><span id='topic+getType-QuantileSD'></span><span id='topic+getType+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>Get <code>type</code> from a quantile spectral density kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
getType(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getType-QuantileSD_+3A_object">object</code></td>
<td>
<p><code>QuantileSD</code> of which to get the <code>type</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>type</code> that's a slot of
<code>object</code>.
</p>

<hr>
<h2 id='getValues-FreqRep'>Get values from a frequency representation.</h2><span id='topic+getValues-FreqRep'></span><span id='topic+getValues+2CFreqRep-method'></span>

<h3>Description</h3>

<p>For two vectors <code>frequencies</code> and <code>levels</code> the values from an
<code>object</code> of type <code>FreqRep</code> are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FreqRep'
getValues(
  object,
  frequencies = 2 * pi * (0:(lenTS(object@Y) - 1))/lenTS(object@Y),
  levels = object@levels,
  d = 1:(dim(object@values)[2])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-FreqRep_+3A_object">object</code></td>
<td>
<p><code>FreqRep</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getValues-FreqRep_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-FreqRep_+3A_levels">levels</code></td>
<td>
<p>a vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-FreqRep_+3A_d">d</code></td>
<td>
<p>optional parameter that determine of which component to return the data;
may be a vector of elements 1, ..., D</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two parameters <code>frequencies</code> and <code>levels</code> are expected to be
vectors of reals; an error is thrown otherwise. If any of the
<code>frequencies</code> or <code>levels</code> requested is not available from
<code>object</code> a warning is issued, and the values with frequencies and levels
closest to the ones requested are returned. Note that the frequencies are
transformed to <code class="reqn">[0,\pi]</code> using <code><a href="#topic+frequenciesValidator">frequenciesValidator</a></code>
when checking if they are available in <code>object</code>.
</p>
<p>The returned array of <code>values</code> is of dimension <code>[J,K,B+1]</code>,
where <code>J=length(frequencies)</code>, <code>K=length(levels)</code>, and <code>B</code>
denotes the value stored in slot <code>B</code> of <code>object</code>. At position
<code>(j,k,b)</code> the returned value is the one corresponding to
<code>frequencies[j]</code> and <code>levels[k]</code> that are closest to the
<code>frequencies</code> and <code>levels</code> available in <code>object</code>;
<code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine what closest to means.
</p>


<h3>Value</h3>

<p>Returns data from the array <code>values</code> that's a slot of
<code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y        &lt;- rnorm(32)
freq     &lt;- 2*pi*c(0:31)/32
levels   &lt;- c(0.25,0.5,0.75)
cFT      &lt;- clippedFT(Y, freq, levels)
V.all    &lt;- getValues(cFT)
V.coarse &lt;- getValues(cFT, frequencies = 2*pi*c(0:15)/16, levels = levels)
V.fine   &lt;- getValues(cFT, frequencies = 2*pi*c(0:63)/64, levels = levels)
V.part   &lt;- getValues(cFT, frequencies = 2*pi*c(0:16)/32, levels = c(0.25))
</code></pre>

<hr>
<h2 id='getValues-IntegrQuantileSD'>Get values from a simulated integrated quantile spectral density kernel</h2><span id='topic+getValues-IntegrQuantileSD'></span><span id='topic+getValues+2CIntegrQuantileSD-method'></span>

<h3>Description</h3>

<p>If none of the optional parameters is specified then the values are returned
for all Fourier frequencies in <code class="reqn">[0,2\pi)</code> (base given by slot
<code>N</code>) and all levels available. The frequencies and levels can be freely
specified. The returned array then has, at position <code>(j,k1,k2,b)</code>,
the value corresponding to the <code>frequencies[j]</code>,
<code>levels.1[k1]</code> and <code>levels.2[k2]</code> that are closest to the
<code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IntegrQuantileSD'
getValues(
  object,
  frequencies = 2 * pi * (0:(getN(object@qsd) - 1))/getN(object@qsd),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-IntegrQuantileSD_+3A_object">object</code></td>
<td>
<p><code>IntegrQuantileSD</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getValues-IntegrQuantileSD_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-IntegrQuantileSD_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-IntegrQuantileSD_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data from the array <code>values</code> that's a slot of
<code>object</code>.
</p>


<h3>See Also</h3>

<p>For examples on how to use this function go to <code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code>.
</p>

<hr>
<h2 id='getValues-KernelWeight'>Get values from a weight object determined by a kernel function <code>W</code> and
a bandwidth <code>b</code>.</h2><span id='topic+getValues-KernelWeight'></span><span id='topic+getValues+2CKernelWeight-method'></span>

<h3>Description</h3>

<p>For an <code>object</code> of type <code>KernelWeight</code> and an optional integer
<code>N</code> the weights <code class="reqn">W_n</code> are returned as a vector that has
<code class="reqn">W_n(2\pi(k-1)/n)</code> at position <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KernelWeight'
getValues(object, N = length(object@env$values))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-KernelWeight_+3A_object">object</code></td>
<td>
<p><code>KernelWeight</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getValues-KernelWeight_+3A_n">N</code></td>
<td>
<p>a <code>numeric</code> specifying the number of equaly spaced Fourier
frequencies from <code class="reqn">[0,2\pi)</code> for which the weight will
be computed; by default the number <code>N</code> specified on construction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of size <code>N</code> as described in the Details section.
</p>

<hr>
<h2 id='getValues-LagEstimator'>Get values from a lag-window type estimator.</h2><span id='topic+getValues-LagEstimator'></span><span id='topic+getValues+2CLagEstimator-method'></span>

<h3>Description</h3>

<p>The returned array of <code>values</code> is of dimension <code>[J,K1,K2]</code>,
where <code>J=length(frequencies)</code>, <code>K1=length(levels.1)</code> and
<code>K2=length(levels.2))</code>. At position <code>(j,k1,k2)</code>
the returned value is the one corresponding to <code>frequencies[j]</code>,
<code>levels.1[k1]</code> and <code>levels.2[k2]</code> that are closest to the
<code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagEstimator'
getValues(
  object,
  frequencies = 2 * pi * (0:(length(object@Y) - 1))/length(object@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-LagEstimator_+3A_object">object</code></td>
<td>
<p><code>LagEstimator</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getValues-LagEstimator_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-LagEstimator_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-LagEstimator_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data from the array <code>values</code> that's a slot of
<code>object</code>.
</p>


<h3>See Also</h3>

<p>An example on how to use this function is analogously to the example given in
<code><a href="#topic+getValues-QuantilePG">getValues-QuantilePG</a></code>.
</p>

<hr>
<h2 id='getValues-LagKernelWeight'>Get values from a weight object determined by a kernel function <code>W</code> and
a bandwidth <code>bw</code>.</h2><span id='topic+getValues-LagKernelWeight'></span><span id='topic+getValues+2CLagKernelWeight-method'></span>

<h3>Description</h3>

<p>For an <code>object</code> of type <code>LagKernelWeight</code> and an optional integer
<code>K</code> the weights <code class="reqn">W_k</code> are returned as a vector that has
<code class="reqn">W_k((k-1)/bw)</code> at position <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagKernelWeight'
getValues(object, K = length(object@env$values))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-LagKernelWeight_+3A_object">object</code></td>
<td>
<p><code>LagKernelWeight</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getValues-LagKernelWeight_+3A_k">K</code></td>
<td>
<p>a <code>numeric</code> that determines the largest lag. The weight will be
computed for the <code class="reqn">K</code> integers <code class="reqn">0:(K-1)</code>; by default the number
<code>K</code> specified on construction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of size <code>K</code> as described in the Details section.
</p>

<hr>
<h2 id='getValues-LagOperator'>Get attribute <code>values</code> from a <code>LagOperator</code>.</h2><span id='topic+getValues-LagOperator'></span><span id='topic+getValues+2CLagOperator-method'></span>

<h3>Description</h3>

<p>Get attribute <code>values</code> from a <code>LagOperator</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagOperator'
getValues(object, levels.1, levels.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-LagOperator_+3A_object">object</code></td>
<td>
<p><code>LagOperator</code> from which to get the <code>values</code>.</p>
</td></tr>
<tr><td><code id="getValues-LagOperator_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-LagOperator_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>values</code> attribute.
</p>

<hr>
<h2 id='getValues-QuantilePG'>Get values from a quantile periodogram.</h2><span id='topic+getValues-QuantilePG'></span><span id='topic+getValues+2CQuantilePG-method'></span>

<h3>Description</h3>

<p>For vectors <code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code> the
values from an <code>object</code> of type <code>QuantilePG</code> are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantilePG'
getValues(
  object,
  frequencies = 2 * pi * (0:(lenTS(object@freqRep@Y) - 1))/lenTS(object@freqRep@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@freqRep@Y)[2]),
  d2 = 1:(dim(object@freqRep@Y)[2])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-QuantilePG_+3A_object">object</code></td>
<td>
<p><code>QuantilePG</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getValues-QuantilePG_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-QuantilePG_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-QuantilePG_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-QuantilePG_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
data; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getValues-QuantilePG_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fetching of the periodogram values basically happens by passing
<code>frequencies</code> and the union of <code>levels.1</code> and <code>levels.2</code> to
<code><a href="#topic+getValues">getValues</a></code>. Therefore,
the parameters <code>frequencies</code>, <code>levels.1</code> and <code>levels.1</code> are
expected to be vectors of reals; an error is thrown otherwise. If any of the
<code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code> requested is not
available from <code>object</code> a warning is issued. Note that the frequencies
are transformed to <code class="reqn">[0,\pi]</code> using <code><a href="#topic+frequenciesValidator">frequenciesValidator</a></code>
when checking if they are available in <code>object</code>.
</p>
<p>The returned array of <code>values</code> is of dimension <code>[J,K1,K2,B+1]</code>,
where <code>J=length(frequencies)</code>, <code>K1=length(levels.1)</code>,
<code>K2=length(levels.2))</code>, and <code>B</code> denotes the
value stored in slot <code>B</code> of <code>freqRep</code> that's a slot of <code>object</code>.
At position <code>(j,k1,k2,b)</code>
the returned value is the one corresponding to <code>frequencies[j]</code>,
<code>levels.1[k1]</code> and <code>levels.2[k2]</code> that are closest to the
<code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means.
</p>


<h3>Value</h3>

<p>Returns data from the array <code>values</code> that's a slot of
<code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y        &lt;- rnorm(32)
freq     &lt;- 2*pi*c(0:31)/32
levels   &lt;- c(0.25,0.5,0.75)
qPG      &lt;- quantilePG(Y, levels.1=levels)
V.all    &lt;- getValues(qPG)
V.coarse &lt;- getValues(qPG, frequencies = 2*pi*c(0:15)/16)
V.fine   &lt;- getValues(qPG, frequencies = 2*pi*c(0:63)/64)
V.part   &lt;- getValues(qPG, frequencies = 2*pi*c(0:16)/32,
                           levels.1 = c(0.25), levels.2 = c(0.5,0.75))
</code></pre>

<hr>
<h2 id='getValues-QuantileSD'>Get values from a quantile spectral density kernel</h2><span id='topic+getValues-QuantileSD'></span><span id='topic+getValues+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>If none of the optional parameters is specified then the values are returned
for all Fourier frequencies in <code class="reqn">[0,2\pi)</code> (base given by slot
<code>N</code>) and all levels available. The frequencies and levels can be freely
specified. The returned array then has, at position <code>(j,k1,k2,b)</code>,
the value corresponding to the <code>frequencies[j]</code>,
<code>levels.1[k1]</code> and <code>levels.2[k2]</code> that are closest to the
<code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
getValues(
  object,
  frequencies = 2 * pi * (0:(object@N - 1))/object@N,
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@values)[2]),
  d2 = 1:(dim(object@values)[4])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-QuantileSD_+3A_object">object</code></td>
<td>
<p><code>QuantileSD</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getValues-QuantileSD_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-QuantileSD_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-QuantileSD_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-QuantileSD_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
data; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getValues-QuantileSD_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data from the array <code>values</code> that's a slot of
<code>object</code>.
</p>


<h3>See Also</h3>

<p>For examples on how to use this function go to <code><a href="#topic+QuantileSD">QuantileSD</a></code>.
</p>

<hr>
<h2 id='getValues-SmoothedPG'>Get values from a smoothed quantile periodogram.</h2><span id='topic+getValues-SmoothedPG'></span><span id='topic+getValues+2CSmoothedPG-method'></span>

<h3>Description</h3>

<p>The returned array of <code>values</code> is of dimension <code>[J,K1,K2,B+1]</code>,
where <code>J=length(frequencies)</code>, <code>K1=length(levels.1)</code>,
<code>K2=length(levels.2))</code>, and <code>B</code> denotes the
value stored in slot <code>B</code> of <code>freqRep</code> [that is the number of
boostrap repetitions performed on initialization].
At position <code>(j,k1,k2,b)</code>
the returned value is the one corresponding to <code>frequencies[j]</code>,
<code>levels.1[k1]</code> and <code>levels.2[k2]</code> that are closest to the
<code>frequencies</code>, <code>levels.1</code> and <code>levels.2</code>
available in <code>object</code>; <code><a href="#topic+closest.pos">closest.pos</a></code> is used to determine
what closest to means. <code>b==1</code> corresponds to the estimate without
bootstrapping; <code>b&gt;1</code> corresponds to the <code>b-1</code>st bootstrap estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothedPG'
getValues(
  object,
  frequencies = 2 * pi * (0:(lenTS(object@qPG@freqRep@Y) -
    1))/lenTS(object@qPG@freqRep@Y),
  levels.1 = getLevels(object, 1),
  levels.2 = getLevels(object, 2),
  d1 = 1:(dim(object@values)[2]),
  d2 = 1:(dim(object@values)[4])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-SmoothedPG_+3A_object">object</code></td>
<td>
<p><code>SmoothedPG</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getValues-SmoothedPG_+3A_frequencies">frequencies</code></td>
<td>
<p>a vector of frequencies for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-SmoothedPG_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-SmoothedPG_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to get the values</p>
</td></tr>
<tr><td><code id="getValues-SmoothedPG_+3A_d1">d1</code></td>
<td>
<p>optional parameter that determine for which j1 to return the
data; may be a vector of elements 1, ..., D</p>
</td></tr>
<tr><td><code id="getValues-SmoothedPG_+3A_d2">d2</code></td>
<td>
<p>same as d1, but for j2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If not only one, but multiple time series are under study, the dimension of
the returned vector is of dimension <code>[J,P,K1,P,K2,B+1]</code>, where <code>P</code>
denotes the dimension of the time series.
</p>


<h3>Value</h3>

<p>Returns data from the array <code>values</code> that's a slot of
<code>object</code>.
</p>


<h3>See Also</h3>

<p>An example on how to use this function is analogously to the example given in
<code><a href="#topic+getValues-QuantilePG">getValues-QuantilePG</a></code>.
</p>

<hr>
<h2 id='getValues-SpecDistrWeight'>Get values from a weight object of type <code><a href="#topic+SpecDistrWeight">SpecDistrWeight</a></code></h2><span id='topic+getValues-SpecDistrWeight'></span><span id='topic+getValues+2CSpecDistrWeight-method'></span>

<h3>Description</h3>

<p>For an <code>object</code> of type <code>SpecDistrWeight</code> and an optional integer
<code>N</code> the weights <code class="reqn">W_n</code> are returned as a vector that has
<code class="reqn">W_n(2\pi(k-1)/n)</code> at position <code>k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpecDistrWeight'
getValues(object, N = length(object@env$values))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues-SpecDistrWeight_+3A_object">object</code></td>
<td>
<p><code>SpecDistrWeight</code> of which to get the values</p>
</td></tr>
<tr><td><code id="getValues-SpecDistrWeight_+3A_n">N</code></td>
<td>
<p>a <code>numeric</code> specifying the number of equaly spaced Fourier
frequencies from <code class="reqn">[0,2\pi)</code> for which the weight will
be computed; by default the number <code>N</code> specified on construction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of size <code>N</code> as described in the Description
section.
</p>

<hr>
<h2 id='getW-KernelWeight'>Get attribute <code>W</code> (kernel used for smoothing) from a <code>KernelWeight</code>.</h2><span id='topic+getW-KernelWeight'></span><span id='topic+getW+2CKernelWeight-method'></span>

<h3>Description</h3>

<p>Get attribute <code>W</code> (kernel used for smoothing) from a <code>KernelWeight</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KernelWeight'
getW(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getW-KernelWeight_+3A_object">object</code></td>
<td>
<p><code>KernelWeight</code> from which to get the kernel <code>W</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>W</code> attribute.
</p>

<hr>
<h2 id='getW-LagKernelWeight'>Get attribute <code>W</code> (kernel used for smoothing) from a <code>LagKernelWeight</code>.</h2><span id='topic+getW-LagKernelWeight'></span><span id='topic+getW+2CLagKernelWeight-method'></span>

<h3>Description</h3>

<p>Get attribute <code>W</code> (kernel used for smoothing) from a <code>LagKernelWeight</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagKernelWeight'
getW(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getW-LagKernelWeight_+3A_object">object</code></td>
<td>
<p><code>LagKernelWeight</code> from which to get the kernel <code>W</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>W</code> attribute.
</p>

<hr>
<h2 id='getWeight-LagEstimator'>Get associated <code><a href="#topic+Weight">Weight</a></code> from a <code><a href="#topic+LagEstimator">LagEstimator</a></code>.</h2><span id='topic+getWeight-LagEstimator'></span><span id='topic+getWeight+2CLagEstimator-method'></span>

<h3>Description</h3>

<p>Get associated <code><a href="#topic+Weight">Weight</a></code> from a <code><a href="#topic+LagEstimator">LagEstimator</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagEstimator'
getWeight(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWeight-LagEstimator_+3A_object">object</code></td>
<td>
<p><code>LagEstimator</code> from which to get the <code>Weight</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+Weight">Weight</a></code> object associated.
</p>

<hr>
<h2 id='getWeight-SmoothedPG'>Get associated <code><a href="#topic+Weight">Weight</a></code> from a <code><a href="#topic+SmoothedPG">SmoothedPG</a></code>.</h2><span id='topic+getWeight-SmoothedPG'></span><span id='topic+getWeight+2CSmoothedPG-method'></span>

<h3>Description</h3>

<p>Get associated <code><a href="#topic+Weight">Weight</a></code> from a <code><a href="#topic+SmoothedPG">SmoothedPG</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothedPG'
getWeight(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWeight-SmoothedPG_+3A_object">object</code></td>
<td>
<p><code>SmoothedPG</code> from which to get the <code>Weight</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+Weight">Weight</a></code> object associated.
</p>

<hr>
<h2 id='getWnj-KernelWeight'>Get attribute <code>Wnj</code> from a <code>QSpecQuantity</code>.</h2><span id='topic+getWnj-KernelWeight'></span><span id='topic+getWnj+2CKernelWeight-method'></span>

<h3>Description</h3>

<p>If the optional parameter <code>j</code> is supplied, then only the <code>j</code>th
element(s) of the vector will be returned, the entire vector otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KernelWeight'
getWnj(object, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWnj-KernelWeight_+3A_object">object</code></td>
<td>
<p><code>KernelWeight</code> from which to get the <code>Wnj</code>.</p>
</td></tr>
<tr><td><code id="getWnj-KernelWeight_+3A_j">j</code></td>
<td>
<p>an integer or vector of indices specifying which <code>Wnj[j]</code>
to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns levels attribute, as a vector of real numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wgt &lt;- kernelWeight(W=W1, N=2^3, bw=0.7)
getWnj(wgt)
getWnj(wgt, 2)
getWnj(wgt, c(2,7))
</code></pre>

<hr>
<h2 id='getY-FreqRep'>Get <code>Y</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code> object.</h2><span id='topic+getY-FreqRep'></span><span id='topic+getY+2CFreqRep-method'></span>

<h3>Description</h3>

<p>Get <code>Y</code> from a <code><a href="#topic+FreqRep">FreqRep</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FreqRep'
getY(object, d = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getY-FreqRep_+3A_object">object</code></td>
<td>
<p><code>FreqRep</code> of which to get the <code>Y</code></p>
</td></tr>
<tr><td><code id="getY-FreqRep_+3A_d">d</code></td>
<td>
<p>optional parameter that determine which time series to return;
may be a vector of elements 1, ..., D</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the attribute <code>Y</code> that's a slot of <code>object</code>.
</p>

<hr>
<h2 id='increasePrecision-QuantileSD'>Increase the precision of a <code>QuantileSD</code></h2><span id='topic+increasePrecision-QuantileSD'></span><span id='topic+increasePrecision+2CQuantileSD-method'></span>

<h3>Description</h3>

<p>The precision is increased by generating an additional <code>R</code>
<code><a href="#topic+QuantilePG">QuantilePG</a></code> objects (independent of the previous ones) and
then including them in the average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD'
increasePrecision(object, R = 1, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="increasePrecision-QuantileSD_+3A_object">object</code></td>
<td>
<p>The <code><a href="#topic+QuantileSD">QuantileSD</a></code> of which to increase the precision.</p>
</td></tr>
<tr><td><code id="increasePrecision-QuantileSD_+3A_r">R</code></td>
<td>
<p>value of which to enlarge R</p>
</td></tr>
<tr><td><code id="increasePrecision-QuantileSD_+3A_quiet">quiet</code></td>
<td>
<p>Don't report progress to console when computing the <code>R</code>
independent quantile periodograms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+QuantileSD">QuantileSD</a></code> object determined from
<code>oldR + R</code> independent repetitions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# First simulate a copula spectral density from R=20 independent runs.
csd &lt;- quantileSD(N=2^9, ts=ts1, levels.1=c(0.25,0.5), type="copula", R=20)

# Check out the result:
getR(csd)
plot(csd)

# Now increase the number of independent simulation runs to 50.
csd &lt;- increasePrecision(csd, R=30)

# Check out the (more precise) result:
getR(csd)
plot(csd)

## End(Not run)
</code></pre>

<hr>
<h2 id='IntegrQuantileSD-class'>Class for a simulated integrated quantile (i. e., Laplace or copula)
density kernel.</h2><span id='topic+IntegrQuantileSD-class'></span><span id='topic+IntegrQuantileSD'></span>

<h3>Description</h3>

<p><code>IntegrQuantileSD</code> is an S4 class that implements the necessary
calculations to determine an integrated version of the quantile spectral
density kernel (computed via <code><a href="#topic+QuantileSD">QuantileSD</a></code>).
In particular it can be determined for any model from which a time series
of length <code>N</code> can be sampled via a function call <code>ts(N)</code>.
</p>


<h3>Details</h3>

<p>In the simulation the quantile spectral density is first determined via
<code><a href="#topic+QuantileSD">QuantileSD</a></code>, it's values are recovered using
<code><a href="#topic+getValues-QuantileSD">getValues-QuantileSD</a></code> and then cumulated using <code>cumsum</code>.
</p>
<p>Note that, all remarks made in the documentation of the super-class
<code><a href="#topic+QSpecQuantity">QSpecQuantity</a></code> apply.
</p>


<h3>Slots</h3>


<dl>
<dt><code>qsd</code></dt><dd><p>a <code><a href="#topic+QuantileSD">QuantileSD</a></code> from which to begin the computations.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>################################################################################
## This script illustrates how to estimate integrated quantile spectral densities

## Simulate a time series Y1,...,Y128 from the QAR(1) process discussed in
## Dette et. al (2015).
set.seed(2581)
Y &lt;- ts1(128)

## For a defined set of quantile levels ... 
levels &lt;- c(0.25,0.5,0.75)

## ... and a weight (of Type A), defined using the Epanechnikov kernel ...
wgt &lt;- specDistrWeight()

## ... compute a smoothed quantile periodogram (based on the clipped time series).
## Repeat the estimation 100 times, using the moving blocks bootstrap with
## block length l=32.
sPG.cl &lt;- smoothedPG(Y, levels.1 = levels, type="clipped", weight = wgt,
    type.boot = "mbb", B=100, l=32)

## Create a (model) spectral density kernel for he QAR(1) model for display
## in the next plot.
csd &lt;- quantileSD(N=2^8, seed.init = 2581, type = "copula",
    ts = ts1, levels.1=levels, R = 100)
icsd &lt;- integrQuantileSD(csd)

plot(sPG.cl, ptw.CIs = 0.1, qsd = icsd, type.CIs = "boot.full")

</code></pre>

<hr>
<h2 id='IntegrQuantileSD-constructor'>Create an instance of the <code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code> class.</h2><span id='topic+IntegrQuantileSD-constructor'></span><span id='topic+integrQuantileSD'></span>

<h3>Description</h3>

<p>Create an instance of the <code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrQuantileSD(
  object = 2^8,
  type = c("copula", "Laplace"),
  ts = rnorm,
  seed.init = 2581,
  levels.1 = 0.5,
  levels.2 = levels.1,
  R = 1,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntegrQuantileSD-constructor_+3A_object">object</code></td>
<td>
<p>the number <code>N</code> of Fourier frequencies to be used;
alternatively a  <code><a href="#topic+QuantileSD">QuantileSD</a></code> object can be supplied
(then all the other  parameters will be ignored)</p>
</td></tr>
<tr><td><code id="IntegrQuantileSD-constructor_+3A_type">type</code></td>
<td>
<p>can be either <code>"Laplace"</code> or <code>"copula"</code>; indicates
whether the marginals are to be assumed uniform <code class="reqn">[0,1]</code>
distributed.</p>
</td></tr>
<tr><td><code id="IntegrQuantileSD-constructor_+3A_ts">ts</code></td>
<td>
<p>a function that has one argument <code>n</code> and, each time it is
invoked, returns a new time series from the model for which the
integrated quantile spectral density kernel is to be simulated.</p>
</td></tr>
<tr><td><code id="IntegrQuantileSD-constructor_+3A_seed.init">seed.init</code></td>
<td>
<p>an integer serving as an initial seed for the simulations.</p>
</td></tr>
<tr><td><code id="IntegrQuantileSD-constructor_+3A_levels.1">levels.1</code></td>
<td>
<p>A vector of length <code>K1</code> containing the levels <code>x1</code>
at which the <code>QuantileSD</code> is to be determined.</p>
</td></tr>
<tr><td><code id="IntegrQuantileSD-constructor_+3A_levels.2">levels.2</code></td>
<td>
<p>A vector of length <code>K2</code> containing the levels <code>x2</code>
at which the <code>QuantileSD</code> is to be determined.</p>
</td></tr>
<tr><td><code id="IntegrQuantileSD-constructor_+3A_r">R</code></td>
<td>
<p>an integer that determines the number of independent simulations;
the larger this number the more precise is the result.</p>
</td></tr>
<tr><td><code id="IntegrQuantileSD-constructor_+3A_quiet">quiet</code></td>
<td>
<p>Don't report progress to console when computing the <code>R</code>
independent quantile periodograms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code>.
</p>


<h3>See Also</h3>

<p>For an example see <code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code>.
</p>

<hr>
<h2 id='is.wholenumber'>Checks whether <code>x</code> contains integer numbers.</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Borrowed from the example in <code><a href="base.html#topic+integer">integer</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>a vector to be checked for integers</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>an optional parameter specifying to which precision the check is
to be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of logicals with the same length as <code>x</code>; each
element <code>i</code> is <code>TRUE</code> iff <code>x[i]</code> is an integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
is.wholenumber(1) # is TRUE
(x &lt;- seq(1, 5, by = 0.5) )
is.wholenumber( x ) #--&gt;  TRUE FALSE TRUE ...

## End(Not run)
</code></pre>

<hr>
<h2 id='kernels'>Kernel function.</h2><span id='topic+kernels'></span><span id='topic+W0'></span><span id='topic+W1'></span><span id='topic+W2'></span><span id='topic+W3'></span><span id='topic+WDaniell'></span><span id='topic+WParzen'></span>

<h3>Description</h3>

<p>Implementations of kernel functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W0(x)

W1(x)

W2(x)

W3(x)

WDaniell(x, a = (pi/2))

WParzen(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernels_+3A_x">x</code></td>
<td>
<p>real-valued argument to the function; can be a vector</p>
</td></tr>
<tr><td><code id="kernels_+3A_a">a</code></td>
<td>
<p>real number between 0 and <code class="reqn">\pi</code></p>
</td></tr>
<tr><td><code id="kernels_+3A_u">u</code></td>
<td>
<p>real number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Daniell kernel function <code>W0</code>:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2\pi} I\{|x| \leq \pi\}.</code>
</p>

<p>Epanechnikov kernel <code>W1</code> (i. e., variance minimizing kernel function of order 2):
</p>
<p style="text-align: center;"><code class="reqn">\frac{3}{4\pi} (1-\frac{x}{\pi})^2 I\{|x| \leq \pi\}.</code>
</p>

<p>Variance minimizing kernel function <code>W2</code> of order 4:
</p>
<p style="text-align: center;"><code class="reqn">\frac{15}{32\pi} (7(x/\pi)^4 -10(x/\pi)^2+3) I\{|x| \leq \pi\}.</code>
</p>

<p>Variance minimizing kernel function <code>W3</code> of order 6:
</p>
<p style="text-align: center;"><code class="reqn">\frac{35}{256\pi} (-99(x/\pi)^6 + 189(x/\pi)^4 - 105(x/\pi)^2+15) I\{|x| \leq \pi\}.</code>
</p>

<p>Kernel yield by convolution of two Daniell kernels:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\pi+a} \Big(1-\frac{|x|-a}{\pi-a} I\{a \leq |x| \leq \pi\}\Big).</code>
</p>

<p>Parzen Window for lagEstimators
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(x=seq(-8,8,0.05), y=W0(seq(-8,8,0.05)), type="l")
plot(x=seq(-8,8,0.05), y=W1(seq(-8,8,0.05)), type="l")
plot(x=seq(-8,8,0.05), y=W2(seq(-8,8,0.05)), type="l")
plot(x=seq(-8,8,0.05), y=W3(seq(-8,8,0.05)), type="l")
plot(x=seq(-pi,pi,0.05), y=WDaniell(seq(-pi,pi,0.05),a=(pi/2)), type="l")
plot(x=seq(-2,2,0.05),y=WParzen(seq(-2,2,0.05)),type = "l")
</code></pre>

<hr>
<h2 id='KernelWeight-class'>Class for Brillinger-type Kernel weights.</h2><span id='topic+KernelWeight-class'></span><span id='topic+KernelWeight'></span>

<h3>Description</h3>

<p><code>KernelWeight</code> is an S4 class that implements a weighting function by
specification of a kernel function <code>W</code> and a scale parameter <code>bw</code>.
</p>


<h3>Details</h3>

<p>It extends the class <code><a href="#topic+Weight">Weight</a></code> and writes
</p>
<p style="text-align: center;"><code class="reqn">W_N(2\pi (k-1)/N) := \sum_{j \in Z} bw^{-1} W(2\pi bw^{-1} [(k-1)/N + j])</code>
</p>

<p>to <code>values[k]</code> [nested inside <code>env</code>] for <code>k=1,...,N</code>.
The number <code>length(values)</code> of Fourier frequencies for which
<code class="reqn">W_N</code> will be evaluated may be set on construction or updated when
evoking the method <code>getValues</code>.
To standardize the weights used in the convolution to unity
</p>
<p style="text-align: center;"><code class="reqn">W_N^j := \sum_{j \neq s = 0}^{N-1} W_n(2\pi s / N)</code>
</p>

<p>is stored to <code>Wnj[s]</code> for <code>s=1,...,N</code>, for later usage.
</p>


<h3>Slots</h3>


<dl>
<dt><code>W</code></dt><dd><p>a kernel function</p>
</dd>
<dt><code>bw</code></dt><dd><p>bandwidth</p>
</dd>
<dt><code>env</code></dt><dd><p>An environment to allow for slots which need to be
accessable in a call-by-reference manner:
</p>

<dl>
<dt><code>values</code></dt><dd><p>A vector storing the weights; see the Details
section.</p>
</dd>
<dt><code>Wnj</code></dt><dd><p>A vector storing the terms used for normalization;
see the Details section.</p>
</dd>
</dl>
</dd>
</dl>


<h3>References</h3>

<p>Brillinger, D. R. (1975). <em>Time Series: Data Analysis and Theory</em>.
Holt, Rinehart and Winston, Inc., New York. [cf. p. 146 f.]
</p>


<h3>See Also</h3>

<p>Examples for implementations of kernels <code>W</code> can be found at:
<code><a href="#topic+kernels">kernels</a></code>.
</p>

<hr>
<h2 id='KernelWeight-constructor'>Create an instance of the <code><a href="#topic+KernelWeight">KernelWeight</a></code> class.</h2><span id='topic+KernelWeight-constructor'></span><span id='topic+kernelWeight'></span>

<h3>Description</h3>

<p>Create an instance of the <code><a href="#topic+KernelWeight">KernelWeight</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelWeight(
  W = W0,
  N = 1,
  bw = 0.1 * N^(-1/5),
  descr = paste("bw=", round(bw, 3), ", N=", N, sep = "")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KernelWeight-constructor_+3A_w">W</code></td>
<td>
<p>A kernel function</p>
</td></tr>
<tr><td><code id="KernelWeight-constructor_+3A_n">N</code></td>
<td>
<p>Fourier basis; number of grid points in <code class="reqn">[0,2\pi)</code> for
which the weights will be computed.</p>
</td></tr>
<tr><td><code id="KernelWeight-constructor_+3A_bw">bw</code></td>
<td>
<p>bandwidth; if a vector, then a list of weights is returned</p>
</td></tr>
<tr><td><code id="KernelWeight-constructor_+3A_descr">descr</code></td>
<td>
<p>a description to be used in some plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code>KernelWeight</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernels">kernels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wgt1 &lt;- kernelWeight(W=W0, N=16, bw=c(0.1,0.3,0.7))
print(wgt1)
wgt2 &lt;- kernelWeight(W=W1, N=2^8, bw=0.1)
plot(wgt2, main="Weights determined from Epanechnikov kernel")
</code></pre>

<hr>
<h2 id='LagEstimator-class'>Class for a lag-window type estimator.</h2><span id='topic+LagEstimator-class'></span><span id='topic+LagEstimator'></span>

<h3>Description</h3>

<p>For a given time series Y a lag-window estimator of the Form
</p>
<p style="text-align: center;"><code class="reqn">\hat{f}(\omega) = \sum_{|k|&lt; n-1 } K_n(k) \Gamma(Y_0,Y_k) \exp(-i \omega k)</code>
</p>
 
<p>will be calculated on initalization. The <code>LagKernelWeight</code> K_n is determined
by the slot <code>weight</code> and the <code>LagOperator</code> <code class="reqn">\Gamma(Y_0,Y_k)</code> is defined 
by the slot lagOp.
</p>


<h3>Details</h3>

<p>Currently, the implementation of this class allows only for the analysis of
univariate time series.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Y</code></dt><dd><p>the time series where the lag estimator was applied one</p>
</dd>
<dt><code>weight</code></dt><dd><p>a <code><a href="#topic+Weight">Weight</a></code> object to be used as lag window</p>
</dd>
<dt><code>lagOp</code></dt><dd><p>a <code><a href="#topic+LagOperator">LagOperator</a></code> object that determines which
kind of bivariate structure should be calculated.</p>
</dd>
<dt><code>env</code></dt><dd><p>An environment to allow for slots which need to be
accessable in a call-by-reference manner:
</p>

<dl>
<dt><code>sdNaive</code></dt><dd><p>An array used for storage of the naively
estimated standard deviations of the smoothed periodogram.</p>
</dd>
<dt><code>sdNaive.done</code></dt><dd><p>a flag indicating whether <code>sdNaive</code>
has been set yet.</p>
</dd></dl>
</dd>
</dl>

<hr>
<h2 id='LagEstimator-constructor'>Create an instance of the <code>LagEstimator</code> class.</h2><span id='topic+LagEstimator-constructor'></span><span id='topic+lagEstimator'></span>

<h3>Description</h3>

<p>A <code>LagEstimator</code> object can be created from <code>numeric</code>, a <code>ts</code>,
or a <code>zoo</code> object. Also a <code><a href="#topic+LagOperator">LagOperator</a></code> and a 
<code><a href="#topic+Weight">Weight</a></code> object can be used to create different types of 
estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagEstimator(
  Y,
  frequencies = 2 * pi/length(Y) * 0:(length(Y) - 1),
  levels.1 = 0.5,
  levels.2 = levels.1,
  weight = lagKernelWeight(K = length(Y), bw = 100),
  type = c("clippedCov")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LagEstimator-constructor_+3A_y">Y</code></td>
<td>
<p>a time series (<code>numeric</code>, <code>ts</code>, or <code>zoo</code> object) or a 
<code><a href="#topic+LagOperator">LagOperator</a></code> from which to determine the <code>LagEstimator</code></p>
</td></tr>
<tr><td><code id="LagEstimator-constructor_+3A_frequencies">frequencies</code></td>
<td>
<p>A vector containing (Fourier-)frequencies at which to determine the
smoothed periodogram.</p>
</td></tr>
<tr><td><code id="LagEstimator-constructor_+3A_levels.1">levels.1</code></td>
<td>
<p>the first vector of levels for which to compute the LagEstimator</p>
</td></tr>
<tr><td><code id="LagEstimator-constructor_+3A_levels.2">levels.2</code></td>
<td>
<p>the second vector of levels for which to compute the LagEstimator</p>
</td></tr>
<tr><td><code id="LagEstimator-constructor_+3A_weight">weight</code></td>
<td>
<p>Object of type <code><a href="#topic+Weight">Weight</a></code> to be used for smoothing.</p>
</td></tr>
<tr><td><code id="LagEstimator-constructor_+3A_type">type</code></td>
<td>
<p>if <code>Y</code> is a time series, this indicates which LagOperator will be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code>LagEstimator</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rnorm(100)
levels.1 &lt;- c(0.1,0.5,0.9)
weight &lt;- lagKernelWeight(W = WParzen,  bw = 10, K = length(Y))
lagOp &lt;- clippedCov(Y,levels.1 = levels.1)
lagEst &lt;- lagEstimator(lagOp, weight = weight)
</code></pre>

<hr>
<h2 id='LagKernelWeight-class'>Class for lag window generators</h2><span id='topic+LagKernelWeight-class'></span><span id='topic+LagKernelWeight'></span>

<h3>Description</h3>

<p><code>LagKernelWeight</code> is an S4 class that implements a weighting function by
specification of a kernel function <code>W</code> and a scale parameter <code>bw</code>.
</p>


<h3>Details</h3>

<p>It extends the class <code><a href="#topic+Weight">Weight</a></code> and writes
</p>
<p style="text-align: center;"><code class="reqn">W_N(x[k]) := W(x[k]/bw)</code>
</p>

<p>to <code>values[k]</code> [nested inside <code>env</code>] for <code>k=1,...,length(x)</code>.
The points <code>x</code> where <code class="reqn">W</code> is evaluated may be set on construction or updated when
evoking the method <code>getValues</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>W</code></dt><dd><p>a kernel function</p>
</dd>
<dt><code>bw</code></dt><dd><p>bandwidth</p>
</dd>
<dt><code>env</code></dt><dd><p>An environment to allow for slots which need to be
accessable in a call-by-reference manner:
</p>

<dl>
<dt><code>values</code></dt><dd><p>A vector storing the weights; see the Details
section.</p>
</dd>
</dl>
</dd>
</dl>


<h3>See Also</h3>

<p>Examples for implementations of kernels <code>W</code> can be found at:
<code><a href="#topic+kernels">kernels</a></code>.
</p>

<hr>
<h2 id='LagKernelWeight-constructor'>Create an instance of the <code><a href="#topic+LagKernelWeight">LagKernelWeight</a></code> class.</h2><span id='topic+LagKernelWeight-constructor'></span><span id='topic+lagKernelWeight'></span>

<h3>Description</h3>

<p>Create an instance of the <code><a href="#topic+LagKernelWeight">LagKernelWeight</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagKernelWeight(
  W = WParzen,
  bw = K/2,
  K = 10,
  descr = paste("bw=", bw, ", K=", K, sep = "")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LagKernelWeight-constructor_+3A_w">W</code></td>
<td>
<p>A kernel function</p>
</td></tr>
<tr><td><code id="LagKernelWeight-constructor_+3A_bw">bw</code></td>
<td>
<p>bandwidth</p>
</td></tr>
<tr><td><code id="LagKernelWeight-constructor_+3A_k">K</code></td>
<td>
<p>a <code>numeric</code> that determines the largest lag. The weight will be
computed for the <code class="reqn">K</code> integers <code class="reqn">0:(K-1)</code>; by default the number
<code>K</code> specified on construction.</p>
</td></tr>
<tr><td><code id="LagKernelWeight-constructor_+3A_descr">descr</code></td>
<td>
<p>a description to be used in some plots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code>LagKernelWeight</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernels">kernels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wgt1 &lt;- lagKernelWeight(W=WParzen, K=20, bw=10)
print(wgt1)
</code></pre>

<hr>
<h2 id='LagOperator-class'>Interface Class to access different types of operators on time series.</h2><span id='topic+LagOperator-class'></span><span id='topic+LagOperator'></span>

<h3>Description</h3>

<p><code>LagOperator</code> is an S4 class that provides a common interface to
implementations of an operator <code class="reqn">\Gamma(Y)</code> which is calculated on 
all pairs of observations <code class="reqn">(Y_0,Y_k)</code> with lag smaller than maxLag
</p>


<h3>Details</h3>

<p>Currently one implementation is available:
(1) <code><a href="#topic+ClippedCov">ClippedCov</a></code>.
</p>
<p>Currently, the implementation of this class allows only for the analysis of
univariate time series.
</p>


<h3>Slots</h3>


<dl>
<dt><code>values</code></dt><dd><p>an array of dimension <code>c(maxLag,length(levels.1),length(levels.2))</code>
containing the values of the operator.</p>
</dd>
<dt><code>Y</code></dt><dd><p>is the time series the operator shall be applied to</p>
</dd>
<dt><code>maxLag</code></dt><dd><p>maximum lag between two observations</p>
</dd>
<dt><code>levels</code></dt><dd><p>a vector of numerics that determines the levels of the operator</p>
</dd>
<dt><code>isRankBased</code></dt><dd><p>A flag that is <code>FALSE</code> if the determined <code>values</code>
are based on the original time series and <code>TRUE</code> if it
is based on the ranks.</p>
</dd>
<dt><code>positions.boot</code></dt><dd><p>An object of type <code><a href="#topic+BootPos">BootPos</a></code>,
that is used to determine the block bootstrapped
replicates of the time series.</p>
</dd>
<dt><code>B</code></dt><dd><p>Number of bootstrap replications to perform.</p>
</dd>
</dl>

<hr>
<h2 id='lenTS'>Validates if <code>Y</code> is of an appropriate type for a time series and
returns the length of the time series.</h2><span id='topic+lenTS'></span>

<h3>Description</h3>

<p>Runs <code><a href="#topic+timeSeriesValidator">timeSeriesValidator</a></code> and returns the number of rows of the
returned matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lenTS(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lenTS_+3A_y">Y</code></td>
<td>
<p>the time series to be validated and of which the length is to
be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the length of the time series after validating it's valid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- lenTS(sp500)
Y &lt;- lenTS(wheatprices)
Y &lt;- lenTS(rnorm(10))
## Not run: Y &lt;- lenTS("Not a valid input")
</code></pre>

<hr>
<h2 id='MovingBlocks-class'>Class for Moving Blocks Bootstrap implementation.</h2><span id='topic+MovingBlocks-class'></span><span id='topic+MovingBlocks'></span>

<h3>Description</h3>

<p><code>MovingBlocks</code> is an S4 class that implements the moving blocks
bootstrap described in K\&quot;unsch (1989).
</p>


<h3>Details</h3>

<p><code>MovingBlocks</code> extends the S4 class
<code><a href="#topic+BootPos">BootPos</a></code> and the remarks made in its documentation
apply here as well.
</p>
<p>The Moving Blocks Bootstrap method of K\&quot;unsch (1989) resamples blocks
randomly, with replacement from the collection of overlapping blocks of
length <code>l</code> that start with observation 1, 2, ..., <code>N-l+1</code>.
A more precise description of the procedure can also be found in
Lahiri (1999), p. 389.
</p>


<h3>References</h3>

<p>K\&quot;unsch, H. R. (1989). The jackknife and the bootstrap for general stationary
observations. <em>The Annals of Statistics</em>, <b>17</b>, 1217&ndash;1261.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPositions-MovingBlocks">getPositions-MovingBlocks</a></code>
</p>

<hr>
<h2 id='MovingBlocks-constructor'>Create an instance of the <code><a href="#topic+MovingBlocks">MovingBlocks</a></code> class.</h2><span id='topic+MovingBlocks-constructor'></span><span id='topic+movingBlocks'></span>

<h3>Description</h3>

<p>Create an instance of the <code><a href="#topic+MovingBlocks">MovingBlocks</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movingBlocks(l, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MovingBlocks-constructor_+3A_l">l</code></td>
<td>
<p>the block length for the block bootstrap methods</p>
</td></tr>
<tr><td><code id="MovingBlocks-constructor_+3A_n">N</code></td>
<td>
<p>number of available observations to bootstrap from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code>MovingBlocks</code>.
</p>

<hr>
<h2 id='plot-FreqRep'>Plot the values of the <code><a href="#topic+FreqRep">FreqRep</a></code>.</h2><span id='topic+plot-FreqRep'></span><span id='topic+plot+2CFreqRep+2CANY-method'></span>

<h3>Description</h3>

<p>Creates a <code>K</code> x <code>2</code> plot depicting a
<code><a href="#topic+FreqRep">FreqRep</a></code> object.
Each of the <code>K</code> &ldquo;lines&rdquo; of subplots shows the frequency representation
for one value of <code class="reqn">\tau</code>. The real and imaginary part are shown on
the left and the right, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FreqRep,ANY'
plot(
  x,
  ratio = 2,
  frequencies = 2 * pi * (1:(floor(lenTS(x@Y)/2)))/lenTS(x@Y),
  levels = x@levels,
  d = 1:(dim(x@Y)[2])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-FreqRep_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+FreqRep">FreqRep</a></code> to plot.</p>
</td></tr>
<tr><td><code id="plot-FreqRep_+3A_ratio">ratio</code></td>
<td>
<p>quotient of width over height of the subplots; use this
parameter to produce landscape or portrait shaped plots.</p>
</td></tr>
<tr><td><code id="plot-FreqRep_+3A_frequencies">frequencies</code></td>
<td>
<p>a set of frequencies for which the values are to be
plotted.</p>
</td></tr>
<tr><td><code id="plot-FreqRep_+3A_levels">levels</code></td>
<td>
<p>a set of levels for which the values are to be plotted.</p>
</td></tr>
<tr><td><code id="plot-FreqRep_+3A_d">d</code></td>
<td>
<p>vector indicating which components of a multivariate time series
should be in the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots the <code><a href="#topic+FreqRep">FreqRep</a></code> for all
<code>frequencies</code> and <code>levels</code> specified.
</p>

<hr>
<h2 id='plot-IntegrQuantileSD'>Plot the values of the <code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code>.</h2><span id='topic+plot-IntegrQuantileSD'></span><span id='topic+plot+2CIntegrQuantileSD+2CANY-method'></span>

<h3>Description</h3>

<p>Creates a <code>K</code> x <code>K</code> plot depicting an integrated quantile spectral
density.
In each of the subplots either the real part (on and below the diagonal;
i. e., <code class="reqn">\tau_1 \leq \tau_2</code>) or the imaginary part
(above the diagonal; i. e., <code class="reqn">\tau_1 &gt; \tau_2</code>) of
</p>

<ul>
<li><p> the integrated quantile spectral density (black line),
</p>
</li></ul>

<p>for the combination of levels <code class="reqn">\tau_1</code> and <code class="reqn">\tau_2</code>
denoted on the left and bottom margin of the plot are displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IntegrQuantileSD,ANY'
plot(
  x,
  ratio = 3/2,
  widthlab = lcm(1),
  xlab = expression(omega/2 * pi),
  ylab = NULL,
  frequencies = 2 * pi * (1:(floor(getN(getQuantileSD(x))/2)))/getN(getQuantileSD(x)),
  levels = getLevels(x, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-IntegrQuantileSD_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code> to plot</p>
</td></tr>
<tr><td><code id="plot-IntegrQuantileSD_+3A_ratio">ratio</code></td>
<td>
<p>quotient of width over height of the subplots; use this
parameter to produce landscape or portrait shaped plots.</p>
</td></tr>
<tr><td><code id="plot-IntegrQuantileSD_+3A_widthlab">widthlab</code></td>
<td>
<p>width for the labels (left and bottom); default is
<code>lcm(1)</code>, cf. <code><a href="graphics.html#topic+layout">layout</a></code>.</p>
</td></tr>
<tr><td><code id="plot-IntegrQuantileSD_+3A_xlab">xlab</code></td>
<td>
<p>label that will be shown on the bottom of the plots; can be
an expression (for formulas), characters or <code>NULL</code> to
force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-IntegrQuantileSD_+3A_ylab">ylab</code></td>
<td>
<p>label that will be shown on the left side of the plots;
can be an expression (for formulas), characters or
<code>NULL</code> to force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-IntegrQuantileSD_+3A_frequencies">frequencies</code></td>
<td>
<p>a set of frequencies for which the values are to be
plotted.</p>
</td></tr>
<tr><td><code id="plot-IntegrQuantileSD_+3A_levels">levels</code></td>
<td>
<p>a set of levels for which the values are to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots the simulated integrated quantile spectral density for all
<code>frequencies</code> and <code>levels</code> specified.
</p>

<hr>
<h2 id='plot-KernelWeight'>Plot the values of the <code><a href="#topic+KernelWeight">KernelWeight</a></code>.</h2><span id='topic+plot-KernelWeight'></span><span id='topic+plot+2CKernelWeight+2Cmissing-method'></span>

<h3>Description</h3>

<p>Creates a plot visualizing the weights <code class="reqn">W_n(\omega)</code>
[cf. <code><a href="#topic+KernelWeight-class">KernelWeight-class</a></code>] that are used to estimate the
quantile spectral density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'KernelWeight,missing'
plot(
  x,
  y,
  ylab = expression(W[n](omega)),
  xlab = expression(omega),
  main = x@descr,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-KernelWeight_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+KernelWeight">KernelWeight</a></code> to plot.</p>
</td></tr>
<tr><td><code id="plot-KernelWeight_+3A_y">y</code></td>
<td>
<p>missing arg from the generic; will be ignored.</p>
</td></tr>
<tr><td><code id="plot-KernelWeight_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis; optional</p>
</td></tr>
<tr><td><code id="plot-KernelWeight_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis; optional</p>
</td></tr>
<tr><td><code id="plot-KernelWeight_+3A_main">main</code></td>
<td>
<p>titel (on top) of the plot; optional</p>
</td></tr>
<tr><td><code id="plot-KernelWeight_+3A_...">...</code></td>
<td>
<p>optional parameters used for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the plot the values at the frequencies
<code class="reqn">2\pi j / N</code>, <code class="reqn">j=L+1-N,\ldots,L</code>, <code class="reqn">L:=\lfloor N/2 \rfloor</code> are
shown, where <code class="reqn">N</code> is the parameter specified on construction of the object
or <code class="reqn">N := 3</code>, if that parameter was smaller than three. A warning is given
in the later case.
</p>


<h3>Value</h3>

<p>Plots the <code><a href="#topic+KernelWeight">KernelWeight</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(kernelWeight(W1, bw=0.3),
       ylab=expression(W[n](x)),
       xlab=expression(x),
       main="Weights to an Epanechnikov kernel", sub="bw=0.3")
</code></pre>

<hr>
<h2 id='plot-LagEstimator'>Plot the values of a <code><a href="#topic+LagEstimator">LagEstimator</a></code>.</h2><span id='topic+plot-LagEstimator'></span><span id='topic+plot+2CLagEstimator+2CANY-method'></span>

<h3>Description</h3>

<p>Creates a <code>K</code> x <code>K</code> plot displaying all levels combinations from the
argument <code>levels</code>.  
In each of the subplots either the real part (on and below the diagonal;
i. e., <code class="reqn">\tau_1 \leq \tau_2</code>) or the imaginary parts
(above the diagonal; i. e., <code class="reqn">\tau_1 &gt; \tau_2</code>) of
the lag-window estimator, for the combination of levels <code class="reqn">\tau_1</code>
and <code class="reqn">\tau_2</code> denoted on the left and bottom margin of the plot are displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagEstimator,ANY'
plot(
  x,
  ptw.CIs = 0.1,
  ratio = 3/2,
  widthlab = lcm(1),
  xlab = expression(omega/2 * pi),
  ylab = NULL,
  type.scaling = c("individual", "real-imaginary", "all"),
  frequencies = x@frequencies,
  type.CIs = c("naive.sd"),
  levels = intersect(x@levels[[1]], x@levels[[2]])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-LagEstimator_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+LagEstimator">LagEstimator</a></code> object to plot</p>
</td></tr>
<tr><td><code id="plot-LagEstimator_+3A_ptw.cis">ptw.CIs</code></td>
<td>
<p>the confidence level for the confidence intervals to be
displayed; must be a number from [0,1]; if null, then no
confidence intervals will be plotted.</p>
</td></tr>
<tr><td><code id="plot-LagEstimator_+3A_ratio">ratio</code></td>
<td>
<p>quotient of width over height of the subplots; use this
parameter to produce landscape or portrait shaped plots.</p>
</td></tr>
<tr><td><code id="plot-LagEstimator_+3A_widthlab">widthlab</code></td>
<td>
<p>width for the labels (left and bottom); default is
<code>lcm(1)</code>, cf. <code><a href="graphics.html#topic+layout">layout</a></code>.</p>
</td></tr>
<tr><td><code id="plot-LagEstimator_+3A_xlab">xlab</code></td>
<td>
<p>label that will be shown on the bottom of the plots; can be
an expression (for formulas), characters or <code>NULL</code> to
force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-LagEstimator_+3A_ylab">ylab</code></td>
<td>
<p>label that will be shown on the left side of the plots;
can be an expression (for formulas), characters or
<code>NULL</code> to force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-LagEstimator_+3A_type.scaling">type.scaling</code></td>
<td>
<p>a method for scaling of the subplots; currently there
are three options: <code>"individual"</code> will scale each of the
<code>K^2</code> subplots to minimum and maximum of the values
in that plot, <code>"real-imaginary"</code> will scale each of the
subplots displaying real parts and each of the subplots
displaying imaginary parts to the minimum and maximum of
the values display in these subportion of plots. The
option <code>"all"</code> will scale the subplots to the minimum and
maximum in all of the subplots.</p>
</td></tr>
<tr><td><code id="plot-LagEstimator_+3A_frequencies">frequencies</code></td>
<td>
<p>a set of frequencies for which the values are to be
plotted.</p>
</td></tr>
<tr><td><code id="plot-LagEstimator_+3A_type.cis">type.CIs</code></td>
<td>
<p>indicates the method to be used for determining the
confidence intervals; the methods available are those
provided by
<code><a href="#topic+getPointwiseCIs-LagEstimator">getPointwiseCIs-LagEstimator</a></code>.</p>
</td></tr>
<tr><td><code id="plot-LagEstimator_+3A_levels">levels</code></td>
<td>
<p>a set of levels for which the values are to be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the plot described in the Description section.
</p>
<p>See Birr et al. (2015)
</p>


<h3>References</h3>

<p>Birr, S., Volgushev, S., Kley, T., Dette, H. &amp; Hallin, M. (2015).
Quantile Spectral Analysis for Locally Stationary Time Series.
<a href="http://arxiv.org/abs/1404.4605">http://arxiv.org/abs/1404.4605</a>.
</p>

<hr>
<h2 id='plot-LagKernelWeight'>Plot the values of the <code><a href="#topic+LagKernelWeight">LagKernelWeight</a></code>.</h2><span id='topic+plot-LagKernelWeight'></span><span id='topic+plot+2CLagKernelWeight+2Cmissing-method'></span>

<h3>Description</h3>

<p>Creates a plot visualizing the weights <code class="reqn">W_n(k</code>
[cf. <code><a href="#topic+LagKernelWeight-class">LagKernelWeight-class</a></code>] that are used to estimate the
quantile spectral density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagKernelWeight,missing'
plot(
  x,
  y,
  ylab = expression(W[n](k)),
  xlab = expression(k),
  main = x@descr,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-LagKernelWeight_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+LagKernelWeight">LagKernelWeight</a></code> to plot.</p>
</td></tr>
<tr><td><code id="plot-LagKernelWeight_+3A_y">y</code></td>
<td>
<p>missing arg from the generic; will be ignored.</p>
</td></tr>
<tr><td><code id="plot-LagKernelWeight_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis; optional</p>
</td></tr>
<tr><td><code id="plot-LagKernelWeight_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis; optional</p>
</td></tr>
<tr><td><code id="plot-LagKernelWeight_+3A_main">main</code></td>
<td>
<p>titel (on top) of the plot; optional</p>
</td></tr>
<tr><td><code id="plot-LagKernelWeight_+3A_...">...</code></td>
<td>
<p>optional parameters used for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the plot the values at the points <code class="reqn">k/bw</code> with 
<code class="reqn">k \in \{-K,\dots,K\}</code> are shown.
</p>


<h3>Value</h3>

<p>Plots the <code><a href="#topic+LagKernelWeight">LagKernelWeight</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(lagKernelWeight(WParzen, bw=10, K = 20),
       ylab=expression(W[n](x)),
       xlab=expression(x),
       main="Weights to the Parzen Window")
</code></pre>

<hr>
<h2 id='plot-LagOperator'>Plot the values of the <code><a href="#topic+LagOperator">LagOperator</a></code>.</h2><span id='topic+plot-LagOperator'></span><span id='topic+plot+2CLagOperator+2CANY-method'></span>

<h3>Description</h3>

<p>Creates a <code>K</code> x <code>K</code> plot (where <code>K</code> is the length of the <code>levels</code> parameter)
showing the values of the <code><a href="#topic+LagOperator">LagOperator</a></code>. The plots below the diagonal show the positive
Lags and the plots above display the negative ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'LagOperator,ANY'
plot(
  x,
  levels = intersect(x@levels.1, x@levels.2),
  maxLag = maxLag,
  widthlab = lcm(1),
  ratio = 3/2,
  xlab = expression(omega/2 * pi),
  ylab = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-LagOperator_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+LagOperator">LagOperator</a></code> to plot.</p>
</td></tr>
<tr><td><code id="plot-LagOperator_+3A_levels">levels</code></td>
<td>
<p>a set of levels for which the values are to be plotted.</p>
</td></tr>
<tr><td><code id="plot-LagOperator_+3A_maxlag">maxLag</code></td>
<td>
<p>maximum Lag that should be displayed. It defaults to the
maximum number of Lags available but usually a smaller number
yields a more informative result.</p>
</td></tr>
<tr><td><code id="plot-LagOperator_+3A_widthlab">widthlab</code></td>
<td>
<p>width for the labels (left and bottom); default is
<code>lcm(1)</code>, cf. <code><a href="graphics.html#topic+layout">layout</a></code>.</p>
</td></tr>
<tr><td><code id="plot-LagOperator_+3A_ratio">ratio</code></td>
<td>
<p>quotient of width over height of the subplots; use this
parameter to produce landscape or portrait shaped plots.</p>
</td></tr>
<tr><td><code id="plot-LagOperator_+3A_xlab">xlab</code></td>
<td>
<p>label that will be shown on the bottom of the plots; can be
an expression (for formulas), characters or <code>NULL</code> to
force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-LagOperator_+3A_ylab">ylab</code></td>
<td>
<p>label that will be shown on the left side of the plots;
can be an expression (for formulas), characters or
<code>NULL</code> to force omission (to save space).</p>
</td></tr>
</table>

<hr>
<h2 id='plot-QuantilePG'>Plot the values of the <code><a href="#topic+QuantilePG">QuantilePG</a></code>.</h2><span id='topic+plot-QuantilePG'></span><span id='topic+plot+2CQuantilePG+2CANY-method'></span>

<h3>Description</h3>

<p>Creates a <code>K</code> x <code>K</code> plot depicting a quantile periodogram.
Optionally, a simulated copula spectral density can
be displayed.
In each of the subplots either the real part (on and below the diagonal;
i. e., <code class="reqn">\tau_1 \leq \tau_2</code>) or the imaginary parts
(above the diagonal; i. e., <code class="reqn">\tau_1 &gt; \tau_2</code>) of
</p>

<ul>
<li><p> the quantile periodogram (black line),
</p>
</li>
<li><p> a simulated quantile spectral density (red line),
</p>
</li></ul>

<p>for the combination of levels <code class="reqn">\tau_1</code> and <code class="reqn">\tau_2</code>
denoted on the left and bottom margin of the plot are displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantilePG,ANY'
plot(
  x,
  qsd,
  ratio = 3/2,
  widthlab = lcm(1),
  xlab = expression(omega/2 * pi),
  ylab = NULL,
  type.scaling = c("individual", "real-imaginary", "all"),
  frequencies = x@frequencies[-which(x@frequencies == 0)],
  levels = intersect(x@levels[[1]], x@levels[[2]])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-QuantilePG_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+QuantilePG">QuantilePG</a></code> object to plot</p>
</td></tr>
<tr><td><code id="plot-QuantilePG_+3A_qsd">qsd</code></td>
<td>
<p>a <code><a href="#topic+QuantileSD">QuantileSD</a></code> object; will be plotted if not
missing.</p>
</td></tr>
<tr><td><code id="plot-QuantilePG_+3A_ratio">ratio</code></td>
<td>
<p>quotient of width over height of the subplots; use this
parameter to produce landscape or portrait shaped plots.</p>
</td></tr>
<tr><td><code id="plot-QuantilePG_+3A_widthlab">widthlab</code></td>
<td>
<p>width for the labels (left and bottom); default is
<code>lcm(1)</code>, cf. <code><a href="graphics.html#topic+layout">layout</a></code>.</p>
</td></tr>
<tr><td><code id="plot-QuantilePG_+3A_xlab">xlab</code></td>
<td>
<p>label that will be shown on the bottom of the plots; can be
an expression (for formulas), characters or <code>NULL</code> to
force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-QuantilePG_+3A_ylab">ylab</code></td>
<td>
<p>label that will be shown on the left side of the plots;
can be an expression (for formulas), characters or
<code>NULL</code> to force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-QuantilePG_+3A_type.scaling">type.scaling</code></td>
<td>
<p>a method for scaling of the subplots; currently there
are three options: <code>"individual"</code> will scale each of the
<code>K^2</code> subplots to minimum and maximum of the values
in that plot, <code>"real-imaginary"</code> will scale each of the
subplots displaying real parts and each of the subplots
displaying imaginary parts to the minimum and maximum of
the values display in these subportion of plots. The
option <code>"all"</code> will scale the subplots to the minimum and
maximum in all of the subplots.</p>
</td></tr>
<tr><td><code id="plot-QuantilePG_+3A_frequencies">frequencies</code></td>
<td>
<p>a set of frequencies for which the values are to be
plotted; default is all available frequencies but 0; if 0 is the
only available frequency, then only 0 will be used.</p>
</td></tr>
<tr><td><code id="plot-QuantilePG_+3A_levels">levels</code></td>
<td>
<p>a set of levels for which the values are to be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only the plot for the first component is shown.
</p>


<h3>Value</h3>

<p>Returns the plot described in the Description section.
</p>

<hr>
<h2 id='plot-QuantileSD'>Plot the values of the <code><a href="#topic+QuantileSD">QuantileSD</a></code>.</h2><span id='topic+plot-QuantileSD'></span><span id='topic+plot+2CQuantileSD+2CANY-method'></span>

<h3>Description</h3>

<p>Creates a <code>K</code> x <code>K</code> plot depicting a quantile spectral density.
In each of the subplots either the real part (on and below the diagonal;
i. e., <code class="reqn">\tau_1 \leq \tau_2</code>) or the imaginary parts
(above the diagonal; i. e., <code class="reqn">\tau_1 &gt; \tau_2</code>) of
</p>

<ul>
<li><p> the quantile spectral density (red line),
</p>
</li>
<li><p> the means of the quantile periodograms used in the simulation
(black line),
</p>
</li></ul>

<p>for the combination of levels <code class="reqn">\tau_1</code> and <code class="reqn">\tau_2</code>
denoted on the left and bottom margin of the plot are displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'QuantileSD,ANY'
plot(
  x,
  ratio = 3/2,
  widthlab = lcm(1),
  xlab = expression(omega/2 * pi),
  ylab = NULL,
  frequencies = 2 * pi * (1:(floor(x@N/2)))/x@N,
  levels = getLevels(x, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-QuantileSD_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+QuantileSD">QuantileSD</a></code> to plot</p>
</td></tr>
<tr><td><code id="plot-QuantileSD_+3A_ratio">ratio</code></td>
<td>
<p>quotient of width over height of the subplots; use this
parameter to produce landscape or portrait shaped plots.</p>
</td></tr>
<tr><td><code id="plot-QuantileSD_+3A_widthlab">widthlab</code></td>
<td>
<p>width for the labels (left and bottom); default is
<code>lcm(1)</code>, cf. <code><a href="graphics.html#topic+layout">layout</a></code>.</p>
</td></tr>
<tr><td><code id="plot-QuantileSD_+3A_xlab">xlab</code></td>
<td>
<p>label that will be shown on the bottom of the plots; can be
an expression (for formulas), characters or <code>NULL</code> to
force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-QuantileSD_+3A_ylab">ylab</code></td>
<td>
<p>label that will be shown on the left side of the plots;
can be an expression (for formulas), characters or
<code>NULL</code> to force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-QuantileSD_+3A_frequencies">frequencies</code></td>
<td>
<p>a set of frequencies for which the values are to be
plotted.</p>
</td></tr>
<tr><td><code id="plot-QuantileSD_+3A_levels">levels</code></td>
<td>
<p>a set of levels for which the values are to be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only the plot for the first component is shown.
</p>


<h3>Value</h3>

<p>Plots the simulated quantile spectral density for all
<code>frequencies</code> and <code>levels</code> specified.
</p>

<hr>
<h2 id='plot-SmoothedPG'>Plot the values of a <code><a href="#topic+SmoothedPG">SmoothedPG</a></code>.</h2><span id='topic+plot-SmoothedPG'></span><span id='topic+plot+2CSmoothedPG+2CANY-method'></span>

<h3>Description</h3>

<p>Creates a <code>K</code> x <code>K</code> plot depicting a smoothed quantile periodogram.
Optionally, the quantile periodogram on which the smoothing was performed,
a simulated quantile spectral density, and pointwise confidence intervals can
be displayed.
In each of the subplots either the real part (on and below the diagonal;
i. e., <code class="reqn">\tau_1 \leq \tau_2</code>) or the imaginary parts
(above the diagonal; i. e., <code class="reqn">\tau_1 &gt; \tau_2</code>) of
</p>

<ul>
<li><p> the smoothed quantile periodogram (blue line),
</p>
</li>
<li><p> the quanitle peridogram that was used for smoothing (gray line),
</p>
</li>
<li><p> a simulated quantile spectral density (red line),
</p>
</li>
<li><p> pointwise (asymptotic) confidence intervals (light gray area),
</p>
</li></ul>

<p>for the combination of levels <code class="reqn">\tau_1</code> and <code class="reqn">\tau_2</code>
denoted on the left and bottom margin of the plot are displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SmoothedPG,ANY'
plot(
  x,
  plotPG = FALSE,
  qsd,
  ptw.CIs = 0.1,
  type.CIs = c("naive.sd", "boot.sd", "boot.full"),
  ratio = 3/2,
  widthlab = lcm(1),
  xlab = expression(omega/2 * pi),
  ylab = NULL,
  type.scaling = c("individual", "real-imaginary", "all"),
  frequencies = x@frequencies,
  levels = intersect(x@levels[[1]], x@levels[[2]])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-SmoothedPG_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+SmoothedPG">SmoothedPG</a></code> object to plot</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_plotpg">plotPG</code></td>
<td>
<p>a flag indicating weater the <code>QuantilePG</code> object
associated with the <code><a href="#topic+SmoothedPG">SmoothedPG</a></code> <code>x</code>
is also to be plotted.</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_qsd">qsd</code></td>
<td>
<p>a <code><a href="#topic+QuantileSD">QuantileSD</a></code> object; will be plotted if not
missing.</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_ptw.cis">ptw.CIs</code></td>
<td>
<p>the confidence level for the confidence intervals to be
displayed; must be a number from [0,1]; if null, then no
confidence intervals will be plotted.</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_type.cis">type.CIs</code></td>
<td>
<p>indicates the method to be used for determining the
confidence intervals; the methods available are those
provided by
<code><a href="#topic+getPointwiseCIs-SmoothedPG">getPointwiseCIs-SmoothedPG</a></code>.</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_ratio">ratio</code></td>
<td>
<p>quotient of width over height of the subplots; use this
parameter to produce landscape or portrait shaped plots.</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_widthlab">widthlab</code></td>
<td>
<p>width for the labels (left and bottom); default is
<code>lcm(1)</code>, cf. <code><a href="graphics.html#topic+layout">layout</a></code>.</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_xlab">xlab</code></td>
<td>
<p>label that will be shown on the bottom of the plots; can be
an expression (for formulas), characters or <code>NULL</code> to
force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_ylab">ylab</code></td>
<td>
<p>label that will be shown on the left side of the plots;
can be an expression (for formulas), characters or
<code>NULL</code> to force omission (to save space).</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_type.scaling">type.scaling</code></td>
<td>
<p>a method for scaling of the subplots; currently there
are three options: <code>"individual"</code> will scale each of the
<code>K^2</code> subplots to minimum and maximum of the values
in that plot, <code>"real-imaginary"</code> will scale each of the
subplots displaying real parts and each of the subplots
displaying imaginary parts to the minimum and maximum of
the values display in these subportion of plots. The
option <code>"all"</code> will scale the subplots to the minimum and
maximum in all of the subplots.</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_frequencies">frequencies</code></td>
<td>
<p>a set of frequencies for which the values are to be
plotted.</p>
</td></tr>
<tr><td><code id="plot-SmoothedPG_+3A_levels">levels</code></td>
<td>
<p>a set of levels for which the values are to be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only the plot for the first component is shown.
</p>


<h3>Value</h3>

<p>Returns the plot described in the Description section.
</p>

<hr>
<h2 id='plot-SpecDistrWeight'>Plot the values of the <code><a href="#topic+SpecDistrWeight">SpecDistrWeight</a></code>.</h2><span id='topic+plot-SpecDistrWeight'></span><span id='topic+plot+2CSpecDistrWeight+2Cmissing-method'></span>

<h3>Description</h3>

<p>Creates a plot visualizing the weights <code class="reqn">W_n(\omega)</code>
[cf. <code><a href="#topic+SpecDistrWeight-class">SpecDistrWeight-class</a></code>] that are used to estimate the
integrated quantile spectral density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpecDistrWeight,missing'
plot(
  x,
  y,
  ylab = expression(W[n](omega)),
  xlab = expression(omega),
  main = x@descr,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-SpecDistrWeight_+3A_x">x</code></td>
<td>
<p>The <code><a href="#topic+SpecDistrWeight">SpecDistrWeight</a></code> to plot.</p>
</td></tr>
<tr><td><code id="plot-SpecDistrWeight_+3A_y">y</code></td>
<td>
<p>missing arg from the generic; will be ignored.</p>
</td></tr>
<tr><td><code id="plot-SpecDistrWeight_+3A_ylab">ylab</code></td>
<td>
<p>label for the y-axis; optional</p>
</td></tr>
<tr><td><code id="plot-SpecDistrWeight_+3A_xlab">xlab</code></td>
<td>
<p>label for the x-axis; optional</p>
</td></tr>
<tr><td><code id="plot-SpecDistrWeight_+3A_main">main</code></td>
<td>
<p>titel (on top) of the plot; optional</p>
</td></tr>
<tr><td><code id="plot-SpecDistrWeight_+3A_...">...</code></td>
<td>
<p>optional parameters used for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the plot the values at the frequencies
<code class="reqn">2\pi j / 128</code>, <code class="reqn">j=-63,\ldots,64</code> are shown.
</p>


<h3>Value</h3>

<p>Plots the <code><a href="#topic+SpecDistrWeight">SpecDistrWeight</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(specDistrWeight(),
       ylab=expression(W[n](x)),
       xlab=expression(x))
</code></pre>

<hr>
<h2 id='QRegEstimator-class'>Class for quantile regression-based estimates in the harmonic linear model.</h2><span id='topic+QRegEstimator-class'></span><span id='topic+QRegEstimator'></span>

<h3>Description</h3>

<p><code>QRegEstimator</code> is an S4 class that implements the necessary
calculations to determine the frequency representation based on the weigthed
<code class="reqn">L_1</code>-projection of a time series as described in
Dette et. al (2015). As a subclass to <code><a href="#topic+FreqRep">FreqRep</a></code>
it inherits slots and methods defined there.
</p>


<h3>Details</h3>

<p>For each frequency <code class="reqn">\omega</code> from <code>frequencies</code> and level
<code class="reqn">\tau</code> from <code>levels</code> the statistic
</p>
<p style="text-align: center;"><code class="reqn">\hat b^{\tau}_n(\omega) := \arg\max_{a \in R, b \in C}
      \sum_{t=0}^{n-1}
      \rho_{\tau}(Y_t - a - Re(b) \cos(\omega t) - Im(b) \sin(\omega t)),</code>
</p>

<p>is determined and stored to the array <code>values</code>.
</p>
<p>The solution to the minimization problem is determined using the function
<code><a href="quantreg.html#topic+rq">rq</a></code> from the <span class="pkg">quantreg</span> package.
</p>
<p>All remarks made in the documentation of the super-class
<code><a href="#topic+FreqRep">FreqRep</a></code> apply.
</p>


<h3>Slots</h3>


<dl>
<dt><code>method</code></dt><dd><p>method used for computing the quantile regression estimates.
The choice is passed to <code>qr</code>; see the
documentation of <code>quantreg</code> for details.</p>
</dd>
<dt><code>parallel</code></dt><dd><p>a flag that signalizes that parallelization mechanisms from
the package <span class="pkg">snowfall</span> may be used.</p>
</dd>
</dl>


<h3>References</h3>

<p>Dette, H., Hallin, M., Kley, T. &amp; Volgushev, S. (2015).
Of Copulas, Quantiles, Ranks and Spectra: an <code class="reqn">L_1</code>-approach to
spectral analysis. <em>Bernoulli</em>, <b>21</b>(2), 781&ndash;831.
[cf. <a href="http://arxiv.org/abs/1111.7205">http://arxiv.org/abs/1111.7205</a>]
</p>

<hr>
<h2 id='QRegEstimator-constructor'>Create an instance of the <code>QRegEstimator</code> class.</h2><span id='topic+QRegEstimator-constructor'></span><span id='topic+qRegEstimator'></span>

<h3>Description</h3>

<p>The parameter <code>type.boot</code> can be set to choose a block bootstrapping
procedure. If <code>"none"</code> is chosen, a moving blocks bootstrap with
<code>l=length(Y)</code> and  <code>N=length(Y)</code> would be done. Note that in that
case one would also chose <code>B=0</code> which means that <code>getPositions</code>
would never be called. If <code>B&gt;0</code> then each bootstrap replication would
be the undisturbed time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qRegEstimator(
  Y,
  frequencies = 2 * pi/lenTS(Y) * 0:(lenTS(Y) - 1),
  levels = 0.5,
  isRankBased = TRUE,
  B = 0,
  l = 0,
  type.boot = c("none", "mbb"),
  method = c("br", "fn", "pfn", "fnc", "lasso", "scad"),
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QRegEstimator-constructor_+3A_y">Y</code></td>
<td>
<p>A <code>vector</code> of real numbers containing the time series from
which to determine the quantile periodogram or a <code>ts</code> object
or a <code>zoo</code> object.</p>
</td></tr>
<tr><td><code id="QRegEstimator-constructor_+3A_frequencies">frequencies</code></td>
<td>
<p>A vector containing frequencies at which to determine the
<code>QRegEstimator</code>.</p>
</td></tr>
<tr><td><code id="QRegEstimator-constructor_+3A_levels">levels</code></td>
<td>
<p>A vector of length <code>K</code> containing the levels <code>x</code>
at which the <code>QRegEstimator</code> is to be determined.</p>
</td></tr>
<tr><td><code id="QRegEstimator-constructor_+3A_isrankbased">isRankBased</code></td>
<td>
<p>If true the time series is first transformed to pseudo
data [cf. <code><a href="#topic+FreqRep">FreqRep</a></code>].</p>
</td></tr>
<tr><td><code id="QRegEstimator-constructor_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="QRegEstimator-constructor_+3A_l">l</code></td>
<td>
<p>(expected) length of blocks</p>
</td></tr>
<tr><td><code id="QRegEstimator-constructor_+3A_type.boot">type.boot</code></td>
<td>
<p>A flag to choose a method for the block bootstrap; currently
two options are implemented: <code>"none"</code> and <code>"mbb"</code>
which means to do a moving blocks  bootstrap with <code>B</code>
and <code>l</code> as specified.</p>
</td></tr>
<tr><td><code id="QRegEstimator-constructor_+3A_method">method</code></td>
<td>
<p>method used for computing the quantile regression estimates.
The choice is passed to <code>qr</code>; see the
documentation of <code>quantreg</code> for details.</p>
</td></tr>
<tr><td><code id="QRegEstimator-constructor_+3A_parallel">parallel</code></td>
<td>
<p>a flag to allow performing parallel computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code>QRegEstimator</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(snowfall)

Y &lt;- rnorm(100) # Try 2000 and parallel computation will in fact be faster.

# Compute without using snowfall capabilities
system.time(
  qRegEst1 &lt;- qRegEstimator(Y, levels=seq(0.25,0.75,0.25), method="fn", parallel=FALSE)
)

# Set up snowfall
sfInit(parallel=TRUE, cpus=2, type="SOCK")
sfLibrary(quantreg)
sfExportAll()

# Compare how much faster the computation is when done in parallel
system.time(
  qRegEst2 &lt;- qRegEstimator(Y, levels=seq(0.25,0.75,0.25), method="fn", parallel=TRUE)
)

sfStop()

# Compare results
V1 &lt;- getValues(qRegEst1)
V2 &lt;- getValues(qRegEst2)
sum(abs(V1-V2)) # Returns: [1] 0
</code></pre>

<hr>
<h2 id='QSpecQuantity-class'>Class for a Quantile Spectral Estimator.</h2><span id='topic+QSpecQuantity-class'></span><span id='topic+QSpecQuantity'></span>

<h3>Description</h3>

<p><code>QSpecQuantity</code> is an S4 class that provides a common interface to
objects that are of the functional form
<code class="reqn">f^{j_1, j_2}(\omega; x_1, x_2)</code>,
where <code class="reqn">j_1, j_2</code> are indices denoting components of a time series
or process, <code class="reqn">\omega</code> is a frequency parameter and
<code class="reqn">x_1, x_2</code> are level parameters. For each combination of
parameters a complex number can be stored.
Examples for objects of this kind currently include the quantile (i. e.,
Laplace or copula) spectral
density kernel [cf. <code><a href="#topic+QuantileSD">QuantileSD</a></code> for an implementation], an
integrated version of the quantile spectral density kernels
[cf. <code><a href="#topic+IntegrQuantileSD">IntegrQuantileSD</a></code> for an implementation], and
estimators of it [cf. <code><a href="#topic+QuantilePG">QuantilePG</a></code> and <code><a href="#topic+SmoothedPG">SmoothedPG</a></code>
for implementations].
</p>


<h3>Slots</h3>


<dl>
<dt><code>values</code></dt><dd><p>The array holding the values
<code class="reqn">f^{j_1, j_2}(\omega; x_1, x_2)</code>.</p>
</dd>
<dt><code>frequencies</code></dt><dd><p>The frequencies <code class="reqn">\omega</code> for which the values are
available.</p>
</dd>
<dt><code>levels</code></dt><dd><p>A list of vectors containing the levels <code class="reqn">x_i</code> serving
as argument for the estimator.</p>
</dd>
</dl>

<hr>
<h2 id='QuantilePG-class'>Class for a quantile (i. e., Laplace or copula) periodogram.</h2><span id='topic+QuantilePG-class'></span><span id='topic+QuantilePG'></span>

<h3>Description</h3>

<p><code>QuantilePG</code> is an S4 class that implements the necessary
calculations to determine one of the periodogram-like statistics defined in
Dette et. al (2015) and Kley et. al (2016).
</p>


<h3>Details</h3>

<p>Performs all the calculations to determine a quantile periodogram from a
<code>FreqRep</code> object upon initizalization (and on request
stores the values for faster access).
The two methods available for the estimation are the ones implemented as
subclasses of <code><a href="#topic+FreqRep">FreqRep</a></code>:
</p>

<ul>
<li><p> the Fourier transformation of the clipped time series
<code class="reqn">(\{I\{Y_t \leq q\})</code> [cf. <code><a href="#topic+ClippedFT">ClippedFT</a></code>], or
</p>
</li>
<li><p> the weighted <code class="reqn">L_1</code>-projection of <code class="reqn">(Y_t)</code> onto an harmonic
basis [cf. <code><a href="#topic+QRegEstimator">QRegEstimator</a></code>].
</p>
</li></ul>

<p>All remarks made in the documentation of the super-class
<code><a href="#topic+QSpecQuantity">QSpecQuantity</a></code> apply.
</p>


<h3>Slots</h3>


<dl>
<dt><code>freqRep</code></dt><dd><p>a <code><a href="#topic+FreqRep">FreqRep</a></code> object where the quantile periodogram will
be based on.</p>
</dd>
</dl>


<h3>References</h3>

<p>Dette, H., Hallin, M., Kley, T. &amp; Volgushev, S. (2015).
Of Copulas, Quantiles, Ranks and Spectra: an <code class="reqn">L_1</code>-approach to
spectral analysis. <em>Bernoulli</em>, <b>21</b>(2), 781&ndash;831.
[cf. <a href="http://arxiv.org/abs/1111.7205">http://arxiv.org/abs/1111.7205</a>]
</p>
<p>Kley, T., Volgushev, S., Dette, H. &amp; Hallin, M. (2016).
Quantile Spectral Processes: Asymptotic Analysis and Inference.
<em>Bernoulli</em>, <b>22</b>(3), 1770&ndash;1807.
[cf. <a href="http://arxiv.org/abs/1401.8104">http://arxiv.org/abs/1401.8104</a>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################################################################################
## This script illustrates how to work with QuantilePG objects

## Simulate a time series Y1,...,Y128 from the QAR(1) process discussed in
## Dette et. al (2015).
Y &lt;- ts1(64)

## For a defined set of quantile levels
levels &lt;- c(0.25,0.5,0.75)

## the various quantile periodograms can be calculated calling quantilePG:

## For a copula periodogram as in Dette et. al (2015) the option 'type="qr"'
## has to be used:
system.time(
    qPG.qr &lt;- quantilePG(Y, levels.1 = levels, type="qr"))

## For the CR-periodogram as in Kley et. al (2016) the option 'type="clipped"'
## has to be used. If bootstrap estimates are to be used the parameters
## type.boot, B and l need to be specified.
system.time(
    qPG.cl &lt;- quantilePG(Y, levels.1 = levels, type="clipped",
        type.boot="mbb", B=250, l=2^5))

## The two previous calls also illustrate that computation of the CR-periodogram
## is much more efficient than the quantile-regression based copula periodogram.

## Either periodogram can be plotted using the plot command
plot(qPG.cl)
plot(qPG.qr)

## Because the indicators are not centered it is often desired to exclude the
## frequency 0; further more the frequencies (pi,2pi) are not wanted to be
## included in the plot, because f(w) = Conj(f(2 pi - w)).
## Using the plot command it is possible to select frequencies and levels for
## the diagram:
plot(qPG.cl, frequencies=2*pi*(1:32)/64, levels=c(0.25))

## We can also plot the same plot together with a (simulated) quantile spectral
## density kernel
csd &lt;- quantileSD(N=2^8, seed.init = 2581, type = "copula",
    ts = ts1, levels.1=c(0.25), R = 100)
plot(qPG.cl, qsd = csd, frequencies=2*pi*(1:32)/64, levels=c(0.25))

## Calling the getValues method allows for comparing the two quantile
## periodograms; here in a diagram:
freq &lt;- 2*pi*(1:31)/32
V.cl &lt;- getValues(qPG.cl, frequencies = freq, levels.1=c(0.25))
V.qr &lt;- getValues(qPG.qr, frequencies = freq, levels.1=c(0.25))
plot(x = freq/(2*pi), Re(V.cl[,1,1,1]), type="l",
        ylab="real part -- quantile PGs", xlab=expression(omega/2*pi))
lines(x = freq/(2*pi), Re(V.qr[,1,1,1]), col="red")

## Now plot the imaginary parts of the quantile spectra for tau1 = 0.25
## and tau2 = 0.5
freq &lt;- 2*pi*(1:31)/32
V.cl &lt;- getValues(qPG.cl, frequencies = freq, levels.1=c(0.25, 0.5))
V.qr &lt;- getValues(qPG.qr, frequencies = freq, levels.1=c(0.25, 0.5))
plot(x = freq/(2*pi), Im(V.cl[,1,2,1]), type="l",
    ylab="imaginary part -- quantile PGs", xlab=expression(omega/2*pi))
lines(x = freq/(2*pi), Im(V.qr[,1,2,1]), col="red")
</code></pre>

<hr>
<h2 id='QuantilePG-constructor'>Create an instance of the <code><a href="#topic+QuantilePG">QuantilePG</a></code> class.</h2><span id='topic+QuantilePG-constructor'></span><span id='topic+quantilePG'></span>

<h3>Description</h3>

<p>The parameter <code>type.boot</code> can be set to choose a block bootstrapping
procedure. If <code>"none"</code> is chosen, a moving blocks bootstrap with
<code>l=length(Y)</code> and  <code>N=length(Y)</code> would be done. Note that in that
case one would also chose <code>B=0</code> which means that <code>getPositions</code>
would never be called. If <code>B&gt;0</code> then each bootstrap replication would
be the undisturbed time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantilePG(
  Y,
  frequencies = 2 * pi/lenTS(Y) * 0:(lenTS(Y) - 1),
  levels.1 = 0.5,
  levels.2 = levels.1,
  isRankBased = TRUE,
  type = c("clipped", "qr"),
  type.boot = c("none", "mbb"),
  B = 0,
  l = 0,
  method = c("br", "fn", "pfn", "fnc", "lasso", "scad"),
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuantilePG-constructor_+3A_y">Y</code></td>
<td>
<p>A <code>vector</code> of real numbers containing the time series from
which to determine the quantile periodogram or a <code>ts</code> object
or a <code>zoo</code> object.</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_frequencies">frequencies</code></td>
<td>
<p>A vector containing frequencies at which to determine the
quantile periodogram.</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_levels.1">levels.1</code></td>
<td>
<p>A vector of length <code>K1</code> containing the levels <code>x1</code>
at which the QuantilePG is to be determined.</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_levels.2">levels.2</code></td>
<td>
<p>A vector of length <code>K2</code> containing the levels <code>x2</code>.</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_isrankbased">isRankBased</code></td>
<td>
<p>If true the time series is first transformed to pseudo
data [cf. <code><a href="#topic+FreqRep">FreqRep</a></code>].</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_type">type</code></td>
<td>
<p>A flag to choose the type of the estimator. Can be either
<code>"clipped"</code> or <code>"qr"</code>. In the first case
<code><a href="#topic+ClippedFT">ClippedFT</a></code> is used as a frequency representation, in
the second case <code><a href="#topic+QRegEstimator">QRegEstimator</a></code> is used.</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_type.boot">type.boot</code></td>
<td>
<p>A flag to choose a method for the block bootstrap; currently
two options are implemented: <code>"none"</code> and <code>"mbb"</code>
which means to do a moving blocks  bootstrap with <code>B</code>
and <code>l</code> as specified.</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_l">l</code></td>
<td>
<p>(expected) length of blocks</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_method">method</code></td>
<td>
<p>method used for computing the quantile regression estimates.
The choice is passed to <code>qr</code>; see the
documentation of <code>quantreg</code> for details.</p>
</td></tr>
<tr><td><code id="QuantilePG-constructor_+3A_parallel">parallel</code></td>
<td>
<p>a flag to allow performing parallel computations,
where possible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code>QuantilePG</code>.
</p>

<hr>
<h2 id='QuantileSD-class'>Class for a simulated quantile (i. e., Laplace or copula)
density kernel.</h2><span id='topic+QuantileSD-class'></span><span id='topic+QuantileSD'></span>

<h3>Description</h3>

<p><code>QuantileSD</code> is an S4 class that implements the necessary
calculations to determine a numeric approximation to the quantile spectral
density kernel of a model from which a time series of length <code>N</code> can be
sampled via a function call <code>ts(N)</code>.
</p>


<h3>Details</h3>

<p>In the simulation a number of <code>R</code> independent quantile periodograms
based on the clipped time series are simulated. If <code>type=="copula"</code>,
then the rank-based version is used. The sum and the sum of the squared
absolute value is stored to the slots <code>sumPG</code> and <code>sumSqPG</code>.
After the simulation is completed the mean and it's standard error (of the
simulated quantile periodograms) are determined and stored to <code>meanPG</code>
and <code>stdError</code>. Finally, the (copula) spectral density kernel is
determined by smoothing real and imaginary part of <code>meanPG</code> seperately
for each combination of levels using <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.
</p>
<p>Note that, all remarks made in the documentation of the super-class
<code><a href="#topic+QSpecQuantity">QSpecQuantity</a></code> apply.
</p>


<h3>Slots</h3>


<dl>
<dt><code>N</code></dt><dd><p>a <code>numeric</code> specifying the number of equaly spaced
Fourier frequencies from
<code class="reqn">[0,2\pi)</code> for which the (copula) spectral density
will be simulated; note that due to the simulation mechanism a
larger number will also yield a better approximation.</p>
</dd>
<dt><code>R</code></dt><dd><p>the number of independent repetitions performed; note that due to
the simulation mechanism a larger number will also yield a better
approximation; can be enlarged
using <code><a href="#topic+increasePrecision-QuantileSD">increasePrecision-QuantileSD</a></code>.</p>
</dd>
<dt><code>type</code></dt><dd><p>can be either <code>Laplace</code> or <code>copula</code>; indicates whether
the marginals are to be assumed uniform <code class="reqn">[0,1]</code> distributed.</p>
</dd>
<dt><code>ts</code></dt><dd><p>a <code>function</code> that allows to draw independent samples
<code class="reqn">Y_0, \ldots, Y_{n-1}</code> from the process for which the (copula)
spectral density kernel is to be simulated</p>
</dd>
<dt><code>seed.last</code></dt><dd><p>used internally to store the state of the pseudo random number
generator, so the precision can be increased by generating
more pseudo random numbers that are independent from the ones
previously used.</p>
</dd>
<dt><code>sumPG</code></dt><dd><p>an <code>array</code> used to store the sum of the simulated quantile
periodograms</p>
</dd>
<dt><code>sumSqPG</code></dt><dd><p>an <code>array</code> used to store the sum of the squared absolute
values of the simulated quantile periodograms</p>
</dd>
<dt><code>meanPG</code></dt><dd><p>an <code>array</code> used to store the mean of the simulated quantile
periodograms</p>
</dd>
<dt><code>stdError</code></dt><dd><p>an <code>array</code> used to store the estimated standard error of the mean
of the simulated quantile periodograms</p>
</dd>
</dl>


<h3>References</h3>

<p>Dette, H., Hallin, M., Kley, T. &amp; Volgushev, S. (2015).
Of Copulas, Quantiles, Ranks and Spectra: an <code class="reqn">L_1</code>-approach to
spectral analysis. <em>Bernoulli</em>, <b>21</b>(2), 781&ndash;831.
[cf. <a href="http://arxiv.org/abs/1111.7205">http://arxiv.org/abs/1111.7205</a>]
</p>
<p>Kley, T., Volgushev, S., Dette, H. &amp; Hallin, M. (2016).
Quantile Spectral Processes: Asymptotic Analysis and Inference.
<em>Bernoulli</em>, <b>22</b>(3), 1770&ndash;1807.
[cf. <a href="http://arxiv.org/abs/1401.8104">http://arxiv.org/abs/1401.8104</a>]
</p>
<p>Barunik, J. &amp; Kley, T. (2015).
Quantile Cross-Spectral Measures of Dependence between Economic Variables.
[preprint available from the authors]
</p>


<h3>See Also</h3>

<p>Examples for implementations of functions <code>ts</code> can be found at:
<code><a href="#topic+ts-models">ts-models</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This script can be used to create and store a QuantileSD object

## Not run: 
## Parameters for the simulation:
R &lt;- 50                      # number of independent repetitions;
                             # R should be much larger than this in practice!
N &lt;- 2^8                     # number of Fourier frequencies in [0,2pi)
ts &lt;- ts1                    # time series model
levels &lt;- seq(0.1,0.9,0.1)   # quantile levels
type &lt;- "copula"             # copula, not Laplace, spectral density kernel
seed.init &lt;- 2581            # seed for the pseudo random numbers

## Simulation takes place once the constructor is invoked
qsd &lt;- quantileSD(N=N, seed.init = 2581, type = type,
    ts = ts, levels.1=levels, R = R)

## The simulated copula spectral density kernel can be called via
V1 &lt;- getValues(qsd)

## It is also possible to fetch the result for only a few levels
levels.few &lt;- c(0.2,0.5,0.7)
V2 &lt;- getValues(qsd, levels.1=levels.few, levels.2=levels.few)

## If desired additional repetitions can be performed to yield a more precise
## simulation result by calling; here the number of independent runs is doubled.
qsd &lt;- increasePrecision(qsd,R)

## Often the result will be stored for later usage.  
save(qsd, file="QAR1.rdata")

## Take a brief look at the result of the simulation
plot(qsd, levels=levels.few)

## When plotting more than only few levels it may be a good idea to plot to
## another device; e. g., a pdf-file
K &lt;- length(levels)
pdf("QAR1.pdf", width=2*K, height=2*K)
  plot(qsd)
dev.off()

## Now we analyse the multivariate process (eps_t, eps_{t-1}) from the
## introduction of Barunik&amp;Kley (2015). It can be defined as
ts_mult &lt;- function(n) {
  eps &lt;- rnorm(n+1)
  return(matrix(c(eps[2:(n+1)], eps[1:n]), ncol=2))
}

## now we determine the quantile cross-spectral densities
qsd &lt;- quantileSD(N=N, seed.init = 2581, type = type,
    ts = ts_mult, levels.1=levels, R = R)

## from which we can for example extract the quantile coherency
Coh &lt;- getCoherency(qsd, freq = 2*pi*(0:64)/128)

## We now plot the real part of the quantile coherency for j1 = 1, j2 = 2,
## tau1 = 0.3 and tau2 = 0.6
plot(x = 2*pi*(0:64)/128, Re(Coh[,1,3,2,6]), type="l")

## End(Not run)
</code></pre>

<hr>
<h2 id='QuantileSD-constructor'>Create an instance of the <code><a href="#topic+QuantileSD">QuantileSD</a></code> class.</h2><span id='topic+QuantileSD-constructor'></span><span id='topic+quantileSD'></span>

<h3>Description</h3>

<p>Create an instance of the <code><a href="#topic+QuantileSD">QuantileSD</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileSD(
  N = 2^8,
  type = c("copula", "Laplace"),
  ts = rnorm,
  seed.init = runif(1),
  levels.1,
  levels.2 = levels.1,
  R = 1,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuantileSD-constructor_+3A_n">N</code></td>
<td>
<p>the number of Fourier frequencies to be used.</p>
</td></tr>
<tr><td><code id="QuantileSD-constructor_+3A_type">type</code></td>
<td>
<p>can be either <code>Laplace</code> or <code>copula</code>; indicates whether
the marginals are to be assumed uniform <code class="reqn">[0,1]</code> distributed.</p>
</td></tr>
<tr><td><code id="QuantileSD-constructor_+3A_ts">ts</code></td>
<td>
<p>a function that has one argument <code>n</code> and, each time it is
invoked, returns a new time series from the model for which the
copula spectral density kernel is to be simulated.</p>
</td></tr>
<tr><td><code id="QuantileSD-constructor_+3A_seed.init">seed.init</code></td>
<td>
<p>an integer serving as an initial seed for the simulations.</p>
</td></tr>
<tr><td><code id="QuantileSD-constructor_+3A_levels.1">levels.1</code></td>
<td>
<p>A vector of length <code>K1</code> containing the levels <code>x1</code>
at which the <code>QuantileSD</code> is to be determined.</p>
</td></tr>
<tr><td><code id="QuantileSD-constructor_+3A_levels.2">levels.2</code></td>
<td>
<p>A vector of length <code>K2</code> containing the levels <code>x2</code>
at which the <code>QuantileSD</code> is to be determined.</p>
</td></tr>
<tr><td><code id="QuantileSD-constructor_+3A_r">R</code></td>
<td>
<p>an integer that determines the number of independent simulations;
the larger this number the more precise is the result.</p>
</td></tr>
<tr><td><code id="QuantileSD-constructor_+3A_quiet">quiet</code></td>
<td>
<p>Dont't report progress to console when computing the <code>R</code>
independent quantile periodograms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an instance of <code>QuantileSD</code>.
</p>


<h3>See Also</h3>

<p>For examples see <code><a href="#topic+QuantileSD">QuantileSD</a></code>.
</p>

<hr>
<h2 id='quantspec-defunct'>Defunct functions in package quantspec</h2><span id='topic+quantspec-defunct'></span><span id='topic+ct'></span><span id='topic+LaplacePeriodogram'></span><span id='topic+plotLaplacePeriodogram'></span><span id='topic+smoothedLaplacePeriodogram'></span>

<h3>Description</h3>

<p>These functions have been declared defunct since Version 1.0-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ct(i1, i2, n)

LaplacePeriodogram(
  X,
  taus,
  omegas = 1:(ceiling(length(X)/2) - 1),
  fromRanks = TRUE,
  showProgressBar = FALSE
)

plotLaplacePeriodogram(
  LPG,
  taus,
  F = 1:length(LPG[, 1]),
  CL = 1:length(taus),
  hRange = FALSE,
  hOffset = FALSE,
  ylabel = expression({     {         hat(f)     }[n]^{         list(tau[1], tau[2])   
     } }(omega)),
  oma = c(2.5, 2.5, 2.5, 2.5),
  mar = c(4.5, 4.5, 1, 0) + 0.1,
  cex.lab = 1.5
)

smoothedLaplacePeriodogram(LPG, taus, W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantspec-defunct_+3A_i1">i1</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_i2">i2</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_n">n</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_x">X</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_taus">taus</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_omegas">omegas</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_fromranks">fromRanks</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_showprogressbar">showProgressBar</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_lpg">LPG</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_f">F</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_cl">CL</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_hrange">hRange</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_hoffset">hOffset</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_ylabel">ylabel</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_oma">oma</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_mar">mar</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
<tr><td><code id="quantspec-defunct_+3A_w">W</code></td>
<td>
<p>Parameter of DEFUNCT function.</p>
</td></tr>
</table>

<hr>
<h2 id='SmoothedPG-class'>Class for a smoothed quantile periodogram.</h2><span id='topic+SmoothedPG-class'></span><span id='topic+SmoothedPG'></span>

<h3>Description</h3>

<p><code>SmoothedPG</code> is an S4 class that implements the necessary
calculations to determine a smoothed version of one of the quantile
periodograms defined in Dette et. al (2015), Kley et. al (2016) and
Barunik&amp;Kley (2015).
</p>


<h3>Details</h3>

<p>For a <code><a href="#topic+QuantilePG">QuantilePG</a></code> <code class="reqn">Q^{j_1, j_2}_n(\omega, x_1, x_2)</code> and
a <code><a href="#topic+Weight">Weight</a></code> <code class="reqn">W_n(\cdot)</code> the smoothed version
</p>
<p style="text-align: center;"><code class="reqn">\frac{2\pi}{n} \sum_{s=1}^{n-1} W_n(\omega-2\pi s / n) Q^{j_1, j_2}_n(2\pi s / n, x_1, x_2)</code>
</p>

<p>is determined.
</p>
<p>The convolution required to determine the smoothed periodogram is implemented
using <code><a href="stats.html#topic+convolve">convolve</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>env</code></dt><dd><p>An environment to allow for slots which need to be
accessable in a call-by-reference manner:
</p>

<dl>
<dt><code>sdNaive</code></dt><dd><p>An array used for storage of the naively
estimated standard deviations of the smoothed periodogram.</p>
</dd>
<dt><code>sdNaive.freq</code></dt><dd><p>a vector indicating for which frequencies
<code>sdNaive</code> has been computed so far.</p>
</dd>
<dt><code>sdNaive.done</code></dt><dd><p>a flag indicating whether <code>sdNaive</code>
has been set yet.</p>
</dd>
<dt><code>sdBoot</code></dt><dd><p>An array used for storage of the standard
deviations of the smoothed periodogram, estimated via
bootstrap.</p>
</dd>
<dt><code>sdBoot.done</code></dt><dd><p>a flag indicating whether
<code>sdBoot.naive</code> has been set yet.</p>
</dd>
</dl>
</dd>
<dt><code>qPG</code></dt><dd><p>the <code><a href="#topic+QuantilePG">QuantilePG</a></code> to be smoothed</p>
</dd>
<dt><code>weight</code></dt><dd><p>the <code><a href="#topic+Weight">Weight</a></code> to be used for smoothing</p>
</dd>
</dl>

<hr>
<h2 id='SmoothedPG-constructor'>Create an instance of the <code>SmoothedPG</code> class.</h2><span id='topic+SmoothedPG-constructor'></span><span id='topic+smoothedPG'></span>

<h3>Description</h3>

<p>A <code>SmoothedPG</code> object can be created from either
</p>

<ul>
<li><p> a <code>numeric</code>, a <code>ts</code>, or a <code>zoo</code> object
</p>
</li>
<li><p> a <code>QuantilePG</code> object.
</p>
</li></ul>

<p>If a <code>QuantilePG</code> object is used for smoothing, only the <code>weight</code>,
<code>frequencies</code> and <code>levels.1</code> and <code>levels.2</code> parameters are
used; all others are ignored. In this case the default values for the levels
are the levels of the <code>QuantilePG</code> used for smoothing. Any subset of the
levels available there can be chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothedPG(
  object,
  frequencies = 2 * pi/lenTS(object) * 0:(lenTS(object) - 1),
  levels.1 = 0.5,
  levels.2 = levels.1,
  isRankBased = TRUE,
  type = c("clipped", "qr"),
  type.boot = c("none", "mbb"),
  method = c("br", "fn", "pfn", "fnc", "lasso", "scad"),
  parallel = FALSE,
  B = 0,
  l = 1,
  weight = kernelWeight()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SmoothedPG-constructor_+3A_object">object</code></td>
<td>
<p>a time series (<code>numeric</code>, <code>ts</code>, or <code>zoo</code> object)
from which to determine the smoothed periodogram; alternatively
a <code><a href="#topic+QuantilePG">QuantilePG</a></code> object can be supplied.</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_frequencies">frequencies</code></td>
<td>
<p>A vector containing frequencies at which to determine the
smoothed periodogram.</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_levels.1">levels.1</code></td>
<td>
<p>A vector of length <code>K1</code> containing the levels <code>x1</code>
at which the SmoothedPG is to be determined.</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_levels.2">levels.2</code></td>
<td>
<p>A vector of length <code>K2</code> containing the levels <code>x2</code>.</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_isrankbased">isRankBased</code></td>
<td>
<p>If true the time series is first transformed to pseudo
data [cf. <code><a href="#topic+FreqRep">FreqRep</a></code>].</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_type">type</code></td>
<td>
<p>A flag to choose the type of the estimator. Can be either
<code>"clipped"</code> or <code>"qr"</code>. In the first case
<code><a href="#topic+ClippedFT">ClippedFT</a></code> is used as a frequency representation, in
the second case <code><a href="#topic+QRegEstimator">QRegEstimator</a></code> is used.</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_type.boot">type.boot</code></td>
<td>
<p>A flag to choose a method for the block bootstrap; currently
two options are implemented: <code>"none"</code> and <code>"mbb"</code>
which means to do a moving blocks  bootstrap with <code>B</code>
and <code>l</code> as specified.</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_method">method</code></td>
<td>
<p>method used for computing the quantile regression estimates.
The choice is passed to <code>qr</code>; see the
documentation of <code>quantreg</code> for details.</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_parallel">parallel</code></td>
<td>
<p>a flag to allow performing parallel computations,
where possible.</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_l">l</code></td>
<td>
<p>(expected) length of blocks</p>
</td></tr>
<tr><td><code id="SmoothedPG-constructor_+3A_weight">weight</code></td>
<td>
<p>Object of type <code><a href="#topic+Weight">Weight</a></code> to be used for smoothing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>type.boot</code> can be set to choose a block bootstrapping
procedure. If <code>"none"</code> is chosen, a moving blocks bootstrap with
<code>l=length(Y)</code> and  <code>N=length(Y)</code> would be done. Note that in that
case one would also chose <code>B=0</code> which means that <code>getPositions</code>
would never be called. If <code>B&gt;0</code> then each bootstrap replication would
be the undisturbed time series.
</p>


<h3>Value</h3>

<p>Returns an instance of <code>SmoothedPG</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rnorm(64)
levels.1 &lt;- c(0.25,0.5,0.75)
weight &lt;- kernelWeight(W=W0)

# Version 1a of the constructor -- for numerics:
sPG.ft &lt;- smoothedPG(Y, levels.1 = levels.1, weight = weight, type="clipped")
sPG.qr &lt;- smoothedPG(Y, levels.1 = levels.1, weight = weight, type="qr")

# Version 1b of the constructor -- for ts objects:
sPG.ft &lt;- smoothedPG(wheatprices, levels.1 = c(0.05,0.5,0.95), weight = weight)

# Version 1c of the constructor -- for zoo objects:
sPG.ft &lt;- smoothedPG(sp500, levels.1 = c(0.05,0.5,0.95), weight = weight)

# Version 2 of the constructor:
qPG.ft &lt;- quantilePG(Y, levels.1 = levels.1, type="clipped")
sPG.ft &lt;- smoothedPG(qPG.ft, weight = weight)
qPG.qr &lt;- quantilePG(Y, levels.1 = levels.1, type="qr")
sPG.qr &lt;- smoothedPG(qPG.qr, weight = weight)
</code></pre>

<hr>
<h2 id='SpecDistrWeight-class'>Class for weights to estimate integrated spectral density kernels.</h2><span id='topic+SpecDistrWeight-class'></span><span id='topic+SpecDistrWeight'></span>

<h3>Description</h3>

<p><code>SpecDistrWeight</code> is an S4 class that implements a weighting function given
by
</p>
<p style="text-align: center;"><code class="reqn">W_n(\alpha) := I\{\alpha \leq 0\}</code>
</p>
<p>.
</p>


<h3>Details</h3>

<p>At position <code>k</code> the value <code class="reqn">W_n(2\pi (k-1)/n</code> is
stored [in a vector <code>values</code> nested inside <code>env</code>] for <code>k=1,...,T</code>.
The number <code>length(values)</code> of Fourier frequencies for which
<code class="reqn">W_n</code> will be evaluated may be set on construction or updated when
evoking the method <code>getValues</code>.
</p>

<hr>
<h2 id='SpecDistrWeight-constructor'>Create an instance of the <code><a href="#topic+SpecDistrWeight">SpecDistrWeight</a></code> class.</h2><span id='topic+SpecDistrWeight-constructor'></span><span id='topic+specDistrWeight'></span>

<h3>Description</h3>

<p>Create an instance of the <code><a href="#topic+SpecDistrWeight">SpecDistrWeight</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specDistrWeight(descr = "Spectral Distribution Weights")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpecDistrWeight-constructor_+3A_descr">descr</code></td>
<td>
<p>a description for the weight object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an instance of <code>SpecDistrWeight</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wgt &lt;- specDistrWeight()
</code></pre>

<hr>
<h2 id='timeSeriesValidator'>Validates if <code>Y</code> is of an appropriate type and converts to a numeric.</h2><span id='topic+timeSeriesValidator'></span>

<h3>Description</h3>

<p>Checks whether <code>Y</code> is either
</p>

<ul>
<li> <p><code>numeric</code>,
</p>
</li>
<li><p> a <code>ts</code> object, or
</p>
</li>
<li><p> a <code>zoo</code> object.
</p>
</li></ul>

<p>If not, an error is returned. If it is one of the three the data is returned
as a numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeSeriesValidator(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeSeriesValidator_+3A_y">Y</code></td>
<td>
<p>the time series to be validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the time series as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- timeSeriesValidator(sp500)
Y &lt;- timeSeriesValidator(wheatprices)
Y &lt;- timeSeriesValidator(rnorm(10))
## Not run: Y &lt;- timeSeriesValidator("Not a valid input")
</code></pre>

<hr>
<h2 id='ts-models'>Functions to simulate from the time series models in Kley et. al (2016).</h2><span id='topic+ts-models'></span><span id='topic+ts1'></span><span id='topic+ts2'></span><span id='topic+ts3'></span>

<h3>Description</h3>

<p>Functions to simulate from the time series models in Kley et. al (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts1(n)

ts2(n)

ts3(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts-models_+3A_n">n</code></td>
<td>
<p>length of the time series to be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ts1</code> QAR(1) model from Dette et. al (2015).
</p>
<p><code>ts2</code> AR(2) model from Li (2012):
</p>
<p><code>ts3</code> ARCH(1) model from Lee and Subba Rao (2012):
</p>


<h3>References</h3>

<p>Dette, H., Hallin, M., Kley, T. &amp; Volgushev, S. (2015).
Of Copulas, Quantiles, Ranks and Spectra: an <code class="reqn">L_1</code>-approach to
spectral analysis. <em>Bernoulli</em>, <b>21</b>(2), 781&ndash;831.
[cf. <a href="http://arxiv.org/abs/1111.7205">http://arxiv.org/abs/1111.7205</a>]
</p>
<p>Li, T.-H. (2012). Quantile Periodograms.
<em>Journal of the American Statistical Association</em>, <b>107</b>, 765&ndash;776.
</p>
<p>Lee, J., &amp; Subba Rao, S. (2012).
The Quantile Spectral Density and Comparison based Tests for Nonlinear Time
Series. <a href="http://arxiv.org/abs/1112.2759">http://arxiv.org/abs/1112.2759</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot sample paths:
plot(ts1(100), type="l")
plot(ts2(100), type="l")
plot(ts3(100), type="l")
</code></pre>

<hr>
<h2 id='ts-models-AR1'>Simulation of an AR(1) time series.</h2><span id='topic+ts-models-AR1'></span><span id='topic+AR1'></span>

<h3>Description</h3>

<p>Returns a simulated time series <code class="reqn">(Y_t)</code> that fulfills the following equation:
</p>
<p style="text-align: center;"><code class="reqn">Y_t = a Y_{t-1} + \epsilon_t,</code>
</p>

<p>where <code class="reqn">a</code> is a parameter and <code class="reqn">\epsilon_t</code> is independent white
noise with marginal distribution specified by the parameter <code>innov</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR1(n, a, overhead = 500, innov = rnorm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts-models-AR1_+3A_n">n</code></td>
<td>
<p>length of the time series to be returned</p>
</td></tr>
<tr><td><code id="ts-models-AR1_+3A_a">a</code></td>
<td>
<p>parameter of the model</p>
</td></tr>
<tr><td><code id="ts-models-AR1_+3A_overhead">overhead</code></td>
<td>
<p>an integer specifying the &ldquo;warmup&rdquo; period to reach an
approximate stationary start for the times series</p>
</td></tr>
<tr><td><code id="ts-models-AR1_+3A_innov">innov</code></td>
<td>
<p>a function that generates a random number each time
<code>innov(1)</code> is called; used to specify the distribution of
the innovations; <code>rnorm</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an AR(1) time series with specified parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(AR1(100, a=-0.7), type="l")
</code></pre>

<hr>
<h2 id='ts-models-AR2'>Simulation of an AR(2) time series.</h2><span id='topic+ts-models-AR2'></span><span id='topic+AR2'></span>

<h3>Description</h3>

<p>Returns a simulated time series <code class="reqn">(Y_t)</code> that fulfills the following equation:
</p>
<p style="text-align: center;"><code class="reqn">Y_t = a_1 Y_{t-1} + a_2 Y_{t-2} + \epsilon_t,</code>
</p>

<p>where <code class="reqn">a_1</code> and <code class="reqn">a_2</code> are parameters and <code class="reqn">\epsilon_t</code> is
independent white noise with marginal distribution specified by the
parameter <code>innov</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR2(n, a1, a2, overhead = 500, innov = rnorm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts-models-AR2_+3A_n">n</code></td>
<td>
<p>length of the time series to be returned</p>
</td></tr>
<tr><td><code id="ts-models-AR2_+3A_a1">a1</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="ts-models-AR2_+3A_a2">a2</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="ts-models-AR2_+3A_overhead">overhead</code></td>
<td>
<p>an integer specifying the &ldquo;warmup&rdquo; period to reach an
approximate stationary start for the times series</p>
</td></tr>
<tr><td><code id="ts-models-AR2_+3A_innov">innov</code></td>
<td>
<p>a function with one parameter <code>n</code> that yields <code>n</code>
independent pseudo random numbers each time it is called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an AR(2) time series with specified parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(AR2(100, a1=0, a2=0.5), type="l")
</code></pre>

<hr>
<h2 id='ts-models-ARCH1'>Simulation of an ARCH(1) time series.</h2><span id='topic+ts-models-ARCH1'></span><span id='topic+ARCH1'></span>

<h3>Description</h3>

<p>Returns a simulated time series <code class="reqn">(Y_t)</code> that fulfills the following equation:
</p>
<p style="text-align: center;"><code class="reqn">Y_t = Z_t \sigma_t, \quad \sigma_t^2 = a_0 + a_1 Y_{t-1}^2 + \epsilon_t</code>
</p>

<p>where <code class="reqn">a_0</code> and <code class="reqn">a_1</code> are parameters and <code class="reqn">\epsilon_t</code> is
independent white noise with marginal distribution specified by the
parameter <code>innov</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARCH1(n, a0, a1, overhead = 500, innov = rnorm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts-models-ARCH1_+3A_n">n</code></td>
<td>
<p>length of the time series to be returned</p>
</td></tr>
<tr><td><code id="ts-models-ARCH1_+3A_a0">a0</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="ts-models-ARCH1_+3A_a1">a1</code></td>
<td>
<p>parameter</p>
</td></tr>
<tr><td><code id="ts-models-ARCH1_+3A_overhead">overhead</code></td>
<td>
<p>an integer specifying the &ldquo;warmup&rdquo; period to reach an
approximate stationary start for the times series</p>
</td></tr>
<tr><td><code id="ts-models-ARCH1_+3A_innov">innov</code></td>
<td>
<p>a function with one parameter <code>n</code> that yields <code>n</code>
independent pseudo random numbers each time it is called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an ARCH(1) time series with specified parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(ARCH1(100, a0=1/1.9, a1=0.9), type="l")

</code></pre>

<hr>
<h2 id='ts-models-QAR1'>Simulation of an QAR(1) time series.</h2><span id='topic+ts-models-QAR1'></span><span id='topic+QAR1'></span>

<h3>Description</h3>

<p>Returns a simulated time series <code class="reqn">(Y_t)</code> that fulfills the following equation:
</p>
<p style="text-align: center;"><code class="reqn">Y_t = \theta_1(U_t) Y_{t-1} + \theta_0(U_t),</code>
</p>

<p>where <code class="reqn">\theta_1</code> and <code class="reqn">\theta_0</code> are parameters and <code class="reqn">U_t</code> is
independent white noise with uniform <code class="reqn">[0,1]</code> marginal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QAR1(
  n,
  th1 = function(u) {     1.9 * ((u - 0.5)) },
  overhead = 1000,
  th0 = qnorm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts-models-QAR1_+3A_n">n</code></td>
<td>
<p>length of the time series to be returned</p>
</td></tr>
<tr><td><code id="ts-models-QAR1_+3A_th1">th1</code></td>
<td>
<p>parameter function with one argument <code>u</code> defined on
<code class="reqn">[0,1]</code></p>
</td></tr>
<tr><td><code id="ts-models-QAR1_+3A_overhead">overhead</code></td>
<td>
<p>an integer specifying the &ldquo;warmup&rdquo; period to reach an
approximate stationary start for the times series</p>
</td></tr>
<tr><td><code id="ts-models-QAR1_+3A_th0">th0</code></td>
<td>
<p>parameter function with one argument <code>u</code> defined on
<code class="reqn">[0,1]</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an QAR(1) time series with specified parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(QAR1(100), type="l")
</code></pre>

<hr>
<h2 id='Weight-class'>Interface Class to access different types of weighting functions.</h2><span id='topic+Weight-class'></span><span id='topic+Weight'></span>

<h3>Description</h3>

<p><code>Weights</code> is an S4 class that provides a common interface to
implementations of a weighting function <code class="reqn">W_n(\omega)</code>.
</p>


<h3>Details</h3>

<p>Currently three implementations are available:
(1) <code><a href="#topic+KernelWeight">KernelWeight</a></code>,
(2) <code><a href="#topic+LagKernelWeight">LagKernelWeight</a></code> and
(3) <code><a href="#topic+SpecDistrWeight">SpecDistrWeight</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>values</code></dt><dd><p>an array containing the weights.</p>
</dd>
<dt><code>descr</code></dt><dd><p>a description to be used in some plots.</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
