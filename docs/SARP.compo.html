<!DOCTYPE html><html><head><title>Help for package SARP.compo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SARP.compo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arbre.Mp'>
<p>Grouping composants by changes in cut-off separation</p></a></li>
<li><a href='#BpLi'><p>Circadian Genes Expression in Bipolar Disorder Patients</p></a></li>
<li><a href='#calc.rapports'>
<p>Compute all pairwise ratios of a set of variables</p></a></li>
<li><a href='#choisir.seuil'>
<p>Cut-off selection by simulations</p></a></li>
<li><a href='#choisir.seuil.equiv'>
<p>Cut-off selection by simulations, in the context of equivalence tests</p></a></li>
<li><a href='#conversions'>
<p>Convert between matrix and data-frame format</p></a></li>
<li><a href='#coupures.Mp'>
<p>Finding cut-offs for graph disjonctions</p></a></li>
<li><a href='#creer_data.frame'>
<p>Create p-values data-frame from pairwise tests of all possible</p>
ratios of a compositional vector</a></li>
<li><a href='#creer_graphe'>
<p>Create a graph using a set of p-values from pairwise tests</p></a></li>
<li><a href='#creer_matrice'>
<p>Create p-values matrix from pairwise tests of all possible</p>
ratios of a compositional vector</a></li>
<li><a href='#distances'>
<p>Simulate the distribution of maximal minimal distances in a random graph</p></a></li>
<li><a href='#equivalence'><p>Utility function to obtain p-value for equivalence tests on</p>
individual ratios</a></li>
<li><a href='#fichiers'>
<p>Create and read a file of p-values for all pairwise tests of all possible</p>
ratios of a compositional vector</a></li>
<li><a href='#GADL1'><p>Gene expression change in bipolar disorder</p></a></li>
<li><a href='#generef'><p>Expression level of candidate reference genes</p></a></li>
<li><a href='#modele'>
<p>Create a compositional model for simulations</p></a></li>
<li><a href='#poteries'><p>Composition of Roman poteries</p></a></li>
<li><a href='#puissance'>
<p>Estimate the power and the type-I error of the disjoint-subgraphs method</p></a></li>
<li><a href='#SCH23390'><p>Effect of MDMA and SCH23390 on gene expression</p></a></li>
<li><a href='#tests'>
<p>Utility functions to obtain p-values from tests on individual ratios</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network-Based Interpretation of Changes in Compositional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emmanuel Curis &lt;emmanuel.curis@parisdescartes.fr&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of functions to interpret changes in
 compositional data based on a network representation of all pairwise ratio
 comparisons: computation of all pairwise ratio, construction of a
 p-value matrix of all pairwise tests of these ratios between
 conditions, conversion of this matrix to a network.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lme4</td>
</tr>
<tr>
<td>Depends:</td>
<td>igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>car</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 09:16:59 UTC; curis</td>
</tr>
<tr>
<td>Author:</td>
<td>Emmanuel Curis <a href="https://orcid.org/0000-0001-8382-1493"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='arbre.Mp'>
Grouping composants by changes in cut-off separation
</h2><span id='topic+arbre.Mp'></span><span id='topic+plot.Arbre'></span>

<h3>Description</h3>

<p> These functions construct a tree based on the successive
disjunctions between nodes of the graph when increasing the cut-off value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arbre.Mp( Mp, en.log = FALSE, reference = NA, complement = FALSE )

## S3 method for class 'Arbre'
plot(x, seuil.p = 0.05,
                     xlab = "Composant",
                     ylab = if ( TRUE == en.log ) "-log seuil" else "Seuil",
                     col.seuil = "red"  , lwd.seuil = 1, lty.seuil = 1,
                     horiz = FALSE, center = TRUE, edge.root = TRUE,
                     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arbre.Mp_+3A_mp">Mp</code></td>
<td>

<p>A square, symmetric matrix containing <em>p</em>-values. Element
in row <code class="reqn">i</code> and line <code class="reqn">j</code> should contain the <em>p</em>-value
for testing the <code class="reqn">\frac{i}{j}</code> ratio. The diagonal is ignored.
</p>
</td></tr>
<tr><td><code id="arbre.Mp_+3A_en.log">en.log</code></td>
<td>

<p>If <code>TRUE</code>, <em>p</em>-values are log-transformed (using decimal
logarithm) to construct the tree. It does not change the tree
structure, it only helps visualisation of the small <em>p</em>-value
part of the tree.
</p>
</td></tr>
<tr><td><code id="arbre.Mp_+3A_reference">reference</code></td>
<td>
<p>Either <code>NA</code> (the default) or a vector giving the
names of reference genes. Corresponding leaves will then be drawn in
orange, whereas leaves for genes of interests will be drawn in
palegreen (like graphs).</p>
</td></tr>
<tr><td><code id="arbre.Mp_+3A_complement">complement</code></td>
<td>

<p>A logical. If TRUE, the tree is built using the complement of the
graph, as when using equivalence test to build the graph.
</p>
</td></tr>
<tr><td><code id="arbre.Mp_+3A_x">x</code></td>
<td>
<p>The tree to be drawn</p>
</td></tr>
<tr><td><code id="arbre.Mp_+3A_seuil.p">seuil.p</code></td>
<td>

<p>Selected cut-off for analysis. Can also be a <code>SARPcompo.H0</code>
object, as returned by <code><a href="#topic+choisir.seuil">choisir.seuil</a></code>, in which case
the bounds of the confidence interval are also drawn, with dashed
lines by default.
</p>
</td></tr>
<tr><td><code id="arbre.Mp_+3A_xlab">xlab</code>, <code id="arbre.Mp_+3A_ylab">ylab</code></td>
<td>

<p>Legends for the axes
</p>
</td></tr>
<tr><td><code id="arbre.Mp_+3A_col.seuil">col.seuil</code>, <code id="arbre.Mp_+3A_lwd.seuil">lwd.seuil</code>, <code id="arbre.Mp_+3A_lty.seuil">lty.seuil</code></td>
<td>

<p>Graphical parameters for drawing the analysis cut-off
</p>
</td></tr>
<tr><td><code id="arbre.Mp_+3A_horiz">horiz</code>, <code id="arbre.Mp_+3A_center">center</code>, <code id="arbre.Mp_+3A_edge.root">edge.root</code></td>
<td>
<p> Options from
<code><a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a></code> with different defaults or
needed for complementary plottings.  If <code>TRUE</code>, the tree is
drawn, respectivally, horizontally instead of vertically, with edges
&ldquo;centered&rdquo;, and with edge to the root node. See the
documentation from <code><a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a></code> for details.
</p>
</td></tr>
<tr><td><code id="arbre.Mp_+3A_...">...</code></td>
<td>

<p>Additionnal parameters for <code><a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a></code>,
which is used internally.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By increasing the cut-off from 0 to 1, more and more edges between
nodes are removed, and disjoint subgraphs appear. This can be used to
build a tree of the composants, with nodes of the tree corresponding
to the apparition of a new distinct subgraph. Leafs of the tree are
the individual components. 
</p>


<h3>Value</h3>

<p> The <code>arbre.Mp</code> function returns a dendrogram.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+creer.Mp">creer.Mp</a></code> to create a matrix of <em>p</em>-values for all
possible ratios of a compositional vector.
</p>
<p><code><a href="#topic+grf.Mp">grf.Mp</a></code> to convert such a matrix to a graph, once a
cut-off is selected.
</p>
<p><code><a href="#topic+coupures.Mp">coupures.Mp</a></code> to obtain the set of <em>p</em>-values
corresponding to the nodes of the tree, that is to the apparition of
new sets of composants.
</p>
<p><code><a href="stats.html#topic+plot.dendrogram">plot.dendrogram</a></code> and
<code><a href="stats.html#topic+as.dendrogram">as.dendrogram</a></code> for more details on dendrogram
drawing and structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the potery data set
   data( poteries )

   # Compute one-way ANOVA p-values for all ratios in this data set   
   Mp &lt;- creer.Mp( poteries, c( 'Al', 'Na', 'Fe', 'Ca', 'Mg' ),
                   f.p = anva1.fpc, v.X = 'Site' )

   # Build the tree (in log scale, p-values are all &lt; 0.01)
   arbre &lt;- arbre.Mp( Mp, en.log = TRUE )

   # It is a dendrogram as defined in the cluster package
   str( arbre )
   class( arbre )

   # Drawing this tree
   plot( arbre )
</code></pre>

<hr>
<h2 id='BpLi'>Circadian Genes Expression in Bipolar Disorder Patients</h2><span id='topic+BpLi_J2'></span><span id='topic+BpLi_J4'></span>

<h3>Description</h3>

<p>These two datasets give the expression level of main circadian genes
in lymphoblastoid cells from bipolar disorder patients, as determined
by qRT-PCR. Results are expressed in cycle thresholds (CT) units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BpLi_J2)
data(BpLi_J4)
</code></pre>


<h3>Format</h3>

<p>Each dataset is a data frame with 78 rows and 26 columns. Each
row give the RNA quantification of circadian and control genes for
lymphoblastoid cells of a given patient, either with or without
lithium in the culture medium.
</p>

<table>
<tr>
 <td style="text-align: right;">
    Phenotype </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> Patient phenotype, either responding (R) or not
    (NR) to lithium </td>
</tr>
<tr>
 <td style="text-align: right;">
    Patient </td><td style="text-align: left;"> integer </td><td style="text-align: left;"> Patient code </td>
</tr>
<tr>
 <td style="text-align: right;">
    Li </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> Is lithium present (Oui) or not (Non) in the
    culture medium of the cells </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>Other columns are the different circadian genes and reference genes
expression levels, expressed as quantities in arbitrary units after
quantitative reverse transcription PCR assays, using the Syber Green
technology.  Three sets of assays were done, using three
different dilutions according to the explored gene: 1/20 (PER3,
BHLHE41, NR1D1, DBP), 1/100 (GSK3b, RORA, PER1, PER2, CLOCK, ARNTL,
CRY2, BHLHE40) and 1/200 (ARNTL2, TIMELESS, CRY1, CSNK1E). The
numerical suffixe after the reference gene name (SDHA or HPRT) gives
this dilution level &ndash; for instance, SDHA_20 is for the 1/20 dilution
level, HRPT_100 for the 1/100 level...
</p>
<p>Patients were classified as presenting a good response (R) or a lack
of responce (NR) to lithium treatment based on the ALDA scale, see the
original publication for details.  Lymphoblastoid cells from each
patients, obtained from blood samples, were cultivated for 2 (BpLi_J2)
or 4 (BpLi_J4) days either with or without LiCl.
</p>


<h3>Source</h3>

<p>Data courtesy allowed to be included in the
package, by Cynthia Marie-Claire.
</p>


<h3>References</h3>

<p>Geoffrey, P. A., Curis E., Courtin, C., Moreira, J., Morvillers, T.,
Etain, B., Laplanche, J.-L., Bellivier, F. and Marie-Claire,
C. (2017).  Lithium response in bipolar disorders and core clock genes
expression. World J Biol Psychiatry, doi: 10.1080/15622975.2017.1282174.
</p>

<hr>
<h2 id='calc.rapports'>
Compute all pairwise ratios of a set of variables
</h2><span id='topic+calc.rapports'></span>

<h3>Description</h3>

<p>This function computes all pairwise ratios or differences of a set of
variables in a given data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.rapports( d, noms, log = FALSE, isoler = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.rapports_+3A_d">d</code></td>
<td>

<p>The data frame that contains the variables. Other objects will be
coerced as data frames using <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>
</td></tr>
<tr><td><code id="calc.rapports_+3A_noms">noms</code></td>
<td>

<p>A character vector containing the column names of the compositional
variables to be used for ratio computations. Names absent from the
data frame will be ignored with a warning.
</p>
<p>Optionnally, an integer vector containing the column numbers can be
given instead. They will be converted to column names before further
processing.
</p>
</td></tr>
<tr><td><code id="calc.rapports_+3A_log">log</code></td>
<td>

<p>If <code>TRUE</code>, values in the columns are assumed to be
log-transformed, and consequently ratios are computed as differences
of the columns. The result is in the log scale.
</p>
<p>If <code>FALSE</code>, values are assumed to be raw data and ratios are
computed directly.
</p>
</td></tr>
<tr><td><code id="calc.rapports_+3A_isoler">isoler</code></td>
<td>
<p> If <code>TRUE</code>, the result data frame will not include
the original values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to compute all pairwise ratio of a set of numerical
variables.  If non-numerical variables are given in the list of
variables, they will be ignores with a warning.
</p>
<p>Since the ratio of variables i and j is the inverse of the ratio of
variables j and i, only one of them is computed. The order is
determined by the order of the variables in <code>noms</code>. In matrix
notations, only the upper right matrix is computed, withour the diagonal.
</p>


<h3>Value</h3>

<p> These function returns the original data.frame with additional
columns corresponding to all pairwise ratios added as the last columns
of the data.frame.
</p>
<p>These variables have their name constructed as the concatenation of
the names of the two variables used, the first one being at the
numerator, separated with a dot and with the additional suffix .r (or
.r.log is working on difference of logarithms).
</p>
<p>Their order is determined by the order given in noms: the first
variable of the list, V1, is used to compute ratios with all others
(V1/V2, V1/V3 and so on). Then the second one is used for ratios
further ones (V2/V3 and so on), and so on until the last one.
</p>


<h3>Note</h3>

<p>This function is mainly for designing a step-by-step analysis or
control purposes. To avoid waste of memory, most of the functions in
the package actually compute &ldquo;on fly&rdquo; the ratios when
constructing the matrix or the data frame of p-values.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+creer.Mp">creer.Mp</a></code> to create a matrix of p-values for all pairwise
tests of ratio changes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the potery data set
   data( poteries )

   # Compute all ratios in the potery data set   
   d.r &lt;- calc.rapports( d = poteries, noms = c( 'Al', 'Fe', 'Mg', 'Ca',
   'Na' ) )
   names( d.r )
   head( d.r )

   identical( d.r$Al.Fe.r, d.r$Al / d.r$Fe )
</code></pre>

<hr>
<h2 id='choisir.seuil'>
Cut-off selection by simulations
</h2><span id='topic+choisir.seuil'></span><span id='topic+print.SARPcompo.H0'></span><span id='topic+plot.SARPcompo.H0'></span>

<h3>Description</h3>

<p>Obtaining the optimal p-value cut-off for individual tests to achieve a
given Type I error level of obtaining disjoint components of the graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choisir.seuil( n.genes,
               taille.groupes = c( 10, 10 ),
               alpha.cible = 0.05,
               seuil.p = (5:30)/100,
               B = 3000, conf.level = 0.95,
               f.p = student.fpc, frm = R ~ Groupe, v.X = 'Groupe',
               normaliser = FALSE, en.log = TRUE,
               n.quantifies = n.genes, masque,
               n.coeurs = 1,
               sigma = rep( 1, n.genes ),
               ... ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choisir.seuil_+3A_n.genes">n.genes</code></td>
<td>

<p>Number of genes to be quantified simultaneously
</p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_taille.groupes">taille.groupes</code></td>
<td>
<p> An integer vector containing the sample size
for each group. The number of groups is determined by the length of
this vector. Unused if <code>masque</code> is provided.  </p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_alpha.cible">alpha.cible</code></td>
<td>
<p> The target type I error level of obtaining
disjoint subnetworks under the null hypothesis that gene expressions
are the same in all groups.  Should be between 0 and 1.  </p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_seuil.p">seuil.p</code></td>
<td>
<p> A numeric vector of candidate cutoffs. Values outside
the [0,1] interval are automatically removed.  The default (from
0.05 to 0.30) is suited for a target type I error of 0.05 and less
than 30 genes, roughly.  </p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_b">B</code></td>
<td>

<p>How many simulations to do.
</p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_conf.level">conf.level</code></td>
<td>

<p>The confidence level of the interval given as a result (see Details).
</p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_f.p">f.p</code></td>
<td>

<p>The function to use for individual tests of each ratio. See
<code><a href="#topic+creer.Mp">creer.Mp</a></code> for details.
</p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_frm">frm</code></td>
<td>
<p> The formula to use.  The default is suited for the 
structure of the simulated data, with R the ratio and Groupe the
variable with group membership.  </p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_v.x">v.X</code></td>
<td>
<p> The name of the grouping variable.  The default is suited
for the structure of the simulated data, with R the ratio and Groupe
the variable with group membership.  </p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_normaliser">normaliser</code></td>
<td>

<p>Should the simulated data by normalised, that is should their sum be
equal to 1? Since ratio are insensitive to the normalisation (by
contrast with individual quantities), it is a useless step for usual
designs, hence the default.
</p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_en.log">en.log</code></td>
<td>

<p>If <code>TRUE</code>, generated data are seen as log of quantities, hence the
normalisation step is performed after exponentiation of the data and
data are converted back in log.
</p>
<p>The option is also used in the call of <code><a href="#topic+creer.Mp">creer.Mp</a></code>.
</p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_n.quantifies">n.quantifies</code></td>
<td>
<p> The number of quantified genes amongst the
<code>n.genes</code> simulated. Must be at most equal to <code>n.genes</code>,
which is the default.  </p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_masque">masque</code></td>
<td>
<p>A data.frame containing the values of needed covariates
for all replicates. If missing, a one-column data.frame generated
using <code>taille.groupes</code>, the column (named &lsquo;Groupe&rsquo;)
containing values &lsquo;G1&rsquo; repeated <code>taille.groupes[ 1 ]</code>
times, &lsquo;G2&rsquo; repeated <code>taille.groupes[ 2 ]</code> times and so
on.</p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_n.coeurs">n.coeurs</code></td>
<td>
<p>The number of CPU cores to use in computation, with
parallelization using forks (does not work on Windows) with the help
of the parallel package.</p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_sigma">sigma</code></td>
<td>
<p>A vector of length <code>n.genes</code> giving the standard
deviation (in the log scale) to use for each gene. By default, all
genes have the same standard deviation. Note that only the ratio
between standard deviations brings information.</p>
</td></tr>
<tr><td><code id="choisir.seuil_+3A_...">...</code></td>
<td>
<p>additional arguments, to be used by the analysis function
f.p</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The <code>choisir.seuil</code> function simulates <code>B</code> datasets
of <code>n.genes</code> &ldquo;quantities&rdquo; measured several times, under
the null hypothesis that there is only random variations between
samples. For each of these <code>B</code> datasets, <code><a href="#topic+creer.Mp">creer.Mp</a></code>
is called with the provided test function, then converted to a graph
using in turn all cut-offs given in  <code>seuil.p</code> and the number of
components of the graph is determined. Having more than one is a type
I error.
</p>
<p>For each cut-off in <code>seuil.p</code>, the proportion of false-positive
is then determined, along with its confidence interval (using the
exact, binomial formula). The optimal cut-off to achieve the target
type I error is then found by linear interpolation.
</p>
<p>Simulation is done assuming a log-normal distribution, with a
reduced, centered Gaussian on the log scale. Since under the null
hypothesis nothing changes between the groups, the only needed
informations is the total number of values for a given gene, which is
determined from the number of rows of <code>masque</code>.
All columns of <code>masque</code> are transfered to the analysis function,
so simulation under virtually any experimental design should be
possible, as far as a complete null hypothesis is wanted (not any
effect of any covariate).
</p>


<h3>Value</h3>

 <p><code>choisir.seuil</code> returns a data.frame with four columns,
corresponding to the candidate cut-offs, the corresponding estimated
type-I error and its lower and upper confidence bounds, and attributes
giving the estimated optimal cut-off, its confidence interval and
details on simulation condition. This data.frame has the additional
class <code>SARPcompo.H0</code>, allowing specific <code>print</code> and
<code>plot</code> methods to be used.
</p>


<h3>Warning</h3>

<p> The simulated ratios are stored in a column called R,
appended to the simulated data.frame. For this reason, do not use any
column of this name in the provided masque: it would be overwritten
during the simulation process.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+creer.Mp">creer.Mp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # What would be the optimal cut-off for 10 genes quantified in two
   #  groups of 5 replicates?
   # For speed reason, only 50 simulations are done here,
   #  but obviously much more are needed to have a good estimate f the cut-off.

   seuil &lt;- choisir.seuil( 10, c( 5, 5 ), B = 50 )
   seuil

   # Get the cut-off and its confidence interval
   attr( seuil, "seuil" )

   # Plot the results
   plot( seuil )
</code></pre>

<hr>
<h2 id='choisir.seuil.equiv'>
Cut-off selection by simulations, in the context of equivalence tests
</h2><span id='topic+choisir.seuil.equiv'></span>

<h3>Description</h3>

<p>Obtaining the optimal p-value cut-off for individual tests to achieve a
given Type I error level of obtaining connected nodes in the graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choisir.seuil.equiv( n.genes, taille.groupes,
                     mu = 10, sigma = 0.5, Delta = 0.5,
                     alpha.cible = 0.05,
                     seuil.p = (10:40)/100,
                     B = 3000, conf.level = 0.95,
                     f.p = equiv.fpc,
                     en.log = TRUE,
                     n.coeurs = 1,
                     ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choisir.seuil.equiv_+3A_n.genes">n.genes</code></td>
<td>

<p>Number of genes to be quantified simultaneously
</p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_taille.groupes">taille.groupes</code></td>
<td>
<p> An integer vector containing the sample size
for each group. The number of groups is determined by the length of
this vector. Unused if <code>masque</code> is provided.  </p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_mu">mu</code></td>
<td>
<p>A numeric vector giving the mean amount for each component
in the first condition, in the log scale (<code class="reqn">\mu</code>\). If a single
value is provided, it is used for each component. Otherwise, the
length of the vector must be equal to the number of components.
</p>
<p>It can also be a two-lines matrix giving the mean amounts for each
component (columns) in the first (firt row) and second (second row)
condition.
</p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_sigma">sigma</code></td>
<td>
<p>A numeric vector giving the standard deviation for the
amount of each component in both conditions, in the log scale
(<code class="reqn">\sigma</code>\). If a single value is provided, it is used for each
component.  Otherwise, the length of the vector must be equal to the
number of components.
</p>
<p>It can also be a two-lines matrix giving the mean amounts for each
component (columns) in the first (firt row) and second (second row)
condition.
</p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_delta">Delta</code></td>
<td>
<p>The limit for the equivalence region, <code class="reqn">\Delta</code>, in
the log scale.</p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_alpha.cible">alpha.cible</code></td>
<td>
<p> The target type I error level of obtaining
disjoint subnetworks under the null hypothesis that gene expressions
are the same in all groups.  Should be between 0 and 1.  </p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_seuil.p">seuil.p</code></td>
<td>
<p> A numeric vector of candidate cutoffs. Values outside
the [0,1] interval are automatically removed.  The default (from
0.05 to 0.30) is suited for a target type I error of 0.05 and less
than 30 genes, roughly.  </p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_b">B</code></td>
<td>
<p> How many simulations to do.  </p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_conf.level">conf.level</code></td>
<td>
<p> The confidence level of the interval given as a
result (see Details).  </p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_f.p">f.p</code></td>
<td>
<p> The function to use for individual tests of each
ratio. See <code><a href="#topic+creer.Mp">creer.Mp</a></code> for details.  </p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_en.log">en.log</code></td>
<td>
<p> If <code>TRUE</code>, generated data are seen as log of
quantities. The option is used in the call of
<code><a href="#topic+creer.Mp">creer.Mp</a></code>.  </p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_n.coeurs">n.coeurs</code></td>
<td>
<p>The number of CPU cores to use in computation, with
parallelization using forks (does not work on Windows) with the help
of the parallel package.</p>
</td></tr>
<tr><td><code id="choisir.seuil.equiv_+3A_...">...</code></td>
<td>
<p>additional arguments, to be used by the analysis function
f.p</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The <code>choisir.seuil.equiv</code> function simulates <code>B</code>
datasets of <code>n.genes</code> &ldquo;quantities&rdquo; measured several times,
under the null hypothesis that variations between samples of two
conditions are given by the difference between the two rows of the
<code class="reqn">\mu</code> matrix.  If <code class="reqn">\mu</code> was given as a single row (or a single
value), the second row is defined as <code class="reqn">(\mu, \mu + \Delta, \mu +
  2\Delta\dots)</code> &ndash; correspondong to the null hypothesis that all
components have a different change between the two conditions, and
that this change is equal to the equivalence region limit
(<code class="reqn">\Delta</code>). For each of these <code>B</code> datasets,
<code><a href="#topic+creer.Mp">creer.Mp</a></code> is called with the provided test function, then
converted to a graph using in turn all cut-offs given in
<code>seuil.p</code> and the number of edges of the graph is
determined. Having at least one edge is a type I error, since under
the null hypothesis there is no couple of genes having the same
change.
</p>
<p>For each cut-off in <code>seuil.p</code>, the proportion of false-positive
is then determined, along with its confidence interval (using the
exact, binomial formula). The optimal cut-off to achieve the target
type I error is then found by linear interpolation.
</p>
<p>Data are generated using a normal (Gaussian) distribution,
independantly for each component and each condition.
</p>


<h3>Value</h3>

 <p><code>choisir.seuil.equiv</code> returns a data.frame with four
columns, corresponding to the candidate cut-offs, the corresponding
estimated type-I error and its lower and upper confidence bounds, and
attributes giving the estimated optimal cut-off, its confidence
interval and details on simulation condition. This data.frame has the
additional class <code>SARPcompo.H0</code>, allowing specific <code>print</code>
and <code>plot</code> methods to be used.  </p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+creer.Mp">creer.Mp</a></code>, <code><a href="#topic+equiv.fpc">equiv.fpc</a></code>.
</p>
<p>See <code><a href="#topic+choisir.seuil">choisir.seuil</a></code> for the case of difference tests and
disjoing subgraphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # What would be the optimal cut-off for 5 genes quantified in two
   #  groups of 5 replicates?
   # Null hypothesis : mean = 0, sd = 1, Delta = 2
   # For speed reason, only 50 simulations are done here,
   #  but obviously much more are needed to have a good estimate f the cut-off.

   seuil &lt;- choisir.seuil.equiv( 5, c( 5, 5 ),
                                 mu = 1, sigma = 1, Delta = 1,
                                 B = 50 )
   seuil

   # Get the cut-off and its confidence interval
   attr( seuil, "seuil" )

   # Plot the results
   plot( seuil )
</code></pre>

<hr>
<h2 id='conversions'>
Convert between matrix and data-frame format
</h2><span id='topic+conversions'></span><span id='topic+Mp.DFp'></span><span id='topic+DFp.Mp'></span>

<h3>Description</h3>

<p> These functions convert all pairwise ratio tests between
the matrix format and the data.frame format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mp.DFp(DFp, col.noms = c( 1, 2 ), col.p = 'p')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversions_+3A_dfp">DFp</code></td>
<td>
<p>Results in the data.frame format.</p>
</td></tr>
<tr><td><code id="conversions_+3A_col.noms">col.noms</code></td>
<td>
<p>A length two character vector giving the columns in
the data.frame format that contain the names of the two components
of which the ratio is tested. If converting from a data.frame, can
be given by number.</p>
</td></tr>
<tr><td><code id="conversions_+3A_col.p">col.p</code></td>
<td>
<p>A length one character vector giving the column
containing the p-values of the test in the data.frame format. If
converting from a data.frame, can be given by number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix format is more convenient for manipulations like finding
cut-off probabilities or building the hierarchical tree of the
components.  However, it can only store one value per couple and is
more memory consuming.
</p>
<p>The data.frame format is more efficient for computations, since it
allows to store several results at once. It can also be easily saved
and read using text-files and <code><a href="utils.html#topic+read.table">read.table</a></code> or
<code><a href="utils.html#topic+write.table">write.table</a></code>. However, finding the hierarchical tree of
components or building the graph is not so straightforward.
</p>
<p>These utilitary functions allow to convert between the two formats.
</p>


<h3>Value</h3>

<p>The results in the other format: a matrix for <code>Mp.DFp</code> and a
3-columns data.frame for <code>DFp.Mp</code>.
</p>
<p>In the matrix form, components will be sorted by alphabetical order.
</p>


<h3>Warning</h3>

<p>When converting a data.frame to a matrix, there is no control that all
possible combinations are present once, and only once, in the
data.frame.  Missing combinations will have 0 in the matrix;
combinations present several time will have the value of the last
replicate.
</p>
<p>When converting a matrix to a data.frame, the diagonal is not included
in the data.frame. The matrix is expected to be symmetric, and only
the upper right part is used.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+creer.Mp">creer.Mp</a></code> to create a matrix of <em>p</em>-values for all
possible ratios of a compositional vector.
</p>
<p><code><a href="#topic+creer.DFp">creer.DFp</a></code> to create a data.frame of <em>p</em>-values for
all possible ratios of a compositional vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # load the potery data set data( poteries )

</code></pre>

<hr>
<h2 id='coupures.Mp'>
Finding cut-offs for graph disjonctions
</h2><span id='topic+coupures.Mp'></span><span id='topic+plot.Coupures'></span>

<h3>Description</h3>

<p> These functions detect the experimental cut-offs to create
distinct subgraphs, and propose adapted graphical representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coupures.Mp( Mp )

## S3 method for class 'Coupures'
plot(x, seuil.p = 0.05, en.log = TRUE,
                        xlab = "Seuil de p", ylab = "Nombre de composantes",
                        col.trait = "black", lwd.trait = 1, lty.trait = 1,
                        col.seuil = "red"  , lwd.seuil = 1, lty.seuil = 1,
                        pch.fin = 19, cex.fin = 1, col.fin ="darkgreen",
                        pch.deb = ")", cex.deb = 1, col.deb = "darkgreen",
                        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coupures.Mp_+3A_mp">Mp</code></td>
<td>

<p>A square, symmetric matrix containing <em>p</em>-values. Element
in row <code class="reqn">i</code> and line <code class="reqn">j</code> should contain the <em>p</em>-value
for testing the <code class="reqn">\frac{i}{j}</code> ratio. The diagonal is ignored.
</p>
</td></tr>
<tr><td><code id="coupures.Mp_+3A_x">x</code></td>
<td>
<p>The set of critical values, as obtained by <code>coupures.Mp</code></p>
</td></tr>
<tr><td><code id="coupures.Mp_+3A_seuil.p">seuil.p</code></td>
<td>

<p>Selected cut-off for analysis. Can also be a <code>SARPcompo.H0</code>
object, as returned by <code><a href="#topic+choisir.seuil">choisir.seuil</a></code>, in which case
the bounds of the confidence interval are also drawn, with dashed
lines by default.
</p>
</td></tr>
<tr><td><code id="coupures.Mp_+3A_en.log">en.log</code></td>
<td>

<p>If <code>TRUE</code>, the <em>p</em>-values axis uses a decimal logarithm
scale. It may help visualisation of the small critical <em>p</em>-values.
</p>
</td></tr>
<tr><td><code id="coupures.Mp_+3A_xlab">xlab</code>, <code id="coupures.Mp_+3A_ylab">ylab</code></td>
<td>

<p>Legends for the axes
</p>
</td></tr>
<tr><td><code id="coupures.Mp_+3A_col.trait">col.trait</code>, <code id="coupures.Mp_+3A_lwd.trait">lwd.trait</code>, <code id="coupures.Mp_+3A_lty.trait">lty.trait</code>, <code id="coupures.Mp_+3A_pch.fin">pch.fin</code>, <code id="coupures.Mp_+3A_cex.fin">cex.fin</code>, <code id="coupures.Mp_+3A_col.fin">col.fin</code>, <code id="coupures.Mp_+3A_pch.deb">pch.deb</code>, <code id="coupures.Mp_+3A_cex.deb">cex.deb</code>, <code id="coupures.Mp_+3A_col.deb">col.deb</code></td>
<td>

<p>Graphical parameters for drawing the number of components in
function of the cut-off. &lsquo;trait&rsquo; refers to the function
itself, &lsquo;deb&rsquo; to the first point of a region of constant
components number (that does not belong to it: the function is
right-discontinuous) and &lsquo;fin&rsquo; to the last point of this
region (that belongs to it)
</p>
</td></tr>
<tr><td><code id="coupures.Mp_+3A_col.seuil">col.seuil</code>, <code id="coupures.Mp_+3A_lwd.seuil">lwd.seuil</code>, <code id="coupures.Mp_+3A_lty.seuil">lty.seuil</code></td>
<td>

<p>Graphical parameters for drawing the analysis cut-off
</p>
</td></tr>
<tr><td><code id="coupures.Mp_+3A_...">...</code></td>
<td>

<p>Additionnal parameters for <code><a href="graphics.html#topic+plot">plot</a></code>,
which is used internally.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By increasing the cut-off from 0 to 1, more and more edges between
nodes are removed, and disjoint subgraphs appear. This function
detects in a matrix of <em>p</em>-values which are the &ldquo;critical&rdquo;
ones, that is the one for which the number of components changes.
</p>
<p>Because the edge removal is defined by <code class="reqn">p &lt; cut-off</code>, the cut-off
returned for a given number of components is to be understand as the
maximal one that gives this number of components.
</p>
<p>The <code>plot</code> method allows to visualize the evolution of the number
of components with the cut-off, and writes the critical cut-off values.
</p>


<h3>Value</h3>

<p> The <code>coupures.Mp</code> function returns a data.frame with
additionnal class &lsquo;Coupures&rsquo;. It contains three columns: one
with the <em>p</em>-value cut-offs, one with the opposite of their
decimal logarithm and one with the number of components when using
exactly this cut-off. The additionnal class allows to provide a
<code>plot</code> method.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+creer.Mp">creer.Mp</a></code> to create a matrix of <em>p</em>-values for all
possible ratios of a compositional vector.
</p>
<p><code><a href="#topic+grf.Mp">grf.Mp</a></code> to convert such a matrix to a graph, once a
cut-off is selected.
</p>
<p><code><a href="#topic+arbre.Mp">arbre.Mp</a></code> to convert such a matrix to a classification
tree of the components of the compositional vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the potery data set
   data( poteries )

   # Compute one-way ANOVA p-values for all ratios in this data set   
   Mp &lt;- creer.Mp( poteries, c( 'Al', 'Na', 'Fe', 'Ca', 'Mg' ),
                   f.p = anva1.fpc, v.X = 'Site' )

   # Where would be the cut-offs?
   seuils &lt;- coupures.Mp( Mp )
   seuils

   # Drawing this, in log10 scale
   plot( seuils, en.log = TRUE )
</code></pre>

<hr>
<h2 id='creer_data.frame'>
Create p-values data-frame from pairwise tests of all possible
ratios of a compositional vector
</h2><span id='topic+creer_data.frame'></span><span id='topic+creer.DFp'></span><span id='topic+create.DFp'></span>

<h3>Description</h3>

<p>This function performs hypothesis testing on all possible pairwise
ratios or differences of a set of variables in a given data frame, and
store their results in a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>creer.DFp( d, noms, f.p = student.fpc,
           log = FALSE, en.log = !log,
           nom.var = 'R',
           noms.colonnes = c( "Cmp.1", "Cmp.2", "p" ),
           add.col = "delta", n.coeurs = 1,
           ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="creer_data.frame_+3A_d">d</code></td>
<td>

<p>The data frame that contains the compositional variables. Other
objects will be coerced as data frames using
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> </p>
</td></tr>
<tr><td><code id="creer_data.frame_+3A_noms">noms</code></td>
<td>

<p>A character vector containing the column names of the compositional
variables to be used for ratio computations. Names absent from the
data frame will be ignored with a warning.
</p>
<p>Optionnally, an integer vector containing the column numbers can be
given instead. They will be converted to column names before further
processing.
</p>
</td></tr>
<tr><td><code id="creer_data.frame_+3A_f.p">f.p</code></td>
<td>

<p>An R function that will perform the hypothesis test on a single
ratio (or log ratio, depending on <code>log</code> and <code>en.log</code>
values).
</p>
<p>This function should return a numeric vector, of which the first one
will typically be the p-value from the test &mdash; see
<code><a href="#topic+creer.Mp">creer.Mp</a></code> for details. 
</p>
<p>Such functions are provided for several common situations, see
references at the end of this manual page.
</p>
</td></tr>
<tr><td><code id="creer_data.frame_+3A_log">log</code></td>
<td>

<p>If <code>TRUE</code>, values in the columns are assumed to be
log-transformed, and consequently ratios are computed as differences
of the columns. The result is in the log scale.
</p>
<p>If <code>FALSE</code>, values are assumed to be raw data and ratios are
computed directly.
</p>
</td></tr>
<tr><td><code id="creer_data.frame_+3A_en.log">en.log</code></td>
<td>
<p> If <code>TRUE</code>, the ratio will be log-transformed
before applying the hypothesis test computed by <code>f.p</code>. Don't
change the default unless you really know what you are doing.
</p>
</td></tr>
<tr><td><code id="creer_data.frame_+3A_nom.var">nom.var</code></td>
<td>
<p> A length-one character vector giving the name of the
variable containing a single ratio (or log-ratio). No sanity check
is performed on it: if you experience strange behaviour, check you
gave a valid column name, for instance using
<code><a href="base.html#topic+make.names">make.names</a></code>.
</p>
</td></tr>
<tr><td><code id="creer_data.frame_+3A_noms.colonnes">noms.colonnes</code></td>
<td>
<p> A length-three character vector giving the names
of, respectively, the two columns of the data frame that will contain
the components identifiers and of the column that will contain the
p-value from the test (the first value returned by <code>f.p</code>).
</p>
</td></tr>
<tr><td><code id="creer_data.frame_+3A_add.col">add.col</code></td>
<td>
<p>A character vector giving the names of additional
columns of the data.frame, used for storing additional return values
of <code>f.p</code> (all but the first one).
</p>
</td></tr>
<tr><td><code id="creer_data.frame_+3A_n.coeurs">n.coeurs</code></td>
<td>
<p>The number of CPU cores to use in computation, with
parallelization using forks (does not work on Windows) with the help
of the parallel package.</p>
</td></tr>
<tr><td><code id="creer_data.frame_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>f.p</code>, passed unchanged to
it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function constructs a data.frame with <code class="reqn">n\times
  (n-1)/2</code> rows, where <code>n = length( noms )</code> (after eventually
removing names in <code>noms</code> that do not correspond to numeric
variables). Each line of the data.frame  is the result of the
<code>f.p</code> function when applied on the ratio of variables whose names
are given in the first two columns (or on its log, if either <code>(log ==
  TRUE) &amp;&amp; (en.log == FALSE)</code> or <code>(log == FALSE) &amp;&amp; (en.log ==
  TRUE)</code>).
</p>


<h3>Value</h3>

<p> These function returns the data.frame obtained as described above.
</p>


<h3>Note</h3>

<p>Creating a data.frame seems slightly less efficient (in terms of
speed) than creating a dense matrix, so for compositionnal data with
only a few components and simple stastitical analysis were only a
single p-value is needed, consider using <code><a href="#topic+creer.Mp">creer.Mp</a></code>
instead.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p>Predefined <code>f.p</code> functions: <code><a href="#topic+anva1.fpc">anva1.fpc</a></code> for one-way
analysis of variance; <code><a href="#topic+kw.fpc">kw.fpc</a></code> for the non-parametric
equivalent (Kruskal-Wallis test).
</p>
<p><code><a href="#topic+grf.DFp">grf.DFp</a> to create a graphe from the obtained matrix.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the Circadian Genes Expression dataset, at day 4
   data( "BpLi_J4" )
   ng &lt;- names( BpLi_J4 )[ -c( 1:3 ) ] # Name of the genes
   
   # analysis function (complex design)
   #   1. the formula to be used
   frm &lt;- R ~  (1 | Patient) + Phenotype + Li + Phenotype:Li

   #   2. the function itself
   #    needs the lme4 package
   if ( TRUE == require( "lme4" ) ) {
     f.p &lt;- function( d, variable, ... ) {
          # Fit the model
          md &lt;- lmer( frm, data = d )

          # Get coefficients and standard errors
          cf &lt;- fixef( md )
          se &lt;- sqrt( diag( vcov( md ) ) )

          # Wald tests on these coefficients
          p &lt;- 2 * pnorm( -abs( cf ) / se )

          # Sending back the 4 p-values
          p
     }
 
     # CRAN does not like 'long' computations
     # =&gt; analyse only the first 6 genes
     #  (remove for real exemple!)
     ng &lt;- ng[ 1:6 ]

     # Create the data.frame with all results
     DF.p &lt;- creer.DFp( d = BpLi_J4, noms = ng,
                        f.p = f.p, add.col = c( 'p.NR', 'p.Li', 'p.I' ) )

     # Make a graphe from it and plot it
     #  for the interaction term, at the p = 0.2 threshold
     plot( grf.DFp( DF.p, p = 0.20, col.p = 'p.I' ) )
  }
</code></pre>

<hr>
<h2 id='creer_graphe'>
Create a graph using a set of p-values from pairwise tests
</h2><span id='topic+creer_graphe'></span><span id='topic+grf.Mp'></span><span id='topic+grf.DFp'></span><span id='topic+create.graphe'></span>

<h3>Description</h3>

<p> These functions construct an undirected graph, using the
igraph package, to represent and investigate the results of all
testing of all ratios of components of a compositional vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grf.Mp( Mp, p = 0.05, reference = NULL, groupes = NULL,
        complement = FALSE )

grf.DFp( DFp, col.noms = c( 1, 2 ), p = 0.05, col.p = 'p',
         reference = NULL, groupes = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="creer_graphe_+3A_mp">Mp</code></td>
<td>

<p>A square, symmetric matrix containing <em>p</em>-values. Element
in row <code class="reqn">i</code> and line <code class="reqn">j</code> should contain the <em>p</em>-value
for testing the <code class="reqn">\frac{i}{j}</code> ratio. The diagonal is ignored.
</p>
</td></tr>
<tr><td><code id="creer_graphe_+3A_dfp">DFp</code></td>
<td>

<p>A data frame containing at least three columns: two with component
names and one with <em>p</em>-values for the corresponding ratio.
</p>
</td></tr>
<tr><td><code id="creer_graphe_+3A_col.noms">col.noms</code></td>
<td>
<p> A length two vector giving the names of the two columns
containing the components names.
</p>
</td></tr>
<tr><td><code id="creer_graphe_+3A_p">p</code></td>
<td>
<p> The <em>p</em>-value cutoff for adding an edge between two
nodes.  See details.
</p>
</td></tr>
<tr><td><code id="creer_graphe_+3A_col.p">col.p</code></td>
<td>
<p> The name of the column containing the <em>p</em>-values to
use to create the graph.
</p>
</td></tr>  
<tr><td><code id="creer_graphe_+3A_reference">reference</code></td>
<td>

<p>A character vector giving the names of nodes that should be
displayed with a different color in the created graph.  These names
should match column names used in Mp. Typical use would be for
reference genes in qRT-PCR experiments.  By default, all nodes are
displayed in palegreen; reference nodes, if any, will be displayed
in orange. </p>
</td></tr>
<tr><td><code id="creer_graphe_+3A_groupes">groupes</code></td>
<td>
<p> A list of character vectors giving set of logically
related nodes, defining groups of nodes that will share common color.
Currently unimplemented.</p>
</td></tr>
<tr><td><code id="creer_graphe_+3A_complement">complement</code></td>
<td>

<p>A logical. If TRUE, the complement of the graph is returned. It
allows to construct graphs using equivalence tests, instead of
difference tests (that is, to keep an edge between two nodes if the
test is significant, instead of non-significant).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a compositional vector of <code class="reqn">n</code> components. These <code class="reqn">n</code>
are seen as the nodes of a graph. Nodes <code class="reqn">i</code> and <code class="reqn">j</code> will be
connected if and only if the <em>p</em>-value for the test of the
<code class="reqn">\frac{i}{j}</code> ratio is higher than the cutoff, <code>p</code> &ndash; that
is, if the test is <strong>not</strong> significant at the level <code class="reqn">p</code>.
</p>
<p>Strongly connected sets of nodes will represent components that share
a similar behaviour between the conditions tested, whereas unrelated
sets of nodes will have a different behaviour.
</p>


<h3>Value</h3>

<p> These function returns the created graph. It is an igraph object
on which any igraph function can be applied, including plotting,
and searching for graph components, cliques or communities.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+creer.Mp">creer.Mp</a></code> to create a matrix of <em>p</em>-values for all
possible ratios of a compositional vector.
</p>
<p><code><a href="#topic+creer.DFp">creer.DFp</a></code> to create a data.frame of <em>p</em>-values for all
possible ratios of a compositional vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the potery data set
   data( poteries )

   # Compute one-way ANOVA p-values for all ratios in this data set   
   Mp &lt;- creer.Mp( poteries, c( 'Al', 'Na', 'Fe', 'Ca', 'Mg' ),
                   f.p = anva1.fpc, v.X = 'Site' )
   Mp

   # Make a graphe from it and plot it
   plot( grf.Mp( Mp ) )
</code></pre>

<hr>
<h2 id='creer_matrice'>
Create p-values matrix from pairwise tests of all possible
ratios of a compositional vector
</h2><span id='topic+creer_matrice'></span><span id='topic+creer.Mp'></span><span id='topic+create.Mp'></span>

<h3>Description</h3>

<p>This function performs hypothesis testing on all possible pairwise
ratios or differences of a set of variables in a given data frame, and
store their results in a (symmetric) matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>creer.Mp( d, noms, f.p, log = FALSE, en.log = !log,
          nom.var = 'R', n.coeurs = 1, controles = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="creer_matrice_+3A_d">d</code></td>
<td>

<p>The data frame that contains the compositional variables. Other
objects will be coerced as data frames using
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> </p>
</td></tr>
<tr><td><code id="creer_matrice_+3A_noms">noms</code></td>
<td>

<p>A character vector containing the column names of the compositional
variables to be used for ratio computations. Names absent from the
data frame will be ignored with a warning.
</p>
<p>Optionnally, an integer vector containing the column numbers can be
given instead. They will be converted to column names before further
processing.
</p>
</td></tr>
<tr><td><code id="creer_matrice_+3A_f.p">f.p</code></td>
<td>

<p>An R function that will perform the hypothesis test on a single
ratio (or log ratio, depending on <code>log</code> and <code>en.log</code>
values).
</p>
<p>This function should return a single numerical value, typically the
p-value from the test.
</p>
<p>This function must accept at least two named arguments: <code>d</code>
that will contain the data frame containing all required variables
and <code>variable</code> that will contain the name of the column that
contains the (log) ratio in this data frame. All other needed
arguments can be passed through <code>...</code>.
</p>
<p>Such functions are provided for several common situations, see
references at the end of this manual page.
</p>
</td></tr>
<tr><td><code id="creer_matrice_+3A_log">log</code></td>
<td>

<p>If <code>TRUE</code>, values in the columns are assumed to be
log-transformed, and consequently ratios are computed as differences
of the columns. The result is in the log scale.
</p>
<p>If <code>FALSE</code>, values are assumed to be raw data and ratios are
computed directly.
</p>
</td></tr>
<tr><td><code id="creer_matrice_+3A_en.log">en.log</code></td>
<td>
<p> If <code>TRUE</code>, the ratio will be log-transformed
before applying the hypothesis test computed by <code>f.p</code>. Don't
change the default unless you really know what you are doing.
</p>
</td></tr>
<tr><td><code id="creer_matrice_+3A_nom.var">nom.var</code></td>
<td>
<p> A length-one character vector giving the name of the
variable containing a single ratio (or log-ratio). No sanity check
is performed on it: if you experience strange behaviour, check you
gave a valid column name, for instance using
<code><a href="base.html#topic+make.names">make.names</a></code>.
</p>
</td></tr>
<tr><td><code id="creer_matrice_+3A_n.coeurs">n.coeurs</code></td>
<td>
<p>The number of CPU cores to use in computation, with
parallelization using forks (does not work on Windows) with the
help of the parallel package.</p>
</td></tr>
<tr><td><code id="creer_matrice_+3A_controles">controles</code></td>
<td>
<p>If TRUE, sanity checks are done on the obtained
matrix. Columns and Rows containing only non-finite values are
removed, with warnings; corresponding component names are stored as
attribute <code>omis</code> in the final result.</p>
</td></tr>
<tr><td><code id="creer_matrice_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>f.p</code>, passed unchanged to
it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function constructs a <code class="reqn">n\times n</code> matrix, where <code>n =
  length( noms )</code> (after eventually removing names in <code>noms</code> that
do not correspond to numeric variables). Term <code class="reqn">(i,j)</code> in this
matrix is the result of the <code>f.p</code> function when applied on the
ratio of variables <code>noms[ i ]</code> and <code>noms[ j ]</code> (or on its
log, if either <code>(log == TRUE) &amp;&amp; (en.log == FALSE)</code> or <code>(log
  == FALSE) &amp;&amp; (en.log == TRUE)</code>).
</p>
<p>The <code>f.p</code> function is always called only once, for <code class="reqn">i &lt; j</code>,
and the other term is obtained by symmetry.
</p>
<p>The diagonal of the matrix is filled with 1 without calling <code>f.p</code>,
since corresponding ratios are always identically equal to 1 so
nothing useful can be tested on.
</p>


<h3>Value</h3>

<p> These function returns the matrix obtained as described above,
with row an column names set to the names in <code>noms</code> (after
conversion into column names and removing all non-numeric variables).
</p>


<h3>Note</h3>

<p>Since the whole matrix is stored and since it is a dense
matrix, memory consumption (and computation time) increases as
<code class="reqn">n^2</code>. For compositional data with  a large number of components,
like in RNA-Seq data, consider instead creating a file.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p>Predefined <code>f.p</code> functions: <code><a href="#topic+anva1.fpc">anva1.fpc</a></code> for one-way
analysis of variance; <code><a href="#topic+kw.fpc">kw.fpc</a></code> for the non-parametric
equivalent (Kruskal-Wallis test).
</p>
<p><code><a href="#topic+grf.Mp">grf.Mp</a> to create a graphe from the obtained matrix.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the potery data set
   data( poteries )

   # Compute one-way ANOVA p-values for all ratios in this data set   
   Mp &lt;- creer.Mp( poteries, c( 'Al', 'Na', 'Fe', 'Ca', 'Mg' ),
                   f.p = anva1.fpc, v.X = 'Site' )
   Mp

   # Make a graphe from it and plot it
   plot( grf.Mp( Mp ) )
</code></pre>

<hr>
<h2 id='distances'>
Simulate the distribution of maximal minimal distances in a random graph
</h2><span id='topic+distrib.distances'></span>

<h3>Description</h3>

<p>This function simulates the distribution of the maximum of the minimal
distances between nodes of a random graph, for a given cut-off
threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distrib.distances( n.genes,
                   taille.groupes = c( 10, 10 ), masque,
                   me.composition = 0, cv.composition = 1, en.log = TRUE,
                   seuil.p = 0.05,
                   B = 3000, conf.level = 0.95,
                   f.p = student.fpc, frm = R ~ Groupe,
                   n.coeurs = 1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distances_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level for the exact confidence
intervals of estimated probabilities of maximal minimal distances in
the graph.</p>
</td></tr>
<tr><td><code id="distances_+3A_n.genes">n.genes</code></td>
<td>
<p>Number of components in the system (of nodes in the
total graph). Ignored if <code>me.composition</code> is a matrix.</p>
</td></tr>
<tr><td><code id="distances_+3A_me.composition">me.composition</code></td>
<td>
<p>The expected median quantity of each component,
in the log scale. Can be either a single value, used for two
conditions and <code>n.genes</code> components (hence, assuming the null
hypothesis that no change occurs), or a matrix with one row by
experimental condition and one column by component.</p>
</td></tr>
<tr><td><code id="distances_+3A_cv.composition">cv.composition</code></td>
<td>
<p>The expected coefficient of variation of the
quantified amounts. Should be either a single value, that will be
used for all components and all conditions, or a matrix with the
same structure than <code>me.composition</code>: one row for each
condition, one column for each component, in the same order and with
the same names.  Coefficients of variations are expected in the
amount scale, in raw form (that is, give 0.2 for a 20% coefficient
of variation)</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="distances_+3A_en.log">en.log</code></td>
<td>
<p>If <code>TRUE</code>, the values in the matrices are given in
the log scale.</p>
</td></tr>
<tr><td><code id="distances_+3A_taille.groupes">taille.groupes</code></td>
<td>
<p>The sample size for each condition. Unused if
<code>masque</code> is given.  If a single value, it will be used for all
conditions.  Otherwise, should have the same length that the number
of rows in the provided matrices.</p>
</td></tr>
<tr><td><code id="distances_+3A_masque">masque</code></td>
<td>
<p>A data.frame that will give the dataset design for a
given experiment. Should contain at least one column containing the
names of the conditions, with values being in the conditions names
in  <code>composition</code>.  If not provided, it is generated from
<code>taille.groupes</code> as a single column named &lsquo;Condition&rsquo;.</p>
</td></tr>
<tr><td><code id="distances_+3A_f.p">f.p</code>, <code id="distances_+3A_frm">frm</code></td>
<td>
<p>The function used to analyse the dataset, and its
parameter. See <code><a href="#topic+creer.Mp">creer.Mp</a></code> for details.</p>
</td></tr>
<tr><td><code id="distances_+3A_seuil.p">seuil.p</code></td>
<td>
<p>The p-value cut-off to be used when creating the
graph. Should be between 0 and 1. See <code><a href="#topic+grf.Mp">grf.Mp</a></code> for
details.</p>
</td></tr>
<tr><td><code id="distances_+3A_b">B</code></td>
<td>
<p>The number of simulations to be done.</p>
</td></tr>
<tr><td><code id="distances_+3A_n.coeurs">n.coeurs</code></td>
<td>
<p>The number of CPU cores to use to parallelize the
simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an undirected graph, minimal distance between two nodes is the
minimal number of edges to cross to go from one node to the other. The
maximal minimal distance is the largest of all possible minimal
distances in a given graph.
</p>
<p>The function simulates the distribution of the maximal minimal
distance in a graph whose edges were removed according to the
specified p-value cut-off. To avoid infinite distances, these
distances are computed in the largest connected component of the
graph.
</p>
<p>In the observed graph, nodes that are at a largest minimal distance
than probable maximal minimal distances may signal components belonging to
different sets, that could not be disconnected because of some nodes
having intermediate changes.
</p>


<h3>Value</h3>

<p>A 4-columns data.frame, with additional attributes giving the number
of simulations (<code>Nombre.simulations</code>) and their results
(<code>Tirages</code>).  The first column contains the maximal minimal
distances, the second contains their observed frequencies in the
simulated datasets, the third and fourth contain the limits of the
confidence interval of the corresponding probability.
</p>
<p>Confidence intervals are exacts, using the Clopper-Pearson method.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code>distances</code>, in package igraph, to compute the matrix of all
minimal distances of a graphe.
</p>
<p><code><a href="#topic+creer.Mp">creer.Mp</a></code> and <code><a href="#topic+grf.Mp">grf.Mp</a></code>, which are used
internally, for details about analysis functions and p-value cutoff.
</p>

<hr>
<h2 id='equivalence'>Utility function to obtain p-value for equivalence tests on
individual ratios
</h2><span id='topic+equivalence'></span><span id='topic+equiv.fpc'></span>

<h3>Description</h3>

<p>These functions can be used in the functions to perform analysis on
all pairwise ratios of a compositional dataset, using equivalence
tests to ensure edge existence  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equiv.fpc( d, variable, v.X, var.equal = TRUE, Delta = 0.5,
           pred = FALSE, ... ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalence_+3A_d">d</code></td>
<td>

<p>The data frame that contains the ratio to test, and all variables of
the original data frame that where not used as compositional data.
</p>
</td></tr>
<tr><td><code id="equivalence_+3A_variable">variable</code></td>
<td>

<p>A length-one character vector containing the names of the variable
corresponding to the ratio (or log-ratio) to test.
</p>
</td></tr>
<tr><td><code id="equivalence_+3A_v.x">v.X</code></td>
<td>

<p>The <strong>name</strong> of the explanatory (independant, predictor)
variable. This variable should be a factor for <code>equiv.fpc</code>.
</p>
</td></tr>
<tr><td><code id="equivalence_+3A_var.equal">var.equal</code></td>
<td>

<p>For <code>equiv.fpc</code>, shall we assume that variance are equals in
the two groups (<code>TRUE</code>, the default) or not
(<code>FALSE</code>).  Same as in <code><a href="stats.html#topic+t.test">t.test</a></code>.
</p>
</td></tr>
<tr><td><code id="equivalence_+3A_delta">Delta</code></td>
<td>

<p>The value giving the positive limit of the equivalence region. For
symmetry reasons, the equivalence region will be [-Delta, Delta].
</p>
</td></tr>
<tr><td><code id="equivalence_+3A_pred">pred</code></td>
<td>

<p>If <code>FALSE</code>, a standard equivalence test of the mean difference
is done.
</p>
<p>If <code>TRUE</code>, the p-value is computed assuming the variance of the
difference, and not the difference of the means. This allows to take
into account the sampling variability in the interval width,
avoiding (with large sample sizes) too narrow intervals
to fit in the equivalence region when large inter-sample variability
does not allow to consider genes as reliable reference genes.
</p>
</td></tr>
<tr><td><code id="equivalence_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are only wrapper to some commonly used equivalence
tests.
</p>
<p>The basic idea underlying equivalence tests is to try to reject the
null hypothesis that the difference between the two conditions is
higher (in absolute value) than a predefined, fixed, value, given by
<code>Delta</code>. Consequently, significant tests will mean that the edge
between the two tested nodes should be kept, whereas non-significant
tests will mean that the existence of the edge is uncertain.
</p>
<p>As a consequence, conversion of the p-value matrix to graphs should be
made using the complement of the graph, and the analysis of the graph
should be made in terms of cliques instead of disjoint subgraphs. See
example for an illustration.
</p>


<h3>Value</h3>

<p> These function returns the <em>p</em>-value from the corresponding test.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+student.fpc">student.fpc</a></code> for a, more usual, approach using difference
tests.
</p>
<p><code><a href="#topic+creer.Mp">creer.Mp</a></code> to use these functions to create a matrix of
<em>p</em>-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the reference genes data set
   data( generef )

   # compute equivalence test of all ratios
   #  Genes are in column 3 to 35
   #  Only the first 10 genes are used here, for speed reasons
   #  Equivalence is defined as a change lower than 0.5 Cq (× 1.41)
   #  Values are expressed as Cq : already in log
   Mp &lt;- creer.Mp( generef, names( generef )[ 3:13 ], log = TRUE,
                   f.p = equiv.fpc, Delta = 0.5, v.X = 'Group' )

   # Make the graph from it, and plot it
   #  Threshold is set at 0.15, for 10 nodes...
   #  (using the complement, to keep edges with p &lt; threshold only )
   plot( grf.Mp( Mp, p = 0.15, complement = TRUE ) )
   #  =&gt; there is a single clique, of 3 genes : HPRT1, B2M, HSP90AB1
   #     only these three genes are "proved" to have the same variation
</code></pre>

<hr>
<h2 id='fichiers'>
Create and read a file of p-values for all pairwise tests of all possible
ratios of a compositional vector
</h2><span id='topic+fichier'></span><span id='topic+creer.Fp'></span><span id='topic+create.Fp'></span><span id='topic+grf.Fp'></span>

<h3>Description</h3>

<p>These functions allow to perform hypothesis testing on all possible pairwise
ratios or differences of a set of variables in a given data frame, and
store or read their results in a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>creer.Fp( d, nom.fichier,
          noms, f.p = student.fpc,
          log = FALSE, en.log = !log,
          nom.var = 'R',
          noms.colonnes = c( "Cmp.1", "Cmp.2", "p" ),
          add.col = "delta",
          sep = ";", dec = ".", row.names = FALSE, col.names = TRUE,
          ... )

grf.Fp( nom.fichier, col.noms = c( 1, 2 ), p = 0.05, col.p = 'p',
        reference = NULL, groupes = NULL,
        sep = ";", dec = ".", header = TRUE,
        ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fichiers_+3A_d">d</code></td>
<td>

<p>The data frame that contains the compositional variables. Other
objects will be coerced as data frames using
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> </p>
</td></tr>
<tr><td><code id="fichiers_+3A_nom.fichier">nom.fichier</code></td>
<td>

<p>A length-one character vector giving the name of the file
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_noms">noms</code></td>
<td>

<p>A character vector containing the column names of the compositional
variables to be used for ratio computations. Names absent from the
data frame will be ignored with a warning.
</p>
<p>Optionnally, an integer vector containing the column numbers can be
given instead. They will be converted to column names before further
processing.
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_f.p">f.p</code></td>
<td>

<p>An R function that will perform the hypothesis test on a single
ratio (or log ratio, depending on <code>log</code> and <code>en.log</code>
values).
</p>
<p>This function should return a numeric vector, of which the first one
will typically be the p-value from the test &mdash; see
<code><a href="#topic+creer.Mp">creer.Mp</a></code> for details. 
</p>
<p>Such functions are provided for several common situations, see
links at the end of this manual page.
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_log">log</code></td>
<td>

<p>If <code>TRUE</code>, values in the columns are assumed to be
log-transformed, and consequently ratios are computed as differences
of the columns. The result is in the log scale.
</p>
<p>If <code>FALSE</code>, values are assumed to be raw data and ratios are
computed directly.
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_en.log">en.log</code></td>
<td>
<p> If <code>TRUE</code>, the ratio will be log-transformed
before applying the hypothesis test computed by <code>f.p</code>. Don't
change the default unless you really know what you are doing.
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_nom.var">nom.var</code></td>
<td>
<p> A length-one character vector giving the name of the
variable containing a single ratio (or log-ratio). No sanity check
is performed on it: if you experience strange behaviour, check you
gave a valid column name, for instance using
<code><a href="base.html#topic+make.names">make.names</a></code>.
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_noms.colonnes">noms.colonnes</code></td>
<td>
<p> A length-three character vector giving the names
of, respectively, the two columns of the data frame that will contain
the components identifiers and of the column that will contain the
p-value from the test (the first value returned by <code>f.p</code>).
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_add.col">add.col</code></td>
<td>
<p>A character vector giving the names of additional
columns of the data.frame, used for storing additional return values
of <code>f.p</code> (all but the first one).
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_sep">sep</code>, <code id="fichiers_+3A_dec">dec</code>, <code id="fichiers_+3A_row.names">row.names</code>, <code id="fichiers_+3A_col.names">col.names</code>, <code id="fichiers_+3A_header">header</code></td>
<td>
<p>Options for controling
the file format, used by <code><a href="utils.html#topic+write.table">write.table</a></code> and
<code><a href="utils.html#topic+read.table">read.table</a></code>.
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_col.noms">col.noms</code></td>
<td>
<p> A length-two vector giving the two columns that
contain the two components of the ratio. Can be given either as
column number or column name.</p>
</td></tr>
<tr><td><code id="fichiers_+3A_col.p">col.p</code></td>
<td>
<p> A length-one vector giving the column that contain the
<em>p</em>-value of the ratio. Can be given either as column number or
column name.</p>
</td></tr>
<tr><td><code id="fichiers_+3A_p">p</code></td>
<td>
<p>The <em>p</em>-value cut-off to be used when creating the
graph, see <code><a href="#topic+grf.Mp">grf.Mp</a></code> for details.
</p>
</td></tr>
<tr><td><code id="fichiers_+3A_reference">reference</code></td>
<td>
<p> A character vector giving the names of nodes that
should be displayed with a different color in the created graph.
These names should match components names present un the
file. Typical use would be for reference genes in qRT-PCR
experiments.  By default, all nodes are displayed in palegreen;
reference nodes, if any, will be displayed in orange. </p>
</td></tr>
<tr><td><code id="fichiers_+3A_groupes">groupes</code></td>
<td>
<p> A list of character vectors giving set of logically
related nodes, defining groups of nodes that will share common color.
Currently unimplemented.</p>
</td></tr>
<tr><td><code id="fichiers_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>f.p</code>, passed unchanged to
it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> These functions are basically the same as the function that
create data.frames (<code><a href="#topic+creer.DFp">creer.DFp</a></code>) and use data.frames to
create a graph (<code><a href="#topic+grf.DFp">grf.DFp</a></code>), except thatthey work on text
files.  This allow to deal with compositionnal data including
thousands of components, like RNA-Seq or microarray data.
</p>
<p>Seeing the results as a matrix, computations are done in rows and the
file is updated after each row. Only the upper-triangular part,
without the diagonal, is stored in the file.
</p>
<p>The function that creates the graphe from file is not very efficient
and can take a lot of time for huge matrices.  Making a first filter
on the file using shell tools, like <code>gawk</code> or <code>perl</code>, or a
dedicated C software and loading the resulting file as a data.frame
before converting it into a graph is a better alternative, but may
lose some isolated nodes.
</p>


<h3>Value</h3>

 <p><code>creer.Fp</code> does not return anything.
<code>grf.Fp</code> returns the result graph.
</p>


<h3>Note</h3>

<p>Creating a file and working from a file is quite inefficient (in terms
of speed), so for compositionnal data with only a few components,
consider using <code><a href="#topic+creer.DFp">creer.DFp</a></code> that creates the data.frame
directly in memory and <code><a href="#topic+grf.DFp">grf.DFp</a></code> that creates the graphe
from a data.frame instead.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p>Predefined <code>f.p</code> functions: <code><a href="#topic+anva1.fpc">anva1.fpc</a></code> for one-way
analysis of variance; <code><a href="#topic+kw.fpc">kw.fpc</a></code> for the non-parametric
equivalent (Kruskal-Wallis test).
</p>
<p>For directly creating and manipulating matrices,
<code><a href="#topic+creer.Mp">creer.Mp</a></code> and  <code><a href="#topic+grf.Mp">grf.Mp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the potery data set
   data( poteries )

   # Create the file name in R temporary directory
   nom.fichier &lt;- paste0( tempdir(), "/fichier_test.csv" )
   nom.fichier

   # Compute one-way ANOVA p-values for all ratios in this data set
   #  and store them in a text file
   creer.Fp( poteries, nom.fichier,
             c( 'Al', 'Na', 'Fe', 'Ca', 'Mg' ),
             f.p = anva1.fpc, v.X = 'Site',
             add.col = c( 'mu0', 'd.C', 'd.CoA', 'd.IT', 'd.L' ) )

   # Make a graphe from it and plot it
   plot( grf.Fp( nom.fichier ) )

   # The file is a simple text-file that can be read as a data.frame
   DFp &lt;- read.table( nom.fichier, header = TRUE, sep = ";", dec = "," )
   DFp  
</code></pre>

<hr>
<h2 id='GADL1'>Gene expression change in bipolar disorder</h2><span id='topic+gadl1'></span><span id='topic+GADL1'></span>

<h3>Description</h3>

<p>This data set gives the mRNA quantification of a few genes compared
between bipolar disorder patients and healthy volunteers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(GADL1)</code></pre>


<h3>Format</h3>

<p>A data frame with 13 columns and 56 rows. Each row gives the
quantification results, expressed in amounts:
</p>

<table>
<tr>
 <td style="text-align: right;">
    Groupe </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> The group label, Ctrl for healthy
    volunteers and BPD for bipolar disorder patients</td>
</tr>
<tr>
 <td style="text-align: right;">
    Phenotype </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> the subgroup label, C for healthy
    volunteers, NR for patients not responding to treatment and R for
    patients responding to treatment</td>
</tr>
<tr>
 <td style="text-align: right;">
    Sample    </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> the sample unique identifier</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>All other columns are numeric and give the amount, in arbitrary unit,
of mRNA of the corresponding gene. The column name gives the name of
the gene and the dilution used for the quantification.  <em>hprt</em> and
<em>sdha</em> are used as reference genes.
</p>


<h3>Source</h3>

<p>Original data communicated by the authors of the experiment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data( GADL1 )
  # Optimal cut-off for ten genes and alpha = 0.05
  #  is around 0.22

  # First step, is there differences between healthy subjects
  #   and patients ?
  #
  M.m &lt;- creer.Mp( d = GADL1, noms = names( GADL1 )[ -c( 1:3 ) ],
                   f.p = student.fpc, v.X = 'Groupe' )

  #  2) L'arbre associé
  #  [reference gene for plotting purpose]
  n.ref &lt;- grep( 'HPRT|SDHA', names( GADL1 ), value = TRUE )
  plot( arbre.Mp( M.m, reference = n.ref ),
        seuil.p = c( 0.218, 0.207, 0.230 ) )

  #  3) Le graphe pour le seuil optimal
  #    =&gt; only IGF1 seems to behave differently
  #       (but it has missing values, so interpretation is difficult)
  plot( grf.Mp( M.m, reference = n.ref, p = 0.22 ) )

  
  # Second step, is there differences between patients
  #   that respond or not respond to treatment?
  d.R &lt;- GADL1[ which( GADL1$Groupe == 'BPD' ), ]
  M.R &lt;- creer.Mp( d = d.R, noms = names( GADL1 )[ -c( 1:3 ) ],
                   f.p = student.fpc, v.X = 'Phenotype' )

  #  2) L'arbre associé
  plot( arbre.Mp( M.R, reference = n.ref ),
        seuil.p = c( 0.218, 0.207, 0.230 ) )

  #  3) Le graphe pour le seuil optimal
  #    =&gt; no sign of any difference
  plot( grf.Mp( M.R, reference = n.ref, p = 0.22 ) )
</code></pre>

<hr>
<h2 id='generef'>Expression level of candidate reference genes</h2><span id='topic+generef'></span><span id='topic+Cq.reference'></span>

<h3>Description</h3>

<p>This dataset gives the expression level of 30 different
candidate reference genes, in control subjects and in subjects with
bipolar disorder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(generef)</code></pre>


<h3>Format</h3>

<p>A data frame with 40 rows and 32 columns. Each row gives the
results and characteristics of a given patient. Columns 3 to 32 give
the average expression level of the gene whose name is the column
name, for the given patient. Columns are sorted in alphabetical order
of the gene name. Values are expressed as Cq (Ct) and were
obtained through qRT-PCR. RNAs were extracted on lymphoblastoid cell
line culture. Cq are the average of three technical replicates, after
eventual removal of outliers.
</p>

<table>
<tr>
 <td style="text-align: right;">
    ID </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> Patient identifier </td>
</tr>
<tr>
 <td style="text-align: right;">
    Group </td><td style="text-align: left;"> factor </td><td style="text-align: left;"> Patient group (control or having bipolar
    disorders) </td>
</tr>
<tr>
 <td style="text-align: right;">
    ATCB </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Cq for gene ATCB </td>
</tr>
<tr>
 <td style="text-align: right;">
    ... </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Cq for gene ... </td>
</tr>
<tr>
 <td style="text-align: right;">
    YWHAZ </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Cq for gene YWHAZ </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Experimental data kindly provided by Calypso Nepost &amp; Cynthia
Marie-Claire, UMR-S 1144, INSERM-Paris Descartes-Paris Diderot
</p>

<hr>
<h2 id='modele'>
Create a compositional model for simulations
</h2><span id='topic+modele'></span><span id='topic+modele_compo'></span><span id='topic+plot.SARPcompo.modele'></span>

<h3>Description</h3>

<p> These functions create and plot a model of compositionnal
data for two or more conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modele_compo( medianes, en.log = FALSE,
              noms = colnames( medianes ),
              conditions = rownames( medianes ),
              reference = NULL, total = 1 )

## S3 method for class 'SARPcompo.modele'
plot( x,
     xlab = "Composant",
     ylab.absolu = "Quantit\u00e9", ylab.relatif = "Fraction",
     taille.noeud = 50, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modele_+3A_medianes">medianes</code></td>
<td>
<p> A matrix giving the medians of all components
quantities in each condition. Each row of this matrix corresponds to
a different condition; each column, to one of the components.
</p>
</td></tr>
<tr><td><code id="modele_+3A_en.log">en.log</code></td>
<td>
<p>If <code>TRUE</code>, the values in the matrix are given in
the log scale.</p>
</td></tr>
<tr><td><code id="modele_+3A_noms">noms</code></td>
<td>
<p>Names of the components. If provided, should be a
character vector whose length is equal to the number of columns of
<code>medianes</code>.</p>
</td></tr>
<tr><td><code id="modele_+3A_conditions">conditions</code></td>
<td>
<p>Names of the different conditions. If provided,
should be a character vector whose length is equal to the number of
rows of <code>medianes</code>.</p>
</td></tr>
<tr><td><code id="modele_+3A_reference">reference</code></td>
<td>
<p>A character vector giving the names of the components
used as reference (typically, reference genes in qRT-PCR).</p>
</td></tr>
<tr><td><code id="modele_+3A_total">total</code></td>
<td>
<p>The total amount. The sum of amounts in each condition
will equal this total, when the data are made compositionnal.</p>
</td></tr>
</table>
<p>Arguments for the plot method
</p>
<table>
<tr><td><code id="modele_+3A_x">x</code></td>
<td>
<p>The modele to be plotted</p>
</td></tr>
<tr><td><code id="modele_+3A_xlab">xlab</code></td>
<td>
<p>Legend for the X axis</p>
</td></tr>
<tr><td><code id="modele_+3A_ylab.absolu">ylab.absolu</code></td>
<td>
<p>Legend for the Y axis, in the amount scale (no
constrain)</p>
</td></tr>
<tr><td><code id="modele_+3A_ylab.relatif">ylab.relatif</code></td>
<td>
<p>Legend for the Y axis, in the compositional
scale.</p>
</td></tr>
<tr><td><code id="modele_+3A_taille.noeud">taille.noeud</code></td>
<td>
<p>The plot size of nodes of the theoretical graph</p>
</td></tr>
<tr><td><code id="modele_+3A_...">...</code></td>
<td>

<p>Additionnal parameters for <code><a href="graphics.html#topic+plot">plot</a></code>,
which is used internally.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The <code>modele_compo</code> function creates a compositionnal data
model using the quantites provided: it converts amounts in fractions
of the total amount for each condition, then computes the theoretical
graph showing classes of equivalents components, that is components
that have the same evolution between the two conditions.  If more than two
conditions are given, graphs correspond to comparison of each
condition with the first one.
</p>
<p>The <code>plot</code> methods represents the original quantities, the
quantities after conversion in compositional data ant the theoretical
graph.
</p>


<h3>Value</h3>

<p> An object of class <code>SARPcompo.modele</code>, with a plot
method. It is a list with the following elements:
</p>
<table>
<tr><td><code>Absolue</code></td>
<td>
<p>The matrix of quantities in amount scale</p>
</td></tr>
<tr><td><code>Relative</code></td>
<td>
<p>The matrix of quantities in compositional data scale</p>
</td></tr>
<tr><td><code>Graphes</code></td>
<td>
<p>A list of length <code>nrow(medianes) - 1</code>. Each
element of the list gives, for the corresponding condition, the
matrix of all ratios of pairwise ratios between condition and the
first condition (element <code>M.rapports</code>), the corresponding
connectivity matrix (element <code>M.connexion</code>), the graph of
component changes compared to the first condition (element
<code>Graphe</code>, an igraph object) and the list of components of this
graph (element <code>Connexe</code>, obtained from the
<code><a href="igraph.html#topic+components">components</a></code> function.</p>
</td></tr>
</table>
<p>It also stores a few informations as attributes.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimer.puissance">estimer.puissance</a></code> and <code><a href="#topic+estimer.alpha">estimer.alpha</a></code> to use
these models in simulations to study power and type I error of the
method in a given situation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Create a toy example: four components, two conditions
  ##  components 1 and 2 do not change between conditions
  ##  component  3 is doubled
  ##  component  4 is halfed
  me &lt;- rbind( 'A' = c( 1, 1, 1, 1 ),
               'B' = c( 1, 1, 2, 0.5 ) )
  colnames( me ) &lt;- paste0( "C-", 1:4 )

  md &lt;- modele_compo( me )

  ## Plot it...
  plot( md )

  ## What is approximately the power to detect that something changes
  ## between conditions A and B using a Student test
  ## with a CV of around 50 % ?
  ##  (only a few simulations for speed, should be increased )
  puissance &lt;- estimer.puissance( md, cv = 0.50, B = 50, f.p = student.fpc )
  plot( puissance )
</code></pre>

<hr>
<h2 id='poteries'>Composition of Roman poteries</h2><span id='topic+poteries'></span>

<h3>Description</h3>

<p>This data set gives the oxide composition of several potteries found
in five different archaelogic sites of the United Kingdom. Composition
was obtained using atomic absorption spectrometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(poteries)</code></pre>


<h3>Format</h3>

<p>A data frame with 14 columns and 48 rows. Each row gives the
composition of a pottery (columns 2 to 10), the archaelogical
site where it was found (columns 6 and 7):
</p>

<table>
<tr>
 <td style="text-align: right;">
    ID   </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> Pottery sample identifier (see original paper
    appendix) </td>
</tr>
<tr>
 <td style="text-align: right;">
    Al   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Percentage of aluminium oxide </td>
</tr>
<tr>
 <td style="text-align: right;">
    Fe   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Percentage of iron oxide </td>
</tr>
<tr>
 <td style="text-align: right;">
    Mg   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Percentage of magnesium oxide </td>
</tr>
<tr>
 <td style="text-align: right;">
    Ca   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Percentage of calcium oxide </td>
</tr>
<tr>
 <td style="text-align: right;">
    Na   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Percentage of natrium oxide </td>
</tr>
<tr>
 <td style="text-align: right;">
    K    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Percentage of kalium oxide </td>
</tr>
<tr>
 <td style="text-align: right;">
    Ti   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Percentage of titanim oxide </td>
</tr>
<tr>
 <td style="text-align: right;">
    Mn   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Percentage of manganese oxide </td>
</tr>
<tr>
 <td style="text-align: right;">
    Ba   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Percentage of baryum oxide </td>
</tr>
<tr>
 <td style="text-align: right;">
    Site </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> Kiln site</td>
</tr>
<tr>
 <td style="text-align: right;">
    Pays </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> Location of the kiln site</td>
</tr>
<tr>
 <td style="text-align: right;">
    Couleur</td><td style="text-align: left;"> factor</td><td style="text-align: left;"> External color of the pottery</td>
</tr>
<tr>
 <td style="text-align: right;">
    Date </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> Approximate date of the pottery</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Note</h3>

<p>The DASL version of the dataset, as presented in the &quot;Pottery stoty&quot;,
does not include data on the poteries from the Gloucester site,
neither the data on K, Ti, Mn and Ba oxides. It neither includes the
color and date informations, and codes sites as their first letter
only.
</p>
<p>The DASL version of the dataset exists in the <code>car</code> package, as
the <code>Pottery</code> dataset (with two locations differently spelled).
</p>


<h3>Source</h3>

<p>Downloaded from the DASL (Data and Story Library) website, and
completed from the original paper of Tubb et al. 
</p>


<h3>References</h3>

<p>A. Tubb, A. J. Parker, and G. Nickless (1980). The analysis of
Romano-British pottery by atomic absorption spectrophotometry.
<em>Archaeometry</em>, 22, 153-171.
</p>
<p>Hand, D. J., Daly, F., Lunn, A. D., McConway, K. J., and E., O.
(1994) <em>A Handbook of Small Data Sets</em>. Chapman and Hall &ndash; for
the short version of the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data( poteries )
  # Reconstruct the car version of this dataset
  dcar &lt;- poteries[ , c( 'Al', 'Fe', 'Mg', 'Ca', 'Na', 'Site' ) ]
  dcar &lt;- droplevels( dcar[ -which( dcar$Site == "College of Art" ), c( 6, 1:5 ) ] )
  levels( dcar$Site )[ c( 1, 3, 4 ) ] &lt;- c( "AshleyRails", "Islethorns", "Llanedyrn" )

  # Reconstruct the DASL version of this dataset
  ddasl &lt;- dcar[ , c( 2:6, 1 ) ]
  levels( ddasl$Site ) &lt;- c( 'A', 'C', 'I', 'L' )
</code></pre>

<hr>
<h2 id='puissance'>
Estimate the power and the type-I error of the disjoint-subgraphs method
</h2><span id='topic+puissance'></span><span id='topic+alpha'></span><span id='topic+estimer.puissance'></span><span id='topic+estimer.alpha'></span>

<h3>Description</h3>

<p> Estimate the power and the type-I error of the
disjoint-graph method to detect a change in compositions between
different conditions </p>


<h3>Usage</h3>

<pre><code class='language-R'>estimer.puissance( composition, cv.composition,
                   taille.groupes = 10, masque,
                   f.p, v.X = 'Condition',
                   seuil.candidats = ( 5:30 ) / 100,
                   f.correct = groupes.identiques,
                   groupes.attendus = composition$Graphes[[ 1 ]]$Connexe,
                   avec.classique = length( attr( composition, "reference" ) ) &gt; 0,
                   f.correct.classique = genes.trouves,
                   genes.attendus,
                   B = 3000, n.coeurs = 1,
                   ... )

estimer.alpha( composition, cv.composition,
               taille.groupes = 10, masque,
               f.p, v.X = 'Condition',
               seuil.candidats = ( 5:30 ) / 100,
               avec.classique = length( attr( composition, "reference" ) ) &gt; 0,
               B = 3000, n.coeurs = 1,
               ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="puissance_+3A_composition">composition</code></td>
<td>
<p> A composition model, as obtained by
<code><a href="#topic+modele_compo">modele_compo</a></code>.  For simulations under the null
hypothesis (<code>estimer.alpha</code>), the first condition is
duplicated to other conditions (but not the cv.composition, if
provided as a matrix, allowing to explore some kinds of
pseudo-null hypothesis).</p>
</td></tr>
<tr><td><code id="puissance_+3A_cv.composition">cv.composition</code></td>
<td>
<p>The expected coefficient of variation of the
quantified amounts. Should be either a single value, that will be
used for all components and all conditions, or a matrix with the
same structure than <code>composition$Absolue</code>: one row for each
condition, one column for each component, in the same order and with
the same names.  Coefficients of variations are expected in the
amount scale, in raw form (that is, give 0.2 for a 20% coefficient
of variation)</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="puissance_+3A_taille.groupes">taille.groupes</code></td>
<td>
<p>The sample size for each condition. Unused if
<code>masque</code> is given.  If a single value, it will be used for all
conditions.  Otherwise, should have the same length that the number
of conditions in the provided model.</p>
</td></tr>
<tr><td><code id="puissance_+3A_masque">masque</code></td>
<td>
<p>A data.frame that will give the dataset design for a
given experiment. Should contain at least one column containing the
names of the conditions, with values being in the conditions names
in  <code>composition</code>.  If not provided, it is generated from
<code>taille.groupes</code> as a single column named &lsquo;Condition&rsquo;.</p>
</td></tr>
<tr><td><code id="puissance_+3A_f.p">f.p</code></td>
<td>
<p>The function used to analyse the dataset. See
<code><a href="#topic+creer.Mp">creer.Mp</a></code> for details.</p>
</td></tr>
<tr><td><code id="puissance_+3A_v.x">v.X</code></td>
<td>
<p>The name of the column identifying the different conditions
in <code>masque</code>.</p>
</td></tr>
<tr><td><code id="puissance_+3A_seuil.candidats">seuil.candidats</code></td>
<td>
<p>A vector of p-value cut-offs to be tested. All
values should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="puissance_+3A_f.correct">f.correct</code></td>
<td>
<p>A function to determine if the result of the analysis
is the expected one. Defaults to a function that compares the
disjoint sub-graphs of a reference graph and the obtained one.
</p>
</td></tr>
<tr><td><code id="puissance_+3A_groupes.attendus">groupes.attendus</code></td>
<td>
<p>The reference graph for the above
function. Defaults to the theoretical graph of the model, for the
comparison between the first and the second conditions.
</p>
</td></tr>
<tr><td><code id="puissance_+3A_avec.classique">avec.classique</code></td>
<td>
<p>If <code>TRUE</code>, analysis is also done using an
additive log-ratio (alr)-like method, using the geometric mean of
the reference components as the &ldquo;normalisation factor&rdquo;.  This
correspond to the Delta-Delta-Ct method, or similar methods, in
qRT-PCR. With this method, each non-reference component is tested in
turn after division by the normalisation factor.
</p>
<p>If requested, the analysis is done with and without multiple testing
correction (with Holm's method). The &ldquo;cut-off p-value&rdquo; is
used as the nominal type~I error level for the individual tests.
</p>
</td></tr>
<tr><td><code id="puissance_+3A_f.correct.classique">f.correct.classique</code></td>
<td>
<p>A function to determine if the alr-like
method finds the correct answer. Defaults to a function that
compares the set of significant tests with the set of expected
components.
</p>
</td></tr>
<tr><td><code id="puissance_+3A_genes.attendus">genes.attendus</code></td>
<td>
<p>A character vector giving the names of
components expected to behave differently than the reference set.
</p>
</td></tr>
<tr><td><code id="puissance_+3A_b">B</code></td>
<td>
<p>The number of simulations to be done.</p>
</td></tr>
<tr><td><code id="puissance_+3A_n.coeurs">n.coeurs</code></td>
<td>
<p>The number of CPU cores to use in computation, with
parallelization using forks (does not work on Windows) with the help
of the parallel package.</p>
</td></tr>
<tr><td><code id="puissance_+3A_...">...</code></td>
<td>

<p>Additionnal parameters for helper functions, including <code>f.p</code>,
<code>f.correct</code> and <code>f.correct.classique</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to simulate experiments and explore the properties
of the disjoint graph method in a specified experimental context.
Simulations are done using a log-normal model, so analysis is always
done on the log scale. Coefficients of variation in the original scale
hence directly translate into standard deviations in the log-scale.
</p>
<p>For power analysis, care should be taken that any rejection of the
null hypothesis &ldquo;nothing is different between conditions&rdquo; is
counted as a success, even if the result does not respect the original
changes.  This is the reason for the additional correct-finding
probability estimation.  However, defining what is a correct, or at
least acceptable, result may be not straightforward, especially for
comparison with other analysis methods.
</p>
<p>Note also that fair power comparisons can be done only for the same
type I error level. Hence, for instance, power of the corrected
alr-like method at p = 0.05 should be compared to the power of the
disjoint-graph method at its &ldquo;optimal&rdquo; cut-off.
</p>


<h3>Value</h3>

<p> An object of class <code>SARPcompo.simulation</code>, with a plot
method. It is a data.frame with the following columns:
</p>
<table>
<tr><td><code>Seuil</code></td>
<td>
<p>The cut-offs used to build the graph</p>
</td></tr>
<tr><td><code>Disjoint</code></td>
<td>
<p>The number of simulations that led to disjoint
graphs.</p>
</td></tr>
<tr><td><code>Correct</code></td>
<td>
<p>The number of simulations that led to the correct graph
(as defined by the <code>f.correct</code> function).</p>
</td></tr>
</table>
<p>If <code>avec.classique</code> is <code>TRUE</code>, it has additionnal columns:
</p>
<table>
<tr><td><code>DDCt</code></td>
<td>
<p>The number of simulations that led at least one
significant test using the alr-like method.</p>
</td></tr>
<tr><td><code>DDCt.H</code></td>
<td>
<p>The number of simulations that led at least one
significant test using the alr-like method, after multiple testing
correction using Holm's method.</p>
</td></tr>
<tr><td><code>DDCt.correct</code></td>
<td>
<p>The number of simulations that detected the
correct components (as defined by the <code>f.correct.classique</code>
function) using the alr-like method.</p>
</td></tr>
<tr><td><code>DDCt.H.correct</code></td>
<td>
<p>As above, but after multiple testing correction
using Holm's method.</p>
</td></tr>  
</table>
<p>It also stores a few informations as attributes, including the total
number of simulations (attribute <code>n.simulations</code>).
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modele_compo">modele_compo</a></code> to create a compositional model for two or
more conditions.
</p>
<p><code><a href="#topic+creer.Mp">creer.Mp</a></code>, which is used internally, for details about
analysis functions. 
</p>
<p><code><a href="#topic+choisir.seuil">choisir.seuil</a></code> for a simpler interface to estimate the
optimal cut-off.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Create a toy example: four components, two conditions
  ##  components 1 and 2 do not change between conditions
  ##  components 3 and 4 are doubled
  ##  component  1 is a reference component
  me &lt;- rbind( 'A' = c( 1, 1, 1, 1 ),
               'B' = c( 1, 1, 2, 2 ) )
  colnames( me ) &lt;- paste0( "C-", 1:4 )

  md &lt;- modele_compo( me, reference = 'C-1' )

  ## How many simulations?
  ##  50 is for speed; increase for useful results...
  B &lt;- 50

  ## What is the optimal cut-off for this situation?
  ## (only a few simulations for speed, should be increased)
  ## (B = 3000 suggests a cut-off between 0.104 and 0.122)
  seuil &lt;- choisir.seuil( 4, B = B )

  ## What is approximately the type I error
  ## between conditions A and B using a Student test
  ## with a CV of around 50 % ?
  ##  (only a few simulations for speed, should be increased)
  alpha &lt;- estimer.alpha( md, cv = 0.50, B = B,
                          f.p = student.fpc )

  # Plot it : darkgreen = the disjoint graph method
  #           orange    = the alr-like method, Holm's corrected
  #           salmon    = the alr-like method, uncorrected
  plot( alpha )

  ## What is approximately the power to detect that something changes
  ## between conditions A and B using a Student test
  ## with a CV of around 50 % ?
  ##  (only a few simulations for speed, should be increased)
  puissance &lt;- estimer.puissance( md, cv = 0.50, B = B,
                                  f.p = student.fpc,
                                  genes.attendus = c( 'C-3', 'C-4' )  )

  # Plot it : darkgreen = the disjoint graph method
  #           orange    = the alr-like method, Holm's corrected
  #           salmon    = the alr-like method, uncorrected
  plot( puissance )

  ## Do we detect the correct situation in general?
  ##  (that is, exactly two sets: one with C-1 and C-2, the second with
  ##   C-3 and C-4 --- for the alr-like method, that only C-3 and C-4
  ##   are significant)
  #           darkgreen = the disjoint graph method
  #           orange    = the alr-like method, Holm's corrected
  #           salmon    = the alr-like method, uncorrected
  plot( puissance, correct = TRUE )
  
</code></pre>

<hr>
<h2 id='SCH23390'>Effect of MDMA and SCH23390 on gene expression</h2><span id='topic+sch23390'></span><span id='topic+SCH23390'></span>

<h3>Description</h3>

<p>This data set gives the mRNA quantification of several genes involved
in the dopamin pathway in four different conditions: control, after
addition of MDMA, after addition of SCH23390 and after addition of both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SCH23390)</code></pre>


<h3>Format</h3>

<p>A data frame with 8 columns and 48 rows. Each row gives the
quantification results, expressed in cycle threshold (CT):
</p>

<table>
<tr>
 <td style="text-align: right;">
    Groupe </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> The group label</td>
</tr>
<tr>
 <td style="text-align: right;">
    MDMA   </td><td style="text-align: left;"> factor  </td><td style="text-align: left;"> MDMA addition indicator (Oui=Yes, Non=No)</td>
</tr>
<tr>
 <td style="text-align: right;">
    SCH23390</td><td style="text-align: left;"> factor </td><td style="text-align: left;"> SCH23390 addition indicator (as above)</td>
</tr>
<tr>
 <td style="text-align: right;">
    Hprt   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> CT for the <em>hprt</em> gene, use as
                             reference gene</td>
</tr>
<tr>
 <td style="text-align: right;">
    Fos,Fosb,Egr1,Egr2 </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> CT for the four genes of interest
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Original data communicated by the authors of the paper.
</p>


<h3>References</h3>

<p>N. Benturquia, C. Courtin, F. Noble, and C. Marie-Claire
(2008). Involvement of D1 dopamine receptor in MDMA-induced locomotor
activity and striatal gene expression in mice. <em>Brain Research</em>,
1211, 1-5
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data( SCH23390 )
  # Optimal cut-off for five genes and alpha = 0.05
  #  is around 0.13

  # First step, experimental check
  #
  # MDMA should change expression levels of all genes but the reference
  #  1) extract the data for the Ctrl vs MDMA groups comparison
  d.MDMA &lt;- SCH23390[ which( SCH23390$Groupe %in% c( 'Ctrl', 'MDMA' ) ), ]
  M.MDMA &lt;- creer.Mp( d = d.MDMA, noms = names( d.MDMA )[ 4:8 ], log = TRUE,
                      f.p = student.fpc, v.X = 'MDMA' )

  #  2) L'arbre associé
  plot( arbre.Mp( M.MDMA, reference = 'Hprt' ),
        seuil.p = c( 0.137, 0.128, 0.147 ) )

  #  3) Le graphe pour le seuil optimal
  #    =&gt; indeed, all genes are modified by MDMA
  #       Fos and Fosb seems to have the same behavior
  plot( grf.Mp( M.MDMA, reference = 'Hprt', p = 0.13 ) )

  
  # Second step, experiment analysis
  # Does SCH23390 modulate the MDMA effect?
  #   =&gt; interaction term in a two-ways analysis of variance
  M.I &lt;- creer.Mp( d = SCH23390, noms = names( SCH23390 )[ 4:8 ], log = TRUE,
                   f.p = anva_SC.fpc,
                   frm = R ~ MDMA + SCH23390 + MDMA:SCH23390, SC = 3 )


  #  2) L'arbre associé
  plot( arbre.Mp( M.I, reference = 'Hprt' ),
        seuil.p = c( 0.137, 0.128, 0.147 ) )

  #  3) Le graphe pour le seuil optimal
  #    =&gt; no clear detection of interaction
  plot( grf.Mp( M.I, reference = 'Hprt', p = 0.13 ) )
</code></pre>

<hr>
<h2 id='tests'>
Utility functions to obtain p-values from tests on individual ratios
</h2><span id='topic+tests'></span><span id='topic+anva1.fpc'></span><span id='topic+anva1vi.fpc'></span><span id='topic+rls.fpc'></span><span id='topic+kw.fpc'></span><span id='topic+anva_SC.fpc'></span><span id='topic+student.fpc'></span>

<h3>Description</h3>

<p>These functions can be used in the functions to perform analysis on
all pairwise ratios of a compositional dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>student.fpc( d, variable, v.X, var.equal = TRUE, ... )
anva1.fpc( d, variable, v.X, frm = NULL, ... )
anva1vi.fpc( d, variable, v.X, frm = NULL, ... )
rls.fpc( d, variable, v.X, frm = NULL, ... )
kw.fpc( d, variable, v.X, frm = NULL, ... )
anva_SC.fpc( d, variable, frm, SC = 1, type = 1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tests_+3A_d">d</code></td>
<td>

<p>The data frame that contains the ratio to test, and all variables of
the original data frame that where not used as compositional data.
</p>
</td></tr>
<tr><td><code id="tests_+3A_variable">variable</code></td>
<td>

<p>A length-one character vector containing the names of the variable
corresponding to the ratio (or log-ratio) to test.
</p>
</td></tr>
<tr><td><code id="tests_+3A_v.x">v.X</code></td>
<td>

<p>The <strong>name</strong> of the explanatory (independant, predictor)
variable. This variable should be a factor for <code>anva1.fpc</code>,
<code>anva1vi.fpc</code> and <code>kw.fpc</code> and a numeric for
<code>rls.fpc</code>.
</p>
</td></tr>
<tr><td><code id="tests_+3A_frm">frm</code></td>
<td>

<p>The formula to use.
</p>
<p>Defaults to <code>as.formula( paste0( variable,
      "~", v.X ) )</code> for <code>anva1.fpc</code>, <code>anva1vi.fpc</code> and <code>kw.fpc</code>.
Providing the formula speeds up the computation, since it avoids
repeating the construction step for each ratio.
</p>
<p>For <code>anva_SC.fpc</code>, giving the formula is mandatory and
<code>variable</code> is unused. Beware of the term order to select the
right sum of squares to test!
</p>
</td></tr>
<tr><td><code id="tests_+3A_sc">SC</code></td>
<td>

<p>For <code>anva_SC.fpc</code>, the number of the line to use in the analysis
of variance table to get a p-value, see details.
</p>
</td></tr>
<tr><td><code id="tests_+3A_type">type</code></td>
<td>

<p>For <code>anva_SC.fpc</code>, the kind of sums of square to be used when
constructing the analysis of variance table, see details.
</p>
</td></tr>
<tr><td><code id="tests_+3A_var.equal">var.equal</code></td>
<td>

<p>For <code>student.fpc</code>, shall we assume that variance are equals in
the two groups (<code>TRUE</code>, the default) or not
(<code>FALSE</code>).  Same as in <code><a href="stats.html#topic+t.test">t.test</a></code>.
</p>
</td></tr>
<tr><td><code id="tests_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are only wrapper to some commonly used tests. The
correspondance is as follow
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>student.fpc</code> </td><td style="text-align: left;"> Student's T-test </td><td style="text-align: left;"> <code>t.test()$p.value</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>anva1.fpc</code> </td><td style="text-align: left;"> One-way analysis of variance </td><td style="text-align: left;"> <code>anova(lm())[ 1, 5 ]</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>rls.fpc</code> </td><td style="text-align: left;"> Simple linear regression </td><td style="text-align: left;"> <code>anova(lm())[ 1, 5 ]</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>anva1vi.fpc</code> </td><td style="text-align: left;"> One-way analysis of variance, without equal
    variance assumption </td><td style="text-align: left;"> <code>oneway.test()$p.value</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>kw.fpc</code> </td><td style="text-align: left;"> Kruskal-Wallis test </td><td style="text-align: left;"> <code>kruskal.test()$p.value</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p><code>anva_SC.fpc</code> is a generic wrapper for <code>lm</code> using any
formula. It then extracts the <em>p</em>-value of the line given by
<code>SC</code> in the analysis of variance table. If <code>type = 1</code>, the
table is built using <code>anova</code> and corresponds to type 1
(sequential sum of square).  If <code>type = 2</code> or <code>type = 3</code>,
the table is built using <code>car::Anova</code> and corresponds either to
type 2 or type 3 sums of squares.
</p>
<p>For Student's test (either with equal or unequal variances), instead
of calling t.test, the computation is done internally, hopefully
speeding up (less controls are done and only useful computations are done)
</p>


<h3>Value</h3>

<p> These function returns the <em>p</em>-value from the corresponding test.
</p>


<h3>Note</h3>

<p><code>rls.fpc</code> is an exact synonym for <code>anva1.fpc</code>, since the
underlying theory is the same. Distinction is made to help users
without a formal statistical background to find the right test.
</p>


<h3>Author(s)</h3>

<p>Emmanuel Curis (<a href="mailto:emmanuel.curis@parisdescartes.fr">emmanuel.curis@parisdescartes.fr</a>)
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>,
<code><a href="car.html#topic+Anova">Anova</a></code>, <code><a href="stats.html#topic+oneway.test">oneway.test</a></code>, for corresponding tests.
</p>
<p><code><a href="#topic+equiv.fpc">equiv.fpc</a></code> for an approach using equivalence tests.
</p>
<p><code><a href="#topic+creer.Mp">creer.Mp</a></code> to use these functions to create a matrix of
<em>p</em>-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # load the potery data set
   data( poteries )

   # Compute one-way ANOVA p-values for all ratios in this data set   
   Mp &lt;- creer.Mp( poteries, c( 'Al', 'Na', 'Fe', 'Ca', 'Mg' ),
                   f.p = anva1.fpc, v.X = 'Site', frm = R ~ Site )
   Mp

   # Make a graphe from it and plot it
   plot( grf.Mp( Mp ) )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
