<!DOCTYPE html><html><head><title>Help for package ecespa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ecespa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ecespa'>
<p>Functions for spatial point pattern analysis in ecology</p>
</p></a></li>
<li><a href='#dixon2002'><p> Dixon (2002) Nearest-neighbor contingency table analysis</p></a></li>
<li><a href='#ecespa-internal'><p> Internal ecespa functions.</p></a></li>
<li><a href='#figuras'><p>Artificial point data.</p></a></li>
<li><a href='#getis'><p> Neighbourhood density function</p></a></li>
<li><a href='#gypsophylous'><p> Spatial point pattern of a plant community</p></a></li>
<li><a href='#haz.ppp'><p>Easily convert xy data to ppp format</p></a></li>
<li><a href='#Helianthemum'><p> Spatial point pattern of Helianthemum squamatum adult plants and seedlings</p></a></li>
<li><a href='#ipc.estK'><p> Fit the (In)homogeneous Poisson Cluster Point Process by Minimum Contrast</p></a></li>
<li><a href='#K012'><p> Tests against 'independent labelling'</p></a></li>
<li><a href='#K1K2'><p> Differences between univariate and bivariate K-functions</p></a></li>
<li><a href='#Kci'><p> Test against non-Poisson (in-)homogeneous models</p></a></li>
<li><a href='#Kinhom.log'><p> Simulation envelopes from the fitted values of a logistic model</p></a></li>
<li><a href='#Kmm'><p> Mark-weighted K-function</p></a></li>
<li><a href='#Kmulti.ls'><p> Lotwick's and Silverman's combined estimator of the marked K-function</p></a></li>
<li><a href='#LF.gof'><p>Loosmore and Ford Goodness of Fit Test</p></a></li>
<li><a href='#marksum'><p> Mark-sum measure</p></a></li>
<li><a href='#p2colasr'><p> P-value for a discrete distribution on small sample data</p></a></li>
<li><a href='#pc.estK'><p> Fit the Poisson Cluster Point Process by Minimum Contrast</p></a></li>
<li><a href='#quercusvm'><p> Alive and dead oak trees</p></a></li>
<li><a href='#rIPCP'><p> Simulate Inhomogeneous Poisson Cluster Process</p></a></li>
<li><a href='#seedlings'><p> Cohorts of Helianthemum squamatum seedlings</p></a></li>
<li><a href='#sim.poissonc'><p> Simulate Poisson Cluster Process</p></a></li>
<li><a href='#swamp'><p> Tree Species in a Swamp Forest</p></a></li>
<li><a href='#syrjala'><p> Syrjala's test for the difference between the spatial distributions of two populations</p></a></li>
<li><a href='#syrjala.data'><p> Syrjala test data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Spatial Point Pattern Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-17</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcelino de la Cruz Rot, with contributions of Philip M. Dixon and Jose M. Blanco-Moreno</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcelino de la Cruz Rot &lt;marcelino.delacruz@urjc.es&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>spatstat (&ge; 2.0-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.geom, spatstat.explore, spatstat.model,
spatstat.random</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dixon</td>
</tr>
<tr>
<td>Description:</td>
<td>Some wrappers, functions and data sets for for spatial point pattern analysis (mainly based on 'spatstat'), used in the book "Introduccion al Analisis Espacial de Datos en Ecologia y Ciencias Ambientales: Metodos y Aplicaciones" and in the papers by De la Cruz et al. (2008) &lt;<a href="https://doi.org/10.1111%2Fj.0906-7590.2008.05299.x">doi:10.1111/j.0906-7590.2008.05299.x</a>&gt; and Olano et al. (2009) &lt;<a href="https://doi.org/10.1051%2Fforest%3A2008074">doi:10.1051/forest:2008074</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-26 12:08:56 UTC; marcelino</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-05 21:50:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='ecespa'>
Functions for spatial point pattern analysis in ecology
</h2><span id='topic+ecespa-package'></span><span id='topic+ecespa'></span>

<h3>Description</h3>

<p>This is a summary of the features of <span class="pkg">ecespa</span> by way of examples of its main functions.
</p>


<h3>Author(s)</h3>

<p>Marcelino de la Cruz Rot, with contributions of Philip M. Dixon and Jose M. Blanco-Moreno and heavily borrowing  Baddeley's &amp; Turner's <span class="pkg">spatstat</span> code.
</p>


<h3>References</h3>

<p>De la Cruz, M. 2006. Introducción al análisis de datos mapeados o algunas de las (muchas) cosas  que puedo hacer si tengo coordenadas. <em>Ecosistemas</em>  15 (3): 19-39. 
</p>
<p>De la Cruz, M. 2008. Métodos para analizar datos puntuales. 
En: <em>Introducción al Análisis Espacial de Datos en Ecología y Ciencias Ambientales: Métodos y Aplicaciones </em> 
(eds. Maestre, F. T., Escudero, A. y Bonet, A.), pp 76-127. Asociación Española de Ecología Terrestre, Universidad Rey Juan Carlos
y Caja de Ahorros del Mediterráneo, Madrid.
</p>
<p>De la Cruz, M., Romao, R.L.,  Escudero, A. and Maestre, F.T. 2008. Where do seedlings go? A spatio-temporal analysis of
early mortality in a semiarid specialist. <em>Ecography</em>, 31(6): 720-730. <a href="https://doi.org/10.1111/j.0906-7590.2008.05299.x">doi:10.1111/j.0906-7590.2008.05299.x</a>.
</p>
<p>Diggle, P. J. 2003. <em>Statistical analysis of spatial point patterns</em>. Arnold, London. 
</p>
<p>Dixon, P.M. 2002. Nearest-neighbor contingency table analysis of spatial segregation for several species.
<em>Ecoscience</em>, 9 (2): 142-151. <a href="https://doi.org/10.1080/11956860.2002.11682700">doi:10.1080/11956860.2002.11682700</a>. 
</p>
<p>Dixon, P. M. 2002. Ripley's K function. In <em>The encyclopedia of environmetrics</em> 
(eds. El-Shaarawi, A.H. &amp; Piergorsch, W.W.), pp. 1976-1803. John Wiley &amp; Sons Ltd, NY.
</p>
<p>Escudero, A., Romao, R.L., De la Cruz, M. &amp; Maestre, F. 2005. Spatial pattern and neighbour effects on 
<em>Helianthemum squamatum</em> seedlings in a Mediterranean gypsum community. <em>Journal of  Vegetation  Science</em>,  16: 383-390. <a href="https://doi.org/10.1111/j.1654-1103.2005.tb02377.x">doi:10.1111/j.1654-1103.2005.tb02377.x</a>.
</p>
<p>Getis, A. and Franklin, J. 1987. Second-order neighbourhood analysis of mapped point patterns. <em>Ecology</em> 68: 473-477. <a href="https://doi.org/10.2307/1938452">doi:10.2307/1938452</a>.
</p>
<p>Loosmore, N.B. and Ford, E.D. (2006) Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87, 1925-1931. <a href="https://doi.org/10.1890/0012-9658%282006%2987%5B1925%3ASIUTGO%5D2.0.CO%3B2">doi:10.1890/0012-9658(2006)87[1925:SIUTGO]2.0.CO;2</a>.
</p>
<p>Lotwick,H.W. &amp; Silverman, B. W. 1982. Methods for analysing spatial processes of several types of points. 
<em>Journal of the Royal Statistical Society</em> B,  44: 406-413. <a href="https://doi.org/10.1111/j.2517-6161.1982.tb01221.x">doi:10.1111/j.2517-6161.1982.tb01221.x</a>.
</p>
<p>Olano, J.M., Laskurain, N.A., Escudero, A. and De la Cruz, M. 2009. Why and where adult trees die in a secondary temperate forest? 
The role of neighbourhood. <em>Annals of Forest Science</em>, 66: 105. <a href="https://doi.org/10.1051/forest%3A2008074">doi:10.1051/forest:2008074</a>.
</p>
<p>Penttinen, A. 2006. Statistics for Marked Point Patterns. In <em>The Yearbook of the Finnish Statistical Society</em>, pp. 70-91. 
</p>
<p>Rey-Benayas, J.M., de la Montaña, E., Pérez-Camacho, L., de la Cruz, M., Moreno, D., Parejo, J.L. and Suárez-Seoane, S. 2010. 
Inter-annual dynamics and spatial congruence of a nocturnal bird assemblage inhabiting a Mediterranean agricultural mosaic. <em>Ardeola</em>,57(2): 303-320.
</p>
<p>Syrjala, S. E. 1996. A statistical test for a difference between the spatial distributions of two populations. <em>Ecology</em> 77: 75-80. <a href="https://doi.org/10.2307/2265656">doi:10.2307/2265656</a>.
</p>
<p>Waagepetersen, R. P. 2007. An estimating function approach to inference for inhomogeneous Neymann-Scott processes. <em>Biometrics</em> 63: 252-258. <a href="https://doi.org/10.1111/j.1541-0420.2006.00667.x">doi:10.1111/j.1541-0420.2006.00667.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#############################################
### Transfom easily data from a data.frame into the ppp format 
### of spatstat:

data(fig1)

plot(fig1) #typical xyplot

fig1.ppp &lt;- haz.ppp (fig1)

fig1.ppp

plot(fig1.ppp) # point pattern plot of spatstat



#############################################
###  Summarize the joint pattern of points and marks at different scales
###  with the normalized mark-weighted K-function (Penttinen, 2006). 
###  Compare this function in two consecutive cohorts of Helianthemum
###  squamatum seedlings:

 ## Figure 3.10 of De la Cruz (2008):
  
  data(seedlings1)
  
  data(seedlings2)
  
  s1km &lt;- Kmm(seedlings1, r=1:100)
  
  s2km &lt;- Kmm(seedlings2, r=1:100)
  
  plot(s1km, ylime=c(0.6,1.2), lwd=2, maine="", xlabe="r(cm)")

  plot(s2km,  lwd=2, lty=2, add=T )

  abline(h=1, lwd=2, lty=3)
  
  legend(x=60, y=1.2, legend=c("Hs_C1", "Hs_C2", "H0"),
	 lty=c(1, 2, 3), lwd=c(3, 2, 2), bty="n")
 
## A pointwise test of normalized Kmm == 1 for seedlings1:

   s1km.test &lt;- Kmm(seedlings1, r=1:100, nsim=99)

   plot(s1km.test,  xlabe="r(cm)")
   
   
   

#############################################
###  Explore the local relationships between marks and locations (e.g. size 
###  of one cohort of H. squamatum seedlings). Map the marked point pattern 
###  to a random field for visual inspection, with the normalized mark-sum
###  measure (Penttinen, 2006).

data(seedlings1)
   
 seed.m &lt;- marksum(seedlings1, R=25)

 plot(seed.m, what="marksum", sigma = 5)  # raw mark-sum measure; sigma is bandwith for smoothing

 plot(seed.m, what="pointsum", sigma = 5) # point sum measure
   
 plot(seed.m,  what="normalized", dimyx=200, contour=TRUE, sigma = 5) # normalized  mark-sum measure

# the same with added grid

 plot(seed.m,  what="normalized", dimyx=200, contour=TRUE, sigma = 5, grid=TRUE) 



#############################################
###  Test against the null model of "independent labelling",
###  i.e. test asociation/repulsion between  a "fixed" pattern (e.g. adult
###  H. squamatum plants) and a "variable" pattern (e.g. of surviving and 
###  dead seedlings), with 2.5% and 97.5% envelopes of 999 random 
###  labellings (De la Cruz &amp; al. 2008).

data(Helianthemum)


cosa &lt;- K012(Helianthemum, fijo="adultHS", i="deadpl", j="survpl",
             r=seq(0,200,le=201), nsim=999, nrank=25, correction="isotropic")

plot(cosa$k01, sqrt(./pi)-r~r,  col=c(3, 1, 3), lty=c(3, 1, 3), las=1,
         ylab=expression(L[12]), xlim=c(0, 200), 
	 main="adult HS vs. dead seedlings", legend=FALSE)

plot(cosa$k02, sqrt(./pi)-r~r, col=c(3, 1, 3), lty=c(3, 1, 3), las=1, 
         ylab=expression(L[12]), xlim=c(0, 200),
 	 main="adult HS vs. surviving seedlings", legend=FALSE)



#############################################
###  Test differences of agregation and segregation between two patterns, 
###  e.g. surviving and dying H. squamatum seedlings (De la Cruz &amp; al. 2008). 

data(Helianthemum)

cosa12 &lt;- K1K2(Helianthemum, j="deadpl", i="survpl", r=seq(0,200,le=201),
		 nsim=999, nrank=1, correction="isotropic")

plot(cosa12$k1k2, lty=c(2, 1, 2), col=c(2, 1, 2), xlim=c(0, 200),
         main= "survival- death",ylab=expression(K[1]-K[2]), legend=FALSE)

plot(cosa12$k1k12, lty=c(2, 1, 2), col=c(2, 1, 2), xlim=c(0, 200),
	 main="segregation of surviving seedlings",ylab=expression(K[1]-K[12]), legend=FALSE)

plot(cosa12$k2k12, lty=c(2, 1, 2), col=c(2, 1, 2), xlim=c(0, 200),
         main= "segregation of dying seedlings",ylab=expression(K[2]-K[12]), legend=FALSE)


#############################################
###  Test 'univariate' and 'bivariate' point patterns 
###  against non-Poisson (in-)homogeneous models 
###  (De la Cruz and Escudero, submited).

 data(urkiola)

   #####################
   ## univariate example

   # get univariate pp
   I.ppp &lt;- split.ppp(urkiola)$birch

   # estimate inhomogeneous intensity function
   I.lam &lt;- predict (ppm(I.ppp, ~polynom(x,y,2)), type="trend", ngrid=200)

   # Compute and plot envelopes to Kinhom, simulating from an Inhomogeneous
   #  Poisson Process:
   
   I2.env &lt;- envelope( I.ppp,Kinhom, lambda=I.lam, correction="trans", 
                              nsim=99, simulate=expression(rpoispp(I.lam)))
   plot(I2.env, sqrt(./pi)-r~r, xlab="r (metres)", ylab= "L (r)", col=c(1,3,2,2),legend=FALSE) 

   # It seems that there is short scale clustering; let's fit an Inhomogeneous 
   # Poisson Cluster Process: 

   I.ki &lt;- ipc.estK(mippp=I.ppp, lambda=I.lam, correction="trans")

   # Compute and plot envelopes to Kinhom, simulating from the fitted IPCP:

   Ipc.env &lt;- Ki(I.ki, correction="trans", nsim=99, ngrid=200)

   plot (Ipc.env, xlab="r (metres)", ylab= "L (r)")
 
   #####################
   ## bivariate example: test independence between birch and quercus in Urkiola

   J.ppp &lt;- split.ppp(urkiola)$oak
   
   # We want to simulate oak from a homogeneous Poisson model:
   J.ppm &lt;- ppm(J.ppp, trend=~1, interaction=Poisson() )
   
   IJ.env &lt;- Kci (mod1=I.ki, mod2=J.ppm, nsim=99)
   
   plot(IJ.env, type=12)
   
   plot(IJ.env, type=21)




#############################################
###  Simulate envelopes from the fitted values of a logistic model,
###  as in Olano et al. (2009)
   
   
   data(quercusvm)

   # read fitted values from logistic model:
   
   
   probquercus &lt;-c(0.99955463, 0.96563477, 0.97577094, 0.97327199, 0.92437309,
   0.84023396, 0.94926682, 0.89687281, 0.99377915, 0.74157478, 0.95491518,
   0.72366493, 0.66771787, 0.77330148, 0.67569082, 0.9874892, 0.7918891, 
   0.73246803, 0.81614635, 0.66446411, 0.80077908, 0.98290508, 0.54641754,
   0.53546689, 0.73273626, 0.7347013, 0.65559655, 0.89481468, 0.63946334,
   0.62101995, 0.78996371, 0.93179582, 0.80160346, 0.82204428, 0.90050059,
   0.83810669, 0.92153079, 0.47872421, 0.24697004, 0.50680935, 0.6297911, 
   0.46374812, 0.65672284, 0.87951682, 0.35818237, 0.50932432, 0.92293014,
   0.48580241, 0.49692053, 0.52290553, 0.7317549, 0.32445982, 0.30300865,
   0.73599359, 0.6206056, 0.85777043, 0.65758613, 0.50100406, 0.31340849, 
   0.22289286, 0.40002879, 0.29567678, 0.56917817, 0.56866864, 0.27718552,
   0.4910667, 0.47394411, 0.40543788, 0.29571349, 0.30436276, 0.47859015,
   0.31754526, 0.42131675, 0.37468782, 0.73271225, 0.26786274, 0.59506388, 
   0.54801851, 0.38983575, 0.64896835, 0.37282031, 0.67624306, 0.29429766,
   0.29197755, 0.2247629, 0.40697843, 0.17022391, 0.26528042, 0.24373722,
   0.26936163, 0.13052254, 0.19958585, 0.18659692, 0.36686678, 0.47263005,
   0.39557661, 0.68048997, 0.74878567, 0.88352322, 0.93851375)
   
  

   ################################ 
   ## Envelopes for an homogeneous point pattern:
   
   cosap &lt;- Kinhom.log(A=quercusvm, lifemark="0", nsim=99, prob=probquercus)

   plot(cosap)

   
   ################################ 
   ## Envelopes for an inhomogeneous point pattern:
   
   ## First, fit an inhomogeneous Poisson model to alive trees :
   
   quercusalive &lt;- unmark(quercusvm[quercusvm$marks == 0])

    mod2 &lt;- ppm(quercusalive, ~polynom(x,y,2))

    ## Now use mod2 to estimate lambda for K.inhom:
    
    cosapm &lt;- Kinhom.log(A=quercusvm, lifemark="0", prob=probquercus,
                                   nsim=99,  mod=mod2)
    plot(cosapm)




#############################################
###  Test segregation based on the counts in the contingency table
###  of nearest neighbors in a multitype point pattern (Dixon, 2002)

data(swamp)

dixon2002(swamp,nsim=99)




#############################################
###  Fit the Poisson cluster point process to a point pattern with 
###  the method of minimum contrast (Diggle 2003).

data(gypsophylous)

# Estimate K function ("Kobs").

gyps.env &lt;- envelope(gypsophylous, Kest, correction="iso", nsim=99)

plot(gyps.env, sqrt(./pi)-r~r, ylab="L(r)", legend=FALSE)

# Fit Poisson Cluster Process. The limits of integration 
# rmin and rmax are setup to 0 and 60, respectively. 

cosa.pc &lt;- pc.estK(Kobs = gyps.env$obs[gyps.env$r&lt;=60],
		           r = gyps.env$r[gyps.env$r&lt;=60])

# Add fitted Kclust function to the plot.

lines(gyps.env$r,sqrt(Kclust(gyps.env$r, cosa.pc$sigma2,cosa.pc$rho)/pi)-gyps.env$r,
       lty=2, lwd=3, col="purple")

# A kind of pointwise test of the gypsophylous pattern been a realisation
# of the fitted model, simulating with sim.poissonc and using function J (Jest).

gyps.env.sim &lt;- envelope(gypsophylous, Jest, nsim=99,
                    simulate=expression(sim.poissonc(gypsophylous,
		    sigma=sqrt(cosa.pc$sigma2), rho=cosa.pc$rho)))

 plot(gyps.env.sim,  main="",legendpos="bottomleft")






#############################################
###  Compute Syrjala's test for the difference between the spatial 
###  distributions of two populations, as in Rey-Benayas et al. 
### (submited)


 
   data(syr1); data(syr2); data(syr3)
   
   plot(syrjala.test(syr1, syr2, nsim=999)) 
   
   plot(syrjala.test(syr1, syr3, nsim=999)) 
   




## End(Not run)
</code></pre>

<hr>
<h2 id='dixon2002'> Dixon (2002) Nearest-neighbor contingency table analysis </h2><span id='topic+dixon2002'></span>

<h3>Description</h3>

<p><code>dixon2002</code> is a wrapper to the functions of Dixon (2002) to test spatial segregation for several species by analyzing the 
counts of the nearest neighbour contingency table for a marked point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dixon2002(datos, nsim = 99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dixon2002_+3A_datos">datos</code></td>
<td>
 <p><code>data.frame</code> with three columns: x-coordinate, y-coordinate and sp-name.
See <code><a href="#topic+swamp">swamp</a></code>. </p>
</td></tr>
<tr><td><code id="dixon2002_+3A_nsim">nsim</code></td>
<td>
<p> number of simulations for the randomization approximation of the p-values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A measure of segregation describes the tendency of one species to be  associated with itself or with other species. Dixon (2002) proposed a measure of the 
<strong>segregation of species</strong> <em>i</em> in a multiespecies  spatial pattern as:
</p>
<p style="text-align: center;"><code class="reqn">S[i] = log{[(N[ii]/(N[i]-N[ii])] / [(N[i]-1)/(N-N[i])]}</code>
</p>

<p>where <code class="reqn">N[i]</code> is the number of individuals of species <em>i</em>, <code class="reqn">N[ii]</code> is the frequency of species <em>i</em> as neighbor of especies <em>i</em> and <code class="reqn">N</code> is the total
number of locations.   Values of <code class="reqn">S[i]</code> larger than 0 indicate that species <em>i</em> is segregated; the larger the value of <code class="reqn">S[i]</code>, the more extreme the segregation. 
Values of <code class="reqn">S[i]</code> less than 0 indicate that species <em>i</em> is is found as neighbor of itself less than expected under random labelling. 
Values of <code class="reqn">S[i]</code> close to 0 are consistent with random labelling of the neighbors of species <em>i</em>.
</p>
<p>Dixon (2002) also proposed a <strong>pairwise segregation index</strong> for the off-diagonal elements of the contingency table:
</p>
<p style="text-align: center;"><code class="reqn">S[ij] = log{[(N[ij]/(N[i]-N[ij])] / [(N[i])/(N-N[j])-1]}</code>
</p>

<p><code class="reqn">S[ij]</code> is larger than 0 when <code class="reqn">N[ij]</code>, the frequency of neighbors of species <em>j</em> around points of species <em>i</em>, is larger than expected under random
labelling and less than 0 when <code class="reqn">N[ij]</code> is smaller than expected under random labelling.
</p>
<p>As a <strong>species/neighbor-specific test</strong>, Dixon(2002) proposed the statistic
</p>
<p style="text-align: center;"><code class="reqn">Z[ij] =(N[ij] -EN[ij])/sqrt(Var N[ij])</code>
</p>

<p>where <em>j</em> may be the same as <em>i</em> and <code class="reqn">EN[ij]</code> is the expected count in the contingency table. It has an asymptotic normal distribution with mean 0 
and variance 1;  its asymptotic p-value  can be obtained from the numerical evaluation of the cumulative normal distribution; when the sample size is small, a p-value on the observed counts in each cell (<code class="reqn">N[ij]</code>) may be obtained by simulation, i.e, by condicting a randomization test. 
</p>
<p>An <strong>overall test of random labelling</strong> (i.e. a test that all counts in the <code class="reqn">k</code> x <code class="reqn">k</code> nearest-neighbor contingency table are equal to their expected counts) is based
on the quadratic form
</p>
<p style="text-align: center;"><code class="reqn"> C = (N-EN)' Sigma^- (N - EN)</code>
</p>

<p>where <code class="reqn">N</code> is the vector of all cell counts in the contingency table, <code class="reqn">Sigma</code> is the variance-covariance matrix of those counts and <code class="reqn">Sigma^-</code>
is a generalized inverse of <code class="reqn">Sigma</code>. Under the null hypothesis of random labelling of points, <code class="reqn">C</code>  has a asymptotic Chi-square distribution with <code class="reqn">k(k-1)</code> 
degrees of freedom (if the sample sizes are small its distribution should be estimated using Monte-Carlo simulation). P-values are computed from the probability of observing
equal or larger values of <code class="reqn">C</code>.
The overall statistic <code class="reqn">C</code> can be partitioned into <code class="reqn">k</code> <strong>species-specific test</strong> statistics <code class="reqn">C[i]</code>. Each <code class="reqn">C[i]</code> test if the frequencies of the neighbors 
of species <em>i</em> are similar to the expected frequencies if the points were randomly labelled. Because the <code class="reqn">C[i]</code> are not independent Chi-square statistics, they do not
sum to the overall <code class="reqn">C</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>ON</code></td>
<td>
<p>Observed nearest neighbor counts in table format. From row sp to column sp.  </p>
</td></tr>
<tr><td><code>EN</code></td>
<td>
<p>Expected nearest neighbor counts in table format.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>Z-score for testing whether the observed count equals the expected count.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Segregation measure.</p>
</td></tr>
<tr><td><code>pZas</code></td>
<td>
<p>P-values based on the asymptotic normal distribution of the Z statistic.</p>
</td></tr>
<tr><td><code>pNr</code></td>
<td>
<p>If nsim !=0, p-values of the observed counts in each cell based on the randomization distribution.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Overall test of random labelling.</p>
</td></tr>
<tr><td><code>Ci</code></td>
<td>
<p>Species-specific test of random labelling.</p>
</td></tr>
<tr><td><code>pCas</code></td>
<td>
<p>P-value of the overall test from the asymptotic chi-square distribution with the appropriate degrees of freedom.</p>
</td></tr>
<tr><td><code>pCias</code></td>
<td>
<p>P-values of the species-specific tests from the asymptotic chi-square distribution with the appropriate degrees of freedom.</p>
</td></tr>
<tr><td><code>pCr</code></td>
<td>
<p>If nsim !=0, p-value of the overall test from the randomization distribution.</p>
</td></tr>
<tr><td><code>pCir</code></td>
<td>
<p>If nsim !=0, p-values of the species-specific tests from the randomization distribution.</p>
</td></tr>
<tr><td><code>tablaZ</code></td>
<td>
<p>table with ON, EN, Z, S, pZas and pNr in pretty format, as in the table II of Dixon (2002).</p>
</td></tr>
<tr><td><code>tablaC</code></td>
<td>
<p>table with C, Ci, pCas,pCias, pCr and pCir  in pretty format, as in the table IV of Dixon (2002).</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The <code class="reqn">S[i]</code> and <code class="reqn">S[ij]</code> statistics asume that the spatial nearest-neighbor process is stationary, at least to second order, 
i.e., have the same sign in every part of the entire plot. A biologically heterogeneous process will violate this asumption.
</p>


<h3>Author(s)</h3>

 
<p>Philip M. Dixon . Marcelino de la Cruz  wrote the wrapper code  for the <code>ecespa</code> version.
</p>


<h3>References</h3>

 
<p>Dixon, P.M. 2002. Nearest-neighbor contingency table analysis of spatial segregation for several species.
<em>Ecoscience</em>, 9 (2): 142-151. <a href="https://doi.org/10.1080/11956860.2002.11682700">doi:10.1080/11956860.2002.11682700</a>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+K012">K012</a></code> for another segregation test, based in the differences of univariate and bivariate <code class="reqn">K</code>-functions. A faster version of this function, with code implemented in FORTRAN it is available in function <code><a href="dixon.html#topic+dixon">dixon</a></code> in <span class="pkg">dixon</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(swamp)

dixon2002(swamp,nsim=99)


</code></pre>

<hr>
<h2 id='ecespa-internal'> Internal ecespa functions. </h2><span id='topic+check'></span><span id='topic+ginv'></span><span id='topic+mNNinfo'></span><span id='topic+mNNinfo2'></span><span id='topic+mNNtest'></span><span id='topic+NNid'></span>

<h3>Description</h3>

<p>Internal ecespa functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>check(x, v, l1, l2)
ginv(m)
mNNinfo2(n, R, Q)
mNNinfo(xy, label, nnid = NULL)
mNNtest(info, obsN = NULL)
NNid(xy)
</code></pre>


<h3>Details</h3>

<p>These fucntions are called by <code><a href="#topic+dixon2002">dixon2002</a></code> and are usually not to be called by the user.
</p>


<h3>Author(s)</h3>

<p> Philip M. Dixon </p>

<hr>
<h2 id='figuras'>Artificial point data.</h2><span id='topic+fig1'></span><span id='topic+fig2'></span><span id='topic+fig3'></span><span id='topic+figuras'></span>

<h3>Description</h3>

<p>The three different point patterns in the figure 3.1 of De la Cruz (2008) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fig1)
data(fig2)
data(fig3)
</code></pre>


<h3>Format</h3>

<p>A data frame with 87 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>x coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y coordinate</p>
</dd>
</dl>



<h3>References</h3>

<p>De la Cruz, M. 2008. Métodos para analizar datos puntuales. 
En: <em>Introducción al Análisis Espacial de Datos en Ecología y Ciencias Ambientales: Métodos y Aplicaciones </em> 
(eds. Maestre, F. T., Escudero, A. y Bonet, A.), pp 76-127. Asociación Española de Ecología Terrestre, Universidad Rey Juan Carlos
y Caja de Ahorros del Mediterráneo, Madrid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fig1)

data(fig2)

data(fig3)

# transform to ppp format of spatstat with function haz.ppp:

fig1.ppp &lt;- haz.ppp(fig1)

fig2.ppp &lt;- haz.ppp(fig2)

fig3.ppp &lt;- haz.ppp(fig3)

#Analyses as in Fig.3.2 of De la Cruz (2008). First, compute function K:

cosa1 &lt;- Kest(fig1.ppp)

# Plot different estimators. 
# Fig. 3.2a: 

par("mar"=par("mar")+c(0,1,0,0))

plot(cosa1, col=c(1,0,0,1), lwd=c(2,2,2,2), lty=c(1,1,1,2), 
	 main="")

# Fig. 3.2b:

plot(cosa1, sqrt(./pi)-r~r, col=c(1,0,0,1), lwd=c(2,2,2,2), 
         lty=c(1,1,1,2), main="", ylab="L(r)")

# Fig. 3.2c:

plot(cosa1, .-(pi*r^2)~r, col=c(1,0,0,1), lwd=c(2,2,2,2), 
         lty=c(1,1,1,2), main="", ylab=expression(K(r)-pi*r^2))

# Fig. 3.2d:

plot(cosa1,(./(pi*r^2))-1~r, col=c(1,0,0,1), lwd=c(2,2,2,2), 
	 lty=c(1,1,1,2), main="",
         ylab=expression((K(r)/pi*r^2)-1))

## Analyses as in fig. 3.7 of De la Cruz (2008).
## First, compute function K and pointwise envelopes:

cosa1.env &lt;- envelope(fig1.ppp, Kest)

cosa2.env &lt;- envelope(fig2.ppp, Kest)

cosa3.env &lt;- envelope(fig3.ppp, Kest)

## Plot function L with pointwise envelopes:

plot(cosa1.env,sqrt(./pi)-r~r, lwd=c(1,1,2,2), 
	 lty=c(1,1,3,3), col=c(1,1,1,1), xlab="r", 
         ylab="L(r)", main="", ylim=c(-2,2))

## Add simultaneous envelopes of Ripley (+-1.68 *sqrt(A)/N):

abline(h=1.68*sqrt(area.owin(fig1.ppp$window))/fig1.ppp$n, 
         lty=2, lwd=2)

abline(h=-1.68*sqrt(area.owin(fig1.ppp$window))/fig1.ppp$n, 
         lty=2, lwd=2)

## Plot function L with pointwise envelopes:

plot(cosa2.env,sqrt(./pi)-r~r, lwd=c(1,1,2,2), 
         lty=c(1,1,3,3), col=c(1,1,1,1), xlab="r", 
         ylab="L(r)", main="")

## Add simultaneous envelopes of Ripley:

abline(h=1.68*sqrt(area.owin(fig2.ppp$window))/fig2.ppp$n, 
         lty=2, lwd=2)

abline(h=-1.68*sqrt(area.owin(fig2.ppp$window))/fig2.ppp$n, 
         lty=2, lwd=2)

## Plot function L with pointwise envelopes:

plot(cosa3.env,sqrt(./pi)-r~r, lwd=c(1,1,2,2), 
         lty=c(1,1,3,3), col=c(1,1,1,1), xlab="r", 
         ylab="L(r)", main="")

## Add simultaneous envelopes of Ripley:

abline(h=1.68*sqrt(area.owin(fig3.ppp$window))/fig3.ppp$n, 
         lty=2, lwd=2)

abline(h=-1.68*sqrt(area.owin(fig3.ppp$window))/fig3.ppp$n, 
         lty=2, lwd=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='getis'> Neighbourhood density function </h2><span id='topic+getis'></span><span id='topic+plot.ecespa.getis'></span><span id='topic+print.ecespa.getis'></span>

<h3>Description</h3>

<p>Computes and plots the neighbourhood density function, a local version of the <code class="reqn">K</code>-function defined by Getis and Franklin (1987). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getis(mippp, nx = 30, ny = 30, R = 10)

## S3 method for class 'ecespa.getis'
plot(x, type="k", dimyx=NULL, xy=NULL, eps=NULL,  color=NULL,
         contour=TRUE, points=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getis_+3A_mippp">mippp</code></td>
<td>
<p>A point pattern. An object with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of <code>spatstat</code>. </p>
</td></tr>
<tr><td><code id="getis_+3A_nx">nx</code></td>
<td>
<p>Grid dimensions (for estimation) in the x-side. </p>
</td></tr>
<tr><td><code id="getis_+3A_ny">ny</code></td>
<td>
<p>Grid dimensions (for estimation) in the y-side. </p>
</td></tr>
<tr><td><code id="getis_+3A_r">R</code></td>
<td>
<p>Radius. The distance argument <em> r</em> at which the function <code class="reqn">K</code> should be computed. </p>
</td></tr>
<tr><td><code id="getis_+3A_x">x</code></td>
<td>
<p>Result of applying <code>getis</code> to a point pattern. </p>
</td></tr>
<tr><td><code id="getis_+3A_type">type</code></td>
<td>
<p>Type of local statistics to be ploted. One of <code>k</code> (local-<code class="reqn">K</code>), <code>l</code> (local-<code class="reqn">L</code>), <code>n</code> (local-<code class="reqn">n</code>) or <code>d</code> (deviations from CSR).</p>
</td></tr>
<tr><td><code id="getis_+3A_color">color</code></td>
<td>
<p>A list of colors such as that generated by <code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, <code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>, <code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>, <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code> or similar functions.</p>
</td></tr>
<tr><td><code id="getis_+3A_dimyx">dimyx</code></td>
<td>
<p>pixel array dimensions, will be passed to (i.e. see details in) <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>.</p>
</td></tr>
<tr><td><code id="getis_+3A_xy">xy</code></td>
<td>
<p>pixel coordinates, will be passed to (i.e. see details in) <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>.</p>
</td></tr>
<tr><td><code id="getis_+3A_eps">eps</code></td>
<td>
<p>width and height of pixels, will be passed to (i.e. see details in) <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>.</p>
</td></tr>
<tr><td><code id="getis_+3A_contour">contour</code></td>
<td>
<p>Logical; if TRUE, add a contour to current plot.</p>
</td></tr>
<tr><td><code id="getis_+3A_points">points</code></td>
<td>
<p>Logical; if TRUE, add the point pattern to current plot.</p>
</td></tr>
<tr><td><code id="getis_+3A_...">...</code></td>
<td>
<p> Additional graphical parameters passed to <code>link{plot}</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Getis and Franklin (1987) proposed the neigbourhood density function, a local version of Ripley's <code class="reqn">L</code>- function.
Given a spatial point pattern <code class="reqn">X</code>, the neigbourhood density function associated with the <em>i</em>th point in <code class="reqn">X</code> is computed by
</p>
<p style="text-align: center;"><code class="reqn">L[i](r) = sqrt((a/((n-1))*pi))*sum[j]e[i,j])</code>
</p>

<p>where the sum is over all points <em> j != i</em> that lie within a distance <em>r</em> of the <em>i</em>th point, <em>a</em> is the area of the observation window,
<em>n</em> is the number of points in <code class="reqn">X</code>, and <em>e[i,j]</em> is the isotropic edge correction term (as described in <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>). The value of <em>L[i](r)</em> can also
be interpreted as one of the summands that contributes to the global estimate of the <code class="reqn">L</code>-function. 
</p>
<p>The command <code>getis</code> actually computes the local <code class="reqn">K</code>-function using <code><a href="spatstat.explore.html#topic+Kcross">Kcross</a></code>. As the main objective of <code>getis</code> is to map the local density function,  
as sugested by Gestis and Franklin (1987: 476) a grid of  points (whose density is controled by <code>nx</code> and <code>ny</code>),  is used to accurately estimate the
functions in empty or sparse areas. The S3 method  <code>plot.ecespa.getis</code>  plots the spatial distribution of  the local <code class="reqn">K</code> or <code class="reqn">L</code> function or other related local statistics, such as 
<code class="reqn">n[i](r)</code>, the number of neighbor points [=<code class="reqn"> lambda*K[i](r)</code>]  or the deviations from  the expected value of  local  <code class="reqn">L</code>  under CSR [= <code class="reqn">L[i](r) -r</code>].  It some of the arguments <code>dimyx</code>, <code>xy</code> or <code>eps</code> is provided it will use the function 
<code><a href="spatstat.geom.html#topic+interp.im">interp.im</a></code> in <code>spatstat</code> package to interpolate the results;otherwise it will plot the estimated values at the origial grid points. 
</p>


<h3>Value</h3>

<p><code>getis</code> gives an object of class <code>ecespa.getis</code>, bassically a list with the following elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x coordinates of pattern points (ahead) and grid points.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y coordinates of pattern points (ahead) and grid points.</p>
</td></tr>
<tr><td><code>klocal</code></td>
<td>
<p>Estimate of local <code class="reqn">K[i](r)</code> at the point pattern points.</p>
</td></tr>
<tr><td><code>klocalgrid</code></td>
<td>
<p>Estimate of local <code class="reqn">K[i](r)</code> at the grid points.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Distance <code class="reqn">r</code> at which the estimation is made.</p>
</td></tr>
<tr><td><code>nx</code></td>
<td>
<p>Density of the estimating grid  in the x-side. </p>
</td></tr> 
<tr><td><code>ny</code></td>
<td>
<p>Density of the estimating grid  in the x-side. </p>
</td></tr> 
<tr><td><code>dataname</code></td>
<td>
<p>Name of the ppp object analysed. </p>
</td></tr> 
<tr><td><code>ppp</code></td>
<td>
<p>Original point pattern.</p>
</td></tr>
</table>
<p><code>plot.ecespa.getis</code> plots an interpolated map of the selected local statistics
</p>


<h3>Note</h3>

<p>As <code>plot.ecespa.getis</code> interpolates over rectangular grid of points, it is not apropriate to map irregular windows. In those cases, <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code> of <code>spatstat</code>
can be used to interpolate the local statistics (see examples).
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot </p>


<h3>References</h3>

 
<p>Getis, A. and Franklin, J. 1987. Second-order neighbourhood analysis of mapped point patterns. <em>Ecology</em> 68: 473-477. <a href="https://doi.org/10.2307/1938452">doi:10.2307/1938452</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="spatstat.explore.html#topic+localK">localK</a></code>, a different approach in <span class="pkg">spatstat</span>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Compare with fig. 5b of Getis &amp; Franklin (1987: 476):
  
  data(ponderosa)
  
  #ponderosa12 &lt;- getis(ponderosa, nx = 30, ny = 30, R = 12)
  ponderosa12 &lt;- getis(ponderosa, nx = 20, ny = 20, R = 12)
  
  plot(ponderosa12, type = "l", dimyx=256)
  
## Not run: 
  ## Plot the same, using Smooth.ppp in spatstat
  
  ponderosa.12 &lt;- setmarks(ponderosa, ponderosa12$klocal)
  
  Z &lt;- Smooth(ponderosa.12, sigma=5, dimyx=256)
  
  plot(Z, col=topo.colors(128), main="smoothed neighbourhood density")
  
  contour(Z, add=TRUE)
  
  points(ponderosa, pch=16, cex=0.5) 
  

  ## Example with irregular window:
  
  data(letterR)
  
  X &lt;- rpoispp(50, win=letterR)
  
  X.g &lt;- getis(X, R=0.2)
  
  plot(X.g,dimyx=c(200,100))
  
   ## Plot the same, using Smooth.ppp in spatstat
    X2 &lt;- setmarks(X, X.g$klocal)
  
    Z &lt;- Smooth(X2, sigma=0.05, dimxy=256)
  
    plot(Z, col=topo.colors(128), main="smoothed neighbourhood density")
  
    contour(Z, add=TRUE)
  
    points(X, pch=16, cex=0.5)
  
    
    
## End(Not run)
</code></pre>

<hr>
<h2 id='gypsophylous'> Spatial point pattern of a plant community</h2><span id='topic+gypsophylous'></span>

<h3>Description</h3>

<p>Locations of  plants  in a gypsophylous plant community in Central Spain. These are part of the data collected by Romao (2003) that have been
analyzed several times (Escudero <em>et al.</em> 2005, De la Cruz 2006).
The coordinates of the plans are given in cm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gypsophylous)</code></pre>


<h3>Format</h3>

<p>An object of class &quot;ppp&quot;  of <code>spatstat</code> representing the point pattern of plants locations. See <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> 
for details of the format.
</p>


<h3>Source</h3>

<p>Romao, R.L. 2003. <em>Estructura espacial de comunidades de gipsófitos: interacciones bióticas
y constricciones abióticas.</em> Tesis Doctoral. Universidad Politécnica de Madrid.
</p>


<h3>References</h3>

<p>De la Cruz, M. 2006. Introducción al análisis de datos mapeados o algunas de las (muchas) cosas
que puedo hacer si tengo coordenadas. <em>Ecosistemas</em>  15 (3): 19-39. 
</p>
<p>Escudero, A., Romao, R.L., De la Cruz, M. &amp; Maestre, F. 2005. Spatial pattern and neighbour effects on 
<em>Helianthemum squamatum</em> seedlings in a Mediterranean gypsum community. <em>Journal of  Vegetation  Science</em>,  16: 383-390. <a href="https://doi.org/10.1111/j.1654-1103.2005.tb02377.x">doi:10.1111/j.1654-1103.2005.tb02377.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

data(gypsophylous)

plot(gypsophylous)


## End(Not run)
</code></pre>

<hr>
<h2 id='haz.ppp'>Easily convert xy data to ppp format</h2><span id='topic+haz.ppp'></span>

<h3>Description</h3>

<p>ppp maker for the impatient  layman
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haz.ppp(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haz.ppp_+3A_w">W</code></td>
<td>
<p> a data frame or matrix with two or three columns (coordinate x, coordinate y, and mark of the point)  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This naive function easily transform your xy data to the format required by spatstat (version &lt;2.0). 
It establishes the window of observation as the rectangle defined by the xy range.
It asumes that the first two columns are coordinates x and y, and the third (if any) gives the marks of the points.
</p>


<h3>Value</h3>

<p>A point pattern with the format of spatstat v. &lt; 2.0
</p>


<h3>Note</h3>

<p>This window is an underestimate of the real sampling window of the observed points. For a less biassed estimate, use function <code><a href="spatstat.geom.html#topic+ripras">ripras</a></code> in spatstat.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz </p>


<h3>See Also</h3>

 <p><code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>, <code><a href="spatstat.geom.html#topic+as.ppp">as.ppp</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(fig1)

plot(fig1) #typical xyplot

fig1.ppp &lt;- haz.ppp (fig1)

fig1.ppp

plot(fig1.ppp) # point pattern plot of spatstat


</code></pre>

<hr>
<h2 id='Helianthemum'> Spatial point pattern of Helianthemum squamatum adult plants and seedlings </h2><span id='topic+Helianthemum'></span>

<h3>Description</h3>

<p>Locations of <em>H. squamatum</em> adult plants and seedlings in a 6 m x 7 m plot over gypsum soil 
in Chinchón (near Madrid, Spain). These are part of the data collected by Romao (2003) that have been
analyzed several times (Escudero <em>et al.</em>2005, De la Cruz 2006, De la Cruz et al. <em>in press.</em> ).
The coordinates of the plans are given in cm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Helianthemum)</code></pre>


<h3>Format</h3>

<p>An object of class &quot;ppp&quot;  of <code>spatstat</code> representing the point pattern of plants locations marked by their type. See <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> 
for details of the format.The dataset has 866 points with the following levels: 
</p>

<dl>
<dt>adultHS</dt><dd><p>adult <em>H. squamatum</em> plants</p>
</dd>
<dt>deadp</dt><dd><p>dying <em>H. squamatum</em> seedlings</p>
</dd>
<dt>survpl</dt><dd><p>surviving <em>H. squamatum</em> seedlings</p>
</dd>
</dl>



<h3>Source</h3>

<p>Romao, R.L. 2003. <em>Estructura espacial de comunidades de gipsófitos: interacciones bióticas
y constricciones abióticas.</em> Tesis Doctoral. Universidad Politécnica de Madrid.
</p>


<h3>References</h3>

<p>De la Cruz, M. 2006. Introducción al análisis de datos mapeados o algunas de las (muchas) cosas  que puedo hacer si tengo coordenadas. <em>Ecosistemas</em>  15 (3): 19-39. 
</p>
<p>De la Cruz, M., Romao, R.L.,  Escudero, A. and Maestre, F.T. 2008. Where do seedlings go? A spatio-temporal analysis of
early mortality in a semiarid specialist. <em>Ecography</em>,31(6): 720-730. <a href="https://doi.org/10.1111/j.0906-7590.2008.05299.x">doi:10.1111/j.0906-7590.2008.05299.x</a>.
</p>
<p>Escudero, A., Romao, R.L., De la Cruz, M. &amp; Maestre, F. 2005. Spatial pattern and neighbour effects on 
<em>Helianthemum squamatum</em> seedlings in a Mediterranean gypsum community. <em>Journal of  Vegetation  Science</em>,  16: 383-390. <a href="https://doi.org/10.1111/j.1654-1103.2005.tb02377.x">doi:10.1111/j.1654-1103.2005.tb02377.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Helianthemum)
plot(Helianthemum)
</code></pre>

<hr>
<h2 id='ipc.estK'> Fit the (In)homogeneous Poisson Cluster Point Process by Minimum Contrast </h2><span id='topic+ipc.estK'></span><span id='topic+plot.ecespa.minconfit'></span><span id='topic+print.ecespa.minconfit'></span><span id='topic+ecespa.minconfit'></span>

<h3>Description</h3>

<p>Fits the (In)homogeneous Poisson Cluster point process to a point pattern dataset by the Method of Minimum Contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipc.estK(mippp, lambda = NULL, correction = "iso", r = NULL, sigma2 = NULL,
            rho = NULL, q = 1/4, p = 2)


## S3 method for class 'ecespa.minconfit'
plot(x, type="L", add=FALSE, xlim=NULL, ylim=NULL, lwd=c(1,1),
           lty=c(1,2), col=c(1,2), main=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipc.estK_+3A_mippp">mippp</code></td>
<td>
<p> Point pattern to which the  (I)PCP will be fitted. A point pattern with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of <code>spatstat</code>. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_lambda">lambda</code></td>
<td>
<p> Optional. Values of the estimated intensity function as a pixel image (object of class &quot;<code><a href="spatstat.geom.html#topic+im">im</a></code>&quot; of spatstat) giving the intensity values at all locations of <code>mippp</code>. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_correction">correction</code></td>
<td>
<p> A character item selecting any of the options &quot;border&quot;, &quot;bord.modif&quot;, &quot;isotropic&quot;, &quot;Ripley&quot; or
&quot;translate&quot;. It specifies the edge correction(s) to be applied in the computation of the <code class="reqn">K(r)</code> function.  </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_r">r</code></td>
<td>
<p>  Numeric vector. The values of the argument <code class="reqn">r</code> at which the <code class="reqn">K(r)</code> functions  should be evaluated.  </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_sigma2">sigma2</code></td>
<td>
<p> Optional. Starting value for the parameter <code class="reqn">sigma2</code> of the Poisson Cluster process. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_rho">rho</code></td>
<td>
<p> Optional. Starting value for the parameter <code class="reqn">rho</code> of the Poisson Cluster process. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_q">q</code></td>
<td>
 <p><code class="reqn">q</code> exponent of the contrast criterion (see <code><a href="spatstat.model.html#topic+mincontrast">mincontrast</a></code>). </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_p">p</code></td>
<td>
 <p><code class="reqn">p</code> exponent of the contrast criterion (see <code><a href="spatstat.model.html#topic+mincontrast">mincontrast</a></code>).  </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_x">x</code></td>
<td>
<p> An object of class 'ecespa.minconfit', resulting of  applying <code>ipc.estK</code> to fit a Poisson Cluster Process. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_type">type</code></td>
<td>
<p> Type of function to be ploted. If type=&quot;L&quot;, function <code class="reqn">L(r)</code> [= <code class="reqn">sqrt(K(r)/pi)-r</code>] is ploted. Otherwise, function <code class="reqn">K(r)</code> is ploted. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_add">add</code></td>
<td>
<p> Logical. Should the curves be added to another plot? </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_xlim">xlim</code></td>
<td>
<p> Vector setting the limits of the x-axis. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_ylim">ylim</code></td>
<td>
<p> Vector setting the limits of the y-axis. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_lwd">lwd</code></td>
<td>
<p> Vector (length=2) setting the line width for ploting the two functions. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_lty">lty</code></td>
<td>
<p> Vector (length=2) setting the line type for ploting the two functions. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_col">col</code></td>
<td>
<p> Vector (length=2) setting the line color for ploting the two functions. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_main">main</code></td>
<td>
<p> Optional. Text to appear as a title of the plot. </p>
</td></tr>
<tr><td><code id="ipc.estK_+3A_...">...</code></td>
<td>
<p> Additional graphical parameters passed to <code>link{plot}</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm fits the (inhomogeneous) Poisson cluster point process (PCP) to a point pattern, by finding the parameters of the (inhomogeneous) Poisson cluster model
which give the closest match between the theoretical K function of the Poisson cluster process and the observed
K function. For a concise explanation of the PCP see <code><a href="#topic+pc.estK">pc.estK</a></code>. For a more detailed explanation of the Method of Minimum Contrast, see <code><a href="spatstat.model.html#topic+mincontrast">mincontrast</a></code>
in <span class="pkg">spatstat</span> or Diggle (2003: 86). 
</p>
<p>The inhomogeneous PCP can be thought of as a thinned process of an homogeneous PCP, where the spatially varying thinning probability
<code class="reqn">f(s)</code> is related to the spatially varying intensity function <code class="reqn">lambda(s)</code> as <code class="reqn">f(s) = lambda(s)/max{lambda(s)}</code> (Waagepetersen, 2007).  
As the inhomogeneous K function  for  the IPCP coincides with the (homogeneous) K function for the corresponding homogeneous PCP, 
the parameters of the underlying homomgeneous PCP can be estimated as those that give the closest match between the theoretical K function 
for the homogeneous PCP and the empirical inhomogeneous K function  for  the observed IPCP.
</p>
<p>This Poisson cluster process can be simulated with <code><a href="#topic+rIPCP">rIPCP</a></code>.
</p>


<h3>Value</h3>

<p><code>ipc.estK</code> gives an object of class '<code>ecespa.minconfit</code>', basically a list with the following components:
</p>
<table>
<tr><td><code>sigma2</code></td>
<td>
<p>Parameter <code class="reqn">sigma^2</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Parameter <code class="reqn">rho</code>. </p>
</td></tr>
<tr><td><code>d.theta</code></td>
<td>
<p>Minimized value of the contrast criterion <code class="reqn">D(theta)</code>. </p>
</td></tr>
<tr><td><code>Kobs</code></td>
<td>
<p>Values of the observed K-function. </p>
</td></tr>
<tr><td><code>Kfit</code></td>
<td>
<p>Values of the fitted K-function. </p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p> Sequence of distances at which <code>Kobs</code> and <code>Kfit</code> have been estimated. </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Original point pattern. </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Original intensity function. </p>
</td></tr>
<tr><td><code>dataname</code></td>
<td>
<p>Name of the original point pattern. </p>
</td></tr>
<tr><td><code>lambdaname</code></td>
<td>
<p>Name of the original intensity function image. </p>
</td></tr>
<tr><td><code>q</code></td>
<td>
 <p><code class="reqn">q</code> exponent of the contrast criterion. </p>
</td></tr>
<tr><td><code>p</code></td>
<td>
 <p><code class="reqn">p</code> exponent of the contrast criterion.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot , inspired by some code of  Philip M. Dixon </p>


<h3>References</h3>

<p>Diggle, P. J. 2003. <em>Statistical analysis of spatial point patterns</em>. Arnold, London.
</p>
<p>Waagepetersen, R. P. 2007. An estimating function approach to inference for inhomogeneous Neymann-Scott processes. <em>Biometrics</em> 63: 252-258. <a href="https://doi.org/10.1111/j.1541-0420.2006.00667.x">doi:10.1111/j.1541-0420.2006.00667.x</a>.
</p>


<h3>See Also</h3>

<p>some functions in <span class="pkg">spatstat</span>: <code><a href="spatstat.model.html#topic+mincontrast">mincontrast</a></code> for a more general implementation of the method of mimimum contrast;
<code><a href="spatstat.model.html#topic+matclust.estK">matclust.estK</a></code> and <code><a href="spatstat.model.html#topic+lgcp.estK">lgcp.estK</a></code> fit other appropriate processes for clustered patterns.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#####################
## Same example as in pc.estK

data(gypsophylous)

# set the number of simulations (nsim=199 or larger for real analyses)
# and resolution for lambda (ngrid=200  or larger for real analyses)
nsim&lt;- 19
ngrid &lt;- 50

## Estimate K function ("Kobs").

gyps.env &lt;- envelope(gypsophylous, Kest, correction="iso", nsim=nsim)

plot(gyps.env, sqrt(./pi)-r~r, legend=FALSE)

## Fit Poisson Cluster Process. The limits of integration 
## rmin and rmax are setup to 0 and 60, respectively. 

cosa.pc2 &lt;- ipc.estK(gypsophylous, r = gyps.env$r[gyps.env$r&lt;=60])

## Add fitted Kclust function to the plot.


plot(cosa.pc2, add=TRUE, lwd=c(3,3))


## A kind of pointwise test of the gypsophylous pattern been a realisation
## of the fitted model, simulating with rIPCP and using function J (Jest).


gyps.env.sim2 &lt;- envelope(gypsophylous, Jest, nsim=nsim,
                    simulate=expression(rIPCP(cosa.pc2)))


plot(gyps.env.sim2,  main="",legendpos="bottomleft")

## Not run: 

#####################
## Inhomogeneous example

data(urkiola)
   
   #####################
   ## univariate case

   # get univariate pp
   I.ppp &lt;- split.ppp(urkiola)$birch

   # estimate inhomogeneous intensity function
   I.lam &lt;- predict (ppm(I.ppp, ~polynom(x,y,2)), type="trend", ngrid=ngrid)

   # Compute and plot envelopes to Kinhom, simulating from an Inhomogeneous
   #  Poisson Process:
   
   I2.env &lt;- envelope( I.ppp,Kinhom, lambda=I.lam, correction="trans", 
                              nsim=nsim, simulate=expression(rpoispp(I.lam)))
   plot(I2.env, sqrt(./pi)-r~r, xlab="r (metres)", ylab= "L (r)", col=c(1,3,2,2),legend=FALSE) 

   # It seems that there is short scale clustering; let's fit an Inhomogeneous 
   # Poisson Cluster Process: 

   I.ki &lt;- ipc.estK(mippp=I.ppp, lambda=I.lam, correction="trans")

   # Compute and plot envelopes to Kinhom, simulating from the fitted IPCP:

   Ipc.env &lt;- Ki(I.ki, correction="trans", nsim=nsim, ngrid=ngrid)

   plot (Ipc.env, xlab="r (metres)", ylab= "L (r)")
 
   #####################
   ## bivariate case: test independence between birch and quercus in Urkiola

   J.ppp &lt;- split.ppp(urkiola)$oak
   
   # We want to simulate oak from a homogeneous Poisson model:
   J.ppm &lt;- ppm(J.ppp, trend=~1, interaction=Poisson() )
   
   IJ.env &lt;- Kci (mod1=I.ki, mod2=J.ppm, nsim=nsim)
   
   plot(IJ.env, type=12)
   
   plot(IJ.env, type=21)

## End(Not run)


</code></pre>

<hr>
<h2 id='K012'> Tests against 'independent labelling' </h2><span id='topic+K012'></span>

<h3>Description</h3>

<p>Given a &quot;fixed&quot; point pattern and some process that asign labels (I,J) to another &quot;variable&quot; point pattern,
<code>K012</code> estimates the combined bivariate K function between the fixed pattern and every type of the 
variable pattern, and  test that they are independent (i.e. that the labels are randomly assigned,
irrespectively of the fixed pattern). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K012(X, fijo, i, j, nsim = 99, nrank = 1, r = NULL,
	 correction = "isotropic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K012_+3A_x">X</code></td>
<td>
<p> Multitype marked point pattern. An object with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of <span class="pkg">spatstat</span>.   </p>
</td></tr>
<tr><td><code id="K012_+3A_fijo">fijo</code></td>
<td>
<p> Number or character string identifying the mark value of the  &quot;fixed&quot; pattern in X </p>
</td></tr>
<tr><td><code id="K012_+3A_i">i</code></td>
<td>
<p> Number or character string identifying the mark value of the  I pattern in X </p>
</td></tr>
<tr><td><code id="K012_+3A_j">j</code></td>
<td>
<p> Number or character string identifying the mark value of the  J pattern in X </p>
</td></tr>
<tr><td><code id="K012_+3A_nsim">nsim</code></td>
<td>
<p> Number of simulated point patterns to be generated when computing the envelopes.</p>
</td></tr>
<tr><td><code id="K012_+3A_nrank">nrank</code></td>
<td>
<p> Integer. Rank of the envelope value amongst the <code>nsim</code> simulated values. 
A rank of 1 means that the minimum and maximum simulated values will be used. </p>
</td></tr>
<tr><td><code id="K012_+3A_r">r</code></td>
<td>
<p> Numeric vector. The values of the argument r at which the K functions  should be evaluated. </p>
</td></tr>
<tr><td><code id="K012_+3A_correction">correction</code></td>
<td>
<p> A character item selecting any of the options &quot;border&quot;, &quot;bord.modif&quot;, &quot;isotropic&quot;, &quot;Ripley&quot; or
&quot;translate&quot;. It specifies the edge correction(s) to be applied. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test was developped to answer some questions about the spatial pattern of survival and
mortality of seedlings and its relationships with adult plants in a plant community (De la Cruz <em>et al. </em> 2008).
In order to evaluate the spatial structures of seedlings fates (survive or die), the null hypothesis of random labelling (Cuzick &amp; Edwards 1990, Dixon 2002)
would be the appropriate one. This kind of pattern is the result of two hierarchical processes: a first one that generates the pattern of points (seedlings)
and other that assign &quot;labels&quot; (i.e. &quot;die&quot;, &quot;survive&quot;) to the points. On the other hand,  to analyze the relationships between the spatial pattern of 
emerging seedlings and the pattern of adult plants (two patterns that have been generated independently), independence would be the appropriate
null hypothesis (Goreaud &amp; Pellisier 2003). However, testing the relationship between the pattern of seedling fates and the pattern of adult plants does
not completely fit any of the  mentioned hypotheses because, although the pattern of adult plants and the pattern of, e.g., dead seedlings are generated
independently, their relationship is conditioned by the dependence of the fate &quot;dead&quot; on the locations of emerging seedlings. This implies that 
one can not apply the usual technique of toroidal shifting one pattern over the other to test the independence hypothesis.
Instead one must permute the label of the focal fate (i.e. survive, die) over the global pattern of seedlings points,
keeping the locations and labels of adults fixed. This is the method that <code>K012</code> uses to build the envelopes. The bivariate K functions are
computed with the Lotwick's and Silverman's (1982) combined estimator (<code><a href="#topic+Kmulti.ls">Kmulti.ls</a></code>).
</p>


<h3>Value</h3>

<p>A list with two elements.
</p>
<table>
<tr><td><code>k01</code></td>
<td>
<p>Bivariate K function of the fixed point pattern and the I variable type, with simulation envelopes</p>
</td></tr>
<tr><td><code>k02</code></td>
<td>
<p>Bivariate K function of the fixed point pattern and the J variable type, with simulation envelopes</p>
</td></tr>
</table>
<p>Each of the above elements is a <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, essentially a <code>data.frame</code> with the following items:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the values of the argument r at which the functions kave been estimated</p>
</td></tr>
<tr><td><code>hi</code></td>
<td>
<p>upper envelope of simulations</p>
</td></tr>
<tr><td><code>lo</code></td>
<td>
<p>lower envelope of simulations</p>
</td></tr>
</table>
<p>together with the observed corrected estimate of the combined bivariate K function ( <code>iso</code>, <code>trans</code>, <code>border</code>, etc).
</p>


<h3>Author(s)</h3>

<p>Marcelino de la Cruz </p>


<h3>References</h3>

<p>Cuzick, J. and Edwards, R. 1990. Spatial clustering for inhomogeneous populations (with discussion). 
<em>Journal of the Royal Statistical Society</em> B <b> 52</b>: 73-104.
</p>
<p>De la Cruz, M. 2006. Introducción al análisis de datos mapeados o algunas de las (muchas) cosas
que puedo hacer si tengo coordenadas. <em>Ecosistemas</em> 15 (3): 19-39. 
</p>
<p>De la Cruz, M., Romao, R.L.,  Escudero, A. and Maestre, F.T. 2008. Where do seedlings go? A spatio-temporal analysis of
early mortality in a semiarid specialist. <em>Ecography</em>, 31(6): 720-730. <a href="https://doi.org/10.1111/j.0906-7590.2008.05299.x">doi:10.1111/j.0906-7590.2008.05299.x</a>.
</p>
<p>Dixon, P. M. 2002. Ripley's K function. In <em>The encyclopedia of environmetrics</em> 
(eds. El-Shaarawi, A.H. &amp; Piergorsch, W.W.), pp. 1976-1803. John Wiley &amp; Sons Ltd, NY.
</p>
<p>Goreaud, F. and Pelissier, R. 2003. Avoiding misinterpretation of biotic interactions with the intertype K12-function: population independence 
vs. random labelling hypotheses. <em>J. Veg. Sci.</em> <b>14</b>: 681-692.
</p>
<p>Lotwick, H. W. &amp; Silverman, B. W. 1982. Methods for analysing spatial processes of several types of points. 
<em>Journal of the Royal Statistical Society</em> B <b>44</b>: 406-413.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dixon2002">dixon2002</a></code> for another segregation test, based in the contingency table of counts of nearest neigbors in a marked point pattern.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(Helianthemum)


# To get 2.5% and 97.5% envelopes of 999 random labelings.
## as in fig. 10 of De la Cruz (2006), change nsim= 999 and nrank=25
nsim &lt;-19
nrank &lt;-1



## Test asociation/repulsion between the fixed pattern of adult
## H. squamatum plants and the "variable" pattern of surviving and 
## dead seedlings,


cosa &lt;- K012(Helianthemum, fijo="adultHS", i="deadpl", j="survpl",
             r=seq(0,200,le=201), nsim=nsim, nrank=nrank, correction="isotropic")

plot(cosa$k01, sqrt(./pi)-r~r,  col=c(3, 1, 3), lty=c(3, 1, 3), las=1,
         ylab=expression(L[12]), xlim=c(0, 200), 
	 main="adult HS vs. dead seedlings")

plot(cosa$k02, sqrt(./pi)-r~r, col=c(3, 1, 3), lty=c(3, 1, 3), las=1, 
         ylab=expression(L[12]), xlim=c(0, 200),
 	 main="adult HS vs. surviving seedlings")

</code></pre>

<hr>
<h2 id='K1K2'> Differences between univariate and bivariate K-functions </h2><span id='topic+K1K2'></span>

<h3>Description</h3>

<p>Given two point patterns I and J, <code>K1K2</code>computes the differences between 
both univariate <code class="reqn">K</code>-functions (i.e. <code class="reqn">Ki(r)-Kj(r)</code>) as well as the differences between 
the univariate and the bivariate <code class="reqn">K</code>-function (i.e. <code class="reqn">Ki(r)-Kij(r)</code> and <code class="reqn">Kj(r)-Kij(r)</code>).
It also computes simulation envelopes to test  that that the observed differences are within the 
range expected asuming the random labelling hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K1K2(X, i, j, nsim = 99, nrank = 1, r = NULL,
	 correction = "isotropic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K1K2_+3A_x">X</code></td>
<td>
<p> Multitype marked point pattern. An object with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of <span class="pkg">spatstat</span>.  </p>
</td></tr>
<tr><td><code id="K1K2_+3A_i">i</code></td>
<td>
<p> Number or character string identifying the mark value of the  I pattern in X. </p>
</td></tr>
<tr><td><code id="K1K2_+3A_j">j</code></td>
<td>
<p> Number or character string identifying the mark value of the  J pattern in X. </p>
</td></tr>
<tr><td><code id="K1K2_+3A_nsim">nsim</code></td>
<td>
<p> Number of simulated point patterns to be generated when computing the envelopes.</p>
</td></tr>
<tr><td><code id="K1K2_+3A_nrank">nrank</code></td>
<td>
<p> Integer. Rank of the envelope value amongst the <code>nsim</code> simulated values. 
A rank of 1 means that the minimum and maximum simulated values will be used. </p>
</td></tr>
<tr><td><code id="K1K2_+3A_r">r</code></td>
<td>
<p> Numeric vector. The values of the argument <code class="reqn">r</code> at which the <code class="reqn">K(r)</code> functions  should be evaluated. </p>
</td></tr>
<tr><td><code id="K1K2_+3A_correction">correction</code></td>
<td>
<p> A character item selecting any of the options &quot;border&quot;, &quot;bord.modif&quot;, &quot;isotropic&quot;, &quot;Ripley&quot; or
&quot;translate&quot;. It specifies the edge correction(s) to be applied. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The indiscriminate use of the raw bivariate functions (mainly the <code class="reqn">K</code> or the <code class="reqn">L</code>-bivariate functions) in ecological studies for testing the association/ repulsion
between different point patterns waste some of the most interesting properties of the <code class="reqn">K</code>-function. One of them is that under the random labelling hypothesis
every individual pattern would be a random thinning of the corresponding bivariate pattern and therefore <code class="reqn">Ki(r)=Kj(r)= Kij(r)=pi*r^2</code> (Diggle 2003). 
Dixon (2002) sugested that some differences of these functions could provide provide interesting ecological information. For example, <code class="reqn">D(r)= Ki(r)-Kj(r)</code>,
has an expected value of 0 for all <code class="reqn">r</code> distances under random labelling and evaluates the differences in the intensity of aggregation of the two point patterns
(e.g., in the example bellow, the pattern of drought and herbivory deaths). Other relevant function is <code class="reqn">D(r) = Ki(r)-Kij(r</code>) and the complementary <code class="reqn">D(r)= Kj(r)-Kij(r</code>)
which evaluate the degree of segregation of every individual pattern, i.e. if every point of the pattern is more -or less- surrounded by other points of the same type
than would be expected under the random labelling hypothesis. <code>K1K2</code> uses <code class="reqn">K^*ij(r)</code>, the combined estimator of Lotwick and Silverman (a weigthed mean of 
<code class="reqn">Kij(r)</code>  and <code class="reqn">Kji(r)</code>) as computed by <code><a href="#topic+Kmulti.ls">Kmulti.ls</a></code>.
</p>


<h3>Value</h3>

<p>A list with three elements.
</p>
<table>
<tr><td><code>k1k2</code></td>
<td>
<p>Difference between <code class="reqn">Ki(r)</code> and <code class="reqn">Kj(r)</code>, with simulation envelopes.</p>
</td></tr>
<tr><td><code>k1k12</code></td>
<td>
<p>Difference between <code class="reqn">Ki(r)</code> and <code class="reqn">Kij(r)</code>, with simulation envelopes.</p>
</td></tr>
<tr><td><code>k2k12</code></td>
<td>
<p>Difference between <code class="reqn">Kj(r)</code> and <code class="reqn">Kij(r)</code>, with simulation envelopes.</p>
</td></tr>
</table>
<p>Each of the above elements is a <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>, essentially a <code>data.frame</code> with the following items:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>The values of the argument r at which the functions have been estimated.</p>
</td></tr>
<tr><td><code>hi</code></td>
<td>
<p>Upper envelope of simulations.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>The respective difference function <code class="reqn">D(r)</code>, i.e., respectively, <code class="reqn">Ki(r)-Kj(r)</code>,  <code class="reqn">Ki(r)-K^*ij(r)</code> or <code class="reqn">Kj(r)-K^*ij(r)</code>.</p>
</td></tr>
<tr><td><code>lo</code></td>
<td>
<p>Lower envelope of simulations.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz </p>


<h3>References</h3>

 
<p>De la Cruz, M. 2006. Introducción al análisis de datos mapeados o algunas de las (muchas) cosas  que puedo hacer si tengo coordenadas. <em>Ecosistemas</em>  15 (3): 19-39. 
</p>
<p>De la Cruz, M., Romao, R.L.,  Escudero, A. and Maestre, F.T. 2008. Where do seedlings go? A spatio-temporal analysis of
early mortality in a semiarid specialist. <em>Ecography</em>,31(6): 720-730. <a href="https://doi.org/10.1111/j.0906-7590.2008.05299.x">doi:10.1111/j.0906-7590.2008.05299.x</a>.
</p>
<p>Diggle, P.J. 2003. <em>Statistical analysis of spatial point patterns</em>. Arnold, London.
</p>
<p>Dixon, P. M. 2002. Ripley's K function. In <em>The encyclopedia of environmetrics</em> 
(eds. El-Shaarawi, A.H. &amp; Piergorsch, W.W.), pp. 1976-1803. John Wiley &amp; Sons Ltd, NY.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Helianthemum)

# set the number of simulations (nsim=199 or larger for real analyses)
nsim&lt;- 19

cosa12 &lt;- K1K2(Helianthemum, j="deadpl", i="survpl", r=seq(0,200,le=201),
		 nsim=nsim, correction="isotropic")

## plots of figure 9 in De la Cruz (2006) (they where made with nsim=999)
plot(cosa12$k1k2, lty=c(2, 1, 2), col=c(2, 1, 2), xlim=c(0, 200),
         main= "survival- death")

plot(cosa12$k1k12, lty=c(2, 1, 2), col=c(2, 1, 2), xlim=c(0, 200),
	 main="segregation of surviving seedlings")

plot(cosa12$k2k12, lty=c(2, 1, 2), col=c(2, 1, 2), xlim=c(0, 200),
         main= "segregation of dying seedlings", legend=FALSE)

</code></pre>

<hr>
<h2 id='Kci'> Test against non-Poisson (in-)homogeneous models </h2><span id='topic+Kci'></span><span id='topic+Ki'></span><span id='topic+plot.ecespa.kci'></span><span id='topic+print.ecespa.kci'></span><span id='topic+ecespa.kci'></span>

<h3>Description</h3>

<p>Functions to automate testing of 'univariate' and 'bivariate' point pattern hypothesis against non-Poisson (in-)homogeneous models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kci(mod1, mod2, correction="trans", nsim=99, ngrid=200, nrep=1e+05,
     r=NULL, simu="both", spctype=1)

Ki(mod1, correction="trans", nsim=99, ngrid=200, nrep=1e+05, r=NULL,
    spctype=1)

## S3 ploth method for objects of class 'ecespa.kci':
## S3 method for class 'ecespa.kci'
plot(x, type=1, q=0.025, kmean=TRUE, add=FALSE, maine=NULL, 
       xlabe=NULL, ylabe=NULL, xlime=NULL, ylime=NULL, 
       lty=c(1,2,3), col=c(1,2,3), lwd=c(1,1,1), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kci_+3A_mod1">mod1</code></td>
<td>
<p> Fitted model. An object of class <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> or  <code><a href="#topic+ecespa.minconfit">ecespa.minconfit</a></code>. </p>
</td></tr>
<tr><td><code id="Kci_+3A_mod2">mod2</code></td>
<td>
<p> Fitted model. An object of class <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> or  <code><a href="#topic+ecespa.minconfit">ecespa.minconfit</a></code>. </p>
</td></tr>
<tr><td><code id="Kci_+3A_correction">correction</code></td>
<td>
<p> A character item selecting any of the options &quot;border&quot;, &quot;bord.modif&quot;,  or &quot;translate&quot;. It specifies 
the edge correction to be applied when computing K-functions. </p>
</td></tr>
<tr><td><code id="Kci_+3A_nsim">nsim</code></td>
<td>
<p> Number of simulated point patterns to be generated when computing the envelopes. </p>
</td></tr>
<tr><td><code id="Kci_+3A_ngrid">ngrid</code></td>
<td>
<p> Dimensions (ngrid by ngrid) of a rectangular grid of locations where <code><a href="spatstat.model.html#topic+predict.ppm">predict.ppm</a></code> 
would evaluate the spatial trend of the fitted models. </p>
</td></tr>
<tr><td><code id="Kci_+3A_nrep">nrep</code></td>
<td>
<p> Total number of steps (proposals) of Metropolis-Hastings algorithm that should be run by <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>
to simulate models of class <code>ppm</code>.</p>
</td></tr>
<tr><td><code id="Kci_+3A_r">r</code></td>
<td>
<p> Numeric vector. The values of the argument <code class="reqn">r</code> at which the <code class="reqn">K(r)</code> functions  should be evaluated. </p>
</td></tr>
<tr><td><code id="Kci_+3A_simu">simu</code></td>
<td>
<p> A character item indicating if both models will be simulated for the computation of the envelopes (<code>simu = "both"</code>) or 
just the second model (<code>simu != "both"</code>). </p>
</td></tr>
<tr><td><code id="Kci_+3A_spctype">spctype</code></td>
<td>
<p> Type of 'pre-thinning' method employed by <code><a href="#topic+rIPCP">rIPCP</a></code> in the simulation of
<code>ecespa.minconfit</code> models. </p>
</td></tr>
<tr><td><code id="Kci_+3A_x">x</code></td>
<td>
<p> An object of class 'ecespa.kci'. The result of runing <code>Kci</code> or <code>Ki</code>. </p>
</td></tr>
<tr><td><code id="Kci_+3A_type">type</code></td>
<td>
<p> What to plot. One of 1 (<em>K1</em>), 2 (<em>K2</em>), 12 (<em>K12</em>), 21 (<em>K21</em>), 112 (<em>K1-K12</em>) or 221 (<em>K2-K21</em>). </p>
</td></tr>
<tr><td><code id="Kci_+3A_q">q</code></td>
<td>
<p>Quantile for selecting the simulation envelopes.</p>
</td></tr>
<tr><td><code id="Kci_+3A_kmean">kmean</code></td>
<td>
<p>Logical. Should the mean of the simulated envelopes be ploted?</p>
</td></tr>
<tr><td><code id="Kci_+3A_add">add</code></td>
<td>
<p>Logical. Should the kci.plot be added to a previous plot? </p>
</td></tr>
<tr><td><code id="Kci_+3A_maine">maine</code></td>
<td>
<p>Title to add to the plot.</p>
</td></tr>
<tr><td><code id="Kci_+3A_xlabe">xlabe</code></td>
<td>
<p>Text  or expression to label the x-axis.</p>
</td></tr>  
<tr><td><code id="Kci_+3A_ylabe">ylabe</code></td>
<td>
<p>Text  or expression to label the y-axis. </p>
</td></tr>
<tr><td><code id="Kci_+3A_xlime">xlime</code></td>
<td>
<p>Max and min coordinates for the x-axis.</p>
</td></tr>
<tr><td><code id="Kci_+3A_ylime">ylime</code></td>
<td>
<p>Max and min coordinates for the y-axis.</p>
</td></tr>
<tr><td><code id="Kci_+3A_lty">lty</code></td>
<td>
<p>Vector with the line type for the estimated Kmm function, the simulated envelopes and the mean of the simulated envelopes. </p>
</td></tr>
<tr><td><code id="Kci_+3A_col">col</code></td>
<td>
<p>Vector with the color for the estimated K-function, the simulated envelopes and the mean of the simulated envelopes.</p>
</td></tr>
<tr><td><code id="Kci_+3A_lwd">lwd</code></td>
<td>
<p>Vector with the line width for the estimated K-function, the simulated envelopes and the mean of the simulated envelopes.</p>
</td></tr>
<tr><td><code id="Kci_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed to automate the testing of 'univariate' and(/or) 'bivariate' point pattern hypotheses (based on K-functions) against non-Poisson (in-)homogeneous
models. These non-Poisson (in-)homogeneous models should have been fitted with pseudolikelihood tools (<code>spatstat</code> <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> function)
or  with minimum contrast methods (<code><a href="#topic+ecespa.minconfit">ecespa.minconfit</a></code>).
</p>
<p>Function <code>Ki</code> is designed to test 'univariate' hypotheses. It will compute the (in-)homogeneous K-function (using <code>spatstat</code> <code><a href="spatstat.explore.html#topic+Kinhom">Kinhom</a></code> function) 
of the point pattern to which  the <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> or  <code><a href="#topic+ecespa.minconfit">ecespa.minconfit</a></code> model has beeen fitted and will compute 'envelopes' simulating from the fitted model. 
The computed envelopes can be considered as a pointwise test of the point pattern been a realisation of the fitted model.
</p>
<p>Function <code>Kci</code> is designed to test 'bivariate' hypotheses. It will compute the  (in-)homogeneous cross K-function 
(using <code>spatstat</code> <code><a href="spatstat.explore.html#topic+Kcross.inhom">Kcross.inhom</a></code> function)  and will compute envelopes simulating from the fitted models.
As, when dealing with inhomogeneos patterns <code class="reqn">K12</code> != <code class="reqn">K21</code>, <code>Kci</code> will compute both functions. If <code>simu = "both"</code> (default option),
<code>Kci</code> will simulate from <code>mod2</code> to test K12 and from <code>mod1</code> to test K21. If <code>simu != "both"</code>, only <code>mod2</code> will be simulated. This option 
may be useful when only K12 is of interest. Function <code>Kci</code> will also compute univariate (in-) homogeneous K-functions and envelopes for each individual point pattern.
</p>
<p>The S3 ploth method will plot the selected K-function and envelopes (actually, it will plot the most usual L-function = <code class="reqn">sqrt[K(r)/pi]-r</code>). 
The appropriate K function can be selected with the argument <code>type</code>. If <code>type = 1</code> (default option), it will plot the univariate K function 
(of the analized model in <code>Ki</code> or of the first model [mod1] in <code>Kci</code>). If <code>type = 2</code>, it will plot the univariate K function of the second model 
(mod2 in <code>Kci</code>). When  <code>type = 12</code> or <code>type = 21</code>, it will plot respectively K12 or K21.
Options <code>type = 112</code> or <code>type = 221</code> will graph a kind of 'segregation test' (see <code><a href="#topic+K1K2">K1K2</a></code>), and will represent de differences 
K1-K12,  K2-K21 and their envelopes.
</p>


<h3>Value</h3>

<p>Both <code>Kci</code> and <code>Ki</code> return an object of class <code>'ecespa.kci'</code>, basically a list with the following items:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>Numeric vector. The values of the argument <code class="reqn">r</code> at which the <code class="reqn">K(r)</code> functions  have been evaluated.</p>
</td></tr>
<tr><td><code>kia</code></td>
<td>
<p>Numeric vector. Observed (in-)homogeneous K function for <code>mod1</code> point pattern.</p>
</td></tr>
<tr><td><code>kib</code></td>
<td>
<p> Numeric vector. Observed (in-)homogeneous K function for <code>mod2</code> point pattern.</p>
</td></tr>
<tr><td><code>kci.ab.o</code></td>
<td>
<p> Numeric vector. Observed (in-) homogeneous cross K-function (K12) for <code>mod1</code> and <code>mod2</code> point patterns.</p>
</td></tr>
<tr><td><code>kci.ba.o</code></td>
<td>
<p> Numeric vector. Observed (in-) homogeneous cross K-function (K21) for <code>mod2</code> and <code>mod1</code> point patterns.</p>
</td></tr>
<tr><td><code>kci.ab.s</code></td>
<td>
<p> Matrix of simulated (in-) homogeneous cross K-function (K12) for <code>mod1</code> and <code>mod2</code> point patterns.</p>
</td></tr>                
<tr><td><code>kci.ba.s</code></td>
<td>
<p> Matrix of simulated (in-) homogeneous cross K-function (K21) for <code>mod2</code> and <code>mod1</code> point patterns.</p>
</td></tr>                
<tr><td><code>kib.s</code></td>
<td>
<p> Matrix of simulated (in-)homogeneous K function for <code>mod2</code> point pattern.</p>
</td></tr>
<tr><td><code>kia.s</code></td>
<td>
<p> Matrix of simulated (in-)homogeneous K function for <code>mod1</code> point pattern.</p>
</td></tr>
<tr><td><code>datanamea</code></td>
<td>
<p> Name of <code>mod1</code> point pattern.</p>
</td></tr>
<tr><td><code>datanameb</code></td>
<td>
<p> Name of <code>mod2</code> point pattern.</p>
</td></tr>
<tr><td><code>modnamea</code></td>
<td>
<p> Name of model <code>mod1</code>.</p>
</td></tr>
<tr><td><code>modnameb</code></td>
<td>
<p> Name of model <code>mod2</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p> Type of analysis. &quot;Kci&quot; or &quot;Ki&quot;.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>As this implementation involves the use of images as the means of evaluation of the (inhomogeneous) spatial trend, and a mask based on
those images will be used as the point pattern window, the &quot;Ripley's&quot; or &quot;isotropic&quot; edge correction can not be employed.
</p>
<p>It is usual that during the simulation process some warnings are produced. 
They are related to some simulated points being rejected as lying outside the specified window.
</p>


<h3>Note</h3>

<p> Even when one of the two point patterns is assumed to be homogeneous Poisson (and, apparently  not worth of fitting any model), an homogeneous
Poisson model can be easily fitted and passed to <code>Kci</code> with <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>. See the examples.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot </p>


<h3>References</h3>

<p>De la Cruz, M. and Escudero, A. 2008. Null models and tools for multivariate heterogeneous point patterns. <em>Submitted</em>.
</p>
<p>De Soto, L., Olano, J.M., Rozas, V. and De la Cruz, M. 2009. Release of <em>Juniperus thurifera</em> woodlands from herbivore-mediated arrested succession in Spain. <em>Applied Vegetation Science</em>,  13: 1525. <a href="https://doi.org/10.1111/j.1654-109X.2009.01045.x">doi:10.1111/j.1654-109X.2009.01045.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
    
    data(urkiola)
    
    # set the number of simulations (nsim=199 or larger for real analyses)
    nsim&lt;- 5

  #####################
   ## univariate case

   # get univariate pp
   I.ppp &lt;- split.ppp(urkiola)$birch

   # estimate inhomogeneous intensity function
   I.lam &lt;- predict (ppm(I.ppp, ~polynom(x,y,2)), type="trend", ngrid=200)

   # Compute and plot envelopes to Kinhom, simulating from an Inhomogeneous
   #  Poisson Process:
   
   I2.env &lt;- envelope( I.ppp,Kinhom, lambda=I.lam, correction="trans", 
                              nsim=nsim, simulate=expression(rpoispp(I.lam)))
   plot(I2.env, sqrt(./pi)-r~r, xlab="r (metres)", ylab= "L (r)", col=c(1,3,2,2),legend=FALSE) 

   # It seems that there is short scale clustering; let's fit an Inhomogeneous 
   # Poisson Cluster Process: 

   I.ki &lt;- ipc.estK(mippp=I.ppp, lambda=I.lam, correction="trans")

   # Compute and plot envelopes to Kinhom, simulating from the fitted IPCP:

   Ipc.env &lt;- Ki(I.ki, correction="trans", nsim=nsim, ngrid=200)

   plot (Ipc.env, xlab="r (metres)", ylab= "L (r)")
 
  ## Not run: 
   #####################
   ## bivariate case: test independence between birch and quercus in Urkiola

   J.ppp &lt;- split.ppp(urkiola)$oak
   
   # We want to simulate oak from a homogeneous Poisson model:
   J.ppm &lt;- ppm(J.ppp, trend=~1, interaction=Poisson() )
   
   IJ.env &lt;- Kci (mod1=I.ki, mod2=J.ppm, nsim=nsim)
   
   plot(IJ.env, type=12)
   
   plot(IJ.env, type=21)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='Kinhom.log'> Simulation envelopes from the fitted values of a logistic model </h2><span id='topic+Kinhom.log'></span>

<h3>Description</h3>

<p>Computes simulation envelopes for (in-)homogeneous K-function simulating from a vector of probabilitiesn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kinhom.log (A, lambda=NULL, mod=NULL, lifemark="0", prob=NULL,
			r=NULL, nsim=99, correction="trans", ngrid=200)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kinhom.log_+3A_a">A</code></td>
<td>
<p> A marked point pattern with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of <code>spatstat</code>. </p>
</td></tr>
<tr><td><code id="Kinhom.log_+3A_lambda">lambda</code></td>
<td>
<p> Optional. Values of the estimated intensity function as a pixel image (object of class
&quot;<code><a href="spatstat.geom.html#topic+im">im</a></code>&quot; of spatstat) giving the intensity values at all locations of <code>A</code>. </p>
</td></tr> 
<tr><td><code id="Kinhom.log_+3A_mod">mod</code></td>
<td>
<p> A fitted model. An object of class <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>. </p>
</td></tr>
<tr><td><code id="Kinhom.log_+3A_lifemark">lifemark</code></td>
<td>
<p> Level of  the marks of  <code>A</code> which represents the &quot;live&quot; or &quot;succes&quot; cases.</p>
</td></tr>
<tr><td><code id="Kinhom.log_+3A_prob">prob</code></td>
<td>
<p>Numeric vector, with length equal to the number of points of <code>A</code>, represeting 
the fitted values of a logistic model fitted to <code>A</code> marks.</p>
</td></tr>
<tr><td><code id="Kinhom.log_+3A_r">r</code></td>
<td>
<p> Numeric vector. The values of the argument <code class="reqn">r</code> at which the <code class="reqn">K(r)</code> functions  should be evaluated. </p>
</td></tr>
<tr><td><code id="Kinhom.log_+3A_nsim">nsim</code></td>
<td>
<p> Number of simulated point patterns to be generated when computing the envelopes. </p>
</td></tr>
<tr><td><code id="Kinhom.log_+3A_correction">correction</code></td>
<td>
<p> A character item selecting any of the options &quot;border&quot;, &quot;bord.modif&quot;,  or &quot;translate&quot;. It specifies 
the edge correction to be applied when computing K-functions. </p>
</td></tr>
<tr><td><code id="Kinhom.log_+3A_ngrid">ngrid</code></td>
<td>
<p> Dimensions (ngrid by ngrid) of a rectangular grid of locations where <code><a href="spatstat.model.html#topic+predict.ppm">predict.ppm</a></code> 
would evaluate the spatial trend of the fitted models. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper to compute the critical envelopes for Monte Carlo test of goodness-of-fit of (in-)homogeneous K functions, 
simulating from the fittted values of a logistic model (i.e. a binomial GLM with logit link) fitted to the marks (&quot;failure&quot;, &quot;success&quot;) of a &quot;binomially&quot;-marked 
point pattern. This is particularly interesting in plant ecology when considering alternatives to the <em>random mortality hypothesis</em> (Kenkel 1988).
This hypothesis is usually tested building Monte Carlo envelopes from the &quot;succesful&quot; patterns resulting from a  random labelling of a &quot;binomially&quot;-marked point pattern 
(this is equivalent to a random thinning of the whole pattern irrespective of  the marks). 
As tree mortality is rarely random but instead can be modelled as a function of a certain number of covariates, the most natural alternative to 
the <em>random mortality hypothesis</em> is the <em>logistic</em> mortality hypothesis, that can be tested thinning the original pattern of trees
with retention probabilities defined by the fitted values of a logistic model (Batista and Maguire 1998, Olano et al. 2008).
</p>
<p><code>Kinhom.log</code> will compute the envelopes by thinning the unmarked point pattern <code>A</code> with retention probabilities <code>prob</code>. If no 
<code>prob</code> vector is provided, all points will be thinned with the same probability ( number of &quot;live&quot; points / number of points ), i.e. <code>Kinhom.log</code>
will compute random thinning envelopes.
</p>
<p><code>Kinhom.log</code> will compute envelopes both to homogeneous and inhomogeneous K functions. If no <code>lambda</code> or <code>mode</code> arguments
are provided, <code>Kinhom.log</code> assumes that the original pattern is homogeneous and will use a constant <code>lambda</code> to compute the inhomogeneous K 
(i.e. it will compute the homogeneous K). The most convenient use with inhomogeneous point patterns is to provide the argument <code>mod</code>
with an inhomogeneous Poisson model fitted to the original pattern of 'live' points (with spatstat function <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>; see the examples).
This model will be used to compute (and to update in the simulations) the inhomogeneous trend (i.e. the &quot;lambda&quot;) of the patterns.  
If the argument <code>lambda</code> is provided but not <code>mod</code>,  these lambda will be used as a covariate to fit an inhomogeneous Poisson model that 
will be used to compute (and to update in the simulations) the inhomogeneous spatial trend.
</p>
<p><code>Kinhom.log</code> will produce an object of class 'ecespa.kci' that can be easily ploted (see the examples). 
This is accomplished by  the S3 ploth method <code><a href="#topic+plot.ecespa.kci">plot.ecespa.kci</a></code>; it will plot the K-function and its envelopes
(actually, it will plot the most usual L-function = <code class="reqn">sqrt[K(r)/pi]-r</code>).
</p>


<h3>Value</h3>

<p><code>Kinhom.log</code> returns an object of class <code><a href="#topic+ecespa.kci">ecespa.kci</a></code>, basically a list with the following items:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>Numeric vector. The values of the argument <code class="reqn">r</code> at which the <code class="reqn">K(r)</code> functions  have been evaluated.</p>
</td></tr>
<tr><td><code>kia</code></td>
<td>
<p>Numeric vector. Observed (in-)homogeneous K function.</p>
</td></tr>
<tr><td><code>kia.s</code></td>
<td>
<p> Matrix of simulated (in-)homogeneous K functions.</p>
</td></tr>
<tr><td><code>datanamea</code></td>
<td>
<p> Name of  point pattern <code>A</code>.</p>
</td></tr>
<tr><td><code>modnamea</code></td>
<td>
<p> Name of model <code>mod</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p> Type of analysis. Always &quot;Kinhom.log&quot;.</p>
</td></tr>
<tr><td><code>probname</code></td>
<td>
<p> Name of the vector of fitted retention probabilities <code>prob</code>.</p>
</td></tr>
<tr><td><code>modtrend</code></td>
<td>
<p> Spatial trend (formula) of the model <code>mod</code>.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p> Number of simulations. </p>
</td></tr>
</table>


<h3>Warning </h3>

<p>As this implementation involves the use of images as the means of evaluation of the (inhomogeneous) spatial trend, and a mask based on
those images will be used as the point pattern window, the &quot;Ripley's&quot; or &quot;isotropic&quot; edge correction can not be employed.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot </p>


<h3>References</h3>

<p>Batista, J.L.F. and Maguire, D.A. 1998. Modelling the spatial structure of tropical forests. <em>For. Ecol. Manag.</em>,  110: 293-314. 
</p>
<p>Kenkel, N.C. 1988. Pattern of self-thinning in Jack Pine: testing the random mortality hypothesis. <em>Ecology</em>,  69: 1017-1024.
</p>
<p>Olano, J.M., Laskurain, N.A., Escudero, A. and De la Cruz, M. 2009. Why and where adult trees die in a secondary temperate forest? 
The role of neighbourhood. <em>Annals of Forest Science</em>, 66: 105. <a href="https://doi.org/10.1051/forest%3A2008074">doi:10.1051/forest:2008074</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
   
   data(quercusvm)
   
   # set the number of simulations (nsim=199 or larger for real analyses)
   nsim&lt;- 19

   # read fitted values from logistic model:
   
   
   probquercus &lt;-c(0.99955463, 0.96563477, 0.97577094, 0.97327199, 0.92437309,
   0.84023396, 0.94926682, 0.89687281, 0.99377915, 0.74157478, 0.95491518,
   0.72366493, 0.66771787, 0.77330148, 0.67569082, 0.9874892, 0.7918891, 
   0.73246803, 0.81614635, 0.66446411, 0.80077908, 0.98290508, 0.54641754,
   0.53546689, 0.73273626, 0.7347013, 0.65559655, 0.89481468, 0.63946334,
   0.62101995, 0.78996371, 0.93179582, 0.80160346, 0.82204428, 0.90050059,
   0.83810669, 0.92153079, 0.47872421, 0.24697004, 0.50680935, 0.6297911, 
   0.46374812, 0.65672284, 0.87951682, 0.35818237, 0.50932432, 0.92293014,
   0.48580241, 0.49692053, 0.52290553, 0.7317549, 0.32445982, 0.30300865,
   0.73599359, 0.6206056, 0.85777043, 0.65758613, 0.50100406, 0.31340849, 
   0.22289286, 0.40002879, 0.29567678, 0.56917817, 0.56866864, 0.27718552,
   0.4910667, 0.47394411, 0.40543788, 0.29571349, 0.30436276, 0.47859015,
   0.31754526, 0.42131675, 0.37468782, 0.73271225, 0.26786274, 0.59506388, 
   0.54801851, 0.38983575, 0.64896835, 0.37282031, 0.67624306, 0.29429766,
   0.29197755, 0.2247629, 0.40697843, 0.17022391, 0.26528042, 0.24373722,
   0.26936163, 0.13052254, 0.19958585, 0.18659692, 0.36686678, 0.47263005,
   0.39557661, 0.68048997, 0.74878567, 0.88352322, 0.93851375)
   
  

   ################################ 
   ## Envelopes for an homogeneous point pattern:
   
   cosap &lt;- Kinhom.log(A=quercusvm, lifemark="0",  prob=probquercus, nsim=nsim)

   plot(cosap)

   
   ################################ 
   ## Envelopes for an inhomogeneous point pattern:
   
   ## First, fit an inhomogeneous Poisson model to alive trees :
   
   quercusalive &lt;- unmark(quercusvm[quercusvm$marks == 0])

    mod2 &lt;- ppm(quercusalive, ~polynom(x,y,2))

    ## Now use mod2 to estimate lambda for K.inhom:
    
    cosapm &lt;- Kinhom.log(A=quercusvm, lifemark="0", prob=probquercus, 
                                   nsim=nsim, mod=mod2)

   
   ################################ 
   ## An example of homogeneous random thinning:
      
   cosa &lt;- Kinhom.log(A=quercusvm, lifemark="0", nsim=nsim)
   
   plot(cosa)
    
    

</code></pre>

<hr>
<h2 id='Kmm'> Mark-weighted K-function </h2><span id='topic+Kmm'></span><span id='topic+plot.ecespa.kmm'></span><span id='topic+print.ecespa.kmm'></span><span id='topic+ecespa.kmm'></span>

<h3>Description</h3>

<p>This is a functional data summary for marked point patterns that measures the joint pattern of points and marks at different scales determined by <code class="reqn">r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kmm(mippp, r = 1:10, nsim=NULL)

## S3 method for ploting objects of class 'ecespa.kmm':
## S3 method for class 'ecespa.kmm'
plot(x, type="Kmm.n", q=0.025, 
            xlime=NULL, ylime=NULL,  maine=NULL, add=FALSE, kmean=TRUE,
            ylabe=NULL, xlabe=NULL, lty=c(1,2,3), col=c(1,2,3), lwd=c(1,1,1),
             ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmm_+3A_mippp">mippp</code></td>
<td>
<p> A marked point pattern. An object with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of <span class="pkg">spatstat</span>. </p>
</td></tr>
<tr><td><code id="Kmm_+3A_r">r</code></td>
<td>
<p> Sequence of distances at which <code>Kmm</code> is estimated. </p>
</td></tr>
<tr><td><code id="Kmm_+3A_nsim">nsim</code></td>
<td>
<p> Number of simulated point patterns to be generated when computing the envelopes.</p>
</td></tr>
<tr><td><code id="Kmm_+3A_x">x</code></td>
<td>
<p> An object of class 'ecespa.kmm'. The result of applying <code>Kmm</code> to a marked point pattern.</p>
</td></tr>
<tr><td><code id="Kmm_+3A_type">type</code></td>
<td>
<p>Type of mark-weighted K-function to plot. One of <code>"Kmm"</code> (&quot;plain&quot; mark-weighted K-function) or 
<code>"Kmm.n"</code> (normalized mark-weighted K-function). </p>
</td></tr>
<tr><td><code id="Kmm_+3A_q">q</code></td>
<td>
<p>Quantile for selecting the simulation envelopes.</p>
</td></tr>
<tr><td><code id="Kmm_+3A_xlime">xlime</code></td>
<td>
<p>Max and min coordinates for the x-axis.</p>
</td></tr>
<tr><td><code id="Kmm_+3A_ylime">ylime</code></td>
<td>
<p>Max and min coordinates for the y-axis.</p>
</td></tr>
<tr><td><code id="Kmm_+3A_maine">maine</code></td>
<td>
<p>Title to add to the plot.</p>
</td></tr>
<tr><td><code id="Kmm_+3A_add">add</code></td>
<td>
<p>Logical. Should the kmm.object be added to a previous plot? </p>
</td></tr>
<tr><td><code id="Kmm_+3A_kmean">kmean</code></td>
<td>
<p>Logical. Should the mean of the simulated Kmm envelopes be ploted?</p>
</td></tr>
<tr><td><code id="Kmm_+3A_ylabe">ylabe</code></td>
<td>
<p>Text  or expression to label the y-axis. </p>
</td></tr>
<tr><td><code id="Kmm_+3A_xlabe">xlabe</code></td>
<td>
<p>Text  or expression to label the x-axis.</p>
</td></tr>
<tr><td><code id="Kmm_+3A_lty">lty</code></td>
<td>
<p>Vector with the line type for the estimated Kmm function, the simulated envelopes and the mean of the simulated envelopes. </p>
</td></tr>
<tr><td><code id="Kmm_+3A_col">col</code></td>
<td>
<p>Vector with the color for the estimated Kmm function, the simulated envelopes and the mean of the simulated envelopes.</p>
</td></tr>
<tr><td><code id="Kmm_+3A_lwd">lwd</code></td>
<td>
<p>Vector with the line width for the estimated Kmm function, the simulated envelopes and the mean of the simulated envelopes.</p>
</td></tr>
<tr><td><code id="Kmm_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Penttinnen (2006) defines <code class="reqn">Kmm(r)</code>, the mark-weighted <code class="reqn">K</code>-function  of a stationary marked point process <code class="reqn">X</code>, 
so that </p>
<p style="text-align: center;"><code class="reqn">lambda*Kmm(r) = Eo[sum(mo*mn)]/mu^2</code>
</p>
<p> where <code class="reqn">lambda</code> is the intensity of the process, 
i.e. the expected number of points of <code class="reqn">X</code> per unit area, <code class="reqn">Eo[ ] </code> denotes expectation (given that there is a point at the origin); 
<code class="reqn">m0</code> and <code class="reqn">mn</code> are the marks attached to every two points of the process separated by a distance <code class="reqn">&lt;= r</code>  and <code class="reqn">mu</code>
is the mean mark. It measures the joint pattern of marks and points at the scales determmined by <code class="reqn">r</code>. If all the marks are set to 1,
then <code class="reqn">lambda*Kmm(r)</code> equals the expected number of additional random points within 
a distance <code class="reqn">r</code> of a typical random point of <code class="reqn">X</code>, i.e. <code class="reqn">Kmm</code> becomes the conventional Ripley's <code class="reqn">K</code>-function for unmarked point processes.
As the <code class="reqn">K</code>-function measures clustering or regularity among the points regardless of the marks, one can separate clustering of marks with the
<em>normalized weighted K-function</em> </p>
<p style="text-align: center;"><code class="reqn">Kmm.normalized(r) = Kmm(r)/K(r)</code>
</p>
<p> If the process is independently marked, <code class="reqn">Kmm(r)</code> equals <code class="reqn">K(r)</code> so the 
normalized mark-weighted <code class="reqn">K</code>-function will equal 1 for all distances <code class="reqn">r</code>.
</p>
<p>If <code>nsim != NULL</code>, <code>Kmm</code>  computes  <em>'simulation envelopes'</em> from the simulated point patterns. These are simulated from <code>nsim</code> random permutations
of the marks over the points coordinates. This is a kind of pointwise test of <code class="reqn">Kmm(r) == 1 </code> or <code class="reqn">normalized Kmm(r) == 1</code> for a given <code class="reqn">r</code>.  
</p>


<h3>Value</h3>

<p><code>Kmm</code> returns an object of class <code>'ecespa.kmm'</code>, basically a list with the following items:
</p>
<table>
<tr><td><code>dataname</code></td>
<td>
<p>Name of the analyzed point pattern.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Sequence of distances at which <code>Kmm</code> is estimated. </p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>Number of simulations for computing the envelopes, or <code>NULL</code> if none.</p>
</td></tr>
<tr><td><code>kmm</code></td>
<td>
<p>Mark-weighted <code class="reqn">K</code>-function.</p>
</td></tr>
<tr><td><code>kmm.n</code></td>
<td>
<p>Normalized mark-weighted <code class="reqn">K</code>-function.</p>
</td></tr>
<tr><td><code>kmmsim</code></td>
<td>
<p>Matrix of simulated  mark-weighted <code class="reqn">K</code>-functions, or or <code>NULL</code> if none.</p>
</td></tr>
<tr><td><code>kmmsim.n</code></td>
<td>
<p>Matrix of simulated  normalized mark-weighted <code class="reqn">K</code>-functions, or or <code>NULL</code> if none.</p>
</td></tr>  
</table>


<h3>Note</h3>

<p>This implementation estimates <code class="reqn">Kmm(r)</code> without any correction of border effects, so it must be used with caution. However, as <code class="reqn">K(r)</code> is 
also estimed without correction it migth compensate the border effects on the normalized <code class="reqn">Kmm</code>-function.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot </p>


<h3>References</h3>

<p>De la Cruz, M. 2008. Métodos para analizar datos puntuales. 
En: <em>Introducción al Análisis Espacial de Datos en Ecología y Ciencias Ambientales: Métodos y Aplicaciones </em> 
(eds. Maestre, F. T., Escudero, A. y Bonet, A.), pp 76-127. Asociación Española de Ecología Terrestre, Universidad Rey Juan Carlos
y Caja de Ahorros del Mediterráneo, Madrid.
</p>
<p>Penttinen, A. 2006. Statistics for Marked Point Patterns. In <em>The Yearbook of the Finnish Statistical Society</em>, pp. 70-91. 
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+markcorr">markcorr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ## Figure 3.10 of De la Cruz (2008):
  # change r to r=1:100
  
   r = seq(1,100, by=5)
  
  data(seedlings1)
  
  data(seedlings2)
  
  s1km &lt;- Kmm(seedlings1, r=r)
  
  s2km &lt;- Kmm(seedlings2, r=r)
  
  plot(s1km, ylime=c(0.6,1.2), lwd=2, maine="", xlabe="r(cm)")

  plot(s2km,  lwd=2, lty=2, add=TRUE )

  abline(h=1, lwd=2, lty=3)
  
  legend(x=60, y=1.2, legend=c("Hs_C1", "Hs_C2", "H0"),
	 lty=c(1, 2, 3), lwd=c(3, 2, 2), bty="n")
## Not run: 
## A pointwise test of normalized Kmm == 1 for seedlings1:

   s1km.test &lt;- Kmm(seedlings1, r=1:100, nsim=99)

   plot(s1km.test,  xlabe="r(cm)")

  
## End(Not run)
</code></pre>

<hr>
<h2 id='Kmulti.ls'> Lotwick's and Silverman's combined estimator of the marked K-function </h2><span id='topic+Kmulti.ls'></span>

<h3>Description</h3>

<p>For a multitype point pattern, calculates the combined estimator of the bivariate <code class="reqn">Kij(r)</code> and <code class="reqn">Kji(r)</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kmulti.ls(X, I, J, r = NULL, corre = "isotropic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmulti.ls_+3A_x">X</code></td>
<td>
<p> Multitype marked point pattern. An object with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="Kmulti.ls_+3A_i">I</code></td>
<td>
<p> Subset index specifying the points of the first pattern.  </p>
</td></tr>
<tr><td><code id="Kmulti.ls_+3A_j">J</code></td>
<td>
<p> Subset index specifying the points of the second pattern. </p>
</td></tr>
<tr><td><code id="Kmulti.ls_+3A_r">r</code></td>
<td>
<p> Numeric vector. The values of the argument r at which the multitype K function <code class="reqn">K^*ij(r)</code> should be evaluated. </p>
</td></tr>
<tr><td><code id="Kmulti.ls_+3A_corre">corre</code></td>
<td>
<p> A character item selecting any of the options &quot;border&quot;, &quot;bord.modif&quot;, &quot;isotropic&quot;, &quot;Ripley&quot; or
&quot;translate&quot;, as described in <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>. It specifies the edge correction(s) to be applied. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a consequence of edge effects, the estimators  <code class="reqn">Kij(r)</code> and <code class="reqn">Kji(r)</code> of the same bivariate pattern could differ.
<code class="reqn">K^*ij(r)</code> is the combined estimator defined by Lotwick and Silverman (1982) as </p>
<p style="text-align: center;"><code class="reqn">nj*Kij(r)+ ni*Kji(r) / (ni + nj) ,</code>
</p>
 
<p><code class="reqn">ni</code> and <code class="reqn">nj</code> being respectively the number of points in <code class="reqn">I</code> and <code class="reqn">J</code>. 
</p>


<h3>Value</h3>

<p>An object of class &quot;fv&quot;  (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>). Essentially a data frame containing numeric columns 
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>The values of the argument r at which the function <code class="reqn">K^*ij(r)</code>  has been estimated</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>theo</code></td>
<td>
<p>The theoretical value of <code class="reqn">K*ij(r)</code> for a marked Poisson process, namely <code class="reqn">pi * r^2</code></p>
</td></tr></table>
<p>.
</p>
<p>together with a column or columns named &quot;border&quot;, &quot;bord.modif&quot;, &quot;iso&quot; and/or &quot;trans&quot;, according to the selected edge corrections.
These columns contain estimates of the function <code class="reqn">K^*ij(r)</code> obtained by the edge corrections named.
</p>


<h3>Note</h3>

 <p><code>Kmulti.ls</code> is a wrapper for a convenient use of the <code><a href="spatstat.explore.html#topic+Kmulti">Kmulti</a></code> function of <span class="pkg">spatstat</span>. 
Please refer to its help page for additional documentation.</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz </p>


<h3>References</h3>

 
<p>Lotwick,H.W. &amp; Silverman, B. W. 1982. Methods for analysing spatial processes of several types of points. 
<em>Journal of the Royal Statistical Society</em> B,  44: 406-413. <a href="https://doi.org/10.1111/j.2517-6161.1982.tb01221.x">doi:10.1111/j.2517-6161.1982.tb01221.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(amacrine)

plot(Kmulti.ls(amacrine, I=amacrine$marks=="on", J=amacrine$marks=="off", 
	 corre="isotropic"), sqrt(./pi)-r~r, main="")

# compare with Kmulti

plot(Kmulti(amacrine, I=amacrine$marks=="on", J=amacrine$marks=="off"),
         sqrt(iso/pi)-r~r, add=TRUE, col=3)

plot(Kmulti(amacrine, J=amacrine$marks=="on", I=amacrine$marks=="off"),
      sqrt(iso/pi)-r~r, add=TRUE, col=4)

</code></pre>

<hr>
<h2 id='LF.gof'>Loosmore and Ford Goodness of Fit Test</h2><span id='topic+LF.gof'></span>

<h3>Description</h3>

 
<p>Performs the Loosmore and Ford (2006) test or the Maximum Absolute Deviation test for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LF.gof(X, rmin=NULL, rmax=NULL, na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LF.gof_+3A_x">X</code></td>
<td>
<p>An object resulting from the function <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>,  i.e., with an attribute &quot;<em>simfuns</em>&quot; (obtained using the argument  <code>savefuns=TRUE</code> in <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>) ,which is an object of class &quot;<code><a href="spatstat.explore.html#topic+fv">fv</a></code>&quot; containing the summary functions computed for each of the simulated patterns.</p>
</td></tr>
<tr><td><code id="LF.gof_+3A_rmin">rmin</code></td>
<td>
<p>Minimum value of the function argument r over which the maximum absolute deviation, or the integral, will be computed for the test.</p>
</td></tr>
<tr><td><code id="LF.gof_+3A_rmax">rmax</code></td>
<td>
<p>Maximum value of the function argument r over which the maximum absolute deviation, or the integral, will be computed for the test.</p>
</td></tr>
<tr><td><code id="LF.gof_+3A_na.rm">na.rm</code></td>
<td>
<p>Should NA's be removed to compute the integral?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These function perform a tests for goodness-of-fit of a point pattern dataset to a point process model, based on Monte Carlo simulation from the model. The simulations should have been previously computed with the function <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>, applied with the argument <code>savefuns=TRUE</code> in order to save all the simulated functions, required for the computation of the test.
</p>
<p>The test, popularized in the ecological field by Loosmore and Ford (2006) is also described in Diggle (2003, page 14), and according to Baddeley and Turner (2005) also in Diggle (1986) and  Cressie (1991, page 667, equation (8.5.42)).
If the arguments <code>rmin</code> and <code>rmax</code> are set to <code>NULL</code>, the integral of the GoF statistics will be computed over the complete range of r values.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt>u</dt><dd><p>The GoF statistic, i.e., the value of the integral over the range of <em>r</em>'s</p>
</dd>
<dt>p</dt><dd><p>The p-value of the test</p>
</dd>
<dt>na.count.by.r</dt><dd><p>Number of <code>NA</code> values for each r. It helps to evaluate the reliability of the computed u's, specially for small <em>r</em>'s</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Marcelino de la Cruz </p>


<h3>References</h3>

<p>Cressie, N.A.C. (1991) <em>Statistics for spatial data</em>. John Wiley and Sons, 1991. 
</p>
<p>Diggle, P. J. (1986). Displaced amacrine cells in the retina of a rabbit : analysis of a bivariate spatial point pattern. <em>J. Neuroscience Methods</em> 18, 115-125. 
</p>
<p>Diggle, P.J. (2003) <em>Statistical analysis of spatial point patterns</em>, Second edition. Arnold. 
</p>
<p>Loosmore, N.B. and Ford, E.D. (2006) Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87, 1925-1931. <a href="https://doi.org/10.1890/0012-9658%282006%2987%5B1925%3ASIUTGO%5D2.0.CO%3B2">doi:10.1890/0012-9658(2006)87[1925:SIUTGO]2.0.CO;2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+dclf.test">dclf.test</a></code> for an alternative implementation of the test in <span class="pkg">spatstat</span>.
</p>

<hr>
<h2 id='marksum'> Mark-sum measure </h2><span id='topic+marksum'></span><span id='topic+plot.ecespa.marksum'></span><span id='topic+print.ecespa.marksum'></span>

<h3>Description</h3>

<p>An exploratory data analysis technique for marked point patterns. The marked point pattern is mapped to a random field for visual inspection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marksum(mippp, R = 10, nx = 30, ny = 30)

## S3 method for ploting objects of class 'ecespa.marksum':
## S3 method for class 'ecespa.marksum'
plot(x, what="normalized",  contour=FALSE, grid=FALSE,
	ribbon=TRUE,col=NULL ,main=NULL,xlab="",ylab="",...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marksum_+3A_mippp">mippp</code></td>
<td>
<p> A marked point pattern. An object with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of <span class="pkg">spatstat</span>. </p>
</td></tr>
<tr><td><code id="marksum_+3A_r">R</code></td>
<td>
<p> Radius. The distance argument <em> r</em> at which the mark-sum measure should be computed </p>
</td></tr>
<tr><td><code id="marksum_+3A_nx">nx</code></td>
<td>
<p>Grid density (for estimation) in the x-side. </p>
</td></tr>
<tr><td><code id="marksum_+3A_ny">ny</code></td>
<td>
<p> Grid density (for estimation) in the y-side. </p>
</td></tr>
<tr><td><code id="marksum_+3A_x">x</code></td>
<td>
<p>An object of class <code>'ecespa.marksum'</code>. Usually, the result of applying <code>marksum</code> to a point pattern.</p>
</td></tr>
<tr><td><code id="marksum_+3A_what">what</code></td>
<td>
<p>What to plot. One of <code>"marksum"</code> (raw mark sum measure), <code>"point"</code> (point sum measure) or <code>"normalized"</code> (normalized sum measure).</p>
</td></tr> 
<tr><td><code id="marksum_+3A_contour">contour</code></td>
<td>
<p>Logical; if <code>"TRUE"</code> add contour to map.</p>
</td></tr>
<tr><td><code id="marksum_+3A_grid">grid</code></td>
<td>
<p>Logical; if <code>"TRUE"</code> add marked grid to map.</p>
</td></tr>
<tr><td><code id="marksum_+3A_ribbon">ribbon</code></td>
<td>
<p>Logical; if <code>"TRUE"</code> add legend to map.</p>
</td></tr>
<tr><td><code id="marksum_+3A_col">col</code></td>
<td>
<p>Color table to use for the map ( see help file on image for details). </p>
</td></tr>
<tr><td><code id="marksum_+3A_main">main</code></td>
<td>
<p>Text or expression to add as a title to the plot.</p>
</td></tr>
<tr><td><code id="marksum_+3A_xlab">xlab</code></td>
<td>
<p>Text or expression to add as a label to axis x.</p>
</td></tr>
<tr><td><code id="marksum_+3A_ylab">ylab</code></td>
<td>
<p>Text or expression to add as a label to axis y.</p>
</td></tr>
<tr><td><code id="marksum_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>, <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> or <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>, to control 
the  parameters of the smoothing kernel, pixel resolution, etc. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Penttinen (2006) defines the <em>mark-sum measure</em> as a smoothed summary measuring locally the contribution of points and marks. For any fixed location <code class="reqn">x</code> within the 
observational   window and a distance <code class="reqn">R</code>, the mark-sum measure <code class="reqn"> S[R](x)</code> equals the sum of the marks of the points within the circle of radius
<code class="reqn">R</code> with centre in  <code class="reqn">x</code>. The <em>point-sum measure</em> <code class="reqn"> I[R](x)</code> is defined by him as the sum of points within the circle of radius <code class="reqn">R</code> with centre
in  <code class="reqn">x</code>, and describes the contribution of points locally near <code class="reqn">x</code>. The <em>normalized mark-sum measure</em> describes the contribution of marks 
near <code class="reqn">x</code> and is defined (Penttinen, 2006) as
</p>
<p style="text-align: center;"><code class="reqn"> S.normalized[R](x) = S[R](x)/I[R](x)</code>
</p>

<p>This implementation of <code>marksum</code> estimates the mark-sum and the point-sum measures in a grid of points whose density is defined by <code>nx</code> and 
<code>ny</code>.
</p>


<h3>Value</h3>

<p><code>marksum</code> gives an object of class <code>'ecespa.marksum'</code>; basically a list with the following elements:
</p>
<table>
<tr><td><code>normalized</code></td>
<td>
<p>Normalized mark-sum measure estimated in the grid points. </p>
</td></tr> 
<tr><td><code>marksum</code></td>
<td>
<p>Raw mark-sum measure estimated in the grid points. </p>
</td></tr> 
<tr><td><code>pointsum</code></td>
<td>
<p>Point-sum measure estimated in the grid points. </p>
</td></tr> 
<tr><td><code>minus</code></td>
<td>
<p>Point-sum of the grid points. For advanced use only.</p>
</td></tr> 
<tr><td><code>grid</code></td>
<td>
<p> Grid of points. </p>
</td></tr> 
<tr><td><code>nx</code></td>
<td>
<p>Density of the estimating grid  in the x-side. </p>
</td></tr> 
<tr><td><code>ny</code></td>
<td>
<p>Density of the estimating grid  in the x-side. </p>
</td></tr> 
<tr><td><code>dataname</code></td>
<td>
<p>Name of the ppp object analysed. </p>
</td></tr> 
<tr><td><code>R</code></td>
<td>
<p> Radius. The distance argument <em>r</em> at which the mark-sum measure has been computed. </p>
</td></tr>
<tr><td><code>window</code></td>
<td>
<p>Window of the point pattern.</p>
</td></tr>
</table>
<p><code>plot.ecespa.marksum</code> plots the selected mark-sum measure.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot </p>


<h3>References</h3>

 
<p>Penttinen, A. 2006. Statistics for Marked Point Patterns. In <em>The Yearbook of the Finnish Statistical Society</em>, pp. 70-91. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+getis">getis</a></code>, related to the point-sum measure, and  <code><a href="spatstat.geom.html#topic+markstat">markstat</a></code> for designing different implementations. </p>


<h3>Examples</h3>

<pre><code class='language-R'>
   
 data(seedlings1)
   
 seed.m &lt;- marksum(seedlings1, R=25)

 # raw mark-sum measure; sigma is bandwith for smoothing
 plot(seed.m, what="marksum", sigma = 5)  

 # point sum measure
 plot(seed.m, what="pointsum", sigma = 5) 
   
 # normalized  mark-sum measure
 plot(seed.m,  what="normalized", dimyx=200, contour=TRUE, sigma = 5) 

# the same with added grid and normalized  mark-sum measure
plot(seed.m,  what="normalized", dimyx=200,
      contour=TRUE, sigma = 5, grid=TRUE)


</code></pre>

<hr>
<h2 id='p2colasr'> P-value for a discrete distribution on small sample data </h2><span id='topic+p2colasr'></span>

<h3>Description</h3>

<p>Computes the p-value  for a two-sided hypothesis test following
Dixon's (2002:145) description of the method of Agresti &amp; Min (2001).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2colasr(Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2colasr_+3A_z">Z</code></td>
<td>
 <p><code>vector</code> with the observed Z-score in the first position and 
all the simulated values behind. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>P-value of the two-sided hypothesis test</p>


<h3>Note</h3>

<p> This function is usually not to be called by the user. It is internally used by <code><a href="#topic+dixon2002">dixon2002</a></code>.</p>


<h3>Author(s)</h3>

<p>Marcelino de la Cruz Rot</p>


<h3>References</h3>

 
<p>Agresti, A. &amp; Min, Y. 2001. On small-sample confidence intervals 
for parameters in discrete distributions. <em>Biometrics</em>, <b>57</b>: 963-971.<br /><br />
Dixon, P.M. 2002. Nearest-neighbor contingency table analysis
of spatial segregation for several species. <em>Ecoscience</em>, <b>9</b>(2): 142-151.<br /><br />
</p>

<hr>
<h2 id='pc.estK'> Fit the Poisson Cluster Point Process by Minimum Contrast</h2><span id='topic+pc.estK'></span><span id='topic+Kclust'></span>

<h3>Description</h3>

<p>Fits the Poisson Cluster point process to a point pattern dataset by the Method of Minimum Contrast. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc.estK(Kobs, r, sigma2 = NULL, rho = NULL)
Kclust(r, sigma2, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pc.estK_+3A_kobs">Kobs</code></td>
<td>
<p> Empirical <code class="reqn">K</code>-function. </p>
</td></tr>
<tr><td><code id="pc.estK_+3A_r">r</code></td>
<td>
<p> Sequence of distances at which function <code class="reqn">K</code> has been estimated. </p>
</td></tr>
<tr><td><code id="pc.estK_+3A_sigma2">sigma2</code></td>
<td>
<p> Optional. Starting value for the parameter <code class="reqn">sigma2</code> of the Poisson Cluster process. </p>
</td></tr>
<tr><td><code id="pc.estK_+3A_rho">rho</code></td>
<td>
<p> Optional. Starting value for the parameter <code class="reqn">rho</code> of the Poisson Cluster process. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm fits the Poisson cluster point process to a point pattern, by finding the parameters of the Poisson cluster model
which give the closest match between the theoretical K function of the Poisson cluster process and the observed
K function. For a more detailed explanation of the Method of Minimum Contrast, see <code><a href="spatstat.model.html#topic+mincontrast">mincontrast</a></code>
in <span class="pkg">spatstat</span> or Diggle (2003: 86). 
</p>
<p>The Poisson cluster processes are defined by the following postulates (Diggle 2003):
</p>

<table>
<tr>
 <td style="text-align: left;">
         <em>PCP1</em></td><td style="text-align: left;"> Parent events form a Poisson process with intensity <code class="reqn">rho</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
         <em>PCP2</em></td><td style="text-align: left;"> Each parent produces a random number of offspring, according to a probability distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
	                    </td><td style="text-align: left;"> <code class="reqn">p[s]: s = 0, 1, 2, ...</code></td>
</tr>
<tr>
 <td style="text-align: left;">
         <em>PCP3</em></td><td style="text-align: left;"> The positions of the offspring relative to their parents are distributed according to a bivariate pdf <code class="reqn">h</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
	 </td>
</tr>

</table>

<p>This implementation asumes that the probability distribution <code class="reqn">p[s]</code> of offspring per parent is a Poisson distribution and 
that the position of each offspring relative to its parent follows a radially symetric Gaussian distribution with pdf
</p>
<p style="text-align: center;"><code class="reqn">h(x, y) = [1/(2*pi*sigma^2)]* exp[-(x^2+y^2)/(2*sigma^2)]</code>
</p>

<p>The theoretical <code class="reqn">K</code>-function of this Poisson cluster process is (Diggle, 2003):
</p>
<p style="text-align: center;"><code class="reqn">pi*r^2 + [1- exp(-r^2/4*sigma^2)]/rho</code>
</p>

<p>The command <code><a href="#topic+Kclust">Kclust</a></code> computes the theoretical <code class="reqn">K</code>-function of this Poisson cluster process and 
can be used to find some initial estimates of <code class="reqn">rho</code> and <code class="reqn">sigma^2</code>. In any case, the optimization usually finds the
correct parameters even without starting values for these parameters.
</p>
<p>This Poisson cluster process can be simulated with <code><a href="#topic+sim.poissonc">sim.poissonc</a></code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>sigma2</code></td>
<td>
<p>Parameter <code class="reqn">sigma^2</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Parameter <code class="reqn">rho</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The exponents <code class="reqn">p</code> and <code class="reqn">q</code> of the contrast criterion (see <code><a href="spatstat.model.html#topic+mincontrast">mincontrast</a></code>) are fixed 
respectively to <code class="reqn">p = 2</code> and <code class="reqn">q = 1/4</code>. The <code class="reqn">rmin</code> and <code class="reqn">rmax</code> limits of integration of the 
contrast criterion are set up by the sequence of values of <code class="reqn">r</code> and <code class="reqn">Kobs</code> passed to <code>pc.estK</code>.</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot, inspired by some code of  Philip M. Dixon </p>


<h3>References</h3>

<p> Diggle, P. J. 2003. <em>Statistical analysis of spatial point patterns</em>. Arnold, London. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ipc.estK">ipc.estK</a></code> for fitting the inhomogeneous Poisson cluster process; some functions in <span class="pkg">spatstat</span>
( <code><a href="spatstat.model.html#topic+matclust.estK">matclust.estK</a></code> and <code><a href="spatstat.model.html#topic+lgcp.estK">lgcp.estK</a></code>) fit other appropriate processes for clustered patterns;
<code><a href="spatstat.model.html#topic+mincontrast">mincontrast</a></code> performs a more general implementation of the method of mimimum contrast.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(gypsophylous)


# set the number of simulations (nsim=199 or larger for real analyses)
nsim&lt;- 19

## Estimate K function ("Kobs").

gyps.env &lt;- envelope(gypsophylous, Kest, correction="iso", nsim=nsim)

plot(gyps.env, sqrt(./pi)-r~r, legend=FALSE)

## Fit Poisson Cluster Process. The limits of integration 
## rmin and rmax are setup to 0 and 60, respectively. 

cosa.pc &lt;- pc.estK(Kobs = gyps.env$obs[gyps.env$r&lt;=60],
		           r = gyps.env$r[gyps.env$r&lt;=60])

## Add fitted Kclust function to the plot.

lines(gyps.env$r,sqrt(Kclust(gyps.env$r, cosa.pc$sigma2,cosa.pc$rho)/pi)-gyps.env$r,
       lty=2, lwd=3, col="purple")

## A kind of pointwise test of the gypsophylous pattern been a realisation
## of the fitted model, simulating with sim.poissonc and using function J (Jest).

gyps.env.sim &lt;- envelope(gypsophylous, Jest, nsim=nsim,
                    simulate=expression(sim.poissonc(gypsophylous,
		    sigma=sqrt(cosa.pc$sigma2), rho=cosa.pc$rho)))

plot(gyps.env.sim,  main="",legendpos="bottomleft")


</code></pre>

<hr>
<h2 id='quercusvm'> Alive and dead oak trees </h2><span id='topic+quercusvm'></span>

<h3>Description</h3>

<p>Locations of alive and dead oak trees (<em>Quercus robur</em>)  in a secondary wood in Urkiola Natural Park (Basque country, north of Spain). 
This is part of a more extensive dataset collected and analysed by Laskurain (2008). The coordinates of the trees are given in meters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(quercusvm)</code></pre>


<h3>Format</h3>

<p>An object of class &quot;ppp&quot;  representing the point pattern of tree locations. Entries include
</p>

<dl>
<dt>x</dt><dd><p>Cartesian x-coordinate of tree.</p>
</dd>
<dt>y</dt><dd><p>Cartesian y-coordinate of tree. </p>
</dd>
<dt>marks</dt><dd><p>factor with two levels indicating the status of each tree (1 = &quot;alive&quot;, 0 = &quot;dead&quot;).</p>
</dd>
</dl>

<p>See <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>  for details of the format of a ppp object. 
</p>


<h3>References</h3>

<p>Laskurain, N. A. (2008) <em>Dinámica espacio-temporal de un bosque secundario en el Parque Natural de Urkiola (Bizkaia).</em>
Tesis Doctoral. Universidad del País Vasco /Euskal Herriko Unibertsitatea.
</p>

<hr>
<h2 id='rIPCP'> Simulate Inhomogeneous Poisson Cluster Process </h2><span id='topic+rIPCP'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a simulated realisation of the Inhomogeneous Poisson Cluster Process. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rIPCP(x, lambda = NULL, type = 1, lmax = NULL, win = owin(c(0, 1), c(0, 1)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rIPCP_+3A_x">x</code></td>
<td>
<p> an object of class <code>'ecespa.minconfit'</code>, resulting from the function <code><a href="#topic+ipc.estK">ipc.estK</a></code>. </p>
</td></tr>
<tr><td><code id="rIPCP_+3A_lambda">lambda</code></td>
<td>
<p> Optional. Values of the estimated intensity function as a pixel image (object of class &quot;im&quot; of <code>spatstat</code>) giving the intensity values at all locations. </p>
</td></tr>
<tr><td><code id="rIPCP_+3A_type">type</code></td>
<td>
<p> Type of 'prethining' employed in the simulation. See details. </p>
</td></tr>
<tr><td><code id="rIPCP_+3A_lmax">lmax</code></td>
<td>
<p> Optional. Upper bound on the values of lambda. </p>
</td></tr>
<tr><td><code id="rIPCP_+3A_win">win</code></td>
<td>
<p> Optional. Window of the simulated pattern. </p>
</td></tr>
<tr><td><code id="rIPCP_+3A_...">...</code></td>
<td>
<p> Optional. Arguments passed to <code><a href="spatstat.geom.html#topic+as.im">as.im</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the Inhomogeneous Poisson Cluster process from an object of class <code>'ecespa.minconfit'</code>, resulting from fitting an IPCP to some 'original' point pattern
using the function <code><a href="#topic+ipc.estK">ipc.estK</a></code>.   Following the approach of Waagepetersen (2007), the simulation involves a first step in which an homogeneous aggregated pattern 
is simulated (from the fitted parameters  of the <code>'ecespa.minconfit'</code> object, using function <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code>   of <code>spatstat</code>) and a second one in which
the homogeneous pattern is thinned with a spatially varying thinning probability <em>f (s)</em> proportional to the spatially varying intensity, i.e. <em>f (s) = lambda(s) / max[lambda(s)]</em>.
To obtain a 'final' density similar to that of the original point pattern, a &quot;prethinning&quot; must be performed. There are two alternatives. If the argument <code>'type'</code> is set equal to '1', 
the expected number of points per cluster (<em>mu</em> parameter of <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code> is thinned as <em>mu &lt;- mu.0 / mean[f(s)]</em>, where <em>mu.0</em> is the 
mean number of points per cluster of the original pattern. This alternative produces point patterns most similar to the 'original'.  If the argument <code>'type'</code> is set equal to '2', 
the fitted intensity of the Poisson process of cluster centres (<em>kappa</em> parameter of <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code>, i.e. the intensity of 'parent' points) is thinned 
as <em>kappa &lt;- kappa / mean[f(s)]</em>. This alternative produces patterns more uniform than the 'original' and it is provided only for experimental purposes.
</p>


<h3>Value</h3>

<p>A point pattern, with the format of the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> objects of <code>spatstat</code>.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot </p>


<h3>References</h3>

 
<p>Waagepetersen, R. P. 2007. An estimating function approach to inference for inhomogeneous Neymann-Scott processes. <em>Biometrics</em> 63: 252-258. <a href="https://doi.org/10.1111/j.1541-0420.2006.00667.x">doi:10.1111/j.1541-0420.2006.00667.x</a>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sim.poissonc">sim.poissonc</a></code> to simulate homogeneous PCP; <code><a href="spatstat.random.html#topic+rNeymanScott">rNeymanScott</a></code> 
and <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code> in <span class="pkg">spatstat</span> are the basis of this function </p>


<h3>Examples</h3>

<pre><code class='language-R'>
  
    data(gypsophylous)
  
    plot(gypsophylous) 
    
    ## It 'seems' that the pattern is clustered, so 
    ## fit a Poisson Cluster Process. The limits of integration 
    ## rmin and rmax are setup to 0 and 60, respectively.
    
   cosa.pc2 &lt;- ipc.estK(gypsophylous, r = seq(0, 60, by=0.2))

   ## Create one instance of the fitted PCP:

   pointp &lt;- rIPCP( cosa.pc2)
   
   plot(pointp)
   
   
   
    #####################
    ## Inhomogeneous example

    data(urkiola)

    # get univariate pp
    I.ppp &lt;- split.ppp(urkiola)$birch

    plot(I.ppp)

    #estimate inhomogeneous intensity function
    I.lam &lt;- predict (ppm(I.ppp, ~polynom(x,y,2)), type="trend", ngrid=200)

    # It seems that there is short scale clustering; lets fit an IPCP: 

    I.ki &lt;- ipc.estK(mippp=I.ppp, lambda=I.lam, correction="trans")

    ## Create one instance of the fitted PCP:

    pointpi &lt;- rIPCP( I.ki)
   
    plot(pointpi)
 

</code></pre>

<hr>
<h2 id='seedlings'> Cohorts of Helianthemum squamatum seedlings </h2><span id='topic+seedlings'></span><span id='topic+seedlings1'></span><span id='topic+seedlings2'></span>

<h3>Description</h3>

<p>Marked point patterns of two consecutive cohorts of seedlings of <em>H. squamatum</em> growing in a gypsophylous plant community in Central Spain. The datasets contains the
locations of the seedlings marked with their heigth. Both the coordinates and the heigth of the seedlings are given in cm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seedlings1)
data(seedlings2)
</code></pre>


<h3>Format</h3>

<p><code>seedlings1</code> and <code>seedlings2</code> are objects of class &quot;ppp&quot; representing the point pattern of seedling locations marked by their heights. See <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> 
for details of the format. </p>


<h3>Source</h3>

<p>Romao, R.L. 2003. <em>Estructura espacial de comunidades de gipsófitos: interacciones bióticas
y constricciones abióticas.</em> Tesis Doctoral. Universidad Politécnica de Madrid.
</p>


<h3>References</h3>

<p>De la Cruz, M. 2006. Introducción al análisis de datos mapeados o algunas de las (muchas) cosas  que puedo hacer si tengo coordenadas. <em>Ecosistemas</em>  15 (3): 19-39. 
</p>
<p>Escudero, A., Romao, R.L., De la Cruz, M. &amp; Maestre, F. 2005. Spatial pattern and neighbour effects on 
<em>Helianthemum squamatum</em> seedlings in a Mediterranean gypsum community. <em>Journal of  Vegetation  Science</em>,  16: 383-390. <a href="https://doi.org/10.1111/j.1654-1103.2005.tb02377.x">doi:10.1111/j.1654-1103.2005.tb02377.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

 data(seedlings1)
 
 plot(seedlings1)


## End(Not run)
</code></pre>

<hr>
<h2 id='sim.poissonc'> Simulate Poisson Cluster Process </h2><span id='topic+sim.poissonc'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a simulated realisation of the Poisson Cluster Process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.poissonc(x.ppp, rho, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.poissonc_+3A_x.ppp">x.ppp</code></td>
<td>
<p> Point pattern whose window and intensity will be simulated. An object with the
<code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of <span class="pkg">spatstat</span>. </p>
</td></tr>
<tr><td><code id="sim.poissonc_+3A_rho">rho</code></td>
<td>
<p> Parameter <code class="reqn">rho</code> of the Poisson Cluster process.  </p>
</td></tr>
<tr><td><code id="sim.poissonc_+3A_sigma">sigma</code></td>
<td>
<p> Parameter <code class="reqn">sigma</code> of the Poisson Cluster process.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Poisson cluster processes are defined by the following postulates (Diggle 2003):
</p>

<table>
<tr>
 <td style="text-align: left;">
         <em>PCP1</em></td><td style="text-align: left;"> Parent events form a Poisson process with intensity <code class="reqn">rho</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
         <em>PCP2</em></td><td style="text-align: left;"> Each parent produces a random number of offspring, according to a probability distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
	                    </td><td style="text-align: left;"> <code class="reqn">p[s]: s = 0, 1, 2, ...</code></td>
</tr>
<tr>
 <td style="text-align: left;">
         <em>PCP3</em></td><td style="text-align: left;"> The positions of the offspring relative to their parents are distributed according to a bivariate pdf <code class="reqn">h</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
	 </td>
</tr>

</table>

<p>This implementation asumes that the probability distribution <code class="reqn">p[s]</code> of offspring per parent is a Poisson distribution and 
that the position of each offspring relative to its parent follows a radially symetric Gaussian distribution with pdf
</p>
<p style="text-align: center;"><code class="reqn">h(x, y) = [1/(2*pi*sigma^2)]* exp[-(x^2+y^2)/(2*sigma^2)]</code>
</p>



<h3>Value</h3>

<p>The simulated point pattern (an object of class &quot;<code>ppp</code>&quot;). </p>


<h3>Warning</h3>

<p>This implementation simulates only point patterns within rectangular windows. Use  <code><a href="#topic+ipc.estK">ipc.estK</a></code> to fit and 
<code><a href="#topic+rIPCP">rIPCP</a></code> (or the <code>spatstat</code> functions) to simulate point patterns within irregular windows.
</p>


<h3>Note</h3>

<p> This function can use the results of  <code><a href="#topic+pc.estK">pc.estK</a></code> to simulate point patterns from a fitted model.
Be careful as the paramted returned by <code><a href="#topic+pc.estK">pc.estK</a></code> is <code class="reqn">sigma^2</code> while <code>sim.poissonc</code> takes 
its square root, i.e. <code class="reqn">sigma</code>.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz Rot </p>


<h3>References</h3>

<p> Diggle, P.J. 2003. <em>Statistical analysis of spatial point patterns</em>. Arnold, London. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+rIPCP">rIPCP</a></code> to simulate inhomogeneous PCP; <code><a href="spatstat.random.html#topic+rNeymanScott">rNeymanScott</a></code> 
and <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code> in <span class="pkg">spatstat</span> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(gypsophylous)

# set the number of simulations (nsim=199 or larger for real analyses)
nsim&lt;- 39

## Estimate K function ("Kobs").
gyps.env &lt;- envelope(gypsophylous, Kest, correction="iso", nsim=nsim)

plot(gyps.env, sqrt(./pi)-r~r, legend=FALSE)

## Fit Poisson Cluster Process. The limits of integration 
## rmin and rmax are setup to 0 and 60, respectively. 
cosa.pc &lt;- pc.estK(Kobs = gyps.env$obs[gyps.env$r&lt;=60],
		           r = gyps.env$r[gyps.env$r&lt;=60])

## Add fitted Kclust function to the plot.
lines(gyps.env$r,sqrt(Kclust(gyps.env$r, cosa.pc$sigma2,cosa.pc$rho)/pi)-gyps.env$r,
       lty=2, lwd=3, col="purple")

## A kind of pointwise test of the pattern gypsophilous been a realisation
## of the fitted model, simulating with sim.poissonc and using function J (Jest).

gyps.env.sim &lt;- envelope(gypsophylous, Jest,  nsim=nsim,
                    simulate=expression(sim.poissonc(gypsophylous,
		    sigma=sqrt(cosa.pc$sigma2), rho=cosa.pc$rho)))

plot(gyps.env.sim,  main="")


</code></pre>

<hr>
<h2 id='swamp'> Tree Species in a Swamp Forest </h2><span id='topic+swamp'></span>

<h3>Description</h3>

<p>Locations and botanical classification of trees in a plot in the Savannah River. Locations are given in metres,
rounded to the nearest 0.1 metre.  The data come from  a 1-ha (200 m x 50 m) plot in the Savannah River Site, South Carolina, USA. 
The 734 mapped stems included 156 Carolina ash (<em>Fraxinus caroliniana</em>), 
215 Water tupelo (<em>Nyssa aquatica</em>), 205 Swamp tupelo (<em>Nyssa sylvatica</em>), 
98 Bald cypress (<em>Taxodium distichum</em>) and 60 stems of 8 additional species.
Although the plots were set up by Bill Good and their spatial patterns described in Good
and Whipple(1982), the plots have been maintained and resampled by Rebecca Sharitz and her colleagues of the Savannah River Ecology Laboratory.
There are slightly different versions of the Good plot data. Every time the plots are
resampled, some errors are corrected. This is mostly a concern for the
biologists. The different versions are very similar; they are all very good
examples of a marked spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swamp)</code></pre>


<h3>Format</h3>

<p>A data frame with 734 observations on the following 3 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>Cartesian x-coordinate of tree</p>
</dd>
<dt><code>y</code></dt><dd><p>Cartesian y-coordinate of tree</p>
</dd>
<dt><code>sp</code></dt><dd><p>a factor with levels indicating the species
of each tree:</p>
</dd>
</dl>

<table>
<tr>
 <td style="text-align: left;">
     <code>FX</code></td><td style="text-align: left;"> Carolina ash (<em>Fraxinus caroliniana</em>)</td>
</tr>
<tr>
 <td style="text-align: left;">
	 <code>NS</code></td><td style="text-align: left;"> Swamp tupelo (<em>Nyssa sylvatica</em>)</td>
</tr>
<tr>
 <td style="text-align: left;">
	 <code>NX</code></td><td style="text-align: left;"> Water tupelo (<em>Nyssa aquatica</em>)</td>
</tr>
<tr>
 <td style="text-align: left;">
	 <code>TD</code></td><td style="text-align: left;"> Bald cypress (<em>Taxodium distichum</em>)</td>
</tr>
<tr>
 <td style="text-align: left;">
	 <code>OT</code></td><td style="text-align: left;"> Other species</td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>




<h3>References</h3>

<p>Dixon, P.M. 2002. Nearest-neighbor contingency table analysis of spatial segregation for several species.
<em>Ecoscience</em>, 9 (2): 142-151. <a href="https://doi.org/10.1080/11956860.2002.11682700">doi:10.1080/11956860.2002.11682700</a>. 
</p>
<p>Good, , B. J. &amp; Whipple, S.A. 1982. Tree spatial patterns: South Carolina bottomland
and swamp forest. <em>Bulletin of the Torrey Botanical Club</em>, 109: 529-536.
</p>
<p>Jones et al. 1994. Tree population dynamics in seven South Carolina mixed-species
forests. <em>Bulletin of the Torrey Botanical Club</em>, 121:360-368.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swamp)
plot(swamp$x,swamp$y, col=as.numeric(swamp$sp),pch=19,
		 xlab="",ylab="",main="Swamp forest")
</code></pre>

<hr>
<h2 id='syrjala'> Syrjala's test for the difference between the spatial distributions of two populations </h2><span id='topic+syrjala'></span><span id='topic+syrjala0'></span><span id='topic+syrjala.test'></span><span id='topic+plot.syrjala.test'></span><span id='topic+print.syrjala.test'></span><span id='topic+plot.ecespa.syrjala'></span><span id='topic+print.ecespa.syrjala'></span>

<h3>Description</h3>

<p>Computes a two-sample Cramer-von Mises (and Kolmogorov-Smirnov) type test for a difference between the spatial distributions of two populations.
It is designed to be sensitive to differences in the way the populations are distributed across the study area but insensitive to differences in abundance between the two populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syrjala0(coords, var1, var2, nsim, R=FALSE)
syrjala(coords = NULL, var1 = NULL, var2 = NULL, nperm = 999)
syrjala.test(ppp1, ppp2, nsim = 999)
## S3 method for class 'syrjala.test'
plot(x, coline=1, ...)
## S3 method for class 'ecespa.syrjala'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syrjala_+3A_coords">coords</code></td>
<td>
<p>A <code>data.frame</code> with '$x' and '$y' components.</p>
</td></tr>
<tr><td><code id="syrjala_+3A_var1">var1</code></td>
<td>
<p>The first numeric variable </p>
</td></tr>
<tr><td><code id="syrjala_+3A_var2">var2</code></td>
<td>
<p>The second numeric variable.</p>
</td></tr>
<tr><td><code id="syrjala_+3A_nperm">nperm</code></td>
<td>
<p>Number of permutations.</p>
</td></tr>
<tr><td><code id="syrjala_+3A_nsim">nsim</code></td>
<td>
<p>Number of permutations.</p>
</td></tr>
<tr><td><code id="syrjala_+3A_r">R</code></td>
<td>
<p>Logical. Should be computed using R approach?</p>
</td></tr>
<tr><td><code id="syrjala_+3A_ppp1">ppp1</code></td>
<td>
<p> A marked point pattern, with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of spatstat, 
representing the values of some parameter measured on the corresponding sampling locations. </p>
</td></tr>
<tr><td><code id="syrjala_+3A_ppp2">ppp2</code></td>
<td>
<p> A marked point pattern, with the <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> format of spatstat, 
representing the values of some other parameter measured on the same locations than <code>ppp1</code>. </p>
</td></tr>
<tr><td><code id="syrjala_+3A_x">x</code></td>
<td>
<p>An object of class '<code>syrjala.test</code>' or  '<code>ecespa.syrjala</code>' resulting from <code>syrjala</code> or <code>syrjala.test</code>, respectively.</p>
</td></tr>
<tr><td><code id="syrjala_+3A_coline">coline</code></td>
<td>
<p>color for drawing the statistic's line in the plot.</p>
</td></tr>
<tr><td><code id="syrjala_+3A_...">...</code></td>
<td>
<p> Graphical parameters passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis of  Syrjala's test is that across the study area, the normalized distributions of the two populations are the same (Syrjala, 1996). Population density data are collected at <code class="reqn">K</code> sampling locations on two populations. 
Let <code class="reqn">(xk, yk)</code> denote the coordinates of the <code class="reqn">kth</code> sampling location (<code class="reqn"> k= 1,...,K</code> ); 
let <code class="reqn">d.i(xk, yk)</code> denote the sample density at the <code class="reqn">Kth</code> sampling location of the <code class="reqn">ith</code> population.
To construct a test that is independent of the population sizes, the observed density data is first normalized:
</p>
<p style="text-align: center;"><code class="reqn">gamma.i(xk, yk) = di(xk, yk)/Di,</code>
</p>
<p> where <code class="reqn">Di</code> is the sum  of <code class="reqn">d.i(xk, yk)</code> observations  across the <code class="reqn">K</code> sampling locations. 
The value of the cumulative distribution function at the location <code class="reqn">(xk, yk)</code>  for the <code class="reqn">ith</code> population, denoted <code class="reqn">GAMMA.i(xk, yk)</code>,
is the sum of all normalized density observations, <code class="reqn">gamma.i(xk, yk)</code>, whose location <code class="reqn">(x, y)</code> is such that 
<code class="reqn">x &lt;= xk</code> and <code class="reqn">y &lt;= yk</code>. The statistic proposed by Syrjala to test the null hypothesis is the square of the difference 
between the cumulative distribution functions  of the two populations,  summed over all sampling locations,
that is </p>
<p style="text-align: center;"><code class="reqn">psi = sum{GAMMA.1(xk, yk) - GAMMA.2(xk, yk)}^2.</code>
</p>
 
<p>As <code class="reqn">psi</code> is not invariant with respect to the 'corner'  of the rectangle enclosing the study area that is chosen as the origin of the coordinate sytem,
<code class="reqn">psi</code>  is computed  four times, one with each corner as the origin, and the average <code class="reqn">psi</code> is employed as the test statistic.
The level of significance of the observed <code class="reqn">psi</code> is determined from its position  in the ordered set of test statistic values from all <code class="reqn">2^K</code> pairwise 
permutations (that is approximated from a large number of randomly selected permutations).
</p>


<h3>Value</h3>

<p>Functions <code>syrjala</code> or <code>syrjala0</code> (with the argument <code>R=FALSE</code>) return an object of class '<code>syrjala.test</code>'. 
Functions <code>syrjala.test</code> or <code>syrjala0</code> (with the argument <code>R=TRUE</code>) return an object of class '<code>ecespa.syrjala</code>'.
In Both cases, the result is a  list with the following elements: 
</p>
<table>
<tr><td><code>cvm.obs</code></td>
<td>
<p>(class syrjala.test). The observed (averaged) <code class="reqn">psi</code> statistic for the CvM test.</p>
</td></tr>
<tr><td><code>cvm.sim</code></td>
<td>
<p>(class syrjala.test). A numeric vector with the <code>nperm+1</code> simulated <code class="reqn">psi</code>'s statistics (including <code>cvm.obs</code>).</p>
</td></tr>
<tr><td><code>ks.obs</code></td>
<td>
<p>(class syrjala.test). The observed (averaged) <code class="reqn">psi</code> statistic for the K-S test.</p>
</td></tr>
<tr><td><code>ks.sim</code></td>
<td>
<p>(class syrjala.test). A numeric vector with the <code>nperm+1</code> simulated <code class="reqn">psi</code>'s statistics (including <code>ks.obs</code>).</p>
</td></tr>
<tr><td><code>datanames</code></td>
<td>
<p>(class syrjala.test). A character vector with the names of the two patterns, the spatial congruence of which is been analyzed.</p>
</td></tr>
<tr><td><code>nperm</code></td>
<td>
<p>(class syrjala.test). The number of permutations employed in the test (not counting the original data).</p>
</td></tr>
<tr><td><code>psi.obs</code></td>
<td>
<p>(class ecespa.syrjala).The observed (averaged) <code class="reqn">psi</code> statistic.</p>
</td></tr>
<tr><td><code>psi.sim</code></td>
<td>
<p>(class ecespa.syrjala). A vector with the <code>nsim</code> simulated <code class="reqn">psi</code>'s statistics.</p>
</td></tr>
<tr><td><code>datanames</code></td>
<td>
<p>(class ecespa.syrjala). A vector with the names of the two point patterns whose spatial congruence is been analyzed.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>
<p>(class ecespa.syrjala). The number of permutations employed in the test.</p>
</td></tr>
</table>
<p>Both S3 plot methods plot an histogram with the distribution of the simulated <code class="reqn">psi</code>'s statistics and draws the observed <code class="reqn">psi</code> as a vertical line.
</p>


<h3>Warning </h3>

<p>The test requires both populations being sampled in exactly the same sampling locations. 
Althoug this implementation employs <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>'s as the supporting data format, this kind of data are <b>not</b> spatial point patterns.
They cannot be analysed with the usual tools employed for marked point patterns.</p>


<h3>Note</h3>

  <p><code>syrjala</code> or <code>syrjala0</code> (with the argument <code>R=FALSE</code>) implement a Fortran version of Syrjala's test. They run considerably faster
than the &quot;whole-R&quot; implementation of <code>syrjala.test</code> or <code>syrjala0</code> (with the argument <code>R=TRUE</code>). This last implementation is supplied for illustrative purposes and to 
maintain compability with previous versions of package <code>ecespa</code>. One can use function <code><a href="#topic+haz.ppp">haz.ppp</a></code> to easily build the <code>ppp</code> objects from a <code>data.frame</code> with only three columns (x-coordinate,
y-coordinate and abundance).  
</p>
<p>This function has been employed to compute Syrjala's test in Rey-Benayas et al. (2008).
</p>


<h3>Author(s)</h3>

<p> Jose M. Blanco-Moreno <a href="mailto:jmblanco@ub.edu">jmblanco@ub.edu</a> for the Fortran implementation of Syrjala's original QBasic function, Marcelino de la Cruz Rot for the R version, the wrapping functions and the documentation</p>


<h3>References</h3>

 
<p>Rey-Benayas, J.M., de la Montaña, E., Pérez-Camacho, L., de la Cruz, M., Moreno, D., Parejo, J.L. and Suárez-Seoane, S. 2010. 
Inter-annual dynamics and spatial congruence of a nocturnal bird assemblage inhabiting a Mediterranean agricultural mosaic. <em>Ardeola</em>,57(2): 303-320.
</p>
<p>Syrjala, S. E. 1996. A statistical test for a difference between the spatial distributions of two populations. <em>Ecology</em> 77: 75-80. <a href="https://doi.org/10.2307/2265656">doi:10.2307/2265656</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   
   data(syr1); data(syr2); data(syr3)
   
   coords &lt;- data.frame(x=syr1$x, y=syr1$y); var1&lt;- syr1$marks; var2&lt;- syr2$marks
   
   (stest&lt;-syrjala(coords, var1, var2, 9999))
   plot(stest)
   
   
   ## Not run: 
   
   plot(syrjala.test(syr1, syr2, nsim=999)) 
   
   plot(syrjala.test(syr1, syr3, nsim=999)) 
   
   syrjala0(coords, var1, var2, 9999)
   
   syrjala0(coords, var1, var2, 999, R=TRUE)
   
   
   coords &lt;- expand.grid(x=1:10,y=1:10)
   var1 &lt;- runif(100)
   var2 &lt;- runif(100)
   syrjala(coords, var1, var2, 9999)
   
   

## End(Not run)
</code></pre>

<hr>
<h2 id='syrjala.data'> Syrjala test data</h2><span id='topic+syr1'></span><span id='topic+syr2'></span><span id='topic+syr3'></span>

<h3>Description</h3>

<p>Artificial data to exemplify Syrjala's test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(syr1)
data(syr2)
data(syr3)</code></pre>


<h3>Format</h3>

<p><code>syr1</code>, <code>syr2</code> and <code>syr3</code> are marked point patterns 
of class &quot;ppp&quot; representing the coordinates of some sampling locations, 'marked' by 
the value of some parameters (e.g. density of individuals) measured on them. See <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> 
for details of the format. On the other hand, one can use function <code><a href="#topic+haz.ppp">haz.ppp</a></code> to easily build <code>ppp</code> objects 
appropriate for use with <code><a href="#topic+syrjala.test">syrjala.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(syr1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
