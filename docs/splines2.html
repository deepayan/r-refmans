<!DOCTYPE html><html><head><title>Help for package splines2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splines2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bernsteinPoly'><p>Generalized Bernstein Polynomial Basis Functions</p></a></li>
<li><a href='#bSpline'><p>B-Spline Basis for Polynomial Splines</p></a></li>
<li><a href='#cSpline'><p>C-Spline Basis for Polynomial Splines</p></a></li>
<li><a href='#deriv'><p>Derivatives of Spline Basis Functions</p></a></li>
<li><a href='#iSpline'><p>I-Spline Basis for Polynomial Splines</p></a></li>
<li><a href='#knots'><p>Extract Knots from the Given Object</p></a></li>
<li><a href='#mSpline'><p>M-Spline Basis for Polynomial Splines</p></a></li>
<li><a href='#naturalSpline'><p>Natural Cubic Spline Basis for Polynomial Splines</p></a></li>
<li><a href='#plot.splines2'><p>Visualize Spline Basis Functions</p></a></li>
<li><a href='#predict'><p>Compute Spline Function for Given Coefficients</p></a></li>
<li><a href='#splines2'><p>splines2: Regression Spline Functions and Classes</p></a></li>
<li><a href='#update'><p>Update Spline Basis Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Regression Spline Functions and Classes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Constructs basis functions of B-splines, M-splines,
    I-splines, convex splines (C-splines), periodic splines,
    natural cubic splines, generalized Bernstein polynomials,
    their derivatives, and integrals (except C-splines)
    by closed-form recursive formulas.
    It also contains a C++ head-only library integrated with Rcpp.
    See Wang and Yan (2021) &lt;<a href="https://doi.org/10.6339%2F21-JDS1020">doi:10.6339/21-JDS1020</a>&gt; for details.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tinytest, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wwenjie.org/splines2">https://wwenjie.org/splines2</a>,
<a href="https://github.com/wenjie2wang/splines2">https://github.com/wenjie2wang/splines2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wenjie2wang/splines2/issues">https://github.com/wenjie2wang/splines2/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 18:24:19 UTC; wenjie</td>
</tr>
<tr>
<td>Author:</td>
<td>Wenjie Wang <a href="https://orcid.org/0000-0003-0363-3180"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Jun Yan <a href="https://orcid.org/0000-0003-4401-7296"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wenjie Wang &lt;wang@wwenjie.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 20:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='bernsteinPoly'>Generalized Bernstein Polynomial Basis Functions</h2><span id='topic+bernsteinPoly'></span><span id='topic+bpoly'></span>

<h3>Description</h3>

<p>Returns generalized Bernstein polynomial basis functions of the given degree
over the specified range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bernsteinPoly(
  x,
  degree = 3,
  intercept = FALSE,
  Boundary.knots = NULL,
  derivs = 0L,
  integral = FALSE,
  ...
)

bpoly(
  x,
  degree = 3,
  intercept = FALSE,
  Boundary.knots = NULL,
  derivs = 0L,
  integral = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bernsteinPoly_+3A_x">x</code></td>
<td>
<p>The predictor variable taking values inside of the specified
boundary.  Missing values are allowed and will be returned as they are.</p>
</td></tr>
<tr><td><code id="bernsteinPoly_+3A_degree">degree</code></td>
<td>
<p>A nonnegative integer representing the degree of the
polynomials.</p>
</td></tr>
<tr><td><code id="bernsteinPoly_+3A_intercept">intercept</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output.</p>
</td></tr>
<tr><td><code id="bernsteinPoly_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>Boundary points at which to anchor the Bernstein
polynomial basis. The default value is <code>NULL</code> and the boundary
knots is set internally to be <code>range(x, na.rm = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="bernsteinPoly_+3A_derivs">derivs</code></td>
<td>
<p>A nonnegative integer specifying the order of derivatives.
The default value is <code>0L</code> for Bernstein polynomial basis functions.</p>
</td></tr>
<tr><td><code id="bernsteinPoly_+3A_integral">integral</code></td>
<td>
<p>A logical value.  If <code>TRUE</code>, the integrals of the
Bernstein polynomials will be returned.  The default value is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bernsteinPoly_+3A_...">...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bernstein polynomial basis functions are defined over the support from 0
to 1.  The generalized Bernstein polynomial basis functions extend the
support to any finite interval in the real line.
</p>
<p>The function <code>bpoly()</code> is an alias to encourage the use in a model
formula.
</p>


<h3>Value</h3>

<p>A <code>BernsteinPoly</code> object that is essentially a numeric matrix
of dimension <code>length(x)</code> by <code>degree + as.integer(intercept)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

x1 &lt;- seq.int(0, 1, 0.01)
x2 &lt;- seq.int(- 2, 2, 0.01)

## Bernstein polynomial basis matrix over [0, 1]
bMat1 &lt;- bernsteinPoly(x1, degree = 4, intercept = TRUE)

## generalized Bernstein polynomials basis over [- 2, 2]
bMat2 &lt;- bernsteinPoly(x2, degree = 4, intercept = TRUE)

op &lt;- par(mfrow = c(1, 2))
plot(bMat1)
plot(bMat2)

## the first and second derivative matrix
d1Mat1 &lt;- bernsteinPoly(x1, degree = 4, derivs = 1, intercept = TRUE)
d2Mat1 &lt;- bernsteinPoly(x1, degree = 4, derivs = 2, intercept = TRUE)
d1Mat2 &lt;- bernsteinPoly(x2, degree = 4, derivs = 1, intercept = TRUE)
d2Mat2 &lt;- bernsteinPoly(x2, degree = 4, derivs = 2, intercept = TRUE)

par(mfrow = c(2, 2))
plot(d1Mat1)
plot(d1Mat2)
plot(d2Mat1)
plot(d2Mat2)

## reset to previous plotting settings
par(op)

## or use the deriv method
all.equal(d1Mat1, deriv(bMat1))
all.equal(d2Mat1, deriv(bMat1, 2))

## the integrals
iMat1 &lt;- bernsteinPoly(x1, degree = 4, integral = TRUE, intercept = TRUE)
iMat2 &lt;- bernsteinPoly(x2, degree = 4, integral = TRUE, intercept = TRUE)
all.equal(deriv(iMat1), bMat1, check.attributes = FALSE)
all.equal(deriv(iMat2), bMat2, check.attributes = FALSE)
</code></pre>

<hr>
<h2 id='bSpline'>B-Spline Basis for Polynomial Splines</h2><span id='topic+bSpline'></span><span id='topic+ibs'></span><span id='topic+dbs'></span><span id='topic+bsp'></span>

<h3>Description</h3>

<p>Generates the spline basis matrix for B-splines representing the family of
piecewise polynomials with the specified interior knots, degree, and
boundary knots, evaluated at the values of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bSpline(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = FALSE,
  Boundary.knots = NULL,
  periodic = FALSE,
  derivs = 0L,
  integral = FALSE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)

ibs(
  x,
  df = NULL,
  knots = NULL,
  degree = 3,
  intercept = FALSE,
  Boundary.knots = NULL,
  ...
)

dbs(
  x,
  derivs = 1L,
  df = NULL,
  knots = NULL,
  degree = 3,
  intercept = FALSE,
  Boundary.knots = NULL,
  ...
)

bsp(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = FALSE,
  Boundary.knots = NULL,
  periodic = FALSE,
  derivs = 0L,
  integral = FALSE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bSpline_+3A_x">x</code></td>
<td>
<p>The predictor variable.  Missing values are allowed and will be
returned as they are.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_df">df</code></td>
<td>
<p>Degree of freedom that equals to the column number of the returned
matrix.  One can specify <code>df</code> rather than <code>knots</code>, then the
function chooses <code>df - degree - as.integer(intercept)</code> internal
knots at suitable quantiles of <code>x</code> ignoring missing values and
those <code>x</code> outside of the boundary.  For periodic splines, <code>df
- as.integer(intercept)</code> internal knots will be chosen at suitable
quantiles of <code>x</code> relative to the beginning of the cyclic intervals
they belong to (see Examples) and the number of internal knots must be
greater or equal to the specified <code>degree - 1</code>.  If internal knots
are specified via <code>knots</code>, the specified <code>df</code> will be ignored.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_knots">knots</code></td>
<td>
<p>The internal breakpoints that define the splines.  The default
is <code>NULL</code>, which results in a basis for ordinary polynomial
regression.  Typical values are the mean or median for one knot,
quantiles for more knots.  For periodic splines, the number of knots
must be greater or equal to the specified <code>degree - 1</code>.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_degree">degree</code></td>
<td>
<p>A nonnegative integer specifying the degree of the piecewise
polynomial. The default value is <code>3</code> for cubic splines. Zero degree
is allowed for piecewise constant basis functions.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_intercept">intercept</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>Boundary points at which to anchor the splines.  By
default, they are the range of <code>x</code> excluding <code>NA</code>.  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>. Data can extend beyond
<code>Boundary.knots</code>.  For periodic splines, the specified bounary
knots define the cyclic interval.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_periodic">periodic</code></td>
<td>
<p>A logical value.  If <code>TRUE</code>, the periodic splines will
be returned.  The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_derivs">derivs</code></td>
<td>
<p>A nonnegative integer specifying the order of derivatives of
splines basis function.  The default value is <code>0</code>.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_integral">integral</code></td>
<td>
<p>A logical value.  If <code>TRUE</code>, the corresponding
integrals of spline basis functions will be returned.  The default value
is <code>FALSE</code>. For periodic splines, the integral of each basis is
integrated from the left boundary knot.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_warn.outside">warn.outside</code></td>
<td>
<p>A logical value indicating if a warning should be thrown
out when any <code>x</code> is outside the boundary.  This option can also be
set through <code>options("splines2.warn.outside")</code> after the package is
loaded.</p>
</td></tr>
<tr><td><code id="bSpline_+3A_...">...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends the <code>bs()</code> function in the <code>splines</code> package
for B-spline basis functions by allowing piecewise constant (left-closed and
right-open except on the right boundary) spline basis of degree zero.  In
addition, the function provides derivatives or integrals of the B-spline
basis functions when one specifies the arguments <code>derivs</code> or
<code>integral</code> appropriately.  The function constructs periodic B-splines
when <code>periodic</code> is <code>TRUE</code>.  All the implementations are based on
the closed-form recursion formula following De Boor (1978) and Wang and Yan
(2021).
</p>
<p>The functions <code>ibs()</code> and <code>dbs()</code> are provided for convenience.
The former provides the integrals of B-splines and is equivalent to
<code>bSpline()</code> with <code>integral = TRUE</code>.  The latter produces the
derivatives of given order of B-splines and is equivalent to
<code>bSpline()</code> with default <code>derivs = 1</code>.  The function <code>bsp()</code>
is an alias of to encourage the use in a model formula.
</p>


<h3>Value</h3>

<p>A numeric matrix of <code>length(x)</code> rows and <code>df</code> columns if
<code>df</code> is specified.  If <code>knots</code> are specified instead, the
output matrix will consist of <code>length(knots) + degree +
    as.integer(intercept)</code> columns if <code>periodic = FALSE</code>, or
<code>length(knots) + as.integer(intercept)</code> columns if <code>periodic =
    TRUE</code>.  Attributes that correspond to the arguments specified are
returned for usage of other functions in this package.
</p>


<h3>References</h3>

<p>De Boor, Carl. (1978). <em>A practical guide to splines</em>.
Vol. 27. New York: Springer-Verlag.
</p>
<p>Wang, W., &amp; Yan, J. (2021). <em>Shape-restricted regression splines with R
package splines2</em>. Journal of Data Science, 19(3),498&ndash;517.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knots">knots</a></code> for extracting internal and boundary knots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

set.seed(1)
x &lt;- runif(100)
knots &lt;- c(0.3, 0.5, 0.6) # internal knots

## cubic B-splines
bsMat &lt;- bSpline(x, knots = knots, degree = 3, intercept = TRUE)
ibsMat &lt;- update(bsMat, integral = TRUE) # the integrals
d1Mat &lt;- deriv(bsMat)                    # the 1st derivaitves
d2Mat &lt;- deriv(bsMat, 2)                 # the 2nd derivaitves

op &lt;- par(mfrow = c(2, 2), mar = c(2.5, 2.5, 0.2, 0.1), mgp = c(1.5, 0.5, 0))
plot(bsMat, ylab = "Cubic B-splines")
plot(ibsMat, ylab = "The integrals")
plot(d1Mat, ylab = "The 1st derivatives")
plot(d2Mat, ylab = "The 2nd derivatives")

## evaluate at new values
predict(bsMat, c(0.125, 0.801))

## periodic B-splines
px &lt;- seq(0, 3, 0.01)
pbsMat &lt;- bSpline(px, knots = knots, Boundary.knots = c(0, 1),
                  intercept = TRUE, periodic = TRUE)
ipMat &lt;- update(pbsMat, integral = TRUE)
dpMat &lt;- deriv(pbsMat)
dp2Mat &lt;- deriv(pbsMat, 2)

plot(pbsMat, ylab = "Periodic B-splines", mark_knots = "b")
plot(ipMat, ylab = "The integrals", mark_knots = "b")
plot(dpMat, ylab = "The 1st derivatives", mark_knots = "b")
plot(dp2Mat, ylab = "The 2nd derivatives", mark_knots = "b")
par(op) # reset to previous plotting settings
</code></pre>

<hr>
<h2 id='cSpline'>C-Spline Basis for Polynomial Splines</h2><span id='topic+cSpline'></span><span id='topic+csp'></span>

<h3>Description</h3>

<p>Generates the convex regression spline (called C-spline) basis matrix by
integrating I-spline basis for a polynomial spline or the corresponding
derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cSpline(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = TRUE,
  Boundary.knots = NULL,
  derivs = 0L,
  scale = TRUE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)

csp(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = TRUE,
  Boundary.knots = NULL,
  derivs = 0L,
  scale = TRUE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSpline_+3A_x">x</code></td>
<td>
<p>The predictor variable.  Missing values are allowed and will be
returned as they are.</p>
</td></tr>
<tr><td><code id="cSpline_+3A_df">df</code></td>
<td>
<p>Degree of freedom that equals to the column number of the returned
matrix.  One can specify <code>df</code> rather than <code>knots</code>, then the
function chooses <code>df - degree - as.integer(intercept)</code> internal
knots at suitable quantiles of <code>x</code> ignoring missing values and
those <code>x</code> outside of the boundary.  For periodic splines, <code>df
- as.integer(intercept)</code> internal knots will be chosen at suitable
quantiles of <code>x</code> relative to the beginning of the cyclic intervals
they belong to (see Examples) and the number of internal knots must be
greater or equal to the specified <code>degree - 1</code>.  If internal knots
are specified via <code>knots</code>, the specified <code>df</code> will be ignored.</p>
</td></tr>
<tr><td><code id="cSpline_+3A_knots">knots</code></td>
<td>
<p>The internal breakpoints that define the splines.  The default
is <code>NULL</code>, which results in a basis for ordinary polynomial
regression.  Typical values are the mean or median for one knot,
quantiles for more knots.  For periodic splines, the number of knots
must be greater or equal to the specified <code>degree - 1</code>.</p>
</td></tr>
<tr><td><code id="cSpline_+3A_degree">degree</code></td>
<td>
<p>The degree of C-spline defined to be the degree of the
associated M-spline instead of actual polynomial degree. For example,
C-spline basis of degree 2 is defined as the scaled double integral of
associated M-spline basis of degree 2.</p>
</td></tr>
<tr><td><code id="cSpline_+3A_intercept">intercept</code></td>
<td>
<p>If <code>TRUE</code> by default, all of the spline basis
functions are returned.  Notice that when using C-Spline for
shape-restricted regression, <code>intercept = TRUE</code> should be set even
when an intercept term is considered additional to the spline basis in
the model.</p>
</td></tr>
<tr><td><code id="cSpline_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>Boundary points at which to anchor the splines.  By
default, they are the range of <code>x</code> excluding <code>NA</code>.  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>. Data can extend beyond
<code>Boundary.knots</code>.  For periodic splines, the specified bounary
knots define the cyclic interval.</p>
</td></tr>
<tr><td><code id="cSpline_+3A_derivs">derivs</code></td>
<td>
<p>A nonnegative integer specifying the order of derivatives of
C-splines. The default value is <code>0L</code> for C-spline basis functions.</p>
</td></tr>
<tr><td><code id="cSpline_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating if scaling C-splines is required. If
<code>TRUE</code> by default, each C-spline basis is scaled to have unit
height at right boundary knot. The corresponding I-spline and M-spline
produced by <code>deriv</code> methods will be scaled to the same extent.</p>
</td></tr>
<tr><td><code id="cSpline_+3A_warn.outside">warn.outside</code></td>
<td>
<p>A logical value indicating if a warning should be thrown
out when any <code>x</code> is outside the boundary.  This option can also be
set through <code>options("splines2.warn.outside")</code> after the package is
loaded.</p>
</td></tr>
<tr><td><code id="cSpline_+3A_...">...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is an implementation of the closed-form C-spline basis derived from the
recursion formula of I-splines and M-splines.  The function <code>csp()</code> is
an alias of to encourage the use in a model formula.
</p>


<h3>Value</h3>

<p>A numeric matrix of <code>length(x)</code> rows and <code>df</code> columns if
<code>df</code> is specified.  If <code>knots</code> are specified instead, the
output matrix will consist of <code>length(knots) + degree +
    as.integer(intercept)</code> columns.  Attributes that correspond to the
arguments specified are returned for usage of other functions in this
package.
</p>


<h3>References</h3>

<p>Meyer, M. C. (2008). Inference using shape-restricted regression splines.
<em>The Annals of Applied Statistics</em>, 2(3), 1013&ndash;1033.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iSpline">iSpline</a></code> for I-splines;
<code><a href="#topic+mSpline">mSpline</a></code> for M-splines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

x &lt;- seq.int(0, 1, 0.01)
knots &lt;- c(0.3, 0.5, 0.6)

### when 'scale = TRUE' (by default)
csMat &lt;- cSpline(x, knots = knots, degree = 2)

plot(csMat, ylab = "C-spline basis", mark_knots = "internal")
isMat &lt;- deriv(csMat)
msMat &lt;- deriv(csMat, derivs = 2)
plot(isMat, ylab = "scaled I-spline basis")
plot(msMat, ylab = "scaled M-spline basis")

### when 'scale = FALSE'
csMat &lt;- cSpline(x, knots = knots, degree = 2, scale = FALSE)

## the corresponding I-splines and M-splines (with same arguments)
isMat &lt;- iSpline(x, knots = knots, degree = 2)
msMat &lt;- mSpline(x, knots = knots, degree = 2, intercept = TRUE)

## or using deriv methods (more efficient)
isMat1 &lt;- deriv(csMat)
msMat1 &lt;- deriv(csMat, derivs = 2)

## equivalent
stopifnot(all.equal(isMat, isMat1, check.attributes = FALSE))
stopifnot(all.equal(msMat, msMat1, check.attributes = FALSE))
</code></pre>

<hr>
<h2 id='deriv'>Derivatives of Spline Basis Functions</h2><span id='topic+deriv'></span><span id='topic+deriv.BSpline'></span><span id='topic+deriv.MSpline'></span><span id='topic+deriv.ISpline'></span><span id='topic+deriv.CSpline'></span><span id='topic+deriv.BernsteinPoly'></span><span id='topic+deriv.NaturalSpline'></span><span id='topic+deriv.NaturalSplineK'></span>

<h3>Description</h3>

<p>Returns derivatives of given order for the given spline basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BSpline'
deriv(expr, derivs = 1L, ...)

## S3 method for class 'MSpline'
deriv(expr, derivs = 1L, ...)

## S3 method for class 'ISpline'
deriv(expr, derivs = 1L, ...)

## S3 method for class 'CSpline'
deriv(expr, derivs = 1L, ...)

## S3 method for class 'BernsteinPoly'
deriv(expr, derivs = 1L, ...)

## S3 method for class 'NaturalSpline'
deriv(expr, derivs = 1L, ...)

## S3 method for class 'NaturalSplineK'
deriv(expr, derivs = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_+3A_expr">expr</code></td>
<td>
<p>Objects of class <code>bSpline2</code>, <code>ibs</code>, <code>mSpline</code>,
<code>iSpline</code>, <code>cSpline</code>, <code>bernsteinPoly</code> or
<code>naturalSpline</code> with attributes describing <code>knots</code>,
<code>degree</code>, etc.</p>
</td></tr>
<tr><td><code id="deriv_+3A_derivs">derivs</code></td>
<td>
<p>A positive integer specifying the order of derivatives. By
default, it is <code>1L</code> for the first derivatives.</p>
</td></tr>
<tr><td><code id="deriv_+3A_...">...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At knots, the derivative is defined to be the right derivative except at the
right boundary knot. By default, the function returns the first derivatives.
For derivatives of order greater than one, nested function calls such as
<code>deriv(deriv(expr))</code> are supported but not recommended.  For a better
performance, argument <code>derivs</code> should be specified instead.
</p>
<p>This function is designed for objects produced by this package.  It
internally extracts necessary specification about the spline/polynomial
basis matrix from its attributes. Therefore, the function will not work if
the key attributes are not available after some operations.
</p>


<h3>Value</h3>

<p>A numeric matrix of the same dimension with the input <code>expr</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

x &lt;- c(seq.int(0, 1, 0.1), NA)  # NA's will be kept.
knots &lt;- c(0.3, 0.5, 0.6)

## helper function
stopifnot_equivalent &lt;- function(...) {
    stopifnot(all.equal(..., check.attributes = FALSE))
}

## integal of B-splines and the corresponding B-splines integrated
ibsMat &lt;- ibs(x, knots = knots)
bsMat &lt;- bSpline(x, knots = knots)

## the first derivative
d1Mat &lt;- deriv(ibsMat)
stopifnot_equivalent(bsMat, d1Mat)

## the second derivative
d2Mat1 &lt;- deriv(bsMat)
d2Mat2 &lt;- deriv(ibsMat, derivs = 2L)
stopifnot_equivalent(d2Mat1, d2Mat2)

## nested calls are supported
d2Mat3 &lt;- deriv(deriv(ibsMat))
stopifnot_equivalent(d2Mat2, d2Mat3)

## C-splines, I-splines, M-splines and the derivatives
csMat &lt;- cSpline(x, knots = knots, intercept = TRUE, scale = FALSE)
isMat &lt;- iSpline(x, knots = knots, intercept = TRUE)
stopifnot_equivalent(isMat, deriv(csMat))

msMat &lt;- mSpline(x, knots = knots, intercept = TRUE)
stopifnot_equivalent(msMat, deriv(isMat))
stopifnot_equivalent(msMat, deriv(csMat, 2))
stopifnot_equivalent(msMat, deriv(deriv(csMat)))

dmsMat &lt;- mSpline(x, knots = knots, intercept = TRUE, derivs = 1)
stopifnot_equivalent(dmsMat, deriv(msMat))
stopifnot_equivalent(dmsMat, deriv(isMat, 2))
stopifnot_equivalent(dmsMat, deriv(deriv(isMat)))
stopifnot_equivalent(dmsMat, deriv(csMat, 3))
stopifnot_equivalent(dmsMat, deriv(deriv(deriv(csMat))))
</code></pre>

<hr>
<h2 id='iSpline'>I-Spline Basis for Polynomial Splines</h2><span id='topic+iSpline'></span><span id='topic+isp'></span>

<h3>Description</h3>

<p>Generates the I-spline (integral of M-spline) basis matrix for a polynomial
spline or the corresponding derivatives of given order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iSpline(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = TRUE,
  Boundary.knots = NULL,
  derivs = 0L,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)

isp(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = TRUE,
  Boundary.knots = NULL,
  derivs = 0L,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iSpline_+3A_x">x</code></td>
<td>
<p>The predictor variable.  Missing values are allowed and will be
returned as they are.</p>
</td></tr>
<tr><td><code id="iSpline_+3A_df">df</code></td>
<td>
<p>Degree of freedom that equals to the column number of the returned
matrix.  One can specify <code>df</code> rather than <code>knots</code>, then the
function chooses <code>df - degree - as.integer(intercept)</code> internal
knots at suitable quantiles of <code>x</code> ignoring missing values and
those <code>x</code> outside of the boundary.  For periodic splines, <code>df
- as.integer(intercept)</code> internal knots will be chosen at suitable
quantiles of <code>x</code> relative to the beginning of the cyclic intervals
they belong to (see Examples) and the number of internal knots must be
greater or equal to the specified <code>degree - 1</code>.  If internal knots
are specified via <code>knots</code>, the specified <code>df</code> will be ignored.</p>
</td></tr>
<tr><td><code id="iSpline_+3A_knots">knots</code></td>
<td>
<p>The internal breakpoints that define the splines.  The default
is <code>NULL</code>, which results in a basis for ordinary polynomial
regression.  Typical values are the mean or median for one knot,
quantiles for more knots.  For periodic splines, the number of knots
must be greater or equal to the specified <code>degree - 1</code>.</p>
</td></tr>
<tr><td><code id="iSpline_+3A_degree">degree</code></td>
<td>
<p>The degree of I-spline defined to be the degree of the
associated M-spline instead of actual polynomial degree. For example,
I-spline basis of degree 2 is defined as the integral of associated
M-spline basis of degree 2.</p>
</td></tr>
<tr><td><code id="iSpline_+3A_intercept">intercept</code></td>
<td>
<p>If <code>TRUE</code> by default, all of the spline basis
functions are returned.  Notice that when using I-Spline for monotonic
regression, <code>intercept = TRUE</code> should be set even when an intercept
term is considered additional to the spline basis functions.</p>
</td></tr>
<tr><td><code id="iSpline_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>Boundary points at which to anchor the splines.  By
default, they are the range of <code>x</code> excluding <code>NA</code>.  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>. Data can extend beyond
<code>Boundary.knots</code>.  For periodic splines, the specified bounary
knots define the cyclic interval.</p>
</td></tr>
<tr><td><code id="iSpline_+3A_derivs">derivs</code></td>
<td>
<p>A nonnegative integer specifying the order of derivatives of
I-splines.</p>
</td></tr>
<tr><td><code id="iSpline_+3A_warn.outside">warn.outside</code></td>
<td>
<p>A logical value indicating if a warning should be thrown
out when any <code>x</code> is outside the boundary.  This option can also be
set through <code>options("splines2.warn.outside")</code> after the package is
loaded.</p>
</td></tr>
<tr><td><code id="iSpline_+3A_...">...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is an implementation of the closed-form I-spline basis based on the
recursion formula given by Ramsay (1988).  The function <code>isp()</code> is an
alias of to encourage the use in a model formula.
</p>


<h3>Value</h3>

<p>A numeric matrix of <code>length(x)</code> rows and <code>df</code> columns if
<code>df</code> is specified.  If <code>knots</code> are specified instead, the
output matrix will consist of <code>length(knots) + degree +
    as.integer(intercept)</code> columns.  Attributes that correspond to the
arguments specified are returned for usage of other functions in this
package.
</p>


<h3>References</h3>

<p>Ramsay, J. O. (1988). Monotone regression splines in action.
<em>Statistical Science</em>, 3(4), 425&ndash;441.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mSpline">mSpline</a></code> for M-splines;
<code><a href="#topic+cSpline">cSpline</a></code> for C-splines;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

## an example given in Ramsay (1988)
x &lt;- seq.int(0, 1, by = 0.01)
knots &lt;- c(0.3, 0.5, 0.6)
isMat &lt;- iSpline(x, knots = knots, degree = 2)

op &lt;- par(mar = c(2.5, 2.5, 0.2, 0.1), mgp = c(1.5, 0.5, 0))
plot(isMat, ylab = "I-spline basis", mark_knots = "internal")
par(op) # reset to previous plotting settings

## the derivative of I-splines is M-spline
msMat1 &lt;- iSpline(x, knots = knots, degree = 2, derivs = 1)
msMat2 &lt;- mSpline(x, knots = knots, degree = 2, intercept = TRUE)
stopifnot(all.equal(msMat1, msMat2))
</code></pre>

<hr>
<h2 id='knots'>Extract Knots from the Given Object</h2><span id='topic+knots'></span><span id='topic+knots.splines2'></span>

<h3>Description</h3>

<p>Methods for the generic function <code>knots</code> from the <span class="pkg">stats</span> package
to obtain internal or boundary knots from the objects produced by this
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splines2'
knots(Fn, type = c("internal", "boundary"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knots_+3A_fn">Fn</code></td>
<td>
<p>An <code>splines2</code> object produced by this package.</p>
</td></tr>
<tr><td><code id="knots_+3A_type">type</code></td>
<td>
<p>A character vector of length one indicating the type of knots to
return.  The available choices are <code>"internal"</code> for internal knots
and <code>"Boundary"</code> for boundary knots.</p>
</td></tr>
<tr><td><code id="knots_+3A_...">...</code></td>
<td>
<p>Optional arguments that are not used now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

set.seed(123)
x &lt;- rnorm(100)

## B-spline basis
bsMat &lt;- bSpline(x, df = 8, degree = 3)

## extract internal knots placed based on the quantile of x
(internal_knots &lt;- knots(bsMat))

## extract boundary knots placed based on the range of x
boundary_knots &lt;- knots(bsMat, type = "boundary")
all.equal(boundary_knots, range(x))
</code></pre>

<hr>
<h2 id='mSpline'>M-Spline Basis for Polynomial Splines</h2><span id='topic+mSpline'></span><span id='topic+msp'></span>

<h3>Description</h3>

<p>Generates the basis matrix of regular M-spline, periodic M-spline, and the
corresponding integrals and derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mSpline(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = FALSE,
  Boundary.knots = NULL,
  periodic = FALSE,
  derivs = 0L,
  integral = FALSE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)

msp(
  x,
  df = NULL,
  knots = NULL,
  degree = 3L,
  intercept = FALSE,
  Boundary.knots = NULL,
  periodic = FALSE,
  derivs = 0L,
  integral = FALSE,
  warn.outside = getOption("splines2.warn.outside", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mSpline_+3A_x">x</code></td>
<td>
<p>The predictor variable.  Missing values are allowed and will be
returned as they are.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_df">df</code></td>
<td>
<p>Degree of freedom that equals to the column number of the returned
matrix.  One can specify <code>df</code> rather than <code>knots</code>, then the
function chooses <code>df - degree - as.integer(intercept)</code> internal
knots at suitable quantiles of <code>x</code> ignoring missing values and
those <code>x</code> outside of the boundary.  For periodic splines, <code>df
- as.integer(intercept)</code> internal knots will be chosen at suitable
quantiles of <code>x</code> relative to the beginning of the cyclic intervals
they belong to (see Examples) and the number of internal knots must be
greater or equal to the specified <code>degree - 1</code>.  If internal knots
are specified via <code>knots</code>, the specified <code>df</code> will be ignored.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_knots">knots</code></td>
<td>
<p>The internal breakpoints that define the splines.  The default
is <code>NULL</code>, which results in a basis for ordinary polynomial
regression.  Typical values are the mean or median for one knot,
quantiles for more knots.  For periodic splines, the number of knots
must be greater or equal to the specified <code>degree - 1</code>.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_degree">degree</code></td>
<td>
<p>A nonnegative integer specifying the degree of the piecewise
polynomial. The default value is <code>3</code> for cubic splines. Zero degree
is allowed for piecewise constant basis functions.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_intercept">intercept</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>Boundary points at which to anchor the splines.  By
default, they are the range of <code>x</code> excluding <code>NA</code>.  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>. Data can extend beyond
<code>Boundary.knots</code>.  For periodic splines, the specified bounary
knots define the cyclic interval.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_periodic">periodic</code></td>
<td>
<p>A logical value.  If <code>TRUE</code>, the periodic splines will
be returned.  The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_derivs">derivs</code></td>
<td>
<p>A nonnegative integer specifying the order of derivatives of
splines basis function.  The default value is <code>0</code>.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_integral">integral</code></td>
<td>
<p>A logical value.  If <code>TRUE</code>, the corresponding
integrals of spline basis functions will be returned.  The default value
is <code>FALSE</code>. For periodic splines, the integral of each basis is
integrated from the left boundary knot.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_warn.outside">warn.outside</code></td>
<td>
<p>A logical value indicating if a warning should be thrown
out when any <code>x</code> is outside the boundary.  This option can also be
set through <code>options("splines2.warn.outside")</code> after the package is
loaded.</p>
</td></tr>
<tr><td><code id="mSpline_+3A_...">...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function contains an implementation of the closed-form M-spline basis
based on the recursion formula given by Ramsay (1988) or periodic M-spline
basis following the procedure producing periodic B-splines given in Piegl
and Tiller (1997).  For monotone regression, one can use I-splines (see
<code><a href="#topic+iSpline">iSpline</a></code>) instead of M-splines.  For shape-restricted
regression, see Wang and Yan (2021) for examples.
</p>
<p>The function <code>msp()</code> is an alias of to encourage the use in a model
formula.
</p>


<h3>Value</h3>

<p>A numeric matrix of <code>length(x)</code> rows and <code>df</code> columns if
<code>df</code> is specified.  If <code>knots</code> are specified instead, the
output matrix will consist of <code>length(knots) + degree +
    as.integer(intercept)</code> columns if <code>periodic = FALSE</code>, or
<code>length(knots) + as.integer(intercept)</code> columns if <code>periodic =
    TRUE</code>.  Attributes that correspond to the arguments specified are
returned for usage of other functions in this package.
</p>


<h3>References</h3>

<p>Ramsay, J. O. (1988). Monotone regression splines in action.
<em>Statistical science</em>, 3(4), 425&ndash;441.
</p>
<p>Piegl, L., &amp; Tiller, W. (1997). <em>The NURBS book</em>. Springer Science &amp;
Business Media.
</p>
<p>Wang, W., &amp; Yan, J. (2021). <em>Shape-restricted regression splines with R
package splines2</em>. Journal of Data Science, 19(3),498&ndash;517.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bSpline">bSpline</a></code> for B-splines;
<code><a href="#topic+iSpline">iSpline</a></code> for I-splines;
<code><a href="#topic+cSpline">cSpline</a></code> for C-splines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

### example given in the reference paper by Ramsay (1988)
x &lt;- seq.int(0, 1, 0.01)
knots &lt;- c(0.3, 0.5, 0.6)
msMat &lt;- mSpline(x, knots = knots, degree = 2, intercept = TRUE)

op &lt;- par(mar = c(2.5, 2.5, 0.2, 0.1), mgp = c(1.5, 0.5, 0))
plot(msMat, mark_knots = "internal")

## derivatives of M-splines
dmsMat &lt;- mSpline(x, knots = knots, degree = 2,
                  intercept = TRUE, derivs = 1)

## or using the deriv method
dmsMat1 &lt;- deriv(msMat)
stopifnot(all.equal(dmsMat, dmsMat1, check.attributes = FALSE))

### periodic M-splines
x &lt;- seq.int(0, 3, 0.01)
bknots &lt;- c(0, 1)
pMat &lt;- mSpline(x, knots = knots, degree = 3, intercept = TRUE,
                Boundary.knots = bknots, periodic = TRUE)
## integrals
iMat &lt;- mSpline(x, knots = knots, degree = 3, intercept = TRUE,
                Boundary.knots = bknots, periodic = TRUE, integral = TRUE)
## first derivatives by "derivs = 1"
dMat1 &lt;- mSpline(x, knots = knots, degree = 3, intercept = TRUE,
                 Boundary.knots = bknots, periodic = TRUE, derivs = 1)
## first derivatives by using the deriv() method
dMat2 &lt;- deriv(pMat)

par(mfrow = c(2, 2))
plot(pMat, ylab = "Periodic Basis", mark_knots = "boundary")
plot(iMat, ylab = "Integrals from 0")
abline(v = seq.int(0, max(x)), h = seq.int(0, max(x)), lty = 2, col = "grey")
plot(dMat1, ylab = "1st derivatives by 'derivs=1'", mark_knots = "boundary")
plot(dMat2, ylab = "1st derivatives by 'deriv()'", mark_knots = "boundary")
par(op) # reset to previous plotting settings

### default placement of internal knots for periodic splines
default_knots &lt;- function(x, df, intercept = FALSE,
                        Boundary.knots = range(x, na.rm = TRUE)) {
    ## get x in the cyclic interval [0, 1)
    x2 &lt;- (x - Boundary.knots[1]) %% (Boundary.knots[2] - Boundary.knots[1])
    knots &lt;- quantile(x2, probs = seq(0, 1, length.out = df + 2 - intercept))
    unname(knots[- c(1, length(knots))])
}

df &lt;- 8
degree &lt;- 3
intercept &lt;- TRUE
internal_knots &lt;- default_knots(x, df, intercept)

## 1. specify df
spline_basis1 =  mSpline(x, degree = degree, df = df,
                         periodic = TRUE, intercept = intercept)
## 2. specify knots
spline_basis2 =  mSpline(x, degree = degree, knots = internal_knots,
                         periodic = TRUE, intercept = intercept)

all.equal(internal_knots, knots(spline_basis1))
all.equal(spline_basis1, spline_basis2)
</code></pre>

<hr>
<h2 id='naturalSpline'>Natural Cubic Spline Basis for Polynomial Splines</h2><span id='topic+naturalSpline'></span><span id='topic+nsp'></span><span id='topic+nsk'></span>

<h3>Description</h3>

<p>Functions <code>naturalSpline()</code> and <code>nsk()</code> generate the natural cubic
spline basis functions, the corresponding derivatives or integrals (from the
left boundary knot).  Both of them are different from <code>splines::ns()</code>.
However, for a given model fitting procedure, using different variants of
spline basis functions should result in identical prediction values.  The
coefficient estimates of the spline basis functions returned by <code>nsk()</code>
are more interpretable compared to <code>naturalSpline()</code> or
<code>splines::ns()</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naturalSpline(
  x,
  df = NULL,
  knots = NULL,
  intercept = FALSE,
  Boundary.knots = NULL,
  trim = 0,
  derivs = 0L,
  integral = FALSE,
  ...
)

nsp(
  x,
  df = NULL,
  knots = NULL,
  intercept = FALSE,
  Boundary.knots = NULL,
  trim = 0,
  derivs = 0L,
  integral = FALSE,
  ...
)

nsk(
  x,
  df = NULL,
  knots = NULL,
  intercept = FALSE,
  Boundary.knots = NULL,
  trim = 0,
  derivs = 0L,
  integral = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naturalSpline_+3A_x">x</code></td>
<td>
<p>The predictor variable.  Missing values are allowed and will be
returned as they are.</p>
</td></tr>
<tr><td><code id="naturalSpline_+3A_df">df</code></td>
<td>
<p>Degree of freedom that equals to the column number of returned
matrix.  One can specify <code>df</code> rather than <code>knots</code>, then the
function chooses <code>df - 1 - as.integer(intercept)</code> internal knots at
suitable quantiles of <code>x</code> ignoring missing values and those
<code>x</code> outside of the boundary.  Thus, <code>df</code> must be greater than
or equal to <code>2</code>.  If internal knots are specified via <code>knots</code>,
the specified <code>df</code> will be ignored.</p>
</td></tr>
<tr><td><code id="naturalSpline_+3A_knots">knots</code></td>
<td>
<p>The internal breakpoints that define the splines.  The default
is <code>NULL</code>, which results in a basis for ordinary polynomial
regression.  Typical values are the mean or median for one knot,
quantiles for more knots.  For periodic splines, the number of knots
must be greater or equal to the specified <code>degree - 1</code>.</p>
</td></tr>
<tr><td><code id="naturalSpline_+3A_intercept">intercept</code></td>
<td>
<p>If <code>TRUE</code>, the complete basis matrix will be returned.
Otherwise, the first basis will be excluded from the output.</p>
</td></tr>
<tr><td><code id="naturalSpline_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>Boundary points at which to anchor the splines.  By
default, they are the range of <code>x</code> excluding <code>NA</code>.  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>. Data can extend beyond
<code>Boundary.knots</code>.  For periodic splines, the specified bounary
knots define the cyclic interval.</p>
</td></tr>
<tr><td><code id="naturalSpline_+3A_trim">trim</code></td>
<td>
<p>The fraction (0 to 0.5) of observations to be trimmed from each
end of <code>x</code> before placing the default internal and boundary knots.
This argument will be ignored if <code>Boundary.knots</code> is specified.
The default value is <code>0</code> for backward compatibility, which sets the
boundary knots as the range of <code>x</code>.  If a positive fraction is
specified, the default boundary knots will be equivalent to
<code>quantile(x, probs = c(trim, 1 - trim), na.rm = TRUE)</code>, which can
be a more sensible choice in practice due to the existence of outliers.
The default internal knots are placed within the boundary afterwards.</p>
</td></tr>
<tr><td><code id="naturalSpline_+3A_derivs">derivs</code></td>
<td>
<p>A nonnegative integer specifying the order of derivatives of
natural splines. The default value is <code>0L</code> for the spline basis
functions.</p>
</td></tr>
<tr><td><code id="naturalSpline_+3A_integral">integral</code></td>
<td>
<p>A logical value.  The default value is <code>FALSE</code>.  If
<code>TRUE</code>, this function will return the integrated natural splines
from the left boundary knot.</p>
</td></tr>
<tr><td><code id="naturalSpline_+3A_...">...</code></td>
<td>
<p>Optional arguments that are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructed spline basis functions from <code>naturalSpline()</code> are
nonnegative within boundary with the second derivatives being zeros at
boundary knots.  The implementation utilizes the close-form null space that
can be derived from the recursive formula for the second derivatives of
B-splines.  The function <code>nsp()</code> is an alias of <code>naturalSpline()</code>
to encourage the use in a model formula.
</p>
<p>The function <code>nsk()</code> produces another variant of natural cubic spline
matrix such that only one of the basis functions is nonzero and takes a
value of one at every boundary and internal knot.  As a result, the
coefficients of the resulting fit are the values of the spline function at
the knots, which makes it easy to interpret the coefficient estimates.  In
other words, the coefficients of a linear model will be the heights of the
function at the knots if <code>intercept = TRUE</code>.  If <code>intercept =
FALSE</code>, the coefficients will be the change in function value between each
knot.  This implementation closely follows the function <code>nsk()</code> of the
<span class="pkg">survival</span> package (version 3.2-8).  The idea corresponds directly to
the physical implementation of a spline by passing a flexible strip of wood
or metal through a set of fixed points, which is a traditional way to create
smooth shapes for things like a ship hull.
</p>
<p>The returned basis matrix can be obtained by transforming the corresponding
B-spline basis matrix with the matrix <code>H</code> provided in the attribute of
the returned object.  Each basis is assumed to follow a linear trend for
<code>x</code> outside of boundary.  A similar implementation is provided by
<code>splines::ns</code>, which uses QR decomposition to find the null space of
the second derivatives of B-spline basis at boundary knots.  See
Supplementray Materials of Wang and Yan (2021) for a more detailed
introduction.
</p>


<h3>Value</h3>

<p>A numeric matrix of <code>length(x)</code> rows and <code>df</code>
columns if <code>df</code> is specified or <code>length(knots) + 1 +
    as.integer(intercept)</code> columns if <code>knots</code> are specified instead.
Attributes that correspond to the arguments specified are returned for
usage of other functions in this package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bSpline">bSpline</a></code> for B-splines;
<code><a href="#topic+mSpline">mSpline</a></code> for M-splines;
<code><a href="#topic+iSpline">iSpline</a></code> for I-splines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

x &lt;- seq.int(0, 1, 0.01)
knots &lt;- c(0.3, 0.5, 0.6)

## naturalSpline()
nsMat0 &lt;- naturalSpline(x, knots = knots, intercept = TRUE)
nsMat1 &lt;- naturalSpline(x, knots = knots, intercept = TRUE, integral = TRUE)
nsMat2 &lt;- naturalSpline(x, knots = knots, intercept = TRUE, derivs = 1)
nsMat3 &lt;- naturalSpline(x, knots = knots, intercept = TRUE, derivs = 2)

op &lt;- par(mfrow = c(2, 2), mar = c(2.5, 2.5, 0.2, 0.1), mgp = c(1.5, 0.5, 0))
plot(nsMat0, ylab = "basis")
plot(nsMat1, ylab = "integral")
plot(nsMat2, ylab = "1st derivative")
plot(nsMat3, ylab = "2nd derivative")
par(op) # reset to previous plotting settings

## nsk()
nskMat &lt;- nsk(x, knots = knots, intercept = TRUE)
plot(nskMat, ylab = "nsk()", mark_knots = "all")
abline(h = 1, col = "red", lty = 3)

## use the deriv method
all.equal(nsMat0, deriv(nsMat1), check.attributes = FALSE)
all.equal(nsMat2, deriv(nsMat0))
all.equal(nsMat3, deriv(nsMat2))
all.equal(nsMat3, deriv(nsMat0, 2))

## a linear model example
fit1 &lt;- lm(weight ~ -1 + nsk(height, df = 4, intercept = TRUE), data = women)
fit2 &lt;- lm(weight ~ nsk(height, df = 3), data = women)

## the knots (same for both fits)
knots &lt;- unlist(attributes(fit1$model[[2]])[c('Boundary.knots', 'knots')])

## predictions at the knot points
predict(fit1, data.frame(height = sort(unname(knots))))
unname(coef(fit1)) # equal to the coefficient estimates

## different interpretation when "intercept = FALSE"
unname(coef(fit1)[-1] - coef(fit1)[1]) # differences: yhat[2:4] - yhat[1]
unname(coef(fit2))[-1]                 # ditto
</code></pre>

<hr>
<h2 id='plot.splines2'>Visualize Spline Basis Functions</h2><span id='topic+plot.splines2'></span>

<h3>Description</h3>

<p>Plot spline basis functions by lines in different colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'splines2'
plot(
  x,
  y,
  from = NULL,
  to = NULL,
  n = 101,
  mark_knots = c("none", "internal", "boundary", "all"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.splines2_+3A_x">x</code></td>
<td>
<p>A <code>splines2</code> object.</p>
</td></tr>
<tr><td><code id="plot.splines2_+3A_y">y</code></td>
<td>
<p>An argument that is not used.</p>
</td></tr>
<tr><td><code id="plot.splines2_+3A_from">from</code>, <code id="plot.splines2_+3A_to">to</code></td>
<td>
<p>Two numbers representing the start and end point for the
plot, respectively.</p>
</td></tr>
<tr><td><code id="plot.splines2_+3A_n">n</code></td>
<td>
<p>An integer, the number of x values at which to evaluate.</p>
</td></tr>
<tr><td><code id="plot.splines2_+3A_mark_knots">mark_knots</code></td>
<td>
<p>A character vector specifying if knot placement should be
indicated by vertical lines.</p>
</td></tr>
<tr><td><code id="plot.splines2_+3A_...">...</code></td>
<td>
<p>Additional arguments (other than <code>x</code> and <code>y</code>) that
would be passed to <code>matplot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to quickly visualize the spline basis functions.
</p>

<hr>
<h2 id='predict'>Compute Spline Function for Given Coefficients</h2><span id='topic+predict'></span><span id='topic+predict.BSpline'></span><span id='topic+predict.MSpline'></span><span id='topic+predict.ISpline'></span><span id='topic+predict.CSpline'></span><span id='topic+predict.BernsteinPoly'></span><span id='topic+predict.NaturalSpline'></span><span id='topic+predict.NaturalSplineK'></span>

<h3>Description</h3>

<p>Returns the spline function (with the specified coefficients) or evaluate
the basis functions at the specified <code>x</code> if the coefficients are not
specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BSpline'
predict(object, newx = NULL, coef = NULL, ...)

## S3 method for class 'MSpline'
predict(object, newx = NULL, coef = NULL, ...)

## S3 method for class 'ISpline'
predict(object, newx = NULL, coef = NULL, ...)

## S3 method for class 'CSpline'
predict(object, newx = NULL, coef = NULL, ...)

## S3 method for class 'BernsteinPoly'
predict(object, newx = NULL, coef = NULL, ...)

## S3 method for class 'NaturalSpline'
predict(object, newx = NULL, coef = NULL, ...)

## S3 method for class 'NaturalSplineK'
predict(object, newx = NULL, coef = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>Spline objects produced by the <code>splines2</code> package.</p>
</td></tr>
<tr><td><code id="predict_+3A_newx">newx</code></td>
<td>
<p>The <code>x</code> values at which evaluations are required.  If it is
<code>NULL</code> (by default), the original <code>x</code> used to create the
spline object will be used.</p>
</td></tr>
<tr><td><code id="predict_+3A_coef">coef</code></td>
<td>
<p>A numeric vector specifying the coefficients of the spline basis
functions.  If it is <code>NULL</code> (by default), the spline basis
functions will be returned.  Otherwise, the resulting spline function
will be returned.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Other options passed to the corresponding function that
constructs the input <code>object</code>.  For example, the additional options
will be passed to <code>bSpline()</code> for a <code>BSpline</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the spline basis functions with the new values
of <code>x</code> if <code>coef</code> is not specified.  Otherwise, the function
returns the resulting spline function (or its derivative if
<code>derivs</code> is specified as a positive integer through <code>...</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

x &lt;- seq.int(0, 1, 0.2)
knots &lt;- c(0.3, 0.5, 0.6)
newx &lt;- seq.int(0.1, 0.9, 0.2)

## Cubic B-spline basis functions
bs_mat &lt;- bSpline(x, knots = knots)

## compute the B-spline basis functions at new x
predict(bs_mat, newx)

## compute the B-spline function for the specified coefficients
beta &lt;- runif(ncol(bs_mat))
predict(bs_mat, coef = beta)

## compute the first derivative of the B-spline function
predict(bs_mat, coef = beta, derivs = 1)
## or equivalently
predict(deriv(bs_mat), coef = beta)

## compute the second derivative
predict(bs_mat, coef = beta, derivs = 2)
## or equivalently
predict(deriv(bs_mat, derivs = 2), coef = beta)

## compute the integral
predict(bs_mat, coef = beta, integral = TRUE)
## or equivalently
predict(update(bs_mat, integral = TRUE), coef = beta)
</code></pre>

<hr>
<h2 id='splines2'>splines2: Regression Spline Functions and Classes</h2><span id='topic+splines2'></span><span id='topic+splines2-package'></span>

<h3>Description</h3>

<p>This package provides functions to construct basis matrices of
</p>

<ul>
<li><p> B-splines
</p>
</li>
<li><p> M-splines
</p>
</li>
<li><p> I-splines
</p>
</li>
<li><p> convex splines (C-splines)
</p>
</li>
<li><p> periodic splines
</p>
</li>
<li><p> natural cubic splines
</p>
</li>
<li><p> generalized Bernstein polynomials
</p>
</li>
<li><p> along with their integrals (except C-splines) and derivatives
of given order by closed-form recursive formulas
</p>
</li></ul>



<h3>Details</h3>

<p>In addition to the R interface, it also provides a C++ header-only library
integrated with <span class="pkg">Rcpp</span>, which allows the construction of spline basis
functions directly in C++ with the help of <span class="pkg">Rcpp</span> and
<span class="pkg">RcppArmadillo</span>.  Thus, it can also be treated as one of the <span class="pkg">Rcpp*</span>
packages.  A toy example package that uses the C++ interface is available at
&lt;https://github.com/wenjie2wang/example-pkg-Rcpp-splines2&gt;.
</p>
<p>The package <span class="pkg">splines2</span> is intended to be a user-friendly supplement to
the base package <span class="pkg">splines</span>.  The trailing number two in the package name
means &quot;too&quot; (and by no means refers to the generation two).  See Wang and
Yan (2021) for details and illustrations of how the package can be applied
to shape-restricted regression.
</p>


<h3>References</h3>

<p>Wang, W., &amp; Yan, J. (2021). Shape-restricted regression splines with R
package <span class="pkg">splines2</span>. <em>Journal of Data Science</em>, 19(3), 498&ndash;517.
</p>

<hr>
<h2 id='update'>Update Spline Basis Functions</h2><span id='topic+update'></span><span id='topic+update.BSpline'></span><span id='topic+update.MSpline'></span><span id='topic+update.ISpline'></span><span id='topic+update.CSpline'></span><span id='topic+update.BernsteinPoly'></span><span id='topic+update.NaturalSpline'></span><span id='topic+update.NaturalSplineK'></span>

<h3>Description</h3>

<p>Update the knot placement, polynomial degree, and any other options
available when constructing the given spline object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BSpline'
update(object, ...)

## S3 method for class 'MSpline'
update(object, ...)

## S3 method for class 'ISpline'
update(object, ...)

## S3 method for class 'CSpline'
update(object, ...)

## S3 method for class 'BernsteinPoly'
update(object, ...)

## S3 method for class 'NaturalSpline'
update(object, ...)

## S3 method for class 'NaturalSplineK'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>Spline objects produced by the <code>splines2</code> package.</p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the corresponing constructor function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated object of the same class as the input object with the
specified updates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(splines2)

x &lt;- seq.int(0, 1, 0.01)
knots &lt;- c(0.3, 0.5, 0.6)

## quadratic B-splines
bsMat2 &lt;- bSpline(x, knots = knots, degree = 2, intercept = TRUE)

## cubic B-splines
bsMat3 &lt;- update(bsMat2, degree = 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
