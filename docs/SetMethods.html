<!DOCTYPE html><html><head><title>Help for package SetMethods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SetMethods}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ambig.cases'>
<p>Function for identifying cases with 0.5 fuzzy-set values.</p></a></li>
<li><a href='#BCMV'><p>Berg-Schlosser and Cronqvist (2005)</p></a></li>
<li><a href='#cluster'>
<p>Diagnostic tool for clustered data.</p></a></li>
<li><a href='#cluster.plot'>
<p>Function for plotting pooled, between, and within consistencies for a cluster diagnostics.</p></a></li>
<li><a href='#EMMF'><p>EMMFnegger (2011)</p></a></li>
<li><a href='#esa'>
<p>Function that performs the Enhanced Standard Analysis.</p></a></li>
<li><a href='#FakeCS'><p>Fake crisp-set data</p></a></li>
<li><a href='#FakeMV'><p>Fake data for mvQCA</p></a></li>
<li><a href='#FSR'><p>Freitag and Schlicht (2009)</p></a></li>
<li><a href='#indirectCalibration'><p>Function performing the indirect calibration</p></a></li>
<li><a href='#intersectExp'>
<p>Intersects two boolean expressions.</p></a></li>
<li><a href='#JOBF'><p>Fake fuzzy-set job motivation data.</p></a></li>
<li><a href='#KAF'><p>Koenig-Archibugi (2004)</p></a></li>
<li><a href='#LIPC'><p>Lipset (1959), crisp-set</p></a></li>
<li><a href='#LIPF'><p>Lipset (1959), fuzzy-set</p></a></li>
<li><a href='#LIPR'><p>Lipset (1959), raw data</p></a></li>
<li><a href='#LR.intersect'>
<p>Function for identifying contradictory simplifying assumptions or easy counterfactuals.</p></a></li>
<li><a href='#negateExp'>
<p>Negates a boolean expression.</p></a></li>
<li><a href='#PAYF'><p>Paykani et al. (2018)</p></a></li>
<li><a href='#PAYR'><p>Paykani et al. (2018)</p></a></li>
<li><a href='#PENF'><p>Pennings (2003)</p></a></li>
<li><a href='#pimdata'>
<p>Function to extract prime implicants table from object of class &quot;qca&quot;</p></a></li>
<li><a href='#pimplot'>
<p>Prime implicants, truth table rows, and necessity plots.</p></a></li>
<li><a href='#property.cube'><p>Function producing a 3D scatter plot.</p></a></li>
<li><a href='#QCAfit'><p>Function calculating the parameters of fit</p></a></li>
<li><a href='#QCAradar'>
<p>Function for displaying a radar chart.</p></a></li>
<li><a href='#rob.calibrange'>
<p>Function for identifying the calibration threshold ranges for a condition within which the Boolean formula for the solution does not change.</p></a></li>
<li><a href='#rob.cases'>
<p>Function for identifying cases in the intersections between an inital solution and test solutions.</p></a></li>
<li><a href='#rob.corefit'>
<p>Function returning parameters of fit for the robust core of different alternative sufficient solutions.</p></a></li>
<li><a href='#rob.fit'>
<p>Function returning robustness parameters of fit.</p></a></li>
<li><a href='#rob.inclrange'>
<p>Function for identifying the raw consistency threshold range within which the Boolean formula for the solution does not change.</p></a></li>
<li><a href='#rob.ncutrange'>
<p>Function for identifying the frequency threshold range within which the Boolean formula for the solution does not change.</p></a></li>
<li><a href='#rob.singletest'>
<p>Function returning robustness parameters for each single test solution in TS.</p></a></li>
<li><a href='#rob.xyplot'>
<p>Function  for plotting an initial solution against the test set.</p></a></li>
<li><a href='#SAMF'><p>Samford (2010)</p></a></li>
<li><a href='#SC'><p>Selbst, practicing the truth table algorithm data</p></a></li>
<li><a href='#SCHF'><p>Schneider et. al. (2010)</p></a></li>
<li><a href='#SCHLF'><p>Schneider et. al. (2010)</p></a></li>
<li><a href='#SDC'><p>Selbst, disappearing necessary condition data</p></a></li>
<li><a href='#SetMethods-package'><p>Functions for Set-Theoretic Multi-Method Research and Advanced QCA</p></a></li>
<li><a href='#skew.check'>
<p>Function for checking how skewed sets are.</p></a></li>
<li><a href='#smmr'>
<p>Function for performing set-theoretic multi-method research.</p></a></li>
<li><a href='#stargazerSol'>
<p>Function for exporting a sufficienct solution from minimize in latex, html, or text format.</p></a></li>
<li><a href='#stargazerTT'>
<p>Function for exporting a sufficienct solution from minimize in latex, html, or text format.</p></a></li>
<li><a href='#STUF'><p>Fake fuzzy-set student data.</p></a></li>
<li><a href='#STUR'><p>Fake raw, student data.</p></a></li>
<li><a href='#theory.evaluation'>
<p>Performs theory evaluation.</p></a></li>
<li><a href='#THOF'><p>Thomann (2015)</p></a></li>
<li><a href='#VISC'><p>Vis (2009), crisp set data</p></a></li>
<li><a href='#VISF'><p>Vis (2009), fuzzy set data</p></a></li>
<li><a href='#xy.plot'><p>Function producing enhanced XY plots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Set-Theoretic Multi-Method Research and Advanced
QCA</td>
</tr>
<tr>
<td>Version:</td>
<td>4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Ioana-Elena Oana [aut, cre],
	Juraj Medzihorsky [aut],  
	Mario Quaranta [aut],
	Carsten Q. Schneider [aut] 		</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ioana-Elena Oana &lt;ioana.oana@eui.eu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for performing set-theoretic multi-method research, QCA for clustered data, theory evaluation, Enhanced Standard Analysis, indirect calibration, radar visualisations. Additionally it includes data to replicate the 	examples in the books by Oana, I.E, C. Q. Schneider, and E. Thomann. Qualitative Comparative Analysis (QCA) using R: A Beginner's Guide. Cambridge University Press and C. Q. Schneider and C. Wagemann "Set Theoretic Methods for the Social Sciences", Cambridge University Press.</td>
</tr>
<tr>
<td>Depends:</td>
<td>QCA, admisc, methods, ggplot2, ggrepel, stargazer, R (&ge;
3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>scatterplot3d, fmsb, betareg</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-31 09:01:58 UTC; ioana</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-31 09:20:07 UTC</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
</table>
<hr>
<h2 id='ambig.cases'>
Function for identifying cases with 0.5 fuzzy-set values.
</h2><span id='topic+ambig.cases'></span>

<h3>Description</h3>

<p>A function that identifies cases with 0.5 fuzzy-set values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ambig.cases(data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ambig.cases_+3A_data">data</code></td>
<td>

<p>A datafarme, a subset of a dataframe, or a vector (i.e. single column in a dataframe). If the function is       provided with the dataframe it will return the name of the cases with 0.5 values together with their            location in the dataframe. If the function is provided with a vector (i.e. a single column), it will return     the position of the case having a 0.5 in that vector. The function should be used for calibrated data and       will give an error if the data contains uncalibrated scores. However, if you have both calibrated and           uncalibrated data in the same dataframe, it is possible to use the function only for the calibrated subset      of that data. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import your data. For example:

data(SCHF)

# Get cases with 0.5 in the entire dataframe:

ambig.cases(SCHF)

# Get cases with 0.5 in the column "EMP" in the dataframe:

ambig.cases(SCHF$EMP)

# Get cases with 0.5 in the 7th column of the dataframe:

ambig.cases(SCHF[,7])

</code></pre>

<hr>
<h2 id='BCMV'>Berg-Schlosser and Cronqvist (2005)</h2><span id='topic+BCMV'></span>

<h3>Description</h3>

<p>The <code>BCMV</code> data frame has 18 rows and 5 variables</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BCMV)</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 5 variables.
</p>

<dl>
<dt><code>GNP</code></dt><dd><p>a numeric vector. Condition, Gross National Product/Capita (ca. 1930). 0 if below 500$, 1 if between 550 and 850$, 2 above 850$.</p>
</dd>
<dt><code>URB</code></dt><dd><p>a numeric vector. Condition, urbanization (population in towns with 20000 and more inhabitants); 0 if below 50 per cent; 1 if above. </p>
</dd>
<dt><code>LIT</code></dt><dd><p>a numeric vector. Condition, literacy: 0 if below 75 per cent; 1 if above.</p>
</dd>
<dt><code>INDUS</code></dt><dd><p>a numeric vector. Condition, Industrial Labour Force (incl. mining); 0 if below 30 per cent of active population; 1 if above.</p>
</dd>
<dt><code>DEMOC</code></dt><dd><p>a numeric vector. Condition, stability of a democracy: 0 if not stable; 1 if stable.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data are used by Berg-Schlosser and Cronqvist (2005) to demostrate mvQCA. The original data are from Lipset (1963). Data are multi-value.</p>


<h3>References</h3>

<p>Berg-Schlosser, D. and Cronqvist, L. (2005)	&quot;Macro-Quantitative vs. Macro-Qualitative Methods in the Social Sciences - An Example from Empirical Democratic Theory&quot;, Historical Social Research 30, pp. 154-175.
</p>
<p>Lipset, Seymour M. (1963) Political Man. The Social Bases of Politics. Doubleday: New York.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>
<p>Schneider, C. Q., Wagemann, C., Quaranta, M. (2012) How To... Use Software for Set-Theoretic Analysis. Online Appendix to &quot;Set-Theoretic Methods for the Social Sciences&quot;. Available at www.cambridge.org/schneider-wagemann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BCMV)</code></pre>

<hr>
<h2 id='cluster'>
Diagnostic tool for clustered data.
</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>Function returns pooled, within, and between consistencies for the relationship between two sets, for an       object of class &quot;qca&quot;, and for a Boolean expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(data=NULL, results, outcome, 
      unit_id, cluster_id, sol = 1, 
      necessity = FALSE, wicons = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_data">data</code></td>
<td>

<p>A data frame in the long format containing both a colum with the unit names and a column with 
the cluster names. Column names should be in capital letters.
</p>
</td></tr>
<tr><td><code id="cluster_+3A_results">results</code></td>
<td>

<p>An object of class &quot;qca&quot;. For performing cluster diagnostics of the sufficient solution for the negated        outcome one must only use the <code>minimize()</code> result from the sufficiency analysis of the negated outcome.
The argument results can also be a vector, a character string, or a boolean expression of the form 
e.g. &quot;A*~B + ~B*C&quot;.
</p>
</td></tr>
<tr><td><code id="cluster_+3A_outcome">outcome</code></td>
<td>

<p>A character string with the name of the outcome in capital letters. When performing cluster 
diagnostics of the sufficient solution for the negated outcome one must only use the <code>minimize()</code>            result from the sufficiency analysis of the negated outcome in the argument <code>results</code>. 
When performing cluster diagnostics for boolean expressions or vectors the negated outcome can be used by      inserting a tilde in the outcome name in the argument <code>outcome</code>.
The outcome can also be a vector. 
</p>
</td></tr>
<tr><td><code id="cluster_+3A_unit_id">unit_id</code></td>
<td>

<p>A character string with the name of the vector containing the units (e.g. countries).
</p>
</td></tr>
<tr><td><code id="cluster_+3A_cluster_id">cluster_id</code></td>
<td>

<p>A character string with the name of the vector containing the clustering units (e.g. years).
</p>
</td></tr>
<tr><td><code id="cluster_+3A_sol">sol</code></td>
<td>

<p>A vector where the first number indicates the number of the conservative or parsimonious solution 
according to the order in the &quot;qca&quot; object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution
and i = intermediate solution.
</p>
</td></tr>
<tr><td><code id="cluster_+3A_necessity">necessity</code></td>
<td>

<p>Logical. Perform the diagnostic for the relationship of necessity?
</p>
</td></tr>
<tr><td><code id="cluster_+3A_wicons">wicons</code></td>
<td>

<p>Logical. Should within consistencies and coverages be printed?
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Garcia-Castro, Roberto, and Miguel A. Arino. 2016. &quot;A General Approach to Panel Data Set-Theoretic Research.&quot;&quot; Journal of Advances in Management Sciences &amp; Information Systems 2: 6376.
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Import your clustered data in the long format. 
# For example:

data(SCHLF)

# Get the intermediate solution:

sol_yi &lt;- minimize(SCHLF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE, dir.exp = c(0,0,0,0,0,0))

# Get pooled, within, and between consistencies for the intermediate solution:

cluster(SCHLF, sol_yi, "EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR", sol = 1)
              
# or:

cluster(SCHLF, sol_yi, "EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR", sol = "c1p1i1")

# Get pooled, within, and between consistencies for EMP as necessary for EXPORT:

cluster(SCHLF, results="EMP", outcome="EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR", necessity=TRUE)
# or:

cluster(results=SCHLF$EMP, outcome=SCHLF$EXPORT, unit_id = SCHLF$COUNTRY, 
              cluster_id = SCHLF$YEAR, necessity=TRUE)
              
# Get pooled, within, and between consistencies for ~EMP as necessary for EXPORT:

cluster(SCHLF, results="~EMP", outcome="EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR", necessity=TRUE)
# or:

cluster(results=1-SCHLF$EMP, outcome=SCHLF$EXPORT, unit_id = SCHLF$COUNTRY, 
              cluster_id = SCHLF$YEAR, necessity=TRUE)                  
              
# Get pooled, within, and between consistencies for EMP*~MA*STOCK as sufficient for EXPORT:

cluster(SCHLF, "EMP*~MA*STOCK", "EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR") 
              
# Get pooled, within, and between consistencies for EMP*MA + ~STOCK as sufficient for ~EXPORT:

cluster(SCHLF, "EMP*MA + ~STOCK", "~EXPORT", unit_id = "COUNTRY", 
              cluster_id = "YEAR")              
</code></pre>

<hr>
<h2 id='cluster.plot'>
Function for plotting pooled, between, and within consistencies for a cluster diagnostics.
</h2><span id='topic+cluster.plot'></span>

<h3>Description</h3>

<p>Function for plotting pooled, between, and within consistencies for a cluster diagnostics. For a sufficient solution, the function returns plots for the entire solution and each sufficient term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.plot(cluster.res,
           labs = TRUE,
           size = 5,
           angle = 0,
           wicons = FALSE,
           wiconslabs = FALSE,
           wiconssize = 5,
           wiconsangle = 90)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster.plot_+3A_cluster.res">cluster.res</code></td>
<td>
<p>An object of class &quot;cluster.res&quot;. This is the result of a cluster diagnostics obtained with the cluster() function.
</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_labs">labs</code></td>
<td>

<p>Logical. Should labels for the clusters be printed?  
</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_size">size</code></td>
<td>

<p>Label font size for the clusters.
</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_angle">angle</code></td>
<td>

<p>Label rotation for the clusters.
</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_wicons">wicons</code></td>
<td>

<p>Logical. Should within consistency plots be returned?
</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_wiconslabs">wiconslabs</code></td>
<td>

<p>Logical. Should labels for the units be printed?  
</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_wiconssize">wiconssize</code></td>
<td>

<p>Label font size for the units.
</p>
</td></tr>
<tr><td><code id="cluster.plot_+3A_wiconsangle">wiconsangle</code></td>
<td>

<p>Label rotation for the units.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana</p>


<h3>References</h3>

<p>Garcia-Castro, Roberto, and Miguel A. Arino. 2016. &quot;A General Approach to Panel Data Set-Theoretic Research.&quot;&quot; Journal of Advances in Management Sciences &amp; Information Systems 2: 6376.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data:
data(PAYF)

# Create a sufficient solution using minimize:
PS &lt;- minimize(data = PAYF,
                        outcome  = "HL",
                        conditions = c("HE","GG","AH","HI","HW"),
                        incl.cut = 0.9,
                        n.cut = 2,
                        include = "?",
                        details = TRUE, 
                        show.cases = TRUE)
PS

# Perform cluster diagnostics:

CB &lt;- cluster(data = PAYF,
           results = PS,
           outcome = "HL",
           unit_id = "COUNTRY",
           cluster_id = "REGION",
           necessity=FALSE,
           wicons = FALSE)
CB

# Plot pooled, between, and within consistencies:

cluster.plot(cluster.res = CB,
             labs = TRUE,
             size = 8,
             angle = 6,
             wicons = TRUE)

</code></pre>

<hr>
<h2 id='EMMF'>EMMFnegger (2011)</h2><span id='topic+EMMF'></span>

<h3>Description</h3>

<p>The <code>EMMF</code> data frame has 19 rows and 8 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EMMF)</code></pre>


<h3>Format</h3>

<p>A data frame with 19 observations on the following 8 sets.
</p>

<dl>
<dt><code>country</code></dt><dd><p>a factor with levels <code>Australia</code> <code>Austria</code> <code>Belgium</code> <code>Canada</code> <code>Denmark</code> <code>Finland</code> <code>France</code> <code>Germany</code> <code>Ireland</code> <code>Italy</code> <code>Netherlands</code> <code>NewZealand</code> <code>Norway</code> <code>Portugal</code> <code>Spain</code> <code>Sweden</code> <code>Switzerland</code> <code>UK</code> <code>USA</code></p>
</dd>
<dt><code>s</code></dt><dd><p>a numeric vector. Condition, state-society relationships.</p>
</dd>
<dt><code>c</code></dt><dd><p>a numeric vector. Condition, non-market coordination.</p>
</dd>
<dt><code>l</code></dt><dd><p>a numeric vector. Condition, strength of the labour movement.</p>
</dd>
<dt><code>r</code></dt><dd><p>a numeric vector. Condition, religious denomination.</p>
</dd>
<dt><code>p</code></dt><dd><p>a numeric vector. Condition, strenght of religious parties.</p>
</dd>
<dt><code>v</code></dt><dd><p>a numeric vector. Condition, institutional veto points.</p>
</dd>
<dt><code>jsr</code></dt><dd><p>a numeric vector. Outcome, job-secturity regulations.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are used by Emmenegger (2011) to analyze job-security regulations in Western democracies. The data are fuzzy-sets.</p>


<h3>References</h3>

<p>Emmenegger, P. (2011) &quot;Job-security regulations in Western democracies&quot;, European Journal of Political Research 50, pp. 336-364.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EMMF)</code></pre>

<hr>
<h2 id='esa'>
Function that performs the Enhanced Standard Analysis.
</h2><span id='topic+esa'></span>

<h3>Description</h3>

<p>Function that performs the Enhanced Standard Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esa(oldtt, nec_cond, untenable_LR, contrad_rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="esa_+3A_oldtt">oldtt</code></td>
<td>

<p>A truthTable object.
</p>
</td></tr>
<tr><td><code id="esa_+3A_nec_cond">nec_cond</code></td>
<td>

<p>A vector of character strings containing the necessary conditions. 
Conditions should be capitalized and negated conditions should be inserted with a &quot;~&quot;.
Unions of conditions are performed with a &quot;+&quot;. Using this argument, logical remainder 
rows that contradict the statement of necessity will not be used in the analysis 
(i.e. OUT will be set to 0 in the truth table).
</p>
</td></tr>
<tr><td><code id="esa_+3A_untenable_lr">untenable_LR</code></td>
<td>

<p>A Boolean expression containing the untenable logical remainders. 
Conditions should be capitalized and negated conditions should be inserted with a &quot;~&quot;.
Intersections of conditions are performed with a &quot;*&quot;. Using this argument, logical remainder
rows containing the particular intersection specified will not be used in the analysis 
(i.e. OUT will be set to 0 in the truth table).
</p>
</td></tr>
<tr><td><code id="esa_+3A_contrad_rows">contrad_rows</code></td>
<td>

<p>A vector containing the names of the rows that are contradictory. Using this argument,
all rows with the names specified (both logical remainders and rows containing empirical information) will not be      used in the analysis (i.e. OUT will be set to 0 in the truth table).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> It returns a new truth table in which all truth table rows are set to outcome value 0 that would otherwise present untenable assumptions.
</p>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Schneider, C. Q., Wagemann, C. 2012. Set-Theoretic Methods for the Social Sciences: A Guide to Qualitative Comparative Analysis. Cambridge: Cambridge University Press, chapter 8.
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import your data. For example:

data(SCHF)

# Get the truth table for the presence of the outcome:

TT_y &lt;- truthTable(SCHF, outcome = "EXPORT",
                   conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                   incl.cut = .9,
                   complete = TRUE,
                   PRI = TRUE,
                   sort.by = c("out", "incl", "n"))

# Exclude condition STOCK + MA and condition EMP as necessary for EXPORT
# Exclude all remainder rows containing the combination BARGAIN*~OCCUP
# Exclude the rows "19", "14", "46", "51" as contradictory:

newtt &lt;- esa(oldtt = TT_y, nec_cond = c("STOCK+MA", "EMP"), 
          untenable_LR = "BARGAIN*~OCCUP", contrad_rows = c("19", "14", "46", "51"))

# The truth table newly created can afterwards be used in further analyses

</code></pre>

<hr>
<h2 id='FakeCS'>Fake crisp-set data</h2><span id='topic+FakeCS'></span>

<h3>Description</h3>

<p>The <code>FakeCS</code> data frame has 30 rows and 5 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FakeCS)</code></pre>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 5 sets.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector. Outcome with 2 categories (crisp-set).</p>
</dd>
<dt><code>j</code></dt><dd><p>a numeric vector. Condition with 2 categories (crisp-set).</p>
</dd>
<dt><code>z</code></dt><dd><p>a numeric vector. Condition with 2 categories (crisp-set).</p>
</dd>
<dt><code>w</code></dt><dd><p>a numeric vector. Condition with 2 categories (crisp-set).</p>
</dd>
<dt><code>k</code></dt><dd><p>a numeric vector. Condition with 2 categories (crisp-set).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data frame has only exercise purpuses to let the user learn how to perform crisp-set QCA in R.</p>


<h3>References</h3>

<p>Schneider, C. Q., Wagemann, C., Quaranta, M. (2012) How To... Use Software for Set-Theoretic Analysis. Online Appendix to &quot;Set-Theoretic Methods for the Social Sciences&quot;. Available at www.cambridge.org/schneider-wagemann.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FakeCS)</code></pre>

<hr>
<h2 id='FakeMV'>Fake data for mvQCA</h2><span id='topic+FakeMV'></span>

<h3>Description</h3>

<p><code>mvQCA</code> data frame has 25 rows and 4 sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FakeMV)</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 4 sets.
</p>

<dl>
<dt><code>Y</code></dt><dd><p>a numeric vector. Outcome with 2 categories (crisp).</p>
</dd>
<dt><code>A</code></dt><dd><p>a numeric vector. Condition with 2 categories (crisp).</p>
</dd>
<dt><code>B</code></dt><dd><p>a numeric vector. Condition with 3 categories (multi-value).</p>
</dd>
<dt><code>C</code></dt><dd><p>a numeric vector. Condition with 3 categories (multi-value).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data frame has only exercise purpuses to let the user learn how to perform mvQCA in R.</p>


<h3>References</h3>

<p>Schneider, C. Q., Wagemann, C., Quaranta, M. (2012) How To... Use Software for Set-Theoretic Analysis. Online Appendix to &quot;Set-Theoretic Methods for the Social Sciences&quot;. Available at www.cambridge.org/schneider-wagemann.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FakeMV)</code></pre>

<hr>
<h2 id='FSR'>Freitag and Schlicht (2009)</h2><span id='topic+FSR'></span>

<h3>Description</h3>

<p>The <code>FSR</code> data frame has 16 rows and 8 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FSR)</code></pre>


<h3>Format</h3>

<p>A data frame with 16 observations on the following 8 sets.
</p>

<dl>
<dt><code>integrated_comp_schools</code></dt><dd><p>a numeric vector. Condition, percentage  of Pupils Enrolled in Integrated Comprehensive Schools,</p>
</dd>
<dt><code>coop_comp_schools</code></dt><dd><p>a numeric vector. Condition, percentage  of Pupils Enrolled in Cooperative Comprehensive Schools.</p>
</dd>
<dt><code>full_day_schools</code></dt><dd><p>a numeric vector. Condition, percentage of Pupils Enrolled in All-Day Schools</p>
</dd>
<dt><code>child_care</code></dt><dd><p>a numeric vector. Condition, ratio of Number of Child Care Facilities to Total Population between 0 and 6 Years (percent).</p>
</dd>
<dt><code>pre_schools</code></dt><dd><p>a numeric vector. Condition, ratio of pupils Enrolled in Pre-School to Total 6-Year-Old Population (per cent)</p>
</dd>
<dt><code>early_tracking</code></dt><dd><p>a numeric vector. Condition, onset of Tracking, Legal Regulation.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>a numeric vector. Outcome, high Degree of Social Inequality
Cases in Education. </p>
</dd>
<dt><code>indep_hauptschule</code></dt><dd><p>a numeric vector. Condition, autonomy of the Hauptschule.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are used by Freitag and Schlicht (2009) to analyze social inequality in education. The data are raw scores.</p>


<h3>References</h3>

<p>Freitag, M, and Schlicht, R. (2009) &quot;Educational Federalism in Germany: Foundations of Social Inequalities in Education&quot;, Governance 22(1), pp. 47-72.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FSR)</code></pre>

<hr>
<h2 id='indirectCalibration'>Function performing the indirect calibration</h2><span id='topic+indirectCalibration'></span>

<h3>Description</h3>

<p>indirectCalibration is a function for the indirect calibration procedure as described by Ragin (2008). It uses a binomial or a beta regression for tranforming raw scores into calibrated scores. In our opinion, using a fractional polynomial may not be appropriate to this case. In fact, we do not deal with proportions. This function requires the package <code>betareg</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>indirectCalibration(x, x_cal, binom = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indirectCalibration_+3A_x">x</code></td>
<td>
<p>vector of raw scores.</p>
</td></tr>
<tr><td><code id="indirectCalibration_+3A_x_cal">x_cal</code></td>
<td>
<p>vector of theoretically calibrated scores.</p>
</td></tr>
<tr><td><code id="indirectCalibration_+3A_binom">binom</code></td>
<td>
<p>logical. If indirect calibration has to be performed using binomial regression or beta regression.  The default is <code>TRUE</code>, which means that binomial regression is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a vector of indirectly calibrated values.</p>


<h3>Author(s)</h3>

<p>Mario Quaranta</p>


<h3>References</h3>

<p>Ragin, C. C. (2008) Redesigning Social Inquiry: Fuzzy Sets and Beyond, The Chicago University Press: Chicago and London.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate fake data
set.seed(4)
x &lt;- runif(20, 0, 1)

# Find quantiles
quant &lt;- quantile(x, c(.2, .4, .5, .6, .8))

# Theoretical calibration
x_cal &lt;- NA  
x_cal[x &lt;= quant[1]] &lt;- 0
x_cal[x &gt; quant[1] &amp; x &lt;= quant[2]] &lt;- .2
x_cal[x &gt; quant[2] &amp; x &lt;= quant[3]] &lt;- .4
x_cal[x &gt; quant[3] &amp; x &lt;= quant[4]] &lt;- .6
x_cal[x &gt; quant[4] &amp; x &lt;= quant[5]] &lt;- .8
x_cal[x &gt; quant[5]] &lt;- 1
x_cal

# Indirect calibration (binomial)
a &lt;- indirectCalibration(x, x_cal, binom = TRUE)

# Indirect calibration (beta regression)
b &lt;- indirectCalibration(x, x_cal, binom = FALSE)

# Correlation
cor(a, b)

# Plot
plot(x, a); points(x, b, col = "red")
</code></pre>

<hr>
<h2 id='intersectExp'>
Intersects two boolean expressions.
</h2><span id='topic+intersectExp'></span>

<h3>Description</h3>

<p>Function that intersects two boolean expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectExp(expression1, expression2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersectExp_+3A_expression1">expression1</code></td>
<td>

<p>A boolean expression.
Conditions should be capitalized and negated conditions should be inserted with a &quot;~&quot;.
Unions of conditions are performed with a &quot;+&quot;, while intersections are performed with a &quot;*&quot;.
</p>
</td></tr>
<tr><td><code id="intersectExp_+3A_expression2">expression2</code></td>
<td>

<p>A boolean expression.
Conditions should be capitalized and negated conditions should be inserted with a &quot;~&quot;.
Unions of conditions are performed with a &quot;+&quot;, while intersections are performed with a &quot;*&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> It returns the boolean expression representing the intersection of the two inputed expressions.
</p>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>Examples</h3>

<pre><code class='language-R'>intersectExp("~EMP*MA", "MA+~STOCK*OCCUP")
intersectExp("~A*B + C*~D","A*B+~D")
</code></pre>

<hr>
<h2 id='JOBF'>Fake fuzzy-set job motivation data.</h2><span id='topic+JOBF'></span>

<h3>Description</h3>

<p>Fake fuzzy-set job motivation data used for Chapter 3 of the Oana et al. (forthcoming) book.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(JOBF)</code></pre>


<h3>Format</h3>

<p>A data frame with 17 observations on the following 3 variables.
</p>

<dl>
<dt><code>HS</code></dt><dd><p>Condition: High salary</p>
</dd>
<dt><code>FS</code></dt><dd><p>Condition: Flexible schedule</p>
</dd>
<dt><code>LS</code></dt><dd><p>Condition: Lenient supervisor</p>
</dd>
<dt><code>LJS</code></dt><dd><p>Condition: Low job security</p>
</dd>
<dt><code>PP</code></dt><dd><p>Condition: High promotion potential</p>
</dd>
<dt><code>HM</code></dt><dd><p>Outcome: High motivation</p>
</dd>
<dt><code>FSorLS</code></dt><dd><p>Condition:</p>
</dd>
</dl>



<h3>References</h3>

<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(JOBF)</code></pre>

<hr>
<h2 id='KAF'>Koenig-Archibugi (2004)</h2><span id='topic+KAF'></span>

<h3>Description</h3>

<p>The <code>KAF</code> data frame has 13 rows and 5 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(KAF)</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations on the following 5 sets.
</p>

<dl>
<dt><code>supranat</code></dt><dd><p>a numeric vector. Government support for supranational CFSP.</p>
</dd>
<dt><code>identmass</code></dt><dd><p>a numeric vector. European identity of the general public.</p>
</dd>
<dt><code>conform</code></dt><dd><p>a numeric vector. Policy conformity.</p>
</dd>
<dt><code>region</code></dt><dd><p>a numeric vector. Regional governance.</p>
</dd>
<dt><code>capab</code></dt><dd><p>a numeric vector. Material capabilities.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are used by Koenig-Archibugi (2004) to analyze government preferences for istitutional change in EU foreign and security policy. Data are fuzzy-sets.</p>


<h3>References</h3>

<p>Koenig-Archibugi, M. (2004) &quot;Explaining Government Preferences for Istitutional Change in EU Foreign and Security Policy&quot;, International Organization 58, pp.137-174.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(KAF)</code></pre>

<hr>
<h2 id='LIPC'>Lipset (1959), crisp-set</h2><span id='topic+LIPC'></span>

<h3>Description</h3>

<p>The <code>LIPC</code> data frame has 18 rows and 6 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LIPC)</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 6 sets.
</p>

<dl>
<dt><code>DEVELOPED</code></dt><dd><p>a numeric vector. Condition, economically developed country.</p>
</dd>
<dt><code>URBAN</code></dt><dd><p>a numeric vector. Condition, urbanized countries.</p>
</dd>
<dt><code>LITERATE</code></dt><dd><p>a numeric vector. Condition, countries with high literacy rate.</p>
</dd>
<dt><code>INDUSTRIAL</code></dt><dd><p>a numeric vector. Condition, Industrialized countries.</p>
</dd>
<dt><code>GOVSTAB</code></dt><dd><p>a numeric vector. Condition, politically stable countries.</p>
</dd>
<dt><code>SURVIVED</code></dt><dd><p>a numeric vector. Outcome, survival of democracy during the inter-war period.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data used by Ragin (2009) to illustrates the variants of QCA. Originally by Lipset (1959). Data are crisp-sets.</p>


<h3>References</h3>

<p>Lipset, S. M. (1959) &quot;Some Social Requisites of Democracy: Economic Development and Political Legitimacy&quot;, American Political Science Review 53, pp. 69-105.
</p>
<p>Ragin, C. C. (2009) &quot;Qualitative Comparative Analysis. Using Fuzzy Sets (fsQCA).&quot; In Rihoux, B., and Ragin, C. C. (eds.) Configurational Comparative Methods. Qualitative Comparative Analysis (QCA) and Related Techniques. Thousand Oaks, CA and London: Sage, pp. 87-121.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LIPC)</code></pre>

<hr>
<h2 id='LIPF'>Lipset (1959), fuzzy-set</h2><span id='topic+LIPF'></span>

<h3>Description</h3>

<p>The <code>LIPF</code> data frame has 18 rows and 6 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LIPF)</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 6 sets.
</p>

<dl>
<dt><code>SURVIVED</code></dt><dd><p>a numeric vector. Outcome, survival of democracy during the inter-war period.</p>
</dd>
<dt><code>DEVELOPED</code></dt><dd><p>a numeric vector. Condition, economically developed countries.</p>
</dd>
<dt><code>URBAN</code></dt><dd><p>a numeric vector. Condition, urbanized countries.</p>
</dd>
<dt><code>LITERATE</code></dt><dd><p>a numeric vector. Condition, countries with high literacy rate.</p>
</dd>
<dt><code>INDUSTRIAL</code></dt><dd><p>a numeric vector. Condition, industrialized countries.</p>
</dd>
<dt><code>STABLE</code></dt><dd><p>a numeric vector. Condition, politically stable countries.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data used by Ragin (2009) to illustrates the variants of QCA. Originally by Lipset (1959). Data are fuzzy-sets.</p>


<h3>References</h3>

<p>Lipset, S. M. (1959) &quot;Some Social Requisites of Democracy: Economic Development and Political Legitimacy&quot;, American Political Science Review 53, pp. 69-105.
</p>
<p>Ragin, C. C. (2009) &quot;Qualitative Comparative Analysis. Using Fuzzy Sets (fsQCA).&quot; In Rihoux, B., and Ragin, C. C. (eds.) Configurational Comparative Methods. Qualitative Comparative Analysis (QCA) and Related Techniques. Thousand Oaks, CA and London: Sage, pp. 87-121.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LIPF)</code></pre>

<hr>
<h2 id='LIPR'>Lipset (1959), raw data</h2><span id='topic+LIPR'></span>

<h3>Description</h3>

<p>The <code>LIPR</code> data frame has 18 rows and 6 variables</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LIPR)</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 6 variables.
</p>

<dl>
<dt><code>SURVIVED</code></dt><dd><p>a numeric vector. Outcome, survival of democracy during the inter-war period.</p>
</dd>
<dt><code>DEVELOPED</code></dt><dd><p>a numeric vector. Condition, level of economic development.</p>
</dd>
<dt><code>URBAN</code></dt><dd><p>a numeric vector. Condition, level of urbanization.</p>
</dd>
<dt><code>LITERATE</code></dt><dd><p>a numeric vector. Condition, level of literacy.</p>
</dd>
<dt><code>INDUSTRIAL</code></dt><dd><p>a numeric vector. Condition, level of industrialization.</p>
</dd>
<dt><code>UNSTABLE</code></dt><dd><p>a numeric vector. Condition, politically stable countries.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data used by Ragin (2009) to illustrates the variants of QCA. Originally by Lipset (1959). Data are raw-scores.</p>


<h3>References</h3>

<p>Lipset, S. M. (1959) &quot;Some Social Requisites of Democracy: Economic Development and Political Legitimacy&quot;, American Political Science Review 53, pp. 69-105.
</p>
<p>Ragin, C. C. (2009) &quot;Qualitative Comparative Analysis. Using Fuzzy Sets (fsQCA).&quot; In Rihoux, B., and Ragin, C. C. (eds.) Configurational Comparative Methods. Qualitative Comparative Analysis (QCA) and Related Techniques. Thousand Oaks, CA and London: Sage, pp. 87-121.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LIPR)</code></pre>

<hr>
<h2 id='LR.intersect'>
Function for identifying contradictory simplifying assumptions or easy counterfactuals.	
</h2><span id='topic+LR.intersect'></span>

<h3>Description</h3>

<p>A function for identifying contradictory simplifying assumptions or easy counterfactuals by intersecting the    SAs or ECs of two solutions.	
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR.intersect(results1, results2, sol1 = 1, sol2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LR.intersect_+3A_results1">results1</code></td>
<td>

<p>An object of class &quot;qca&quot;. It can be a parsimonious or an intermediate solution for an outcome or its            negation obtained via <code>minimize()</code>.
</p>
</td></tr>
<tr><td><code id="LR.intersect_+3A_results2">results2</code></td>
<td>

<p>An object of class &quot;qca&quot;. It can be a parsimonious or an intermediate solution for an outcome or its            negation obtained via <code>minimize()</code>.
</p>
</td></tr>
<tr><td><code id="LR.intersect_+3A_sol1">sol1</code></td>
<td>

<p>A vector where the first number indicates the number of the
conservative or parsimonious solution according to the order in the &quot;qca&quot; object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution
and i = intermediate solution.
</p>
</td></tr>
<tr><td><code id="LR.intersect_+3A_sol2">sol2</code></td>
<td>

<p>A vector where the first number indicates the number of the
conservative or parsimonious solution according to the order in the &quot;qca&quot; object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution
and i = intermediate solution.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import your data. For example:

data(SCHF)

# Get the parsimonious solution:

sol_yp &lt;- minimize(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE)

# Get the parsimonious solution for the absence of the outcome:

sol_nyp &lt;- minimize(SCHF, outcome = "EXPORT", neg.out = TRUE,
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE)


# Get the contradictory simplofying assumptions:

LR.intersect(sol_yp, sol_nyp)
</code></pre>

<hr>
<h2 id='negateExp'>
Negates a boolean expression.
</h2><span id='topic+negateExp'></span>

<h3>Description</h3>

<p>Function that negates a boolean expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negateExp(expression)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negateExp_+3A_expression">expression</code></td>
<td>

<p>A boolean expression.
Conditions should be capitalized and negated conditions should be inserted with a &quot;~&quot;.
Unions of conditions are performed with a &quot;+&quot;, while intersections are performed with a &quot;*&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> It returns a negated boolean expression.
</p>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>Examples</h3>

<pre><code class='language-R'>negateExp("~EMP*MA")
negateExp("~A*B + C*~D")
</code></pre>

<hr>
<h2 id='PAYF'>Paykani et al. (2018)</h2><span id='topic+PAYF'></span>

<h3>Description</h3>

<p>The <code>PAYF</code> data frame has 131 rows and 9 sets.  The data is calibrated into fuzzy sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PAYF)</code></pre>


<h3>Format</h3>

<p>A data frame with 131 observations on the following 9 sets.
</p>

<dl>
<dt><code>COUNTRY</code></dt><dd><p>Country</p>
</dd>
<dt><code>REGION</code></dt><dd><p>Region the country belongs to.</p>
</dd>
<dt><code>HE</code></dt><dd><p>Condition: healthy education system</p>
</dd>
<dt><code>GG</code></dt><dd><p>Condition: good governance</p>
</dd>
<dt><code>AH</code></dt><dd><p>Condition: affluent health  system</p>
</dd>
<dt><code>HI</code></dt><dd><p>Condition: high income inequality</p>
</dd>
<dt><code>HW</code></dt><dd><p>Condition: high wealth</p>
</dd>
<dt><code>HL</code></dt><dd><p>Outcome: high life expectancy</p>
</dd>
<dt><code>LL</code></dt><dd><p>Negated Outcome: low life expectancy</p>
</dd>
</dl>



<h3>References</h3>

<p>Paykani, Toktam, Rafiey, Hassan, and Sajjadi, Homeira. 2018. A fuzzy set qualitative comparative analysis of 131 countries: which configuration of the structural conditions can explain health better? International journal for equity in health, 17(1), 10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PAYF)</code></pre>

<hr>
<h2 id='PAYR'>Paykani et al. (2018)</h2><span id='topic+PAYR'></span>

<h3>Description</h3>

<p>The <code>PAYR</code> data frame has 131 rows and 9 variables. The data is raw, uncalibrated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PAYR)</code></pre>


<h3>Format</h3>

<p>A data frame with 131 observations on the following 9 sets.
</p>

<dl>
<dt><code>COUNTRY</code></dt><dd><p>Country</p>
</dd>
<dt><code>REGION</code></dt><dd><p>Region the country belongs to.</p>
</dd>
<dt><code>LIFEX</code></dt><dd><p>Life expectancy, raw data.</p>
</dd>
<dt><code>EDUC</code></dt><dd><p>Education, raw data.</p>
</dd>
<dt><code>GOV</code></dt><dd><p>Governance, raw  data.</p>
</dd>
<dt><code>HEAL</code></dt><dd><p>Health system, raw data.</p>
</dd>
<dt><code>INCEQ</code></dt><dd><p>Income inequality, raw data.</p>
</dd>
<dt><code>WEAL</code></dt><dd><p>Wealth, raw data.</p>
</dd>
</dl>



<h3>References</h3>

<p>Paykani, Toktam, Rafiey, Hassan, and Sajjadi, Homeira. 2018. A fuzzy set qualitative comparative analysis of 131 countries: which configuration of the structural conditions can explain health better? International journal for equity in health, 17(1), 10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PAYR)</code></pre>

<hr>
<h2 id='PENF'>Pennings (2003)</h2><span id='topic+PENF'></span>

<h3>Description</h3>

<p>The <code>PENF</code> data frame has 45 rows and 5 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(PENF)</code></pre>


<h3>Format</h3>

<p>A data frame with 45 observations on the following 5 sets.
</p>

<dl>
<dt><code>K</code></dt><dd><p>a numeric vector. Outcome, constitutional control.</p>
</dd>
<dt><code>C</code></dt><dd><p>a numeric vector. Condition, consensus democracy.</p>
</dd>
<dt><code>P</code></dt><dd><p>a numeric vector. Condition, presidentialism.</p>
</dd>
<dt><code>N</code></dt><dd><p>a numeric vector. Condition, new democracy.</p>
</dd>
<dt><code>R</code></dt><dd><p>a numeric vector. Condition, rigid constritution.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data used by Pennings (2009) to explain constitutional control. Data are fuzzy-sets.</p>


<h3>References</h3>

<p>Pennings, P. (2009) &quot;Beyond Dichotomous Explanations: Explaining Constitutional control of the Executive with Fuzzy-sets&quot;, European Journal of Political Research 42, pp. 541-567.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PENF)</code></pre>

<hr>
<h2 id='pimdata'>
Function to extract prime implicants table from object of class &quot;qca&quot;	
</h2><span id='topic+pimdata'></span>

<h3>Description</h3>

<p>A function that displays each case's set membership scores in each sufficient term, the solution formula, and the outcome from an object of class
&quot;qca&quot;.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pimdata(results, outcome, sol = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pimdata_+3A_results">results</code></td>
<td>

<p>An object of class &quot;qca&quot;. For performing pimdata of the sufficient solution for the negated outcome one        must only use the <code>minimize()</code> result from the sufficiency analysis of the negated outcome.
</p>
</td></tr>
<tr><td><code id="pimdata_+3A_outcome">outcome</code></td>
<td>

<p>A character string with the name of the outcome in capital letters. When performing pimdata of the             sufficient solution for the negated outcome one must only use the <code>minimize()</code> result from the            sufficiency analysis of the negated outcome in the argument <code>results</code>. Changing the name in the           argument <code>outcome</code> or using a tilde is not necessary.
</p>
</td></tr>
<tr><td><code id="pimdata_+3A_sol">sol</code></td>
<td>

<p>A vector where the first number indicates the number of the
conservative or parsimonious solution according to the order in the &quot;qca&quot; object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution
and i = intermediate solution.
</p>
</td></tr>
<tr><td><code id="pimdata_+3A_...">...</code></td>
<td>

<p>Deprecated arguments (neg.out, use.tilde)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with set memberships.
</p>
<table>
<tr><td><code>solution_formula</code></td>
<td>
<p>The solution formula.</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>Membership in the outcome.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana and Juraj Medzihorsky
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>
<code><a href="#topic+pimplot">pimplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import your data. For example:

data(SCHF)

# Get the parsimonious solution:


sol_yp &lt;- minimize(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE)

# Get the intermediate solution:

sol_yi &lt;- minimize(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE, dir.exp = c(0,0,0,0,0,0))


# Get the prime implicants table for the parsimonious solution:

pimdata(results = sol_yp, outcome = "EXPORT")

# Get the prime implicants table for the first intermediate solution:

pimdata(results = sol_yi, outcome = "EXPORT", sol = 1)

</code></pre>

<hr>
<h2 id='pimplot'>
Prime implicants, truth table rows, and necessity plots.
</h2><span id='topic+pimplot'></span>

<h3>Description</h3>

<p>A function that displays XY plots for each sufficient term and the solution formula plotted against the outcome from an object of class &quot;qca&quot; (obtained by using the <code>minimize</code> function in package <code>QCA</code>). The function can also plot truth table rows against the outcome. Additionally, the function can plot results obtained from necessity analyses using an object of class &quot;sS&quot; (obtained by using the <code>superSubset</code> function in package <code>QCA</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pimplot(data = NULL,
           results,
           outcome,
           incl.tt=NULL,
           ttrows= c(),
           necessity=FALSE,
           sol=1,
           all_labels=FALSE,
           markers = TRUE,
           labcol="black", 
           jitter = FALSE,
           font = "sans",
           fontface = "italic", 
           fontsize = 3,
           crisp = FALSE,
           consH = FALSE,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pimplot_+3A_data">data</code></td>
<td>

<p>For analyses of sufficiency, providing a dataframe is not necessary.
For analyses of necessity on objects of class &quot;sS, you need to provide a dataframe with the 
name of the outcome and of the conditions in capital letters. 
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_results">results</code></td>
<td>

<p>An object of class &quot;qca&quot; when necessity is <code>FALSE</code>. An object of class &quot;sS&quot; when necessity is          <code>TRUE</code>. For performing pimplot of the sufficient solution for the negated outcome one must use the <code>minimize()</code> result from the sufficiency analysis of the negated outcome.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_outcome">outcome</code></td>
<td>

<p>A character string with the name of the outcome in capital letters. When performing pimplot of the        sufficient solution for the negated outcome one must only use the <code>minimize()</code> result from the           sufficiency analysis of the negated outcome in the argument <code>results</code>. Changing the name in the argument <code>outcome</code> or using a tilde is not necessary, but recommended.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_incl.tt">incl.tt</code></td>
<td>

<p>A numerical vector of length 1 specifying the row consistency threshold above which it 
should plot truth table rows. By default it is <code>NULL</code> and the function will produce 
plots using &quot;qca&quot; or &quot;sS&quot; objects. If a numerical value is specifyied, then it 
automatically only plots truth table rows above that consistency value.
N.B. This argument cannot be used simultaneously with the <code>ttrows</code> argument.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_ttrows">ttrows</code></td>
<td>

<p>A vector of character strings specifying the names of the truth table rows to be printed.
By default this vector is empty and the function will produce plots using &quot;qca&quot; or &quot;sS&quot; objects. 
If a value is specifyied, then it automatically only plots those particular truth table rows.
N.B. This argument cannot be used simultaneously with the <code>incl.tt</code> argument.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_necessity">necessity</code></td>
<td>

<p>logical. It indicates if the output should be for the results of sufficiency or necessity analyses. 
By default, <code>FALSE</code>, the function works with an object of class &quot;qca&quot; obtained from the 
<code>minimize</code> function in package <code>QCA</code>. When it set to <code>TRUE</code> the function returns plots for     an object of class &quot;sS&quot; obtained from the <code>superSubset</code> function in package <code>QCA</code>.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_sol">sol</code></td>
<td>

<p>A vector where the first number indicates the number of the
conservative or parsimonious solution according to the order in the &quot;qca&quot; object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution
and i = intermediate solution.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_all_labels">all_labels</code></td>
<td>

<p>Logical. Print ALL case labels?
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_markers">markers</code></td>
<td>

<p>Logical. Print deviant consistency cases with different markers?
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_labcol">labcol</code></td>
<td>

<p>Color of the labels.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_jitter">jitter</code></td>
<td>

<p>Logical. Should labels not overlab?
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_font">font</code></td>
<td>

<p>Font of the labels. Accepts &quot;sans&quot;, &quot;serif&quot;, and &quot;mono&quot; fonts.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_fontface">fontface</code></td>
<td>

<p>Fontface of the labels. Accepts &quot;plain&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;bold.italic&quot;.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_fontsize">fontsize</code></td>
<td>

<p>Fontsize of the labels.
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_crisp">crisp</code></td>
<td>

<p>Logical. Should the function return a two-by-two table for crisp sets?
</p>
</td></tr>
<tr><td><code id="pimplot_+3A_consh">consH</code></td>
<td>
<p>Logical. Should Haesebrouck's consistency be printed?</p>
</td></tr>
<tr><td><code id="pimplot_+3A_...">...</code></td>
<td>

<p>Other non essential arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>XY plots.
</p>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Haesebrouck, T. (2015) Pitfalls in QCA's consistency measure. Journal of Comparative Politics 2:65-80.
</p>
<p>Schneider, C. Q., Rohlfing, I. 2013. Combining QCA and Process Tracing in Set-Theoretic Multi-Method Research. Sociological Methods Research 42(4): 559-597
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>
<code><a href="#topic+pimdata">pimdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import your data. For example:

data(SCHF)

# Get the parsimonious solution:


sol_yp &lt;- minimize(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE)

# Plot the prime implicants of the parsimonious solution:

pimplot(data = SCHF, results = sol_yp, outcome = "EXPORT")

# Plot a two-by-two table:

pimplot(data = SCHF, results = sol_yp, outcome = "EXPORT", crisp = TRUE)

# Plot all truth table rows with a consistency higher than 0.95:

pimplot(data=SCHF, results = sol_yp, incl.tt=0.97, outcome = "EXPORT", sol = 1)

# Plot truth table row "60":

pimplot(data=SCHF, results = sol_yp, ttrows =c("60"), 
        outcome = "EXPORT", sol = 1)

# For plotting results of necessity analyses using superSubset,
# the first stept is to obtain an "sS" object:

SUPSUB &lt;- superSubset(SCHF, outcome="EXPORT", 
                      conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"), 
                      relation = "necessity", incl.cut = 0.996)
SUPSUB

# This can be imputed as result and necessity should be set to \code{TRUE}:

pimplot(data = SCHF, results = SUPSUB, outcome = "EXPORT", necessity = TRUE)

</code></pre>

<hr>
<h2 id='property.cube'>Function producing a 3D scatter plot.</h2><span id='topic+property.cube'></span>

<h3>Description</h3>

<p>A function for visualizing 3D property spaces as a 3D scatter plot using the scatterplot3d package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>property.cube(data, labs = FALSE, 
                          main = "3D Property Space", 
                          xlab=NULL, 
                          ylab=NULL, 
                          zlab=NULL,
                          highlight.3d=TRUE,
                          dot.cex=0.5,
                          dot.col="black",
                          dot.srt=15,
                          dot.pos=3,
                          dot.offset = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="property.cube_+3A_data">data</code></td>
<td>
<p>A dataframe with 3 conditions.</p>
</td></tr>
<tr><td><code id="property.cube_+3A_labs">labs</code></td>
<td>
<p>Logical. Should the case names be printed? If set to TRUE, it will automatically print the rownames of the dataframe given.</p>
</td></tr>
<tr><td><code id="property.cube_+3A_main">main</code></td>
<td>
<p>an overall title for the plot. The default is &quot;3D Property Space&quot;</p>
</td></tr>
<tr><td><code id="property.cube_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x-axis. The default is the name of the first column in the dataframe.</p>
</td></tr>
<tr><td><code id="property.cube_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y-axis. The default is the name of the third column in the dataframe.</p>
</td></tr>
<tr><td><code id="property.cube_+3A_zlab">zlab</code></td>
<td>
<p>a title for the z-axis. The default is the name of the second column in the dataframe.</p>
</td></tr>
<tr><td><code id="property.cube_+3A_highlight.3d">highlight.3d</code></td>
<td>
<p>Logical. Should dots be colored differently according to their position in the property space?</p>
</td></tr>
<tr><td><code id="property.cube_+3A_dot.cex">dot.cex</code></td>
<td>
<p>size of the case labels</p>
</td></tr>
<tr><td><code id="property.cube_+3A_dot.col">dot.col</code></td>
<td>
<p>color of the case labels</p>
</td></tr>
<tr><td><code id="property.cube_+3A_dot.srt">dot.srt</code></td>
<td>
<p>rotation of the case labels</p>
</td></tr>
<tr><td><code id="property.cube_+3A_dot.pos">dot.pos</code></td>
<td>
<p>position of the case labels (1-below, 2-left, 3-above, 4-right)</p>
</td></tr>
<tr><td><code id="property.cube_+3A_dot.offset">dot.offset</code></td>
<td>
<p>distance of text label from the dot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an enhanced 3d scatter plot using the <code>scatterplot3d</code> package.</p>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the Schneider data:

data(SCHF)

# Create a property space for conditions "EMP","BARGAIN", and outcome "EXPORT":

property.cube(SCHF[,c("EMP","BARGAIN","EXPORT")])

# Create a property space for conditions 1,2, and 3 in the data together with case labels:

property.cube(SCHF[,1:3], labs=TRUE)
</code></pre>

<hr>
<h2 id='QCAfit'>Function calculating the parameters of fit</h2><span id='topic+QCAfit'></span>

<h3>Description</h3>

<p>QCAfit is a function calculating parameters of fit useful in QCA and fsQCA that are consistency, coverage, PRI, Haesebrouck's consistency, RoN and PRODUCT. It works with both single and multiple conditions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>QCAfit(x, y, cond.lab = NULL, necessity = TRUE, neg.out = FALSE, 
              product = FALSE, sol=1, ttrows= c(), consH = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QCAfit_+3A_x">x</code></td>
<td>

<p>A vector containing the values of a condition, a matrix with more than one conditions, or an object of         class &quot;qca&quot; when necessity is <code>FALSE</code> and when outcome is specifyied as a character string.</p>
</td></tr>
<tr><td><code id="QCAfit_+3A_y">y</code></td>
<td>

<p>A vector containing the values of the output or a character string when y is of class &quot;qca&quot;.</p>
</td></tr>
<tr><td><code id="QCAfit_+3A_cond.lab">cond.lab</code></td>
<td>

<p>When inserting a dataframe or a matrix with more than one condition and column names, the function
automatically prints the names of the conditions tested. When inputing a vector, hence a single condition      (i.e. a single column in a dataframe, the name of the condition tested should be inserted in this option       .)</p>
</td></tr>
<tr><td><code id="QCAfit_+3A_necessity">necessity</code></td>
<td>

<p>logical. It indicates if the output should be for sufficient or necessary condition(s). By default,             <code>FALSE</code>, the function returns a table of parameters of fit for sufficient condition(s) (Consistency,       Coverage, PRI, Haesebrouck's Consistency, and optionally Product). When it set to <code>TRUE</code> the              function returns a table of parameters of fit for necessary condition(s) (Consistency, Coverage,               Relevance of Necessity).</p>
</td></tr>
<tr><td><code id="QCAfit_+3A_neg.out">neg.out</code></td>
<td>
<p>logical. It indicates if the parameters of fit should be computed for the positive or the        negative outcome. By default, <code>FALSE</code>, the function returns parameters of fit for the positive outcome   .</p>
</td></tr>
<tr><td><code id="QCAfit_+3A_product">product</code></td>
<td>
<p>logical. It indicates whether the parameter of fit PRODUCT should be shown. This stands for     the product between the consistency sufficiency parameter and the PRI parameter.</p>
</td></tr>
<tr><td><code id="QCAfit_+3A_sol">sol</code></td>
<td>

<p>A vector where the first number indicates the number of the
conservative or parsimonious solution according to the order in the &quot;qca&quot; object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution
and i = intermediate solution.</p>
</td></tr>
<tr><td><code id="QCAfit_+3A_ttrows">ttrows</code></td>
<td>

<p>A vector specifying the names of the truth table rows for which the function reports parameters of fit. 
For using this option y must be a &quot;qca&quot; object.
</p>
</td></tr>
<tr><td><code id="QCAfit_+3A_consh">consH</code></td>
<td>

<p>Logical. Print also the Haesebrouck's consistency among the parameters of fit?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a matrix containing the parameters of fit for each condition.</p>


<h3>Author(s)</h3>

<p>Mario Quaranta and Ioana-Elena Oana</p>


<h3>References</h3>

<p>Haesebrouck, T. (2015) Pitfalls in QCA's consistency measure. Journal of Comparative Politics 2:65-80.
</p>
<p>Ragin, C. C. 2006. Set Relations in Social Research: Evaluating Their Consistency and Coverage. Political Analysis 14(3): 291-310.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.	
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate fake data
set.seed(1234)

a &lt;- runif(100, 0, 1)
b &lt;- runif(100, 0, 1)
c &lt;- runif(100, 0, 1)
y &lt;- runif(100, 0, 1)

# Only one condition, for necessity
QCAfit(a, y, cond.lab = "A")

# With three conditions and their negation, for necessity
QCAfit(cbind(a, b, c), y)

# Only one condition, for sufficiency
QCAfit(a, y, cond.lab = "A", necessity = FALSE)

# With three conditions, their negation and negated output, for necessity
QCAfit(cbind(a, b, c), y, neg.out = TRUE)

# Load the Schneider data:

data(SCHF)

# Get parameters of fit for condition EMP as necessary for outcome EXPORT:

QCAfit(SCHF$EMP, SCHF$EXPORT, cond.lab = "EMP")

# Get parameters of fit for condition ~EMP as necessary for outcome ~EXPORT:

QCAfit(1-SCHF$EMP, SCHF$EXPORT, neg.out=TRUE, cond.lab = "~EMP")

# Get parameters of fit for all conditions and their negation as necessary for outcome EXPORT:

QCAfit(SCHF[,1:6], SCHF$EXPORT)

# Obtain the parsimonious solution for outcome "EXPORT":

sol_yp &lt;- minimize(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE)
                
# Get parameters of fit for the parsimonious solution:

QCAfit(x = sol_yp, y = "EXPORT", necessity = FALSE)

# Get parameters of fit for truth table rows 2,8, and 10:

QCAfit(x = sol_yp, y = "EXPORT", ttrows=c("2","8","10"), necessity = FALSE)

</code></pre>

<hr>
<h2 id='QCAradar'>
Function for displaying a radar chart.
</h2><span id='topic+QCAradar'></span>

<h3>Description</h3>

<p>Function displays a radar chart for an object of class &quot;qca&quot; or for a boolean expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QCAradar(results, outcome= NULL, fit= FALSE, sol = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QCAradar_+3A_results">results</code></td>
<td>

<p>An object of class &quot;qca&quot;. For performing radar charts of the sufficient solution for 
the negated outcome one must only use the <code>minimize()</code> result from the sufficiency 
analysis of the negated outcome.
The argument results can also be a boolean expression of the form e.g. &quot;A*~B + ~B*C&quot;.
</p>
</td></tr>
<tr><td><code id="QCAradar_+3A_outcome">outcome</code></td>
<td>

<p>A character string with the name of the outcome in capital letters when results is of type 'qca'. 
When performing radar charts of the sufficient solution for the negated outcome one must 
only use the <code>minimize()</code>result from the sufficiency analysis of the negated outcome 
in the argument <code>results</code>. Changing the name in the argument <code>outcome</code> or using 
a tilde is not necessary.
</p>
</td></tr>
<tr><td><code id="QCAradar_+3A_fit">fit</code></td>
<td>

<p>Logical. Print parameters of fit when results is of type 'qca'
</p>
</td></tr>
<tr><td><code id="QCAradar_+3A_sol">sol</code></td>
<td>

<p>A vector where the first number indicates the number of the conservative or parsimonious solution 
according to the order in the &quot;qca&quot; object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution
and i = intermediate solution.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Maerz, F. Seraphine. 2017. &quot;Pathways of Authoritarian Persistence.&quot; Paper presented at the CEU Annual Doctoral Conference 
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Import data. 
# For example:

data(SCHF)

# Get the intermediate solution:

sol_yi &lt;- minimize(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE, dir.exp = c(0,0,0,0,0,0))

# Display radar chart for the intermediate solution:

QCAradar(results = sol_yi, outcome = "EXPORT", fit=TRUE, sol = 1)

# Show a radar chart for the following boolean expression "A + ~B*Z*~C"

QCAradar(results = "A + ~B*Z*~C")

</code></pre>

<hr>
<h2 id='rob.calibrange'>
Function for identifying the calibration threshold ranges for a condition within which the Boolean formula for the solution does not change.
</h2><span id='topic+rob.calibrange'></span>

<h3>Description</h3>

<p>Function for identifying the calibration threshold ranges for a conditio within which the Boolean formula for the solution does not change. The function gradually increases and, then, decreases each of the three (0, 0,5, 1) calibration thresholds of a condition by the value specifyied in the step argument and checks whether the solution formula changes. The function performs this iteration for the number of times specified in the max.runs argument. If the solution formula does not change given the number of runs specified, it will return an NA, meaning that it could not find a limit to the range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob.calibrange(raw.data,
    calib.data,
    test.cond.raw,
    test.cond.calib,
    test.thresholds,
    type = "fuzzy",
    step = 1,
    max.runs = 20,
    outcome,
    conditions,
    incl.cut = 1,
    n.cut = 1,
    include = "",
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rob.calibrange_+3A_raw.data">raw.data</code></td>
<td>
<p>A data frame containing the raw data used to test the calibration thresholds for the chosen condition.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_calib.data">calib.data</code></td>
<td>
<p>A data frame containing the calibrated data for the sufficient solution.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_test.cond.raw">test.cond.raw</code></td>
<td>
<p>A character string specifying the name of the condition in the RAW dataset for which to test the calibration ranges.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_test.cond.calib">test.cond.calib</code></td>
<td>
<p>A character string specifying the name of the condition in the CALIBRATED dataset for which to test the calibration ranges.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_test.thresholds">test.thresholds</code></td>
<td>

<p>The initial qualitative anchors used for calibrating the chosen condition.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_type">type</code></td>
<td>

<p>The calibration type, &quot;fuzzy&quot; is the default, but it can also be changed to &quot;crisp&quot;.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_step">step</code></td>
<td>
<p>The value to be gradually added and subtracted from the threshold tested.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_max.runs">max.runs</code></td>
<td>
<p>The maximum number of times the step value gets gradually added and subtracted.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_outcome">outcome</code></td>
<td>
<p>A character string with the name of the outcome in capital letters. For the negated outcome a tilde &quot;~&quot; should be used. This had the same usage as the outcome argument in the minimize function.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_conditions">conditions</code></td>
<td>

<p>A vector of character strings containing the names of the conditions.This had the same usage as the conditions argument in the minimize function.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_incl.cut">incl.cut</code></td>
<td>

<p>The raw consistency threshold for the truth table rows.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_n.cut">n.cut</code></td>
<td>

<p>The frequency threshold for the truth table rows.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_include">include</code></td>
<td>

<p>A vector of other output values (for example &quot;?&quot; for logical remainders) to include in the minimization. This had the same usage as the include argument in the minimize function.
</p>
</td></tr>
<tr><td><code id="rob.calibrange_+3A_...">...</code></td>
<td>

<p>Other options that the minimize function in the QCA package accepts. Check them out using ?minimize.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, and Carsten Q. Schneider. 2020. Robustness tests in QCA: A fit-oriented and case-oriented perspective using R. Unpublished Manuscript.
</p>
<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the calibrated data:
data(LIPF)

# Load the raw data:
data(LIPR)

# Get calibration ranges for condition DEVELOPED:

rob.calibrange(
  raw.data = LIPR,
  calib.data = LIPF,
  test.cond.raw = "DEVELOPED",
  test.cond.calib = "DEVELOPED",
  test.thresholds = c(400, 550, 900),
  step = 500,
  max.runs = 2,
  outcome  = "SURVIVED",
  conditions = c("URBAN","LITERATE","INDUSTRIAL","STABLE"),
  incl.cut = 0.8,
  n.cut = 1,
  include = "?"
)
</code></pre>

<hr>
<h2 id='rob.cases'>
Function for identifying cases in the intersections between an inital solution and test solutions.
</h2><span id='topic+rob.cases'></span>

<h3>Description</h3>

<p>Function for identifying cases between the various intersections between an inital solution and test solutions. The function also returns case ratio paramaters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob.cases(test_sol, 
           initial_sol, 
           outcome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rob.cases_+3A_test_sol">test_sol</code></td>
<td>

<p>The different alternative solutions created with minimize() and placed in a list using list().
</p>
</td></tr>
<tr><td><code id="rob.cases_+3A_initial_sol">initial_sol</code></td>
<td>

<p>The initial solution created with minimize().
</p>
</td></tr>
<tr><td><code id="rob.cases_+3A_outcome">outcome</code></td>
<td>

<p>A character string containing the name of the outcome.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, and Carsten Q. Schneider. 2020. Robustness tests in QCA: A fit-oriented and case-oriented perspective using R. Unpublished Manuscript.
</p>
<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the data:
data(PAYF)

# Store the name of the conditions in one vector:
conds &lt;-  c("HE","GG","AH","HI","HW")

# Create several solutions:

# The initial solution
IS &lt;- minimize(data = PAYF,
                outcome  = "HL",
                conditions = conds,
                incl.cut = 0.87,
                n.cut = 2,
                include = "?",
                details = TRUE, 
                show.cases = TRUE)

# altering consistency
TS1 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.7,
                 n.cut = 2,
                 include = "?",
                 details = TRUE, show.cases = TRUE)

#altering n.cut
TS2 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.87,
                 n.cut = 1,
                 include = "?",
                 details = TRUE, show.cases = TRUE)
                 
# Create the test set in a list:
TS &lt;- list(TS1, TS2)

# Looking at cases against the test set:

rob.cases(test_sol = TS, 
                 initial_sol = IS, 
                 outcome = "HL")
## End(Not run)


</code></pre>

<hr>
<h2 id='rob.corefit'>
Function returning parameters of fit for the robust core of different alternative sufficient solutions.
</h2><span id='topic+rob.corefit'></span>

<h3>Description</h3>

<p>Function returning parameters of fit for the robust core between an initial solution and various alternative test solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob.corefit(test_sol, 
          initial_sol, 
          outcome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rob.corefit_+3A_test_sol">test_sol</code></td>
<td>

<p>The different alternative solutions created with minimize() and placed in a list using list().
</p>
</td></tr>
<tr><td><code id="rob.corefit_+3A_initial_sol">initial_sol</code></td>
<td>

<p>The initial solution created with minimize().
</p>
</td></tr>
<tr><td><code id="rob.corefit_+3A_outcome">outcome</code></td>
<td>

<p>A character string containing the name of the outcome.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, and Carsten Q. Schneider. 2020. Robustness tests in QCA: A fit-oriented and case-oriented perspective using R. Unpublished Manuscript.
</p>
<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data:
data(PAYF)

# Store the name of the conditions in one vector:
conds &lt;-  c("HE","GG","AH","HI","HW")

# Create several solutions:

# The initial solution
IS &lt;- minimize(data = PAYF,
                outcome  = "HL",
                conditions = conds,
                incl.cut = 0.87,
                n.cut = 2,
                include = "?",
                details = TRUE, 
                show.cases = TRUE)

# altering consistency
TS1 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.7,
                 n.cut = 2,
                 include = "?",
                 details = TRUE, show.cases = TRUE)

#altering n.cut
TS2 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.87,
                 n.cut = 1,
                 include = "?",
                 details = TRUE, show.cases = TRUE)
                 
# Create the test set in a list:
TS &lt;- list(TS1, TS2)

# Calculate robustness parameters, i.e. the ratio of the parameters
# of fit for the core vis-a-vis for the initial solution:

CF &lt;- rob.corefit(test_sol = TS, 
           initial_sol = IS,  
           outcome = "HL")
CF
</code></pre>

<hr>
<h2 id='rob.fit'>
Function returning robustness parameters of fit.
</h2><span id='topic+rob.fit'></span>

<h3>Description</h3>

<p>Function returning robustness parameters of fit of the intersections between an initial sufficient solution and various alternative test solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob.fit(test_sol, 
              initial_sol, 
              outcome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rob.fit_+3A_test_sol">test_sol</code></td>
<td>

<p>The different alternative solutions created with minimize() and placed in a list using list().
</p>
</td></tr>
<tr><td><code id="rob.fit_+3A_initial_sol">initial_sol</code></td>
<td>

<p>The initial solution created with minimize().
</p>
</td></tr>
<tr><td><code id="rob.fit_+3A_outcome">outcome</code></td>
<td>

<p>A character string containing the name of the outcome.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, and Carsten Q. Schneider. 2020. Robustness tests in QCA: A fit-oriented and case-oriented perspective using R. Unpublished Manuscript.
</p>
<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data:
data(PAYF)

# Store the name of the conditions in one vector:
conds &lt;-  c("HE","GG","AH","HI","HW")

# Create several solutions:

# The initial solution
IS &lt;- minimize(data = PAYF,
                outcome  = "HL",
                conditions = conds,
                incl.cut = 0.87,
                n.cut = 2,
                include = "?",
                details = TRUE, 
                show.cases = TRUE)

# altering consistency
TS1 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.7,
                 n.cut = 2,
                 include = "?",
                 details = TRUE, show.cases = TRUE)

#altering n.cut
TS2 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.87,
                 n.cut = 1,
                 include = "?",
                 details = TRUE, show.cases = TRUE)
                 
# Create the test set in a list:
TS &lt;- list(TS1, TS2)

# Calculate robustness parameters, i.e. the ratio of the parameters
# of fit for the core vis-a-vis for the initial solution:

RF &lt;- rob.fit(test_sol = TS, 
           initial_sol = IS,  
           outcome = "HL")
RF
</code></pre>

<hr>
<h2 id='rob.inclrange'>
Function for identifying the raw consistency threshold range within which the Boolean formula for the solution does not change.
</h2><span id='topic+rob.inclrange'></span>

<h3>Description</h3>

<p>Function for identifying the raw consistency threshold range for a truth table within which the Boolean formula for the solution does not change. The function gradually increases and, then, decreases an inital selected threshold by the value specifyied in the step argument and checks whether the solution formula changes for finding the lower and upper ranges for the raw consistency threshold. The function performs this iteration for the number of times specified in the max.runs argument. If the solution formula does not change given the number of runs specified, it will return an NA, meaning that it could not find a limit to the range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob.inclrange(data,
    step = 0.1,
    max.runs = 20,
    outcome,
    conditions,
    incl.cut = 1,
    n.cut = 1,
    include = "",
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rob.inclrange_+3A_data">data</code></td>
<td>

<p>A data frame containing the calibrated data for the sufficient solution.
</p>
</td></tr>
<tr><td><code id="rob.inclrange_+3A_step">step</code></td>
<td>
<p>The value to be gradually added and subtracted from the threshold tested.
</p>
</td></tr>
<tr><td><code id="rob.inclrange_+3A_max.runs">max.runs</code></td>
<td>
<p>The maximum number of times the step value gets gradually added and subtracted.
</p>
</td></tr>
<tr><td><code id="rob.inclrange_+3A_outcome">outcome</code></td>
<td>
<p>A character string with the name of the outcome in capital letters. For the negated outcome a tilde &quot;~&quot; should be used. This had the same usage as the outcome argument in the minimize function.
</p>
</td></tr>
<tr><td><code id="rob.inclrange_+3A_conditions">conditions</code></td>
<td>

<p>A vector of character strings containing the names of the conditions.This had the same usage as the conditions argument in the minimize function.
</p>
</td></tr>
<tr><td><code id="rob.inclrange_+3A_incl.cut">incl.cut</code></td>
<td>

<p>The raw consistency threshold for the truth table rows.
</p>
</td></tr>
<tr><td><code id="rob.inclrange_+3A_n.cut">n.cut</code></td>
<td>

<p>The frequency threshold for the truth table rows.
</p>
</td></tr>
<tr><td><code id="rob.inclrange_+3A_include">include</code></td>
<td>

<p>A vector of other output values (for example &quot;?&quot; for logical remainders) to include in the minimization. This had the same usage as the include argument in the minimize function.
</p>
</td></tr>
<tr><td><code id="rob.inclrange_+3A_...">...</code></td>
<td>

<p>Other options that the minimize function in the QCA package accepts. Check them out using ?minimize.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, and Carsten Q. Schneider. 2020. Robustness tests in QCA: A fit-oriented and case-oriented perspective using R. Unpublished Manuscript.
</p>
<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the calibrated data:
data(PAYF)

# Check raw consistency ranges:

rob.inclrange(
  data = PAYF,
  step = 0.01,
  max.runs = 10,
  outcome  = "HL",
  conditions = c("HE","GG","AH","HI","HW"),
  incl.cut = 0.87,
  n.cut = 2,
  include = "?"
)
</code></pre>

<hr>
<h2 id='rob.ncutrange'>
Function for identifying the frequency threshold range within which the Boolean formula for the solution does not change.
</h2><span id='topic+rob.ncutrange'></span>

<h3>Description</h3>

<p>Function for identifying the frequency threshold range for a truth table within which the Boolean formula for the solution does not change. The function gradually increases and, then, decreases an inital selected threshold by the value specifyied in the step argument and checks whether the solution formula changes for finding the lower and upper ranges for the frequency threshold. The function performs this iteration for the number of times specified in the max.runs argument. If the solution formula does not change given the number of runs specified, it will return an NA, meaning that it could not find a limit to the range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob.ncutrange(data,
    step = 1,
    max.runs = 20,
    outcome,
    conditions,
    incl.cut = 1,
    n.cut = 1,
    include = "",
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rob.ncutrange_+3A_data">data</code></td>
<td>
<p>A data frame containing the calibrated data for the sufficient solution.
</p>
</td></tr>
<tr><td><code id="rob.ncutrange_+3A_step">step</code></td>
<td>
<p>The value to be gradually added and subtracted from the threshold tested.
</p>
</td></tr>
<tr><td><code id="rob.ncutrange_+3A_max.runs">max.runs</code></td>
<td>
<p>The maximum number of times the step value gets gradually added and subtracted.
</p>
</td></tr>
<tr><td><code id="rob.ncutrange_+3A_outcome">outcome</code></td>
<td>
<p>A character string with the name of the outcome in capital letters. For the negated outcome a tilde &quot;~&quot; should be used. This had the same usage as the outcome argument in the minimize function.
</p>
</td></tr>
<tr><td><code id="rob.ncutrange_+3A_conditions">conditions</code></td>
<td>

<p>A vector of character strings containing the names of the conditions.This had the same usage as the conditions argument in the minimize function.
</p>
</td></tr>
<tr><td><code id="rob.ncutrange_+3A_incl.cut">incl.cut</code></td>
<td>

<p>The raw consistency threshold for the truth table rows.
</p>
</td></tr>
<tr><td><code id="rob.ncutrange_+3A_n.cut">n.cut</code></td>
<td>

<p>The frequency threshold for the truth table rows.
</p>
</td></tr>
<tr><td><code id="rob.ncutrange_+3A_include">include</code></td>
<td>

<p>A vector of other output values (for example &quot;?&quot; for logical remainders) to include in the minimization. This had the same usage as the include argument in the minimize function.
</p>
</td></tr>
<tr><td><code id="rob.ncutrange_+3A_...">...</code></td>
<td>

<p>Other options that the minimize function in the QCA package accepts. Check them out using ?minimize.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, and Carsten Q. Schneider. 2020. Robustness tests in QCA: A fit-oriented and case-oriented perspective using R. Unpublished Manuscript.
</p>
<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the calibrated data:
data(PAYF)

# Check frequency ranges:
rob.ncutrange(
  data = PAYF,
  step = 1,
  max.runs = 10,
  outcome  = "HL",
  conditions = c("HE","GG","AH","HI","HW"),
  incl.cut = 0.87,
  n.cut = 2,
  include = "?"
)
</code></pre>

<hr>
<h2 id='rob.singletest'>
Function returning robustness parameters for each single test solution in TS.
</h2><span id='topic+rob.singletest'></span>

<h3>Description</h3>

<p>Function returning robustness parameters for each single test solution in TS. The function returns the set-coincidence and RC_Rank between each alternative solution and the initial solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob.singletest(test_sol, 
              initial_sol, 
              outcome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rob.singletest_+3A_test_sol">test_sol</code></td>
<td>

<p>The different alternative solutions created with minimize() and placed in a list using list().
</p>
</td></tr>
<tr><td><code id="rob.singletest_+3A_initial_sol">initial_sol</code></td>
<td>

<p>The initial solution created with minimize().
</p>
</td></tr>
<tr><td><code id="rob.singletest_+3A_outcome">outcome</code></td>
<td>

<p>A character string containing the name of the outcome.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, and Carsten Q. Schneider. 2021. Robustness tests in QCA: A fit-oriented and case-oriented perspective using R. Unpublished Manuscript.
</p>
<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (2021). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data:
data(PAYF)

# Store the name of the conditions in one vector:
conds &lt;-  c("HE","GG","AH","HI","HW")

# Create several solutions:

# The initial solution
IS &lt;- minimize(data = PAYF,
                outcome  = "HL",
                conditions = conds,
                incl.cut = 0.87,
                n.cut = 2,
                include = "?",
                details = TRUE, 
                show.cases = TRUE)

# altering consistency
TS1 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.7,
                 n.cut = 2,
                 include = "?",
                 details = TRUE, show.cases = TRUE)

#altering n.cut
TS2 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.87,
                 n.cut = 1,
                 include = "?",
                 details = TRUE, show.cases = TRUE)
                 
# Create the test set in a list:
TS &lt;- list(TS1, TS2)

# Calculate robustness parameters, i.e. the ratio of the parameters
# of fit for the core vis-a-vis for the initial solution:

RST &lt;- rob.singletest(test_sol = TS, 
           initial_sol = IS,  
           outcome = "HL")
RST
</code></pre>

<hr>
<h2 id='rob.xyplot'>
Function  for plotting an initial solution against the test set.</h2><span id='topic+rob.xyplot'></span>

<h3>Description</h3>

<p>Function  for plotting an initial solution against the test set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rob.xyplot(test_sol, 
            initial_sol, 
            outcome,
            all_labels = FALSE,
            jitter = TRUE,
            fontsize = 3,
            labs = TRUE,
            area_lab = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rob.xyplot_+3A_test_sol">test_sol</code></td>
<td>

<p>The different alternative solutions created with minimize() and placed in a list using list().
</p>
</td></tr>
<tr><td><code id="rob.xyplot_+3A_initial_sol">initial_sol</code></td>
<td>

<p>The initial solution created with minimize().
</p>
</td></tr>
<tr><td><code id="rob.xyplot_+3A_outcome">outcome</code></td>
<td>

<p>A character string containing the name of the outcome.
</p>
</td></tr>
<tr><td><code id="rob.xyplot_+3A_all_labels">all_labels</code></td>
<td>

<p>Logical. Should all the case labels be printed? If FALSE, only shaky and possible cases are printed.
</p>
</td></tr>
<tr><td><code id="rob.xyplot_+3A_jitter">jitter</code></td>
<td>

<p>Logical. Should case labels be jitter so as not to overlap?
</p>
</td></tr>
<tr><td><code id="rob.xyplot_+3A_fontsize">fontsize</code></td>
<td>

<p>The size of the font for case labels.
</p>
</td></tr>
<tr><td><code id="rob.xyplot_+3A_labs">labs</code></td>
<td>

<p>Logical.Should case labels be printed?
</p>
</td></tr>
<tr><td><code id="rob.xyplot_+3A_area_lab">area_lab</code></td>
<td>

<p>Logical.Should labels for each area with regard to minTS/maxTS be printed?
</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, and Carsten Q. Schneider. 2020. Robustness tests in QCA: A fit-oriented and case-oriented perspective using R. Unpublished Manuscript.
</p>
<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data:
data(PAYF)

# Store the name of the conditions in one vector:
conds &lt;-  c("HE","GG","AH","HI","HW")

# Create several solutions:

# The initial solution
IS &lt;- minimize(data = PAYF,
                outcome  = "HL",
                conditions = conds,
                incl.cut = 0.87,
                n.cut = 2,
                include = "?",
                details = TRUE, 
                show.cases = TRUE)

# altering consistency
TS1 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.7,
                 n.cut = 2,
                 include = "?",
                 details = TRUE, show.cases = TRUE)

#altering n.cut
TS2 &lt;- minimize(data = PAYF,
                 outcome  = "HL",
                 conditions = conds,
                 incl.cut = 0.87,
                 n.cut = 1,
                 include = "?",
                 details = TRUE, show.cases = TRUE)
                 
# Create the test set in a list:
TS &lt;- list(TS1, TS2)

# Plotting the initial solution against the test set:

rob.xyplot(test_sol = TS, 
                  initial_sol = IS, 
                  outcome = "HL", 
                  fontsize = 2.5, 
                  jitter=TRUE)
</code></pre>

<hr>
<h2 id='SAMF'>Samford (2010)</h2><span id='topic+SAMF'></span>

<h3>Description</h3>

<p>The <code>SAMF</code> data frame has 61 rows and 4 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SAMF)</code></pre>


<h3>Format</h3>

<p>A data frame with 61 observations on the following 4 sets.
</p>

<dl>
<dt><code>Y</code></dt><dd><p>a numeric vector. Outcome, trade liberalization.</p>
</dd>
<dt><code>G</code></dt><dd><p>a numeric vector. Condition, lack of weak growth.</p>
</dd>
<dt><code>H</code></dt><dd><p>a numeric vector. Condition, lack of hyper-inflation</p>
</dd>
<dt><code>HorG</code></dt><dd><p>a numeric vector. Condition, H or G.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are used by Samford (2010) to analyze rapid trade liberalization in Latin America. Data are fuzzy-sets.</p>


<h3>References</h3>

<p>Samford, S. (2010) &quot;Averting 'Disruption and Reversal': Reassessing the Logic of Rapid Trade Reform in Latin America&quot;, Politics and Policy 38(3), pp. 373-407.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SAMF)</code></pre>

<hr>
<h2 id='SC'>Selbst, practicing the truth table algorithm data</h2><span id='topic+SC'></span>

<h3>Description</h3>

<p>The <code>SC</code> data frame has 130 rows and 4 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SC)</code></pre>


<h3>Format</h3>

<p>A data frame with 130 observations on the following 4 sets.
</p>

<dl>
<dt><code>A</code></dt><dd><p>a numeric vector. Condition, crisp-set.</p>
</dd>
<dt><code>B</code></dt><dd><p>a numeric vector. Condition, crisp-set.</p>
</dd>
<dt><code>C</code></dt><dd><p>a numeric vector. Condition, crisp-set.</p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector. Condition, crisp-set.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The authors of the data are Carsten Schnieder and Claudius Wagemann. The data are used in the on-line appendix of &quot;Set-Theoretic Methods for the Social Sciences&quot; to practice the truth table algorithm. Data are crisp-sets.</p>


<h3>References</h3>

<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>
<p>Schneider, C. Q., Wagemann, C., Quaranta, M. (2012) How To... Use Software for Set-Theoretic Analysis. Online Appendix to &quot;Set-Theoretic Methods for the Social Sciences&quot;. Available at www.cambridge.org/schneider-wagemann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SC)</code></pre>

<hr>
<h2 id='SCHF'>Schneider et. al. (2010)</h2><span id='topic+SCHF'></span>

<h3>Description</h3>

<p>The <code>SCHF</code> data frame has 76 observations and 7 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SCHF)</code></pre>


<h3>Format</h3>

<p>A data frame with 76 observations on the following 7 sets.
</p>

<dl>
<dt><code>EMP</code></dt><dd><p>a numeric vector. Condition, employment protection.</p>
</dd>
<dt><code>BARGAIN</code></dt><dd><p>a numeric vector. Condition, collective bargaining.</p>
</dd>
<dt><code>UNI</code></dt><dd><p>a numeric vector. Condition, university training.</p>
</dd>
<dt><code>OCCUP</code></dt><dd><p>a numeric vector. Condition, occupational training.</p>
</dd>
<dt><code>STOCK</code></dt><dd><p>a numeric vector. Condition, stock market size.</p>
</dd>
<dt><code>MA</code></dt><dd><p>a numeric vector. Condition, mergers and acquisitions.</p>
</dd>
<dt><code>EXPORT</code></dt><dd><p>a numeric vector. Outcome, export performance in high-tech industries.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data used by Schneider et. al. (2010) to explain capitalist variety 
and export performance in high-tech industries. Data are fuzzy-sets.</p>


<h3>References</h3>

<p>Schneider, M. R., Schulze-Bentrop, C., Paunescu, M. (2010) &quot;Mapping the institutional capital of high-tech firms: A fuzzy-set analysis of capitalist variety and export performance&quot;, Journal of International Business Studies 41, pp. 246-266.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SCHF)</code></pre>

<hr>
<h2 id='SCHLF'>Schneider et. al. (2010)</h2><span id='topic+SCHLF'></span>

<h3>Description</h3>

<p>The <code>SCHLF</code> data frame has 76 observations and 9 variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SCHLF)</code></pre>


<h3>Format</h3>

<p>A data frame with 76 observations on the following 9 variables.
</p>

<dl>
<dt><code>EMP</code></dt><dd><p>a numeric vector. Condition, employment protection.</p>
</dd>
<dt><code>BARGAIN</code></dt><dd><p>a numeric vector. Condition, collective bargaining.</p>
</dd>
<dt><code>UNI</code></dt><dd><p>a numeric vector. Condition, university training.</p>
</dd>
<dt><code>OCCUP</code></dt><dd><p>a numeric vector. Condition, occupational training.</p>
</dd>
<dt><code>STOCK</code></dt><dd><p>a numeric vector. Condition, stock market size.</p>
</dd>
<dt><code>MA</code></dt><dd><p>a numeric vector. Condition, mergers and acquisitions.</p>
</dd>
<dt><code>EXPORT</code></dt><dd><p>a numeric vector. Outcome, export performance in high-tech industries.</p>
</dd>
<dt><code>COUNTRY</code></dt><dd><p>a string vector. Name of the country in which the observation was made.</p>
</dd>
<dt><code>YEAR</code></dt><dd><p>a numeric vector. Year in which the observation was made.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data used by Schneider et. al. (2010) to explain capitalist variety 
and export performance in high-tech industries. Data is saved in the long format and the first 7 variables are fuzzy-sets.</p>


<h3>References</h3>

<p>Schneider, M. R., Schulze-Bentrop, C., Paunescu, M. (2010) &quot;Mapping the institutional capital of high-tech firms: A fuzzy-set analysis of capitalist variety and export performance&quot;, Journal of International Business Studies 41, pp. 246:266;
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SCHLF)</code></pre>

<hr>
<h2 id='SDC'>Selbst, disappearing necessary condition data</h2><span id='topic+SDC'></span>

<h3>Description</h3>

<p>The <code>SDC</code> data frame has 98 rows and 4 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SDC)</code></pre>


<h3>Format</h3>

<p>A data frame with 98 observations on the following 4 sets.
</p>

<dl>
<dt><code>A</code></dt><dd><p>a numeric vector. Condition, crisp-set.</p>
</dd>
<dt><code>B</code></dt><dd><p>a numeric vector. Condition, crisp-set.</p>
</dd>
<dt><code>C</code></dt><dd><p>a numeric vector. Condition, crisp-set.</p>
</dd>
<dt><code>Y</code></dt><dd><p>a numeric vector. Outcome, crisp-set.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The authors of the data are Carsten Schnieder and Claudius Wagemann. The data are used in the on-line appendix of &quot;Set-Theoretic Methods for the Social Sciences&quot; to show the disappearance of a necessary condition. Data are crisp-sets.</p>


<h3>References</h3>

<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>
<p>Schneider, C. Q., Wagemann, C., Quaranta, M. (2012) How To... Use Software for Set-Theoretic Analysis. Online Appendix to &quot;Set-Theoretic Methods for the Social Sciences&quot;. Available at www.cambridge.org/schneider-wagemann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SDC)</code></pre>

<hr>
<h2 id='SetMethods-package'>Functions for Set-Theoretic Multi-Method Research and Advanced QCA</h2><span id='topic+SetMethods-package'></span><span id='topic+SetMethods'></span>

<h3>Description</h3>

<p>This initiated as a package companion to the book by C. Q. Schneider and C. Wagemann &quot;Set-Theoretic Methods for the Social Sciences&quot;, Cambridge University Press. It has now grown to include functions for performing set-theoretic multi-method research (Schneider 2023, Schneider and Rohlfing 2013), QCA for clustered data (Garcia-Castro and Arino 2013), theory evaluation, Enhanced Standard Analysis, QCA Radar Charts, indirect calibration, robustness tests (Oana and Schneider - 2021) etc.. Additionally it includes data to replicate the examples in the book by Oana, I.E, C. Q. Schneider, and E. Thomann. Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge University Press and C. Q. Schneider and C. Wagemann &quot;Set Theoretic Methods for the Social Sciences&quot;, 2021, Cambridge University Press.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SetMethods</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 4.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-03-29</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package contains functions to perform set-theoretic multi-method research, theory evaluation, QCA for clustered data, Enhanced Standard Analyses, indirect calibration, calculate parameters of fit and produce XY plots and QCA Radar Charts, perform robustness tests, etc.. Furthermore, it contains all the data used in the Schneider and Wagemann (2012) and Oana, Schneider, and Thomann (2021) books.</p>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana [aut, cre], Juraj Medzihorsky [aut], Carsten Q. Schneider [aut], Mario Quaranta [aut]
</p>
<p>Maintainer: Ioana-Elena Oana &lt;ioana.oana@eui.eu&gt;
</p>


<h3>References</h3>

<p>Schneider, C. Q. (2023). Set-Theoretic Multi-Method Research: A Guide to Combining QCA and Case Studies. Cambridge: Cambridge University Press.
</p>
<p>Oana, I.E., Schneider, C. Q., Thomann, E. (2021). Qualitative Comparative Analysis (QCA) using R: A Beginner's Guide. Cambridge: Cambridge University Press.
</p>
<p>Oana, I.E., Schneider, C. Q. (2021). A Robustness Test Protocol for Applied QCA: Theory and R Software Application. Sociological Methods and Research. https://doi.org/10.1177/00491241211036158.
</p>
<p>Oana, I.E., Schndeider, C.Q. (2018) SetMethods: An Add-on R Package for Advanced QCA.The R Journal 10(1): 507-33.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge
</p>
<p>Schneider, C. Q., Rohlfing, I. (2013) Combining QCA and Process Tracing in Set-Theoretic Multi-Method Research. Sociological Methods Research 42(4): 559-597
</p>
<p>Haesebrouck, T. (2015) Pitfalls in QCA's consistency measure. Journal of Comparative Politics 2:65-80.
</p>
<p>Garcia-Castro, A., Arino, M. A.. (2013) A General Approach to Panel Data Set-Theoretic Research. COMPASSS Working Paper 2013-76
</p>

<hr>
<h2 id='skew.check'>
Function for checking how skewed sets are.
</h2><span id='topic+skew.check'></span>

<h3>Description</h3>

<p>A function that identifies how skewed sets are by returning the number and percentage of cases with higher than 0.5 fuzzy-set values. The function can also return histograms of the calibrated sets.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
skew.check(data, hist =  FALSE, main = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skew.check_+3A_data">data</code></td>
<td>

<p>A datafarme, a subset of a dataframe, or a vector (i.e. single column in a dataframe). The function should      be used for calibrated data and will give an error if the data contains uncalibrated scores. However, if you     have both calibrated and uncalibrated data in the same dataframe, it is possible to use the function only       for the calibrated subset of that data. 
</p>
</td></tr>
<tr><td><code id="skew.check_+3A_hist">hist</code></td>
<td>
<p>Logical. Should the function also return histograms of the sets?
</p>
</td></tr>
<tr><td><code id="skew.check_+3A_main">main</code></td>
<td>
<p>Title for the plot. When provided with a dataframe, the function automatically assigns the column name to the plot.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import your data. For example:

data(SCHF)

# Check skewness for the entire dataframe:

skew.check(SCHF)

# Check skewness for the column "EMP" in the dataframe:

skew.check(SCHF$EMP)

# Check skewness for the 5th column of the dataframe:

skew.check(SCHF[,5])

</code></pre>

<hr>
<h2 id='smmr'>
Function for performing set-theoretic multi-method research.
</h2><span id='topic+smmr'></span>

<h3>Description</h3>

<p>A function that selects best available cases for single case studies and best pairs of matching cases for comparative case studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smmr(results, outcome, sol = 1, match = NULL, 
      cases = NULL, max_pairs = 5, term = 1, nec.cond =NULL, necessity = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smmr_+3A_results">results</code></td>
<td>

<p>An object of class &quot;qca&quot;.
</p>
</td></tr>
<tr><td><code id="smmr_+3A_outcome">outcome</code></td>
<td>

<p>A character string with the name of the outcome. If the negated outcome is analyzed, one can 
also write for example outcome = &quot;~Y&quot;, however this is unnecessary as the values in the outcome 
will be taken from the appropriate minimized solution.
</p>
</td></tr>
<tr><td><code id="smmr_+3A_sol">sol</code></td>
<td>

<p>A vector where the first number indicates the number of the
conservative or parsimonious solution according to the order in the &quot;qca&quot; object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution
and i = intermediate solution.
</p>
</td></tr>
<tr><td><code id="smmr_+3A_match">match</code></td>
<td>

<p>Logical. Should comparative SMMR be used?
</p>
</td></tr>
<tr><td><code id="smmr_+3A_cases">cases</code></td>
<td>

<p>A numerical vector indicating the type of cases to be returned.
<br /> For single case studies for SUFFICIENCY: <br /> <code style="white-space: pre;">&#8288; 1 = typical cases,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 2 = typical cases for each focal conjunct in a sufficient term,&#8288;</code>   
<br /> <code style="white-space: pre;">&#8288; 3 = deviant consistency,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 4 = deviant coverage,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 5 = individually irrelevant,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 6 = all of the above;&#8288;</code>
<br /> For comparative case studies for SUFFICIENCY:<br /> <code style="white-space: pre;">&#8288; 1 = Typical-Typical for each focal conjuct in a sufficient term,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 2 = Typical-IIR for each focal conjuct in a sufficient term,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 3 = Typical-Dev.Cons.,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 4 = Dev.Cov.-IIR;&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 5 = Typical-Typical for each term;&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 6 = Typical-IIR for each term;&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 7 = all of the above;&#8288;</code>
<br /> For single case studies for NECESSITY: <br /> <code style="white-space: pre;">&#8288; 1 = typical cases,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 2 = deviant consistency,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 3 = deviant relevance,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 4 = all of the above;&#8288;</code>
<br /> For comparative case studies for NECESSITY:<br /> <code style="white-space: pre;">&#8288; 1 = Typical-Deviant Relevance ,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 2 = Typical-Deviant Consistency,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 3 = Typical-IIR,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 4 = Typical-Typical,&#8288;</code>
<br /> <code style="white-space: pre;">&#8288; 5 = all of the above;&#8288;</code>
</p>
</td></tr>
<tr><td><code id="smmr_+3A_max_pairs">max_pairs</code></td>
<td>

<p>Maximum number of pairs to extract.
</p>
</td></tr>
<tr><td><code id="smmr_+3A_term">term</code></td>
<td>

<p>A numeric vector where the first number indicates the number of the
term according to the order in the &quot;qca&quot; object.
</p>
</td></tr>
<tr><td><code id="smmr_+3A_nec.cond">nec.cond</code></td>
<td>

<p>A character vector specifying the necessity results obtained. This could be of the form &quot;A&quot;, &quot;A+B&quot;, or &quot;A*B&quot;, making sure no spaces are left between the name of the conditions and the Boolean operator. Notice than nec.cond can also be specified for sufficiency results in single SMMR typical cases for each focal conjunct in a sufficient term, and for comparative SMMR in typical-typical and typical-iir comparisons for each focal conjunct. Note that in the later case only expressions of the forms &quot;A&quot; or &quot;A+B&quot; are accepted. If dealing with a necessary condition of the form &quot;A*B&quot;, each of the individual conditions should be entered separately when performing analyses of sufficiency.
</p>
</td></tr>
<tr><td><code id="smmr_+3A_necessity">necessity</code></td>
<td>

<p>Logical. Should SMMR results for necessity be shown?
</p>
</td></tr>
<tr><td><code id="smmr_+3A_...">...</code></td>
<td>

<p>Deprecated arguments (neg.out, use.tilde)
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Schneider, C. Q., Rohlfing, I. 2013. Combining QCA and Process Tracing in Set-Theoretic Multi-Method Research. Sociological Methods and Research 42(4): 559-97
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import your data. For example:

data(SCHF)

## SUFFICIENCY SMMR examples:

# Get the parsimonious solution:

sol_yp &lt;- minimize(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE)

# Get typical cases for each focal conjunct in the third term of the parsimonious solution:

smmr(results = sol_yp, outcome = "EXPORT", match=FALSE, cases=2, term = 3)

# Get typical cases for each focal conjunct in the third term of the parsimonious solution
# and specifying STOCK as a necessary condition:

smmr(results = sol_yp, outcome = "EXPORT", 
      match=FALSE, cases=2, term = 3, nec.cond="STOCK")

# Get matching typical-typical cases for the second term of the parsimonious solution:

smmr(results = sol_yp, outcome = "EXPORT", match=TRUE, cases=1, term = 2)

# Get matching typical-DCN cases:

smmr(results = sol_yp, outcome = "EXPORT", match=TRUE, cases=3)

## NECESSITY SMMR examples:

# Imagine you found condition "STOCK + MA" is nececssary for outcome "EXPORT".

# Get typical cases for each disjunct of the necessary condition:

smmr(results = sol_yp, outcome = "EXPORT", match=FALSE, cases=1, 
     nec.cond = "STOCK+MA", necessity = TRUE)

# Get typical - deviant relevance cases for each disjunct of the necessary condition:

smmr(results = sol_yp, outcome = "EXPORT", match=TRUE, cases=1, 
     nec.cond = "STOCK+MA", necessity = TRUE)


</code></pre>

<hr>
<h2 id='stargazerSol'>
Function for exporting a sufficienct solution from minimize in latex, html, or text format.</h2><span id='topic+stargazerSol'></span>

<h3>Description</h3>

<p>Function for exporting a sufficienct solution from minimize in latex, html, or text format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stargazerSol(results,
           outcome,
           sol = 1,
           show.cases = FALSE,
           type = "latex", 
           title = "",
           out = NULL,
           digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stargazerSol_+3A_results">results</code></td>
<td>
<p>An object of class &quot;qca&quot;: a sufficient solution obtained with the minimize function.
</p>
</td></tr>
<tr><td><code id="stargazerSol_+3A_outcome">outcome</code></td>
<td>
<p>A character string with the name of the outcome in capital letters. When performing pimplot of the sufficient solution for the negated outcome one must only use the minimize() result from the sufficiency analysis of the negated outcome in the argument results. Changing the name in the argument outcome or using a tilde is not necessary, but recommended.
</p>
</td></tr>
<tr><td><code id="stargazerSol_+3A_sol">sol</code></td>
<td>
<p>A vector where the first number indicates the number of the conservative or parsimonious solution according to the order in the &quot;qca&quot; object. For more complicated structures of model ambiguity, the intermediate solution can also be specified by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution and i = intermediate solution.
</p>
</td></tr>
<tr><td><code id="stargazerSol_+3A_show.cases">show.cases</code></td>
<td>
<p> Logical. Should the names of cases be printed?
</p>
</td></tr>
<tr><td><code id="stargazerSol_+3A_type">type</code></td>
<td>
<p>character string that specifies what type of output the command should produce. The possible values are &quot;latex&quot; (default), &quot;html&quot;, &quot;text&quot;.
</p>
</td></tr>
<tr><td><code id="stargazerSol_+3A_title">title</code></td>
<td>
<p>title for the table.
</p>
</td></tr>
<tr><td><code id="stargazerSol_+3A_out">out</code></td>
<td>
<p>name of the file to be saved containing the extension (e.g. &quot;mysol.tex&quot;, &quot;mysol.txt&quot;)
</p>
</td></tr>
<tr><td><code id="stargazerSol_+3A_digits">digits</code></td>
<td>
<p>To how many digits should the parameters of fit be rounded up.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import your data. For example:

data(SCHF)

# Get the parsimonious solution:


sol_yp &lt;- minimize(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE)
                
# Print in latex format:

stargazerSol(sol_yp, "EXPORT")
</code></pre>

<hr>
<h2 id='stargazerTT'>
Function for exporting a sufficienct solution from minimize in latex, html, or text format.</h2><span id='topic+stargazerTT'></span>

<h3>Description</h3>

<p>Function for exporting a sufficienct solution from minimize in latex, html, or text format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stargazerTT(truthtable,
           show.cases = FALSE,
           type = "latex", 
           title = "",
           out = NULL,
           digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stargazerTT_+3A_truthtable">truthtable</code></td>
<td>
<p>A truth table obtained with the truthTable function.
</p>
</td></tr>
<tr><td><code id="stargazerTT_+3A_show.cases">show.cases</code></td>
<td>
<p> Logical. Should the names of cases be printed?
</p>
</td></tr>
<tr><td><code id="stargazerTT_+3A_type">type</code></td>
<td>
<p>character string that specifies what type of output the command should produce. The possible values are &quot;latex&quot; (default), &quot;html&quot;, &quot;text&quot;.
</p>
</td></tr>
<tr><td><code id="stargazerTT_+3A_title">title</code></td>
<td>
<p>title for the table.
</p>
</td></tr>
<tr><td><code id="stargazerTT_+3A_out">out</code></td>
<td>
<p>name of the file to be saved containing the extension (e.g. &quot;mysol.tex&quot;, &quot;mysol.txt&quot;)
</p>
</td></tr>
<tr><td><code id="stargazerTT_+3A_digits">digits</code></td>
<td>
<p>To how many digits should the parameters of fit be rounded up.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana</p>


<h3>References</h3>

<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import your data. For example:

data(SCHF)

# Get the truth table:

mytt &lt;- truthTable(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, complete = TRUE)

# Export as latex:
stargazerTT(mytt)

# Export as text:
stargazerTT(mytt, type = "text")

</code></pre>

<hr>
<h2 id='STUF'>Fake fuzzy-set student data.</h2><span id='topic+STUF'></span>

<h3>Description</h3>

<p>Fake fuzzy-set football practice data used for Chapter 4 of the Oana et al. (forthcoming) book.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(STUF)</code></pre>


<h3>Format</h3>

<p>A data frame with 17 observations on the following 3 variables. Conditions for arriving in time for football practice.
</p>

<dl>
<dt><code>A</code></dt><dd><p>Condition: Live close by</p>
</dd>
<dt><code>B</code></dt><dd><p>Condition: Arrive by bike</p>
</dd>
<dt><code>C</code></dt><dd><p>Condition: Come from punctual familie</p>
</dd>
<dt><code>D</code></dt><dd><p>Condition: Are seasoned players</p>
</dd>
<dt><code>E</code></dt><dd><p>Condition: Goalkeepers</p>
</dd>
<dt><code>Y</code></dt><dd><p>Outcome: Arrive on time for football practice</p>
</dd>
</dl>



<h3>References</h3>

<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(STUF)</code></pre>

<hr>
<h2 id='STUR'>Fake raw, student data.</h2><span id='topic+STUR'></span>

<h3>Description</h3>

<p>Fake raw, student data used for Chapter 2 of the Oana et al. (forthcoming) book.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(STUR)</code></pre>


<h3>Format</h3>

<p>A data frame with 17 observations on the following 3 variables.
</p>

<dl>
<dt><code>MARK</code></dt><dd><p>Cond.: student mark</p>
</dd>
<dt><code>PARTICIPATION</code></dt><dd><p>Cond.: quality and correctness of the student's comments in class,</p>
</dd>
<dt><code>PEERS</code></dt><dd><p>Cond.: extent to which the student engages with and helps peers during interactive in-class teaching exercises</p>
</dd>
</dl>



<h3>References</h3>

<p>Oana, Ioana-Elena, Carsten Q. Schneider, and Eva Thomann (forthcoming). Qualitative Comparative Analysis (QCA) using R: A Gentle Introduction. Cambridge: Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(STUR)</code></pre>

<hr>
<h2 id='theory.evaluation'>
Performs theory evaluation.
</h2><span id='topic+theory.evaluation'></span>

<h3>Description</h3>

<p>Function that returns membership of cases in the intersections between theory and 
the empirical solution in the form of a data frame, the names of cases in the intersections 
between theory and the empirical solution, and the parameters of fit for these intersections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theory.evaluation(theory, empirics, outcome, sol = 1, print.fit=FALSE, 
                  print.data=FALSE, consH = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theory.evaluation_+3A_theory">theory</code></td>
<td>

<p>A character string specifying the theory.
Unions of conditions are performed with a &quot;+&quot;, while intersections are performed with a &quot;*&quot;.
Conditions should be capitalized and negated conditions should be inserted with a &quot;~&quot;.
</p>
</td></tr>
<tr><td><code id="theory.evaluation_+3A_empirics">empirics</code></td>
<td>

<p>An object of class 'qca'. When performing analyses for the negated outcome, just use the 
results from the <code>minimize()</code> function for the negation of the outcome.
</p>
</td></tr>
<tr><td><code id="theory.evaluation_+3A_outcome">outcome</code></td>
<td>

<p>A character string with the name of the outcome. When performing analyses of the sufficient solution for the negated outcome one must only use the <code>minimize()</code> result from the sufficiency analysis of the negated outcome in the argument <code>empirics</code>. Changing the name in the argument <code>outcome</code> or using a tilde is not necessary.
</p>
</td></tr>
<tr><td><code id="theory.evaluation_+3A_sol">sol</code></td>
<td>

<p>A vector where the first number indicates the number of the conservative or parsimonious solution 
according to the order in the &quot;qca&quot; object.
For more complicated structures of model ambiguity, the intermediate solution can also be specified
by using a character string of the form &quot;c1p3i2&quot; where c = conservative solution, p = parsimonious solution
and i = intermediate solution.
</p>
</td></tr>
<tr><td><code id="theory.evaluation_+3A_print.data">print.data</code></td>
<td>

<p>Logical. Print also the membership of cases in all the intersections between theory and empirics?
</p>
</td></tr>
<tr><td><code id="theory.evaluation_+3A_print.fit">print.fit</code></td>
<td>

<p>Logical. Print also the parameters of fit for the intersections between theory and empirics?
</p>
</td></tr>
<tr><td><code id="theory.evaluation_+3A_consh">consH</code></td>
<td>

<p>Logical. Print also the Haesebrouck's consistency among the parameters of fit?
</p>
</td></tr>
<tr><td><code id="theory.evaluation_+3A_...">...</code></td>
<td>

<p>Deprecated arguments (use.tilde).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ioana-Elena Oana
</p>


<h3>References</h3>

<p>Ragin, C. C. 1987. The Comparative Method: Moving Beyond Qualitative and Quantitative Strategies. Berkeley: University of California Press, pp. 118-121
</p>
<p>Schneider, C. Q., Wagemann, C. 2012. Set-Theoretic Methods for the Social Sciences: A Guide to Qualitative Comparative Analysis. Cambridge: Cambridge University Press, chapter 11.3
</p>


<h3>See Also</h3>

<p><code><a href="QCA.html#topic+minimize">minimize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Import your data. For example:

data(SCHF)

# Get the intermediate solution:

sol_yi &lt;- minimize(SCHF, outcome = "EXPORT",
                conditions = c("EMP","BARGAIN","UNI","OCCUP","STOCK", "MA"),
                incl.cut = .9, 
                include = "?", 					   
                details = TRUE, show.cases = TRUE, dir.exp = c(0,0,0,0,0,0))


# Specify the theory. Let's assume the theory says that the 
# absence of EMP and the presence of MA is sufficient for EXPORT:

t&lt;-"~EMP*MA"


# Perform theory evaluation (get only the names of the cases and the Boolean intersections):

TH &lt;- theory.evaluation(theory = t, empirics = sol_yi, outcome = "EXPORT", sol = 1, 
                  print.data=FALSE, print.fit=FALSE)
TH

# Get only the case names:

TH$cases

# Or only the parameters of fit:

TH$fit
## End(Not run)

</code></pre>

<hr>
<h2 id='THOF'>Thomann (2015)</h2><span id='topic+THOF'></span>

<h3>Description</h3>

<p>The <code>THOF</code> data frame has 76 rows and 7 sets. The study analyses how European Union (EU) member states adapt EU directives
to domestic contexts during transposition and asks how and why fully compliant countries 'customize' EU directives.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(THOF)</code></pre>


<h3>Format</h3>

<p>A data frame with 76 observations on the following 7 sets.
</p>

<dl>
<dt><code>RESP</code></dt><dd><p>Cond.: Responsive regulatory mode</p>
</dd>
<dt><code>SAL</code></dt><dd><p>Cond.: Salient issue </p>
</dd>
<dt><code>RES</code></dt><dd><p>Cond.: Domestic resistance</p>
</dd>
<dt><code>VPO</code></dt><dd><p>Cond.: Many veto points </p>
</dd>
<dt><code>VPL</code></dt><dd><p>Cond.: Many veto players </p>
</dd>
<dt><code>COERC</code></dt><dd><p>Cond.: Coercive interventionist style</p>
</dd>
<dt><code>CUSTOM</code></dt><dd><p>Outcome: Extensive customization</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data used by Thomann (2015) to explain customization. Data are fuzzy-sets.</p>


<h3>References</h3>

<p>Thomann, E. 2015. Customizing Europe: Transposition as bottom-up implementation. Journal of European Public Policy 22(10): 1368-1387.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(THOF)</code></pre>

<hr>
<h2 id='VISC'>Vis (2009), crisp set data</h2><span id='topic+VISC'></span>

<h3>Description</h3>

<p>The <code>VISC</code> data frame has 25 rows and 4 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VISC)</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 4 sets.
</p>

<dl>
<dt><code>P</code></dt><dd><p>a numeric vector. Condition, weak political positions, with parties in government expecting losses at the next election.</p>
</dd>
<dt><code>S</code></dt><dd><p>a numeric vector. Condition, deteriorating economic situation.</p>
</dd>
<dt><code>R</code></dt><dd><p>a numeric vector. Condition, government dominated by parties from the right of the political spectrum.</p>
</dd>
<dt><code>U</code></dt><dd><p>a numeric vector. Outcome, unpopular reform.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are used by Vis (2009) to analyze the pursuit of unpopular reforms by governments. Data are crisp-sets.</p>


<h3>References</h3>

<p>Vis, B. (2009) &quot;Government and Unpopular Social Policy Reforms: Biting the Bullet or Steering Clear?&quot;, European Journal of Political Research 48, pp. 31-57.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VISC)</code></pre>

<hr>
<h2 id='VISF'>Vis (2009), fuzzy set data</h2><span id='topic+VISF'></span>

<h3>Description</h3>

<p>The <code>VISF</code> data frame has 25 rows and 4 sets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(VISF)</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 4 sets.
</p>

<dl>
<dt><code>p</code></dt><dd><p>a numeric vector. Condition, weak political positions, with parties in government expecting losses at the next election.</p>
</dd>
<dt><code>s</code></dt><dd><p>a numeric vector. Condition, deteriorating economic situation.</p>
</dd>
<dt><code>r</code></dt><dd><p>a numeric vector. Condition, government dominated by parties from the right of the political spectrum.</p>
</dd>
<dt><code>u</code></dt><dd><p>a numeric vector. Outcome, unpopular reform.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are used by Vis (2009) to analyze the pursuit of unpopular reforms by governments. Data are fuzzy-sets.</p>


<h3>References</h3>

<p>Vis, B. (2009) &quot;Government and Unpopular Social Policy Reforms: Biting the Bullet or Steering Clear?&quot;, European Journal of Political Research 48, pp. 31-57.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge University Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(VISF)</code></pre>

<hr>
<h2 id='xy.plot'>Function producing enhanced XY plots</h2><span id='topic+xy.plot'></span>

<h3>Description</h3>

<p>xy.plot produces XY plots and provides values for consistency, Haesebrouck's consistency, coverage, RoN, PRI. Several graphic parameters can be decided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy.plot(x, y, data, 
           labcol = "black",
           main = "XY plot", 
           ylab = "Outcome", 
           xlab = "Condition",
           necessity = FALSE,
           jitter = FALSE, 
           font = "sans",
           fontface = "italic", 
           fontsize = 3,
           labs = rownames(data),
           crisp = FALSE,
           shape = 19,
           consH = FALSE,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xy.plot_+3A_x">x</code></td>
<td>
<p>vector containing the condition.</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_y">y</code></td>
<td>
<p>vector containing the outcome.</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_data">data</code></td>
<td>
<p>The dataset used</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_labcol">labcol</code></td>
<td>
<p>color of the dots.</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_main">main</code></td>
<td>
<p>an overall title for the plot. The default is <code>"XY plot"</code>. See ?title.</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y-axis. The default is <code>"Outcome"</code>. See ?title.</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x-axis. The default is <code>"Condition"</code>. See ?title.</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_necessity">necessity</code></td>
<td>
<p>logical. Indicates if the parameters of fit are calculated for a sufficient or necessary condition. The default is <code>FALSE</code>, therefore it calculates the parameters of fit for sufficiency. To get the parameters of fit for necessary conditions set <code>necessity</code> as <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_jitter">jitter</code></td>
<td>

<p>Logical. Should labels be jitter to not overlap?
</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_font">font</code></td>
<td>

<p>Font of the labels. Accepts &quot;sans&quot;, &quot;serif&quot;, and &quot;mono&quot; fonts.
</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_fontface">fontface</code></td>
<td>

<p>Fontface of the labels. Accepts &quot;plain&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;bold.italic&quot;.
</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_fontsize">fontsize</code></td>
<td>

<p>Fontsize of the labels.
</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_labs">labs</code></td>
<td>
<p>the vector of case labels. The default is the rownames of the dataset.</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_crisp">crisp</code></td>
<td>
<p>Logical. Should a two-by-two table for crisp sets be returned?</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_shape">shape</code></td>
<td>
<p>The shape for the markers.</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_consh">consH</code></td>
<td>
<p>Logical. Should Haesebrouck's consistency be printed?</p>
</td></tr>
<tr><td><code id="xy.plot_+3A_...">...</code></td>
<td>
<p>Other internal arguments. Do not specify!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns an enhanced XY plot.</p>


<h3>Author(s)</h3>

<p>Mario Quaranta and Ioana-Elena Oana.</p>


<h3>References</h3>

<p>Haesebrouck, T. (2015) Pitfalls in QCA's consistency measure. Journal of Comparative Politics 2:65-80.
</p>
<p>Ragin, C. C. (2008) Redesigning Social Inquiry: Fuzzy Sets and Beyond. The Chicago University Press: Chicago and London.
</p>
<p>Schneider, C. Q., Wagemann, C. (2012) Set-Theoretic Methods for the Social Sciences, Cambridge Univeristy Press: Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the Schneider data:

data(SCHF)

# Plot of condition EMP as necessary for outcome EXPORT with case labels 
# and names for the plot and axes:

xy.plot("EMP", "EXPORT", data=SCHF, necessity = TRUE,
            main = "EMP as necessary for EXPORT", ylab = "EXPORT", xlab = "EMP")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
