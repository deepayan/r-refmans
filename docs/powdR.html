<!DOCTYPE html><html lang="en"><head><title>Help for package powdR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {powdR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#afps'><p>Automated full pattern summation</p></a></li>
<li><a href='#afps.powdRlib'><p>Automated full pattern summation</p></a></li>
<li><a href='#afsis'><p>Africa Soil Information Service (AfSIS) XRPD reference library</p></a></li>
<li><a href='#afsis_codes'><p>Original codes for the <code>afsis</code> reference patterns</p></a></li>
<li><a href='#afsis_regroup'><p>Regrouping structure for the Africa Soil Information Service (AfSIS) XRPD</p>
reference library</a></li>
<li><a href='#align_xy'><p>Align XRPD data to a given standard</p></a></li>
<li><a href='#align_xy.multiXY'><p>Align XRPD data in a multiXY object to a given standard</p></a></li>
<li><a href='#align_xy.XY'><p>Align XRPD data in an XY object to a given standard</p></a></li>
<li><a href='#as_multi_xy'><p>Create a multiXY object</p></a></li>
<li><a href='#as_multi_xy.data.frame'><p>Create a multiXY object from a list of XRPD data</p></a></li>
<li><a href='#as_multi_xy.list'><p>Create a multiXY object from a list of XRPD data</p></a></li>
<li><a href='#as_xy'><p>Create an XY object</p></a></li>
<li><a href='#bkg'><p>Fit a background to XRPD data</p></a></li>
<li><a href='#close_quant'><p>Close the phase concentration data within a <code>powdRfps</code> or</p>
<code>powdRafps</code> object</a></li>
<li><a href='#close_quant.powdRafps'><p>Close the phase concentration data within a <code>powdRafps</code> object</p></a></li>
<li><a href='#close_quant.powdRfps'><p>Close the phase concentration data within a <code>powdRfps</code> object</p></a></li>
<li><a href='#delta'><p>Calculate the Delta value for a fitted pattern</p></a></li>
<li><a href='#extract_xy'><p>Import and extract XY data from proprietary files</p></a></li>
<li><a href='#fps'><p>Full pattern summation</p></a></li>
<li><a href='#fps_lm'><p>Full pattern summation using linear regression</p></a></li>
<li><a href='#fps_lm.powdRlib'><p>Full pattern summation using linear regression</p></a></li>
<li><a href='#fps.powdRlib'><p>Full pattern summation</p></a></li>
<li><a href='#interpolate'><p>Interpolate an XY, multiXY or powdRlib object to a given 2theta scale.</p></a></li>
<li><a href='#interpolate.multiXY'><p>Interpolate a multiXY object onto a given 2theta scale.</p></a></li>
<li><a href='#interpolate.powdRlib'><p>Interpolate a <code>powdRlib</code> object onto a given 2theta scale.</p></a></li>
<li><a href='#interpolate.XY'><p>Interpolate an <code>XY</code> object onto a given 2theta scale.</p></a></li>
<li><a href='#merge.powdRlib'><p>Merge two powdRlib objects</p></a></li>
<li><a href='#minerals'><p>An example powdRlib reference library</p></a></li>
<li><a href='#minerals_phases'><p>Example phases table for a reference library</p></a></li>
<li><a href='#minerals_regroup'><p>Example regrouping structure for the <code>minerals</code> data</p></a></li>
<li><a href='#minerals_xrd'><p>Example xrd table for a reference library</p></a></li>
<li><a href='#multi_xy_to_df'><p>Convert a multiXY object to a data frame.</p></a></li>
<li><a href='#multi_xy_to_df.multiXY'><p>Convert a multiXY object to a data frame.</p></a></li>
<li><a href='#omit_std'><p>Omit the internal standard from phase concentration data within a <code>powdRfps</code> or</p>
<code>powdRafps</code> object</a></li>
<li><a href='#omit_std.powdRafps'><p>Omit the internal standard from phase concentration data within a <code>powdRafps</code> object</p></a></li>
<li><a href='#omit_std.powdRfps'><p>Omit the internal standard from phase concentration data within a <code>powdRfps</code> object</p></a></li>
<li><a href='#plot.multiXY'><p>Plotting a multiXY object</p></a></li>
<li><a href='#plot.powdRafps'><p>Plotting elements of a powdRafps object</p></a></li>
<li><a href='#plot.powdRbkg'><p>Plotting a powdRbkg object</p></a></li>
<li><a href='#plot.powdRfps'><p>Plotting elements of a powdRfps object</p></a></li>
<li><a href='#plot.powdRlib'><p>Plotting elements of a powdRlib object</p></a></li>
<li><a href='#plot.powdRlm'><p>Plotting elements of a powdRlm object</p></a></li>
<li><a href='#plot.XY'><p>Plotting an XY object</p></a></li>
<li><a href='#powdR'><p>powdR: Full Pattern Summation of X-Ray Powder Diffraction Data</p></a></li>
<li><a href='#powdRlib'><p>Create an XRPD reference library</p></a></li>
<li><a href='#r'><p>Calculate the R value for a fitted pattern</p></a></li>
<li><a href='#read_xy'><p>Read ASCII XY data</p></a></li>
<li><a href='#regroup'><p>regroup</p></a></li>
<li><a href='#regroup.powdRafps'><p>regroup</p></a></li>
<li><a href='#regroup.powdRfps'><p>regroup</p></a></li>
<li><a href='#rockjock'><p>RockJock reference library</p></a></li>
<li><a href='#rockjock_mixtures'><p>RockJock synthetic mixtures</p></a></li>
<li><a href='#rockjock_regroup'><p>Regrouping structure for the rockjock reference library</p></a></li>
<li><a href='#rockjock_weights'><p>Mineral concentrations of the <code>rockjock_mixtures</code> data</p></a></li>
<li><a href='#run_bkg'><p>Run the background fitting shiny app</p></a></li>
<li><a href='#run_powdR'><p>Run the powdR shiny app</p></a></li>
<li><a href='#rwp'><p>Calculate the Rwp value for a fitted pattern</p></a></li>
<li><a href='#soils'><p>Example soil XRPD data</p></a></li>
<li><a href='#subset.powdRlib'><p>Subset a powdRlib object</p></a></li>
<li><a href='#summarise_mineralogy'><p>Summarise the mineralogy from multiple powdRfps and powdRafps outputs</p></a></li>
<li><a href='#tth_transform'><p>Transform a two theta axis between wavelengths</p></a></li>
<li><a href='#xrpd_pca'><p>PCA of XRPD data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Full Pattern Summation of X-Ray Powder Diffraction Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-08-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Butler &lt;benjamin.butler@hutton.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Full pattern summation of X-ray powder diffraction data as
  described in Chipera and Bish (2002) &lt;<a href="https://doi.org/10.1107%2FS0021889802017405">doi:10.1107/S0021889802017405</a>&gt; and
  Butler and Hillier (2021) &lt;<a href="https://doi.org/10.1016%2Fj.cageo.2020.104662">doi:10.1016/j.cageo.2020.104662</a>&gt;.
  Derives quantitative estimates of crystalline and amorphous phase
  concentrations in complex mixtures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/benmbutler/powdR">https://github.com/benmbutler/powdR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/benmbutler/powdR/issues">https://github.com/benmbutler/powdR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr (&ge; 1.8.6), reshape (&ge; 0.8.8), plotly (&ge; 4.9.2.1),
ggplot2 (&ge; 3.3.0), stats (&ge; 3.4.3), utils (&ge; 3.4.3), ggpubr
(&ge; 0.2.5), shiny (&ge; 1.4.0.2), DT (&ge; 0.13), nnls (&ge; 1.4),
shinyWidgets (&ge; 0.5.1), baseline (&ge; 1.2), tidyr (&ge; 1.0.2),
FactoMineR (&ge; 2.3), factoextra (&ge; 1.0.7), rxylib (&ge; 0.2.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-13 14:59:17 UTC; bb42885</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Butler [aut, cre],
  Stephen Hillier [aut],
  Dylan Beaudette [ctb],
  Dennis Eberl [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-13 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='afps'>Automated full pattern summation</h2><span id='topic+afps'></span>

<h3>Description</h3>

<p><code>afps</code> returns estimates of phase concentrations using automated full pattern
summation of X-ray powder diffraction data. It is designed for high-throughput cases
involving mineral quantification from large reference libraries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afps(
  lib,
  smpl,
  harmonise,
  solver,
  obj,
  refs,
  std,
  force,
  std_conc,
  omit_std,
  closed,
  normalise,
  tth_align,
  align,
  manual_align,
  shift,
  tth_fps,
  lod,
  amorphous,
  amorphous_lod,
  weighting,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="afps_+3A_lib">lib</code></td>
<td>
<p>A <code>powdRlib</code> object representing the reference library. Created using the
<code>powdRlib</code> constructor function.</p>
</td></tr>
<tr><td><code id="afps_+3A_smpl">smpl</code></td>
<td>
<p>A data frame. First column is 2theta, second column is counts</p>
</td></tr>
<tr><td><code id="afps_+3A_harmonise">harmonise</code></td>
<td>
<p>logical parameter defining whether to harmonise the <code>lib</code> and <code>smpl</code>.
Default = <code>TRUE</code>. Harmonises to the intersecting 2theta range at the coarsest resolution
available using natural splines.</p>
</td></tr>
<tr><td><code id="afps_+3A_solver">solver</code></td>
<td>
<p>The optimisation routine to be used. One of <code>"BFGS", "Nelder-Mead",
or "CG"</code>. Default = <code>"BFGS"</code>.</p>
</td></tr>
<tr><td><code id="afps_+3A_obj">obj</code></td>
<td>
<p>The objective function to minimise. One of <code>"Delta", "R", "Rwp"</code>.
Default = <code>"Rwp"</code>. See Chipera and Bish (2002) and page 247 of Bish and Post (1989)
for definitions of these functions.</p>
</td></tr>
<tr><td><code id="afps_+3A_refs">refs</code></td>
<td>
<p>A character string of reference pattern IDs or names from the specified library.
The IDs or names supplied must be present within the <code>lib$phases$phase_id</code> or
<code>lib$phases$phase_name</code> columns. If missing from the function call then all phases in
the reference library will be used.</p>
</td></tr>
<tr><td><code id="afps_+3A_std">std</code></td>
<td>
<p>The phase ID (e.g. &quot;QUA.1&quot;) to be used as internal
standard. Must match an ID provided in the <code>refs</code> parameter.</p>
</td></tr>
<tr><td><code id="afps_+3A_force">force</code></td>
<td>
<p>An optional string of phase ID's or names specifying which phases should be forced to
remain throughout the automated full pattern summation. The ID's or names supplied must be present
within the <code>lib$phases$phase_id</code> or <code>lib$phases$phase_name</code> columns.</p>
</td></tr>
<tr><td><code id="afps_+3A_std_conc">std_conc</code></td>
<td>
<p>The concentration of the internal standard (if known) in weight percent. If
unknown then either omit the argument from the function call of use <code>std_conc = NA</code>, in which
case it will be assumed that all phases sum to 100 percent (default).</p>
</td></tr>
<tr><td><code id="afps_+3A_omit_std">omit_std</code></td>
<td>
<p>A logical parameter to be used when the <code>std_conc</code> argument is defined. When
<code>omit_std = TRUE</code> the phase concentrations are recomputed to account for value supplied in
<code>std_conc</code>. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="afps_+3A_closed">closed</code></td>
<td>
<p>A logical parameter to be used when the <code>std_conc</code> argument is defined and
<code>omit_std = TRUE</code>. When <code>closed = TRUE</code> the internal standard concentration is removed
and the remaining phase concentrations closed to sum to 100 percent. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="afps_+3A_normalise">normalise</code></td>
<td>
<p>deprecated. Please use the <code>omit_std</code> and <code>closed</code> arguments instead.</p>
</td></tr>
<tr><td><code id="afps_+3A_tth_align">tth_align</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
alignment (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="afps_+3A_align">align</code></td>
<td>
<p>The maximum shift that is allowed during initial 2theta
alignment (degrees). Default = 0.1.</p>
</td></tr>
<tr><td><code id="afps_+3A_manual_align">manual_align</code></td>
<td>
<p>A logical operator denoting whether to optimise the alignment within the
negative/position 2theta range defined in the <code>align</code> argument, or to use the specified
value of the <code>align</code> argument for alignment of the sample to the standards. Default
= <code>FALSE</code>, i.e. alignment is optimised.</p>
</td></tr>
<tr><td><code id="afps_+3A_shift">shift</code></td>
<td>
<p>A single numeric value denoting the maximum (positive or negative) shift,
in degrees 2theta, that is allowed during the shifting of selected phases. Default = 0.</p>
</td></tr>
<tr><td><code id="afps_+3A_tth_fps">tth_fps</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
automated full pattern summation (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="afps_+3A_lod">lod</code></td>
<td>
<p>Optional parameter used to define the limit of detection (in weight percent) of the internal standard
(i.e. the phase provided in the <code>std</code> argument). The <code>lod</code> value is used to estimate the lod of other
phases during the fitting process and hence remove reference patterns that are considered below detection limit.
Default = 0.1. If <code>lod = 0</code> then limits of detection are not computed.</p>
</td></tr>
<tr><td><code id="afps_+3A_amorphous">amorphous</code></td>
<td>
<p>A character string of any phase IDs that should be treated as amorphous. These must
match phases present in <code>lib$phases$phase_id</code>.</p>
</td></tr>
<tr><td><code id="afps_+3A_amorphous_lod">amorphous_lod</code></td>
<td>
<p>Optional parameter used to exclude amorphous phases if they are below this
specified limit (percent). Must be between 0 and 100. Default = 0.</p>
</td></tr>
<tr><td><code id="afps_+3A_weighting">weighting</code></td>
<td>
<p>an optional 2 column data frame specifying the 2theta values in the first
column and a numeric weighting vector in the second column that specifies areas of the pattern
to either emphasise (values &gt; 1) or omit (values = 0) when minimising the objective function
defined in the <code>obj</code> argument. Use this weighting parameter with caution. The default
is simply a weighting vector where all values are 1, which hence has no effect on the computed
objective function.</p>
</td></tr>
<tr><td><code id="afps_+3A_...">...</code></td>
<td>
<p>Other parameters passed to methods e.g. <code>afps.powdRlib</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies automated full pattern summation to an XRPD
measurement to quantify phase concentrations. Requires a <code>powdRlib</code> library of
reference patterns with reference intensity ratios in order to derive
mineral concentrations. Details provided in Butler and Hillier (2021).
</p>


<h3>Value</h3>

<p>a powdRafps object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the count intensities of fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the count intensities of original XRPD measurement (aligned)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped and summed by phase_name</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>References</h3>

<p>Butler, B. M., Hillier, S., 2021.powdR: An R package for quantitative mineralogy using full pattern
summation of X-ray powder diffraction data. Comp. Geo. 147, 104662. doi:10.1016/j.cageo.2020.104662
</p>
<p>Chipera, S.J., Bish, D.L., 2013. Fitting Full X-Ray Diffraction Patterns for Quantitative Analysis:
A Method for Readily Quantifying Crystalline and Disordered Phases. Adv. Mater. Phys. Chem. 03, 47-53.
doi:10.4236/ampc.2013.31A007
</p>
<p>Chipera, S.J., Bish, D.L., 2002. FULLPAT: A full-pattern quantitative analysis program for X-ray powder
diffraction using measured and calculated patterns. J. Appl. Crystallogr. 35, 744-749.
doi:10.1107/S0021889802017405
</p>
<p>Eberl, D.D., 2003. User's guide to RockJock - A program for determining quantitative mineralogy from
powder X-ray diffraction data. Boulder, CA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

# Load the soils data
data(soils)

## Not run: 
afps_sand &lt;-  afps(lib = minerals,
                 smpl = soils$sandstone,
                 std = "QUA.2",
                 align = 0.2,
                 lod = 0.2,
                 amorphous = "ORG",
                 amorphous_lod = 1)

afps_lime &lt;- afps(lib = minerals,
                smpl = soils$limestone,
                std = "QUA.2",
                align = 0.2,
                lod = 0.2,
                amorphous = "ORG",
                amorphous_lod = 1)

afps_granite &lt;- afps(lib = minerals,
                   smpl = soils$granite,
                   std = "QUA.2",
                   align = 0.2,
                   lod = 0.2,
                   amorphous = "ORG",
                   amorphous_lod = 1)

#Alternatively run all 3 at once using lapply

afps_soils &lt;- lapply(soils, afps,
                     lib = minerals,
                     std = "QUA.2",
                     align = 0.2,
                     lod = 0.2,
                     amorphous = "ORG",
                     amorphous_lod = 1)

#Automated quantification using the rockjock library

data(rockjock)
data(rockjock_mixtures)

#This takes a few minutes to run
rockjock_a1 &lt;- afps(lib = rockjock,
                    smpl = rockjock_mixtures$Mix1,
                    std = "CORUNDUM",
                    align = 0.3,
                    lod = 1)

#Quantifying the same sample but defining the internal standard
#concentration (also takes a few minutes to run):
rockjock_a1s &lt;- afps(lib = rockjock,
                     smpl = rockjock_mixtures$Mix1,
                     std = "CORUNDUM",
                     std_conc = 20,
                     align = 0.3,
                     lod = 1)


## End(Not run)
</code></pre>

<hr>
<h2 id='afps.powdRlib'>Automated full pattern summation</h2><span id='topic+afps.powdRlib'></span>

<h3>Description</h3>

<p><code>afps</code> returns estimates of phase concentrations using automated full pattern
summation of X-ray powder diffraction data. It is designed for high-throughput cases
involving mineral quantification from large reference libraries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRlib'
afps(
  lib,
  smpl,
  harmonise,
  solver,
  obj,
  refs,
  std,
  force,
  std_conc,
  omit_std,
  closed,
  normalise,
  tth_align,
  align,
  manual_align,
  shift,
  tth_fps,
  lod,
  amorphous,
  amorphous_lod,
  weighting,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="afps.powdRlib_+3A_lib">lib</code></td>
<td>
<p>A <code>powdRlib</code> object representing the reference library. Created using the
<code>powdRlib</code> constructor function.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_smpl">smpl</code></td>
<td>
<p>A data frame. First column is 2theta, second column is counts</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_harmonise">harmonise</code></td>
<td>
<p>logical parameter defining whether to harmonise the <code>lib</code> and <code>smpl</code>.
Default = <code>TRUE</code>. Harmonises to the intersecting 2theta range at the coarsest resolution
available using natural splines.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_solver">solver</code></td>
<td>
<p>The optimisation routine to be used. One of <code>"BFGS", "Nelder-Mead",
or "CG"</code>. Default = <code>"BFGS"</code>.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_obj">obj</code></td>
<td>
<p>The objective function to minimise. One of <code>"Delta", "R", "Rwp"</code>.
Default = <code>"Rwp"</code>. See Chipera and Bish (2002) and page 247 of Bish and Post (1989)
for definitions of these functions.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_refs">refs</code></td>
<td>
<p>A character string of reference pattern IDs or names from the specified library.
The IDs or names supplied must be present within the <code>lib$phases$phase_id</code> or
<code>lib$phases$phase_name</code> columns. If missing from the function call then all phases in
the reference library will be used.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_std">std</code></td>
<td>
<p>The phase ID (e.g. &quot;QUA.1&quot;) to be used as internal
standard. Must match an ID provided in the <code>refs</code> parameter.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_force">force</code></td>
<td>
<p>An optional string of phase ID's or names specifying which phases should be forced to
remain throughout the automated full pattern summation. The ID's or names supplied must be present
within the <code>lib$phases$phase_id</code> or <code>lib$phases$phase_name</code> columns.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_std_conc">std_conc</code></td>
<td>
<p>The concentration of the internal standard (if known) in weight percent. If
unknown then either omit the argument from the function call of use <code>std_conc = NA</code>, in which
case it will be assumed that all phases sum to 100 percent (default).</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_omit_std">omit_std</code></td>
<td>
<p>A logical parameter to be used when the <code>std_conc</code> argument is defined. When
<code>omit_std = TRUE</code> the phase concentrations are recomputed to account for value supplied in
<code>std_conc</code>. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_closed">closed</code></td>
<td>
<p>A logical parameter to be used when the <code>std_conc</code> argument is defined and
<code>omit_std = TRUE</code>. When <code>closed = TRUE</code> the internal standard concentration is removed
and the remaining phase concentrations closed to sum to 100 percent. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_normalise">normalise</code></td>
<td>
<p>deprecated. Please use the <code>omit_std</code> and <code>closed</code> arguments instead.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_tth_align">tth_align</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
alignment (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_align">align</code></td>
<td>
<p>The maximum shift that is allowed during initial 2theta
alignment (degrees). Default = 0.1.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_manual_align">manual_align</code></td>
<td>
<p>A logical operator denoting whether to optimise the alignment within the
negative/position 2theta range defined in the <code>align</code> argument, or to use the specified
value of the <code>align</code> argument for alignment of the sample to the standards. Default
= <code>FALSE</code>, i.e. alignment is optimised.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_shift">shift</code></td>
<td>
<p>A single numeric value denoting the maximum (positive or negative) shift,
in degrees 2theta, that is allowed during the shifting of selected phases. Default = 0.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_tth_fps">tth_fps</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
automated full pattern summation (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_lod">lod</code></td>
<td>
<p>Optional parameter used to define the limit of detection (in weight percent) of the internal standard
(i.e. the phase provided in the <code>std</code> argument). The <code>lod</code> value is used to estimate the lod of other
phases during the fitting process and hence remove reference patterns that are considered below detection limit.
Default = 0.1. If <code>lod = 0</code> then limits of detection are not computed.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_amorphous">amorphous</code></td>
<td>
<p>A character string of any phase IDs that should be treated as amorphous. These must
match phases present in <code>lib$phases$phase_id</code>.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_amorphous_lod">amorphous_lod</code></td>
<td>
<p>Optional parameter used to exclude amorphous phases if they are below this
specified limit (percent). Must be between 0 and 100. Default = 0.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_weighting">weighting</code></td>
<td>
<p>an optional 2 column data frame specifying the 2theta values in the first
column and a numeric weighting vector in the second column that specifies areas of the pattern
to either emphasise (values &gt; 1) or omit (values = 0) when minimising the objective function
defined in the <code>obj</code> argument. Use this weighting parameter with caution. The default
is simply a weighting vector where all values are 1, which hence has no effect on the computed
objective function.</p>
</td></tr>
<tr><td><code id="afps.powdRlib_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies automated full pattern summation to an XRPD
measurement to quantify phase concentrations. Requires a <code>powdRlib</code> library of
reference patterns with reference intensity ratios in order to derive
mineral concentrations. Details provided in Butler and Hillier (2021).
</p>


<h3>Value</h3>

<p>a powdRafps object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the count intensities of fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the count intensities of original XRPD measurement (aligned)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped and summed by phase_name</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>References</h3>

<p>Butler, B. M., Hillier, S., 2021.powdR: An R package for quantitative mineralogy using full pattern
summation of X-ray powder diffraction data. Comp. Geo. 147, 104662. doi:10.1016/j.cageo.2020.104662
</p>
<p>Bish, D.L., Post, J.E., 1989. Modern powder diffraction. Mineralogical Society of America.
</p>
<p>Chipera, S.J., Bish, D.L., 2013. Fitting Full X-Ray Diffraction Patterns for Quantitative Analysis:
A Method for Readily Quantifying Crystalline and Disordered Phases. Adv. Mater. Phys. Chem. 03, 47-53.
doi:10.4236/ampc.2013.31A007
</p>
<p>Chipera, S.J., Bish, D.L., 2002. FULLPAT: A full-pattern quantitative analysis program for X-ray powder
diffraction using measured and calculated patterns. J. Appl. Crystallogr. 35, 744-749.
doi:10.1107/S0021889802017405
</p>
<p>Eberl, D.D., 2003. User's guide to RockJock - A program for determining quantitative mineralogy from
powder X-ray diffraction data. Boulder, CA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

# Load the soils data
data(soils)

## Not run: 
afps_sand &lt;-  afps(lib = minerals,
                 smpl = soils$sandstone,
                 std = "QUA.2",
                 align = 0.2,
                 lod = 0.2,
                 amorphous = "ORG",
                 amorphous_lod = 1)

afps_lime &lt;- afps(lib = minerals,
                smpl = soils$limestone,
                std = "QUA.2",
                align = 0.2,
                lod = 0.2,
                amorphous = "ORG",
                amorphous_lod = 1)

afps_granite &lt;- afps(lib = minerals,
                   smpl = soils$granite,
                   std = "QUA.2",
                   align = 0.2,
                   lod = 0.2,
                   amorphous = "ORG",
                   amorphous_lod = 1)

#Alternatively run all 3 at once using lapply

afps_soils &lt;- lapply(soils, afps,
                     lib = minerals,
                     std = "QUA.2",
                     align = 0.2,
                     lod = 0.2,
                     amorphous = "ORG",
                     amorphous_lod = 1)

#Automated quantification using the rockjock library

data(rockjock)
data(rockjock_mixtures)

#This takes a few minutes to run
rockjock_a1 &lt;- afps(lib = rockjock,
                    smpl = rockjock_mixtures$Mix1,
                    std = "CORUNDUM",
                    align = 0.3,
                    lod = 1)

#Quantifying the same sample but defining the internal standard
#concentration (also takes a few minutes to run):
rockjock_a1s &lt;- afps(lib = rockjock,
                     smpl = rockjock_mixtures$Mix1,
                     std = "CORUNDUM",
                     std_conc = 20,
                     align = 0.3,
                     lod = 1)


## End(Not run)
</code></pre>

<hr>
<h2 id='afsis'>Africa Soil Information Service (AfSIS) XRPD reference library</h2><span id='topic+afsis'></span>

<h3>Description</h3>

<p>A <code>powdRlib</code> object of 21 pure reference patterns and associated reference
intensity ratios for a range of common soil minerals. Data were collected on a Bruker D2
Phaser using Cu K-alpha radiation. All patterns have been normalised to 10,000
counts and reference intensity ratios transformed so that all are relative
to that of corundum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afsis
</code></pre>


<h3>Format</h3>

<p>A powdRlib object of 3 components
</p>

<dl>
<dt>xrd</dt><dd><p>A dataframe of all the count intensities of all reference patterns. Column names denote the
unique phase ID of each reference pattern</p>
</dd>
<dt>tth</dt><dd><p>A vector of the 2theta scale for all reference patterns in the library</p>
</dd>
<dt>phases</dt><dd><p>A dataframe the phase IDs, names and reference intensity
ratios (RIR)</p>
</dd>
</dl>


<hr>
<h2 id='afsis_codes'>Original codes for the <code>afsis</code> reference patterns</h2><span id='topic+afsis_codes'></span>

<h3>Description</h3>

<p>A data frame detailing the original codes associated with the <code>afsis</code> reference
patterns prior to their addition to powdR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afsis_codes
</code></pre>


<h3>Format</h3>

<p>An 2 column data frame. First column contains the phase IDs from <code>afsis$phase_id</code>
and the second column the original IDs prior to the inclusion in powdR.
</p>

<hr>
<h2 id='afsis_regroup'>Regrouping structure for the Africa Soil Information Service (AfSIS) XRPD
reference library</h2><span id='topic+afsis_regroup'></span>

<h3>Description</h3>

<p>A data frame containing an example re-grouping structure for the <code>afsis</code>
reference library, which results in a slightly coarser description of clay
minerals and Fe/Ti-(hydr)oxides in <code>powdRfps</code> or <code>powdRafps</code> objects
when used with <code>regroup()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afsis_regroup
</code></pre>


<h3>Format</h3>

<p>A data frame with three columns:
</p>

<dl>
<dt>phase_id</dt><dd><p>the phase IDs present in <code>afsis$phases$phase_id</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>phase_name_grouped</dt><dd><p>The phase names that constitute the first
regrouping structure.</p>
</dd>
<dt>phase_name_grouped2</dt><dd><p>The phase names that constitute the second
regrouping structure</p>
</dd>
</dl>


<hr>
<h2 id='align_xy'>Align XRPD data to a given standard</h2><span id='topic+align_xy'></span>

<h3>Description</h3>

<p>See <code>?align_xy.XY</code> and <code>align_xy.multiXY</code> for
method-specific details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_xy(x, std, xmin, xmax, xshift, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align_xy_+3A_x">x</code></td>
<td>
<p>an <code>XY</code> or <code>multiXY</code> object.</p>
</td></tr>
<tr><td><code id="align_xy_+3A_std">std</code></td>
<td>
<p>a dataframe of the chosen standard that each
sample will be aligned to (column 1 = 2theta, column 2 = counts)</p>
</td></tr>
<tr><td><code id="align_xy_+3A_xmin">xmin</code></td>
<td>
<p>the minimum 2theta value used during alignment</p>
</td></tr>
<tr><td><code id="align_xy_+3A_xmax">xmax</code></td>
<td>
<p>the maximum 2theta value used during alignment</p>
</td></tr>
<tr><td><code id="align_xy_+3A_xshift">xshift</code></td>
<td>
<p>the maximum (positive and negative) 2theta shift
that is allowed during alignment</p>
</td></tr>
<tr><td><code id="align_xy_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>XY</code> or <code>multiXY</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load soils xrd data
data(soils)

#Load minerals library
data(minerals)

## Not run: 
#Create a standard quartz pattern to align to
quartz &lt;- data.frame(tth = minerals$tth,
                     counts = minerals$xrd$QUA.1)

#Plot the main quartz peak prior to alignment
plot(soils, wavelength = "Cu",
     xlim = c(26,27),
     normalise = TRUE)

#align data
aligned &lt;- align_xy(soils,
                    std = quartz,
                    xmin = 10,
                    xmax = 60,
                    xshift = 0.2)

#replot data
plot(aligned, wavelength = "Cu",
     xlim = c(26,27),
     normalise = TRUE)

#Alternatively try with a single XY object

unaligned &lt;- as_multi_xy(list("quartz" = quartz,
                             "sandstone" = soils$sandstone))

plot(unaligned, wav = "Cu",
     xlim = c(26,27), normalise = TRUE)

sandstone_a &lt;- align_xy(soils$sandstone,
                        std = quartz,
                        xmin = 10,
                        xmax = 60,
                        xshift = 0.3)

aligned &lt;- as_multi_xy(list("quartz" = quartz,
                            "sandstone" = sandstone_a))

plot(aligned, wav = "Cu",
     xlim = c(26,27), normalise = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='align_xy.multiXY'>Align XRPD data in a multiXY object to a given standard</h2><span id='topic+align_xy.multiXY'></span>

<h3>Description</h3>

<p><code>align_xy.multiXY</code> takes a multiXY object and aligns
each of the XY data frames within it to a given standard.
An optimisation routine is used that computes a suitable
linear shift. After all samples have been aligned,
the function harmonises the data to a single 2theta scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiXY'
align_xy(x, std, xmin, xmax, xshift, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align_xy.multiXY_+3A_x">x</code></td>
<td>
<p>a <code>multiXY</code> object.</p>
</td></tr>
<tr><td><code id="align_xy.multiXY_+3A_std">std</code></td>
<td>
<p>a dataframe of the chosen standard that each
sample will be aligned to (column 1 = 2theta, column 2 = counts)</p>
</td></tr>
<tr><td><code id="align_xy.multiXY_+3A_xmin">xmin</code></td>
<td>
<p>the minimum 2theta value used during alignment</p>
</td></tr>
<tr><td><code id="align_xy.multiXY_+3A_xmax">xmax</code></td>
<td>
<p>the maximum 2theta value used during alignment</p>
</td></tr>
<tr><td><code id="align_xy.multiXY_+3A_xshift">xshift</code></td>
<td>
<p>the maximum (positive and negative) 2theta shift
that is allowed during alignment</p>
</td></tr>
<tr><td><code id="align_xy.multiXY_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>multiXY</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load soils xrd data
data(soils)

#Load minerals library
data(minerals)

## Not run: 
#Create a standard quartz pattern to align to
quartz &lt;- data.frame(tth = minerals$tth,
                     counts = minerals$xrd$QUA.1)

#Plot the main quartz peak prior to alignment
plot(soils, wavelength = "Cu",
     xlim = c(26,27),
     normalise = TRUE)

#align data
aligned &lt;- align_xy(soils,
                    std = quartz,
                    xmin = 10,
                    xmax = 60,
                    xshift = 0.2)

#replot data
plot(aligned, wavelength = "Cu",
     xlim = c(26,27),
     normalise = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='align_xy.XY'>Align XRPD data in an XY object to a given standard</h2><span id='topic+align_xy.XY'></span>

<h3>Description</h3>

<p><code>align_xy.XY</code> takes an XY object and aligns
it to a given standard. An optimisation routine is used
that computes a suitable linear shift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XY'
align_xy(x, std, xmin, xmax, xshift, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align_xy.XY_+3A_x">x</code></td>
<td>
<p>an <code>XY</code> object.</p>
</td></tr>
<tr><td><code id="align_xy.XY_+3A_std">std</code></td>
<td>
<p>a dataframe of the chosen standard that each
sample is aligned to (column 1 = 2theta, column 2 = counts)</p>
</td></tr>
<tr><td><code id="align_xy.XY_+3A_xmin">xmin</code></td>
<td>
<p>the minimum 2theta value used during alignment</p>
</td></tr>
<tr><td><code id="align_xy.XY_+3A_xmax">xmax</code></td>
<td>
<p>the maximum 2theta value used during alignment</p>
</td></tr>
<tr><td><code id="align_xy.XY_+3A_xshift">xshift</code></td>
<td>
<p>the maximum (positive and negative) 2theta shift
that is allowed during alignment</p>
</td></tr>
<tr><td><code id="align_xy.XY_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>XY</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load soils xrd data
data(soils)

#Load minerals library
data(minerals)

## Not run: 

#Create a standard quartz pattern to align to
quartz &lt;- data.frame(tth = minerals$tth,
                     counts = minerals$xrd$QUA.1)

unaligned &lt;- as_multi_xy(list("quartz" = quartz,
                              "sandstone" = soils$sandstone))

plot(unaligned, wav = "Cu",
     xlim = c(26,27), normalise = TRUE)

sandstone_a &lt;- align_xy(soils$sandstone,
                        std = quartz,
                        xmin = 10,
                        xmax = 60,
                        xshift = 0.3)

aligned &lt;- as_multi_xy(list("quartz" = quartz,
                            "sandstone" = sandstone_a))

plot(aligned, wav = "Cu",
     xlim = c(26,27), normalise = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='as_multi_xy'>Create a multiXY object</h2><span id='topic+as_multi_xy'></span>

<h3>Description</h3>

<p><code>as_multi_xy</code> takes a list or data frame of XRPD data and ensures
that the data meet various requirements to create a multiXY object.
Once a multiXY object has been created, it can easily be plotted using
the associated <code>plot.multiXY</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_multi_xy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_multi_xy_+3A_x">x</code></td>
<td>
<p>a list or data frame of XRPD data</p>
</td></tr>
<tr><td><code id="as_multi_xy_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>multiXY</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#EXAMPLE 1

#load soils data
data(soils)

#extract first two samples from the list
soils &lt;- soils[c(1:2)]

#convert to multiXY
soils &lt;- as_multi_xy(soils)

#EXAMPLE 2
#load the soils data
data(soils)

#Convert to data frame
soils_df &lt;- multi_xy_to_df(soils,
                           tth = TRUE)

#Convert back to multiXY object
soils2 &lt;- as_multi_xy(soils_df)
</code></pre>

<hr>
<h2 id='as_multi_xy.data.frame'>Create a multiXY object from a list of XRPD data</h2><span id='topic+as_multi_xy.data.frame'></span>

<h3>Description</h3>

<p><code>as_multi_xy.data.frame</code> takes a data frame of XRPD data from multiple
samples and ensures that it meets various requirements to create a multiXY object.
Once a <code>multiXY</code> object has been created, it can easily be plotted using
the associated <code>plot.multiXY</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
as_multi_xy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_multi_xy.data.frame_+3A_x">x</code></td>
<td>
<p>a data frame of XRPD data, with the first column as the 2theta
axis and subsequent columns of count intensities.</p>
</td></tr>
<tr><td><code id="as_multi_xy.data.frame_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>multiXY</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load the soils data
data(soils)

#Convert to data frame
soils_df &lt;- multi_xy_to_df(soils,
                           tth = TRUE)

#Convert back to multiXY object
soils2 &lt;- as_multi_xy(soils_df)

</code></pre>

<hr>
<h2 id='as_multi_xy.list'>Create a multiXY object from a list of XRPD data</h2><span id='topic+as_multi_xy.list'></span>

<h3>Description</h3>

<p><code>as_multi_xy.list</code> takes a list of XRPD data and ensures that they meet
various requirements to create a multiXY object. These requirements
include that each item in the list contains 2 columns of numeric data in a
data frame. <code>as_multi_xy.list</code> also checks that all names are unique.
Once a <code>multiXY</code> object has been created, it can easily be plotted using
the associated <code>plot.multiXY</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
as_multi_xy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_multi_xy.list_+3A_x">x</code></td>
<td>
<p>a list of XRPD data frames (column 1 = 2theta, column 2 = counts)</p>
</td></tr>
<tr><td><code id="as_multi_xy.list_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>multiXY</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' #load soils data
data(soils)

#extract first two samples from the list
soils &lt;- soils[c(1:2)]

#convert to multiXY
soils &lt;- as_multi_xy(soils)
</code></pre>

<hr>
<h2 id='as_xy'>Create an XY object</h2><span id='topic+as_xy'></span>

<h3>Description</h3>

<p><code>as_xy</code> takes a data frame of XY XRPD data and ensures that it
meets the criteria for an XY object. These requirements
include that the data contains 2 columns of numeric data in a dataframe.
Once an XY object has been created, it can easily be plotted using the
associated <code>plot.XY</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_xy(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_xy_+3A_x">x</code></td>
<td>
<p>a data frame (column 1 = 2theta, column 2 = counts)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an XY object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load soils xrd data
data(rockjock_mixtures)

xy &lt;- as_xy(rockjock_mixtures$Mix1)

class(xy)

## Not run: 
plot(xy, wavelength = "Cu")
plot(xy, wavelength = "Cu", interactive = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='bkg'>Fit a background to XRPD data</h2><span id='topic+bkg'></span>

<h3>Description</h3>

<p><code>bkg</code> fits a background to X-Ray Powder Diffraction data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkg(xrd, lambda, hwi, it, int)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bkg_+3A_xrd">xrd</code></td>
<td>
<p>an xy data frame of the data to fit a background to. First column
is the 2theta scale, second column is count intensities</p>
</td></tr>
<tr><td><code id="bkg_+3A_lambda">lambda</code></td>
<td>
<p>second derivative penalty for primary smoothing. Default = 0.5.</p>
</td></tr>
<tr><td><code id="bkg_+3A_hwi">hwi</code></td>
<td>
<p>Half width of local windows. Default = 25.</p>
</td></tr>
<tr><td><code id="bkg_+3A_it">it</code></td>
<td>
<p>Number of iterations in suppression loop. Default = 50.</p>
</td></tr>
<tr><td><code id="bkg_+3A_int">int</code></td>
<td>
<p>Number of buckets to divide the data into. Default = <code>round(nrow(xrd)/4)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper for the <code>baseline.fillPeaks</code> in the <code>baseline</code> package.
</p>


<h3>Value</h3>

<p>a powdRbkg object consisting of of 3 vectors
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>The 2theta axis of the measurement</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>The count intensities of the measurement</p>
</td></tr>
<tr><td><code>background</code></td>
<td>
<p>The count intensities of the fitted background</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(soils)
## Not run: 
fit_bkg &lt;- bkg(soils$granite)
plot(bkg)

## End(Not run)
</code></pre>

<hr>
<h2 id='close_quant'>Close the phase concentration data within a <code>powdRfps</code> or
<code>powdRafps</code> object</h2><span id='topic+close_quant'></span>

<h3>Description</h3>

<p><code>close_quant</code> closes the quantitative data within a <code>powdRfps</code> or
<code>powdRafps</code> object (derived from <code>fps()</code> and <code>afps()</code>, respectively) by
ensuring that the composition sums to 100 percent. See also <code>?close_quant.powdRfps</code> and
<code>?close_quant.powdRafps</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>close_quant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="close_quant_+3A_x">x</code></td>
<td>
<p>A <code>powdRfps</code> or <code>powdRafps</code> object..</p>
</td></tr>
<tr><td><code id="close_quant_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>powdRfps</code> or <code>powdRafps</code> object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original XRPD measurement (aligned and harmonised)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (fitted vs measured)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern and their concentrations</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and concentrations summed</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rockjock)
data(rockjock_mixtures)

rockjock_1 &lt;- fps(lib = rockjock,
                  smpl = rockjock_mixtures$Mix1,
                  refs = c("ORDERED_MICROCLINE",
                           "LABRADORITE",
                           "KAOLINITE_DRY_BRANCH",
                           "MONTMORILLONITE_WYO",
                           "ILLITE_1M_RM30",
                           "CORUNDUM"),
                 std = "CORUNDUM",
                 align = 0.3,
                 std_conc = 20)

sum(rockjock_1$phases$phase_percent)

rockjock_1c &lt;- close_quant(rockjock_1)

sum(rockjock_1c$phases$phase_percent)

rockjock_a1 &lt;- afps(lib = rockjock,
                    smpl = rockjock_mixtures$Mix1,
                    std = "CORUNDUM",
                    align = 0.3,
                    lod = 1,
                    std_conc = 20)

sum(rockjock_a1$phases$phase_percent)

rockjock_a1c &lt;- close_quant(rockjock_a1)

sum(rockjock_a1c$phases$phase_percent)


## End(Not run)
</code></pre>

<hr>
<h2 id='close_quant.powdRafps'>Close the phase concentration data within a <code>powdRafps</code> object</h2><span id='topic+close_quant.powdRafps'></span>

<h3>Description</h3>

<p><code>close_quant</code> closes the quantitative data within a <code>powdRafps</code> object
(derived from <code>afps()</code>) by ensuring that the composition sums to 100 percent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRafps'
close_quant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="close_quant.powdRafps_+3A_x">x</code></td>
<td>
<p>A <code>powdRafps</code> object derived from <code>afps()</code>.</p>
</td></tr>
<tr><td><code id="close_quant.powdRafps_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>powdRafps</code> object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original XRPD measurement (aligned and harmonised)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (fitted vs measured)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern and their concentrations</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and concentrations summed</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rockjock)
data(rockjock_mixtures)

rockjock_a1 &lt;- afps(lib = rockjock,
                    smpl = rockjock_mixtures$Mix1,
                    std = "CORUNDUM",
                    align = 0.3,
                    lod = 1,
                    std_conc = 20)

sum(rockjock_a1$phases$phase_percent)

rockjock_a1c &lt;- close_quant(rockjock_a1)

sum(rockjock_a1c$phases$phase_percent)


## End(Not run)
</code></pre>

<hr>
<h2 id='close_quant.powdRfps'>Close the phase concentration data within a <code>powdRfps</code> object</h2><span id='topic+close_quant.powdRfps'></span>

<h3>Description</h3>

<p><code>close_quant</code> closes the quantitative data within a <code>powdRfps</code> object
(derived from <code>fps()</code>) by ensuring that the composition sums to 100 percent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRfps'
close_quant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="close_quant.powdRfps_+3A_x">x</code></td>
<td>
<p>A <code>powdRfps</code> object derived from <code>fps()</code>.</p>
</td></tr>
<tr><td><code id="close_quant.powdRfps_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>powdRfps</code> object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original XRPD measurement (aligned and harmonised)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (fitted vs measured)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern and their concentrations</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and concentrations summed</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rockjock)
data(rockjock_mixtures)

rockjock_1 &lt;- fps(lib = rockjock,
                  smpl = rockjock_mixtures$Mix1,
                  refs = c("ORDERED_MICROCLINE",
                           "LABRADORITE",
                           "KAOLINITE_DRY_BRANCH",
                           "MONTMORILLONITE_WYO",
                           "ILLITE_1M_RM30",
                           "CORUNDUM"),
                 std = "CORUNDUM",
                 align = 0.3,
                 std_conc = 20)

sum(rockjock_1$phases$phase_percent)

rockjock_1c&lt;- close_quant(rockjock_1)

sum(rockjock_1c$phases$phase_percent)


## End(Not run)
</code></pre>

<hr>
<h2 id='delta'>Calculate the Delta value for a fitted pattern</h2><span id='topic+delta'></span>

<h3>Description</h3>

<p><code>delta</code> computes the absolute difference between a measured and fitted pattern.
See equation for Delta in section 2.1 of Butler and Hillier (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta(measured, fitted, weighting)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta_+3A_measured">measured</code></td>
<td>
<p>a vector of count intensities for a measured pattern</p>
</td></tr>
<tr><td><code id="delta_+3A_fitted">fitted</code></td>
<td>
<p>a vector of count intensities for a fitted pattern</p>
</td></tr>
<tr><td><code id="delta_+3A_weighting">weighting</code></td>
<td>
<p>an optional weighting vector of the same length as those specified
in <code>measured</code> and <code>fitted</code>, which specifies areas of the pattern
to either emphasise (values &gt; 1) or omit (values = 0) from the calculation.
Use with caution. Default is simply a weighting vector where all values are 1, which
hence has no effect on the computed value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value
</p>


<h3>References</h3>

<p>Butler, B.M., Hillier, S., 2021. powdR: An R package for quantitative mineralogy using full pattern summation
of X-ray powder diffraction data. Computers and Geosciences. 147, 104662. doi:10.1016/j.cageo.2020.104662
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load soils xrd data
data(soils)

#Load minerals library
data(minerals)

## Not run: 
#Produce a fit
fps_sand &lt;-  fps(lib = minerals,
                 smpl = soils$sandstone,
                 refs = minerals$phases$phase_id,
                 std = "QUA.1",
                 align = 0.2)

delta(measured = fps_sand$measured,
      fitted = fps_sand$fitted)


## End(Not run)

</code></pre>

<hr>
<h2 id='extract_xy'>Import and extract XY data from proprietary files</h2><span id='topic+extract_xy'></span>

<h3>Description</h3>

<p><code>extract_xy</code> is a wrapper for <code>read_xyData</code> of the <code>rxylib</code> package,
which extracts the xy data from various proprietary formats of X-ray powder
diffraction data using the <code>xylib</code> C++ library. For more information see
<code>?rxylib</code> and <code>?rxylib::read_xyData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_xy(files)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_xy_+3A_files">files</code></td>
<td>
<p>path of the file(s) to be imported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If only one path is supplied then an XY data frame with 2 columns is returned,
the first being the 2theta axis and the second being the count intensities. If more
than one path is supplied then a multiXY list is returned, with each item in the list being
an XY data frame as already described.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load example RAW file
file &lt;- system.file("extdata/D5000/RAW/D5000_1.RAW", package = "powdR")
raw1 &lt;- extract_xy(file)

#Load multiple RAW files
files &lt;- dir(system.file("extdata/D5000/RAW", package = "powdR"),
             full.names = TRUE)
raw_list &lt;- extract_xy(files)

class(raw_list)

## Not run: 
plot(raw_list, wavelength = "Cu")
plot(raw_list, wavelength = "Cu", interactive = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='fps'>Full pattern summation</h2><span id='topic+fps'></span>

<h3>Description</h3>

<p><code>fps</code> returns estimates of phase concentrations using full pattern
summation of X-ray powder diffraction data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fps(
  lib,
  smpl,
  harmonise,
  solver,
  obj,
  refs,
  std,
  force,
  std_conc,
  omit_std,
  normalise,
  closed,
  tth_align,
  align,
  manual_align,
  tth_fps,
  shift,
  remove_trace,
  weighting,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fps_+3A_lib">lib</code></td>
<td>
<p>A <code>powdRlib</code> object representing the reference library. Created using the
<code>powdRlib</code> constructor function.</p>
</td></tr>
<tr><td><code id="fps_+3A_smpl">smpl</code></td>
<td>
<p>A data frame. First column is 2theta, second column is counts</p>
</td></tr>
<tr><td><code id="fps_+3A_harmonise">harmonise</code></td>
<td>
<p>logical parameter defining whether to harmonise the <code>lib</code> and <code>smpl</code>.
Default = <code>TRUE</code>. When <code>TRUE</code> the function will harmonise the <code>lib</code> and
<code>smpl</code> to the intersecting 2theta range at the coarsest resolution available using
natural splines.</p>
</td></tr>
<tr><td><code id="fps_+3A_solver">solver</code></td>
<td>
<p>The optimisation routine to be used. One of <code>"BFGS", "Nelder-Mead",
"CG", "NNLS"</code>. Default = <code>"BFGS"</code>.</p>
</td></tr>
<tr><td><code id="fps_+3A_obj">obj</code></td>
<td>
<p>The objective function to minimise when &quot;BFGS&quot;, &quot;Nelder-Mead&quot;,
or &quot;CG&quot; are used as the <code>solver</code> argument. One of <code>"Delta", "R", "Rwp"</code>.
Default = <code>"Rwp"</code>. See Chipera and Bish (2002) and page 247 of Bish and Post (1989)
for definitions of these functions.</p>
</td></tr>
<tr><td><code id="fps_+3A_refs">refs</code></td>
<td>
<p>A character string of reference pattern IDs or names from the specified library.
The IDs or names supplied must be present within the <code>lib$phases$phase_id</code> or
<code>lib$phases$phase_name</code> columns. If missing from the function call then all phases in
the reference library will be used.</p>
</td></tr>
<tr><td><code id="fps_+3A_std">std</code></td>
<td>
<p>The phase ID (e.g. &quot;QUA.1&quot;) to be used as an internal
standard. Must match an ID provided in the <code>refs</code> parameter.</p>
</td></tr>
<tr><td><code id="fps_+3A_force">force</code></td>
<td>
<p>An optional string of phase IDs or names specifying which phases should be forced to
remain throughout the automated full pattern summation. The IDs or names supplied must be present
within the <code>lib$phases$phase_id</code> or <code>lib$phases$phase_name</code> columns.</p>
</td></tr>
<tr><td><code id="fps_+3A_std_conc">std_conc</code></td>
<td>
<p>The concentration of the internal standard (if known) in weight percent. If
unknown then omit the argument from the function call or use <code>std_conc = NA</code> (default),
n which case it will be assumed that all phases sum to 100 percent.</p>
</td></tr>
<tr><td><code id="fps_+3A_omit_std">omit_std</code></td>
<td>
<p>A logical parameter to be used when the <code>std_conc</code> argument is defined. When
<code>omit_std = TRUE</code> the phase concentrations are recomputed to account for the value supplied in
<code>std_conc</code>. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="fps_+3A_normalise">normalise</code></td>
<td>
<p>deprecated. Please use the <code>omit_std</code> and <code>closed</code> arguments instead.</p>
</td></tr>
<tr><td><code id="fps_+3A_closed">closed</code></td>
<td>
<p>A logical parameter to be used when the <code>std_conc</code> argument is defined and
<code>omit_std = TRUE</code>. When <code>closed = TRUE</code> the internal standard concentration is removed
and the remaining phase concentrations closed to sum to 100 percent. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="fps_+3A_tth_align">tth_align</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
alignment (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="fps_+3A_align">align</code></td>
<td>
<p>The maximum shift that is allowed during initial 2theta
alignment (degrees). Default = 0.1.</p>
</td></tr>
<tr><td><code id="fps_+3A_manual_align">manual_align</code></td>
<td>
<p>A logical operator denoting whether to optimise the alignment within the
negative/position 2theta range defined in the <code>align</code> argument, or to use the specified
value of the <code>align</code> argument for alignment of the sample to the standards. Default
= <code>FALSE</code>, i.e. alignment is optimised.</p>
</td></tr>
<tr><td><code id="fps_+3A_tth_fps">tth_fps</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
full pattern summation (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="fps_+3A_shift">shift</code></td>
<td>
<p>A single numeric value denoting the maximum (positive or negative) shift,
in degrees 2theta, that is allowed during the shifting of reference patterns. Default = 0.</p>
</td></tr>
<tr><td><code id="fps_+3A_remove_trace">remove_trace</code></td>
<td>
<p>A single numeric value representing the limit for the concentration
of trace phases to be retained, i.e. any mineral with an estimated concentration below
<code>remove_trace</code> will be omitted. Default = 0.</p>
</td></tr>
<tr><td><code id="fps_+3A_weighting">weighting</code></td>
<td>
<p>an optional 2 column data frame specifying the 2theta values in the first
column and a numeric weighting vector in the second column that specifies areas of the pattern
to either emphasise (values &gt; 1) or omit (values = 0) when minimising the objective function
defined in the <code>obj</code> argument. Use this weighting parameter with caution. The default
is simply a weighting vector where all values are 1, which hence has no effect on the computed
objective function.</p>
</td></tr>
<tr><td><code id="fps_+3A_...">...</code></td>
<td>
<p>Other parameters passed to methods e.g. <code>fps.powdRlib</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies full pattern summation (Chipera &amp; Bish, 2002, 2013; Eberl, 2003) to an XRPD
measurement to quantify phase concentrations. Requires a <code>powdRlib</code> library of
reference patterns with reference intensity ratios in order to derive
mineral concentrations. Details provided in Butler and Hillier (2021).
</p>


<h3>Value</h3>

<p>a powdRfps object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original XRPD measurement (aligned and harmonised)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern and their concentrations</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and concentrations summed</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>References</h3>

<p>Butler, B. M., Hillier, S., 2021.powdR: An R package for quantitative mineralogy using full pattern
summation of X-ray powder diffraction data. Comp. Geo. 147, 104662. doi:10.1016/j.cageo.2020.104662
</p>
<p>Chipera, S.J., Bish, D.L., 2013. Fitting Full X-Ray Diffraction Patterns for Quantitative Analysis:
A Method for Readily Quantifying Crystalline and Disordered Phases. Adv. Mater. Phys. Chem. 03, 47-53.
doi:10.4236/ampc.2013.31A007
</p>
<p>Chipera, S.J., Bish, D.L., 2002. FULLPAT: A full-pattern quantitative analysis program for X-ray powder
diffraction using measured and calculated patterns. J. Appl. Crystallogr. 35, 744-749.
doi:10.1107/S0021889802017405
</p>
<p>Eberl, D.D., 2003. User's guide to RockJock - A program for determining quantitative mineralogy from
powder X-ray diffraction data. Boulder, CA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

# Load the soils data
data(soils)

#Since the reference library is relatively small,
#the whole library can be used at once to get an
#estimate of the phases within each sample.
## Not run: 
fps_sand &lt;-  fps(lib = minerals,
                 smpl = soils$sandstone,
                 refs = minerals$phases$phase_id,
                 std = "QUA.1",
                 align = 0.2)

fps_lime &lt;- fps(lib = minerals,
                smpl = soils$limestone,
                refs = minerals$phases$phase_id,
                std = "QUA.1",
                align = 0.2)

fps_granite &lt;- fps(lib = minerals,
                   smpl = soils$granite,
                   refs = minerals$phases$phase_id,
                   std = "QUA.1",
                   align = 0.2)

#Alternatively run all 3 at once using lapply

fps_soils &lt;- lapply(soils, fps,
                    lib = minerals,
                    std = "QUA.2",
                    refs = minerals$phases$phase_id,
                    align = 0.2)

#Using the rockjock library:

data(rockjock)
data(rockjock_mixtures)

rockjock_1 &lt;- fps(lib = rockjock,
                  smpl = rockjock_mixtures$Mix1,
                  refs = c("ORDERED_MICROCLINE",
                           "LABRADORITE",
                           "KAOLINITE_DRY_BRANCH",
                           "MONTMORILLONITE_WYO",
                           "ILLITE_1M_RM30",
                           "CORUNDUM"),
                  std = "CORUNDUM",
                  align = 0.3)

#Alternatively you can specify the internal standard
#concentration if known:
rockjock_1s &lt;- fps(lib = rockjock,
                 smpl = rockjock_mixtures$Mix1,
                 refs = c("ORDERED_MICROCLINE",
                          "LABRADORITE",
                          "KAOLINITE_DRY_BRANCH",
                          "MONTMORILLONITE_WYO",
                          "ILLITE_1M_RM30",
                          "CORUNDUM"),
                 std = "CORUNDUM",
                 std_conc = 20,
                 align = 0.3)


## End(Not run)
</code></pre>

<hr>
<h2 id='fps_lm'>Full pattern summation using linear regression</h2><span id='topic+fps_lm'></span>

<h3>Description</h3>

<p><code>fps_lm</code> returns a simple fit of a given pattern using linear regression,
where coefficients may be either positive or negative. Does not return quantitative
data. For quantitative results use <code>fps</code> or <code>afps</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fps_lm(
  lib,
  smpl,
  harmonise,
  refs,
  std,
  tth_align,
  align,
  manual_align,
  tth_fps,
  shift,
  p,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fps_lm_+3A_lib">lib</code></td>
<td>
<p>A <code>powdRlib</code> object representing the reference library. Created using the
<code>powdRlib</code> constructor function.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_smpl">smpl</code></td>
<td>
<p>A data frame. First column is 2theta, second column is counts</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_harmonise">harmonise</code></td>
<td>
<p>logical parameter defining whether to harmonise the <code>lib</code> and <code>smpl</code>.
Default = <code>TRUE</code>. When <code>TRUE</code> the function harmonises the <code>lib</code> and <code>smpl</code>
data to the intersecting 2theta range at the coarsest resolution available using natural splines.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_refs">refs</code></td>
<td>
<p>A character string of reference pattern IDs or names from the specified library.
The IDs or names supplied must be present within the <code>lib$phases$phase_id</code> or
<code>lib$phases$phase_name</code> columns. If missing from the function call then all phases in
the reference library will be used.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_std">std</code></td>
<td>
<p>The phase ID (e.g. &quot;QUA.1&quot;) to be used as internal
standard. Must match an ID provided in the <code>refs</code> parameter.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_tth_align">tth_align</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
alignment (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_align">align</code></td>
<td>
<p>The maximum shift that is allowed during initial 2theta
alignment (degrees). Default = 0.1.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_manual_align">manual_align</code></td>
<td>
<p>A logical operator denoting whether to optimise the alignment within the
negative/position 2theta range defined in the <code>align</code> argument, or to use the specified
value of the <code>align</code> argument for alignment of the sample to the standards. Default
= <code>FALSE</code>, i.e. alignment is optimised.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_tth_fps">tth_fps</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
full pattern summation (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_shift">shift</code></td>
<td>
<p>A single numeric value denoting the maximum (positive or negative) shift,
in degrees 2theta, that is allowed during the shifting of selected phases. Default = 0.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_p">p</code></td>
<td>
<p>a numeric parameter between 0 and 1 specifying the p-value limit for coefficients.
Any reference patterns with a p-value greater than this value will be omitted from the
linear regression and results recomputed. Must be greater than 0.000001 but no greater than 1.</p>
</td></tr>
<tr><td><code id="fps_lm_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires a <code>powdRlib</code> library of reference patterns. Mineral concentrations
are not quantified and therefore reference intensity ratios are not required.
</p>


<h3>Value</h3>

<p>a powdRlm object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original XRPD measurement (aligned)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (fitted vs measured)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and summed</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(rockjock)
data(rockjock_mixtures)

#Compute the PCA and loadings
x1 &lt;- xrpd_pca(rockjock_mixtures,
               mean_center = TRUE,
               bin_size = 1,
               root_transform = 1)

## Not run: 
fps_lm_out &lt;- fps_lm(rockjock,
                     smpl = data.frame("x" = x1$loadings$tth,
                                       "y" = x1$loadings$Dim.1),
                     refs = rockjock$phases$phase_id,
                     std = "QUARTZ",
                     align = 0.3,
                     p = 0.01)

plot(fps_lm_out,
     wavelength = "Cu",
     interactive = TRUE,
     group = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='fps_lm.powdRlib'>Full pattern summation using linear regression</h2><span id='topic+fps_lm.powdRlib'></span>

<h3>Description</h3>

<p><code>fps_lm.powdRlib</code> returns a simple fit of a given pattern using linear regression,
where coefficients may be either positive or negative. Does not return quantitative
data. For quantitative results use <code>fps</code> or <code>afps</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRlib'
fps_lm(
  lib,
  smpl,
  harmonise,
  refs,
  std,
  tth_align,
  align,
  manual_align,
  tth_fps,
  shift,
  p,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fps_lm.powdRlib_+3A_lib">lib</code></td>
<td>
<p>A <code>powdRlib</code> object representing the reference library. Created using the
<code>powdRlib</code> constructor function.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_smpl">smpl</code></td>
<td>
<p>A data frame. First column is 2theta, second column is counts</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_harmonise">harmonise</code></td>
<td>
<p>logical parameter defining whether to harmonise the <code>lib</code> and <code>smpl</code>.
Default = <code>TRUE</code>. When <code>TRUE</code> the function harmonises the <code>lib</code> and <code>smpl</code>
data to the intersecting 2theta range at the coarsest resolution available using natural splines.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_refs">refs</code></td>
<td>
<p>A character string of reference pattern IDs or names from the specified library.
The IDs or names supplied must be present within the <code>lib$phases$phase_id</code> or
<code>lib$phases$phase_name</code> columns. If missing from the function call then all phases in
the reference library will be used.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_std">std</code></td>
<td>
<p>The phase ID (e.g. &quot;QUA.1&quot;) to be used as internal
standard. Must match an ID provided in the <code>refs</code> parameter.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_tth_align">tth_align</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
alignment (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_align">align</code></td>
<td>
<p>The maximum shift that is allowed during initial 2theta
alignment (degrees). Default = 0.1.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_manual_align">manual_align</code></td>
<td>
<p>A logical operator denoting whether to optimise the alignment within the
negative/position 2theta range defined in the <code>align</code> argument, or to use the specified
value of the <code>align</code> argument for alignment of the sample to the standards. Default
= <code>FALSE</code>, i.e. alignment is optimised.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_tth_fps">tth_fps</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
full pattern summation (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_shift">shift</code></td>
<td>
<p>A single numeric value denoting the maximum (positive or negative) shift,
in degrees 2theta, that is allowed during the shifting of selected phases. Default = 0.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_p">p</code></td>
<td>
<p>a numeric parameter between 0 and 1 specifying the p-value limit for coefficients.
Any reference patterns with a p-value greater than this value will be omitted from the
linear regression and results recomputed. Must be greater than 0.000001 but no greater than 1.</p>
</td></tr>
<tr><td><code id="fps_lm.powdRlib_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires a <code>powdRlib</code> library of reference patterns. Mineral concentrations
are not quantified and therefore reference intensity ratios are not required.
</p>


<h3>Value</h3>

<p>a powdRlm object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the count intensities of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original count intensities of the XRPD measurement (aligned)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (fitted vs measured)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern and their concentrations</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and concentrations summed</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(rockjock)
data(rockjock_mixtures)

#Compute the PCA and loadings
x1 &lt;- xrpd_pca(rockjock_mixtures,
               mean_center = TRUE,
               bin_size = 1,
               root_transform = 1)

## Not run: 
fps_lm_out &lt;- fps_lm(rockjock,
                     smpl = data.frame("x" = x1$loadings$tth,
                                       "y" = x1$loadings$Dim.1),
                     refs = rockjock$phases$phase_id,
                     std = "QUARTZ",
                     align = 0.3,
                     p = 0.01)

plot(fps_lm_out,
     wavelength = "Cu",
     interactive = TRUE,
     group = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='fps.powdRlib'>Full pattern summation</h2><span id='topic+fps.powdRlib'></span>

<h3>Description</h3>

<p><code>fps.powdRlib</code> returns estimates of phase concentrations using full pattern
summation of X-ray powder diffraction data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRlib'
fps(
  lib,
  smpl,
  harmonise,
  solver,
  obj,
  refs,
  std,
  force,
  std_conc,
  omit_std,
  normalise,
  closed,
  tth_align,
  align,
  manual_align,
  tth_fps,
  shift,
  remove_trace,
  weighting,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fps.powdRlib_+3A_lib">lib</code></td>
<td>
<p>A <code>powdRlib</code> object representing the reference library. Created using the
<code>powdRlib</code> constructor function.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_smpl">smpl</code></td>
<td>
<p>A data frame. First column is 2theta, second column is counts</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_harmonise">harmonise</code></td>
<td>
<p>logical parameter defining whether to harmonise the <code>lib</code> and <code>smpl</code>.
Default = <code>TRUE</code>. When <code>TRUE</code> the function will harmonise the <code>lib</code> and
<code>smpl</code> to the intersecting 2theta range at the coarsest resolution available using
natural splines.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_solver">solver</code></td>
<td>
<p>The optimisation routine to be used. One of <code>"BFGS", "Nelder-Mead",
"CG", "NNLS"</code>. Default = <code>"BFGS"</code>.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_obj">obj</code></td>
<td>
<p>The objective function to minimise when &quot;BFGS&quot;, &quot;Nelder-Mead&quot;,
or &quot;CG&quot; are used as the <code>solver</code> argument. One of <code>"Delta", "R", "Rwp"</code>.
Default = <code>"Rwp"</code>. See Chipera and Bish (2002) and page 247 of Bish and Post (1989)
for definitions of these functions.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_refs">refs</code></td>
<td>
<p>A character string of reference pattern IDs or names from the specified library.
The IDs or names supplied must be present within the <code>lib$phases$phase_id</code> or
<code>lib$phases$phase_name</code> columns. If missing from the function call then all phases in
the reference library will be used.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_std">std</code></td>
<td>
<p>The phase ID (e.g. &quot;QUA.1&quot;) to be used as an internal
standard. Must match an ID provided in the <code>refs</code> parameter.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_force">force</code></td>
<td>
<p>An optional string of phase IDs or names specifying which phases should be forced to
remain throughout the automated full pattern summation. The IDs or names supplied must be present
within the <code>lib$phases$phase_id</code> or <code>lib$phases$phase_name</code> columns.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_std_conc">std_conc</code></td>
<td>
<p>The concentration of the internal standard (if known) in weight percent. If
unknown then omit the argument from the function call or use <code>std_conc = NA</code> (default),
n which case it will be assumed that all phases sum to 100 percent.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_omit_std">omit_std</code></td>
<td>
<p>A logical parameter to be used when the <code>std_conc</code> argument is defined. When
<code>omit_std = TRUE</code> the phase concentrations are recomputed to account for the value supplied in
<code>std_conc</code>. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_normalise">normalise</code></td>
<td>
<p>deprecated. Please use the <code>omit_std</code> and <code>closed</code> arguments instead.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_closed">closed</code></td>
<td>
<p>A logical parameter to be used when the <code>std_conc</code> argument is defined and
<code>omit_std = TRUE</code>. When <code>closed = TRUE</code> the internal standard concentration is removed
and the remaining phase concentrations closed to sum to 100 percent. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_tth_align">tth_align</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
alignment (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_align">align</code></td>
<td>
<p>The maximum shift that is allowed during initial 2theta
alignment (degrees). Default = 0.1.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_manual_align">manual_align</code></td>
<td>
<p>A logical operator denoting whether to optimise the alignment within the
negative/position 2theta range defined in the <code>align</code> argument, or to use the specified
value of the <code>align</code> argument for alignment of the sample to the standards. Default
= <code>FALSE</code>, i.e. alignment is optimised.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_tth_fps">tth_fps</code></td>
<td>
<p>A vector defining the minimum and maximum 2theta values to be used during
full pattern summation (e.g. <code>c(5,65)</code>). If not defined, then the full range is used.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_shift">shift</code></td>
<td>
<p>A single numeric value denoting the maximum (positive or negative) shift,
in degrees 2theta, that is allowed during the shifting of reference patterns. Default = 0.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_remove_trace">remove_trace</code></td>
<td>
<p>A single numeric value representing the limit for the concentration
of trace phases to be retained, i.e. any mineral with an estimated concentration below
<code>remove_trace</code> will be omitted. Default = 0.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_weighting">weighting</code></td>
<td>
<p>an optional 2 column data frame specifying the 2theta values in the first
column and a numeric weighting vector in the second column that specifies areas of the pattern
to either emphasise (values &gt; 1) or omit (values = 0) when minimising the objective function
defined in the <code>obj</code> argument. Use this weighting parameter with caution. The default
is simply a weighting vector where all values are 1, which hence has no effect on the computed
objective function.</p>
</td></tr>
<tr><td><code id="fps.powdRlib_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies full pattern summation (Chipera &amp; Bish, 2002, 2013; Eberl, 2003) to an XRPD
sample to quantify phase concentrations. Requires a <code>powdRlib</code> library of reference
patterns with reference intensity ratios in order to derive mineral
concentrations. Details provided in Butler and Hillier (2021)
</p>


<h3>Value</h3>

<p>a powdRfps object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original XRPD measurement (aligned and harmonised)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern and their concentrations</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and concentrations summed</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>References</h3>

<p>Butler, B. M., Hillier, S., 2021.powdR: An R package for quantitative mineralogy using full pattern
summation of X-ray powder diffraction data. Comp. Geo. 147, 104662. doi:10.1016/j.cageo.2020.104662
</p>
<p>Bish, D.L., Post, J.E., 1989. Modern powder diffraction. Mineralogical Society of America.
</p>
<p>Chipera, S.J., Bish, D.L., 2013. Fitting Full X-Ray Diffraction Patterns for Quantitative Analysis:
A Method for Readily Quantifying Crystalline and Disordered Phases. Adv. Mater. Phys. Chem. 03, 47-53.
doi:10.4236/ampc.2013.31A007
</p>
<p>Chipera, S.J., Bish, D.L., 2002. FULLPAT: A full-pattern quantitative analysis program for X-ray powder
diffraction using measured and calculated patterns. J. Appl. Crystallogr. 35, 744-749.
doi:10.1107/S0021889802017405
</p>
<p>Eberl, D.D., 2003. User's guide to RockJock - A program for determining quantitative mineralogy from
powder X-ray diffraction data. Boulder, CA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

# Load the soils data
data(soils)

#Since the reference library is relatively small,
#the whole library can be used at once to get an
#estimate of the phases within each sample.
## Not run: 
fps_sand &lt;-  fps(lib = minerals,
                 smpl = soils$sandstone,
                 refs = minerals$phases$phase_id,
                 std = "QUA.1",
                 align = 0.2)

fps_lime &lt;- fps(lib = minerals,
                smpl = soils$limestone,
                refs = minerals$phases$phase_id,
                std = "QUA.1",
                align = 0.2)

fps_granite &lt;- fps(lib = minerals,
                   smpl = soils$granite,
                   refs = minerals$phases$phase_id,
                   std = "QUA.1",
                   align = 0.2)

#Alternatively run all 3 at once using lapply

fps_soils &lt;- lapply(soils, fps,
                    lib = minerals,
                    std = "QUA.2",
                    refs = minerals$phases$phase_id,
                    align = 0.2)

#Using the rockjock library:

data(rockjock)
data(rockjock_mixtures)

rockjock_1 &lt;- fps(lib = rockjock,
                  smpl = rockjock_mixtures$Mix1,
                  refs = c("ORDERED_MICROCLINE",
                           "LABRADORITE",
                           "KAOLINITE_DRY_BRANCH",
                           "MONTMORILLONITE_WYO",
                           "ILLITE_1M_RM30",
                           "CORUNDUM"),
                  std = "CORUNDUM",
                  align = 0.3)

#Alternatively you can specify the internal standard
#concentration if known:
rockjock_1s &lt;- fps(lib = rockjock,
                 smpl = rockjock_mixtures$Mix1,
                 refs = c("ORDERED_MICROCLINE",
                          "LABRADORITE",
                          "KAOLINITE_DRY_BRANCH",
                          "MONTMORILLONITE_WYO",
                          "ILLITE_1M_RM30",
                          "CORUNDUM"),
                 std = "CORUNDUM",
                 std_conc = 20,
                 align = 0.3)


## End(Not run)
</code></pre>

<hr>
<h2 id='interpolate'>Interpolate an XY, multiXY or powdRlib object to a given 2theta scale.</h2><span id='topic+interpolate'></span>

<h3>Description</h3>

<p><code>interpolate</code> takes an XY, multiXY or powdRlib object and
interpolates the data onto a new 2theta scale using a natural spline.
See additional help via <code>?interpolate.XY</code>,
<code>?interpolate.multiXY</code> or <code>?interpolate.powdRlib</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate(x, new_tth, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate_+3A_x">x</code></td>
<td>
<p>an <code>XY</code> or <code>multiXY</code> object.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_new_tth">new_tth</code></td>
<td>
<p>a numeric vector of the new 2theta scale.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>XY</code> or <code>multiXY</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Define a new 2theta scale:
data(rockjock_mixtures)
tth &lt;- seq(10, 60, 0.04)

#interpolate multiXY object of data onto new scale
i1 &lt;- interpolate(rockjock_mixtures, new_tth = tth)

#interpolate XY object onto new scale
i2 &lt;- interpolate(rockjock_mixtures$Mix1, new_tth = tth)

#interpolate powdRlib object onto new scale
i3 &lt;- interpolate(minerals, new_tth = tth)

</code></pre>

<hr>
<h2 id='interpolate.multiXY'>Interpolate a multiXY object onto a given 2theta scale.</h2><span id='topic+interpolate.multiXY'></span>

<h3>Description</h3>

<p><code>interpolate</code> takes a <code>multiXY</code> object, which may contain
XY data frames with varying 2theta scales, and interpolates all
data frames onto the same scale using cubic splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiXY'
interpolate(x, new_tth, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate.multiXY_+3A_x">x</code></td>
<td>
<p>a <code>multiXY</code> object.</p>
</td></tr>
<tr><td><code id="interpolate.multiXY_+3A_new_tth">new_tth</code></td>
<td>
<p>a numeric vector of the new 2theta scale.</p>
</td></tr>
<tr><td><code id="interpolate.multiXY_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>multiXY</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rockjock_mixtures)

#Define a new 2theta scale:
tth &lt;- seq(10, 60, 0.04)

#interpolate data onto new scale
i1 &lt;- interpolate(rockjock_mixtures, new_tth = tth)
</code></pre>

<hr>
<h2 id='interpolate.powdRlib'>Interpolate a <code>powdRlib</code> object onto a given 2theta scale.</h2><span id='topic+interpolate.powdRlib'></span>

<h3>Description</h3>

<p><code>interpolate</code> takes a <code>powdRlib</code> object and interpolates the
data onto a new 2theta scale using a cubic spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRlib'
interpolate(x, new_tth, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate.powdRlib_+3A_x">x</code></td>
<td>
<p>a <code>powdRlib</code> object.</p>
</td></tr>
<tr><td><code id="interpolate.powdRlib_+3A_new_tth">new_tth</code></td>
<td>
<p>a numeric vector of the new 2theta scale.</p>
</td></tr>
<tr><td><code id="interpolate.powdRlib_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>powdRlib</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(minerals)

#Define a new 2theta scale:
tth &lt;- seq(10, 60, 0.04)

#interpolate data onto new scale
i1 &lt;- interpolate(minerals, new_tth = tth)
</code></pre>

<hr>
<h2 id='interpolate.XY'>Interpolate an <code>XY</code> object onto a given 2theta scale.</h2><span id='topic+interpolate.XY'></span>

<h3>Description</h3>

<p><code>interpolate</code> takes an <code>XY</code> object and interpolates the
data onto a new 2theta scale using a cubic spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XY'
interpolate(x, new_tth, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate.XY_+3A_x">x</code></td>
<td>
<p>an <code>XY</code> object.</p>
</td></tr>
<tr><td><code id="interpolate.XY_+3A_new_tth">new_tth</code></td>
<td>
<p>a numeric vector of the new 2theta scale.</p>
</td></tr>
<tr><td><code id="interpolate.XY_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>XY</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rockjock_mixtures)

#Define a new 2theta scale:
tth &lt;- seq(10, 60, 0.04)

#interpolate data onto new scale
i1 &lt;- interpolate(rockjock_mixtures$Mix1, new_tth = tth)
</code></pre>

<hr>
<h2 id='merge.powdRlib'>Merge two powdRlib objects</h2><span id='topic+merge.powdRlib'></span>

<h3>Description</h3>

<p><code>merge.powdRlib</code> allows two <code>powdRlib</code> objects (which must have) the
same 2theta scale) to be merged into a single powdRlib object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRlib'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge.powdRlib_+3A_x">x</code></td>
<td>
<p>a <code>powdRlib</code> object.</p>
</td></tr>
<tr><td><code id="merge.powdRlib_+3A_y">y</code></td>
<td>
<p>a <code>powdRlib</code> object</p>
</td></tr>
<tr><td><code id="merge.powdRlib_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>powdRlib</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

#Load the rockjock library
data(rockjock)

#interpolate minerals library onto same 2theta as rockjock
minerals_i &lt;- interpolate(minerals, new_tth = rockjock$tth)

#merge the libraries
merged_lib &lt;- merge(rockjock, minerals_i)
</code></pre>

<hr>
<h2 id='minerals'>An example powdRlib reference library</h2><span id='topic+minerals'></span>

<h3>Description</h3>

<p>This <code>powdRlib</code> object, built using the <code>powdRlib</code> constructor function,
contains a range of measured XRPD data (collected using Cu K-alpha radiation) along with
their reference intensity ratios. The library is designed for simple examples only and
can be used with the <code>soils</code> data for relatively fast tests of <code>fps</code> and
<code>afps</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minerals
</code></pre>


<h3>Format</h3>

<p>A powdRlib object of 3 components
</p>

<dl>
<dt>xrd</dt><dd><p>A dataframe of all the count intensities of all reference patterns. Column names denote the
unique phase ID of each reference pattern</p>
</dd>
<dt>tth</dt><dd><p>A vector of the 2theta scale for all reference patterns in the library</p>
</dd>
<dt>phases</dt><dd><p>A dataframe the phase IDs, names and reference intensity
ratios (RIR)</p>
</dd>
</dl>


<hr>
<h2 id='minerals_phases'>Example phases table for a reference library</h2><span id='topic+minerals_phases'></span>

<h3>Description</h3>

<p>A data frame of associated phase information for the <code>minerals_xrd</code> data.
Together these two data frames can be combined with the <code>powdRlib</code> constructor
function to create an example reference library (see <code>?powdRlib</code>). Use the same
layout to create custom reference libraries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minerals_phases
</code></pre>


<h3>Format</h3>

<p>A 3 column data frame consisting of:
</p>

<dl>
<dt>phase_id</dt><dd><p>A string defining the unique phase IDs that
should match those defined as column names of the minerals table
(e.g. <code>minerals_xrd</code>).</p>
</dd>
<dt>phase_name</dt><dd><p>A string defining the mineral group that each
reference pattern belongs to.</p>
</dd>
<dt>rir</dt><dd><p>A vector defining the reference intensity ratios
of each reference pattern.</p>
</dd>
</dl>


<hr>
<h2 id='minerals_regroup'>Example regrouping structure for the <code>minerals</code> data</h2><span id='topic+minerals_regroup'></span>

<h3>Description</h3>

<p>Example regrouping structure for the <code>minerals</code> data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minerals_regroup
</code></pre>


<h3>Format</h3>

<p>A 2 column data frame.
</p>
<p>First column contains the unique phase IDs of all phases
in the <code>minerals</code> data. Second column contains the grouping structure for the data
(Non-clay, Clay or Amorphous).
</p>

<hr>
<h2 id='minerals_xrd'>Example xrd table for a reference library</h2><span id='topic+minerals_xrd'></span>

<h3>Description</h3>

<p>A table of 14 reference patterns and their corresponding two theta scale that can
be combined with the <code>minerals_phases</code> table to create a <code>powdRlib</code> object using
the <code>powdRlib</code> constructor function. Use the same layout to create custom
reference libraries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minerals_xrd
</code></pre>


<h3>Format</h3>

<p>A dataframe
</p>

<p>The first column defines the two theta scale, and remaining columns are individual
reference patterns of pure minerals or amorphous phases. Each column title
should be a unique mineral ID

</p>

<hr>
<h2 id='multi_xy_to_df'>Convert a multiXY object to a data frame.</h2><span id='topic+multi_xy_to_df'></span>

<h3>Description</h3>

<p><code>multi_xy_to_df</code> converts multiXY objects to a column-wise data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_xy_to_df(x, tth, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_xy_to_df_+3A_x">x</code></td>
<td>
<p>a <code>multiXY</code> object.</p>
</td></tr>
<tr><td><code id="multi_xy_to_df_+3A_tth">tth</code></td>
<td>
<p>a logical value denoting whether the 2theta scale is appended as the
first column. Default <code>= TRUE</code>.</p>
</td></tr>
<tr><td><code id="multi_xy_to_df_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(soils)

soils_df1 &lt;- multi_xy_to_df(soils, tth = TRUE)
soils_df2 &lt;- multi_xy_to_df(soils, tth = FALSE)
</code></pre>

<hr>
<h2 id='multi_xy_to_df.multiXY'>Convert a multiXY object to a data frame.</h2><span id='topic+multi_xy_to_df.multiXY'></span>

<h3>Description</h3>

<p><code>multi_xy_to_df.multiXY</code> converts multiXY objects to a column-wise data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiXY'
multi_xy_to_df(x, tth, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_xy_to_df.multiXY_+3A_x">x</code></td>
<td>
<p>a <code>multiXY</code> object.</p>
</td></tr>
<tr><td><code id="multi_xy_to_df.multiXY_+3A_tth">tth</code></td>
<td>
<p>a logical value denoting whether the 2theta scale is appended as the
first column. Default <code>= TRUE</code>.</p>
</td></tr>
<tr><td><code id="multi_xy_to_df.multiXY_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(soils)

soils_df1 &lt;- multi_xy_to_df(soils, tth = TRUE)
soils_df2 &lt;- multi_xy_to_df(soils, tth = FALSE)
</code></pre>

<hr>
<h2 id='omit_std'>Omit the internal standard from phase concentration data within a <code>powdRfps</code> or
<code>powdRafps</code> object</h2><span id='topic+omit_std'></span>

<h3>Description</h3>

<p><code>omit_std</code> adjusts phase concentrations in a <code>powdRfps</code> or <code>powdRafps</code> object
(derived from <code>fps()</code> and <code>afps()</code>, respectively) by removing the concentrations of
the internal standard. Relevant information for the calculation is automatically
extracted from <code>x$inputs$std</code> and <code>x$inputs$std_conc</code>. For more information see
<code>?omit_std.powdRfps</code> and <code>omit_std.powdRafps</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omit_std(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="omit_std_+3A_x">x</code></td>
<td>
<p>A <code>powdRfps</code> or <code>powdRafps</code> object..</p>
</td></tr>
<tr><td><code id="omit_std_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>powdRfps</code> or <code>powdRafps</code> object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original XRPD measurement (aligned and harmonised)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern and their concentrations</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and concentrations summed</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rockjock)
data(rockjock_mixtures)

rockjock_1 &lt;- fps(lib = rockjock,
                  smpl = rockjock_mixtures$Mix1,
                  refs = c("ORDERED_MICROCLINE",
                           "LABRADORITE",
                           "KAOLINITE_DRY_BRANCH",
                           "MONTMORILLONITE_WYO",
                           "ILLITE_1M_RM30",
                           "CORUNDUM"),
                 std = "CORUNDUM",
                 align = 0.3,
                 std_conc = 20)

rockjock_1o &lt;- omit_std(rockjock_1)

rockjock_a1 &lt;- afps(lib = rockjock,
                    smpl = rockjock_mixtures$Mix1,
                    std = "CORUNDUM",
                    align = 0.3,
                    lod = 1,
                    std_conc = 20)

rockjock_a1o &lt;- omit_std(rockjock_a1)


## End(Not run)
</code></pre>

<hr>
<h2 id='omit_std.powdRafps'>Omit the internal standard from phase concentration data within a <code>powdRafps</code> object</h2><span id='topic+omit_std.powdRafps'></span>

<h3>Description</h3>

<p><code>omit_std.powdRafps</code> adjusts phase concentrations in a <code>powdRafps</code> object by removing
the concentrations of the internal standard. Relevant information for the calculation is
automatically extracted from <code>x$inputs$std</code> and <code>x$inputs$std_conc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRafps'
omit_std(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="omit_std.powdRafps_+3A_x">x</code></td>
<td>
<p>A <code>powdRafps</code> object derived from <code>afps()</code>.</p>
</td></tr>
<tr><td><code id="omit_std.powdRafps_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>powdRafps</code> object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original XRPD measurement (aligned and harmonised)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern and their concentrations</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and concentrations summed</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rockjock)
data(rockjock_mixtures)

rockjock_a1 &lt;- afps(lib = rockjock,
                    smpl = rockjock_mixtures$Mix1,
                    std = "CORUNDUM",
                    align = 0.3,
                    lod = 1,
                    std_conc = 20)

rockjock_a1o &lt;- omit_std(rockjock_a1)


## End(Not run)
</code></pre>

<hr>
<h2 id='omit_std.powdRfps'>Omit the internal standard from phase concentration data within a <code>powdRfps</code> object</h2><span id='topic+omit_std.powdRfps'></span>

<h3>Description</h3>

<p><code>omit_std.powdRfps</code> adjusts phase concentrations in a <code>powdRfps</code> object by removing
the concentrations of the internal standard. Relevant information for the calculation is
automatically extracted from <code>x$inputs$std</code> and <code>x$inputs$std_conc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRfps'
omit_std(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="omit_std.powdRfps_+3A_x">x</code></td>
<td>
<p>A <code>powdRfps</code> object derived from <code>fps()</code>.</p>
</td></tr>
<tr><td><code id="omit_std.powdRfps_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>powdRfps</code> object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the original XRPD measurement (aligned and harmonised)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern and their concentrations</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped by phase_name and concentrations summed</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(rockjock)
data(rockjock_mixtures)

rockjock_1 &lt;- fps(lib = rockjock,
                  smpl = rockjock_mixtures$Mix1,
                  refs = c("ORDERED_MICROCLINE",
                           "LABRADORITE",
                           "KAOLINITE_DRY_BRANCH",
                           "MONTMORILLONITE_WYO",
                           "ILLITE_1M_RM30",
                           "CORUNDUM"),
                 std = "CORUNDUM",
                 align = 0.3,
                 std_conc = 20)

rockjock_1o &lt;- omit_std(rockjock_1)


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.multiXY'>Plotting a multiXY object</h2><span id='topic+plot.multiXY'></span>

<h3>Description</h3>

<p><code>plot.multiXY</code> is designed to provide easy, adaptable plots
of multiple XRPD patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiXY'
plot(x, wavelength, xlim, normalise, interactive, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.multiXY_+3A_x">x</code></td>
<td>
<p>a multiXY object</p>
</td></tr>
<tr><td><code id="plot.multiXY_+3A_wavelength">wavelength</code></td>
<td>
<p>One of &quot;Cu&quot;, &quot;Co&quot; or a custom numeric value defining the wavelength
(in Angstroms). Used to compute d-spacings.When &quot;Cu&quot; or &quot;Co&quot; are supplied, wavelengths
of 1.54056 or 1.78897 are used, respectively.</p>
</td></tr>
<tr><td><code id="plot.multiXY_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector providing limits of the x-axis (E.g. <code>c(10, 60)</code>).
Defaults to full x-axis unless specified.</p>
</td></tr>
<tr><td><code id="plot.multiXY_+3A_normalise">normalise</code></td>
<td>
<p>Logical. If TRUE then count intensities will be normalised to a
minimum of zero and maximum of 1. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.multiXY_+3A_interactive">interactive</code></td>
<td>
<p>Logical. If TRUE then the output will be an interactive
ggplotly object. If FALSE then the output will be a ggplot object.</p>
</td></tr>
<tr><td><code id="plot.multiXY_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots can be made interactive using the logical <code>interactive</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the minerals library
data(rockjock_mixtures)
## Not run: 
plot(as_multi_xy(rockjock_mixtures), wavelength = "Cu")
plot(as_multi_xy(rockjock_mixtures), wavelength = "Cu", interactive = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.powdRafps'>Plotting elements of a powdRafps object</h2><span id='topic+plot.powdRafps'></span>

<h3>Description</h3>

<p><code>plot.powdRafps</code> is designed to provide easy, adaptable plots
of full pattern summation outputs produced from <code><a href="#topic+afps">afps</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRafps'
plot(x, wavelength, mode, group, xlim, show_excluded, interactive, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.powdRafps_+3A_x">x</code></td>
<td>
<p>a powdRafps object</p>
</td></tr>
<tr><td><code id="plot.powdRafps_+3A_wavelength">wavelength</code></td>
<td>
<p>One of &quot;Cu&quot;, &quot;Co&quot; or a custom numeric value defining the wavelength
(in Angstroms). Used to compute d-spacings.When &quot;Cu&quot; or &quot;Co&quot; are supplied, wavelengths
of 1.54056 or 1.78897 are used, respectively.</p>
</td></tr>
<tr><td><code id="plot.powdRafps_+3A_mode">mode</code></td>
<td>
<p>One of &quot;fit&quot;, &quot;residuals&quot; or &quot;both&quot; defining whether to plot the fitted
patterns, the residuals of the fit, or both, respectively. Default = &quot;fit&quot;.</p>
</td></tr>
<tr><td><code id="plot.powdRafps_+3A_group">group</code></td>
<td>
<p>A logical parameter used to specify whether the plotted data are grouped
according to the phase name. Default = FALSE.</p>
</td></tr>
<tr><td><code id="plot.powdRafps_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector providing limits of the x-axis (E.g. <code>c(10, 60)</code>).
Defaults to full x-axis unless specified.</p>
</td></tr>
<tr><td><code id="plot.powdRafps_+3A_show_excluded">show_excluded</code></td>
<td>
<p>A logical value specifying whether the areas excluded from the
fitting are identified in the plot as grey rectangles. Default <code>= TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.powdRafps_+3A_interactive">interactive</code></td>
<td>
<p>logical. If TRUE then the output will be an interactive
ggplotly object. If FALSE then the output will be a ggplot object.</p>
</td></tr>
<tr><td><code id="plot.powdRafps_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When seeking to inspect the results from full pattern summation, interactive
plots are particularly useful and can be specified with the <code>interactive</code>
argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

# Load the soils data
data(soils)

## Not run: 
afps_sand &lt;-  afps(lib = minerals,
                   smpl = soils$sandstone,
                   std = "QUA.1",
                   amorphous = "ORG",
                   align = 0.2,
                   lod = 0.1)

plot(afps_sand, wavelength = "Cu")
plot(afps_sand, wavelength = "Cu", interactive = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.powdRbkg'>Plotting a powdRbkg object</h2><span id='topic+plot.powdRbkg'></span>

<h3>Description</h3>

<p><code>plot.powdRbkg</code> is designed to provide quick plots to inspect the
fitted backgrounds obtained from <code>bkg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRbkg'
plot(x, interactive, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.powdRbkg_+3A_x">x</code></td>
<td>
<p>a powdRbkg object</p>
</td></tr>
<tr><td><code id="plot.powdRbkg_+3A_interactive">interactive</code></td>
<td>
<p>Logical. If TRUE then the output will be an interactive
ggplotly object. If FALSE then the output will be a ggplot object.</p>
</td></tr>
<tr><td><code id="plot.powdRbkg_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only mandatory argument is x, which must be a powdRbkg object. Plots can
be made interactive using the logical <code>interactive</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the minerals library
data(minerals)

## Not run: 
plot(minerals, interactive = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.powdRfps'>Plotting elements of a powdRfps object</h2><span id='topic+plot.powdRfps'></span>

<h3>Description</h3>

<p><code>plot.powdRfps</code> is designed to provide easy, adaptable plots
of full pattern summation outputs produced from <code><a href="#topic+fps">fps</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRfps'
plot(x, wavelength, mode, group, xlim, show_excluded, interactive, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.powdRfps_+3A_x">x</code></td>
<td>
<p>a powdRfps object</p>
</td></tr>
<tr><td><code id="plot.powdRfps_+3A_wavelength">wavelength</code></td>
<td>
<p>One of &quot;Cu&quot;, &quot;Co&quot; or a custom numeric value defining the wavelength
(in Angstroms). Used to compute d-spacings.When &quot;Cu&quot; or &quot;Co&quot; are supplied, wavelengths
of 1.54056 or 1.78897 are used, respectively.</p>
</td></tr>
<tr><td><code id="plot.powdRfps_+3A_mode">mode</code></td>
<td>
<p>One of &quot;fit&quot;, &quot;residuals&quot; or &quot;both&quot; defining whether to plot the fitted
patterns, the residuals of the fit, or both, respectively. Default = &quot;fit&quot;.</p>
</td></tr>
<tr><td><code id="plot.powdRfps_+3A_group">group</code></td>
<td>
<p>A logical parameter used to specify whether the plotted data are grouped
according to the phase name. Default = FALSE.</p>
</td></tr>
<tr><td><code id="plot.powdRfps_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector providing limits of the x-axis (E.g. <code>c(10, 60)</code>).
Defaults to full x-axis unless specified.</p>
</td></tr>
<tr><td><code id="plot.powdRfps_+3A_show_excluded">show_excluded</code></td>
<td>
<p>A logical value specifying whether the areas excluded from the
fitting are identified in the plot as grey rectangles. Default <code>= TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.powdRfps_+3A_interactive">interactive</code></td>
<td>
<p>logical. If TRUE then the output will be an interactive
ggplotly object. If FALSE then the output will be a ggplot object.</p>
</td></tr>
<tr><td><code id="plot.powdRfps_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When seeking to inspect the results from full pattern summation, interactive
plots are particularly useful and can be specified with the <code>interactive</code>
argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

# Load the soils data
data(soils)

## Not run: 
fps_sand &lt;-  fps(lib = minerals,
                smpl = soils$sandstone,
                refs = minerals$phases$phase_id,
                std = "QUA.1",
                align = 0.2)

plot(fps_sand, wavelength = "Cu")
plot(fps_sand, wavelength = "Cu", interactive = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.powdRlib'>Plotting elements of a powdRlib object</h2><span id='topic+plot.powdRlib'></span>

<h3>Description</h3>

<p><code>plot.powdRlib</code> is designed to provide easy, adaptable plots
of an XRPD reference library built using the <code>powdRlib</code> constructor
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRlib'
plot(x, wavelength, refs, interactive, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.powdRlib_+3A_x">x</code></td>
<td>
<p>a powdRlib object</p>
</td></tr>
<tr><td><code id="plot.powdRlib_+3A_wavelength">wavelength</code></td>
<td>
<p>One of &quot;Cu&quot;, &quot;Co&quot; or a custom numeric value defining the wavelength
(in Angstroms). Used to compute d-spacings.When &quot;Cu&quot; or &quot;Co&quot; are supplied, wavelengths
of 1.54056 or 1.78897 are used, respectively.</p>
</td></tr>
<tr><td><code id="plot.powdRlib_+3A_refs">refs</code></td>
<td>
<p>a character string of reference pattern id's to be plotted</p>
</td></tr>
<tr><td><code id="plot.powdRlib_+3A_interactive">interactive</code></td>
<td>
<p>Logical. If TRUE then the output will be an interactive
ggplotly object. If FALSE then the output will be a ggplot object.</p>
</td></tr>
<tr><td><code id="plot.powdRlib_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots can be made interactive using the logical <code>interactive</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the minerals library
data(minerals)
## Not run: 
plot(minerals, wavelength = "Cu", refs = "ALB")
plot(minerals, wavelength = "Cu", refs = "ALB", interactive = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.powdRlm'>Plotting elements of a powdRlm object</h2><span id='topic+plot.powdRlm'></span>

<h3>Description</h3>

<p><code>plot.powdRlm</code> is designed to provide easy, adaptable plots
of full pattern summation outputs produced from <code><a href="#topic+fps_lm">fps_lm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRlm'
plot(x, wavelength, mode, xlim, group, show_excluded, interactive, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.powdRlm_+3A_x">x</code></td>
<td>
<p>a powdRlm object</p>
</td></tr>
<tr><td><code id="plot.powdRlm_+3A_wavelength">wavelength</code></td>
<td>
<p>One of &quot;Cu&quot;, &quot;Co&quot; or a custom numeric value defining the wavelength
(in Angstroms). Used to compute d-spacings.When &quot;Cu&quot; or &quot;Co&quot; are supplied, wavelengths
of 1.54056 or 1.78897 are used, respectively.</p>
</td></tr>
<tr><td><code id="plot.powdRlm_+3A_mode">mode</code></td>
<td>
<p>One of &quot;fit&quot;, &quot;residuals&quot; or &quot;both&quot; defining whether to plot the fitted
patterns, the residuals of the fit, or both, respectively. Default = &quot;fit&quot;.</p>
</td></tr>
<tr><td><code id="plot.powdRlm_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector providing limits of the x-axis (E.g. <code>c(10, 60)</code>).
Defaults to full x-axis unless specified.</p>
</td></tr>
<tr><td><code id="plot.powdRlm_+3A_group">group</code></td>
<td>
<p>A logical parameter used to specify whether the plotted data are grouped
according to the phase name. Default = FALSE.</p>
</td></tr>
<tr><td><code id="plot.powdRlm_+3A_show_excluded">show_excluded</code></td>
<td>
<p>A logical value specifying whether the areas excluded from the
fitting are identified in the plot as grey rectangles. Default <code>= TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.powdRlm_+3A_interactive">interactive</code></td>
<td>
<p>logical. If TRUE then the output will be an interactive
ggplotly object. If FALSE then the output will be a ggplot object.</p>
</td></tr>
<tr><td><code id="plot.powdRlm_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When seeking to inspect the results from full pattern summation, interactive
plots are particularly useful and can be specified with the <code>interactive</code>
argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rockjock)
data(rockjock_mixtures)

#Compute the PCA and loadings
x1 &lt;- xrpd_pca(rockjock_mixtures,
               mean_center = TRUE,
               bin_size = 1,
               root_transform = 1)

## Not run: 
fps_lm_out &lt;- fps_lm(rockjock,
                     smpl = data.frame("x" = x1$loadings$tth,
                                       "y" = x1$loadings$Dim.1),
                     refs = rockjock$phases$phase_id,
                     std = "QUARTZ",
                     align = 0.3,
                     p = 0.01)

plot(fps_lm_out,
     wavelength = "Cu",
     interactive = TRUE,
     group = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.XY'>Plotting an XY object</h2><span id='topic+plot.XY'></span>

<h3>Description</h3>

<p><code>plot.XY</code> is designed to provide easy, adaptable plots
of an XRPD pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XY'
plot(x, wavelength, xlim, normalise, interactive, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.XY_+3A_x">x</code></td>
<td>
<p>an XY object</p>
</td></tr>
<tr><td><code id="plot.XY_+3A_wavelength">wavelength</code></td>
<td>
<p>One of &quot;Cu&quot;, &quot;Co&quot; or a custom numeric value defining the wavelength
(in Angstroms). Used to compute d-spacings.When &quot;Cu&quot; or &quot;Co&quot; are supplied, wavelengths
of 1.54056 or 1.78897 are used, respectively.</p>
</td></tr>
<tr><td><code id="plot.XY_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector providing limits of the x-axis (E.g. <code>c(10, 60)</code>).
Defaults to full x-axis unless specified.</p>
</td></tr>
<tr><td><code id="plot.XY_+3A_normalise">normalise</code></td>
<td>
<p>Logical. If TRUE then count intensities will be normalised to a
minimum of zero and maximum of 1. Default <code>= FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.XY_+3A_interactive">interactive</code></td>
<td>
<p>Logical. If TRUE then the output will be an interactive
ggplotly object. If FALSE then the output will be a ggplot object.</p>
</td></tr>
<tr><td><code id="plot.XY_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots can be made interactive using the logical <code>interactive</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the minerals library
data(rockjock_mixtures)
## Not run: 
plot(rockjock_mixtures$Mix1, wavelength = "Cu")
plot(rockjock_mixtures$Mix1, wavelength = "Cu", interactive = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='powdR'>powdR: Full Pattern Summation of X-Ray Powder Diffraction Data</h2><span id='topic+powdR'></span>

<h3>Description</h3>

<p>An implementation of the full pattern summation approach to quantitative mineralogy
from X-ray powder diffraction data (Chipera &amp; Bish, 2002, 2013; Eberl, 2003;
Butler &amp; Hillier 2021).
</p>


<h3>Author(s)</h3>

<p>Benjamin Butler, The James Hutton Institute, Aberdeen, UK
</p>


<h3>References</h3>

<p>Butler, B. M., Hillier, S., 2021.powdR: An R package for quantitative mineralogy using full pattern
summation of X-ray powder diffraction data. Comp. Geo. 147, 104662. doi:10.1016/j.cageo.2020.104662
</p>
<p>Chipera, S.J., Bish, D.L., 2013. Fitting Full X-Ray Diffraction Patterns for Quantitative Analysis:
A Method for Readily Quantifying Crystalline and Disordered Phases. Adv. Mater. Phys. Chem. 03, 47-53.
doi:10.4236/ampc.2013.31A007
</p>
<p>Chipera, S.J., Bish, D.L., 2002. FULLPAT: A full-pattern quantitative analysis program for X-ray powder
diffraction using measured and calculated patterns. J. Appl. Crystallogr. 35, 744-749.
doi:10.1107/S0021889802017405
</p>
<p>Eberl, D.D., 2003. User's guide to ROCKJOCK - A program for determining quantitative mineralogy from
powder X-ray diffraction data. Boulder, CA.
</p>

<hr>
<h2 id='powdRlib'>Create an XRPD reference library</h2><span id='topic+powdRlib'></span>

<h3>Description</h3>

<p>A constructor function for creating a <code>powdRlib</code> object from two tables of
data. The resulting <code>powdRlib</code> object is required when
using <code><a href="#topic+fps">fps</a></code> or <code><a href="#topic+afps">afps</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powdRlib(xrd_table, phases_table, check_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powdRlib_+3A_xrd_table">xrd_table</code></td>
<td>
<p>A data frame of the count intensities of the XRPD reference patterns,
all scaled to same maximum intensity, with their 2theta axis as the first column.</p>
</td></tr>
<tr><td><code id="powdRlib_+3A_phases_table">phases_table</code></td>
<td>
<p>A data frame of the required data (phase ID, phase name, and reference
intensity ratio) for each reference pattern.</p>
</td></tr>
<tr><td><code id="powdRlib_+3A_check_names">check_names</code></td>
<td>
<p>A logical argument defining whether the column names in the data
supplied in <code>xrd_table</code> are syntactically valid variable names and are not
duplicated. Default = <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a powdRlib object with components:
</p>
<table role = "presentation">
<tr><td><code>xrd</code></td>
<td>
<p>a data frame of the count intensities of the reference patterns</p>
</td></tr>
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta axis</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a 3 column data frame of the IDs, names and reference
intensity ratios of the reference pattern</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#load an example xrd_table
data(minerals_xrd)
#load an example phases_table
data(minerals_phases)

#Create a reference library object
xrd_lib &lt;- powdRlib(xrd_table = minerals_xrd,
                    phases_table = minerals_phases)
</code></pre>

<hr>
<h2 id='r'>Calculate the R value for a fitted pattern</h2><span id='topic+r'></span>

<h3>Description</h3>

<p><code>r</code> computes the difference between a measured and fitted pattern. See
equation for R in section 2.1 of Butler and Hillier (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r(measured, fitted, weighting)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r_+3A_measured">measured</code></td>
<td>
<p>a vector of count intensities for a measured pattern</p>
</td></tr>
<tr><td><code id="r_+3A_fitted">fitted</code></td>
<td>
<p>a vector of count intensities for a fitted pattern</p>
</td></tr>
<tr><td><code id="r_+3A_weighting">weighting</code></td>
<td>
<p>an optional weighting vector of the same length as those specified
in <code>measured</code> and <code>fitted</code>, which specifies areas of the pattern
to either emphasise (values &gt; 1) or omit (values = 0) from the calculation.
Use with caution. Default is simply a weighting vector where all values are 1, which
hence has no effect on the computed value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value
</p>


<h3>References</h3>

<p>Butler, B.M., Hillier, S., 2021. powdR: An R package for quantitative mineralogy using full pattern summation
of X-ray powder diffraction data. Computers and Geosciences. 147, 104662. doi:10.1016/j.cageo.2020.104662
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load soils xrd data
data(soils)

#Load minerals library
data(minerals)

## Not run: 
#Produce a fit
fps_sand &lt;-  fps(lib = minerals,
                 smpl = soils$sandstone,
                 refs = minerals$phases$phase_id,
                 std = "QUA.1",
                 align = 0.2)

r(measured = fps_sand$measured,
  fitted = fps_sand$fitted)


## End(Not run)

</code></pre>

<hr>
<h2 id='read_xy'>Read ASCII XY data</h2><span id='topic+read_xy'></span>

<h3>Description</h3>

<p><code>read_xy</code> is a wrapper for <code>read.csv</code> that is designed for space separated XRPD
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_xy(files, header, sep)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_xy_+3A_files">files</code></td>
<td>
<p>path of the file(s) to be imported.</p>
</td></tr>
<tr><td><code id="read_xy_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains the names
of the variables as its first line. Default = <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="read_xy_+3A_sep">sep</code></td>
<td>
<p>the field separator character. Values on each line of the file
are separated by this character. Default = <code>" "</code>, indicating space
separated format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If only one path is supplied then an XY data frame with 2 columns is returned,
the first being the 2theta axis and the second being the count intensities. If more
than one path is supplied then a multiXY list is returned, with each item in the list being
an XY data frame as already described.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load example XY file
file &lt;- system.file("extdata/D5000/xy/D5000_1.xy", package = "powdR")
xy &lt;- read_xy(file)

#Load multiple XY files
files &lt;- dir(system.file("extdata/D5000/xy", package = "powdR"),
             full.names = TRUE)
xy_list &lt;- read_xy(files)

## Not run: 
plot(xy_list, wavelength = "Cu")
plot(xy_list, wavelength = "Cu", interactive = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='regroup'>regroup</h2><span id='topic+regroup'></span>

<h3>Description</h3>

<p><code>regroup</code> allows an alternative grouping structure to be applied to <code>powdRfps</code>
and <code>powdRafps</code> objects. For more details see <code>?regroup.powdRfps</code> or
<code>?regroup.powdRafps</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroup(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regroup_+3A_x">x</code></td>
<td>
<p>A <code>powdRfps</code> or <code>powdRafps</code> object</p>
</td></tr>
<tr><td><code id="regroup_+3A_...">...</code></td>
<td>
<p>Other parameters passed to methods e.g. <code>fps.powdRlib</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>powdRfps</code> and <code>powdRafps</code> objects contain a data frame called <code>phases_grouped</code>
that summarises phase concentrations based on defined mineral groups from the <code>powdRlib</code>
reference library. <code>regroup</code> allows you to change this grouping structure by supplying
new group identities.
</p>


<h3>Value</h3>

<p>a <code>powdRfps</code> or <code>powdRafps</code> object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the count intensities of fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the count intensities of original XRPD measurement (aligned)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped and summed by phase_name</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

#Load the soils data
data(soils)

#Load the regrouping structure
data(minerals_regroup)

## Not run: 
fps_sandstone &lt;- fps(lib = minerals,
                     smpl = soils$sandstone,
                     refs = minerals$phases$phase_id,
                     std = "QUA.1",
                     align = 0.2)

fps_sandstone_regrouped &lt;- regroup(fps_sandstone,
                                   minerals_regroup)

fps_sandstone_regrouped$phases_grouped


## End(Not run)
</code></pre>

<hr>
<h2 id='regroup.powdRafps'>regroup</h2><span id='topic+regroup.powdRafps'></span>

<h3>Description</h3>

<p><code>regroup.powdRafps</code> allows an alternative grouping structure to be applied to
<code>powdRafps</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRafps'
regroup(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regroup.powdRafps_+3A_x">x</code></td>
<td>
<p>A <code>powdRafps</code> object</p>
</td></tr>
<tr><td><code id="regroup.powdRafps_+3A_y">y</code></td>
<td>
<p>A data frame. First column contains the phase IDs covering all those present in
<code>x$phases$phase_id</code>. Second column contains the desired grouping of each phase.</p>
</td></tr>
<tr><td><code id="regroup.powdRafps_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>powdRafps</code> objects contain a data frame called <code>phases_grouped</code>
that summarises phase concentrations based on defined mineral groups from the <code>powdRlib</code>
reference library. <code>regroup</code> allows you to change this grouping structure by supplying
new group identities.
</p>


<h3>Value</h3>

<p>a <code>powdRafps</code> object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the count intensities of fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the count intensities of original XRPD measurement (aligned)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped and summed by phase_name</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

# Load the soils data
data(soils)

#Load the regrouping structure
data(minerals_regroup)

## Not run: 
afps_sandstone &lt;- afps(lib = minerals,
                       smpl = soils$sandstone,
                       std = "QUA.2",
                       align = 0.2,
                       lod = 0.2,
                       amorphous = "ORG",
                       amorphous_lod = 1)

afps_sandstone_regrouped &lt;- regroup(afps_sandstone,
                                    minerals_regroup)

afps_sandstone_regrouped$phases_grouped

## End(Not run)
</code></pre>

<hr>
<h2 id='regroup.powdRfps'>regroup</h2><span id='topic+regroup.powdRfps'></span>

<h3>Description</h3>

<p><code>regroup.powdRfps</code> allows an alternative grouping structure to be applied to <code>powdRfps</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRfps'
regroup(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regroup.powdRfps_+3A_x">x</code></td>
<td>
<p>A <code>powdRfps</code> object</p>
</td></tr>
<tr><td><code id="regroup.powdRfps_+3A_y">y</code></td>
<td>
<p>A data frame. First column contains the phase IDs covering all those present in
<code>x$phases$phase_id</code>. Second column contains the desired grouping of each phase.</p>
</td></tr>
<tr><td><code id="regroup.powdRfps_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>powdRfps</code> objects contain a data frame called <code>phases_grouped</code>
that summarises phase concentrations based on defined mineral groups from the <code>powdRlib</code>
reference library. <code>regroup</code> allows you to change this grouping structure by supplying
new group identities.
</p>


<h3>Value</h3>

<p>a <code>powdRfps</code> object with components:
</p>
<table role = "presentation">
<tr><td><code>tth</code></td>
<td>
<p>a vector of the 2theta scale of the fitted data</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector of the count intensities of fitted XRPD pattern</p>
</td></tr>
<tr><td><code>measured</code></td>
<td>
<p>a vector of the count intensities of original XRPD measurement (aligned)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of the residuals (measured minus fitted)</p>
</td></tr>
<tr><td><code>phases</code></td>
<td>
<p>a dataframe of the phases used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>phases_grouped</code></td>
<td>
<p>the phases dataframe grouped and summed by phase_name</p>
</td></tr>
<tr><td><code>obj</code></td>
<td>
<p>named vector of the objective parameters summarising the quality of the fit</p>
</td></tr>
<tr><td><code>weighted_pure_patterns</code></td>
<td>
<p>a dataframe of reference patterns used to produce the fitted pattern.
All patterns have been weighted according to the coefficients used in the fit</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients used to produce the fitted pattern</p>
</td></tr>
<tr><td><code>inputs</code></td>
<td>
<p>a list of input arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

#Load the soils data
data(soils)

#Load the regrouping structure
data(minerals_regroup)

## Not run: 
fps_sandstone &lt;- fps(lib = minerals,
                     smpl = soils$sandstone,
                     refs = minerals$phases$phase_id,
                     std = "QUA.1",
                     align = 0.2)

fps_sandstone_regrouped &lt;- regroup(fps_sandstone,
                                   minerals_regroup)

fps_sandstone_regrouped$phases_grouped


## End(Not run)
</code></pre>

<hr>
<h2 id='rockjock'>RockJock reference library</h2><span id='topic+rockjock'></span>

<h3>Description</h3>

<p>A <code>powdRlib</code> object of 168 pure reference patterns from the RockJock
library (Cu K-alpha radiation) along with reference intensity ratios. Note that compared
to same library supplied with RockJock the powdR patterns have been normalised to 10,000
counts and reference intensity ratios transformed so that all are relative
to that of corundum, which has been set to a value of 1.0.
Can be used with the <code>fps()</code> and <code>afps()</code> functions for quantitative
analysis. Example mixtures for testing the <code>rockjock</code> library with known
concentrations are available in the <code>rockjock_mixtures</code> data. See
<code>?rockjock_mixtures</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rockjock
</code></pre>


<h3>Format</h3>

<p>A powdRlib object of 3 components
</p>

<dl>
<dt>xrd</dt><dd><p>A dataframe of all the count intensities of all reference patterns. Column names denote the
unique phase ID of each reference pattern</p>
</dd>
<dt>tth</dt><dd><p>A vector of the 2theta scale for all reference patterns in the library</p>
</dd>
<dt>phases</dt><dd><p>A dataframe the phase IDs, names and reference intensity
ratios (RIR)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Dennis Eberl
</p>


<h3>References</h3>

<p>Eberl, D.D., 2003. User's guide to RockJock - A program for determining quantitative mineralogy from
powder X-ray diffraction data. Boulder, CA.
</p>

<hr>
<h2 id='rockjock_mixtures'>RockJock synthetic mixtures</h2><span id='topic+rockjock_mixtures'></span>

<h3>Description</h3>

<p>A multiXY list containing 8 XRPD measurements (Cu K-alpha radiation) of synthetic mixtures
that can be used to assess accuracy of quantitative analysis from the <code>fps()</code>
and <code>afps()</code> functions. The mixtures contain various amounts of quartz (QUARTZ
standard of the <code>rockjock</code> library), K-feldspar (ORDERED_MICROCLINE),
plagioclase (LABRADORITE), kaolinite (KAOLINITE_DRY_BRANCH), dioctahedral smectite
(MONTMORILLIONITE_WYO), illite (ILLITE_1M_RM30) and corundum (CORUNDUM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rockjock_mixtures
</code></pre>


<h3>Format</h3>

<p>A multiXY list of 8 components, each comprised of two columns. Column <code>tth</code> specifies
the 2theta axis and <code>counts</code> specifies the count intensities. The mixtures have to following
compositions that are also tabulated in the <code>rockjock_weights</code> data.
</p>

<dl>
<dt>Mix1</dt><dd><p>Contains: 4 % K-feldspar, 20 % plagioclase, 12 % kaolinite, 36 % dioctahedral
smectite, 8 % illite and 20 % corundum.</p>
</dd>
<dt>Mix2</dt><dd><p>Contains: 4 % quartz, 8 % K-feldspar, 36 % plagioclase, 20 % kaolinite,
12 % illite and 20 % corundum.</p>
</dd>
<dt>Mix3</dt><dd><p>Contains: 8 % quartz, 12 % K-feldspar, 36 % kaolinite, 4 % dioctahedral
smectite, 20 % illite and 20 % corundum.</p>
</dd>
<dt>Mix4</dt><dd><p>Contains: 12 % quartz, 20 % K-feldspar, 4 % plagioclase, 8 % dioctahedral
smectite, 36 % illite and 20 % corundum.</p>
</dd>
<dt>Mix5</dt><dd><p>Contains: 20 % quartz, 36 % K-feldspar, 8 % plagioclase, 4 % kaolinite,
12 % dioctahedral smectite and 20 % corundum.</p>
</dd>
<dt>Mix6</dt><dd><p>Contains: 36 % quartz, 12 % plagioclase, 8 % kaolinite, 20 % dioctahedral
smectite, 4 % illite and 20 % corundum.</p>
</dd>
<dt>Mix7</dt><dd><p>Contains: 8 % K-feldspar, 40 % plagioclase, 4 % kaolinite, 12 % dioctahedral
smectite, 16 % illite and 20 % corundum.</p>
</dd>
<dt>Mix8</dt><dd><p>Contains: 8 % quartz, 4 % K-feldspar, 4 % plagioclase, 24 % dioctahedral
smectite, 40 % illite and 20 % corundum.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Dennis Eberl
</p>


<h3>References</h3>

<p>Eberl, D.D., 2003. User's guide to RockJock - A program for determining quantitative mineralogy from
powder X-ray diffraction data. Boulder, CA.
</p>

<hr>
<h2 id='rockjock_regroup'>Regrouping structure for the rockjock reference library</h2><span id='topic+rockjock_regroup'></span>

<h3>Description</h3>

<p>A data frame containing an example re-grouping structure for the <code>rockjock</code>
reference library, which results in a slightly coarser description of clay
minerals and Fe/Ti-(hydr)oxides in <code>powdRfps</code> or <code>powdRafps</code> objects
when used with <code>regroup()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rockjock_regroup
</code></pre>


<h3>Format</h3>

<p>A data frame with three columns:
</p>

<dl>
<dt>phase_id</dt><dd><p>the phase IDs present in <code>afsis$phases$phase_id</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>phase_name_grouped</dt><dd><p>The phase names that constitute the first
regrouping structure.</p>
</dd>
<dt>phase_name_grouped2</dt><dd><p>The phase names that constitute the second
regrouping structure</p>
</dd>
</dl>


<hr>
<h2 id='rockjock_weights'>Mineral concentrations of the <code>rockjock_mixtures</code> data</h2><span id='topic+rockjock_weights'></span>

<h3>Description</h3>

<p>A dataframe summarising the weighed mineral concentrations of the <code>rockjock_mixtures</code> data,
all in units of weight percent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rockjock_weights
</code></pre>


<h3>Format</h3>

<p>An 8 column dataframe, with each row detailing the composition of a sample.
</p>


<h3>Author(s)</h3>

<p>Dennis Eberl
</p>


<h3>References</h3>

<p>Eberl, D.D., 2003. User's guide to RockJock - A program for determining quantitative mineralogy from
powder X-ray diffraction data. Boulder, CA.
</p>

<hr>
<h2 id='run_bkg'>Run the background fitting shiny app</h2><span id='topic+run_bkg'></span>

<h3>Description</h3>

<p>A wrapper for <code>shiny::runApp</code> to start the <code>powdR</code>
background fitting Shiny app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_bkg(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_bkg_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>shiny::runApp</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

run_powdR()


## End(Not run)

</code></pre>

<hr>
<h2 id='run_powdR'>Run the powdR shiny app</h2><span id='topic+run_powdR'></span>

<h3>Description</h3>

<p>A wrapper for <code>shiny::runApp</code> to start the Shiny app for <code>powdR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_powdR(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_powdR_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code>shiny::runApp</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

run_powdR()


## End(Not run)

</code></pre>

<hr>
<h2 id='rwp'>Calculate the Rwp value for a fitted pattern</h2><span id='topic+rwp'></span>

<h3>Description</h3>

<p><code>rwp</code> computes the difference between a measured and fitted pattern. See
equation for Rwp in section 2.1 of Butler and Hillier (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwp(measured, fitted, weighting)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rwp_+3A_measured">measured</code></td>
<td>
<p>a vector of count intensities for a measured pattern</p>
</td></tr>
<tr><td><code id="rwp_+3A_fitted">fitted</code></td>
<td>
<p>a vector of count intensities for a fitted pattern</p>
</td></tr>
<tr><td><code id="rwp_+3A_weighting">weighting</code></td>
<td>
<p>an optional weighting vector of the same length as those specified
in <code>measured</code> and <code>fitted</code>, which specifies areas of the pattern
to either emphasise (values &gt; 1) or omit (values = 0) from the calculation.
Use with caution. Default is simply a weighting vector where all values are 1, which
hence has no effect on the computed value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value
</p>


<h3>References</h3>

<p>Butler, B.M., Hillier, S., 2021. powdR: An R package for quantitative mineralogy using full pattern summation
of X-ray powder diffraction data. Computers and Geosciences. 147, 104662. doi:10.1016/j.cageo.2020.104662
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load soils xrd data
data(soils)

#Load minerals library
data(minerals)

## Not run: 
#Produce a fit
fps_sand &lt;-  fps(lib = minerals,
                 smpl = soils$sandstone,
                 refs = minerals$phases$phase_id,
                 std = "QUA.1",
                 align = 0.2)

rwp(measured = fps_sand$measured,
    fitted = fps_sand$fitted)


## End(Not run)

</code></pre>

<hr>
<h2 id='soils'>Example soil XRPD data</h2><span id='topic+soils'></span>

<h3>Description</h3>

<p>3 soil samples from different parent materials measured by XRPD (Cu K-alpha radiation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soils
</code></pre>


<h3>Format</h3>

<p>A multiXY list of 3 XY dataframes (named according to parent material type),
with each XY dataframe containing two columns of:
</p>

<dl>
<dt>tth</dt><dd><p>The 2theta measurement intervals</p>
</dd>
<dt>counts</dt><dd><p>The count intensities</p>
</dd>
</dl>


<hr>
<h2 id='subset.powdRlib'>Subset a powdRlib object</h2><span id='topic+subset.powdRlib'></span>

<h3>Description</h3>

<p><code>subset.powdRlib</code> is designed to provide an easy way of
subsetting a <code>powdRlib</code> object by defining the phase ID's
that the user wishes to either keep or remove.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'powdRlib'
subset(x, refs, mode, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.powdRlib_+3A_x">x</code></td>
<td>
<p>a <code>powdRlib</code> object.</p>
</td></tr>
<tr><td><code id="subset.powdRlib_+3A_refs">refs</code></td>
<td>
<p>a string of the phase IDs or names of reference patterns to be subset. The ID's
or names supplied must be present within the <code>lib$phases$phase_id</code> or
<code>lib$phases$phase_name</code> columns.</p>
</td></tr>
<tr><td><code id="subset.powdRlib_+3A_mode">mode</code></td>
<td>
<p>denotes whether the phase IDs or names defined in the <code>refs</code> argument are
retained (<code>"keep"</code>) or removed (<code>"remove"</code>).</p>
</td></tr>
<tr><td><code id="subset.powdRlib_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>powdRlib</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Load the minerals library
data(minerals)

minerals_keep &lt;- subset(minerals,
                        refs = c("QUA.1", "QUA.2"),
                        mode = "keep")

minerals_remove &lt;- subset(minerals,
                          refs = c("QUA.1", "QUA.2"),
                          mode = "remove")
</code></pre>

<hr>
<h2 id='summarise_mineralogy'>Summarise the mineralogy from multiple powdRfps and powdRafps outputs</h2><span id='topic+summarise_mineralogy'></span>

<h3>Description</h3>

<p><code>summarise_mineralogy</code> creates a summary table of quantified mineral
concentrations across a given dataset using a list of multiple <code>powdRfps</code>
or <code>powdRafps</code> derived from <code>fps()</code> and <code>afps()</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_mineralogy(x, type, order, rwp, r, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarise_mineralogy_+3A_x">x</code></td>
<td>
<p>a list of <code>powdRfps</code> or <code>powdRafps</code> objects.</p>
</td></tr>
<tr><td><code id="summarise_mineralogy_+3A_type">type</code></td>
<td>
<p>a string specifying whether the table uses all phase ID's, or
summarises them according to the phase name. One of <code>"all"</code> or <code>"grouped"</code>.</p>
</td></tr>
<tr><td><code id="summarise_mineralogy_+3A_order">order</code></td>
<td>
<p>a logical operator denoting whether the columns of the resulting summary
table are ordered in descending order according to the summed abundance of each phase
across the dataset.</p>
</td></tr>
<tr><td><code id="summarise_mineralogy_+3A_rwp">rwp</code></td>
<td>
<p>a logical operator denoting whether to include the Rwp value as the final column
in the output. This provides an objective measure of the difference between the fitted
and measured patterns.</p>
</td></tr>
<tr><td><code id="summarise_mineralogy_+3A_r">r</code></td>
<td>
<p>a logical operator denoting whether to include the R value as the final column
in the output. This provides an objective measure of the difference between the fitted
and measured patterns.</p>
</td></tr>
<tr><td><code id="summarise_mineralogy_+3A_delta">delta</code></td>
<td>
<p>a logical operator denoting whether to include the Delta value as the final column
in the output. This provides an objective measure of the difference between the fitted
and measured patterns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(minerals)
data(soils)

## Not run: 
multiple_afps &lt;- lapply(soils, afps,
                        lib = minerals,
                        std = "QUA.1",
                        align = 0.2,
                        lod = 0.1,
                        amorphous = "ORG",
                        amorphous_lod = 1)

sm1 &lt;- summarise_mineralogy(multiple_afps,
                            type = "all",
                            order = TRUE)

sm2 &lt;- summarise_mineralogy(multiple_afps,
                            type = "grouped",
                            order = TRUE)

sm3 &lt;- summarise_mineralogy(multiple_afps,
                            type = "grouped",
                            order = TRUE,
                            rwp = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='tth_transform'>Transform a two theta axis between wavelengths</h2><span id='topic+tth_transform'></span>

<h3>Description</h3>

<p><code>tth_transform</code> converts the two theta axis from one wavelength to another via Bragg's law.
Use this function with caution if intending the apply <code>fps()</code> or <code>afps()</code> to wavelength
transformed samples or libraries because background signals can vary with wavelength which may
therefore affect the quality of the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tth_transform(tth, from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tth_transform_+3A_tth">tth</code></td>
<td>
<p>the 2theta vector to be transformed</p>
</td></tr>
<tr><td><code id="tth_transform_+3A_from">from</code></td>
<td>
<p>numeric value defining the wavelength (Angstroms) to transform from</p>
</td></tr>
<tr><td><code id="tth_transform_+3A_to">to</code></td>
<td>
<p>numeric value defining the wavelength (Angstroms) to transform to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a transformed 2theta vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soils)
sandstone2 &lt;- soils$sandstone

#Convert from Cu (1.54056 Angstroms) to Co (1.78897 Angstroms)
sandstone2$tth &lt;- tth_transform(sandstone2$tth,
                                from = 1.54056,
                                to = 1.78897)

sandstone_list &lt;- as_multi_xy(list("sandstone" = soils$sandstone,
                                   "sandstone2" = sandstone2))
#plot the change
plot(sandstone_list, wavelength = "Cu")

#Alternatively convert the 2theta axis of a library
data(minerals)

minerals2 &lt;- minerals
minerals2$tth &lt;- tth_transform(minerals2$tth,
                                from = 1.54056,
                                to = 1.78897)

#Plot the difference
plot(x = minerals$tth, y = minerals$xrd$QUA.1,
     type = "l", xlim = c(0, 85))
lines(x = minerals2$tth, y = minerals2$xrd$QUA.1,
      col = "red")
</code></pre>

<hr>
<h2 id='xrpd_pca'>PCA of XRPD data</h2><span id='topic+xrpd_pca'></span>

<h3>Description</h3>

<p><code>xrpd_pca</code> is used to apply principal component analysis to X-ray powder
diffraction data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xrpd_pca(x, mean_center, bin_size, root_transform, components)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xrpd_pca_+3A_x">x</code></td>
<td>
<p>A multiXY list containing the XRPD data, where each item in the
list is a 2 column XY dataframe defining the x (2theta) and y (counts)
axes of each measurement. Each item in the list must have a name corresponding
to a unique sample ID.</p>
</td></tr>
<tr><td><code id="xrpd_pca_+3A_mean_center">mean_center</code></td>
<td>
<p>A logical argument defining whether mean centering
is applied to the XRPD data (default <code>= TRUE</code>).</p>
</td></tr>
<tr><td><code id="xrpd_pca_+3A_bin_size">bin_size</code></td>
<td>
<p>An integer between 1 and 10 defining whether to bin the
XRPD data to a lower resolution. This <code>bin_size</code> defines the number of
data points used in each bin.</p>
</td></tr>
<tr><td><code id="xrpd_pca_+3A_root_transform">root_transform</code></td>
<td>
<p>An integer between 1 and 8 defining the root transform
to apply to the XRPD data</p>
</td></tr>
<tr><td><code id="xrpd_pca_+3A_components">components</code></td>
<td>
<p>An integer defining the number of principal components to
include in the output. Must be at least 1 less than the
number of XRPD patterns in the dataset (the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies data pre-treatment and principal components analysis to XRPD data based
based on the protocols detailed in Butler et al. (2020).
</p>


<h3>Value</h3>

<p>a list with components:
</p>
<table role = "presentation">
<tr><td><code>coords</code></td>
<td>
<p>a dataframe containing the sample ID's for each sample and the
PCA coordinates for each dimension</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>a dataframe containing the 2theta axis and the loading of
each dimension</p>
</td></tr>
<tr><td><code>eig</code></td>
<td>
<p>a dataframe summarising the variance explained by each dimension</p>
</td></tr>
</table>


<h3>References</h3>

<p>Butler, B.M., Sila, A.M., Shepherd, K.D., Nyambura, M., Gilmore, C.J., Kourkoumelis,
N., Hillier, S., 2019. Pre-treatment of soil X-ray powder diffraction data for
cluster analysis. Geoderma 337, 413-424. doi:10.4236/ampc.2013.31A007
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rockjock_mixtures)

x1 &lt;- xrpd_pca(rockjock_mixtures,
               mean_center = TRUE,
               bin_size = 1,
               root_transform = 1)

#Plot the loading of dimension 1

plot(x = x1$loadings$tth,
     y = x1$loadings$Dim.1,
     type = "l")

## Not run: 
#Fit loading 1 to the rockjock library
f1 &lt;- fps_lm(rockjock,
             smpl = data.frame("tth" = x1$loadings$tth,
                               "counts" = x1$loadings$Dim.1),
             refs = rockjock$phases$phase_id,
             std = "QUARTZ",
             align = 0,
             p = 0.05)

plot(f1, wavelength = "Cu", interactive = TRUE)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
