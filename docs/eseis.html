<!DOCTYPE html><html><head><title>Help for package eseis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eseis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eseis'><p>eseis: Environmental Seismology Toolbox</p></a></li>
<li><a href='#aux_commondt'><p>Identify highest common sampling interval</p></a></li>
<li><a href='#aux_cubeinfo'><p>Get cube file information</p></a></li>
<li><a href='#aux_eseisobspy'><p>Convert eseis object to ObsPy stream object</p></a></li>
<li><a href='#aux_fixmseed'><p>Fix corrupt miniseed files</p></a></li>
<li><a href='#aux_getevent'><p>Load seismic data of a user-defined event</p></a></li>
<li><a href='#aux_getFDSNdata'><p>Download seismic data from FDSN data base</p></a></li>
<li><a href='#aux_getFDSNstation'><p>Query FDSN data base for stations</p></a></li>
<li><a href='#aux_getIRISdata'><p>Download seismic data from IRIS data base</p></a></li>
<li><a href='#aux_getIRISstation'><p>Query IRIS data base for stations</p></a></li>
<li><a href='#aux_gettemperature'><p>Extract temperature data from cube files.</p></a></li>
<li><a href='#aux_hvanalysis'><p>Perform H-V-spectral ratio analysis of a seismic data set</p></a></li>
<li><a href='#aux_initiateeseis'><p>Initiate an eseis object</p></a></li>
<li><a href='#aux_obspyeseis'><p>Convert ObsPy object to eseis object</p></a></li>
<li><a href='#aux_organisecentaurfiles'><p>Reorganise seismic files recorded by Nanometrics Centaur loggers</p></a></li>
<li><a href='#aux_organisecubefiles'><p>Convert Omnirecs/Digos Datacube files to mseed or sac files and organise in directory structure.</p></a></li>
<li><a href='#aux_psdsummary'><p>Calculate aggregated PSDs over long time periods</p></a></li>
<li><a href='#aux_sonifysignal'><p>Convert seismic signal to sound (sonification)</p></a></li>
<li><a href='#aux_stationinfofile'><p>Create station info file from cube files.</p></a></li>
<li><a href='#earthquake'><p>Seismic traces of a small earthquake</p></a></li>
<li><a href='#fmi_inversion'><p>Invert fluvial data set based on reference spectra catalogue</p></a></li>
<li><a href='#fmi_parameters'><p>Create reference model reference parameter catalogue</p></a></li>
<li><a href='#fmi_spectra'><p>Create reference model spectra catalogue</p></a></li>
<li><a href='#gui_models'><p>Start GUI with seismic models</p></a></li>
<li><a href='#list_logger'><p>List library with data logger information.</p></a></li>
<li><a href='#list_sacparameters'><p>List all header parameters of a sac file.</p></a></li>
<li><a href='#list_sensor'><p>List sensor library.</p></a></li>
<li><a href='#model_amplitude'><p>Model source amplitude by amplitude-distance model fitting</p></a></li>
<li><a href='#model_bedload'><p>Model the seismic spectrum due to bedload transport in rivers</p></a></li>
<li><a href='#model_turbulence'><p>Model the seismic spectrum due to hydraulic turbulence</p></a></li>
<li><a href='#pick_correlation'><p>Signal correlation based event picking</p></a></li>
<li><a href='#pick_kurtosis'><p>Kutosis based event picking</p></a></li>
<li><a href='#pick_stalta'><p>Calculate stal-lta-ratio.</p></a></li>
<li><a href='#plot_components'><p>Plot three seismic components against each other</p></a></li>
<li><a href='#plot_ppsd'><p>Plot a probabilistic power spectral density estimate (PPSD)</p></a></li>
<li><a href='#plot_signal'><p>Plot a seismic signal</p></a></li>
<li><a href='#plot_spectrogram'><p>Plot spectrograms (power spectral density estimates)</p></a></li>
<li><a href='#plot_spectrum'><p>Plot a spectrum of a seismic signal</p></a></li>
<li><a href='#read_data'><p>Load seismic data from an archive</p></a></li>
<li><a href='#read_fdsn'><p>Download and import seismic data from an FDSN service provider</p></a></li>
<li><a href='#read_mseed'><p>Read mseed files.</p></a></li>
<li><a href='#read_sac'><p>Read sac files.</p></a></li>
<li><a href='#rockfall'><p>Seismic trace of a rockfall event.</p></a></li>
<li><a href='#signal_aggregate'><p>Aggregate a signal vector</p></a></li>
<li><a href='#signal_clip'><p>Clip signal based on time vector.</p></a></li>
<li><a href='#signal_cut'><p>Cut signal amplitude at standard deviation-defined level.</p></a></li>
<li><a href='#signal_deconvolve'><p>Deconvolve a signal vector.</p></a></li>
<li><a href='#signal_demean'><p>Remove mean of signal vector.</p></a></li>
<li><a href='#signal_detrend'><p>Detrend a signal vector.</p></a></li>
<li><a href='#signal_envelope'><p>Calculate signal envelope.</p></a></li>
<li><a href='#signal_fill'><p>Fill NA-gaps of a signal</p></a></li>
<li><a href='#signal_filter'><p>Filter a seismic signal in the time or frequency domain</p></a></li>
<li><a href='#signal_hilbert'><p>Calculate Hilbert transform.</p></a></li>
<li><a href='#signal_hvratio'><p>Calculate h-v-ratio of seismic components</p></a></li>
<li><a href='#signal_integrate'><p>Integrate a seismic signal</p></a></li>
<li><a href='#signal_motion'><p>Calculate particle motion parameters</p></a></li>
<li><a href='#signal_pad'><p>Pad signal with zeros.</p></a></li>
<li><a href='#signal_rotate'><p>Rotate signal vectors using a 3-D rotation matrix.</p></a></li>
<li><a href='#signal_sign'><p>Convert amplitude signal to one bit signed signal</p></a></li>
<li><a href='#signal_snr'><p>Calculate signal-to-noise-ratio.</p></a></li>
<li><a href='#signal_spectrogram'><p>Calculate spectrograms (power spectral density estimates) from time series.</p></a></li>
<li><a href='#signal_spectrum'><p>Calculate the spectrum of a time series</p></a></li>
<li><a href='#signal_stats'><p>Calculate signal statistics</p></a></li>
<li><a href='#signal_sum'><p>Calculate signal vector sum.</p></a></li>
<li><a href='#signal_taper'><p>Taper a signal vector.</p></a></li>
<li><a href='#signal_whiten'><p>Perform spectral whitening of a signal vector</p></a></li>
<li><a href='#spatial_amplitude'><p>Locate the source of a seismic event by modelling amplutide attenuation</p></a></li>
<li><a href='#spatial_clip'><p>Clip values of spatial data.</p></a></li>
<li><a href='#spatial_convert'><p>Convert coordinates between reference systems</p></a></li>
<li><a href='#spatial_crop'><p>Crop extent of spatial data.</p></a></li>
<li><a href='#spatial_distance'><p>Calculate topography-corrected distances for seismic waves.</p></a></li>
<li><a href='#spatial_migrate'><p>Migrate signals of a seismic event through a grid of locations.</p></a></li>
<li><a href='#spatial_pmax'><p>Get most likely source location</p></a></li>
<li><a href='#spatial_track'><p>Track a spatially mobile seismic source</p></a></li>
<li><a href='#time_aggregate'><p>Aggregate a time series</p></a></li>
<li><a href='#time_clip'><p>Clip time vector.</p></a></li>
<li><a href='#time_convert'><p>Convert Julian Day to Date and vice versa</p></a></li>
<li><a href='#write_mseed'><p>Write seismic traces as mseed file to disk.</p></a></li>
<li><a href='#write_report'><p>Create a HTML report for (RLum) objects</p></a></li>
<li><a href='#write_sac'><p>Write seismic traces as sac file to disk.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Environmental Seismology Toolbox</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-31</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Dietze &lt;michael.dietze@uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Environmental seismology is a scientific field that studies the  
    seismic signals, emitted by Earth surface processes. This package 
    provides all relevant functions to read/write seismic data files, prepare, 
    analyse and visualise seismic data, and generate reports of the processing 
    history.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>terra, caTools, signal, fftw, matrixStats, methods,
IRISSeismic, XML, shiny, rmarkdown, colorspace, reticulate,
extraDistr, minpack.lm, Rcpp (&ge; 1.0.7)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plot3D, rgl, seewave</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gipptools dataselect</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-31 17:24:02 UTC; micha</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Dietze [cre, aut, trl],
  Christoph Burow [ctb],
  Sophie Lagarde [ctb, trl]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-10 14:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='eseis'>eseis: Environmental Seismology Toolbox</h2><span id='topic+eseis'></span><span id='topic+eseis-package'></span>

<h3>Description</h3>

<p>Environmental seismoloy is a scientific field that studies the seismic 
signals, emitted by Earth surface processes. This package eseis provides 
all relevant functions to read/write seismic data files, prepare, analyse
and visualise seismic data, and generate reports of the processing history.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
**Package:** </td><td style="text-align: left;"> eseis </td>
</tr>
<tr>
 <td style="text-align: left;">
**Type:** </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
**Version:** </td><td style="text-align: left;"> 0.4.0 </td>
</tr>
<tr>
 <td style="text-align: left;">
**Date:** </td><td style="text-align: left;"> 2021-11-23 </td>
</tr>
<tr>
 <td style="text-align: left;">
**License:** </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Michael Dietze
</p>

<hr>
<h2 id='aux_commondt'>Identify highest common sampling interval</h2><span id='topic+aux_commondt'></span>

<h3>Description</h3>

<p>The function compares the sampling intervals of a list of <code>eseis</code>
objects and identifies the highest common sampling interval (dt) as well 
as the aggregation factors for each <code>eseis</code> object needed to reach 
this common sampling interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_commondt(data, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_commondt_+3A_data">data</code></td>
<td>
<p><code>list</code> of <code>eseis</code> objects or vector of sampling 
intervals to be checked for highest common sampling interval</p>
</td></tr>
<tr><td><code id="aux_commondt_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> vector of length one, user-defined common 
sampling frequency for which aggregation factors shall be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> object with elements <code>dt</code> (highest common 
sampling interval) and <code>agg</code> (aggregation factors for each 
of the input data sets to reach the common sampling interval)
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## TO BE WRITTEN

## End(Not run)
                     
</code></pre>

<hr>
<h2 id='aux_cubeinfo'>Get cube file information</h2><span id='topic+aux_cubeinfo'></span>

<h3>Description</h3>

<p>This is a simple wrapper for the Gipptools program <code>cubeinfo</code>, 
providing a short summary of the cube file meta data, in a coherent 
data frame structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_cubeinfo(file, gipptools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_cubeinfo_+3A_file">file</code></td>
<td>
<p><code>Characater</code> value, cube file to be processes</p>
</td></tr>
<tr><td><code id="aux_cubeinfo_+3A_gipptools">gipptools</code></td>
<td>
<p><code>Character</code> value, path to gipptools or 
Gipptools directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data frame</code> with cube meta data
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## get cube info
x = aux_cubeinfo(file = "data/cube/example.ATB", 
                 gipptools = "/software/gipptools-2019.332/")


## End(Not run)

</code></pre>

<hr>
<h2 id='aux_eseisobspy'>Convert eseis object to ObsPy stream object</h2><span id='topic+aux_eseisobspy'></span>

<h3>Description</h3>

<p>The function converts an eseis object to an ObsPy stream object. The 
functionality is mainly useful when running ObsPy through R using the 
package 'reticulate'. Currently, only single traces (i.e., single eseis 
objects) can be converted. Thus, to convert multiple traces, these need 
to be converted individually and added to the first trace using ObsPy 
functionalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_eseisobspy(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_eseisobspy_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>list</code> element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ObsPy</code> stream object as defined by the architecture of 
package 'reticulate'.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## load ObsPy library with package 'reticulate'
## (requires ObsPy to be installed on the computer)
obspy &lt;- reticulate::import("obspy")

## load example data set
data(rockfall)

## convert example eseis object to ObsPy stream object
x &lt;- aux_eseisobspy(data = rockfall_eseis)

## filter data set using ObsPy
x_filter &lt;- obspy$traces[[1]]$filter(type = "bandpass", 
                                     freqmin = 0.5, 
                                     freqmax = 1.0)
                                     
## plot filtered trace using ObsPy plotting routine
x$traces[[1]]$plot()


## End(Not run)

</code></pre>

<hr>
<h2 id='aux_fixmseed'>Fix corrupt miniseed files</h2><span id='topic+aux_fixmseed'></span>

<h3>Description</h3>

<p>This function is a wrapper for the library 'dataselect' from IRIS. It 
reads a corrupt mseed file and saves it in fixed state. Therefore, the 
function requires dataselect being installed (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_fixmseed(file, input_dir, output_dir, software)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_fixmseed_+3A_file">file</code></td>
<td>
<p><code>Character</code> vector, seismic file to process.</p>
</td></tr>
<tr><td><code id="aux_fixmseed_+3A_input_dir">input_dir</code></td>
<td>
<p><code>Character</code> value, path to input directory, i.e., 
the directory where the files to process are located.</p>
</td></tr>
<tr><td><code id="aux_fixmseed_+3A_output_dir">output_dir</code></td>
<td>
<p><code>Character</code> value, path to output directory, i.e., 
the directory where the processed files are written to. This must be 
different from <code>input_dir</code>.</p>
</td></tr>
<tr><td><code id="aux_fixmseed_+3A_software">software</code></td>
<td>
<p><code>Character</code> value, path to the 'dataselect' library, 
required unless the path to the library is made gobally visible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The library 'dataselect' can be downloaded at 
https://github.com/iris-edu/dataselect
and requires compilation (see README file in dataselect directory). The 
function goes back to an email discussion with Gillian Sharer (IRIS team),
many thanks for pointing me at this option to process corrupt mseed files.
</p>


<h3>Value</h3>

<p>a set of mseed files written to disk.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

aux_fixmseed(file = list.files(path = "~/data/mseed", 
                               pattern = "miniseed"), 
                    input_dir = "~/data/mseed",
                    software = "~/software/dataselect-3.17")


## End(Not run)

</code></pre>

<hr>
<h2 id='aux_getevent'>Load seismic data of a user-defined event</h2><span id='topic+aux_getevent'></span>

<h3>Description</h3>

<p>The function loads seismic data from a data directory structure (see 
<code>aux_organisecubefiles()</code>) based on the event start time, duration,
component and station ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_getevent(
  start,
  duration,
  station,
  component = "BHZ",
  format,
  dir,
  simplify = TRUE,
  eseis = TRUE,
  try = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_getevent_+3A_start">start</code></td>
<td>
<p><code>POSIXct</code> value, start time of the data to import. If
lazy users only submit a text string instead of a POSIXct obejct, the 
function will try to convert that text string.</p>
</td></tr>
<tr><td><code id="aux_getevent_+3A_duration">duration</code></td>
<td>
<p><code>Numeric</code> value, duration of the data to import,
in seconds.</p>
</td></tr>
<tr><td><code id="aux_getevent_+3A_station">station</code></td>
<td>
<p><code>Character</code> value, seismic station ID, which must
correspond to the ID in the file name of the data directory structure 
(cf. <code>aux_organisecubefiles</code>).</p>
</td></tr>
<tr><td><code id="aux_getevent_+3A_component">component</code></td>
<td>
<p><code>Character</code> value, seismic component, which must
correspond to the component name in the file name of the data directory  
structure (cf. <code>aux_organisecubefiles</code>). Default is 
<code>"BHZ"</code> (vertical component of a sac file).</p>
</td></tr>
<tr><td><code id="aux_getevent_+3A_format">format</code></td>
<td>
<p><code>Character</code> value, seismic data format. One out of 
<code>"sac"</code> and <code>"mseed"</code>. If omitted, the function will try to 
identify the right format automatically.</p>
</td></tr>
<tr><td><code id="aux_getevent_+3A_dir">dir</code></td>
<td>
<p><code>Character</code> value, path to the seismic data directory.
See details for further info on data structure.</p>
</td></tr>
<tr><td><code id="aux_getevent_+3A_simplify">simplify</code></td>
<td>
<p><code>Logical</code> value, option to simplify output
when possible. This basically means that if only data from one station 
is loaded, the list object will have one level less. Default is 
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aux_getevent_+3A_eseis">eseis</code></td>
<td>
<p><code>Logical</code> value, option to read data to an <code>eseis</code>
object (recommended, see documentation of 
<code>aux_initiateeseis</code>), default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="aux_getevent_+3A_try">try</code></td>
<td>
<p><code>Logical</code> value, option to run the function in try-mode, 
i.e., to let it return <code>NA</code> in case an error occurs during data
import. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aux_getevent_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value, option to show messages during 
function execution. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data to be read needs to be adequately structured. The data directory
must contain SAC files organised by year (e.g.2022) then by Julian Day
in full three digits (e.g. 001) and then by a dedicated SAC file name, 
containing the station ID, two-digit year, three-digit Julian Day, start 
time hour, minute and second, three channel ID and the file extension SAC. 
All these items need to be separated by stops (e.g. 
sac/2022/001/LAU01.22.001.08.00.00. BHZ.SAC). This data structure will be 
most conveniently created by the functions <code>aux_organisecubefiles()</code> 
or <code>aux_organisecentaurfiles()</code>, or by manually written R code. 
</p>
<p>The function assumes complete data sets, i.e., not a single hourly 
data set must be missing. The time 
vector is loaded only once, from the first station and its first 
component. Thus, it is assumed that all loaded seismic signals are
of the same sampling frequency and length.
</p>


<h3>Value</h3>

<p>A <code>list</code> object containing either a set of <code>eseis</code>
objects or a data set with the time vector (<code>$time</code>) 
and a list of seismic stations (<code>$station_ID</code>) with their seismic
signals as data frame (<code>$signal</code>). If <code>simplify = TRUE</code> (the 
default option) and only one seismic station is provided, the output  
object containseither just one eseis object or the vectors for 
<code>$time</code> and <code>$signal</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set seismic data directory
dir_data &lt;- paste0(system.file("extdata", package="eseis"), "/")

## load the z component data from a station
data &lt;- aux_getevent(start = as.POSIXct(x = "2017-04-09 01:20:00", 
                                        tz = "UTC"), 
                      duration = 120,
                      station = "RUEG1",
                      component = "BHZ",
                      dir = dir_data)                       
## plot signal
plot_signal(data = data)

## load data from two stations
data &lt;- aux_getevent(start = as.POSIXct(x = "2017-04-09 01:20:00", 
                                        tz = "UTC"), 
                     duration = 120,
                     station = c("RUEG1", "RUEG2"),
                     component = "BHZ",
                     dir = dir_data)

## plot both signals
par(mfcol = c(2, 1))
lapply(X = data, FUN = plot_signal)
                     
</code></pre>

<hr>
<h2 id='aux_getFDSNdata'>Download seismic data from FDSN data base</h2><span id='topic+aux_getFDSNdata'></span>

<h3>Description</h3>

<p>The function accesses the specified FDSN internet data base(s) and 
downloads seismic data based on the network and station IDs and time
constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_getFDSNdata(
  start,
  duration,
  channel = "BHZ",
  network,
  station,
  url,
  link_only = FALSE,
  eseis = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_getFDSNdata_+3A_start">start</code></td>
<td>
<p><code>POSIXct</code> value, start time of the data to query.</p>
</td></tr>
<tr><td><code id="aux_getFDSNdata_+3A_duration">duration</code></td>
<td>
<p><code>Numeric</code> value, length of the data to query, in 
seconds.</p>
</td></tr>
<tr><td><code id="aux_getFDSNdata_+3A_channel">channel</code></td>
<td>
<p><code>Character</code> value, seismic channel to get. Default is
<code>"BHZ"</code>.</p>
</td></tr>
<tr><td><code id="aux_getFDSNdata_+3A_network">network</code></td>
<td>
<p><code>Character</code> vector, two-character FDSN network ID.</p>
</td></tr>
<tr><td><code id="aux_getFDSNdata_+3A_station">station</code></td>
<td>
<p><code>Character</code> vector, FDSN station ID.</p>
</td></tr>
<tr><td><code id="aux_getFDSNdata_+3A_url">url</code></td>
<td>
<p><code>Character</code> vector, FDSN URL.</p>
</td></tr>
<tr><td><code id="aux_getFDSNdata_+3A_link_only">link_only</code></td>
<td>
<p><code>Logical</code> vector, return only FDSN link instead of
downloading and importing the data.</p>
</td></tr>
<tr><td><code id="aux_getFDSNdata_+3A_eseis">eseis</code></td>
<td>
<p><code>Logical</code> scalar, option to read data to an <code>eseis</code>
object (recommended, see documentation of 
<code>aux_initiateeseis</code>), default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convenient way to get all the required input data is using the 
function <code>aux_getFDSNstation</code> before. It will return all the 
information in a structured way.
</p>
<p>It is possible to use the function to process more than one data set. In 
this case, the arguments <code>network</code>, <code>station</code> and <code>url</code> 
must match pairwise. The arguments <code>start</code>, <code>duration</code> and 
<code>channel</code> will be treated as constants if not also provided as 
vectors.
</p>


<h3>Value</h3>

<p><code>List</code> object with imported seismic data for each provided 
set of input arguments.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>See Also</h3>

<p>aux_get_FDSNstation, read_mseed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## get stations &lt; 0.6 degrees away from Piz Chengalo collapse
x &lt;- aux_getFDSNstation(centre = c(46.3, 9.6),
                        radius = 0.6,
                        access = TRUE)

## sort statiions by distance
x &lt;- x[order(x$distance),]

## download available data
d &lt;- aux_getFDSNdata(start = as.POSIXct(x = "2017-08-23 07:30:00", 
                                        tz = "UTC"),
                     duration = 180, 
                     network = x$network_ID, 
                     station = x$station_code, 
                     url = x$network_url)

## remove stations without available data
x &lt;- x[!unlist(lapply(d, is.null)),]
d &lt;- d[!unlist(lapply(d, is.null))]

## generate plots of the three nearest stations
par(mfcol = c(3, 1))

for(i in 1:3) {

  plot_signal(data = d[[i]],
              main = paste(x$ID[i], 
                           " | ",
                           round(x$distance[i], 2),
                           "distance (DD)"))
} 

## End(Not run)
                     
</code></pre>

<hr>
<h2 id='aux_getFDSNstation'>Query FDSN data base for stations</h2><span id='topic+aux_getFDSNstation'></span>

<h3>Description</h3>

<p>This function queries as series of data bases for seismic stations that 
match a set of criteria for seismic data. The criteria include signal time 
stamp and location, and component. The returned data can be used to 
download data using the function <code>aux_FDSNdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_getFDSNstation(centre, radius, start, access, url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_getFDSNstation_+3A_centre">centre</code></td>
<td>
<p><code>Numeric</code> vector of length two, center coordinates 
of the location to search data for (<code>c(latitude, longitude)</code>). 
Units must be decimal degrees.</p>
</td></tr>
<tr><td><code id="aux_getFDSNstation_+3A_radius">radius</code></td>
<td>
<p><code>Numeric</code> value, radius within which to search for 
seismic stations. Unit must be decimal degrees.</p>
</td></tr>
<tr><td><code id="aux_getFDSNstation_+3A_start">start</code></td>
<td>
<p><code>POSIXct</code> value, start time of the data to query. If 
omitted, stations are queried for the full time available.</p>
</td></tr>
<tr><td><code id="aux_getFDSNstation_+3A_access">access</code></td>
<td>
<p><code>Logical</code> value, access type of the data. If omitted,
all data sets are returned, if set <code>TRUE</code>, only data with access 
flag <code>"open"</code> are returned.</p>
</td></tr>
<tr><td><code id="aux_getFDSNstation_+3A_url">url</code></td>
<td>
<p><code>Character</code> vector, optional other FDSN base web 
addresses to search for stations. See details for default addresses and 
their format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires a working internet connection to perform the query.
It uses the following FDSN data bases by default: 
</p>

<ul>
<li> <p><code>orfeus</code> <code>"http://www.orfeus-eu.org"</code>
</p>
</li>
<li> <p><code>geofon</code> <code>"http://geofon.gfz-potsdam.de/"</code>
</p>
</li>
<li> <p><code>bgr</code> <code>"http://eida.bgr.de"</code>
</p>
</li>
<li> <p><code>sss</code> <code>"http://eida.ethz.ch"</code>
</p>
</li></ul>

<p>Other FDSN data base addresses can be provided in the same way as the 
addresses in the above list. They need to be provided as character 
vector. For a list of addresses see 
<code>"http://www.fdsn.org/webservices/datacenters/"</code> and 
<code>"http://docs.obspy.org/packages/obspy.clients.fdsn.html#module-obspy.clients.fdsn"</code>.
</p>


<h3>Value</h3>

<p><code>Data frame</code> with query results. The data frame contains 
information for all seismic stations fulfilling the defined criteria.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>See Also</h3>

<p>aux_get_FDSNdata, aux_getIRISstation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

x &lt;- aux_getFDSNstation(start = as.POSIXct(x = "2010-01-01 22:22:22", 
                                           tz = "UTC"), 
                        centre = c(45, 10), 
                        radius = 1)
                           
## optionally plot station locations on a map (requires RgoogleMaps)
center &lt;- c(mean(x$station_latitude), 
            mean(x$station_longitude))

zoom &lt;- min(RgoogleMaps::MaxZoom(range(x$station_latitude), 
                                 range(x$station_longitude)))
                                 
Map &lt;- RgoogleMaps::GetMap(center = center,
                           zoom = zoom, 
                           maptype = "terrain")
                           
RgoogleMaps::PlotOnStaticMap(MyMap = Map, 
                             lat = x$station_latitude, 
                             lon = x$station_longitude, 
                             pch = 15, 
                             col = 4)

## End(Not run)
                     
</code></pre>

<hr>
<h2 id='aux_getIRISdata'>Download seismic data from IRIS data base</h2><span id='topic+aux_getIRISdata'></span>

<h3>Description</h3>

<p>This function accesses the IRIS internet data base of seismic signals and 
downloads seismic data based on the provided SNCL string and time 
information. The downloaded data is converted to the same structure as 
would be expected from <code>read_sac</code> or <code>read_mseed</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_getIRISdata(
  start,
  duration,
  sncl,
  quality = "D",
  ID_iris = "IrisClient",
  eseis = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_getIRISdata_+3A_start">start</code></td>
<td>
<p><code>POSIXct</code> value, start time of the data to query.</p>
</td></tr>
<tr><td><code id="aux_getIRISdata_+3A_duration">duration</code></td>
<td>
<p><code>Numeric</code> value, length of the data to query, in 
seconds.</p>
</td></tr>
<tr><td><code id="aux_getIRISdata_+3A_sncl">sncl</code></td>
<td>
<p><code>Character</code> vector, SNCL string used to identify station 
and component of interest. These strings should match the time criteria. 
Typically, the SNCL string can be taken from the output of the function
<code>aux_getirisstations</code>.</p>
</td></tr>
<tr><td><code id="aux_getIRISdata_+3A_quality">quality</code></td>
<td>
<p><code>Character</code> value, quality level of the data. One out 
of <code>"D"</code> (The state of quality control of the data is indeterminate), 
<code>"R"</code> (Raw Waveform Data with no Quality Control), 
<code>"Q"</code> (Quality Controlled Data, some processes have been applied to 
the data), <code>"M"</code> (Data center modified, time-series values have not 
been changed), <code>"B"</code>. Default is <code>"D"</code>.</p>
</td></tr>
<tr><td><code id="aux_getIRISdata_+3A_id_iris">ID_iris</code></td>
<td>
<p><code>Character</code> value, IRIS ID. Default is 
<code>"IrisClient"</code>.</p>
</td></tr>
<tr><td><code id="aux_getIRISdata_+3A_eseis">eseis</code></td>
<td>
<p><code>Logical</code> scalar, option to read data to an <code>eseis</code>
object (recommended, see documentation of 
<code>aux_initiateeseis</code>), default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function makes use of the package 'IRISSeismic'. It requires a working 
internet connection to perform the download.
</p>


<h3>Value</h3>

<p><code>List</code> with downloaded seismic data. For each element in 
<code>sncl</code>, a list element is created, which in turn contains a list with 
the typical seismic data organisation as, for example, created by 
<code>read_sac</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

sncl &lt;- aux_getIRISstation(start = as.POSIXct("2010-01-01 22:22:22", 
                                               tz = "UTC"), 
                            duration = 120, 
                            location = c(53, 13), 
                            radius = 0.7, 
                            component = "BHZ")

s &lt;- aux_getIRISdata(start = as.POSIXct("2010-01-01 22:22:22", 
                                           tz = "UTC"), 
                        duration = 120,
                        sncl = sncl$sncl[1])
                        
plot_signal(data = s[[1]])

## End(Not run)
                     
</code></pre>

<hr>
<h2 id='aux_getIRISstation'>Query IRIS data base for stations</h2><span id='topic+aux_getIRISstation'></span>

<h3>Description</h3>

<p>This function queries the IRIS data base for seismic stations that match
a set of criteria for seismic data. The criteria include signal time stamp 
and location, component and a search radius. The returned SNCL strings can 
be used to download data using the function <code>aux_getIRISdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_getIRISstation(
  start,
  duration,
  location,
  radius = 10,
  component = "BHZ",
  ID_iris = "IrisClient"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_getIRISstation_+3A_start">start</code></td>
<td>
<p><code>POSIXct</code> value, start time of the data to query.</p>
</td></tr>
<tr><td><code id="aux_getIRISstation_+3A_duration">duration</code></td>
<td>
<p><code>Numeric</code> value, length of the data to query, in 
seconds.</p>
</td></tr>
<tr><td><code id="aux_getIRISstation_+3A_location">location</code></td>
<td>
<p><code>Numeric</code> vector of length two, coordinates of the 
seismic source, in decimal degrees (i.e., latitude and longitude).</p>
</td></tr>
<tr><td><code id="aux_getIRISstation_+3A_radius">radius</code></td>
<td>
<p><code>Numeric</code> value, search radius for the query, in 
decimal degrees. Default is <code>10</code> (about 1100 km).</p>
</td></tr>
<tr><td><code id="aux_getIRISstation_+3A_component">component</code></td>
<td>
<p><code>Character</code> value, signal component to check for. 
One out of <code>"BHE"</code>, <code>"BHN"</code> and <code>"BHZ"</code>. Currently, only  
one component can be defined per search. Default is <code>"BHZ"</code>.</p>
</td></tr>
<tr><td><code id="aux_getIRISstation_+3A_id_iris">ID_iris</code></td>
<td>
<p><code>Character</code> value, IRIS ID. Default is 
<code>"IrisClient"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function makes use of the package  IRISSeismic. It requires a working 
internet connection to perform the query.
</p>


<h3>Value</h3>

<p><code>Data frame</code> with query results. The data frame contains 
information for all seismic stations fulfilling the defined criteria.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

x &lt;- aux_getIRISstation(start = as.POSIXct("2010-01-01 22:22:22", 
                         tz = "UTC"), 
                         duration = 3 * 3600, 
                         location = c(53, 13), 
                         radius = 1, 
                         component = "BHZ")

## End(Not run)
                     
</code></pre>

<hr>
<h2 id='aux_gettemperature'>Extract temperature data from cube files.</h2><span id='topic+aux_gettemperature'></span>

<h3>Description</h3>

<p>This function reads auxiliary information stored in Omnirecs/Digos Datacube  
files and extracts the temperature data that is stored along with each GPS 
tag. Optionally, the data is interpolated to equal intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_gettemperature(input_dir, logger_ID, interval, cpu, gipptools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_gettemperature_+3A_input_dir">input_dir</code></td>
<td>
<p><code>Character</code> value, path to directory where all cube 
files to be processed as stored. Each set of files from one logger must be 
stored in a separate sub-directory named after the cube ID.</p>
</td></tr>
<tr><td><code id="aux_gettemperature_+3A_logger_id">logger_ID</code></td>
<td>
<p><code>Character</code> vector, logger ID.</p>
</td></tr>
<tr><td><code id="aux_gettemperature_+3A_interval">interval</code></td>
<td>
<p><code>Numeric</code> value, time interval (minutes) to which
temperature data is interpolated. No interpolation is performed if this 
argument is omitted.</p>
</td></tr>
<tr><td><code id="aux_gettemperature_+3A_cpu">cpu</code></td>
<td>
<p><code>Numeric</code> value, fraction of CPUs to use for parallel 
processing. If omitted, one CPU is used.</p>
</td></tr>
<tr><td><code id="aux_gettemperature_+3A_gipptools">gipptools</code></td>
<td>
<p><code>Character</code> value, path to gipptools or cubetools 
directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This feature is ony available for  Omnirecs/Digos Datacube that were 
produced since 2015, i.e., whose GPS output files also record the 
temperature inside the logger. Generating an ACSII GPS tag file using the 
gipptools software requires a few minutes time per daily file.
</p>


<h3>Value</h3>

<p>A <code>list</code> of <code>data frames</code> with time and temperature 
values for each cube data logger.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## uncomment to use
# t &lt;- aux_gettemperature(input_dir = "input",
#                         logger_ID = c("ANN", "ABT"),
#                         interval = 15,
#                         gipptools = "~/software/gipptools-2015.225/")

</code></pre>

<hr>
<h2 id='aux_hvanalysis'>Perform H-V-spectral ratio analysis of a seismic data set</h2><span id='topic+aux_hvanalysis'></span>

<h3>Description</h3>

<p>This function cuts a three component seismic data set into time windows
that may or may not overlap and calculates the spectral ratio for each of 
these windows. It returns a matrix with the ratios for each time slice. 
Thus, it is a wrapper for the function <code>signal_hvratio</code>. For 
further information about the technique and function arguments see the 
description of <code>signal_hvratio</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_hvanalysis(
  data,
  time,
  window,
  overlap = 0,
  dt,
  method = "periodogram",
  kernel,
  order = "xyz",
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_hvanalysis_+3A_data">data</code></td>
<td>
<p><code>List</code>, <code>data frame</code> or <code>matrix</code>, seismic
componenents to be processed. If <code>data</code> is a matrix, the components 
must be organised as columns. Also, <code>data</code> can be a list of 
<code>eseis</code> objects.</p>
</td></tr>
<tr><td><code id="aux_hvanalysis_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector with time values. If omitted, an 
synthetic time vector will be created, based on <code>dt</code>.</p>
</td></tr>
<tr><td><code id="aux_hvanalysis_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> scalar, time window length in seconds used to 
calculate individual spectral ratios. Set to 10 percent of the time  
series length by default.</p>
</td></tr>
<tr><td><code id="aux_hvanalysis_+3A_overlap">overlap</code></td>
<td>
<p><code>Numeric</code> value, fraction of window overlap.</p>
</td></tr>
<tr><td><code id="aux_hvanalysis_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period.</p>
</td></tr>
<tr><td><code id="aux_hvanalysis_+3A_method">method</code></td>
<td>
<p><code>Character</code> value, method for calculating the spectra. 
One out of <code>"periodogram"</code> , <code>"autoregressive"</code> and 
<code>"multitaper"</code>, default is <code>"periodogram"</code>.</p>
</td></tr>
<tr><td><code id="aux_hvanalysis_+3A_kernel">kernel</code></td>
<td>
<p><code>Numeric</code> value, window size (defined by number of 
samples) of the moving window used for smoothing the spectra. By default 
no smoothing is performed.</p>
</td></tr>
<tr><td><code id="aux_hvanalysis_+3A_order">order</code></td>
<td>
<p><code>Character</code> value, order of the seismic components. 
Describtion must contain the letters <code>"x"</code>,<code>"y"</code> and
<code>"z"</code> in the order according to the input data set. Default is 
<code>"xyz"</code> (NW-SE-vertical).</p>
</td></tr>
<tr><td><code id="aux_hvanalysis_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> value, toggle plot output. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aux_hvanalysis_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the h-v-frequency ratios for each time slice.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data set
data(earthquake)

## ATTENTION, THIS EXAMPLE DATA SET IS FAR FROM IDEAL FOR THIS PURPOSE

## detrend data
s &lt;- signal_detrend(data = s)

## calculate the HV ratios straightforward
HV &lt;- aux_hvanalysis(data = s,
                     dt = 1 / 200,
                     kernel = 100)

## calculate the HV ratios with plot output, userdefined palette
plot_col &lt;- colorRampPalette(colors = c("grey", "darkblue", "blue", "orange"))
HV &lt;- aux_hvanalysis(data = s,
                     dt = 1 / 200,
                     kernel = 100,
                     plot = TRUE,
                     col = plot_col(100))

## calculate the HV ratios with optimised method settings
HV &lt;- aux_hvanalysis(data = s, 
                     time = t,
                     dt = 1 / 200, 
                     window = 10, 
                     overlap = 0.9, 
                     method = "autoregressive",
                     plot = TRUE,
                     col = plot_col(100),
                     xlab = "Time (UTC)",
                     ylab = "f (Hz)")
                     
## calculate and plot stack (mean and sd) of all spectral ratios
HV_mean &lt;- apply(X = HV, MARGIN = 1, FUN = mean)
HV_sd &lt;- apply(X = HV, MARGIN = 1, FUN = sd)
HV_f &lt;- as.numeric(rownames(HV))

plot(x = HV_f, y = HV_mean, type = "l", ylim = c(0, 50))
lines(x = HV_f, y = HV_mean + HV_sd, col = 2)
lines(x = HV_f, y = HV_mean - HV_sd, col = 2)              

</code></pre>

<hr>
<h2 id='aux_initiateeseis'>Initiate an eseis object</h2><span id='topic+aux_initiateeseis'></span>

<h3>Description</h3>

<p>The function generates an empty eseis object, starting with processing 
step 0. The object contains no data and the history only contains the 
system information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_initiateeseis()
</code></pre>


<h3>Details</h3>

<p>The S3 object class <code>eseis</code> contains the data vector (<code>$signal</code>), 
a meta information list (<code>$meta</code>) with all essential seismic meta data - 
such as sampling interval, station ID, component, start time of the stream 
or file name of the input file - a list with header data of the seismic 
source file (<code>$header</code>), and a history list (<code>$history</code>), which 
records all data manipulation steps of an (<code>eseis</code>) object. The element 
(<code>$meta</code>) will be used by functions of the package to look for 
essential information to perform data manipulations (e.g., the sampling 
interval). Thus, working with (<code>eseis</code>) objects is convenient and less 
prone to user related errors/bugs, given that the meta information is 
correct and does not change during the processing chain; package functions 
will update the meta information whenever necessary (e.g., 
<code>signal_aggregate</code>). The element <code>$header</code> will only be
present if a seismic source file has been imported.
</p>
<p>The history element is the key feature for transparent and reproducable 
research using this R package. An <code>eseis</code> object records a history of 
every function it has been subject to, including the time stamp, the 
function call, all used function arguments and their associated values, 
and the overall processing duration in seconds. The history is updated 
whenever an <code>eseis</code> object is manipulated with one of the functions 
of this package (with a few exceptions, mainly from the aux_... category).
</p>


<h3>Value</h3>

<p><code>S3</code> list object of class <code>eseis</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## initiate eseis object
aux_initiateeseis()
                     
</code></pre>

<hr>
<h2 id='aux_obspyeseis'>Convert ObsPy object to eseis object</h2><span id='topic+aux_obspyeseis'></span>

<h3>Description</h3>

<p>The function converts an ObsPy stream object to an eseis object. The 
functionality is mainly useful when running ObsPy through R using the 
package 'reticulate'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_obspyeseis(data, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_obspyeseis_+3A_data">data</code></td>
<td>
<p><code>obspy</code> stream object, <code>list</code> element, created by 
running ObsPy through R using the package 'reticulate'.</p>
</td></tr>
<tr><td><code id="aux_obspyeseis_+3A_simplify">simplify</code></td>
<td>
<p><code>Logical</code> value, option to simplify output
when possible. This basically means that if there is only trace object 
in the ObsPy stream, the list object will have one level less. Default is 
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initiation of the reticulate-based python toolbox support can be 
cumbersome. The following suggestions from Guthub 
(https://github.com/rstudio/reticulate/issues/578) helped in a case 
study:
</p>
<p><code>library(reticulate)</code>
<code>use_condaenv("r-reticulate")</code>
<code>py_install("obspy", pip = TRUE)</code>
</p>


<h3>Value</h3>

<p><code>eseis</code> object.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## load ObsPy library with package 'reticulate'
## (requires ObsPy to be installed on the computer)
obspy &lt;- reticulate::import("obspy")

## set seismic data directory
dir_data &lt;- paste0(system.file("extdata", package="eseis"), "/")

## read miniseed file to stream object via ObsPy
x &lt;- obspy$read(pathname_or_url = "dir_data/2017/99/RUEG1.17.99.00.00.00.BHZ.SAC")

## convert ObsPy stream object to eseis object
y &lt;- aux_obspyeseis(data = x)

## plot eseis object
plot_signal(y)

## End(Not run)

</code></pre>

<hr>
<h2 id='aux_organisecentaurfiles'>Reorganise seismic files recorded by Nanometrics Centaur loggers</h2><span id='topic+aux_organisecentaurfiles'></span>

<h3>Description</h3>

<p>This function optionally converts mseed files to sac files and 
organises these in a coherent directory structure, by year, Julian day, 
(station, hour and channel). It depends on the cubetools or gipptools  
software package (see details). The function is at an experimental stage  
and only used for data processing at the GFZ Geomorphology section, 
currently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_organisecentaurfiles(
  stationfile,
  input_dir,
  output_dir,
  format = "sac",
  channel_name = "bh",
  cpu,
  gipptools,
  file_key = "miniseed",
  network
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_organisecentaurfiles_+3A_stationfile">stationfile</code></td>
<td>
<p><code>Character</code> value, file name of the station info 
file, with extension. See <code>aux_stationinfofile</code>.</p>
</td></tr>
<tr><td><code id="aux_organisecentaurfiles_+3A_input_dir">input_dir</code></td>
<td>
<p><code>Character</code> value, path to directory where all 
files to be processed as stored. Each set of files from one logger must be 
stored in a separate sub-directory named after the logger ID (which in 
turn must be the four digit number of the logger).</p>
</td></tr>
<tr><td><code id="aux_organisecentaurfiles_+3A_output_dir">output_dir</code></td>
<td>
<p><code>Character</code> value, path to directory where output 
data is written to.</p>
</td></tr>
<tr><td><code id="aux_organisecentaurfiles_+3A_format">format</code></td>
<td>
<p><code>Character</code> value, output file format. One out of 
<code>"mseed"</code> and <code>"sac"</code>. Default is <code>"sac"</code>.</p>
</td></tr>
<tr><td><code id="aux_organisecentaurfiles_+3A_channel_name">channel_name</code></td>
<td>
<p><code>Character</code> value, output file extension. One out 
of <code>"bh"</code> and <code>"p"</code>. Default is <code>"bh"</code>.</p>
</td></tr>
<tr><td><code id="aux_organisecentaurfiles_+3A_cpu">cpu</code></td>
<td>
<p><code>Numeric</code> value, fraction of CPUs to use for parallel 
processing. If omitted, one CPU is used.</p>
</td></tr>
<tr><td><code id="aux_organisecentaurfiles_+3A_gipptools">gipptools</code></td>
<td>
<p><code>Character</code> value, path to gipptools or cubetools 
directory.</p>
</td></tr>
<tr><td><code id="aux_organisecentaurfiles_+3A_file_key">file_key</code></td>
<td>
<p><code>Character</code> value, file name extension of the files
to process. Only files with this extension will be processed. Default is 
<code>"miniseed"</code>.</p>
</td></tr>
<tr><td><code id="aux_organisecentaurfiles_+3A_network">network</code></td>
<td>
<p><code>Character</code> value, optional seismic network code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that the Nanometrics Centaur data logger directory 
contains only hourly mseed files. These hourly files are organised in a 
coherent directory structure which is organised by year and Julian day. 
In each Julian day directory the hourly files are placed and named according 
to the following scheme: 
STATIONID.YEAR.JULIANDAY.HOUR.MINUTE.SECOND.CHANNEL.<br />
The function requires that the software cubetools 
(<code>http://www.omnirecs.de/documents.html</code>) or gipptools 
(<code>http://www.gfz-potsdam.de/en/section/geophysical-deep-sounding/infrastructure/geophysical-instrument-pool-potsdam-gipp/software/gipptools/</code>) 
are installed. <br /> Specifying an input directory 
(<code>input_dir</code>) is mandatory. This input directory must only contain the 
subdirectories with mseed data for each Centaur logger. The subdirectory 
must be named after the four digit Centaur ID and contain only mseed files,
regardless if further subdirectories are used (e.g., for calendar days). 
</p>
<p>In the case a six-channel Centaur is used to record signals from two
sensors, in the station info file (cf. <code>aux_stationinfofile()</code>)
the logger ID field must contain the four digit logger ID and the 
channel qualifiers, e.g., &quot;AH&quot; (first three channels) or &quot;BH&quot; (last three channels), 
separated by an underscore.
</p>


<h3>Value</h3>

<p>A set of hourly seismic files written to disk.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## basic example with minimum effort
aux_organisecentaurfiles(stationfile = "output/stationinfo.txt", 
                         input_dir = "input", 
                         gipptools = "software/gipptools-2015.225/")


## End(Not run)
                        
</code></pre>

<hr>
<h2 id='aux_organisecubefiles'>Convert Omnirecs/Digos Datacube files to mseed or sac files and organise in directory structure.</h2><span id='topic+aux_organisecubefiles'></span>

<h3>Description</h3>

<p>This function converts Omnirecs/Digos Datacube files to hourly mseed or 
sac files and organises these in a coherent directory structure, by year, 
Julian day, (station, hour and channel). It depends on the cubetools or   
gipptools software package (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_organisecubefiles(
  stationfile,
  input_dir,
  output_dir,
  format = "sac",
  channel_name = "bh",
  cpu,
  fringe = "constant",
  verbose = FALSE,
  gipptools,
  heapspace,
  mseed_manual = FALSE,
  mseed_keep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_organisecubefiles_+3A_stationfile">stationfile</code></td>
<td>
<p><code>Character</code> value, file name of the station info 
file, with extension. See <code>aux_stationinfofile</code>.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_input_dir">input_dir</code></td>
<td>
<p><code>Character</code> value, path to directory where all cube 
files to be processed are stored. Each set of files from one logger must be 
stored in a separate sub-directory named after the cube ID.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_output_dir">output_dir</code></td>
<td>
<p><code>Character</code> value, path to directory where output 
data is written to.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_format">format</code></td>
<td>
<p><code>Character</code> value, output file format. One out of 
<code>"mseed"</code> and <code>"sac"</code>. Default is <code>"sac"</code>.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_channel_name">channel_name</code></td>
<td>
<p><code>Character</code> value, output file extension. One out 
of <code>"bh"</code> and <code>"p"</code>. Default is <code>"bh"</code>.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_cpu">cpu</code></td>
<td>
<p><code>Numeric</code> value, fraction of CPUs to use for parallel 
processing. If omitted, one CPU is used.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_fringe">fringe</code></td>
<td>
<p><code>Character</code> value, option to handle data outside the 
GPS-tagged time span. One out of <code>"skip"</code>, <code>"nominal"</code> or 
<code>"constant"</code>. Default is <code>"constant"</code>.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value, option to enable extended screen 
output of cubetools operations. Default is <code>FALSE</code>. This option 
might not work with Windows operating systems.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_gipptools">gipptools</code></td>
<td>
<p><code>Character</code> value, path to gipptools or cubetools 
directory.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_heapspace">heapspace</code></td>
<td>
<p><code>Numeric</code> value, heap space assigned to the Java 
Runtime Environment, e.g., <code>4096</code>. Should be increased if the cube 
to mseed conversion fails (announced if <code>verbose = TRUE</code>). Please 
note that this argument fails on Windows machines, and also in other 
operating systems, it should only be used if the function returns an
error caused by Java running out of memory.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_mseed_manual">mseed_manual</code></td>
<td>
<p><code>Logical</code> value, option to convert mseed files 
manually. See details. Default is <code>FALSE</code>, i.e., the function converts 
cube files to mseed files using the GIPP tools.</p>
</td></tr>
<tr><td><code id="aux_organisecubefiles_+3A_mseed_keep">mseed_keep</code></td>
<td>
<p><code>Logical</code> value, option to keep mseed files instead 
of deleting them. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function converts seismic data from the cube file format to either 
mseed (cf. <code>read_mseed</code>) or sac (cf. <code>read_sac</code>) and cuts the 
daily cube files to hourly files. These hourly files are organised in a 
coherent directory structure which is organised by year and Julian day. 
In each Julian day directory the hourly files are placed and named after 
the following scheme: 
STATIONID.YEAR.JULIANDAY.HOUR.MINUTE.SECOND.CHANNEL.<br />
The function requires that the software cubetools 
(<code>http://www.omnirecs.de/documents.html</code>) or gipptools 
(<code>http://www.gfz-potsdam.de/en/section/geophysical-deep-sounding/infrastructure/geophysical-instrument-pool-potsdam-gipp/software/gipptools/</code>) 
are installed. <br /> Specifying an input directory 
(<code>input_dir</code>) is mandatory. This input directory must only contain the 
subdirectories with the cube files to process, each set of cube files must 
be located in a separate subdirectory and these subdiretories must 
have the same name as specified by the logger IDs (<code>logger_ID</code>). An 
appropriate structure would be something like: <br /> 
</p>

<ol>
<li><p> input
</p>

<ol>
<li><p> A1A
</p>

<ol>
<li><p> file1.A1A
</p>
</li>
<li><p> file2.A1A
</p>
</li></ol>

</li>
<li><p> A1B
</p>

<ol>
<li><p> file1.A1B
</p>
</li>
<li><p> file2.A1B
</p>
</li></ol>

</li></ol>

</li></ol>

<p>With one of the latest updates of either R or Java the cache size for 
converting cube files to mseed files has been reduced. 
Thus, in several cases the conversion 
stops due to buffer overruns. This effect has been particularly observed 
when trying to convert more than about 20 consecutive days of cube files
at once. In such a case, it is appropriate to set the function argument
mseed_manual to <code>TRUE</code>. This will stop the function just at the point
where the function would call the GIPPtools function cube2mseed. The user 
will see a confirmation command line in the R console, which asks 
to first copy all manually converted mseed files to the directory 
<code>mseed_raw</code> before confirming to continue with the R function. To 
convert all cube files to mseed files it is advised to open a terminal and 
run the function <code>GIPPtools/bin/cube2mseed</code> with the following 
parameters: <code>GIPPtools/bin/cube2mseed --verbose --output-dir=./mseed_raw/ ./input_dir/</code>
without further adjustments, except for the fringe sample option, as 
specified in <code>aux_organisecubefiles</code>. Please also see the documentation 
of the cube2mseed program from the gipptools for further information.
</p>
<p>Alternatively, increasing the heap space of the Java Runtime Environment, 
required for converting the cube files, can solve the above mentioned 
issue. To increase the heap space, use the argument <code>heapspace</code>. By 
default, this argument is set to 4096.
</p>


<h3>Value</h3>

<p>A set of hourly seismic files written to disk.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## basic example with minimum effort
aux_organisecubefiles(stationfile = "output/stationinfo.txt", 
                      input_dir = "input", 
                      gipptools = "software/gipptools-2015.225/")


## End(Not run)
                        
</code></pre>

<hr>
<h2 id='aux_psdsummary'>Calculate aggregated PSDs over long time periods</h2><span id='topic+aux_psdsummary'></span>

<h3>Description</h3>

<p>The function generates a long time PSD with aggregated time and frequency
resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_psdsummary(
  start,
  stop,
  ID,
  window,
  component = "BHZ",
  sensor,
  logger,
  gain = 1,
  dir,
  hours_skip,
  res = 1000,
  n = 100,
  cpu,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_psdsummary_+3A_start">start</code></td>
<td>
<p><code>POSIXct</code> value, start time for PSD 
calculation. If a character string (or vector) is provided, the function 
will try to convert it to POSIXct.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_stop">stop</code></td>
<td>
<p><code>POSIXct</code> value, stop time for PSD calculation. 
If a character string (or vector) is provided, the function will try to 
convert it to POSIXct.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_id">ID</code></td>
<td>
<p><code>Character</code> vector, station ID to be processed</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> value, time window size for the PSD 
calculation. Should be appropriately large to avoid extensive calculation
times, usually at the order of 0.1 percent of the total PSD duration.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_component">component</code></td>
<td>
<p><code>Character</code> value or vector, seismic component to 
be used. If omitted, the function will use <code>"BHZ"</code> by default.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_sensor">sensor</code></td>
<td>
<p><code>Character</code> value, sensor keyword for the deconvolution 
step (see <code>signal_deconvolve</code> for details and keywords). If omitted, 
no deconvolution will be attempted.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_logger">logger</code></td>
<td>
<p><code>Character</code> value, logger keyword for the deconvolution 
step (see <code>signal_deconvolve</code> for details and keywords). If omitted, 
no deconvolution will be attempted.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_gain">gain</code></td>
<td>
<p><code>Numeric</code> value, signal preamplification factor used for 
the deconvolution step (see <code>signal_deconvolve</code> for details. Default
value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_dir">dir</code></td>
<td>
<p><code>Character</code> value, path to directory that contains the 
seismic files. See <code>aux_getevent</code> for details and constraints on the 
data structure.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_hours_skip">hours_skip</code></td>
<td>
<p><code>Integer</code> vector, one or more full hours that will
be excluded from the PSD generation. This optional value is useful if one 
wants to omit noisy daytime hours.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_res">res</code></td>
<td>
<p><code>Numeric</code> value, frequency resolution of the PSD, by 
default set to <code>1000</code>. This is used to reduce the resulting data 
size.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> value, number of times to try to find a time 
snippet with data to estimate the frequency vector length. By
default set to <code>100</code>.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_cpu">cpu</code></td>
<td>
<p><code>Numeric</code> value, fraction of CPUs to use. If omitted, 
only one CPU will be used.</p>
</td></tr>
<tr><td><code id="aux_psdsummary_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value, option to show extended function 
information as the function is running. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will calculate PSDs using the Welch method (see 
<code>signal_spectrogram</code>), with no overlap of the main time windows. The 
sub-windows will be automatically set to 10 
the overlap of sub-windows to 0.5.
</p>


<h3>Value</h3>

<p><code>eseis</code> object, a spectrogram
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

p &lt;- aux_psdsummary(start = "2017-04-15 19:00:00 UTC",
                    stop = "2017-04-15 22:00:00 UTC",
                    ID = "RUEG1",
                    component = "BHE",
                    dir = "~/data/sac/",
                    sensor = "TC120s", 
                    logger = "Cube3ext",
                    window = 600,
                    res = 1000,
                    verbose = TRUE)
                    
plot(p)


## End(Not run)

</code></pre>

<hr>
<h2 id='aux_sonifysignal'>Convert seismic signal to sound (sonification)</h2><span id='topic+aux_sonifysignal'></span>

<h3>Description</h3>

<p>The function converts a seismic signal to sound and saves it as a 
wav file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_sonifysignal(
  data,
  file,
  aggregate = 1,
  amplification = 10^6,
  speed = 1,
  dt
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_sonifysignal_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object to be converted to sound file</p>
</td></tr>
<tr><td><code id="aux_sonifysignal_+3A_file">file</code></td>
<td>
<p><code>Character</code> value, file name under which the sonified 
signal is saved.</p>
</td></tr>
<tr><td><code id="aux_sonifysignal_+3A_aggregate">aggregate</code></td>
<td>
<p><code>Numeric</code> value, factor by which the seismic 
file is aggregated before conversion. Aggregation is performed by 
linear interpolation.</p>
</td></tr>
<tr><td><code id="aux_sonifysignal_+3A_amplification">amplification</code></td>
<td>
<p><code>Numeric</code> value, amplification factor. Default 
is <code>10^6</code>.</p>
</td></tr>
<tr><td><code id="aux_sonifysignal_+3A_speed">speed</code></td>
<td>
<p><code>Numeric</code> value, factor by which sampling rate is 
increased to make sound sensible. The higher the speed value, the 
higher is the tone. Default is <code>1</code> (100 Hz seismic signal becomes 
100 Hz sound signal).</p>
</td></tr>
<tr><td><code id="aux_sonifysignal_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, samplig rate. Only needed if data is 
not an <code>eseis</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sound file in wav format, written to disk.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## load example data
data(rockfall)

## deconvolve and taper signal
s &lt;- signal_deconvolve(data = rockfall_eseis)
s &lt;- signal_taper(data = s, p = 0.05)

## sonify as is (barely sensible, due to too low frequency)
aux_sonifysignal(data = s, 
                 file = "~/Downloads/r1.wav")

## sonify at 20-fold speed
aux_sonifysignal(data = s, 
                 file = "~/Downloads/r1.wav", 
                 speed = 20)

## End(Not run)

</code></pre>

<hr>
<h2 id='aux_stationinfofile'>Create station info file from cube files.</h2><span id='topic+aux_stationinfofile'></span>

<h3>Description</h3>

<p>This function reads GPS tags from Omnirecs/Digos Datacube files and creates 
a station info file from additional input data. It depends on the cubetools 
or gipptools software package (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_stationinfofile(
  name,
  input_dir,
  output_dir,
  station_ID,
  station_name,
  station_z,
  station_d,
  sensor_type,
  logger_type,
  sensor_ID,
  logger_ID,
  unit = "dd",
  n,
  quantile = 0.95,
  random = TRUE,
  cpu,
  gipptools,
  write_file = TRUE,
  write_raw = FALSE,
  write_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_stationinfofile_+3A_name">name</code></td>
<td>
<p><code>Character</code> value, file name of the output station info 
file, without extention (will be added as *.txt).</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_input_dir">input_dir</code></td>
<td>
<p><code>Character</code> value, path to directory where all cube 
files to be processed as stored. Each set of files from one logger must be 
stored in a separate sub-directory named after the cube ID.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_output_dir">output_dir</code></td>
<td>
<p><code>Character</code> value, path to directory where output 
data is written to.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_station_id">station_ID</code></td>
<td>
<p><code>Character</code> vector, seismic station ID. Each value
must not contain more than 5 characters. Longer entries will be clipped. If  
omitted, a default ID will be created.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_station_name">station_name</code></td>
<td>
<p><code>Character</code> vector, seismic station name. If
omitted, the station ID is used as name.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_station_z">station_z</code></td>
<td>
<p><code>Numeric</code> vector, elevation of the seismic stations.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_station_d">station_d</code></td>
<td>
<p><code>Numeric</code> vector, deployment depth of the seismic sensor.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_sensor_type">sensor_type</code></td>
<td>
<p><code>Character</code> vector, sensor type.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_logger_type">logger_type</code></td>
<td>
<p><code>Character</code> vector, logger type.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_sensor_id">sensor_ID</code></td>
<td>
<p><code>Character</code> vector, sensor ID.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_logger_id">logger_ID</code></td>
<td>
<p><code>Character</code> vector, logger ID.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_unit">unit</code></td>
<td>
<p><code>Character</code> value, coordinates unit of the location. One 
out of <code>"dd"</code> (decimal degrees) and <code>"utm"</code> (metric in UTM zone). 
Default is <code>"dd"</code>.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> value, number of cube file to process for GPS 
coordinate extraction. If omitted, all files are processed.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_quantile">quantile</code></td>
<td>
<p><code>Numeric</code> value, quantile size to which the extracted 
coordinate sample size is restricted. This is mainly used to remove 
coordinate outliers, due to spurious GPS signals. Default is 
<code>0.95</code>. Set to <code>1</code> to omit any sample rejection.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_random">random</code></td>
<td>
<p><code>Logical</code> value, option to draw <code>n</code> cube files 
randomly instead of ordered by date. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_cpu">cpu</code></td>
<td>
<p><code>Numeric</code> value, fraction of CPUs to use for parallel 
processing. If omitted, one CPU is used.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_gipptools">gipptools</code></td>
<td>
<p><code>Character</code> value, path to gipptools or cubetools 
directory.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_write_file">write_file</code></td>
<td>
<p><code>Logical</code> value, option to write station info file 
to disk. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_write_raw">write_raw</code></td>
<td>
<p><code>Logical</code> value, option to write (keep) raw ASCII 
GPS data. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aux_stationinfofile_+3A_write_data">write_data</code></td>
<td>
<p><code>Logical</code> value, option to write gps raw data as 
rda-file. File name will be the same as for <code>file</code>. Default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A station info file is an ASCII file that contains all relevant information
about the individual stations of a seismic network. The variables contain a 
station ID (containing not more than 5 characters), station name, latitude, 
longitude, elevation, deployment depth, sensor type, logger type, sensor 
ID and logger ID.<br /> The function requires that the software cubetools 
(<code>http://www.omnirecs.de/documents.html</code>) or gipptools 
(<code>http://www.gfz-potsdam.de/en/section/geophysical-deep-sounding/infrastructure/geophysical-instrument-pool-potsdam-gipp/software/gipptools/</code>) 
are installed. Note that GPS tag extraction may take several minutes per 
cube file. Hence, depending on the number of files and utilised CPUs the 
processing may take a while.<br /> Specifying an input directory 
(<code>input_dir</code>) is mandatory. This input directory must only contain the 
subdirectories with the cube files to process, each set of cube files must 
be located in a separate subdirectory and these subdiretories must 
have the same name as specified by the logger IDs (<code>logger_ID</code>). An 
appropriate structure would be something like: <br /> 
</p>

<ol>
<li><p> input
</p>

<ol>
<li><p> A1A
</p>

<ol>
<li><p> file1.A1A
</p>
</li>
<li><p> file2.A1A
</p>
</li></ol>

</li>
<li><p> A1B
</p>

<ol>
<li><p> file1.A1B
</p>
</li>
<li><p> file2.A1B
</p>
</li></ol>

</li></ol>

</li></ol>



<h3>Value</h3>

<p>A set of files written to disk and a data frame with seismic 
station information.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## basic example with minimum effort
aux_stationinfofile(name = "stationinfo", 
                    input_dir = "input", 
                    logger_ID = c("864", "876", "AB1"),
                    gipptools = "software/gipptools-2015.225")

## example with more adjustments
aux_stationinfofile(name = "stationinfo",
                    input_dir = "input",
                    logger_ID = c("864", "876", "AB1"),
                    station_name = c("KTZ01", "KTZ02", "KTZ03"), 
                    station_z = c(30, 28, 29), 
                    station_d = rep(0.5, 3), 
                    sensor_type = rep("TC120s", 3), 
                    logger_type = rep("Cube3ext", 3), 
                    unit = "utm", 
                    n = 1, 
                    cpu = 0.9,
                    gipptools = "software/gipptools-2015.225", 
                    write_raw = TRUE, 
                    write_data = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='earthquake'>Seismic traces of a small earthquake</h2><span id='topic+earthquake'></span><span id='topic+s'></span><span id='topic+t'></span>

<h3>Description</h3>

<p>The dataset comprises the seismic signal (all three components) of 
a small earthquake. The data have been recorded at 200 Hz sampling 
frequency with an Omnirecs Cube ext 3 data logger.
</p>
<p>The dataset comprises the time vector associated with the data set
<code>earthquake</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s

t
</code></pre>


<h3>Format</h3>

<p>The format is: 
List of 3
$ BHE: num [1:8001] -3.95e-07 ...
$ BHN: num [1:8001] -2.02e-07 ...
$ BHZ: num [1:8001] -1.65e-07 ...
</p>
<p>The format is: POSIXct[1:98400], format: &quot;2015-04-06 13:16:54&quot; ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(earthquake)

## plot signal vector
plot(x = t, y = s$BHZ, type = "l")


## load example data set
data(earthquake)

## show range of time vector
range(t)

</code></pre>

<hr>
<h2 id='fmi_inversion'>Invert fluvial data set based on reference spectra catalogue</h2><span id='topic+fmi_inversion'></span>

<h3>Description</h3>

<p>The fluvial model inversion (FMI) routine uses a predefined look-up table 
with reference spectra to identify those spectra that fit the empirical 
data set best, and returns the corresponding target variables and fit 
errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmi_inversion(reference, data, n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmi_inversion_+3A_reference">reference</code></td>
<td>
<p><code>List</code> containing lists with precalculated model 
spectra.</p>
</td></tr>
<tr><td><code id="fmi_inversion_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object or <code>numeric</code> matrix (spectra organised
by columns), empiric spectra which are used to identify the best matching 
target parameters of the reference data set.</p>
</td></tr>
<tr><td><code id="fmi_inversion_+3A_n_cores">n_cores</code></td>
<td>
<p><code>Numeric</code> value, number of CPU cores to use. Disabled 
by setting to 1. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the frequencies of the empiric and modelled data sets must 
match.
</p>


<h3>Value</h3>

<p><code>List</code> object containing the inversion results.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## NOTE THAT THE EXAMPLE IS OF BAD QUALITY BECAUSE ONLY 10 REFERENCE 
## PARAMETER SETS AND SPECTRA ARE CALCULATED, DUE TO COMPUATATION TIME
## CONSTRAINTS. SET THE VALUE TO 1000 FOR MORE MEANINGFUL RESULTS.

## create 100 example reference parameter sets
ref_pars &lt;- fmi_parameters(n = 10,
                           h_w = c(0.02, 1.20),
                           q_s = c(0.001, 8.000) / 2650,
                           d_s = 0.01,
                           s_s = 1.35,
                           r_s = 2650,
                           w_w = 6,
                           a_w = 0.0075,
                           f_min = 5,
                           f_max = 80,
                           r_0 = 6,
                           f_0 = 1,
                           q_0 = 10,
                           v_0 = 350,
                           p_0 = 0.55,
                           e_0 = 0.09,
                           n_0_a = 0.6,
                           n_0_b = 0.8,
                           res = 100)

## create corresponding reference spectra
ref_spectra &lt;- fmi_spectra(parameters = ref_pars)

## define water level and bedload flux time series
h &lt;- c(0.01, 1.00, 0.84, 0.60, 0.43, 0.32, 0.24, 0.18, 0.14, 0.11)
q &lt;- c(0.05, 5.00, 4.18, 3.01, 2.16, 1.58, 1.18, 0.89, 0.69, 0.54) / 2650
hq &lt;- as.list(as.data.frame(rbind(h, q)))

## calculate synthetic spectrogram
psd &lt;- do.call(cbind, lapply(hq, function(hq) {

  psd_turbulence &lt;- eseis::model_turbulence(h_w = hq[1],
                                            d_s = 0.01,
                                            s_s = 1.35,
                                            r_s = 2650,
                                            w_w = 6,
                                            a_w = 0.0075,
                                            f = c(10, 70),
                                            r_0 = 5.5,
                                            f_0 = 1,
                                            q_0 = 18,
                                            v_0 = 450,
                                            p_0 = 0.34,
                                            e_0 = 0.0,
                                            n_0 = c(0.5, 0.8),
                                            res = 100, 
                                            eseis = FALSE)$power

  psd_bedload &lt;- eseis::model_bedload(h_w = hq[1],
                                      q_s = hq[2],
                                      d_s = 0.01,
                                      s_s = 1.35,
                                      r_s = 2650,
                                      w_w = 6,
                                      a_w = 0.0075,
                                      f = c(10, 70),
                                      r_0 = 5.5,
                                      f_0 = 1,
                                      q_0 = 18,
                                      v_0 = 450,
                                      x_0 = 0.34,
                                      e_0 = 0.0,
                                      n_0 = 0.5,
                                      res = 100,
                                      eseis = FALSE)$power

  ## combine spectra
  psd_sum &lt;- psd_turbulence + psd_bedload

  ## return output
  return(10 * log10(psd_sum))
}))

graphics::image(t(psd))

## invert empiric data set
X &lt;- fmi_inversion(reference = ref_spectra, 
                   data = psd)

## plot model results
plot(X$parameters$q_s * 2650, 
     type = "l")
plot(X$parameters$h_w, 
     type = "l")

</code></pre>

<hr>
<h2 id='fmi_parameters'>Create reference model reference parameter catalogue</h2><span id='topic+fmi_parameters'></span>

<h3>Description</h3>

<p>In order to run the fluvial model inversion (FMI) routine, a set of 
randomised target parameter combinations needs to be created. This 
function does this job.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmi_parameters(
  n,
  d_s,
  s_s,
  r_s,
  q_s,
  h_w,
  w_w,
  a_w,
  f_min,
  f_max,
  r_0,
  f_0,
  q_0,
  v_0,
  p_0,
  e_0,
  n_0_a,
  n_0_b,
  res
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmi_parameters_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> value, number of output reference spectra.</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_d_s">d_s</code></td>
<td>
<p><code>Numeric</code> value, mean sediment grain diameter (m). 
Alternative to <code>gsd</code>.</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_s_s">s_s</code></td>
<td>
<p><code>Numeric</code> value, standard deviation of sediment grain 
diameter (m). Alternative to <code>gsd</code>.</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_r_s">r_s</code></td>
<td>
<p><code>Numeric</code> value, specific sediment density (kg / m^3)</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_q_s">q_s</code></td>
<td>
<p><code>Numeric</code> value, unit sediment flux (m^2 / s)</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_h_w">h_w</code></td>
<td>
<p><code>Numeric</code> value, fluid flow depth (m)</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_w_w">w_w</code></td>
<td>
<p><code>Numeric</code> value, fluid flow width (m)</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_a_w">a_w</code></td>
<td>
<p><code>Numeric</code> value, fluid flow inclination angle (radians)</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_f_min">f_min</code></td>
<td>
<p><code>Numeric</code> value, lower boundary of the frequency range 
to be modelled.</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_f_max">f_max</code></td>
<td>
<p><code>Numeric</code> value, upper boundary of the frequency range 
to be modelled.</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_r_0">r_0</code></td>
<td>
<p><code>Numeric</code> value, distance of seismic station to source</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_f_0">f_0</code></td>
<td>
<p><code>Numeric</code> value, reference frequency (Hz)</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_q_0">q_0</code></td>
<td>
<p><code>Numeric</code> value, ground quality factor at <code>f_0</code>.
&quot;Reasonable value may be <code>20</code>&quot; (Tsai et al. 2012).</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_v_0">v_0</code></td>
<td>
<p><code>Numeric</code> value, phase speed of the Rayleigh wave at 
<code>f_0</code> (m/s). Assuming a shear wave velocity of about 2200 m/s, 
Tsai et al. (2012) yield a value of 1295 m/s for this parameter.</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_p_0">p_0</code></td>
<td>
<p><code>Numeric</code> value, variation exponent of Rayleigh wave 
velocities with frequency (dimensionless)</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_e_0">e_0</code></td>
<td>
<p><code>Numeric</code> value, exponent characterizing quality factor 
increase with frequency (dimensionless). &quot;Reasonable value may be 
<code>0</code>&quot; (Tsai et al. 2012).</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_n_0_a">n_0_a</code></td>
<td>
<p><code>Numeric</code> value, lower Greens function 
displacement amplitude coefficients. Cf. N_ij in eq. 36 in Gimbert et 
al. (2014)</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_n_0_b">n_0_b</code></td>
<td>
<p><code>Numeric</code> value, lower Greens function 
displacement amplitude coefficients. Cf. N_ij in eq. 36 in Gimbert et 
al. (2014)</p>
</td></tr>
<tr><td><code id="fmi_parameters_+3A_res">res</code></td>
<td>
<p><code>Numeric</code> value, output resolution, i.e. length of the 
spectrum vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parameters must be provided as single values, except for those 
parameters that shall be randomised, which must be provided as a vector
of length two. This vector defines the range within which uniformly 
distributed random values will be generated and assigned.
</p>


<h3>Value</h3>

<p><code>List</code> object with model reference parameters.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create two parameter sets where h_w (water level) and q_s (sediment
## flux) are randomly varied.

ref_pars &lt;- fmi_parameters(n = 2,
                           h_w = c(0.02, 2.00),
                           q_s = c(0.001, 50.000) / 2650,
                           d_s = 0.01,
                           s_s = 1.35,
                           r_s = 2650,
                           w_w = 6,
                           a_w = 0.0075,
                           f_min = 5,
                           f_max = 80,
                           r_0 = 6,
                           f_0 = 1,
                           q_0 = 10,
                           v_0 = 350,
                           p_0 = 0.55,
                           e_0 = 0.09,
                           n_0_a = 0.6,
                           n_0_b = 0.8,
                           res = 100)

</code></pre>

<hr>
<h2 id='fmi_spectra'>Create reference model spectra catalogue</h2><span id='topic+fmi_spectra'></span>

<h3>Description</h3>

<p>In order to run the fluvial model inversion (FMI) routine, a look-up 
table with reference spectra needs to be created (based on predefined 
model parameters). This function does this job.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmi_spectra(parameters, n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmi_spectra_+3A_parameters">parameters</code></td>
<td>
<p><code>List</code> containing lists with model parameters 
for which the spectra shall be calculated.</p>
</td></tr>
<tr><td><code id="fmi_spectra_+3A_n_cores">n_cores</code></td>
<td>
<p><code>Numeric</code> value, number of CPU cores to use. Disabled 
by setting to 1. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>List</code> object containing the calculated reference spectra 
and the corresponding input parameters. Note that the spectra are given
in dB for a seamless comparison with the empirical PSD data, while the 
original output of the models are in linear scale.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create 2 example reference parameter sets
ref_pars &lt;- fmi_parameters(n = 2,
                           h_w = c(0.02, 2.00),
                           q_s = c(0.001, 50.000) / 2650,
                           d_s = 0.01,
                           s_s = 1.35,
                           r_s = 2650,
                           w_w = 6,
                           a_w = 0.0075,
                           f_min = 5,
                           f_max = 80,
                           r_0 = 6,
                           f_0 = 1,
                           q_0 = 10,
                           v_0 = 350,
                           p_0 = 0.55,
                           e_0 = 0.09,
                           n_0_a = 0.6,
                           n_0_b = 0.8,
                           res = 100)

## create corresponding reference spectra
ref_spectra &lt;- fmi_spectra(parameters = ref_pars)

</code></pre>

<hr>
<h2 id='gui_models'>Start GUI with seismic models</h2><span id='topic+gui_models'></span>

<h3>Description</h3>

<p>This function starts a browser-based graphic user interface to explore the 
parameter space of seismic models that predict the spectra of turbulent 
water flow and bedload flux.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gui_models(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gui_models_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code><a href="shiny.html#topic+runApp">runApp</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>See Also</h3>

<p><code><a href="shiny.html#topic+runApp">runApp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Start the GUI
gui_models()

## End(Not run)

</code></pre>

<hr>
<h2 id='list_logger'>List library with data logger information.</h2><span id='topic+list_logger'></span>

<h3>Description</h3>

<p>The function returns the list of supported data loggers to extract signal 
deconvolution parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_logger()
</code></pre>


<h3>Details</h3>

<p>The value AD is the analogue-digital conversion factor.
</p>


<h3>Value</h3>

<p><code>List</code> object, supported loggers with their parameters.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## show documented loggers
list_logger()

## show names of loggers in list
names(list_logger())
                     
</code></pre>

<hr>
<h2 id='list_sacparameters'>List all header parameters of a sac file.</h2><span id='topic+list_sacparameters'></span>

<h3>Description</h3>

<p>The function returns a data frame with all header values of a sac file. It 
may be used for advanced modifications by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_sacparameters()
</code></pre>


<h3>Value</h3>

<p><code>List</code> object, parameters supported by a sac file.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## show sac parameters
list_sacparameters()
                     
</code></pre>

<hr>
<h2 id='list_sensor'>List sensor library.</h2><span id='topic+list_sensor'></span>

<h3>Description</h3>

<p>The function returns the list of supported sensors to extract signal 
deconvolution parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_sensor()
</code></pre>


<h3>Details</h3>

<p>Poles and zeros must be given in rad/s. Characteristics of further 
sensors can be added manually. See examples of <code>signal_deconvolve</code>
for further information. The value s is the generator constant 
(sensitivity) given in Vs/m. The value k is the normalisation factor of 
the sensor.
</p>


<h3>Value</h3>

<p><code>List</code> object, supported sensors with their parameters.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## show sensors
list_sensor()
                     
</code></pre>

<hr>
<h2 id='model_amplitude'>Model source amplitude by amplitude-distance model fitting</h2><span id='topic+model_amplitude'></span>

<h3>Description</h3>

<p>The function fits one of several models of signal amplitude attenuation and
returns a set of model parameters, including the source amplitude (a_0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_amplitude(
  data,
  model = "SurfSpreadAtten",
  distance,
  source,
  d_map,
  coupling,
  v,
  q,
  f,
  k,
  a_0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_amplitude_+3A_data">data</code></td>
<td>
<p><code>Numeric</code> matrix or <code>eseis</code> object, seismic signals
to work with. Since the function will calculate the maxima of the data it
is usually the envolopes of the data that should be used here. In an 
extreme case, a vector with just the maximum amplitudes recorded at each 
station can be provided, as well.</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_model">model</code></td>
<td>
<p><code>Character</code> value, model to fit the data. One out of the 
list in the details section. Default is <code>"SurfSpreadAtten"</code>.</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_distance">distance</code></td>
<td>
<p><code>Numeric</code> vector with distance of station locations
to source. Alternatively, the distance can be calculated by providing the 
source coordinates (<code>xy</code>) and distance maps (<code>d_map</code>)</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_source">source</code></td>
<td>
<p><code>Numeric</code> vector of length two, location of the seismic 
source to model (x and y coordinates).</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_d_map">d_map</code></td>
<td>
<p><code>List</code> object, distance maps for each station (i.e.,
<code>SpatialGridDataFrame</code> objects). Output of <code>distance_map</code>.</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_coupling">coupling</code></td>
<td>
<p><code>Numeric</code> vector, coupling efficiency factors for each
seismic station. The best coupled station (or the one with the highest
amplification) must receive <code>1</code>, the others must be scaled relatively
to this one.</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_v">v</code></td>
<td>
<p><code>Numeric</code> value, mean velocity of seismic waves (m/s). 
Only relevant for models accounting for unelastic attenuation (see 
details).</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_q">q</code></td>
<td>
<p><code>Numeric</code> value, quality factor of the ground.
Only relevant for models accounting for unelastic attenuation (see 
details).</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_f">f</code></td>
<td>
<p><code>Numeric</code> value, frequency for which to model the
attenuation. Only relevant for models accounting for unelastic attenuation 
(see details).</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_k">k</code></td>
<td>
<p><code>Numeric</code> value, fraction of surface wave contribution to 
signals. Only relevant for models that include mixture of surface and 
body waves (see details).</p>
</td></tr>
<tr><td><code id="model_amplitude_+3A_a_0">a_0</code></td>
<td>
<p><code>Logical</code> value, start parameter of the source amplitude,
if not provided, a best guess is made as 100 times the maximum amplitude
value of the data set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the choice of the model to fit, several parameters can 
(or should) be provided, e.g. <code>f</code>,<code>q</code>, <code>v</code>, <code>k</code>, 
and most importantly, <code>a_0</code>. 
If more signals than free parameters are available, the missing 
parameters may be estimated during the fit, but without any checks 
of quality and meaningfulness. The parameter <code>a_0</code> will be 
defined as 100 times the maximum input amplitude, by default. The 
parameters <code>f</code> will be set to 10 Hz, <code>q</code> to 50, <code>v</code> 
to 1000 m/s and <code>k</code> to 0.5.
</p>
<p>ISSUES: account for non-fixed parameters, especially k
</p>
<p>The following amplitude-distance models are available:
</p>

<ul>
<li> <p><code>"SurfSpreadAtten"</code>, Surface waves including geometric 
spreading and unelastic attenuation
</p>
</li>
<li> <p><code>"BodySpreadAtten"</code>, Body waves including geometric 
spreading and unelastic attenuation
</p>
</li>
<li> <p><code>"SurfBodySpreadAtten"</code>, Surface and body waves including  
geometric spreading and unelastic attenuation
</p>
</li>
<li> <p><code>"SurfSpread"</code>, Surface waves including geometric 
spreading, only
</p>
</li>
<li> <p><code>"BodySpread"</code>, Body waves including geometric 
spreading, only
</p>
</li>
<li> <p><code>"SurfBodySpread"</code>, Surface and body waves including  
geometric spreading, only
</p>
</li></ul>

<p>**SurfSpreadAtten**
The model is based on Eq. 17 from Burtin et al. (2016):
</p>
<p style="text-align: center;"><code class="reqn">a_d = a_0 / sqrt(d) * exp(-(pi * f * d) / (q * v))</code>
</p>

<p>where a_0 is the source amplitude, a_d the amplitude as recorded by a sensor 
at distance d, f is the center frequency of the signal, q the ground quality 
factor and v the seismic wave velocity.
</p>
<p>**BodySpreadAtten**
The model is based on Eq. 16 from Burtin et al. (2016):
</p>
<p style="text-align: center;"><code class="reqn">a_d = a_0 / d * exp(-(pi * f * d) / (q * v))</code>
</p>

<p>where a_0 is the source amplitude, a_d the amplitude as recorded by a sensor 
at distance d, f is the center frequency of the signal, q the ground quality 
factor and v the seismic wave velocity.
</p>
<p>**SurfBodySpreadAtten**
The model based on Eqs. 16 and 17 from Burtin et al. (2016):
</p>
<p style="text-align: center;"><code class="reqn">a_d = k * a_0 / sqrt(d) * exp(-(pi * f * d) / (q * v)) + (1 - k) * a_0 / d * exp(-(pi * f * d) / (q * v))</code>
</p>

<p>where a_0 is the source amplitude, a_d the amplitude as recorded by a sensor 
at distance d, f is the center frequency of the signal, q the ground quality 
factor, v the seismic wave velocity, and n and m two factors determining the 
relative contributions of the two wave types, thus summing to 1.
</p>
<p>**BodySpread**
The model is simply accounting for geometric spreading
</p>
<p style="text-align: center;"><code class="reqn">a_d = a_0 / d</code>
</p>

<p>where a_0 is the source amplitude, a_d the amplitude as recorded by a sensor 
at distance d.
</p>
<p>**SurfSpread**
The model is simply accounting for geometric spreading
</p>
<p style="text-align: center;"><code class="reqn">a_d = a_0 / sqrt(d)</code>
</p>

<p>where a_0 is the source amplitude, a_d the amplitude as recorded by a sensor 
at distance d.
</p>
<p>**SurfBodySpread**
The model is simply accounting for geometric spreading
</p>
<p style="text-align: center;"><code class="reqn">a_d = k * (a_0 / d) + (1 - k) * a_d / sqrt(d)</code>
</p>

<p>where a_0 is the source amplitude, a_d the amplitude as recorded by a sensor 
at distance d, and n and m two factors determining the relative 
contributions of the two wave types, thus summing to 1.
</p>
<p>**References**
- Burtin, A., Hovius, N., and Turowski, J. M.: Seismic monitoring of 
torrential and fluvial processes, Earth Surf. Dynam., 4, 285307, 
https://doi.org/10.5194/esurf-4-285-2016, 2016.
</p>


<h3>Value</h3>

<p><code>List</code> with model results, including <code>a_0</code> (source 
amplitude), <code>residuals</code> (model residuals), <code>coefficients</code> 
model coefficients.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

 ## create synthetic DEM
dem &lt;- terra::rast(nrows = 20, ncols = 20, 
                   xmin = 0, xmax = 10000, 
                   ymin= 0, ymax = 10000, 
                   vals = rep(0, 400))

## define station coordinates
sta &lt;- data.frame(x = c(1000, 9000, 5000, 9000),
                  y = c(1000, 1000, 9000, 9000),
                  ID = c("A", "B", "C", "D"))
 
## create synthetic signal (source in towards lower left corner of the DEM)
s &lt;- rbind(dnorm(x = 1:1000, mean = 500, sd = 50) * 50,
           dnorm(x = 1:1000, mean = 500, sd = 50) * 2,
           dnorm(x = 1:1000, mean = 500, sd = 50) * 1,
           dnorm(x = 1:1000, mean = 500, sd = 50) * 0.5)

## calculate spatial distance maps and inter-station distances
D &lt;- eseis::spatial_distance(stations = sta[,1:2],
                             dem = dem)

model_amplitude(data = s, 
                source = c(500, 600), 
                d_map = D$maps, 
                v = 500, 
                q = 50, 
                f = 10)

model_amplitude(data = s, 
                distance = c(254, 8254, 9280, 11667),
                model = "SurfBodySpreadAtten", 
                v = 500, 
                q = 50, 
                f = 10, 
                k = 0.5)


## End(Not run)

</code></pre>

<hr>
<h2 id='model_bedload'>Model the seismic spectrum due to bedload transport in rivers</h2><span id='topic+model_bedload'></span>

<h3>Description</h3>

<p>The function calculates a seismic spectrum as predicted by the model 
of Tsai et al. (2012) for river bedload transport. The code was written to 
R by Sophie Lagarde and integrated to the R package 'eseis' by Michael 
Dietze.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_bedload(
  gsd,
  d_s,
  s_s,
  r_s,
  q_s,
  h_w,
  w_w,
  a_w,
  f = c(1, 100),
  r_0,
  f_0,
  q_0,
  e_0,
  v_0,
  x_0,
  n_0,
  n_c,
  res = 100,
  adjust = TRUE,
  eseis = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_bedload_+3A_gsd">gsd</code></td>
<td>
<p><code>data frame</code> grain-size distribution function. Must be 
provided as data frame with two variables: grain-size class (in m, first 
column) and wgt/vol percentage per class (second column). See examples for 
details.</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_d_s">d_s</code></td>
<td>
<p><code>Numeric</code> value, mean sediment grain diameter (m). 
Alternative to <code>gsd</code>.</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_s_s">s_s</code></td>
<td>
<p><code>Numeric</code> value, standard deviation of sediment grain 
diameter (m). Alternative to <code>gsd</code>.</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_r_s">r_s</code></td>
<td>
<p><code>Numeric</code> value, specific sediment density (kg / m^3)</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_q_s">q_s</code></td>
<td>
<p><code>Numeric</code> value, unit sediment flux (m^2 / s)</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_h_w">h_w</code></td>
<td>
<p><code>Numeric</code> value, fluid flow depth (m)</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_w_w">w_w</code></td>
<td>
<p><code>Numeric</code> value, fluid flow width (m)</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_a_w">a_w</code></td>
<td>
<p><code>Numeric</code> value, fluid flow inclination angle (radians)</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_f">f</code></td>
<td>
<p><code>Numeric</code> vector, frequency range to be modelled. 
If of length two the argument is interpreted as representing the lower and 
upper limit and the final length of the frequency vector is set by the 
argument <code>res</code>. If <code>f</code> contains more than two values it is 
interpreted as the actual frequency vector and the value of <code>res</code> is 
ignored.</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_r_0">r_0</code></td>
<td>
<p><code>Numeric</code> value, distance of seismic station to source</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_f_0">f_0</code></td>
<td>
<p><code>Numeric</code> value, reference frequency (Hz)</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_q_0">q_0</code></td>
<td>
<p><code>Numeric</code> value, ground quality factor at <code>f_0</code>.
&quot;Reasonable value may be <code>20</code>&quot; (Tsai et al. 2012).</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_e_0">e_0</code></td>
<td>
<p><code>Numeric</code> value, exponent characterizing quality factor 
increase with frequency (dimensionless). &quot;Reasonable value may be 
<code>0</code>&quot; (Tsai et al. 2012).</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_v_0">v_0</code></td>
<td>
<p><code>Numeric</code> value, phase speed of the Rayleigh wave at 
<code>f_0</code> (m/s). Assuming a shear wave velocity of about 2200 m/s, 
Tsai et al. (2012) yield a value of 1295 m/s for this parameter.</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_x_0">x_0</code></td>
<td>
<p><code>Numeric</code> value, exponent of the power law variation of 
Rayleigh wave velocities with frequency</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_n_0">n_0</code></td>
<td>
<p><code>Numeric</code> vector of length two, Greens function 
displacement amplitude coefficients. Cf. N_ij in eq. 36 in Gimbert et 
al. (2014)</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_n_c">n_c</code></td>
<td>
<p><code>Numeric</code> value, option to include single particle hops 
coherent in time, causing spectrum modulation due to secondary effects. 
Omitted is no value is specified, here. Usual values may be between 2 and 
4.</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_res">res</code></td>
<td>
<p><code>Numeric</code> value, output resolution, i.e. length of the 
spectrum vector. Default is 1000.</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_adjust">adjust</code></td>
<td>
<p><code>Logical</code> value, option to adjust PSD for wide 
grain-size distributions, according to implementation by Tsai et al. 
(2012).</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_eseis">eseis</code></td>
<td>
<p><code>Character</code> value, option to return an eseis object 
instead of a data frame. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="model_bedload_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model uses a set of predefined constants. These can also be changed
by the user, using the <code>...</code> argument:
</p>

<ul>
<li> <p><code>g = 9.81</code>, gravitational acceleration (m/s^2)
</p>
</li>
<li> <p><code>r_w = 1000</code>, fluid specific density (kg/m^3)
</p>
</li>
<li> <p><code>k_s = 3 * d_50</code>, roughness length (m)
</p>
</li>
<li> <p><code>log_lim = c(0.0001, 100), limits of grain-size distribution 
  function template (m)</code>
</p>
</li>
<li> <p><code>log_length = 10000, length of grain-size distribution 
  function template</code>
</p>
</li>
<li> <p><code>nu = 10^(-6)</code>, specific density of the fluid (kg/m^3)
</p>
</li>
<li> <p><code>power_d = 3</code>, grain-size power exponent
</p>
</li>
<li> <p><code>gamma = 0.9</code>, gamma parameter, after Parker (1990)
</p>
</li>
<li> <p><code>s_c = 0.8</code>, drag coefficient parameter
</p>
</li>
<li> <p><code>s_p = 3.5</code>, drag coefficient parameter
</p>
</li>
<li> <p><code>c_1 = 2 / 3</code>, inter-impact time scaling, after 
Sklar &amp; Dietrich (2004)
</p>
</li></ul>

<p>When no user defined grain-size distribution function is provided,the 
function calculates the raised cosine distribution function as defined 
in Tsai et al. (2012) using the default range and resolution as specified 
by <code>log_lim</code> and <code>log_length</code> (see additional arguments list 
above). These default values are appropriate for mean sediment sizes 
between 0.001 and 10 m and log standard deivations between 0.05 and 1. 
When more extreme distributions are to be used, it is necessary to either 
adjust the arguments <code>log_lim</code> and <code>log_length</code> or use a 
user defined distribution function.
</p>
<p>The adjustment option (implemented with package version 0.6.0) is only 
relevant for wide grain-size distributions, i.e., <code>s_s</code> &gt; 0.2. In 
such cases, the unadjusted version tends to underestimate seismic power.
</p>


<h3>Value</h3>

<p><code>eseis</code> object containing the modelled spectrum.
</p>


<h3>Author(s)</h3>

<p>Sophie Lagarde, Michael Dietze
</p>


<h3>References</h3>

<p>Tsai, V. C., B. Minchew, M. P. Lamb, and J.-P. Ampuero (2012), A 
physical model for seismic noise generation from sediment transport in 
rivers, Geophys. Res. Lett., 39, L02404, doi:10.1029/2011GL050255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## calculate spectrum (i.e., fig. 1b in Tsai et al., 2012)
p_bedload &lt;- model_bedload(d_s = 0.7,
                           s_s = 0.1,
                           r_s = 2650,
                           q_s = 0.001,
                           h_w = 4,
                           w_w = 50,
                           a_w = 0.005,
                           f = c(0.1, 20),
                           r_0 = 600,
                           f_0 = 1,
                           q_0 = 20,
                           e_0 = 0,
                           v_0 = 1295,
                           x_0 = 0.374,
                           n_0 = 1,
                           res = 100,
                           eseis = TRUE)

## plot spectrum
plot_spectrum(data = p_bedload, 
              ylim = c(-170, -110))
              
## define empiric grain-size distribution
gsd_empiric &lt;- data.frame(d = c(0.70, 0.82, 0.94, 1.06, 1.18, 1.30),
                          p = c(0.02, 0.25, 0.45, 0.23, 0.04, 0.00))
                  
## calculate spectrum
p_bedload &lt;- model_bedload(gsd = gsd_empiric,
                           r_s = 2650,
                           q_s = 0.001,
                           h_w = 4,
                           w_w = 50,
                           a_w = 0.005,
                           f = c(0.1, 20),
                           r_0 = 600,
                           f_0 = 1,
                           q_0 = 20,
                           e_0 = 0,
                           v_0 = 1295,
                           x_0 = 0.374,
                           n_0 = 1,
                           res = 100,
                           eseis = TRUE)
                  
## plot spectrum
plot_spectrum(data = p_bedload, 
              ylim = c(-170, -110))
              
## define mean and sigma for parametric distribution function
d_50 &lt;- 1
sigma &lt;- 0.1

## define raised cosine distribution function following Tsai et al. (2012)
d_1 &lt;- 10^seq(log10(d_50 - 5 * sigma), 
              log10(d_50 + 5 * sigma), 
              length.out = 20)

sigma_star &lt;- sigma / sqrt(1 / 3 - 2 / pi^2)

p_1 &lt;- (1 / (2 * sigma_star) * 
          (1 + cos(pi * (log(d_1) - log(d_50)) / sigma_star))) / d_1
p_1[log(d_1) - log(d_50) &gt; sigma_star] &lt;- 0
p_1[log(d_1) - log(d_50) &lt; -sigma_star] &lt;- 0
p_1 &lt;- p_1 / sum(p_1)

gsd_raised_cos &lt;- data.frame(d = d_1,
                             p = p_1)
             
</code></pre>

<hr>
<h2 id='model_turbulence'>Model the seismic spectrum due to hydraulic turbulence</h2><span id='topic+model_turbulence'></span>

<h3>Description</h3>

<p>The function calculates the seismic spectrum as predicted by the model 
of Gimbert et al. (2014) for hydraulic turbulence. The code was written to 
R by Sophie Lagarde and integrated to the R package 'eseis' by Michael 
Dietze.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_turbulence(
  d_s,
  s_s,
  r_s = 2650,
  h_w,
  w_w,
  a_w,
  f = c(1, 100),
  r_0,
  f_0,
  q_0,
  v_0,
  p_0,
  n_0,
  res = 1000,
  eseis = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_turbulence_+3A_d_s">d_s</code></td>
<td>
<p><code>Numeric</code> value, mean sediment grain diameter (m)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_s_s">s_s</code></td>
<td>
<p><code>Numeric</code> value, standard deviation of sediment grain 
diameter (m)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_r_s">r_s</code></td>
<td>
<p><code>Numeric</code> value, specific sediment density (kg / m^3)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_h_w">h_w</code></td>
<td>
<p><code>Numeric</code> value, fluid flow depth (m)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_w_w">w_w</code></td>
<td>
<p><code>Numeric</code> value, fluid flow width (m)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_a_w">a_w</code></td>
<td>
<p><code>Numeric</code> value, fluid flow inclination angle (radians)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_f">f</code></td>
<td>
<p><code>Numeric</code> vector, frequency range to be modelled. 
If of length two the argument is interpreted as representing the lower and 
upper limit and the final length of the frequency vector is set by the 
argument <code>res</code>. If <code>f</code> contains more than two values it is 
interpreted as the actual frequency vector and the value of <code>res</code> is 
ignored.</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_r_0">r_0</code></td>
<td>
<p><code>Numeric</code> value, distance of seismic station to source</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_f_0">f_0</code></td>
<td>
<p><code>Numeric</code> value, reference frequency (Hz)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_q_0">q_0</code></td>
<td>
<p><code>Numeric</code> value, ground quality factor at <code>f_0</code></p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_v_0">v_0</code></td>
<td>
<p><code>Numeric</code> value, phase velocity of the Rayleigh wave at 
<code>f_0</code> (m/s)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_p_0">p_0</code></td>
<td>
<p><code>Numeric</code> value, variation exponent of Rayleigh wave 
velocities with frequency (dimensionless)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_n_0">n_0</code></td>
<td>
<p><code>Numeric</code> vector of length two, Greens function 
displacement amplitude coefficients. Cf. N_ij in eq. 36 in Gimbert et 
al. (2014)</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_res">res</code></td>
<td>
<p><code>Numeric</code> value, output resolution, i.e. length of the 
spectrum vector. Default is 1000.</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_eseis">eseis</code></td>
<td>
<p><code>Character</code> value, option to return an eseis object 
instead of a data frame. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="model_turbulence_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model uses a set of predefined constants. These can also be changed
by the user, using the <code>...</code> argument:
</p>

<ul>
<li> <p><code>c = 0.5</code>, instantaneous fluid-grain friction coefficient 
(dimensionless)
</p>
</li>
<li> <p><code>g = 9.81</code>, gravitational acceleration (m/s^2)
</p>
</li>
<li> <p><code>k = 0.5</code>, Kolmogrov constant (dimensionless)
</p>
</li>
<li> <p><code>k_s = 3 * d_s</code>, roughness length (m)
</p>
</li>
<li> <p><code>h = k_s / 2</code>, reference height of the measurement (m)
</p>
</li>
<li> <p><code>e_0 = 0</code>, exponent of Q increase with frequency 
(dimensionless)
</p>
</li>
<li> <p><code>r_w = 1000</code>, specific density of the fluid (kg/m^3)
</p>
</li>
<li> <p><code>c_w = 0.5</code>, instantaneous fluid-grain friction coefficient
(dimensionless)
</p>
</li></ul>



<h3>Value</h3>

<p><code>eseis</code> object containing the modelled spectrum.
</p>


<h3>Author(s)</h3>

<p>Sophie Lagarde, Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## model the turbulence-related power spectrum
P &lt;- model_turbulence(d_s = 0.03, # 3 cm mean grain-size
                      s_s = 1.35, # 1.35 log standard deviation
                      r_s = 2650, # 2.65 g/cm^3 sediment density
                      h_w = 0.8, # 80 cm water level
                      w_w = 40, # 40 m river width
                      a_w = 0.0075, # 0.0075 rad river inclination
                      f = c(1, 200), # 1-200 Hz frequency range
                      r_0 = 10, # 10 m distance to the river
                      f_0 = 1, # 1 Hz Null frequency 
                      q_0 = 10, # 10 quality factor at f = 1 Hz
                      v_0 = 2175, # 2175 m/s phase velocity
                      p_0 = 0.48, # 0.48 power law variation coefficient
                      n_0 = c(0.6, 0.8), # Greens function estimates
                      res = 1000) # 1000 values build the output resolution

## plot the power spectrum
plot_spectrum(data = P)
              
</code></pre>

<hr>
<h2 id='pick_correlation'>Signal correlation based event picking</h2><span id='topic+pick_correlation'></span>

<h3>Description</h3>

<p>The function picks (identifies) events from continuous data by comparing 
the data patterns against a template signal using Pearson's correlation 
coefficient, defining an event when that coefficient is above a threshold 
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_correlation(data, on, template, dur_min, time, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_correlation_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="pick_correlation_+3A_on">on</code></td>
<td>
<p><code>Numeric</code> value, minimum correlation coefficient to define 
event occurence.</p>
</td></tr>
<tr><td><code id="pick_correlation_+3A_template">template</code></td>
<td>
<p><code>eseis</code> object or signal vector, template event 
with which the data set is correlated.</p>
</td></tr>
<tr><td><code id="pick_correlation_+3A_dur_min">dur_min</code></td>
<td>
<p><code>Numeric</code> value, minimum duration of the event. This 
is required as the routine tends to identify multipe picks with similarly 
high correlation coefficients due to autocorrelation effects. If omitted, 
<code>dur_min</code> is set to <code>0</code>, i.e., all picks are returned.</p>
</td></tr>
<tr><td><code id="pick_correlation_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector, time vector of the signal(s). If not 
provided, a synthetic time vector will be created.</p>
</td></tr>
<tr><td><code id="pick_correlation_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. If omitted, either 
estimated from <code>time</code> or set to 0.01 s (i.e., f = 100 Hz).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>, picked events.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create synthetic event signal
p &lt;- sin(seq(0, 10 * pi, by = 0.35)) * 0.2 * 
  (1 + sin(seq(0, pi, length.out = 90)))^5

## show event signal
plot(p, type = "l")

## create synthetic noise signal
x &lt;- runif(n = 1000, min = -1, max = 1)
t &lt;- seq(from = Sys.time(), length.out = length(x), by = 1/200)
ii &lt;- floor(runif(n = 3, min = 100, max = 900))

## add events to noise
for(k in 1:length(ii)) {
  
  nn &lt;- ii[k]:(ii[k] + 89)
  x[nn] &lt;- x[nn] + p
}

## show resulting time series
plot(x = t, y = x, type = "l")

## pick events based on template
picks &lt;- eseis::pick_correlation(data = x, 
                                 on = 0.8, 
                                 template = p, 
                                 time = t, 
                                 dt = 1/200)
                                 
## show result
print(picks)
                     
</code></pre>

<hr>
<h2 id='pick_kurtosis'>Kutosis based event picking</h2><span id='topic+pick_kurtosis'></span>

<h3>Description</h3>

<p>The function picks (identifies) events from continuous data using the 
kurtosis of the signal, and when it reaches beyond a defined threshold 
value. The end of an event is determined by the signal-to-noise ratio 
(SNR)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_kurtosis(
  data,
  on,
  off = 1,
  dur_min = 0,
  dur_max,
  window_kurt,
  window_amp,
  time,
  dt
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_kurtosis_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="pick_kurtosis_+3A_on">on</code></td>
<td>
<p><code>Numeric</code> value, kurtosis threshold that defines the 
onset of an event.</p>
</td></tr>
<tr><td><code id="pick_kurtosis_+3A_off">off</code></td>
<td>
<p><code>Numeric</code> value, ratio of average post and pre event
signal amplitude inside a running window. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="pick_kurtosis_+3A_dur_min">dur_min</code></td>
<td>
<p><code>Numeric</code> value, minimum duration of the event. This 
is required as the kurtosis routine tends to identify multipe picks in 
the beginning of an event.</p>
</td></tr>
<tr><td><code id="pick_kurtosis_+3A_dur_max">dur_max</code></td>
<td>
<p><code>Numeric</code> value, maximum duration of the event. This
value can be omitted but would increase computational speed as it 
determines the length of samples to look for the amplitude ratio that 
signals the end of an event</p>
</td></tr>
<tr><td><code id="pick_kurtosis_+3A_window_kurt">window_kurt</code></td>
<td>
<p><code>Numeric</code> value, size of the running window (in
number of samples) in which the kurtosis is calculated.</p>
</td></tr>
<tr><td><code id="pick_kurtosis_+3A_window_amp">window_amp</code></td>
<td>
<p><code>Numeric</code> value, size of the running window (in
number of samples) in which the running mean is calculated.</p>
</td></tr>
<tr><td><code id="pick_kurtosis_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector, time vector of the signal(s). If not 
provided, a synthetic time vector will be created.</p>
</td></tr>
<tr><td><code id="pick_kurtosis_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. If omitted, either 
estimated from <code>time</code> or set to 0.01 s (i.e., f = 100 Hz).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further reading: 
</p>
<p>Baillard, C., Crawford, W.C., Ballu, V., Hibert, C., Mangeney, A., 2014. 
An automatic kurtosis-based p- and s-phase picker designed for local 
seismic networks. Bull. Seismol. Soc. Am. 104 (1), 394409.
</p>
<p>Hibert, C., Mangeney, A., Grandjean, G., Baillard, C., Rivet, D., 
Shapiro, N.M., Satriano, C., Maggi, A., Boissier, P., Ferrazzini, V., 
Crawford, W., 2014. Automated identification, location, and volume 
estimation of rockfalls at Piton de la Fournaise Volcano. J. Geophys. 
Res. Earth Surf. 119 (5), 
10821105. http://dx.doi.org/10.1002/2013JF002970.
</p>


<h3>Value</h3>

<p><code>data.frame</code>, picked events.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## preprocess signal (aggregate to increase speed, filter, envelope)
s &lt;- signal_aggregate(data = rockfall_eseis, n = 4)
s &lt;- signal_filter(data = s, f = c(5, 20), lazy = TRUE)
e &lt;- signal_envelope(data = s)

## pick events based on signal kurtosis
p &lt;- eseis::pick_kurtosis(data = e, 
                          window_kurt = 200, 
                          on = 15, 
                          off = 5, 
                          dur_min = 10, 
                          dur_max = 90, 
                          window_amp = 300)

p$picks
                     
</code></pre>

<hr>
<h2 id='pick_stalta'>Calculate stal-lta-ratio.</h2><span id='topic+pick_stalta'></span>

<h3>Description</h3>

<p>The function calculates the ratio of the short-term-average and 
long-term-average of the input signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_stalta(data, time, dt, sta, lta, freeze = FALSE, on, off)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_stalta_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="pick_stalta_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector, time vector of the signal(s). If not 
provided, a synthetic time vector will be created.</p>
</td></tr>
<tr><td><code id="pick_stalta_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. If omitted, either 
estimated from <code>time</code> or set to 0.01 s (i.e., f = 100 Hz).</p>
</td></tr>
<tr><td><code id="pick_stalta_+3A_sta">sta</code></td>
<td>
<p><code>Numeric</code> value, number of samples for short-term window.</p>
</td></tr>
<tr><td><code id="pick_stalta_+3A_lta">lta</code></td>
<td>
<p><code>Numeric</code> value, number of samples for long-term window.</p>
</td></tr>
<tr><td><code id="pick_stalta_+3A_freeze">freeze</code></td>
<td>
<p><code>Logical</code> value, option to freeze lta value at start of 
an event. Useful to avoid self-adjustment of lta for long-duration events.</p>
</td></tr>
<tr><td><code id="pick_stalta_+3A_on">on</code></td>
<td>
<p><code>Numeric</code> value, threshold value for event onset.</p>
</td></tr>
<tr><td><code id="pick_stalta_+3A_off">off</code></td>
<td>
<p><code>Numeric</code> value, threshold value for event end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data frame</code>, detected events (ID, start time, duration in 
seconds, STA-LTA vaue).
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(rockfall)

## filter signal
rockfall_f &lt;- signal_filter(data = rockfall_eseis,
                            f = c(1, 90), 
                            p = 0.05)
                    
## calculate signal envelope
rockfall_e &lt;- signal_envelope(data = rockfall_f)

## pick earthquake and rockfall event
p &lt;- pick_stalta(data = rockfall_e,
                 sta = 100, 
                 lta = 18000, 
                 freeze = TRUE, 
                 on = 5, 
                 off = 3)
                 
p$picks
                     
</code></pre>

<hr>
<h2 id='plot_components'>Plot three seismic components against each other</h2><span id='topic+plot_components'></span>

<h3>Description</h3>

<p>The function visualises the time evolution of three seismic components 
of the same signal against each other as line graphs. There are three 
different visualisation types available: <code>2D</code> (a panel of three 
2D plots), <code>3D</code> (a perspective threedimensional plot) and 
<code>scene</code> (an interactive threedimensional plot, mainly for 
exploratory purpose).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_components(data, type = "2D", order = "xyz", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_components_+3A_data">data</code></td>
<td>
<p><code>List</code>, <code>data frame</code> or <code>matrix</code>, seismic
componenents to be processed. If <code>data</code> is a matrix, the components 
must be organised as columns. Also, <code>data</code> can be a list of 
<code>eseis</code> objects.</p>
</td></tr>
<tr><td><code id="plot_components_+3A_type">type</code></td>
<td>
<p><code>Character</code> value, plot type. One out of <code>"2D"</code> 
(panel of three 2-dimensional plots), <code>"3D"</code> (perspective 3D plot)
and <code>"scene"</code> (interactive 3D plot). Default is <code>"2D"</code>.</p>
</td></tr>
<tr><td><code id="plot_components_+3A_order">order</code></td>
<td>
<p><code>Caracter</code> value, order of the seismic components. 
Describtion must contain the letters <code>"x"</code>,<code>"y"</code> and
<code>"z"</code> in the order according to the input data set. Default is 
<code>"xyz"</code> (NW-SE-vertical).</p>
</td></tr>
<tr><td><code id="plot_components_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot type <code>type = "3D"</code> requires the package <code>plot3D</code> 
being installed. The plot type <code>type = "scene"</code> requires the  
package <code>rgl</code> being installed.
</p>


<h3>Value</h3>

<p>A plot
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(earthquake)

## filter seismic signals
s &lt;- eseis::signal_filter(data = s, 
                          dt = 1/200, 
                          f = c(0.05, 0.1))

## integrate signals to get displacement
s_d &lt;- eseis::signal_integrate(data = s, dt = 1/200)

## plot components in 2D
plot_components(data = s_d, 
                type = "2D")

## plot components with time colour-coded
plot_components(data = s_d, 
                type = "2D",
                col = rainbow(n = length(s$BHE)))

## plot components with used defined coulour ramp
col_user &lt;- colorRampPalette(colors = c("grey20", "darkblue", "blue", 
                                        "green", "red", "orange"))

plot_components(data = s_d, 
                type = "2D",
                col = col_user(n = length(s$BHE)))

## plot components as 3D plot, uncomment to use
#plot_components(data = s_d, 
#                 type = "3D",
#                 col = rainbow(n = length(s$BHE)))
                
</code></pre>

<hr>
<h2 id='plot_ppsd'>Plot a probabilistic power spectral density estimate (PPSD)</h2><span id='topic+plot_ppsd'></span>

<h3>Description</h3>

<p>The function uses the output of <code>signal_spectrogram()</code> to plot a 
probabilistic power spectral density estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ppsd(data, res = c(500, 500), n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ppsd_+3A_data">data</code></td>
<td>
<p><code>List</code> object, spectrogram to be plotted. Must be output
of <code>signal_spectrogram()</code> or of equivalent structure.</p>
</td></tr>
<tr><td><code id="plot_ppsd_+3A_res">res</code></td>
<td>
<p><code>Integer</code> vector of length two, factors of image 
resolution in pixels, i.e. in time and frequency dimension.  
Default is <code>c(100, 100)</code>.</p>
</td></tr>
<tr><td><code id="plot_ppsd_+3A_n">n</code></td>
<td>
<p><code>Integer</code> vector of length two, factors by which the image 
will be smoothend by a running average. <code>n</code> sets the filter window 
size, in x and y direction, respectively. By default, the window sizes 
are set to one percent of the input data set dimension.</p>
</td></tr>
<tr><td><code id="plot_ppsd_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphic output of a spectrogram.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal_spectrogram">signal_spectrogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## deconvolve data set
r &lt;- signal_deconvolve(data = rockfall_eseis)

## calculate PSD
p &lt;- signal_spectrogram(data = r)

## plot PPSD
plot_ppsd(data = p$PSD)

## plot PPSD with lower resolution, more smoothing and other colour
ppsd_color &lt;- colorRampPalette(c("white", "black", "red"))

plot_ppsd(data = p$PSD, 
          res = c(200, 200), 
          n = c(15, 20), 
          col = ppsd_color(200))

</code></pre>

<hr>
<h2 id='plot_signal'>Plot a seismic signal</h2><span id='topic+plot_signal'></span>

<h3>Description</h3>

<p>This function plots a line graph of a seismic signal. To avoid long plot 
preparation times the signal is reduced to a given number of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_signal(data, time, n = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_signal_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object or <code>numeric</code> vector, data set to 
be plotted.</p>
</td></tr>
<tr><td><code id="plot_signal_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector, corresponding time vector.</p>
</td></tr>
<tr><td><code id="plot_signal_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> value, number of values to which the dataset 
is reduced. Default is <code>10000</code>.</p>
</td></tr>
<tr><td><code id="plot_signal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>format</code> argument is based on hints provided by Sebastian 
Kreutzer and Christoph Burow. It allows plotting time axis units in 
user defined formats. The time format must be provided as character string 
using the POSIX standard (see documentation of <code>strptime</code> for a list 
of available keywords), e.g., &quot;
&quot;
</p>


<h3>Value</h3>

<p>A line plot of a seismic wave form.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## plot data set straightforward
plot_signal(data = rockfall_eseis)

## plot data set with lower resolution
plot_signal(data = rockfall_eseis, n = 100)

## plot data set but not as an eseis object
plot_signal(data = rockfall_z, time = rockfall_t)

## load earthquake data set
data(earthquake)

## plot all three components (after changing plot options)
pars &lt;- par(no.readonly = TRUE)
par(mfcol = c(3, 1))

plt &lt;- lapply(s, plot_signal, t = t)

par(pars)

</code></pre>

<hr>
<h2 id='plot_spectrogram'>Plot spectrograms (power spectral density estimates)</h2><span id='topic+plot_spectrogram'></span>

<h3>Description</h3>

<p>This function plots spectrograms of seismic signals. It uses the output 
of <code>signal_spectrogram</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spectrogram(data, legend = TRUE, keep_par = FALSE, agg = c(1, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_spectrogram_+3A_data">data</code></td>
<td>
<p><code>List</code> object, spectrogram to be plotted. Must be output
of <code>signal_spectrogram</code> or of equivalent structure.</p>
</td></tr>
<tr><td><code id="plot_spectrogram_+3A_legend">legend</code></td>
<td>
<p><code>Logical</code> value, option to add colour bar legend. Legend
label can be changed by <code>zlab</code>.</p>
</td></tr>
<tr><td><code id="plot_spectrogram_+3A_keep_par">keep_par</code></td>
<td>
<p><code>Logical</code> value, option to omit resetting plot 
parameters after function execution. Useful for adding further data to the 
PSD plot. Default is <code>FALSE</code> (parameters are reset to original values).</p>
</td></tr>
<tr><td><code id="plot_spectrogram_+3A_agg">agg</code></td>
<td>
<p><code>Integer</code> vector of length two, factors of image 
aggregation, i.e. in time and frequency dimension. Useful to decrease 
image size. Default is <code>c(1, 1)</code> (no aggregation).</p>
</td></tr>
<tr><td><code id="plot_spectrogram_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of version 0.7.2, the value range (<code>zlim</code>) is no longer set to the 
full data range but to the range between quantiles 0.01 and 0.99. For the 
full value range to be plotted, use <code>zlim = range(data$PSD$S)</code>.
</p>
<p>As of version 0.7.2, the default plot colour has changed from the &quot;jet&quot; 
colour palette to the &quot;Inferno&quot; palette. This due to perception issues with 
the &quot;jet&quot; palette. If one wants to decisively use the &quot;jet&quot; colours, this 
can be done by adding the keyword <code>col = "jet"</code>. To use other 
colour schemes, such as sequential HCL schemes from the 
colorspace package, specify them as additional argument, e.g. 
<code>col = colorspace::sequential_hcl(200, palette = "Plasma")</code>,
<code>col = colorspace::sequential_hcl(200, palette = "Inferno")</code>,
<code>col = colorspace::sequential_hcl(200, palette = "Viridis")</code>.
</p>


<h3>Value</h3>

<p>Graphic output of a spectrogram.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal_spectrogram">signal_spectrogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## deconvolve signal
rockfall &lt;- signal_deconvolve(data = rockfall_eseis)

## calculate spectrogram
PSD &lt;- signal_spectrogram(data = rockfall)

## plot spectrogram
plot_spectrogram(data = PSD)

## plot spectrogram with legend and labels in rainbow colours
plot_spectrogram(data = PSD, 
                 xlab = "Time (min)", 
                 ylab = "f (Hz)", 
                 main = "Power spectral density estimate", 
                 legend = TRUE, 
                 zlim = c(-220, -70),
                 col = rainbow(100)) 
                 
## plot spectrogram with frequencies in log scale
plot_spectrogram(data = PSD, log = "y")

## plot spectrogram with formatted time axis (minutes and seconds)
plot_spectrogram(data = PSD, format = "%M:%S")
                     
</code></pre>

<hr>
<h2 id='plot_spectrum'>Plot a spectrum of a seismic signal</h2><span id='topic+plot_spectrum'></span>

<h3>Description</h3>

<p>This function plots a line graph of the spectrum of a seismic signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spectrum(data, unit = "dB", n = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_spectrum_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object or <code>data frame</code> with two elements,
<code>frequency</code> vector and <code>spectrum</code> vector.</p>
</td></tr>
<tr><td><code id="plot_spectrum_+3A_unit">unit</code></td>
<td>
<p><code>Character</code> value. One out of <code>"linear"</code>, 
<code>"log"</code>, <code>"dB"</code>. Default is <code>"dB"</code>.</p>
</td></tr>
<tr><td><code id="plot_spectrum_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> value, number of values to which the dataset 
is reduced. Default is <code>10000</code>.</p>
</td></tr>
<tr><td><code id="plot_spectrum_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line plot.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signal_spectrum">signal_spectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## calculate spectrum
spectrum_rockfall &lt;- signal_spectrum(data = rockfall_eseis)

## plot data set with lower resolution
plot_spectrum(data = spectrum_rockfall)

</code></pre>

<hr>
<h2 id='read_data'>Load seismic data from an archive</h2><span id='topic+read_data'></span>

<h3>Description</h3>

<p>The function loads seismic data from a data directory structure (see 
<code>aux_organisecubefiles</code>) based on the event start time, duration,
component and station ID. The data to be read needs to be adequately 
structured. The data directory must contain mseed or SAC files. These 
files will either be identified automatically or can be defined 
explicitly by the parameter <code>format</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_data(
  start,
  duration,
  station,
  component = "BHZ",
  format,
  dir,
  pattern = "eseis",
  simplify = TRUE,
  interpolate = FALSE,
  eseis = TRUE,
  try = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_data_+3A_start">start</code></td>
<td>
<p><code>POSIXct</code> value, start time of the data to import. If
lazy users only submit a text string instead of a POSIXct object, the 
function will try to convert that text string, assuming UTC as time zone.</p>
</td></tr>
<tr><td><code id="read_data_+3A_duration">duration</code></td>
<td>
<p><code>Numeric</code> value, duration of the data to import,
in seconds.</p>
</td></tr>
<tr><td><code id="read_data_+3A_station">station</code></td>
<td>
<p><code>Character</code> value, seismic station ID, which must
correspond to the ID in the file name of the data directory structure 
(cf. <code>aux_organisecubefiles</code>).</p>
</td></tr>
<tr><td><code id="read_data_+3A_component">component</code></td>
<td>
<p><code>Character</code> value, seismic component, which must
correspond to the component name in the file name of the data directory  
structure (cf. <code>aux_organisecubefiles</code>). Default is 
<code>"BHZ"</code> (vertical component of a sac file).</p>
</td></tr>
<tr><td><code id="read_data_+3A_format">format</code></td>
<td>
<p><code>Character</code> value, seismic data format. One out of 
<code>"sac"</code> and <code>"mseed"</code>. If omitted, the function will try to 
identify the right format automatically.</p>
</td></tr>
<tr><td><code id="read_data_+3A_dir">dir</code></td>
<td>
<p><code>Character</code> value, path to the seismic data directory.
See details for further info on data structure.</p>
</td></tr>
<tr><td><code id="read_data_+3A_pattern">pattern</code></td>
<td>
<p><code>Character</code> value, either keyword or pattern string 
with wildcards, describing the data organisation. Supported keywords are 
<code>"eseis"</code> and <code>"seiscomp"</code>. See details for keyword definition 
and format of pattern strings. Default option is <code>eseis</code>.</p>
</td></tr>
<tr><td><code id="read_data_+3A_simplify">simplify</code></td>
<td>
<p><code>Logical</code> value, option to simplify output
when possible. This basically means that if only data from one station 
is loaded, the list object will have one level less. Default is 
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_data_+3A_interpolate">interpolate</code></td>
<td>
<p><code>Logical</code> value, option to interpolate possible 
gaps in the resulting data stream. If enabled, NA values will be identified 
and linearly interpolated using the function <code>signal_fill</code>. Default 
is <code>FALSE</code>, i.e. NA gaps will remain in the imported data set.</p>
</td></tr>
<tr><td><code id="read_data_+3A_eseis">eseis</code></td>
<td>
<p><code>Logical</code> value, option to read data to an <code>eseis</code>
object (recommended, see documentation of 
<code>aux_initiateeseis</code>), default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="read_data_+3A_try">try</code></td>
<td>
<p><code>Logical</code> value, option to run the function in try-mode, 
i.e., to let it return <code>NA</code> in case an error occurs during data
import. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="read_data_+3A_...">...</code></td>
<td>
<p>Further arguments to describe data structure, only needed for 
pattern type <code>seiscomp</code>. These arguments can be one or more of the 
following: <code>"network"</code>, <code>"type"</code>, <code>"location"</code>. If omitted, 
the function will identify all files in the SeisComP data archive that 
fulfill the criteria. If other than data files (<code>type = "D"</code>) or 
files from another network are in the archive, these may lead to crashes  
of the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data organisation must follow a consistent scheme. The default scheme, 
<code>eseis</code> (Dietze, 2018 ESurf) requires 
hourly files organised in a directory for each Julian Day, and in each  
calendar year. The file name must be entirely composed of 
station ID, 2-digit year, Julian Day, hour, minute, second and 
channel name. Each item must be separated by a full stop, 
e.g. <code>"2013/203/IGB01.13.203.16.00.00.BHZ"</code> for a 
file from 2013, Julian Day 203, from station IGB01, covering one hour from 
<code>"16:00:00 UTC"</code>, and containing the BHZ component. Each Julian Day directory 
can contain files from different components and stations. The respective 
pattern string to describe that file organisation is 
<code>"%Y/%j/%STA.%y.%j.%H.%M.%S.%CMP"</code>. The percent sign indicates  
a wild card, where <code>%Y</code> is the 4-digit year, <code>%j</code> the 3-digit Julian 
Julian Day, <code>%STA</code> the station ID, <code>%y</code> the 2-digit year, 
<code>%H</code> the 2-digit hour, <code>%M</code> the 2-digit minute, <code>%S</code> the 
2-digit second and <code>%CMP</code> the component ID. The files can have a 
further file extension which does not need to be explicitly defined in the 
pattern string. The slashes in the above pattern string define 
subdirectories.
</p>
<p>An alternative organisation scheme is the one used by SeisComP, indicated 
by the keyword <code>"seiscomp"</code> or the pattern string 
<code>"%Y/%NET/%STA/%CMP/%NET.%STA.%LOC.%CMP.%TYP.%Y.%j"</code>. 
The wild card <code>"NET"</code> means the network ID, <code>"LOC"</code> the location 
abbreviation and <code>"TYP"</code> the data type. The other wild cards are as 
defined above. Hence, the SeisComP scheme consists of directories of the 
calendar year, the network to which the data belongs, the station it has 
been recorded by, and the component it belongs to. The files in that 
latter directory must be daily files.
</p>


<h3>Value</h3>

<p>A <code>list</code> object containing either a set of <code>eseis</code>
objects or a data set with the time vector (<code>$time</code>) 
and a list of seismic stations (<code>$station_ID</code>) with their seismic
signals as data frame (<code>$signal</code>). If <code>simplify = TRUE</code> (the 
default option) and only one seismic station is provided, the output  
object containseither just one eseis object or the vectors for 
<code>$time</code> and <code>$signal</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## set seismic data directory
dir_data &lt;- paste0(system.file("extdata", package="eseis"), "/")

## load the z component data from a station
data &lt;- read_data(start = as.POSIXct(x = "2017-04-09 01:20:00", 
                                        tz = "UTC"), 
                      duration = 120,
                      station = "RUEG1",
                      component = "BHZ",
                      dir = dir_data)
## plot signal
plot_signal(data = data)

## load data from two stations
data &lt;- read_data(start = as.POSIXct(x = "2017-04-09 01:20:00", 
                                     tz = "UTC"), 
                  duration = 120,
                  station = c("RUEG1", "RUEG2"),
                  component = "BHZ",
                  dir = dir_data)

## plot both signals
par(mfcol = c(2, 1))
lapply(X = data, FUN = plot_signal)
                     
</code></pre>

<hr>
<h2 id='read_fdsn'>Download and import seismic data from an FDSN service provider</h2><span id='topic+read_fdsn'></span>

<h3>Description</h3>

<p>The function implements download and import of seismic data from FDSN data
providers via the fdsnws-dataselect service (see 
<a href="https://www.fdsn.org/webservices/">https://www.fdsn.org/webservices/</a>). It is basically a wrapper for 
the query approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fdsn(
  start,
  duration,
  station,
  network,
  component = "BHZ",
  url,
  eseis = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fdsn_+3A_start">start</code></td>
<td>
<p><code>POSIXct</code> value, start time of the data to import. If
lazy users only submit a text string instead of a POSIXct object, the 
function will try to convert that text string, assuming UTC as time zone.</p>
</td></tr>
<tr><td><code id="read_fdsn_+3A_duration">duration</code></td>
<td>
<p><code>Numeric</code> value, duration of the data to import,
in seconds.</p>
</td></tr>
<tr><td><code id="read_fdsn_+3A_station">station</code></td>
<td>
<p><code>Character</code> vector, optional 3-4-digit FDSN station ID.</p>
</td></tr>
<tr><td><code id="read_fdsn_+3A_network">network</code></td>
<td>
<p><code>Character</code> vector, optional 2-digit FDSN network ID.</p>
</td></tr>
<tr><td><code id="read_fdsn_+3A_component">component</code></td>
<td>
<p><code>Character</code> vector, seismic component to search for. 
If omitted, the function will look for <code>"BHZ"</code> by default.</p>
</td></tr>
<tr><td><code id="read_fdsn_+3A_url">url</code></td>
<td>
<p><code>Chracter</code> vector, URL of the FDSN data provider. Should be 
of the form <code>"http://service.iris.edu"</code>, i.e., without further URL 
parts. URLs can be submitted as a vector. If omitted, the function will 
look in the two most comprehensive providers, i.e. 
<code>url = c("http://service.iris.edu", "http://eida-federator.ethz.ch")</code>. 
See details for further information.</p>
</td></tr>
<tr><td><code id="read_fdsn_+3A_eseis">eseis</code></td>
<td>
<p><code>Logical</code> value, option to read data to an <code>eseis</code>
object (recommended, see documentation of 
<code>aux_initiateeseis</code>), default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="read_fdsn_+3A_...">...</code></td>
<td>
<p>Additional query arguments sent to the FDSN data provider. See
details for available argument names and conventions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FDSN (International Federation of Digital Seismograph Networks) 
provides access to a large number of seismic stations worldwide. The data 
are organised by network, station, component and further arguments. In 
order to use the eseis function <code>read_fdsn</code>, one must know at least 
the former three criteria for the data of interest. A list of networks is 
available here: <a href="https://www.fdsn.org/networks/">https://www.fdsn.org/networks/</a>. The function expects 
the 2-digit network code, the 3- or 4-digit station code, a single seismic 
component ID, and the URL to the data archive. Additional query arguments 
can be added (and must be added to point at a single seismic trace to 
download and import). A complete list of query arguments is available 
here: <a href="https://www.fdsn.org/webservices/fdsnws-dataselect-1.1.pdf">https://www.fdsn.org/webservices/fdsnws-dataselect-1.1.pdf</a>.
</p>
<p>For each network listed there, one can find the URL that gives access to 
the data (if existing) under &quot;Data Access&quot;. Note that the function only 
requires the first URL part, e.g., <a href="https://geofon.gfz-potsdam.de">https://geofon.gfz-potsdam.de</a>.
</p>


<h3>Value</h3>

<p>An <code>eseis</code> object or a <code>list</code> with the time  
(<code>$time</code>) and <code>$signal</code> vectors as well as meta information.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## read and plot 10 min of data from Ecuador, specifying the component
s &lt;- read_fdsn(start = "2020-05-16 22:42:00",
               duration = 360, 
               station = "IMBA", 
               network = "EC", 
               component = "HHZ")
plot(s)

## read and plot 10 min of data from Germany, specifying the URL
s &lt;- read_fdsn(start = "2017-03-21 04:38:00",
               duration = 360, 
               station = "RGN", 
               network = "GE", 
               url = "http://geofon.gfz-potsdam.de")
plot(s)


## End(Not run)
                     
</code></pre>

<hr>
<h2 id='read_mseed'>Read mseed files.</h2><span id='topic+read_mseed'></span>

<h3>Description</h3>

<p>This function reads mseed files. If <code>append = TRUE</code>, all
files will be appended to the first one in the order as they are provided. 
In the append-case the function returns a either a list with the elements 
<code>signal</code>, <code>time</code>, <code>meta</code> and <code>header</code> or a list of the 
class <code>eseis</code> (see documentation of 
<code>aux_initiateeseis()</code>). If <code>append = FALSE</code> and more than one file 
is provided, the function returns a list of the length of the input files, 
each containing the above elements. <br /><br /> The mseed data format is read 
using the function <code>readMiniseedFile</code> from the 
package <code>IRISSeismic</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_mseed(
  file,
  append = TRUE,
  signal = TRUE,
  time = TRUE,
  meta = TRUE,
  header = TRUE,
  eseis = TRUE,
  type = "waveform"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_mseed_+3A_file">file</code></td>
<td>
<p><code>Character</code> vector, input file name(s), with extension.</p>
</td></tr>
<tr><td><code id="read_mseed_+3A_append">append</code></td>
<td>
<p><code>Logical</code> value, option to append single files to one
continuous file, keeping only the hedaer information of the first file,
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_mseed_+3A_signal">signal</code></td>
<td>
<p><code>Logical</code> value, option to import the signal vector, 
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_mseed_+3A_time">time</code></td>
<td>
<p><code>Logical</code> value, option to create the time vector. The 
timezone is automatically set to <code>"UTC"</code>, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_mseed_+3A_meta">meta</code></td>
<td>
<p><code>Logical</code> value, option to append the meta data part, 
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_mseed_+3A_header">header</code></td>
<td>
<p><code>Logical</code> value, option to append the header part, 
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_mseed_+3A_eseis">eseis</code></td>
<td>
<p><code>Logical</code> value, option to read data to an <code>eseis</code>
object (recommended, see documentation of 
<code>aux_initiateeseis</code>), default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="read_mseed_+3A_type">type</code></td>
<td>
<p><code>Character</code> value, type keyword of the data. One out of 
<code>"waveform"</code>, <code>"envelope"</code>, <code>"fft"</code>, <code>"spectrum"</code>, 
<code>"spectrogram"</code>, <code>"other"</code>, <code>hilbert</code>, <code>hvratio</code>. 
Default is <code>"waveform"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>List</code> object, optionally of class <code>eseis</code>
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## read mseed file with default options
x &lt;- read_mseed(file = "input.miniseed")

## read mseed file, only signal trace, not as eseis object
x &lt;- read_mseed(file = "input.miniseed", 
                time = FALSE, 
                meta = FALSE, 
                header = FALSE, 
                eseis = FALSE)
                
## read more than one mseed files and append traces
x &lt;- read_mseed(file = c("input_1.miniseed", "input_2.miniseed"))

## End(Not run)

</code></pre>

<hr>
<h2 id='read_sac'>Read sac files.</h2><span id='topic+read_sac'></span>

<h3>Description</h3>

<p>This function reads sac files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_sac(
  file,
  append = TRUE,
  signal = TRUE,
  time = TRUE,
  meta = TRUE,
  header = TRUE,
  eseis = TRUE,
  get_instrumentdata = FALSE,
  endianness = "little",
  biglong = FALSE,
  type = "waveform"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_sac_+3A_file">file</code></td>
<td>
<p><code>Character</code> vector, input file name(s), with extension.</p>
</td></tr>
<tr><td><code id="read_sac_+3A_append">append</code></td>
<td>
<p><code>Logical</code> value, option append single files to one
continuous file, keeping only the header information of the first file,
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_sac_+3A_signal">signal</code></td>
<td>
<p><code>Logical</code> value, option to import the signal vector, 
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_sac_+3A_time">time</code></td>
<td>
<p><code>Logical</code> value, option to create the time vector. The 
timezone is automatically set to <code>"UTC"</code>, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_sac_+3A_meta">meta</code></td>
<td>
<p><code>Logical</code> value, option to append the meta data part, 
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_sac_+3A_header">header</code></td>
<td>
<p><code>Logical</code> value, option to append the header part, 
default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_sac_+3A_eseis">eseis</code></td>
<td>
<p><code>Logical</code> value, option to read data to an <code>eseis</code>
object (recommended, see documentation of 
<code>aux_initiateeseis</code>), default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="read_sac_+3A_get_instrumentdata">get_instrumentdata</code></td>
<td>
<p><code>Logical</code> value, option to fill meta 
information (sensor name, logger name, logger gain) from SAC user fields 
(field 127-129, KUSER0-KUSER2). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="read_sac_+3A_endianness">endianness</code></td>
<td>
<p><code>Logical</code> value, endianness of the sac file. One
out of <code>"little"</code>, <code>"big"</code> and <code>"swap"</code>. Default 
is <code>"little"</code>.</p>
</td></tr>
<tr><td><code id="read_sac_+3A_biglong">biglong</code></td>
<td>
<p><code>Logical</code> value, number coding format. Default 
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="read_sac_+3A_type">type</code></td>
<td>
<p><code>Character</code> value, type keyword of the data. One out of 
<code>"waveform"</code>, <code>"envelope"</code>, <code>"fft"</code>, <code>"spectrum"</code>, 
<code>"spectrogram"</code>, <code>"other"</code>, <code>hilbert</code>, <code>hvratio</code>. 
Default is <code>"waveform"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads one or more sac-files. If <code>append = TRUE</code>, all
files will be appended to the first one in the order as they are provided. 
In the append-case the function returns a either a list with the elements 
<code>signal</code>, <code>time</code>, <code>meta</code> and <code>header</code> or a list of the 
class <code>eseis</code> (see documentation of 
<code>aux_initiateeseis</code>). If <code>append = FALSE</code> and more than one file 
is provided, the function returns a list of the length of the input files, 
each containing the above elements. <br /><br /> The sac data format is 
implemented as descibed on the IRIS website 
(https://ds.iris.edu/files/sac-manual/manual/file_format.html).
</p>


<h3>Value</h3>

<p><code>List</code> object, optionally of class <code>eseis</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## read one file
file1 &lt;- "~/Data/sac/EXMP01.14.213.01.00.00.BHE.SAC"

sac1 &lt;- read_sac(file = file1)

## read two (or more files) without meta and header parts
file2 &lt;- c("~/Data/sac/EXMP01.14.213.01.00.00.BHE.SAC",
           "~/Data/sac/EXMP01.14.213.02.00.00.BHE.SAC")

sac2 &lt;- read_sac(file = file2, 
                 meta = FALSE, 
                 header = FALSE,
                 eseis = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='rockfall'>Seismic trace of a rockfall event.</h2><span id='topic+rockfall'></span><span id='topic+rockfall_z'></span><span id='topic+rockfall_t'></span><span id='topic+rockfall_eseis'></span>

<h3>Description</h3>

<p>The dataset comprises the seismic signal (vertical component) of 
a rockfall event, preceeded by an earthquake. The data have been
recorded at 200 Hz sampling frequency with an Omnirecs Cube ext 3
data logger.
</p>
<p>The dataset comprises the time vector corresponding the to seismic signal
of the rockfall event from the example data set &quot;rockfall&quot;.
</p>
<p>The dataset comprises the seismic signal (vertical component) of 
a rockfall event, preceeded by an earthquake. The data have been
recorded at 200 Hz sampling frequency with an Omnirecs Cube ext 3
data logger.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rockfall_z

rockfall_t

rockfall_eseis
</code></pre>


<h3>Format</h3>

<p>The format is: num [1:98400] 65158 65176 65206 65194 65155 ...
</p>
<p>The format is: POSIXct[1:98400], format: &quot;2015-04-06 13:16:54&quot; ...
</p>
<p>List of 4
$ signal : num [1:98399] 65211 65192 65158 65176 65206 ...
$ meta   :List of 12
..$ station  : chr &quot;789     &quot;
..$ network  : chr &quot;XX      &quot;
..$ component: chr &quot;p0      &quot;
..$ n        : int 98399
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## plot signal vector using base functionality
plot(x = rockfall_t, y = rockfall_z, type = "l")

## plot signal vector using the package plot function
plot_signal(data = rockfall_z, time = rockfall_t)


## load example data set
data(rockfall)


## load example data set
data(rockfall)

</code></pre>

<hr>
<h2 id='signal_aggregate'>Aggregate a signal vector</h2><span id='topic+signal_aggregate'></span>

<h3>Description</h3>

<p>The signal vector <code>data</code> is aggregated by an integer factor <code>n</code>.
If an <code>eseis</code> object is provided, the meta data is updated. The 
function is a wrapper for the funcion <code>decimate</code> of the package
<code>signal</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_aggregate(data, n = 2, type = "iir")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_aggregate_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_aggregate_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> value, number of samples to be aggregated to one
new data value. Must be an integer value greater than 1. Default is 
<code>2</code>.</p>
</td></tr>
<tr><td><code id="signal_aggregate_+3A_type">type</code></td>
<td>
<p><code>Character</code> value, filter type used for aggregation. For 
details see documentation of <code>signal::decimate</code>. Default is 
<code>"iir"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Aggregated data set.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## aggregate signal by factor 4 (i.e., dt goes from 1/200 to 1/50)
rockfall_agg &lt;- signal_aggregate(data = rockfall_z, 
                                 n = 4)

## create example data set
s &lt;- 1:10
  
## aggregate x by factor 2
s_agg_2 &lt;- signal_aggregate(data = s,
                            n = 2)
                              
## aggregate x by factor 3
s_agg_3 &lt;- signal_aggregate(data = s, 
                            n = 3)
                              
## plot results
plot(x = s,
     y = rep(x = 1, times = length(s)),
     ylim = c(1, 3))
     
points(x = s_agg_2, 
       y = rep(x = 2, times = length(s_agg_2)), 
       col = 2)

points(x = s_agg_3, 
       y = rep(x = 3, times = length(s_agg_3)), 
       col = 3)
       
abline(v = s_agg_2,
       col = 2)

abline(v = s_agg_3, 
       col = 3)
       
## create signal matrix
X &lt;- rbind(1:100, 1001:1100, 10001:10100)

## aggregate signal matrix by factor 4
X_agg &lt;- signal_aggregate(data = X, 
n = 4)

</code></pre>

<hr>
<h2 id='signal_clip'>Clip signal based on time vector.</h2><span id='topic+signal_clip'></span>

<h3>Description</h3>

<p>The function clips a seismic signal based on the corresponding time vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_clip(data, time, limits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_clip_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_clip_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector, corresponding time vector. Only needed 
if <code>data</code> is no <code>eseis</code> object.</p>
</td></tr>
<tr><td><code id="signal_clip_+3A_limits">limits</code></td>
<td>
<p><code>POSIXct</code> vector of length two, time limits for 
clipping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> data set clipped to provided time interval.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(rockfall)

## define limits (second 10 to 20 of the signal)
limits &lt;- c(rockfall_t[1] + 10, rockfall_t[1] + 20)

## clip signal 
rockfall_clip &lt;- signal_clip(data = rockfall_z, 
                             time = rockfall_t, 
                             limits = limits)
                     
## clip signal using the eseis object
rockfall_clip &lt;- signal_clip(data = rockfall_eseis, 
                             limits = limits)
                             
</code></pre>

<hr>
<h2 id='signal_cut'>Cut signal amplitude at standard deviation-defined level.</h2><span id='topic+signal_cut'></span>

<h3>Description</h3>

<p>This function cuts the amplitude of signal parts that exceede a user 
defined threshold set by k times the standard deviation of the signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_cut(data, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_cut_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_cut_+3A_k">k</code></td>
<td>
<p><code>Numeric</code> value, multiplier of the standard deviation
threshold used to cut the signal amplitude. Default is <code>1</code> (1 sd).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, cut signal.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(rockfall)

## cut signal
rockfall_cut &lt;- signal_cut(data = rockfall_eseis)

</code></pre>

<hr>
<h2 id='signal_deconvolve'>Deconvolve a signal vector.</h2><span id='topic+signal_deconvolve'></span>

<h3>Description</h3>

<p>The function removes the instrument response from a signal vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_deconvolve(
  data,
  sensor = "TC120s",
  logger = "Cube3BOB",
  gain = 1,
  use_metadata = FALSE,
  dt,
  p = 10^-6,
  waterlevel = 10^-6,
  na.replace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_deconvolve_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_deconvolve_+3A_sensor">sensor</code></td>
<td>
<p><code>Character</code> value or <code>list</code> object, 
seismic sensor name. Must be present in the sensor library 
(<code>list_sensor</code>) or parameters must be added manually (see 
examples). Default is <code>"TC120s"</code>.</p>
</td></tr>
<tr><td><code id="signal_deconvolve_+3A_logger">logger</code></td>
<td>
<p><code>Character</code> value, seismic logger name. Must be 
present in the logger library (<code>list_logger</code>) or parameters must be
added manually. Default is <code>"Cube3extBOB"</code>.</p>
</td></tr>
<tr><td><code id="signal_deconvolve_+3A_gain">gain</code></td>
<td>
<p><code>Numeric</code> value, signal gain level of the logger. Default 
is <code>1</code>.</p>
</td></tr>
<tr><td><code id="signal_deconvolve_+3A_use_metadata">use_metadata</code></td>
<td>
<p><code>Logical</code> value, option to take keywords for 
<code>sensor</code>, <code>logger</code> and <code>gain</code> from eseis object meta data
element instead of using explicitly provided arguments. Default is 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="signal_deconvolve_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling rate. Only needed if <code>data</code> 
is not an <code>eseis</code> object</p>
</td></tr>
<tr><td><code id="signal_deconvolve_+3A_p">p</code></td>
<td>
<p><code>Numeric</code> value, proportion of signal to be tapered. Default
is<code>10^-6</code>.</p>
</td></tr>
<tr><td><code id="signal_deconvolve_+3A_waterlevel">waterlevel</code></td>
<td>
<p><code>Numeric</code> value, waterlevel value for frequency
division, default is <code>10^-6</code>.</p>
</td></tr>
<tr><td><code id="signal_deconvolve_+3A_na.replace">na.replace</code></td>
<td>
<p><code>Logical</code> value, option to replace NA values in the 
data set by zeros. Default is <code>FALSE</code>. Attention, the zeros will 
create artifacts in the deconvolved data set. However, <code>NA</code> values will 
result in no deconvolution at all.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires a set of input parameters, apart from the signal 
vector. These parameters are contained in and read from the function 
<code>list_sensor()</code> and <code>list_logger()</code>. Poles and zeros are used 
to build the transfer function. The value s is the generator constant in 
Vs/m. The value k is the normalisation factor. AD is the analogue-digital 
conversion factor. If the signal was recorded with a gain value other than 
1, the resulting signal needs to be corrected for this, as well.
</p>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, deconvolved signal.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## deconvolve signal with minimum effort
rockfall_decon &lt;- signal_deconvolve(data = rockfall_eseis)

## plot time series
plot_signal(data = rockfall_decon, 
     main = "Rockfall, deconvolved signal", 
     ylab = "m/s")
 
## add new logger manually
logger_new &lt;- list_logger()[[1]]

## add logger data
logger_new$ID &lt;- "logger_new"
logger_new$name &lt;- "logger_new"
logger_new$AD &lt;- 2.4414e-07

## deconvolve signal with new logger
rockfall_decon &lt;- signal_deconvolve(data = rockfall_eseis,
                                    sensor = "TC120s", 
                                    logger = logger_new)
                                    
## Change the setup of a logger, here: Centaur AD is changed due to 
## other than default Vpp value, according to AD = V / (2^24).

## extract default Centaur logger
Centaur_10V &lt;- list_logger()[[2]]

## replace AD value
Centaur_10V$AD &lt;- 20/(2^24)
                                    
</code></pre>

<hr>
<h2 id='signal_demean'>Remove mean of signal vector.</h2><span id='topic+signal_demean'></span>

<h3>Description</h3>

<p>The function removes the mean from a signal vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_demean(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_demean_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, data set with mean 
subtracted.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## remove mean from data set
rockfall_demean &lt;- signal_demean(data = rockfall_eseis)

## compare data ranges
range(rockfall_eseis$signal)
range(rockfall_demean$signal)

## show mean of initial signal
mean(rockfall_eseis$signal)
                     
</code></pre>

<hr>
<h2 id='signal_detrend'>Detrend a signal vector.</h2><span id='topic+signal_detrend'></span>

<h3>Description</h3>

<p>The function removes a trend from a signal vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_detrend(data, method = "linear")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_detrend_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_detrend_+3A_method">method</code></td>
<td>
<p><code>Character</code> value, method used for detrending. 
One out of <code>"simple"</code> and <code>"linear"</code>. Default is 
<code>"linear"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method <code>"simple"</code> subtracts a linear trend built from 
the first and last sample of the data set. The method <code>"linear"</code> 
uses the linear function as implemented in pracma::detrend.
</p>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, detrended data set.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## remove linear trend from data set
rockfall_detrend &lt;- signal_detrend(data = rockfall_eseis)

## compare data ranges
range(rockfall_eseis$signal)
range(rockfall_detrend$signal)
                     
</code></pre>

<hr>
<h2 id='signal_envelope'>Calculate signal envelope.</h2><span id='topic+signal_envelope'></span>

<h3>Description</h3>

<p>The function calculates envelopes of the input signals as 
cosine-tapered envelope of the Hilbert-transformed signal. The signal
should be detrended and/or the mean should be removed before processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_envelope(data, p = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_envelope_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_envelope_+3A_p">p</code></td>
<td>
<p><code>Numeric</code> value, proportion of the signal to be tapered,
default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, signal envelope.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## detrend data set
rockfall_detrend &lt;- signal_detrend(data = rockfall_eseis)

## calculate envelope
rockfall_envelope &lt;- signal_envelope(data = rockfall_detrend)

## plot envelope
plot_signal(data = rockfall_envelope)
                     
</code></pre>

<hr>
<h2 id='signal_fill'>Fill NA-gaps of a signal</h2><span id='topic+signal_fill'></span>

<h3>Description</h3>

<p>This function performs linear interpolation of NA values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_fill(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_fill_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, numeric vector or list of objects, 
data set to be processed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the procedure will contaminate the signal by artefacts as 
increasingly larger data gaps are filled with interpolated values.
</p>


<h3>Value</h3>

<p><code>eseis</code> object, numeric vector or list of objects, 
interpolated data set(s).
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create synthetic data set and add NA-gaps
x &lt;- eseis::signal_detrend(data = runif(1000))
x_gap &lt;- x
x_gap[100:102] &lt;- NA
x_gap[500:530] &lt;- NA

## fill gaps
y &lt;- signal_fill(data = x_gap)

## filter both data sets
x &lt;- signal_filter(data = x, f = c(1, 3), dt = 1/200)
y &lt;- signal_filter(data = y, f = c(1, 3), dt = 1/200)

## plot both data sets
plot(y, type = "l", col = "grey", lwd = 3)
lines(x, col = "red")

</code></pre>

<hr>
<h2 id='signal_filter'>Filter a seismic signal in the time or frequency domain</h2><span id='topic+signal_filter'></span>

<h3>Description</h3>

<p>The function filters the input signal vector in the time or
frequency domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_filter(
  data,
  f,
  fft = FALSE,
  dt,
  type,
  shape = "butter",
  order = 2,
  p,
  zero = FALSE,
  lazy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_filter_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_filter_+3A_f">f</code></td>
<td>
<p><code>Numeric</code> value or vector of length two, lower and/or 
upper cutoff frequencies (Hz).</p>
</td></tr>
<tr><td><code id="signal_filter_+3A_fft">fft</code></td>
<td>
<p><code>Logical</code> value, option to filter in the time domain 
(<code>fft = FALSE</code>) or the frequency domain (<code>fft = TRUE</code>). Default 
is (<code>fft = FALSE</code>).</p>
</td></tr>
<tr><td><code id="signal_filter_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling rate If omitted, <code>dt</code> 
is set to 1/200.</p>
</td></tr>
<tr><td><code id="signal_filter_+3A_type">type</code></td>
<td>
<p><code>Character</code> value, type of filter, one out of 
<code>"LP"</code> (low pass), <code>"HP"</code> (high pass), <code>"BP"</code> (band 
pass) and <code>"BR"</code> (band rejection). If omitted, the type is interpreted 
from <code>f</code>. If <code>f</code> is of length two, <code>type</code> is set to 
<code>"BP"</code>. If <code>f</code> is of length one, <code>type</code> is set to 
<code>"HP"</code>.</p>
</td></tr>
<tr><td><code id="signal_filter_+3A_shape">shape</code></td>
<td>
<p><code>Character</code> value, one out of <code>"butter"</code> 
(Butterworth), default is <code>"butter"</code>.</p>
</td></tr>
<tr><td><code id="signal_filter_+3A_order">order</code></td>
<td>
<p><code>Numeric</code> value, order of the filter, default 
is <code>2</code>. Only needed if <code>data</code> is no <code>eseis</code> object.</p>
</td></tr>
<tr><td><code id="signal_filter_+3A_p">p</code></td>
<td>
<p><code>Numeric</code> value, fraction of the signal to be tapered. If 
omitted, no tapering will be done.</p>
</td></tr>
<tr><td><code id="signal_filter_+3A_zero">zero</code></td>
<td>
<p><code>Logical</code> value, option to run filter in zero phase 
shift mode. Note that this will triple the length of the signal vector 
during calculation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="signal_filter_+3A_lazy">lazy</code></td>
<td>
<p><code>Logical</code> value, option to pre- and post-process data, 
including detrending, demeaning and tapering (<code>p = 0.02</code>). Default 
if <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, filtered signal vector.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## filter data set by bandpass filter between 1 and 90 Hz
rockfall_bp &lt;- signal_filter(data = rockfall_eseis, 
                             f = c(1, 90))
                             
## taper signal to account for edge effects
rockfall_bp &lt;- signal_taper(data = rockfall_bp, 
                            n = 2000)

## plot filtered signal
plot_signal(data = rockfall_bp)

## compare time domain versus frequency domain filtering
rockfall_td &lt;- signal_filter(data = rockfall_eseis, 
                             f = c(10, 40), 
                             fft = FALSE)
                             
rockfall_td_sp &lt;- signal_spectrum(data = rockfall_td)

rockfall_fd &lt;- signal_filter(data = rockfall_eseis, 
                             f = c(10, 40), 
                             fft = TRUE)
                             
rockfall_fd_sp &lt;- signal_spectrum(data = rockfall_fd)

plot_spectrum(data = rockfall_td_sp)
plot_spectrum(data = rockfall_fd_sp)
                     
</code></pre>

<hr>
<h2 id='signal_hilbert'>Calculate Hilbert transform.</h2><span id='topic+signal_hilbert'></span>

<h3>Description</h3>

<p>The function calculates the Hilbert transform of the input signal vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_hilbert(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_hilbert_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, Hilbert transform.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(rockfall)

## calculate hilbert transform
rockfall_h &lt;- signal_hilbert(data = rockfall_eseis)

</code></pre>

<hr>
<h2 id='signal_hvratio'>Calculate h-v-ratio of seismic components</h2><span id='topic+signal_hvratio'></span>

<h3>Description</h3>

<p>This function uses three components of a seismic signal, evaluates 
their spectra and builds the ratio of horizontal to vertical power. 
For details see http://www.geopsy.org/documentation/geopsy/hv.html.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_hvratio(
  data,
  dt,
  log = FALSE,
  method = "periodogram",
  kernel,
  order = "xyz"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_hvratio_+3A_data">data</code></td>
<td>
<p><code>List</code>, <code>data frame</code> or <code>matrix</code>, seismic
componenents to be processed. If <code>data</code> is a matrix, the components 
must be organised as columns. Also, <code>data</code> can be a list of 
<code>eseis</code> objects.</p>
</td></tr>
<tr><td><code id="signal_hvratio_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period.</p>
</td></tr>
<tr><td><code id="signal_hvratio_+3A_log">log</code></td>
<td>
<p><code>Logical</code> value, unit of spectral power. If set to 
<code>TRUE</code> power will be used in dB, if set to <code>FALSE</code>, power 
is used in amplitude squared. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="signal_hvratio_+3A_method">method</code></td>
<td>
<p><code>Character</code> value, method for calculating the spectra. 
One out of <code>"periodogram"</code> , <code>"autoregressive"</code> and 
<code>"multitaper"</code>, default is <code>"periodogram"</code>.</p>
</td></tr>
<tr><td><code id="signal_hvratio_+3A_kernel">kernel</code></td>
<td>
<p><code>Numeric</code> value, window size (number of samples) of 
the moving window used for smoothing the spectra. By default no smoothing 
is performed.</p>
</td></tr>
<tr><td><code id="signal_hvratio_+3A_order">order</code></td>
<td>
<p><code>Character</code> value, order of the seismic components. 
Describtion must contain the letters <code>"x"</code>,<code>"y"</code> and
<code>"z"</code> in the order according to the input data set. Default is 
<code>"xyz"</code> (EW-SN-vertical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spectra should be smoothed. This can either be done directly 
during their calculation or before the calculation of the ratio. For 
the former case set <code>method = "autoregressive"</code>. For the latter 
case provide a value for <code>"kernel"</code>, which is the smoothing 
window size. Smoothing is performed with the logarithms of the spectral 
power data, using <code>caTools::runmean()</code> with the 
<code>endrule = "NA"</code>. After smoothing the data is re-linearised.
</p>


<h3>Value</h3>

<p>A <code>data frame</code> with the h-v-frequency ratio.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data set
data(earthquake)

## ATTENTION, THIS EXAMPLE DATA SET IS FAR FROM IDEAL FOR THIS PURPOSE

## detrend data
s &lt;- signal_detrend(data = s)

## calculate h-v-ratio, will be very rugged
hv &lt;- signal_hvratio(data = s, 
                     dt = 1 / 200)
plot(hv$ratio, 
     type = "l")

## calculate h-v-ratio using the autogressive spectrum method
hv &lt;- signal_hvratio(data = s, 
                     dt = 1 / 200, 
                     method = "autoregressive")
plot(hv, type = "l")

## calculate h-v-ratio with a smoothing window equivalent to dt
hv &lt;- signal_hvratio(data = s, 
                     dt = 1 / 200,
                     kernel = 200)
plot(hv, type = "l")

</code></pre>

<hr>
<h2 id='signal_integrate'>Integrate a seismic signal</h2><span id='topic+signal_integrate'></span>

<h3>Description</h3>

<p>The function integrates a signal vector to convert values from velocity to 
displacement. Two methods are available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_integrate(data, dt, method = "fft", waterlevel = 10^-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_integrate_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_integrate_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> scalar, sampling rate.</p>
</td></tr>
<tr><td><code id="signal_integrate_+3A_method">method</code></td>
<td>
<p><code>Character</code> scalar, method used for integration. One out 
of <code>"fft"</code> (convert in the frequency domain) and <code>"trapezoid"</code> 
(integrate using the trapezoidal rule). Default is <code>"fft"</code>.</p>
</td></tr>
<tr><td><code id="signal_integrate_+3A_waterlevel">waterlevel</code></td>
<td>
<p><code>Numeric</code> scalar, waterlevel value for frequency
division, default is <code>10^-6</code>. Only used when <code>method = "fft"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, integrated signal.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## deconvolve signal
rockfall_decon &lt;- signal_deconvolve(data = rockfall_eseis)
                                    
## integrate signal
rockfall_int &lt;- signal_integrate(data = rockfall_decon)
                                 
## Note that usually the signal should be filtered prior to integration.
                     
</code></pre>

<hr>
<h2 id='signal_motion'>Calculate particle motion parameters</h2><span id='topic+signal_motion'></span>

<h3>Description</h3>

<p>The function calculates from a data set of three seismic 
components of the same signal the following particle motion 
paramters using a moving window approach: horizontal-vertical 
eigenvalue ratio, azimuth and inclination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_motion(data, time, dt, window, step, order = "xyz")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_motion_+3A_data">data</code></td>
<td>
<p><code>List</code> of eseis objects or <code>matrix</code>, seismic
components to be processed. If <code>data</code> is a matrix, the components 
must be organised as columns.</p>
</td></tr>
<tr><td><code id="signal_motion_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector, time vector corresponding to the 
seismic signal components. If omitted, a synthetic time vector will 
be generated. If omitted, the sampling period (<code>dt</code>) must be 
provided or is taken from the first eseis object in the <code>data</code> list.</p>
</td></tr>
<tr><td><code id="signal_motion_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. Only needed if 
<code>time</code> is omitted or if <code>data</code> is no <code>eseis</code> object.</p>
</td></tr>
<tr><td><code id="signal_motion_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> value, time window length (given as 
number of samples) used to calculate the particle motion parameters. 
If value is even, it will be set to the next smaller odd value. If 
omitted, the window size is set to 1 percent of the time series length by
default.</p>
</td></tr>
<tr><td><code id="signal_motion_+3A_step">step</code></td>
<td>
<p><code>Numeric</code> value, step size (given as number of samples), 
by which the window is shifted over the data set. If omitted, the step 
size is set to 50 percent of the window size by default.</p>
</td></tr>
<tr><td><code id="signal_motion_+3A_order">order</code></td>
<td>
<p><code>Character</code> value, order of the seismic components. 
Description must contain the letters <code>"x"</code>,<code>"y"</code> and
<code>"z"</code> in the order according to the input data set. Default is 
<code>"xyz"</code> (EW-NS-vertical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function code is loosely based on the function GAZI() from 
the package RSEIS with removal of unnecessary content and updated 
or rewritten loop functionality. In its current form, it also uses 
additional workflows from obspy.signal.polarisation, specifically 
following the Flinn (1965) approach. It windows the input signals,
calculates the covariance matrix and performs a singular values 
decomposition to use the eigen values and vectors to determine the 
ratios corresponding to the output values rectilinearity, angularity,
azimuth and incidence. 
</p>
<p>Note that the names of the output objects as well as the calculation 
routine have changed from the earlier version (V. 0.6.0), to increase 
computational efficiency and fix a bug in the windowing implementation.
</p>


<h3>Value</h3>

<p>A List object with rectilinearity (<code>rectilinearity</code>),  
angularity (<code>polarity</code>), azimuth (<code>azimuth</code>) and incidence 
(<code>incidence</code>), as well as the corresponding time vector for 
these values.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example data set
data(earthquake)

## filter seismic signals
s &lt;- eseis::signal_filter(data = s, 
                          dt = 1/200, 
                          f = c(1, 3))

## convert list of signal vectors to column-wise matrix
s &lt;- do.call(cbind, s)

## calculate particle motion parameters
pm &lt;- signal_motion(data = s, 
                    dt = 1 / 200,
                    window = 500, 
                    step = 250)
                    
## plot function output
par_original &lt;- par(no.readonly = TRUE)
par(mfcol = c(2, 2))

plot(pm$time, pm$rect, type = "b")
plot(pm$time, pm$plan, type = "b")
plot(pm$time, pm$azimuth, type = "b")
plot(pm$time, pm$incidence, type = "b")

par(par_original)

</code></pre>

<hr>
<h2 id='signal_pad'>Pad signal with zeros.</h2><span id='topic+signal_pad'></span>

<h3>Description</h3>

<p>The function adds zeros to the input vector to reach a length,
corresponding to the next higher power of two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_pad(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_pad_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, signal vector with 
added zeros.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## pad with zeros
rockfall_pad &lt;- signal_pad(data = rockfall_eseis)

## compare lengths
rockfall_eseis$meta$n
rockfall_pad$meta$n
                     
</code></pre>

<hr>
<h2 id='signal_rotate'>Rotate signal vectors using a 3-D rotation matrix.</h2><span id='topic+signal_rotate'></span>

<h3>Description</h3>

<p>The function rotates the horizontal components of the input data according 
to the specified angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_rotate(data, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_rotate_+3A_data">data</code></td>
<td>
<p><code>List</code>, <code>data frame</code> or <code>matrix</code>, seismic
componenents to be processed. If <code>data</code> is a matrix, the components 
must be organised as rows. Also, <code>data</code> can be a list of 
<code>eseis</code> objects. If a matrix, this matrix must contain either two 
columns (x- and y-component) or three columns (x-, y-, and z-component), 
in exactly that order of the components.</p>
</td></tr>
<tr><td><code id="signal_rotate_+3A_angle">angle</code></td>
<td>
<p><code>Numeric</code> value, rotation angle in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> matrix, the 3-dimensional rotation matrix.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create synthetic data set
data &lt;- rbind(x = sin(seq(0, pi, length.out = 10)),
y = sin(seq(0, pi, length.out = 10)),
z = rep(0, 10))

## rotate the data set
x_rot &lt;- signal_rotate(data = data, 
                       angle = 15)
                      
## plot the rotated data set 
plot(x_rot[1,], col = 1, ylim = c(-2, 2))
points(x_rot[2,], col = 2)
points(x_rot[3,], col = 3)

</code></pre>

<hr>
<h2 id='signal_sign'>Convert amplitude signal to one bit signed signal</h2><span id='topic+signal_sign'></span>

<h3>Description</h3>

<p>This function assigns 1 for positive values and -1 for negative input
values of a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_sign(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_sign_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector or list of vectors, sign-cut signal.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(rockfall)

## sign-cut signal
rockfall_sign &lt;- signal_sign(data = rockfall_eseis)

</code></pre>

<hr>
<h2 id='signal_snr'>Calculate signal-to-noise-ratio.</h2><span id='topic+signal_snr'></span>

<h3>Description</h3>

<p>The function calculates the signal-to-noise ratio of an input signal 
vector as the ratio between mean and max.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_snr(data, detrend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_snr_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_snr_+3A_detrend">detrend</code></td>
<td>
<p><code>Logical</code> value, optionally detrend data set before
calcualting snr.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> value, signal-to-noise ratio.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## calculate snr with detrend option off and on
snr &lt;- signal_snr(data = rockfall_eseis)
print(snr$snr)

snr &lt;- signal_snr(data = rockfall_eseis, 
                  detrend = TRUE)
print(snr$snr)
                     
</code></pre>

<hr>
<h2 id='signal_spectrogram'>Calculate spectrograms (power spectral density estimates) from time series.</h2><span id='topic+signal_spectrogram'></span>

<h3>Description</h3>

<p>This function creates spectrograms from seismic signals. It supports the
standard spectrogram approach and the Welch method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_spectrogram(
  data,
  time,
  dt,
  Welch = FALSE,
  window,
  overlap = 0.5,
  window_sub,
  overlap_sub = 0.5,
  method = "periodogram",
  cpu = NULL,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_spectrogram_+3A_data">data</code></td>
<td>
<p><code>Numeric</code> vector or list of vectors, seismic signal to 
be processed.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_time">time</code></td>
<td>
<p><code>POSIX.ct</code> vector with time values. If omitted, an 
artificial time vector will be created, based on <code>dt</code>. Only needed 
if <code>data</code> is no <code>eseis</code> object.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. If omitted, either 
estimated from <code>time</code> or set to 0.01 s (i.e., f = 100 Hz). Only needed 
if <code>data</code> is no <code>eseis</code> object.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_welch">Welch</code></td>
<td>
<p><code>Logical</code> value, option to use the Welch method for
calculations.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> value, time window length in seconds used to 
calculate individual spectra. Set to 1 percent of the time series length 
by default.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_overlap">overlap</code></td>
<td>
<p><code>Numeric</code> value, fraction of window overlap.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_window_sub">window_sub</code></td>
<td>
<p><code>Numeric</code> value, length of the sub-window in seconds 
used to calculate spectra. Only relevant if <code>Welch = TRUE</code>. If omitted, 
the sub-window length is set to 10 percent of the main window length.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_overlap_sub">overlap_sub</code></td>
<td>
<p><code>Numeric</code> value, fraction of sub-window overlap.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_method">method</code></td>
<td>
<p><code>Character</code> value, method to calculate the spectra. 
One out of <code>"periodogram"</code> and <code>"autoregressive"</code>. 
Default is <code>"periodogram"</code>.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_cpu">cpu</code></td>
<td>
<p><code>Numeric</code> value between 0 and 1, fraction of CPU cores to 
use. If omitted, only one CPU is used.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> value, toggle plot output. Default is
<code>FALSE</code>. For more customised plotting see <code>plot_spectrogram</code>.</p>
</td></tr>
<tr><td><code id="signal_spectrogram_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data containing <code>NA</code> values is replaced by zeros and set to NA in the 
output data set.
</p>


<h3>Value</h3>

<p><code>List</code> with spectrogram matrix, time and frequency vectors.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data("earthquake")

## calculate and plot PSD straight away
P &lt;- signal_spectrogram(data = s$BHZ, 
                               time = t, 
                               dt = 1 / 200, 
                               plot = TRUE)

## calculate and plot PSD with defined window sizes and the Welch method
P &lt;- signal_spectrogram(data = s$BHZ, 
                               time = t, 
                               dt = 1 / 200, 
                               window = 5, 
                               overlap = 0.9, 
                               window_sub = 3, 
                               overlap_sub = 0.9, 
                               Welch = TRUE,
                               plot = TRUE)
                      
</code></pre>

<hr>
<h2 id='signal_spectrum'>Calculate the spectrum of a time series</h2><span id='topic+signal_spectrum'></span>

<h3>Description</h3>

<p>The power spectral density estimate of the time series is calculated using 
different approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_spectrum(data, dt, method = "periodogram", n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_spectrum_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_spectrum_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. If omitted, <code>dt</code> 
is set to 1/200. Only needed if <code>data</code> is no <code>eseis</code> object.</p>
</td></tr>
<tr><td><code id="signal_spectrum_+3A_method">method</code></td>
<td>
<p><code>Character</code> value, calculation method. One out of 
<code>"periodogram"</code> and <code>"autoregressive"</code>. 
default is <code>"periodogram"</code>.</p>
</td></tr>
<tr><td><code id="signal_spectrum_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> value, optional number of samples in 
running window used for smoothing the spectrogram. Only applied if a 
number is provided. Smoothing is performed as running mean.</p>
</td></tr>
<tr><td><code id="signal_spectrum_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Data frame</code> with frequency and power vector
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## calculate spectrum with standard setup
s &lt;- signal_spectrum(data = rockfall_eseis)

## plot spectrum
plot_spectrum(data = s)

</code></pre>

<hr>
<h2 id='signal_stats'>Calculate signal statistics</h2><span id='topic+signal_stats'></span>

<h3>Description</h3>

<p>This function calculates a set of statistics for the seismic signal 
submitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_stats(data, stats, range_f, res_psd = 1, dt, cut = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_stats_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_stats_+3A_stats">stats</code></td>
<td>
<p><code>Character</code> vector, keywords of statistics to be 
calculated. If omitted, all statistics will be calculated. Wrongly 
spelled keywords will be omitted without warning.</p>
</td></tr>
<tr><td><code id="signal_stats_+3A_range_f">range_f</code></td>
<td>
<p><code>Numerical</code> vector of length two, range of the 
frequency spectra used to calculate spectral properties. This is 
recommended to account for spurious or unwanted frequency pars, for 
example caused by ocean micro seism or high frequency effects.</p>
</td></tr>
<tr><td><code id="signal_stats_+3A_res_psd">res_psd</code></td>
<td>
<p><code>Numerical</code> value, resolution of the spectrogram
used to calculate statistics, in seconds. Default is <code>1</code> sec. The 
spectrogram will be calculated with 90 
running window of 5 sec.</p>
</td></tr>
<tr><td><code id="signal_stats_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. If omitted, <code>dt</code> 
is set to 1/200.</p>
</td></tr>
<tr><td><code id="signal_stats_+3A_cut">cut</code></td>
<td>
<p><code>Logical</code> value, option to cut output vector to the 
required statistics, instead of returning the full length of statistics, 
filled with NA values where no statistic was calculated. Default is 
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available statistics keywords are:
- (1) '&quot;t_duration&quot;' (Duration of the signal)
- (2) '&quot;f_rise&quot;' (Signal rise time, time from start to maximum amplitude)
- (3) '&quot;f_fall&quot;' (Signal fall time, tme from maximum amplitude to end)
- (4) '&quot;t_risefall&quot;' (Ratio of rise to fall time)
- (5) '&quot;a_skewness&quot;' (Skewness of the signal amplitude, see <code>seewave::specprop</code>)
- (6) '&quot;a_kurtosis&quot;' (Kurtosis of the signal amplitude, see <code>seewave::specprop</code>)
- (7) '&quot;a1_kurtosis&quot;' (Kurtosis of the filtered (0.1-1 Hz) signal amplitude, see <code>seewave::specprop</code>)
- (8) '&quot;a2_kurtosis&quot;' (Kurtosis of the filtered (1-3 Hz) signal amplitude, see <code>seewave::specprop</code>)
- (9) '&quot;a3_kurtosis&quot;' (Kurtosis of the filtered (3-10 Hz) signal amplitude, see <code>seewave::specprop</code>)
- (10) '&quot;a4_kurtosis&quot;' (Kurtosis of the filtered (10-20 Hz) signal amplitude, see <code>seewave::specprop</code>)
- (11) '&quot;a5_kurtosis&quot;' (Kurtosis of the filtered (20-50 Hz) signal amplitude, see <code>seewave::specprop</code>)
- (12) '&quot;e_maxmean&quot;' (Ratio of maximum and mean envelope value, see Hibert et al. (2017))
- (13) '&quot;e_maxmedian&quot;' (Ratio of maximum and median envelope value, see Hibert et al. (2017))
- (14) '&quot;e_skewness&quot;' (Skewness of the signal envelope, see <code>seewave::specprop</code>)
- (15) '&quot;e_kurtosis&quot;' (Kurtosis of the signal envelope, see <code>seewave::specprop</code>)
- (16) '&quot;e1_logsum&quot;' (Logarithm of the filtered (0.1-1 Hz) envelope sum, see Hibert et al. (2017))
- (17) '&quot;e2_logsum&quot;' (Logarithm of the filtered (1-3 Hz) envelope sum, see Hibert et al. (2017))
- (18) '&quot;e3_logsum&quot;' (Logarithm of the filtered (3-10 Hz) envelope sum, see Hibert et al. (2017))
- (19) '&quot;e4_logsum&quot;' (Logarithm of the filtered (10-20 Hz) envelope sum, see Hibert et al. (2017))
- (20) '&quot;e5_logsum&quot;' (Logarithm of the filtered (20-50 Hz) envelope sum, see Hibert et al. (2017))
- (21) '&quot;e_rmsdecphaseline&quot;' (RMS of envelope from linear decrease, see Hibert et al. (2017))
- (22) '&quot;c_peaks&quot;' (Number of peaks (excursions above 75 
- (23) '&quot;c_energy1&quot;' (Sum of the first third of the signal cross correlation function, see Hibert et al. (2017))
- (24) '&quot;c_energy2&quot;' (Sum of the last two thirds of the signal cross correlation function, see Hibert et al. (2017))
- (25) '&quot;c_energy3&quot;' (Ratio of c_energy1 and c_energy2, see Hibert et al. (2017))
- (26) '&quot;s_peaks&quot;' (Number of peaks (excursions above 75 
- (27) '&quot;s_peakpower&quot;' (Mean power of spectral peaks, see Hibert et al. (2017))
- (28) '&quot;s_mean&quot;' (Mean spectral power, see Hibert et al. (2017))
- (29) '&quot;s_median&quot;' (Median spectral power, see Hibert et al. (2017))
- (30) '&quot;s_max&quot;' (Maximum spectral power, see Hibert et al. (2017))
- (31) '&quot;s_var&quot;' (Variance of the spectral power, see Hibert et al. (2017))
- (32) '&quot;s_sd&quot;' (Standard deviation of the spectral power, see <code>seewave::specprop</code>)
- (33) '&quot;s_sem&quot;' (Standard error of the mean of the spectral power, see <code>seewave::specprop</code>)
- (34) '&quot;s_flatness&quot;' (Spectral flatness, see <code>seewave::specprop</code>)
- (35) '&quot;s_entropy&quot;' (Spectral entropy, see <code>seewave::specprop</code>)
- (36) '&quot;s_precision&quot;' (Spectral precision, see <code>seewave::specprop</code>)
- (37) '&quot;s1_energy&quot;' (Energy of the filtered (0.1-1 Hz) spectrum, see Hibert et al. (2017))
- (38) '&quot;s2_energy&quot;' (Energy of the filtered (1-3 Hz) spectrum, see Hibert et al. (2017))
- (39) '&quot;s3_energy&quot;' (Energy of the filtered (3-10 Hz) spectrum, see Hibert et al. (2017))
- (40) '&quot;s4_energy&quot;' (Energy of the filtered (10-20 Hz) spectrum, see Hibert et al. (2017))
- (41) '&quot;s5_energy&quot;' (Energy of the filtered (20-30 Hz) spectrum, see Hibert et al. (2017))
- (42) '&quot;s_gamma1&quot;' (Gamma 1, spectral centroid, see Hibert et al. (2017))
- (43) '&quot;s_gamma2&quot;' (Gamma 2, spectral gyration radius, see Hibert et al. (2017))
- (44) '&quot;s_gamma3&quot;' (Gamma 3, spectral centroid width, see Hibert et al. (2017))
- (45) '&quot;f_modal&quot;' (Modal frequency, see <code>seewave::specprop</code>)
- (46) '&quot;f_mean&quot;' (Mean frequency (aka central frequency), see <code>seewave::specprop</code>)
- (47) '&quot;f_median&quot;' (Median frequency, see <code>seewave::specprop</code>)
- (48) '&quot;f_q05&quot;' (Quantile 0.05 of the spectrum, see <code>seewave::specprop</code>)
- (49) '&quot;f_q25&quot;' (Quantile 0.25 of the spectrum, see <code>seewave::specprop</code>)
- (50) '&quot;f_q75&quot;' (Quantile 0.75 of the spectrum, see <code>seewave::specprop</code>)
- (51) '&quot;f_q95&quot;' (Quantile 0.95 of the spectrum, see <code>seewave::specprop</code>)
- (52) '&quot;f_iqr&quot;' (Inter quartile range of the spectrum, see <code>seewave::specprop</code>)
- (53) '&quot;f_centroid&quot;' (Spectral centroid, see <code>seewave::specprop</code>)
- (54) '&quot;p_kurtosismax&quot;' (Kurtosis of the maximum spectral power over time, see Hibert et al. (2017))
- (55) '&quot;p_kurtosismedian&quot;' (Kurtosis of the median spectral power over time, see Hibert et al. (2017))
- (56) '&quot;p_maxmean&quot;' (Mean of the ratio of max to mean spectral power over time, see Hibert et al. (2017))
- (57) '&quot;p_maxmedian&quot;' (Mean of the ratio of max to median spectral power over time, see Hibert et al. (2017))
- (58) '&quot;p_peaksmean&quot;' (Number of peaks in normalised mean spectral power over time, see Hibert et al. (2017))
- (59) '&quot;p_peaksmedian&quot;' (Number of peaks in normalised median spectral power over time, see Hibert et al. (2017))
- (60) '&quot;p_peaksmax&quot;' (Number of peaks in normalised max spectral power over time, see Hibert et al. (2017))
- (61) '&quot;p_peaksmaxmean&quot;' (Ratio of number of peaks in normalised max and mean spectral power over time, see Hibert et al. (2017))
- (62) '&quot;p_peaksmaxmedian&quot;' (Ratio of number of peaks in normalised max and median spectral power over time, see Hibert et al. (2017))
- (63) '&quot;p_peaksfcentral&quot;' (Number of peaks in spectral power at central frequency over time, see Hibert et al. (2017))
- (64) '&quot;p_diffmaxmean&quot;' (Mean difference between max and mean power, see Hibert et al. (2017))
- (65) '&quot;p_diffmaxmedian&quot;' (Mean difference between max and median power, see Hibert et al. (2017))
- (66) '&quot;p_diffquantile21&quot;' (Mean difference between power quantiles 2 and 1, see Hibert et al. (2017))
- (67) '&quot;p_diffquantile32&quot;' (Mean difference between power quantiles 3 and 2, see Hibert et al. (2017))
- (68) '&quot;p_diffquantile31&quot;' (Mean difference between power quantiles 3 and 1, see Hibert et al. (2017))
</p>
<p>References:
- Hibert C, Provost F, Malet J-P, Maggi A, Stumpf A, Ferrazzini V. 2017. 
Automatic identification of rockfalls and volcano-tectonic earthquakes
at the Piton de la Fournaise volcano using a Random Forest algorithm. 
Journal of Volcanology and Geothermal Research 340, 130-142.
</p>


<h3>Value</h3>

<p><code>data frame</code> with calculated statsitics
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(rockfall)

## clip data to event of interest
eq &lt;- signal_clip(data = rockfall_eseis, 
                  limits = as.POSIXct(c("2015-04-06 13:18:50",
                                        "2015-04-06 13:20:10"), 
                                      tz = "UTC"))

## calculate full statistics
eq_stats &lt;- signal_stats(data = eq)

## show names of statistics
names(eq_stats)

## calculate and show selected statistics, with truncated frequency range
eq_stats_sub &lt;- signal_stats(data = eq, 
                             stats = c("t_rise", 
                                       "c_peaks",
                                       "f_centroid"),
                             range_f = c(1, 90))
print(eq_stats_sub)

</code></pre>

<hr>
<h2 id='signal_sum'>Calculate signal vector sum.</h2><span id='topic+signal_sum'></span>

<h3>Description</h3>

<p>The function calculates the vector sum of the input signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_sum(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_sum_+3A_...">...</code></td>
<td>
<p><code>Numeric</code> vectors or <code>eseis</code> objects, input 
signal, that must be of the same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector, signal vector sum.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create random vectors
x &lt;- runif(n = 1000, min = -1, max = 1)
y &lt;- runif(n = 1000, min = -1, max = 1)
z &lt;- runif(n = 1000, min = -1, max = 1)

## calculate vector sums
xyz &lt;- signal_sum(x, y, z)
                     
</code></pre>

<hr>
<h2 id='signal_taper'>Taper a signal vector.</h2><span id='topic+signal_taper'></span>

<h3>Description</h3>

<p>The function tapers a signal vector with a cosine bell taper, either of a
given proportion or a discrete number of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_taper(data, p = 0, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_taper_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, <code>numeric</code> vector or list of 
objects, data set to be processed.</p>
</td></tr>
<tr><td><code id="signal_taper_+3A_p">p</code></td>
<td>
<p><code>Numeric</code> value, proportion of the signal vector to be 
tapered. Alternative to <code>n</code>.</p>
</td></tr>
<tr><td><code id="signal_taper_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> value, number of samples to be tapered at each
end of the signal vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Data frame</code>, tapered signal vector.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## remove mean from data set
rockfall &lt;- signal_demean(data = rockfall_eseis)

## create artefact at the beginning
rockfall_eseis$signal[1:100] &lt;- runif(n = 100, min = -5000, max = 5000)

## taper signal
rockfall_taper &lt;- signal_taper(data = rockfall, n = 1000)

## plot both data sets
plot_signal(data = rockfall_eseis)
plot_signal(rockfall_taper)
                     
</code></pre>

<hr>
<h2 id='signal_whiten'>Perform spectral whitening of a signal vector</h2><span id='topic+signal_whiten'></span>

<h3>Description</h3>

<p>The function normalises the input signal within a given frequency 
window. If a time series is provided, it is converted to the spectral 
domain, whitening is performed, and it is transformed back to the time 
domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_whiten(data, f, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_whiten_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object, or <code>complex</code> vector, data set to 
be processed.</p>
</td></tr>
<tr><td><code id="signal_whiten_+3A_f">f</code></td>
<td>
<p><code>Numeric</code> vector of length two, frequency window within 
which to normalise. If omitted, the entire bandwidth is normalised.</p>
</td></tr>
<tr><td><code id="signal_whiten_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. Only needed if the input 
object is not an <code>eseis</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector or eseis object, whitened signal vector.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data("rockfall")

## whiten data set between 10 and 30 Hz
rockfall_2 &lt;- signal_whiten(data = rockfall_eseis, 
                            f = c(10, 30))
                            
## plot whitened data set
plot(rockfall_2)

</code></pre>

<hr>
<h2 id='spatial_amplitude'>Locate the source of a seismic event by modelling amplutide attenuation</h2><span id='topic+spatial_amplitude'></span>

<h3>Description</h3>

<p>The function fits a model of signal amplitude attenuation for all grid
cells of the distance data sets and returns the residual sum as measure
of the most likely source location of an event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_amplitude(
  data,
  coupling,
  d_map,
  aoi,
  v,
  q,
  f,
  a_0,
  normalise = TRUE,
  output = "variance",
  cpu
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_amplitude_+3A_data">data</code></td>
<td>
<p><code>Numeric</code> matrix or <code>eseis</code> object, seismic signals
to work with. Since the function will calculate the maxima of the data it
is usually the envelopes of the data that should be used here.</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_coupling">coupling</code></td>
<td>
<p><code>Numeric</code> vector, coupling efficiency factors for each
seismic station. The best coupled station (or the one with the highest
amplification) must receive <code>1</code>, the others must be scaled relatively
to this one.</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_d_map">d_map</code></td>
<td>
<p><code>List</code> object, distance maps for each station. Output 
of <code>spatial_distance</code>.</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_aoi">aoi</code></td>
<td>
<p><code>raster</code> object that defines which pixels are used to 
locate the source. If omitted, the entire distance map extent is used. 
<code>aoi</code> and <code>d_map</code> objects must have the same extents, 
projections and pixel sizes. The <code>aoi</code> map must be of logical values.</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_v">v</code></td>
<td>
<p><code>Numeric</code> value, mean velocity of seismic waves (m/s).</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_q">q</code></td>
<td>
<p><code>Numeric</code> value, quality factor of the ground.</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_f">f</code></td>
<td>
<p><code>Numeric</code> value, frequency for which to model the
attenuation.</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_a_0">a_0</code></td>
<td>
<p><code>Logical</code> value, start parameter of the source amplitude,
if not provided, a best guess is made as 100 times the maximum amplitude
value of the data set.</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_normalise">normalise</code></td>
<td>
<p><code>Logical</code> value, option to normalise sum of
residuals between 0 and 1. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_output">output</code></td>
<td>
<p><code>Character</code> value, type of metric the function returns.
One out of <code>"residuals"</code> (sums of the squared model residuals) or
<code>"variance"</code> (variance reduction, cf. Walter et al. (2017)). Default
is <code>"variance"</code>.</p>
</td></tr>
<tr><td><code id="spatial_amplitude_+3A_cpu">cpu</code></td>
<td>
<p><code>Numeric</code> value, fraction of CPUs to use. If omitted, 
only one CPU will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster object with the location output metrics for each
grid cell.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## create synthetic DEM
dem &lt;- terra::rast(xmin = 0, xmax = 10000, 
                  ymin= 0, ymax = 10000, 
                  res = c(500, 500),
                  vals = rep(0, 400))

## define station coordinates
sta &lt;- data.frame(x = c(1000, 9000, 5000),
                 y = c(1000, 1000, 9000),
                 ID = c("A", "B", "C"))

## create synthetic signal (source in towards lower left corner of the DEM)
s &lt;- rbind(dnorm(x = 1:1000, mean = 500, sd = 50) * 100,
          dnorm(x = 1:1000, mean = 500, sd = 50) * 2,
          dnorm(x = 1:1000, mean = 500, sd = 50) * 1)

## plot DEM and stations
terra::plot(dem)
text(x = sta$x, 
    y = sta$y, 
    labels = sta$ID)

## calculate spatial distance maps and inter-station distances
D &lt;- eseis::spatial_distance(stations = sta[,1:2],
                            dem = dem)

## locate signal
e &lt;- eseis::spatial_amplitude(data = s, 
                             d_map = D$maps, 
                             v = 500, 
                             q = 50, 
                             f = 10)

## get most likely location coordinates (example contains two equal points)
e_max &lt;- spatial_pmax(data = e)

## plot output
terra::plot(e)
points(e_max[1], 
      e_max[2],
      pch = 20)
points(sta[,1:2])


## End(Not run)

</code></pre>

<hr>
<h2 id='spatial_clip'>Clip values of spatial data.</h2><span id='topic+spatial_clip'></span>

<h3>Description</h3>

<p>The function replaces raster values based on different thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_clip(data, quantile, replace = NA, normalise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_clip_+3A_data">data</code></td>
<td>
<p><code>SpatRaster</code> object, spatial data set to be processed.</p>
</td></tr>
<tr><td><code id="spatial_clip_+3A_quantile">quantile</code></td>
<td>
<p><code>Numeric</code> value, quantile value below which raster 
values are clipped.</p>
</td></tr>
<tr><td><code id="spatial_clip_+3A_replace">replace</code></td>
<td>
<p><code>Numeric</code> value, replacement value, default is
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="spatial_clip_+3A_normalise">normalise</code></td>
<td>
<p><code>Logical</code> value, optionally normalise values above 
threshold quantile between 0 and 1. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatRaster</code> object, data set with clipped values.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(volcano)

## convert matrix to raster object
volcano &lt;- terra::rast(volcano)

## clip values to those &gt; quantile 0.5
volcano_clip &lt;- spatial_clip(data = volcano, 
                             quantile = 0.5)
                                    
## plot clipped data set
terra::plot(volcano_clip)
                     
</code></pre>

<hr>
<h2 id='spatial_convert'>Convert coordinates between reference systems</h2><span id='topic+spatial_convert'></span>

<h3>Description</h3>

<p>Coordinates are converted between reference systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_convert(data, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_convert_+3A_data">data</code></td>
<td>
<p><code>Numeric</code> vector of length two or data frame, 
x-, y-coordinates to be converted.</p>
</td></tr>
<tr><td><code id="spatial_convert_+3A_from">from</code></td>
<td>
<p><code>Character</code> value, proj4 string of the input 
reference system.</p>
</td></tr>
<tr><td><code id="spatial_convert_+3A_to">to</code></td>
<td>
<p><code>Character</code> value, proj4 string of the output 
reference system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> data frame with converted coordinates.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create lat lon coordinates
xy &lt;- c(13, 55)

## define output coordinate systems 
proj_in &lt;- "+proj=longlat +datum=WGS84"
proj_out &lt;- "+proj=utm +zone=32 +datum=WGS84"

## convert coordinate pair
spatial_convert(data = xy, 
                from = proj_in,
                to = proj_out)
                
## define set of coordinates
xy &lt;- data.frame(x = c(10, 11),
                 y = c(54, 55))
                 
## convert set of coordinates
spatial_convert(data = xy, 
                from = proj_in,
                to = proj_out)
                     
</code></pre>

<hr>
<h2 id='spatial_crop'>Crop extent of spatial data.</h2><span id='topic+spatial_crop'></span>

<h3>Description</h3>

<p>The function crops the spatial extent of raster objects or other 
spatial objects based on bounding box coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_crop(data, bbox)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_crop_+3A_data">data</code></td>
<td>
<p><code>raster</code> object, spatial data set to be processed.</p>
</td></tr>
<tr><td><code id="spatial_crop_+3A_bbox">bbox</code></td>
<td>
<p><code>Numeric</code> vector of length four, bounding box coordinates 
in the form <code>c(xmin, xmax, ymin, ymax)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>spatial object, cropped to bounding box
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create example data set
x &lt;- terra::rast(nrows = 100, ncols = 100, 
                 xmin = 0, xmax = 10, 
                 ymin = 0, ymax = 10)
terra::values(x) &lt;- 1:10000

## create crop extent vector
bbox &lt;- c(3, 7, 3, 7)

## crop spatial object
y &lt;- spatial_crop(data = x, 
                  bbox = bbox)

## plot both objects
terra::plot(x)
terra::plot(y, add = TRUE)

</code></pre>

<hr>
<h2 id='spatial_distance'>Calculate topography-corrected distances for seismic waves.</h2><span id='topic+spatial_distance'></span>

<h3>Description</h3>

<p>The function calculates topography-corrected distances either between 
seismic stations or from seismic stations to pixels of an input raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_distance(
  stations,
  dem,
  topography = TRUE,
  maps = TRUE,
  matrix = TRUE,
  aoi,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_distance_+3A_stations">stations</code></td>
<td>
<p><code>Numeric</code> matrix of length two, x- and y-coordinates 
of the seismic stations to be processed (column-wise orgnaised).The 
coordinates must be in metric units, such as the UTM system and 
match with the reference system of the <code>dem</code>.</p>
</td></tr>
<tr><td><code id="spatial_distance_+3A_dem">dem</code></td>
<td>
<p><code>SpatRaster</code> object, the digital elevation model (DEM) to 
be processed. The DEM must be in metric units, such as the UTM system and 
match with the reference system of the coordinates of <code>stations</code>. 
See <code>terra</code> for supported types and how to read these to R.</p>
</td></tr>
<tr><td><code id="spatial_distance_+3A_topography">topography</code></td>
<td>
<p><code>Logical</code> scalar, option to enable topography
correction, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatial_distance_+3A_maps">maps</code></td>
<td>
<p><code>Logical</code> scalar, option to enable/disable calculation
of distance maps. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatial_distance_+3A_matrix">matrix</code></td>
<td>
<p><code>Logical</code> scalar, option to enable/disable calculation
of interstation distances. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatial_distance_+3A_aoi">aoi</code></td>
<td>
<p><code>Numeric</code> vector of length four, bounding coordinates of 
the area of interest to process, in the form <code>c(x0, x1, y0, y1)</code>.</p>
</td></tr>
<tr><td><code id="spatial_distance_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value, option to show extended function 
information as the function is running. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Topography correction is necessary because seismic waves can only travel 
on the direct path as long as they are within solid matter. When the 
direct path is through air, the wave can only travel along the surface
of the landscape. The function accounts for this effect and returns the
corrected travel distance data set.
</p>


<h3>Value</h3>

<p><code>List</code> object with distance maps (list of 
<code>SpatRaster</code> objects from <code>terra</code> package) and station distance 
matrix (<code>data.frame</code>).
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data("volcano")
dem &lt;- terra::rast(volcano)
dem &lt;- dem * 10
terra::ext(dem) &lt;- terra::ext(dem) * 10
terra::ext(dem) &lt;-terra::ext(dem) + c(510, 510, 510, 510)

## define example stations
stations &lt;- cbind(c(200, 700), c(220, 700))

## plot example data
terra::plot(dem)
points(stations[,1], stations[,2])

## calculate distance matrices and stations distances
D &lt;- spatial_distance(stations = stations, 
                      dem = dem)

terra::plot(D$maps[[1]])

## show station distance matrix
print(D$matrix)

## calculate with AOI and in verbose mode
D &lt;- spatial_distance(stations = stations, 
                      dem = dem, 
                      verbose = TRUE,
                      aoi = c(0, 200, 0, 200))

## plot distance map for station 2
terra::plot(D$maps[[1]])


## End(Not run) 
                                          
</code></pre>

<hr>
<h2 id='spatial_migrate'>Migrate signals of a seismic event through a grid of locations.</h2><span id='topic+spatial_migrate'></span>

<h3>Description</h3>

<p>The function performs signal migration in space in order to determine 
the location of a seismic signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_migrate(
  data,
  d_stations,
  d_map,
  snr,
  v,
  dt,
  normalise = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_migrate_+3A_data">data</code></td>
<td>
<p><code>Numeric</code> matrix or <code>eseis</code> object, seismic signals 
to cross-correlate.</p>
</td></tr>
<tr><td><code id="spatial_migrate_+3A_d_stations">d_stations</code></td>
<td>
<p><code>Numeric</code> matrix, inter-station distances. Output 
of <code>spatial_distance</code>.</p>
</td></tr>
<tr><td><code id="spatial_migrate_+3A_d_map">d_map</code></td>
<td>
<p><code>List</code> object, distance maps for each station. Output 
of <code>spatial_distance</code>.</p>
</td></tr>
<tr><td><code id="spatial_migrate_+3A_snr">snr</code></td>
<td>
<p><code>Numeric</code> vector, optional signal-to-noise-ratios for 
each signal trace, used for normalisation. If omitted it is calculated
from input signals.</p>
</td></tr>
<tr><td><code id="spatial_migrate_+3A_v">v</code></td>
<td>
<p><code>Numeric</code> value, mean velocity of seismic waves (m/s).</p>
</td></tr>
<tr><td><code id="spatial_migrate_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period.</p>
</td></tr>
<tr><td><code id="spatial_migrate_+3A_normalise">normalise</code></td>
<td>
<p><code>Logical</code> value, option to normalise stations 
correlations by signal-to-noise-ratios.</p>
</td></tr>
<tr><td><code id="spatial_migrate_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value, option to show extended function 
information as the function is running. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the switch from the package raster to the package terra, the 
resulting distance maps can no longer be saved in lists as distance
maps. Thus, the function re-defines the distance SpatRaster objects by
a list of data on crs, extent, resolution and raster values. As a 
consequence, plotting the data requires turning them into a SpatRaster
object, first (see examples).
</p>


<h3>Value</h3>

<p>A SpatialGridDataFrame-object with Gaussian probability density
function values for each grid cell.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## create synthetic DEM
dem &lt;- terra::rast(nrows = 20, ncols = 20, 
                   xmin = 0, xmax = 10000, 
                   ymin= 0, ymax = 10000, 
                   vals = rep(0, 400))

## define station coordinates
sta &lt;- data.frame(x = c(1000, 9000, 5000),
                  y = c(1000, 1000, 9000),
                  ID = c("A", "B", "C"))

## create synthetic signal (source in the center of the DEM)
s &lt;- rbind(dnorm(x = 1:1000, mean = 500, sd = 50),
           dnorm(x = 1:1000, mean = 500, sd = 50),
           dnorm(x = 1:1000, mean = 500, sd = 50))

## plot DEM and stations
terra::plot(dem)

text(x = sta$x, 
     y = sta$y, 
     labels = sta$ID)

## calculate spatial distance maps and inter-station distances
D &lt;- spatial_distance(stations = sta[,1:2],
                             dem = dem)
                             
## restore SpatRaster object for plotting purpose
D_map_1 &lt;- terra:rast(crs = D$maps[[1]]$crs,
                      ext = D$maps[[1]]$ext,
                      res = D$maps[[1]]$res,
                      val = D$maps[[1]]$values)
                      
## plot distance map
terra::plot(D_map_1) 

## locate signal
e &lt;- spatial_migrate(data = s, 
                     d_stations = D$matrix, 
                     d_map = D$maps, 
                     v = 1000, 
                     dt = 1/100)

## get most likely location coordinates
e_max &lt;- spatial_pmax(data = e)

## plot location estimate, most likely location estimate and stations
terra::plot(e)
points(e_max[1], 
       e_max[2],
       pch = 20)
points(sta[,1:2])
 

## End(Not run)

</code></pre>

<hr>
<h2 id='spatial_pmax'>Get most likely source location</h2><span id='topic+spatial_pmax'></span>

<h3>Description</h3>

<p>The function identifies the location of a seismic source with the 
heighest likelihood (P_max).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_pmax(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_pmax_+3A_data">data</code></td>
<td>
<p><code>SpatRaster</code> object, spatial data set with source location
estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>, coordinates (x and y) of the most likely s
ource location(s).
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create example source location likelihood raster
x &lt;- terra::rast(nrows = 100, ncols = 100, 
                 xmin = 0, xmax = 10, 
                 ymin = 0, ymax = 10)
terra::values(x) &lt;- runif(n = 100)

## identify location of highest likelihood
p_max &lt;- spatial_pmax(data = x)

## show result
print(p_max)

</code></pre>

<hr>
<h2 id='spatial_track'>Track a spatially mobile seismic source</h2><span id='topic+spatial_track'></span>

<h3>Description</h3>

<p>This function allows tracking a spatially mobile seismic source and 
thereby estimating the source amplitude and the model's variance 
reduction as a measure of quality or robustness of the time-resolved 
estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_track(
  data,
  coupling,
  window,
  overlap = 0,
  d_map,
  aoi,
  v,
  q,
  f,
  k,
  qt = 1,
  dt,
  model = "SurfSpreadAtten",
  cpu,
  verbose = FALSE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_track_+3A_data">data</code></td>
<td>
<p><code>Numeric</code> matrix or <code>eseis</code> object, seismic signals 
used for source tracking. Note that the function will start tracking 
within a smaller time window, narrows be the maximum signal arrival time 
differences as defined by the maximum inter station distance and the 
seismic velocity. The signals should be the envelopes of waveforms.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_coupling">coupling</code></td>
<td>
<p><code>Numeric</code>  vector, coupling efficiency factors for 
each seismic station. The best coupled station (or the one with the 
highest amplification) must receive 1, the others must be scaled 
relatively to this one.Numeric vector, coupling efficiency factors for 
each seismic station. The best coupled station (or the one with the 
highest amplification) must receive 1, the others must be scaled 
relatively to this one.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_window">window</code></td>
<td>
<p><code>Numeric</code> value, time window for which the source is 
tracked. If omitted, ten time steps are generated.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_overlap">overlap</code></td>
<td>
<p><code>Numeric</code> value between 0 and 1, fraction of overlap 
of time windows used for source tracking. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_d_map">d_map</code></td>
<td>
<p><code>List</code> object, distance maps for each station (i.e., 
<code>SpatialGridDataFrame</code> objects). Output of <code>spatial_distance</code>.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_aoi">aoi</code></td>
<td>
<p><code>Raster</code> object (optional) that defines which pixels are 
used to locate the source. If omitted, the entire distance map extent is  
used. <code>aoi</code> and <code>d_map</code> objects must have the same extents, 
projections and pixel sizes. The aoi map must be of logical values.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_v">v</code></td>
<td>
<p><code>Numeric</code> value, mean velocity of seismic waves (m/s).</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_q">q</code></td>
<td>
<p><code>Numeric</code> value, quality factor of the ground.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_f">f</code></td>
<td>
<p><code>Numeric</code> value, frequency for which to model the 
attenuation.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_k">k</code></td>
<td>
<p><code>Numeric</code> value, fraction of surface wave contribution to 
signals. Only relevant for models that include mixture of surface and 
body waves (see <code>model_amplitude</code>).</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_qt">qt</code></td>
<td>
<p><code>Numeric</code> value, quantile threshold that defines acceptable
location estimates. Default is <code>1</code> (only single best estimate is 
kept).</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling frequency. Only required if 
input signals are no eseis objects.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_model">model</code></td>
<td>
<p><code>Character</code> value,</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_cpu">cpu</code></td>
<td>
<p><code>Numeric</code> value, fraction of CPUs to use for parallel 
processing. If omitted, one CPU is used</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_verbose">verbose</code></td>
<td>
<p><code>Logical</code> value, optional screen output of processing
progress. Default is FALSE.</p>
</td></tr>
<tr><td><code id="spatial_track_+3A_plot">plot</code></td>
<td>
<p><code>Logical</code> value, enable graphical output of key results. 
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is based on ideas published by Burtin et al. (2016), 
Walter et al. 82017) and Perez-Guillen et al. (2019) and implemented 
in the R package eseis by Dietze (2018). It is related to the function
<code>spatial_amplitude</code>, which can be used to locate spatially 
stable seismic sources by the same technique, and it resuires 
prepared input data as delivered by the function 
<code>spatial_distance</code>.
</p>
<p>The input data (<code>data</code>) should ideally be a list of eseis 
objects (alternatively a matrix with seismic signal traces) containing 
the envelopes of the seismic event to track (i.e., describe by its 
location and amplitude as a function of propagation time). The temporal 
resolution of the track is defined by the arguments <code>window</code> and 
<code>overlap</code> (as a fraction between 0 and 1). The approach is based on 
fitting known amplitude-distance functions (for an overview of available 
functions see <code>model_amplitude</code>) to the envelope time snippets 
for each pixel of a grid, which provides the distance from a pixel to 
each seismic station, i.e., the distance map set <code>d_map</code>. To avoid 
fitting each of the pixels of the distance map, one can provide an area
of interest, AOI (<code>aoi</code>), which has the same extent and resolution 
as the distance map set and pixel values are either <code>TRUE</code> or 
<code>FALSE</code>. Depending on which amplitude-distance function is chosen, 
further arguments need to be provided (ground quality factor <code>q</code>,
center frequency of the signal <code>f</code>). The apparent seismic wave 
velocity <code>v</code> is required regardless, either as fit model parameter 
or to correct the amplitude time snippets for the travel time delay from 
the source to the respective pixel of the distance map set. The output 
of the function can be provided with uncertainty estimates on all output 
values. The uncertainty is based on the size of accepted location 
estimates per time step, as defined by the variance reduction quantile 
threshold <code>qt</code> (i.e., all locations above this quantile will be 
assumed to be valid location estimates, whose parameters will be used 
to estimate the uncertainty). Note that usually, <code>qt</code> should be 
set to around 0.99, a value that depends on the number of pixels in 
the distance map set and that affects the location uncertainty, which 
in many cases is about 10 
Note however, that this value is purely arbitrary and should be based 
on field-based control data. It is possible to run the function in a 
multi-CPU mode, to speed up computational time, using the argument 
<code>cpu</code>. Also, the function can generate generic plot output of 
the results, a panel of three plots: source trajectory, source 
amplitude and variance reduction.
</p>
<p>Note that depending on the resolution of the distance map set, number 
of included seismic stations, and number of time windows, the 
function can take significant processing time. 50 time steps for 5 
stations and 5000 pixels per distance map requires about 10 minutes 
time on a normal grade computer using a single CPU.
</p>


<h3>Value</h3>

<p>A <code>List</code> object with summarising statistics of the fits.
</p>


<h3>References</h3>

<p>Burtin, A., Hovius, N., and Turowski, J. M.: Seismic monitoring of 
torrential and fluvial processes, Earth Surf. Dynam., 4, 285307, 
https://doi.org/10.5194/esurf-4-285-2016, 2016. 
</p>
<p>Dietze, M.: The R package 'eseis'  a software toolbox for environmental
seismology, Earth Surf. Dynam., 6, 669686, 
https://doi.org/10.5194/esurf-6-669-2018, 2018. 
</p>
<p>Perez-Guillen, C., Tsunematsu, K., Nishimura, K., and Issler, D.: Seismic 
location and tracking of snow avalanches and slush flows on Mt. Fuji, 
Japan, Earth Surf. Dynam., 7, 9891007, 
https://doi.org/10.5194/esurf-7-989-2019, 2019. 
</p>
<p>Walter, F., Burtin, A., McArdell, B. W., Hovius, N., Weder, B., and 
Turowski, J. M.: Testing seismic amplitude source location for fast
debris-flow detection at Illgraben, Switzerland, Nat. Hazards Earth 
Syst. Sci., 17, 939955, https://doi.org/10.5194/nhess-17-939-2017, 2017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

x &lt;- spatial_track(data = data, 
                   window = 5, 
                   overlap = 0.5,
                   d_map = D$maps, 
                   aoi = aoi, 
                   v = 800, 
                   q = 40, 
                   f = 12, 
                   qt = 0.99)


## End(Not run)

</code></pre>

<hr>
<h2 id='time_aggregate'>Aggregate a time series</h2><span id='topic+time_aggregate'></span>

<h3>Description</h3>

<p>The time series <code>x</code> is aggregated by an integer factor <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_aggregate(data, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_aggregate_+3A_data">data</code></td>
<td>
<p><code>POSIXct</code> vector, time to be processed.</p>
</td></tr>
<tr><td><code id="time_aggregate_+3A_n">n</code></td>
<td>
<p><code>Numeric</code> value, number of samples to be aggregated to one
new data value. Must be an integer value greater than 1. Default is 
<code>2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>POSIXct</code> vector, aggregated data.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data set
data(rockfall)

## aggregate time series
rockfall_t_agg &lt;- time_aggregate(data = rockfall_t, 
                          n = 2)

## compare results
range(rockfall_t)
diff(rockfall_t)

range(rockfall_t_agg)
diff(rockfall_t_agg)

</code></pre>

<hr>
<h2 id='time_clip'>Clip time vector.</h2><span id='topic+time_clip'></span>

<h3>Description</h3>

<p>The function clips a time vector based on provided limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_clip(time, limits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_clip_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector, time vector.</p>
</td></tr>
<tr><td><code id="time_clip_+3A_limits">limits</code></td>
<td>
<p><code>POSIXct</code> vector of length two, time limits for 
clipping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>POSIXct</code> vector, clipped time vector.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(rockfall)

## define limits to clip to
limits &lt;- c(min(rockfall_t) + 10,
            max(rockfall_t) - 10)

## clip data set
rockfall_t_clip &lt;- time_clip(time = rockfall_t, 
                             limits = limits)

## compare time ranges
range(rockfall_t)
range(rockfall_t_clip)
                     
</code></pre>

<hr>
<h2 id='time_convert'>Convert Julian Day to Date and vice versa</h2><span id='topic+time_convert'></span>

<h3>Description</h3>

<p>The function converts a Julian Day value to a date, to <code>POSIXct</code> if a 
year is provided, otherwise to <code>POSIXlt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_convert(input, output, timezone = "UTC", year)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_convert_+3A_input">input</code></td>
<td>
<p><code>Numeric</code> vector, input time Supported formats are 
<code>YYYY-MM-DD</code>, <code>JD</code> and <code>POSIXct</code>.</p>
</td></tr>
<tr><td><code id="time_convert_+3A_output">output</code></td>
<td>
<p><code>Numeric</code> vector, output time. Supported formats are 
<code>YYYY-MM-DD</code>, <code>JD</code> and <code>POSIXct</code>.</p>
</td></tr>
<tr><td><code id="time_convert_+3A_timezone">timezone</code></td>
<td>
<p><code>Character</code> vector, time zone of the output date. 
Default is <code>"UTC"</code>.</p>
</td></tr>
<tr><td><code id="time_convert_+3A_year">year</code></td>
<td>
<p><code>Character</code> vector, year of the date. Only used when 
<code>input</code> is <code>JD</code>. If omitted, the current year is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Numeric</code> vector,
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## convert Julian Day 18 to POSIXct
time_convert(input = 18, output = "POSIXct")

## convert Julian Day 18 to yyyy-mm-dd
time_convert(input = 18, output = "yyyy-mm-dd")

## convert yyyy-mm-dd to Julian Day
time_convert(input = "2016-01-18", output = "JD")

## convert a vector of Julian Days to yyyy-mm-dd
time_convert(input = 18:21, output = "yyyy-mm-dd")
                     
</code></pre>

<hr>
<h2 id='write_mseed'>Write seismic traces as mseed file to disk.</h2><span id='topic+write_mseed'></span>

<h3>Description</h3>

<p>This function converts seismic traces to mseed files and writes them to 
disk. It makes use of the Python library 'ObsPy'. Thus, this software 
must be installed, to make use of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_mseed(data, file, time, component, station, location, network, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_mseed_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object or <code>numeric</code> vector, data set to 
be processed. Most other arguments can be omitted if <code>data</code> is an
<code>eseis</code> object.</p>
</td></tr>
<tr><td><code id="write_mseed_+3A_file">file</code></td>
<td>
<p><code>Character</code> scalar, mseed file name with extension.</p>
</td></tr>
<tr><td><code id="write_mseed_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector, time vector corresponding to the 
seismic trace. Alternatively, the start time stamp can be provided as
<code>POSIXct</code> value and a value for <code>dt</code> must be given.</p>
</td></tr>
<tr><td><code id="write_mseed_+3A_component">component</code></td>
<td>
<p><code>Character</code> value, component ID, optional.</p>
</td></tr>
<tr><td><code id="write_mseed_+3A_station">station</code></td>
<td>
<p><code>Character</code> value, station ID, optional.</p>
</td></tr>
<tr><td><code id="write_mseed_+3A_location">location</code></td>
<td>
<p><code>Character</code> vector of length four, station location 
data (latitude, longitude, elevation, depth), optional.</p>
</td></tr>
<tr><td><code id="write_mseed_+3A_network">network</code></td>
<td>
<p><code>Character</code> value, network ID, optional.</p>
</td></tr>
<tr><td><code id="write_mseed_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. Only needed if no time
vector is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ObsPy Python library can be installed following the information 
provided here: <code>"https://github.com/obspy/obspy/wiki"</code>.
</p>
<p>Since the ObsPy functionality through R is not able to interpret path 
definitions using the tilde symbol, e.g. <code>"~/Downloads"</code>, this 
Linux type definition must be avoided.
</p>


<h3>Value</h3>

<p>A binary file written to disk.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## load example data 
data("rockfall")

## write as mseed file
write_mseed(data = rockfall_eseis, file = "rockfall.mseed")
          

## End(Not run)

</code></pre>

<hr>
<h2 id='write_report'>Create a HTML report for (RLum) objects</h2><span id='topic+write_report'></span>

<h3>Description</h3>

<p>This function creates a HTML report for a given eseis object, listing its
complete processing history. The report serves both as a convenient way of
browsing through objects and as a proper approach to documenting and saving
scientific data and workflows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_report(object, file, title = "eseis report", browser = FALSE, css)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_report_+3A_object">object</code></td>
<td>
<p><code>eseis</code> object to be reported on</p>
</td></tr>
<tr><td><code id="write_report_+3A_file">file</code></td>
<td>
<p><code>Character</code> value, name of the output file (without
extension)</p>
</td></tr>
<tr><td><code id="write_report_+3A_title">title</code></td>
<td>
<p><code>Character</code> value, title of the report</p>
</td></tr>
<tr><td><code id="write_report_+3A_browser">browser</code></td>
<td>
<p><code>Logical</code> value, optionally open the HTML file in the
default web browser after it has been rendered.</p>
</td></tr>
<tr><td><code id="write_report_+3A_css">css</code></td>
<td>
<p><code>Character</code> value, path to a CSS file to change the
default styling of the HTML document.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function heavily lends ideas from the function <code>report_RLum()</code>
written by Christoph Burow, which is contained in the package
<code>Luminescence</code>. This function here is a truncated, tailored version
with minimised availabilities.
</p>


<h3>Value</h3>

<p>HTML and .Rds file.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## load example data set
data(rockfall)

## make report for rockfall object
write_report(object = rockfall_eseis, 
             browser = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='write_sac'>Write seismic traces as sac file to disk.</h2><span id='topic+write_sac'></span>

<h3>Description</h3>

<p>This function converts seismic traces to sac files and writes them to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_sac(
  data,
  file,
  time,
  component,
  unit,
  station,
  location,
  network,
  dt,
  autoname = FALSE,
  parameters,
  biglong = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_sac_+3A_data">data</code></td>
<td>
<p><code>eseis</code> object or <code>numeric</code> vector, data set to 
be processed. Most other arguments can be omitted if <code>data</code> is an
<code>eseis</code> object.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_file">file</code></td>
<td>
<p><code>Character</code> scalar, sac file name with extension.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_time">time</code></td>
<td>
<p><code>POSIXct</code> vector, time vector corresponding to the 
seismic trace. Alternatively, the start time stamp can be provided as
<code>POSIXct</code> value and a value for <code>dt</code> must be given.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_component">component</code></td>
<td>
<p><code>Character</code> value, component ID, optional.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_unit">unit</code></td>
<td>
<p><code>Character</code> value, unit of the signal, optional. One out
of <code>"unknown"</code>, <code>"displacement"</code>, <code>"velocity"</code>, 
<code>"volts"</code>, <code>"acceleration"</code>. Default is <code>"unknown"</code>.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_station">station</code></td>
<td>
<p><code>Character</code> value, station ID, optinal.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_location">location</code></td>
<td>
<p><code>Character</code> vector of length four, station location 
data (latitude, longitude, elevation, depth), optional.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_network">network</code></td>
<td>
<p><code>Character</code> value, network ID, optional.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_dt">dt</code></td>
<td>
<p><code>Numeric</code> value, sampling period. Only needed if no time
vector is provided.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_autoname">autoname</code></td>
<td>
<p><code>Logical</code> value, option to let the function generate 
the file name automatically. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_parameters">parameters</code></td>
<td>
<p><code>Data frame</code> sac parameter list, as obtained from
<code>list_sacparameters</code>. Allows user-specific modifications. If this 
data frame is provided, it overrides all other arguments.</p>
</td></tr>
<tr><td><code id="write_sac_+3A_biglong">biglong</code></td>
<td>
<p><code>Logical</code> value, biglong option, default is 
<code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For description of the sac file format see
https://ds.iris.edu/files/sac-manual/manual/file_format.html. Currently the 
following parameters are not supported when writing the sac file: 
LAT, LON, ELEVATION, NETWORK.
</p>


<h3>Value</h3>

<p>A binary file written to disk.
</p>


<h3>Author(s)</h3>

<p>Michael Dietze
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## load example data 
data("rockfall")

## write as sac file
write_sac(data = rockfall_eseis)
          

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
