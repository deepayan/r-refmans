<!DOCTYPE html><html><head><title>Help for package ScatterDensity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ScatterDensity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ScatterDensity-package'>
<p>Density Estimation and Visualization of 2D Scatter Plots</p></a></li>
<li><a href='#DDCAL'>
<p>Density Distribution Cluster Algorithm of [Lux and Rinderle-Ma, 2023].</p></a></li>
<li><a href='#DensityScatter.DDCAL'>
<p>Scatter density plot [Brinkmann et al., 2023]</p></a></li>
<li><a href='#inPSphere2D'><p>2D data points in Pareto Sphere</p></a></li>
<li><a href='#PDEscatter'><p>Scatter Density Plot</p></a></li>
<li><a href='#PointsInPolygon'>
<p>PointsInPolygon</p></a></li>
<li><a href='#PolygonGate'>
<p>PolygonGate</p></a></li>
<li><a href='#SmoothedDensitiesXY'>
<p>Smoothed Densities X with Y</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Density Estimation and Visualization of 2D Scatter Plots</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-09</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Thrun &lt;m.thrun@gmx.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The user has the option to utilize the two-dimensional density estimation techniques called smoothed density published by Eilers and Goeman (2004) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtg454">doi:10.1093/bioinformatics/btg454</a>&gt;, and pareto density which was evaluated for univariate data by Thrun, Gehlert and Ultsch, 2020 &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0238835">doi:10.1371/journal.pone.0238835</a>&gt;. Moreover, it provides visualizations of the density estimation in the form of two-dimensional scatter plots in which the points are color-coded based on increasing density. Colors are defined by the one-dimensional clustering technique called 1D distribution cluster algorithm (DDCAL) published by Lux and Rinderle-Ma (2023) &lt;<a href="https://doi.org/10.1007%2Fs00357-022-09428-6">doi:10.1007/s00357-022-09428-6</a>&gt;.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, pracma</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DataVisualizations, ggplot2, ggExtra, plotly, FCPS,
parallelDist, secr, ClusterR</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 2.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.deepbionics.org/">https://www.deepbionics.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Mthrun/ScatterDensity/issues">https://github.com/Mthrun/ScatterDensity/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-09 14:19:26 UTC; MCT</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Thrun <a href="https://orcid.org/0000-0001-9542-5543"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Felix Pape [aut, rev],
  Luca Brinkman [aut],
  Quirin Stier <a href="https://orcid.org/0000-0002-7896-4737"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-09 14:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ScatterDensity-package'>
Density Estimation and Visualization of 2D Scatter Plots
</h2><span id='topic+ScatterDensity-package'></span><span id='topic+ScatterDensity'></span>

<h3>Description</h3>

<p>The user has the option to utilize the two-dimensional density estimation techniques called smoothed density published by Eilers and Goeman (2004) &lt;doi:10.1093/bioinformatics/btg454&gt;, and pareto density which was evaluated for univariate data by Thrun, Gehlert and Ultsch, 2020 &lt;doi:10.1371/journal.pone.0238835&gt;. Moreover, it provides visualizations of the density estimation in the form of two-dimensional scatter plots in which the points are color-coded based on increasing density. Colors are defined by the one-dimensional clustering technique called 1D distribution cluster algorithm (DDCAL) published by Lux and Rinderle-Ma (2023) &lt;doi:10.1007/s00357-022-09428-6&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ScatterDensity</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Density Estimation and Visualization of 2D Scatter Plots</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-10-09</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Michael", "Thrun", email= "m.thrun@gmx.net",role=c("aut","cre","cph"), comment = c(ORCID = "0000-0001-9542-5543")),person("Felix", "Pape",role=c("aut","rev")),person("Luca","Brinkman",role=c("aut")),person("Quirin", "Stier",role=c("aut"), comment = c(ORCID = "0000-0002-7896-4737")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Michael Thrun &lt;m.thrun@gmx.net&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> The user has the option to utilize the two-dimensional density estimation techniques called smoothed density published by Eilers and Goeman (2004) &lt;doi:10.1093/bioinformatics/btg454&gt;, and pareto density which was evaluated for univariate data by Thrun, Gehlert and Ultsch, 2020 &lt;doi:10.1371/journal.pone.0238835&gt;. Moreover, it provides visualizations of the density estimation in the form of two-dimensional scatter plots in which the points are color-coded based on increasing density. Colors are defined by the one-dimensional clustering technique called 1D distribution cluster algorithm (DDCAL) published by Lux and Rinderle-Ma (2023) &lt;doi:10.1007/s00357-022-09428-6&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp, pracma</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> DataVisualizations, ggplot2, ggExtra, plotly, FCPS,
parallelDist, secr, ClusterR</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods, R (&gt;= 2.10)</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.deepbionics.org/</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/Mthrun/ScatterDensity/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Michael Thrun [aut, cre, cph] (&lt;https://orcid.org/0000-0001-9542-5543&gt;),
  Felix Pape [aut, rev],
  Luca Brinkman [aut],
  Quirin Stier [aut] (&lt;https://orcid.org/0000-0002-7896-4737&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Archs: </td><td style="text-align: left;"> x64</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
DDCAL                   Density Distribution Cluster Algorithm of [Lux
                        and Rinderle-Ma, 2023].
DensityScatter.DDCAL    Scatter density plot [Brinkmann et al., 2023]
PDEscatter              Scatter Density Plot
PointsInPolygon         PointsInPolygon
PolygonGate             PolygonGate
ScatterDensity-package
                        Density Estimation and Visualization of 2D
                        Scatter Plots
SmoothedDensitiesXY     Smoothed Densities X with Y
inPSphere2D             2D data points in Pareto Sphere
</pre>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Michael Thrun &lt;m.thrun@gmx.net&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Todo
</code></pre>

<hr>
<h2 id='DDCAL'>
Density Distribution Cluster Algorithm of [Lux and Rinderle-Ma, 2023].
</h2><span id='topic+DDCAL'></span>

<h3>Description</h3>

<p>DDCAL is a clustering-algorithm for one-dimensional data, which heuristically finds clusters to evenly distribute the data points in low variance clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DDCAL(data, nClusters, minBoundary = 0.1, maxBoundary = 0.45,

numSimulations = 20, csTolerance = 0.45, csToleranceIncrease = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DDCAL_+3A_data">data</code></td>
<td>

<p>[1:n] Numeric vector, with the data values
</p>
</td></tr>
<tr><td><code id="DDCAL_+3A_nclusters">nClusters</code></td>
<td>

<p>Scalar, number of clusters to be found
</p>
</td></tr>
<tr><td><code id="DDCAL_+3A_minboundary">minBoundary</code></td>
<td>

<p>Scalar, in the range (0,1), gives the lower boundary (in percent), for the simulation. Default is 0.1
</p>
</td></tr>
<tr><td><code id="DDCAL_+3A_maxboundary">maxBoundary</code></td>
<td>

<p>Scalar, in the range (0,1), gives the upper boundary (in percent), for the simulation. Default is 0.45
</p>
</td></tr>
<tr><td><code id="DDCAL_+3A_numsimulations">numSimulations</code></td>
<td>

<p>Scalar, number of simulations/iterations of the algorithm
</p>
</td></tr>
<tr><td><code id="DDCAL_+3A_cstolerance">csTolerance</code></td>
<td>

<p>Scalar, in the range (0,1). Gives cluster size tolerance factor. The necessary cluster size is defined by (dataSize/nClusters - dataSize/nClusters * csTolerance). Default is 0.45
</p>
</td></tr>
<tr><td><code id="DDCAL_+3A_cstoleranceincrease">csToleranceIncrease</code></td>
<td>

<p>Scalar, in the range (0,1), gives the procentual increase of the csTolerance-factor, if some clusters did not reach the necessary size. Default is 0.5
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DDCAL creates a evenly spaced division of the min-max-normalized data from minBoundary to maxBoundary. Those divisions will be used as boundaries. The first initial clusters will be the data from min(data) to minBoundary and maxBoundary to max(data). The clusters will be extended to neighboring points, as long as the standard deviations of the clusters will be reduced. A potential clusters will be used, if they have the necessary size, given as (dataSize/nClusters - dataSize/nClusters * csTolerance). If both clusters can be used, the left cluster (which is the cluster from min(data) to minBoundary or above) is preferred. If no clusters can be found with the necessary size, then the csTolerance-factor and with it the necessary cluster size will be lowered.
If a clusters is used, the next boundaries are found, which are not in the already existing clusters and the procedure is repeated with the not already clustered data, until all points are assigned to clusters.
</p>
<p>If a matrix is given as input data, the first column of the matrix will be used as data for the clustering
</p>
<p>Non-finite values will not be clustered, but instead will get the cluster label <code>NaN</code>.
</p>
<p>The algorithm is not garantueed to produce the given number of clusters, given in nClusters. The found number of clusters can be lower, depending on the data and input parameters.
</p>


<h3>Value</h3>

<table>
<tr><td><code>labels</code></td>
<td>
<p>[1:n] Numeric vector, containing the labels for the input data points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Brinkmann
</p>


<h3>References</h3>

<p>[Lux and Rinderle-Ma, 2023] Lux, M., Rinderle-Ma, S.: DDCAL: Evenly Distributing Data into Low Variance Clusters Based on Iterative Feature Scaling; Springer Journal of Classification, Vol. 40, pp. 106-144, DOI: <a href="https://doi.org/10.1007/s00357-022-09428-6">doi:10.1007/s00357-022-09428-6</a>, 2023.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load data
if(requireNamespace("FCPS")){
data(EngyTime, package = "FCPS")
engyTimeData = EngyTime$Data
c1 = engyTimeData[,1]
c2 = engyTimeData[,2]
}else{
c1 = rnorm(n=4000)
c2 = rnorm(n=4000,1,2)
}
# Calculate Densities

densities = SmoothedDensitiesXY(c1,c2)$Densities
# Use DDCAL to cluster the densities
labels = DDCAL(densities, 9)

# Plot Densities according to labels
my_colors = c("#000066", "#3333CC", "#9999FF", "#00FFFF", "#66FF33",
                       "#FFFF00", "#FF9900", "#FF0000", "#990000")
labels = as.factor(labels)
df = data.frame(c1, c2, labels)

if(requireNamespace("ggplot2")){
ggplot2::ggplot(df, ggplot2::aes(c1, c2, color = labels)) +
  ggplot2::geom_point() +
  ggplot2::scale_color_manual(values = my_colors)
}

</code></pre>

<hr>
<h2 id='DensityScatter.DDCAL'>
Scatter density plot [Brinkmann et al., 2023]
</h2><span id='topic+DensityScatter.DDCAL'></span>

<h3>Description</h3>

<p>Density estimation (PDE) [Ultsch, 2005] or &quot;SDH&quot; [Eilers/Goeman, 2004] used for a scatter density plot, with clustering of densities with DDCAL [Lux/Rinderle-Ma, 2023] proposed by [Brinkmann et al., 2023].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DensityScatter.DDCAL(X, Y, nClusters = 12, Plotter = "native", 
SDHorPDE = TRUE, PDEsample = 5000,
Marginals = FALSE, na.rm=TRUE,
pch = 10, Size = 1, 
xlab="x", ylab="y", main = "",lwd = 2,
xlim=NULL,ylim=NULL,Polygon,BW = TRUE,Silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DensityScatter.DDCAL_+3A_x">X</code></td>
<td>

<p>Numeric vector [1:n], first feature (for x axis values)
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_y">Y</code></td>
<td>

<p>Numeric vector [1:n], second feature (for y axis values)
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_nclusters">nClusters</code></td>
<td>

<p>Integer defining the number of clusters (colors) used for finding a hard color
transition.
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_plotter">Plotter</code></td>
<td>

<p>(Optional) String, name of the plotting backend to use. Possible values are: &quot;<code>native</code>&quot; or &quot;<code>ggplot2</code>&quot;
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_sdhorpde">SDHorPDE</code></td>
<td>

<p>(Optional) Boolean, if TRUE SDH is used to calculate density, if FALSE PDE is used
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_pdesample">PDEsample</code></td>
<td>

<p>(Optional) Scalar, Sample size for PDE and/or for ggplot2 plotting. Default is 5000
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_marginals">Marginals</code></td>
<td>

<p>(Optional) Boolean, if TRUE the marginal distributions of X and Y will be plotted together with the 2D density of X and Y. Default is FALSE
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_na.rm">na.rm</code></td>
<td>

<p>(Optional) Boolean, if TRUE non finite values will be removed
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_pch">pch</code></td>
<td>

<p>(Optional) Scalar or character. Indicates the shape of data points, see <code>plot()</code> function or the <code>shape</code> argument in ggplot2. Default is 10
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_size">Size</code></td>
<td>

<p>(Optional) Scalar, size of data points in plot, default is 1
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_xlab">xlab</code></td>
<td>

<p>String, title of the x axis. Default: &quot;X&quot;,   see <code>plot()</code> function
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_ylab">ylab</code></td>
<td>

<p>String, title of the y axis. Default: &quot;Y&quot;,   see <code>plot()</code> function
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_main">main</code></td>
<td>

<p>(Optional)  Character, title of the plot. [1:2] 
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_lwd">lwd</code></td>
<td>

<p>(Optional) Scalar, thickness of the lines used for the marginal distributions (only needed if <code>Marginals=TRUE</code>), see <code>plot()</code>. Default = 2
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_xlim">xlim</code></td>
<td>

<p>(Optional) numerical vector, min and max of x values to be plottet
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_ylim">ylim</code></td>
<td>

<p>(Optional) numerical vector, min and max of y values to be plottet
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_polygon">Polygon</code></td>
<td>

<p>(Optional) [1:p,1:2] numeric matrix that defines for x and y coordinates a polygon in magenta
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_bw">BW</code></td>
<td>

<p>(Optional) Boolean, if TRUE ggplot2 will use a white background, if FALSE the typical ggplot2 backgournd is used. Not needed if &quot;<code>native</code>&quot; as Plotter is used. Default is TRUE
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_silent">Silent</code></td>
<td>

<p>(Optional) Boolean, if TRUE no messages will be printed, default is FALSE
</p>
</td></tr>
<tr><td><code id="DensityScatter.DDCAL_+3A_...">...</code></td>
<td>

<p>Further plot arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>DensityScatter.DDCAL</code> function generates the density of the xy data as a z coordinate. Afterwards xyz will be plotted as a contour plot. It assumens that the cases of x and y are mapped to each other meaning that a <code>cbind(x,y)</code> operation is allowed.
The colors for the densities in the contour plot are calculated with DDCAL, which produces clusters to evenly distribute the densities in low variance clusters.
</p>
<p>In the case of &quot;<code>native</code>&quot; as Plotter, the handle returns <code>NULL</code> because the basic R functon <code>plot</code>() is used
</p>


<h3>Value</h3>

<p>If &quot;<code>ggplot2</code>&quot; as Plotter is used, the ggobj is returned
</p>


<h3>Note</h3>

<p>Support for plotly will be implemented later
</p>


<h3>Author(s)</h3>

<p>Luca Brinkmann, Michael Thrun
</p>


<h3>References</h3>

<p>[Ultsch, 2005]  Ultsch, A.: Pareto density estimation: A density estimation for knowledge discovery, In Baier, D. &amp; Werrnecke, K. D. (Eds.), Innovations in classification, data science, and information systems, (Vol. 27, pp. 91-100), Berlin, Germany, Springer, 2005.
</p>
<p>[Eilers/Goeman, 2004]  Eilers, P. H., &amp; Goeman, J. J.: Enhancing scatterplots with smoothed densities, Bioinformatics, Vol. 20(5), pp. 623-628. 2004.
</p>
<p>[Lux/Rinderle-Ma, 2023]  Lux, M. &amp; Rinderle-Ma, S.: DDCAL: Evenly Distributing Data into Low Variance Clusters Based on Iterative Feature Scaling, Journal of Classification vol. 40, pp. 106-144, 2023.
</p>
<p>[Brinkmann et al., 2023]  Brinkmann, L., Stier, Q., &amp; Thrun, M. C.: Computing Sensitive Color Transitions for the Identification of Two-Dimensional Structures, Proc. Data Science, Statistics &amp; Visualisation (DSSV) and the European Conference on Data Analysis (ECDA), p.109, Antwerp, Belgium, July 5-7, 2023. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Create two bimodial distributions
x1=rnorm(n = 7500,mean = 0,sd = 1)
y1=rnorm(n = 7500,mean = 0,sd = 1)
x2=rnorm(n = 7500,mean = 2.5,sd = 1)
y2=rnorm(n = 7500,mean = 2.5,sd = 1)
x=c(x1,x2)
y=c(y1,y2)

DensityScatter.DDCAL(x, y, Marginals = TRUE)

</code></pre>

<hr>
<h2 id='inPSphere2D'>2D data points in Pareto Sphere</h2><span id='topic+inPSphere2D'></span>

<h3>Description</h3>

<p>This function determines the 2D data points inside a ParetoSphere with ParetoRadius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inPSphere2D(data, paretoRadius=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inPSphere2D_+3A_data">data</code></td>
<td>
<p>numeric matrix of data.</p>
</td></tr>
<tr><td><code id="inPSphere2D_+3A_paretoradius">paretoRadius</code></td>
<td>
<p>numeric value. radius of P-spheres. If not given, calculate by the function 'paretoRad' </p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with the number of data points inside a P-sphere with ParetoRadius.
</p>


<h3>Author(s)</h3>

<p>Felix Pape</p>

<hr>
<h2 id='PDEscatter'>Scatter Density Plot</h2><span id='topic+PDEscatter'></span>

<h3>Description</h3>

<p>Concept of Pareto density estimation (PDE) proposed for univsariate data by [Ultsch, 2005] and comparet to varius density estimation techniques by [Thrun et al., 2020] for univariate data is here applied for a scatter density plot. It was also applied in [Thrun and Ultsch, 2018] to bivariate data, but is not yet compared to other techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PDEscatter(x,y,SampleSize,

na.rm=FALSE,PlotIt=TRUE,ParetoRadius,sampleParetoRadius,
                              
NrOfContourLines=20,Plotter='native', DrawTopView = TRUE,
                              
xlab="X", ylab="Y", main="PDEscatter",
                              
xlim, ylim, Legendlab_ggplot="value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PDEscatter_+3A_x">x</code></td>
<td>
<p>Numeric vector [1:n], first feature (for x axis values)</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_y">y</code></td>
<td>
<p>Numeric vector [1:n], second feature (for y axis values)</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_samplesize">SampleSize</code></td>
<td>
<p>Numeric m, positiv scalar, maximum size of the sample used for calculation. High values increase runtime significantly. The default is that no sample is drawn</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_na.rm">na.rm</code></td>
<td>
<p>Function may not work with non finite values. If these cases should be automatically removed, set parameter TRUE</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_paretoradius">ParetoRadius</code></td>
<td>
<p>Numeric, positiv scalar, the Pareto Radius. If omitted (or 0), calculate by paretoRad.</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_sampleparetoradius">sampleParetoRadius</code></td>
<td>
<p>Numeric, positiv scalar, maximum size of the sample used for estimation of &quot;kernel&quot;, should be significantly lower than SampleSize because requires distance computations which is memory expensive</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_plotit">PlotIt</code></td>
<td>
<p><code>TRUE</code>: plots with function call
</p>
<p><code>FALSE</code>: Does not plot, plotting can be done using the list element <code>Handle</code>
</p>
<p><code>-1</code>: Computes density only, does not perfom any preperation for plotting meaning that <code>Handle=NULL</code>
</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_nrofcontourlines">NrOfContourLines</code></td>
<td>
<p>Numeric, number of contour lines to be drawn. 20 by default.</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_plotter">Plotter</code></td>
<td>
<p>String, name of the plotting backend to use. Possible values are: &quot;<code>native</code>&quot;, &quot;<code>ggplot</code>&quot;, &quot;<code>plotly</code>&quot;</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_drawtopview">DrawTopView</code></td>
<td>
<p>Boolean, True means contur is drawn, otherwise a 3D plot is drawn. Default: TRUE</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_xlab">xlab</code></td>
<td>
<p>String, title of the x axis. Default: &quot;X&quot;,   see <code>plot()</code> function</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_ylab">ylab</code></td>
<td>
<p>String, title of the y axis. Default: &quot;Y&quot;,   see <code>plot()</code> function</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_main">main</code></td>
<td>

<p>string, the same as &quot;main&quot; in <code>plot()</code> function
</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_xlim">xlim</code></td>
<td>

<p>see <code>plot()</code> function
</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_ylim">ylim</code></td>
<td>

<p>see <code>plot()</code> function
</p>
</td></tr>
<tr><td><code id="PDEscatter_+3A_legendlab_ggplot">Legendlab_ggplot</code></td>
<td>
<p>String, in case of <code>Plotter="ggplot"</code> label for the legend. Default: &quot;value&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>PDEscatter</code> function generates the density of the xy data as a z coordinate. Afterwards xyz will be plotted either as a contour plot or a 3d plot. It assumens that the cases of x and y are mapped to each other meaning that a <code>cbind(x,y)</code> operation is allowed.
This function plots the PDE on top of a scatterplot. Variances of x and y should not differ by extreme numbers, otherwise calculate the percentiles on both first. If <code>DrawTopView=FALSE</code> only the plotly option is currently available. If another option is chosen, the method switches automatically there.
</p>
<p>The method was succesfully used in [Thrun, 2018; Thrun/Ultsch 2018].
</p>
<p><code>PlotIt=FALSE</code> is usefull if one likes to perform adjustements like axis scaling prior to plotting with <span class="pkg">ggplot2</span> or  <span class="pkg">plotly</span>. In the case of &quot;<code>native</code>&quot;&quot; the handle returns <code>NULL</code> because the basic R functon <code>plot</code>() is used
</p>


<h3>Value</h3>

<p>List of:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>Numeric vector [1:m],m&lt;=n, first feature used in the plot or the kernels used</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Numeric vector [1:m],m&lt;=n, second feature used in the plot or the kernels used</p>
</td></tr>
<tr><td><code>Densities</code></td>
<td>
<p>Numeric vector [1:m],m&lt;=n, Number of points within the ParetoRadius of each point, i.e. density information</p>
</td></tr>
<tr><td><code>Matrix3D</code></td>
<td>
<p>1:n,1:3] marix of x,y and density information</p>
</td></tr>
<tr><td><code>ParetoRadius</code></td>
<td>
<p>ParetoRadius used for PDEscatter</p>
</td></tr>
<tr><td><code>Handle</code></td>
<td>
<p>Handle of the plot object. Information-string if native R plot is used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>MT contributed with several adjustments
</p>


<h3>Author(s)</h3>

<p>Felix Pape</p>


<h3>References</h3>

<p>[Thrun/Ultsch, 2018] Thrun, M. C., &amp; Ultsch, A. : Effects of the payout system of income taxes to municipalities in Germany, in Papiez, M. &amp; Smiech,, S. (eds.), Proc. 12th Professor Aleksander Zelias International Conference on Modelling and Forecasting of Socio-Economic Phenomena, pp. 533-542, Cracow: Foundation of the Cracow University of Economics, Cracow, Poland, 2018. 
</p>
<p>[Ultsch, 2005]  Ultsch, A.: Pareto density estimation: A density estimation for knowledge discovery, In Baier, D. &amp; Werrnecke, K. D. (Eds.), Innovations in classification, data science, and information systems, (Vol. 27, pp. 91-100), Berlin, Germany, Springer, 2005.
</p>
<p>[Thrun et al., 2020] Thrun, M. C., Gehlert, T. &amp; Ultsch, A.: Analyzing the Fine Structure of Distributions, PLoS ONE, Vol. 15(10), pp. 1-66, DOI <a href="https://doi.org/10.1371/journal.pone.0238835">doi:10.1371/journal.pone.0238835</a>, 2020. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#taken from [Thrun/Ultsch, 2018]
if(requireNamespace("DataVisualizations")){
data("ITS",package = "DataVisualizations")
data("MTY",package = "DataVisualizations")
Inds=which(ITS&lt;900&amp;MTY&lt;8000)
plot(ITS[Inds],MTY[Inds],main='Bimodality is not visible in normal scatter plot')


PDEscatter(ITS[Inds],MTY[Inds],xlab = 'ITS in EUR',

ylab ='MTY in EUR' ,main='Pareto Density Estimation indicates Bimodality' )


}
</code></pre>

<hr>
<h2 id='PointsInPolygon'>
PointsInPolygon
</h2><span id='topic+PointsInPolygon'></span>

<h3>Description</h3>

<p>Defines a Cls based on points in a given polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PointsInPolygon(Points, Polygon, PlotIt = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PointsInPolygon_+3A_points">Points</code></td>
<td>

<p>[1:n,1:2] xy cartesian coordinates of a projection
</p>
</td></tr>
<tr><td><code id="PointsInPolygon_+3A_polygon">Polygon</code></td>
<td>

<p>Numerical matrix of 2 columns defining a closed polygon
</p>
</td></tr>
<tr><td><code id="PointsInPolygon_+3A_plotit">PlotIt</code></td>
<td>

<p>TRUE: Plots marked points
</p>
</td></tr>
<tr><td><code id="PointsInPolygon_+3A_...">...</code></td>
<td>

<p><code>BMUorProjected</code>: Default == FALSE, If TRUE assuming BestMatches of ESOM instead of Projected Points
</p>
<p><code>main</code>: title of plot
</p>
<p>Further Plotting Arguments,xlab etc used in <code><a href="DataVisualizations.html#topic+Classplot">Classplot</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that polygon is closed, i.e., that the last point connects to the fist point
</p>


<h3>Value</h3>

<p>Numerical classification vector Cls with 1 = outside polygon and 2 = inside polygon
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>See Also</h3>

<p><code><a href="DataVisualizations.html#topic+Classplot">Classplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY=cbind(runif(80,min = -1,max = 1),rnorm(80))
#closed polygon
polymat &lt;- cbind(x = c(0,1,1,0), y = c(0,0,1,1))
#takes sometimes more than 5 sec

Cls=PointsInPolygon(XY,polymat,PlotIt = TRUE)

</code></pre>

<hr>
<h2 id='PolygonGate'>
PolygonGate
</h2><span id='topic+PolygonGate'></span>

<h3>Description</h3>

<p>A specific Gate defined by xy coordinates that result in a closed polygon is applied to the flowcytometry data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PolygonGate(Data, Polygon, GateVars,  PlotIt = FALSE, PlotSampleSize = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PolygonGate_+3A_data">Data</code></td>
<td>

<p>numerical matrix n x d
</p>
</td></tr>
<tr><td><code id="PolygonGate_+3A_polygon">Polygon</code></td>
<td>

<p>numerical marix of two columns defining the coordiantes of the polygon. polygon assumed to be closed, i.e.,last coordinate connects to first coordinate.
</p>
</td></tr>
<tr><td><code id="PolygonGate_+3A_gatevars">GateVars</code></td>
<td>

<p>vector, either column index in Data of X and Y coordinates of gate or its variable names as string
</p>
</td></tr>
<tr><td><code id="PolygonGate_+3A_plotit">PlotIt</code></td>
<td>

<p>if TRUE: plots a sample of data in the two selected variables and marks point inside the gate as yellow and outside as magenta
</p>
</td></tr>
<tr><td><code id="PolygonGate_+3A_plotsamplesize">PlotSampleSize</code></td>
<td>

<p>size pof the plottet sample
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gates are alwaxs two dimensional, i.e., require two filters, although all dimensions of data are filted by the gates. Only high-dimensional points inside the polygon (gate) are given back
</p>


<h3>Value</h3>

<p>list of
</p>
<table>
<tr><td><code>DataInGate</code></td>
<td>
<p>m x d numerical matrix with m&lt;=n of data points inside the gate</p>
</td></tr>
<tr><td><code>InGateInd</code></td>
<td>
<p>index of length m for the datapoints in original matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p>if GateVars is not found a text is given back which will state this issue
</p>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PointsInPolygon">PointsInPolygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Data &lt;- matrix(runif(1000), ncol = 10)
colnames(Data)=paste0("GateVar",1:ncol(Data))
poly &lt;- cbind(x = c(0.2,0.5,0.8), y = c(0.2,0.8,0.2))
#set PlotIt TRUE for understanding the example


#Select index
V=PolygonGate(Data,poly,c(5,8),PlotIt=FALSE,100)

#select var name
V=PolygonGate(Data,poly,c("GateVar5","GateVar8"),PlotIt=FALSE,100)

</code></pre>

<hr>
<h2 id='SmoothedDensitiesXY'>
Smoothed Densities X with Y
</h2><span id='topic+SmoothedDensitiesXY'></span>

<h3>Description</h3>

<p>Density is the smothed histogram density at [X,Y] of [Eilers/Goeman, 2004]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SmoothedDensitiesXY(X, Y, nbins, lambda, Xkernels, Ykernels, PlotIt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SmoothedDensitiesXY_+3A_x">X</code></td>
<td>

<p>Numeric vector [1:n], first feature (for x axis values)
</p>
</td></tr>
<tr><td><code id="SmoothedDensitiesXY_+3A_y">Y</code></td>
<td>

<p>Numeric vector [1:n], second feature (for y axis values),
nbins= nxy      =&gt; the nr of bins in x and y is nxy
nbins = c(nx,ny) =&gt; the nr of bins in x is nx and for y is ny
</p>
</td></tr>
<tr><td><code id="SmoothedDensitiesXY_+3A_nbins">nbins</code></td>
<td>

<p>number of bins, nbins =200 (default)
</p>
</td></tr>
<tr><td><code id="SmoothedDensitiesXY_+3A_lambda">lambda</code></td>
<td>

<p>smoothing factor used by the density estimator or c()
default: lambda = 20 which roughly  means that the smoothing is over 20 bins around a given point.
</p>
</td></tr>
<tr><td><code id="SmoothedDensitiesXY_+3A_xkernels">Xkernels</code></td>
<td>

<p>bin kernels in x direction are given
</p>
</td></tr>
<tr><td><code id="SmoothedDensitiesXY_+3A_ykernels">Ykernels</code></td>
<td>

<p>bin kernels y direction are given
</p>
</td></tr>
<tr><td><code id="SmoothedDensitiesXY_+3A_plotit">PlotIt</code></td>
<td>

<p>FALSE: no plotting, TRUE: simple plot
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>lambda has to chosen by the user and is a sensitive parameter.
</p>


<h3>Value</h3>

<p>List of:
</p>
<table>
<tr><td><code>Densities</code></td>
<td>
<p>numeric vector [1:n] is the smothed density in 3D  </p>
</td></tr>
<tr><td><code>Xkernels</code></td>
<td>
<p>numeric vector [1:nx], nx defined by <code>nbins</code>, such that mesh(Xkernels,Ykernels,F) form the ( not NaN) smothed densisties</p>
</td></tr>
<tr><td><code>Ykernels</code></td>
<td>
<p>numeric vector [1:ny], nx defined by <code>nbins</code>, such that mesh(Xkernels,Ykernels,F) form the ( not NaN) smothed densisties</p>
</td></tr>
<tr><td><code>hist_F_2D</code></td>
<td>
<p>matrix [1:nx,1:ny] beeing the smoothed 2D histogram </p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>an index such that <code>Densities = hist_F_2D[ind]</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Thrun
</p>


<h3>References</h3>

<p>[Eilers/Goeman, 2004]  Eilers, P. H., &amp; Goeman, J. J.: Enhancing scatterplots with smoothed densities, Bioinformatics, Vol. 20(5), pp. 623-628.DOI: <a href="https://doi.org/10.1093/bioinformatics/btg454">doi:10.1093/bioinformatics/btg454</a>, 2004.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



if(requireNamespace("DataVisualizations")){
data("ITS",package = "DataVisualizations")
data("MTY",package = "DataVisualizations")
Inds=which(ITS&lt;900&amp;MTY&lt;8000)
V=SmoothedDensitiesXY(ITS[Inds],MTY[Inds])
}else{
#sample random data
ITS=rnorm(1000)
MTY=rnorm(1000)
V=SmoothedDensitiesXY(ITS,MTY)
}



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
