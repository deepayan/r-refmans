<!DOCTYPE html><html><head><title>Help for package geojson</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geojson}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geojson-package'><p>geojson</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#as.geojson'><p>Geojson class</p></a></li>
<li><a href='#bbox'><p>Add or get bounding box</p></a></li>
<li><a href='#crs'><p>Add or get CRS</p></a></li>
<li><a href='#feature'><p>feature class</p></a></li>
<li><a href='#featurecollection'><p>featurecollection class</p></a></li>
<li><a href='#geo_bbox'><p>Calculate a bounding box</p></a></li>
<li><a href='#geo_pretty'><p>Pretty print geojson</p></a></li>
<li><a href='#geo_type'><p>Get geometry type</p></a></li>
<li><a href='#geo_write'><p>Write geojson to disk</p></a></li>
<li><a href='#geobuf'><p>Geobuf serialization</p></a></li>
<li><a href='#geojson_data'><p>Data for use in examples</p></a></li>
<li><a href='#geometrycollection'><p>geometrycollection class</p></a></li>
<li><a href='#linestring'><p>linestring class</p></a></li>
<li><a href='#linting_opts'><p>GeoJSON Linting</p></a></li>
<li><a href='#multilinestring'><p>multilinestring class</p></a></li>
<li><a href='#multipoint'><p>multipoint class</p></a></li>
<li><a href='#multipolygon'><p>multipolygon class</p></a></li>
<li><a href='#ndgeo'><p>Read and write newline-delimited GeoJSON (GeoJSON text sequences)</p></a></li>
<li><a href='#point'><p>point class</p></a></li>
<li><a href='#polygon'><p>polygon class</p></a></li>
<li><a href='#properties'><p>Add or get properties</p></a></li>
<li><a href='#to_geojson'><p>Convert GeoJSON character string to approriate GeoJSON class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Classes for 'GeoJSON'</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes for 'GeoJSON' to make working with 'GeoJSON' easier.
    Includes S3 classes for 'GeoJSON' classes with brief summary output,
    and a few methods such as extracting and adding bounding boxes,
    properties, and coordinate reference systems; working with 
    newline delimited 'GeoJSON'; and serializing to/from 'Geobuf' binary 'GeoJSON' 
    format.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/geojson/">https://docs.ropensci.org/geojson/</a>,
<a href="https://github.com/ropensci/geojson">https://github.com/ropensci/geojson</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/geojson/issues">https://github.com/ropensci/geojson/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, sp, jsonlite (&ge; 1.6), protolite (&ge; 1.8), jqr (&ge;
1.1.0), magrittr, lazyeval</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tibble, testthat, knitr, rmarkdown, sf, stringi, covr</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Geospatial</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>geojson, geospatial, conversion, data,
input-output, bbox, polygon, geobuf</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-25 03:38:39 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jeroen Ooms [aut],
  Michael Sumner [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='geojson-package'>geojson</h2><span id='topic+geojson-package'></span><span id='topic+geojson'></span>

<h3>Description</h3>

<p>Classes for GeoJSON to make working with GeoJSON easier
</p>


<h3>Package API</h3>

<p>GeoJSON objects:
</p>

<ul>
<li> <p><code><a href="#topic+feature">feature</a></code> - Feature
</p>
</li>
<li> <p><code><a href="#topic+featurecollection">featurecollection</a></code> - FeatureCollection
</p>
</li>
<li> <p><code><a href="#topic+geometrycollection">geometrycollection</a></code> - GeometryCollection
</p>
</li>
<li> <p><code><a href="#topic+linestring">linestring</a></code> - LineString
</p>
</li>
<li> <p><code><a href="#topic+multilinestring">multilinestring</a></code> - MultiLineString
</p>
</li>
<li> <p><code><a href="#topic+multipoint">multipoint</a></code> - MultiPoint
</p>
</li>
<li> <p><code><a href="#topic+multipolygon">multipolygon</a></code> - MultiPolygon
</p>
</li>
<li> <p><code><a href="#topic+point">point</a></code> - Point
</p>
</li>
<li> <p><code><a href="#topic+polygon">polygon</a></code> - Polygon
</p>
</li></ul>

<p>The above are assigned two classes. All of them are class <strong>geojson</strong>,
but also have a class name that is <strong>geo</strong> plus the name of
the geometry, e.g., <strong>geopolygon</strong> for polygon.
</p>
<p>GeoJSON properties:
</p>

<ul>
<li> <p><code><a href="#topic+properties_add">properties_add</a></code>, <code><a href="#topic+properties_get">properties_get</a></code> - Add
or get properties
</p>
</li>
<li> <p><code><a href="#topic+crs_add">crs_add</a></code>, <code><a href="#topic+crs_get">crs_get</a></code> - Add or get CRS
</p>
</li>
<li> <p><code><a href="#topic+bbox_add">bbox_add</a></code>, <code><a href="#topic+bbox_get">bbox_get</a></code> - Add or get
bounding box
</p>
</li></ul>

<p>GeoJSON operations:
</p>

<ul>
<li> <p><code><a href="#topic+geo_bbox">geo_bbox</a></code> - calculate a bounding box for any GeoJSON
object
</p>
</li>
<li> <p><code><a href="#topic+geo_pretty">geo_pretty</a></code> - pretty print any GeoJSON object
</p>
</li>
<li> <p><code><a href="#topic+geo_type">geo_type</a></code> - get the object type for any GeoJSON
object
</p>
</li>
<li> <p><code><a href="#topic+geo_write">geo_write</a></code> - easily write any GeoJSON to a file
</p>
</li>
<li><p> More complete GeoJSON operations are provdied in the package
<span class="pkg">geoops</span>
</p>
</li></ul>

<p>GeoJSON/Geobuf serialization:
</p>

<ul>
<li> <p><code><a href="#topic+from_geobuf">from_geobuf</a></code> - Geobuf to GeoJSON
</p>
</li>
<li> <p><code><a href="#topic+to_geobuf">to_geobuf</a></code> - GeoJSON to Geobuf
</p>
</li>
<li><p> Check out <a href="https://github.com/mapbox/geobuf">https://github.com/mapbox/geobuf</a> for inormation on
the Geobuf format
</p>
</li></ul>



<h3>Coordinate Reference System</h3>

<p>According to RFC 7946
(<a href="https://datatracker.ietf.org/doc/html/rfc7946#page-12">https://datatracker.ietf.org/doc/html/rfc7946#page-12</a>) the CRS for all GeoJSON
objects must be WGS-84, equivalent to <code>urn:ogc:def:crs:OGC::CRS84</code>.
And lat/long must be in decimal degrees.
</p>
<p>Given the above, but considering that GeoJSON blobs exist that have CRS
attributes in them, we provide CRS helpers in this package. But moving
forward these are not likely to be used much.
</p>


<h3>Coordinate precision</h3>

<p>According to RFC 7946 (<a href="https://datatracker.ietf.org/doc/html/rfc7946#section-11.2">https://datatracker.ietf.org/doc/html/rfc7946#section-11.2</a>)
consider that 6 decimal places amoutns to ~10 centimeters, a precision
well within that of current GPS sytems. Further, A GeoJSON text containing
many detailed Polygons can be inflated almost by a factor of two by
increasing coordinate precision from 6 to 15 decimal places - so consider
whether it is worth it to have more decimal places.
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain, Jeroen Ooms
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='as.geojson'>Geojson class</h2><span id='topic+as.geojson'></span><span id='topic+as.geojson+2Cjson-method'></span><span id='topic+as.geojson+2Cgeojson-method'></span><span id='topic+as.geojson+2Ccharacter-method'></span><span id='topic+as.geojson+2CSpatialPointsDataFrame-method'></span><span id='topic+as.geojson+2CSpatialPoints-method'></span><span id='topic+as.geojson+2CSpatialLinesDataFrame-method'></span><span id='topic+as.geojson+2CSpatialLines-method'></span><span id='topic+as.geojson+2CSpatialPolygonsDataFrame-method'></span><span id='topic+as.geojson+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Geojson class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.geojson(x)

## S4 method for signature 'json'
as.geojson(x)

## S4 method for signature 'geojson'
as.geojson(x)

## S4 method for signature 'character'
as.geojson(x)

## S4 method for signature 'SpatialPointsDataFrame'
as.geojson(x)

## S4 method for signature 'SpatialPoints'
as.geojson(x)

## S4 method for signature 'SpatialLinesDataFrame'
as.geojson(x)

## S4 method for signature 'SpatialLines'
as.geojson(x)

## S4 method for signature 'SpatialPolygonsDataFrame'
as.geojson(x)

## S4 method for signature 'SpatialPolygons'
as.geojson(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.geojson_+3A_x">x</code></td>
<td>
<p>input, an object of class character, json, SpatialPoints,
SpatialPointsDataFrame, SpatialLines, SpatialLinesDataFrame,
SpatialPolygons, or SpatialPolygonsDataFrame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print.geojson</code> method prints the geojson geometry
type, the bounding box, number of features (if applicable), and the
geometries and their lengths
</p>


<h3>Value</h3>

<p>an object of class geojson/json
</p>


<h3>Examples</h3>

<pre><code class='language-R'># character
as.geojson(geojson_data$featurecollection_point)
as.geojson(geojson_data$polygons_average)
as.geojson(geojson_data$polygons_aggregate)
as.geojson(geojson_data$points_count)

# sp classes

## SpatialPoints
library(sp)
x &lt;- c(1,2,3,4,5)
y &lt;- c(3,2,5,1,4)
s &lt;- SpatialPoints(cbind(x,y))
as.geojson(s)

## SpatialPointsDataFrame
s &lt;- SpatialPointsDataFrame(cbind(x,y), mtcars[1:5,])
as.geojson(s)

## SpatialLines
L1 &lt;- Line(cbind(c(1,2,3), c(3,2,2)))
L2 &lt;- Line(cbind(c(1.05,2.05,3.05), c(3.05,2.05,2.05)))
L3 &lt;- Line(cbind(c(1,2,3),c(1,1.5,1)))
Ls1 &lt;- Lines(list(L1), ID = "a")
Ls2 &lt;- Lines(list(L2, L3), ID = "b")
sl1 &lt;- SpatialLines(list(Ls1))
as.geojson(sl1)

## SpatialLinesDataFrame
sl12 &lt;- SpatialLines(list(Ls1, Ls2))
dat &lt;- data.frame(X = c("Blue", "Green"),
                  Y = c("Train", "Plane"),
                  Z = c("Road", "River"), row.names = c("a", "b"))
sldf &lt;- SpatialLinesDataFrame(sl12, dat)
as.geojson(sldf)

## SpatialPolygons
poly1 &lt;- Polygons(list(Polygon(cbind(c(-100,-90,-85,-100),
   c(40,50,45,40)))), "1")
poly2 &lt;- Polygons(list(Polygon(cbind(c(-90,-80,-75,-90),
   c(30,40,35,30)))), "2")
sp_poly &lt;- SpatialPolygons(list(poly1, poly2), 1:2)
as.geojson(sp_poly)

## SpatialPolygonsDataFrame
sp_polydf &lt;- as(sp_poly, "SpatialPolygonsDataFrame")
as.geojson(sp_polydf)

## sf objects
if (requireNamespace('sf')) {
  nc &lt;- sf::st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
  as.geojson(nc)
}

</code></pre>

<hr>
<h2 id='bbox'>Add or get bounding box</h2><span id='topic+bbox'></span><span id='topic+bbox_add'></span><span id='topic+bbox_get'></span>

<h3>Description</h3>

<p>Add or get bounding box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox_add(x, bbox = NULL)

bbox_get(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox_+3A_x">x</code></td>
<td>
<p>An object of class <code>geojson</code></p>
</td></tr>
<tr><td><code id="bbox_+3A_bbox">bbox</code></td>
<td>
<p>(numeric) a vector or list of length 4 for a 2D bounding box
or length 6 for a 3D bounding box. If <code>NULL</code>, the bounding box is
calculated for you</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>bbox_get</code> outputs the bbox if it exists, but
does not calculate it from the geojson. See <code><a href="#topic+geo_bbox">geo_bbox</a></code>
to calculate a bounding box. Bounding boxes can be 2D or 3D.
</p>


<h3>Value</h3>


<ul>
<li><p> bbox_add: an object of class jqson/character from <span class="pkg">jqr</span>
</p>
</li>
<li><p> bbox_get: a bounding box, of the form
<code>[west, south, east, north]</code> for 2D or of the form
<code>[west, south, min-altitude, east, north, max-altitude]</code> for 3D
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://datatracker.ietf.org/doc/html/rfc7946#section-5">https://datatracker.ietf.org/doc/html/rfc7946#section-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a polygon
x &lt;- '{ "type": "Polygon",
"coordinates": [
  [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]
  ]
}'
(y &lt;- polygon(x))

# add bbox - without an input, we figure out the 2D bbox for you
y %&gt;% feature() %&gt;% bbox_add()
## 2D bbox
y %&gt;% feature() %&gt;% bbox_add(c(100.0, -10.0, 105.0, 10.0))
## 3D bbox
y %&gt;% feature() %&gt;% bbox_add(c(100.0, -10.0, 3, 105.0, 10.0, 17))

# get bounding box
z &lt;- y %&gt;% feature() %&gt;% bbox_add()
bbox_get(z)

## returns NULL if no bounding box
bbox_get(x)
</code></pre>

<hr>
<h2 id='crs'>Add or get CRS</h2><span id='topic+crs'></span><span id='topic+crs_add'></span><span id='topic+crs_get'></span>

<h3>Description</h3>

<p>Add or get CRS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crs_add(x, crs)

crs_get(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crs_+3A_x">x</code></td>
<td>
<p>An object of class <code>geojson</code></p>
</td></tr>
<tr><td><code id="crs_+3A_crs">crs</code></td>
<td>
<p>(character) a CRS string. required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to RFC 7946
(<a href="https://datatracker.ietf.org/doc/html/rfc7946#page-12">https://datatracker.ietf.org/doc/html/rfc7946#page-12</a>) the CRS for all GeoJSON
objects must be WGS-84, equivalent to <code>urn:ogc:def:crs:OGC::CRS84</code>.
And lat/long must be in decimal degrees.
</p>
<p>Given the above, but considering that GeoJSON blobs exist that have CRS
attributes in them, we provide CRS helpers here. But moving forward
these are not likely to be used much.
</p>


<h3>References</h3>

<p><a href="https://github.com/OSGeo/PROJ">https://github.com/OSGeo/PROJ</a>,
<a href="https://geojson.org/geojson-spec.html#coordinate-reference-system-objects">https://geojson.org/geojson-spec.html#coordinate-reference-system-objects</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{ "type": "Polygon",
"coordinates": [
  [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]
  ]
}'

# add crs
crs &lt;- '{"type": "name",
 "properties": {
     "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
}}'
x %&gt;% feature() %&gt;% crs_add(crs)

# get crs
z &lt;- x %&gt;% feature() %&gt;% crs_add(crs)
crs_get(z)
</code></pre>

<hr>
<h2 id='feature'>feature class</h2><span id='topic+feature'></span>

<h3>Description</h3>

<p>feature class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Feature objects:
</p>

<ul>
<li><p> A feature object must have a member with the name &quot;geometry&quot;. The
value of the geometry member is a geometry object as defined above or a
JSON null value.
</p>
</li>
<li><p> A feature object must have a member with the name &quot;properties&quot;. The
value of the properties member is an object (any JSON object or a JSON
null value).
</p>
</li>
<li><p> If a feature has a commonly used identifier, that identifier should
be included as a member of the feature object with the name &quot;id&quot;.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># point -&gt; feature
x &lt;- '{ "type": "Point", "coordinates": [100.0, 0.0] }'
point(x) %&gt;% feature()

# multipoint -&gt; feature
x &lt;- '{"type": "MultiPoint", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ] }'
multipoint(x) %&gt;% feature()

# linestring -&gt; feature
x &lt;- '{ "type": "LineString", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ] }'
linestring(x) %&gt;% feature()

# multilinestring -&gt; feature
x &lt;- '{ "type": "MultiLineString",
 "coordinates": [ [ [100.0, 0.0], [101.0, 1.0] ], [ [102.0, 2.0], [103.0, 3.0] ] ] }'
multilinestring(x) %&gt;% feature()

# add to a data.frame
library('tibble')
tibble(a = 1:5, b = list(multilinestring(x)))
</code></pre>

<hr>
<h2 id='featurecollection'>featurecollection class</h2><span id='topic+featurecollection'></span>

<h3>Description</h3>

<p>featurecollection class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>featurecollection(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="featurecollection_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("examples", 'featurecollection1.geojson',
  package = "geojson")
file &lt;- system.file("examples", 'featurecollection2.geojson',
  package = "geojson")
str &lt;- paste0(readLines(file), collapse = " ")
(y &lt;- featurecollection(str))
geo_type(y)
geo_pretty(y)
geo_write(y, f &lt;- tempfile(fileext = ".geojson"))
jsonlite::fromJSON(f, FALSE)
unlink(f)

# add to a data.frame
library('tibble')
tibble(a = 1:5, b = list(y))

# features to featurecollection
x &lt;- '{ "type": "Point", "coordinates": [100.0, 0.0] }'
point(x) %&gt;% feature() %&gt;% featurecollection()

## all points
x &lt;- '{ "type": "Point", "coordinates": [100.0, 0.0] }'
y &lt;- '{ "type": "Point", "coordinates": [100.0, 50.0] }'
featls &lt;- lapply(list(x, y), function(z) feature(point(z)))
featurecollection(featls)
</code></pre>

<hr>
<h2 id='geo_bbox'>Calculate a bounding box</h2><span id='topic+geo_bbox'></span>

<h3>Description</h3>

<p>Calculate a bounding box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_bbox(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_bbox_+3A_x">x</code></td>
<td>
<p>an object of class geojson</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Supports inputs of type: character, point, multipoint,
linestring, multilinestring, polygon, multipoygon, feature, and
featurecollection
</p>
<p>On character inputs, we lint the input to make sure it's proper
JSON and GeoJSON, then caculate the bounding box
</p>


<h3>Value</h3>

<p>a vector of four doubles: min lon, min lat, max lon, max lat
</p>


<h3>Examples</h3>

<pre><code class='language-R'># point
x &lt;- '{ "type": "Point", "coordinates": [100.0, 0.0] }'
(y &lt;- point(x))
geo_bbox(y)
y %&gt;% feature() %&gt;% geo_bbox()

# multipoint
x &lt;- '{"type": "MultiPoint", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ] }'
(y &lt;- multipoint(x))
geo_bbox(y)
y %&gt;% feature() %&gt;% geo_bbox()

# linestring
x &lt;- '{ "type": "LineString", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ]}'
(y &lt;- linestring(x))
geo_bbox(y)
y %&gt;% feature() %&gt;% geo_bbox()
file &lt;- system.file("examples", 'linestring_one.geojson',
  package = "geojson")
con &lt;- file(file)
str &lt;- paste0(readLines(con), collapse = " ")
(y &lt;- linestring(str))
geo_bbox(y)
y %&gt;% feature() %&gt;% geo_bbox()
close(con)

## Not run: 
# multilinestring
x &lt;- '{ "type": "MultiLineString",
 "coordinates": [ [ [100.0, 0.0], [101.0, 1.0] ], [ [102.0, 2.0],
 [103.0, 3.0] ] ] }'
(y &lt;- multilinestring(x))
geo_bbox(y)
y %&gt;% feature() %&gt;% geo_bbox()

# polygon
x &lt;- '{ "type": "Polygon",
"coordinates": [
  [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]
  ]
}'
(y &lt;- polygon(x))
geo_bbox(y)
y %&gt;% feature() %&gt;% geo_bbox()

# multipolygon
x &lt;- '{ "type": "MultiPolygon",
"coordinates": [
  [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],
  [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
  [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]
  ]
}'
(y &lt;- multipolygon(x))
geo_bbox(y)
y %&gt;% feature() %&gt;% geo_bbox()

# featurecollection
file &lt;- system.file("examples", 'featurecollection2.geojson',
  package = "geojson")
str &lt;- paste0(readLines(file), collapse = " ")
x &lt;- featurecollection(str)
geo_bbox(x)

# character
file &lt;- system.file("examples", 'featurecollection2.geojson',
  package = "geojson")
str &lt;- paste0(readLines(file), collapse = " ")
geo_bbox(str)

# json
library('jsonlite')
geo_bbox(toJSON(fromJSON(str), auto_unbox = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='geo_pretty'>Pretty print geojson</h2><span id='topic+geo_pretty'></span>

<h3>Description</h3>

<p>Pretty print geojson
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_pretty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_pretty_+3A_x">x</code></td>
<td>
<p>input, an object of class <code>geojson</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper around <code><a href="jsonlite.html#topic+prettify">prettify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo_pretty(point('{ "type": "Point", "coordinates": [100.0, 0.0] }'))

x &lt;- '{ "type": "Polygon",
"coordinates": [
  [ [100.0, 0.0], [100.0, 1.0], [101.0, 1.0], [101.0, 0.0], [100.0, 0.0] ]
  ]
}'
poly &lt;- polygon(x)
geo_pretty(poly)
</code></pre>

<hr>
<h2 id='geo_type'>Get geometry type</h2><span id='topic+geo_type'></span>

<h3>Description</h3>

<p>Get geometry type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_type_+3A_x">x</code></td>
<td>
<p>input, an object of class <code>geojson</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>geo_type(point('{ "type": "Point", "coordinates": [100.0, 0.0] }'))

x &lt;- '{ "type": "Polygon",
"coordinates": [
  [ [100.0, 0.0], [100.0, 1.0], [101.0, 1.0], [101.0, 0.0], [100.0, 0.0] ]
  ]
}'
poly &lt;- polygon(x)

geo_type(poly)
</code></pre>

<hr>
<h2 id='geo_write'>Write geojson to disk</h2><span id='topic+geo_write'></span>

<h3>Description</h3>

<p>Write geojson to disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_write(x, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_write_+3A_x">x</code></td>
<td>
<p>input, an object of class <code>geojson</code></p>
</td></tr>
<tr><td><code id="geo_write_+3A_file">file</code></td>
<td>
<p>(character) a file path, or connection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper around <code>jsonlite::toJSON()</code> and
<code><a href="base.html#topic+cat">cat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- tempfile(fileext = ".geojson")
geo_write(
  point('{ "type": "Point", "coordinates": [100.0, 0.0] }'),
  file
)
readLines(file)
unlink(file)
</code></pre>

<hr>
<h2 id='geobuf'>Geobuf serialization</h2><span id='topic+geobuf'></span><span id='topic+from_geobuf'></span><span id='topic+to_geobuf'></span>

<h3>Description</h3>

<p>Geobuf serialization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_geobuf(x, pretty = FALSE)

to_geobuf(x, file = NULL, decimals = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geobuf_+3A_x">x</code></td>
<td>
<p>(character) a file or raw object for <code>from_geobuf</code>, and
json string for <code>to_geobuf</code></p>
</td></tr>
<tr><td><code id="geobuf_+3A_pretty">pretty</code></td>
<td>
<p>(logical) pretty print JSON. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="geobuf_+3A_file">file</code></td>
<td>
<p>(character) file to write protobuf to. if NULL, geobuf
raw binary returned</p>
</td></tr>
<tr><td><code id="geobuf_+3A_decimals">decimals</code></td>
<td>
<p>(integer) how many decimals (digits behind the dot) to
store for numbers</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>from_geobuf</code> uses <code>protolite::geobuf2json()</code>,
while <code>to_geobuf</code> uses <code>protolite::json2geobuf()</code>
</p>
<p>Note that <span class="pkg">protolite</span> expects either a <strong>Feature</strong>,
<strong>FeatureCollection</strong>, or <strong>Geometry</strong> class geojson
object, Thus, for <code>to_geobuf</code> we check the geojson class, and
convert to a <strong>Feature</strong> if the class is something other than
the acceptable set.
</p>


<h3>Value</h3>

<p>for <code>from_geobuf</code> JSON as a character string, and for
<code>to_geobuf</code> raw or file written to disk
</p>


<h3>References</h3>

<p>Geobuf is a compact binary encoding for geographic data
using protocol buffers https://github.com/mapbox/geobuf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("examples/test.pb", package = "geojson")
(json &lt;- from_geobuf(file))
from_geobuf(file, pretty = TRUE)
pb &lt;- to_geobuf(json)
f &lt;- tempfile(fileext = ".pb")
to_geobuf(json, f)
from_geobuf(f)

object.size(json)
object.size(pb)
file.info(file)$size
file.info(f)$size

file &lt;- system.file("examples/featurecollection1.geojson",
  package = "geojson")
json &lt;- paste0(readLines(file), collapse = "")
to_geobuf(json)

# other geojson class objects
x &lt;- '{ "type": "Polygon",
"coordinates": [
  [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]
  ]
}'
(y &lt;- polygon(x))
to_geobuf(y)

x &lt;- '{"type": "MultiPoint", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ] }'
(y &lt;- multipoint(x))
to_geobuf(y)
</code></pre>

<hr>
<h2 id='geojson_data'>Data for use in examples</h2><span id='topic+geojson_data'></span>

<h3>Description</h3>

<p>Data for use in examples
</p>


<h3>Format</h3>

<p>A list of character strings of points or polygons in
FeatureCollection or Feature Geojson formats.
</p>


<h3>Details</h3>

<p>The data objects included in the list, accessible by name
</p>

<ul>
<li><p> featurecollection_point - FeatureCollection with a single point
</p>
</li>
<li><p> filter_features - FeatureCollection of points
</p>
</li>
<li><p> points_average - FeatureCollection of points
</p>
</li>
<li><p> polygons_average - FeatureCollection of polygons
</p>
</li>
<li><p> points_count - FeatureCollection of points
</p>
</li>
<li><p> polygons_count - FeatureCollection of polygons
</p>
</li>
<li><p> points_within - FeatureCollection of points
</p>
</li>
<li><p> polygons_within - FeatureCollection of polygons
</p>
</li>
<li><p> poly - Feaure of a single 1 degree by 1 degree polygon
</p>
</li>
<li><p> multipoly - FeatureCollection of two 1 degree by 1 degree polygons
</p>
</li>
<li><p> polygons_aggregate - FeatureCollection of Polygons from
turf.js examples
</p>
</li>
<li><p> points_aggregate - FeatureCollection of Points from turf.js examples
</p>
</li></ul>


<hr>
<h2 id='geometrycollection'>geometrycollection class</h2><span id='topic+geometrycollection'></span>

<h3>Description</h3>

<p>geometrycollection class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometrycollection(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geometrycollection_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{
 "type": "GeometryCollection",
 "geometries": [
   {
     "type": "Point",
     "coordinates": [100.0, 0.0]
   },
   {
     "type": "LineString",
     "coordinates": [ [101.0, 0.0], [102.0, 1.0] ]
   }
  ]
}'
(y &lt;- geometrycollection(x))
geo_type(y)
geo_pretty(y)
geo_write(y, f &lt;- tempfile(fileext = ".geojson"))
jsonlite::fromJSON(f, FALSE)
unlink(f)

# bigger geometrycollection
file &lt;- system.file("examples", "geometrycollection1.geojson", package = "geojson")
(y &lt;- geometrycollection(paste0(readLines(file), collapse="")))
geo_type(y)
geo_pretty(y)
</code></pre>

<hr>
<h2 id='linestring'>linestring class</h2><span id='topic+linestring'></span>

<h3>Description</h3>

<p>linestring class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linestring(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linestring_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{ "type": "LineString", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ] }'
(y &lt;- linestring(x))
geo_type(y)
geo_pretty(y)
geo_write(y, f &lt;- tempfile(fileext = ".geojson"))
jsonlite::fromJSON(f, FALSE)
unlink(f)

# add to a data.frame
library('tibble')
tibble(a = 1:5, b = list(y))
</code></pre>

<hr>
<h2 id='linting_opts'>GeoJSON Linting</h2><span id='topic+linting_opts'></span>

<h3>Description</h3>

<p>GeoJSON Linting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linting_opts(
  lint = FALSE,
  method = "hint",
  error = FALSE,
  suppress_pkgcheck_warnings = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linting_opts_+3A_lint">lint</code></td>
<td>
<p>(logical) lint geojson or not. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="linting_opts_+3A_method">method</code></td>
<td>
<p>(character) method to use:
</p>

<ul>
<li><p> hint - uses <code>geojsonlint::geojson_hint()</code>
</p>
</li>
<li><p> lint - uses <code>geojsonlint::geojson_lint()</code>
</p>
</li>
<li><p> validate - uses <code>geojsonlint::geojson_validate()</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="linting_opts_+3A_error">error</code></td>
<td>
<p>(logical) Throw an error on parse failure? If <code>TRUE</code>, then
function returns <code>TRUE</code> on success, and stop with the error
message on error. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="linting_opts_+3A_suppress_pkgcheck_warnings">suppress_pkgcheck_warnings</code></td>
<td>
<p>(logical) Suppress warning when
<code>geojsonlint</code> is not installed? Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>linting_opts was deprecated in 0.3.5
</p>

<hr>
<h2 id='multilinestring'>multilinestring class</h2><span id='topic+multilinestring'></span>

<h3>Description</h3>

<p>multilinestring class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multilinestring(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multilinestring_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{ "type": "MultiLineString",
 "coordinates": [ [ [100.0, 0.0], [101.0, 1.0] ], [ [102.0, 2.0], [103.0, 3.0] ] ] }'
(y &lt;- multilinestring(x))
y[1]
geo_type(y)
geo_pretty(y)
geo_write(y, f &lt;- tempfile(fileext = ".geojson"))
jsonlite::fromJSON(f, FALSE)
unlink(f)

file &lt;- system.file("examples", 'multilinestring_one.geojson', 
  package = "geojson")
con &lt;- file(file)
str &lt;- paste0(readLines(con), collapse = " ")
(y &lt;- multilinestring(str))
y[1]
geo_type(y)
geo_pretty(y)
close(con)

# add to a data.frame
library('tibble')
tibble(a = 1:5, b = list(y))
</code></pre>

<hr>
<h2 id='multipoint'>multipoint class</h2><span id='topic+multipoint'></span>

<h3>Description</h3>

<p>multipoint class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipoint(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multipoint_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{"type": "MultiPoint", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ] }'
(y &lt;- multipoint(x))
geo_type(y)
geo_pretty(y)
geo_write(y, f &lt;- tempfile(fileext = ".geojson"))
jsonlite::fromJSON(f, FALSE)
unlink(f)

# add to a data.frame
library('tibble')
tibble(a = 1:5, b = list(y))

# as.geojson coercion
as.geojson(x)
</code></pre>

<hr>
<h2 id='multipolygon'>multipolygon class</h2><span id='topic+multipolygon'></span>

<h3>Description</h3>

<p>multipolygon class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipolygon(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multipolygon_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{ "type": "MultiPolygon",
"coordinates": [
  [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],
  [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
  [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]
  ]
}'
(y &lt;- multipolygon(x))
geo_type(y)
geo_pretty(y)
geo_write(y, f &lt;- tempfile(fileext = ".geojson"))
jsonlite::fromJSON(f, FALSE)
unlink(f)

# add to a data.frame
library('tibble')
tibble(a = 1:5, b = list(y))
</code></pre>

<hr>
<h2 id='ndgeo'>Read and write newline-delimited GeoJSON (GeoJSON text sequences)</h2><span id='topic+ndgeo'></span><span id='topic+ndgeo_write'></span><span id='topic+ndgeo_write.default'></span><span id='topic+ndgeo_write.geofeaturecollection'></span><span id='topic+ndgeo_write.geofeature'></span><span id='topic+ndgeo_read'></span>

<h3>Description</h3>

<p>There are various flavors of newline-delimited GeoJSON, all of which
we aim to handle here. See Details for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndgeo_write(x, file, sep = "\n")

## Default S3 method:
ndgeo_write(x, file, sep = "\n")

## S3 method for class 'geofeaturecollection'
ndgeo_write(x, file, sep = "\n")

## S3 method for class 'geofeature'
ndgeo_write(x, file, sep = "\n")

ndgeo_read(txt, pagesize = 500, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndgeo_+3A_x">x</code></td>
<td>
<p>input, an object of class <code>geojson</code></p>
</td></tr>
<tr><td><code id="ndgeo_+3A_file">file</code></td>
<td>
<p>(character) a file. not a connection. required.</p>
</td></tr>
<tr><td><code id="ndgeo_+3A_sep">sep</code></td>
<td>
<p>(character) a character separator to use in <code><a href="base.html#topic+writeLines">writeLines()</a></code></p>
</td></tr>
<tr><td><code id="ndgeo_+3A_txt">txt</code></td>
<td>
<p>text, a file, or a url. required.</p>
</td></tr>
<tr><td><code id="ndgeo_+3A_pagesize">pagesize</code></td>
<td>
<p>(integer) number of lines to read/write from/to the
connection per iteration</p>
</td></tr>
<tr><td><code id="ndgeo_+3A_verbose">verbose</code></td>
<td>
<p>(logical) print messages. default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>ndgeo_write</code>: writes <span class="pkg">geojson</span> package types as
newline-delimited GeoJSON to a file
</p>
</li>
<li> <p><code>ndgeo_read</code>: reads newline-delimited GeoJSON from a string,
file, or URL into the appropriate geojson type
</p>
</li></ul>

<p>As an alternative to <code>ndgeo_read</code>, you can simply use
<code><a href="jsonlite.html#topic+stream_in">jsonlite::stream_in()</a></code> to convert newline-delimited GeoJSON
to a data.frame
</p>


<h3>Value</h3>

<p>a <code>geojson</code> class object
</p>


<h3>Note</h3>

<p><strong>IMPORTANT</strong>: <code>ngeo_read</code> for now only handles lines of geojson
in your file that are either features or geometry objects (e.g., point,
multipoint, polygon, multipolygon, linestring, multilinestring)
</p>


<h3>References</h3>

<p>Newline-delimited JSON has a few flavors.
The only difference between ndjson <a href="http://ndjson.org/">http://ndjson.org/</a> and
JSON Lines <a href="https://jsonlines.org/">https://jsonlines.org/</a> I can tell is that the former
requires UTF-8 encoding, while the latter does not.
</p>
<p>GeoJSON text sequences has a specification found at
<a href="https://datatracker.ietf.org/doc/html/rfc8142">https://datatracker.ietf.org/doc/html/rfc8142</a>. The spec states that:
</p>

<ul>
<li><p> a GeoJSON text sequence is any number of GeoJSON RFC7946 texts
</p>
</li>
<li><p> each line encoded in UTF-8 RFC3629
</p>
</li>
<li><p> each line preceded by one ASCII RFC20 record separator (RS; &quot;0x1e&quot;)
character
</p>
</li>
<li><p> each line followed by a line feed (LF)
</p>
</li>
<li><p> each JSON text MUST contain a single GeoJSON object as defined in RFC7946
</p>
</li></ul>

<p>See also the GeoJSON specification <a href="https://datatracker.ietf.org/doc/html/rfc7946">https://datatracker.ietf.org/doc/html/rfc7946</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># featurecollection
## write
file &lt;- system.file("examples", 'featurecollection2.geojson',
  package = "geojson")
str &lt;- paste0(readLines(file), collapse = " ")
(x &lt;- featurecollection(str))
outfile &lt;- tempfile(fileext = ".geojson")
ndgeo_write(x, outfile)
readLines(outfile)
jsonlite::stream_in(file(outfile))
## read
ndgeo_read(outfile)
unlink(outfile)

# read from an existing file
## GeoJSON objects all of same type: Feature
file &lt;- system.file("examples", 'ndgeojson1.json', package = "geojson")
ndgeo_read(file)
## GeoJSON objects all of same type: Point
file &lt;- system.file("examples", 'ndgeojson2.json', package = "geojson")
ndgeo_read(file)
## GeoJSON objects of mixed type: Point, and Feature
file &lt;- system.file("examples", 'ndgeojson3.json', package = "geojson")
ndgeo_read(file)

## Not run: 
# read from a file
url &lt;- "https://raw.githubusercontent.com/ropensci/geojson/main/inst/examples/ndgeojson1.json"
f &lt;- tempfile(fileext = ".geojsonl")
download.file(url, f)
x &lt;- ndgeo_read(f)
x
unlink(f)

# read from a URL
url &lt;- "https://raw.githubusercontent.com/ropensci/geojson/main/inst/examples/ndgeojson1.json"
x &lt;- ndgeo_read(url)
x

# geojson text sequences from file
file &lt;- system.file("examples", 'featurecollection2.geojson',
  package = "geojson")
str &lt;- paste0(readLines(file), collapse = " ")
x &lt;- featurecollection(str)
outfile &lt;- tempfile(fileext = ".geojson")
ndgeo_write(x, outfile, sep = "\u001e\n")
con &lt;- file(outfile)
readLines(con)
close(con)
ndgeo_read(outfile)
unlink(outfile)

## End(Not run)
</code></pre>

<hr>
<h2 id='point'>point class</h2><span id='topic+point'></span>

<h3>Description</h3>

<p>point class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{ "type": "Point", "coordinates": [100.0, 0.0] }'
(y &lt;- point(x))
geo_type(y)
geo_pretty(y)
geo_write(y, f &lt;- tempfile(fileext = ".geojson"))
jsonlite::fromJSON(f, FALSE)
unlink(f)

# add to a data.frame
library('tibble')
tibble(a = 1:5, b = list(y))

# as.geojson coercion
as.geojson(x)
</code></pre>

<hr>
<h2 id='polygon'>polygon class</h2><span id='topic+polygon'></span>

<h3>Description</h3>

<p>polygon class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygon_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- '{ "type": "Polygon",
"coordinates": [
  [ [100.0, 0.0], [100.0, 1.0], [101.0, 1.0], [101.0, 0.0], [100.0, 0.0] ]
  ]
}'
(y &lt;- polygon(x))
y[1]
geo_type(y)
geo_pretty(y)
geo_write(y, f &lt;- tempfile(fileext = ".geojson"))
jsonlite::fromJSON(f, FALSE)
unlink(f)

x &lt;- '{ "type": "Polygon",
"coordinates": [
  [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ],
  [ [100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2] ]
  ]
}'
(y &lt;- polygon(x))
y[1]
geo_type(y)
geo_pretty(y)

# add to a data.frame
library('tibble')
tibble(a = 1:5, b = list(y))
</code></pre>

<hr>
<h2 id='properties'>Add or get properties</h2><span id='topic+properties'></span><span id='topic+properties_add'></span><span id='topic+properties_get'></span>

<h3>Description</h3>

<p>Add or get properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>properties_add(x, ..., .list = NULL)

properties_get(x, property)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="properties_+3A_x">x</code></td>
<td>
<p>An object of class <code>geojson</code></p>
</td></tr>
<tr><td><code id="properties_+3A_...">...</code></td>
<td>
<p>Properties to be added, supports NSE as well as SE</p>
</td></tr>
<tr><td><code id="properties_+3A_.list">.list</code></td>
<td>
<p>a named list of properties to add. must be named</p>
</td></tr>
<tr><td><code id="properties_+3A_property">property</code></td>
<td>
<p>(character) property name</p>
</td></tr>
</table>


<h3>References</h3>

<p><a href="https://geojson.org/geojson-spec.html">https://geojson.org/geojson-spec.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add properties
x &lt;- '{ "type": "LineString", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ]}'
(y &lt;- linestring(x))
y %&gt;% feature() %&gt;% properties_add(population = 1000)

## add with a named list already created
x &lt;- '{ "type": "LineString", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ]}'
(y &lt;- linestring(x))
props &lt;- list(population = 1000, temperature = 89, size = 5)
y %&gt;% feature() %&gt;% properties_add(.list = props)

## combination of NSE and .list
x &lt;- '{ "type": "LineString", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ]}'
(y &lt;- linestring(x))
props &lt;- list(population = 1000, temperature = 89, size = 5)
y %&gt;% feature() %&gt;% properties_add(stuff = 4, .list = props)

# features to featurecollection
x &lt;- '{ "type": "Point", "coordinates": [100.0, 0.0] }'
point(x) %&gt;%
  feature() %&gt;%
  featurecollection() %&gt;%
  properties_add(population = 10)

# get property
x &lt;- '{ "type": "LineString", "coordinates": [ [100.0, 0.0], [101.0, 1.0] ]}'
(y &lt;- linestring(x))
x &lt;- y %&gt;% feature() %&gt;% properties_add(population = 1000)
properties_get(x, property = 'population')
</code></pre>

<hr>
<h2 id='to_geojson'>Convert GeoJSON character string to approriate GeoJSON class</h2><span id='topic+to_geojson'></span>

<h3>Description</h3>

<p>Automatically detects and adds the class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_geojson(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_geojson_+3A_x">x</code></td>
<td>
<p>GeoJSON character string</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mp &lt;- '{"type":"MultiPoint","coordinates":[[100,0],[101,1]]}'
to_geojson(mp)

ft &lt;- '{"type":"Feature","properties":{"a":"b"},
"geometry":{"type": "MultiPoint","coordinates": [ [100.0, 0.0], [101.0, 1.0] ]}}'
to_geojson(mp)

fc &lt;- '{"type":"FeatureCollection","features":[{"type":"Feature","properties":{"a":"b"},
"geometry":{"type": "MultiPoint","coordinates": [ [100.0, 0.0], [101.0, 1.0] ]}}]}'
to_geojson(fc)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
