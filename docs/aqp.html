<!DOCTYPE html><html><head><title>Help for package aqp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aqp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aqp-package'><p>Algorithms for Quantitative Pedology</p></a></li>
<li><a href='#+5B+2CSoilProfileCollection-method'><p>Matrix/data.frame-like access to profiles and horizons in a SoilProfileCollection</p></a></li>
<li><a href='#+5B+5B'><p>Get column of horizon or site data in a SoilProfileCollection</p></a></li>
<li><a href='#+5B+5B+26lt+3B-'><p>Add or change column of horizon or site data in a SoilProfileCollection</p></a></li>
<li><a href='#+24'><p>Get data from column of horizon or site data in a SoilProfileCollection</p></a></li>
<li><a href='#+24+26lt+3B-'><p>Set data in column of horizon or site data in a SoilProfileCollection</p></a></li>
<li><a href='#accumulateDepths'><p>Accumulate horizon depths, and reflect reversed depths, relative to new datum</p></a></li>
<li><a href='#addBracket'><p>Add Depth Brackets</p></a></li>
<li><a href='#addDiagnosticBracket'><p>Annotate Diagnostic Features</p></a></li>
<li><a href='#addVolumeFraction'><p>Symbolize Volume Fraction on a Soil Profile Collection Plot</p></a></li>
<li><a href='#aggregateColor'><p>Summarize Soil Colors</p></a></li>
<li><a href='#aggregateSoilDepth'><p>Probabalistic Estimation of Soil Depth within Groups</p></a></li>
<li><a href='#alignTransect'><p>Calculate Relative Positions from Transect Data</p></a></li>
<li><a href='#allocate'><p>Allocate soil properties within various classification systems.</p></a></li>
<li><a href='#aqp_df_class+2CSoilProfileCollection-method'><p>Get aqp_df_class entry from metadata or return a safe value.</p></a></li>
<li><a href='#argillic.clay.increase.depth'><p>Return upper boundary of argillic horizon</p></a></li>
<li><a href='#as'><p>Coerce SoilProfileCollection with <code>as()</code></p></a></li>
<li><a href='#barron.torrent.redness.LAB'><p>Barron &amp; Torrent (1986) Redness Index in LAB color space</p></a></li>
<li><a href='#bootstrapSoilTexture'><p>Bootstrap Soil Texture Data</p></a></li>
<li><a href='#brierScore'><p>Multinominal Brier Score</p></a></li>
<li><a href='#buntley.westin.index'><p>Buntley-Westin (1965) Index</p></a></li>
<li><a href='#c+2CSoilProfileCollection-method'><p>Combine SoilProfileCollection objects</p></a></li>
<li><a href='#ca630'><p>Soil Data from the Central Sierra Nevada Region of California</p></a></li>
<li><a href='#checkHzDepthLogic'><p>Check a SoilProfileCollection object for errors in horizon depths.</p></a></li>
<li><a href='#checkSPC'><p>Test for a valid SoilProfileCollection</p></a></li>
<li><a href='#col2Munsell'><p>Convert colors into Munsell Notation</p></a></li>
<li><a href='#colorChart'><p>Visualize soil colors in Munsell notation according to within-group frequency.</p></a></li>
<li><a href='#colorContrast'><p>Metrics of Contrast Suitable for Comparing Soil Colors</p></a></li>
<li><a href='#colorContrastPlot'><p>Color Contrast Plot</p></a></li>
<li><a href='#colorQuantiles'><p>Soil Color Range via Quantiles</p></a></li>
<li><a href='#compareSites'><p>Compare Site Level Attributes of a SoilProfileCollection</p></a></li>
<li><a href='#compositeSPC'><p>Return a list representation of site and horizon level data</p></a></li>
<li><a href='#confusionIndex'><p>Confusion Index</p></a></li>
<li><a href='#contrastChart'><p>Color Contrast Chart</p></a></li>
<li><a href='#contrastClass'><p>Soil Color Contrast</p></a></li>
<li><a href='#correctAWC'><p>Apply rock fragment or salt correction to available water content</p></a></li>
<li><a href='#crit.clay.argillic'><p>Determines threshold (minimum) clay content for argillic upper bound</p></a></li>
<li><a href='#denormalize'><p>Create a (redundant) horizon-level attribute from a site-level attribute</p></a></li>
<li><a href='#depth_units+2CSoilProfileCollection-method'><p>Get depth units from metadata</p></a></li>
<li><a href='#depthOf'><p>Get top or bottom depths of horizons matching a regular expression pattern</p></a></li>
<li><a href='#depths'><p>Initialize a SoilProfileCollection from data.frame</p></a></li>
<li><a href='#depthWeights'><p>Return a vector of contributing fractions over a depth interval</p></a></li>
<li><a href='#diagnostic_hz+2CSoilProfileCollection-method'><p>Retrieve diagnostic data from SoilProfileCollection</p></a></li>
<li><a href='#diagnostic_hz+26lt+3B-'><p>Add Data to Diagnostic Features Slot</p></a></li>
<li><a href='#dice+2CSoilProfileCollection-method'><p>Efficient Slicing of <code>SoilProfileCollection</code> Objects</p></a></li>
<li><a href='#dissolve_hz'><p>Dissolving horizon boundaries by grouping variables</p></a></li>
<li><a href='#duplicate'><p>Duplicate Profiles of a SoilProfileCollection</p></a></li>
<li><a href='#electroStatics_1D'><p>Label placement based on a simulation of electrostatic forces</p></a></li>
<li><a href='#equivalent_munsell'><p>Indices of &quot;equivalent&quot; Munsell chips in the <code>munsell</code> data set</p></a></li>
<li><a href='#equivalentMunsellChips'><p>Identify &quot;equivalent&quot; (whole number value/chroma) Munsell chips</p></a></li>
<li><a href='#estimateAWC'><p>Estimate available water capacity for fine-earth fraction</p></a></li>
<li><a href='#estimatePSCS'><p>Estimate boundaries of the particle size control section (U.S Soil Taxonomy;</p>
12th edition)</a></li>
<li><a href='#estimateSoilColor'><p>Estimate dry soil colors from moist soil colors and vice versa.</p></a></li>
<li><a href='#estimateSoilDepth'><p>Estimate Soil Depth</p></a></li>
<li><a href='#evalGenHZ'><p>Evaluate Generalized Horizon Labels</p></a></li>
<li><a href='#evalMissingData'><p>Evaluate Missing Data within a SoilProfileCollection</p></a></li>
<li><a href='#explainPlotSPC'><p>Visual Explanation for <code>plotSPC</code></p></a></li>
<li><a href='#fillHzGaps'><p>Find and Fill Horizon Gaps</p></a></li>
<li><a href='#findOverlap'><p>Find Overlap within a Sequence</p></a></li>
<li><a href='#fixOverlap'><p>Fix Overlap within a Sequence</p></a></li>
<li><a href='#flagOverlappingHz'><p>Flag perfectly overlapping horizons within a SoilProfileCollection</p></a></li>
<li><a href='#fragmentClasses'><p>Coarse Fragment Class Labels and Diameter</p></a></li>
<li><a href='#fragmentSieve'><p>Sieve the Coarse Fraction of Soil</p></a></li>
<li><a href='#generalize.hz'><p>Generalize Horizon Names</p></a></li>
<li><a href='#genhzTableToAdjMat'><p>Convert cross-tabulation to adjacency matrix.</p></a></li>
<li><a href='#genSlabLabels'><p>Generate Labels for Slabs</p></a></li>
<li><a href='#get.increase.matrix'><p>Compute Pair-wise Distances of Soil Properties over Depth</p></a></li>
<li><a href='#get.ml.hz'><p>Determine ML Horizon Boundaries</p></a></li>
<li><a href='#getArgillicBounds'><p>Estimate upper and lower boundary of argillic diagnostic subsurface horizon</p></a></li>
<li><a href='#getCambicBounds'><p>Find all intervals that are potentially part of a Cambic horizon</p></a></li>
<li><a href='#getClosestMunsellChip'><p>Get Approximate Munsell Chip</p></a></li>
<li><a href='#getLastHorizonID'><p>Get IDs of Deepest Horizons by Profile</p></a></li>
<li><a href='#getSoilDepthClass'><p>Generate Soil Depth Class Matrix</p></a></li>
<li><a href='#getSurfaceHorizonDepth'><p>Determine thickness of horizons (continuous from surface) matching a pattern</p></a></li>
<li><a href='#GHL'><p>Get or Set Generalized Horizon Label (GHL) Column Name</p></a></li>
<li><a href='#glom+2CSoilProfileCollection-method'><p>Subset soil horizon data using a depth or depth interval</p></a></li>
<li><a href='#glomApply'><p>Subset an SPC by applying glom to each profile</p></a></li>
<li><a href='#grepSPC'><p>Subset SPC with pattern-matching for text-based attributes</p></a></li>
<li><a href='#groupedProfilePlot'><p>Grouped Soil Profile Plot</p></a></li>
<li><a href='#groupSPC'><p>Store groupings within a profile collection.</p></a></li>
<li><a href='#guessGenHzLevels'><p>Guess Appropriate Ordering for Generalized Horizon Labels</p></a></li>
<li><a href='#guessHzAttrName'><p>Guess Horizon Slot Column Names</p></a></li>
<li><a href='#harden.melanization'><p>Harden (1982) Melanization</p></a></li>
<li><a href='#harden.rubification'><p>Harden (1982) Rubification</p></a></li>
<li><a href='#harmonize+2CSoilProfileCollection-method'><p>Harmonize a property by profile-level denormalization for convenient visualization or analysis of ranges</p></a></li>
<li><a href='#hasDarkColors'><p>Find horizons with colors darker than a Munsell hue, value, chroma threshold</p></a></li>
<li><a href='#horizonColorIndices'><p>Horizon Color Indices</p></a></li>
<li><a href='#horizonDepths+26lt+3B-'><p>Set horizon depth column names</p></a></li>
<li><a href='#horizonNames+26lt+3B-'><p>Set horizon column names</p></a></li>
<li><a href='#horizons+2CSoilProfileCollection-method'><p>Retrieve horizon data from SoilProfileCollection</p></a></li>
<li><a href='#huePosition'><p>Munsell Hue Reference and Position Searching</p></a></li>
<li><a href='#huePositionCircle'><p>Visual Description of Munsell Hue Ordering</p></a></li>
<li><a href='#hurst.redness'><p>Hurst (1977) Redness Index</p></a></li>
<li><a href='#hzAbove'><p>Horizons Above or Below</p></a></li>
<li><a href='#HzDepthLogicSubset'><p>Subset <code>SoilProfileCollection</code> Objects or Horizons via <code>checkHzDepthLogic</code></p></a></li>
<li><a href='#hzDepthTests'><p>Tests of horizon depth logic</p></a></li>
<li><a href='#hzDesgn+2CSoilProfileCollection-method'><p>Get horizon designation column name</p></a></li>
<li><a href='#hzdesgnname'><p>Get or Set Horizon Designation Column Name</p></a></li>
<li><a href='#hzDistinctnessCodeToOffset'><p>Convert Horizon Boundary Distinctness to Vertical Offset</p></a></li>
<li><a href='#hzID+26lt+3B-+2CSoilProfileCollection-method'><p>Set horizon IDs</p></a></li>
<li><a href='#hzidname+26lt+3B-'><p>Set horizon ID column name</p></a></li>
<li><a href='#hzMetadata+2CSoilProfileCollection-method'><p>Get horizon-level metadata</p></a></li>
<li><a href='#hztexclname'><p>Get or Set Horizon Texture Class Column Name</p></a></li>
<li><a href='#hzTopographyCodeToLineType'><p>Convert Horizon Boundary Topography to Line Type</p></a></li>
<li><a href='#hzTopographyCodeToOffset'><p>Convert Horizon Boundary Topography to Vertical Offset</p></a></li>
<li><a href='#hzTransitionProbabilities'><p>Horizon Transition Probabilities</p></a></li>
<li><a href='#idname+2CSoilProfileCollection-method'><p>Get profile ID column name</p></a></li>
<li><a href='#initSpatial+26lt+3B-'><p>Initialize Spatial Data in a SoilProfileCollection</p></a></li>
<li><a href='#invertLabelColor'><p>Make High Contrast Label Colors</p></a></li>
<li><a href='#isEmpty+2CSoilProfileCollection-method'><p>Check for &quot;empty&quot; profiles in a SoilProfileCollection</p></a></li>
<li><a href='#jacobs2000'><p>Soil Morphologic Data from Jacobs et al. 2002.</p></a></li>
<li><a href='#L1_profiles'><p>Create Representative Soil Profiles via L1 Estimator</p></a></li>
<li><a href='#length+2CSoilProfileCollection-method'><p>Get the number of profiles in a SoilProfileCollection</p></a></li>
<li><a href='#lunique'><p>Eliminate duplicate instances of profile IDs in a list of SoilProfileCollections</p></a></li>
<li><a href='#max+2CSoilProfileCollection-method'><p>Get the maximum bottom depth in a SoilProfileCollection</p></a></li>
<li><a href='#metadata+2CSoilProfileCollection-method'><p>Retrieve metadata from SoilProfileCollection</p></a></li>
<li><a href='#min+2CSoilProfileCollection-method'><p>Get the minimum bottom depth in a SoilProfileCollection</p></a></li>
<li><a href='#missingDataGrid'><p>Missing Data Grid</p></a></li>
<li><a href='#mixMunsell'><p>Mix Munsell Colors via Spectral Library</p></a></li>
<li><a href='#mollic.thickness.requirement'><p>Calculate the minimum thickness requirement for Mollic epipedon</p></a></li>
<li><a href='#munsell'><p>Munsell to sRGB Lookup Table for Common Soil Colors</p></a></li>
<li><a href='#munsell.spectra'><p>Spectral Library of Munsell Colors</p></a></li>
<li><a href='#munsell2rgb'><p>Convert Munsell Color Notation to other Color Space Coordinates (sRGB and CIELAB)</p></a></li>
<li><a href='#munsell2spc+2CSoilProfileCollection-method'><p>Merge Munsell Hue, Value, Chroma converted to sRGB &amp; CIELAB into a SoilProfileCollection</p></a></li>
<li><a href='#munsellHuePosition'><p>Munsell Hue Position Reference</p></a></li>
<li><a href='#mutate_profile'><p>Transform a SPC (by profile) with a set of expressions</p></a></li>
<li><a href='#names+2CSoilProfileCollection-method'><p>Get names of columns in site and horizons table</p></a></li>
<li><a href='#NCSP'><p>Numerical Classification of Soil Profiles</p></a></li>
<li><a href='#nrow+2CSoilProfileCollection-method'><p>Get the number of horizons in a SoilProfileCollection</p></a></li>
<li><a href='#osd'><p>Example Output from soilDB::fetchOSD()</p></a></li>
<li><a href='#panel.depth_function'><p>Lattice Panel Function for Soil Profiles</p></a></li>
<li><a href='#parseMunsell'><p>Parse Munsell Color Notation</p></a></li>
<li><a href='#pbindlist'><p>Combine a list of SoilProfileCollection objects</p></a></li>
<li><a href='#pc'><p>Deprecated: Numerical Soil Profile Comparison</p></a></li>
<li><a href='#perturb'><p>Perturb soil horizon depths using boundary distinctness</p></a></li>
<li><a href='#ph_to_rxnclass'><p>Convert pH to/from Reaction Classes</p></a></li>
<li><a href='#plot_distance_graph'><p>Between Individual Distance Plot</p></a></li>
<li><a href='#plotColorMixture'><p>Visualize Spectral Mixing of Munsell Colors</p></a></li>
<li><a href='#plotColorQuantiles'><p>Visualize Color Quantiles</p></a></li>
<li><a href='#plotMultipleSPC'><p>Plot Multiple <code>SoilProfileCollection</code> Objects</p></a></li>
<li><a href='#plotSPC'><p>Create Soil Profile Sketches</p></a></li>
<li><a href='#previewColors'><p>Preview Colors</p></a></li>
<li><a href='#prj+2CSoilProfileCollection-method'><p>Get or Set Coordinate Reference System for SoilProfileCollection</p></a></li>
<li><a href='#profile_id+26lt+3B-'><p>Set profile IDs</p></a></li>
<li><a href='#profileApply'><p>Iterate over profiles in a SoilProfileCollection</p></a></li>
<li><a href='#profileGroupLabels'><p>Soil Profile Group Labels</p></a></li>
<li><a href='#profileInformationIndex'><p>Soil Profile Information Index</p></a></li>
<li><a href='#quickSPC'><p>Quickly Assemble a SoilProfileCollection</p></a></li>
<li><a href='#random_profile'><p>Random Profile</p></a></li>
<li><a href='#reactionclass'><p>pH Reaction Classes</p></a></li>
<li><a href='#rebuildSPC'><p>Rebuild a SoilProfileCollection object</p></a></li>
<li><a href='#reduceSPC'><p>Select a subset of columns from a SoilProfileCollection</p></a></li>
<li><a href='#reorderHorizons'><p>Re-order corrupted horizon data</p></a></li>
<li><a href='#repairMissingHzDepths'><p>Repair Problematic Lower Horizon Depths</p></a></li>
<li><a href='#replaceHorizons+26lt+3B-'><p>Replace Data in Horizon Slot</p></a></li>
<li><a href='#restrictions+2CSoilProfileCollection-method'><p>Retrieve restriction data from SoilProfileCollection</p></a></li>
<li><a href='#restrictions+26lt+3B-'><p>Add Data to Restrictions Slot</p></a></li>
<li><a href='#rgb2munsell'><p>sRGB to Munsell Color Conversion</p></a></li>
<li><a href='#ROSETTA.centroids'><p>Average Hydraulic Parameters from the ROSETTA Model by USDA Soil Texture</p>
Class</a></li>
<li><a href='#rowley2019'><p>Soil Morphologic, Geochemical, and Mineralogy Data from Rowley et al. 2019.</p></a></li>
<li><a href='#SANN_1D'><p>Fix Overlap within a Sequence via Simulated Annealing</p></a></li>
<li><a href='#segment'><p>Segmenting of Soil Horizon Data by Depth Interval</p></a></li>
<li><a href='#shannonEntropy'><p>Shannon Entropy</p></a></li>
<li><a href='#show'><p>SoilProfileCollection show method</p></a></li>
<li><a href='#sierraTransect'><p>Soil Physical and Chemical Data Related to Studies in the Sierra Nevada</p>
Mountains, CA, USA.</a></li>
<li><a href='#sim'><p>DEPRECATED Simulate Soil Profiles</p></a></li>
<li><a href='#simulateColor'><p>Simulate Soil Colors</p></a></li>
<li><a href='#site+2CSoilProfileCollection-method'><p>Retrieve site data from SoilProfileCollection</p></a></li>
<li><a href='#siteNames+26lt+3B-'><p>Set site column names</p></a></li>
<li><a href='#slab'><p>Slab-Wise Aggregation of SoilProfileCollection Objects</p></a></li>
<li><a href='#slice-methods'><p>Slicing of SoilProfileCollection Objects</p></a></li>
<li><a href='#slicedHSD'><p>Tukey's HSD Over Slices</p></a></li>
<li><a href='#soil_minerals'><p>Munsell Colors of Common Soil Minerals</p></a></li>
<li><a href='#soilColorSignature'><p>Soil Profile Color Signatures</p></a></li>
<li><a href='#soilPalette'><p>Soil Color Palette</p></a></li>
<li><a href='#SoilProfileCollection'><p>An S4 object representation of a group of soil profiles.</p></a></li>
<li><a href='#soiltexture'><p>Lookup tables for sand, silt, clay, texture class, and textural modifiers.</p></a></li>
<li><a href='#SoilTextureLevels'><p>Ranking Systems for USDA Soil Texture Classes</p></a></li>
<li><a href='#sp1'><p>Soil Profile Data Example 1</p></a></li>
<li><a href='#sp2'><p>Honcut Creek Soil Profile Data</p></a></li>
<li><a href='#sp3'><p>Soil Profile Data Example 3</p></a></li>
<li><a href='#sp4'><p>Soil Chemical Data from Serpentinitic Soils of California</p></a></li>
<li><a href='#sp5'><p>Sample Soil Database #5</p></a></li>
<li><a href='#sp6'><p>Soil Physical and Chemical Data from Manganiferous Soils</p></a></li>
<li><a href='#spc_in_sync'><p>Quickly assess relative state of site and horizon slots</p></a></li>
<li><a href='#SPC.with.overlap'><p>Example SoilProfileCollection with Overlapping Horizons</p></a></li>
<li><a href='#spc2mpspline+2CSoilProfileCollection-method'><p>SoilProfileCollection wrapper for <code>mpspline2::mpspline()</code></p></a></li>
<li><a href='#spec2Munsell'><p>Convert reflectance spectra to closest Munsell chip</p></a></li>
<li><a href='#spectral.reference'><p>Standard Illuminants and Observers</p></a></li>
<li><a href='#split+2CSoilProfileCollection-method'><p>Split a SoilProfileCollection object into a list of SoilProfileCollection objects.</p></a></li>
<li><a href='#splitLogicErrors'><p>Split a SoilProfileCollection into a list based on types of horizon logic errors</p></a></li>
<li><a href='#subApply'><p>Subset SPC based on result of performing function on each profile</p></a></li>
<li><a href='#subset+2CSoilProfileCollection-method'><p>Subset a SoilProfileCollection with logical expressions</p></a></li>
<li><a href='#subsetHz+2CSoilProfileCollection-method'><p>Subset the horizons in a SoilProfileCollection using logical criteria</p></a></li>
<li><a href='#subsetProfiles'><p>DEPRECATED use subset</p></a></li>
<li><a href='#summarizeSPC'><p>Perform summaries on groups (from <code>group_by</code>) and create new site or horizon level attributes</p></a></li>
<li><a href='#tauW'><p>Compute weighted naive and <em>tau</em> statistics for a cross-classification matrix</p></a></li>
<li><a href='#texcl_to_ssc'><p>Textural conversions</p></a></li>
<li><a href='#textureTriangleSummary'><p>Soil Texture Low-RV-High as Defined by Quantiles</p></a></li>
<li><a href='#thompson.bell.darkness'><p>Thompson-Bell (1996) Index</p></a></li>
<li><a href='#traditionalColorNames'><p>Traditional Soil Color Names</p></a></li>
<li><a href='#transform+2CSoilProfileCollection-method'><p>Transform a SPC with expressions based on site or horizon level attributes</p></a></li>
<li><a href='#unique+2CSoilProfileCollection-method'><p>Uniqueness within a <code>SoilProfileCollection</code> via MD5 Hash</p></a></li>
<li><a href='#unroll'><p>Unroll Genetic Horizons</p></a></li>
<li><a href='#us.state.soils'><p>US State Soils</p></a></li>
<li><a href='#validSpatialData+2CSoilProfileCollection-method'><p>Check for valid spatial reference of profiles</p></a></li>
<li><a href='#warpHorizons'><p>Inflate / Deflate Horizon Thickness</p></a></li>
<li><a href='#wilson2022'><p>Example Data from Wilson et al. 2022</p></a></li>
<li><a href='#xtableTauW'><p>Format a LaTeX table with results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Algorithms for Quantitative Pedology</td>
</tr>
<tr>
<td>Author:</td>
<td>Dylan Beaudette [aut, cre],
  Pierre Roudier [aut, ctb],
  Andrew Brown [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dylan Beaudette &lt;dylan.beaudette@usda.gov&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, utils, methods, grid, lattice,
cluster, sp, stringr, data.table, farver</td>
</tr>
<tr>
<td>Suggests:</td>
<td>colorspace, ape, soilDB, sf, latticeExtra, tactile,
compositions, sharpshootR, markovchain, xtable, testthat,
Gmedian, Hmisc, tibble, RColorBrewer, scales, digest, MASS,
mpspline2, soiltexture, gower, knitr, rmarkdown, plyr</td>
</tr>
<tr>
<td>Description:</td>
<td>The Algorithms for Quantitative Pedology (AQP) project was started in 2009 to organize a loosely-related set of concepts and source code on the topic of soil profile visualization, aggregation, and classification into this package (aqp). Over the past 8 years, the project has grown into a suite of related R packages that enhance and simplify the quantitative analysis of soil profile data. Central to the AQP project is a new vocabulary of specialized functions and data structures that can accommodate the inherent complexity of soil profile information; freeing the scientist to focus on ideas rather than boilerplate data processing tasks &lt;<a href="https://doi.org/10.1016%2Fj.cageo.2012.10.020">doi:10.1016/j.cageo.2012.10.020</a>&gt;. These functions and data structures have been extensively tested and documented, applied to projects involving hundreds of thousands of soil profiles, and deeply integrated into widely used tools such as SoilWeb <a href="https://casoilresource.lawr.ucdavis.edu/soilweb-apps/">https://casoilresource.lawr.ucdavis.edu/soilweb-apps/</a>. Components of the AQP project (aqp, soilDB, sharpshootR, soilReports packages) serve an important role in routine data analysis within the USDA-NRCS Soil Science Division. The AQP suite of R packages offer a convenient platform for bridging the gap between pedometric theory and practice.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ncss-tech/aqp">https://github.com/ncss-tech/aqp</a>, <a href="https://ncss-tech.github.io/AQP/">https://ncss-tech.github.io/AQP/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ncss-tech/aqp/issues">https://github.com/ncss-tech/aqp/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 23:27:23 UTC; Dylan.Beaudette</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 05:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='aqp-package'>Algorithms for Quantitative Pedology</h2><span id='topic+aqp-package'></span><span id='topic+aqp'></span><span id='topic+aqp.env'></span>

<h3>Description</h3>

<p>The aqp (Algorithms for Quantitative Pedology) package for R was developed
to address some of the difficulties associated with processing soils
information, specifically related to visualization, aggregation, and
classification of soil profile data. This package is based on a mix of S3/S4
functions and classes, and most functions use basic dataframes as input,
where rows represent soil horizons and columns define properties of those
horizons. Common to most functions are the requirements that horizon
boundaries are defined as depth from 0, and that profiles are uniquely
defined by an id column. The aqp package defines an S4 class,
&quot;SoilProfileCollection&quot;, for storage of profile-level metadata, as well as
summary, print, and plotting methods that have been customized for common
tasks related to soils data.
</p>


<h3>Details</h3>

<p>Demos: <code>demo(aqp)</code>
</p>
<p><a href="http://ncss-tech.github.io/AQP/">Project homepage</a>
</p>


<h3>Author(s)</h3>

<p>Dylan E. Beaudette <a href="mailto:debeaudette@ucdavis.edu">debeaudette@ucdavis.edu</a>, Pierre Roudier, Andrew G. Brown
</p>


<h3>See Also</h3>

<p><code style="white-space: pre;">&#8288;depths&lt;-()&#8288;</code>, <code>SoilProfileCollection()</code>, <code><a href="#topic+sp1">sp1</a></code>, <code><a href="#topic+sp2">sp2</a></code>, <code><a href="#topic+sp3">sp3</a></code>, <code><a href="#topic+sp4">sp4</a></code>, <code><a href="#topic+sp5">sp5</a></code>, <code><a href="#topic+sp6">sp6</a></code>
</p>

<hr>
<h2 id='+5B+2CSoilProfileCollection-method'>Matrix/data.frame-like access to profiles and horizons in a SoilProfileCollection</h2><span id='topic++5B+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>You can access the contents of a SoilProfileCollection by profile and horizon &quot;index&quot;, <code>i</code> and <code>j</code>, respectively: <code>spc[i, j, ...]</code>. Subset operations are propagated to other slots (such as diagnostics or spatial) when they result in removal of sites from a collection.
</p>

<ul>
<li> <p><code>i</code> refers to the profile position within the collection. By default the order is based on the C SORT order of the variable that you specified as your unique profile ID at time of object construction. Note that if your ID variable was numeric, then it has been sorted as a character.
</p>
</li>
<li> <p><code>j</code> refers to the horizon or &quot;slice&quot; index. This index is most useful when either a) working with <code>slice</code>'d SoilProfileCollection or b) working with single-profile collections. <code>j</code> returns the layer in the specified index positions for all profiles in a collection.
</p>
</li>
<li> <p><code>...</code> is an area to specify an expression that is evaluated in the subset. Currently supported
</p>

<ul>
<li> <p><code>.LAST</code> (last horizon in each profile): return the last horizon from each profile. This uses <code>i</code> but ignores the regular <code>j</code> index.
</p>
</li>
<li> <p><code>.FIRST</code> (first horizon in each profile): return the last horizon from each profile. This uses <code>i</code> but ignores the regular <code>j</code> index.
</p>
</li>
<li> <p><code>.HZID</code> (horizon index): return the horizon indices corresponding to <code>i</code>+<code>j</code>+<code>...</code> (&quot;k&quot;) constraints
</p>
</li>
<li> <p><code>.NHZ</code> (number of horizons): return the number of horizons in the profiles resulting from <code>i</code>+<code>j</code>+<code>...</code> (&quot;k&quot;) constraints
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSoilProfileCollection-method_+3A_i">i</code></td>
<td>
<p>a numeric or logical value denoting profile indices to select in a subset</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSoilProfileCollection-method_+3A_j">j</code></td>
<td>
<p>a numeric or logical value denoting horizon indices to select in a subset</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p>non-standard expressions to evaluate in a subset</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CSoilProfileCollection-method_+3A_drop">drop</code></td>
<td>
<p>Default: <code>TRUE</code>. When <code>drop=FALSE</code> placeholder horizons (profile ID with all other values <code>NA</code>) are created where the specified <code>j</code> index results in removal of all horizons.</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+5B'>Get column of horizon or site data in a SoilProfileCollection</h2><span id='topic++5B+5B'></span><span id='topic++5B+5B+2CSoilProfileCollection-method'></span><span id='topic++5B+5B+2CSoilProfileCollection+2CANY-method'></span><span id='topic++5B+5B+2CSoilProfileCollection+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Get the data from a column accessed by name. Column names other than profile ID are not shared between site and horizons.
Bonus: <code>[[</code> gives access to all site and horizon level variables in tab complete for RStudio using the magrittr pipe operator!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection,ANY,ANY'
x[[i, j]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B_+3A_i">i</code></td>
<td>
<p>an expression resolving to a single column name in site or horizon table</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B_+3A_j">j</code></td>
<td>
<p>(not used)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp2)
depths(sp2) &lt;- id ~ top + bottom
site(sp2) &lt;- ~ surface

# get with [[
sp2[['surface']]

# get using "unknown" expression:
#  "2nd + 3rd horizon column names"
for(i in horizonNames(sp2)[2:3])
 print(sp2[[i]])

data(sp5)

# some column names to work with
rgb.columns &lt;- c("R25","G25","B25")

res &lt;- lapply(rgb.columns, function(x) {

  # [[ allows you to access column names in a loop
  round(sp5[[x]] * 255)

})

# rename scaled results
names(res) &lt;- paste0(rgb.columns,"_scl")

# add horizon ID to results
result &lt;- data.frame(hzID = hzID(sp5), do.call('cbind', res))
head(result)

# join result back into horizons
horizons(sp5) &lt;- result
</code></pre>

<hr>
<h2 id='+5B+5B+26lt+3B-'>Add or change column of horizon or site data in a SoilProfileCollection</h2><span id='topic++5B+5B+3C-'></span><span id='topic++5B+5B+3C-+2CSoilProfileCollection-method'></span><span id='topic++5B+5B+3C-+2CSoilProfileCollection+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Add or change the data from a column accessed by name. Column names other
than profile ID are not shared between site and horizons. The benefit of
using double bracket setter over <code>$</code> is that <code>name</code> can be
calculated, whereas with <code>$</code>, it must be known a priori and hard coded.
</p>
<p>When using the double bracket setter the length of input and output matching
either the number of sites or number of horizons is used to determine which
slot new columns are assigned to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection,ANY,ANY'
x[[i]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-_+3A_i">i</code></td>
<td>
<p>an expression resolving to a single column name in site or horizon
table-</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>New value to replace &ndash; unit length or equal in length to number
of sites or horizons in the collection.</p>
</td></tr>
</table>

<hr>
<h2 id='+24'>Get data from column of horizon or site data in a SoilProfileCollection</h2><span id='topic++24'></span><span id='topic++24+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Get the data from a column accessed by name <code>x$name</code>. Column names other than profile ID are not shared between site and horizons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="+2B24_+3A_name">name</code></td>
<td>
<p>a single column name in site or horizon table</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)

depths(sp1) &lt;- id ~ top + bottom

# get data from a column by name (prop)
sp1$prop

</code></pre>

<hr>
<h2 id='+24+26lt+3B-'>Set data in column of horizon or site data in a SoilProfileCollection</h2><span id='topic++24+3C-'></span><span id='topic++24+3C-+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Set the data in a column accessed by name <code>spc$name</code>. Column names other than profile ID are not shared between site and horizons.
</p>
<p>When using <code>$&lt;-</code>, the length of input and output matching either the number of sites or number of horizons is used to determine which slot new columns are assigned to. Use <code>site(x)$name &lt;- value</code> or  <code>horizons(x)$name &lt;- value</code> to be explicit about which slot is being accessed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="+2B24+2B26lt+2B3B-_+3A_name">name</code></td>
<td>
<p>a single column name in site or horizon table</p>
</td></tr>
<tr><td><code id="+2B24+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Replacement values: unit length or equal to number of horizons or sites.</p>
</td></tr>
</table>

<hr>
<h2 id='accumulateDepths'>Accumulate horizon depths, and reflect reversed depths, relative to new datum</h2><span id='topic+accumulateDepths'></span>

<h3>Description</h3>

<p>Fix old-style organic horizon depths or depths with a non-standard datum by the &quot;depth accumulation&quot; method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accumulateDepths(
  x,
  id = NULL,
  hzdepths = NULL,
  hzname = NULL,
  hzdatum = 0,
  seqnum = NULL,
  pattern = "O",
  fix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accumulateDepths_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> or <code>SoilProfileCollection</code></p>
</td></tr>
<tr><td><code id="accumulateDepths_+3A_id">id</code></td>
<td>
<p>unique profile ID. Default: <code>NULL</code>, if <code>x</code> is a SoilProfileCollection <code>idname(x)</code></p>
</td></tr>
<tr><td><code id="accumulateDepths_+3A_hzdepths">hzdepths</code></td>
<td>
<p>character vector containing horizon top and bottom depth column names. Default: <code>NULL</code>, if <code>x</code> is a SoilProfileCollection <code>horizonDepths(x)</code></p>
</td></tr>
<tr><td><code id="accumulateDepths_+3A_hzname">hzname</code></td>
<td>
<p>character vector containing horizon designation or other label column names. Default: <code>NULL</code>, if <code>x</code> is a SoilProfileCollection <code>hzdesgnname(x)</code></p>
</td></tr>
<tr><td><code id="accumulateDepths_+3A_hzdatum">hzdatum</code></td>
<td>
<p>a numeric vector to add to accumulated depths. Default: <code>0</code>. Can be equal in length to number of profiles if <code>x</code> is a <code>SoilProfileCollection</code> or number of (unique) IDs if <code>x</code> is a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="accumulateDepths_+3A_seqnum">seqnum</code></td>
<td>
<p>Optional: character vector containing record &quot;sequence number&quot; column name; used in-lieu of <code>hzname</code> (when <code>NA</code>) to identify &quot;first&quot; record in a profile</p>
</td></tr>
<tr><td><code id="accumulateDepths_+3A_pattern">pattern</code></td>
<td>
<p>pattern to search for in <code>hzname</code> to identify matching horizons to append the profile to</p>
</td></tr>
<tr><td><code id="accumulateDepths_+3A_fix">fix</code></td>
<td>
<p>apply adjustments to missing (<code>NA</code>) depths and expand 0-thickness horizons? Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;depth accumulation&quot; method calculates thicknesses of individual horizons and then cumulative sums them after putting them in <code>id</code> + top depth order. The routine tries to determine context based on <code>hzname</code> and <code>pattern</code>. The main transformation is if a top depth is deeper than the bottom depth, the depths are reflected on the Z-axis (made negative). The data are then <code>id</code> + top depth sorted again, the thickness calculated and accumulated to replace the old depths.
</p>
<p>This function uses several heuristics to adjust data before transformation and thickness calculation:
</p>


<h4>Regex matching of horizon designation patterns and similar</h4>


<ul>
<li><p> matches of <code>pattern</code> where both top and bottom depth <code>NA</code> -&gt; <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> <code style="white-space: pre;">&#8288;[top,bottom]&#8288;</code> depth
</p>
</li>
<li><p> REMOVE horizons that do not match <code>pattern</code> where both top and bottom depths <code>NA</code>
</p>
</li></ul>




<h4>Over-ride <code>hzname</code> handling with the sequence column argument <code>seqnum</code></h4>


<ul>
<li><p> if <code>seqnum</code> column specified &quot;first record with <code>NA</code> <code>hzname</code>&quot; is considered a <code>pattern</code> match if <code>seqnum == 1</code>
</p>
</li></ul>




<h4>Trigger &quot;fixing&quot; with the <code>fix</code> argument:</h4>


<ul>
<li><p> Add 1 cm to bottom-most horizons with <code>NA</code> bottom depth
</p>
</li>
<li><p> Add 1 cm thickness to horizons with top and bottom depth equal
</p>
</li>
<li><p> Add 1 cm thickness to horizons with <code>NA</code> top depth and bottom depth <code>0</code>
</p>
</li></ul>




<h3>Value</h3>

<p>A horizon-level <code>data.frame</code>, suitable for promoting to SPC with <code style="white-space: pre;">&#8288;depths&lt;-&#8288;</code>, or a <code>SoilProfileCollection</code>, depending on the class of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example using hzdatum argument
data(sp4)
depths(sp4) &lt;- id ~ top + bottom
hz &lt;- accumulateDepths(sp4,
                       id = "id",
                       hzdepths = c("top", "bottom"),
                       hzname = "name",
                       hzdatum = 5 * 1:length(sp4))
plot(hz)
  
# example using old-style O horizons
hz &lt;- read.table(text = "peiidref hzdept hzdepb hzname seqnum phiid
                    1        11      0      5      A      2   295
                    2        11      1      0     Oe      1   294
                    3        11      5     13     C1      3   296
                    4        11     13     58     C2      4   297
                    5        11     58    152     C3      5   298
                    6        13      0      5      A      2   303
                    7        13      1      0     Oe      1   302
                    8        13      5     25     Bw      3   304
                    9        13     25     61      C      4   305
                    10       13     61     NA      R      5   306
                    11      136      0     13     A1      3   695
                    12      136      1      0     Oe      2   694
                    13      136      2      1     Oi      1   693
                    14      136     13     61     C1      4   696
                    15      136     61     76     C2      5   697")
                    
depths(hz) &lt;- peiidref ~ hzdept + hzdepb

hz_fixed &lt;- accumulateDepths(hz,
                             id = "peiidref",
                             hzdepths = c("hzdept", "hzdepb"),
                             hzname = "hzname")
is_valid &lt;- checkHzDepthLogic(hz_fixed)$valid

test0 &lt;- subset(hz_fixed, !is_valid)
test1 &lt;- subset(hz_fixed, is_valid)

origO &lt;- subset(hz, grepl("O", hzname))
fixedO &lt;- subset(hz_fixed, grepl("O", hzname))

par(mfrow=c(2,1), mar=c(0,0,3,2))
plotSPC(origO, max.depth = 25)
plotSPC(fixedO, max.depth = 25)

</code></pre>

<hr>
<h2 id='addBracket'>Add Depth Brackets</h2><span id='topic+addBracket'></span>

<h3>Description</h3>

<p>Add depth brackets to soil profile sketches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addBracket(
  x,
  label.cex = 0.75,
  tick.length = 0.05,
  arrow.length = 0.05,
  offset = -0.3,
  missing.bottom.depth = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addBracket_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> object containing <code>idname(x)</code>, <code>top</code>, <code>bottom</code>, and optionally <code>label</code> columns</p>
</td></tr>
<tr><td><code id="addBracket_+3A_label.cex">label.cex</code></td>
<td>
<p>scaling factor for label font</p>
</td></tr>
<tr><td><code id="addBracket_+3A_tick.length">tick.length</code></td>
<td>
<p>length of bracket &quot;tick&quot; mark</p>
</td></tr>
<tr><td><code id="addBracket_+3A_arrow.length">arrow.length</code></td>
<td>
<p>length of arrowhead</p>
</td></tr>
<tr><td><code id="addBracket_+3A_offset">offset</code></td>
<td>
<p>left-hand offset from each profile</p>
</td></tr>
<tr><td><code id="addBracket_+3A_missing.bottom.depth">missing.bottom.depth</code></td>
<td>
<p>distance (in depth units) to extend brackets that are missing a lower depth (defaults to max depth of collection)</p>
</td></tr>
<tr><td><code id="addBracket_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code>segments</code> or <code>arrows</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> may contain multiple records per profile. Additional examples can be found in <a href="http://ncss-tech.github.io/AQP/aqp/SPC-plotting-ideas.html">this tutorial</a>.
</p>


<h3>Note</h3>

<p>This is a <code>low-level</code> plotting function: you must first plot a <code>SoilProfileCollection</code> object before using this function.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addDiagnosticBracket">addDiagnosticBracket</a>, <a href="#topic+plotSPC">plotSPC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# sample data
data(sp1)

# add color vector
sp1$soil_color &lt;- with(sp1, munsell2rgb(hue, value, chroma))

# promote to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom

# plot profiles
par(mar = c(0, 0, 0, 1))
plotSPC(sp1, width = 0.3)

# extract min--max depths associated with all A horizons
# result is a single-row data.frame / profile
combinedBracket &lt;- function(i) {
  h &lt;- horizons(i)
  idn &lt;- idname(i)
  this.id &lt;- h[[idn]][1]
  
  idx &lt;- grep('^A', h$name)
  
  res &lt;- data.frame(
    id = this.id,
    top = min(h$top[idx]), 
    bottom = max(h$bottom[idx], na.rm=TRUE)
  )
  names(res)[1] &lt;- idn
  
  return(res)
}

# return matching horizon top / bottom depths for A or C horizons
# result is a 0 or more row data.frame / profile
individualBrackets &lt;- function(i) {
  h &lt;- horizons(i)
  idn &lt;- idname(i)
  this.id &lt;- h[[idn]][1]
  
  idx &lt;- grep('^A|^C', h$name)
  
  res &lt;- data.frame(
    id = this.id,
    top = h$top[idx], 
    bottom = h$bottom[idx]
  )
  names(res)[1] &lt;- idn
  
  return(res)
}

# combined brackets
b1 &lt;- profileApply(sp1, combinedBracket, frameify = TRUE)

# individual brackets
b2 &lt;- profileApply(sp1, individualBrackets, frameify = TRUE)

# plot in reverse order
plotSPC(sp1, plot.order = rev(1:length(sp1)), width = 0.25)

# note that plotting order is derived from the call to `plotSPC(sp1)`
addBracket(b1, col='red', offset = -0.35)

# plot in reverse order
plotSPC(sp1, plot.order = rev(1:length(sp1)), width = 0.25)

# note that plotting order is derived from the call to `plotSPC(sp1)`
addBracket(b2, col='red', offset = -0.35)


</code></pre>

<hr>
<h2 id='addDiagnosticBracket'>Annotate Diagnostic Features</h2><span id='topic+addDiagnosticBracket'></span>

<h3>Description</h3>

<p>Annotate diagnostic features within a sketch of soil profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addDiagnosticBracket(
  s,
  kind,
  feature = "featkind",
  top = "featdept",
  bottom = "featdepb",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addDiagnosticBracket_+3A_s">s</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="addDiagnosticBracket_+3A_kind">kind</code></td>
<td>
<p>filter applied to <code>feature</code> column of diagnostic horizons registered within <code>s</code></p>
</td></tr>
<tr><td><code id="addDiagnosticBracket_+3A_feature">feature</code></td>
<td>
<p>column name containing feature kind</p>
</td></tr>
<tr><td><code id="addDiagnosticBracket_+3A_top">top</code></td>
<td>
<p>column name containing feature top depth</p>
</td></tr>
<tr><td><code id="addDiagnosticBracket_+3A_bottom">bottom</code></td>
<td>
<p>column name containing feature top depth</p>
</td></tr>
<tr><td><code id="addDiagnosticBracket_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>addBracket</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional examples can be found in <a href="http://ncss-tech.github.io/AQP/aqp/SPC-plotting-ideas.html">this tutorial</a>.
</p>


<h3>Note</h3>

<p>This is a <code>low-level</code> plotting function: you must first plot a <code>SoilProfileCollection</code> object before using this function.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addBracket">addBracket</a>, <a href="#topic+plotSPC">plotSPC</a></code>
</p>

<hr>
<h2 id='addVolumeFraction'>Symbolize Volume Fraction on a Soil Profile Collection Plot</h2><span id='topic+addVolumeFraction'></span>

<h3>Description</h3>

<p>Symbolize volume fraction on an existing soil profile collection plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addVolumeFraction(
  x,
  colname,
  res = 10,
  cex.min = 0.1,
  cex.max = 0.5,
  pch = 1,
  col = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addVolumeFraction_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="addVolumeFraction_+3A_colname">colname</code></td>
<td>
<p>character vector of length 1, naming the column containing volume fraction data (horizon-level attribute)</p>
</td></tr>
<tr><td><code id="addVolumeFraction_+3A_res">res</code></td>
<td>
<p>integer, resolution of the grid used to symbolize volume fraction</p>
</td></tr>
<tr><td><code id="addVolumeFraction_+3A_cex.min">cex.min</code></td>
<td>
<p>minimum symbol size</p>
</td></tr>
<tr><td><code id="addVolumeFraction_+3A_cex.max">cex.max</code></td>
<td>
<p>maximum symbol size</p>
</td></tr>
<tr><td><code id="addVolumeFraction_+3A_pch">pch</code></td>
<td>
<p>integer, plotting character code</p>
</td></tr>
<tr><td><code id="addVolumeFraction_+3A_col">col</code></td>
<td>
<p>symbol color, either a single color or as many colors as there are horizons in <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can only be called after plotting a <code>SoilProfileCollection</code> object. Details associated with a call to <code>plotSPC</code> are automatically accounted for within this function: e.g. <code>plot.order</code>, <code>width</code>, etc..
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSPC">plotSPC</a></code>
</p>

<hr>
<h2 id='aggregateColor'>Summarize Soil Colors</h2><span id='topic+aggregateColor'></span>

<h3>Description</h3>

<p>Summarize soil color data, weighted by occurrence and horizon thickness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateColor(
  x,
  groups = "genhz",
  col = "soil_color",
  colorSpace = "CIE2000",
  k = NULL,
  profile_wt = NULL,
  mixingMethod = c("estimate", "exact")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateColor_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="aggregateColor_+3A_groups">groups</code></td>
<td>
<p>the name of a horizon or site attribute used to group horizons, see examples</p>
</td></tr>
<tr><td><code id="aggregateColor_+3A_col">col</code></td>
<td>
<p>the name of a horizon-level attribute with soil color specified in hexadecimal (i.e. &quot;#rrggbb&quot;)</p>
</td></tr>
<tr><td><code id="aggregateColor_+3A_colorspace">colorSpace</code></td>
<td>
<p>(now deprecated, removed in aqp 2.1) 'CIE2000' used for all cases</p>
</td></tr>
<tr><td><code id="aggregateColor_+3A_k">k</code></td>
<td>
<p>single integer specifying the number of colors discretized via PAM (<code><a href="cluster.html#topic+pam">cluster::pam()</a></code>), see details</p>
</td></tr>
<tr><td><code id="aggregateColor_+3A_profile_wt">profile_wt</code></td>
<td>
<p>the name of a site-level attribute used to modify weighting, e.g. area</p>
</td></tr>
<tr><td><code id="aggregateColor_+3A_mixingmethod">mixingMethod</code></td>
<td>
<p>method used to estimate &quot;aggregate&quot; soil colors, see <code><a href="#topic+mixMunsell">mixMunsell()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Weights are computed by:
<code>w_i = sqrt(sum(thickness_i)) * n_i</code>
where <code>w_i</code> is the weight associated with color <code>i</code>, <code>thickness_i</code> is the total thickness of all horizons associated with the color <code>i</code>, and <code>n_i</code> is the number of horizons associated with color <code>i</code>. Weights are computed within groups specified by <code>groups</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>scaled.data</code></td>
<td>
<p>a <code>list</code> of colors and associated weights, one item for each generalized horizon label with at least one color specified in the source data</p>
</td></tr>
<tr><td><code>aggregate.data</code></td>
<td>
<p>a <code>data.frame</code> of weighted-mean colors, one row for each generalized horizon label with at least one color specified in the source data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generalize.hz">generalize.hz()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# load some example data
data(sp1, package='aqp')

# upgrade to SoilProfileCollection and convert Munsell colors
sp1$soil_color &lt;- with(sp1, munsell2rgb(hue, value, chroma))
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

# generalize horizon names
n &lt;- c('O', 'A', 'B', 'C')
p &lt;- c('O', 'A', 'B', 'C')
sp1$genhz &lt;- generalize.hz(sp1$name, n, p)

# aggregate colors over horizon-level attribute: 'genhz'
a &lt;- aggregateColor(sp1, groups = 'genhz', col = 'soil_color')

# check results
str(a)

## Not run: 
# aggregate colors over site-level attribute: 'group'
a &lt;- aggregateColor(sp1, groups = 'group', col = 'soil_color')

# aggregate colors over site-level attribute: 'group'
# discretize colors to 4 per group
a &lt;- aggregateColor(sp1, groups = 'group', col = 'soil_color', k = 4)

# aggregate colors over depth-slices
s &lt;- dice(sp1, c(5, 10, 15, 25, 50, 100, 150) ~ soil_color)
s$slice &lt;- paste0(s$top, ' cm')
s$slice &lt;- factor(s$slice, levels=guessGenHzLevels(s, 'slice')$levels)
a &lt;- aggregateColor(s, groups = 'slice', col = 'soil_color')

  # optionally plot with helper function
  if(require(sharpshootR))
    aggregateColorPlot(a)

# a more interesting example
  data(loafercreek, package = 'soilDB')
  
  # generalize horizon names using REGEX rules
  n &lt;- c('Oi', 'A', 'BA','Bt1','Bt2','Bt3','Cr','R')
  p &lt;- c('O', '^A$|Ad|Ap|AB','BA$|Bw', 
         'Bt1$|^B$','^Bt$|^Bt2$','^Bt3|^Bt4|CBt$|BCt$|2Bt|2CB$|^C$','Cr','R')
  loafercreek$genhz &lt;- generalize.hz(loafercreek$hzname, n, p)
  
  # remove non-matching generalized horizon names
  loafercreek$genhz[loafercreek$genhz == 'not-used'] &lt;- NA
  loafercreek$genhz &lt;- factor(loafercreek$genhz)
  
  a &lt;- aggregateColor(loafercreek, 'genhz')
  
  # plot results with helper function
  par(mar=c(1,4,4,1))
  aggregateColorPlot(a, print.n.hz = TRUE)
  
  # inspect aggregate data
  a$aggregate.data

## End(Not run)

</code></pre>

<hr>
<h2 id='aggregateSoilDepth'>Probabalistic Estimation of Soil Depth within Groups</h2><span id='topic+aggregateSoilDepth'></span>

<h3>Description</h3>

<p>Estimate the most-likely depth to contact within a collection of soil profiles. Consider <code>getSoilDepthClass</code> followed by group-wise percentile estimation as a faster alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateSoilDepth(
  x,
  groups,
  crit.prob = 0.9,
  name = hzdesgnname(x),
  p = "Cr|R|Cd",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateSoilDepth_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="aggregateSoilDepth_+3A_groups">groups</code></td>
<td>
<p>the name of a site-level attribute that defines groups of profiles within a collection</p>
</td></tr>
<tr><td><code id="aggregateSoilDepth_+3A_crit.prob">crit.prob</code></td>
<td>
<p>probability cutoff used to determine where the most likely depth to contact will be, e.g. 0.9 translates to 90% of profiles are shallower than this depth</p>
</td></tr>
<tr><td><code id="aggregateSoilDepth_+3A_name">name</code></td>
<td>
<p>horizon-level attribute where horizon designation is stored, defaults to <code>hzdesgnname(x)</code></p>
</td></tr>
<tr><td><code id="aggregateSoilDepth_+3A_p">p</code></td>
<td>
<p>a REGEX pattern that matches non-soil genetic horizons</p>
</td></tr>
<tr><td><code id="aggregateSoilDepth_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>slab</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a probability-based estimate of soil depth by group. If no grouping variable exists, a dummy value can be used to compute a single estimate. The <code>crit.prob</code> argument sets the critical probability (e.g. 0.9) at which soil depth within a group of profiles is determined. For example, a <code>crit.prob</code> of 0.95 might result in an estimated soil depth (e.g. 120cm) where 95% of the profiles (by group) had depths that were less than or equal to 120cm.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> is returned, with as many rows as there are unique group labels, as specified in <code>groups</code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateSoilDepth">estimateSoilDepth()</a></code> <code><a href="#topic+slab">slab()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

# set horizon designation in SPC
hzdesgnname(sp1) &lt;- 'name'

aggregateSoilDepth(sp1, 'group', crit.prob = 0.9)

</code></pre>

<hr>
<h2 id='alignTransect'>Calculate Relative Positions from Transect Data</h2><span id='topic+alignTransect'></span>

<h3>Description</h3>

<p>This function is used to support relative positioning of soil profiles by <code>plotSPC</code>, based on transect or gradient values typically associated with a site level attribute (e.g. elevation). Gradient values specified in <code>x</code> are translated to the range used by <code>plotSPC</code> (usually <code style="white-space: pre;">&#8288;1, length(SPC)&#8288;</code>) specified in <code>x.min</code> and <code>x.max</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignTransect(x, x.min, x.max, fix = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignTransect_+3A_x">x</code></td>
<td>
<p>numeric vector, describing values along a transect: distance, elevation, climatic variables, etc.. Typically sourced from the site level attributes of a <code>SoilProfileCollection</code> object. Order is not important.</p>
</td></tr>
<tr><td><code id="alignTransect_+3A_x.min">x.min</code></td>
<td>
<p>numeric, lower boundary to relative position scale</p>
</td></tr>
<tr><td><code id="alignTransect_+3A_x.max">x.max</code></td>
<td>
<p>numeric, upper boundary to relative position scale</p>
</td></tr>
<tr><td><code id="alignTransect_+3A_fix">fix</code></td>
<td>
<p>logical, attempt fixing overlapping positions with <code>fixOverlap</code></p>
</td></tr>
<tr><td><code id="alignTransect_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>fixOverlap</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="http://ncss-tech.github.io/AQP/aqp/genhz-distance-eval.html">Pair-Wise Distances by Generalized Horizon Labels</a> tutorial for additional examples.
</p>


<h3>Value</h3>

<p><code>list</code> containing:
</p>

<ul>
<li> <p><code>grad</code>: values of <code>x</code> in ascending order
</p>
</li>
<li> <p><code>order</code>: ordering vector of <code>x</code>
</p>
</li>
<li> <p><code>relative.pos</code>: elements of <code>x</code> translated to the new relative scale defined by <code>x.min</code> and <code>x.max</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data("sierraTransect")

# split transects
g &lt;- subset(sierraTransect, transect == 'Granite')
a &lt;- subset(sierraTransect, transect == 'Andesite')

g.p &lt;- alignTransect(g$elev, x.min = 1, x.max = length(g), fix = FALSE)
a.p &lt;- alignTransect(a$elev, x.min = 1, x.max = length(a), fix = FALSE)

op &lt;- par(mar=c(2,0,0,2), mfrow=c(2,1))

plotSPC(g, width=0.25, name.style='center-center', 
        cex.names=0.75, 
        relative.pos = g.p$relative.pos, plot.order = g.p$order)

axis(1, at = g.p$relative.pos, labels = g.p$grad, line = -1.5)

plotSPC(a, width=0.25, name.style='center-center', 
        cex.names=0.75, 
        relative.pos = a.p$relative.pos, plot.order = a.p$order)

axis(1, at = a.p$relative.pos, labels = a.p$grad, line = -1.5)


par(op)

</code></pre>

<hr>
<h2 id='allocate'>Allocate soil properties within various classification systems.</h2><span id='topic+allocate'></span>

<h3>Description</h3>

<p>Generic function to allocate soil properties to different classification schemes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocate(
  ...,
  to = c("FAO Salt Severity", "FAO Black Soil", "ST Diagnostic Features"),
  droplevels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allocate_+3A_...">...</code></td>
<td>
<p>arguments to specific allocation functions, see details and examples</p>
</td></tr>
<tr><td><code id="allocate_+3A_to">to</code></td>
<td>
<p>character specifying the classification scheme: FAO Salt Severity, FAO Black Soil (see details for the required <code>...</code>)</p>
</td></tr>
<tr><td><code id="allocate_+3A_droplevels">droplevels</code></td>
<td>
<p>logical indicating whether to drop unused levels in factors. This is useful when the results have a large number of unused classes, which can waste space in tables and figures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to allocate a set of soil properties to an established soil classification scheme, such as Salt Severity or Black Soil. Allocation is semantically different from classification. While classification is the 'act' of developing a grouping scheme, allocation is the assignment or identification of measurements to a established class (Powell, 2008).
</p>


<h4>Usage Details</h4>

<p>Each classification scheme (<code>to</code> argument) uses a different set of arguments.
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;FAO Salt Severity&#8288;</code>
</p>

<ul>
<li> <p><strong>EC:</strong> electrical conductivity column name, dS/m
</p>
</li>
<li> <p><strong>pH:</strong> pH column name, saturated paste extract
</p>
</li>
<li> <p><strong>ESP:</strong> exchangeable sodium percentage column name, percent
</p>
</li></ul>

</li>
<li> <p><code style="white-space: pre;">&#8288;FAO Black Soils&#8288;</code>
</p>

<ul>
<li> <p><strong>object:</strong> a <code>data.frame</code> or <code>SoilProfileCollection</code>
</p>
</li>
<li> <p><strong>pedonid:</strong> pedon ID column name, required when <code>object</code> is a <code>data.frame</code>
</p>
</li>
<li> <p><strong>hztop:</strong> horizon top depth column name, required when <code>object</code> is a <code>data.frame</code>
</p>
</li>
<li> <p><strong>hzbot:</strong> horizon bottom depth column name, required when <code>object</code> is a <code>data.frame</code>
</p>
</li>
<li> <p><strong>OC</strong>: organic carbon column name, percent
</p>
</li>
<li> <p><strong>m_chroma:</strong> moist Munsell chroma column name
</p>
</li>
<li> <p><strong>m_value:</strong> moist Munsell value column name
</p>
</li>
<li> <p><strong>d_value:</strong> dry Munsell value column name
</p>
</li>
<li> <p><strong>CEC:</strong> cation exchange capacity column name (NH4OAc at pH 7), units of cmol(+)/kg soil
</p>
</li>
<li> <p><strong>BS:</strong> base saturation column name (NH4OAc at pH 7), percent
</p>
</li>
<li> <p><strong>tropical:</strong> logical, data are associated with &quot;tropical soils&quot;
</p>
</li></ul>

</li>
<li> <p><code style="white-space: pre;">&#8288;ST Diagnostic Features&#8288;</code>
</p>

<ul>
<li> <p><strong>object:</strong> a <code>data.frame</code> or <code>SoilProfileCollection</code>
</p>
</li>
<li> <p><strong>pedonid:</strong> pedon ID column name, required when <code>object</code> is a <code>data.frame</code>
</p>
</li>
<li> <p><strong>hzname:</strong> horizon name column, required when <code>object</code> is a <code>data.frame</code>
</p>
</li>
<li> <p><strong>hztop:</strong> horizon top depth column name, required when <code>object</code> is a <code>data.frame</code>
</p>
</li>
<li> <p><strong>hzbot:</strong> horizon bottom depth column name, required when <code>object</code> is a <code>data.frame</code>
</p>
</li>
<li> <p><strong>texcl:</strong> soil texture class (USDA) column name
</p>
</li>
<li> <p><strong>rupresblkcem:</strong> rupture resistance column name
</p>
</li>
<li> <p><strong>m_value:</strong> moist Munsell value column name
</p>
</li>
<li> <p><strong>m_chroma:</strong> moist Munsell chroma column name
</p>
</li>
<li> <p><strong>d_value:</strong> dry Munsell value column name
</p>
</li>
<li> <p><strong>BS:</strong> base saturation column name (method ??), percent
</p>
</li>
<li> <p><strong>OC</strong>: organic carbon column name, percent
</p>
</li>
<li> <p><strong>n_value:</strong> ??
</p>
</li>
<li> <p><strong>featkind:</strong> ??
</p>
</li></ul>

</li></ul>




<h3>Value</h3>

<p>A vector or <code>data.frame</code> object.
</p>


<h3>Note</h3>

<p>The results returned by <code>allocate(to = "ST Diagnostic Features")</code> currently return a limited set of diagnostic features that are easily defined. Also, the logic implemented for some features does not include all the criteria defined in the Keys to Soil Taxonomy.
</p>


<h3>References</h3>

<p>Abrol, I., Yadav, J. &amp; Massoud, F. 1988. <a href="https://www.fao.org/3/x5871e/x5871e00.htm">Salt-affected soils and their management</a>. No. Bulletin 39. Rome, FAO Soils.
</p>
<p>FAO. 2006. <a href="https://www.fao.org/publications/card/en/c/903943c7-f56a-521a-8d32-459e7e0cdae9/">Guidelines for soil description</a>. Rome, Food and Agriculture Organization of the United Nations.
</p>
<p>FAO. 2020. DEFINITION | What is a black soil? (online). (Cited 28 December 2020). http://www.fao.org/global-soil-partnership/intergovernmental-technical-panel-soils/gsoc17-implementation/internationalnetworkblacksoils/more-on-black-soils/definition-what-is-a-black-soil/es/
</p>
<p>Powell, B., 2008. Classifying soil and land, in: McKenzie, N.J., Grundy, M.J., Webster, R., Ringrose-Voase, A.J. (Eds.), Guidelines for Survey Soil and Land Resources, Australian Soil and Land Survey Handbook Series. CSIRO, Melbourne, p. 572.
</p>
<p>Richards, L.A. 1954. <a href="https://www.ars.usda.gov/ARSUserFiles/20360500/hb60_pdf/hb60complete.pdf">Diagnosis and Improvement of Saline and Alkali Soils</a>. U. S. Government Printing Office. 166 pp.
</p>
<p>Soil Survey Staff, 2014. Keys to Soil Taxonomy, 12th ed. USDA-Natural Resources Conservation Service, Washington, D.C.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Salt Severity
test &lt;- expand.grid(
  EC  = sort(sapply(c(0, 0.75, 2, 4, 8, 15, 30), function(x) x + c(0, -0.05, 0.05))),
  pH  = c(8.1, 8.2, 8.3, 8.4, 8.5, 8.6),
  ESP = sort(sapply(c(0, 15, 30, 50, 70, 100), function(x) x + c(0, 0.1, -0.1)))
)
test$ss      &lt;- with(test, allocate(EC = EC, pH = pH, ESP = ESP, to = "FAO Salt Severity"))
table(test$ss)

# Black Soil Category 1 (BS1)
test &lt;- expand.grid(
  dept = seq(0, 50, 10),
  OC   = sort(sapply(c(0, 0.6, 1.2, 20, 40), function(x) x + c(0, -0.05, 0.05))),
  chroma_moist  = 2:4,
  value_moist   = 2:4,
  value_dry     = 4:6,
  thickness     = 24:26,
  CEC           = 24:26,
  BS            = 49:51,
  tropical      = c(TRUE, FALSE)
)
test$pedon_id &lt;- rep(1:21870, each = 6)
test$depb     &lt;- test$dept + 10

bs1 &lt;- allocate(test, pedonid = "pedon_id", hztop = "dept", hzbot = "depb", 
                OC = "OC", m_chroma = "chroma_moist", m_value = "value_moist", 
                d_value = "value_dry", CEC = "CEC", BS = "BS", 
                to = "FAO Black Soil"
)

table(BS1 = bs1$BS1, BS2 = bs1$BS2)


# SoilProfileCollection interface

data(sp3)
depths(sp3) &lt;- id ~ top + bottom
hzdesgnname(sp3) &lt;- 'name'

# fake base saturation
horizons(sp3)$bs &lt;- 75

plotSPC(sp3)

allocate(
  sp3, 
  to = 'FAO Black Soil', 
  OC = 'tc', 
  m_chroma = 'chroma', 
  m_value = 'value', 
  d_value = 'value',
  CEC = 'cec',
  BS = 'bs'
)

# make a copy and edit horizon values
x &lt;- sp3
x$value &lt;- 2
x$chroma &lt;- 2
x$cec &lt;- 26
x$tc &lt;- 2

x$soil_color &lt;- munsell2rgb(x$hue, x$value, x$chroma)

plotSPC(x)

allocate(
  x, 
  to = 'FAO Black Soil', 
  OC = 'tc', 
  m_chroma = 'chroma', 
  m_value = 'value', 
  d_value = 'value',
  CEC = 'cec',
  BS = 'bs'
)


# Soil Taxonomy Diagnostic Features
data(sp1)
sp1$texcl = gsub("gr|grv|cbv", "", sp1$texture)
df &lt;- allocate(object = sp1, pedonid = "id", hzname = "name", 
               hzdept = "top", hzdepb = "bottom", texcl = "texcl", 
               to = "ST Diagnostic Features"
)
aggregate(featdept ~ id, data = df, summary)

</code></pre>

<hr>
<h2 id='aqp_df_class+2CSoilProfileCollection-method'>Get aqp_df_class entry from metadata or return a safe value.</h2><span id='topic+aqp_df_class+2CSoilProfileCollection-method'></span><span id='topic+aqp_df_class'></span><span id='topic+aqp_df_class+3C-+2CSoilProfileCollection-method'></span><span id='topic+aqp_df_class+3C-'></span>

<h3>Description</h3>

<p>This is an accessor and replacement method for the <code>aqp_df_class</code> entry in the metadata slot. This entry is used internally by methods that interact with <code>data.frame</code> objects and slots to ensure that the same class used to promote to the SoilProfileCollection initially is used throughout the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
aqp_df_class(object)

## S4 replacement method for signature 'SoilProfileCollection'
aqp_df_class(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aqp_df_class+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="aqp_df_class+2B2CSoilProfileCollection-method_+3A_value">value</code></td>
<td>
<p>&quot;data.frame&quot;, &quot;data.table&quot; or &quot;tbl_df&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='argillic.clay.increase.depth'>Return upper boundary of argillic horizon</h2><span id='topic+argillic.clay.increase.depth'></span>

<h3>Description</h3>

<p>Returns the top depth of the argillic horizon as a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argillic.clay.increase.depth(p, clay.attr = "clay")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="argillic.clay.increase.depth_+3A_p">p</code></td>
<td>
<p>A single-profile <code>SoilProfileCollection</code> object.</p>
</td></tr>
<tr><td><code id="argillic.clay.increase.depth_+3A_clay.attr">clay.attr</code></td>
<td>
<p>OPTIONAL: horizon attribute name referring to clay content.
default: <code>clay</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>crit.clay.argillic</code> to determine threshold clay increase, and
<code>get.increase.matrix</code> to determine where increase is met within a
vertical distance of 30 cm.
</p>


<h3>Value</h3>

<p>A numeric vector containing top depth of argillic horizon, if
present, or NA.
</p>


<h3>Author(s)</h3>

<p>Andrew Gene Brown
</p>


<h3>See Also</h3>

<p><code>getArgillicBounds</code>, <code>get.increase.matrix</code>,
<code>crit.clay.argillic</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1, package = 'aqp')
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

p &lt;- sp1[1]
attr &lt;- 'prop' # clay contents 
foo &lt;- argillic.clay.increase.depth(p, clay.attr = attr)
foo

</code></pre>

<hr>
<h2 id='as'>Coerce SoilProfileCollection with <code>as()</code></h2><span id='topic+as'></span><span id='topic+as+2CSoilProfileCollection-method'></span><span id='topic+as.data.frame+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>SoilProfileCollections can be coerced to other R object types using <code>as(spc, 'type')</code>.
</p>
<p>Possible endpoints include: <code>list</code>, <code>data.frame</code>, <code>SpatialPointsDataFrame</code> and <code>SpatialPoints</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
as.data.frame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>
<p>data.frame
</p>
<p>tbl_df
</p>
<p>data.table
</p>
<p>SpatialPointsDataFrame
</p>
<p>sf
</p>
<p>SpatialPoints
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data stored as SoilProfileCollection
data(sp5)

# sp5
str(sp5)

# list output
str(as(sp5, 'list'))

# data.frame output
str(as(sp5, 'data.frame'))

# Spatial Objects
# make some random coordinate data for each profile
sp5$x &lt;- sp5$y &lt;- rnorm(length(sp5))
initSpatial(sp5, crs = "OGC:CRS84") &lt;- ~ x + y

# SpatialPointsDataFrame output
str(as(sp5, 'SpatialPointsDataFrame'))

# SpatialPoints output
str(as(sp5, 'SpatialPoints'))
</code></pre>

<hr>
<h2 id='barron.torrent.redness.LAB'>Barron &amp; Torrent (1986) Redness Index in LAB color space</h2><span id='topic+barron.torrent.redness.LAB'></span>

<h3>Description</h3>

<p>Calculate Redness Index after Barron &amp; Torrent (1986) &quot;Use of the Kubelka—Munk Theory to Study the Influence of Iron Oxides on Soil Colour&quot; using Munsell colors converted to LAB. DOI: 10.1111/j.1365-2389.1986.tb00382.x. Accepts vectorized inputs for hue, value and chroma, produces vector output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barron.torrent.redness.LAB(hue, value, chroma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barron.torrent.redness.LAB_+3A_hue">hue</code></td>
<td>
<p>A character vector containing Munsell hues (e.g. &quot;7.5YR&quot;)</p>
</td></tr>
<tr><td><code id="barron.torrent.redness.LAB_+3A_value">value</code></td>
<td>
<p>A numeric vector containing Munsell values</p>
</td></tr>
<tr><td><code id="barron.torrent.redness.LAB_+3A_chroma">chroma</code></td>
<td>
<p>A numeric vector containing Munsell chromas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of horizon redness index (higher values = redder).
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>References</h3>

<p>Barron, V. and Torrent, J. (1986), Use of the Kubelka—Munk theory to study the influence of iron oxides on soil colour. Journal of Soil Science, 37: 499-510. doi:10.1111/j.1365-2389.1986.tb00382.x
</p>

<hr>
<h2 id='bootstrapSoilTexture'>Bootstrap Soil Texture Data</h2><span id='topic+bootstrapSoilTexture'></span>

<h3>Description</h3>

<p>Simulate realistic sand/silt/clay values (a composition) using multivariate Normal distribution or Dirichlet distribution. Simulations from the multivariate Normal distribution are based on the compositional mean and variance-covariance matrix. Simulations from the Dirichlet distribution are based on maximum likelihood estimation of <code>alpha</code> parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrapSoilTexture(ssc, method = c("dirichlet", "normal"), n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapSoilTexture_+3A_ssc">ssc</code></td>
<td>
<p>a <code>data.frame</code> object with 3 columns: 'sand', 'silt', 'clay' and at least three rows of data within the range of 0-100 (percent). NA are automatically removed, but care should be taken to ensure that the sand/silt/clay values add to 100 percent. Simulations are based on these examples.</p>
</td></tr>
<tr><td><code id="bootstrapSoilTexture_+3A_method">method</code></td>
<td>
<p>type of simulation: 'dirichlet' or 'normal'. See details.</p>
</td></tr>
<tr><td><code id="bootstrapSoilTexture_+3A_n">n</code></td>
<td>
<p>number of simulated compositions. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulations from the multivariate normal distribution will more closely track the marginal distributions of sand, silt, and clay&ndash;possibly a better fit for &quot;squished&quot; compositions (TODO elaborate). However, these simulations can result in extreme (unlikely) estimates.
</p>
<p>Simulations from the Dirichlet distribution will usually be a better fit (fewer extreme estimates) but require a fairly large number of records in <code>ssc</code> (<code>n &gt;= 30</code>?) for a reliable fit.
</p>
<p>Additional examples will be added to <a href="http://ncss-tech.github.io/AQP/aqp/soiltexture-vizualization-ideas.html">this tutorial</a>.
</p>


<h3>Value</h3>

<p>a <code>list</code> containing:
</p>

<ul>
<li> <p><code>samples</code> - <code>data.frame</code> of simulated sand, silt, clay values
</p>
</li>
<li> <p><code>mean</code> - compositional mean
</p>
</li>
<li> <p><code>var</code> - compositional variance-covariance matrix
</p>
</li>
<li> <p><code>D.alpha</code> - (fitted) alpha parameters of the Dirichlet distribution, <code>NULL</code> when <code>method = 'normal'</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Aitchison, J. (1986) The Statistical Analysis of Compositional Data Monographs on Statistics and Applied Probability. Chapman &amp; Hall Ltd., London (UK). 416p.
</p>
<p>Aitchison, J, C. Barcel'o-Vidal, J.J. Egozcue, V. Pawlowsky-Glahn (2002) A concise guide to the algebraic geometric structure of the simplex, the sample space for compositional data analysis, Terra Nostra, Schriften der Alfred Wegener-Stiftung, 03/2003
</p>
<p>Malone Brendan, Searle Ross (2021) Updating the Australian digital soil texture mapping (Part 1*): re-calibration of field soil texture class centroids and description of a field soil texture conversion algorithm. Soil Research. https://www.publish.csiro.au/SR/SR20283
</p>
<p>Malone Brendan, Searle Ross (2021) Updating the Australian digital soil texture mapping (Part 2*): spatial modelling of merged field and lab measurements. Soil Research. https://doi.org/10.1071/SR20284
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if(
requireNamespace("compositions") &amp;
  requireNamespace("soiltexture")
) {
  
  # sample data, data.frame
  data('sp4')
  
  # filter just Bt horizon data
  ssc &lt;- sp4[grep('^Bt', sp4$name), c('sand', 'silt', 'clay')]
  names(ssc) &lt;- toupper(names(ssc))
  
  # simulate 100 samples
  s &lt;- bootstrapSoilTexture(ssc, n = 100)
  s &lt;- s$samples
  
  # empty soil texture triangle
  TT &lt;- soiltexture::TT.plot(
    class.sys= "USDA-NCSS.TT",
    main= "",
    tri.sum.tst=FALSE,
    cex.lab=0.75,
    cex.axis=0.75,
    frame.bg.col='white',
    class.lab.col='black',
    lwd.axis=1.5,
    arrows.show=TRUE,
    new.mar = c(3, 0, 0, 0)
  )
  
  # add original data points
  soiltexture::TT.points(
    tri.data = s, geo = TT, col='firebrick', 
    pch = 3, cex = 0.5, lwd = 1, 
    tri.sum.tst = FALSE
  )
  
  # add simulated points
  soiltexture::TT.points(
    tri.data = ssc, geo = TT, bg='royalblue', 
    pch = 22, cex = 1, lwd = 1, 
    tri.sum.tst = FALSE
  )
  
  # simple legend
  legend('top', 
         legend = c('Source', 'Simulated'), 
         pch = c(22, 3), 
         col = c('black', 'firebrick'), 
         pt.bg = c('royalblue', NA), 
         horiz = TRUE, bty = 'n'
  )
  
  
}



</code></pre>

<hr>
<h2 id='brierScore'>Multinominal Brier Score</h2><span id='topic+brierScore'></span>

<h3>Description</h3>

<p>Compute a multinominal Brier score from predicted class probabilities and observed class label. Lower values are associated with a more accurate classifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brierScore(x, classLabels, actual = "actual")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brierScore_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> of class probabilities (numeric) and observed class label (character), see examples</p>
</td></tr>
<tr><td><code id="brierScore_+3A_classlabels">classLabels</code></td>
<td>
<p>vector of predicted class labels (probabilities), corresponding to column names in <code>x</code></p>
</td></tr>
<tr><td><code id="brierScore_+3A_actual">actual</code></td>
<td>
<p>name of column containing the observed class, should be character vector not factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single Brier score, representative of data in <code>x</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Brier, Glenn W. 1950. &quot;Verification of Forecasts Expressed in Terms of Probability.&quot; Monthly Weather Review 78 (1): 1-3. doi:10.1175/1520-0493(1950)078&lt;0001:VOFEIT&gt;2.0.CO;2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# columns 'a', 'b', 'c' contain predicted probabilities
# column 'actual' contains observed class label

# a good classifier
d.good &lt;- data.frame(
  a = c(0.05, 0.05, 0.10),
  b = c(0.90, 0.85, 0.75),
  c = c(0.05, 0.10, 0.15),
  actual = c('b', 'b', 'b'),
  stringsAsFactors = FALSE
)

# a rather bad classifier
d.bad &lt;- data.frame(
  a = c(0.05, 0.05, 0.10),
  b = c(0.90, 0.85, 0.75),
  c = c(0.05, 0.10, 0.15),
  actual = c('c', 'c', 'c'),
  stringsAsFactors = FALSE
)

# class labels are factors
d.factors &lt;- data.frame(
  a = c(0.05, 0.05, 0.10),
  b = c(0.90, 0.85, 0.75),
  c = c(0.05, 0.10, 0.15),
  actual = c('b', 'b', 'b'),
  stringsAsFactors = TRUE
)

# relatively low value = accurate
brierScore(x = d.good, classLabels = c('a', 'b', 'c'), actual = 'actual')

# high values = not accuate
brierScore(x = d.bad, classLabels = c('a', 'b', 'c'), actual = 'actual')

# message related to conversion of factor -&gt; character
brierScore(x = d.factors, classLabels = c('a', 'b', 'c'), actual = 'actual')

</code></pre>

<hr>
<h2 id='buntley.westin.index'>Buntley-Westin (1965) Index</h2><span id='topic+buntley.westin.index'></span>

<h3>Description</h3>

<p>Calculate &quot;Color Development Equivalent&quot; by the method of Buntley &amp; Westin (1965) &quot;A Comparative Study of Developmental Color in a Chestnut-Chernozem-Brunizem Soil Climosequence&quot; DOI: 10.2136/sssaj1965.03615995002900050029x. Originally developed for Mollisols, the Buntley-Westin index has been used as a tool to separate soils based on depth to particular colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buntley.westin.index(hue, chroma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buntley.westin.index_+3A_hue">hue</code></td>
<td>
<p>A character vector containing Munsell hues (e.g. &quot;7.5YR&quot;)</p>
</td></tr>
<tr><td><code id="buntley.westin.index_+3A_chroma">chroma</code></td>
<td>
<p>A numeric vector containing Munsell chromas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector reflecting horizon color development.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>References</h3>

<p>Buntley, G.J. and Westin, F.C. (1965), A Comparative Study of Developmental Color in a Chestnut-Chernozem-Brunizem Soil Climosequence. Soil Science Society of America Journal, 29: 579-582. doi:10.2136/sssaj1965.03615995002900050029x
</p>

<hr>
<h2 id='c+2CSoilProfileCollection-method'>Combine SoilProfileCollection objects</h2><span id='topic+c+2CSoilProfileCollection-method'></span><span id='topic+combine'></span><span id='topic+c'></span><span id='topic+combine+2CSoilProfileCollection-method'></span><span id='topic+combine+2Clist-method'></span>

<h3>Description</h3>

<p>Combine <code>SoilProfileCollection</code> objects or lists of <code>SoilProfileCollection</code> objects. This method provides <code>...</code> expansion for the <code>pbindlist</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
c(x, ...)

## S4 method for signature 'SoilProfileCollection'
combine(...)

## S4 method for signature 'list'
combine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>A <code>SoilProfileCollection</code></p>
</td></tr>
<tr><td><code id="c+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p><code>SoilProfileCollection</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SoilProfileCollection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example data
spc1 &lt;- random_profile(1, SPC = TRUE)
spc2 &lt;- random_profile(2, SPC = TRUE)
spc3 &lt;- random_profile('A', SPC = TRUE)

# combine into a single SPC, ... interface
spc &lt;- combine(spc1, spc2, spc3)

# combine into a single SPC, list interface
spc &lt;- combine(list(spc1, spc2, spc3))

# input are combined into a single SPC
spc &lt;- c(spc1, spc2, spc3)

# result is a list when a mixture of objects are provided
spc &lt;- c(spc1, bar=spc2, baz="foo")

</code></pre>

<hr>
<h2 id='ca630'>Soil Data from the Central Sierra Nevada Region of California</h2><span id='topic+ca630'></span>

<h3>Description</h3>

<p>Site and laboratory data from soils sampled in the central Sierra Nevada
Region of California.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ca630)
</code></pre>


<h3>Format</h3>

<p>List containing:
</p>
<p>$site : A data frame containing site information.  </p>

<dl>
<dt>user_site_id</dt><dd><p>national user site id</p>
</dd> <dt>mlra</dt><dd><p>the
MLRA</p>
</dd> <dt>county</dt><dd><p>the county</p>
</dd> <dt>ssa</dt><dd><p>soil survey area</p>
</dd>
<dt>lon</dt><dd><p>longitude, WGS84</p>
</dd> <dt>lat</dt><dd><p>latitude, WGS84</p>
</dd>
<dt>pedon_key</dt><dd><p>national soil profile id</p>
</dd>
<dt>user_pedon_id</dt><dd><p>local soil profile id</p>
</dd>
<dt>cntrl_depth_to_top</dt><dd><p>control section top depth (cm)</p>
</dd>
<dt>cntrl_depth_to_bot</dt><dd><p>control section bottom depth (cm)</p>
</dd>
<dt>sampled_taxon_name</dt><dd><p>soil series name</p>
</dd> </dl>

<p>$lab : A data frame containing horizon information.  </p>

<dl>
<dt>pedon_key</dt><dd><p>national soil profile id</p>
</dd>
<dt>layer_key</dt><dd><p>national horizon id</p>
</dd>
<dt>layer_sequence</dt><dd><p>horizon sequence number</p>
</dd>
<dt>hzn_top</dt><dd><p>horizon top (cm)</p>
</dd> <dt>hzn_bot</dt><dd><p>horizon
bottom (cm)</p>
</dd> <dt>hzn_desgn</dt><dd><p>horizon name</p>
</dd>
<dt>texture_description</dt><dd><p>USDA soil texture</p>
</dd>
<dt>nh4_sum_bases</dt><dd><p>sum of bases extracted by ammonium acetate (pH
7)</p>
</dd> <dt>ex_acid</dt><dd><p>exchangeable acidity [method ?]</p>
</dd>
<dt>CEC8.2</dt><dd><p>cation exchange capacity by sum of cations method (pH
8.2)</p>
</dd> <dt>CEC7</dt><dd><p>cation exchange capacity by ammonium acetate (pH
7)</p>
</dd> <dt>bs_8.2</dt><dd><p>base saturation by sum of cations method (pH 8.2)</p>
</dd>
<dt>bs_7</dt><dd><p>base saturation by ammonium acetate (pH 7)</p>
</dd> </dl>



<h3>Details</h3>

<p>These data were extracted from the NSSL database. <code>ca630</code> is a list composed
of site and lab data, each stored as <code>data.frame</code> objects. These data are modeled by a
1:many (site:lab) relation, with the <code>pedon_id</code> acting as the primary key in
the <code>site</code> table and as the foreign key in the <code>lab</code> table.
</p>


<h3>Note</h3>

<p>These data are out of date. Pending some new data + documentation. Use
with caution
</p>


<h3>Source</h3>

<p><a href="https://ncsslabdatamart.sc.egov.usda.gov/">https://ncsslabdatamart.sc.egov.usda.gov/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(tactile)
library(lattice)
library(Hmisc)
library(sp)

# check the data out:
data(ca630)
str(ca630)

# note that pedon_key is the link between the two tables

# make a copy of the horizon data
ca &lt;- ca630$lab

# promote to a SoilProfileCollection class object
depths(ca) &lt;- pedon_key ~ hzn_top + hzn_bot

# add site data, based on pedon_key
site(ca) &lt;- ca630$site

# ID data missing coordinates: '|' is a logical OR
(missing.coords.idx &lt;- which(is.na(ca$lat) | is.na(ca$lon)))

# remove missing coordinates by safely subsetting
if(length(missing.coords.idx) &gt; 0)
	ca &lt;- ca[-missing.coords.idx, ]

# register spatial data
initSpatial(ca) &lt;- ~ lon + lat

# assign a coordinate reference system
prj(ca) &lt;- 'EPSG:4269'

# check the result
print(ca)

# aggregate %BS 7 for all profiles into 1 cm slices
a &lt;- slab(ca, fm= ~ bs_7)

# plot median &amp; IQR by 1 cm slice
xyplot(
top ~ p.q50, 
data = a, 
lower=a$p.q25, 
upper=a$p.q75,
alpha=0.5,
ylim=c(160,-5), 
scales = list(alternating = 1, y = list(tick.num = 7)),
panel = panel.depth_function, 
prepanel = prepanel.depth_function,
ylab='Depth (cm)', xlab='Base Saturation at pH 7',
par.settings = tactile.theme(superpose.line = list(col = 'black', lwd = 2))
)

# aggregate %BS at pH 8.2 for all profiles by MLRA, along 1 cm slices
# note that mlra is stored in @site
a &lt;- slab(ca, mlra ~ bs_8.2)

# keep only MLRA 18 and 22
a &lt;- subset(a, subset=mlra %in% c('18', '22'))

# plot median &amp; IQR by 1 cm slice, using different colors for each MLRA
xyplot(
top ~ p.q50, 
groups = factor(mlra), 
data = a,
lower=a$p.q25, 
upper=a$p.q75,
alpha=0.25,
sync.colors = TRUE,
ylim=c(160,-5), 
scales = list(alternating = 1, y = list(tick.num = 7)),
panel = panel.depth_function, 
prepanel = prepanel.depth_function,
ylab='Depth (cm)', xlab='Base Saturation at pH 7',
par.settings = tactile.theme(superpose.line = list(lwd = 2)),
auto.key = list(lines = TRUE, points = FALSE, columns = 2)
)



# Extract the 2nd horizon from all profiles as SPDF
ca.2 &lt;- ca[, 2]

# subset profiles 1 through 10
ca.1.to.10 &lt;- ca[1:10, ]

# basic plot method: profile plot
par(mar = c(0, 0, 3, 1))
plotSPC(ca.1.to.10, name='hzn_desgn', color = 'CEC7')

## End(Not run)

</code></pre>

<hr>
<h2 id='checkHzDepthLogic'>Check a SoilProfileCollection object for errors in horizon depths.</h2><span id='topic+checkHzDepthLogic'></span>

<h3>Description</h3>

<p>This function inspects a <code>SoilProfileCollection</code> object, looking for four common errors in horizon depths:
</p>

<ol>
<li><p> bottom depth shallower than top depth
</p>
</li>
<li><p> equal top and bottom depth
</p>
</li>
<li><p> missing top or bottom depth (e.g. <code>NA</code>)
</p>
</li>
<li><p> gap or overlap between adjacent horizons (only if <code>byhz = FALSE</code>)
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>checkHzDepthLogic(
  x,
  hzdepths = NULL,
  idname = NULL,
  fast = FALSE,
  byhz = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkHzDepthLogic_+3A_x">x</code></td>
<td>
<p><code>SoilProfileCollection</code> or <code>data.frame</code> object to check</p>
</td></tr>
<tr><td><code id="checkHzDepthLogic_+3A_hzdepths">hzdepths</code></td>
<td>
<p>character vector, describing top and bottom depths in a <code>SoilProfileCollection</code> or <code>data.frame</code>. <code>horizonDepths(x)</code> is used when <code>x</code> is a <code>SoilProfileCollection</code>.</p>
</td></tr>
<tr><td><code id="checkHzDepthLogic_+3A_idname">idname</code></td>
<td>
<p>character, describing the column containing profile IDs in a <code>SoilProfileCollection</code> or <code>data.frame</code>. <code>idname(x)</code> is used when <code>x</code> is a <code>SoilProfileCollection</code>.</p>
</td></tr>
<tr><td><code id="checkHzDepthLogic_+3A_fast">fast</code></td>
<td>
<p>logical, When <code>TRUE</code>, details about specific test results are not needed, the operation can allocate less memory and run approximately 5x faster.</p>
</td></tr>
<tr><td><code id="checkHzDepthLogic_+3A_byhz">byhz</code></td>
<td>
<p>logical, apply logic tests to profiles (<code>FALSE</code>) or individual horizons (<code>TRUE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing profile IDs, validity boolean (<code>valid</code>) and test results if <code>fast = FALSE</code>.
</p>
<p>The <code>data.frame</code> will have as many rows as profiles in <code>x</code> (<code>length(x)</code>).
</p>

<ul>
<li> <p><code>id</code> : Profile IDs, named according to <code>idname(x)</code>
</p>
</li>
<li> <p><code>valid</code> : boolean, profile passes all of the following tests
</p>
</li>
<li> <p><code>depthLogic</code> : boolean, errors related to depth logic
</p>
</li>
<li> <p><code>sameDepth</code> : boolean, errors related to same top/bottom depths
</p>
</li>
<li> <p><code>missingDepth</code> : boolean, NA in top / bottom depths
</p>
</li>
<li> <p><code>overlapOrGap</code> : boolean, gaps or overlap in adjacent horizons (<code>NA</code> when <code>byhz = TRUE</code>)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette, A.G. Brown, S.M. Roecker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## sample data

data(sp3)
depths(sp3) &lt;- id ~ top + bottom

# these data should be clean
res &lt;- checkHzDepthLogic(sp3)

head(res)

# less memory if only concerned about net validity
res &lt;- checkHzDepthLogic(sp3, fast = TRUE)

head(res)

</code></pre>

<hr>
<h2 id='checkSPC'>Test for a valid SoilProfileCollection</h2><span id='topic+checkSPC'></span>

<h3>Description</h3>

<p>Test for a valid SoilProfileCollection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSPC(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSPC_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Test for valid <code>SoilProfileCollection</code> by checking for slots defined in
the class prototype. Likely only used between major versions of <code>aqp</code> where
internal structure of <code>SoilProfileCollection</code> has changed. Use
<code>checkHzDepthLogic</code> to check for common errors in horizon depths.
</p>


<h3>Value</h3>

<p>TRUE or FALSE. Consider using <code>rebuildSPC()</code> if FALSE.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rebuildSPC">rebuildSPC</a></code>, <code><a href="#topic+checkHzDepthLogic">checkHzDepthLogic</a></code>
</p>

<hr>
<h2 id='col2Munsell'>Convert colors into Munsell Notation</h2><span id='topic+col2Munsell'></span>

<h3>Description</h3>

<p>Lookup the <code>n</code> closest Munsell chips from the <code>munsell</code> lookup table from various color notations. This function replaces <code>rgb2munsell()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2Munsell(col, space = c("sRGB", "CIELAB"), nClosest = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col2Munsell_+3A_col">col</code></td>
<td>
<p>character vector of colors, <code>data.frame</code> or <code>matrix</code> of color coordinates in sRGB or CIELAB color space</p>
</td></tr>
<tr><td><code id="col2Munsell_+3A_space">space</code></td>
<td>
<p>character, one of <code>sRGB</code> or <code>CIELAB</code>, defines the input color system</p>
</td></tr>
<tr><td><code id="col2Munsell_+3A_nclosest">nClosest</code></td>
<td>
<p>integer, number of closest Munsell colors to return (valid range is 1-20)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an (NA-padded) <code>data.frame</code> containing <code>hue</code>, <code>value</code>, <code>chroma</code>, and CIE delta-E 2000 color contrast metric between source and nearest matching color(s).
</p>


<h3>Note</h3>

<p>This function is fully vectorized and will pad output with NA-records when NA are present in <code>color</code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p><a href="http://ncss-tech.github.io/AQP/">http://ncss-tech.github.io/AQP/</a>
<a href="http://www.brucelindbloom.com/index.html?ColorCalcHelp.html">http://www.brucelindbloom.com/index.html?ColorCalcHelp.html</a>
<a href="https://www.munsellcolourscienceforpainters.com/MunsellAndKubelkaMunkToolbox/MunsellAndKubelkaMunkToolbox.html">https://www.munsellcolourscienceforpainters.com/MunsellAndKubelkaMunkToolbox/MunsellAndKubelkaMunkToolbox.html</a>
http://www.cis.rit.edu/mcsl/online/munsell.php
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# vector of named R colors
col2Munsell(c('red', 'green', 'blue'))

# sRGB matrix in the range of 0-255
col2Munsell(cbind(255, 0, 0))

# sRGB matrix in the range of 0-1
col2Munsell(cbind(1, 0, 0))

# 10YR 5/6 in CIELAB
col2Munsell(
  cbind(51.4337, 9.917916, 38.6889), 
  space = 'CIELAB'
)

# 2.5YR 6/8 in hex notation
col2Munsell("#D18158FF")

# 7.5YR 8/1 in sRGB {0, 1}
col2Munsell(
  cbind(0.8240707, 0.7856834, 0.7541048)
)

# 7.5YR 8/1 in sRGB {0, 255}
col2Munsell(
  cbind(0.8240707, 0.7856834, 0.7541048) * 255
)

# multple colors in CIELAB
col2Munsell(
  parseMunsell(c('10BG 6/6', '2.5YR 4/6'), returnLAB = TRUE),
  space = 'CIELAB'
)

# data.frame input
col2Munsell(
  data.frame(r = 1, g = 0, b = 0),
  space = 'sRGB'
)

# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# Munsell notation to sRGB triplets {0, 1} 
color &lt;- munsell2rgb(
  the_hue = c('10YR', '2.5YR', '5YR'), 
  the_value = c(3, 5, 2.5), 
  the_chroma = c(5, 6, 2), 
  return_triplets = TRUE
)

# result is a data.frame of sRGB {0, 1}
color

# back-transform sRGB -&gt; closest Munsell color
# sigma is the dE00 color contrast metric
col2Munsell(color, space = 'sRGB')

</code></pre>

<hr>
<h2 id='colorChart'>Visualize soil colors in Munsell notation according to within-group frequency.</h2><span id='topic+colorChart'></span>

<h3>Description</h3>

<p>Visualize soil colors in Munsell notation according to within-group frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorChart(
  m,
  g = factor("All"),
  size = TRUE,
  annotate = FALSE,
  chip.cex = 3,
  chip.cex.min = 0.1,
  chip.cex.max = 1.5,
  chip.border.col = "black",
  annotate.cex = chip.cex * 0.25,
  annotate.type = c("count", "percentage"),
  threshold = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorChart_+3A_m">m</code></td>
<td>
<p>character vector of color in Munsell notation ('10YR 4/6')</p>
</td></tr>
<tr><td><code id="colorChart_+3A_g">g</code></td>
<td>
<p>factor describing group membership, typically a generalization of horizon designation, default value will generate a fake grouping that covers all of the colors in <code>m</code></p>
</td></tr>
<tr><td><code id="colorChart_+3A_size">size</code></td>
<td>
<p>logical, encode group-wise frequency with chip size</p>
</td></tr>
<tr><td><code id="colorChart_+3A_annotate">annotate</code></td>
<td>
<p>logical, annotate color chip frequency</p>
</td></tr>
<tr><td><code id="colorChart_+3A_chip.cex">chip.cex</code></td>
<td>
<p>scaling factor applied to each color chip</p>
</td></tr>
<tr><td><code id="colorChart_+3A_chip.cex.min">chip.cex.min</code></td>
<td>
<p>lower limit for color chip frequency depiction</p>
</td></tr>
<tr><td><code id="colorChart_+3A_chip.cex.max">chip.cex.max</code></td>
<td>
<p>lower limit for color chip frequency depiction</p>
</td></tr>
<tr><td><code id="colorChart_+3A_chip.border.col">chip.border.col</code></td>
<td>
<p>color for chip borders (outline)</p>
</td></tr>
<tr><td><code id="colorChart_+3A_annotate.cex">annotate.cex</code></td>
<td>
<p>scaling factor for chip frequency annotation</p>
</td></tr>
<tr><td><code id="colorChart_+3A_annotate.type">annotate.type</code></td>
<td>
<p>character, within-group <code>count</code> or <code>percentage</code></p>
</td></tr>
<tr><td><code id="colorChart_+3A_threshold">threshold</code></td>
<td>
<p>numeric within 0-1, color chips with proportion <code style="white-space: pre;">&#8288;&lt; threshold&#8288;</code> are removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>trellis</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# required for latticeExtra:useOuterStrips
if(!requireNamespace('latticeExtra')) {
  
  # two hue pages
  ric &lt;- expand.grid(
    hue = c('5YR', '7.5YR'),
    value = 2:8,
    chroma = 2:8
  )
  
  # combine hue, value, chroma into standard Munsell notation
  ric &lt;- sprintf("%s %s/%s", ric$hue, ric$value, ric$chroma)
  
  # note that chip frequency-based size is disabled 
  # because all chips have equal frequency
  colorChart(ric, chip.cex = 4, size = TRUE)
  
  # annotation of frequency
  colorChart(ric, chip.cex = 4, annotate = TRUE)
  
  # bootstrap to larger size
  ric.big &lt;- sample(ric, size = 100, replace = TRUE)
  
  # frequency can be encoded in size
  colorChart(ric.big, chip.cex = 3)
  colorChart(ric.big, chip.cex = 5, annotate = TRUE)
     
  # constant size
  colorChart(ric.big, chip.cex = 3, size = FALSE)
  colorChart(ric.big, chip.cex = 3, size = FALSE, chip.border.col = 'NA')
  
  # simulate colors based dE00 thresholding
  p &lt;- list(
    list(m = '10YR 4/4', thresh = 10, hues = c('10YR', '7.5YR'))
  )
  
  # perform 500 simulations
  s &lt;- simulateColor(method = 'dE00', n = 500, parameters = p)
  
  # result is a list, use the first element
  colorChart(s[[1]], chip.cex = 4)
  
  # increase the possible range of color chip sizes
  colorChart(s[[1]], chip.cex = 4, chip.cex.min = 0.01, chip.cex.max = 2)
  
  # slightly funky support for neutral hues
  N &lt;- sprintf('N %s/', 2:8)
  cols &lt;- c(rep(N, times = 5), ric.big)
  
  # note special panel used to show neutral hues
  colorChart(cols, size = FALSE, annotate = TRUE)
  
  # filter proportions below given threshold
  colorChart(cols, size = FALSE, annotate = TRUE, threshold = 0.01, 
  chip.cex = 4, annotate.type = 'percentage')
  
}

</code></pre>

<hr>
<h2 id='colorContrast'>Metrics of Contrast Suitable for Comparing Soil Colors</h2><span id='topic+colorContrast'></span>

<h3>Description</h3>

<p>Pair-wise comparisons of Munsell color specifications, based on the NCSS color contrast classes (Soil Survey Technical Note 2) and CIE delta-E 2000 metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorContrast(m1, m2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorContrast_+3A_m1">m1</code></td>
<td>
<p>vector of Munsell colors ('10YR 3/3')</p>
</td></tr>
<tr><td><code id="colorContrast_+3A_m2">m2</code></td>
<td>
<p>vector of Munsell colors ('10YR 3/6')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is fully vectorized but expects input to be of the same length. Use <code>expand.grid()</code> to generate suitable input from 1:many or many:1 type comparisons. See <a href="http://ncss-tech.github.io/AQP/aqp/color-contrast.html">this tutorial</a> for an expanded discussion and more examples. Neutral colors are not mentioned in SSTN2: in this function any comparison to a neutral color (e.g. 'N 3/') are assigned a delta-hue of 1. Since SSTN2 expects hues to be counted clock wise from 5R, it possible to get very large delta-hue values for otherwise adjacent colors: '5R' vs. '2.5R'. This will be addressed in an update to the standards.
</p>
<p>The most meaningful representation of color contrast is the CIE2000 (dE00) metric.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with the following columns:
</p>

<ul>
<li><p> m1: Munsell color 1
</p>
</li>
<li><p> m2: Munsell color 2
</p>
</li>
<li><p> dH: delta-hue, as computed by <code>huePosition</code>
</p>
</li>
<li><p> dV: delta-value, absolute value of difference in Munsell value (m1 vs. m2)
</p>
</li>
<li><p> dc: delta-chroma, absolute value of difference in Munsell chroma (m1 vs. m2)
</p>
</li>
<li><p> dE00: delta-E00, e.g. the <a href="https://en.wikipedia.org/wiki/Color_difference#CIEDE2000">CIE delta-E as refined in 2000</a>
</p>
</li>
<li><p> cc: soil color contrast class, as specified in Soil Survey Technical Note 2.
</p>
</li></ul>



<h3>Note</h3>

<p>delta-E00 is computed by the <a href="https://CRAN.R-project.org/package=farver">farver package</a>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>


<ol>
<li><p> https://en.wikipedia.org/wiki/Color_difference
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+colorContrastPlot">colorContrastPlot</a>, <a href="#topic+huePosition">huePosition</a>, <a href="#topic+huePositionCircle">huePositionCircle</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# two sets of colors to compare
m1 &lt;- c('10YR 6/3', '7.5YR 3/3', '10YR 2/2', '7.5YR 3/4')
m2 &lt;- c('5YR 3/4', '7.5YR 4/4', '2.5YR 2/2', '7.5YR 6/3')

# contrast metrics
colorContrast(m1, m2)

# adjacent chips
colorContrast('10YR 3/3', '10YR 3/4')
colorContrast('10YR 3/3', '7.5YR 3/3')

# highly contrasting colors
# http://colour.granjow.net/fabercastell-polychromos.html
colorContrastPlot('10B 4/13', '10YR 10/15',
labels = c('helioblue-reddish', 'light cadmium yellow')
)


## Note: neutral hues aren't defined in TN2
# approximation / extension of the concept
colorContrast(m1 = 'N 3/', m2 = 'N 6/')

#
colorContrast(m1 = '10YR 3/3', m2 = 'N 3/')

m1 &lt;- c('10YR 6/3', '7.5YR 3/3', '10YR 2/2', 'N 3/')
m2 &lt;- c('5YR 3/4', '7.5YR 4/4', '2.5YR 2/2', '7.5YR 6/3')
colorContrast(m1, m2)

</code></pre>

<hr>
<h2 id='colorContrastPlot'>Color Contrast Plot</h2><span id='topic+colorContrastPlot'></span>

<h3>Description</h3>

<p>A simple display of two sets of colors, NCSS color contrast class and CIE
delta-E00.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorContrastPlot(
  m1,
  m2,
  col.cex = 1,
  col.font = 2,
  d.cex = 1,
  cc.font = 3,
  dE00.font = 1,
  labels = c("m1", "m2"),
  label.cex = 1,
  label.font = 1,
  printMetrics = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorContrastPlot_+3A_m1">m1</code></td>
<td>
<p>first set of Munsell colors for comparison (e.g. '5YR 3/2')</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_m2">m2</code></td>
<td>
<p>second set of Munsell colors for comparison</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_col.cex">col.cex</code></td>
<td>
<p>scaling factor for color labels</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_col.font">col.font</code></td>
<td>
<p>font for color labels</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_d.cex">d.cex</code></td>
<td>
<p>contrast for contrast metric labels</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_cc.font">cc.font</code></td>
<td>
<p>font for contrast class</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_de00.font">dE00.font</code></td>
<td>
<p>font for delta-E00</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_labels">labels</code></td>
<td>
<p>labels for compared colors, vector length 2</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_label.cex">label.cex</code></td>
<td>
<p>scaling factor for labels</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_label.font">label.font</code></td>
<td>
<p>font for labels</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_printmetrics">printMetrics</code></td>
<td>
<p>logical, print metrics between color swatches</p>
</td></tr>
<tr><td><code id="colorContrastPlot_+3A_...">...</code></td>
<td>
<p>further arguments to <code>colorspace::swatchplot</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function requires the <code>farver</code> package for calculation of CIE
delta-E00.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorContrast">colorContrast()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# two sets of colors to compare
m1 &lt;- c('10YR 6/3', '7.5YR 3/3', '10YR 2/2', '7.5YR 3/4')
m2 &lt;- c('5YR 3/4', '7.5YR 4/4', '2.5YR 2/2', '7.5YR 6/3')

# contrast metrics
colorContrast(m1, m2)

# graphical display
colorContrastPlot(m1, m2)

</code></pre>

<hr>
<h2 id='colorQuantiles'>Soil Color Range via Quantiles</h2><span id='topic+colorQuantiles'></span>

<h3>Description</h3>

<p>Estimate central tendency and spread of soil color using marginal quantiles and L1 median of CIELAB coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorQuantiles(soilColors, p = c(0.05, 0.5, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorQuantiles_+3A_soilcolors">soilColors</code></td>
<td>
<p>vector of R colors (sRGB colorspace)</p>
</td></tr>
<tr><td><code id="colorQuantiles_+3A_p">p</code></td>
<td>
<p>marginal quantiles of interest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colors are converted from sRGB to CIELAB (D65 illuminant), marginal quantiles of (L,A,B) coordinates are estimated, and L1 median (L,A,B) is estimates. The closest Munsell chips (via Munsell/CIELAB lookup table provided by <code>munsell</code>) and R colors are determined by locating chips closest to the marginal quantiles and L1 median.
</p>
<p>The results can be conveniently inspected using <code><a href="#topic+plotColorQuantiles">plotColorQuantiles()</a></code>.
</p>


<h3>Value</h3>

<p>A List containing the following elements:
</p>

<ul>
<li> <p><code>marginal</code>: <code>data.frame</code> containing marginal quantiles in CIELAB (D65), closest Munsell chips, and dE00
</p>
</li>
<li> <p><code>L1</code>: L1 median CIELAB (D65) values, closest Munsell chip, and dE00
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# example data, see manual page for details
data(sp5)

# slice top 25 cm
# 24-25cm is the last slice
s &lt;- dice(sp5, 0:24 ~ .)

# check some of the data
par(mar=c(0,0,0,0))
plotSPC(sample(s, 25), divide.hz = FALSE, name = '', print.id = FALSE, width = 0.5)

# colors
previewColors(unique(s$soil_color))

# compute marginal quantiles and L1 median
cq &lt;- colorQuantiles(s$soil_color)

# simple graphical display of results
plotColorQuantiles(cq)

## End(Not run)

</code></pre>

<hr>
<h2 id='compareSites'>Compare Site Level Attributes of a SoilProfileCollection</h2><span id='topic+compareSites'></span>

<h3>Description</h3>

<p>Compare site level attributes of a <code>SoilProfileCollection</code> object, returning a distance matrix conformal with the output from <code><a href="#topic+NCSP">NCSP()</a></code>. Values are within the range of 0-1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareSites(x, vars, weights = rep(1, times = length(vars)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareSites_+3A_x">x</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="compareSites_+3A_vars">vars</code></td>
<td>
<p>character vector listing one or more site level attributes of <code>x</code></p>
</td></tr>
<tr><td><code id="compareSites_+3A_weights">weights</code></td>
<td>
<p>numeric vector, same length as <code>vars</code>, variable weighting</p>
</td></tr>
<tr><td><code id="compareSites_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="cluster.html#topic+daisy">cluster::daisy()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is typically used in conjunction with the output from <code><a href="#topic+NCSP">NCSP()</a></code>.
</p>


<h3>Value</h3>

<p><code>dissimilarity</code> / <code>dist</code> class object containing pair-wise distances, row/column names derived from <code>profile_id(x)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NCSP">NCSP()</a></code> <code><a href="cluster.html#topic+daisy">cluster::daisy()</a></code>
</p>

<hr>
<h2 id='compositeSPC'>Return a list representation of site and horizon level data</h2><span id='topic+compositeSPC'></span><span id='topic+compositeSPC+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>compositeSPC()</code> is a convenience function that returns a named list representation of the columns from the <code>@site</code> and <code>@horizons</code> slots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compositeSPC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compositeSPC_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown.
</p>

<hr>
<h2 id='confusionIndex'>Confusion Index</h2><span id='topic+confusionIndex'></span>

<h3>Description</h3>

<p>Calculate the confusion index of Burrough et al., 1997.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confusionIndex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confusionIndex_+3A_x">x</code></td>
<td>
<p>vector of probabilities (0,1), should not contain NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Burrough, P.A., P.F.M. van Gaans, and R. Hootsmans. 1997. &quot;Continuous Classification in Soil Survey: Spatial Correlation, Confusion and Boundaries.&quot; Geoderma 77: 115-35. doi:10.1016/S0016-7061(97)00018-9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a very simple example
p &lt;- c(0.25, 0.25, 0.4, 0.05, 0.05)
confusionIndex(p)

# for comparison
shannonEntropy(p)

</code></pre>

<hr>
<h2 id='contrastChart'>Color Contrast Chart</h2><span id='topic+contrastChart'></span>

<h3>Description</h3>

<p>Compare one or more pages from a simulated Munsell book of soil colors to a reference color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contrastChart(
  m,
  hues,
  ccAbbreviate = 1,
  style = "hue",
  gridLines = FALSE,
  de00.cex = 0.6,
  cc.cex = 0.6,
  thresh = NULL,
  returnData = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contrastChart_+3A_m">m</code></td>
<td>
<p>Munsell representation of a single color for comparison e.g. '10YR 4/3'</p>
</td></tr>
<tr><td><code id="contrastChart_+3A_hues">hues</code></td>
<td>
<p>vector of one or more Munsell hue pages to display</p>
</td></tr>
<tr><td><code id="contrastChart_+3A_ccabbreviate">ccAbbreviate</code></td>
<td>
<p>length of abbreviated contrast classes, use 0 to suppress labels</p>
</td></tr>
<tr><td><code id="contrastChart_+3A_style">style</code></td>
<td>
<p>'hue' or 'CC', see details</p>
</td></tr>
<tr><td><code id="contrastChart_+3A_gridlines">gridLines</code></td>
<td>
<p>logical, add grid lines to the color contrast chart</p>
</td></tr>
<tr><td><code id="contrastChart_+3A_de00.cex">de00.cex</code></td>
<td>
<p>character scaling applied to dE00 annotation</p>
</td></tr>
<tr><td><code id="contrastChart_+3A_cc.cex">cc.cex</code></td>
<td>
<p>character scaling applied to contrast class annotation</p>
</td></tr>
<tr><td><code id="contrastChart_+3A_thresh">thresh</code></td>
<td>
<p>threshold (&lt;) applied to pair-wise comparisons and resulting color chips</p>
</td></tr>
<tr><td><code id="contrastChart_+3A_returndata">returnData</code></td>
<td>
<p>logical, return lattice figure + data used to generate the figure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simulated Munsell color book page or pages are used to demonstrate color contrast between all chips and the reference color <code>m</code> (highlighted in red). NCSS color contrast class and CIE delta-E00 values are printed below all other color chips. Munsell color chips for chroma 5 and 7 are omitted, but axis labels are retained as a reminder of this fact.
</p>
<p>Setting <code>style='hue'</code> emphasizes the contrast classes and CIE delta-E00 of chips adjacent to <code>m</code>. Setting <code>style='CC'</code> emphasizes adjacent chips according to respective contrast class via lattice panels.
</p>
<p>Two-way panels are used when multiple hues are provided and <code>style='CC'</code>. The default output can be greatly enhanced via:
</p>
<p><code>
  latticeExtra::useOuterStrips(...,
                               strip = strip.custom(bg=grey(0.85)),
                               strip.left = strip.custom(bg=grey(0.85))
                              )
  </code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# single hue page
contrastChart(m = '10YR 3/3', hues = '10YR')

# multiple hue pages
contrastChart(m = '10YR 3/3', hues = c('10YR', '2.5Y'))

# contrast class, single hue
contrastChart(m = '10YR 3/3', hues = '10YR', style='CC')

# contrast class, multiple hues
# consider latticeExtra::useOuterStrips()
contrastChart(m = '10YR 5/6', hues = c('10YR', '2.5Y'), style='CC')

</code></pre>

<hr>
<h2 id='contrastClass'>Soil Color Contrast</h2><span id='topic+contrastClass'></span>

<h3>Description</h3>

<p>Determine soil color contrast class according to methods outlined in the
Soil Survey Manual. This function is typically called from
<code>colorContrast()</code> which is simpler to use and provides more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contrastClass(v1, c1, v2, c2, dH, dV, dC, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contrastClass_+3A_v1">v1</code></td>
<td>
<p>Munsell value of first color</p>
</td></tr>
<tr><td><code id="contrastClass_+3A_c1">c1</code></td>
<td>
<p>Munsell chroma of first color</p>
</td></tr>
<tr><td><code id="contrastClass_+3A_v2">v2</code></td>
<td>
<p>Munsell value of second color</p>
</td></tr>
<tr><td><code id="contrastClass_+3A_c2">c2</code></td>
<td>
<p>Munsell chroma of second color</p>
</td></tr>
<tr><td><code id="contrastClass_+3A_dh">dH</code></td>
<td>
<p>delta Hue</p>
</td></tr>
<tr><td><code id="contrastClass_+3A_dv">dV</code></td>
<td>
<p>delta Value</p>
</td></tr>
<tr><td><code id="contrastClass_+3A_dc">dC</code></td>
<td>
<p>delta Chroma</p>
</td></tr>
<tr><td><code id="contrastClass_+3A_verbose">verbose</code></td>
<td>
<p>return a list for testing rules/cases</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is fully vectorized but expects all inputs have the same
length.
</p>


<h3>Value</h3>

<p>A vector of color contrast classes (ordered factor). A list when
<code>verbose</code> is TRUE.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>


<ul>
<li><p> Soil Survey Technical Note 2 <a href="https://web.archive.org/web/20220704214918/https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/ref/?cid=nrcs142p2_053569">wayback machine URL</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+colorContrast">colorContrast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## standard use, result is an ordered factor
# 10YR 6/3 vs 5YR 3/4
contrastClass(v1=6, c1=3, v2=3, c2=4, dH=2, dV=3, dC=1)

## verbose output, useful for testing rules/cases
# 10YR 6/3 vs 5YR 3/4
contrastClass(v1=6, c1=3, v2=3, c2=4, dH=2, dV=3, dC=1, verbose = TRUE)

</code></pre>

<hr>
<h2 id='correctAWC'>Apply rock fragment or salt correction to available water content</h2><span id='topic+correctAWC'></span>

<h3>Description</h3>

<p>Apply rock fragment or salt correction to available water content
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctAWC(
  awc,
  total_rf = numeric(length(awc)),
  gravel = NULL,
  ec = NULL,
  nullFragsAreZero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctAWC_+3A_awc">awc</code></td>
<td>
<p>Numeric vector of available water capacities (e.g. from <code>estimateAWC</code>)</p>
</td></tr>
<tr><td><code id="correctAWC_+3A_total_rf">total_rf</code></td>
<td>
<p>Numeric vector  of rock fragment volume percentage, 0 - 100</p>
</td></tr>
<tr><td><code id="correctAWC_+3A_gravel">gravel</code></td>
<td>
<p>Numeric vector of gravel volume percentage, 0 - 100</p>
</td></tr>
<tr><td><code id="correctAWC_+3A_ec">ec</code></td>
<td>
<p>Numeric vector of electrical conductivity, mmhos/cm</p>
</td></tr>
<tr><td><code id="correctAWC_+3A_nullfragsarezero">nullFragsAreZero</code></td>
<td>
<p>Interpret <code>NA</code> in <code>total_rf</code>, <code>gravel</code> or <code>ec</code> as <code>0</code>? Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector (double) containing estimated available water capacities corrected for rock fragments and salts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# medium organic matter, loam texture 
base.awc &lt;- 0.18 # estimateAWC(texcl = "l", omcl = 2, na.rm = TRUE)

# medium organic matter, loam texture w/ 23% rock fragments by volume 
corrected.awc &lt;- correctAWC(base.awc, total_rf = 23)
corrected.awc

# medium organic matter, loam texture w/ 0% frags by volume and 8 mmhos/cm salts
salty.awc &lt;- correctAWC(base.awc, total_rf = 0, ec = 8)
salty.awc
</code></pre>

<hr>
<h2 id='crit.clay.argillic'>Determines threshold (minimum) clay content for argillic upper bound</h2><span id='topic+crit.clay.argillic'></span>

<h3>Description</h3>

<p>Given a vector or matrix of &quot;eluvial&quot; horizon clay contents (\
<code>crit.clay.argillic()</code> returns a vector or matrix of minimum clay
contents (thresholds) that must be met for an argillic horizon clay
increase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crit.clay.argillic(eluvial_clay_content)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crit.clay.argillic_+3A_eluvial_clay_content">eluvial_clay_content</code></td>
<td>
<p>A numeric vector or matrix containing clay
contents of potential &quot;eluvial&quot; horizons. May contain <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the standard equations for clay contents less than 15 \
and 40 \
the definition of the argillic horizon from 12th Edition Keys to Soil
Taxonomy (Soil Survey Staff, 2014).
</p>


<h3>Value</h3>

<p>A vector or matrix (input-dependent) containing minimum &quot;illuvial&quot;
horizon clay contents (thresholds) to be met for argillic horizon clay
increase.
</p>


<h3>Note</h3>

<p>This function is intended for identifying clay content threshold
required for an argillic horizon. These thresholds may not apply depending
on the specifics of your soil. E.g. if the upper part of argillic has been
plowed (has Ap immediately over upper boundary) the clay increase
requirement can be waived (Soil Survey Staff, 2014).
</p>


<h3>Author(s)</h3>

<p>Andrew Gene Brown
</p>


<h3>References</h3>

<p>Soil Survey Staff. 2014. Keys to Soil Taxonomy, 12th ed.
USDA-Natural Resources Conservation Service, Washington, DC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getArgillicBounds">getArgillicBounds</a></code>, <code><a href="#topic+get.increase.matrix">get.increase.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# crit.clay.argillic uses different equations for clay content
# less than 15 %, between 15 and 40 %, and &gt;40 %

crit.clay.argillic(eluvial_clay_content=c(5, 20, 45))

</code></pre>

<hr>
<h2 id='denormalize'>Create a (redundant) horizon-level attribute from a site-level attribute</h2><span id='topic+denormalize'></span>

<h3>Description</h3>

<p>Create a (redundant) horizon-level attribute from a site-level attribute. Specify a SoilProfileCollection and a site-level attribute from that SPC (by name) to receive a vector of length equal to the number of horizons containing the site-level values. This vector is directly usable with the SoilProfileCollection horizon setter.
</p>
<p><code>denormalize</code> is the inverse operation for the formula interface that &quot;normalizes&quot; a horizon level variable to site level:
</p>
<p><code>site(object) &lt;- ~ horizonvar</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denormalize(object, attr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denormalize_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="denormalize_+3A_attr">attr</code></td>
<td>
<p>Site-level attribute name (character string) to denormalize to horizon.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;Denormalization&quot; is the process of trying to improve the read performance of a database, at the expense of losing some write performance, by adding redundant copies of data or by grouping data. Sometimes it is beneficial to have site-level attributes denormalized for grouping of horizon-level data in analyses. <code>denormalize</code> achieves this result for SoilProfileCollections.
</p>


<h3>Value</h3>

<p>A vector of values of equal length to the number of rows in the horizon table of the input SPC.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown, Dylan Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)

# create a SoilProfileCollection from horizon data
depths(sp1) &lt;- id ~ top + bottom

# create random site-level attribute `sitevar` with a binary (0/1) outcome
sp1$sitevar &lt;- round(runif(length(sp1)))

# use denormalize() to create a mirror of sitevar in the horizon table
# name the attribute something different (e.g. `hz.sitevar`) to 
# prevent collision with the site attribute
# the attributes can have the same name but you will then need 
# site() or horizons() to access explicitly
sp1$hz.sitevar &lt;- denormalize(sp1, 'sitevar')

# compare number of profiles to number of sitevar assignments
length(sp1)
table(sp1$sitevar)

# compare number of horizons to number of horizon-level copies of sitevar `hz.'sitevar`
nrow(sp1)
table(sp1$hz.sitevar)
</code></pre>

<hr>
<h2 id='depth_units+2CSoilProfileCollection-method'>Get depth units from metadata</h2><span id='topic+depth_units+2CSoilProfileCollection-method'></span><span id='topic+depth_units'></span><span id='topic+depth_units+3C-+2CSoilProfileCollection-method'></span><span id='topic+depth_units+3C-'></span>

<h3>Description</h3>

<p>Get units of depth measurement from metadata. Default value is centimeters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
depth_units(object)

## S4 replacement method for signature 'SoilProfileCollection'
depth_units(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_units+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="depth_units+2B2CSoilProfileCollection-method_+3A_value">value</code></td>
<td>
<p>character, a value representing units. Default <code>'cm'</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp5)

## get depth units
du &lt;- depth_units(sp5)

# set alternate units; e.g. inches
depth_units(sp5) &lt;- 'in'

# replace original value (cm)
depth_units(sp5) &lt;- du
</code></pre>

<hr>
<h2 id='depthOf'>Get top or bottom depths of horizons matching a regular expression pattern</h2><span id='topic+depthOf'></span><span id='topic+maxDepthOf'></span><span id='topic+minDepthOf'></span>

<h3>Description</h3>

<p>The <code>depthOf</code> family of functions calculate depth of occurrence of a horizon designation pattern, or any other value that can be coerced to character and matched with a regular expression.
</p>
<p>If you need all depths of occurrence for a particular pattern, <code>depthOf</code> is what you are looking for. <code>minDepthOf</code> and <code>maxDepthOf</code> are wrappers around <code>depthOf</code> that return the minimum and maximum depth. They are all set up to handle missing values and missing &quot;contacts&quot; with the target pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthOf(
  p,
  pattern,
  FUN = NULL,
  top = TRUE,
  hzdesgn = guessHzDesgnName(p),
  no.contact.depth = NULL,
  no.contact.assigned = NA_real_,
  na.rm = TRUE,
  simplify = TRUE
)

maxDepthOf(
  p,
  pattern,
  top = TRUE,
  hzdesgn = guessHzDesgnName(p),
  no.contact.depth = NULL,
  no.contact.assigned = NA,
  na.rm = TRUE,
  simplify = TRUE
)

minDepthOf(
  p,
  pattern,
  top = TRUE,
  hzdesgn = guessHzDesgnName(p),
  no.contact.depth = NULL,
  no.contact.assigned = NA,
  na.rm = TRUE,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthOf_+3A_p">p</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="depthOf_+3A_pattern">pattern</code></td>
<td>
<p>a regular expression to match in the horizon designation column. See:<code>hzdesgn</code></p>
</td></tr>
<tr><td><code id="depthOf_+3A_fun">FUN</code></td>
<td>
<p>a function that returns a single value, and takes argument <code>na.rm</code></p>
</td></tr>
<tr><td><code id="depthOf_+3A_top">top</code></td>
<td>
<p>should the top (TRUE) or bottom (FALSE) depth be returned for matching horizons? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="depthOf_+3A_hzdesgn">hzdesgn</code></td>
<td>
<p>column name containing horizon designations. Default: <code>guessHzDesgnName(p)</code></p>
</td></tr>
<tr><td><code id="depthOf_+3A_no.contact.depth">no.contact.depth</code></td>
<td>
<p>depth to assume that contact did not occur.</p>
</td></tr>
<tr><td><code id="depthOf_+3A_no.contact.assigned">no.contact.assigned</code></td>
<td>
<p>depth to assign when a contact did not occur.</p>
</td></tr>
<tr><td><code id="depthOf_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Remove <code>NA</code>? (default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="depthOf_+3A_simplify">simplify</code></td>
<td>
<p>logical. Return single profile results as vector (default: <code>TRUE</code>) or <code>data.frame</code> (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector containing specified depth(s) of horizons matching a pattern. If <code>length(p) &gt; 1</code> then a <em>data.frame</em> containing profile ID, horizon ID, top or bottom depths, horizon designation and pattern.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a fake profile
spc &lt;- data.frame(id=1, taxsubgrp = "Lithic Haploxerepts",
                  hzname   = c("A","AB","Bw","BC","R"),
                  hzdept   = c(0,  20, 32, 42,  49),
                  hzdepb   = c(20, 32, 42, 49, 200),
                  clay     = c(19, 22, 22, 21,  NA),
                  texcl    = c("l","l","l", "l","br"),
                  d_value  = c(5,   5,  5,  6,  NA),
                  m_value  = c(2.5, 3,  3,  4,  NA),
                  m_chroma = c(2,   3,  4,  4,  NA))

# promote to SoilProfileCollection
depths(spc) &lt;- id ~ hzdept + hzdepb
hzdesgnname(spc) &lt;- 'hzname'
hztexclname(spc) &lt;- 'texcl'

# multiple horizons contain B
depthOf(spc, "B")

# deepest top depth of horizon containing B
maxDepthOf(spc, "B")

# shallowest top depth
minDepthOf(spc, "B")

# deepest bottom depth
maxDepthOf(spc, "B", top = FALSE)

# deepest bottom depth above 35cm
maxDepthOf(spc, "B", top = FALSE, no.contact.depth = 35)

# assign infinity (Inf) if B horizon does not start within 10cm
minDepthOf(spc, "B", no.contact.depth = 10, no.contact.assigned = Inf)

</code></pre>

<hr>
<h2 id='depths'>Initialize a SoilProfileCollection from data.frame</h2><span id='topic+depths'></span><span id='topic+depths+2CSoilProfileCollection-method'></span><span id='topic+depths+3C-+2CSoilProfileCollection-method'></span><span id='topic+depths+3C-'></span><span id='topic+depths+3C-+2Cdata.frame-method'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;depths(&lt;data.frame&gt;) &lt;- &lt;formula&gt;&#8288;</code>: Initialize SoilProfileCollection
</p>
<p><code style="white-space: pre;">&#8288;depths(&lt;SoilProfileCollection&gt;)&#8288;</code>: Extract profile ID and horizon depths from SoilProfileCollection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
depths(x, hzID = FALSE, ...)

## S4 replacement method for signature 'SoilProfileCollection'
depths(object) &lt;- value

## S4 replacement method for signature 'data.frame'
depths(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depths_+3A_x">x</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="depths_+3A_hzid">hzID</code></td>
<td>
<p>Include horizon ID? Usually this is calculated from the (sorted) row index unless <code style="white-space: pre;">&#8288;hzidname()&lt;-&#8288;</code> has been called. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="depths_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="depths_+3A_object">object</code></td>
<td>
<p>An object to promote to SoilProfileCollection (inherits from data.frame)</p>
</td></tr>
<tr><td><code id="depths_+3A_value">value</code></td>
<td>
<p>A formula specifying the unique profile ID, top and bottom depth column names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input horizon data, and the resulting profile order, is sorted based on unique profile ID and top depth. ID columns are converted to character, depth columns are converted to integer. If <code>NA</code> values exist in all of the top depths, a prototype with 1 horizon per profile ID is returned, with <code>NA</code> in all non-essential columns. If the input <code>object</code> has 0 rows, a prototype with 0 horizons and 0 rows, but same column names as <code>object</code>, is returned.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing profile ID, top depth, and bottom depth
</p>


<h3>See Also</h3>

<p><code>horizons()</code> <code>idname()</code> <code>hzidname()</code> <code>horizonDepths()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a SoilProfileCollection
data(jacobs2000, package = "aqp")

depths(jacobs2000)
## init SoilProfileCollection objects from data.frame of horizon data

# load demo data
data(sp1)

# promote to SPC
depths(sp1) &lt;- id ~ top + bottom

# plot
plot(sp1)

# number of profiles
length(sp1)

# number of horizons
nrow(sp1)

</code></pre>

<hr>
<h2 id='depthWeights'>Return a vector of contributing fractions over a depth interval</h2><span id='topic+depthWeights'></span><span id='topic+depthWeights+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>depthWeights()</code> calculates the contributing fraction for each pair of horizon top and bottom depths, given an upper and lower boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthWeights(top, bottom, upper, lower)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depthWeights_+3A_top">top</code></td>
<td>
<p>A numeric vector of horizon top depths.</p>
</td></tr>
<tr><td><code id="depthWeights_+3A_bottom">bottom</code></td>
<td>
<p>A numeric vector of horizon bottom depths.</p>
</td></tr>
<tr><td><code id="depthWeights_+3A_upper">upper</code></td>
<td>
<p>A unit length numeric vector with upper boundary.</p>
</td></tr>
<tr><td><code id="depthWeights_+3A_lower">lower</code></td>
<td>
<p>A unit length numeric vector with lower boundary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown.
</p>

<hr>
<h2 id='diagnostic_hz+2CSoilProfileCollection-method'>Retrieve diagnostic data from SoilProfileCollection</h2><span id='topic+diagnostic_hz+2CSoilProfileCollection-method'></span><span id='topic+diagnostic_hz'></span>

<h3>Description</h3>

<p>Get diagnostic feature data from SoilProfileCollection. Result is returned in the same <code>data.frame</code> class used to initially construct the SoilProfileCollection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
diagnostic_hz(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic_hz+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>

<hr>
<h2 id='diagnostic_hz+26lt+3B-'>Add Data to Diagnostic Features Slot</h2><span id='topic+diagnostic_hz+3C-'></span><span id='topic+diagnostic_hz+3C-+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Diagnostic feature data in an object inheriting from <code>data.frame</code> can easily be added via merge (LEFT JOIN). There must be one or more same-named columns containing profile ID on the left and right hand side to facilitate the join: <code>diagnostic_hz(spc) &lt;- newdata</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
diagnostic_hz(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic_hz+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="diagnostic_hz+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>An object inheriting <code>data.frame</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# load test data
data(sp2)

# promote to SPC
depths(sp2) &lt;- id ~ top + bottom

# assign two profiles a zone related to the mollic epipedon
newdata &lt;- data.frame(id = c("hon-1","hon-17"),
                      featkind = "fixed-depth surface sample",
                      featdept = 0,
                      featdepb = 18)

# do left join
diagnostic_hz(sp2) &lt;- newdata

# inspect site table: newvalue TRUE only for horizons
#  with top depth equal to zero
diagnostic_hz(sp2)

</code></pre>

<hr>
<h2 id='dice+2CSoilProfileCollection-method'>Efficient Slicing of <code>SoilProfileCollection</code> Objects</h2><span id='topic+dice+2CSoilProfileCollection-method'></span><span id='topic+dice'></span>

<h3>Description</h3>

<p>Cut (&quot;dice&quot;) soil horizons into 1-unit thick slices. This function replaces <code>aqp::slice()</code>, which will be deprecated in aqp 2.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
dice(
  x,
  fm = NULL,
  SPC = TRUE,
  pctMissing = FALSE,
  fill = FALSE,
  strict = TRUE,
  byhz = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dice+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="dice+2B2CSoilProfileCollection-method_+3A_fm">fm</code></td>
<td>
<p>optional <code>formula</code> describing top depths and horizon level attributes to include: <code>integer.vector ~ var1 + var2 + var3</code> or <code>integer.vector ~ .</code> to include all horizon level attributes. Specification of <code>integer.vector</code> forces <code>fill = TRUE</code>. When <code>NULL</code> profiles are &quot;diced&quot; to depth and results will include all horizon level attributes. Note on interpretation of <code>integer.vector</code> (slice tops)</p>
</td></tr>
<tr><td><code id="dice+2B2CSoilProfileCollection-method_+3A_spc">SPC</code></td>
<td>
<p>return the diced <code>SoilPrfolileCollection</code>, if <code>FALSE</code> a <code>data.frame</code> of horizon-level attributes</p>
</td></tr>
<tr><td><code id="dice+2B2CSoilProfileCollection-method_+3A_pctmissing">pctMissing</code></td>
<td>
<p>compute &quot;percent missing data&quot; by slice (when <code>TRUE</code> expect 6-8x longer run time)</p>
</td></tr>
<tr><td><code id="dice+2B2CSoilProfileCollection-method_+3A_fill">fill</code></td>
<td>
<p>logical, fill with empty placeholder horizons in gaps within profiles, and/or, above/below interval specified in <code>fm</code>. Automatically set to <code>TRUE</code> when LHS of <code>fm</code> is specified. Backwards compatibility with <code>slice</code> is maintained by setting <code>fill = TRUE</code> with or without <code>fm</code>.</p>
</td></tr>
<tr><td><code id="dice+2B2CSoilProfileCollection-method_+3A_strict">strict</code></td>
<td>
<p>perform horizon depth logic checking / flagging / removal</p>
</td></tr>
<tr><td><code id="dice+2B2CSoilProfileCollection-method_+3A_byhz">byhz</code></td>
<td>
<p>Evaluate horizon depth logic at the horizon level (<code>TRUE</code>) or profile level (<code>FALSE</code>). Invalid depth logic invokes <code>HzDepthLogicSubset</code> which removes offending profiles or horizon records.</p>
</td></tr>
<tr><td><code id="dice+2B2CSoilProfileCollection-method_+3A_verbose">verbose</code></td>
<td>
<p>Print information about object size/memory usage. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For large and potentially messy collections that may include missing horizon depth logic errors, consider using <code>repairMissingHzDepths()</code> before <code>dice()</code>. Consider using <code>accumulateDepths()</code> before invoking <code>dice()</code> on collections that may contain old-style O horizon notation (e.g. 5-0cm).
</p>


<h3>Value</h3>

<p>a <code>SoilProfileCollection</code> object, or <code>data.frame</code> when <code>SPC = FALSE</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and A.G. Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repairMissingHzDepths">repairMissingHzDepths()</a></code>, <code><a href="#topic+accumulateDepths">accumulateDepths()</a></code>, <code><a href="#topic+fillHzGaps">fillHzGaps()</a></code>
</p>

<hr>
<h2 id='dissolve_hz'>Dissolving horizon boundaries by grouping variables</h2><span id='topic+dissolve_hz'></span>

<h3>Description</h3>

<p>This function dissolves or combines horizons that have a common set of grouping variables. It only combines those horizon records that are sequential (e.g. share a horizon boundary). Thus, it can be used to identify discontinuities in the grouping variables along a profile and their unique depths. It is particularly useful for determining the depth to the top or bottom of horizons with a specific category, and should be simpler than previous methods that require aggregating over profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissolve_hz(
  object,
  by,
  id = "peiid",
  hztop = "hzdept",
  hzbot = "hzdepb",
  collapse = FALSE,
  order = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissolve_hz_+3A_object">object</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="dissolve_hz_+3A_by">by</code></td>
<td>
<p>character: column names, to be used as grouping variables, within the object.</p>
</td></tr>
<tr><td><code id="dissolve_hz_+3A_id">id</code></td>
<td>
<p>character: column name of the pedon ID within the object.</p>
</td></tr>
<tr><td><code id="dissolve_hz_+3A_hztop">hztop</code></td>
<td>
<p>character: column name of the horizon top depth within the object.</p>
</td></tr>
<tr><td><code id="dissolve_hz_+3A_hzbot">hzbot</code></td>
<td>
<p>character: column name of the horizon bottom depth in the object.</p>
</td></tr>
<tr><td><code id="dissolve_hz_+3A_collapse">collapse</code></td>
<td>
<p>logical: indicating whether to not combine grouping variables before dissolving.</p>
</td></tr>
<tr><td><code id="dissolve_hz_+3A_order">order</code></td>
<td>
<p>logical: indicating whether or not to order the object by the id, hztop, and hzbot columns.
#'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes the profiles and horizons within the object follow the logic defined by <code>checkHzDepthLogic</code> (e.g. records are ordered sequentially by id, hztop, and hzbot and without gaps). If the records are not ordered, set the <code>order = TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the original id, by grouping variables, and non-consecutive horizon depths.
</p>


<h3>Author(s)</h3>

<p>Stephen Roecker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkHzDepthLogic">checkHzDepthLogic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example 1
data(jacobs2000)
spc &lt;- jacobs2000

spc$dep_5 &lt;- spc$depletion_pct &gt;=5
spc$genhz &lt;- generalize.hz(spc$name, c("A", "E", "B", "C"), c("A", "E", "B", "C")) 
h &lt;- horizons(spc)

test &lt;- dissolve_hz(h, by = c("genhz", "dep_5"), id = "id", hztop = "top", hzbot = "bottom")

vars &lt;- c("id", "top", "bottom", "genhz", "dep_5")
h[h$id == "92-1", vars]
test[test$id == "92-1", ]


# example 2
df &lt;- data.frame(
    peiid = 1,
    hzdept = c(0, 5,  10, 15, 25, 50), 
    hzdepb = c(5, 10, 15, 25, 50, 100),
    hzname = c("A1",  "A2",  "E/A", "2Bt1", "2Bt2", "2C"),
    genhz  = c("A",   "A",   "E",   "2Bt",  "2Bt", "2C"),
    texcl  = c("sil", "sil", "sil", "sl",   "sl",   "s")
    )

df

dissolve_hz(df, c("genhz", "texcl"))
dissolve_hz(df, c("genhz", "texcl"), collapse = TRUE)

test &lt;- dissolve_hz(df, "genhz")
subset(test, value == "2Bt")

</code></pre>

<hr>
<h2 id='duplicate'>Duplicate Profiles of a SoilProfileCollection</h2><span id='topic+duplicate'></span>

<h3>Description</h3>

<p>A simple function to duplicate the contents of a <code>SoilProfileCollection</code> object. Old profile IDs are saved as a site-level attribute (<code>oldID</code>) and new IDs are generated using a numeric serial number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicate(x, times = 3, oldID = ".oldID")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicate_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object with 1 or more profiles</p>
</td></tr>
<tr><td><code id="duplicate_+3A_times">times</code></td>
<td>
<p>requested number of copies</p>
</td></tr>
<tr><td><code id="duplicate_+3A_oldid">oldID</code></td>
<td>
<p>site-level attribute used to store the original profile IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>SoilProfileCollection</code> object
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# sample data
data('sp4')

# promote to SPC
depths(sp4) &lt;- id ~ top + bottom

# duplicate each profile 2 times
d &lt;- duplicate(sp4, times = 2)

# graphical check
par(mar = c(0, 0, 3, 1))
plotSPC(d, color = 'Ca', width = 0.25)

</code></pre>

<hr>
<h2 id='electroStatics_1D'>Label placement based on a simulation of electrostatic forces</h2><span id='topic+electroStatics_1D'></span>

<h3>Description</h3>

<p>This function attempts to move labels along a 1D coordinate system such that overlap (as specified by threshold) is minimized. An electrostatic simulation applies forces of repulsion between labels that are within <code>thresh</code> (e.g. overlapping) and forces of attraction to a uniformly spaced sequence to iteratively perturb affected labels until either no overlap is reported, or a maximum number of iterations (<code>maxIter</code>) has been reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>electroStatics_1D(
  x,
  thresh,
  q = 1,
  chargeDecayRate = 0.01,
  QkA_GrowthRate = 0.05,
  maxIter = 100,
  tiny = 1e-04,
  const = 0.001,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="electroStatics_1D_+3A_x">x</code></td>
<td>
<p>numeric vector, pre-sorted sorted, without duplication, describing 1D label (particle) configuration</p>
</td></tr>
<tr><td><code id="electroStatics_1D_+3A_thresh">thresh</code></td>
<td>
<p>numeric, overlap threshold, same as in <code><a href="#topic+fixOverlap">fixOverlap()</a></code></p>
</td></tr>
<tr><td><code id="electroStatics_1D_+3A_q">q</code></td>
<td>
<p>numeric, electrical charge (typically between 0.1 and 2)</p>
</td></tr>
<tr><td><code id="electroStatics_1D_+3A_chargedecayrate">chargeDecayRate</code></td>
<td>
<p>numeric, exponential decay rate constant for <code>q</code> as a function of iteration <code>i</code></p>
</td></tr>
<tr><td><code id="electroStatics_1D_+3A_qka_growthrate">QkA_GrowthRate</code></td>
<td>
<p>numeric, growth rate constant for <code>Qk</code> applied to attraction to uniform spacing of labels, invoked when rank order is violated during the simulation</p>
</td></tr>
<tr><td><code id="electroStatics_1D_+3A_maxiter">maxIter</code></td>
<td>
<p>integer, maximum number of iterations before giving up</p>
</td></tr>
<tr><td><code id="electroStatics_1D_+3A_tiny">tiny</code></td>
<td>
<p>numeric, 0-values replaced by this number to avoid division by 0 and infinite forces</p>
</td></tr>
<tr><td><code id="electroStatics_1D_+3A_const">const</code></td>
<td>
<p>numeric, empirical constant added to the 1D electrostatic force equation to dampen oscillation: <code>(Qk * Q1 * Q2) / (d^ex + const)</code></p>
</td></tr>
<tr><td><code id="electroStatics_1D_+3A_trace">trace</code></td>
<td>
<p>logical, include diagnostic output</p>
</td></tr>
<tr><td><code id="electroStatics_1D_+3A_...">...</code></td>
<td>
<p>not used, absorbs additional arguments to <code><a href="#topic+fixOverlap">fixOverlap()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Difficult overlap problems can be addressed by reducing <code>thresh</code> and increasing <code>q</code>. Large values of <code>q</code> can lead to chaotic results.
</p>
<p>This function will generate unpredictable output when <code>x</code> contains duplicate values.
</p>
<p>This function requires input to be pre-sorted, although interesting &quot;artistic&quot; simulations will often result from unsorted <code>x</code>.
</p>


<h3>Value</h3>

<p>When <code>trace = TRUE</code> a <code>list</code>, otherwise numeric vector with <code>converged</code> attribute.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and K.C. Thompson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixOverlap">fixOverlap()</a></code>, <code><a href="#topic+SANN_1D">SANN_1D()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# vector of object locations, with potential overlap
x &lt;- c(1, 2, 3, 3.3, 3.8, 5, 6, 7, 8, 9, 10)

# full diagnostic output
z &lt;- electroStatics_1D(x, thresh = 0.65, trace = TRUE, q = 1)
txt &lt;- sprintf("Converged %s (%s iterations)", z$converged, length(z$cost))

plot(
seq_along(z$cost),
z$cost, 
las = 1, 
xlab = 'Iteration', 
ylab = 'Overlap Cost', 
type = 'b', 
main = txt
)

abline(h = 0, lty = 2, col = 2)

# final configuration only
xnew &lt;- electroStatics_1D(x, thresh = 0.65, q = 1)

# check for convergence
attr(xnew, 'converged')

# compare original vs. modified
data.frame(orig = x, new = round(xnew, 2))

</code></pre>

<hr>
<h2 id='equivalent_munsell'>Indices of &quot;equivalent&quot; Munsell chips in the <code>munsell</code> data set</h2><span id='topic+equivalent_munsell'></span>

<h3>Description</h3>

<p>A pre-calculated lookup list (made with <code>farver::compare_colour</code>) based on pair-wise color contrast (<code>CIE2000</code> or <code>dE00</code>) evaluated over all &quot;chips&quot; in the <code>aqp::munsell</code> data set.
</p>
<p>The intention is to identify Munsell chips that may be &quot;functionally equivalent&quot; to some other given whole chip elsewhere in the Munsell color space &ndash; as discretized in the <code>aqp::munsell</code> lookup table.
</p>
<p>&quot;Equivalent&quot; chips are based (fairly arbitrarily) on the 0.001 probability level of <code>dE00</code> (default Type 7 <code>quantile</code>) within the upper triangle of the 8467x8467 contrast matrix. This corresponds to a <code>dE00</code> threshold of approximately 2.15.
</p>
<p>This is a naive (to the subtleties of human color perception, and overall magnitude of contrast between some of the &quot;chips&quot;) but computationally consistent approach. Using the lookup list, as opposed to manual contrast via e.g. <code>farver::compare_colour</code> may have some benefits for efficiency in certain applications where the exact contrast value is not as important as the concept of having some threshold that is non-zero, but very small.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(equivalent_munsell)
</code></pre>


<h3>Format</h3>

<p>A named list with 8467 elements, each containing a numeric vector of indices corresponding to the <code>munsell</code> data set, which has 8467 rows (unique, whole-number chips). Names have the format <code>HUE VALUE/CHROMA</code>, e.g. <code>"7.5YR 4/4"</code>
</p>


<h3>References</h3>

<p>Gaurav Sharma, Wencheng Wu, Edul N. Dalal. (2005). The CIEDE2000 Color-Difference Formula: Implementation Notes, Supplementary Test Data, and Mathematical Observations. COLOR research and application. 30(1):21-30. http://www2.ece.rochester.edu/~gsharma/ciede2000/ciede2000noteCRNA.pdf
</p>
<p>Thomas Lin Pedersen, Berendea Nicolae and Romain Francois (2020). farver: High Performance Colour Space Manipulation. R package version 2.0.3. https://CRAN.R-project.org/package=farver
</p>
<p>Dong, C.E., Webb, J.B., Bottrell, M.C., Saginor, I., Lee, B.D. and Stern, L.A. (2020). Strengths, Limitations, and Recommendations for Instrumental Color Measurement in Forensic Soil Characterization. J Forensic Sci, 65: 438-449. https://doi.org/10.1111/1556-4029.14193
</p>


<h3>See Also</h3>

<p><code><a href="#topic+equivalentMunsellChips">equivalentMunsellChips</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(equivalent_munsell)
</code></pre>

<hr>
<h2 id='equivalentMunsellChips'>Identify &quot;equivalent&quot; (whole number value/chroma) Munsell chips</h2><span id='topic+equivalentMunsellChips'></span>

<h3>Description</h3>

<p>Uses a pre-calculated lookup list (<code><a href="#topic+equivalent_munsell">equivalent_munsell</a></code>) based on pair-wise CIE2000 contrast (<code>dE00</code>) of LAB color with D65 illuminant for all whole value/chroma &quot;chips&quot; in the <code>aqp::munsell</code> data set.
</p>
<p>The intention is to identify Munsell chips that may be &quot;functionally equivalent&quot; to some other given whole value/chroma chip elsewhere in the Munsell color space &ndash; as discretized in the <code>aqp::munsell</code> data table. This basic assumption needs to be validated against your end goal: probably by visual inspection of some or all of the resulting sets. See <code><a href="#topic+colorContrast">colorContrast</a></code> and <code><a href="#topic+colorContrastPlot">colorContrastPlot</a></code>.
</p>
<p>&quot;Equivalent&quot; chips table are based (fairly arbitrarily) on the 0.001 probability level of dE00 (default Type 7 <code>quantile</code>) within the upper triangle of the 8467x8467 contrast matrix. This corresponds to a <code>dE00</code> contrast threshold of approximately 2.15.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalentMunsellChips(hue = NULL, value = NULL, chroma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalentMunsellChips_+3A_hue">hue</code></td>
<td>
<p>A character vector containing Munsell hues</p>
</td></tr>
<tr><td><code id="equivalentMunsellChips_+3A_value">value</code></td>
<td>
<p>A numeric vector containing Munsell values (integer only)</p>
</td></tr>
<tr><td><code id="equivalentMunsellChips_+3A_chroma">chroma</code></td>
<td>
<p>A numeric vector containing Munsell chromas (integer only)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list; Each list element contains a data.frame with one or more rows of &quot;equivalent&quot; Munsell, RGB and LAB color coordinates from <code>munsell</code> data set.
</p>


<h3>References</h3>

<p>Gaurav Sharma, Wencheng Wu, Edul N. Dalal. (2005). The CIEDE2000 Color-Difference Formula: Implementation Notes, Supplementary Test Data, and Mathematical Observations. COLOR research and application. 30(1):21-30. http://www2.ece.rochester.edu/~gsharma/ciede2000/ciede2000noteCRNA.pdf
</p>
<p>Thomas Lin Pedersen, Berendea Nicolae and Romain François (2020). farver: High Performance Colour Space Manipulation. R package version 2.0.3. https://CRAN.R-project.org/package=farver
</p>
<p>Dong, C.E., Webb, J.B., Bottrell, M.C., Saginor, I., Lee, B.D. and Stern, L.A. (2020). Strengths, Limitations, and Recommendations for Instrumental Color Measurement in Forensic Soil Characterization. J Forensic Sci, 65: 438-449. https://doi.org/10.1111/1556-4029.14193
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorContrast">colorContrast</a></code> <code><a href="#topic+colorContrastPlot">colorContrastPlot</a></code> <code><a href="#topic+equivalent_munsell">equivalent_munsell</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 7.5YR 4/4 (the one and only)

equivalentMunsellChips("7.5YR", 4, 4)
#&gt;
#&gt; $`7.5YR 4/4`
#&gt;        hue value chroma         r        g         b        L       A       B
#&gt; 8330 7.5YR     4      4 0.4923909 0.352334 0.2313328 41.26403 10.8689 23.5914

# 7.5YR 1/1 (two chips are equivalent; 3 row result)

equivalentMunsellChips("7.5YR", 1, 1)
#&gt;
#&gt; $`7.5YR 1/1`
#&gt;        hue value chroma         r         g          b        L        A        B
#&gt; 1983  10YR     1      1 0.1345633 0.1087014 0.07606787 10.64787 1.621323 6.847629
#&gt; 6189   5YR     1      1 0.1330994 0.1076359 0.09450179 10.63901 2.489012 3.515146
#&gt; 8303 7.5YR     1      1 0.1329483 0.1082380 0.08862581 10.64210 2.065514 4.623922

# 10YR 6/8 (two chips are equivalent; 3 row result)

equivalentMunsellChips("10YR", 6, 8)
#&gt;
#&gt; $`10YR 6/8`
#&gt;       hue value chroma         r         g         b        L        A        B
#&gt; 2039 10YR     6      7 0.7382230 0.5512957 0.2680260 61.76795 10.50886 44.78574
#&gt; 2040 10YR     6      8 0.7519872 0.5472116 0.2157209 61.77496 11.83215 51.15496
#&gt; 2041 10YR     6      9 0.7642826 0.5433189 0.1559069 61.78085 13.09599 57.49773

# compare visually a very red color

veryred &lt;- equivalentMunsellChips("10R", 6, 28)[[1]]

par(mar=c(0,0,1,1))

pie(rep(1, nrow(veryred)), col = with(veryred, munsell2rgb(hue, value, chroma)),
    label = with(veryred, sprintf("%s %s/%s", hue, value, chroma)))

table(veryred$hue) # 2 hues
#&gt; 
#&gt;  10R 7.5R 
#&gt;    8   17

table(veryred$value) # 2 values
#&gt; 
#&gt;  5  6 
#&gt; 11 14

table(veryred$chroma) # 10 chromas
#&gt; 
#&gt; 21 22 23 24 25 26 27 28 29 30 
#&gt;  1  2  2  3  3  4  3  3  2  2

</code></pre>

<hr>
<h2 id='estimateAWC'>Estimate available water capacity for fine-earth fraction</h2><span id='topic+estimateAWC'></span>

<h3>Description</h3>

<p>Estimate available water capacity for fine-earth fraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateAWC(texcl, omcl, precision = 2, FUN = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateAWC_+3A_texcl">texcl</code></td>
<td>
<p>character, USDA textural class fine earth fraction</p>
</td></tr>
<tr><td><code id="estimateAWC_+3A_omcl">omcl</code></td>
<td>
<p>integer, Organic matter class. 1: less than 1.5 percent, 2: less than 5, 3: greate than 5</p>
</td></tr>
<tr><td><code id="estimateAWC_+3A_precision">precision</code></td>
<td>
<p>integer, Number of decimal places in result default: 2</p>
</td></tr>
<tr><td><code id="estimateAWC_+3A_fun">FUN</code></td>
<td>
<p>Function for interpolating between table values default: <code>mean</code></p>
</td></tr>
<tr><td><code id="estimateAWC_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector double containing estimated available water capacities for fine-earth fraction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# organic matter, loam texture, low medium and high OM
base.awc &lt;- estimateAWC(c("l","l","l"), c(1, 2, 3), na.rm = TRUE)
base.awc

</code></pre>

<hr>
<h2 id='estimatePSCS'>Estimate boundaries of the particle size control section (U.S Soil Taxonomy;
12th edition)</h2><span id='topic+estimatePSCS'></span>

<h3>Description</h3>

<p>Estimates the upper and lower boundary of the particle size control section
by applying a programmatic version of the particle size control section key
from the Keys to Soil Taxonomy (12th edition).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimatePSCS(
  p,
  hzdesgn = "hzname",
  clay.attr = "clay",
  texcl.attr = "texcl",
  tax_order_field = "tax_order",
  bottom.pattern = "Cr|R|Cd",
  simplify = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimatePSCS_+3A_p">p</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="estimatePSCS_+3A_hzdesgn">hzdesgn</code></td>
<td>
<p>Name of the horizon attribute containing the horizon
designation. Default 'hzname'</p>
</td></tr>
<tr><td><code id="estimatePSCS_+3A_clay.attr">clay.attr</code></td>
<td>
<p>Name of the horizon attribute containing clay contents.
Default 'clay'</p>
</td></tr>
<tr><td><code id="estimatePSCS_+3A_texcl.attr">texcl.attr</code></td>
<td>
<p>Name of the horizon attribute containing textural class
(used for finding sandy textures). Default 'texcl'</p>
</td></tr>
<tr><td><code id="estimatePSCS_+3A_tax_order_field">tax_order_field</code></td>
<td>
<p>Name of the site attribute containing taxonomic
order; for handling PSCS rules for Andisols in lieu of lab data. May be NA
or column missing altogether, in which case Andisol PSC possibility is
ignored.</p>
</td></tr>
<tr><td><code id="estimatePSCS_+3A_bottom.pattern">bottom.pattern</code></td>
<td>
<p>Regular expression pattern to match a root-restrictive
contact. Default matches Cr, R or Cd. This argument is passed to both
estimateSoilDepth and getArgillicBounds.</p>
</td></tr>
<tr><td><code id="estimatePSCS_+3A_simplify">simplify</code></td>
<td>
<p>Return a length 2 vector with upper and lower boundary when p has length 1? Default TRUE.</p>
</td></tr>
<tr><td><code id="estimatePSCS_+3A_...">...</code></td>
<td>
<p>additional arguments are passed to getArgillicBounds()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires information to identify argillic horizons (clay contents, horizon
designations) with <code>getArgillicBounds()</code> as well as the presence of
plow layers and surface organic soil material. Any
<code>getArgillicBounds()</code> arguments may be passed to <code>estimatePSCS</code>.
</p>
<p>Requires information on taxonomic order (to handle andisols).
</p>
<p>WARNING: Soils in arenic or grossarenic subgroups, with fragipans, or with
strongly contrasting PSCs may not be classified correctly. The author would
welcome a dataset to develop this functionality for.
</p>


<h3>Value</h3>

<p>A numeric vector (when <code>simplify=TRUE</code>) containing the top and bottom depth of the particle
size control section. First value is top, second value is bottom.
If <code>p</code> contains more than one profile, the result is a data.frame with profile ID plus PSCS top and bottom depths.
</p>


<h3>Author(s)</h3>

<p>Andrew Gene Brown
</p>


<h3>References</h3>

<p>Soil Survey Staff. 2014. Keys to Soil Taxonomy, 12th ed.
USDA-Natural Resources Conservation Service, Washington, DC.
</p>


<h3>See Also</h3>

<p><code>getArgillicBounds</code>, <code>getSurfaceHorizonDepth</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1, package = 'aqp')
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

p &lt;- sp1
attr &lt;- 'prop' # clay contents
foo &lt;- estimatePSCS(p, hzdesgn='name', clay.attr = attr, texcl.attr="texture")
foo


</code></pre>

<hr>
<h2 id='estimateSoilColor'>Estimate dry soil colors from moist soil colors and vice versa.</h2><span id='topic+estimateSoilColor'></span>

<h3>Description</h3>

<p>Soil color is typically described at dry and moist conditions. This function attempts to estimate soil color at dry or moist condition when one is missing. Estimation proceeds as:
</p>

<ul>
<li><p> convert Munsell notation to CIELAB color coordinates via <code>munsell2rgb()</code>
</p>
</li>
<li><p> apply scaling, rotation, and translation parameters in CIELAB color space
</p>
</li>
<li><p> convert CIELAB to sRGB coordinates
</p>
</li>
<li><p> locate closest Munsell chip to sRGB coordinates via <code>col2munsell()</code>
</p>
</li></ul>

<p>Estimation of dry from moist soil color state is not guaranteed to be symmetric with estimation of moist from dry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateSoilColor(hue, value, chroma, sourceMoistureState = c("dry", "moist"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateSoilColor_+3A_hue">hue</code></td>
<td>
<p>vector of Munsell hue ('10YR', '2.5Y', etc.)</p>
</td></tr>
<tr><td><code id="estimateSoilColor_+3A_value">value</code></td>
<td>
<p>vector of Munsell value (2,2.5 2.5, 3, 5, 6, etc.)</p>
</td></tr>
<tr><td><code id="estimateSoilColor_+3A_chroma">chroma</code></td>
<td>
<p>vector of Munsell chroma (2, 3, 4, etc.)</p>
</td></tr>
<tr><td><code id="estimateSoilColor_+3A_sourcemoisturestate">sourceMoistureState</code></td>
<td>
<p>character, source colors are either 'dry' or 'moist'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Scaling, rotation, and translation parameters for shifting between dry &lt;&ndash;&gt; moist CIELAB coordinates was determined using <code>vegan::procrustes()</code>, from those official series descriptions (OSD) where moist and dry soil colors were available.
</p>
<p>Estimates for colors having a (dry or moist) Munsell value of 10 are not likely correct.
</p>
<p>This is still a work in progress.
</p>


<h3>Value</h3>

<p><code>data.frame</code> of estimated colors in Munsell notation. The <code>sigma</code> column contains CIE2000 color contrast metric values describing the perceptual distance between estimated color in CIELAB coordinates and closest Munsell chip.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

estimateSoilColor(hue = '10YR', value = 3, chroma = 3, sourceMoistureState = 'moist')

# note that estimation is not symmetric
estimateSoilColor(hue = '10YR', value = 5, chroma = 3, sourceMoistureState = 'dry')

</code></pre>

<hr>
<h2 id='estimateSoilDepth'>Estimate Soil Depth</h2><span id='topic+estimateSoilDepth'></span>

<h3>Description</h3>

<p>Estimate the soil depth of a single profile within a SoilProfileCollection object. This function would typically be called by <code><a href="#topic+profileApply">profileApply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateSoilDepth(
  f,
  name = hzdesgnname(f),
  p = "Cr|R|Cd",
  selection = min,
  no.contact.depth = NULL,
  no.contact.assigned = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateSoilDepth_+3A_f">f</code></td>
<td>
<p>SoilProfileCollection object of length 1, e.g. a single profile</p>
</td></tr>
<tr><td><code id="estimateSoilDepth_+3A_name">name</code></td>
<td>
<p>name of the column that contains horizon designations</p>
</td></tr>
<tr><td><code id="estimateSoilDepth_+3A_p">p</code></td>
<td>
<p>REGEX pattern for determining &quot;contact&quot;, or depth to some morphologic feature (e.g. <code>Bt</code>)</p>
</td></tr>
<tr><td><code id="estimateSoilDepth_+3A_selection">selection</code></td>
<td>
<p>an R function applied in the presence of multiple matching horizons: <code>min</code> (default), <code>max</code>, <code>mean</code>, etc.</p>
</td></tr>
<tr><td><code id="estimateSoilDepth_+3A_no.contact.depth">no.contact.depth</code></td>
<td>
<p>in the absence of contact matching <code>p</code>, a depth at which we can assume a standard depth-to-contact</p>
</td></tr>
<tr><td><code id="estimateSoilDepth_+3A_no.contact.assigned">no.contact.assigned</code></td>
<td>
<p>value assigned when no contact is encountered at or below <code>no.contact.depth</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The choice of a <code>selection</code> function usually follows:
</p>
<p><code>min</code>: the top of the first matching horizon, <code>max</code>: the top bot the last matching horizon,
or possibly <code>mean</code>: somewhere in-between.
</p>


<h3>Value</h3>

<p>single value representing the depth to <code>contact</code> or <code>no.contact.assigned</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and J.M. Skovlin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getSoilDepthClass">getSoilDepthClass</a></code>, <code><a href="#topic+profileApply">profileApply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## consider a situation where there were multiple candidate
## "contacts": 2 Cd horizons over an R

# init hypothetical profile
d &lt;- data.frame(
  id = '1',
  top = c(0, 10, 20, 30, 40, 50, 60),
  bottom = c(10, 20, 30, 40, 50, 60, 80),
  name = c('A', 'Bt1', 'Bt2', 'BC', 'Cd1', 'Cd2', 'R'),
  stringsAsFactors = FALSE
)

# upgrade to SPC
depths(d) &lt;- id ~ top + bottom

# init horizon designation
hzdesgnname(d) &lt;- 'name'

# visual check
par(mar = c(0, 0, 0, 1))
plotSPC(d, hz.depths = TRUE, name.style = 'center-center', cex.names = 1, width = 0.1)

# top of the first Cd
estimateSoilDepth(d, name = 'name')

# top of the first Cd
estimateSoilDepth(d, name = 'name', selection = min)

# top of the R
estimateSoilDepth(d, name = 'name', selection = max)

# top of the second Cd
estimateSoilDepth(d, name = 'name', selection = max, p = 'Cd')


## another example

data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# init horizon designation
hzdesgnname(d) &lt;- 'name'

# apply to each profile in a collection, and save as site-level attribute
sp1$depth &lt;- profileApply(sp1, estimateSoilDepth, name='name')

# this function can be used to "find" depth to any feature 
# that can be defined via REGEX pattern matching on the horizon name
# for example, locate the depth to the top "Bt" horizon
# returning NA when there is no match
sp1$top_Bt &lt;- profileApply(
  sp1, estimateSoilDepth, 
  name='name', 
  p='Bt', 
  no.contact.depth=0, 
  no.contact.assigned=NA
)

# reduced margins
par(mar=c(1,1,1,2))
# adjust default y-offset and depth scaling for following examples
plotSPC(sp1, y.offset=10, scaling.factor=0.5)

# get plotting parameters for profile widths and depth scaling factors
lsp &lt;- get("last_spc_plot", envir = aqp.env)

# positions on x-axis, same for both depth and top "Bt" horizon
x.positions &lt;- (1:length(sp1)) - lsp$width

# annotate contact with unicode right-arrow
# y-position is adjusted based on plot y-offset and scaling factor
y.positions &lt;- lsp$y.offset + (sp1$depth * lsp$scaling.factor)
text(x.positions, y.positions, '\u2192', col='red', adj=1, cex=1.25, lwd=2)

# annotate top "Bt" depth with unicode right-arrow
# y-position is adjusted based on plot y-offset and scaling factor
y.positions &lt;- lsp$y.offset + (sp1$top_Bt * lsp$scaling.factor)
text(x.positions, y.positions, '\u2192', col='blue', adj=1, cex=1.25, lwd=2)


## Not run: 
  # sample data
  data(gopheridge, package='soilDB')
  
  # run on a single profile
  estimateSoilDepth(gopheridge[1, ], name = 'hzname')
  
  # apply to an entire collection
  profileApply(gopheridge, estimateSoilDepth, name = 'hzname')

## End(Not run)
</code></pre>

<hr>
<h2 id='evalGenHZ'>Evaluate Generalized Horizon Labels</h2><span id='topic+evalGenHZ'></span>

<h3>Description</h3>

<p>Data-driven evaluation of generalized horizon labels using nMDS and
silhouette width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalGenHZ(
  obj,
  genhz = GHL(obj, required = TRUE),
  vars,
  non.matching.code = "not-used",
  stand = TRUE,
  trace = FALSE,
  metric = "euclidean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalGenHZ_+3A_obj">obj</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="evalGenHZ_+3A_genhz">genhz</code></td>
<td>
<p>name of horizon-level attribute containing generalized horizon
labels</p>
</td></tr>
<tr><td><code id="evalGenHZ_+3A_vars">vars</code></td>
<td>
<p>character vector of horizon-level attributes to include in the
evaluation</p>
</td></tr>
<tr><td><code id="evalGenHZ_+3A_non.matching.code">non.matching.code</code></td>
<td>
<p>code used to represent horizons not assigned a
generalized horizon label</p>
</td></tr>
<tr><td><code id="evalGenHZ_+3A_stand">stand</code></td>
<td>
<p>standardize variables before computing distance matrix (default
= TRUE), passed to <code><a href="cluster.html#topic+daisy">daisy</a></code></p>
</td></tr>
<tr><td><code id="evalGenHZ_+3A_trace">trace</code></td>
<td>
<p>verbose output from passed to <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code>, (default =
FALSE)</p>
</td></tr>
<tr><td><code id="evalGenHZ_+3A_metric">metric</code></td>
<td>
<p>distance metric, passed to <code><a href="cluster.html#topic+daisy">daisy</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-metric multidimensional scaling is performed via <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code>.
The input distance matrix is generated by <code><a href="cluster.html#topic+daisy">daisy</a></code> using
(complete cases of) horizon-level attributes from <code>obj</code> as named in
<code>vars</code>.
</p>
<p>Silhouette widths are computed via <code><a href="cluster.html#topic+silhouette">silhouette</a></code>. The input
distance matrix is generated by <code><a href="cluster.html#topic+daisy">daisy</a></code> using (complete cases
of) horizon-level attributes from <code>obj</code> as named in <code>vars</code>. Note
that observations with genhz labels specified in <code>non.matching.code</code>
are removed filtered before calculation of the distance matrix.
</p>


<h3>Value</h3>

<p>a list is returned containing: </p>
 <dl>
<dt>horizons</dt><dd><p>c('mds.1',
'mds.2', 'sil.width', 'neighbor')</p>
</dd> <dt>stats</dt><dd><p>mean and standard deviation
of <code>vars</code>, computed by generalized horizon label</p>
</dd> <dt>dist</dt><dd><p>the
distance matrix as passed to <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code></p>
</dd> </dl>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.ml.hz">get.ml.hz</a></code>
</p>

<hr>
<h2 id='evalMissingData'>Evaluate Missing Data within a SoilProfileCollection</h2><span id='topic+evalMissingData'></span>

<h3>Description</h3>

<p>Evaluate missing data within a <code>SoilProfileCollection</code> object
</p>
<p>Data completeness is evaluated by profile or by horizon. Profile-level evaluation is based on the thickness of horizons (<code>method = absolute</code>) with complete horizon-level attributes (<code>vars</code>), optionally divided by the total thickness (<code>method = relative</code>). The REGEX pattern (<code>p</code>) is used to filter non-soil horizons from the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalMissingData(
  x,
  vars,
  name = hzdesgnname(x),
  p = "Cr|R|Cd",
  method = c("relative", "absolute", "horizon")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalMissingData_+3A_x">x</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="evalMissingData_+3A_vars">vars</code></td>
<td>
<p>character vector, naming horizon-level attributes in <code>x</code></p>
</td></tr>
<tr><td><code id="evalMissingData_+3A_name">name</code></td>
<td>
<p>character, the name of a horizon-level attribute where horizon designations are stored, defaults to <code>hzdesgnname(x)</code></p>
</td></tr>
<tr><td><code id="evalMissingData_+3A_p">p</code></td>
<td>
<p>character, REGEX pattern used to match non-soil horizons</p>
</td></tr>
<tr><td><code id="evalMissingData_+3A_method">method</code></td>
<td>
<p>character, one of: 'relative' (proportion of total) depth, 'absolute' depth, or 'horizon' (fraction not-missing by horizon)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector values ranging from 0 to 1 (<code>method = 'relative'</code>) or 0 to maximum depth in specified depth units (<code>method = 'absolute'</code>) representing the quantity of non-missing data (as specified in <code>vars</code>) for each profile. When <code>method = 'horizon'</code> a non-missing data fraction is returned for each horizon.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example data
data("jacobs2000")

# fully populated
plotSPC(jacobs2000, name.style = 'center-center', 
        cex.names = 0.8, color = 'time_saturated')

# missing some data
plotSPC(jacobs2000, name.style = 'center-center', 
        cex.names = 0.8, color = 'concentration_color')

# very nearly complete
plotSPC(jacobs2000, name.style = 'center-center', 
        cex.names = 0.8, color = 'matrix_color')


# variables to consider
v &lt;- c('time_saturated', 'concentration_color', 'matrix_color')

# compute data completeness by profile
# ignore 2C horizons
jacobs2000$data.complete &lt;- evalMissingData(
  jacobs2000, 
  vars = v, 
  method = 'relative',
  p = '2C'
)

jacobs2000$data.complete.abs &lt;- evalMissingData(
  jacobs2000, 
  vars = v, 
  method = 'absolute',
  p = '2C'
)

# compute data completeness by horizon
# ignore 2C horizons
jacobs2000$hz.data.complete &lt;- evalMissingData(
  jacobs2000, 
  vars = v, 
  method = 'horizon',
  p = '2C'
)


# "fraction complete" by horizon
plotSPC(
  jacobs2000, name.style = 'center-center', 
  cex.names = 0.8, color = 'hz.data.complete'
)


# rank on profile completeness
new.order &lt;- order(jacobs2000$data.complete)

# plot along data completeness ranking
plotSPC(
  jacobs2000, name.style = 'center-center', 
  cex.names = 0.8, color = 'concentration_color', 
  plot.order = new.order
)

# add relative completeness axis
# note re-ordering of axis labels
axis(
  side = 1, at = 1:length(jacobs2000), 
  labels = round(jacobs2000$data.complete[new.order], 2),
  line = 0, cex.axis = 0.75
)

# add absolute completeness (cm)
axis(
  side = 1, at = 1:length(jacobs2000), 
  labels = jacobs2000$data.complete.abs[new.order],
  line = 2.5, cex.axis=0.75
)

</code></pre>

<hr>
<h2 id='explainPlotSPC'>Visual Explanation for <code>plotSPC</code></h2><span id='topic+explainPlotSPC'></span>

<h3>Description</h3>

<p>Create a visual explanation for the many arguments to <code>plotSPC</code>. Call this function instead of <code>plotSPC</code>, all objects after <code>x</code> are passed on to <code>plotSPC</code>. Nearly all of the figures in the <a href="https://ncss-tech.github.io/AQP/aqp/aqp-intro.html">Introduction to SoilProfileCollection Objects tutorial</a> are created with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explainPlotSPC(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explainPlotSPC_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="explainPlotSPC_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+plotSPC">plotSPC</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of internally-used ordering vectors and graphical offsets / scaling factors
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSPC">plotSPC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# sample data
data(sp4)
depths(sp4) &lt;- id ~ top + bottom

# proposed vector of relative positions, overlap likely
pos &lt;- c(1, 1.1, 3, 4, 5, 5.2, 7, 8, 9, 10)

# try it
explainPlotSPC(sp4, name = 'name', relative.pos=pos)

# attempt to fix using an integer sequence, short-circut will prevent adjustments
explainPlotSPC(sp4, name = 'name', relative.pos = fixOverlap(1:10))

# attempt to adjust using defaults
explainPlotSPC(sp4, name = 'name', relative.pos = fixOverlap(pos))

# attempt to adjust and tinker with defaults
explainPlotSPC(sp4, name = 'name', relative.pos = fixOverlap(pos, adj = 0.2))

# enforce larger space between
explainPlotSPC(sp4, name = 'name', relative.pos = fixOverlap(pos, thresh = 0.7))

# more complex adjustments required
pos &lt;- c(1, 2, 3, 3.3, 5, 5.1, 5.5, 8, 9, 10)

# tinker
explainPlotSPC(sp4, name = 'name', relative.pos = pos)
explainPlotSPC(sp4, name = 'name', relative.pos = fixOverlap(pos))

explainPlotSPC(sp4, name = 'name', relative.pos = fixOverlap(pos, 
thresh = 0.7))

explainPlotSPC(sp4, name = 'name', relative.pos = fixOverlap(pos, 
thresh = 0.7, adj = 0.2))

# SANN: solution requires many iterations, and will not always converge
explainPlotSPC(sp4, name = 'name', 
relative.pos = fixOverlap(pos, thresh = 0.85, adj = 0.2)
)

# electrostatics: solution requires larger charge (q)
explainPlotSPC(sp4, name = 'name', 
relative.pos = fixOverlap(pos, thresh = 0.85, method = 'E', q = 2)
)

</code></pre>

<hr>
<h2 id='fillHzGaps'>Find and Fill Horizon Gaps</h2><span id='topic+fillHzGaps'></span>

<h3>Description</h3>

<p>This function attempts to find &quot;gaps&quot; in the horizon records of a <code>SoilProfileCollection</code> object and fill with placeholder horizons (profile ID, horizon ID, to/bottom depths, all else <code>NA</code>). Missing horizon records between the top of each profile and <code>to_top</code>, or the bottom of each profile and <code>to_bottom</code> are treated as gaps when those arguments are not <code>NULL</code>. You can use this function to prepare a potentially messy <code>SoilProfileCollection</code> for subsequent analyses that are sensitive to horizon sequence inconsistencies or require a conformal &quot;rectangle&quot; of data spanning known depths.
</p>
<p>Gaps are defined as:
</p>

<ul>
<li><p> within each profile, for horizons <code>i</code> to <code>n_hz</code>:
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;bottom_i != top_i+1 (but only to i = 1:(n_hz - 1)&#8288;</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>fillHzGaps(x, flag = TRUE, to_top = 0, to_bottom = max(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillHzGaps_+3A_x">x</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="fillHzGaps_+3A_flag">flag</code></td>
<td>
<p>logical, flag empty horizons that have been added. default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="fillHzGaps_+3A_to_top">to_top</code></td>
<td>
<p>numeric, fill from shallowest top depth in each profile to specified depth? default: <code>0</code></p>
</td></tr>
<tr><td><code id="fillHzGaps_+3A_to_bottom">to_bottom</code></td>
<td>
<p>numeric, fill from deepest bottom depth in each profile to specified depth? default: <code>aqp::max(x)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a possibly modified <code>SoilProfileCollection</code> object
</p>


<h3>Author(s)</h3>

<p>A.G. Brown and D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp4)
depths(sp4) &lt;- id ~ top + bottom

# introduce depth logic errors
idx &lt;- c(2, 6:7, 8, 12)
sp4$top[idx] &lt;- NA

# check
horizons(sp4)[idx, ]

# create gaps by removing logic errors
x &lt;- HzDepthLogicSubset(sp4, byhz = TRUE)

# check on removed horizons (hzID values)
metadata(x)$removed.horizons

# inspect
par(mar = c(0, 0, 0, 2))
plotSPC(x, width = 0.3, default.color = 'royalblue', 
name = 'hzID', name.style = 'center-center', cex.names = 0.8,
cex.id = 0.66)

# fill gaps left by HzDepthLogicSubset()
z &lt;- fillHzGaps(x, flag = TRUE)

# graphical check
plotSPC(z, width = 0.3, color = '.filledGap', name = 'hzID', 
show.legend = FALSE, name.style = 'center-center', cex.names = 0.8,
cex.id = 0.66)

# fill top to 0 cm
z2 &lt;- fillHzGaps(x, flag = TRUE, to_top = 0)
plotSPC(z2, width = 0.3, color = '.filledGap', name = 'hzID', show.legend = FALSE)

# fill bottom to max(SPC)
z3 &lt;- fillHzGaps(x, flag = TRUE, to_top = 0, to_bottom = max(x))
plotSPC(z3, width = 0.3, color = '.filledGap', name = 'hzID', show.legend = FALSE)

## another example
data(sp4)
depths(sp4) &lt;- id ~ top + bottom

# remove 1st horizons from profiles 1:4
idx &lt;- sp4[,, .FIRST, .HZID]
replaceHorizons(sp4) &lt;- horizons(sp4)[-idx[1:4], ]

# prepare for dice()
z &lt;- fillHzGaps(sp4, to_top = 0, to_bottom = 50, flag = TRUE) 

# empty-horizon padding is in place for formula interface to dice()
d &lt;- dice(z, fm = 0:50 ~ .)
plotSPC(d, color = 'Ca', show.legend = FALSE)
plotSPC(d, color = '.filledGap', show.legend = FALSE)

</code></pre>

<hr>
<h2 id='findOverlap'>Find Overlap within a Sequence</h2><span id='topic+findOverlap'></span><span id='topic+overlapMetrics'></span>

<h3>Description</h3>

<p>Establish which elements within a vector of horizontal positions overlap beyond a given threshold
</p>
<p>Desc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findOverlap(x, thresh)

overlapMetrics(x, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findOverlap_+3A_x">x</code></td>
<td>
<p>vector of relative horizontal positions, one for each profile</p>
</td></tr>
<tr><td><code id="findOverlap_+3A_thresh">thresh</code></td>
<td>
<p>threshold defining &quot;overlap&quot;, typically &lt; 1
</p>
<p>@return a <code>list</code>:
</p>

<ul>
<li> <p><code>idx</code>: unique index to overlapping elements in <code>x</code>
</p>
</li>
<li> <p><code>ov</code>: normalized overlap (see details)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>unique index to affected (overlapping) elements in <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1, 2, 3, 3.4, 3.5, 5, 6, 10)

findOverlap(x, thresh = 0.5)


x &lt;- c(1, 2, 3, 3.4, 3.5, 5, 6, 10)

overlapMetrics(x, thresh = 0.5)


</code></pre>

<hr>
<h2 id='fixOverlap'>Fix Overlap within a Sequence</h2><span id='topic+fixOverlap'></span>

<h3>Description</h3>

<p>Fix Overlap within a Sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixOverlap(x, thresh = 0.6, method = c("S", "E"), trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixOverlap_+3A_x">x</code></td>
<td>
<p>vector of initial positions, pre-sorted</p>
</td></tr>
<tr><td><code id="fixOverlap_+3A_thresh">thresh</code></td>
<td>
<p>numeric, overlap threshold defined on the same scale as <code>x</code></p>
</td></tr>
<tr><td><code id="fixOverlap_+3A_method">method</code></td>
<td>
<p>character vector, 'S' for simulated annealing via <code><a href="#topic+SANN_1D">SANN_1D()</a></code> or 'E' for electrostatic simulation via <code><a href="#topic+electroStatics_1D">electroStatics_1D()</a></code></p>
</td></tr>
<tr><td><code id="fixOverlap_+3A_trace">trace</code></td>
<td>
<p>logical, return full output</p>
</td></tr>
<tr><td><code id="fixOverlap_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+SANN_1D">SANN_1D()</a></code> or <code><a href="#topic+electroStatics_1D">electroStatics_1D()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>trace = FALSE</code>, a vector of the same length as <code>x</code>, preserving rank-ordering and boundary conditions. When <code>trace = TRUE</code> a list containing the new sequence along with information about objective functions and decisions made during adjustment of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+electroStatics_1D">electroStatics_1D()</a></code>, <code><a href="#topic+SANN_1D">SANN_1D()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s &lt;- c(1, 2, 2.3, 4, 5, 5, 7)

# simulated annealing, solution is non-deterministic
fixOverlap(s, thresh = 0.6, method = 'S')

# electrostatics-inspired simulation of particles
# solution is deterministic
fixOverlap(s, thresh = 0.6, method = 'E')


# create a very busy profile with lots of possible overlapping
# depth annotation
x &lt;- quickSPC(
  "SPC:AAA|BBB|CCC|D|EEEEE|FF|GG|HH|I|I|JJ|KK|LL|M|N|O|P|QQQQ|RR|S|TTTTTT|U", 
  interval = 1
)

# convert horizon ID to numeric
x$z &lt;- as.numeric(x$hzID)

# plotSPC arguments
.a &lt;- list(
  width = 0.2, 
  hz.depths = TRUE, 
  name.style = 'center-center', 
  cex.names = 1.5, 
  depth.axis = FALSE, 
  name = NA,
  color = 'z',
  show.legend = FALSE,
  print.id = FALSE,
  col.palette = hcl.colors(n = 25, palette = 'Spectral', rev = TRUE)
)

# set plotSPC default arguments
options(.aqp.plotSPC.args = .a)

# wrapper function to test label collision solutions
testIt &lt;- function(x, ...) {
  
  plotSPC(x, ...)
  
  # a normalized index of label adjustment
  .txt &lt;- sprintf(
    "LAI: %0.3f", 
    get('last_spc_plot', envir = aqp.env)$hz.depth.LAI
  )
  mtext(.txt, side = 1, at = 1, line = -2, cex = 0.8)
  
}


# compare and contrast
op &lt;- par(mar = c(0, 0, 0, 0), mfcol = c(1, 6))

testIt(x)
title('ES (defaults)', line = -3)

testIt(x, fixOverlapArgs = list(method = 'S'))
title('SANN (defaults)', line = -3)

testIt(x, fixOverlapArgs = list(method = 'E', q = 1.5))
title('ES (q = 1.5)', line = -3)

testIt(x, fixOverlapArgs = list(method = 'E', q = 1))
title('ES (q = 1)', line = -3)

testIt(x, fixOverlapArgs = list(method = 'E', q = 0.5))
title('ES (q = 0.5)', line = -3)

testIt(x, fixOverlapArgs = list(method = 'E', q = 0.1))
title('ES (q = 0.1)', line = -3)

par(op)

</code></pre>

<hr>
<h2 id='flagOverlappingHz'>Flag perfectly overlapping horizons within a SoilProfileCollection</h2><span id='topic+flagOverlappingHz'></span>

<h3>Description</h3>

<p>Flag perfectly overlapping horizons within a SoilProfileCollection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flagOverlappingHz(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flagOverlappingHz_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector with length (and order) matching the horizons of <code>x</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two overlapping horizons
z &lt;- data.frame(
  id = 'SPC',
  top = c(0, 25, 25, 50, 75, 100, 100),
  bottom = c(25, 50, 50, 75, 100, 125, 125)
)

# init SPC
depths(z) &lt;- id ~ top + bottom

# flag perfectly overlapping horizons
z$.overlapFlag &lt;- flagOverlappingHz(z)

# thematic sketches
plotSPC(z, color = '.overlapFlag', hz.depths = TRUE, 
depth.axis = FALSE, cex.names = 0.85)

</code></pre>

<hr>
<h2 id='fragmentClasses'>Coarse Fragment Class Labels and Diameter</h2><span id='topic+fragmentClasses'></span>

<h3>Description</h3>

<p>This is a convenience function for accessing coarse fragment class labels and associated diameter (mm), as defined in various classification systems such as USDA, Unified, and AASHTO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fragmentClasses(
  sys = c("usda_simplified", "usda", "international", "unified", "aashto",
    "mod.wentworth"),
  flat = FALSE,
  rounded = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fragmentClasses_+3A_sys">sys</code></td>
<td>
<p>character, length 1. This is an abbreviated name used to select class labels and fragment diameter.</p>
</td></tr>
<tr><td><code id="fragmentClasses_+3A_flat">flat</code></td>
<td>
<p>logical. Fragments are flat, only used by USDA systems.</p>
</td></tr>
<tr><td><code id="fragmentClasses_+3A_rounded">rounded</code></td>
<td>
<p>logical. Fragments are rounded, only used by AASHTO system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector of fragment diameter in mm
</p>


<h3>References</h3>

<p>Schoeneberger, P.J., D.A. Wysocki, E.C. Benham, and Soil Survey Staff. 2012. Field book for describing and sampling soils, Version 3.0. Natural Resources Conservation Service, National Soil Survey Center, Lincoln, NE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fragmentSieve">fragmentSieve()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use default system: "usda_simplified"
fragmentClasses()
fragmentClasses(flat = TRUE)

fragmentClasses(sys = 'usda')
fragmentClasses(sys = 'USDA', flat = TRUE)

fragmentClasses(sys = 'international')

fragmentClasses(sys = 'unified')

fragmentClasses(sys = 'aashto')
fragmentClasses(sys = 'aashto', rounded = TRUE)

fragmentClasses(sys = 'mod.wentworth')

</code></pre>

<hr>
<h2 id='fragmentSieve'>Sieve the Coarse Fraction of Soil</h2><span id='topic+fragmentSieve'></span>

<h3>Description</h3>

<p>Sieve applies thresholds to a numeric vector of fragment diameter values, returning fragment size classes. Particle diameter thresholds are evaluated as <code>d &lt; threshold</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fragmentSieve(
  diameter,
  sieves = NULL,
  ordered = FALSE,
  prefix = "",
  new_names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fragmentSieve_+3A_diameter">diameter</code></td>
<td>
<p>numeric. Vector of diameters of coarse fragments to &quot;sieve&quot;. Default <code>sieves</code> are specified in millimeters.</p>
</td></tr>
<tr><td><code id="fragmentSieve_+3A_sieves">sieves</code></td>
<td>
<p>leave as <code>NULL</code> to use fragment class labels and diameters defined by <code><a href="#topic+fragmentClasses">fragmentClasses()</a></code>, or a named vector of fragment diameters. See examples.</p>
</td></tr>
<tr><td><code id="fragmentSieve_+3A_ordered">ordered</code></td>
<td>
<p>logical. Return as an ordered factor.</p>
</td></tr>
<tr><td><code id="fragmentSieve_+3A_prefix">prefix</code></td>
<td>
<p>character. Add a prefix to result names? Default: <code>""</code> adds no prefix. For example <code>"para"</code> might be used for size classes of pararock fragments.</p>
</td></tr>
<tr><td><code id="fragmentSieve_+3A_new_names">new_names</code></td>
<td>
<p>Optional: apply new labels to result classes. Should match length of <code>sieves</code>.</p>
</td></tr>
<tr><td><code id="fragmentSieve_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+fragmentClasses">fragmentClasses()</a></code>, such as <code>sys</code>, <code>flat</code>, and <code>rounded</code>, see examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character. Size class labels based on names of <code>sieves</code>, <code>new_names</code>, and <code>prefix</code> (if specified).
</p>


<h3>References</h3>

<p>Soil Science Division Staff. 2017. Soil survey manual. C. Ditzler, K. Scheffe, and H.C. Monger (eds.). USDA Handbook 18. Government Printing Office, Washington, D.C.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fragmentClasses">fragmentClasses()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use a simplified version of the USDA system
# common within NRCS/SPSD and NCSS
fragmentSieve(c(30, 125, 180, 500, 1000))

# pararock fragments
fragmentSieve(c(30, 125, 180, 500, 1000), prefix = 'para')

# result as an ordered factor
fragmentSieve(c(30, 125, 180, 500, 1000), ordered = TRUE)

# USDA system, flat size classes
fragmentSieve(c(30, 125, 180, 500, 1000), flat = TRUE)

# alternative classification systems
fragmentSieve(c(30, 125, 180, 500, 1000), sys = 'usda')
fragmentSieve(c(30, 125, 180, 500, 1000), sys = 'international')
fragmentSieve(c(30, 125, 180, 500, 1000), sys = 'unified')
fragmentSieve(c(30, 125, 180, 500, 1000), sys = 'aashto')
fragmentSieve(c(30, 125, 180, 500, 1000), sys = 'mod.wentworth')

# custom fragment labels / diameter
fragmentSieve(
  c(30, 125, 180, 500, 1000),
  sieves = c(clumps = 50, chunks = 300, blocks = 100000)
)

# unnamed sieves, generic labels used
fragmentSieve(c(10, 50), sieves = c(30, 70))

fragmentSieve(c(10, 50), sieves = c(30, 70), ordered = TRUE)
 
</code></pre>

<hr>
<h2 id='generalize.hz'>Generalize Horizon Names</h2><span id='topic+generalize.hz'></span><span id='topic+generalizeHz+2Ccharacter-method'></span><span id='topic+generalizeHz'></span><span id='topic+generalizeHz+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Generalize a vector of horizon names, based on new classes, and REGEX
patterns. Or create a new column <code>ghl</code> in a <code>SoilProfileCollection</code> (requires a horizon designation name to be defined for the collection, see details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generalize.hz(
  x,
  new,
  pattern,
  non.matching.code = "not-used",
  hzdepm = NULL,
  ordered = !missing(hzdepm),
  ...
)

## S4 method for signature 'character'
generalizeHz(
  x,
  new,
  pattern,
  non.matching.code = "not-used",
  hzdepm = NULL,
  ordered = !missing(hzdepm),
  ...
)

## S4 method for signature 'SoilProfileCollection'
generalizeHz(
  x,
  new,
  pattern,
  non.matching.code = "not-used",
  hzdepm = NULL,
  ordered = !missing(hzdepm),
  ghl = "genhz",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalize.hz_+3A_x">x</code></td>
<td>
<p>character vector of horizon names or a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="generalize.hz_+3A_new">new</code></td>
<td>
<p>character vector of generalized horizon labels (GHL)</p>
</td></tr>
<tr><td><code id="generalize.hz_+3A_pattern">pattern</code></td>
<td>
<p>character vector of REGEX patterns, same length as <code>new</code></p>
</td></tr>
<tr><td><code id="generalize.hz_+3A_non.matching.code">non.matching.code</code></td>
<td>
<p>character, label used for any horizon not matched by <code>pattern</code></p>
</td></tr>
<tr><td><code id="generalize.hz_+3A_hzdepm">hzdepm</code></td>
<td>
<p>numeric vector of horizon mid-points; <code>NA</code> values in <code>hzdepm</code> will result in <code>non.matching.code</code> (or <code>NA</code> if not defined) in result</p>
</td></tr>
<tr><td><code id="generalize.hz_+3A_ordered">ordered</code></td>
<td>
<p>logical, <code>TRUE</code> when <code>hzdepm</code> argument is specified</p>
</td></tr>
<tr><td><code id="generalize.hz_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>grep()</code> such as <code>perl = TRUE</code> for advanced REGEX</p>
</td></tr>
<tr><td><code id="generalize.hz_+3A_ghl">ghl</code></td>
<td>
<p>Generalized Horizon Designation column name (to be created/updated when <code>x</code> is a <code>SoilProfileCollection</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> is a <code>SoilProfileCollection</code> the <code>ghl</code> column will be updated with the factor results. This requires that the &quot;horizon designation name&quot; metadata be defined for the collection to set the column for input designations.
</p>


<h3>Value</h3>

<p>factor (possibly an ordered factor) of the same length as <code>x</code> (if character) or as number of horizons in <code>x</code> (if <code>SoilProfileCollection</code>)
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Beaudette, D. E., Roudier, P., &amp; Skovlin, J. (2016). Probabilistic representation of genetic soil horizons. Digital soil morphometrics, 281-293.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hzdesgnname">hzdesgnname()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)

# check original distribution of hz designations
table(sp1$name)

# generalized horizon labels
# character vector input
sp1$genhz &lt;- generalizeHz(
  sp1$name,
  new = c('O','A','B','C','R'),
  pattern = c('O', '^A','^B','C','R'),
  ordered = TRUE
)

# see how we did / what we missed
table(sp1$genhz, sp1$name)


## a more advanced example, requries `perl = TRUE`
# example data
x &lt;- c('A', 'AC', 'Bt1', '^AC', 'C', 'BC', 'CB')

# new labels
n &lt;- c('A', '^AC', 'C')

# patterns:
# "A anywhere in the name"
# "literal '^A' anywhere in the name"
# "C anywhere in name, but without preceding A"
p &lt;- c('A', '^A', '(?&lt;!A)C')

# note additional argument
res &lt;- generalizeHz(
  x, 
  new = n, 
  pattern = p, 
  perl = TRUE
)

# double-check: OK
table(res, x)

## apply to a SoilProfileCollection
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# must set horizon designation metadata
hzdesgnname(sp1) &lt;- 'name'

# result is a SoilProfileCollection
x &lt;- generalizeHz(
  sp1,
  new = c('O','A','B','C','R'),
  pattern = c('O', '^A','^B','C','R'),
  ordered = TRUE
)

# GHL stored in 'genhz' column
x$genhz

# GHL metadata is set
GHL(x)

</code></pre>

<hr>
<h2 id='genhzTableToAdjMat'>Convert cross-tabulation to adjacency matrix.</h2><span id='topic+genhzTableToAdjMat'></span>

<h3>Description</h3>

<p>Convert a cross-tabulation of e.g. original horizon designations vs. generalized horizon labels to adjacency matrix form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genhzTableToAdjMat(tab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genhzTableToAdjMat_+3A_tab">tab</code></td>
<td>
<p>table, cross-tabulation of original and generalized horizon labels e.g. <code>table(original, genhz)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of numeric values
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='genSlabLabels'>Generate Labels for Slabs</h2><span id='topic+genSlabLabels'></span>

<h3>Description</h3>

<p>This method is used by <code><a href="#topic+slab">slab()</a></code> for generating labels that assign IDs to layers in a SoilProfileCollection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genSlabLabels(
  slab.structure = 1,
  max.d = NULL,
  n.profiles = NULL,
  spc = NULL,
  diced = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genSlabLabels_+3A_slab.structure">slab.structure</code></td>
<td>
<p>A user-defined slab thickness (defined by an integer), or user-defined structure (numeric vector). See details for <code>slab()</code>.</p>
</td></tr>
<tr><td><code id="genSlabLabels_+3A_max.d">max.d</code></td>
<td>
<p>Maximum depth</p>
</td></tr>
<tr><td><code id="genSlabLabels_+3A_n.profiles">n.profiles</code></td>
<td>
<p>Number of profiles</p>
</td></tr>
<tr><td><code id="genSlabLabels_+3A_spc">spc</code></td>
<td>
<p>Optional: A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="genSlabLabels_+3A_diced">diced</code></td>
<td>
<p>Optional: The <code>dice()</code>-ed horizon-level data.frame corresponding to <code>spc</code></p>
</td></tr>
<tr><td><code id="genSlabLabels_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>dice()</code> when <code>spc</code> is specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new routine used in aqp 2.0 requires that, at a minimum, the <code>spc</code> and <code>slab.structure</code> arguments be specified.
</p>


<h3>Value</h3>

<p>factor. slab IDs, labels are the segment top and bottom depth separated by <code>"-"</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slab">slab()</a></code>
</p>

<hr>
<h2 id='get.increase.matrix'>Compute Pair-wise Distances of Soil Properties over Depth</h2><span id='topic+get.increase.matrix'></span><span id='topic+get.increase.depths'></span>

<h3>Description</h3>

<p>Computes pair-wise distance matrix to determine where an attribute increases within
a specified vertical distance threshold.
</p>
<p><code>get.increase.depths</code> performs the conversion of the square matrix
output of <code>get.increase.matrix</code> back to horizon top depth for where
criteria were met.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.increase.matrix(p, attr, threshold.fun, vertical.distance)

get.increase.depths(p, attr, threshold.fun, vertical.distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.increase.matrix_+3A_p">p</code></td>
<td>
<p>a SoilProfileCollection, containing a single profile</p>
</td></tr>
<tr><td><code id="get.increase.matrix_+3A_attr">attr</code></td>
<td>
<p>horizon attribute name to get the &quot;increase&quot; of</p>
</td></tr>
<tr><td><code id="get.increase.matrix_+3A_threshold.fun">threshold.fun</code></td>
<td>
<p>a function that returns the threshold (as a function of
attr); may return a constant single value</p>
</td></tr>
<tr><td><code id="get.increase.matrix_+3A_vertical.distance">vertical.distance</code></td>
<td>
<p>the vertical distance (determined from difference
SPC top depth variable) within which increase must be met</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses matrix outer product to determine all pair-wise differences in <code>attr</code>
for the horizons of <code>p</code>. Supplies <code>attr</code> to <code>threshold.fun</code> to determine the
minimum value criterion to return TRUE in output matrix for an &quot;increase&quot;.
Also, computes all pair-wise distances in depth dimension to determine
whether the vertical distance criteria have been met simultaneously with
<code>attr</code> increase.
</p>
<p>This function assumes that the <code>threshold.fun</code> supplied by the user returns
either a constant or a vector of equal length to its input.
</p>
<p>Note that the <code>threshold.fun</code> result is allowed to contain NA, but that will
result in no output for affected cells.
</p>
<p><code>get.increase.depths</code> performs the conversion of the square matrix
output of <code>get.increase.matrix</code> back to horizon top depth for where
criteria were met.
</p>
<p>Note that the <code>threshold.fun</code> result is allowed to contain <code>NA</code>, but that will
result in no output for affected cells.
</p>


<h3>Value</h3>

<p>Returns a square logical matrix reflecting where the increase
criteria were met.
</p>
<p><code>get.increase.depths</code> converts to horizon dop depth by using above
matrix output to determine depths where increase is met.
</p>
<p>Returns a numeric vector of depths where the increase requirement is
met. For the argillic, the first is the one of interest.
</p>
<p><code>get.increase.depths()</code> converts to horizon top depth by using above
matrix output to determine depths where increase is met.
</p>


<h3>Author(s)</h3>

<p>Andrew Gene Brown
</p>


<h3>See Also</h3>

<p><code>getArgillicBounds</code>, <code>crit.clay.argillic</code>
</p>
<p><code><a href="#topic+getArgillicBounds">getArgillicBounds()</a></code> <code><a href="#topic+crit.clay.argillic">crit.clay.argillic()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1, package = 'aqp')
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

p &lt;- sp1[1]
attr &lt;- 'prop' # clay contents
foo &lt;- get.increase.matrix(p, threshold.fun = crit.clay.argillic,
                           attr = attr, vertical.distance = 30)
foo


data(sp1, package = 'aqp')
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

p &lt;- sp1[1]
attr &lt;- 'prop' # clay contents
foo &lt;- get.increase.depths(p, threshold.fun = crit.clay.argillic,
                           attr = attr, vertical.distance = 30)
foo

</code></pre>

<hr>
<h2 id='get.ml.hz'>Determine ML Horizon Boundaries</h2><span id='topic+get.ml.hz'></span>

<h3>Description</h3>

<p>This function accepts input from <code><a href="#topic+slab">slab()</a></code> (a <code>data.frame</code>) along with a vector of
horizon names, and returns a <code>data.frame</code> of the most likely horizon
boundaries.
</p>
<p>This function expects that <code>x</code> is a <code>data.frame</code> generated by
<code><a href="#topic+slab">slab()</a></code>. If <code>x</code> was not generated by <code><a href="#topic+slab">slab()</a></code>, then <code>o.names</code> is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.ml.hz(x, o.names = attr(x, which = "original.levels"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.ml.hz_+3A_x">x</code></td>
<td>
<p><code>data.frame</code>, output from <code><a href="#topic+slab">slab()</a></code></p>
</td></tr>
<tr><td><code id="get.ml.hz_+3A_o.names">o.names</code></td>
<td>
<p>an optional character vector of horizon designations that will be used in the final table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following columns:
</p>

<ul>
<li> <p><code>hz</code>: horizon names
</p>
</li>
<li> <p><code>top</code>: horizon top depth
</p>
</li>
<li> <p><code>bottom</code>: horizon bottom depth
</p>
</li>
<li> <p><code>confidence</code>: integrated probability over thickness of each ML horizon, rounded to the nearest integer
</p>
</li>
<li> <p><code>pseudo.brier</code>: A &quot;pseudo&quot;&quot; Brier Score for a multi-class prediction, where the most-likely horizon label is treated as the &quot;correct&quot; outcome. Details on the calculation for traditional Brier Scores here: <a href="https://en.wikipedia.org/wiki/Brier_score">https://en.wikipedia.org/wiki/Brier_score</a>. Lower values suggest better agreement between ML horizon label and class-wise probabilities.
</p>
</li>
<li> <p><code>mean.H</code>: mean Shannon entropy (bits), derived from probabilities within each most-likely horizon. Larger values suggest more confusion within each ML.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Beaudette, D. E., Roudier, P., &amp; Skovlin, J. (2016). Probabilistic representation of genetic soil horizons. Digital soil morphometrics, 281-293.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slab">slab()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# init SPC
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# set horizon designation metadata
hzdesgnname(sp1) &lt;- 'name'

# generalize horizon designations from character vector
# result is an ordered factor
sp1$genhz &lt;- generalizeHz(
  sp1$name,
  new = c('O','A','B','C'),
  pat = c('O', '^A','^B','C'),
  ordered = TRUE
)

# compute slice-wise GHL probability
# so that it sums to contributing fraction
# from 0-150cm
a &lt;- slab(sp1, fm = ~ genhz, cpm = 1, slab.structure = 0:150)

# note original GHL names are set by slab()
attr(a, 'original.levels')

# generate table of ML horizonation
get.ml.hz(a)

</code></pre>

<hr>
<h2 id='getArgillicBounds'>Estimate upper and lower boundary of argillic diagnostic subsurface horizon</h2><span id='topic+getArgillicBounds'></span>

<h3>Description</h3>

<p><code>getArgillicBounds</code> estimates the upper and lower boundary of argillic diagnostic subsurface horizon for a profile in a single-profile SoilProfileCollection object (<code>p</code>).
</p>
<p>The upper boundary is where the clay increase threshold is met. The function uses <code>crit.clay.argillic</code> as the threshold function for determining whether a clay increase occurs and <code>get.increase.matrix</code> to determine whether the increase is met, whether vertical distance of increase is sufficiently small, and in which horizon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getArgillicBounds(
  p,
  hzdesgn = "hzname",
  clay.attr = "clay",
  texcl.attr = "texcl",
  require_t = TRUE,
  bottom.pattern = "Cr|R|Cd",
  lower.grad.pattern = "^[2-9]*B*CB*[^rtd]*[1-9]*$",
  sandy.texture.pattern = "-S$|^S$|COS$|L[^V]FS$|[^L]VFS$|LS$|LFS$",
  vertical.distance = 30,
  simplify = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getArgillicBounds_+3A_p">p</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_hzdesgn">hzdesgn</code></td>
<td>
<p>the name of the column/attribute containing the horizon designation; default=&quot;hzname&quot;</p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_clay.attr">clay.attr</code></td>
<td>
<p>the name of the column/attribute containing the clay content; default=&quot;clay&quot;</p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_texcl.attr">texcl.attr</code></td>
<td>
<p>the name of the column/attribute containing the textural class (used for finding sandy horizons); default=&quot;texcl&quot;</p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_require_t">require_t</code></td>
<td>
<p>require a &quot;t&quot; subscript for positive identification of upper and lower bound of argillic? default: TRUE</p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_bottom.pattern">bottom.pattern</code></td>
<td>
<p>regular expression passed to <code>estimateSoilDepth</code> to match the lower boundary of the soil. default is &quot;Cr|R|Cd&quot; which approximately matches paralithic, lithic and densic contacts.</p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_lower.grad.pattern">lower.grad.pattern</code></td>
<td>
<p>this is a pattern for adjusting the bottom depth of the argillic horizon upwards from the bottom depth of the soil. The absence of illuviation is used as a final control on horizon pattern matching.</p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_sandy.texture.pattern">sandy.texture.pattern</code></td>
<td>
<p>this is a pattern for matching sandy textural classes: <code style="white-space: pre;">&#8288;-S$|^S$|COS$|L[^V]FS$|[^L]VFS$|LS$|LFS$&#8288;</code></p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_vertical.distance">vertical.distance</code></td>
<td>
<p>Vertical distance in which clay increase must be met. Default <code>30</code> cm</p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_simplify">simplify</code></td>
<td>
<p>Return a length 2 vector with upper and lower boundary when <code>p</code> has length 1? Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getArgillicBounds_+3A_verbose">verbose</code></td>
<td>
<p>Print out information about 't' subscripts, sandy textures, plow layers and lower gradational horizons?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lower boundary is first approximated as the depth to a lithic/paralithic/densic contact, or some other horizon matchable by a custom regular expression pattern. Subsequently, that boundary is extended upwards to the end of &quot;evidence of illuviation.&quot;
</p>
<p>The depth to contact is estimated using 'bottom.pattern' &quot;Cr|R|Cd&quot; by default. It matches anything containing Cr, R or Cd.
</p>
<p>The lower gradational horizon regular expression ‘lower.grad.pattern' default is <code style="white-space: pre;">&#8288;^[2-9]*B*CB*[^rtd]*[1-9]*$}&#8288;</code>. It matches anything that starts with a lithologic discontinuity (or none) and a C master horizon designation. May contain B as second horizon designation in transitional horizon. May not contain 'r' or 't' subscript.
</p>
<p>The minimum thickness of the argillic horizon is dependent on whether all subhorizons are &quot;sandy&quot; or not. The <code>sandy.texture.pattern</code> default <code style="white-space: pre;">&#8288;-S$|^S$|COS$|L[^V]FS$|[^L]VFS$|LS$|LFS$&#8288;</code> captures USDA textural class fine earth fractions that meet &quot;sandy&quot; particle size class criteria.
</p>
<p>There also is an option ‘require_t' to omit the requirement for evidence of eluviation in form of 't' subscript in 'hzdesgn'. Even if &quot;t&quot; subscript is not required for positive identification, the presence of lower gradational C horizons lacking 't' will still be used to modify the lower boundary upward from a detected contact, if needed. If this behavior is not desired, just set 'lower.grad.pattern' to something that will not match any horizons in your data.
</p>


<h3>Value</h3>

<p>Returns a numeric vector; first value is top depth, second value is bottom depth. If as.list is TRUE, returns a list with top depth named &quot;ubound&quot; and bottom depth named &quot;lbound&quot;. If <code>p</code> has more than one profile or if <code>simplify = FALSE</code> the result is a data.frame containing profile ID, upper and lower boundary columns.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sp1, package = 'aqp')
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

p &lt;- sp1
attr &lt;- 'prop' # clay contents
foo &lt;- getArgillicBounds(p, hzdesgn='name', clay.attr = attr, texcl.attr="texture")
foo

</code></pre>

<hr>
<h2 id='getCambicBounds'>Find all intervals that are potentially part of a Cambic horizon</h2><span id='topic+getCambicBounds'></span>

<h3>Description</h3>

<p>Find all intervals that are potentially part of a Cambic horizon excluding those that are part of an argillic horizon (defined either by depth interval or <code>getArgillicBounds()</code>).
</p>
<p>There may be multiple cambic horizons (indexes) in a profile. Each cambic index has a top and bottom depth associated: cambic_top and cambic_bottom. This result is designed to be used for single profiles, or with <code>profileApply(..., frameify = TRUE)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCambicBounds(
  p,
  hzdesgn = guessHzDesgnName(p, required = TRUE),
  texcl.attr = guessHzTexClName(p, required = TRUE),
  clay.attr = guessHzAttrName(p, attr = "clay", c("total", "_r")),
  argi_bounds = NULL,
  d_value = "d_value",
  m_value = "m_value",
  m_chroma = "m_chroma",
  sandy.texture.pattern = "-S$|^S$|COS$|L[^V]FS$|[^L]VFS$|LS$|LFS$",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCambicBounds_+3A_p">p</code></td>
<td>
<p>A single-profile SoilProfileCollection</p>
</td></tr>
<tr><td><code id="getCambicBounds_+3A_hzdesgn">hzdesgn</code></td>
<td>
<p>Column name containing horizon designations.</p>
</td></tr>
<tr><td><code id="getCambicBounds_+3A_texcl.attr">texcl.attr</code></td>
<td>
<p>Arguments to <code>getArgillicBounds()</code></p>
</td></tr>
<tr><td><code id="getCambicBounds_+3A_clay.attr">clay.attr</code></td>
<td>
<p>Arguments to <code>getArgillicBounds()</code></p>
</td></tr>
<tr><td><code id="getCambicBounds_+3A_argi_bounds">argi_bounds</code></td>
<td>
<p>Optional: numeric vector of length 2 with top and bottom of argillic; (Default: NULL)</p>
</td></tr>
<tr><td><code id="getCambicBounds_+3A_d_value">d_value</code></td>
<td>
<p>Column name containing dry value. Default: d_value</p>
</td></tr>
<tr><td><code id="getCambicBounds_+3A_m_value">m_value</code></td>
<td>
<p>Column name containing moist value. Default: m_value</p>
</td></tr>
<tr><td><code id="getCambicBounds_+3A_m_chroma">m_chroma</code></td>
<td>
<p>Column name containing moist chroma Default: m_chroma</p>
</td></tr>
<tr><td><code id="getCambicBounds_+3A_sandy.texture.pattern">sandy.texture.pattern</code></td>
<td>
<p>this is a pattern for matching sandy textural classes: <code style="white-space: pre;">&#8288;-S$|^S$|COS$|L[^V]FS$|[^L]VFS$|LS$|LFS$&#8288;</code></p>
</td></tr>
<tr><td><code id="getCambicBounds_+3A_...">...</code></td>
<td>
<p>Arguments to <code>getArgillicBounds()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing profile, cambic indexes, along with top and bottom depths.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a fake profile
spc &lt;- data.frame(id=1, taxsubgrp = "Lithic Haploxerepts",
                  hzname   = c("A","AB","Bw","BC","R"),
                  hzdept   = c(0,  20, 32, 42,  49),
                  hzdepb   = c(20, 32, 42, 49, 200),
                  clay     = c(19, 22, 22, 21,  NA),
                  texcl    = c("l","l","l", "l","br"),
                  d_value  = c(5,   5,  5,  6,  NA),
                  m_value  = c(2.5, 3,  3,  4,  NA),
                  m_chroma = c(2,   3,  4,  4,  NA))

# promote to SoilProfileCollection
depths(spc) &lt;- id ~ hzdept + hzdepb
hzdesgnname(spc) &lt;- 'hzname'
hztexclname(spc) &lt;- 'texcl'

# print results in table
getCambicBounds(spc)

</code></pre>

<hr>
<h2 id='getClosestMunsellChip'>Get Approximate Munsell Chip</h2><span id='topic+getClosestMunsellChip'></span>

<h3>Description</h3>

<p>Non-standard Munsell notation ('7.9YR 2.7/2.0') can be matched (nearest-neighbor, no interpolation) to the closest color within the <code>munsell</code> sRGB/CIELAB look-up table via <code>getClosestMunsellChip()</code>. A more accurate estimate of sRGB values from non-standard notation can be achieved with the <a href="https://CRAN.R-project.org/package=munsellinterpol">munsellinterpol</a> package. For example, conversion from Munsell to CIELAB, assuming a D65 illuminant via: <code>MunsellToLab('0.1Y 3.3/4.4', white='D65', adapt='Bradford')</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClosestMunsellChip(munsellColor, convertColors = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClosestMunsellChip_+3A_munsellcolor">munsellColor</code></td>
<td>
<p>character vector of strings containing Munsell notation of color, e.g. '10YR 4/3'</p>
</td></tr>
<tr><td><code id="getClosestMunsellChip_+3A_convertcolors">convertColors</code></td>
<td>
<p>logical, should parsed Munsell colors be converted into sRGB values</p>
</td></tr>
<tr><td><code id="getClosestMunsellChip_+3A_...">...</code></td>
<td>
<p>further arguments to <code>munsell2rgb</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> when <code>convertColors=TRUE</code>, otherwise character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# convert a non-standard color to closest "chip" in `munsell` look-up table
getClosestMunsellChip('7.9YR 2.7/2.0', convertColors = FALSE)

# convert directly to R color
getClosestMunsellChip('7.9YR 2.7/2.0')

# special case for 2.5 value -&gt; no rounding, we have these records in the conversion LUT
getClosestMunsellChip('7.5YR 2.5/2', convertColors = FALSE)


getClosestMunsellChip('7.5YR 6.8/4.4', convertColors = FALSE)

</code></pre>

<hr>
<h2 id='getLastHorizonID'>Get IDs of Deepest Horizons by Profile</h2><span id='topic+getLastHorizonID'></span>

<h3>Description</h3>

<p>Return horizon IDs of the deepest horizon within each profile of a <code>SoilProfileCollection</code>. IDs are returned in the same order as <code>profile_id(x)</code>. Horizon top depths are used because there are cases where bottom depths may be missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLastHorizonID(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLastHorizonID_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code></p>
</td></tr>
</table>

<hr>
<h2 id='getSoilDepthClass'>Generate Soil Depth Class Matrix</h2><span id='topic+getSoilDepthClass'></span>

<h3>Description</h3>

<p>Generate a boolean matrix of soil depth classes, actual soil depth class, and estimate of soil depth from a <code>SoilProfileCollection</code> object. Soil depths are estimated using pattern matching applied to horizon designations, by <code><a href="#topic+estimateSoilDepth">estimateSoilDepth()</a></code>. The default REGEX pattern (<code>p = 'Cr|R|Cd'</code>) will match most &quot;contacts&quot; described using the USDA / Soil Taxonomy horizon designation conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSoilDepthClass(
  f,
  depth.classes = c(very.shallow = 25, shallow = 50, mod.deep = 100, deep = 150,
    very.deep = 10000),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSoilDepthClass_+3A_f">f</code></td>
<td>
<p>a SoilProfileCollection object</p>
</td></tr>
<tr><td><code id="getSoilDepthClass_+3A_depth.classes">depth.classes</code></td>
<td>
<p>a named vector of classes and depth breaks</p>
</td></tr>
<tr><td><code id="getSoilDepthClass_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+estimateSoilDepth">estimateSoilDepth</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> containing soil depth and depth class for each
profile, see examples
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and J.M. Skovlin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateSoilDepth">estimateSoilDepth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# generate depth-class matrix
sdc &lt;- getSoilDepthClass(sp1, name = 'name')

# inspect
head(sdc)

# join back into sp1 as site-level data
site(sp1) &lt;- sdc

## Not run: 
# sample data
data(gopheridge, package='soilDB')

getSoilDepthClass(gopheridge, name = 'hzname')

## End(Not run)

</code></pre>

<hr>
<h2 id='getSurfaceHorizonDepth'>Determine thickness of horizons (continuous from surface) matching a pattern</h2><span id='topic+getSurfaceHorizonDepth'></span><span id='topic+getMineralSoilSurfaceDepth'></span><span id='topic+getPlowLayerDepth'></span>

<h3>Description</h3>

<p>Find the thickness of horizon designations, or any other character patterns, that are continuous from the soil surface (depth = 0 or shallowest depth in profile).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSurfaceHorizonDepth(
  p,
  pattern,
  hzdesgn = guessHzDesgnName(p),
  simplify = TRUE
)

getMineralSoilSurfaceDepth(
  p,
  hzdesgn = guessHzDesgnName(p),
  pattern = "O",
  simplify = TRUE
)

getPlowLayerDepth(
  p,
  hzdesgn = guessHzDesgnName(p),
  pattern = "^Ap[^b]*",
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSurfaceHorizonDepth_+3A_p">p</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="getSurfaceHorizonDepth_+3A_pattern">pattern</code></td>
<td>
<p>a regular expression pattern to match for all horizons to be considered part of the &quot;surface&quot;.</p>
</td></tr>
<tr><td><code id="getSurfaceHorizonDepth_+3A_hzdesgn">hzdesgn</code></td>
<td>
<p>column name containing horizon designation. Default: <code>guessHzDesgnName(p, required = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="getSurfaceHorizonDepth_+3A_simplify">simplify</code></td>
<td>
<p>logical. Return single profile results as vector (default: <code>TRUE</code>) or <code>data.frame</code> (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The horizon designation to match is specified with the regular expression pattern 'pattern'. All horizons matching that pattern, that are continuous from the soil surface, count towards the depth / thickness value that is ultimately returned. For instance: horizon designations: A1-A2-A3-C-Ab , would return A3 bottom depth given <code>pattern = "^A[1-9]*$"</code>.
</p>
<p><code>getSurfaceHorizonDepth</code> is used by <code>getPlowLayerDepth</code> for matching Ap horizons; and, it is used by <code>getMineralSoilSurfaceDepth</code> to find the thickness of O horizons in lieu of lab data.
</p>


<h3>Value</h3>

<p>a numeric value corresponding to the bottom depth of the last horizon matching 'pattern' that is contiguous with other matching horizons up to the soil surface. If <code>length(p) &gt; 1</code> then a <em>data.frame</em> containing profile ID, horizon ID, top or bottom depths, horizon designation and pattern.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(aqp)
data(sp1, package = 'aqp')
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

p &lt;- sp1[1]
q &lt;- sp1[2]

# look at horizon designations in p and q
p$name
q$name

# thickness of all surface horizons containing A
getSurfaceHorizonDepth(p, pattern = 'A', hzdesgn = 'name')

# thickness of all surface horizons that start with A
getSurfaceHorizonDepth(p, pattern = '^A', hzdesgn = 'name')

# thickness of all surface horizons that start with A, and the A is not followed by B
getSurfaceHorizonDepth(p, pattern = '^A[^B]*', hzdesgn = 'name')

# thickness of all surface horizons that start with A
#  followed by a number from _2_ to 9 (returns ZERO)
getSurfaceHorizonDepth(p, pattern = '^A[2-9]*', hzdesgn = 'name')

# getPlowLayerDepth matches first two horizons in fake Ap horizon data with "buried Ap"
p$aphorizons &lt;- c("Ap1","Ap2","AB", rep('C', nrow(p) - 4), "Apb")
getPlowLayerDepth(p, hzdesgn = 'aphorizons')

# getMineralSoilSurfaceDepthmatches first 3 horizons in fake O horizon data
p$ohorizons &lt;- c("Oi1","Oi2","Oe", rep('C', nrow(p) - 4), "2C")
getMineralSoilSurfaceDepth(p, hzdesgn='ohorizons')

# matches first Oi horizon with original horizon designations of pedon 2
getMineralSoilSurfaceDepth(q, hzdesgn='name')

</code></pre>

<hr>
<h2 id='GHL'>Get or Set Generalized Horizon Label (GHL) Column Name</h2><span id='topic+GHL'></span><span id='topic+GHL+2CSoilProfileCollection-method'></span><span id='topic+GHL+3C-'></span><span id='topic+GHL+3C-+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>GHL()</code>: Get column name containing generalized horizon labels
</p>
<p><code style="white-space: pre;">&#8288;GHL&lt;-&#8288;</code>: Set generalized horizon label column name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
GHL(object, required = FALSE)

## S4 replacement method for signature 'SoilProfileCollection'
GHL(object, required = FALSE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GHL_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="GHL_+3A_required">required</code></td>
<td>
<p>logical, is this attribute required? If it is, set to <code>TRUE</code> to trigger error on invalid <code>value</code>.</p>
</td></tr>
<tr><td><code id="GHL_+3A_value">value</code></td>
<td>
<p>character, name of column containing generalized horizon labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Store the column name containing generalized horizon labels in the metadata slot of the SoilProfileCollection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)

# promote to SPC
depths(sp1) &lt;- id ~ top + bottom

# set horizon designation column
GHL(sp1) &lt;- "name"

# get horizon designation column
GHL(sp1)
</code></pre>

<hr>
<h2 id='glom+2CSoilProfileCollection-method'>Subset soil horizon data using a depth or depth interval</h2><span id='topic+glom+2CSoilProfileCollection-method'></span><span id='topic+glom'></span><span id='topic+trunc+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Make a &quot;clod&quot; of horizons from a SoilProfileCollection given a point or a depth interval to intersect. The interval <code style="white-space: pre;">&#8288;[z1,z2]&#8288;</code> may be profile-specific (equal in length to <code>p</code>), or may be recycled over all profiles (if boundaries are length 1). For &quot;point&quot; intersection, <code>z2</code> may be left as the default value <code>NULL</code>.
</p>
<p><code>trunc()</code> is a wrapper method (using S4 generic) for <code>glom()</code> where <code>truncate=TRUE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
glom(
  p,
  z1,
  z2 = NULL,
  ids = FALSE,
  df = FALSE,
  truncate = FALSE,
  invert = FALSE,
  fill = FALSE,
  modality = "all",
  drop = !fill,
  ...
)

## S4 method for signature 'SoilProfileCollection'
trunc(x, z1, z2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_p">p</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_z1">z1</code></td>
<td>
<p>numeric vector of top depth to intersect horizon (required). Can be an expression involving <code>siteNames(p)</code> or quoted column name. Should evaluate to numeric length <code>1</code> or length equal to <code>length(p)</code></p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_z2">z2</code></td>
<td>
<p>numeric vector bottom depth of intersection interval (optional). Can also be an expression involving <code>siteNames(p)</code> or quoted column name. Should evaluate to numeric length <code>1</code>, length equal to <code>length(p)</code> or <code>NULL</code>. Default: <code>NULL</code> is &quot;point&quot; intersection</p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_ids">ids</code></td>
<td>
<p>return only horizon IDs? default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_df">df</code></td>
<td>
<p>return a data.frame, by intersection with <code>horizons(p)</code>? default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_truncate">truncate</code></td>
<td>
<p>truncate horizon top and bottom depths to <code>z1</code> and <code>z2</code>? default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_invert">invert</code></td>
<td>
<p>get horizons <em>outside</em> the interval <code style="white-space: pre;">&#8288;[z1,z2]&#8288;</code>? default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_fill">fill</code></td>
<td>
<p>keep sites and preserve order for profiles that do not have horizons in interval by filling with a single horizon with <code>NA</code> top and bottom depth. default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_modality">modality</code></td>
<td>
<p>default: <code>"all"</code> return all horizons; or <code>modality = "thickest"</code>) to return the <em>thickest</em> horizon in interval. If multiple horizons have equal thickness, the first (shallowest) is returned.</p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_drop">drop</code></td>
<td>
<p>Inverted alias of fill for consistency with other methods. When <code>drop=FALSE</code>, filling occurs.</p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p><code>trunc()</code>: additional arguments passed to <code>glom()</code></p>
</td></tr>
<tr><td><code id="glom+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;To glom&quot; is &quot;to steal&quot; or to &quot;become stuck or attached to&quot;. The word is related to the compound &quot;glomalin&quot;, which is a glycoprotein produced by mycorrhizal fungi in soil.
</p>
<p>The full depth range of horizons included within the interval are returned (a &quot;ragged&quot; SoilProfileCollection) unless the <code>truncate</code> argument is set as <code>TRUE</code>. Horizon intersection is based on unique ID <code>hzidname(spc)</code> and depth range of interest. Profiles that lack data in the range of interest will be dropped from the resulting SoilProfileCollection.
</p>
<p>If inverting results with <code>invert</code>, it is possible that thick horizons (whose boundaries span wider than the specified interval) will be split into <em>two</em> horizons, where previously they were one. This may make the results from <code>ids = TRUE</code> different from what you expect, as they will be based on a profile with an &quot;extra&quot; horizon and re-calculated unique horizon ID (<code>hzidname(spc)</code>) <code>"hzID"</code>.
</p>


<h3>Value</h3>

<p>a SoilProfileCollection, data.frame, or a vector of horizon IDs. <code>NULL</code> if no result.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glomApply">glomApply</a></code> <code><a href="base.html#topic+trunc">trunc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

data(sp1, package = 'aqp')
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

p &lt;- glom(sp1, 25, 150)

# 28 horizons
nrow(p) 

# inspect graphically
par(mar = c(1,1,3,1))
plot(p, color = "prop", max.depth = 200)
abline(h = c(25, 100), lty = 2)

## glom(..., truncate = TRUE)

p2 &lt;- glom(sp1, 25, 150, truncate = TRUE)

# 28 horizons
nrow(p2) 

# inspect graphically
par(mar = c(1,1,3,1))
plot(p2, color = "prop", max.depth = 200)
abline(h = c(25, 100), lty = 2)

## glom(..., truncate = TRUE, invert = TRUE)

p3 &lt;- glom(sp1, 25, 150, truncate = TRUE, invert = TRUE)

# 45 horizons
nrow(p3) 

# inspect graphically
par(mar = c(1,1,3,1))
plot(p3, color = "prop", max.depth = 200)
abline(h = c(25, 100), lty = 2)

## profile-specific interval, using expressions evaluated within sp1@site

# calculate some new site-level variables containing target interval
sp1$glom_top &lt;- (1:9) * 10
sp1$glom_bottom &lt;- 10 + sp1$glom_top

# glom evaluates non-standard expressions using siteNames(sp1) column names
p4 &lt;- glom(sp1, glom_top / 2, glom_bottom * 1.2, truncate = TRUE)

# inspect graphically
par(mar = c(1,1,3,1))
plot(p4, color = "prop", max.depth = 200)


# load sample data
data("sp3")

# promote to SPC
depths(sp3) &lt;- id ~ top + bottom

### TRUNCATE all profiles in sp3 to [0,25]

# set up plot parameters
par(mfrow=c(2,1), mar=c(0,0,0,0))

# full profiles
plot(sp3)

# trunc'd profiles
plot(trunc(sp3, 0, 25))
</code></pre>

<hr>
<h2 id='glomApply'>Subset an SPC by applying glom to each profile</h2><span id='topic+glomApply'></span><span id='topic+glomApply+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>glomApply()</code> is a function used for subsetting SoilProfileCollection objects by depth. It is a wrapper around <code>glom</code> which is intended to subset single-profile SPCs based on depth intervals/intersection.
</p>
<p><code>glomApply</code> works by accepting a function <code>.fun</code> as argument. This function is used on each profile to process a multi-profile SPC for input to <code>glom</code> (via <code>profileApply</code>). For each profile, <code>.fun</code> returns a 2-length numeric vector of top and bottom boundaries <code>glom</code> arguments: <code>z1</code>, <code>z2</code>.
</p>
<p><code>glomApply</code> provides the option to generate profile-specific glom depths for a large SPC and handles iteration and rebuilding of a subset SPC object. Optional arguments include: <code>truncate</code> to cut the boundaries to specified <code>[z1, z2]</code>; <code>invert</code> to the portion outside <code>[z1, z2]</code>, <code>modality</code> to either <code>"all"</code> horizons or <code>"thickest"</code> horizon in the <code>glom</code> interval. <code>...</code> are various expressions you can run on the individual profiles using NSE, similar to <code>mutate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glomApply(
  object,
  .fun = NULL,
  truncate = FALSE,
  invert = FALSE,
  modality = "all",
  ...,
  chunk.size = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glomApply_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="glomApply_+3A_.fun">.fun</code></td>
<td>
<p>A function that returns vector with top and bottom depth (<code>z1</code> and <code>z2</code> arguments to <code>glom</code>) for a single profile <code>p</code> (as passed by <code>profileApply</code>)</p>
</td></tr>
<tr><td><code id="glomApply_+3A_truncate">truncate</code></td>
<td>
<p>Truncate horizon top and bottom depths to <code>[z1, z2]</code></p>
</td></tr>
<tr><td><code id="glomApply_+3A_invert">invert</code></td>
<td>
<p>Truncate horizon top and bottom depths to <code>[z1, z2]</code> and then invert result?</p>
</td></tr>
<tr><td><code id="glomApply_+3A_modality">modality</code></td>
<td>
<p>Aggregation method for glom result. Default <code>"all"</code>: return all horizons; <code>"thickest"</code>: return (shallowest) thickest horizon</p>
</td></tr>
<tr><td><code id="glomApply_+3A_...">...</code></td>
<td>
<p>A set of comma-delimited R expressions that resolve to a transformation to be applied to a single profile e.g <code>glomApply(hzdept = max(hzdept) - hzdept)</code> like <code>aqp::mutate</code></p>
</td></tr>
<tr><td><code id="glomApply_+3A_chunk.size">chunk.size</code></td>
<td>
<p>Chunk size parameter for <code>profileApply</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SoilProfileCollection.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glom">glom</a></code>  <code><a href="base.html#topic+trunc">trunc</a></code>
</p>
<p><code><a href="#topic+glom">glom</a></code>  <code><a href="#topic+glomApply">glomApply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

data(sp3)
depths(sp3) &lt;- id ~ top + bottom

# init horizon designation column in metadata, used by estimateSoilDepth
hzdesgnname(sp3) &lt;- 'name'

# constant depths, whole horizon returns by default
plot(glomApply(sp3, function(p) c(25,100)))

# constant depths, truncated
#(see aqp::trunc for helper function)
plot(glomApply(sp3, function(p) c(25,30), truncate = TRUE))

# constant depths, inverted
plot(glomApply(sp3, function(p) c(25,100), invert = TRUE))

# constant depths, inverted + truncated (same as above)
plot(glomApply(sp3, function(p) c(25,30), invert = TRUE, truncate=TRUE))

# random boundaries in each profile
plot(glomApply(sp3, function(p) round(sort(runif(2, 0, max(sp3))))))

# random boundaries in each profile (truncated)
plot(glomApply(sp3, function(p) round(sort(runif(2, 0, max(sp3)))), truncate = TRUE))

# calculate some boundaries as site level attribtes
sp3$glom_top &lt;- profileApply(sp3, getMineralSoilSurfaceDepth)
sp3$glom_bottom &lt;- profileApply(sp3, estimateSoilDepth)

# use site level attributes for glom intervals for each profile
plot(glomApply(sp3, function(p) return(c(p$glom_top, p$glom_bottom))))

</code></pre>

<hr>
<h2 id='grepSPC'>Subset SPC with pattern-matching for text-based attributes</h2><span id='topic+grepSPC'></span><span id='topic+grepSPC+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>grepSPC()</code> is a shorthand function for subsetting SoilProfileCollections. For example, by <code>filter(grepl(spc, ...))</code> or <code>filter(stringr::str_detect(spc, ...))</code>. It provides pattern matching for a single text-based site or horizon level attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grepSPC(object, attr, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grepSPC_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="grepSPC_+3A_attr">attr</code></td>
<td>
<p>A character vector (column in object) for matching patterns against.</p>
</td></tr>
<tr><td><code id="grepSPC_+3A_pattern">pattern</code></td>
<td>
<p>REGEX pattern to match in <code>attr</code></p>
</td></tr>
<tr><td><code id="grepSPC_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code>grep()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SoilProfileCollection.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown.
</p>

<hr>
<h2 id='groupedProfilePlot'>Grouped Soil Profile Plot</h2><span id='topic+groupedProfilePlot'></span>

<h3>Description</h3>

<p>Plot a collection of soil profiles, sorted by group.
</p>
<p>The left-right ordering of groups can be adjusted by converting
<code>groups</code> into a factor and explicitly setting factor levels.
Alpha-numeric ordering is used for all other types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupedProfilePlot(
  x,
  groups,
  group.name.offset = -5,
  group.name.cex = 0.75,
  group.line.col = "RoyalBlue",
  group.line.lwd = 2,
  group.line.lty = 2,
  break.style = c("line", "arrow", "both"),
  break.offset = 0.5,
  arrow.offset = group.name.offset + 5,
  arrow.length = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupedProfilePlot_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_groups">groups</code></td>
<td>
<p>the name of a site-level attribute that defines groups, factor
levels will influence plotting order</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_group.name.offset">group.name.offset</code></td>
<td>
<p>vertical offset for group names, single numeric
value or vector of offsets</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_group.name.cex">group.name.cex</code></td>
<td>
<p>font size for group names</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_group.line.col">group.line.col</code></td>
<td>
<p>color for line that splits groups</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_group.line.lwd">group.line.lwd</code></td>
<td>
<p>width of line that splits groups</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_group.line.lty">group.line.lty</code></td>
<td>
<p>style of line that splits groups</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_break.style">break.style</code></td>
<td>
<p>style of group boundaries: &quot;line&quot;, &quot;arrow&quot;, &quot;both&quot;</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_break.offset">break.offset</code></td>
<td>
<p>horizontal offset used to place vertical breaks and/or arrows, shifted slightly to the right of default when <code>hz.depths=TRUE</code> is passed to <code>plotSPC()</code></p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_arrow.offset">arrow.offset</code></td>
<td>
<p>vertical offset for &quot;arrow&quot; style boundaries, single
numeric value or vector of offsets</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_arrow.length">arrow.length</code></td>
<td>
<p>value passed to <code>arrows</code> to define arrow head size</p>
</td></tr>
<tr><td><code id="groupedProfilePlot_+3A_...">...</code></td>
<td>
<p>further arguments to <code>plotSPC</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSPC">plotSPC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# sample data
data(sp1)
# convert colors from Munsell to hex-encoded RGB
sp1$soil_color &lt;- with(sp1, munsell2rgb(hue, value, chroma))

# promote to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

# add a groups
sp1$group.2 &lt;- sprintf("%s-%s", rev(LETTERS[1:3]), sp1$group)

# convert fake groupt to factor with new levels
sp1$group.3 &lt;- factor(sp1$group.2, levels=c('C-2', 'B-2', 'A-2', 'C-1', 'B-1', 'A-1'))

# plot profiles, sorted and annotated by 'group' (integers)
par(mar=c(1,1,1,1))
groupedProfilePlot(sp1, groups='group', max.depth=150, group.name.offset = -5, id.style='side')

# plot profiles, sorted and annotated by 'group.2' (characters)
par(mar=c(1,1,1,1))
groupedProfilePlot(sp1, groups='group.2', max.depth=150, group.name.offset = -5, id.style='side')

# plot profiles, sorted and annotated by 'group.3' (characters)
par(mar=c(1,1,1,1))
groupedProfilePlot(sp1, groups='group.3', max.depth=150, group.name.offset = -5, id.style='side')


# make fake site-level attribute and adjust levels
sp1$new.group &lt;- sample(letters[1:3], size=length(sp1), replace=TRUE)

# tabulate pedons / group
tab &lt;- table(sp1$new.group)

# sort large -&gt; small
tab &lt;- sort(tab, decreasing = TRUE)

# set levels based on sorted tabulation
# assign custom labels
sp1$new.group &lt;- factor(sp1$new.group, levels=names(tab),
labels=paste0(names(tab), ' (', tab, ')'))

groupedProfilePlot(sp1, groups='new.group', max.depth=150,
group.name.offset = -10, id.style='side')

# offsets can be set using a vector of values, recycled as needed
groupedProfilePlot(sp1, groups='new.group', max.depth=150,
group.name.offset=c(-10, -5), id.style='side')

# annotate with arrows instead of vertical lines
groupedProfilePlot(sp1, groups='new.group', max.depth=150,
group.name.offset=c(-10, -12), break.style='arrow', arrow.offset=-3,
group.line.lty = 1, group.line.lwd = 1, id.style='side')


## Not run: 
# more complete example using data from soilDB package
data(loafercreek, package='soilDB')
par(mar=c(1,1,1,1))
# lines
groupedProfilePlot(loafercreek, groups='hillslopeprof', group.name.cex = 0.5,
group.name.offset = -10)

# arrows
groupedProfilePlot(loafercreek, groups='hillslopeprof', group.name.cex = 0.5,
group.name.offset = -10, break.style ='arrow', group.line.lty = 1,
group.line.lwd = 1)

# both
groupedProfilePlot(loafercreek, groups='hillslopeprof', group.name.cex = 0.5,
group.name.offset = -10, break.style ='both', group.line.lty = 1,
group.line.lwd = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='groupSPC'>Store groupings within a profile collection.</h2><span id='topic+groupSPC'></span>

<h3>Description</h3>

<p>Store groupings within a profile collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupSPC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupSPC_+3A_object">object</code></td>
<td>
<p>SoilProfileCollection.</p>
</td></tr>
<tr><td><code id="groupSPC_+3A_...">...</code></td>
<td>
<p>One or more expressions evaluated within the context of <code>object</code> that resolve to vectors that can be coerced to factor &quot;groups.&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='guessGenHzLevels'>Guess Appropriate Ordering for Generalized Horizon Labels</h2><span id='topic+guessGenHzLevels'></span>

<h3>Description</h3>

<p>This function makes an (educated) guess at an appropriate set of levels for
generalized horizon labels using the median of horizon depth mid-points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guessGenHzLevels(x, hz = GHL(x, required = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guessGenHzLevels_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="guessGenHzLevels_+3A_hz">hz</code></td>
<td>
<p>name of horizon-level attribute containing generalized horizon
labels, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful when groups of horizons have been generalized via
some method other than <code>generalize.hz</code>. For example, it may be useful
to generalize horizons using labels derived from slice depths. The default
sorting of these labels will not follow a logical depth-wise sorting when
converted to a factor. <code>guessGenHzLevels</code> does a good job of &quot;guessing&quot;
the proper ordering of these labels based on median horizon depth mid-point.
</p>


<h3>Value</h3>

<p>a list: </p>
<table>
<tr><td><code>levels</code></td>
<td>
<p>a vector of levels sorted by median horizon
depth mid-point</p>
</td></tr> <tr><td><code>median.depths</code></td>
<td>
<p>a vector of median horizon mid-points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generalize.hz">generalize.hz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load some example data
data(sp1, package='aqp')

# upgrade to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom

# generalize horizon names
n &lt;- c('O', 'A', 'B', 'C')
p &lt;- c('O', 'A', 'B', 'C')
sp1$genhz &lt;- generalize.hz(sp1$name, n, p)

# note: levels are in the order in which originally defined:
levels(sp1$genhz)

# generalize horizons by depth slice
s &lt;- dice(sp1, c(5, 10, 15, 25, 50, 100, 150) ~ .)
s$slice &lt;- paste0(s$top, ' cm')
# not a factor
levels(s$slice)

# the proper ordering of these new labels can be guessed from horizon depths
guessGenHzLevels(s, 'slice')

# convert to factor, and set proper order
s$slice &lt;- factor(s$slice, levels=guessGenHzLevels(s, 'slice')$levels)

# that is better
levels(s$slice)

</code></pre>

<hr>
<h2 id='guessHzAttrName'>Guess Horizon Slot Column Names</h2><span id='topic+guessHzAttrName'></span><span id='topic+guessHzDesgnName'></span><span id='topic+guessHzTexClName'></span>

<h3>Description</h3>

<p><code>guessHzAttrName()</code>: Guess the horizon column name where possible/preferred formative elements are known. There is a preference for records where more optional requirements are met to handle cases where there will be many matches. For example, working with soil data one might have &quot;low, RV and high&quot; total clay, as well as clay fractions. One could distinguish between these different measurements using standard formative elements for column names from the database of interest. Result is the first match in <code>horizonNames(x)</code> with the most required plus optional patterns matched.
</p>
<p>e.g. <code>guessHzAttrName(x, attr="clay", optional=c("total", "_r"))</code> matches (<code>claytotal_r == totalclay_r</code>) over (<code>clay_r == claytotal == totalclay</code>) over <code>clay</code>.
</p>
<p><code>guessHzDesgnName()</code>: This follows the historic convention used by <code>aqp::plotSPC()</code> looking for &quot;hzname&quot; or other column names containing the regular expression &quot;name&quot;. If the pattern &quot;name&quot; is not found, the pattern &quot;desgn&quot; is searched as a fallback, as &quot;hzdesgn&quot; or &quot;hz_desgn&quot; are other common column naming schemes for horizon designation name.
</p>
<p><code>guessHzTexClName()</code>: This function is used to provide a texture class attribute column name to functions. It will use regular expressions to match &quot;texcl&quot; which is typically the texture of the fine earth fraction, without modifiers or in-lieu textures. Alternately, it will match &quot;texture&quot; for cases where &quot;texcl&quot; is absent (e.g. in NASIS Component Horizon).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guessHzAttrName(x, attr, optional = NULL, verbose = TRUE, required = FALSE)

guessHzDesgnName(x, required = FALSE)

guessHzTexClName(x, required = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guessHzAttrName_+3A_x">x</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="guessHzAttrName_+3A_attr">attr</code></td>
<td>
<p>A regular expression containing required formative element of attribute name.</p>
</td></tr>
<tr><td><code id="guessHzAttrName_+3A_optional">optional</code></td>
<td>
<p>A character vector of regular expression(s) containing optional formative elements of attribute name.</p>
</td></tr>
<tr><td><code id="guessHzAttrName_+3A_verbose">verbose</code></td>
<td>
<p>A boolean value for whether to produce message output about guesses.</p>
</td></tr>
<tr><td><code id="guessHzAttrName_+3A_required">required</code></td>
<td>
<p>logical Default: <code>FALSE</code>. Is this attribute required? If it is, set to <code>TRUE</code> to trigger error on invalid value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character containing horizon attribute column name. Result is the first match in <code>horizonNames(x)</code> with the most required plus optional patterns matched.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a has the required attr pattern, but none of the optional
a &lt;- data.frame(id = 1, top = c(0,10), bottom=c(10,40),
                clay=c(18,19))
depths(a) &lt;- id ~ top + bottom

guessHzAttrName(a, attr="clay", optional=c("total", "_r"))

# b has requried attr pattern, and one of the opional patterns
#   notice that it also contains "clay" but preferentially matches more optional patterns
b &lt;- data.frame(id = 1, top = c(0,10), bottom=c(10,40),
                clay=c(0.18,0.19), clay_r=c(18,19))
depths(b) &lt;- id ~ top + bottom

guessHzAttrName(b, attr="clay", optional=c("total", "_r"))

# c has total and _r (both optional) on either side of clay
# having all of the optional patterns plus required is best evidence, and first
# column containing that combination will be returned
c &lt;- data.frame(id = 1, top = c(0,10), bottom=c(10,40),
                totalclay_r=c(18,19), claytotal_r=c(0.18,0.19))
depths(c) &lt;- id ~ top + bottom

guessHzAttrName(c, attr="clay", optional=c("total", "_r"))


a &lt;- data.frame(id = 1, top = c(0,10), bottom=c(10,40), horizonname=c("A","Bw"))
depths(a) &lt;- id ~ top + bottom

# store guess in metadata
hzdesgnname(a) &lt;- guessHzDesgnName(a)

# inspect result
hzdesgnname(a)


a &lt;- data.frame(id = 1, top = c(0,10), bottom=c(10,40), texture=c("A","Bw"))
depths(a) &lt;- id ~ top + bottom

# store guess in metadata
hztexclname(a) &lt;- guessHzTexClName(a)

# inspect result
hztexclname(a)

</code></pre>

<hr>
<h2 id='harden.melanization'>Harden (1982) Melanization</h2><span id='topic+harden.melanization'></span>

<h3>Description</h3>

<p>Calculate &quot;melanization&quot; component of &quot;Profile Development Index&quot; after Harden (1982) &quot;A quantitative index of soil development from field descriptions: Examples from a chronosequence in central California&quot;. Accepts vectorized inputs for value and reference value to produce vector output. A convenient use case would be to apply this on a profile-specific basis, where the <code>value_ref</code> has a single value, and <code>value</code> is a vector of length equal to the number of horizons within the upper 100 cm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harden.melanization(value, value_ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harden.melanization_+3A_value">value</code></td>
<td>
<p>numeric vector containing Munsell values</p>
</td></tr>
<tr><td><code id="harden.melanization_+3A_value_ref">value_ref</code></td>
<td>
<p>A numeric vector containing Munsell value(s) for reference material</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Harden (1982), &quot;melanization&quot; is calculated relative to a reference parent material for all horizons within 100cm of the soil surface. In addition, several other non-color components are normalized relative to a maximum value and summed to obtain the overall Profile Development Index.
</p>


<h3>Value</h3>

<p>A numeric vector reflecting horizon darkening relative to a reference (e.g. parent) material.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>References</h3>

<p>Harden, J.W. (1982) A quantitative index of soil development from field descriptions: Examples from a chronosequence in central California. Geoderma. 28(1) 1-28. doi:  10.1016/0016-7061(82)90037-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

library(aqp)
data("jacobs2000", package="aqp")

# LEFT JOIN hue, value, chroma matrix color columns
horizons(jacobs2000) &lt;- cbind(horizons(jacobs2000)[,c(idname(jacobs2000), hzidname(jacobs2000))],
                              parseMunsell(jacobs2000$matrix_color_munsell, convertColors = FALSE))

# calculate a mixed 150-200cm color ~"parent material"

jacobs2000$c_horizon_color &lt;- profileApply(jacobs2000, function(p) {

  # and derive the parent material from the 150-200cm interval
  p150_200 &lt;- glom(p, 150, 200, truncate = TRUE)
  p150_200$thickness &lt;- p150_200$bottom - p150_200$top

  # mix colors
  clrs &lt;- na.omit(horizons(p150_200)[,c('matrix_color_munsell','thickness')])
  mixMunsell(clrs$matrix_color_munsell, w = clrs$thickness)$munsell

})

# segment profile into 1cm slices (for proper depth weighting)
jacobs2000$melan &lt;- profileApply(jacobs2000, function(p) {

  # sum the melanization index over the 0-100cm interval
  p0_100 &lt;- segment(p, 0:100)

  ccol &lt;- parseMunsell(p$c_horizon_color, convertColors = FALSE)

  sum(harden.melanization(
    value = as.numeric(p0_100$value),
    value_ref = as.numeric(ccol$value)), na.rm = TRUE)

})

jacobs2000$melanorder &lt;- order(jacobs2000$melan)

# Plot in order of increasing Melanization index

plotSPC(jacobs2000, 
        color = "matrix_color",
        label = "melan",
        plot.order = jacobs2000$melanorder,
        max.depth = 250
        )

segments(
  x0 = 0.5, 
  x1 = length(jacobs2000) + 0.5, 
  y0 = c(0,100,150,200), 
  y1 = c(0,100,150,200), 
  lty = 2
)

# Add [estimated] parent material color swatches
lapply(seq_along(jacobs2000$c_horizon_color), function(i) {
  rect(i - 0.15, 250, i + 0.15, 225,
       col = parseMunsell(jacobs2000$c_horizon_color[jacobs2000$melanorder[i]]))
})
</code></pre>

<hr>
<h2 id='harden.rubification'>Harden (1982) Rubification</h2><span id='topic+harden.rubification'></span>

<h3>Description</h3>

<p>Calculate &quot;rubification&quot; component of &quot;Profile Development Index&quot; after Harden (1982) &quot;A quantitative index of soil development from field descriptions: Examples from a chronosequence in central California&quot;. Accepts vectorized inputs for hue and chroma to produce vector output.
</p>
<p>In Harden (1982) &quot;rubification&quot; is calculated relative to a reference parent material. Several other non-color components are normalized relative to a maximum value and summed to obtain the overall Profile Development Index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harden.rubification(hue, chroma, hue_ref, chroma_ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harden.rubification_+3A_hue">hue</code></td>
<td>
<p>A character vector containing Munsell hues (e.g. &quot;7.5YR&quot;)</p>
</td></tr>
<tr><td><code id="harden.rubification_+3A_chroma">chroma</code></td>
<td>
<p>A numeric vector containing Munsell chromas</p>
</td></tr>
<tr><td><code id="harden.rubification_+3A_hue_ref">hue_ref</code></td>
<td>
<p>A character vector containing Munsell hue(s) (e.g. &quot;10YR&quot;) for reference material</p>
</td></tr>
<tr><td><code id="harden.rubification_+3A_chroma_ref">chroma_ref</code></td>
<td>
<p>A numeric vector containing Munsell chroma(s) for reference material</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector reflecting horizon redness increase relative to a reference (e.g. parent) material.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>References</h3>

<p>Harden, J.W. (1982) A quantitative index of soil development from field descriptions: Examples from a chronosequence in central California. Geoderma. 28(1) 1-28. doi:  10.1016/0016-7061(82)90037-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

library(aqp)
data("jacobs2000", package="aqp")

# LEFT JOIN hue, value, chroma matrix color columns
horizons(jacobs2000) &lt;- cbind(horizons(jacobs2000)[,c(idname(jacobs2000), hzidname(jacobs2000))],
                              parseMunsell(jacobs2000$matrix_color_munsell, convertColors = FALSE))

#' # calculate a mixed 150-200cm color ~"parent material"
jacobs2000$c_horizon_color &lt;- profileApply(jacobs2000, function(p) {

  # and derive the parent material from the 150-200cm interval
  p150_200 &lt;- glom(p, 150, 200, truncate = TRUE)
  p150_200$thickness &lt;- p150_200$bottom - p150_200$top
  
  # subset colors and thickness
  clrs &lt;- na.omit(horizons(p150_200)[,c('matrix_color_munsell','thickness')])
  
  # simulate a subtractive mixture using thickness as weight
  mixMunsell(
  clrs$matrix_color_munsell, 
  w = clrs$thickness, 
  mixingMethod = 'exact')$munsell
})

# segment profile into 1cm slices (for proper depth weighting)
jacobs2000$rubif &lt;- profileApply(jacobs2000, function(p) {

  # sum the melanization index over the 0-100cm interval
  p0_100 &lt;- segment(p, 0:100)

  ccol &lt;- parseMunsell(p$c_horizon_color, convertColors = FALSE)

  sum(harden.rubification(
    hue = p0_100$hue,
    chroma = as.numeric(p0_100$chroma),
    hue_ref = ccol$hue,
    chroma_ref = as.numeric(ccol$chroma)
  ), na.rm = TRUE)

})

jacobs2000$rubiforder &lt;- order(jacobs2000$rubif)

# Plot in order of increasing Rubification index

plotSPC(jacobs2000,
color = "matrix_color",
label = "rubif",
plot.order = jacobs2000$rubiforder,
max.depth = 250
)

segments(
  x0 = 0.5, 
  x1 = length(jacobs2000) + 0.5, 
  y0 = c(0,100,150,200), 
  y1 = c(0,100,150,200), 
  lty = 2
)

# Add [estimated] parent material color swatches
trash &lt;- sapply(seq_along(jacobs2000$c_horizon_color), function(i) {
  rect(i - 0.15, 250, i + 0.15, 225,
       col = parseMunsell(jacobs2000$c_horizon_color[jacobs2000$rubiforder[i]]))
})
</code></pre>

<hr>
<h2 id='harmonize+2CSoilProfileCollection-method'>Harmonize a property by profile-level denormalization for convenient visualization or analysis of ranges</h2><span id='topic+harmonize+2CSoilProfileCollection-method'></span><span id='topic+harmonize'></span>

<h3>Description</h3>

<p>It is sometimes convenient to be able to &quot;denormalize&quot; to a <code>SoilProfileCollection</code> with fewer attributes but more profiles. This is helpful wherever calculations are made on a profile basis and ranges or repeated measures are depicted with multiple attributes per soil horizon.
</p>
<p><code>harmonize</code> is most commonly used for creating &quot;comparison&quot; soil profile sketches with <code>plotSPC</code>&ndash;where the thematic attribute is derived from multiple data sources or summary statistics (such as quantiles of a property for Low-RV-High). However, the method more generally applies wherever one wants to alias between multiple columns containing &quot;similar&quot; data as input to an algorithm.
</p>
<p>Data are &quot;harmonized&quot; to a common attribute names specified by the names of list elements in <code>x.names</code>. Profiles are essentially duplicated. In order to satisfy uniqueness constraints of the <code>SoilProfileCollection</code>, the label from the sub-elements of <code>x.names</code> are used to disambiguate profiles. A new column in the site table is calculated to reflect these groupings and facilitate filtering. See examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
harmonize(x, x.names, keep.cols = NULL, grp.name = "hgroup")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonize+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>A <code>SoilProfileCollection</code>.</p>
</td></tr>
<tr><td><code id="harmonize+2B2CSoilProfileCollection-method_+3A_x.names">x.names</code></td>
<td>
<p>a named list of character vectors specifying target names, profile ID suffixes and source attribute names for harmonization</p>
</td></tr>
<tr><td><code id="harmonize+2B2CSoilProfileCollection-method_+3A_keep.cols">keep.cols</code></td>
<td>
<p>a character vector of column names to keep unaltered from the horizon data</p>
</td></tr>
<tr><td><code id="harmonize+2B2CSoilProfileCollection-method_+3A_grp.name">grp.name</code></td>
<td>
<p>a character vector with column name to store grouping variable in site table (default: &quot;hgroup&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If attributes reflecting the same or similar property within a soil layer have different names (e.g. <code>socQ05</code>, <code>socQ50</code>, <code>socQ95</code>) it is sometimes inconvenient to work with them as multiple attributes within the same profile. These similar attributes may need to be analyzed together, or in sequence by profile, displayed using the same name or using a common scale. It is also useful to be able to alias different data sources that have the same attributes with different names.
</p>
<p>Each list element in <code>x.names</code> specifies a single &quot;harmonization,&quot; which is comprised of one or more mappings from new to old. Each named &quot;sub-element&quot; of <code>x.names</code> specifies the name and attribute to use for updating the profile ID and site table of  the duplicated profiles.
</p>


<h3>Value</h3>

<p>A (redundant) <code>SoilProfileCollection</code>, with one profile for each set of harmonizations specified by <code>x.names</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### single source "harmonization" of single-profile with range -&gt; single attribute, multi-profile

# make some test data
spc &lt;- pbindlist(lapply(1:10, random_profile, SPC = TRUE))

# assume that p1, p2 and p3 are the low RV and high quantiles for a hypothetical property "foo"
h1 &lt;- harmonize(spc, x.names = list(foo = c(q05 = "p1", q50 = "p2", q95 = "p3")))

# inspect result
plot(h1, color = "foo")

# filter with calculated "harmonized group" to get just RV profiles
plot(subset(h1, hgroup == "q50"), color="foo")

### single source, two properties at once; with common labels: "method1" "method2"

# assume that p1, p2 are measurements by two (!=) methods for a hypothetical property "foo"
#             p3, p4 are measurements by same two methods for a hypothetical property "bar"
h3 &lt;- harmonize(spc, x.names = list(foo = c(method1 = "p1", method2 = "p2"),
                                    bar = c(method1 = "p3", method2 = "p4")))
plot(h3, color = "foo")
plot(h3, color = "bar")
head(horizons(h3))

# a slight modification, "method 1" onlyused for "foo" and "method 3" for "bar"
h3 &lt;- harmonize(spc, x.names = list(foo = c(method1 = "p1", method2 = "p2"),
                                    bar = c(method2 = "p3", method3 = "p4")))
plot(h3, color = "foo") # note the pattern of values missing for foo (*_method3)
plot(h3, color = "bar") #  likewise for bar (*_method1)

#' the new labels need not match across harmonizations -- not sure how useful this is but it works
h3 &lt;- harmonize(spc, x.names = list(foo = c(method1 = "p1", method2 = "p2"),
                                    bar = c(method3 = "p3", method4 = "p4")))
plot(h3, color = "foo") # note the pattern of values missing for foo (*_method 3 + 4)
plot(h3, color = "bar") #  likewise for bar (*_method 1 + 2)

### two-source harmonization

# make test data
spc1 &lt;- pbindlist(lapply(LETTERS[1:5], random_profile, SPC = TRUE))
spc2 &lt;- pbindlist(lapply(letters[1:5], random_profile, SPC = TRUE))

h4 &lt;- pbindlist(list(harmonize(spc1, list(foo = c(transect1 = "p4"))),   # foo is p4 in dataset 1
                      harmonize(spc2, list(foo = c(transect2 = "p2")))))  # foo is p2 in dataset 2

# same property with different name in two different datasets
plot(h4, color = "foo")

### many source harmonization

# make test datasets (n=10); highly redundant IDs (1:3 repeated)
spcs &lt;- lapply(1:10, function(x) pbindlist(lapply(1:3, random_profile, SPC = TRUE)))

# randomly varying column name for demo (in each dataset, foo could could be p1 thru p5)
rcolname &lt;- paste0("p", round(runif(10, 0.5, 5.5)))

# iterate over data sources
bigspc &lt;- pbindlist(lapply(1:length(spcs), function(i) {

  # assume each data source has a unique name for the property "foo"
  xn &lt;- rcolname[i]

  # set names attribute to be equal to index i [creating unique profile IDs]
  #   i.e. 2_10 will be profile ID 2 from 10th dataset
  names(xn) &lt;- i

  # harmonize each data source, using unique column name and target name "foo"
  harmonize(spcs[[i]], x.names = list(foo = xn))
}))

# inspect a subset
plot(bigspc[1:30,], color = "foo")

</code></pre>

<hr>
<h2 id='hasDarkColors'>Find horizons with colors darker than a Munsell hue, value, chroma threshold</h2><span id='topic+hasDarkColors'></span>

<h3>Description</h3>

<p><code>hasDarkColors</code> returns a boolean value by horizon representing whether darkness thresholds are met. The code is fully vectorized and deals with missing data and optional thresholds.
</p>
<p>Default arguments are set up for &quot;5-3-3 colors&quot; &ndash; the basic criteria for Mollic/Umbric epipedon/mineral soil darkness. Any of the thresholds or column names can be altered. Any thresholds that are set equal to <code>NA</code> will be ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasDarkColors(
  p,
  d_hue = NA,
  m_hue = NA,
  d_value = 5,
  d_chroma = NA,
  m_value = 3,
  m_chroma = 3,
  dhuenm = "d_hue",
  dvalnm = "d_value",
  dchrnm = "d_chroma",
  mhuenm = "m_hue",
  mvalnm = "m_value",
  mchrnm = "m_chroma"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasDarkColors_+3A_p">p</code></td>
<td>
<p>A SoilProfileCollection.</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_d_hue">d_hue</code></td>
<td>
<p>Optional: character vector of dry hues to match (default: NA)</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_m_hue">m_hue</code></td>
<td>
<p>Optional: character vector of moist hues to match (default: NA)</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_d_value">d_value</code></td>
<td>
<p>Maximum value of dry value (default: 5)</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_d_chroma">d_chroma</code></td>
<td>
<p>Optional: Maximum value of dry chroma (default: NA)</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_m_value">m_value</code></td>
<td>
<p>Maximum value of moist value (default: 3)</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_m_chroma">m_chroma</code></td>
<td>
<p>Maximum value of moist chroma (default: 3)</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_dhuenm">dhuenm</code></td>
<td>
<p>Column name containing dry hue.</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_dvalnm">dvalnm</code></td>
<td>
<p>Column name containing dry value.</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_dchrnm">dchrnm</code></td>
<td>
<p>Column name containing dry chroma.</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_mhuenm">mhuenm</code></td>
<td>
<p>Column name containing moist hue.</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_mvalnm">mvalnm</code></td>
<td>
<p>Column name containing moist value.</p>
</td></tr>
<tr><td><code id="hasDarkColors_+3A_mchrnm">mchrnm</code></td>
<td>
<p>Column name containing moist chroma.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean value (for each horizon in <code>p</code>) reflecting whether &quot;darkness&quot; criteria are met.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a fake profile
spc &lt;- data.frame(id=1, taxsubgrp = "Lithic Haploxeralfs",
                  hzdesgn  = c("A","AB","Bt","BCt","R"),
                  hzdept   = c(0, 20, 32, 42,  49),
                  hzdepb   = c(20, 32, 42, 49, 200),
                  d_value  = c(5,   5,  5,  6,  NA),
                  m_value  = c(2.5, 3,  3,  4,  NA),
                  m_chroma = c(2,   3,  4,  4,  NA))

# promote to SoilProfileCollection
depths(spc) &lt;- id ~ hzdept + hzdepb

# print results in table
data.frame(id = spc[[idname(spc)]],
           hz_desgn = spc$hzdesgn,
           has_dark_colors = hasDarkColors(spc))

</code></pre>

<hr>
<h2 id='horizonColorIndices'>Horizon Color Indices</h2><span id='topic+horizonColorIndices'></span>

<h3>Description</h3>

<p>Calculate basic horizon-level color indices for a SoilProfileCollection. Basic indices do not require aggregation over the whole profile or comparison to a &quot;reference&quot; (e.g. parent material) color. Includes Hurst (1977) Redness Index, Barron-Torrent Redness Index (1986) and Buntley-Westin Index (1965). This is a wrapper method around several horizon-level indices. See the individual functions for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horizonColorIndices(p, hue = "m_hue", value = "m_value", chroma = "m_chroma")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horizonColorIndices_+3A_p">p</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="horizonColorIndices_+3A_hue">hue</code></td>
<td>
<p>Column name containing moist hue; default: &quot;m_hue&quot;</p>
</td></tr>
<tr><td><code id="horizonColorIndices_+3A_value">value</code></td>
<td>
<p>Column name containing moist value; default: &quot;m_value&quot;</p>
</td></tr>
<tr><td><code id="horizonColorIndices_+3A_chroma">chroma</code></td>
<td>
<p>Column name containing moist chroma; default: &quot;m_chroma&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing unique pedon and horizon IDs and horizon-level color indices.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hurst.redness">hurst.redness</a></code> <code><a href="#topic+barron.torrent.redness.LAB">barron.torrent.redness.LAB</a></code> <code><a href="#topic+buntley.westin.index">buntley.westin.index</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

data(sp1)

# promote sp1 data to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom

# move site data
site(sp1) &lt;- ~ group

# compute indices
# merged into `sp1` with left-join on hzidname(sp1)
horizons(sp1) &lt;- horizonColorIndices(sp1, hue="hue", value="value", chroma="chroma")

# visualize
par(mar=c(0, 1, 3, 1))
plot(sp1, color='hurst_redness')
plot(sp1, color='barron_torrent_redness')
plot(sp1, color='buntley_westin')
</code></pre>

<hr>
<h2 id='horizonDepths+26lt+3B-'>Set horizon depth column names</h2><span id='topic+horizonDepths+3C-'></span><span id='topic+horizonDepths+3C-+2CSoilProfileCollection-method'></span><span id='topic+horizonDepths+2CSoilProfileCollection-method'></span><span id='topic+horizonDepths'></span>

<h3>Description</h3>

<p>Set column name containing horizon ID
</p>
<p>Get column names containing horizon depths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
horizonDepths(object) &lt;- value

## S4 method for signature 'SoilProfileCollection'
horizonDepths(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horizonDepths+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="horizonDepths+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a character vector of length two with names of columns containing numeric top and bottom depths</p>
</td></tr>
</table>

<hr>
<h2 id='horizonNames+26lt+3B-'>Set horizon column names</h2><span id='topic+horizonNames+3C-'></span><span id='topic+horizonNames+3C-+2CSoilProfileCollection-method'></span><span id='topic+horizonNames+2CSoilProfileCollection-method'></span><span id='topic+horizonNames'></span>

<h3>Description</h3>

<p>Set horizon column names
</p>
<p>Get names of columns in horizon table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
horizonNames(object) &lt;- value

## S4 method for signature 'SoilProfileCollection'
horizonNames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horizonNames+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="horizonNames+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a unique vector of equal length to number of columns in horizons <code>length(horizonNames(object))</code></p>
</td></tr>
</table>

<hr>
<h2 id='horizons+2CSoilProfileCollection-method'>Retrieve horizon data from SoilProfileCollection</h2><span id='topic+horizons+2CSoilProfileCollection-method'></span><span id='topic+horizons'></span><span id='topic+horizons+3C-'></span><span id='topic+horizons+3C-+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Get horizon data from SoilProfileCollection. Result is returned in the same <code>data.frame</code> class used to initially construct the SoilProfileCollection.
</p>
<p>Horizon data in an object inheriting from <code>data.frame</code> can easily be added via merge (LEFT JOIN). There must be one or more same-named columns (with at least some matching data) on the left and right hand side to facilitate the join: <code>horizons(spc) &lt;- newdata</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
horizons(object)

## S4 replacement method for signature 'SoilProfileCollection'
horizons(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horizons+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="horizons+2B2CSoilProfileCollection-method_+3A_value">value</code></td>
<td>
<p>An object inheriting <code>data.frame</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# load test data
data(sp2)

# promote to SPC
depths(sp2) &lt;- id ~ top + bottom

# assign true to surface horizon
newdata &lt;- data.frame(top = 0,
                      newvalue = TRUE)

# do left join
horizons(sp2) &lt;- newdata

# inspect site table: newvalue TRUE only for horizons
#  with top depth equal to zero
horizons(sp2)

</code></pre>

<hr>
<h2 id='huePosition'>Munsell Hue Reference and Position Searching</h2><span id='topic+huePosition'></span>

<h3>Description</h3>

<p>The 40 Munsell hues are typically arranged from 5R to 2.5R moving clock wise on the unit circle. This function matches a vector of hues to positions on that circle, with options for setting a custom origin or search direction.
</p>
<p>This function is fully vectorized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huePosition(
  x,
  returnHues = FALSE,
  includeNeutral = FALSE,
  origin = "5R",
  direction = c("cw", "ccw")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huePosition_+3A_x">x</code></td>
<td>
<p>character vector of hues, e.g. c('10YR', '5YR'), optional if <code>returnHues = TRUE</code></p>
</td></tr>
<tr><td><code id="huePosition_+3A_returnhues">returnHues</code></td>
<td>
<p>logical, should the full set of Munsell hues be returned? See details.</p>
</td></tr>
<tr><td><code id="huePosition_+3A_includeneutral">includeNeutral</code></td>
<td>
<p>logical, add 'N' to the end of the full set of Munsell hues</p>
</td></tr>
<tr><td><code id="huePosition_+3A_origin">origin</code></td>
<td>
<p>hue to be used as the starting point for position searches (position 1)</p>
</td></tr>
<tr><td><code id="huePosition_+3A_direction">direction</code></td>
<td>
<p>indexing direction, should be <code>cw</code> (clock wise) or <code>ccw</code> (counter-clock wise)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integer hue positions is returned, of the same
length and order as <code>x</code>. If <code>returnHues = TRUE</code>, then all hue
names and ordering are returned and <code>x</code> is ignored.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>


<ul>
<li><p> Soil Survey Technical Note 2 <a href="https://web.archive.org/web/20220704214918/https://www.nrcs.usda.gov/wps/portal/nrcs/detail/soils/ref/?cid=nrcs142p2_053569">wayback machine URL</a>
</p>
</li>
<li><p> Munsell book of color. 1976. Macbeth, a Division of Kollmorgen Corp., Baltimore, MD.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+colorContrast">colorContrast</a>, <a href="#topic+huePositionCircle">huePositionCircle</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get hue ordering for setting levels of a factor
huePosition(returnHues = TRUE)

# get hue ordering including N (neutral)
huePosition(returnHues = TRUE, includeNeutral = TRUE)

# get position of the '10YR' hue, relative to standard origin of '5R'
# should be 7
huePosition(x = '10YR')

# get position of the '10YR' hue, relative to standard origin of '5YR'
# should be 3
huePosition(x = '10YR', origin = '5YR')

# visualize
op &lt;- par(mar = c(0, 0, 0, 0), fg = 'white', bg = 'black')

huePositionCircle(huePosition(returnHues = TRUE, origin = '5YR'))

par(op)

</code></pre>

<hr>
<h2 id='huePositionCircle'>Visual Description of Munsell Hue Ordering</h2><span id='topic+huePositionCircle'></span>

<h3>Description</h3>

<p>Munsell hues are arranged on the unit circle with &quot;neutral&quot; at the center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huePositionCircle(
  hues = huePosition(returnHues = TRUE),
  value = 6,
  chroma = 10,
  chip.cex = 5.5,
  label.cex = 0.66,
  seg.adj = 0.8,
  seg.col = "grey",
  plot = TRUE,
  simulateCVD = NULL,
  CVDseverity = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huePositionCircle_+3A_hues">hues</code></td>
<td>
<p>vector of Munsell hues, commonly derived from <code>huePosition()</code></p>
</td></tr>
<tr><td><code id="huePositionCircle_+3A_value">value</code></td>
<td>
<p>single integer, Munsell value used to create an actual color</p>
</td></tr>
<tr><td><code id="huePositionCircle_+3A_chroma">chroma</code></td>
<td>
<p>single integer, Munsell chroma used to create an actual color</p>
</td></tr>
<tr><td><code id="huePositionCircle_+3A_chip.cex">chip.cex</code></td>
<td>
<p>numeric, scaling for color chips</p>
</td></tr>
<tr><td><code id="huePositionCircle_+3A_label.cex">label.cex</code></td>
<td>
<p>numeric, scaling labels</p>
</td></tr>
<tr><td><code id="huePositionCircle_+3A_seg.adj">seg.adj</code></td>
<td>
<p>numeric, scaling for line segment cues</p>
</td></tr>
<tr><td><code id="huePositionCircle_+3A_seg.col">seg.col</code></td>
<td>
<p>single color, color used for line segment cues</p>
</td></tr>
<tr><td><code id="huePositionCircle_+3A_plot">plot</code></td>
<td>
<p>logical, generate output on the current graphics device</p>
</td></tr>
<tr><td><code id="huePositionCircle_+3A_simulatecvd">simulateCVD</code></td>
<td>
<p>simulate color vision deficiencies with the colorspace package, should be the character representation of a function name, one of: 'deutan', 'protan', or 'tritan'.</p>
</td></tr>
<tr><td><code id="huePositionCircle_+3A_cvdseverity">CVDseverity</code></td>
<td>
<p>numeric value between 0 (none) and 1 (total), describing the severity of the color vision deficiency</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an invisible <code>data.frame</code> of data used to create the figure
</p>


<h3>Note</h3>

<p>The best results are obtained when setting margins to zero, and inverting foreground / background colors. For example: <code>par(mar = c(0, 0, 0, 0), fg = 'white', bg = 'black')</code>.
</p>


<h3>References</h3>

<p>Munsell book of color. 1976. Macbeth, a Division of Kollmorgen Corp., Baltimore, MD.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))


# better graphics defaults
op &lt;- par(mar = c(0, 0, 0, 0), fg = 'white', bg = 'black')

# full set of hues, as generated by huePosition(returnHues = TRUE)
huePositionCircle()

# subset
huePositionCircle(hues = c('5R', '5Y', '5G', '5B', '5P'))

# reset graphics state
par(op)

</code></pre>

<hr>
<h2 id='hurst.redness'>Hurst (1977) Redness Index</h2><span id='topic+hurst.redness'></span>

<h3>Description</h3>

<p>Calculate Redness Index after Hurst (1977) &quot;Visual estimation of iron in saprolite&quot; DOI: 10.1130/0016-7606(1977)88&lt;174:VEOIIS&gt;2.0.CO;2. Accepts vectorized inputs for hue, value and chroma, produces vector output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hurst.redness(hue, value, chroma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hurst.redness_+3A_hue">hue</code></td>
<td>
<p>A character vector containing Munsell hues (e.g. &quot;7.5YR&quot;)</p>
</td></tr>
<tr><td><code id="hurst.redness_+3A_value">value</code></td>
<td>
<p>A numeric vector containing Munsell values</p>
</td></tr>
<tr><td><code id="hurst.redness_+3A_chroma">chroma</code></td>
<td>
<p>A numeric vector containing Munsell chromas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of horizon redness index (lower values = redder).
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>References</h3>

<p>Hurst, V.J. (1977) Visual estimation of iron in saprolite. GSA Bulletin. 88(2): 174–176. doi: https://doi.org/10.1130/0016-7606(1977)88&lt;174:VEOIIS&gt;2.0.CO;2
</p>

<hr>
<h2 id='hzAbove'>Horizons Above or Below</h2><span id='topic+hzAbove'></span><span id='topic+hzBelow'></span><span id='topic+hzOffset'></span>

<h3>Description</h3>

<p>Horizons Above or Below
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hzAbove(x, ..., offset = 1, SPC = TRUE, simplify = SPC)

hzBelow(x, ..., offset = 1, SPC = TRUE, simplify = SPC)

hzOffset(x, hzid, offset, SPC = FALSE, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzAbove_+3A_x">x</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="hzAbove_+3A_...">...</code></td>
<td>
<p>Comma-separated set of R expressions that evaluate as <code>TRUE</code> or <code>FALSE</code> in context of horizon data frame. Length for individual expressions matches number of horizons, in <code>x</code>.</p>
</td></tr>
<tr><td><code id="hzAbove_+3A_offset">offset</code></td>
<td>
<p>Integer offset in terms of SoilProfileCollection <code style="white-space: pre;">&#8288;[,j]&#8288;</code> (horizon/slice) index</p>
</td></tr>
<tr><td><code id="hzAbove_+3A_spc">SPC</code></td>
<td>
<p>Return a SoilProfileCollection? Default <code>TRUE</code> for <code style="white-space: pre;">&#8288;horizon_*&#8288;</code> methods.</p>
</td></tr>
<tr><td><code id="hzAbove_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code> return a vector (all elements combined), or a list (1 element per profile). If <code>SPC</code> is <code>TRUE</code> then <code>simplify</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hzAbove_+3A_hzid">hzid</code></td>
<td>
<p>A vector of target horizon IDs. These are calculated from <code>...</code> for <code style="white-space: pre;">&#8288;horizon_*()&#8288;</code> methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To minimize likelihood of issues with non-standard evaluation context, especially when using <code>hzAbove()</code>/<code>hzBelow()</code> inside another function, all expressions used in <code>...</code> should be in terms of variables that are in the horizon data frame.
</p>


<h3>Value</h3>

<p>A SoilProfileCollection (when <code>SPC = TRUE</code>) or a vector of horizon row indices (when <code>SPC = FALSE</code> and <code>simplify = TRUE</code>) or a list (when <code>SPC = FALSE</code> and <code>simplify = FALSE</code>))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sp4)
depths(sp4) &lt;- id ~ top + bottom

# get the horizon above the last horizon (j-index of bottom horizon minus 1)
hzAbove(sp4, hzID(sp4) %in% getLastHorizonID(sp4))

# get horizons below the last horizon (none; j-index of bottom horizon plus 1)
hzBelow(sp4, hzID(sp4) %in% getLastHorizonID(sp4))

</code></pre>

<hr>
<h2 id='HzDepthLogicSubset'>Subset <code>SoilProfileCollection</code> Objects or Horizons via <code>checkHzDepthLogic</code></h2><span id='topic+HzDepthLogicSubset'></span>

<h3>Description</h3>

<p>This function removes profiles or horizons from a <code>SoilProfileCollection</code> that are flagged as having invalid horizon depth logic by <code><a href="#topic+checkHzDepthLogic">checkHzDepthLogic</a></code>. Invalid profiles may be created when setting <code>byhz = TRUE</code>; use caution as some functions may not work properly in the presence of gaps. Consider using <code><a href="#topic+fillHzGaps">fillHzGaps</a></code> to fill these gaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HzDepthLogicSubset(x, byhz = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HzDepthLogicSubset_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="HzDepthLogicSubset_+3A_byhz">byhz</code></td>
<td>
<p>logical, evaluate horizon depth logic at the horizon level (profile level if <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>SoilProfileCollection</code> object
</p>


<h3>Note</h3>

<p>This function cannot identify (and remove) overlapping horizons when <code>byhz = TRUE</code>.
</p>

<hr>
<h2 id='hzDepthTests'>Tests of horizon depth logic</h2><span id='topic+hzDepthTests'></span>

<h3>Description</h3>

<p>Function used internally by <code>checkHzDepthLogic()</code>, <code>glom()</code> and various other functions that operate on horizon data from single soil profiles and require a priori depth logic checks. Checks for bottom depths less than top depth / bad top depth order (&quot;depthLogic&quot;), bottom depths equal to top depth (&quot;sameDepth&quot;), overlaps/gaps (&quot;overlapOrGap&quot;) and missing depths (&quot;missingDepth&quot;). Use <code>names(res)[res]</code> on result <code>res</code> of <code>hzDepthTest()</code> to to determine type of logic error(s) found &ndash; see examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hzDepthTests(top, bottom = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzDepthTests_+3A_top">top</code></td>
<td>
<p>A numeric vector containing horizon top depths. Or a <code>data.frame</code> with two columns (first containing top depths, second containing bottom)</p>
</td></tr>
<tr><td><code id="hzDepthTests_+3A_bottom">bottom</code></td>
<td>
<p>A numeric vector containing horizon bottom depths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named logical vector containing TRUE for each type of horizon logic error found in the given data.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown &amp; Dylan E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# no logic errors
res &lt;- hzDepthTests(top = c(0,10,20,30), bottom = c(10,20,30,50))
names(res)[res]

# bottom &lt; top
hzDepthTests(top = c(10,20,30,50), bottom = c(0,10,20,30))
names(res)[res]

# bottom == top
hzDepthTests(top = c(10,20,30,50), bottom = c(0,20,20,30))
names(res)[res]

# overlap
hzDepthTests(top = c(0,5,20,30), bottom = c(10,20,30,50))
names(res)[res]

# gap
hzDepthTests(top = c(0,15,20,30), bottom = c(10,20,30,50))
names(res)[res]

# missing
hzDepthTests(c(0,15,NA,30),c(10,NA,30,50))
names(res)[res]

</code></pre>

<hr>
<h2 id='hzDesgn+2CSoilProfileCollection-method'>Get horizon designation column name</h2><span id='topic+hzDesgn+2CSoilProfileCollection-method'></span><span id='topic+hzDesgn'></span>

<h3>Description</h3>

<p>Get horizon designation names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
hzDesgn(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzDesgn+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>

<hr>
<h2 id='hzdesgnname'>Get or Set Horizon Designation Column Name</h2><span id='topic+hzdesgnname'></span><span id='topic+hzdesgnname+2CSoilProfileCollection-method'></span><span id='topic+hzdesgnname+3C-'></span><span id='topic+hzdesgnname+3C-+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>hzdesgnname()</code>: Get column name containing horizon designations
</p>
<p><code style="white-space: pre;">&#8288;hzdesgnname&lt;-&#8288;</code>: Set horizon designation column name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
hzdesgnname(object, required = FALSE)

## S4 replacement method for signature 'SoilProfileCollection'
hzdesgnname(object, required = FALSE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzdesgnname_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="hzdesgnname_+3A_required">required</code></td>
<td>
<p>logical, is this attribute required? If it is, set to <code>TRUE</code> to trigger error on invalid <code>value</code>.</p>
</td></tr>
<tr><td><code id="hzdesgnname_+3A_value">value</code></td>
<td>
<p>character, name of column containing horizon designations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Store the column name containing horizon designations or other identifiers in the metadata slot of the SoilProfileCollection.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hzDesgn">hzDesgn()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)

# promote to SPC
depths(sp1) &lt;- id ~ top + bottom

# set horizon designation column
hzdesgnname(sp1) &lt;- "name"

# get horizon designation column
hzdesgnname(sp1)
</code></pre>

<hr>
<h2 id='hzDistinctnessCodeToOffset'>Convert Horizon Boundary Distinctness to Vertical Offset</h2><span id='topic+hzDistinctnessCodeToOffset'></span>

<h3>Description</h3>

<p>This function will convert USDA-NCSS horizon boundary distinctness codes into vertical (+/-) offsets in cm, based on the <a href="https://nrcspad.sc.egov.usda.gov/DistributionCenter/product.aspx?ProductID=991">Field Book for Describing and Sampling Soils, version 3.0</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hzDistinctnessCodeToOffset(
  x,
  codes = c("very abrupt", "abrupt", "clear", "gradual", "diffuse"),
  offset = c(0.5, 2, 5, 15, 20)/2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzDistinctnessCodeToOffset_+3A_x">x</code></td>
<td>
<p>vector of boundary distinctness codes to be converted</p>
</td></tr>
<tr><td><code id="hzDistinctnessCodeToOffset_+3A_codes">codes</code></td>
<td>
<p>character vector of distinctness terms ('clear') or codes ('C'), case insensitive, see details</p>
</td></tr>
<tr><td><code id="hzDistinctnessCodeToOffset_+3A_offset">offset</code></td>
<td>
<p>vertical offset factors (cm), approximating 1/2 of the transitional zone thickness, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default offsets are based on the high-end of ranges presented in &quot;transitional zone thickness criteria&quot; from the Field Book version 3.0 (page 2-6). Offsets are returned as 1/2 of the transitional zone thickness so that horizon boundaries can be adjusted up/down from horizon depths. See <code><a href="#topic+plotSPC">plotSPC</a></code>, specifically the <code>hz.distinctness.offset</code> argument for visualization ideas. Missing data in <code>x</code> (NA) or codes that are not defined in <code>codes</code> are returned as 0 offsets.
</p>
<p>Either format (or mixture) are accepted, case insensitive:
</p>

<ul>
<li><p> terms: <code>c('very abrupt', 'abrupt', 'clear', 'gradual', 'diffuse')</code>
</p>
</li>
<li><p> coded values: <code style="white-space: pre;">&#8288;c('v', 'a', 'c', 'g', d')&#8288;</code>
</p>
</li></ul>

<p>Additional examples are available in the <a href="https://ncss-tech.github.io/AQP/aqp/hz-boundaries.html">Visualization of Horizon Boundaries tutorial</a>.
</p>


<h3>Value</h3>

<p>vector of offsets with same length as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p><a href="https://nrcspad.sc.egov.usda.gov/DistributionCenter/product.aspx?ProductID=991">Field Book for Describing and Sampling Soils, version 3.0</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSPC">plotSPC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
data(sp1)

# compute 1/2 transitional zone thickness from distinctness codes
sp1$hzdo &lt;- hzDistinctnessCodeToOffset(sp1$bound_distinct)

# convert colors from Munsell to hex-encoded RGB
sp1$soil_color &lt;- with(sp1, munsell2rgb(hue, value, chroma))

# promote to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom
hzdesgnname(sp1) &lt;- 'name'

# adjust margins
op &lt;- par(mar=c(0,0,0,1.5))

# sketches, adjust width, adjust text size, include coded hz distinctness offsets
plotSPC(sp1, width=0.3, cex.names=0.75, hz.distinctness.offset = 'hzdo')

# clean-up
par(op)
</code></pre>

<hr>
<h2 id='hzID+26lt+3B-+2CSoilProfileCollection-method'>Set horizon IDs</h2><span id='topic+hzID+3C-+2CSoilProfileCollection-method'></span><span id='topic+hzID+3C-'></span><span id='topic+hzID+2CSoilProfileCollection-method'></span><span id='topic+hzID'></span>

<h3>Description</h3>

<p>Set vector containing horizon IDs
</p>
<p>Get vector containing horizon IDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
hzID(object) &lt;- value

## S4 method for signature 'SoilProfileCollection'
hzID(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzID+2B26lt+2B3B-+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="hzID+2B26lt+2B3B-+2B2CSoilProfileCollection-method_+3A_value">value</code></td>
<td>
<p>a unique vector of equal length to number of horizons <code>nrow(object)</code></p>
</td></tr>
</table>

<hr>
<h2 id='hzidname+26lt+3B-'>Set horizon ID column name</h2><span id='topic+hzidname+3C-'></span><span id='topic+hzidname+3C-+2CSoilProfileCollection-method'></span><span id='topic+hzidname+2CSoilProfileCollection-method'></span><span id='topic+hzidname'></span>

<h3>Description</h3>

<p>Set unique horizon ID column name
</p>
<p>Get column name containing unique horizon ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
hzidname(object) &lt;- value

## S4 method for signature 'SoilProfileCollection'
hzidname(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzidname+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="hzidname+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>character, column name containing unique horizon ID values</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sp1)

# promote to SPC
depths(sp1) &lt;- id ~ top + bottom

# create new horizon ID
sp1$hzIDrev &lt;- rev(sp1$hzID)

# set horizon designation column
hzidname(sp1) &lt;- "hzIDrev"

# get horizon designation column
hzidname(sp1)

</code></pre>

<hr>
<h2 id='hzMetadata+2CSoilProfileCollection-method'>Get horizon-level metadata</h2><span id='topic+hzMetadata+2CSoilProfileCollection-method'></span><span id='topic+hzMetadata'></span>

<h3>Description</h3>

<p>Get <code>idname(object)</code> and <code>hzidname(object)</code>, with <code>hzdesgnname(object)</code>, <code>hztexclname(object)</code> (if defined)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
hzMetadata(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzMetadata+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>

<hr>
<h2 id='hztexclname'>Get or Set Horizon Texture Class Column Name</h2><span id='topic+hztexclname'></span><span id='topic+hztexclname+2CSoilProfileCollection-method'></span><span id='topic+hztexclname+3C-'></span><span id='topic+hztexclname+3C-+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>hztexclname()</code>: Get column name containing horizon designation name
</p>
<p><code style="white-space: pre;">&#8288;hztexclname&lt;-&#8288;</code>: Set horizon texture class column name for a SoilProfileCollection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
hztexclname(object, required = FALSE)

## S4 replacement method for signature 'SoilProfileCollection'
hztexclname(object, required = FALSE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hztexclname_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="hztexclname_+3A_required">required</code></td>
<td>
<p>logical, is this attribute required? If it is, set to <code>TRUE</code> to trigger error on invalid <code>value</code>.</p>
</td></tr>
<tr><td><code id="hztexclname_+3A_value">value</code></td>
<td>
<p>character, name of column containing horizon texture classes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Store the column name containing horizon texture classes or other identifiers in the metadata slot of the SoilProfileCollection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)

# promote to SPC
depths(sp1) &lt;- id ~ top + bottom

# set horizon texture class column
hztexclname(sp1) &lt;- "texture"

# get horizon texture class column
hztexclname(sp1)
</code></pre>

<hr>
<h2 id='hzTopographyCodeToLineType'>Convert Horizon Boundary Topography to Line Type</h2><span id='topic+hzTopographyCodeToLineType'></span>

<h3>Description</h3>

<p>This function will convert USDA-NCSS horizon boundary topography codes into line types, based on the <a href="https://nrcspad.sc.egov.usda.gov/DistributionCenter/product.aspx?ProductID=991">Field Book for Describing and Sampling Soils, version 3.0</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hzTopographyCodeToLineType(
  x,
  codes = c("smooth", "wavy", "irregular", "broken"),
  lty = c(1, 2, 3, 4)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzTopographyCodeToLineType_+3A_x">x</code></td>
<td>
<p>vector of boundary topography codes to be converted</p>
</td></tr>
<tr><td><code id="hzTopographyCodeToLineType_+3A_codes">codes</code></td>
<td>
<p>character vector of topography terms ('smooth') or codes ('S'), case insensitive, see details</p>
</td></tr>
<tr><td><code id="hzTopographyCodeToLineType_+3A_lty">lty</code></td>
<td>
<p>line types</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Visualization of horizon boundary topography can be difficult, line type offers an additional visual cue. See <code>hzTopographyCodeToOffset</code> for an offset-based approach. Additional examples are available in the <a href="https://ncss-tech.github.io/AQP/aqp/hz-boundaries.html">Visualization of Horizon Boundaries tutorial</a>. Missing data in <code>x</code> (NA) or codes that are not defined in <code>codes</code> are returned as line type 1.
</p>
<p>Either format (or mixture) are accepted, case insensitive:
</p>

<ul>
<li><p> terms: <code>c('smooth', 'wavy', 'irregular', 'broken')</code>
</p>
</li>
<li><p> coded values: <code>c('s', 'w', 'i', 'b')</code>
</p>
</li></ul>



<h3>Value</h3>

<p>vector of line types with same length as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p><a href="https://nrcspad.sc.egov.usda.gov/DistributionCenter/product.aspx?ProductID=991">Field Book for Describing and Sampling Soils, version 3.0</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSPC">plotSPC</a>, <a href="#topic+hzTopographyCodeToOffset">hzTopographyCodeToOffset</a></code>
</p>

<hr>
<h2 id='hzTopographyCodeToOffset'>Convert Horizon Boundary Topography to Vertical Offset</h2><span id='topic+hzTopographyCodeToOffset'></span>

<h3>Description</h3>

<p>This function will convert USDA-NCSS horizon boundary topography codes into a vertical offset, suitable for use in <code>plotSPC</code>. Default values are reasonable starting points for encoding smooth, wavy, irregular, or broken style horizon boundary topography as defined in <a href="https://nrcspad.sc.egov.usda.gov/DistributionCenter/product.aspx?ProductID=991">Field Book for Describing and Sampling Soils, version 3.0</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hzTopographyCodeToOffset(
  x,
  codes = c("smooth", "wavy", "irregular", "broken"),
  offset = c(0, 4, 8, 12)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzTopographyCodeToOffset_+3A_x">x</code></td>
<td>
<p>vector of boundary topography codes to be converted</p>
</td></tr>
<tr><td><code id="hzTopographyCodeToOffset_+3A_codes">codes</code></td>
<td>
<p>character vector of topography terms ('smooth') or codes ('S'), case insensitive, see details</p>
</td></tr>
<tr><td><code id="hzTopographyCodeToOffset_+3A_offset">offset</code></td>
<td>
<p>vertical offset (depth units) used to create &quot;chevron&quot; effect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional examples are available in the <a href="https://ncss-tech.github.io/AQP/aqp/hz-boundaries.html">Visualization of Horizon Boundaries tutorial</a>. Missing data in <code>x</code> (NA) or codes that are not defined in <code>codes</code> are returned with an offset of 0.
</p>
<p>Either format (or mixture) are accepted, case insensitive:
</p>

<ul>
<li><p> terms: <code>c('smooth', 'wavy', 'irregular', 'broken')</code>
</p>
</li>
<li><p> coded values: <code>c('s', 'w', 'i', 'b')</code>
</p>
</li></ul>



<h3>Value</h3>

<p>vector of vertical offsets with same length as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p><a href="https://nrcspad.sc.egov.usda.gov/DistributionCenter/product.aspx?ProductID=991">Field Book for Describing and Sampling Soils, version 3.0</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSPC">plotSPC</a></code>
</p>

<hr>
<h2 id='hzTransitionProbabilities'>Horizon Transition Probabilities</h2><span id='topic+hzTransitionProbabilities'></span><span id='topic+mostLikelyHzSequence'></span>

<h3>Description</h3>

<p>Functions for creating and working with horizon (sequence) transition
probability matrices.
</p>
<p>See the following tutorials for some ideas:
</p>

<ul>
<li> <p><a href="http://ncss-tech.github.io/AQP/aqp/hz-transition-probabilities.html">horizon designation TP</a>
</p>
</li>
<li> <p><a href="http://ncss-tech.github.io/AQP/aqp/series-color-TP-graph.html">soil color TP</a>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>hzTransitionProbabilities(
  x,
  name = GHL(x, required = TRUE),
  loopTerminalStates = FALSE
)

mostLikelyHzSequence(mc, t0, maxIterations = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hzTransitionProbabilities_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object.</p>
</td></tr>
<tr><td><code id="hzTransitionProbabilities_+3A_name">name</code></td>
<td>
<p>A horizon level attribute in <code>x</code> that names horizons.</p>
</td></tr>
<tr><td><code id="hzTransitionProbabilities_+3A_loopterminalstates">loopTerminalStates</code></td>
<td>
<p>should terminal states loop back to themselves?
</p>
<p>This is useful when the transition probability matrix will be used to
initialize a <code>markovchain</code> object. See examples below.</p>
</td></tr>
<tr><td><code id="hzTransitionProbabilities_+3A_mc">mc</code></td>
<td>
<p>Passed to <code>markovchain</code> <code>conditionalDistribution()</code></p>
</td></tr>
<tr><td><code id="hzTransitionProbabilities_+3A_t0">t0</code></td>
<td>
<p>Passed to <code>markovchain</code> <code>conditionalDistribution()</code></p>
</td></tr>
<tr><td><code id="hzTransitionProbabilities_+3A_maxiterations">maxIterations</code></td>
<td>
<p>Maximum number of iterations. Default: <code>10</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix of transition probabilities. See examples.
</p>
<p>The function <code><a href="#topic+genhzTableToAdjMat">genhzTableToAdjMat()</a></code> returns a square adjacency matrix.
See examples.
</p>
<p>The function <code><a href="#topic+mostLikelyHzSequence">mostLikelyHzSequence()</a></code> returns the most likely sequence of
horizons, given a <code>markovchain</code> object initialized from horizon
transition probabilities and an initial state, <code>t0</code>. See examples.
</p>


<h3>Note</h3>

<p>These functions are still experimental and subject to change.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generalize.hz">generalize.hz()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp4)
depths(sp4) &lt;- id ~ top + bottom

# horizon transition probabilities: row -&gt; col transitions
(tp &lt;- hzTransitionProbabilities(sp4, 'name'))


## Not run: 
## plot TP matrix with functions from sharpshootR package
library(sharpshootR)
par(mar=c(0,0,0,0), mfcol=c(1,2))
plot(sp4)
plotSoilRelationGraph(tp, graph.mode = 'directed', edge.arrow.size=0.5)

## demonstrate genhzTableToAdjMat usage
data(loafercreek, package='soilDB')

# convert contingency table -&gt; adj matrix / TP matrix
tab &lt;- table(loafercreek$hzname, loafercreek$genhz)
m &lt;- genhzTableToAdjMat(tab)

# plot
par(mar=c(0,0,0,0), mfcol=c(1,1))
plotSoilRelationGraph(m, graph.mode = 'directed', edge.arrow.size=0.5)


## demonstrate markovchain integration
library(markovchain)
tp.loops &lt;- hzTransitionProbabilities(sp4, 'name', loopTerminalStates = TRUE)

# init new markovchain from TP matrix
mc &lt;- new("markovchain", states=dimnames(tp.loops)[[1]], transitionMatrix = tp.loops)

# simple plot
plot(mc, edge.arrow.size=0.5)

# check absorbing states
absorbingStates(mc)

# steady-state:
steadyStates(mc)

## End(Not run)

</code></pre>

<hr>
<h2 id='idname+2CSoilProfileCollection-method'>Get profile ID column name</h2><span id='topic+idname+2CSoilProfileCollection-method'></span><span id='topic+idname'></span>

<h3>Description</h3>

<p>Get column name containing unique profile IDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
idname(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idname+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>

<hr>
<h2 id='initSpatial+26lt+3B-'>Initialize Spatial Data in a SoilProfileCollection</h2><span id='topic+initSpatial+3C-'></span><span id='topic+initSpatial+3C-+2CSoilProfileCollection+2CANY+2CANY-method'></span><span id='topic+initSpatial+3C-+2CSoilProfileCollection+2CANY+2Ccharacter-method'></span><span id='topic+getSpatial+2CSoilProfileCollection-method'></span><span id='topic+getSpatial'></span><span id='topic+coordinates+2CSoilProfileCollection-method'></span><span id='topic+coordinates'></span><span id='topic+coordinates+3C-+2CSoilProfileCollection+2CANY-method'></span><span id='topic+coordinates+3C-'></span><span id='topic+coordinates+3C-+2CSoilProfileCollection+2Ccharacter-method'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;initSpatial()&lt;-&#8288;</code>: Set the column names containing spatial data and the corresponding coordinate reference system for a SoilProfileCollection.
</p>
<p><code>getSpatial()</code>: Get spatial data associated with a SoilProfileCollection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection,ANY,ANY'
initSpatial(object, crs = NULL) &lt;- value

## S4 replacement method for signature 'SoilProfileCollection,ANY,character'
initSpatial(object, crs = NULL) &lt;- value

## S4 method for signature 'SoilProfileCollection'
getSpatial(object)

## S4 method for signature 'SoilProfileCollection'
coordinates(obj)

## S4 replacement method for signature 'SoilProfileCollection,ANY'
coordinates(object) &lt;- value

## S4 replacement method for signature 'SoilProfileCollection,character'
coordinates(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initSpatial+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="initSpatial+2B26lt+2B3B-_+3A_crs">crs</code></td>
<td>
<p>Optional: character. Representation of Coordinate Reference System as <code>"authority:code"</code>, integer EPSG code, WKT2019 or PROJ4 string, an sf <code>crs</code> or sp <code>CRS</code> object.</p>
</td></tr>
<tr><td><code id="initSpatial+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A formula specifying names of columns containing geometry (x and y coordinates), or character with the column names</p>
</td></tr>
<tr><td><code id="initSpatial+2B26lt+2B3B-_+3A_obj">obj</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+prj">prj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp5)

# coordinates are stored in x and y column of site
sp5$x &lt;- rnorm(length(sp5))
sp5$y &lt;- rnorm(length(sp5))

# coordinates takes a formula object as input
initSpatial(sp5) &lt;- ~ x + y

# optionally specify Coordinate Reference System (crs) on left-hand side
initSpatial(sp5, crs = "OGC:CRS84") &lt;- ~ x + y
</code></pre>

<hr>
<h2 id='invertLabelColor'>Make High Contrast Label Colors</h2><span id='topic+invertLabelColor'></span>

<h3>Description</h3>

<p>Generate a vector of white or black label colors conditioned on a vector of colors to maximize label contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertLabelColor(colors, threshold = 0.65)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invertLabelColor_+3A_colors">colors</code></td>
<td>
<p>vector of colors</p>
</td></tr>
<tr><td><code id="invertLabelColor_+3A_threshold">threshold</code></td>
<td>
<p>black | white threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of label colors
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# test with shades of grey
s &lt;- seq(0, 1, by = 0.05)
cols &lt;- grey(s)
soilPalette(cols, lab = as.character(s))

# test with 10YR x/3
m &lt;- sprintf('10YR %s/3', 1:8)
cols &lt;- parseMunsell(m)
soilPalette(cols, lab = m)


</code></pre>

<hr>
<h2 id='isEmpty+2CSoilProfileCollection-method'>Check for &quot;empty&quot; profiles in a SoilProfileCollection</h2><span id='topic+isEmpty+2CSoilProfileCollection-method'></span><span id='topic+isEmpty'></span>

<h3>Description</h3>

<p>&quot;Empty&quot; profiles are used as placeholders for positions in a <code>SoilProfileCollection</code>
These profiles result from operations that remove or extract portions of horizons
from source profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
isEmpty(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isEmpty+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="isEmpty+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p>Additional arguments not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a <code>SoilProfileCollection</code> an empty profile occurs when it has one horizon,
with <code>NA</code> top and bottom depths. Generally all non-profile ID site and horizon-level
values are all also <code>NA</code>, but only the depths are checked by <code>isEmpty()</code>.
</p>


<h3>Value</h3>

<p>logical. Vector of length equal to number of profiles in <code>object</code>. Returns <code>TRUE</code> when a profile has one horizon with <code>NA</code> top and bottom depths
</p>

<hr>
<h2 id='jacobs2000'>Soil Morphologic Data from Jacobs et al. 2002.</h2><span id='topic+jacobs2000'></span>

<h3>Description</h3>

<p>Select soil morphologic data from &quot;Redoximorphic Features as Indicators of
Seasonal Saturation, Lowndes County, Georgia&quot;. This is a useful sample
dataset for testing the analysis and visualization of redoximorphic
features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(jacobs2000)
</code></pre>


<h3>Format</h3>

<p>A <code>SoilProfileCollection</code> object.
</p>


<h3>References</h3>

<p>Jacobs, P. M., L. T. West, and J. N. Shaw. 2002. Redoximorphic
Features as Indicators of Seasonal Saturation, Lowndes County, Georgia. Soil
Sci. Soc. Am. J. 66:315-323. doi:10.2136/sssaj2002.3150
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# load
data(jacobs2000)

# basic plot
par(mar=c(0, 1, 3, 1.5))
plotSPC(jacobs2000, name='name', color='matrix_color', width=0.3)
# add concentrations
addVolumeFraction(jacobs2000, 'concentration_pct',
col = jacobs2000$concentration_color, pch = 16, cex.max = 0.5)

# add depletions
plotSPC(jacobs2000, name='name', color='matrix_color', width=0.3)
addVolumeFraction(jacobs2000, 'depletion_pct',
col = jacobs2000$depletion_color, pch = 16, cex.max = 0.5)

# time saturated
plotSPC(jacobs2000, color='time_saturated', cex.names=0.8, col.label = 'Time Saturated')

# color contrast: matrix vs. concentrations
cc &lt;- colorContrast(jacobs2000$matrix_color_munsell, jacobs2000$concentration_munsell)
cc &lt;- na.omit(cc)

cc &lt;- cc[order(cc$dE00), ]
cc &lt;- unique(cc)

par(bg='black', fg='white')
colorContrastPlot(cc$m1[1:10], cc$m2[1:10], labels = c('matrix', 'concentration'))
colorContrastPlot(cc$m1[11:21], cc$m2[11:21], labels = c('matrix', 'concentration'))


# color contrast: depletion vs. concentrations
cc &lt;- colorContrast(jacobs2000$depletion_munsell, jacobs2000$concentration_munsell)
cc &lt;- na.omit(cc)

cc &lt;- cc[order(cc$dE00), ]
cc &lt;- unique(cc)

par(bg='black', fg='white')
colorContrastPlot(cc$m1, cc$m2, labels = c('depletion', 'concentration'))


</code></pre>

<hr>
<h2 id='L1_profiles'>Create Representative Soil Profiles via L1 Estimator</h2><span id='topic+L1_profiles'></span>

<h3>Description</h3>

<p>The L1 estimator, or <a href="https://en.wikipedia.org/wiki/Geometric_median">geometric median</a>, is a multivariate generalization of the (univariate) <a href="https://en.wikipedia.org/wiki/Median">median</a> concept. This function performs a multivariate aggregation (via L1 estimator) according to a suite of ratio-scale soil properties. The L1 estimator is applied to soil profile data that have been sliced to a 1-depth-unit basis. Data should be well stratified by groups defined in <code>fm</code>, otherwise the L1 median may not make any sense.
</p>
<p>See the <a href="https://ncss-tech.github.io/AQP/aqp/L1-profiles.html">L1 Profiles Tutorial</a> for additional examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L1_profiles(
  x,
  fm,
  basis = 1,
  method = c("regex", "simple", "constant"),
  maxDepthRule = c("max", "min"),
  maxDepthConstant = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L1_profiles_+3A_x">x</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="L1_profiles_+3A_fm">fm</code></td>
<td>
<p>formula, for example: <code>group ~ p1 + p2 + p3</code>, where &quot;group&quot; is a site-level grouping variable, and &quot;p1&quot;, &quot;p2&quot;, and &quot;p3&quot; are horizon level variables</p>
</td></tr>
<tr><td><code id="L1_profiles_+3A_basis">basis</code></td>
<td>
<p>positive integer, aggregation basis (e.g. 1 for 1-depth-unit intervals). Values other than 1 are not currently supported.</p>
</td></tr>
<tr><td><code id="L1_profiles_+3A_method">method</code></td>
<td>
<p>soil depth evaluation method: &quot;regex&quot; for regular expression, &quot;simple&quot;, or &quot;constant&quot;. See details.</p>
</td></tr>
<tr><td><code id="L1_profiles_+3A_maxdepthrule">maxDepthRule</code></td>
<td>
<p>maximum depth rule: &quot;max&quot; or &quot;min&quot; See details.</p>
</td></tr>
<tr><td><code id="L1_profiles_+3A_maxdepthconstant">maxDepthConstant</code></td>
<td>
<p>positive integer, maximum depth when <code>maxDepthRule = 'constant'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://ncss-tech.github.io/AQP/aqp/L1-profiles.html">this related tutorial</a> for additional examples. The <code>method</code>, <code>maxDepthRule</code>, and <code>maxDepthConstant</code> arguments set the maximum depth (over the entire collection) of analysis used to build &quot;L1 profiles&quot;. The following rules are available:
</p>

<ul>
<li> <p><code>method = 'regex'</code> uses pattern matching on horizon designations (note that <code>hzdesgnname</code> metadata must be set with <code>hzdesgnname(x) &lt;- 'columnname'</code>)
</p>
</li>
<li> <p><code>method = 'simple'</code> uses <code>min</code> or <code>max</code> as applied to <code>x</code>, no accounting for non-soil horizons (e.g. Cr or R)
</p>
</li>
<li> <p><code>method = 'constant'</code> uses a fixed depth value supplied by <code>maxDepthConstant</code>
</p>
</li></ul>

<p>The <code>maxDepthRule</code> argument sets depth calculation constraint, applied to soil depths computed according to <code>method</code> (<code>min</code> or <code>max</code>).
</p>


<h3>Value</h3>

<p>a <code>SoilProfileCollection</code> object
</p>


<h3>Note</h3>

<p>This function requires the <code>Gmedian</code> package.
</p>


<h3>References</h3>

<p>Cardot, H., Cenac, P. and Zitt, P-A. (2013). Efficient and fast estimation of the geometric median in Hilbert spaces with an averaged stochastic gradient algorithm. Bernoulli, 19, 18-43.
</p>

<hr>
<h2 id='length+2CSoilProfileCollection-method'>Get the number of profiles in a SoilProfileCollection</h2><span id='topic+length+2CSoilProfileCollection-method'></span><span id='topic+length'></span>

<h3>Description</h3>

<p>Get the number of profiles in a SoilProfileCollection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>

<hr>
<h2 id='lunique'>Eliminate duplicate instances of profile IDs in a list of SoilProfileCollections</h2><span id='topic+lunique'></span>

<h3>Description</h3>

<p>@description Experimental function to &quot;clean&quot; list input where duplicates exist (that would otherwise prevent <code>pbindlist</code>). Useful for queries that may have overlapping instances of the same data, for instance a list of SoilProfileCollections where each list element contains profiles gathered from a set of (potentially overlapping) extents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lunique(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lunique_+3A_l">l</code></td>
<td>
<p>A list of SoilProfileCollections.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of SoilProfileCollections, with duplicate profile IDs removed.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp5)

# EXAMPLE #1 -- resolving overlap

# 6 profiles in four sets, and 5,6,7 are missing
input &lt;- lapply(list(c(1,3,4), c(2,2,3), NA, c(8,9,1)), function(idx) {
      if(!all(is.na(idx)))
       sp5[idx,]
})

output &lt;- lunique(input)

# 6 profiles are in final SPC; 5,6,7 are missing
match(profile_id(pbindlist(output)), profile_id(sp5))

# EXAMPLE #2 -- exact duplicates

# deliberately duplicate an SPC
sp5_2 &lt;- sp5
res &lt;- lunique(list(sp5, sp5_2))

# the number of profiles in first element is equal to number in sp5
length(res[[1]]) == length(sp5)

# second list element contains NA b/c all uniques are in #1
res[[2]]

</code></pre>

<hr>
<h2 id='max+2CSoilProfileCollection-method'>Get the maximum bottom depth in a SoilProfileCollection</h2><span id='topic+max+2CSoilProfileCollection-method'></span><span id='topic+max'></span>

<h3>Description</h3>

<p>Get the deepest depth of description out of all profiles in a SoilProfileCollection. Data missing one or more of: bottom depth, profile ID, or any optional attribute are omitted using <code>complete.cases</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
max(x, v = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="max+2B2CSoilProfileCollection-method_+3A_v">v</code></td>
<td>
<p>optional: horizon-level column name to refine calculation</p>
</td></tr>
<tr><td><code id="max+2B2CSoilProfileCollection-method_+3A_na.rm">na.rm</code></td>
<td>
<p>remove <code>NA</code>? default: <code>TRUE</code></p>
</td></tr>
</table>

<hr>
<h2 id='metadata+2CSoilProfileCollection-method'>Retrieve metadata from SoilProfileCollection</h2><span id='topic+metadata+2CSoilProfileCollection-method'></span><span id='topic+metadata'></span><span id='topic+metadata+3C-+2CSoilProfileCollection-method'></span><span id='topic+metadata+3C-'></span>

<h3>Description</h3>

<p>Get metadata from SoilProfileCollection. Result is a list. Two entries (aqp_df_class, depth_units) should not be edited in the metadata list directly. There are methods that facilitate changing them &ndash; and propagating their changes throughout the collection. Otherwise, metadata list is a free-form slot used to store arbitrary information about the data, how it was collected, citations, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
metadata(object)

## S4 replacement method for signature 'SoilProfileCollection'
metadata(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metadata+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="metadata+2B2CSoilProfileCollection-method_+3A_value">value</code></td>
<td>
<p>A named list (see examples)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp5)

# replace default metadata with itself
metadata(sp5) &lt;- metadata(sp5)

# set new metadata attribute value
metadata(sp5)$newvalue &lt;- 'foo'

# get metadata attribute
metadata(sp5)$newvalue

</code></pre>

<hr>
<h2 id='min+2CSoilProfileCollection-method'>Get the minimum bottom depth in a SoilProfileCollection</h2><span id='topic+min+2CSoilProfileCollection-method'></span><span id='topic+min'></span>

<h3>Description</h3>

<p>Get the shallowest depth of description out of all profiles in a SoilProfileCollection. Data missing one or more of: bottom depth, profile ID, or any optional attribute are omitted using <code>complete.cases</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
min(x, v = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="min+2B2CSoilProfileCollection-method_+3A_v">v</code></td>
<td>
<p>optional: a vector of horizon attribute names to refine calculation</p>
</td></tr>
<tr><td><code id="min+2B2CSoilProfileCollection-method_+3A_na.rm">na.rm</code></td>
<td>
<p>remove <code>NA</code>? default: <code>TRUE</code></p>
</td></tr>
</table>

<hr>
<h2 id='missingDataGrid'>Missing Data Grid</h2><span id='topic+missingDataGrid'></span>

<h3>Description</h3>

<p>Generate a levelplot of missing data from a SoilProfileCollection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missingDataGrid(
  s,
  max_depth,
  vars,
  filter.column = NULL,
  filter.regex = NULL,
  cols = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missingDataGrid_+3A_s">s</code></td>
<td>
<p>a SoilProfileCollection object</p>
</td></tr>
<tr><td><code id="missingDataGrid_+3A_max_depth">max_depth</code></td>
<td>
<p>integer specifying the max depth of analysis</p>
</td></tr>
<tr><td><code id="missingDataGrid_+3A_vars">vars</code></td>
<td>
<p>character vector of column names over which to evaluate missing
data</p>
</td></tr>
<tr><td><code id="missingDataGrid_+3A_filter.column">filter.column</code></td>
<td>
<p>a character string naming the column to apply the
filter REGEX to</p>
</td></tr>
<tr><td><code id="missingDataGrid_+3A_filter.regex">filter.regex</code></td>
<td>
<p>a character string with a regular expression used to
filter horizon data OUT of the analysis</p>
</td></tr>
<tr><td><code id="missingDataGrid_+3A_cols">cols</code></td>
<td>
<p>a vector of colors</p>
</td></tr>
<tr><td><code id="missingDataGrid_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code>levelplot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates a <code style="white-space: pre;">&#8288;missing data fraction&#8288;</code> based on slice-wise
evaluation of named variables in a <code>SoilProfileCollection</code> object.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> describing the percentage of missing data by
variable.
</p>


<h3>Note</h3>

<p>A lattice graphic is printed to the active output device.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slice">slice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 10 random profiles
set.seed(10101)
s &lt;- lapply(as.character(1:10), random_profile)
s &lt;- do.call('rbind', s)

# randomly sprinkle some missing data
s[sample(nrow(s), 5), 'p1'] &lt;- NA
s[sample(nrow(s), 5), 'p2'] &lt;- NA
s[sample(nrow(s), 5), 'p3'] &lt;- NA

# set all p4 and p5 attributes of `soil 1' to NA
s[which(s$id == '1'), 'p5'] &lt;- NA
s[which(s$id == '1'), 'p4'] &lt;- NA

# upgrade to SPC
depths(s) &lt;- id ~ top + bottom

# plot missing data via slicing + levelplot
missingDataGrid(
  s,
  max_depth = 100,
  vars = c('p1', 'p2', 'p3', 'p4', 'p5'),
  main='Missing Data Fraction'
)

</code></pre>

<hr>
<h2 id='mixMunsell'>Mix Munsell Colors via Spectral Library</h2><span id='topic+mixMunsell'></span>

<h3>Description</h3>

<p>Simulate mixing of colors in Munsell notation, similar to the way in which mixtures of pigments operate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixMunsell(
  x,
  w = rep(1, times = length(x))/length(x),
  mixingMethod = c("exact", "reference", "estimate", "adaptive"),
  n = 1,
  keepMixedSpec = FALSE,
  distThreshold = 0.025,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixMunsell_+3A_x">x</code></td>
<td>
<p>vector of colors in Munsell notation</p>
</td></tr>
<tr><td><code id="mixMunsell_+3A_w">w</code></td>
<td>
<p>vector of proportions, can sum to any number</p>
</td></tr>
<tr><td><code id="mixMunsell_+3A_mixingmethod">mixingMethod</code></td>
<td>
<p>approach used to simulate a mixture:
</p>

<ul>
<li> <p><code>exact</code>: simulate a subtractive mixture of pigments, color conversion via CIE1931 color-matching functions (see details)
</p>
</li>
<li> <p><code>reference</code>: simulate a subtractive mixture of pigments, selecting <code>n</code> closest reference spectra from <code><a href="#topic+munsell.spectra.wide">munsell.spectra.wide</a></code> (requires <code>gower</code> package)
</p>
</li>
<li> <p><code>estimate</code>: closest Munsell chip to a weighted mean of CIELAB coordinates (fastest)
</p>
</li>
<li> <p><code>adaptive</code>: use <code>exact</code> method when possible, falling-back to <code>estimate</code> (weighted mean of CIELAB coordinates) otherwise
</p>
</li></ul>
</td></tr>
<tr><td><code id="mixMunsell_+3A_n">n</code></td>
<td>
<p>number of closest matching color chips (<code>mixingMethod = reference</code> only)</p>
</td></tr>
<tr><td><code id="mixMunsell_+3A_keepmixedspec">keepMixedSpec</code></td>
<td>
<p>keep weighted geometric mean spectra, final result is a <code>list</code> (<code>mixingMethod = reference</code> only)</p>
</td></tr>
<tr><td><code id="mixMunsell_+3A_distthreshold">distThreshold</code></td>
<td>
<p>spectral distance used to compute <code>scaledDistance</code>, default value is based on an analysis of spectral distances associated with adjacent Munsell color chips. This argument is only used with  <code>mixingMethod = 'reference'</code>.</p>
</td></tr>
<tr><td><code id="mixMunsell_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+spec2Munsell">spec2Munsell</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://ncss-tech.github.io/AQP/aqp/mix-colors.html">expanded tutorial</a> for examples.
</p>
<p>An accurate simulation of pigment mixtures (&quot;subtractive&quot; color mixtures) is incredibly complex due to factors that aren't easily measured or controlled: pigment solubility, pigment particle size distribution, water content, substrate composition, and physical obstruction to name a few. That said, it is possible to simulate reasonable, subtractive color mixtures given a reference spectra library (350-800nm) and some assumptions about pigment qualities and lighting. For the purposes of estimating a mixture of soil colors (these are pigments after all) we can relax these assumptions and assume a standard light source. The only missing piece is the spectral library for all Munsell chips in our color books.
</p>
<p>Thankfully, <a href="https://arxiv.org/ftp/arxiv/papers/1710/1710.06364.pdf">Scott Burns has outlined the entire process</a>, and Paul Centore has provided a Munsell color chip <a href="https://www.munsellcolourscienceforpainters.com">reflectance spectra library</a>. The estimation of a subtractive mixture of soil colors can proceed as follows:
</p>

<ol>
<li><p> look up the associated spectra for each color in <code>x</code>
</p>
</li>
<li><p> compute the weighted (<code>w</code> argument) geometric mean of the spectra
</p>
</li>
<li><p> convert the spectral mixture to the closest Munsell color via:
</p>
</li></ol>


<ul>
<li><p> search for the closest <code>n</code> matching spectra in the reference library (<code>mixtureMethod = 'reference'</code>)
</p>
</li>
<li><p> direct conversion of spectra to closest Munsell color via <code><a href="#topic+spec2Munsell">spec2Munsell()</a></code> (<code>mixtureMethod = 'exact'</code>)
</p>
</li></ul>


<ol>
<li><p> suggest resulting Munsell chip(s) as the best candidate for a simulated mixture
</p>
</li></ol>

<p>Key assumptions include:
</p>

<ul>
<li><p> similar particle size distribution
</p>
</li>
<li><p> similar mineralogy (i.e. pigmentation qualities)
</p>
</li>
<li><p> similar water content.
</p>
</li></ul>

<p>For the purposes of estimating (for example) a &quot;mixed soil color within the top 18cm of soil&quot; these assumptions are usually valid. Again, these are estimates that are ultimately &quot;snapped&quot; to the nearest chip and not do not need to approach the accuracy of paint-matching systems.
</p>
<p>A message is printed when <code>scaledDistance</code> is larger than 1.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the closest matching Munsell color(s):
</p>

<ul>
<li> <p><code>munsell</code>: Munsell notation of the n-closest spectra
</p>
</li>
<li> <p><code>distance</code>: spectral (Gower) distance to the n-closest spectra
</p>
</li>
<li> <p><code>scaledDistance</code>: spectral distance scaled by <code>distThreshold</code>
</p>
</li>
<li> <p><code>mixingMethod</code>: method used for each mixture
</p>
</li></ul>

<p>When <code>keepMixedSpec = TRUE</code> then a <code>list</code>:
</p>

<ul>
<li> <p><code>mixed</code>: a <code>data.frame</code> containing the same elements as above
</p>
</li>
<li> <p><code>spec</code>: spectra for the 1st closest match
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Marcus, R.T. (1998). The Measurement of Color. In K. Nassau (Ed.), Color for Science, Art, and Technology (pp. 32-96). North-Holland.
</p>

<ul>
<li> <p><a href="https://arxiv.org/ftp/arxiv/papers/1710/1710.06364.pdf">inspiration / calculations based on the work of Scott Burns</a>
</p>
</li>
<li> <p><a href="https://stackoverflow.com/questions/10254022/implementing-kubelka-munk-like-krita-to-mix-colours-color-like-paint/29967630#29967630">related discussion on Stack Overflow</a>
</p>
</li>
<li> <p><a href="https://www.munsellcolourscienceforpainters.com/MunsellResources/SpectralReflectancesOf2007MunsellBookOfColorGlossy.txt">spectral library source</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+munsell.spectra">munsell.spectra</a>
</p>

<hr>
<h2 id='mollic.thickness.requirement'>Calculate the minimum thickness requirement for Mollic epipedon</h2><span id='topic+mollic.thickness.requirement'></span>

<h3>Description</h3>

<p>Utilize horizon depths, designations and textures in a profile to estimate the thickness requirement for the Mollic or Umbric epipedon, per criterion 6 in the U.S. Keys to Soil Taxonomy (12th Edition).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mollic.thickness.requirement(
  p,
  hzdesgn = guessHzDesgnName(p),
  texcl.attr = guessHzTexClName(p),
  clay.attr = guessHzAttrName(p, "clay", c("total", "_r")),
  truncate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mollic.thickness.requirement_+3A_p">p</code></td>
<td>
<p>A single-profile SoilProfileCollection.</p>
</td></tr>
<tr><td><code id="mollic.thickness.requirement_+3A_hzdesgn">hzdesgn</code></td>
<td>
<p>Column in horizon table containing designations. Default: <code>guessHzDesgnName(p)</code></p>
</td></tr>
<tr><td><code id="mollic.thickness.requirement_+3A_texcl.attr">texcl.attr</code></td>
<td>
<p>Column in horizon table containing texture classes. Default: <code>guessHzTexClName(p)</code></p>
</td></tr>
<tr><td><code id="mollic.thickness.requirement_+3A_clay.attr">clay.attr</code></td>
<td>
<p>Column in horizon table containing clay contents. Default: <code>guessHzAttrName(p, 'clay', c('total','_r'))</code></p>
</td></tr>
<tr><td><code id="mollic.thickness.requirement_+3A_truncate">truncate</code></td>
<td>
<p>Should sliding scale (Criterion 6C) results be truncated to 18 to 25cm interval? (Experimental; Default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A unit length numeric vector containing Mollic or Umbric epipedon minimum thickness requirement.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a fake profile
spc &lt;- data.frame(id=1, taxsubgrp = "Lithic Haploxeralfs",
                  hzname   = c("A","AB","Bt","BCt","R"),
                  hzdept   = c(0,  20, 32, 42,  49),
                  hzdepb   = c(20, 32, 42, 49, 200),
                  prop     = c(18, 22, 28, 24,  NA),
                  texcl    = c("l","l","cl", "l","br"),
                  d_value  = c(5,   5,  5,  6,  NA),
                  m_value  = c(2.5, 3,  3,  4,  NA),
                  m_chroma = c(2,   3,  4,  4,  NA))

# promote to SoilProfileCollection
depths(spc) &lt;- id ~ hzdept + hzdepb
hzdesgnname(spc) &lt;- 'hzname'
hztexclname(spc) &lt;- 'texcl'

# print results in table
data.frame(id = spc[[idname(spc)]],
           thickness_req = mollic.thickness.requirement(spc, clay.attr='prop'),
           thickness_req_nobound = mollic.thickness.requirement(spc,
                                        clay.attr='prop', truncate=FALSE))

</code></pre>

<hr>
<h2 id='munsell'>Munsell to sRGB Lookup Table for Common Soil Colors</h2><span id='topic+munsell'></span>

<h3>Description</h3>

<p>A lookup table of interpolated Munsell color chips for common soil colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(munsell)
</code></pre>


<h3>Format</h3>

<p>A data frame with 8825 rows.  </p>
 <dl>
<dt>hue</dt><dd><p>Munsell
Hue, upper case</p>
</dd> <dt>value</dt><dd><p>Munsell Value</p>
</dd>
<dt>chroma</dt><dd><p>Munsell Chroma</p>
</dd> <dt>r</dt><dd><p>sRGB &quot;red&quot; value
(0-1)</p>
</dd> <dt>g</dt><dd><p>sRGB &quot;green&quot; value (0-1)</p>
</dd> <dt>b</dt><dd><p>sRGB
&quot;blue&quot; value (0-1)</p>
</dd> <dt>L</dt><dd><p>CIE LAB &quot;L&quot; coordinate</p>
</dd>
<dt>A</dt><dd><p>CIE LAB &quot;A&quot; coordinate</p>
</dd> <dt>B</dt><dd><p>CIE LAB &quot;B&quot;
coordinate</p>
</dd> </dl>



<h3>Details</h3>

<p>See <code>munsell2rgb</code> for conversion examples. Note that this table does
not currently have entries for values of 2.5&ndash;common in most soil color
books. These chips should be added in the next major release of aqp. Values
are referenced to the D65 standard illuminant.
</p>


<h3>Source</h3>

<p>Color chip XYZ values:
http://www.rit.edu/cos/colorscience/rc_munsell_renotation.php
</p>


<h3>References</h3>


<dl>
<dt>http://www.brucelindbloom.com/index.html?ColorCalcHelp.html</dt><dd><p>Color
conversion equations</p>
</dd>
<dt>http://dx.doi.org/10.1016/j.cageo.2012.10.020</dt><dd><p>Methods used to
generate this table</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(munsell)

</code></pre>

<hr>
<h2 id='munsell.spectra'>Spectral Library of Munsell Colors</h2><span id='topic+munsell.spectra'></span><span id='topic+munsell.spectra.wide'></span>

<h3>Description</h3>

<p>The original database &quot;SpectralReflectancesOf2007MunsellBookOfColorGlossy.txt&quot; was provided by Paul Centore and downloaded July, 2020. Reflectance values for odd chroma have been interpolated from adjacent chips. See <code>aqp/misc/utils/Munsell/</code> for the entire set of processing steps.
</p>
<p>Munsell value typically ranges from 2-9, and chroma from 1-12. Ranges vary by hue. Run <code>aqp:::.summarizeMunsellSpectraRanges()</code> for a detailed listing by hue.
</p>
<p>The original database contains the following description:
</p>
<p>This file contains spectral reflectance measurements of X-Rite's 2007 Munsell Book of Color (Glossy Finish).  The measurements were made in 2012 with a ColorMunki spectrophotometer.  The first column is the Munsell name.  The remaining columns give reflectance values for 380 nm to 730 nm, in steps of 10 nm.  The reflectance is a value between 0 (indicating that no light at that wavelength is reflected) and 1 (indicating that all the light at that wavelength is reflected).  Occasionally an entry is slightly greater than 1.  The likely cause is random variability, and those entries can be adjusted to 1 with negligible loss. In all, 1485 colour samples were measured.  Researchers are invited to analyze the data in this file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(munsell.spectra)
</code></pre>


<h3>Format</h3>

<p>A data frame with 89496 rows and 10 variables:
</p>

<dl>
<dt>munsell</dt><dd><p>munsell color</p>
</dd>
<dt>hue</dt><dd><p>hue component</p>
</dd>
<dt>value</dt><dd><p>value component</p>
</dd>
<dt>chroma</dt><dd><p>chroma component</p>
</dd>
<dt>wavelength</dt><dd><p>wavelength (nm)</p>
</dd>
<dt>reflectance</dt><dd><p>reflectance</p>
</dd>
</dl>



<h3>References</h3>

<p>Centore, Paul. Colour Tools for Painters. <a href="https://www.munsellcolourscienceforpainters.com/">https://www.munsellcolourscienceforpainters.com/</a>.
</p>

<hr>
<h2 id='munsell2rgb'>Convert Munsell Color Notation to other Color Space Coordinates (sRGB and CIELAB)</h2><span id='topic+munsell2rgb'></span>

<h3>Description</h3>

<p>Color conversion based on a look-up table of common soil colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>munsell2rgb(
  the_hue,
  the_value,
  the_chroma,
  alpha = 1,
  maxColorValue = 1,
  return_triplets = FALSE,
  returnLAB = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="munsell2rgb_+3A_the_hue">the_hue</code></td>
<td>
<p>a vector of one or more more hues, upper-case (e.g. '10YR')</p>
</td></tr>
<tr><td><code id="munsell2rgb_+3A_the_value">the_value</code></td>
<td>
<p>a vector of one or more values (e.g. '4')</p>
</td></tr>
<tr><td><code id="munsell2rgb_+3A_the_chroma">the_chroma</code></td>
<td>
<p>a vector of one or more chromas (e.g. '6'), may be NA for neutral hues</p>
</td></tr>
<tr><td><code id="munsell2rgb_+3A_alpha">alpha</code></td>
<td>
<p>numeric, transparency setting used when <code>return_triplets = FALSE</code> and <code>returnLAB = FALSE</code></p>
</td></tr>
<tr><td><code id="munsell2rgb_+3A_maxcolorvalue">maxColorValue</code></td>
<td>
<p>maximum sRGB color value, typically <code>1</code> (see <code><a href="grDevices.html#topic+rgb">rgb</a>)</code></p>
</td></tr>
<tr><td><code id="munsell2rgb_+3A_return_triplets">return_triplets</code></td>
<td>
<p>logical, return sRGB coordinates (range 0-1) instead of standard hex notation of sRGB (e.g. '#8080B')</p>
</td></tr>
<tr><td><code id="munsell2rgb_+3A_returnlab">returnLAB</code></td>
<td>
<p>logical, return CIELAB coordinates (D65 illuminant)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is vectorized without recycling: i.e. the length of each argument must be the same. Both functions will pad output with NA if there are any NA present in the inputs.
</p>
<p>Neutral hues are approximated by greyscale shades ranging from 20\
</p>
<p>Gley soil colors that are missing a chroma will not be correctly interpreted. Consider using a chroma of 1.
Non-standard Munsell notation (e.g. '7.9YR 2.7/2.0') can be matched (nearest-neighbor, no interpolation) to the closest color within the <code>munsell</code> sRGB/CIELAB look-up table via <code>getClosestMunsellChip()</code>. A more accurate estimate of sRGB values from non-standard notation can be achieved with the <a href="https://CRAN.R-project.org/package=munsellinterpol">munsellinterpol</a> package.
</p>
<p>See examples below.
</p>


<h3>Value</h3>

<p>A vector of R colors is returned that is the same length as the input data. When <code>return_triplets = TRUE</code> and/or <code>returnLAB = TRUE</code>, then a <code>data.frame</code> (of sample length as input) is returned.
</p>


<h3>Note</h3>

<p>Care should be taken when using the resulting sRGB values; they are close to their Munsell counterparts, but will vary based on your monitor and ambient lighting conditions. Also, the value used for <code>maxColorValue</code> will affect the brightness of the colors. Th default value (1) will usually give acceptable results, but can be adjusted to force the colors closer to what the user thinks they should look like.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p><a href="http://ncss-tech.github.io/AQP/">http://ncss-tech.github.io/AQP/</a>
<a href="http://www.brucelindbloom.com/index.html?ColorCalcHelp.html">http://www.brucelindbloom.com/index.html?ColorCalcHelp.html</a>
<a href="https://www.munsellcolourscienceforpainters.com/MunsellAndKubelkaMunkToolbox/MunsellAndKubelkaMunkToolbox.html">https://www.munsellcolourscienceforpainters.com/MunsellAndKubelkaMunkToolbox/MunsellAndKubelkaMunkToolbox.html</a>
http://www.cis.rit.edu/mcsl/online/munsell.php
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# neutral hues (N) can be defined with chroma of 0 or NA 
g &lt;- expand.grid(hue='N', value=2:8, chroma=0, stringsAsFactors=FALSE)
(m &lt;- munsell2rgb(g$hue, g$value, g$chroma))
soilPalette(m)

# back-transform
rgb2munsell(t(col2rgb(m)) / 255)


# basic example
d &lt;- expand.grid(hue='10YR', value=2:8, chroma=1:8, stringsAsFactors=FALSE)
d$color &lt;- with(d, munsell2rgb(hue, value, chroma))

# similar to the 10YR color book page
plot(value ~ chroma, data=d, col=d$color, pch=15, cex=3)

# multiple pages of hue:
hues &lt;- c('2.5YR','5YR','7.5YR','10YR')
d &lt;- expand.grid(hue=hues, value=c(2, 2.5, 3:8), chroma=seq(2,8,by=2), stringsAsFactors=FALSE)
# convert Munsell -&gt; sRGB
d$color &lt;- with(d, munsell2rgb(hue, value, chroma))

# extract CIELAB coordinates
with(d, munsell2rgb(hue, value, chroma, returnLAB=TRUE))

# plot: note that we are setting panel order from red --&gt; yellow
library(lattice)
xyplot(value ~ factor(chroma) | factor(hue, levels=hues),
       main="Common Soil Colors", layout=c(4,1), scales=list(alternating=1),
       strip=strip.custom(bg=grey(0.85)),
       data=d, as.table=TRUE, subscripts=TRUE, xlab='Chroma', ylab='Value',
       panel=function(x, y, subscripts, ...)
       {
         panel.xyplot(x, y, pch=15, cex=4, col=d$color[subscripts])
       }
)


# soils example
data(sp1)

# convert colors
sp1$soil_color &lt;- with(sp1, munsell2rgb(hue, value, chroma))

# simple plot, may need to tweak gamma-correction...
image(matrix(1:nrow(sp1)), axes=FALSE, col=sp1$soil_color, main='Soil Colors')

# convert into a more useful color space
# you will need the colorspace package for this to work
if(require(colorspace)) {
  # keep RGB triplets from conversion
  sp1.rgb &lt;- with(sp1, munsell2rgb(hue, value, chroma, return_triplets=TRUE))
  
  # convert into LAB color space
  sp1.lab &lt;- as(with(sp1.rgb, sRGB(r,g,b)), 'LAB')
  plot(sp1.lab)
}

# convert a non-standard color to closest "chip" in `munsell` look-up table
getClosestMunsellChip('7.9YR 2.7/2.0', convertColors = FALSE)
# convert directly to R color
getClosestMunsellChip('7.9YR 2.7/2.0')
</code></pre>

<hr>
<h2 id='munsell2spc+2CSoilProfileCollection-method'>Merge Munsell Hue, Value, Chroma converted to sRGB &amp; CIELAB into a SoilProfileCollection</h2><span id='topic+munsell2spc+2CSoilProfileCollection-method'></span><span id='topic+munsell2spc'></span>

<h3>Description</h3>

<p>Convert Munsell hue, value and chroma into sRGB (<code>rgb_R, rgb_G, rgb_B</code>) and CIELAB (lab_L, lab_A, lab_B) color coordinates using <code>munsell2rgb</code>. The converted values are stored in the <code>horizons()</code> slot unless <code>as.spc</code> is <code>FALSE</code>, in which case the results are combined with profile and horizon ID columns and returned as the <code>data.frame</code> subclass used by the SPC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
munsell2spc(
  object,
  hue = "hue",
  value = "value",
  chroma = "chroma",
  .data = NULL,
  as.spc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="munsell2spc+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="munsell2spc+2B2CSoilProfileCollection-method_+3A_hue">hue</code></td>
<td>
<p>Column name containing numeric hue values. Default: <code>"hue"</code></p>
</td></tr>
<tr><td><code id="munsell2spc+2B2CSoilProfileCollection-method_+3A_value">value</code></td>
<td>
<p>Column name containing numeric value values. Default: <code>"value"</code></p>
</td></tr>
<tr><td><code id="munsell2spc+2B2CSoilProfileCollection-method_+3A_chroma">chroma</code></td>
<td>
<p>Column name containing numeric chroma values. Default: <code>"chroma"</code></p>
</td></tr>
<tr><td><code id="munsell2spc+2B2CSoilProfileCollection-method_+3A_.data">.data</code></td>
<td>
<p>Optional: a character vector of equal length to number of horizons (containing Munsell notation), or a column name in the horizon data OR a data.frame containing three columns (names specified in <code>hue</code>, <code>value</code>, <code>chroma</code>)</p>
</td></tr>
<tr><td><code id="munsell2spc+2B2CSoilProfileCollection-method_+3A_as.spc">as.spc</code></td>
<td>
<p>Return a data.frame-like object with ID columns?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SoilProfileCollection or <code>data.frame</code>-like object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parseMunsell">parseMunsell</a></code> <code><a href="#topic+rgb2munsell">rgb2munsell</a></code> <code><a href="#topic+munsell2rgb">munsell2rgb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp3)
depths(sp3) &lt;- id ~ top + bottom

# inspect input data
horizons(sp3)[,c("hue","value","chroma")]

# do color conversions to sRGB and LAB, join into horizon data
sp3 &lt;- munsell2spc(sp3)

# plot rgb "R" coordinate by horizon
plot(sp3, color = "rgb_R")

# plot lab "A" coordinate by horizon
plot(sp3, color = "lab_A")

# note that `lab_A` values do not exactly match the original `A` values
# this is because `lab_A` was computed from the (field determined) Munsell color notation,
# while `A` was directly measured in the lab by colorimeter
plot(sp3$A, sp3$lab_A, xlab = 'Measured', ylab = 'Converted from Field Observed Munsell')

</code></pre>

<hr>
<h2 id='munsellHuePosition'>Munsell Hue Position Reference</h2><span id='topic+munsellHuePosition'></span>

<h3>Description</h3>

<p>Position data for the 40 standard Munsell hues (and neutral). Data include angular positions (compass-style, origin at <code style="white-space: pre;">&#8288;[x = 0, y = 1]&#8288;</code>, CW rotation) and Cartesian coordinates on the unit circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(munsellHuePosition)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 41 rows and 4 columns.
</p>


<h3>References</h3>

<p>Munsell book of color. 1976. Macbeth, a Division of Kollmorgen Corp., Baltimore, MD.
</p>

<hr>
<h2 id='mutate_profile'>Transform a SPC (by profile) with a set of expressions</h2><span id='topic+mutate_profile'></span><span id='topic+mutate_profile+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>mutate_profile()</code> is a function used for transforming SoilProfileCollections. Each expression is applied to site or horizon level attributes of individual profiles. This distinguishes this function from <code>transform</code>, which is applied to all values in a collection, regardless of which profile they came from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_profile(object, ..., horizon_level = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_profile_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="mutate_profile_+3A_...">...</code></td>
<td>
<p>A set of comma-delimited R expressions that resolve to a transformation to be applied to a single profile e.g <code>mutate_profile(hzdept = max(hzdept) - hzdept)</code></p>
</td></tr>
<tr><td><code id="mutate_profile_+3A_horizon_level">horizon_level</code></td>
<td>
<p>logical. If <code>TRUE</code> results of expressions are added to the SoilProfileCollection's horizon slot, if <code>FALSE</code> the results are added to the site slot. If <code>NULL</code> (default) the results are stored in the site or horizon slot based on the number of rows in each slot compared to the length of the result calculated from the <em>first</em> and <em>last</em> profile in the collection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the length an expression's result matches the number of horizons, the result is stored as a horizon-level variable. If the result has length 1, it is stored as a site-level variable. In the ambiguous case where the first and last profile have only <em>one</em> horizon, the results are stored in the horizon slot by default. To force results into site slot use <code>horizon_level = FALSE</code>.
</p>


<h3>Value</h3>

<p>A SoilProfileCollection.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown.
</p>

<hr>
<h2 id='names+2CSoilProfileCollection-method'>Get names of columns in site and horizons table</h2><span id='topic+names+2CSoilProfileCollection-method'></span><span id='topic+names'></span>

<h3>Description</h3>

<p>Get names of columns in site and horizons table of a SoilProfileCollection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>

<hr>
<h2 id='NCSP'>Numerical Classification of Soil Profiles</h2><span id='topic+NCSP'></span>

<h3>Description</h3>

<p>Replacement for <code>profile_compare()</code>.
</p>
<p>Performs a numerical comparison of soil profiles using named properties,
based on a weighted, summed, depth-segment-aligned dissimilarity
calculation.
</p>
<p>Variability in soil depth can interfere significantly with the calculation
of between-profile dissimilarity&ndash; what is the numerical &ldquo;distance&rdquo; (or
dissimilarity) between a slice of soil from profile A and the corresponding,
but missing, slice from a shallower profile B? Gower's distance metric would
yield a NULL distance, despite the fact that intuition suggests otherwise:
shallower soils should be more dissimilar from deeper soils. For example,
when a 25 cm deep profile is compared with a 50 cm deep profile, numerical
distances are only accumulated for the first 25 cm of soil (distances from
26 - 50 cm are NULL). When summed, the total distance between these profiles
will generally be less than the distance between two profiles of equal
depth. Our algorithm has an option (setting replace_na=TRUE) to replace NULL
distances with the maximum distance between any pair of profiles for the
current depth slice. In this way, the numerical distance between a slice of
soil and a corresponding slice of non-soil reflects the fact that these two
materials should be treated very differently (i.e. maximum dissimilarity).
</p>
<p>This alternative calculation of dissimilarities between soil and non-soil
slices solves the problem of comparing shallow profiles with deeper
profiles. However, it can result in a new problem: distances calculated
between two shallow profiles will be erroneously inflated beyond the extent
of either profile's depth. Our algorithm has an additional option (setting
add_soil_flag=TRUE) that will preserve NULL distances between slices when
both slices represent non-soil material. With this option enabled, shallow
profiles will only accumulate mutual dissimilarity to the depth of the
deeper profile.
</p>
<p>Slices
are classified as 'soil' down to the maximum depth to which at least one of
variables used in the dissimilarity calculation is not NA. This will cause
problems when profiles within a collection contain all NAs within the
columns used to determine dissimilarity. An approach for identifying and
removing these kind of profiles is presented in the examples section below.
</p>
<p>A notice is issued if there are any NA values within the matrix used for
distance calculations, as these values are optionally replaced by the max
dissimilarity.
</p>
<p>Our approach builds on the work of (Moore, 1972) and the previously
mentioned depth-slicing algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCSP(
  x,
  vars,
  fm = NULL,
  weights = rep(1, times = length(vars)),
  maxDepth = max(x),
  k = 0,
  isColor = FALSE,
  rescaleResult = FALSE,
  progress = TRUE,
  verbose = TRUE,
  returnDepthDistances = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NCSP_+3A_x">x</code></td>
<td>
<p><code>SoilProfileColection</code> object, should be pre-filtered to remove profiles with horizon depth logic, see <code><a href="#topic+HzDepthLogicSubset">HzDepthLogicSubset</a></code></p>
</td></tr>
<tr><td><code id="NCSP_+3A_vars">vars</code></td>
<td>
<p>character vector, names of horizon attributes to use in the classification</p>
</td></tr>
<tr><td><code id="NCSP_+3A_fm">fm</code></td>
<td>
<p>formula, formula as specified to <code><a href="#topic+dice">dice()</a></code>, not yet implemented</p>
</td></tr>
<tr><td><code id="NCSP_+3A_weights">weights</code></td>
<td>
<p>numeric vector, same length as <code>vars</code>: variable importance weights, need not sum to 1</p>
</td></tr>
<tr><td><code id="NCSP_+3A_maxdepth">maxDepth</code></td>
<td>
<p>numeric, maximum depth of analysis</p>
</td></tr>
<tr><td><code id="NCSP_+3A_k">k</code></td>
<td>
<p>numeric, weighting coefficient, see examples</p>
</td></tr>
<tr><td><code id="NCSP_+3A_iscolor">isColor</code></td>
<td>
<p>logical: variables represent color, should be CIELAB coordinates (D65 illuminant), weights are ignored. Variables should be named <code>L</code>, <code>A</code>, <code>B</code> in specified in that order.</p>
</td></tr>
<tr><td><code id="NCSP_+3A_rescaleresult">rescaleResult</code></td>
<td>
<p>logical, distance matrix is rescaled based on max(D)</p>
</td></tr>
<tr><td><code id="NCSP_+3A_progress">progress</code></td>
<td>
<p>logical, report progress</p>
</td></tr>
<tr><td><code id="NCSP_+3A_verbose">verbose</code></td>
<td>
<p>logical, extra output messages</p>
</td></tr>
<tr><td><code id="NCSP_+3A_returndepthdistances">returnDepthDistances</code></td>
<td>
<p>logical, return a list of distances by depth slice</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>NCSP()</code> will overwrite the <code>removed.profiles</code> metadata from <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Dylan E. Beaudette and Jon Maynard
</p>


<h3>References</h3>


<ul>
<li><p> J.J Maynard, S.W. Salley, D.E. Beaudette, J.E Herrick. Numerical soil classification supports soil identification by citizen scientists using limited, simple soil observations. Soil Sci. Soc. Am. J. 2020; 84: 1675-1692. <a href="https://doi.org/10.1002/saj2.20119">doi:10.1002/saj2.20119</a>.
</p>
</li>
<li><p> D.E. Beaudette, P. Roudier, A.T. O'Geen, Algorithms for quantitative pedology: A toolkit for soil scientists, Computers &amp; Geosciences, Volume 52, 2013, Pages 258-268, ISSN 0098-3004, <a href="https://doi.org/10.1016/j.cageo.2012.10.020">doi:10.1016/j.cageo.2012.10.020</a>.
</p>
</li>
<li><p> Moore, A.; Russell, J. &amp; Ward, W. Numerical analysis of soils: A comparison of three soil profile models with field classification. Journal of Soil Science, 1972, 23, 194-209.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+dice">dice()</a></code>, <code><a href="cluster.html#topic+daisy">cluster::daisy()</a></code>, <code><a href="#topic+compareSites">compareSites()</a></code>
</p>

<hr>
<h2 id='nrow+2CSoilProfileCollection-method'>Get the number of horizons in a SoilProfileCollection</h2><span id='topic+nrow+2CSoilProfileCollection-method'></span><span id='topic+nrow'></span>

<h3>Description</h3>

<p>Get the number of horizons in a SoilProfileCollection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
nrow(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrow+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>

<hr>
<h2 id='osd'>Example Output from soilDB::fetchOSD()</h2><span id='topic+osd'></span>

<h3>Description</h3>

<p>An example <code>SoilProfileCollection</code> object created by <code>soilDB::fetchOSD()</code>, derived from the Cecil, Appling, and Bonneau Official Series Descriptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(osd)
</code></pre>


<h3>Format</h3>

<p>A <code>SoilProfileCollection</code>
</p>

<hr>
<h2 id='panel.depth_function'>Lattice Panel Function for Soil Profiles</h2><span id='topic+panel.depth_function'></span><span id='topic+prepanel.depth_function'></span>

<h3>Description</h3>

<p>Panel function for plotting grouped soil property data, along with upper and
lower estimates of uncertainty.
</p>
<p>This function can be used to replace <code>panel.superpose</code> when plotting
depth function data. When requested, contributing fraction data are printed
using colors the same color as corresponding depth function lines unless a
single color value is given via <code>cf.col</code>.
</p>
<p>This function is not able to apply transformations (typically <code>log = 10</code>) applied in the <code>scales</code> argument to <code>xyplot</code> to  upper/lower bounds. These will have to be manually applied. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.depth_function(
  x,
  y,
  id,
  upper = NA,
  lower = NA,
  subscripts = NULL,
  groups = NULL,
  sync.colors = FALSE,
  cf = NA,
  cf.col = NA,
  cf.interval = 20,
  ...
)

prepanel.depth_function(
  x,
  y,
  upper = NA,
  lower = NA,
  subscripts,
  groups = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.depth_function_+3A_x">x</code></td>
<td>
<p>x values (generated by calling lattice function)</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_y">y</code></td>
<td>
<p>y values (generated by calling lattice function)</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_id">id</code></td>
<td>
<p>vector of id labels, same length as x and y&ndash;only required when
plotting segments (see Details section)</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_upper">upper</code></td>
<td>
<p>vector of upper confidence envelope values</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_lower">lower</code></td>
<td>
<p>vector of lower confidence envelope values</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_subscripts">subscripts</code></td>
<td>
<p>paneling indices (generated by calling lattice function)</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_groups">groups</code></td>
<td>
<p>grouping data (generated by calling lattice function)</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_sync.colors">sync.colors</code></td>
<td>
<p>optionally sync the fill color within the region bounded
by (lower&ndash;upper) with the line colors</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_cf">cf</code></td>
<td>
<p>optionally annotate contributing fraction data at regular depth
intervals see <code><a href="#topic+slab">slab</a></code></p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_cf.col">cf.col</code></td>
<td>
<p>optional color for contributing fraction values, typically
used to override the line color</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_cf.interval">cf.interval</code></td>
<td>
<p>number of depth units to space printed contributing
fraction values</p>
</td></tr>
<tr><td><code id="panel.depth_function_+3A_...">...</code></td>
<td>
<p>further arguments to lower-level lattice plotting functions,
see below</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sp1">sp1</a></code>, <code><a href="#topic+slice">slice</a></code>, <code><a href="#topic+slab">slab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lattice)
data(sp1)

# 1. plotting mechanism for step-functions derived from soil profile data
xyplot(
  cbind(top, bottom) ~ prop,
  data = sp1,
  id = sp1$id,
  panel = panel.depth_function,
  ylim = c(250, -10),
  scales = list(y = list(tick.number = 10)),
  xlab = 'Property',
  ylab = 'Depth (cm)',
  main = 'panel.depth_function() demo'
)

# 1.1 include groups argument to leverage lattice styling framework
sp1$group &lt;- factor(sp1$group, labels = c('Group 1', 'Group2'))

xyplot(
  cbind(top, bottom) ~ prop,
  groups = group,
  data = sp1,
  id = sp1$id,
  panel = panel.depth_function,
  ylim = c(250, -10),
  scales = list(y = list(tick.number = 10)),
  xlab = 'Property',
  ylab = 'Depth (cm)',
  main = 'panel.depth_function() demo',
  auto.key = list(
    columns = 2,
    points = FALSE,
    lines = TRUE
  ),
  par.settings = list(superpose.line = list(col = c(
    'Orange', 'RoyalBlue'
  )))
)


# more complex examples, using step functions with grouped data
# better looking figures with less customization via tactile package
if(requireNamespace('tactile')) {
  
  library(data.table)
  library(lattice)
  library(tactile)
  
  # example data
  data(sp6)
  
  # a single profile
  x &lt;- sp6[1:5, ]
  
  # wide -&gt; long format
  x.long &lt;- data.table::melt(
    data.table::data.table(x), 
    id.vars = c('id', 'top', 'bottom'), 
    measure.vars = c('sand', 'silt', 'clay')
  )
  
  # (optional) convert back to data.frame
  x.long &lt;- as.data.frame(x.long)
  
  # three variables sharing a common axis
  # factor levels set by melt()
  xyplot(
    cbind(top, bottom) ~ value | id,
    groups = variable,
    data = x.long,
    id = x.long$id,
    ylim = c(200, -5), xlim = c(10, 60),
    scales = list(alternating = 1, y = list(tick.number = 10)),
    par.settings = tactile.theme(superpose.line = list(lwd = 2)),
    xlab = 'Sand, Silt, Clay (%)',
    ylab = 'Depth (cm)',
    panel = panel.depth_function,
    auto.key = list(columns = 3, lines = TRUE, points = FALSE),
    asp = 1.5
  )
  
  
  # all profiles
  x &lt;- sp6
  
  # wide -&gt; long format
  x.long &lt;- data.table::melt(
    data.table::data.table(x), 
    id.vars = c('id', 'top', 'bottom'), 
    measure.vars = c('sand', 'silt', 'clay')
  )
  
  # (optional) convert back to data.frame
  x.long &lt;- as.data.frame(x.long)
  
  # three variables sharing a common axis
  # factor levels set by melt()
  xyplot(
    cbind(top, bottom) ~ value | id,
    groups = variable,
    data = x.long,
    id = x.long$id,
    ylim = c(200, -5), xlim = c(0, 70),
    scales = list(alternating = 1, y = list(tick.number = 10)),
    par.settings = tactile.theme(superpose.line = list(lwd = 2)),
    xlab = 'Sand, Silt, Clay (%)',
    ylab = 'Depth (cm)',
    panel = panel.depth_function,
    auto.key = list(columns = 3, lines = TRUE, points = FALSE),
    as.table = TRUE
  )
  
  xyplot(
    cbind(top, bottom) ~ value,
    groups = variable,
    data = x.long,
    id = x.long$id,
    ylim = c(200, -5), xlim = c(0, 70),
    scales = list(alternating = 1, y = list(tick.number = 10)),
    par.settings = tactile.theme(superpose.line = list(lwd = 2)),
    xlab = 'Sand, Silt, Clay (%)',
    ylab = 'Depth (cm)',
    panel = panel.depth_function,
    auto.key = list(columns = 3, lines = TRUE, points = FALSE),
    as.table = TRUE
  )
  
  xyplot(
    cbind(top, bottom) ~ value | variable,
    groups = variable,
    data = x.long,
    id = x.long$id,
    ylim = c(200, -5), xlim = c(0, 70),
    scales = list(alternating = 1, y = list(tick.number = 10)),
    par.settings = tactile.theme(superpose.line = list(lwd = 2)),
    xlab = 'Sand, Silt, Clay (%)',
    ylab = 'Depth (cm)',
    panel = panel.depth_function,
    auto.key = list(columns = 3, lines = TRUE, points = FALSE),
    as.table = TRUE
  )
  
  
  xyplot(
    cbind(top, bottom) ~ value | variable,
    data = x.long,
    id = x.long$id,
    ylim = c(200, -5), xlim = c(0, 70),
    scales = list(alternating = 1, y = list(tick.number = 10)),
    par.settings = tactile.theme(superpose.line = list(lwd = 2)),
    xlab = 'Sand, Silt, Clay (%)',
    ylab = 'Depth (cm)',
    panel = panel.depth_function,
    auto.key = list(columns = 3, lines = TRUE, points = FALSE),
    as.table = TRUE
  )
  
  
}
</code></pre>

<hr>
<h2 id='parseMunsell'>Parse Munsell Color Notation</h2><span id='topic+parseMunsell'></span>

<h3>Description</h3>

<p>Split Munsell color notation into &quot;hue&quot;, &quot;value&quot;, and &quot;chroma&quot;, with optional conversion to sRGB hex notation, sRGB coordinates, and CIELAB coordinates. Conversion is performed by <code><a href="#topic+munsell2rgb">munsell2rgb</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseMunsell(munsellColor, convertColors = TRUE, delim = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseMunsell_+3A_munsellcolor">munsellColor</code></td>
<td>
<p>character vector of Munsell colors (e.g. <code>c('10YR 3/4', '5YR 4/6')</code>)</p>
</td></tr>
<tr><td><code id="parseMunsell_+3A_convertcolors">convertColors</code></td>
<td>
<p>logical, convert colors to sRGB hex notation, sRGB coordinates, CIELAB coordinates</p>
</td></tr>
<tr><td><code id="parseMunsell_+3A_delim">delim</code></td>
<td>
<p>optional, specify the type of delimiter used between value and chroma parts of the Munsell code. By default &quot;:&quot;, &quot;,:, &quot;'&quot;, and &quot;/&quot; are supported.</p>
</td></tr>
<tr><td><code id="parseMunsell_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+munsell2rgb">munsell2rgb</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> object
</p>


<h3>Author(s)</h3>

<p>P. Roudier and D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# just sRGB
parseMunsell("10YR 3/5", return_triplets = TRUE)

# sRGB + CIELAB (D65 illuminant)
parseMunsell("10YR 3/5", return_triplets = TRUE, returnLAB = TRUE)

# CIELAB only
parseMunsell("10YR 3/5", return_triplets = FALSE, returnLAB = TRUE)

# neutral hue
# note chroma encoded as '0'
parseMunsell('N 3/', convertColors = FALSE)

</code></pre>

<hr>
<h2 id='pbindlist'>Combine a list of SoilProfileCollection objects</h2><span id='topic+pbindlist'></span>

<h3>Description</h3>

<p>See <code>combine(...)</code> for a connotative short-hand method that does not require that <code>SoilProfileCollection</code> be in a list. Profiles will be sorted based on character sorting of profile ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbindlist(l, new.idname = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbindlist_+3A_l">l</code></td>
<td>
<p>a list of SoilProfileCollection objects</p>
</td></tr>
<tr><td><code id="pbindlist_+3A_new.idname">new.idname</code></td>
<td>
<p>Optional: a character referring to a new column name to put unique profile IDs in; default: <code>NULL</code> to attempt with existing idname in first element</p>
</td></tr>
<tr><td><code id="pbindlist_+3A_verbose">verbose</code></td>
<td>
<p>Produce warnings and messages regarding results? default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data must share a common depth unit, and if spatial data are present, a common CRS and coordinate names. In the case of non-conformal @idname and/or @depthcols, the first SoilProfileCollection is used as a template. If one or more subsequent list elements has non-unique values in a site level attribute of that name, the ID name from the second list element is attempted, and so on. Non-conforming spatial data are dropped from the final result (returns default empty <code>SpatialPoints</code>).
</p>


<h3>Value</h3>

<p>a SoilProfileCollection object
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and A.G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
data(sp2, package = 'aqp')
depths(sp2) &lt;- id ~ top + bottom
site(sp2) &lt;- ~ surface

# copy pieces
x &lt;- sp2[1:5, ]
y &lt;- sp2[6:10, ]

# reset IDs and combine
profile_id(y) &lt;- sprintf("%s-copy", profile_id(y))

# this should work
z &lt;- pbindlist(list(x, y))

# check
plot(z)
</code></pre>

<hr>
<h2 id='pc'>Deprecated: Numerical Soil Profile Comparison</h2><span id='topic+pc'></span><span id='topic+pc.SPC'></span><span id='topic+profile_compare'></span><span id='topic+profile_compare+2CSoilProfileCollection-method'></span><span id='topic+profile_compare+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>See <code>NCSP()</code> for the modern interface to numerical soil profile comparison/classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc(
  s,
  vars,
  max_d,
  k,
  filter = NULL,
  sample_interval = NA,
  replace_na = TRUE,
  add_soil_flag = TRUE,
  return_depth_distances = FALSE,
  strict_hz_eval = FALSE,
  progress = "none",
  plot.depth.matrix = FALSE,
  rescale.result = FALSE,
  verbose = FALSE
)

pc.SPC(s, vars, rescale.result = FALSE, ...)

## S4 method for signature 'SoilProfileCollection'
profile_compare(s, vars, rescale.result = FALSE, ...)

## S4 method for signature 'data.frame'
profile_compare(
  s,
  vars,
  max_d,
  k,
  filter = NULL,
  sample_interval = NA,
  replace_na = TRUE,
  add_soil_flag = TRUE,
  return_depth_distances = FALSE,
  strict_hz_eval = FALSE,
  progress = "none",
  plot.depth.matrix = FALSE,
  rescale.result = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pc_+3A_s">s</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="pc_+3A_vars">vars</code></td>
<td>
<p>Variable names</p>
</td></tr>
<tr><td><code id="pc_+3A_max_d">max_d</code></td>
<td>
<p>depth-slices up to this depth are considered in the comparison</p>
</td></tr>
<tr><td><code id="pc_+3A_k">k</code></td>
<td>
<p>a depth-weighting coeficient, use '0' for no depth-weighting (see
examples below)</p>
</td></tr>
<tr><td><code id="pc_+3A_filter">filter</code></td>
<td>
<p>an index used to determine which horizons (rows) are included
in the analysis</p>
</td></tr>
<tr><td><code id="pc_+3A_sample_interval">sample_interval</code></td>
<td>
<p>use every n-th depth slice instead of every depth
slice, useful for working with &gt; 1000 profiles at a time</p>
</td></tr>
<tr><td><code id="pc_+3A_replace_na">replace_na</code></td>
<td>
<p>if TRUE, missing data are replaced by maximum
dissimilarity (TRUE)</p>
</td></tr>
<tr><td><code id="pc_+3A_add_soil_flag">add_soil_flag</code></td>
<td>
<p>The algorithm will generate a 'soil'/'non-soil' matrix
for use when comparing soil profiles with large differences in depth (TRUE).
See details section below.</p>
</td></tr>
<tr><td><code id="pc_+3A_return_depth_distances">return_depth_distances</code></td>
<td>
<p>return intermediate, depth-wise dissimilarity
results (FALSE)</p>
</td></tr>
<tr><td><code id="pc_+3A_strict_hz_eval">strict_hz_eval</code></td>
<td>
<p>should horizons be strictly checked for internal
self-consistency? (FALSE)</p>
</td></tr>
<tr><td><code id="pc_+3A_progress">progress</code></td>
<td>
<p>'none' (default)</p>
</td></tr>
<tr><td><code id="pc_+3A_plot.depth.matrix">plot.depth.matrix</code></td>
<td>
<p>should a plot of the 'soil'/'non-soil' matrix be
returned (FALSE)</p>
</td></tr>
<tr><td><code id="pc_+3A_rescale.result">rescale.result</code></td>
<td>
<p>Rescale result? Default: FALSE</p>
</td></tr>
<tr><td><code id="pc_+3A_verbose">verbose</code></td>
<td>
<p>extra debug output (FALSE)</p>
</td></tr>
<tr><td><code id="pc_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>profile_compare()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a numerical comparison of soil profiles using named properties,
based on a weighted, summed, depth-segment-aligned dissimilarity
calculation. If <code>s</code> is a <code><a href="#topic+SoilProfileCollection">SoilProfileCollection</a></code>,
site-level variables (2 or more) can also be used. The site-level and
horizon-level dissimilarity matrices are then re-scaled and averaged.
</p>
<p>Variability in soil depth can interfere significantly with the calculation
of between-profile dissimilarity&ndash; what is the numerical &ldquo;distance&rdquo; (or
dissimilarity) between a slice of soil from profile A and the corresponding,
but missing, slice from a shallower profile B? Gower's distance metric would
yield a NULL distance, despite the fact that intuition suggests otherwise:
shallower soils should be more dissimilar from deeper soils. For example,
when a 25 cm deep profile is compared with a 50 cm deep profile, numerical
distances are only accumulated for the first 25 cm of soil (distances from
26 - 50 cm are NULL). When summed, the total distance between these profiles
will generally be less than the distance between two profiles of equal
depth. Our algorithm has an option (setting replace_na=TRUE) to replace NULL
distances with the maximum distance between any pair of profiles for the
current depth slice. In this way, the numerical distance between a slice of
soil and a corresponding slice of non-soil reflects the fact that these two
materials should be treated very differently (i.e. maximum dissimilarity).
</p>
<p>This alternative calculation of dissimilarities between soil and non-soil
slices solves the problem of comparing shallow profiles with deeper
profiles. However, it can result in a new problem: distances calculated
between two shallow profiles will be erroneously inflated beyond the extent
of either profile's depth. Our algorithm has an additional option (setting
add_soil_flag=TRUE) that will preserve NULL distances between slices when
both slices represent non-soil material. With this option enabled, shallow
profiles will only accumulate mutual dissimilarity to the depth of the
deeper profile.
</p>
<p>Note that when the <code>add_soil_flag</code> option is enabled (default), slices
are classified as 'soil' down to the maximum depth to which at least one of
variables used in the dissimilarity calculation is not NA. This will cause
problems when profiles within a collection contain all NAs within the
columns used to determine dissimilarity. An approach for identifying and
removing these kind of profiles is presented in the examples section below.
</p>
<p>A notice is issued if there are any NA values within the matrix used for
distance calculations, as these values are optionally replaced by the max
dissimilarity.
</p>
<p>Our approach builds on the work of (Moore, 1972) and the previously
mentioned depth-slicing algorithm.
</p>


<h3>Value</h3>

<p>A dissimilarity matrix object of class 'dissimilarity, dist',
optionally scaled by max(D).
</p>


<h3>Author(s)</h3>

<p>Dylan E. Beaudette
</p>


<h3>References</h3>


<ul>
<li><p> D.E. Beaudette, P. Roudier, A.T. O'Geen, Algorithms for quantitative pedology: A toolkit for soil scientists, Computers &amp; Geosciences, Volume 52, 2013, Pages 258-268, ISSN 0098-3004, <a href="https://doi.org/10.1016/j.cageo.2012.10.020">doi:10.1016/j.cageo.2012.10.020</a>.
</p>
</li>
<li><p> Moore, A.; Russell, J. &amp; Ward, W. Numerical analysis of soils: A comparison of three soil profile models with field classification. Journal of Soil Science, 1972, 23, 194-209.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+slice">slice</a></code>, <code><a href="cluster.html#topic+daisy">daisy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?NCSP for examples
</code></pre>

<hr>
<h2 id='perturb'>Perturb soil horizon depths using boundary distinctness</h2><span id='topic+perturb'></span><span id='topic+permute_profile'></span>

<h3>Description</h3>

<p>&quot;Perturbs&quot; the <strong>boundary between horizons</strong> or the <strong>thickness of horizons</strong> using a standard deviation specified as a horizon-level attribute. This is selected using either <code>boundary.attr</code> or <code>thickness.attr</code> to specify the column name.
</p>
<p>The boundary standard deviation corresponds roughly to the concept of &quot;horizon boundary distinctness.&quot; In contrast, the <em>horizon thickness</em> standard deviation corresponds roughly to the &quot;variation in horizon thickness&quot; so it may be determined from several similar profiles that have a particular layer &quot;in common.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturb(
  p,
  n = 100,
  id = NULL,
  thickness.attr = NULL,
  boundary.attr = NULL,
  min.thickness = 1,
  max.depth = NULL,
  new.idname = "pID"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturb_+3A_p">p</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="perturb_+3A_n">n</code></td>
<td>
<p>Number of new profiles to generate (default: <code>100</code>) per profile in <code>p</code></p>
</td></tr>
<tr><td><code id="perturb_+3A_id">id</code></td>
<td>
<p>a vector of profile IDs with length equal to (<code>n</code>). Overrides use of <code>seq_len(n)</code> as default profile ID values.</p>
</td></tr>
<tr><td><code id="perturb_+3A_thickness.attr">thickness.attr</code></td>
<td>
<p>Horizon variance attribute containing numeric &quot;standard deviations&quot; reflecting horizon thickness</p>
</td></tr>
<tr><td><code id="perturb_+3A_boundary.attr">boundary.attr</code></td>
<td>
<p>Horizon variance attribute containing numeric &quot;standard deviations&quot; reflecting boundary transition distinctness</p>
</td></tr>
<tr><td><code id="perturb_+3A_min.thickness">min.thickness</code></td>
<td>
<p>Minimum thickness of permuted horizons (default: <code>1</code>)</p>
</td></tr>
<tr><td><code id="perturb_+3A_max.depth">max.depth</code></td>
<td>
<p>Depth below which horizon depths are not perturbed (default: <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="perturb_+3A_new.idname">new.idname</code></td>
<td>
<p>New column name to contain unique profile ID (default: <code>pID</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imagine a Normal curve with mean centered on the vertical (depth axis) at a representative value (RV) horizon bottom depth or thickness. By the Empirical Rule for Normal distribution, two &quot;standard deviations&quot; above or below that &quot;central&quot; mean value represent 95% of the &quot;typical volume&quot; of that horizon or boundary.
</p>
<p><code>perturb()</code> can leverage semi-quantitative (ordered factor) levels of boundary distinctness/topography for the upper and lower boundary of individual horizons. A handy function for this is <code><a href="#topic+hzDistinctnessCodeToOffset">hzDistinctnessCodeToOffset()</a></code>. The <code>boundary.attr</code> is arguably easier to parameterize from a single profile description or &quot;Form 232&quot; where <em>horizon boundary distinctness</em> classes (based on vertical distance of transition) are conventionally recorded for each layer.
</p>
<p>Alternately, <code>perturb()</code> can be parameterized using standard deviation in thickness of layers derived from a group. Say, the variance parameters are defined from a set of pedons correlated to a particular series or component, and the template &quot;seed&quot; profile is, for example, the Official Series Description or the Representative Component Pedon.
</p>


<h3>Value</h3>

<p>a SoilProfileCollection with <code>n</code> realizations of each profile in <code>p</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette, A.G. Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+random_profile">random_profile()</a></code> <code><a href="#topic+hzDistinctnessCodeToOffset">hzDistinctnessCodeToOffset()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### THICKNESS

# load sample data and convert into SoilProfileCollection
data(sp3)
depths(sp3) &lt;- id ~ top + bottom

# select a profile to use as the basis for simulation
s &lt;- sp3[3,]

# reset horizon names
s$name &lt;- paste('H', seq_along(s$name), sep = '')

# simulate 25 new profiles
horizons(s)$hz.sd &lt;- 2 # constant standard deviation
sim.1 &lt;- perturb(s, n = 25, thickness.attr = "hz.sd")

# simulate 25 new profiles using different SD for each horizon
horizons(s)$hz.sd &lt;- c(1, 2, 5, 5, 5, 10, 3)
sim.2 &lt;- perturb(s, n = 25, thickness.attr = "hz.sd")

# plot
par(mfrow = c(2, 1), mar = c(0, 0, 0, 0))
plot(sim.1)
mtext(
  'SD = 2',
  side = 2,
  line = -1.5,
  font = 2,
  cex = 0.75
)
plot(sim.2)
mtext(
  'SD = c(1, 2, 5, 5, 5, 10, 3)',
  side = 2,
  line = -1.5,
  font = 2,
  cex = 0.75
)

# aggregate horizonation of simulated data
# note: set class_prob_mode=2 as profiles were not defined to a constant depth
sim.2$name &lt;- factor(sim.2$name)
a &lt;- slab(sim.2, ~ name, cpm=2)

# convert to long format for plotting simplicity
library(data.table)
a.long &lt;- data.table::melt(data.table::as.data.table(a),
               id.vars = c('top', 'bottom'),
                measure.vars = levels(sim.2$name))

# plot horizon probabilities derived from simulated data
# dashed lines are the original horizon boundaries
library(lattice)

xyplot(
  top ~ value,
  groups = variable,
  data = a.long,
  subset = value &gt; 0,
  ylim = c(100,-5),
  type = c('l', 'g'),
  asp = 1.5,
  ylab = 'Depth (cm)',
  xlab = 'Probability',
  auto.key = list(
    columns = 4,
    lines = TRUE,
    points = FALSE
  ),
  panel = function(...) {
    panel.xyplot(...)
    panel.abline(h = s$top, lty = 2, lwd = 2)
  }
)

### BOUNDARIES

# example with sp1 (using boundary distinctness)
data("sp1")
depths(sp1) &lt;- id ~ top + bottom

# specify "standard deviation" for boundary thickness
#   consider a normal curve centered at boundary RV depth
# lookup table: ~maximum thickness of boundary distinctness classes, divided by 3
bound.lut &lt;- c('V'=0.5,'A'=2,'C'=5,'G'=15,'D'=45) / 3

## V          A          C          G          D
## 0.1666667  0.6666667  1.6666667  5.0000000 15.0000000

sp1$bound_sd &lt;- bound.lut[sp1$bound_distinct]

# hold any NA boundary distinctness constant
sp1$bound_sd[is.na(sp1$bound_sd)] &lt;- 0

quantile(sp1$bound_sd, na.rm = TRUE)
p &lt;- sp1[3]

# assume boundary sd is 1/12 midpoint of horizon depth
# (i.e. general relationship: SD increases (less well known) with depth)
sp1 &lt;- transform(sp1, midpt = (bottom - top) / 2 + top, bound_sd = midpt / 12)
quantile(sp1$bound_sd)

perturb(p, boundary.attr = "bound_sd", n = 10)


### Custom IDs

ids &lt;- sprintf("%s-%03d", profile_id(p), 1:10) 
perturb(p, boundary.attr = "bound_sd", id = ids)


</code></pre>

<hr>
<h2 id='ph_to_rxnclass'>Convert pH to/from Reaction Classes</h2><span id='topic+ph_to_rxnclass'></span><span id='topic+rxnclass_to_ph'></span><span id='topic+ReactionClassLevels'></span>

<h3>Description</h3>

<p>Convert pH to/from Reaction Classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph_to_rxnclass(x, halfclass = FALSE, as.is = FALSE, droplevels = TRUE)

rxnclass_to_ph(x, halfclass = FALSE, digits = 2, simplify = TRUE)

ReactionClassLevels(halfclass = FALSE, as.is = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ph_to_rxnclass_+3A_x">x</code></td>
<td>
<p>input pH values (numeric; <code>ph_to_rxnclass()</code>) or reaction classes (character; <code>rxnclass_to_ph()</code>)</p>
</td></tr>
<tr><td><code id="ph_to_rxnclass_+3A_halfclass">halfclass</code></td>
<td>
<p>Split the standard classes in half for higher resolution? Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ph_to_rxnclass_+3A_as.is">as.is</code></td>
<td>
<p>logical. Should character vectors be converted to factors? Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ph_to_rxnclass_+3A_droplevels">droplevels</code></td>
<td>
<p>logical. Drop unused levels in factors? Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ph_to_rxnclass_+3A_digits">digits</code></td>
<td>
<p>Number of digits after decimal place; Default: <code>2</code>. Used only for <code>rxnclass_to_ph()</code></p>
</td></tr>
<tr><td><code id="ph_to_rxnclass_+3A_simplify">simplify</code></td>
<td>
<p>Simplify list result to numeric vector when length of result is 1? Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ph_to_rxnclass()</code>: a vector of reaction classes corresponding to numeric input in <code>x</code>; if <code>as.is=FALSE</code> an ordered factor using <code>ReactionClassLevels()</code>
</p>
<p><code>rxnclass_to_ph()</code>: a list of data.frame objects containing high/low values of reaction class 1:1 with input; if simplify=TRUE and input is  a data.frame.
</p>
<p><code>ReactionClassLevels()</code>: ordered factor containing descriptive terms for reaction classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ph_to_rxnclass(6.2)
rxnclass_to_ph("slightly acid")

rxnclass_to_ph(list(c("Slightly Acid", NA, "Moderately Acid"),
                    c("Slightly Acid", NA, "Strongly Acid")), simplify = FALSE)
ReactionClassLevels()
</code></pre>

<hr>
<h2 id='plot_distance_graph'>Between Individual Distance Plot</h2><span id='topic+plot_distance_graph'></span>

<h3>Description</h3>

<p>Plot pair-wise distances between individuals as line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_distance_graph(D, idx = 1:dim(as.matrix((D)))[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_distance_graph_+3A_d">D</code></td>
<td>
<p>distance matrix, should be of class 'dist' or compatible class</p>
</td></tr>
<tr><td><code id="plot_distance_graph_+3A_idx">idx</code></td>
<td>
<p>an integer sequence defining which individuals should be compared</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default all individuals are plotting on the same axis. When there are
more than about 10 individuals, the plot can become quite messy. See
examples below for ideas.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Dylan E Beaudette
</p>


<h3>References</h3>

<p>http://casoilresource.lawr.ucdavis.edu/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sp2">sp2</a></code>, <code><a href="#topic+profile_compare">profile_compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp2)
depths(sp2) &lt;- id ~ top + bottom
d &lt;- NCSP(
  sp2,
  vars = c('prop', 'field_ph', 'hue', 'value'),
  maxDepth = 100,
  k = 0.01
)

par(mfcol=c(3,1), mar=c(2.5,4.5,1,1))
plot_distance_graph(d, idx=1:6)
plot_distance_graph(d, idx=7:12)
plot_distance_graph(d, idx=12:18)
</code></pre>

<hr>
<h2 id='plotColorMixture'>Visualize Spectral Mixing of Munsell Colors</h2><span id='topic+plotColorMixture'></span>

<h3>Description</h3>

<p>Lattice visualization demonstrating subtractive mixtures of colors in Munsell notation and associated spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotColorMixture(
  x,
  w = rep(1, times = length(x))/length(x),
  mixingMethod = c("exact", "reference"),
  n = 1,
  swatch.cex = 1.5,
  label.cex = 0.85,
  showMixedSpec = FALSE,
  overlapFix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotColorMixture_+3A_x">x</code></td>
<td>
<p>vector of colors in Munsell notation, should not contain duplicates</p>
</td></tr>
<tr><td><code id="plotColorMixture_+3A_w">w</code></td>
<td>
<p>vector of weights, can sum to any number</p>
</td></tr>
<tr><td><code id="plotColorMixture_+3A_mixingmethod">mixingMethod</code></td>
<td>
<p>approach used to simulate a mixture:
</p>

<ul>
<li> <p><code>exact</code>: simulate a subtractive mixture of pigments, color conversion via CIE1931 color-matching functions (see <code><a href="#topic+mixMunsell">mixMunsell()</a></code>)
</p>
</li>
<li> <p><code>reference</code>  : simulate a subtractive mixture of pigments, selecting <code>n</code> closest reference spectra, requires <code>gower</code> package
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotColorMixture_+3A_n">n</code></td>
<td>
<p>number of closest mixture candidates when <code>mixingMethod = 'reference'</code> (see <code><a href="#topic+mixMunsell">mixMunsell()</a></code>), results can be hard to interpret when <code>n &gt; 2</code></p>
</td></tr>
<tr><td><code id="plotColorMixture_+3A_swatch.cex">swatch.cex</code></td>
<td>
<p>scaling factor for color swatch rectangle width and height, relative to <code>label.cex</code>, typically between 1 and 3</p>
</td></tr>
<tr><td><code id="plotColorMixture_+3A_label.cex">label.cex</code></td>
<td>
<p>scaling factor for swatch labels</p>
</td></tr>
<tr><td><code id="plotColorMixture_+3A_showmixedspec">showMixedSpec</code></td>
<td>
<p>show weighted geometric mean (mixed) spectra as dotted line (only when <code>mixingMethod = 'reference'</code>)</p>
</td></tr>
<tr><td><code id="plotColorMixture_+3A_overlapfix">overlapFix</code></td>
<td>
<p>attempt to &quot;fix&quot; overlapping chip labels via <code><a href="#topic+fixOverlap">fixOverlap()</a></code>, using <code>method = 'E'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If present, <code>names</code> attribute of <code>x</code> is used for the figure legend. See the <a href="https://ncss-tech.github.io/AQP/aqp/mix-colors.html">expanded tutorial</a> for examples.
</p>


<h3>Value</h3>

<p>a <code>lattice</code> graphics object
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mixMunsell">mixMunsell()</a></code>
</p>

<hr>
<h2 id='plotColorQuantiles'>Visualize Color Quantiles</h2><span id='topic+plotColorQuantiles'></span>

<h3>Description</h3>

<p>This function creates a visualization of the output from <code>colorQuantiles</code> using lattice graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotColorQuantiles(res, pt.cex = 7, lab.cex = 0.66)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotColorQuantiles_+3A_res">res</code></td>
<td>
<p>list returned by <code>colorQuantiles</code></p>
</td></tr>
<tr><td><code id="plotColorQuantiles_+3A_pt.cex">pt.cex</code></td>
<td>
<p>scaling factor for color chips</p>
</td></tr>
<tr><td><code id="plotColorQuantiles_+3A_lab.cex">lab.cex</code></td>
<td>
<p>chip label scaling factor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Marginal percentiles and L1 median CIELAB values from <code>colorQuantiles()</code> are combined into a single plot, arranged in panels according to L, A, and B coordinates. Munsell &quot;chips&quot; (colors and labels) are based on the closest Munsell color found via <code><a href="#topic+col2Munsell">col2Munsell()</a></code>.
</p>


<h3>Value</h3>

<p>a <code>lattice</code> graphics object
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>

<hr>
<h2 id='plotMultipleSPC'>Plot Multiple <code>SoilProfileCollection</code> Objects</h2><span id='topic+plotMultipleSPC'></span>

<h3>Description</h3>

<p>Plot Multiple <code>SoilProfileCollection</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMultipleSPC(
  spc.list,
  group.labels,
  args = rep(list(NA), times = length(spc.list)),
  merged.legend = NULL,
  merged.colors = c("#5E4FA2", "#3288BD", "#66C2A5", "#ABDDA4", "#E6F598", "#FEE08B",
    "#FDAE61", "#F46D43", "#D53E4F", "#9E0142"),
  merged.legend.title = merged.legend,
  arrow.offset = 2,
  bracket.base.depth = 95,
  label.offset = 2,
  label.cex = 0.75,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMultipleSPC_+3A_spc.list">spc.list</code></td>
<td>
<p>a list of <code>SoilProfileCollection</code> objects</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_group.labels">group.labels</code></td>
<td>
<p>a vector of group labels, one for each
<code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_args">args</code></td>
<td>
<p>a list of arguments passed to <code>plotSPC</code>, one for each
<code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_merged.legend">merged.legend</code></td>
<td>
<p>name of a horizon level attribute from which to create thematic sketches and merged legend</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_merged.colors">merged.colors</code></td>
<td>
<p>vector of colors used to create thematic sketches from a shared horizon level attribute</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_merged.legend.title">merged.legend.title</code></td>
<td>
<p>legend title</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_arrow.offset">arrow.offset</code></td>
<td>
<p>vertical offset in depth from base of start / end
profiles and group bracket arrows</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_bracket.base.depth">bracket.base.depth</code></td>
<td>
<p>baseline depth used for group brackets</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_label.offset">label.offset</code></td>
<td>
<p>vertical offset of group labels from baseline</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_label.cex">label.cex</code></td>
<td>
<p>label size</p>
</td></tr>
<tr><td><code id="plotMultipleSPC_+3A_...">...</code></td>
<td>
<p>additional arguments to the first call to <code>plotSPC</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combine multiple <code>SoilProfileCollection</code> objects into a single profile sketch,
with annotated groups.
</p>
<p>See examples below for usage.
</p>


<h3>Note</h3>

<p>For thematic sketches, use the <code>merged.legend</code> argument instead of <code>color</code> argument to <code>plotSPC</code>
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and Ben Marshall
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profileGroupLabels">profileGroupLabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
## Simple Example
##

# using default arguments to plotSPC()

# load sample data
data(sp3)
data(sp4)

# promote to SoilProfileCollection
depths(sp3) &lt;- id ~ top + bottom
depths(sp4) &lt;- id ~ top + bottom

# combine into a list
spc.list &lt;- list(sp3, sp4)

# argument list
arg.list &lt;- list(
  list(name='name', id.style='top'),
  list(name='name', id.style='side')
)

# plot multiple SPC objects, 
# with list of named arguments for each call to plotSPC
par(mar=c(1,1,3,3))
plotMultipleSPC(
  spc.list, 
  group.labels = c('Collection 1', 'Collection 2'),
  args = arg.list, 
  bracket.base.depth = 120, label.cex = 1
)

# specify a different max.depth
plotMultipleSPC(
  spc.list, 
  group.labels = c('Collection 1', 'Collection 2'),
  args = arg.list, 
  bracket.base.depth = 120, label.cex = 1,
  max.depth = 250
)



##
## Merged Legend Example
##

# merged legend based on hz attribute 'clay'

# reset sample data
data(sp3)
data(sp4)

# promote to SoilProfileCollection
depths(sp3) &lt;- id ~ top + bottom
depths(sp4) &lt;- id ~ top + bottom

# combine into a list
spc.list &lt;- list(sp3, sp4)

# argument list
arg.list &lt;- list(
  list(name='name', id.style='top'),
  list(name='name', id.style='side')
)


par(mar=c(1,1,3,3))
plotMultipleSPC(
  spc.list, 
  group.labels = c('Collection 1', 'Collection 2'),
  args = arg.list, 
  label.cex = 1, 
  merged.legend = 'clay', merged.legend.title = 'Clay (%)'
)


##
## Complex Merged Legend Example
##

# create a merged legend from "clay" in sp4 and jacobs2000
# use "soil_color" from sp3

# reset sample data
data(sp3)
data(sp4)
data(jacobs2000)

# promote to SoilProfileCollection
depths(sp3) &lt;- id ~ top + bottom
depths(sp4) &lt;- id ~ top + bottom

# remove 'clay' column from sp3
sp3$clay &lt;- NULL

# combine into a list
spc.list &lt;- list(sp3, sp4, jacobs2000)

# try some variations on the default arguments
# `clay` is missing in the first SPC, safe to specify another column for colors
arg.list &lt;- list(
  list(color = 'soil_color', id.style='top', name = NA, width = 0.3, hz.depths = TRUE),
  list(name='name', id.style='side', name.style = 'center-center'),
  list(name='name', id.style='side', name.style = 'left-center', hz.depths = TRUE)
)

par(mar=c(1,1,3,3))
plotMultipleSPC(
  spc.list, 
  group.labels = c('sp3', 'sp4', 'jacobs2000'),
  label.offset = 3,
  args = arg.list, 
  merged.legend = 'clay', merged.legend.title = 'Clay (%)',
  depth.axis = list(line = 0)
)
</code></pre>

<hr>
<h2 id='plotSPC'>Create Soil Profile Sketches</h2><span id='topic+plotSPC'></span><span id='topic+plot+2CSoilProfileCollection+2CANY-method+2Cplot.SoilProfileCollection'></span><span id='topic+plot'></span><span id='topic+plot+2CSoilProfileCollection-method'></span><span id='topic+plot+2CSoilProfileCollection+2CANY-method'></span>

<h3>Description</h3>

<p>Generate a diagram of soil profile sketches from a <code>SoilProfileCollection</code> object. The <a href="http://ncss-tech.github.io/aqp/articles/Introduction-to-SoilProfileCollection-Objects.html">Introduction to SoilProfileCollection Objects Vignette</a> contains many examples and discussion of the large number of arguments to this function. The <a href="https://ncss-tech.github.io/AQP/aqp/sketches.html">Soil Profile Sketches</a> tutorial has longer-form discussion and examples pertaining to suites of related arguments.
</p>
<p>Options can be used to conveniently specify sets of arguments that will be used in several calls to <code>plotSPC()</code> within a single R session. For example, arguments can be specified in a named list (<code>.a</code>) and set using: <code>options(.aqp.plotSPC.args = .a)</code>. Reset these options via <code>options(.aqp.plotSPC.args = NULL)</code>. Arguments explicitly passed to <code>plotSPC()</code> will override arguments set via <code><a href="base.html#topic+options">options()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSPC(
  x,
  color = "soil_color",
  width = ifelse(length(x) &lt; 2, 0.15, 0.25),
  name = hzdesgnname(x),
  name.style = "right-center",
  label = idname(x),
  raggedBottom = NULL,
  hz.depths = FALSE,
  hz.depths.offset = ifelse(fixLabelCollisions, 0.03, 0),
  hz.depths.lines = fixLabelCollisions,
  depth.axis = list(style = "traditional", cex = cex.names * 1.15),
  alt.label = NULL,
  alt.label.col = "black",
  cex.names = 0.5,
  cex.id = cex.names + (0.2 * cex.names),
  font.id = 2,
  srt.id = 0,
  print.id = TRUE,
  id.style = "auto",
  plot.order = 1:length(x),
  relative.pos = 1:length(x),
  add = FALSE,
  scaling.factor = 1,
  y.offset = rep(0, times = length(x)),
  x.idx.offset = 0,
  n = length(x),
  max.depth = ifelse(is.infinite(max(x)), 200, max(x)),
  n.depth.ticks = 10,
  shrink = FALSE,
  shrink.cutoff = 3,
  shrink.thin = NULL,
  abbr = FALSE,
  abbr.cutoff = 5,
  divide.hz = TRUE,
  hz.distinctness.offset = NULL,
  hz.topography.offset = NULL,
  hz.boundary.lty = NULL,
  density = NULL,
  show.legend = TRUE,
  col.label = color,
  col.palette = c("#5E4FA2", "#3288BD", "#66C2A5", "#ABDDA4", "#E6F598", "#FEE08B",
    "#FDAE61", "#F46D43", "#D53E4F", "#9E0142"),
  col.palette.bias = 1,
  col.legend.cex = 1,
  n.legend = 8,
  lwd = 1,
  lty = 1,
  default.color = grey(0.95),
  fixLabelCollisions = hz.depths,
  fixOverlapArgs = list(method = "E", q = 1),
  cex.depth.axis = cex.names,
  axis.line.offset = -2,
  plot.depth.axis = TRUE,
  ...
)

## S4 method for signature 'SoilProfileCollection,ANY'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSPC_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_color">color</code></td>
<td>
<p>quoted column name containing R-compatible color descriptions, or numeric / categorical data to be displayed thematically; see details</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_width">width</code></td>
<td>
<p>scaling of profile widths (typically 0.1 - 0.4)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_name">name</code></td>
<td>
<p>quoted column name of the (horizon-level) attribute containing horizon designations or labels, if missing <code>hzdesgnname(x)</code> is used. Suppress horizon name printing by setting <code>name = NA</code> or <code>name = ''</code>.</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_name.style">name.style</code></td>
<td>
<p>one of several possible horizon designations labeling styles: <code>c('right-center', 'left-center', 'left-top', 'center-center', 'center-top')</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_label">label</code></td>
<td>
<p>quoted column name of the (site-level) attribute used to identify profile sketches</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_raggedbottom">raggedBottom</code></td>
<td>
<p>either quoted column name of the (site-level) attribute (logical) used to mark profiles with a truncated lower boundary, or <code>FALSE</code> suppress ragged bottom depths when <code>max.depth &lt; max(x)</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_hz.depths">hz.depths</code></td>
<td>
<p>logical, annotate horizon top depths to the right of each sketch (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_hz.depths.offset">hz.depths.offset</code></td>
<td>
<p>numeric, user coordinates for left-right adjustment for horizon depth annotation; reasonable values are usually within 0.01-0.05 (default: 0)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_hz.depths.lines">hz.depths.lines</code></td>
<td>
<p>logical, draw segments between horizon depth labels and actual horizon depth; this is useful when including horizon boundary distinctness and/or <code>fixLabelCollisions = TRUE</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_depth.axis">depth.axis</code></td>
<td>
<p>logical or list. Use a logical to suppress (<code>FALSE</code>) or add depth axis using defaults (<code>TRUE</code>). Use a list to specify one or more of:
</p>

<ul>
<li> <p><code>style</code>: character, one of 'traditional', 'compact', or 'tape'
</p>
</li>
<li> <p><code>line</code>: numeric, negative values move axis to the left (does not apply to <code>style = 'tape'</code>)
</p>
</li>
<li> <p><code>cex</code>: numeric, scaling applied to entire depth axis
</p>
</li>
<li> <p><code>interval</code>: numeric, axis interval
See examples.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotSPC_+3A_alt.label">alt.label</code></td>
<td>
<p>quoted column name of the (site-level) attribute used for secondary annotation</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_alt.label.col">alt.label.col</code></td>
<td>
<p>color used for secondary annotation text</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_cex.names">cex.names</code></td>
<td>
<p>baseline character scaling applied to all text labels</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_cex.id">cex.id</code></td>
<td>
<p>character scaling applied to <code>label</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_font.id">font.id</code></td>
<td>
<p>font style applied to <code>label</code>, default is 2 (bold)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_srt.id">srt.id</code></td>
<td>
<p>rotation applied to <code>label</code>, only when <code>id.style = 'top'</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_print.id">print.id</code></td>
<td>
<p>logical, print <code>label</code> above/beside each profile? (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_id.style">id.style</code></td>
<td>
<p><code>label</code> printing style: 'auto' (default) = simple heuristic used to select from: 'top' = centered above each profile, 'side' = 'along the top-left edge of profiles'</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_plot.order">plot.order</code></td>
<td>
<p>integer vector describing the order in which individual soil profiles should be plotted</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_relative.pos">relative.pos</code></td>
<td>
<p>vector of relative positions along the x-axis, within {1, n}, ignores <code>plot.order</code> see details</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_add">add</code></td>
<td>
<p>logical, add to an existing figure</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_scaling.factor">scaling.factor</code></td>
<td>
<p>vertical scaling of profile depths, useful for adding profiles to an existing figure</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_y.offset">y.offset</code></td>
<td>
<p>numeric vector of vertical offset for top of profiles in depth units of <code>x</code>, can either be a single numeric value or vector of length = <code>length(x)</code>. A vector of y-offsets will be automatically re-ordered according to <code>plot.order</code>.</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_x.idx.offset">x.idx.offset</code></td>
<td>
<p>integer specifying horizontal offset from 0 (left-hand edge)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_n">n</code></td>
<td>
<p>integer describing amount of space along x-axis to allocate, defaults to <code>length(x)</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_max.depth">max.depth</code></td>
<td>
<p>numeric. The lower depth for all sketches, deeper profiles are truncated at this depth. Use larger values to arbitrarily extend the vertical dimension, convenient for leaving extract space for annotation.</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_n.depth.ticks">n.depth.ticks</code></td>
<td>
<p>suggested number of ticks in depth scale</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_shrink">shrink</code></td>
<td>
<p>logical, reduce character scaling for 'long' horizon by 80%</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_shrink.cutoff">shrink.cutoff</code></td>
<td>
<p>character length defining 'long' horizon names</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_shrink.thin">shrink.thin</code></td>
<td>
<p>integer, horizon thickness threshold for shrinking horizon names by 80%, only activated when <code>shrink = TRUE</code> (<code>NULL</code> = no shrinkage)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_abbr">abbr</code></td>
<td>
<p>logical, abbreviate <code>label</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_abbr.cutoff">abbr.cutoff</code></td>
<td>
<p>suggested minimum length for abbreviated <code>label</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_divide.hz">divide.hz</code></td>
<td>
<p>logical, divide horizons with line segment? (<code>TRUE</code>), see details</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_hz.distinctness.offset">hz.distinctness.offset</code></td>
<td>
<p><code>NULL</code>, or quoted column name (horizon-level attribute) containing vertical offsets used to depict horizon boundary distinctness (same units as profiles), see details and <code><a href="#topic+hzDistinctnessCodeToOffset">hzDistinctnessCodeToOffset()</a></code>; consider setting <code>hz.depths.lines = TRUE</code> when used in conjunction with <code>hz.depths = TRUE</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_hz.topography.offset">hz.topography.offset</code></td>
<td>
<p><code>NULL</code>, or quoted column name (horizon-level attribute) containing offsets used to depict horizon boundary topography (same units as profiles), see details and <code><a href="#topic+hzTopographyCodeToOffset">hzTopographyCodeToOffset()</a></code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_hz.boundary.lty">hz.boundary.lty</code></td>
<td>
<p>quoted column name (horizon-level attribute) containing line style (integers) used to encode horizon topography</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_density">density</code></td>
<td>
<p>fill density used for horizon color shading, either a single integer or a quoted column name (horizon-level attribute) containing integer values (default is <code>NULL</code>, no shading)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_show.legend">show.legend</code></td>
<td>
<p>logical, show legend? (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_col.label">col.label</code></td>
<td>
<p>thematic legend title</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_col.palette">col.palette</code></td>
<td>
<p>color palette used for thematic sketches (default is <code>rev(brewer.pal(10, 'Spectral'))</code>)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_col.palette.bias">col.palette.bias</code></td>
<td>
<p>color ramp bias (skew), see <code><a href="grDevices.html#topic+colorRamp">colorRamp()</a></code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_col.legend.cex">col.legend.cex</code></td>
<td>
<p>scaling of thematic legend</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_n.legend">n.legend</code></td>
<td>
<p>approximate number of classes used in numeric legend, max number of items per row in categorical legend</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_lwd">lwd</code></td>
<td>
<p>line width multiplier used for sketches</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_lty">lty</code></td>
<td>
<p>line style used for sketches</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_default.color">default.color</code></td>
<td>
<p>default horizon fill color used when <code>color</code> attribute is <code>NA</code></p>
</td></tr>
<tr><td><code id="plotSPC_+3A_fixlabelcollisions">fixLabelCollisions</code></td>
<td>
<p>use <code><a href="#topic+fixOverlap">fixOverlap()</a></code> to attempt fixing hz depth labeling collisions, will slow plotting of large collections; enabling also sets <code>hz.depths.lines = TRUE</code>. Additional arguments to <code><a href="#topic+fixOverlap">fixOverlap()</a></code> can be passed via <code>fixOverlapArgs</code>. Overlap collisions cannot be fixed within profiles containing degenerate or missing horizon depths (e.g. top == bottom).</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_fixoverlapargs">fixOverlapArgs</code></td>
<td>
<p>a named list of arguments to <code><a href="#topic+fixOverlap">fixOverlap()</a></code>. Overlap adjustments are attempted using electrostatic simulation with arguments: <code>list(method = 'E', q = 1)</code>. Alternatively, select adjustment by simulated annealing via <code>list(method = 'S')</code>. See <code><a href="#topic+electroStatics_1D">electroStatics_1D()</a></code> and <code><a href="#topic+SANN_1D">SANN_1D()</a></code> for details.</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_cex.depth.axis">cex.depth.axis</code></td>
<td>
<p>(deprecated, use <code>depth.axis</code> instead) character scaling applied to depth scale</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_axis.line.offset">axis.line.offset</code></td>
<td>
<p>(deprecated, use <code>depth.axis</code> instead) horizontal offset applied to depth axis (default is -2, larger numbers move the axis to the right)</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_plot.depth.axis">plot.depth.axis</code></td>
<td>
<p>(deprecated, use <code>depth.axis</code> instead) logical, plot depth axis?</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_...">...</code></td>
<td>
<p>other arguments passed into lower level plotting functions</p>
</td></tr>
<tr><td><code id="plotSPC_+3A_y">y</code></td>
<td>
<p>(not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depth limits (<code>max.depth</code>) and number of depth ticks (<code>n.depth.ticks</code>) are <em>suggestions</em> to the <code><a href="base.html#topic+pretty">pretty()</a></code> function. You may have to tinker with both parameters to get what you want.
</p>
<p>The 'side' <code>id.style</code> is useful when plotting a large collection of profiles, and/or, when profile IDs are long.
</p>
<p>If the column containing horizon designations is not specified (the <code>name</code> argument), a column (presumed to contain horizon designation labels) is guessed based on regular expression matching of the pattern 'name'&ndash;this usually works, but it is best to manual specify the name of the column containing horizon designations.
</p>
<p>The <code>color</code> argument can either name a column containing R-compatible colors, possibly created via <code><a href="#topic+munsell2rgb">munsell2rgb()</a></code>, or column containing either numeric or categorical (either factor or character) values. In the second case, values are converted into colors and displayed along with a simple legend above the plot. Note that this functionality makes several assumptions about plot geometry and is most useful in an interactive setting.
</p>
<p>Adjustments to the legend can be specified via <code>col.label</code> (legend title), <code>col.palette</code> (palette of colors, automatically expanded), <code>col.legend.cex</code> (legend scaling), and <code>n.legend</code> (approximate number of classes for numeric variables, or, maximum number of legend items per row for categorical variables). Currently, <code>plotSPC</code> will only generate two rows of legend items. Consider reducing the number of classes if two rows isn't enough room.
</p>
<p>Profile sketches can be added according to relative positions along the x-axis (vs. integer sequence) via <code>relative.pos</code> argument. This should be a vector of positions within {1,n} that are used for horizontal placement. Default values are <code>1:length(x)</code>. Care must be taken when both <code>plot.order</code> and <code>relative.pos</code> are used simultaneously: <code>relative.pos</code> specifies horizontal placement after sorting. <code><a href="#topic+addDiagnosticBracket">addDiagnosticBracket()</a></code> and <code><a href="#topic+addVolumeFraction">addVolumeFraction()</a></code> use the <code>relative.pos</code> values for subsequent annotation.
</p>
<p>Relative positions that are too close will result in overplotting of sketches. Adjustments to relative positions such that overlap is minimized can be performed with <code>fixOverlap(pos)</code>, where <code>pos</code> is the original vector of relative positions.
</p>
<p>The <code>x.idx.offset</code> argument can be used to shift a collection of pedons from left to right in the figure. This can be useful when plotting several different <code>SoilProfileCollection</code> objects within the same figure. Space must be pre-allocated in the first plotting call, with an offset specified in the second call. See examples below.
</p>
<p>Horizon depths (e.g. cm) are converted to figure y-coordinates via: y = (depth * scaling.factor) + y.offset.
</p>


<h3>Note</h3>

<p>A new plot of soil profiles is generated, or optionally added to an existing plot.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>Beaudette, D.E., Roudier P., and A.T. O'Geen. 2013. Algorithms for Quantitative Pedology: A Toolkit for
Soil Scientists. Computers &amp; Geosciences. 52:258 - 268.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixOverlap">fixOverlap()</a></code>, <code><a href="#topic+explainPlotSPC">explainPlotSPC()</a></code>, <a href="#topic+SoilProfileCollection-class">SoilProfileCollection</a>, <code><a href="base.html#topic+pretty">pretty()</a></code>, <code><a href="#topic+hzDistinctnessCodeToOffset">hzDistinctnessCodeToOffset()</a></code>, <code><a href="#topic+addBracket">addBracket()</a></code>, <code><a href="#topic+profileGroupLabels">profileGroupLabels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))


# example data
data(sp1)
# usually best to adjust margins
par(mar = c(0,0,3,0))

# add color vector
sp1$soil_color &lt;- with(sp1, munsell2rgb(hue, value, chroma))

# promote to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom

# init horizon designation 
hzdesgnname(sp1) &lt;- 'name'

# plot profiles
plotSPC(sp1, id.style = 'side')

# title, note line argument:
title('Sample Data 1', line = 1, cex.main = 0.75)

# plot profiles without horizon-line divisions
plotSPC(sp1, divide.hz = FALSE)

# diagonal lines encode horizon boundary distinctness
sp1$hzD &lt;- hzDistinctnessCodeToOffset(sp1$bound_distinct)
plotSPC(sp1, hz.distinctness.offset = 'hzD', name.style = 'center-center')

# plot horizon color according to some property
data(sp4)
depths(sp4) &lt;- id ~ top + bottom
hzdesgnname(sp4) &lt;- 'name'
plotSPC(sp4, color = 'clay')

# another example
data(sp2)
depths(sp2) &lt;- id ~ top + bottom
hzdesgnname(sp2) &lt;- 'name'
site(sp2) &lt;- ~ surface

# some of these profiles are very deep, truncate plot at 400cm
# label / re-order with site-level attribute: `surface`
plotSPC(sp2, label = 'surface', plot.order = order(sp2$surface), 
max.depth = 400)

# example using a categorical attribute
plotSPC(sp2, color = "plasticity", 
max.depth = 400)

# plot two SPC objects in the same figure
par(mar = c(1,1,1,1))

# plot the first SPC object and
# allocate space for the second SPC object
plotSPC(sp1, n = length(sp1) + length(sp2))

# plot the second SPC, starting from the first empty space
plotSPC(sp2, x.idx.offset = length(sp1), add = TRUE)


##
## demonstrate horizon designation shrinkage
##

data("jacobs2000")

# shrink "long" horizon names
plotSPC(
  jacobs2000, 
  name = 'name',
  name.style = 'center-center', 
  shrink = TRUE, 
  cex.names = 0.8
)

# shrink horizon names in "thin" horizons
plotSPC(
  jacobs2000, 
  name = 'name',
  name.style = 'center-center', 
  shrink = TRUE, 
  shrink.thin = 15,
  cex.names = 0.8,
)


##
## demonstrate adaptive legend
##

data(sp3)
depths(sp3) &lt;- id ~ top + bottom

# make some fake categorical data
horizons(sp3)$fake.data &lt;- sample(letters[1:15], size = nrow(sp3), replace=TRUE)

# better margins
par(mar=c(0,0,3,1))

# note that there are enough colors for 15 classes (vs. previous limit of 10)
# note that the legend is split into 2 rows when length(classes) &gt; n.legend argument
plotSPC(sp3, color='fake.data', name='fake.data', cex.names=0.8)

# make enough room in a single legend row
plotSPC(sp3, color='fake.data', name='fake.data', cex.names=0.8, n.legend=15)


##
## demonstrate y.offset argument
## must be of length 1 or length(x)
##

# example data and local copy
data("jacobs2000")
x &lt;- jacobs2000
hzdesgnname(x) &lt;- 'name'

# y-axis offsets, simulating a elevation along a hillslope sequence
# same units as horizon depths in `x`
# same order as profiles in `x`
y.offset &lt;- c(-5, -10, 22, 65, 35, 15, 12)

par(mar = c(0, 0, 2, 2))

# y-offset at 0
plotSPC(x, color = 'matrix_color', cex.names = 0.66)

# constant adjustment to y-offset
plotSPC(x, color = 'matrix_color', cex.names = 0.66, y.offset = 50)

# attempt using invalid y.offset
# warning issued and default value of '0' used
# plotSPC(x, color = 'matrix_color', cex.names = 0.66, y.offset = 1:2)

# variable y-offset
# fix overlapping horizon depth labels
par(mar = c(0, 0, 1, 0))
plotSPC(
  x, 
  y.offset = y.offset, 
  color = 'matrix_color', 
  cex.names = 0.75, 
  shrink = TRUE,
  hz.depths = TRUE, 
  hz.depths.offset = 0.05,
  fixLabelCollisions = TRUE,
  name.style = 'center-center'
)



# random y-axis offsets
yoff &lt;- runif(n = length(x), min = 1, max = 100)

# random gradient of x-positions
xoff &lt;- runif(n = length(x), min = 1, max = length(x))

# note profiles overlap
plotSPC(x, 
        relative.pos = xoff, 
        y.offset = yoff, 
        color = 'matrix_color', 
        cex.names = 0.66, 
        hz.depths = TRUE, 
        name.style = 'center-center'
)


# align / adjust relative x positions
set.seed(111)
pos &lt;- alignTransect(xoff, x.min = 1, x.max = length(x), thresh = 0.65)

# y-offset is automatically re-ordered according to
# plot.order

par(mar = c(0.5, 0.5, 0.5, 0.5))
plotSPC(x, 
        plot.order = pos$order, 
        relative.pos = pos$relative.pos, 
        y.offset = yoff, 
        color = 'matrix_color', 
        cex.names = 0.66, 
        hz.depths = TRUE, 
        name.style = 'center-center'
)

box()

</code></pre>

<hr>
<h2 id='previewColors'>Preview Colors</h2><span id='topic+previewColors'></span>

<h3>Description</h3>

<p>Preview colors arranged according to CIE2000 distances or manual specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>previewColors(
  cols,
  method = c("grid", "MDS", "manual"),
  labels = NULL,
  labels.cex = 1,
  col.order = NULL,
  nrow = ceiling(sqrt(length(cols))),
  ncol = nrow,
  border.col = "black",
  pt.cex = 2,
  pt.pch = 15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="previewColors_+3A_cols">cols</code></td>
<td>
<p>vector of R colors</p>
</td></tr>
<tr><td><code id="previewColors_+3A_method">method</code></td>
<td>
<p>either &quot;grid&quot;, &quot;MDS&quot;, or &quot;manual&quot;, see details</p>
</td></tr>
<tr><td><code id="previewColors_+3A_labels">labels</code></td>
<td>
<p>optional vector of labels, disabled when <code>length(cols) &gt; 5000</code></p>
</td></tr>
<tr><td><code id="previewColors_+3A_labels.cex">labels.cex</code></td>
<td>
<p>scaling factor for labels</p>
</td></tr>
<tr><td><code id="previewColors_+3A_col.order">col.order</code></td>
<td>
<p>integer vector used to order colors</p>
</td></tr>
<tr><td><code id="previewColors_+3A_nrow">nrow</code></td>
<td>
<p>number of rows used by &quot;grid&quot; method</p>
</td></tr>
<tr><td><code id="previewColors_+3A_ncol">ncol</code></td>
<td>
<p>number of columns used by &quot;grid&quot; method</p>
</td></tr>
<tr><td><code id="previewColors_+3A_border.col">border.col</code></td>
<td>
<p>border color used by &quot;grid&quot; method</p>
</td></tr>
<tr><td><code id="previewColors_+3A_pt.cex">pt.cex</code></td>
<td>
<p>point scaling factor used by &quot;MDS&quot; method</p>
</td></tr>
<tr><td><code id="previewColors_+3A_pt.pch">pt.pch</code></td>
<td>
<p>point symbol used by &quot;MDS&quot; method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Color sorting is based on CIE2000 distances as calculated by <code>farver::compare_colour()</code>. The &quot;grid&quot; method arranges colors in a rectangular grid with ordering based on divisive hierarchical clustering of the pair-wise distances. Unique colors are used when <code>cols</code> contains more than 5,000 colors.
</p>
<p>The &quot;MDS&quot; method arranges unique colors via classical multidimensional scaling (principal coordinates) via <code>cmdscale()</code>.
</p>
<p>Colors can be manually arranged by supplying a vector of integers to <code>col.order</code> and setting <code>method='manual'</code>.
</p>


<h3>Value</h3>

<p>When <code>method = "grid" or "manual"</code> a vector of color order is returned. When <code>method = "MDS"</code>, the output from <code>MASS::cmdscale</code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example data
data(sp2)

# convert into SoilProfileCollection object
depths(sp2) &lt;- id ~ top + bottom

previewColors(sp2$soil_color)
previewColors(sp2$soil_color, method = 'MDS', pt.cex = 3)

# create colors using HCL space
cols.hcl &lt;- hcl(h = 0:360, c = 100, l = 50)

# grid, colors sorted by dE00
previewColors(cols.hcl)

# manual specification
previewColors(cols.hcl, method = 'manual', col.order = 1:361)

# MDS
previewColors(cols.hcl, method = 'MDS', pt.cex = 1)

</code></pre>

<hr>
<h2 id='prj+2CSoilProfileCollection-method'>Get or Set Coordinate Reference System for SoilProfileCollection</h2><span id='topic+prj+2CSoilProfileCollection-method'></span><span id='topic+prj'></span><span id='topic+prj+3C-+2CSoilProfileCollection-method'></span><span id='topic+prj+3C-'></span><span id='topic+proj4string+2CSoilProfileCollection-method'></span><span id='topic+proj4string+3C-+2CSoilProfileCollection+2CANY-method'></span>

<h3>Description</h3>

<p><code>prj()</code>: Get Coordinate Reference System (Projection) metadata
</p>
<p><code style="white-space: pre;">&#8288;prj()&lt;-&#8288;</code>: Set Coordinate Reference System metadata for the SoilProfileCollection
</p>
<p><code>proj4string()</code>: (Deprecated) Get Coordinate Reference System as PROJ4 String
</p>
<p><code style="white-space: pre;">&#8288;proj4string()&lt;-&#8288;</code>: (Deprecated) Set Coordinate Reference System metadata for the SoilProfileCollection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
prj(object, ...)

## S4 replacement method for signature 'SoilProfileCollection'
prj(object, ...) &lt;- value

## S4 method for signature 'SoilProfileCollection'
proj4string(obj)

## S4 replacement method for signature 'SoilProfileCollection,ANY'
proj4string(obj) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prj+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="prj+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used)</p>
</td></tr>
<tr><td><code id="prj+2B2CSoilProfileCollection-method_+3A_value">value</code></td>
<td>
<p>character. Representation of Coordinate Reference System as <code>"authority:code"</code>, integer EPSG code, WKT2019 / PROJ4 string, an sf <code>crs</code> or sp <code>CRS</code> object.</p>
</td></tr>
<tr><td><code id="prj+2B2CSoilProfileCollection-method_+3A_obj">obj</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+initSpatial+3C-">initSpatial&lt;-()</a></code>
</p>

<hr>
<h2 id='profile_id+26lt+3B-'>Set profile IDs</h2><span id='topic+profile_id+3C-'></span><span id='topic+profile_id+3C-+2CSoilProfileCollection-method'></span><span id='topic+profile_id+2CSoilProfileCollection-method'></span><span id='topic+profile_id'></span>

<h3>Description</h3>

<p>Set vector containing profile IDs
</p>
<p>Get or set a vector of profile IDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
profile_id(object) &lt;- value

## S4 method for signature 'SoilProfileCollection'
profile_id(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile_id+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="profile_id+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a unique vector of equal length to number of profiles <code>length(object)</code></p>
</td></tr>
</table>

<hr>
<h2 id='profileApply'>Iterate over profiles in a SoilProfileCollection</h2><span id='topic+profileApply'></span><span id='topic+profileApply+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Iterate over all profiles in a SoilProfileCollection, calling <code>FUN</code> on a single-profile SoilProfileCollection for each step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
profileApply(
  object,
  FUN,
  simplify = TRUE,
  frameify = FALSE,
  chunk.size = 100,
  column.names = NULL,
  APPLY.FUN = lapply,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profileApply_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="profileApply_+3A_fun">FUN</code></td>
<td>
<p>a function to be applied to each profile within the collection</p>
</td></tr>
<tr><td><code id="profileApply_+3A_simplify">simplify</code></td>
<td>
<p>logical, should the result be simplified to a vector? default: TRUE; see examples</p>
</td></tr>
<tr><td><code id="profileApply_+3A_frameify">frameify</code></td>
<td>
<p>logical, should the result be collapsed into a data.frame? default: FALSE; overrides simplify argument; see examples</p>
</td></tr>
<tr><td><code id="profileApply_+3A_chunk.size">chunk.size</code></td>
<td>
<p>numeric, size of &quot;chunks&quot; for faster processing of large SoilProfileCollection objects; default: 100</p>
</td></tr>
<tr><td><code id="profileApply_+3A_column.names">column.names</code></td>
<td>
<p>character, optional character vector to replace frameify-derived column names; should match length of colnames() from FUN result; default: NULL</p>
</td></tr>
<tr><td><code id="profileApply_+3A_apply.fun">APPLY.FUN</code></td>
<td>
<p>function, optional alternate <code>lapply()</code>-like function for processing chunks. For example <code>future.apply::future_lapply()</code> for processing chunks in parallel. Default <code>base::lapply()</code>.</p>
</td></tr>
<tr><td><code id="profileApply_+3A_...">...</code></td>
<td>
<p>additional arguments passed to FUN</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When simplify is TRUE, a vector of length nrow(object) (horizon data) or of length length(object) (site data). When simplify is FALSE, a list is returned. When frameify is TRUE, a data.frame is returned. An attempt is made to identify idname and/or hzidname in the data.frame result, safely ensuring that IDs are preserved to facilitate merging profileApply result downstream.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# estimate soil depth using horizon designations
profileApply(sp1, estimateSoilDepth, name='name')

# scale a single property 'prop' in horizon table
# scaled = (x - mean(x)) / sd(x)
sp1$d &lt;- profileApply(sp1, FUN=function(x) round(scale(x$prop), 2))
plot(sp1, name='d')

# compute depth-wise differencing by profile
# note that our function expects that the column 'prop' exists
f &lt;- function(x) { c(x$prop[1], diff(x$prop)) }
sp1$d &lt;- profileApply(sp1, FUN=f)
plot(sp1, name='d')

# compute depth-wise cumulative sum by profile
# note the use of an anonymous function
sp1$d &lt;- profileApply(sp1, FUN=function(x) cumsum(x$prop))
plot(sp1, name='d')

# compute profile-means, and save to @site
# there must be some data in @site for this to work
site(sp1) &lt;- ~ group
sp1$mean_prop &lt;- profileApply(sp1, FUN=function(x) mean(x$prop, na.rm=TRUE))

# re-plot using ranks defined by computed summaries (in @site)
plot(sp1, plot.order=rank(sp1$mean_prop))

## iterate over profiles, calculate on each horizon, merge into original SPC

# example data
data(sp1)

# promote to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

# calculate horizon thickness and proportional thickness
# returns a data.frame result with multiple attributes per horizon
thicknessFunction &lt;- function(p) {
  hz &lt;- horizons(p)
  depthnames &lt;- horizonDepths(p)
  res &lt;- data.frame(profile_id(p), hzID(p),
                    thk=(hz[[depthnames[[2]]]] - hz[[depthnames[1]]]))
  res$hz_prop &lt;- res$thk / sum(res$thk)
  colnames(res) &lt;- c(idname(p), hzidname(p), 'hz_thickness', 'hz_prop')
  return(res)
}

# list output option with simplify=F, list names are profile_id(sp1)
list.output &lt;- profileApply(sp1, thicknessFunction, simplify = FALSE)
head(list.output)

# data.frame output option with frameify=TRUE
df.output &lt;- profileApply(sp1, thicknessFunction, frameify = TRUE)
head(df.output)

# since df.output contains idname(sp1) and hzidname(sp1),
# it can safely be merged by a left-join via horizons&lt;- setter
horizons(sp1) &lt;- df.output

plot(density(sp1$hz_thickness, na.rm=TRUE), main="Density plot of Horizon Thickness")

## iterate over profiles, subsetting horizon data

# example data
data(sp1)

# promote to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

# make some fake site data related to a depth of some importance
sp1$dep &lt;- profileApply(sp1, function(i) {round(rnorm(n=1, mean=mean(i$top)))})

# custom function for subsetting horizon data, by profile
# keep horizons with lower boundary &lt; site-level attribute 'dep'
fun &lt;- function(i) {
  # extract horizons
  h &lt;- horizons(i)
  # make an expression to subset horizons
  exp &lt;- paste('bottom &lt; ', i$dep, sep='')
  # subset horizons, and write-back into current SPC
  slot(i, 'horizons') &lt;- subset(h, subset=eval(parse(text=exp)))
  # return modified SPC
  return(i)
}

# list of modified SoilProfileCollection objects
l &lt;- profileApply(sp1, fun, simplify=FALSE)

# re-combine list of SoilProfileCollection objects into a single SoilProfileCollection
sp1.sub &lt;- pbindlist(l)

# graphically check
par(mfrow=c(2,1), mar=c(0,0,1,0))
plot(sp1)
points(1:length(sp1), sp1$dep, col='red', pch=7)
plot(sp1.sub)

</code></pre>

<hr>
<h2 id='profileGroupLabels'>Soil Profile Group Labels</h2><span id='topic+profileGroupLabels'></span>

<h3>Description</h3>

<p>Labels groups of soil profiles within soil profile sketches.
</p>
<p>See examples below for ideas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileGroupLabels(
  x0,
  x1,
  labels,
  y0 = 100,
  y1 = 98,
  label.offset = 2,
  label.cex = 0.75
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profileGroupLabels_+3A_x0">x0</code></td>
<td>
<p>integer indices to the first profile within each group</p>
</td></tr>
<tr><td><code id="profileGroupLabels_+3A_x1">x1</code></td>
<td>
<p>integer indices to the last profile within each group</p>
</td></tr>
<tr><td><code id="profileGroupLabels_+3A_labels">labels</code></td>
<td>
<p>vector of group labels</p>
</td></tr>
<tr><td><code id="profileGroupLabels_+3A_y0">y0</code></td>
<td>
<p>baseline depth used for group brackets</p>
</td></tr>
<tr><td><code id="profileGroupLabels_+3A_y1">y1</code></td>
<td>
<p>depth used for start and end markers for group brackets (see
examples)</p>
</td></tr>
<tr><td><code id="profileGroupLabels_+3A_label.offset">label.offset</code></td>
<td>
<p>vertical offset of group labels from baseline</p>
</td></tr>
<tr><td><code id="profileGroupLabels_+3A_label.cex">label.cex</code></td>
<td>
<p>label size</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is typically called by some other convenience function
such as <code><a href="#topic+plotMultipleSPC">plotMultipleSPC</a></code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotMultipleSPC">plotMultipleSPC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# load sample data
data(sp3)
data(sp4)

# convert soil colors
sp3$h &lt;- NA ; sp3$s &lt;- NA ; sp3$v &lt;- NA
sp3.rgb &lt;- with(sp3, munsell2rgb(hue, value, chroma, return_triplets=TRUE))
sp3[, c('h','s','v')] &lt;- t(with(sp3.rgb, rgb2hsv(r, g, b, maxColorValue=1)))

# promote to SoilProfileCollection
depths(sp3) &lt;- id ~ top + bottom
depths(sp4) &lt;- id ~ top + bottom

# combine into a list
spc.list &lt;- list(sp3, sp4)

# compute group lengths and start/stop locations
n.groups &lt;- length(spc.list)
spc.lengths &lt;- sapply(spc.list, length)
n.pedons &lt;- sum(spc.lengths)
group.starts &lt;- c(1, 1 + cumsum(spc.lengths[-n.groups]))
group.ends &lt;- cumsum(spc.lengths)

# determine depths of first / last profile in each group
yy &lt;- unlist(sapply(spc.list, function(i) profileApply(i, max)))
tick.heights &lt;- yy[c(group.starts, group.ends)] + 2

# plot 2 SoilProfileCollection objects on the same axis
par(mar=c(1,1,1,1))
plotSPC(sp3, n = n.pedons)
plotSPC(sp4, add = TRUE, x.idx.offset = group.ends[1], 
depth.axis = FALSE, id.style = 'side')

# annotate groups
profileGroupLabels(x0 = group.starts, x1 = group.ends,
labels=c('Collection 1', 'Collection 2'), y0=120, y1=tick.heights)

</code></pre>

<hr>
<h2 id='profileInformationIndex'>Soil Profile Information Index</h2><span id='topic+profileInformationIndex'></span>

<h3>Description</h3>

<p>A simple index of &quot;information&quot; content associated with individuals in a <code>SoilProfileCollection</code> object. Information content is quantified by number of bytes after compression via <code>memCompress()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profileInformationIndex(
  x,
  vars,
  method = c("joint", "individual"),
  baseline = FALSE,
  numericDigits = 8,
  padNA = FALSE,
  scaleNumeric = FALSE,
  compression = "gzip"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profileInformationIndex_+3A_x">x</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="profileInformationIndex_+3A_vars">vars</code></td>
<td>
<p>character vector of site or horizon level attributes to consider</p>
</td></tr>
<tr><td><code id="profileInformationIndex_+3A_method">method</code></td>
<td>
<p>character, 'individual' or 'joint' complexity</p>
</td></tr>
<tr><td><code id="profileInformationIndex_+3A_baseline">baseline</code></td>
<td>
<p>logical, compute ratio to &quot;baseline&quot; information content, see details</p>
</td></tr>
<tr><td><code id="profileInformationIndex_+3A_numericdigits">numericDigits</code></td>
<td>
<p>integer, number of significant digits to retain in numeric -&gt; character conversion</p>
</td></tr>
<tr><td><code id="profileInformationIndex_+3A_padna">padNA</code></td>
<td>
<p>logical, pad depths to <code>max(x)</code>, supplied to <code>dice(fill = padNA)</code></p>
</td></tr>
<tr><td><code id="profileInformationIndex_+3A_scalenumeric">scaleNumeric</code></td>
<td>
<p>logical, <code>scale()</code> each numeric variable, causing &quot;profile information&quot; to vary based on other profiles in the collection</p>
</td></tr>
<tr><td><code id="profileInformationIndex_+3A_compression">compression</code></td>
<td>
<p>character, compression method as used by <code><a href="base.html#topic+memCompress">memCompress()</a></code>: 'gzip', 'bzip2', 'xz', 'none'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information content via compression (gzip) is the central assumption behind this function: the values associated with a simple soil profile having few horizons and little variation between horizons (isotropic depth-functions) will compress to a much smaller size than a complex profile (many horizons, strong anisotropy). Information content is evaluated a profile at a time, over each site or horizon level attribute specified in <code>vars</code>. The <code>baseline</code> argument invokes a comparison to the simplest possible representation of each depth-function:
</p>

<ul>
<li> <p><code>numeric</code>: replication of the mean value to match the number of horizons with non-NA values
</p>
</li>
<li> <p><code>character</code> or <code>factor</code>: replication of the most frequent value to match the number of horizons with non-NA values
</p>
</li></ul>

<p>The ratios computed against a &quot;simple&quot; baseline represent something like &quot;information gain&quot;. Larger baseline ratios suggest more complexity (more information) associated with a soil profile's depth-functions. Alternatively, the total quantity of information (in bytes) can be determined by setting <code>baseline = FALSE</code>.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as <code>length(x)</code> and in the same order, suitable for direct assignment to a new site-level attribute
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# single horizon, constant value
p1 &lt;- data.frame(id = 1, top = 0, bottom = 100, p = 5, name = 'H')

# multiple horizons, constant value
p2 &lt;- data.frame(
  id = 2, top = c(0, 10, 20, 30, 40, 50),
  bottom = c(10, 20, 30, 40, 50, 100),
  p = rep(5, times = 6),
  name = c('A1', 'A2', 'Bw', 'Bt1', 'Bt2', 'C')
)

# multiple horizons, random values
p3 &lt;- data.frame(
  id = 3, top = c(0, 10, 20, 30, 40, 50),
  bottom = c(10, 20, 30, 40, 50, 100),
  p = c(1, 5, 10, 35, 6, 2),
  name = c('A1', 'A2', 'Bw', 'Bt1', 'Bt2', 'C')
)

# multiple horizons, mostly NA
p4 &lt;- data.frame(
  id = 4, top = c(0, 10, 20, 30, 40, 50),
  bottom = c(10, 20, 30, 40, 50, 100),
  p = c(1, NA, NA, NA, NA, NA),
  name = c('A1', 'A2', 'Bw', 'Bt1', 'Bt2', 'C')
)

# shallower version of p1
p5 &lt;- data.frame(id = 5, top = 0, bottom = 50, p = 5, name = 'H')

# combine and upgrade to SPC
z &lt;- rbind(p1, p2, p3, p4, p5)
depths(z) &lt;- id ~ top + bottom
hzdesgnname(z) &lt;- 'name'

z &lt;- fillHzGaps(z)

# visual check
par(mar = c(1, 0, 3, 3))
plotSPC(z, color = 'p', name.style = 'center-center', cex.names = 0.8, max.depth = 110)

# factor version of horizon name
z$fname &lt;- factor(z$name)

vars &lt;- c('p', 'name')
# result is total bytes
pi &lt;- profileInformationIndex(z, vars = vars, method = 'joint', baseline = FALSE)

text(x = 1:5, y = 105, labels = pi, cex = 0.85)
mtext('Profile Information Index (bytes)', side = 1, line = -1)

</code></pre>

<hr>
<h2 id='quickSPC'>Quickly Assemble a SoilProfileCollection</h2><span id='topic+quickSPC'></span>

<h3>Description</h3>

<p>Quickly assemble a single-profile, <code>SoilProfileCollection</code> object from two possible templates. This function is a useful shortcut for creating theoretical <code>SoilProfileCollection</code> objects for testing or demonstrative purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickSPC(
  x,
  id = "id",
  d = "depths",
  n = "name",
  m = "soil_color",
  interval = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickSPC_+3A_x">x</code></td>
<td>
<p>either a <code>list</code> or <code>character</code> vector, see Details and Examples</p>
</td></tr>
<tr><td><code id="quickSPC_+3A_id">id</code></td>
<td>
<p>character, specified when <code>x</code> is a <code>list</code>, name of ID list element</p>
</td></tr>
<tr><td><code id="quickSPC_+3A_d">d</code></td>
<td>
<p>character, specified when <code>x</code> is a <code>list</code>, name of depths list element</p>
</td></tr>
<tr><td><code id="quickSPC_+3A_n">n</code></td>
<td>
<p>character, specified when <code>x</code> is a <code>list</code>, name of horizon name list element</p>
</td></tr>
<tr><td><code id="quickSPC_+3A_m">m</code></td>
<td>
<p>character, specified when <code>x</code> is a <code>list</code>, name of list element containing Munsell color notation</p>
</td></tr>
<tr><td><code id="quickSPC_+3A_interval">interval</code></td>
<td>
<p>numeric, typically an integer and only specified when using character templates in mode 2. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list template for a single SPC allows for full specification of ID, horizon designation, bottom depths, and an arbitrary number of horizon-level attributes. A compact notation is used for profile ID (single value) and horizon depths (bottom depths, assuming datum of 0). Horizon designation and additional data (e.g. clay content) are specified as vectors all of equal length, matching the number of horizons in the profile.
</p>
<p>The character template can be provided in one of several formats:
</p>

<ol>
<li><p> 'A-Bt1-Bt2-Bt3-Cr-R'
</p>
</li>
<li><p> 'ApAp|AA|E|BhsBhs|Bw1Bw1|CCCCC'
</p>
</li></ol>

<p>Format 1 is interpreted as a horizon sequence delimited by '-' or newline character (\n). Random integer thickness are assigned to horizons, and profile ID created via <code>digest::digest(..., algo = 'xxhash32')</code>. Iteration over templates in this format is automatic when <code>x</code> is a character vector of <code>length &gt; 1</code>.
</p>
<p>Format 2 is interpreted as a horizon sequence delimited by '|'. Horizon thickness is proportional to replication of horizon designation and scaled by the <code>interval</code> argument. Profile ID is created via <code>digest::digest(..., algo = 'xxhash32')</code>. Iteration over templates in this format is automatic when <code>x</code> is a character vector of <code>length &gt; 1</code>.
</p>
<p>Explicit naming of profile IDs can be accomplished by specifying an ID via prefix, as in &quot;ID:A-Bt1-Bt2-Cr-R&quot; or &quot;ID:ApAp|AA|E|BhsBhs|Bw1Bw1|CCCCC&quot;. Labels specified before a &quot;:&quot; will be interpreted as a profile ID. These labels are optional but if specified must be unique within <code>x</code>.
</p>
<p>Single-horizon profile templates must include a trailing horizon delimiter: '-', '\n', or '|' depending on the format.
</p>


<h3>Value</h3>

<p><code>SoilProfileCollection</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# list-based template
x &lt;- list(
id = 'P1',
depths = c(25, 33, 100, 150),
name = c('A', 'Bw', 'Bt', 'Cr'),
clay = c(12, 15, 22, 25),
soil_color = c('10YR 3/3', '10YR 4/4', '10YR 4/6', '5G 6/2')
)

s &lt;- quickSPC(x)
plotSPC(s, name.style = 'center-center', cex.names = 1)

# character template, mode 1
# horizon thickness is generated at random (uniform [5,20])
x &lt;- 'A-Bt1-Bt2-Bt3-Cr-R'

s &lt;- quickSPC(x)
plotSPC(s, name.style = 'center-center', cex.names = 1)


# multiple templates
x &lt;- c(
'A-Bt1-Bt2-Bt3-Cr-R', 
'A-C1-C2-C3-C4-Ab', 
'Ap-A-A/E-E-Bhs-Cr'
)

# this interface is vectorized 
s &lt;- quickSPC(x)
plotSPC(s, name.style = 'center-center', cex.names = 1)


# optionally specify profile IDs using "ID:" prefix
x &lt;- c(
'P1:A-Bt1-Bt2-Bt3-Cr-R',
'P2:A-C1-C2-C3-C4-Ab',
'P3:Ap-A-A/E-E-Bhs-Cr'
)

s &lt;- quickSPC(x)
plotSPC(s, name.style = 'center-center', cex.names = 1)


# optionally specify:
# horizon bottom depths in cm
# soil color in Munsell notation
x &lt;- c(
'1. simple:Oe-A-E-Bhs',
'2. full:Oe,10,10YR 2/2-A,20,10YR 3/3-E,30,2.5Y 8/2-Bhs,60,7.5YR 4/6'
)

s &lt;- quickSPC(x)
plotSPC(s, name.style = 'center-center', cex.names = 1)

# use newline character as delimiter, more compact
x &lt;- 'Oe,10,10YR 2/2
A,20,10YR 3/3
E,30,2.5Y 8/2
Bhs,60,7.5YR 4/6
BC,125,7.5YR 6/4
C,150,10YR 6/2'

plotSPC(quickSPC(x), name.style = 'center-center', cex.names = 1)


# character template, mode 2
# horizon thickness is proportional to replication of 
# horizon designation and scaled by 'interval' argument
# default of 10 depth units
# e.g. A horizon is 3 * 10 = 30 depth units thick.
x &lt;- c(
  'AAA|BwBwBwBw|CCCCCCC|CdCdCdCd',
  'ApAp|AA|E|BhsBhs|Bw1Bw1|CCCCC',
  'A|Bt1Bt1Bt1|Bt2Bt2Bt2|Bt3|Cr|RRRRR'
  )

# each horizon label is '10' depth-units (default)
s &lt;- quickSPC(x)
plotSPC(s, name.style = 'center-center', 
        cex.names = 1, depth.axis = FALSE, 
        hz.depths = TRUE
)

# each horizon label is '5' depth-units
s &lt;- quickSPC(x, interval = 5)
plotSPC(s, name.style = 'center-center', 
        cex.names = 1, depth.axis = FALSE, 
        hz.depths = TRUE
)

# optionally specify some / all profile IDs with "ID:" prefix
x &lt;- c(
  'P1:AAA|BwBwBwBw|CCCCCCC|CdCdCdCd',
  'P2:ApAp|AA|E|BhsBhs|Bw1Bw1|CCCCC',
  'A|Bt1Bt1Bt1|Bt2Bt2Bt2|Bt3|Cr|RRRRR'
  )

s &lt;- quickSPC(x)
plotSPC(s, name.style = 'center-center', 
        cex.names = 1, depth.axis = FALSE, 
        hz.depths = TRUE
)


# make a NODATA profile, with a random hash ID
#  note the use of trailing horizon delimiter
#  note the use of NA soil color field
x &lt;- 'NODATA,150,NA-'
s &lt;- quickSPC(x)
plotSPC(s, name.style = 'center-center', 
        cex.names = 1, depth.axis = FALSE, 
        hz.depths = TRUE)


</code></pre>

<hr>
<h2 id='random_profile'>Random Profile</h2><span id='topic+random_profile'></span><span id='topic+.lpp'></span>

<h3>Description</h3>

<p>Generate a random soil profile according to set criteria, with correlated
depth trends.
</p>
<p>The random walk method produces profiles with considerable variation between
horizons and is based on values from the normal distribution seeded with
means and standard deviations drawn from the uniform distribution of [0,
10].
</p>
<p>The logistic power peak (LPP) function can be used to generate random soil
property depth functions that are sharply peaked. LPP parameters can be
hard-coded using the optional arguments: &quot;lpp.a&quot;, &quot;lpp.b&quot;, &quot;lpp.u&quot;, &quot;lpp.d&quot;,
&quot;lpp.e&quot;. Amplitude of the peak is controlled by (&quot;lpp.a + &quot;lpp.b&quot;), depth of
the peak by &quot;lpp.u&quot;, and abruptness by &quot;lpp.d&quot; and &quot;lpp.e&quot;. Further
description of the method is outlined in (Brenton et al, 2011). Simulated
horizon distinctness codes are based on the USDA-NCSS field description
methods.
Simulated distinctness codes are constrained according to horizon thickness,
i.e. a gradual boundary (+/- 5cm) will not be simulated for horizons that
are thinner than 3x this vertical distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_profile(
  id,
  n = c(3, 4, 5, 6),
  min_thick = 5,
  max_thick = 30,
  n_prop = 5,
  exact = FALSE,
  method = "random_walk",
  HzDistinctSim = FALSE,
  SPC = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_profile_+3A_id">id</code></td>
<td>
<p>a character or numeric id used for this profile</p>
</td></tr>
<tr><td><code id="random_profile_+3A_n">n</code></td>
<td>
<p>vector of possible number of horizons, or the exact number of
horizons (see below)</p>
</td></tr>
<tr><td><code id="random_profile_+3A_min_thick">min_thick</code></td>
<td>
<p>minimum thickness criteria for a simulated horizon</p>
</td></tr>
<tr><td><code id="random_profile_+3A_max_thick">max_thick</code></td>
<td>
<p>maximum thickness criteria for a simulated horizon</p>
</td></tr>
<tr><td><code id="random_profile_+3A_n_prop">n_prop</code></td>
<td>
<p>number of simulated soil properties (columns in the returned
dataframe)</p>
</td></tr>
<tr><td><code id="random_profile_+3A_exact">exact</code></td>
<td>
<p>should the exact number of requested horizons be generated?
(defaults to FALSE)</p>
</td></tr>
<tr><td><code id="random_profile_+3A_method">method</code></td>
<td>
<p>named method used to synthesize depth function ('random_walk'
or 'LPP'), see details</p>
</td></tr>
<tr><td><code id="random_profile_+3A_hzdistinctsim">HzDistinctSim</code></td>
<td>
<p>optionally simulate horizon boundary distinctness codes</p>
</td></tr>
<tr><td><code id="random_profile_+3A_spc">SPC</code></td>
<td>
<p>result is a <code>SoilProfileCollection</code> object, otherwise a
<code>data.frame</code> object</p>
</td></tr>
<tr><td><code id="random_profile_+3A_...">...</code></td>
<td>
<p>additional parameters passed-in to the LPP (<code>.lpp</code>)
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>SoilProfileCollection</code> object.
</p>


<h3>Note</h3>

<p>See examples for ideas on simulating several profiles at once.
</p>


<h3>Author(s)</h3>

<p>Dylan E. Beaudette
</p>


<h3>References</h3>

<p>Myers, D. B.; Kitchen, N. R.; Sudduth, K. A.; Miles, R. J.;
Sadler, E. J. &amp; Grunwald, S. Peak functions for modeling high resolution
soil profile data Geoderma, 2011, 166, 74-83.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile_compare">profile_compare</a>, <a href="#topic+hzDistinctnessCodeToOffset">hzDistinctnessCodeToOffset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# generate 10 random profiles, result is a list of SoilProfileCollection objects
d &lt;- lapply(1:10, random_profile, SPC=TRUE)

# combine
d &lt;- combine(d)

# plot
opar &lt;- par(mar=c(0,0,3,2))
plotSPC(d, color='p1', name='name', cex.names=0.75)
par(opar)

# simulate horizon boundary distinctness codes:
d &lt;- lapply(1:10, random_profile, SPC=TRUE, HzDistinctSim=TRUE)
d &lt;- combine(d)

d$HzD &lt;- hzDistinctnessCodeToOffset(d$HzDistinctCode)

opar &lt;- par(mar=c(0,0,3,2))
plotSPC(d, name='name', color='p1', hz.distinctness.offset='HzD')
par(opar)


# depth functions are generated using the LPP function
opar &lt;- par(mfrow=c(2,1), mar=c(0,0,3,0))

# generate data
d.1 &lt;- lapply(1:10, random_profile, SPC=TRUE, n=c(6, 7, 8), n_prop=1, method='LPP')
d.1 &lt;- combine(d.1)

# plot
plotSPC(d.1, name='name', color='p1', col.label = 'LPP Defaults')


# do this again, this time set all of the LPP parameters
d.2 &lt;- lapply(1:10, random_profile, SPC=TRUE, n=c(6, 7, 8), n_prop=1, method='LPP',
           lpp.a=5, lpp.b=10, lpp.d=5, lpp.e=5, lpp.u=25)
d.2 &lt;- combine(d.2)

# plot
plotSPC(d.2, name='name', color='p1', col.label = 'Custom LPP Parameters')


# reset plotting defaults
par(opar)



# try plotting the LPP-derived simulated data
# aggregated over all profiles
a &lt;- slab(d.2, fm= ~ p1)
a$mid &lt;- with(a, (top + bottom) / 2)

library(lattice)
(p1 &lt;- xyplot(mid ~ p.q50, data=a,
              lower=a$p.q25, upper=a$p.q75, ylim=c(150,-5), alpha=0.5,
              panel=panel.depth_function, prepanel=prepanel.depth_function,
              cf=a$contributing_fraction, xlab='Simulated Data', ylab='Depth',
              main='LPP(a=5, b=10, d=5, e=5, u=25)',
              par.settings=list(superpose.line=list(col='black', lwd=2))
))

# optionally add original data as step-functions
if(require(latticeExtra)) {
  h &lt;- horizons(d.2)
  p1 + as.layer(xyplot(top ~ p1, groups=id, data=h,
                       horizontal=TRUE, type='S',
                       par.settings=list(superpose.line=list(col='blue', lwd=1, lty=2))))
}



</code></pre>

<hr>
<h2 id='reactionclass'>pH Reaction Classes</h2><span id='topic+reactionclass'></span>

<h3>Description</h3>

<p>Levels of pH (reaction) classes including descriptive name, and range from low to high pH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(reactionclass)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 11 rows and 3 columns.
</p>


<h3>References</h3>

<p>Soil Science Division Staff. (2017) Soil Survey Manual. C. Ditzler, K. Scheffe, and H.C. Monger (eds.). USDA Handbook 18. Government Printing Office, Washington, D.C.
</p>

<hr>
<h2 id='rebuildSPC'>Rebuild a SoilProfileCollection object</h2><span id='topic+rebuildSPC'></span>

<h3>Description</h3>

<p>Rebuild a SoilProfileCollection object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rebuildSPC(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rebuildSPC_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attempt rebuilding a <code>SoilProfileCollection</code> object by splitting into
components and re-assembling. Likely only used to fix outdated
<code>SoilProfileCollection</code> objects that are missing slots.
</p>


<h3>Value</h3>

<p>A valid <code>SoilProfileCollection</code> object.
</p>
<p>A valid <code>SoilProfileCollection</code> object.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>
<p>D.E. Beaudette, A.G. Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkSPC">checkSPC</a></code>
Rebuild a SoilProfileCollection object
</p>
<p>Rebuild a SoilProfileCollection object
</p>
<p>Attempt rebuilding a <code>SoilProfileCollection</code> object by splitting into
components and re-assembling. Likely only used to fix outdated
<code>SoilProfileCollection</code> objects that are missing slots.
</p>
<p><code><a href="#topic+checkSPC">checkSPC</a></code>
</p>

<hr>
<h2 id='reduceSPC'>Select a subset of columns from a SoilProfileCollection</h2><span id='topic+reduceSPC'></span>

<h3>Description</h3>

<p>Reduce the number of columns in a SoilProfileCollection to a minimal set plus additional selected columns. Optional metadata columns are included if set. At a minimum the profileID, horizon top and bottom depth, horizon ID are included. Horizon designation and horizon texture class column names are included if metadata attributes are set. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceSPC(p, column_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceSPC_+3A_p">p</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="reduceSPC_+3A_column_names">column_names</code></td>
<td>
<p>a set of additional columns to include in the result</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimum column names included (when <code>column_names = NULL</code>)
</p>

<ul>
<li> <p><code>idname(p)</code>, <code>horizonDepths(p)</code>, <code>hzidname(p)</code>
</p>
</li></ul>

<p>Optional column names included (when metadata are set)
</p>

<ul>
<li> <p><code>hzdesgnname(p)</code>, <code>hztexclname(p)</code>, <code>GHL(p)</code>
</p>
</li></ul>



<h3>Value</h3>

<p>a SoilProfileCollection
</p>


<h3>See Also</h3>

<p><code>hzdesgnname()</code> <code>hztexclname()</code> <code>GHL()</code>
</p>

<hr>
<h2 id='reorderHorizons'>Re-order corrupted horizon data</h2><span id='topic+reorderHorizons'></span><span id='topic+reorderHorizons+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>This is a method made available primarily to repair horizon data that have been corrupted relative to their order at time of SoilProfileCollection construction.
</p>
<p>There is an option to specify the target order, but this will not update the corresponding metadata entry tracking the original order. Use this functionality at your own risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
reorderHorizons(object, target.order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorderHorizons_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="reorderHorizons_+3A_target.order">target.order</code></td>
<td>
<p>A numeric vector of equal length to <code>object</code>. Default value is <code>NULL</code> which restores the internal order of the collection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SoilProfileCollection
</p>

<hr>
<h2 id='repairMissingHzDepths'>Repair Problematic Lower Horizon Depths</h2><span id='topic+repairMissingHzDepths'></span>

<h3>Description</h3>

<p>Attempt a simple repair of horizon bottom depths in the presence of <code>NA</code>, or in cases where the horizon shares a common top and bottom depth. Both situations are common in pedon description where &quot;contact&quot; (Cd, Cr, R, etc.) was described without a lower depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairMissingHzDepths(x, adj = 10, max.depth = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repairMissingHzDepths_+3A_x">x</code></td>
<td>
<p><code>SoilProfileCollection</code></p>
</td></tr>
<tr><td><code id="repairMissingHzDepths_+3A_adj">adj</code></td>
<td>
<p>vertical offset applied to &quot;repair&quot; missing bottom depths when top and bottom depth are equal or bottom depth is missing. (<code>NA</code> to use <code>max.depth</code>)</p>
</td></tr>
<tr><td><code id="repairMissingHzDepths_+3A_max.depth">max.depth</code></td>
<td>
<p>If adj is <code>NA</code>, or the resulting offset sum exceeds <code>max.depth</code>, <code>max.depth</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This repair is applied to the deepest horizon within a profile as identified by <code><a href="#topic+getLastHorizonID">getLastHorizonID</a></code>, as well as to bottom depths of any horizon that has a horizon below it. Horizon bottom depths are adjusted by adding <code>adj</code> (if non-NA). If the resulting value exceeds <code>max.depth</code>, the <code>max.depth</code> value is returned (if not <code>NA</code>).
</p>


<h3>Value</h3>

<p><code>SoilProfileCollection</code> with a new (logical) horizon-level attribute <code>.repaired</code> marking affected horizons
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
h &lt;- data.frame(
id = c(1, 1, 1, 2, 2, 2, 2, 3, 3),
top = c(0:2, 0:3, 0:1) * 10,
bottom = c(rep(NA_integer_, 7), c(10, 99))
)

# NA depths result in warnings
suppressWarnings({
  depths(h) &lt;- id ~ top + bottom
})

# inspect data before repairs
plotSPC(h)

g &lt;- repairMissingHzDepths(h)

# all depth logic now valid
all(checkHzDepthLogic(g)$valid)

# inspect
plotSPC(g)

# no adj, max.depth only
f &lt;- repairMissingHzDepths(h, adj = NA, max.depth = 200)
all(checkHzDepthLogic(f)$valid)
plotSPC(f)

# max.depth defaults to max(x) if too small
f$bottom[c(3,7)] &lt;- NA
d &lt;- repairMissingHzDepths(f, adj = NA, max.depth = 20)
all(checkHzDepthLogic(d)$valid)
plotSPC(d)

</code></pre>

<hr>
<h2 id='replaceHorizons+26lt+3B-'>Replace Data in Horizon Slot</h2><span id='topic+replaceHorizons+3C-'></span><span id='topic+replaceHorizons+3C-+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Replaces horizon data with new data.frame object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
replaceHorizons(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceHorizons+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="replaceHorizons+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>An object inheriting <code>data.frame</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# load test data
data(sp2)

# promote to SPC
depths(sp2) &lt;- id ~ top + bottom

# one profile
p &lt;- sp2[1,]

# 23 variables in horizon data
length(horizonNames(sp2))

# remove all but essential ones
replaceHorizons(p) &lt;- horizons(p)[,c(idname(p),hzidname(p),horizonDepths(p))]

# inspect result (a clean slate)
horizons(p)

</code></pre>

<hr>
<h2 id='restrictions+2CSoilProfileCollection-method'>Retrieve restriction data from SoilProfileCollection</h2><span id='topic+restrictions+2CSoilProfileCollection-method'></span><span id='topic+restrictions'></span>

<h3>Description</h3>

<p>Get restriction data from SoilProfileCollection. Result is returned in the same <code>data.frame</code> class used to initially construct the SoilProfileCollection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
restrictions(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrictions+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>

<hr>
<h2 id='restrictions+26lt+3B-'>Add Data to Restrictions Slot</h2><span id='topic+restrictions+3C-'></span><span id='topic+restrictions+3C-+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Restrictions data in an object inheriting from <code>data.frame</code> can easily be added via merge (LEFT JOIN). There must be one or more same-named profile ID columns on the left and right hand side to facilitate the join: <code>restrictions(spc) &lt;- newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
restrictions(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrictions+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="restrictions+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>An object inheriting <code>data.frame</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# load test data
data(sp2)

# promote to SPC
depths(sp2) &lt;- id ~ top + bottom

# assign abrupt textural change to a profile
newdata &lt;- data.frame(id = c("hon-21"),
                      restrkind = "abrupt textural change",
                      restrdep = 46)

# do left join
restrictions(sp2) &lt;- newdata

# inspect site table: newvalue TRUE only for horizons
#  with top depth equal to zero
restrictions(sp2)

</code></pre>

<hr>
<h2 id='rgb2munsell'>sRGB to Munsell Color Conversion</h2><span id='topic+rgb2munsell'></span>

<h3>Description</h3>

<p>Convert sRGB color coordinates to the closest <code>n</code> Munsell chips in the <code>munsell</code> lookup table. This function will be replaced by <code>col2Munsell()</code> in <strong>aqp 2.1</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgb2munsell(color, colorSpace = c("CIE2000", "LAB", "sRGB"), nClosest = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgb2munsell_+3A_color">color</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> object containing sRGB coordinates in the range of (0,1)</p>
</td></tr>
<tr><td><code id="rgb2munsell_+3A_colorspace">colorSpace</code></td>
<td>
<p>distance metric (colorspace) to use for finding the closest chip: CIE2000 is the most accurate but requires farver &gt;= 2.0.3, Euclidean distance in CIELAB is a close second, while Euclidean distance in sRGB is not at all accurate and should only be used for demonstration purposes.</p>
</td></tr>
<tr><td><code id="rgb2munsell_+3A_nclosest">nClosest</code></td>
<td>
<p>number of closest Munsell colors to return (valid range is 1-20)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an (NA-padded) <code>data.frame</code> containing <code>hue</code>, <code>value</code>, <code>chroma</code>, and distance (dE00 when <code>colorSpace = 'CIE2000'</code>, Euclidean distance otherwise) to nearest matching color.
</p>


<h3>Note</h3>

<p>This function is fully vectorized and will pad output with NA-records when NA are present in <code>color</code>.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p><a href="http://ncss-tech.github.io/AQP/">http://ncss-tech.github.io/AQP/</a>
<a href="http://www.brucelindbloom.com/index.html?ColorCalcHelp.html">http://www.brucelindbloom.com/index.html?ColorCalcHelp.html</a>
<a href="https://www.munsellcolourscienceforpainters.com/MunsellAndKubelkaMunkToolbox/MunsellAndKubelkaMunkToolbox.html">https://www.munsellcolourscienceforpainters.com/MunsellAndKubelkaMunkToolbox/MunsellAndKubelkaMunkToolbox.html</a>
http://www.cis.rit.edu/mcsl/online/munsell.php
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# Munsell notation to sRGB triplets [0-1] 
color &lt;- munsell2rgb(
  the_hue = c('10YR', '2.5YR', '5YR'), 
  the_value = c(3, 5, 2.5), 
  the_chroma = c(5, 6, 2), 
  return_triplets = TRUE
)

# result is a data.frame
color

# back-transform sRGB -&gt; closest Munsell color
# sigma is the dE00 color contrast metric
rgb2munsell(color)

</code></pre>

<hr>
<h2 id='ROSETTA.centroids'>Average Hydraulic Parameters from the ROSETTA Model by USDA Soil Texture
Class</h2><span id='topic+ROSETTA.centroids'></span>

<h3>Description</h3>

<p>Average soil hydraulic parameters generated by the first stage predictions
of the ROSETTA model by USDA soil texture class. These data were extracted
from <a href="https://www.ars.usda.gov/pacific-west-area/riverside-ca/agricultural-water-efficiency-and-salinity-research-unit/docs/model/rosetta-class-average-hydraulic-parameters/">ROSETTA documentation</a> and re-formatted for ease of use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ROSETTA.centroids)
</code></pre>


<h3>Format</h3>

<p>A data frame: </p>

<dl>
<dt>texture</dt><dd><p>soil texture class, ordered from low to high
available water holding capacity</p>
</dd> <dt>theta_r</dt><dd><p>average saturated
water content</p>
</dd> <dt>theta_s</dt><dd><p>average residual water content</p>
</dd>
<dt>alpha</dt><dd><p>average value, related to the inverse of the air entry
suction, log10-transformed values with units of cm</p>
</dd>
<dt>npar</dt><dd><p>average value, index of pore size distribution,
log10-transformed values with units of 1/cm</p>
</dd>
<dt>theta_r_sd</dt><dd><p>1 standard deviation of <code>theta_r</code></p>
</dd>
<dt>theta_s_sd</dt><dd><p>1 standard deviation of <code>theta_s</code></p>
</dd>
<dt>alpha_sd</dt><dd><p>1 standard deviation of <code>alpha</code></p>
</dd>
<dt>npar_sd</dt><dd><p>1 standard deviation of <code>npar</code></p>
</dd>
<dt>sat</dt><dd><p>approximate volumetric water content at which soil
material is saturated</p>
</dd> <dt>fc</dt><dd><p>approximate volumetric water
content at which matrix potential = -33kPa</p>
</dd> <dt>pwp</dt><dd><p>approximate
volumetric water content at which matrix potential = -1500kPa</p>
</dd>
<dt>awc</dt><dd><p>approximate available water holding capacity: VWC(-33kPa)
</p>

<ul>
<li><p> VWC(-1500kPa)</p>
</li></ul>
 </dd>
</dl>



<h3>Details</h3>

<p>Theoretical water-retention parameters for uniform soil material of each
texture class have been estimated via van Genuchten model.
</p>
<p>See <a href="https://ncss-tech.github.io/AQP/soilDB/fetchKSSL-VG-demo.html">the related tutorial</a>
</p>


<h3>Source</h3>

<p><a href="https://www.ars.usda.gov/pacific-west-area/riverside-ca/agricultural-water-efficiency-and-salinity-research-unit/docs/model/rosetta-class-average-hydraulic-parameters/">ROSETTA Class Average Hydraulic Parameters</a>
</p>


<h3>References</h3>

<p>van Genuchten, M.Th. (1980). &quot;A closed-form equation for
predicting the hydraulic conductivity of unsaturated soils&quot;. Soil Science
Society of America Journal. 44 (5): 892-898.
</p>
<p>Schaap, M.G., F.J. Leij, and M.Th. van Genuchten. 2001. ROSETTA: A computer
program for estimating soil hydraulic parameters with hierarchical
pedotransfer functions. Journal of Hydrology 251(3–4): 163-176.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

library(aqp)
library(soilDB)
library(latticeExtra)

data("ROSETTA.centroids")

# iterate over horizons and generate VG model curve
res &lt;- lapply(1:nrow(ROSETTA.centroids), function(i) {
  m &lt;- KSSL_VG_model(VG_params = ROSETTA.centroids[i, ], phi_min = 10^-3, phi_max=10^6)$VG_curve
  # copy generalized hz label
  m$hz &lt;- ROSETTA.centroids$hz[i]
  # copy ID
  m$texture_class &lt;- ROSETTA.centroids$texture[i]
  return(m)
})

# copy over lab sample number as ID
res &lt;- do.call('rbind', res)

# check: OK
str(res)


# visual check: OK
xyplot(
  phi ~ theta | texture_class, data=res,
  type=c('l', 'g'),
  scales=list(alternating=3, x=list(tick.number=10), y=list(log=10, tick.number=10)),
  yscale.components=yscale.components.logpower,
  ylab=expression(Suction~~(kPa)),
  xlab=expression(Volumetric~Water~Content~~(cm^3/cm^3)),
  par.settings = list(superpose.line=list(col='RoyalBlue', lwd=2)),
  strip=strip.custom(bg=grey(0.85)),
  as.table=TRUE
)



## End(Not run)


</code></pre>

<hr>
<h2 id='rowley2019'>Soil Morphologic, Geochemical, and Mineralogy Data from Rowley et al. 2019.</h2><span id='topic+rowley2019'></span>

<h3>Description</h3>

<p>Data from Table 1 and Supplementary Tables 1 and 2 from &quot;A cascading
influence of calcium carbonate on the biogeochemistry and pedogenic
trajectories of subalpine soils, Switzerland&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rowley2019)
</code></pre>


<h3>Format</h3>

<p>A <code>SoilProfileCollection</code> object:
</p>
<p>site-level attributes </p>
 <dl>
<dt>id</dt><dd><p>profile ID</p>
</dd> <dt>group</dt><dd><p>profile
group</p>
</dd> </dl>

<p>horizon-level attributes </p>
 <dl>
<dt>sample_id</dt><dd><p>sample ID</p>
</dd>
<dt>name</dt><dd><p>horizon name</p>
</dd> <dt>pH</dt><dd><p>pH</p>
</dd> <dt>Al_exch</dt><dd><p>cmol(+) / kg,
exchangeable Al</p>
</dd> <dt>Ca_exch</dt><dd><p>cmol(+) / kg, exchangeable Ca</p>
</dd>
<dt>CEC_sum</dt><dd><p>cmol(+) / kg, cation exchange capacity calculated as the sum
of exchangeable cations, not including H+</p>
</dd>
<dt>Ca_exch_saturation</dt><dd><p>percent</p>
</dd> <dt>Al_exch_saturation</dt><dd><p>percent</p>
</dd>
<dt>TON</dt><dd><p>percent, total nitrogen</p>
</dd> <dt>SOC</dt><dd><p>percent, soil organic carbon</p>
</dd>
<dt>C_to_N</dt><dd><p>carbon to nitrogen ratio</p>
</dd> <dt>Alo</dt><dd><p>g/kg, oxalate-extractable
Al</p>
</dd> <dt>Feo</dt><dd><p>g/kg, oxalate-extractable Fe</p>
</dd> <dt>Ald</dt><dd><p>g/kg,
dithionite-extractable Al</p>
</dd> <dt>Fed</dt><dd><p>g/kg, dithionite-extractable Fe</p>
</dd>
<dt>Feo_Fed</dt><dd><p>Fe_o to Fe_d ratio</p>
</dd> <dt>id</dt><dd><p>profile ID</p>
</dd> <dt>top</dt><dd><p>horizon
top (cm)</p>
</dd> <dt>bottom</dt><dd><p>horizon bottom (cm)</p>
</dd> <dt>Al</dt><dd><p>g/kg by x-ray
fluorescence</p>
</dd> <dt>Ca</dt><dd><p>g/kg by x-ray fluorescence</p>
</dd> <dt>Cr</dt><dd><p>g/kg by x-ray
fluorescence</p>
</dd> <dt>Fe</dt><dd><p>g/kg by x-ray fluorescence</p>
</dd> <dt>K</dt><dd><p>g/kg by x-ray
fluorescence</p>
</dd> <dt>Mg</dt><dd><p>g/kg by x-ray fluorescence</p>
</dd> <dt>Mn</dt><dd><p>g/kg by x-ray
fluorescence</p>
</dd> <dt>Na</dt><dd><p>g/kg by x-ray fluorescence</p>
</dd> <dt>Ni</dt><dd><p>g/kg by x-ray
fluorescence</p>
</dd> <dt>P</dt><dd><p>g/kg by x-ray fluorescence</p>
</dd> <dt>Si</dt><dd><p>g/kg by x-ray
fluorescence</p>
</dd> <dt>Ti</dt><dd><p>g/kg by x-ray fluorescence</p>
</dd>
<dt>Phyllosilicates</dt><dd><p>percent by x-ray diffraction spectra</p>
</dd>
<dt>Quartz</dt><dd><p>percent by x-ray diffraction spectra</p>
</dd>
<dt>K_Feldspar</dt><dd><p>percent by x-ray diffraction spectra</p>
</dd>
<dt>Na_Plagioclase</dt><dd><p>percent by x-ray diffraction spectra</p>
</dd>
<dt>Goethite</dt><dd><p>percent by x-ray diffraction spectra</p>
</dd>
<dt>Unidentified</dt><dd><p>percent by x-ray diffraction spectra</p>
</dd>
<dt>CCE_Total</dt><dd><p>percent</p>
</dd> <dt>CCE_Reactive</dt><dd><p>percent</p>
</dd>
<dt>Reactive_carbonate</dt><dd><p>percent</p>
</dd> <dt>Sand</dt><dd><p>percent &lt;2um</p>
</dd>
<dt>Silt</dt><dd><p>percent 2-50um</p>
</dd> <dt>Clay</dt><dd><p>percent 50-2000um</p>
</dd>
<dt>CaH2O</dt><dd><p>Milliq ex: grams of Ca per kilogram of dry soil (g kg-1)</p>
</dd>
<dt>Ca2MKCl</dt><dd><p>2M KCl: grams of Ca per kilogram of dry soil (g kg-1)</p>
</dd>
<dt>CaNa2EDTA</dt><dd><p>0.05 M Na2EDTA: grams of Ca per kilogram of dry soil (g
kg-1)</p>
</dd> <dt>CaCuCl2</dt><dd><p>0.5 M CuCl2: grams of Ca per kilogram of dry soil (g
kg-1)</p>
</dd>
<dt>hzID</dt><dd><p>horizon ID</p>
</dd> </dl>



<h3>References</h3>

<p>Mike C. Rowley, Stephanie Grand, Thierry Adatte, Eric P.
Verrecchia, Cascading influence of calcium carbonate on the biogeochemistry and
pedogenic trajectories of subalpine soils), Switzerland, Geoderma, 2019,
114065, ISSN 0016-7061, <a href="https://doi.org/10.1016/j.geoderma.2019.114065">doi:10.1016/j.geoderma.2019.114065</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lattice)

# load data
data('rowley2019')

# check first 5 rows and 10 columns of horizon data
horizons(rowley2019)[1:5, 1:10]

# check site data
site(rowley2019)

# graphical summary
par(mar=c(1,1,3,1))
plotSPC(rowley2019, color='Feo_Fed', name='name', cex.names=0.85)

plotSPC(rowley2019, color='Ca_exch', name='name', cex.names=0.85)

# grouped plot
groupedProfilePlot(rowley2019, groups = 'group', color='Ca_exch',
name='name', cex.names=0.85, group.name.offset = -10)

# aggregate over 1cm slices, for select properties
a &lt;- slab(rowley2019, group ~ Reactive_carbonate + Ca_exch + pH + K_Feldspar + Na_Plagioclase + Al)

# plot styling
tps &lt;- list(superpose.line=list(lwd=2, col=c('royalblue', 'firebrick')))

# make the figure
xyplot(top ~ p.q50 | variable, data=a, ylab='Depth', groups=group,
       main='', as.table=TRUE,
       xlab='median bounded by 25th and 75th percentiles',
       lower=a$p.q25, upper=a$p.q75, ylim=c(55,-5),
       panel=panel.depth_function,
       prepanel=prepanel.depth_function,
       cf=a$contributing_fraction,
       alpha=0.33, sync.colors=TRUE,
       scales=list(x=list(relation='free', alternating=1)),
       par.settings=tps,
       auto.key=list(columns=2, lines=TRUE, points=FALSE),
       strip=strip.custom(bg=grey(0.9))
)


</code></pre>

<hr>
<h2 id='SANN_1D'>Fix Overlap within a Sequence via Simulated Annealing</h2><span id='topic+SANN_1D'></span>

<h3>Description</h3>

<p>This function makes small adjustments to elements of <code>x</code> until overlap defined by <code>thresh</code> is removed, or until <code>maxIter</code> is reached. Rank order and boundary conditions (defined by <code>min.x</code> and <code>max.x</code>) are preserved. The underlying algorithm is based on simulated annealing. The &quot;cooling schedule&quot; parameters <code>T0</code> and <code>k</code> can be used to tune the algorithm for specific applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SANN_1D(
  x,
  thresh = 0.6,
  adj = thresh * 2/3,
  min.x = min(x) - 0.2,
  max.x = max(x) + 0.2,
  maxIter = 1000,
  trace = FALSE,
  tiny = 1e-04,
  T0 = 500,
  k = 10,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SANN_1D_+3A_x">x</code></td>
<td>
<p>vector of horizontal positions, pre-sorted</p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_thresh">thresh</code></td>
<td>
<p>horizontal threshold defining &quot;overlap&quot; or distance between elements of <code>x</code>. For adjusting soil profile sketches values are typically &lt; 1 and likely in (0.3, 0.8).</p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_adj">adj</code></td>
<td>
<p>specifies the size of perturbations within <code>runif(min = adj * -1, max = adj)</code>. Larger values will sometimes reduce the number of iterations required to solve particularly difficult overlap conditions. See <code>coolingRate</code> argument when <code>adj</code> is large</p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_min.x">min.x</code></td>
<td>
<p>left-side boundary condition, consider expanding if a solution cannot be found within <code>maxIter</code>.</p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_max.x">max.x</code></td>
<td>
<p>right-side boundary condition, consider expanding if a solution cannot be found within <code>maxIter</code>.</p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations to attempt before giving up and returning a regularly-spaced sequence</p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_trace">trace</code></td>
<td>
<p>print diagnostics, result is a <code>list</code> vs <code>vector</code></p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_tiny">tiny</code></td>
<td>
<p>the smallest allowable overlap</p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_t0">T0</code></td>
<td>
<p>starting temperature</p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_k">k</code></td>
<td>
<p>cooling constant</p>
</td></tr>
<tr><td><code id="SANN_1D_+3A_...">...</code></td>
<td>
<p>not used, absorbs additional arguments to <code><a href="#topic+fixOverlap">fixOverlap()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ideas for solving difficult overlap scenarios:
</p>

<ul>
<li><p> widen the boundary conditions by adjusting <code>min.x</code> and <code>max.x</code> beyond the original scale of <code>x</code>
</p>
</li>
<li><p> reduce the allowable overlap threshold <code>thresh</code>
</p>
</li>
<li><p> reduce the magnitude of perturbations (<code>adj</code>) and increase <code>maxIter</code>
</p>
</li>
<li><p> increase <code>k</code>
</p>
</li></ul>



<h3>Value</h3>

<p>When <code>trace = FALSE</code>, a vector of the same length as <code>x</code>, preserving rank-ordering and boundary conditions. When <code>trace = TRUE</code> a list containing the new sequence along with information about objective functions and decisions made during iteration.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and K.C. Thompson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+electroStatics_1D">electroStatics_1D()</a></code>, <code><a href="#topic+fixOverlap">fixOverlap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1, 2, 3, 3.4, 3.5, 5, 6, 10)

# easy
z &lt;- fixOverlap(x, thresh = 0.2, trace = TRUE)

# harder
z &lt;- fixOverlap(x, thresh = 0.6, trace = TRUE)

# much harder
z &lt;- fixOverlap(x, thresh = 0.9, trace = TRUE)


# interpret `trace` output

# relatively challenging
x &lt;- c(1, 2, 3.4, 3.4, 3.4, 3.4, 6, 8, 10, 12, 13, 13, 15, 15.5)

# fix overlap, return debugging information
set.seed(10101)
z &lt;- fixOverlap(x, thresh = 0.8, trace = TRUE)

# setup plot device
par(mar = c(4, 4, 1, 1))
layout(matrix(c(1,2,3)), widths = 1, heights = c(1,1,2))

# objective function = overlap + SSD
plot(
  seq_along(z$stats), z$stats, 
  type = 'h', las = 1,
  xlab = 'Iteration', ylab = 'Overlap',
  cex.axis = 0.8
)

# SSD: deviation from original configuration 
plot(
  seq_along(z$ssd), z$ssd, 
  type = 'h', las = 1,
  xlab = 'Iteration', ylab = 'Deviation',
  cex.axis = 0.8
)
# adjustments at each iteration
matplot(
  z$states, type = 'l', 
  lty = 1, las = 1, 
  xlab = 'Iteration', ylab = 'x-position'
)

# trace log
# B: boundary condition violation
# O: rank (order) violation
# +: accepted perturbation
# -: rejected perturbation
table(z$log)

</code></pre>

<hr>
<h2 id='segment'>Segmenting of Soil Horizon Data by Depth Interval</h2><span id='topic+segment'></span>

<h3>Description</h3>

<p>This function segments or subdivides horizon data from a <code>SoilProfileCollection</code> or <code>data.frame</code> by depth interval (e.g. <code>c(0, 10)</code>, <code>c(0, 50)</code>, or <code>25:100</code>). This results in horizon records being split at the specified depth intervals, which duplicates the original horizon data but also adds new horizon depths. In addition, labels (i.e. <code>"segment_id"</code>) are added to each horizon record that correspond with their depth interval (e.g. <code>025-100</code>). This function is intended to harmonize horizons to a common support (i.e. depth interval) for further aggregation or summary. See the examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment(object, intervals, trim = TRUE, hzdepcols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment_+3A_object">object</code></td>
<td>
<p>either a <code>SoilProfileCollection</code> or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="segment_+3A_intervals">intervals</code></td>
<td>
<p>a vector of integers over which to slice the horizon data (e.g. <code>c(25, 100)</code> or <code>25:100</code>)</p>
</td></tr>
<tr><td><code id="segment_+3A_trim">trim</code></td>
<td>
<p>logical, when <code>TRUE</code> horizons in <code>object</code> are truncated to the min/max specified in <code>intervals</code>. When <code>FALSE</code>, those horizons overlapping an interval are marked as such. Care should be taken when specifying more than one depth interval and <code>trim = FALSE</code>.</p>
</td></tr>
<tr><td><code id="segment_+3A_hzdepcols">hzdepcols</code></td>
<td>
<p>a character vector of length 2 specifying the names of the horizon depths (e.g. <code>c("hzdept", "hzdepb")</code>), only necessary if <code>object</code> is a <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>segment()</code> performs no aggregation or resampling of the source data, rather, labels are added to horizon records for subsequent aggregation or summary. This makes it possible to process a very large number of records outside of the constraints associated with e.g. <code>slice()</code> or <code>slab()</code>.
</p>


<h3>Value</h3>

<p>Either a <code>SoilProfileCollection</code> or <code>data.frame</code> with the original horizon data segmented by depth intervals. There are usually more records in the resulting object, one for each time a segment interval partially overlaps with a horizon. A new column called <code>segment_id</code> identifying the depth interval is added.
</p>


<h3>Author(s)</h3>

<p>Stephen Roecker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dice">dice()</a></code>, <code><a href="#topic+glom">glom()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example data
data(sp1)

# upgrade to SPC
depths(sp1) &lt;- id ~ top + bottom

# segment and trim
z &lt;- segment(sp1, intervals = c(0, 10, 20, 30), trim = TRUE)

# display segment labels
# note that there are new horizon boundaries at segments
par(mar = c(0, 0, 3, 1))
plotSPC(z, color = 'segment_id', width = 0.3)

# highlight new horizon records
par(mar = c(0, 0, 2, 1))
plotSPC(z, color = NA, default.color = NA, width = 0.3, lwd = 1)
plotSPC(sp1, color = NA, default.color = NA, 
width = 0.3, lwd = 3, add = TRUE, name = NA, print.id = FALSE)
legend('top', horiz = TRUE, 
legend = c('original', 'segmented'), 
lwd = c(1, 3), cex = 0.85, bty = 'n')


# same results as slab()
# 10 random profiles
s &lt;- lapply(1:10, random_profile, n_prop = 1, SPC = TRUE, method = 'random_walk')
s &lt;- combine(s)

a.slab &lt;- slab(s, fm = ~ p1, slab.structure = c(0, 10, 20, 30), slab.fun = mean, na.rm = TRUE)

z &lt;- segment(s, intervals = c(0, 10, 20, 30), trim = TRUE)
z &lt;- horizons(z)
z$thick &lt;- z$bottom - z$top

a.segment &lt;- sapply(split(z, z$segment_id), function(i) {
  weighted.mean(i$p1, i$thick)
})


res &lt;- data.frame(
  slab = a.slab$value,
  segment = a.segment,
  diff = a.slab$value - a.segment
)

print(res)
res$diff &lt; 0.001



data(sp5)

# segment by upper 25-cm
test1 &lt;- segment(sp5, intervals = c(0, 100))
print(test1)
nrow(test1)
print(object.size(test1), units = "Mb")

# segment by 1-cm increments
test2 &lt;- segment(sp5, intervals = 0:100)
print(test2)
nrow(test2)
print(object.size(test2), units = "Mb")


# segment and aggregate
test3 &lt;- segment(horizons(sp5), 
                 intervals = c(0, 5, 15, 30, 60, 100, 200), 
                 hzdepcols = c("top", "bottom")
)
test3$hzthk &lt;- test3$bottom - test3$top
test3_agg &lt;- by(test3, test3$segment_id, function(x) {
  data.frame(
    hzID = x$hzID[1],
    segment_id = x$segment_id[1],
    average = weighted.mean(x$clay, w = x$hzthk)
  )
})
test3_agg &lt;- do.call("rbind", test3_agg)

head(test3_agg)

</code></pre>

<hr>
<h2 id='shannonEntropy'>Shannon Entropy</h2><span id='topic+shannonEntropy'></span>

<h3>Description</h3>

<p>A very simple implementation of Shannon entropy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shannonEntropy(x, b = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shannonEntropy_+3A_x">x</code></td>
<td>
<p>vector of probabilities (0,1), must sum to 1, should not contain NA</p>
</td></tr>
<tr><td><code id="shannonEntropy_+3A_b">b</code></td>
<td>
<p>logarithm base</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>0</code>s are automatically removed by <code>na.rm = TRUE</code>, as <code>(0 * log(0) = Nan)</code>
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>Note</h3>

<p>When <code>b = length(x)</code> the result is the normalized Shannon entropy of (Kempen et al, 2009).
</p>


<h3>References</h3>

<p>Kempen, Bas, Dick J. Brus, Gerard B.M. Heuvelink, and Jetse J. Stoorvogel. 2009. &quot;Updating the 1:50,000 Dutch Soil Map Using Legacy Soil Data: A Multinominal Logistic Regression Approach.&quot; Geoderma 151: 311-26. doi:10.1016/j.geoderma.2009.04.023
</p>
<p>Shannon, Claude E. (July-October 1948). &quot;A Mathematical Theory of Communication&quot;. Bell System Technical Journal. 27 (3): 379-423. doi:10.1002/j.1538-7305.1948.tb01338.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a very simple example
p &lt;- c(0.25, 0.25, 0.4, 0.05, 0.05)

shannonEntropy(p)



</code></pre>

<hr>
<h2 id='show'>SoilProfileCollection show method</h2><span id='topic+show'></span><span id='topic+show+2CSoilProfileCollection-method'></span><span id='topic+as.character+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Pretty output method for SoilProfileCollection objects. By default this method limits output to 10 columns and 6 rows from the site and horizon tables respectively.
</p>
<p>There is an aqp environment option you can set to increase the number of columns shown by default: <code>options(.aqp.show.n.cols = 100)</code>,
</p>
<p><code>as.character()</code>: Character Representation of SoilProfileCollection Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
show(object)

## S4 method for signature 'SoilProfileCollection'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="show_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="show_+3A_...">...</code></td>
<td>
<p>additional arguments (not used)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# load a SoilProfileCollection
data(sp5)

# use the show() method
show(sp5)

# which is same as this (in the console)
sp5

</code></pre>

<hr>
<h2 id='sierraTransect'>Soil Physical and Chemical Data Related to Studies in the Sierra Nevada
Mountains, CA, USA.</h2><span id='topic+sierraTransect'></span>

<h3>Description</h3>

<p>Soil physical and chemical data associated with two bio-climatic sequences
(granitic and andesitic parent material) from the western flank of the
Sierra Nevada mountains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sierraTransect)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>SoilProfileCollection</code> of length 14.
</p>


<h3>Details</h3>

<p>These data were assembled from Dahlgren et al. (1997) and Rasmussen et al.
(2007), with permission granted by lead authors, by D.E. Beaudette.
</p>


<h3>Source</h3>

<p>Original manuscripts and person communication with authors.
</p>


<h3>References</h3>

<p>R.A. Dahlgren, J.L. Boettinger, G.L. Huntington, R.G. Amundson.
Soil development along an elevational transect in the western Sierra Nevada,
California, Geoderma, Volume 78, Issues 3–4, 1997, Pages 207-236.
</p>
<p>Rasmussen, C., Matsuyama, N., Dahlgren, R.A., Southard, R.J. and Brauer, N.
(2007), Soil Genesis and Mineral Transformation Across an Environmental
Gradient on Andesitic Lahar. Soil Sci. Soc. Am. J., 71: 225-237.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sierraTransect)

# tighter margins
op &lt;- par(mar=c(0,0,0,0))

# quick sketch
plotSPC(sierraTransect, name.style = 'center-center', width=0.3)

# split by transect
par(mar=c(0,0,1,1))
groupedProfilePlot(
sierraTransect, groups='transect',
group.name.offset = -15, width=0.3,
name.style='center-center'
)

# thematic
groupedProfilePlot(
sierraTransect, groups='transect',
group.name.offset = -15, width=0.3,
name.style='center-center', color='Fe_o_to_Fe_d'
)

# horizon boundary viz
sierraTransect$hzd &lt;- hzDistinctnessCodeToOffset(substr(sierraTransect$hz_boundary, 0, 1))

groupedProfilePlot(
sierraTransect, groups='transect', group.name.offset = -15,
width=0.3, name.style='center-center', color='Fe_o_to_Fe_d',
hz.distinctness.offset='hzd')


# split transects
g &lt;- subset(sierraTransect, transect == 'Granite')
a &lt;- subset(sierraTransect, transect == 'Andesite')

g.order &lt;- order(g$elev)
a.order &lt;- order(a$elev)

# order (left -&gt; right) by elevation
par(mar=c(2,0,0,2), mfrow=c(2,1))
plot(g, width=0.3, name.style='center-center', cex.names=0.75, plot.order=g.order)
axis(1, at=1:length(g), labels=g$elev[g.order], line=-1.5)

plot(a, width=0.3, name.style='center-center', cex.names=0.75, plot.order=a.order)
axis(1, at=1:length(a), labels=a$elev[a.order], line=-1.5)


par(op)

</code></pre>

<hr>
<h2 id='sim'>DEPRECATED Simulate Soil Profiles</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>Simulate a collection of soil profiles based on the horizonation of a single soil profile. Now deprecated: use <code><a href="#topic+perturb">perturb()</a></code> for perturbations of horizon thicknesses or boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(x, n = 1, iterations = 25, hz.sd = 2, min.thick = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection object containing a single profile from which to draw simulated data</p>
</td></tr>
<tr><td><code id="sim_+3A_n">n</code></td>
<td>
<p>the number of requested simulations</p>
</td></tr>
<tr><td><code id="sim_+3A_iterations">iterations</code></td>
<td>
<p>sampling iterations used to determine each horizon thickness</p>
</td></tr>
<tr><td><code id="sim_+3A_hz.sd">hz.sd</code></td>
<td>
<p>standard deviation used to simulate horizon thickness, can be a vector but must divide evenly into the number of horizons found in <code>x</code></p>
</td></tr>
<tr><td><code id="sim_+3A_min.thick">min.thick</code></td>
<td>
<p>minimum horizon thickness allowed in simulation results</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a collection of simulated soil profiles based on the horizon thickness data associated with a single &quot;template&quot; profile. Simulation is based on sampling from a family of Gaussian distribution with means defined by the &quot;template&quot; profile and standard deviation defined by the user.
</p>


<h3>Value</h3>

<p>A SoilProfileCollection object with <code>n</code> simulated profiles, each containing the same number of horizons and same data as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>D. E. Beaudette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+random_profile">random_profile</a></code>  <code><a href="#topic+perturb">perturb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# please see documentation for perturb() for examples
#  the sim() function calls perturb() internally

</code></pre>

<hr>
<h2 id='simulateColor'>Simulate Soil Colors</h2><span id='topic+simulateColor'></span>

<h3>Description</h3>

<p>Simulate plausible soil colors based on proportions by Munsell &quot;chip&quot;, or using a seed Munsell chip and threshold specified via CIE2000 color contrast metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateColor(method = c("dE00", "proportions"), n, parameters, SPC = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateColor_+3A_method">method</code></td>
<td>
<p>simulation method, see details</p>
</td></tr>
<tr><td><code id="simulateColor_+3A_n">n</code></td>
<td>
<p>number of simulated colors per horizon</p>
</td></tr>
<tr><td><code id="simulateColor_+3A_parameters">parameters</code></td>
<td>
<p>a <code>list</code>, format depends on <code>method</code>:
</p>

<ul>
<li> <p><code>proportions</code>: output from <code><a href="#topic+aggregateColor">aggregateColor</a></code>
</p>
</li>
<li> <p><code>dE00</code>: formatted as <code>list(m = '7.5YR 3/3', thresh = 5, hues = c('7.5YR'))</code>
</p>
</li></ul>

<p>Where <code>m</code> is a single representative Munsell chip, <code>thresh</code> is a threshold specified in CIE2000 color contrast (dE00), and <code>hues</code> is a vector of allowed Munsell hues.</p>
</td></tr>
<tr><td><code id="simulateColor_+3A_spc">SPC</code></td>
<td>
<p><code>SoilProfileCollection</code>, attempt to modify <code>SPC</code> with simulated colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code>, unless <code>SPC</code> is specified, then a <code>SoilProfileCollection</code> object
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# restrict examples to 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

# m: representative or most likely color
# thresh: dE00 threshold
# hues: allowed Munsell hues
p &lt;- list(
  'A' = list(m = '7.5YR 3/3', thresh = 5, hues = c('7.5YR')),
  'BA' = list(m = '7.5YR 4/4', thresh = 8, hues = c('7.5YR')),
  'Bt1' = list(m = '7.5YR 4/4', thresh = 8, hues = c('5YR', '7.5YR')),
  'Bt2' = list(m = '5YR 4/5', thresh = 8, hues = c('5YR', '7.5YR')),
  'Bt3' = list(m = '10YR 4/6', thresh = 10, hues = c('10YR', '7.5YR')),
  'Cr' = list(m = '2.5G 6/2', thresh = 15, hues = c('2.5G', '2.5GY', '2.5BG'))
)

# simulate
(cols &lt;- simulateColor(method = 'dE00', n = 10, parameters = p))

# preview
previewColors(parseMunsell(unlist(cols)), method = 'MDS')

# another example, this time using a larger dE00 threshold
p &lt;- list(
  'A' = list(m = '7.5YR 3/3', thresh = 20, hues = c('10YR', '7.5YR', '5YR'))
)

# simulate
set.seed(54654)
cols &lt;- simulateColor(method = 'dE00', n = 200, parameters = p)

# flatten
cols &lt;- unlist(cols)

# tabulate, sort: most frequent color should be 7.5YR 3/3
sort(table(cols), decreasing = TRUE)

# review colors
previewColors(parseMunsell(cols))

# what does a dE00 threshold look like on 3 pages of hue?
contrastChart('7.5YR 3/3', hues = c('10YR', '7.5YR', '5YR'), thresh = 20)

</code></pre>

<hr>
<h2 id='site+2CSoilProfileCollection-method'>Retrieve site data from SoilProfileCollection</h2><span id='topic+site+2CSoilProfileCollection-method'></span><span id='topic+site'></span><span id='topic+site+3C-'></span><span id='topic+site+3C-+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>Get site data from SoilProfileCollection. Result is returned in the same <code>data.frame</code> class used to initially construct the SoilProfileCollection.
</p>
<p>There are two options available via the <code>site&lt;-</code> setter.
</p>
<p>The first is a &quot;normalization&quot; by formula interface, whereby one specifies an attribute that is constant in horizons within profiles to be promoted to a site-level variable: <code>site(spc) &lt;- ~ horizonvariable</code>
</p>
<p>The second is creation of site data from an external <code>data.frame</code> via merge (LEFT JOIN). There must be one or more same-named columns (with at least some matching data) on the left and right hand side to facilitate the join: <code>site(spc) &lt;- newdata</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
site(object)

site(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="site+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="site+2B2CSoilProfileCollection-method_+3A_value">value</code></td>
<td>
<p>A formula or object inheriting <code>data.frame</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# load test data
data(sp2)

# promote to SPC
depths(sp2) &lt;- id ~ top + bottom

# normalize a horizon-level attribute to site
site(sp2) &lt;- ~ surface

# inspect site table
site(sp2)

# make some data: classify two geomorphic surfaces with numeric value
newdata &lt;- data.frame(surface = c("holocene",
                                  "lower riverbank"),
                      newvalue = c(1,2))

# do left join based on newly-normalized "surface" attribute
site(sp2) &lt;- newdata

# inspect site table: holocene &amp; lower riverbank have values
site(sp2)

</code></pre>

<hr>
<h2 id='siteNames+26lt+3B-'>Set site column names</h2><span id='topic+siteNames+3C-'></span><span id='topic+siteNames+3C-+2CSoilProfileCollection-method'></span><span id='topic+siteNames+2CSoilProfileCollection-method'></span><span id='topic+siteNames'></span>

<h3>Description</h3>

<p>Set site column names
</p>
<p>Get names of columns in site table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SoilProfileCollection'
siteNames(object) &lt;- value

## S4 method for signature 'SoilProfileCollection'
siteNames(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siteNames+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="siteNames+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>a unique vector of equal length to number of columns in site: <code>length(siteNames(object))</code></p>
</td></tr>
</table>

<hr>
<h2 id='slab'>Slab-Wise Aggregation of SoilProfileCollection Objects</h2><span id='topic+slab'></span><span id='topic+slab+2CSoilProfileCollection-method'></span><span id='topic+slab_function'></span>

<h3>Description</h3>

<p>Aggregate soil properties along user-defined <code>slabs</code>, and optionally within
groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
slab(
  object,
  fm,
  slab.structure = 1,
  strict = FALSE,
  byhz = TRUE,
  slab.fun = slab_function(method = "numeric"),
  cpm = 1,
  weights = NULL,
  ...
)

slab_function(
  method = c("numeric", "factor", "hd", "weighted.numeric", "weighted.factor", "fast")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slab_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="slab_+3A_fm">fm</code></td>
<td>
<p>A formula: either <code>groups ~ var1 + var2 + var3</code> where named
variables are aggregated within <code style="white-space: pre;">&#8288;groups' OR where named variables are aggregated across the entire collection &#8288;</code> ~ var1 + var2 + var3<code style="white-space: pre;">&#8288;. If &#8288;</code>groups<code style="white-space: pre;">&#8288;is a factor it must not contain&#8288;</code>NA'</p>
</td></tr>
<tr><td><code id="slab_+3A_slab.structure">slab.structure</code></td>
<td>
<p>A user-defined slab thickness (defined by an integer),
or user-defined structure (numeric vector). See details below.</p>
</td></tr>
<tr><td><code id="slab_+3A_strict">strict</code></td>
<td>
<p>logical: should horizons be strictly checked for
self-consistency?</p>
</td></tr>
<tr><td><code id="slab_+3A_byhz">byhz</code></td>
<td>
<p>logical: should horizons or whole profiles be removed by logic checks in <code>strict</code>? Default <code>TRUE</code> removes only offending horizons, <code>FALSE</code> removes whole profiles with one or more illogical horizons.</p>
</td></tr>
<tr><td><code id="slab_+3A_slab.fun">slab.fun</code></td>
<td>
<p>Function used to process each 'slab' of data, ideally
returning a vector with names attribute. Defaults to a wrapper function
around <code>stats::quantile()</code>. See details.</p>
</td></tr>
<tr><td><code id="slab_+3A_cpm">cpm</code></td>
<td>
<p>Strategy for normalizing slice-wise probabilities, dividing by
either: number of profiles with data at the current slice (<code>cpm=1</code>), or by the
number of profiles in the collection (cpm=2). Mode 1 values will always sum
to the contributing fraction, while mode 2 values will always sum to 1.</p>
</td></tr>
<tr><td><code id="slab_+3A_weights">weights</code></td>
<td>
<p>Column name containing site-level weights</p>
</td></tr>
<tr><td><code id="slab_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>slab.fun</code></p>
</td></tr>
<tr><td><code id="slab_+3A_method">method</code></td>
<td>
<p>one of <code>"numeric"</code>, <code>"factor"</code>, <code>"hd"</code>, <code>"weighted.numeric"</code>, <code>"weighted.factor"</code>, <code>"fast"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple continuous variables OR a single categorical (factor) variable can
be aggregated within a call to <code>slab</code>. Basic error checking is
performed to make sure that top and bottom horizon boundaries make sense.
User-defined aggregate functions (<code>slab.fun</code>) should return a named
vector of results. A new, named column will appear in the results of
<code>slab</code> for every named element of a vector returned by <code>slab.fun</code>.
See examples below for a simple example of a slab function that computes
mean, mean-1SD and mean+1SD. The default slab function wraps
<code>stats::quantile</code> from the Hmisc package, which requires at least 2
observations per chunk. Note that if <code>group</code> is a factor it must not contain
NAs.
</p>
<p><code>slab()</code> uses <code>dice()</code> to &quot;resample&quot; profiles to 1cm slices from depth 0 to <code>max(x)</code> (or <code>slab.structure[2]</code>, if defined).
</p>
<p>Sometimes <code>slab</code> is used to conveniently re-arrange data vs. aggregate.
This is performed by specifying <code>identity</code> in <code>slab.fun</code>. See
examples beflow for a demonstration of this functionality.
</p>
<p>The default <code>slab.fun</code> was changed 2019-10-30 from a wrapper around
<code>Hmisc::hdquantile</code> to a wrapper around <code>stats::quantile</code>. See
examples below for a simple way to switch to the HD quantile estimator.
</p>
<p>Execution time scales linearly (slower) with the total number of profiles in
<code>object</code>, and exponentially (faster) as the number of profiles / group
is increased. <code>slab</code> and <code>slice</code> are much faster and require less
memory if input data are either numeric or character.
</p>
<p>There are several possible ways to define slabs, using
<code>slab.structure</code>:
</p>
 <dl>
<dt>a single integer</dt><dd><p>e.g. 10: data are aggregated over a
regular sequence of 10-unit thickness slabs</p>
</dd> <dt>a vector of 2
integers</dt><dd><p>e.g. c(50, 60): data are aggregated over depths spanning 50&ndash;60
units</p>
</dd> <dt>a vector of 3 or more integers</dt><dd><p>e.g. c(0, 5, 10, 50, 100): data
are aggregated over the depths spanning 0&ndash;5, 5&ndash;10, 10&ndash;50, 50&ndash;100 units</p>
</dd>
</dl>

<p><code>slab_function()</code>: The default <code>"numeric"</code> aggregation method is the <code>"fast"</code> numeric (quantile) method. Additional methods include <code>"factor"</code> for categorical data, <code>"hd"</code> to use the Harrell-Davis Distribution-Free Quantile Estimator from the Hmisc package, and &quot;<code>weighted</code>&quot; to use a weighted quantile method from the Hmisc package
</p>


<h3>Value</h3>

<p>Output is returned in long format, such that slice-wise aggregates
are returned once for each combination of grouping level (optional),
variable described in the <code>fm</code> argument, and depth-wise 'slab'.
</p>
<p>Aggregation of numeric variables, using the default slab function:
</p>
 <dl>
<dt>variable</dt><dd><p>The names of variables included in the call to
<code>slab</code>.</p>
</dd> <dt>groupname</dt><dd><p>The name of the grouping variable when
provided, otherwise a fake grouping variable named 'all.profiles'.</p>
</dd>
<dt>p.q5</dt><dd><p>The slice-wise 5th percentile.</p>
</dd> <dt>p.q25</dt><dd><p>The slice-wise 25th
percentile</p>
</dd> <dt>p.q50</dt><dd><p>The slice-wise 50th percentile (median)</p>
</dd>
<dt>p.q75</dt><dd><p>The slice-wise 75th percentile</p>
</dd> <dt>p.q95</dt><dd><p>The slice-wise
95th percentile</p>
</dd> <dt>top</dt><dd><p>The slab top boundary.</p>
</dd> <dt>bottom</dt><dd><p>The slab
bottom boundary.</p>
</dd> <dt>contributing_fraction</dt><dd><p>The fraction of profiles
contributing to the aggregate value, ranges from 1/n_profiles to 1.</p>
</dd> </dl>

<p>When a single factor variable is used, slice-wise probabilities for each
level of that factor are returned as: </p>
 <dl>
<dt>variable</dt><dd><p>The names
of variables included in the call to <code>slab</code>.</p>
</dd> <dt>groupname</dt><dd><p>The name
of the grouping variable when provided, otherwise a fake grouping variable
named 'all.profiles'.</p>
</dd> <dt>A</dt><dd><p>The slice-wise probability of level A</p>
</dd>
<dt>B</dt><dd><p>The slice-wise probability of level B</p>
</dd> <dt>list()</dt><dd></dd> <dt>n</dt><dd><p>The
slice-wise probability of level n</p>
</dd> <dt>top</dt><dd><p>The slab top boundary.</p>
</dd>
<dt>bottom</dt><dd><p>The slab bottom boundary.</p>
</dd> <dt>contributing_fraction</dt><dd><p>The
fraction of profiles contributing to the aggregate value, ranges from
1/n_profiles to 1.</p>
</dd>
</dl>

<p><code>slab_function()</code>: return an aggregation function based on the <code>method</code> argument
</p>


<h3>Methods</h3>

 <dl>
<dt>data = &quot;SoilProfileCollection&quot;</dt><dd><p>Typical
usage, where input is a <code><a href="#topic+SoilProfileCollection">SoilProfileCollection</a></code>.</p>
</dd> </dl>



<h3>Note</h3>

<p>Arguments to <code>slab</code> have changed with <code>aqp</code> 1.5 (2012-12-29)
as part of a code clean-up and optimization. Calculation of
weighted-summaries was broken in <code>aqp</code> 1.2-6 (2012-06-26), and removed
as of <code>aqp</code> 1.5 (2012-12-29).  <code>slab</code> replaced the previously
defined <code>soil.slot.multiple</code> function as of <code>aqp</code> 0.98-8.58
(2011-12-21).
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>D.E. Beaudette, P. Roudier, A.T. O'Geen, Algorithms for
quantitative pedology: A toolkit for soil scientists, Computers &amp;
Geosciences, Volume 52, March 2013, Pages 258-268,
10.1016/j.cageo.2012.10.020.
</p>
<p>Harrell FE, Davis CE (1982): A new distribution-free quantile estimator.
Biometrika 69:635-640.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slice">slice</a>, <a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
## basic examples
##
library(lattice)
library(grid)
library(data.table)

# load sample data, upgrade to SoilProfileCollection
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

hzdesgnname(sp1) &lt;- "name"

# aggregate entire collection with two different segment sizes
a &lt;- slab(sp1, fm = ~ prop)
b &lt;- slab(sp1, fm = ~ prop, slab.structure=5)

# check output
str(a)

# stack into long format
ab &lt;- make.groups(a, b)
ab$which &lt;- factor(ab$which, levels=c('a','b'),
labels=c('1-cm Interval', '5-cm Interval'))

# plot median and IQR
# custom plotting function for uncertainty viz.
xyplot(top ~ p.q50 | which, data=ab, ylab='Depth',
			 xlab='median bounded by 25th and 75th percentiles',
			 lower=ab$p.q25, upper=ab$p.q75, ylim=c(250,-5),
			 panel=panel.depth_function,
			 prepanel=prepanel.depth_function,
			 cf=ab$contributing_fraction,
			 alpha=0.5,
			 layout=c(2,1), scales=list(x=list(alternating=1))
			 )


###
### re-arrange data / no aggregation
###

# load sample data, upgrade to SoilProfileCollection
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# arrange data by ID
a &lt;- slab(sp1, fm = id ~ prop, slab.fun=identity)

# convert id to a factor for plotting
a$id &lt;- factor(a$id)

# check output
str(a)

# plot via step function
xyplot(top ~ value | id, data=a, ylab='Depth',
       ylim=c(250, -5), as.table=TRUE,
       panel=panel.depth_function,
       prepanel=prepanel.depth_function,
       scales=list(x=list(alternating=1))
)

##
## categorical variable example
##

data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# normalize horizon names: result is a factor
sp1$name &lt;- generalize.hz(
  sp1$name,
  new = c('O','A','B','C'),
  pat = c('O', '^A','^B','C')
  )

# compute slice-wise probability so that it sums to contributing fraction, from 0-150
a &lt;- slab(sp1, fm= ~ name, cpm=1, slab.structure=0:150)

# convert wide -&gt; long for plotting
# result is a data.table
# genhz factor levels are set by order in `measure.vars`
a.long &lt;- data.table::melt(
  data.table::as.data.table(a),
  id.vars = c('top','bottom'),
  measure.vars = c('O', 'A', 'B', 'C'),
  )


# plot horizon type proportions using panels
xyplot(top ~ value | variable,
       data = a.long, subset=value &gt; 0,
       col = 1, lwd = 2,
       xlab = 'Class Probability',
       ylab = 'Depth (cm)',
       strip = strip.custom(bg = grey(0.85)),
       scales = list(x = list(alternating = FALSE)),
       ylim = c(150, -5), type=c('S','g'),
       horizontal = TRUE, layout = c(4,1)
       )

# again, this time using groups
xyplot(top ~ value,
       data = a.long,
       groups = variable,
       subset = value &gt; 0,
       ylim = c(150, -5),
       type = c('S','g'),
       horizontal = TRUE,
       asp = 2,
       lwd = 2,
       auto.key = list(
         lines = TRUE,
         points = FALSE,
         cex = 0.8,
         columns = 1,
         space = 'right'
       )
)

# adjust probability to size of collection, from 0-150
a.1 &lt;- slab(sp1, fm= ~ name, cpm = 2, slab.structure = 0:150)

# convert wide -&gt; long for plotting
# result is a data.table
# genhz factor levels are set by order in `measure.vars`
a.1.long &lt;- data.table::melt(
  data.table::as.data.table(a.1),
  id.vars = c('top','bottom'),
  measure.vars = c('O','A','B','C')
)

# combine aggregation from `cpm` modes 1 and 2
g &lt;- make.groups(cmp.mode.1 = a.long, cmp.mode.2 = a.1.long)

# plot horizon type proportions
xyplot(top ~ value | variable,
       groups = which,
       data = g, subset = value &gt; 0,
       ylim = c(240, -5),
       type = c('S','g'),
       horizontal = TRUE,
       layout = c(4,1),
       auto.key = list(lines = TRUE, points = FALSE, columns = 2),
       par.settings = list(superpose.line = list(col = c(1, 2), lwd = 2)),
       scales = list(alternating = 3),
       xlab = 'Class Probability',
       ylab = 'Depth (cm)',
       strip = strip.custom(bg = grey(0.85))
)


# apply slice-wise evaluation of max probability, and assign ML-horizon at each slice
gen.hz.ml &lt;- get.ml.hz(a, c('O','A','B','C'))


## Not run: 
##
## HD quantile estimator
##

library(soilDB)
library(lattice)
library(data.table)

# sample data
data('loafercreek', package = 'soilDB')

# defaul slab.fun wraps stats::quantile()
a &lt;- slab(loafercreek, fm = ~ total_frags_pct + clay)

# use HD quantile estimator from Hmisc package instead
a.HD &lt;- slab(loafercreek, fm = ~ total_frags_pct + clay, slab.fun = aqp:::.slab.fun.numeric.HD)

# combine
g &lt;- make.groups(standard=a, HD=a.HD)

# note differences
densityplot(~ p.q50 | variable, data=g, groups=which,
            scales=list(relation='free', alternating=3, tick.number=10, y=list(rot=0)),
            xlab='50th Percentile', pch=NA, main='Loafercreek',
            auto.key=list(columns=2, points=FALSE, lines=TRUE),
            par.settings=list(superpose.line=list(lwd=2, col=c('RoyalBlue', 'Orange2')))
)

# differences are slight but important
xyplot(
  top ~ p.q50 | variable, data=g, groups=which,
  xlab='Value', ylab='Depth (cm)',
  asp=1.5, main='Loafercreek',
  lower=g$p.q25, upper=g$p.q75,
  sync.colors=TRUE, alpha=0.25, cf=g$contributing_fraction,
  ylim=c(115,-5), layout=c(2,1), scales=list(x=list(relation='free')),
  par.settings=list(superpose.line=list(lwd=2, col=c('RoyalBlue', 'Orange2'))),
  strip=strip.custom(bg=grey(0.85)),
  panel=panel.depth_function,
  prepanel=prepanel.depth_function,
  auto.key=list(columns=2, lines=TRUE, points=FALSE)
)

##
## multivariate examples
##
data(sp3)

# add new grouping factor
sp3$group &lt;- 'group 1'
sp3$group[as.numeric(sp3$id) &gt; 5] &lt;- 'group 2'
sp3$group &lt;- factor(sp3$group)

# upgrade to SPC
depths(sp3) &lt;- id ~ top + bottom
site(sp3) &lt;- ~ group

# custom 'slab' function, returning mean +/- 1SD
mean.and.sd &lt;- function(values) {
  m &lt;- mean(values, na.rm=TRUE)
  s &lt;- sd(values, na.rm=TRUE)
  upper &lt;- m + s
  lower &lt;- m - s
  res &lt;- c(mean=m, lower=lower, upper=upper)
  return(res)
}

# aggregate several variables at once, within 'group'
a &lt;- slab(sp3, fm = group ~ L + A + B, slab.fun = mean.and.sd)

# check the results:
# note that 'group' is the column containing group labels
xyplot(
  top ~ mean | variable, data=a, groups=group,
  lower=a$lower, upper=a$upper,
  sync.colors=TRUE, alpha=0.5,
  cf = a$contributing_fraction,
  xlab = 'Mean Bounded by +/- 1SD',
  ylab = 'Depth (cm)',
  ylim=c(125,-5), layout=c(3,1),
  scales=list(x=list(relation='free')),
  par.settings = list(superpose.line=list(lwd=2, col=c('RoyalBlue', 'Orange2'))),
  panel = panel.depth_function,
  prepanel = prepanel.depth_function,
  strip = strip.custom(bg=grey(0.85)),
  auto.key = list(columns=2, lines=TRUE, points=FALSE)
)


# compare a single profile to the group-level aggregate values
a.1 &lt;- slab(sp3[1, ], fm = group ~ L + A + B, slab.fun = mean.and.sd)

# manually update the group column
a.1$group &lt;- 'profile 1'

# combine into a single data.frame:
g &lt;- rbind(a, a.1)

# plot with customized line styles
xyplot(
  top ~ mean | variable, data=g, groups=group, subscripts=TRUE,
  lower=a$lower, upper=a$upper, ylim=c(125,-5),
  layout=c(3,1), scales=list(x=list(relation='free')),
  xlab = 'Mean Bounded by +/- 1SD',
  ylab = 'Depth (cm)',
  panel=panel.depth_function,
  prepanel=prepanel.depth_function,
  sync.colors = TRUE, alpha = 0.25,
  par.settings = list(
    superpose.line = list(
      col = c('orange', 'royalblue', 'black'),
      lwd = 2, lty = c(1,1,2)
    )
  ),
  strip = strip.custom(bg=grey(0.85)),
  auto.key = list(columns=3, lines=TRUE, points=FALSE)
)




## again, this time for a user-defined slab from 40-60 cm
a &lt;- slab(sp3,
          fm = group ~ L + A + B,
          slab.structure = c(40,60),
          slab.fun = mean.and.sd
)

# now we have weighted average properties (within the defined slab)
# for each variable, and each group
# convert long -&gt; wide
data.table::dcast(
  data.table::as.data.table(a),
  formula = group + top + bottom ~ variable,
  value.var = 'mean'
)

## this time, compute the weighted mean of selected properties, by profile ID
a &lt;- slab(sp3,
          fm = id ~ L + A + B,
          slab.structure = c(40,60),
          slab.fun = mean.and.sd
)

# convert long -&gt; wide
data.table::dcast(
  data.table::as.data.table(a),
  formula = id + top + bottom ~ variable,
  value.var = 'mean'
)


## aggregate the entire collection, using default slab function (hdquantile)
## note the missing left-hand side of the formula
a &lt;- slab(sp3, fm= ~ L + A + B)



## weighted-aggregation -- NOT YET IMPLEMENTED --
# load sample data, upgrade to SoilProfileCollection
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# generate pretend weights as site-level attribute
set.seed(10101)
sp1$site.wts &lt;- runif(n=length(sp1), min=20, max=100)

## End(Not run)

</code></pre>

<hr>
<h2 id='slice-methods'>Slicing of SoilProfileCollection Objects</h2><span id='topic+slice-methods'></span><span id='topic+slice.fast'></span><span id='topic+get.slice'></span><span id='topic+slice'></span><span id='topic+slice+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>A method for &quot;slicing&quot; of SoilProfileCollection objects into constant depth intervals. Now deprecated, see <code style="white-space: pre;">&#8288;[dice()]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice.fast(object, fm, top.down = TRUE, just.the.data = FALSE, strict = TRUE)

## S4 method for signature 'SoilProfileCollection'
slice(object, fm, top.down = TRUE, just.the.data = FALSE, strict = TRUE)

get.slice(h, id, top, bottom, vars, z, include = "top", strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice-methods_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_fm">fm</code></td>
<td>
<p>A formula: either <code>integer.vector ~ var1 + var2 + var3</code> where
named variables are sliced according to <code>integer.vector</code> OR where all
variables are sliced according to <code>integer.vector</code>: <code>integer.vector ~ .</code>.</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_top.down">top.down</code></td>
<td>
<p>logical, slices are defined from the top-down: <code>0:10</code> implies 0-11 depth units.</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_just.the.data">just.the.data</code></td>
<td>
<p>Logical, return just the sliced data or a new <code>SoilProfileCollection</code> object.</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_strict">strict</code></td>
<td>
<p>Check for logic errors? Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="slice-methods_+3A_h">h</code></td>
<td>
<p>Horizon data.frame</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_id">id</code></td>
<td>
<p>Profile ID</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_top">top</code></td>
<td>
<p>Top Depth Column Name</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_bottom">bottom</code></td>
<td>
<p>Bottom Depth Column Name</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_vars">vars</code></td>
<td>
<p>Variables of Interest</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_z">z</code></td>
<td>
<p>Slice Depth (index).</p>
</td></tr>
<tr><td><code id="slice-methods_+3A_include">include</code></td>
<td>
<p>Either <code>'top'</code> or <code>'bottom'</code>. Boundary to include in slice. Default: <code>'top'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a new <code>SoilProfileCollection</code> with data sliced according to <code>fm</code>, or a <code>data.frame</code>.
</p>


<h3>Details</h3>

<p>By default, slices are defined from the top-down:
<code>0:10</code> implies 0-11 depth units.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>D.E. Beaudette, P. Roudier, A.T. O'Geen, Algorithms for
quantitative pedology: A toolkit for soil scientists, Computers &amp;
Geosciences, Volume 52, March 2013, Pages 258-268,
10.1016/j.cageo.2012.10.020.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slab">slab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(aqp)

# simulate some data, IDs are 1:20
d &lt;- lapply(1:20, random_profile)
d &lt;- do.call('rbind', d)

# init SoilProfileCollection object
depths(d) &lt;- id ~ top + bottom
head(horizons(d))

# generate single slice at 10 cm
# output is a SoilProfileCollection object
s &lt;- dice(d, fm = 10 ~ name + p1 + p2 + p3)

# generate single slice at 10 cm, output data.frame
s &lt;- dice(d, 10 ~ name + p1 + p2 + p3, SPC = FALSE)

# generate integer slices from 0 - 26 cm
# note that slices are specified by default as "top-down"
# result is a SoilProfileCollection
# e.g. the lower depth will always by top + 1
s &lt;- dice(d, fm = 0:25 ~ name + p1 + p2 + p3)
par(mar=c(0,1,0,1))
plotSPC(s)

# generate slices from 0 - 11 cm, for all variables
s &lt;- dice(d, fm = 0:10 ~ .)
print(s)

# compute percent missing, for each slice,
# if all vars are missing, then NA is returned
d$p1[1:10] &lt;- NA
s &lt;- dice(d, 10 ~ ., SPC = FALSE, pctMissing = TRUE)
head(s)

## Not run: 
##
## check sliced data
##

# test that mean of 1 cm slices property is equal to the
# hz-thickness weighted mean value of that property
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# get the first profile
sp1.sub &lt;- sp1[which(profile_id(sp1) == 'P009'), ]

# compute hz-thickness wt. mean
hz.wt.mean &lt;- with(
  horizons(sp1.sub),
  sum((bottom - top) * prop) / sum(bottom - top)
)

# hopefully the same value, calculated via slice()
s &lt;- dice(sp1.sub, fm = 0:max(sp1.sub) ~ prop)
hz.slice.mean &lt;- mean(s$prop, na.rm = TRUE)

# they are the same
all.equal(hz.slice.mean, hz.wt.mean)

## End(Not run)

</code></pre>

<hr>
<h2 id='slicedHSD'>Tukey's HSD Over Slices</h2><span id='topic+slicedHSD'></span>

<h3>Description</h3>

<p>Apply Tukey's HSD over 1-unit depth slices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slicedHSD(object, fm, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slicedHSD_+3A_object">object</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="slicedHSD_+3A_fm">fm</code></td>
<td>
<p>a formula describing depth sequence, horizon attribute, and site (grouping) attribute.
For example 0:100 ~ estimated_oc | taxonname</p>
</td></tr>
<tr><td><code id="slicedHSD_+3A_conf">conf</code></td>
<td>
<p>confidence applied in <code>TukeyHSD</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D.E. Beaudette and Sharon Perrone
</p>

<hr>
<h2 id='soil_minerals'>Munsell Colors of Common Soil Minerals</h2><span id='topic+soil_minerals'></span>

<h3>Description</h3>

<p>Munsell colors for some common soil minerals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(soil_minerals)
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 5 variables.
</p>
 <dl>
<dt>mineral</dt><dd><p>mineral name</p>
</dd> <dt>color</dt><dd><p>Munsell
color</p>
</dd> <dt>hue</dt><dd><p>Munsell hue</p>
</dd> <dt>value</dt><dd><p>Munsell value</p>
</dd>
<dt>chroma</dt><dd><p>Munsell chroma</p>
</dd> </dl>



<h3>Details</h3>

<p>Soil color and other properties including texture, structure, and
consistence are used to distinguish and identify soil horizons (layers) and
to group soils according to the soil classification system called Soil
Taxonomy. Color development and distribution of color within a soil profile
are part of weathering. As rocks containing iron or manganese weather, the
elements oxidize. Iron forms small crystals with a yellow or red color,
organic matter decomposes into black humus, and manganese forms black
mineral deposits. These pigments paint the soil (Michigan State Soil). Color
is also affected by the environment: aerobic environments produce sweeping
vistas of uniform or subtly changing color, and anaerobic (lacking oxygen),
wet environments disrupt color flow with complex, often intriguing patterns
and points of accent. With depth below the soil surface, colors usually
become lighter, yellower, or redder.
</p>


<h3>References</h3>


<ol>
<li><p> Lynn, W.C. and Pearson, M.J., The Color of Soil, The Science
Teacher, May 2000. 2. Schwertmann, U. 1993. Relations Between Iron Oxides,
Soil Color, and Soil Formation. &quot;Soil Color&quot;. SSSA Special Publication no.
31, pages 51&ndash;69.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(aqp)
library(ape)
library(cluster)
library(farver)

# load common soil mineral colors
data(soil_minerals)

# convert Munsell to R colors
soil_minerals$col &lt;- munsell2rgb(
  soil_minerals$hue, 
  soil_minerals$value,
  soil_minerals$chroma
)

# make a grid for plotting
n &lt;- ceiling(sqrt(nrow(soil_minerals)))

# read from top-left to bottom-right
g &lt;- expand.grid(x=1:n, y=n:1)[1:nrow(soil_minerals),]

# convert Munsell -&gt; sRGB -&gt; LAB
col.rgb &lt;- munsell2rgb(
  soil_minerals$hue,
  soil_minerals$value,
  soil_minerals$chroma,
  return_triplets = TRUE
)

# sRGB values expected to be in the range [0,255]
col.rgb &lt;- col.rgb * 255

# convert from sRGB -&gt; CIE LAB
col.lab &lt;- convert_colour(
  col.rgb , from = 'rgb',
  to = 'lab', white_from = 'D65'
)

# keep track of soil mineral names
# in a way that will persist in a dist obj
row.names(col.lab) &lt;- soil_minerals$mineral

# perceptual distance via CIE dE00
d &lt;- compare_colour(
  from = col.lab,
  to = col.lab,
  from_space = 'lab',
  to_space = 'lab',
  white_from = 'D65',
  method = 'CIE2000'
)

# matrix -&gt; dist
d &lt;- as.dist(d)

# divisive hierarchical clustering of LAB coordinates
h &lt;- as.hclust(diana(d))
p &lt;- as.phylo(h)

# colors, in order based on clustering
# starting from top-left
min.cols &lt;- rev(soil_minerals$col[h$order])

# mineral names, in order based on clustering
# starting from top-left
min.names &lt;- rev(soil_minerals$mineral[h$order])

min.munsell &lt;- rev(soil_minerals$color[h$order])

# plot grid of mineral names / colors
layout(matrix(c(1, 2), nrow = 1), widths = c(1.25, 1))

par(mar = c(1, 0, 0, 1))
plot(g$x, g$y, pch = 15, cex = 12, axes = FALSE, xlab = '', ylab = '',
     col = min.cols, 
     xlim = c(0.5, 5.5), ylim = c(1.5, 5.5)
)
text(g$x, g$y, min.names, adj = c(0.45, 5.5), cex = 0.75, font = 2)
text(g$x, g$y, min.munsell, col = invertLabelColor(min.cols), cex = 0.85, font = 2)

title(main = 'Common Soil Pigments', line = -1.75, cex.main = 2)
mtext('U. Schwertmann, 1993. SSSA Special Publication no. 31, pages 51--69', side = 1,
      cex = 0.75, line = -1.5)

# dendrogram + tip labels with mineral colors
plot(p, cex = 0.85, label.offset = 5, font = 1)
tiplabels(pch = 15, cex = 3, offset = 2, col = soil_minerals$col)


## End(Not run)


</code></pre>

<hr>
<h2 id='soilColorSignature'>Soil Profile Color Signatures</h2><span id='topic+soilColorSignature'></span>

<h3>Description</h3>

<p>Generate a color signature for each soil profile in a collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soilColorSignature(
  spc,
  r = "r",
  g = "g",
  b = "b",
  method = c("colorBucket", "depthSlices", "pam"),
  pam.k = 3,
  RescaleLightnessBy = 1,
  useProportions = TRUE,
  pigmentNames = c(".white.pigment", ".red.pigment", ".green.pigment", ".yellow.pigment",
    ".blue.pigment"),
  apply.fun = lapply
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soilColorSignature_+3A_spc">spc</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="soilColorSignature_+3A_r">r</code></td>
<td>
<p>horizon level attribute containing soil color (sRGB) red values</p>
</td></tr>
<tr><td><code id="soilColorSignature_+3A_g">g</code></td>
<td>
<p>horizon level attribute containing soil color (sRGB) green values</p>
</td></tr>
<tr><td><code id="soilColorSignature_+3A_b">b</code></td>
<td>
<p>horizon level attribute containing soil color (sRGB) blue values</p>
</td></tr>
<tr><td><code id="soilColorSignature_+3A_method">method</code></td>
<td>
<p>algorithm used to compute color signature, <code>colorBucket</code>, <code>depthSlices</code>, or <code>pam</code></p>
</td></tr>
<tr><td><code id="soilColorSignature_+3A_pam.k">pam.k</code></td>
<td>
<p>number of classes to request from <code>cluster::pam()</code></p>
</td></tr>
<tr><td><code id="soilColorSignature_+3A_rescalelightnessby">RescaleLightnessBy</code></td>
<td>
<p>rescaling factor for CIE LAB L-coordinate</p>
</td></tr>
<tr><td><code id="soilColorSignature_+3A_useproportions">useProportions</code></td>
<td>
<p>use proportions or quantities, see details</p>
</td></tr>
<tr><td><code id="soilColorSignature_+3A_pigmentnames">pigmentNames</code></td>
<td>
<p>names for resulting pigment proportions or quantities</p>
</td></tr>
<tr><td><code id="soilColorSignature_+3A_apply.fun">apply.fun</code></td>
<td>
<p>function passed to <code>aqp::profileApply(APPLY.FUN)</code> argument, can be used to add progress bars via <code>pbapply::pblapply</code>, or parallel processing with <code>furrr::future_map</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="http://ncss-tech.github.io/AQP/aqp/soil-color-signatures.html">related tutorial</a>.
</p>


<h3>Value</h3>

<p>For the <code>colorBucket</code> method, a <code>data.frame</code> object containing:
</p>

<ul>
<li><p> id column: set according to <code>idname(spc)</code>
</p>
</li>
<li> <p><code>.white.pigment</code>: proportion or quantity of CIE LAB L-values
</p>
</li>
<li> <p><code>.red.pigment</code>: proportion or quantity of CIE LAB positive A-values
</p>
</li>
<li> <p><code>.green.pigment</code>: proportion or quantity of CIE LAB negative A-values
</p>
</li>
<li> <p><code>.yellow.pigment</code>: proportion or quantity of CIE LAB positive B-values
</p>
</li>
<li> <p><code>.blue.pigment</code>: proportion or quantity of CIE LAB negative B-values
</p>
</li></ul>

<p>Column names can be adjusted with the <code>pigmentNames</code> argument.
</p>
<p>For the <code>depthSlices</code> method ...
</p>
<p>For the <code>pam</code> method ...
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Lab_color_space
</p>


<h3>See Also</h3>

<p><code><a href="#topic+munsell2rgb">munsell2rgb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# trivial example, not very interesting
data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# convert Munsell -&gt; sRGB triplets
rgb.data &lt;- munsell2rgb(sp1$hue, sp1$value, sp1$chroma, return_triplets = TRUE)
sp1$r &lt;- rgb.data$r
sp1$g &lt;- rgb.data$g
sp1$b &lt;- rgb.data$b

# extract color signature
pig &lt;- soilColorSignature(sp1)

</code></pre>

<hr>
<h2 id='soilPalette'>Soil Color Palette</h2><span id='topic+soilPalette'></span>

<h3>Description</h3>

<p>A very simple function for generating labeled swatches of soil colors. Largely based on <code>colorspace::swatchplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soilPalette(
  colors,
  lab = colors,
  lab.cex = 0.75,
  dynamic.labels = TRUE,
  x.inset = 0.01,
  y.inset = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soilPalette_+3A_colors">colors</code></td>
<td>
<p>vector of hex colors (e.g. #A66E46FF)</p>
</td></tr>
<tr><td><code id="soilPalette_+3A_lab">lab</code></td>
<td>
<p>vector of labels</p>
</td></tr>
<tr><td><code id="soilPalette_+3A_lab.cex">lab.cex</code></td>
<td>
<p>character scaling for labels</p>
</td></tr>
<tr><td><code id="soilPalette_+3A_dynamic.labels">dynamic.labels</code></td>
<td>
<p>logical, adjust label colors for maximum contrast via <code>invertLabelColor</code></p>
</td></tr>
<tr><td><code id="soilPalette_+3A_x.inset">x.inset</code></td>
<td>
<p>horizontal adjustment for labels</p>
</td></tr>
<tr><td><code id="soilPalette_+3A_y.inset">y.inset</code></td>
<td>
<p>vertical adjustment for labels</p>
</td></tr>
<tr><td><code id="soilPalette_+3A_...">...</code></td>
<td>
<p>further arguments to <code>colorspace::swatchplot</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The result is a simple figure on the active plotting device.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# maybe useful for teaching about soil color

par(mfrow=c(2,1), mar=c(1,1,1,1))

# demonstrate range of Munsell value
m &lt;- sprintf('10YR %s/4', 2:8)
# convert to hex representation
cols &lt;- parseMunsell(m)
# plot
soilPalette(cols, m)

# demonstrate range of Munsell chroma
m &lt;- sprintf('10YR 4/%s', 2:8)
# convert to hex representation
cols &lt;- parseMunsell(m)
# plot
soilPalette(cols, m)

</code></pre>

<hr>
<h2 id='SoilProfileCollection'>An S4 object representation of a group of soil profiles.</h2><span id='topic+SoilProfileCollection'></span><span id='topic+SoilProfileCollection-class'></span>

<h3>Description</h3>

<p>In general, one should use <code>depths()</code> to initiate a SoilProfileCollection object from data. However, sometimes there are instances where either an empty, or very specific, object is needed. If that is the case, the general constructor <code>SoilProfileCollection</code> is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SoilProfileCollection(
  idcol = "id",
  hzidcol = "hzID",
  depthcols = c("top", "bottom"),
  metadata = list(aqp_df_class = "data.frame", aqp_group_by = "", aqp_hzdesgn = "",
    aqp_hztexcl = "", stringsAsFactors = FALSE),
  horizons = data.frame(id = character(0), hzID = character(0), top = numeric(0), bottom
    = numeric(0), stringsAsFactors = FALSE),
  site = data.frame(id = character(0), stringsAsFactors = FALSE),
  sp = new("SpatialPoints"),
  diagnostic = data.frame(stringsAsFactors = FALSE),
  restrictions = data.frame(stringsAsFactors = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SoilProfileCollection_+3A_idcol">idcol</code></td>
<td>
<p>character Profile ID Column Name</p>
</td></tr>
<tr><td><code id="SoilProfileCollection_+3A_hzidcol">hzidcol</code></td>
<td>
<p>character Horizon ID Column Name</p>
</td></tr>
<tr><td><code id="SoilProfileCollection_+3A_depthcols">depthcols</code></td>
<td>
<p>character, length 2 Top and Bottom Depth Column Names</p>
</td></tr>
<tr><td><code id="SoilProfileCollection_+3A_metadata">metadata</code></td>
<td>
<p>list, metadata including data.frame class in use and depth units</p>
</td></tr>
<tr><td><code id="SoilProfileCollection_+3A_horizons">horizons</code></td>
<td>
<p>data.frame An object inheriting from data.frame containing Horizon data.</p>
</td></tr>
<tr><td><code id="SoilProfileCollection_+3A_site">site</code></td>
<td>
<p>data.frame An object inheriting from data.frame containing Site data.</p>
</td></tr>
<tr><td><code id="SoilProfileCollection_+3A_sp">sp</code></td>
<td>
<p>SpatialPoints A SpatialPoints object. No longer used in aqp 2+, see <code>?initSpatial</code></p>
</td></tr>
<tr><td><code id="SoilProfileCollection_+3A_diagnostic">diagnostic</code></td>
<td>
<p>data.frame An object inheriting from data.frame containing diagnostic feature data. Must contain profile ID. See <code>diagnostic_hz()</code></p>
</td></tr>
<tr><td><code id="SoilProfileCollection_+3A_restrictions">restrictions</code></td>
<td>
<p>data.frame An object inheriting from data.frame containing restrictive feature data. Must contain profile ID. See <code>restrictions()</code></p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>idcol</code></dt><dd><p>character.</p>
</dd>
<dt><code>hzidcol</code></dt><dd><p>character.</p>
</dd>
<dt><code>depthcols</code></dt><dd><p>character.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>list.</p>
</dd>
<dt><code>horizons</code></dt><dd><p>data.frame.</p>
</dd>
<dt><code>site</code></dt><dd><p>data.frame.</p>
</dd>
<dt><code>sp</code></dt><dd><p>SpatialPoints.</p>
</dd>
<dt><code>diagnostic</code></dt><dd><p>data.frame.</p>
</dd>
<dt><code>restrictions</code></dt><dd><p>data.frame.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pierre Roudier, Dylan E. Beaudette, Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## structure of default, empty SoilProfileCollection
str(SoilProfileCollection())


## use the depths() formula interface to specify
## profile ID, top and bottom depth and set up
## a SPC that is topologically correct and complete

d &lt;- do.call('rbind', lapply(1:10, random_profile))

# promote to SoilProfileCollection and plot
depths(d) &lt;- id ~ top + bottom
plot(d)

# split into new SoilProfileCollection objects by index
d.1 &lt;- d[1, ]
d.2 &lt;- d[2, ]
d.345 &lt;- d[3:5, ]

# combine profile collections
# note that profiles are sorted according to ID
d.new &lt;- c(d.345, d.1, d.2)
plot(d.new)

data(sp1)

## init SoilProfileCollection objects from data.frame
depths(sp1) &lt;- id ~ top + bottom

## depth units
du &lt;- depth_units(sp1)
depth_units(sp1) &lt;- 'in'
depth_units(sp1) &lt;- du

## horizon designation column
hzdesgnname(sp1) &lt;- "name"
hzdesgnname(sp1)

## all designations in an SPC (useful for single profile SPC)
hzDesgn(sp1)

## horizon texture class column
hztexclname(sp1) &lt;- "texture"
hztexclname(sp1)

## get/set metadata on SoilProfileCollection objects
# this is a 1-row data.frame
m &lt;- metadata(sp1)
m$sampler &lt;- 'Dylan'
metadata(sp1) &lt;- m

## extract horizon data from SoilProfileCollection objects as data.frame
h &lt;- horizons(sp1)

# also merge (left-join) of new columns and
# replacement of existing columns via horizons&lt;-
horizons(sp1) &lt;- h

# get number of horizons
nrow(sp1)


## getting site-level data
site(sp1)

## setting site-level data
# site-level data from horizon-level data (stored in @horizons)
site(sp1) &lt;- ~ group


# make some fake site data, and append from data.frame
# a matching ID column must be present in both @site and new data
# note that IDs should all be character class
d &lt;- data.frame(id=profile_id(sp1), p=runif(n=length(sp1)), stringsAsFactors=FALSE)
site(sp1) &lt;- d

# edit horizon depths
horizonDepths(sp1) &lt;- c('t', 'b')
horizonDepths(sp1)

# edit profile IDs
p &lt;- sprintf("%s-new", profile_id(sp1))
profile_id(sp1) &lt;- p
profile_id(sp1)

</code></pre>

<hr>
<h2 id='soiltexture'>Lookup tables for sand, silt, clay, texture class, and textural modifiers.</h2><span id='topic+soiltexture'></span>

<h3>Description</h3>

<p>A list that contains a snapshot of the values generated using the logic from
the particle size estimator calculation in NASIS, the average values per
texture class, and average rock fragment values by textural modifier.
</p>
<p>A list that contains a snapshot of the values generated using the logic from
the particle size estimator calculation in NASIS, the average values per
texture class, and average rock fragment values by textural modifier.
</p>


<h3>Format</h3>

<p>A list with 3 data frames. The first named values which contains
values for sand, silt and clay by texture class. The second with average
values for sand, silt and clay per texture class. The third has fragvoltot
low, rv and high values for texmod.  </p>
 <dl>
<dt>list(&quot;clay&quot;)</dt><dd><p>clay
percentage of the fine earth fraction, a integer vector</p>
</dd>
<dt>list(&quot;sand&quot;)</dt><dd><p>sand percentage of the fine earth fraction, a integer
vector</p>
</dd> <dt>list(&quot;silt&quot;)</dt><dd><p>silt percentage of the fine earth fraction, a
integer vector</p>
</dd> <dt>list(&quot;texcl&quot;)</dt><dd><p>texture class, a character vector</p>
</dd>
<dt>list(&quot;texmod&quot;)</dt><dd><p>textural modifiers, a character vector</p>
</dd> </dl>

<p>A list with 3 data frames. The first named values which contains
values for sand, silt and clay by texture class. The second with average
values for sand, silt and clay per texture class. The third has fragvoltot
low, rv and high values for texmod.  </p>
 <dl>
<dt>list(&quot;clay&quot;)</dt><dd><p>clay
percentage of the fine earth fraction, a integer vector</p>
</dd>
<dt>list(&quot;sand&quot;)</dt><dd><p>sand percentage of the fine earth fraction, a integer
vector</p>
</dd> <dt>list(&quot;silt&quot;)</dt><dd><p>silt percentage of the fine earth fraction, a
integer vector</p>
</dd> <dt>list(&quot;texcl&quot;)</dt><dd><p>texture class, a character vector</p>
</dd>
<dt>list(&quot;texmod&quot;)</dt><dd><p>textural modifiers, a character vector</p>
</dd> </dl>



<h3>Details</h3>

<p>A list that contains a snapshot of the values generated using the logic from
the particle size estimator calculation in NASIS, and the average values per
texture class.
</p>
<p>A list that contains a snapshot of the values generated using the logic from
the particle size estimator calculation in NASIS, and the average values per
texture class.
</p>

<hr>
<h2 id='SoilTextureLevels'>Ranking Systems for USDA Soil Texture Classes</h2><span id='topic+SoilTextureLevels'></span>

<h3>Description</h3>

<p>Generate a vector of USDA soil texture codes or class names, sorted according to approximate particle size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SoilTextureLevels(which = "codes", simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SoilTextureLevels_+3A_which">which</code></td>
<td>
<p>'codes' (texture codes) or 'names' (texture class names)</p>
</td></tr>
<tr><td><code id="SoilTextureLevels_+3A_simplify">simplify</code></td>
<td>
<p>Return 12-class factor levels (<code>TRUE</code>) or 21-class factor levels (default: <code>FALSE</code>)? The 12-class system does not separate sands, loamy sands and sandy loams into sand fraction variants (e.g. &quot;very fine sandy loam&quot; in the 21-class system is &quot;sandy loam&quot; in 12-class system)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ordered factor
</p>


<h3>References</h3>

<p><a href="https://nrcspad.sc.egov.usda.gov/DistributionCenter/product.aspx?ProductID=991">Field Book for Describing and Sampling Soils, version 3.0</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# class codes
SoilTextureLevels()

# class names
SoilTextureLevels(which = 'names')

# simpler class names
SoilTextureLevels(which = 'names', simplify = TRUE)
 
</code></pre>

<hr>
<h2 id='sp1'>Soil Profile Data Example 1</h2><span id='topic+sp1'></span>

<h3>Description</h3>

<p>Soil profile data from Pinnacles National Monument, CA.
</p>


<h3>Format</h3>

<p>A data frame with 60 observations on the following 21 variables.
</p>
 <dl>
<dt>group</dt><dd><p>a numeric vector</p>
</dd> <dt>id</dt><dd><p>a
character vector</p>
</dd> <dt>top</dt><dd><p>a numeric vector</p>
</dd>
<dt>bottom</dt><dd><p>a numeric vector</p>
</dd> <dt>bound_distinct</dt><dd><p>a
character vector</p>
</dd> <dt>bound_topography</dt><dd><p>a character vector</p>
</dd>
<dt>name</dt><dd><p>a character vector</p>
</dd> <dt>texture</dt><dd><p>a character
vector</p>
</dd> <dt>prop</dt><dd><p>a numeric vector</p>
</dd>
<dt>structure_grade</dt><dd><p>a character vector</p>
</dd>
<dt>structure_size</dt><dd><p>a character vector</p>
</dd>
<dt>structure_type</dt><dd><p>a character vector</p>
</dd>
<dt>stickiness</dt><dd><p>a character vector</p>
</dd> <dt>plasticity</dt><dd><p>a
character vector</p>
</dd> <dt>field_ph</dt><dd><p>a numeric vector</p>
</dd>
<dt>hue</dt><dd><p>a character vector</p>
</dd> <dt>value</dt><dd><p>a numeric
vector</p>
</dd> <dt>chroma</dt><dd><p>a numeric vector</p>
</dd> </dl>



<h3>References</h3>

<p>http://casoilresource.lawr.ucdavis.edu/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)
# convert colors from Munsell to hex-encoded RGB
sp1$soil_color &lt;- with(sp1, munsell2rgb(hue, value, chroma))

# promote to SoilProfileCollection
depths(sp1) &lt;- id ~ top + bottom
site(sp1) &lt;- ~ group

# re-sample each profile into 1 cm (thick) depth slices
# for the variables 'prop', 'name', 'soil_color'
# result is a SoilProfileCollection object
s &lt;- dice(sp1, 0:25 ~ prop + name + soil_color)

# plot, note slices
plot(s)


# aggregate all profiles along 1 cm depth slices,
# using data from column 'prop'
s1 &lt;- slab(sp1, fm= ~ prop)

# check median &amp; IQR
library(lattice)
xyplot(top ~ p.q50 + p.q25 + p.q75,
data=s1, type='S', horizontal=TRUE, col=1, lty=c(1,2,2),
panel=panel.superpose, ylim=c(110,-5), asp=2)


</code></pre>

<hr>
<h2 id='sp2'>Honcut Creek Soil Profile Data</h2><span id='topic+sp2'></span>

<h3>Description</h3>

<p>A collection of 18 soil profiles, consisting of select soil morphologic
attributes, associated with a stratigraphic study conducted near Honcut
Creek, California.
</p>


<h3>Format</h3>

<p>A data frame with 154 observations on the following 21 variables.
</p>
 <dl>
<dt>id</dt><dd><p>profile id</p>
</dd> <dt>surface</dt><dd><p>dated
surface</p>
</dd> <dt>top</dt><dd><p>horizon top in cm</p>
</dd> <dt>bottom</dt><dd><p>horizon
bottom in cm</p>
</dd> <dt>bound_distinct</dt><dd><p>horizon lower boundary
distinctness class</p>
</dd> <dt>bound_topography</dt><dd><p>horizon lower boundary
topography class</p>
</dd> <dt>name</dt><dd><p>horizon name</p>
</dd>
<dt>texture</dt><dd><p>USDA soil texture class</p>
</dd>
<dt>prop</dt><dd><p>field-estimated clay content</p>
</dd>
<dt>structure_grade</dt><dd><p>soil structure grade</p>
</dd>
<dt>structure_size</dt><dd><p>soil structure size</p>
</dd>
<dt>structure_type</dt><dd><p>soil structure type</p>
</dd>
<dt>stickiness</dt><dd><p>stickiness</p>
</dd> <dt>plasticity</dt><dd><p>plasticity</p>
</dd>
<dt>field_ph</dt><dd><p>field-measured pH</p>
</dd> <dt>hue</dt><dd><p>Munsell hue</p>
</dd>
<dt>value</dt><dd><p>Munsell value</p>
</dd> <dt>chroma</dt><dd><p>Munsell chroma</p>
</dd>
<dt>r</dt><dd><p>RGB red component</p>
</dd> <dt>g</dt><dd><p>RGB green component</p>
</dd>
<dt>b</dt><dd><p>RGB blue component</p>
</dd> <dt>soil_color</dt><dd><p>R-friendly
encoding of soil color</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Dylan E. Beaudette
</p>


<h3>Source</h3>

<p>Busacca, Alan J.; Singer, Michael J.; Verosub, Kenneth L. 1989. Late
Cenozoic stratigraphy of the Feather and Yuba rivers area, California, with
a section on soil development in mixed alluvium at Honcut Creek. USGS
Bulletin 1590-G.
</p>


<h3>References</h3>

<p>http://casoilresource.lawr.ucdavis.edu/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# keep examples from using more than 2 cores
data.table::setDTthreads(Sys.getenv("OMP_THREAD_LIMIT", unset = 2))

data(sp2)

# convert into SoilProfileCollection object
depths(sp2) &lt;- id ~ top + bottom

# transfer site-level data
site(sp2) &lt;- ~ surface

# generate a new plotting order, based on the dated surface each soil was described on
p.order &lt;- order(sp2$surface)

# plot
par(mar=c(1,0,3,0))
plot(sp2, plot.order=p.order)

# setup multi-figure output
par(mfrow=c(2,1), mar=c(0,0,1,0))

# truncate plot to 200 cm depth
plot(sp2, plot.order=p.order, max.depth=200)
abline(h=200, lty=2, lwd=2)

# compute numerical distances between profiles
# based on select horizon-level properties, to a depth of 200 cm
d &lt;- NCSP(sp2, vars=c('prop','field_ph','hue'), maxDepth = 100, k = 0)

# plot dendrogram with ape package:
if(require(ape) &amp; require(cluster)) {
h &lt;- diana(d)
p &lt;- as.phylo(as.hclust(h))
plot(p, cex=0.75, label.offset=0.01, font=1, direct='down', srt=90, adj=0.5, y.lim=c(-0.125, 0.5))

# add in the dated surface type via color
tiplabels(col=as.numeric(sp2$surface), pch=15)

# based on distance matrix values, YMMV
legend('topleft', legend=levels(sp2$surface), col=1:6, pch=15, bty='n', bg='white', cex=0.75)
}


</code></pre>

<hr>
<h2 id='sp3'>Soil Profile Data Example 3</h2><span id='topic+sp3'></span>

<h3>Description</h3>

<p>Soil samples from 10 soil profiles, taken from the Sierra Foothill Region of
California.
</p>


<h3>Format</h3>

<p>A data frame with 46 observations on the following 15 variables.
</p>
 <dl>
<dt>id</dt><dd><p>soil id</p>
</dd> <dt>top</dt><dd><p>horizon upper
boundary (cm)</p>
</dd> <dt>bottom</dt><dd><p>horizon lower boundary (cm)</p>
</dd>
<dt>clay</dt><dd><p>clay content</p>
</dd> <dt>cec</dt><dd><p>CEC by amonium acetate
at pH 7</p>
</dd> <dt>ph</dt><dd><p>pH in 1:1 water-soil mixture</p>
</dd>
<dt>tc</dt><dd><p>total carbon percent</p>
</dd> <dt>hue</dt><dd><p>Munsell hue
(dry)</p>
</dd> <dt>value</dt><dd><p>Munsell value (dry)</p>
</dd>
<dt>chroma</dt><dd><p>Munsell chroma (dry)</p>
</dd> <dt>mid</dt><dd><p>horizon
midpoint (cm)</p>
</dd> <dt>ln_tc</dt><dd><p>natural log of total carbon percent</p>
</dd>
<dt>L</dt><dd><p>color: l-coordinate, CIE-LAB colorspace (dry)</p>
</dd>
<dt>A</dt><dd><p>color: a-coordinate, CIE-LAB colorspace (dry)</p>
</dd>
<dt>B</dt><dd><p>color: b-coordinate, CIE-LAB colorspace (dry)</p>
</dd>
<dt>name</dt><dd><p>horizon name</p>
</dd> <dt>soil_color</dt><dd><p>horizon color</p>
</dd> </dl>



<h3>Details</h3>

<p>These data were collected to support research funded by the Kearney
Foundation of Soil Science.
</p>


<h3>References</h3>

<p>http://casoilresource.lawr.ucdavis.edu/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## this example investigates the concept of a "median profile"

# required packages
if (require(ape) &amp; require(cluster)) {
  data(sp3)

  # generate a RGB version of soil colors
  # and convert to HSV for aggregation
  sp3$h &lt;- NA
  sp3$s &lt;- NA
  sp3$v &lt;- NA
  sp3.rgb &lt;- with(sp3, munsell2rgb(hue, value, chroma, return_triplets = TRUE))

  sp3[, c('h', 's', 'v')] &lt;- t(with(sp3.rgb, rgb2hsv(r, g, b, maxColorValue = 1)))

  # promote to SoilProfileCollection
  depths(sp3) &lt;- id ~ top + bottom

  # aggregate across entire collection
  a &lt;- slab(sp3, fm = ~ clay + cec + ph + h + s + v, slab.structure = 10)

  # check
  str(a)

  # convert back to wide format
  library(data.table)

  a.wide.q25 &lt;- dcast(as.data.table(a), top + bottom ~ variable, value.var = c('p.q25'))
  a.wide.q50 &lt;- dcast(as.data.table(a), top + bottom ~ variable, value.var = c('p.q50'))
  a.wide.q75 &lt;- dcast(as.data.table(a), top + bottom ~ variable, value.var = c('p.q75'))

  # add a new id for the 25th, 50th, and 75th percentile pedons
  a.wide.q25$id &lt;- 'Q25'
  a.wide.q50$id &lt;- 'Q50'
  a.wide.q75$id &lt;- 'Q75'

  # combine original data with "mean profile"
  vars &lt;- c('top', 'bottom', 'id', 'clay', 'cec', 'ph', 'h', 's', 'v')
  # make data.frame version of sp3
  sp3.df &lt;- as(sp3, 'data.frame')

  sp3.grouped &lt;- as.data.frame(rbind(as.data.table(horizons(sp3))[, .SD, .SDcol = vars], 
                                     a.wide.q25[, .SD, .SDcol = vars],
                                     a.wide.q50[, .SD, .SDcol = vars], 
                                     a.wide.q75[, .SD, .SDcol = vars]))
                                     
  # re-constitute the soil color from HSV triplets
  # convert HSV back to standard R colors
  sp3.grouped$soil_color &lt;- with(sp3.grouped, hsv(h, s, v))

  # give each horizon a name
  sp3.grouped$name &lt;- paste(
    round(sp3.grouped$clay),
    '/' ,
    round(sp3.grouped$cec),
    '/',
    round(sp3.grouped$ph, 1)
  )


# first promote to SoilProfileCollection
depths(sp3.grouped) &lt;- id ~ top + bottom

plot(sp3.grouped)

## perform comparison, and convert to phylo class object
## D is rescaled to [0,]
d &lt;- NCSP(
  sp3.grouped,
  vars = c('clay', 'cec', 'ph'),
  maxDepth = 100,
  k = 0.01
)

h &lt;- agnes(d, method = 'ward')
p &lt;- ladderize(as.phylo(as.hclust(h)))

# look at distance plot-- just the median profile
plot_distance_graph(d, 12)

# similarity relative to median profile (profile #12)
round(1 - (as.matrix(d)[12, ] / max(as.matrix(d)[12, ])), 2)

## make dendrogram + soil profiles

# setup plot: note that D has a scale of [0,1]
par(mar = c(1, 1, 1, 1))
p.plot &lt;- plot(p,
               cex = 0.8,
               label.offset = 3,
               direction = 'up',
               y.lim = c(200, 0),
               x.lim = c(1.25, length(sp3.grouped) + 1),
               show.tip.label = FALSE)

# get the last plot geometry
lastPP &lt;- get("last_plot.phylo", envir = .PlotPhyloEnv)

# the original labels, and new (indexed) order of pedons in dendrogram
d.labels &lt;- attr(d, 'Labels')

new_order &lt;- sapply(1:lastPP$Ntip,
                    function(i)
                      which(as.integer(lastPP$xx[1:lastPP$Ntip]) == i))

# plot the profiles, in the ordering defined by the dendrogram
# with a couple fudge factors to make them fit
plotSPC(
  sp3.grouped,
  color = "soil_color",
  plot.order = new_order,
  y.offset = max(lastPP$yy) + 10,
  width = 0.1,
  cex.names = 0.5,
  add = TRUE
)
}
</code></pre>

<hr>
<h2 id='sp4'>Soil Chemical Data from Serpentinitic Soils of California</h2><span id='topic+sp4'></span>

<h3>Description</h3>

<p>Soil Chemical Data from Serpentinitic Soils of California
</p>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 13 variables.
</p>
 <dl>
<dt>id</dt><dd><p>site name</p>
</dd> <dt>name</dt><dd><p>horizon
designation</p>
</dd> <dt>top</dt><dd><p>horizon top boundary in cm</p>
</dd>
<dt>bottom</dt><dd><p>horizon bottom boundary in cm</p>
</dd>
<dt>K</dt><dd><p>exchangeable K in c mol/kg</p>
</dd> <dt>Mg</dt><dd><p>exchangeable
Mg in cmol/kg</p>
</dd> <dt>Ca</dt><dd><p>exchangeable Ca in cmol/kg</p>
</dd>
<dt>CEC_7</dt><dd><p>cation exchange capacity (NH4OAc at pH 7)</p>
</dd>
<dt>ex_Ca_to_Mg</dt><dd><p>extractable Ca:Mg ratio</p>
</dd> <dt>sand</dt><dd><p>sand
content by weight percentage</p>
</dd> <dt>silt</dt><dd><p>silt content by weight
percentage</p>
</dd> <dt>clay</dt><dd><p>clay content by weight percentage</p>
</dd>
<dt>CF</dt><dd><p>&gt;2mm fraction by volume percentage</p>
</dd> </dl>



<h3>Details</h3>

<p>Selected soil physical and chemical data from (McGahan et al., 2009).
</p>


<h3>Source</h3>

<p>https://www.soils.org/publications/sssaj/articles/73/6/2087
</p>


<h3>References</h3>

<p>McGahan, D.G., Southard, R.J, Claassen, V.P. 2009.
Plant-Available Calcium Varies Widely in Soils on Serpentinite Landscapes.
Soil Sci. Soc. Am. J. 73: 2087-2095.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load sample data set, a simple data.frame object with horizon-level data from 10 profiles
library(aqp)
data(sp4)
str(sp4)
sp4$idbak &lt;- sp4$id
#sp4 &lt;- sp4[order(match(sp4$id, aqp:::.coalesce.idx(sort(sp4$id))), sp4$top),]


# upgrade to SoilProfileCollection
# 'id' is the name of the column containing the profile ID
# 'top' is the name of the column containing horizon upper boundaries
# 'bottom' is the name of the column containing horizon lower boundaries
depths(sp4) &lt;- id ~ top + bottom

# check it out
class(sp4) # class name
str(sp4) # internal structure

# check integrity of site:horizon linkage
spc_in_sync(sp4)

# check horizon depth logic
checkHzDepthLogic(sp4)

# inspect object properties
idname(sp4) # self-explanitory
horizonDepths(sp4) # self-explanitory

# you can change these:
depth_units(sp4) # defaults to 'cm'
metadata(sp4) # not much to start with

# alter the depth unit metadata
depth_units(sp4) &lt;- 'inches' # units are really 'cm'

# more generic interface for adjusting metadata

# add attributes to metadata list
metadata(sp4)$describer &lt;- 'DGM'
metadata(sp4)$date &lt;- as.Date('2009-01-01')
metadata(sp4)$citation &lt;- 'McGahan, D.G., Southard, R.J, Claassen, V.P.
2009. Plant-Available Calcium Varies Widely in Soils
on Serpentinite Landscapes. Soil Sci. Soc. Am. J. 73: 2087-2095.'

depth_units(sp4) &lt;- 'cm' # fix depth units, back to 'cm'

# further inspection with common function overloads
length(sp4) # number of profiles in the collection
nrow(sp4) # number of horizons in the collection
names(sp4) # column names
min(sp4) # shallowest profile depth in collection
max(sp4) # deepest profile depth in collection

# extraction of soil profile components
profile_id(sp4) # vector of profile IDs
horizons(sp4) # horizon data

# extraction of specific horizon attributes
sp4$clay # vector of clay content

# subsetting SoilProfileCollection objects
sp4[1, ] # first profile in the collection
sp4[, 1] # first horizon from each profile

# basic plot method, highly customizable: see manual page ?plotSPC
plot(sp4)
# inspect plotting area, very simple to overlay graphical elements
abline(v=1:length(sp4), lty=3, col='blue')
# profiles are centered at integers, from 1 to length(obj)
axis(1, line=-1.5, at=1:10, cex.axis=0.75, font=4, col='blue', lwd=2)
# y-axis is based on profile depths
axis(2, line=-1, at=pretty(1:max(sp4)), cex.axis=0.75, font=4, las=1, col='blue', lwd=2)


# symbolize soil properties via color
par(mar=c(0,0,4,0))
plot(sp4, color='clay')
plot(sp4, color='CF')

# apply a function to each profile, returning a single value per profile,
# in the same order as profile_id(sp4)
soil.depths &lt;- profileApply(sp4, max) # recall that max() gives the depth of a soil profile

# check that the order is correct
all.equal(names(soil.depths), profile_id(sp4))

# a vector of values that is the same length as the number of profiles
# can be stored into site-level data
sp4$depth &lt;- soil.depths
# check: looks good
max(sp4[1, ]) == sp4$depth[1]

# extract site-level data
site(sp4) # as a data.frame
sp4$depth # specific columns as a vector

# use site-level data to alter plotting order
new.order &lt;- order(sp4$depth) # the result is an index of rank
par(mar=c(0,0,0,0))
plot(sp4, plot.order=new.order)

# deconstruct SoilProfileCollection into a data.frame, with horizon+site data
as(sp4, 'data.frame')

</code></pre>

<hr>
<h2 id='sp5'>Sample Soil Database #5</h2><span id='topic+sp5'></span>

<h3>Description</h3>

<p>296 Soil Profiles from the La Rochelle region of France (F. Carre and
Girard, 2002)
</p>


<h3>Format</h3>

<p><code>SoilProfileCollection</code> object
</p>


<h3>Details</h3>

<p>These data are c/o F. Carre (Florence.CARRE@ineris.fr).
</p>


<h3>Source</h3>

<p>296 Soil Profiles from the La Rochelle region of France (F. Carre
and Girard, 2002). These data can be found on the OSACA project page
(<a href="http://eusoils.jrc.ec.europa.eu/projects/OSACA/">http://eusoils.jrc.ec.europa.eu/projects/OSACA/</a>).
</p>


<h3>References</h3>

<p>F. Carre, M.C. Girard. 2002. Quantitative mapping of soil types
based on regression kriging of taxonomic distances with landform and land
cover attributes. Geoderma. 110: 241&ndash;263.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(scales)
data(sp5)
par(mar=c(1,1,1,1))
# plot a random sampling of profiles
s &lt;- sample(1:length(sp5), size=25)
plot(sp5[s, ], divide.hz=FALSE)

# plot the first 100 profiles, as 4 rows of 25, hard-coding the max depth
layout(matrix(c(1,2,3,4), ncol=1), height=c(0.25,0.25,0.25,0.25))
plot(sp5[1:25, ], max.depth=300)
plot(sp5[26:50, ], max.depth=300)
plot(sp5[51:75, ], max.depth=300)
plot(sp5[76:100, ], max.depth=300)


# 4x1 matrix of plotting areas
layout(matrix(c(1,2,3,4), ncol=1), height=c(0.25,0.25,0.25,0.25))

# plot profiles, with points added to the mid-points of randomly selected horizons
sub &lt;- sp5[1:25, ]
plot(sub, max.depth=300) ; mtext('Set 1', 2, line=-0.5, font=2)
y.p &lt;- profileApply(sub, function(x) {
  s &lt;- sample(1:nrow(x), 1)
  h &lt;- horizons(x); with(h[s,], (top+bottom)/2)
  })
points(1:25, y.p, bg='white', pch=21)

# plot profiles, with arrows pointing to profile bottoms
sub &lt;- sp5[26:50, ]
plot(sub, max.depth=300); mtext('Set 2', 2, line=-0.5, font=2)
y.a &lt;- profileApply(sub, function(x) max(x))
arrows(1:25, y.a-50, 1:25, y.a, len=0.1, col='white')

# plot profiles, with points connected by lines: ideally reflecting some kind of measured data
sub &lt;- sp5[51:75, ]
plot(sub, max.depth=300); mtext('Set 3', 2, line=-0.5, font=2)
y.p &lt;- 20*(sin(1:25) + 2*cos(1:25) + 5)
points(1:25, y.p, bg='white', pch=21)
lines(1:25, y.p, lty=2)

# plot profiles, with polygons connecting horizons with max clay content (+/-) 10 cm
sub &lt;- sp5[76:100, ]
y.clay.max &lt;- profileApply(sub, function(x) {
  i &lt;- which.max(x$clay)
  h &lt;- horizons(x)
  with(h[i, ], (top+bottom)/2)
  } )

plot(sub, max.depth=300); mtext('Set 4', 2, line=-0.5, font=2)
polygon(c(1:25, 25:1), c(y.clay.max-10, rev(y.clay.max+10)),
border='black', col=rgb(0,0,0.8, alpha=0.25))
points(1:25, y.clay.max, pch=21, bg='white')

# close plot
dev.off()


# plotting parameters
yo &lt;- 100 # y-offset
sf &lt;- 0.65 # scaling factor
# plot profile sketches
par(mar=c(0,0,0,0))
plot(sp5[1:25, ], max.depth=300, y.offset=yo, scaling.factor=sf)
# optionally add describe plotting area above profiles with lines
# abline(h=c(0,90,100, (300*sf)+yo), lty=2)
# simulate an environmental variable associated with profiles (elevation, etc.)
r &lt;- vector(mode='numeric', length=25)
r[1] &lt;- -50 ; for(i in 2:25) {r[i] &lt;- r[i-1] + rnorm(mean=-1, sd=25, n=1)}
# rescale
r &lt;- rescale(r, to=c(80, 0))
# illustrate gradient with points/lines/arrows
lines(1:25, r)
points(1:25, r, pch=16)
arrows(1:25, r, 1:25, 95, len=0.1)
# add scale for simulated gradient
axis(2, at=pretty(0:80), labels=rev(pretty(0:80)), line=-1, cex.axis=0.75, las=2)
# depict a secondary environmental gradient with polygons (water table depth, etc.)
polygon(c(1:25, 25:1), c((100-r)+150, rep((300*sf)+yo, times=25)),
border='black', col=rgb(0,0,0.8, alpha=0.25))


## End(Not run)


</code></pre>

<hr>
<h2 id='sp6'>Soil Physical and Chemical Data from Manganiferous Soils</h2><span id='topic+sp6'></span>

<h3>Description</h3>

<p>Soil Physical and Chemical Data from Manganiferous Soils (Bourgault and
Rabenhorst, 2011)
</p>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 13 variables.
</p>
 <dl>
<dt>id</dt><dd><p>pedon name</p>
</dd> <dt>name</dt><dd><p>horizon
designation</p>
</dd> <dt>top</dt><dd><p>horizon top boundary in cm</p>
</dd>
<dt>bottom</dt><dd><p>horizon bottom boundary in cm</p>
</dd>
<dt>color</dt><dd><p>moist soil color in Munsell notation</p>
</dd>
<dt>texture</dt><dd><p>USDA soil texture class</p>
</dd> <dt>sand</dt><dd><p>sand
content by weight percentage</p>
</dd> <dt>silt</dt><dd><p>silt content by weight
percentage</p>
</dd> <dt>clay</dt><dd><p>clay content by weight percentage</p>
</dd>
<dt>Fe</dt><dd><p>DCB-extracted Fe in g/kg (see citation)</p>
</dd>
<dt>Mn</dt><dd><p>DCB-extracted Mn in g/kg (see citation)</p>
</dd>
<dt>C</dt><dd><p>total organic carbon as g/kg</p>
</dd> <dt>pH</dt><dd><p>measured in
1:1 H20 slurry</p>
</dd> <dt>Db</dt><dd><p>bulk density (g/cc), clod method</p>
</dd> </dl>



<h3>Details</h3>

<p>Selected soil physical and chemical data from (Bourgault and Rabenhorst,
2011).
</p>


<h3>Source</h3>

<p>http://www.sciencedirect.com/science/article/pii/S0016706111001972
</p>


<h3>References</h3>

<p>Rebecca R. Bourgault, Martin C. Rabenhorst. 2011.  Genesis and
characterization of manganiferous soils in the Eastern Piedmont, USA.
Geoderma. 165:84-94.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # setup environment
  library(aqp)
  data(sp6)

  # init SPC
  depths(sp6) &lt;- id ~ top + bottom
  # convert non-standard Munsell colors
  sp6$soil_color &lt;- getClosestMunsellChip(sp6$color)

  # profile sketches
  par(mar=c(0,0,3,0))
  plot(sp6, color='soil_color')
  plot(sp6, color='Mn')
  plot(sp6, color='Fe')
  plot(sp6, color='pH')
  plot(sp6, color='texture')


</code></pre>

<hr>
<h2 id='spc_in_sync'>Quickly assess relative state of site and horizon slots</h2><span id='topic+spc_in_sync'></span>

<h3>Description</h3>

<p>Determine &quot;state&quot; of SoilProfileCollection before or after major modifications of site or horizon slot contents.
</p>
<p>Two logical checks are performed on the site and horizon tables, and a third element <code>valid</code> returns <code>TRUE</code> when both checks are <code>TRUE</code>.
</p>
<p>Check 1: Same number of sites in site as number of sites in horizons. No intermingling of IDs, no orphan horizons, no sites without horizons (for now)
</p>
<p>Check 2: Site IDs match coalesced profile ID from horizons. Ensures the same <em>relative</em> ordering, but horizons still may be out of order within profiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spc_in_sync(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spc_in_sync_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sp5)

spc_in_sync(sp5)

</code></pre>

<hr>
<h2 id='SPC.with.overlap'>Example SoilProfileCollection with Overlapping Horizons</h2><span id='topic+SPC.with.overlap'></span>

<h3>Description</h3>

<p>A <code>SoilProfileCollection</code> with overlapping horizons, derived from a Dynamic Soil Properties project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SPC.with.overlap)
</code></pre>


<h3>Format</h3>

<p>A <code>SoilProfileCollection</code>
</p>

<hr>
<h2 id='spc2mpspline+2CSoilProfileCollection-method'>SoilProfileCollection wrapper for <code>mpspline2::mpspline()</code></h2><span id='topic+spc2mpspline+2CSoilProfileCollection-method'></span><span id='topic+spc2mpspline'></span>

<h3>Description</h3>

<p>Generate mass-preserving splines for any numeric attribute in a SoilProfileCollection using <code>mpspline2::mpspline()</code>. mpspline2 implements the method described in Bishop et al. (1999). Currently this function only works with a single <code>var_name</code> at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
spc2mpspline(
  object,
  var_name = NULL,
  method = c("est_1cm", "est_icm", "est_dcm"),
  pattern = "R|Cr|Cd|qm",
  hzdesgn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spc2mpspline+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="spc2mpspline+2B2CSoilProfileCollection-method_+3A_var_name">var_name</code></td>
<td>
<p>Column name in <code style="white-space: pre;">&#8288;@horizons&#8288;</code> slot of <code>object</code> containing numeric values to spline</p>
</td></tr>
<tr><td><code id="spc2mpspline+2B2CSoilProfileCollection-method_+3A_method">method</code></td>
<td>
<p>Options include &quot;est_1cm&quot; (default; 1cm estimates), &quot;est_icm&quot; (estimates over original layer boundaries), &quot;est_dcm&quot; (estimates over constant interval, specified with <code>d</code> argument to <code>mpspline3::mpspline()</code>). Default value for <code>d</code> is <code>c(0, 5, 15, 30, 60, 100, 200)</code>.</p>
</td></tr>
<tr><td><code id="spc2mpspline+2B2CSoilProfileCollection-method_+3A_pattern">pattern</code></td>
<td>
<p>Regex pattern to match for bottom of profile (passed to <code>minDepthOf()</code>) default: &quot;R|Cr|Cd|qm&quot;; only used if <code>hzdesgn</code> is specified</p>
</td></tr>
<tr><td><code id="spc2mpspline+2B2CSoilProfileCollection-method_+3A_hzdesgn">hzdesgn</code></td>
<td>
<p>Column name in <code style="white-space: pre;">&#8288;@horizons&#8288;</code> slot of <code>object</code> containing horizon designations default: <code>NULL</code></p>
</td></tr>
<tr><td><code id="spc2mpspline+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>mpspline2::mpspline()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function now relies on the missing data checks provided by the mpspline2 package. See <code>attr(..., 'removed')</code> to see whole profiles that were removed from the set. Horizons containing <code>NA</code> in the property of interest are dropped with a message.
</p>
<p>Data completeness is assessed and the input SoilProfileCollection is filtered and truncated to create a container for the results from <code>mpspline2::mpspline()</code>.
</p>


<h3>Value</h3>

<p>A SoilProfileCollection with 1cm slices. Spline variables are in columns prefixed with &quot;spline_&quot; and RMSE/RMSE_IQR are in columns prefixed with &quot;rmse_&quot;. If any profiles were removed from the collection, their profile IDs are stored in <code>attr(result, 'removed')</code>.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>References</h3>

<p>Bishop, T.F.A., McBratney, A.B., Laslett, G.M. (1999) Modelling soil attribute depth functions with equal-area quadratic smoothing splines. Geoderma 91(1–2), pp. 27-45. <a href="https://doi.org/10.1016/S0016-7061%2899%2900003-8">doi:10.1016/S0016-7061(99)00003-8</a>
</p>
<p>O'Brien, Lauren (2022). mpspline2: Mass-Preserving Spline Functions for Soil Data. R package version 0.1.6. <a href="https://cran.r-project.org/package=mpspline2">https://cran.r-project.org/package=mpspline2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mpspline2")) {
  data(sp1)
  depths(sp1) &lt;- id ~ top + bottom

  res &lt;- spc2mpspline(sp1, "prop")

  plotSPC(res[1:5,], color = "prop_spline", divide.hz = FALSE)
}
</code></pre>

<hr>
<h2 id='spec2Munsell'>Convert reflectance spectra to closest Munsell chip</h2><span id='topic+spec2Munsell'></span>

<h3>Description</h3>

<p>Convert reflectance spectra to closest Munsell chip
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec2Munsell(
  x,
  res = 10,
  convert = TRUE,
  SO = c("CIE1931", "CIE1964"),
  illuminant = c("D65", "F2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec2Munsell_+3A_x">x</code></td>
<td>
<p>reflectance spectra, must range from 380nm to 730nm with resolution specified in <code>res</code></p>
</td></tr>
<tr><td><code id="spec2Munsell_+3A_res">res</code></td>
<td>
<p>spectra resolution in nm, typically 5nm or 10nm</p>
</td></tr>
<tr><td><code id="spec2Munsell_+3A_convert">convert</code></td>
<td>
<p>logical, convert sRGB coordinates to closest Munsell chip (see <code>?munsell</code>)</p>
</td></tr>
<tr><td><code id="spec2Munsell_+3A_so">SO</code></td>
<td>
<p>CIE standard observer: these are the color matching functions defined by CIE and used to represent &quot;average&quot; human color perception. CIE1931 is the 2 degree standard observer more useful for describing color perception over very small areas or at distance. CIE1964 is the 10 degree standard observer, used for most industrial color matching applications.</p>
</td></tr>
<tr><td><code id="spec2Munsell_+3A_illuminant">illuminant</code></td>
<td>
<p>CIE standard illuminants:
</p>

<ul>
<li><p> D65 represents average daylight
</p>
</li>
<li><p> F2 represents typical fluorescent lighting
</p>
</li></ul>
</td></tr>
<tr><td><code id="spec2Munsell_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="#topic+col2Munsell">col2Munsell()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://ncss-tech.github.io/AQP/aqp/mix-colors.html">expanded tutorial</a> for additional examples.
</p>


<h3>Value</h3>

<p>output from <code><a href="#topic+col2Munsell">col2Munsell()</a></code>
</p>


<h3>References</h3>

<p>Marcus, R.T. (1998). The Measurement of Color. In K. Nassau (Ed.), Color for Science, Art, and Technology (pp. 32-96). North-Holland.
</p>
<p>CIE Colorimetry – Part 1: CIE standard colorimetric observers. CIES014-1/E:2006 – ISO 11664-1:2007(E)
</p>
<p>CIE. (n.d.). CIE 15:2004 Tables Data. Retrieved from https://law.resource.org/pub/us/cfr/ibr/003/cie.15.2004.tables.xls
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Munsell reference spectra
data("munsell.spectra.wide")

# convert to closest Munsell chip
# sRGB -&gt; Munsell conversion via col2Munsell()
spec2Munsell(munsell.spectra.wide[, '10YR 3/3'])

# attempt several
cols &lt;- c('10YR 6/2', '5YR 5/6', '10B 4/4', '5G 4/4', '2.5Y 8/2', '10YR 3/3', '7.5YR 2.5/2')

# most are exact or very close
z &lt;- do.call(
  'rbind',
  lapply(cols, function(i) {
    spec2Munsell(munsell.spectra.wide[, i])  
  })
)

# format Munsell notation from pieces
z$m &lt;- sprintf("%s %s/%s", z$hue, z$value, z$chroma)

# compare
colorContrastPlot(
  m1 = cols, 
  m2 = z$m, 
  labels = c('original', 'spectral\ninterpretation')
)

## Not run: 
if(requireNamespace("gower")) {
# mix colors, return spectra, convert to color
cols &lt;- c('10YR 6/2', '5YR 5/6', '10B 4/4')
res &lt;- mixMunsell(cols, keepMixedSpec = TRUE, mixingMethod = 'reference')

# note that they are slightly different
res$mixed
spec2Munsell(res$spec)

}

## End(Not run)

</code></pre>

<hr>
<h2 id='spectral.reference'>Standard Illuminants and Observers</h2><span id='topic+spectral.reference'></span>

<h3>Description</h3>

<p>D65 and F2 standard illuminant spectral power distributions, CIE1931 Standard Observer (2 degree), and CIE1964 Supplemental Standard Observer (10 degree)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spectral.reference)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 71 rows and 9 columns.
</p>


<h3>References</h3>

<p>Marcus, R.T. (1998). The Measurement of Color. In K. Nassau (Ed.), Color for Science, Art, and Technology (pp. 32-96). North-Holland.
</p>
<p>CIE Colorimetry – Part 1: CIE standard colorimetric observers. CIES014-1/E:2006 – ISO 11664-1:2007(E)
</p>
<p>CIE. (n.d.). CIE 15:2004 Tables Data. Retrieved from https://law.resource.org/pub/us/cfr/ibr/003/cie.15.2004.tables.xls
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("spectral.reference")

matplot(
  x = spectral.reference[, 1],
  y = spectral.reference[, c('xbar_2', 'ybar_2', 'zbar_2')],
  ylim = c(0, 2),
  type = 'l',
  lwd = 2, 
  lty = 1,
  las = 1,
  xlab = 'Wavelength (nm)',
  ylab = 'Weight | Intensity',
  main = "CIE1931 (2\u00B0) and CIE1964 (10\u00B0) Standard Observers
  D65 and F2 Illuminant Power Spectrum (rescaled / offset for clarity)",
  cex.main = 0.9
)

matlines(
  x = spectral.reference[, 1],
  y = spectral.reference[, c('xbar_10', 'ybar_10', 'zbar_10')],
  type = 'l',
  lwd = 2, 
  lty = 2,
  las = 1,
  xlab = 'Wavelength (nm)',
  ylab = 'Weight | Intensity',
  main = 'CIE1931 Standard Observer Weights\nD65 Standard Illuminant'
)

lines(
  x = spectral.reference$w,
  y = (spectral.reference$D65 / 100) + 0.33,
  lty = 1,
  col = 'royalblue'
)

lines(
  x = spectral.reference$w,
  y = (spectral.reference$F2 / 25) + 0.4,
  lty = 1,
  col = 'violet'
)

legend(
  'topright',
  legend = c('X_2', 'Y_2', 'Z_2', 'X_10', 'Y_10', 'Z_10', 'D65', 'F2'),
  col = c(1, 2, 3, 1, 2, 3, 'royalblue', 'violet'),
  lwd = c(2, 2, 2, 2, 2, 2, 1, 1),
  lty = c(1, 1, 1, 2, 2, 2, 1, 1),
  bty = 'n',
  cex = 0.85
)

</code></pre>

<hr>
<h2 id='split+2CSoilProfileCollection-method'>Split a SoilProfileCollection object into a list of SoilProfileCollection objects.</h2><span id='topic+split+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>This function splits a <code>SoilProfileCollection</code> into a list of <code>SoilProfileCollection</code> objects using a site-level attribute to define groups or profile ID (<code>idname(x)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
split(x, f, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p><code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="split+2B2CSoilProfileCollection-method_+3A_f">f</code></td>
<td>
<p>character vector naming a single site-level attribute that defines groups, a ‘factor’ in the sense that <code>as.factor(f)</code> defines the grouping, or a list of such factors in which case their interaction is used for the grouping.</p>
</td></tr>
<tr><td><code id="split+2B2CSoilProfileCollection-method_+3A_drop">drop</code></td>
<td>
<p>logical indicating if levels that do not occur should be dropped (if f is a factor or a list). When <code>drop=FALSE</code> and <code>f</code> contains missing values an additional group &quot;missing&quot; is returned.</p>
</td></tr>
<tr><td><code id="split+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of aqp 1.25, omission of <code>f</code> argument is no longer possible, as the base R generic is overloaded by this <code>SoilProfileCollection</code> method. This used to result in an &quot;identity&quot; split, according to <code>idname(x)</code>, e.g. a list as long as <code>length(x)</code>, with a single-profile <code>SoilProfileCollection</code> per list element. Replicate this behavior using <code>f = idname(x)</code> or <code>f = profile_id(x)</code>.
</p>


<h3>Value</h3>

<p>A list of <code>SoilProfileCollection</code> or <code>NULL</code> for empty result.
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and A.G. Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp2)
depths(sp2) &lt;- id ~ top + bottom

# add a more interesting site-level attribute
site(sp2) &lt;- ~ surface

# using identity site-level attribute (profile ID)
p1 &lt;- split(sp2, f = idname(sp2))
names(p1)
length(p1)

# using vector equal in length to number of profiles (profile ID, again)
p2 &lt;- split(sp2, f = profile_id(sp2))
names(p2)
length(p2)

# which are both equivalent to setting `f` to NULL
p3 &lt;- split(sp2, f = NULL)
names(p3)
length(p3)

# split on surface (age) site-level var
p4 &lt;- split(sp2, f = "surface")
names(p4)
length(p4) # 5 unique "surfaces", 5 SPCs in result list

</code></pre>

<hr>
<h2 id='splitLogicErrors'>Split a SoilProfileCollection into a list based on types of horizon logic errors</h2><span id='topic+splitLogicErrors'></span>

<h3>Description</h3>

<p>Uses <code>checkHzDepthLogic</code> to identify presence of depth logic errors, same depths, missing depths, and overlaps/gaps between the horizons of each profile in a SoilProfileCollection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitLogicErrors(object, interact = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitLogicErrors_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="splitLogicErrors_+3A_interact">interact</code></td>
<td>
<p>Calculate interaction between the four logic errors for groups? Default: <code>FALSE</code> always returns 4 groups, one for each logic error type.</p>
</td></tr>
<tr><td><code id="splitLogicErrors_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>split.default</code>, called when <code>interact = TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of SoilProfileCollections (or <code>NULL</code>), with names: &quot;depthLogic&quot;, &quot;sameDepth&quot;, &quot;missingDepth&quot;, &quot;overlapOrGap&quot;. If <code>interact = TRUE</code> then the list elements groups determined by <code>interaction()</code> of the error types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp4)
depths(sp4) &lt;- id ~ top + bottom

# no errors (all four list elements return NULL)
splitLogicErrors(sp4)

# NA in top depth triggers depth logic and missing depth errors
data(sp4)
sp4$top[1] &lt;- NA
depths(sp4) &lt;- id ~ top + bottom

splitLogicErrors(sp4)

# interact = TRUE gets errors for profile 1 in same group
#  and allows you to pass extra arguments to split.default()
splitLogicErrors(sp4, interact = TRUE, sep = "_", drop = TRUE)

</code></pre>

<hr>
<h2 id='subApply'>Subset SPC based on result of performing function on each profile</h2><span id='topic+subApply'></span><span id='topic+subApply+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>subApply()</code> is a function used for subsetting SoilProfileCollections. It currently does NOT support for &quot;tidy&quot; lexical features in the <code>...</code> arguments passed to <code>profileApply()</code>. The expectation is that the function <code>.fun</code> takes a single-profile SoilProfileCollection and returns a logical value of length one. The use case would be for any logical comparisons that cannot be evaluated inline by <code>subSPC()</code> because they require more than simple logical operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subApply(object, .fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subApply_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="subApply_+3A_.fun">.fun</code></td>
<td>
<p>A function that takes a single profile, returns <em>logical</em> of length 1.</p>
</td></tr>
<tr><td><code id="subApply_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code>.fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SoilProfileCollection.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown.
</p>

<hr>
<h2 id='subset+2CSoilProfileCollection-method'>Subset a SoilProfileCollection with logical expressions</h2><span id='topic+subset+2CSoilProfileCollection-method'></span><span id='topic+subset'></span>

<h3>Description</h3>

<p><code>subset()</code> is a function used for extracting profiles from a SoilProfileCollection based on logical criteria. It allows the user to specify an arbitrary number of logical vectors (equal in length to site or horizon), separated by commas. The function includes some support for non-standard evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
subset(x, ..., greedy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="subset+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p>Comma-separated set of R expressions that evaluate as TRUE or FALSE. Length for individual expressions matches number of sites OR number of horizons, in <code>object</code>.</p>
</td></tr>
<tr><td><code id="subset+2B2CSoilProfileCollection-method_+3A_greedy">greedy</code></td>
<td>
<p>Use &quot;greedy&quot; matching for combination of site and horizon level matches? <code>greedy = TRUE</code> is the union, whereas <code>greedy = FALSE</code> (default) is the intersection (of site and horizon matches).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To minimize likelihood of issues with non-standard evaluation context, especially when using <code>subset()</code> inside another function, all expressions used in <code>...</code> should be in terms of variables that are in the site or horizon data frame.
</p>


<h3>Value</h3>

<p>A SoilProfileCollection.
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown.
</p>

<hr>
<h2 id='subsetHz+2CSoilProfileCollection-method'>Subset the horizons in a SoilProfileCollection using logical criteria</h2><span id='topic+subsetHz+2CSoilProfileCollection-method'></span><span id='topic+subsetHz'></span>

<h3>Description</h3>

<p><code>subsetHz()</code> is a function used for extracting horizons from a SoilProfileCollection based on logical criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
subsetHz(x, ..., drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetHz+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
<tr><td><code id="subsetHz+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p>Comma-separated set of R expressions that evaluate as <code>TRUE</code> or <code>FALSE</code> in context of horizon data frame. Length for individual expressions matches number of horizons, in <code>x</code>.</p>
</td></tr>
<tr><td><code id="subsetHz+2B2CSoilProfileCollection-method_+3A_drop">drop</code></td>
<td>
<p>Default: <code>TRUE</code>. When <code>drop=FALSE</code> placeholder horizons (profile ID with all other values <code>NA</code>) are created where the specified filter results in removal of all horizons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To minimize likelihood of issues with non-standard evaluation context, especially when using <code>subsetHz()</code> inside another function, all expressions used in <code>...</code> should be in terms of variables that are in the horizon data frame.
</p>


<h3>Value</h3>

<p>a SoilProfileCollection with a subset of horizons, possibly with some sites removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp3)

depths(sp3) &lt;- id ~ top + bottom

# show just horizons with 10YR hues
plot(subsetHz(sp3, hue == '10YR'))

</code></pre>

<hr>
<h2 id='subsetProfiles'>DEPRECATED use subset</h2><span id='topic+subsetProfiles'></span><span id='topic+subsetProfiles+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p>This function is used to subset <code>SoilProfileCollection</code> objects using
either site-level or horizon-level attributes, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
subsetProfiles(object, s, h, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetProfiles_+3A_object">object</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="subsetProfiles_+3A_s">s</code></td>
<td>
<p>fully-quoted search criteria for matching
via site-level attributes</p>
</td></tr>
<tr><td><code id="subsetProfiles_+3A_h">h</code></td>
<td>
<p>fully-quoted search criteria for matching
via horizon-level attributes</p>
</td></tr>
<tr><td><code id="subsetProfiles_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>s</code> argument supplies a fully-quoted search criteria for matching
via site or horizon-level attributes. The <code>h</code> argument supplies a fully-quoted
search criteria for matching via horizon-level attributes. All horizons
associated with a single horizon-level match (i.e. out of several, only a
single horizon matches the search criteria) are returned. See examples for
usage.
</p>


<h3>Value</h3>

<p>A <code>SoilProfileCollection</code> class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# more interesting sample data
data(sp2)
depths(sp2) &lt;- id ~ top + bottom
site(sp2) &lt;- ~ surface

# subset by integer index, note that this does not re-order the profiles
plot(sp2[1:5, ])

# generate an integer index via pattern-matching
idx &lt;- grep('modesto', sp2$surface, ignore.case=TRUE)
plot(sp2[idx, ])

# generate in index via profileApply:
# subset those profiles where: min(ph) &lt; 5.6
idx &lt;- which(profileApply(sp2, function(i) min(i$field_ph, na.rm=TRUE) &lt; 5.6))
plot(sp2[idx, ])

</code></pre>

<hr>
<h2 id='summarizeSPC'>Perform summaries on groups (from <code>group_by</code>) and create new site or horizon level attributes</h2><span id='topic+summarizeSPC'></span><span id='topic+summarizeSPC+2CSoilProfileCollection-method+2C'></span><span id='topic+summarize'></span>

<h3>Description</h3>

<p><code>summarize()</code> is a function used for summarizing SoilProfileCollections. Specify the groups using the group_by verb, and then (named) expressions to evaluate on each group. The result is a data.frame with one row per categorical level in the grouping variable and one column for each summary variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeSPC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeSPC_+3A_object">object</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="summarizeSPC_+3A_...">...</code></td>
<td>
<p>A set of (named) comma-delimited R expressions that resolve to a summary value. e.g <code>groupmean = mean(clay, na.rm = TRUE)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one row per level in the grouping variable, and one column for each summary
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>

<hr>
<h2 id='tauW'>Compute weighted naive and <em>tau</em> statistics for a cross-classification matrix</h2><span id='topic+tauW'></span><span id='topic+summaryTauW'></span>

<h3>Description</h3>

<p><code>tauW</code>: Computes: (1) unweighted naive, (2) weighted naive, (3) unweighted <em>tau</em>, (4) weighted <em>tau</em> accuracy statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauW(
  CM,
  W = diag(sqrt(length(as.matrix(CM)))),
  P = rep(1/nrow(as.matrix(CM)), nrow(as.matrix(CM)))
)

summaryTauW(result.tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tauW_+3A_cm">CM</code></td>
<td>
<p>a square confusion (cross-classification) matrix (rows: allocation, columns: reference)</p>
</td></tr>
<tr><td><code id="tauW_+3A_w">W</code></td>
<td>
<p>weights: 1 on diagonals, [-1..1] off giving partial credit to this error</p>
</td></tr>
<tr><td><code id="tauW_+3A_p">P</code></td>
<td>
<p>prior probability vector, length = number of rows/columns in <code>CM</code> and <code>W</code></p>
</td></tr>
<tr><td><code id="tauW_+3A_result.tau">result.tau</code></td>
<td>
<p><code>tauW()</code> result</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summaryTauW</code>: prints a summary of the results from <em>tauW</em>
</p>
<p><code>xtableTauW</code>: formats a LaTeX table with results from <em>tauW</em> and saves it as a <code>.tex</code> file for import into a LaTeX document.
</p>
<p>Input matrices <code>CM</code> and <code>W</code> may be in <code>data.frame</code> format and will be converted
</p>
<p>Weights matrix <code>W</code>: 0 = no credit; 1 = full credit; -1 = maximum penalty
</p>
<p>If absent, default is no partial credit, i.e., unweighted.
</p>
<p>Prior probabilities vector <code>P</code>: If absent, <code>P</code> are equal priors for each class. Special value <code>P = 0</code> is interpreted as <code>P</code> = column marginals.
</p>
<p>Error checks: <code>CM</code> must be square; <code>P</code> must have correct number of classes and sum to 1 +/- 0.0001; <code>W</code> &amp; <code>CM</code> must be conformable
</p>


<h3>Value</h3>

<p>Results are returned in a list with obvious R names
</p>


<h3>Author(s)</h3>

<p>D.G. Rossiter
</p>


<h3>References</h3>


<ul>
<li><p> Rossiter, D. G., Zeng, R., &amp; Zhang, G.-L. (2017). Accounting for taxonomic distance in accuracy assessment of soil class predictions. Geoderma, 292, 118–127. <a href="https://doi.org/10.1016/j.geoderma.2017.01.012">doi:10.1016/j.geoderma.2017.01.012</a>
</p>
</li>
<li><p> Ma, Z. K., &amp; Redmond, R. L. (1995). Tau-coefficients for accuracy assessment of classification of remote-sensing data. Photogrammetric Engineering and Remote Sensing, 61(4), 435–439.
</p>
</li>
<li><p> Naesset, E. (1996). Conditional tau coefficient for assessment of producer’s accuracy of classified remotely sensed data. ISPRS Journal of Photogrammetry and Remote Sensing, 51(2), 91–98. <a href="https://doi.org/10.1016/0924-2716%2869%2900007-4">doi:10.1016/0924-2716(69)00007-4</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# example confusion matrix
# rows: allocation (user's counts)
# columns: reference (producer's counts)
crossclass &lt;- matrix(data=c(2,1,0,5,0,0,
                            1,74,2,1,3,6,
                            0,5,8,6,1,3,
                            6,1,3,91,0,0,
                            0,4,0,0,0,4,
                            0,6,2,2,4,38),
                     nrow=6, byrow=TRUE)
row.names(crossclass) &lt;- c("OP", "SA", "UA", "UC", "AV", "AC")
colnames(crossclass) &lt;- row.names(crossclass)

# build the weights matrix
# how much credit for a mis-allocation
weights &lt;- matrix(data=c(1.00,0.05,0.05,0.15,0.05,0.15,
                         0.05,1.00,0.05,0.05,0.05,0.35,
                         0.05,0.05,1.00,0.20,0.15,0.15,
                         0.15,0.05,0.25,1.00,0.10,0.25,
                         0.05,0.10,0.15,0.10,1.00,0.15,
                         0.20,0.30,0.10,0.25,0.20,1.00),
                  nrow=6, byrow=TRUE)

# unweighted accuracy
summaryTauW(nnaive &lt;- tauW(crossclass))

# unweighted tau with equal priors, equivalent to Foody (1992) modified Kappa
tauW(crossclass)$tau

# unweighted tau with user's = producer's marginals, equivalent to original kappa
(priors &lt;-  apply(crossclass, 2, sum)/sum(crossclass))
tauW(crossclass, P=priors)$tau

# weighted accuracy; tau with equal priors
summaryTauW(weighted &lt;- tauW(crossclass, W=weights))

# weighted accuracy; tau with user's = producer's marginals
summaryTauW(tauW(crossclass, W=weights, P=priors))

# change in accuracy statistics weighted vs. non-weighted
(weighted$overall.weighted - weighted$overall.naive)
(weighted$user.weighted - weighted$user.naive)
(weighted$prod.weighted - weighted$prod.naive)

</code></pre>

<hr>
<h2 id='texcl_to_ssc'>Textural conversions</h2><span id='topic+texcl_to_ssc'></span><span id='topic+ssc_to_texcl'></span><span id='topic+texmod_to_fragvoltot'></span><span id='topic+texture_to_taxpartsize'></span><span id='topic+texture_to_texmod'></span><span id='topic+fragvol_to_texmod'></span>

<h3>Description</h3>

<p>These functions consist of several conversions between sand, silt and clay
to texture class and visa versa, textural modifiers to rock fragments, and
grain size composition to the family particle size class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>texcl_to_ssc(texcl = NULL, clay = NULL, sample = FALSE)

ssc_to_texcl(
  sand = NULL,
  clay = NULL,
  simplify = FALSE,
  as.is = FALSE,
  droplevels = TRUE
)

texmod_to_fragvoltot(texmod = NULL, lieutex = NULL)

texture_to_taxpartsize(
  texcl = NULL,
  clay = NULL,
  sand = NULL,
  fragvoltot = NULL
)

texture_to_texmod(texture, duplicates = "combine")

fragvol_to_texmod(
  object = NULL,
  gravel = NULL,
  cobbles = NULL,
  stones = NULL,
  boulders = NULL,
  channers = NULL,
  flagstones = NULL,
  paragravel = NULL,
  paracobbles = NULL,
  parastones = NULL,
  paraboulders = NULL,
  parachanners = NULL,
  paraflagstones = NULL,
  as.is = TRUE,
  droplevels = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="texcl_to_ssc_+3A_texcl">texcl</code></td>
<td>
<p>vector of texture classes than conform to the USDA code
conventions (e.g. c|C, sil|SIL, sl|SL, cos|COS)</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_clay">clay</code></td>
<td>
<p>vector of clay percentages</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_sample">sample</code></td>
<td>
<p>logical: should ssc be random sampled from the lookup table?
(default: FALSE)</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_sand">sand</code></td>
<td>
<p>vector of sand percentages</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_simplify">simplify</code></td>
<td>
<p>Passed to <code>SoilTextureLevels()</code> to set the nu mber of possible texture classes. If <code>TRUE</code>, the ordered factor has a maximum of 12 levels, if <code>FALSE</code> (default) the ordered factor has a maximum of 21 levels (including e.g. very fine/fine/coarse variants)</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_as.is">as.is</code></td>
<td>
<p>logical: should character vectors be converted to factors?
(default: TRUE)</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_droplevels">droplevels</code></td>
<td>
<p>logical: indicating whether to drop unused levels in
factors. This is useful when the results have a large number of unused
classes, which can waste space in tables and figures.</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_texmod">texmod</code></td>
<td>
<p>vector of textural modifiers that conform to the USDA code
conventions (e.g. gr|GR, grv|GRV)</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_lieutex">lieutex</code></td>
<td>
<p>vector of in lieu of texture terms that conform to the USDA
code conventions (e.g. gr|GR, pg|PG), only used when fragments or artifacts
are &gt; 90 percent by volume (default: NULL))</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_fragvoltot">fragvoltot</code></td>
<td>
<p>vector of total rock fragment percentages</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_texture">texture</code></td>
<td>
<p>vector of combinations of texcl, texmod, and lieutex (e.g. CL, GR-CL, CBV-S, GR)</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_duplicates">duplicates</code></td>
<td>
<p>character: specifying how multiple values should be handled, options are <code>"combined"</code> (e.g. 'GR &amp; GRV) or <code>"max"</code>(e.g. 'GRV')</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_object">object</code></td>
<td>
<p>data.frame: containing the following column names: gravel, cobbles,
stones, boulders, channers, flagstones, paragravel, paracobbles, parastones,
paraboulders, parachanners, paraflagstones</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_gravel">gravel</code></td>
<td>
<p>numeric: gravel volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_cobbles">cobbles</code></td>
<td>
<p>numeric: cobble volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_stones">stones</code></td>
<td>
<p>numeric: stone volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_boulders">boulders</code></td>
<td>
<p>numeric: boulder volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_channers">channers</code></td>
<td>
<p>numeric: channer volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_flagstones">flagstones</code></td>
<td>
<p>numeric: flagstone volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_paragravel">paragravel</code></td>
<td>
<p>numeric: para gravel volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_paracobbles">paracobbles</code></td>
<td>
<p>numeric: para cobble volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_parastones">parastones</code></td>
<td>
<p>numeric: para stone volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_paraboulders">paraboulders</code></td>
<td>
<p>numeric: para boulder volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_parachanners">parachanners</code></td>
<td>
<p>numeric: para channer volume %</p>
</td></tr>
<tr><td><code id="texcl_to_ssc_+3A_paraflagstones">paraflagstones</code></td>
<td>
<p>numeric: para flagstone volume %</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are intended to estimate missing values or allocate particle
size fractions to classes. The <code>ssc_to_texcl()</code> function uses the same
logic as the particle size estimator calculation in NASIS to classify sand
and clay into texture class. The results are stored in <code>soiltexture</code>
and used by <code>texcl_to_ssc()</code> as a lookup table to convert texture class
to sand, silt and clay. The function <code>texcl_to_ssc()</code> replicates the
functionality described by Levi (2017). The <code>texmod_to_fragvol()</code>
function similarly uses the logical from the
Exhibit618-11_texture_modifier.xls spreadsheet to determine the textural
modifier from the various combinations of rock and pararock fragments
(e.g. GR and PGR).
</p>
<p>When <code>sample = TRUE</code>, the results can be used to estimate within-class,
marginal distributions of sand, silt, and clay fractions. It is recommended
that at least 10 samples be drawn for reasonable estimates.
</p>
<p>The function <code>texmod_to_fragvoltot</code> returns a data.frame with multiple
fragvoltot columns differentiated by tailing abbreviations (e.g. _r) which
refer to the following:
</p>

<ol>
<li><p> l = low
</p>
</li>
<li><p> r = representative
</p>
</li>
<li><p> h = high
</p>
</li>
<li><p> nopf = no pararock fragments (i.e. total fragments - pararock fragments)
</p>
</li></ol>

<p>The function <code>texture_to_texmod()</code> parses texture (e.g. GR-CL) to extract the texmod values from it in the scenario where it is missing from
texmod column. If multiple texmod values are present (for example in the
case of stratified textures) and <code>duplicates = "combine"</code> they will be combined in the output (e.g. GR &amp; CBV). Otherwise if <code>duplicates = "max"</code>
the texmod with the highest rock fragment (e.g. CBV) will be returned.
</p>
<p>Unlike the other functions, <code>texture_to_taxpartsize()</code> is intended to
be computed on weighted averages within the family particle size control
section. Also recall from the criteria that carbonate clay should be
subtracted from clay content and added to silt content. Similarly, if the
percent of very fine sand is known it should be subtracted from the sand,
and added to the silt content. Unlike the other functions,
<code>texture_to_taxpartsize()</code> is intended to be computed on weighted
averages within the family particle size control section. Also recall from
the criteria that carbonate clay should be subtracted from clay content and
added to silt content. Similarly, if the percent of very fine sand is known
it should be subtracted from the sand, and added to the silt content.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>texcl_to_ssc</code>: A <code>data.frame</code> containing columns <code>"sand"</code>,<code>"silt"</code>, <code>"clay"</code>
</p>
</li></ul>


<ul>
<li> <p><code>ssc_to_texcl</code>: A <code>character</code> vector containing texture class
</p>
</li></ul>


<ul>
<li> <p><code>texmod_to_fragvoltot</code>: A <code>data.frame</code> containing columns <code>"fragvoltot_l"</code>,
<code>"fragvoltot_r"</code>, <code>"fragvoltot_h"</code>, <code>"fragvoltot_l_nopf"</code>, <code>"fragvoltot_r_nopf"</code>, <code>"fragvoltot_h_nopf"</code>
</p>
</li></ul>


<ul>
<li> <p><code>texture_to_taxpartsize</code>: a character vector containing <code>"taxpartsize"</code> classes
</p>
</li></ul>


<ul>
<li> <p><code>texture_to_texmod</code>: a character vector containing <code>"texmod"</code> classes
</p>
</li></ul>


<ul>
<li> <p><code>texmod_to_fragvol</code>: a data.frame containing <code>"texmod"</code> and <code>"lieutex"</code> classes
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Stephen Roecker
</p>


<h3>References</h3>

<p>Matthew R. Levi, Modified Centroid for Estimating Sand, Silt, and Clay from Soil Texture Class, Soil Science Society of America Journal, 2017, 81(3):578-588, ISSN 1435-0661, <a href="https://doi.org/10.2136/sssaj2016.09.0301">doi:10.2136/sssaj2016.09.0301</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example of ssc_to_texcl()
tex &lt;- expand.grid(sand = 0:100, clay = 0:100)
tex &lt;- subset(tex, (sand + clay) &lt; 101)
tex$texcl &lt;- ssc_to_texcl(sand = tex$sand, clay = tex$clay)
head(tex)

# example of texcl_to_ssc(texcl)
texcl &lt;- c("cos", "s", "fs", "vfs", "lcos", "ls",
          "lfs", "lvfs", "cosl", "sl", "fsl", "vfsl", "l",
          "sil", "si", "scl", "cl", "sicl", "sc", "sic", "c"
          )
test &lt;- texcl_to_ssc(texcl)
head(test &lt;- cbind(texcl, test), 10)


# example of texcl_to_ssc(texcl, clay)
data(soiltexture)
st &lt;- soiltexture$values
idx &lt;- sample(1:length(st$texcl), 10)
st &lt;- st[idx, ]
ssc &lt;- texcl_to_ssc(texcl = st$texcl)
head(cbind(texcl = st$texcl, clay = ssc$clay))


# example of texmod_to_fragvoltol
frags &lt;- c("gr", "grv", "grx", "pgr", "pgrv", "pgrx")
head(texmod_to_fragvoltot(frags))


# example of texture_to_taxpartsize()
tex &lt;- data.frame(texcl = c("c", "cl", "l", "ls", "s"),
                  clay  = c(55, 33, 18, 6, 3),
                  sand  = c(20, 33, 42, 82, 93),
                  fragvoltot = c(35, 15, 34, 60, 91))
tex$fpsc &lt;- texture_to_taxpartsize(texcl = tex$texcl,
                                   clay = tex$clay,
                                   sand = tex$sand,
                                   fragvoltot = tex$fragvoltot)
head(tex)


# example of texture_to_taxpartsize() with carbonate clay and very fine sand
carbclay &lt;- rnorm(5, 2, 3)
vfs &lt;- rnorm(5, 10, 3)
st$fpsc &lt;- texture_to_taxpartsize(texcl = tex$texcl,
                                  clay = tex$clay - carbclay,
                                  sand = tex$sand - vfs,
                                  fragvoltot = tex$fragvoltot)
head(tex)


# example of sample = TRUE
texcl &lt;- rep(c("cl", "sil", "sl"), 10)
ssc1 &lt;- cbind(texcl, texcl_to_ssc(texcl = texcl, sample = FALSE))
ssc2 &lt;- cbind(texcl, texcl_to_ssc(texcl = texcl, sample = TRUE))
ssc1$sample &lt;- FALSE
ssc2$sample &lt;- TRUE
ssc  &lt;- rbind(ssc1, ssc2)
aggregate(clay ~ sample + texcl, data = ssc, summary)


# example of texture_to_texmod()
tex &lt;- c("SL", "GR-SL", "CBV-L", "SR- GR-FS GRX-COS")
texture_to_texmod(tex)
texture_to_texmod(tex, duplicates = "max")


# example of fragvol_to_texmod()
df &lt;- expand.grid(
  gravel  = seq(0, 100, 5), 
  cobbles = seq(0, 100, 5), 
  stones  = seq(0, 100, 5), 
  boulders = seq(0, 100, 5)
  )
df &lt;- df[rowSums(df) &lt; 100, ]

# data.frame input
test &lt;- fragvol_to_texmod(df)
table(test$texmod)
table(test$lieutex)

# vector inputs
fragvol_to_texmod(gravel = 10, cobbles = 10)


</code></pre>

<hr>
<h2 id='textureTriangleSummary'>Soil Texture Low-RV-High as Defined by Quantiles</h2><span id='topic+textureTriangleSummary'></span>

<h3>Description</h3>

<p>This function accepts soil texture components (sand, silt, and clay percentages) and plots a soil texture triangle with a &quot;representative value&quot; (point) and low-high region (polygon) defined by quantiles (estimated with <code>Hmisc::hdquantile</code>). Marginal quantiles of sand, silt, and clay are used to define the boundary of a low-high region. The default settings place the RV symbol at the texture defined by marginal medians of sand, silt, and clay. The default low-high region is defined by the 5th and 95th marginal percentiles of sand, silt, and clay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textureTriangleSummary(
  ssc,
  p = c(0.05, 0.5, 0.95),
  delta = 1,
  rv.col = "red",
  range.border = "black",
  range.col = "RoyalBlue",
  range.alpha = 80,
  range.lty = 1,
  range.lwd = 2,
  main = "Soil Textures",
  legend.cex = 0.75,
  legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textureTriangleSummary_+3A_ssc">ssc</code></td>
<td>
<p><code>data.frame</code> with columns: 'SAND', 'SILT', 'CLAY', values are percentages that should add to 100. No NA allowed.</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_p">p</code></td>
<td>
<p>vector of percentiles (length = 3) defining 'low', 'representative value', and 'high'</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_delta">delta</code></td>
<td>
<p>grid size used to form low-high region</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_rv.col">rv.col</code></td>
<td>
<p>color used for representative value (RV) symbol</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_range.border">range.border</code></td>
<td>
<p>color used for polygon border enclosing the low-high region</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_range.col">range.col</code></td>
<td>
<p>color used for polygon enclosing the low-high region</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_range.alpha">range.alpha</code></td>
<td>
<p>transparency of the low-high range polygon (0-255)</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_range.lty">range.lty</code></td>
<td>
<p>line style for polygon enclosing the low-high region</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_range.lwd">range.lwd</code></td>
<td>
<p>line weight polygon enclosing the low-high region</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_main">main</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_legend.cex">legend.cex</code></td>
<td>
<p>scaling factor for legend</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_legend">legend</code></td>
<td>
<p>logical, enable/disable automatic legend</p>
</td></tr>
<tr><td><code id="textureTriangleSummary_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>soiltexture::TT.points</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an invisible <code>matrix</code> with marginal percentiles of sand, silt, and clay
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette, J. Nemecek, K. Godsey
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootstrapSoilTexture">bootstrapSoilTexture</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if(
requireNamespace("Hmisc") &amp;
  requireNamespace("compositions") &amp;
  requireNamespace("soiltexture")
) {
  
  # sample data
  data('sp4')
  
  # subset rows / columns
  ssc &lt;- sp4[grep('^Bt', sp4$name), c('sand', 'silt', 'clay')]
  names(ssc) &lt;- toupper(names(ssc))
  
  # make figure, marginal percentiles are silently returned
  stats &lt;- textureTriangleSummary(
    ssc, pch = 1, cex = 0.5, 
    range.alpha = 50, 
    range.lwd = 1,
    col = grey(0.5), 
    legend = FALSE
  )
  
  # check
  stats
  
  # simulate some data and try again
  s &lt;- bootstrapSoilTexture(ssc, n = 100)$samples
  
  # make the figure, ignore results
  textureTriangleSummary(
    s, pch = 1, cex = 0.5, 
    range.alpha = 50, 
    range.lwd = 1,
    col = grey(0.5), 
    legend = FALSE
  )
}



</code></pre>

<hr>
<h2 id='thompson.bell.darkness'>Thompson-Bell (1996) Index</h2><span id='topic+thompson.bell.darkness'></span>

<h3>Description</h3>

<p>Calculate the &quot;Profile Darkness Index&quot; by the method of Thompson &amp; Bell (1996) &quot;Color index for identifying hydric conditions for seasonally saturated mollisols in Minnesota&quot; DOI: 10.2136/sssaj1996.03615995006000060051x. The Thompson-Bell Index has been shown to reflect catenary relationships in some Mollisols of Minnesota (generally: wetter landscape positions = thicker, darker surfaces).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thompson.bell.darkness(
  p,
  name = guessHzDesgnName(p, required = TRUE),
  pattern = "^A",
  value = "m_value",
  chroma = "m_chroma"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thompson.bell.darkness_+3A_p">p</code></td>
<td>
<p>A single-profile SoilProfileCollection (e.g. via profileApply())</p>
</td></tr>
<tr><td><code id="thompson.bell.darkness_+3A_name">name</code></td>
<td>
<p>Column name containing horizon designations used to find A horizons (default: first column name containing 'name')</p>
</td></tr>
<tr><td><code id="thompson.bell.darkness_+3A_pattern">pattern</code></td>
<td>
<p>Regular expression to match A horizons (default: &quot;^A&quot; which means horizon designation <em>starts with</em> A)</p>
</td></tr>
<tr><td><code id="thompson.bell.darkness_+3A_value">value</code></td>
<td>
<p>Column name containing horizon color values (default: &quot;m_value&quot;)</p>
</td></tr>
<tr><td><code id="thompson.bell.darkness_+3A_chroma">chroma</code></td>
<td>
<p>Column name containing horizon color chromas (default: &quot;m_chroma&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector reflecting horizon darkness (lower values = darker).
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown
</p>


<h3>References</h3>

<p>Thompson, J.A. and Bell, J.C. (1996), Color Index for Identifying Hydric Conditions for Seasonally Saturated Mollisols in Minnesota. Soil Science Society of America Journal, 60: 1979-1988. doi:10.2136/sssaj1996.03615995006000060051x
</p>

<hr>
<h2 id='traditionalColorNames'>Traditional Soil Color Names</h2><span id='topic+traditionalColorNames'></span>

<h3>Description</h3>

<p>Traditional soil color names associated with select Munsell colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(traditionalColorNames)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 482 rows and 2 columns.
</p>


<h3>References</h3>

<p>Sourced from the &quot;colorconverter&quot; NASIS property script.
</p>

<hr>
<h2 id='transform+2CSoilProfileCollection-method'>Transform a SPC with expressions based on site or horizon level attributes</h2><span id='topic+transform+2CSoilProfileCollection-method'></span><span id='topic+mutate'></span><span id='topic+mutate+2CSoilProfileCollection-method'></span>

<h3>Description</h3>

<p><code>transform()</code> is a function used for modifying columns in SoilProfileCollections.
</p>
<p>It allows the user to specify an arbitrary number of expressions that resolve to the (re-)calculation of one or more site or horizon level attributes. For instance: <code>mutate(spc, thickness = hzdepb - hzdept)</code>. The expressions may depend on one another, and are evaluated from left to right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
transform(`_data`, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform+2B2CSoilProfileCollection-method_+3A__data">_data</code></td>
<td>
<p>A SoilProfileCollection</p>
</td></tr>
<tr><td><code id="transform+2B2CSoilProfileCollection-method_+3A_...">...</code></td>
<td>
<p>Comma-separated set of R expressions e.g. <code>thickness = hzdepb - hzdept, hzdepm = hzdept + round(thk / 2)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SoilProfileCollection
</p>


<h3>Author(s)</h3>

<p>Andrew G. Brown.
</p>

<hr>
<h2 id='unique+2CSoilProfileCollection-method'>Uniqueness within a <code>SoilProfileCollection</code> via MD5 Hash</h2><span id='topic+unique+2CSoilProfileCollection-method'></span><span id='topic+unique'></span>

<h3>Description</h3>

<p>Unique profiles within a <code>SoilProfileCollection</code> using and MD5 hash of select horizon and / or site level attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
unique(x, vars, SPC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique+2B2CSoilProfileCollection-method_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code></p>
</td></tr>
<tr><td><code id="unique+2B2CSoilProfileCollection-method_+3A_vars">vars</code></td>
<td>
<p>Variables to consider in uniqueness.</p>
</td></tr>
<tr><td><code id="unique+2B2CSoilProfileCollection-method_+3A_spc">SPC</code></td>
<td>
<p>logical return a <code>SoilProfileCollection</code> when <code>TRUE</code>, otherwise vector of profile indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SoilProfileCollection</code> when <code>SPC = TRUE</code>, otherwise a vector of integers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # an example soil profile
  x &lt;- data.frame(
    id = 'A',
    name = c('A', 'E', 'Bhs', 'Bt1', 'Bt2', 'BC', 'C'),
    top = c(0, 10, 20, 30, 40, 50, 100),
    bottom = c(10, 20, 30, 40, 50, 100, 125),
    z = c(8, 5, 3, 7, 10, 2, 12)
  )
  
  # init SPC
  depths(x) &lt;- id ~ top + bottom
  
  # horizon depth variability for simulation
  horizons(x)$.sd &lt;- 2
  
  # duplicate several times
  x.dupes &lt;- duplicate(x, times = 5)
  
  # simulate some new profiles based on example
  x.sim &lt;- perturb(x, n = 5, thickness.attr = '.sd')
  
  # graphical check
  plotSPC(x.dupes, name.style = 'center-center')
  plotSPC(x.sim, name.style = 'center-center')
  
  # inspect unique results
  plotSPC(unique(x.dupes, vars = c('top', 'bottom')), name.style = 'center-center')
  
  # uniqueness is a function of variable selection
  plotSPC(unique(x.sim, vars = c('top', 'bottom')), name.style = 'center-center')
  plotSPC(unique(x.sim, vars = c('name')), name.style = 'center-center')
  


</code></pre>

<hr>
<h2 id='unroll'>Unroll Genetic Horizons</h2><span id='topic+unroll'></span>

<h3>Description</h3>

<p>Generate a discretized vector of genetic horizons along a user-defined
pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unroll(top, bottom, prop, max_depth, bottom_padding_value = NA, strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unroll_+3A_top">top</code></td>
<td>
<p>vector of upper horizon boundaries, must be an integer</p>
</td></tr>
<tr><td><code id="unroll_+3A_bottom">bottom</code></td>
<td>
<p>vector of lower horizon boundaries, must be an integer</p>
</td></tr>
<tr><td><code id="unroll_+3A_prop">prop</code></td>
<td>
<p>vector of some property to be &quot;unrolled&quot; over a regular sequence</p>
</td></tr>
<tr><td><code id="unroll_+3A_max_depth">max_depth</code></td>
<td>
<p>maximum depth to which missing data is padded with NA</p>
</td></tr>
<tr><td><code id="unroll_+3A_bottom_padding_value">bottom_padding_value</code></td>
<td>
<p>value to use when padding missing data</p>
</td></tr>
<tr><td><code id="unroll_+3A_strict">strict</code></td>
<td>
<p>should horizons be strictly checked for self-consistency?
defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by several higher-level components of the
<code>aqp</code> package. Basic error checking is performed to make sure that
bottom and top horizon boundaries make sense. Note that the horizons should
be sorted according to depth before using this function. The
<code>max_depth</code> argument is used to specify the maximum depth of profiles
within a collection, so that data from any profile shallower than this depth
is padded with NA.
</p>


<h3>Value</h3>

<p>a vector of &quot;unrolled&quot; property values
</p>


<h3>Author(s)</h3>

<p>Dylan E. Beaudette
</p>


<h3>References</h3>

<p>http://casoilresource.lawr.ucdavis.edu/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(sp1)

# subset a single soil profile:
sp1.1 &lt;- subset(sp1, subset=id == 'P001')

# demonstrate how this function works
x &lt;- with(sp1.1, unroll(top, bottom, prop, max_depth=50))
plot(x, 1:length(x), ylim=c(90,0), type='b', cex=0.5)

</code></pre>

<hr>
<h2 id='us.state.soils'>US State Soils</h2><span id='topic+us.state.soils'></span>

<h3>Description</h3>

<p>A listing of the 50 US state soils, along with Puerto Rico and Virgin Islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(us.state.soils)
</code></pre>


<h3>Format</h3>


<dl>
<dt>state</dt><dd><p>state name</p>
</dd>
<dt>abbreviated</dt><dd><p>abbreviated state name</p>
</dd>
<dt>series</dt><dd><p>soil series name</p>
</dd>
</dl>


<hr>
<h2 id='validSpatialData+2CSoilProfileCollection-method'>Check for valid spatial reference of profiles</h2><span id='topic+validSpatialData+2CSoilProfileCollection-method'></span><span id='topic+validSpatialData'></span>

<h3>Description</h3>

<p>Are coordinate column names defined in metadata and existing in the SoilProfileCollection?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SoilProfileCollection'
validSpatialData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validSpatialData+2B2CSoilProfileCollection-method_+3A_object">object</code></td>
<td>
<p>a SoilProfileCollection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical <code>TRUE</code> if column names are defined and correspond to existing data
</p>

<hr>
<h2 id='warpHorizons'>Inflate / Deflate Horizon Thickness</h2><span id='topic+warpHorizons'></span>

<h3>Description</h3>

<p>This function applies a warping factor to the horizons of a single-profile <code>SoilProfileCollection</code> object. Warping values &gt;1 will inflate horizon thickness, values &lt;1 will deflate horizon thickness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warpHorizons(x, fact, updateProfileID = TRUE, suffix = "-w")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warpHorizons_+3A_x">x</code></td>
<td>
<p>a <code>SoilProfileCollection</code> object</p>
</td></tr>
<tr><td><code id="warpHorizons_+3A_fact">fact</code></td>
<td>
<p>numeric or character; warping factor specified as a single numeric value, vector of numeric values (length = nrow(x)), or column name of a horizon level attribute containing numeric values</p>
</td></tr>
<tr><td><code id="warpHorizons_+3A_updateprofileid">updateProfileID</code></td>
<td>
<p>logical; modify profile IDs</p>
</td></tr>
<tr><td><code id="warpHorizons_+3A_suffix">suffix</code></td>
<td>
<p>character; suffix added to profile IDs when <code>updateProfileID = TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified version of <code>x</code>, <code>SoilProfileCollection</code> object
</p>


<h3>Author(s)</h3>

<p>D.E. Beaudette and S.W. Salley
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create an example profile
s &lt;- quickSPC('p1:AA|Bt1Bt1Bt1|Bt2Bt2B|Bt3|Cr|RRRRR')

# warp each horizon
# values &gt; 1: inflation
# values &lt; 1: deflation (erosion / compaction)
s.w &lt;- warpHorizons(s, fact = c(1.3, 0.7, 0.8, 1, 1, 1))

# combine original + warped
x &lt;- combine(s, s.w)

# compute profile bottom depths
.bottoms &lt;- x[, , .LAST, .BOTTOM]

# change in total depth after warping
# used to vertically offset the warped profile
.yoff &lt;- c(0, .bottoms[1] - .bottoms[2])

# depths for line segments connecting horizon tops
.y1 &lt;- x[1, , .TOP]
.y2 &lt;- x[2, , .TOP] + .yoff[2]

# sketches
# can't automatically add a depth axis
par(mar = c(0.5, 0, 0, 2))
plotSPC(
  x, 
  name.style = 'center-center', 
  cex.names = 0.8, 
  width = 0.2, 
  max.depth = 150, 
  depth.axis = list(line = -3), 
  y.offset = .yoff
)

# illustrate warping with arrows
arrows(x0 = 1 + 0.25, y0 = .y1, x1 = 2 - 0.25, y1 = .y2, len = 0.1, col = 2)

# manually add depth axis
axis(side = 4, line = -3.5, las = 1, at = seq(from = 0, to = 150, by = 25))


# apply to multiple profiles
# text-based template
.template &lt;- c(
'P1:AAA|BwBwBwBw|CCCCCCC|CdCdCdCd',
'P2:ApAp|AA|E|BhsBhs|Bw1Bw1|CCCCC',
'P3: A|Bt1Bt1Bt1|Bt2Bt2Bt2|Bt3|Cr|RRRRR'
)

# each horizon label is '10' depth-units (default)
s &lt;- quickSPC(.template)

# random warping factor, by horizon
s$f &lt;- runif(n = nrow(s), min = 0.8, max = 1.2)

# warp horizons by profile, result is a list of SPCs
s.w &lt;- profileApply(s, FUN = warpHorizons, fact = 'f')

# flatten list -&gt; SoilProfileCollection
s.w &lt;- combine(s.w)

# combine with original SPC
x &lt;- combine(s, s.w)

# sketches 
par(mar = c(0.5, 0, 0, 2.5))
plotSPC(
  x,
  name.style = 'center-center',
  cex.names = 0.8,
  width = 0.3,
  max.depth = 165,
  depth.axis = list(line = -2)
)


</code></pre>

<hr>
<h2 id='wilson2022'>Example Data from Wilson et al. 2022</h2><span id='topic+wilson2022'></span>

<h3>Description</h3>

<p>An example <code>SoilProfileCollection</code>, derived from Wilson et al., 2022. Select data extracted from Appendix tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wilson2022)
</code></pre>


<h3>Format</h3>

<p>A <code>SoilProfileCollection</code> with the following elements. Total elemental analysis by lithium borate fusion.
</p>
<p>Horizon level attributes:
</p>

<ul>
<li><p> name: horizon designation
</p>
</li>
<li><p> Al2O3: total Al (wt %)
</p>
</li>
<li><p> Fe2O3: total Fe (wt %)
</p>
</li>
<li><p> K2O: total K (wt %)
</p>
</li>
<li><p> MgO: total Mg (wt %)
</p>
</li>
<li><p> Na2O: total Na (wt %)
</p>
</li>
<li><p> P2O5: total P (wt %)
</p>
</li>
<li><p> SiO2: total Si (wt %)
</p>
</li>
<li><p> CaO: total Ca(wt %)
</p>
</li>
<li><p> Alo: Oxalate Extractable Al (g/kg)
</p>
</li>
<li><p> Feo: Oxalate Extractable Fe (g/kg)
</p>
</li>
<li><p> Fed: Dithionite extractable Fe (g/kg)
</p>
</li>
<li><p> Fed_minus_Feo: Crystalline Fe (hydr)oxides (g/kg)
</p>
</li>
<li><p> CIA: Chemical Index of Alteration, see original paper (ratio, unitless)
</p>
</li>
<li><p> Fed_div_Fet: (ratio, unitless)
</p>
</li>
<li><p> Fet: Total Fe from lithium borate fusion (g/kg)
</p>
</li>
<li><p> resin_Pi: Hedley phosphorus fractions (mg/kg)
</p>
</li>
<li><p> NaHCO3_Pi: Hedley phosphorus fractions (mg/kg)
</p>
</li>
<li><p> labile_Pi: Sum of resin Pi and NaHCO3 Pi (mg/kg)
</p>
</li>
<li><p> NaCO3_Po: Hedley phosphorus fractions (mg/kg)
</p>
</li>
<li><p> NaOH_Pi: Hedley phosphorus fractions (mg/kg)
</p>
</li>
<li><p> NaOH_Po: Hedley phosphorus fractions (mg/kg)
</p>
</li>
<li><p> Ca_Pi: Hedley phosphorus fractions (mg/kg)
</p>
</li>
<li><p> organic_P: Sum of NaHCO3 and NaOH Po fractions (mg/kg)
</p>
</li>
<li><p> total_P: Total P from lithium borate fusion (mg/kg)
</p>
</li>
<li><p> occluded_P: Difference between total P and sum of Hedley P fractions (mg/kg)
</p>
</li>
<li><p> top: horizon top depth (cm)
</p>
</li>
<li><p> bottom: horizon bottom depth (cm)
</p>
</li>
<li><p> pedonID: pedon ID (serial number)
</p>
</li></ul>

<p>Site level attributes:
</p>

<ul>
<li><p> pm: parent material group
</p>
</li>
<li><p> biome: biome
</p>
</li></ul>



<h3>References</h3>

<p>Stewart G. Wilson, Randy A. Dahlgren, Andrew J. Margenot, Craig Rasmussen, Anthony T. O'Geen. 2022. Expanding the Paradigm: The influence of climate and lithology on soil phosphorus, Geoderma: 421. <a href="https://doi.org/10.1016/j.geoderma.2022.115809">doi:10.1016/j.geoderma.2022.115809</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(wilson2022)

groupedProfilePlot(wilson2022, groups = 'pm', 
group.name.offset = -15, label = 'biome', 
name.style = 'center-center', color = 'CIA', 
cex.names = 0.66, cex.id = 0.66, width = 0.3, 
depth.axis = FALSE, hz.depths = TRUE)

groupedProfilePlot(wilson2022, groups = 'biome', 
group.name.offset = -15, label = 'pm', 
name.style = 'center-center', color = 'Fet', 
cex.names = 0.66, cex.id = 0.66, width = 0.3, 
depth.axis = FALSE, hz.depths = TRUE)

</code></pre>

<hr>
<h2 id='xtableTauW'>Format a LaTeX table with results</h2><span id='topic+xtableTauW'></span>

<h3>Description</h3>

<p>Format a LaTeX table with results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtableTauW(result.tau, file.name = "tau_results_table.tex")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtableTauW_+3A_result.tau">result.tau</code></td>
<td>
<p>results returned by <code>tauW</code></p>
</td></tr>
<tr><td><code id="xtableTauW_+3A_file.name">file.name</code></td>
<td>
<p>name of file to write output TeX file; Default: <code>file.name="tau_results_table.tex"</code></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
