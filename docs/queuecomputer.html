<!DOCTYPE html><html><head><title>Help for package queuecomputer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {queuecomputer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.server.list'><p>Creates a <code>"server.list"</code> object from a list of times and starting availability.</p></a></li>
<li><a href='#as.server.stepfun'><p>Create a <code>server.stepfun</code> object with a roster of times and number of available servers.</p></a></li>
<li><a href='#average_queue'><p>Compute time average queue length</p></a></li>
<li><a href='#depart'><p>get departure times from <code>queue_list</code> object</p></a></li>
<li><a href='#lag_step'><p>Add lag to vector of arrival times.</p></a></li>
<li><a href='#plot.queue_list'><p>ggplot2 method for output from queueing model</p></a></li>
<li><a href='#print.summary_queue_list'><p>Print method for output of <code>summary.queue_list</code>.</p></a></li>
<li><a href='#ql_summary'><p>Summarise queue lengths</p></a></li>
<li><a href='#queue'><p>Compute the departure times for a set of customers in a queue from their arrival and service times.</p></a></li>
<li><a href='#queue_lengths'><p>Compute queue lengths from arrival, service and departure data</p></a></li>
<li><a href='#queue_step'><p>Compute the departure times and queue lengths for a queueing system from arrival and service times.</p></a></li>
<li><a href='#summary.queue_list'><p>Summary method for queue_list object</p></a></li>
<li><a href='#wait_step'><p>Compute maximum time for each row from two vectors of arrival times.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Computationally Efficient Queue Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of a computationally efficient method for
    simulating queues with arbitrary arrival and service times. 
    Please see Ebert, Wu, Mengersen &amp; Ruggeri (2020, &lt;<a href="https://doi.org/10.18637%2Fjss.v095.i05">doi:10.18637/jss.v095.i05</a>&gt;) 
    for further details. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rcpp, tidyr, dplyr, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.7.500.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AnthonyEbert/queuecomputer">https://github.com/AnthonyEbert/queuecomputer</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>file COPYRIGHTS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-13 15:40:39 UTC; EN81SE</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Ebert <a href="https://orcid.org/0000-0003-3002-6300"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kerrie Mengersen [ths],
  Paul Wu [ths],
  Fabrizio Ruggeri [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anthony Ebert &lt;anthonyebert+CRAN@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-15 21:20:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.server.list'>Creates a <code>"server.list"</code> object from a list of times and starting availability.</h2><span id='topic+as.server.list'></span>

<h3>Description</h3>

<p>Creates a <code>"server.list"</code> object from a list of times and starting availability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.server.list(times, init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.server.list_+3A_times">times</code></td>
<td>
<p>list of numeric vectors giving change times for each server.</p>
</td></tr>
<tr><td><code id="as.server.list_+3A_init">init</code></td>
<td>
<p>vector of 1s and 0s with equal length to <code>times</code>.
It represents whether the server starts in an available <code>(1)</code> or unavailable <code>(0)</code> state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"server.list"</code>, which is a list of step functions of range {0, 1}.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.server.stepfun">as.server.stepfun</a></code>, <code><a href="#topic+queue_step">queue_step</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a server.list object with the first server available anytime before time 10,
# and the second server available between time 15 and time 30.
as.server.list(list(10, c(15,30)), c(1,0))
</code></pre>

<hr>
<h2 id='as.server.stepfun'>Create a <code>server.stepfun</code> object with a roster of times and number of available servers.</h2><span id='topic+as.server.stepfun'></span>

<h3>Description</h3>

<p>Create a <code>server.stepfun</code> object with a roster of times and number of available servers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.server.stepfun(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.server.stepfun_+3A_x">x</code></td>
<td>
<p>numeric vector giving the times of changes in number of servers.</p>
</td></tr>
<tr><td><code id="as.server.stepfun_+3A_y">y</code></td>
<td>
<p>numeric vector one longer than <code>x</code> giving the number of servers
available between x values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the analogy of a step function to specify the number of
available servers throughout the day. It is used as input to the <code><a href="#topic+queue_step">queue_step</a></code>
function. Alternatively one may use <code>as.server.list</code> to specify available servers as
a list, however <code>queue_step</code> is much faster when <code>as.server.stepfun</code> is used
as input rather than <code>as.server.list</code>.
</p>
<p>If any of the service times are large compared to any element of <code>diff(x)</code> then the
<code><a href="#topic+as.server.list">as.server.list</a></code> function should be used.
</p>


<h3>Value</h3>

<p>A <code>list</code> and <code>server.stepfun</code> object with x and y as elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.server.list">as.server.list</a></code>, <code><a href="#topic+queue_step">queue_step</a></code>, <code><a href="stats.html#topic+stepfun">stepfun</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
servers &lt;- as.server.stepfun(c(15,30,50), c(0, 1, 3, 2))
servers

</code></pre>

<hr>
<h2 id='average_queue'>Compute time average queue length</h2><span id='topic+average_queue'></span>

<h3>Description</h3>

<p>Compute time average queue length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_queue(times, queuelength)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_queue_+3A_times">times</code></td>
<td>
<p>numeric vector of times</p>
</td></tr>
<tr><td><code id="average_queue_+3A_queuelength">queuelength</code></td>
<td>
<p>numeric vector of queue lengths</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1e3
arrivals &lt;- cumsum(rexp(n))
service &lt;- rexp(n)
departures &lt;- queue(arrivals, service, 1)

queuedata &lt;- queue_lengths(arrivals, service, departures)
average_queue(queuedata$times, queuedata$queuelength)
</code></pre>

<hr>
<h2 id='depart'>get departure times from <code>queue_list</code> object</h2><span id='topic+depart'></span>

<h3>Description</h3>

<p>get departure times from <code>queue_list</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depart(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depart_+3A_x">x</code></td>
<td>
<p>an <code>queue_list</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>departure times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arrivals &lt;- cumsum(rexp(10))
service &lt;- rexp(10)
queue_obj &lt;- queue_step(arrivals, service)

depart(queue_obj)
queue_obj$departures_df$departures
</code></pre>

<hr>
<h2 id='lag_step'>Add lag to vector of arrival times.</h2><span id='topic+lag_step'></span>

<h3>Description</h3>

<p>Add lag to vector of arrival times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag_step(arrivals, service)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag_step_+3A_arrivals">arrivals</code></td>
<td>
<p>Either a numeric vector or an object of class <code>queue_list</code>. It represents the arrival times.</p>
</td></tr>
<tr><td><code id="lag_step_+3A_service">service</code></td>
<td>
<p>A vector of service times with the same ordering as arrivals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of response times for the input of arrival times and service times.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wait_step">wait_step</a></code>, <code><a href="#topic+queue_step">queue_step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create arrival times
arrivals &lt;- rlnorm(100, meanlog = 3)

# Create service times
service &lt;- rlnorm(100)
lag_step(arrivals = arrivals, service = service)

# lag_step is equivalent to queue_step with a large number of queues, but it's faster to compute.

cbind(queue(arrivals, service = service, servers = 100),
lag_step(arrivals = arrivals, service = service))
</code></pre>

<hr>
<h2 id='plot.queue_list'>ggplot2 method for output from queueing model</h2><span id='topic+plot.queue_list'></span>

<h3>Description</h3>

<p>ggplot2 method for output from queueing model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'queue_list'
plot(x, which = c(2:6), annotated = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.queue_list_+3A_x">x</code></td>
<td>
<p>an object of class <code>queue_list</code></p>
</td></tr>
<tr><td><code id="plot.queue_list_+3A_which">which</code></td>
<td>
<p>Numeric vector of integers from 1 to 6 which represents which plots are to be created. See examples.</p>
</td></tr>
<tr><td><code id="plot.queue_list_+3A_annotated">annotated</code></td>
<td>
<p>logical, if <code>TRUE</code> annotations will be added to the plot.</p>
</td></tr>
<tr><td><code id="plot.queue_list_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

n_customers &lt;- 50
arrival_rate &lt;- 1.8
service_rate &lt;- 1
arrivals &lt;- cumsum(rexp(n_customers, arrival_rate))
service &lt;- rexp(n_customers, service_rate)
queue_obj &lt;- queue_step(arrivals, service, servers = 2)
plot(queue_obj)



library(ggplot2)

## density plots of arrival and departure times
plot(queue_obj, which = 1)

## histograms of arrival and departure times
plot(queue_obj, which = 2)

## density plots of waiting and system times
plot(queue_obj, which = 3)

## step function of queue length
plot(queue_obj, which = 4)

## line range plot of customer and server status
plot(queue_obj, which = 5)

## empirical distribution plot of arrival and departure times
plot(queue_obj, which = 6)


## End(Not run)

</code></pre>

<hr>
<h2 id='print.summary_queue_list'>Print method for output of <code>summary.queue_list</code>.</h2><span id='topic+print.summary_queue_list'></span>

<h3>Description</h3>

<p>Print method for output of <code>summary.queue_list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_queue_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary_queue_list_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary_queue_list</code>, the result of a call to <code>summary.queue_list()</code>.</p>
</td></tr>
<tr><td><code id="print.summary_queue_list_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of performance statistics for the queue:
</p>
<p>&quot;Total customers&quot;: Total customers in simulation,
</p>
<p>&quot;Missed customers&quot;: Customers who never saw a server,
</p>
<p>&quot;Mean waiting time&quot;: The mean time each customer had to wait in queue for service,
</p>
<p>&quot;Mean response time&quot;: The mean time that each customer spends in the system (departure time - arrival time),
</p>
<p>&quot;Utilization factor&quot;: The ratio of available time for all servers and time all servers were used. It can be greater than one if a customer arrives near the end of a shift and keeps a server busy,
</p>
<p>&quot;Mean queue length&quot;: Average queue length, and
</p>
<p>&quot;Mean number of customers in system&quot;: Average number of customers in queue or currently being served.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1e3
arrivals &lt;- cumsum(rexp(n, 1.8))
service &lt;- rexp(n)

queue_obj &lt;- queue_step(arrivals, service, servers = 2)
summary(queue_obj)
</code></pre>

<hr>
<h2 id='ql_summary'>Summarise queue lengths</h2><span id='topic+ql_summary'></span>

<h3>Description</h3>

<p>Summarise queue lengths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ql_summary(times, queuelength)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ql_summary_+3A_times">times</code></td>
<td>
<p>numeric vector of times</p>
</td></tr>
<tr><td><code id="ql_summary_+3A_queuelength">queuelength</code></td>
<td>
<p>numeric vector of queue lengths</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1e3
arrivals &lt;- cumsum(rexp(n))
service &lt;- rexp(n)
departures &lt;- queue(arrivals, service, 1)

queuedata &lt;- queue_lengths(arrivals, service, departures)
ql_summary(queuedata$times, queuedata$queuelength)
</code></pre>

<hr>
<h2 id='queue'>Compute the departure times for a set of customers in a queue from their arrival and service times.</h2><span id='topic+queue'></span>

<h3>Description</h3>

<p><code>queue</code> is a faster version of <code>queue_step</code> but the input returned is much simpler. It is not compatible with the <code>summary.queue_list</code> method or the <code>plot.queue_list</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queue(arrivals, service, servers = 1, serveroutput = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queue_+3A_arrivals">arrivals</code></td>
<td>
<p>numeric vector of non-negative arrival times</p>
</td></tr>
<tr><td><code id="queue_+3A_service">service</code></td>
<td>
<p>numeric vector of non-negative service times</p>
</td></tr>
<tr><td><code id="queue_+3A_servers">servers</code></td>
<td>
<p>a non-zero natural number, an object of class <code>server.stepfun</code>
or an object of class <code>server.list</code>.</p>
</td></tr>
<tr><td><code id="queue_+3A_serveroutput">serveroutput</code></td>
<td>
<p>boolean whether the server used by each customer should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the arrival vector is out of order the function will reorder it. The same reordering will be applied to the service vector, this is so each customer keeps their service time. Once the queue is computed the original order is put back.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+queue_step">queue_step</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1e2
arrivals &lt;- cumsum(rexp(n, 1.8))
service &lt;- rexp(n)

departures &lt;- queue(
    arrivals, service, servers = 2)

head(departures)
curve(ecdf(departures)(x) * n,
    from = 0, to = max(departures),
    xlab = "Time", ylab = "Number of customers")
curve(ecdf(arrivals)(x) * n,
    from = 0, to = max(departures),
    col = "red", add = TRUE)

</code></pre>

<hr>
<h2 id='queue_lengths'>Compute queue lengths from arrival, service and departure data</h2><span id='topic+queue_lengths'></span>

<h3>Description</h3>

<p>Compute queue lengths from arrival, service and departure data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queue_lengths(arrivals, service = 0, departures, epsilon = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queue_lengths_+3A_arrivals">arrivals</code></td>
<td>
<p>vector of arrival times</p>
</td></tr>
<tr><td><code id="queue_lengths_+3A_service">service</code></td>
<td>
<p>vector of service times. Leave as zero if you want to compute the number of customers in the system rather than queue length.</p>
</td></tr>
<tr><td><code id="queue_lengths_+3A_departures">departures</code></td>
<td>
<p>vector of departure times</p>
</td></tr>
<tr><td><code id="queue_lengths_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric small number added to departures to prevent negative queue lengths</p>
</td></tr>
<tr><td><code id="queue_lengths_+3A_...">...</code></td>
<td>
<p>additional arguments - does nothing, for compatibility</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(queuecomputer)

set.seed(1L)
n_customers &lt;- 100

queueoutput_df &lt;- data.frame(
  arrivals = runif(n_customers, 0, 300),
  service = rexp(n_customers)
)

queueoutput_df &lt;- queueoutput_df %&gt;% mutate(
  departures = queue(arrivals, service, servers = 2)
)

queue_lengths(
  queueoutput_df$arrivals,
  queueoutput_df$service,
  queueoutput_df$departures
)

# The dplyr way
queueoutput_df %&gt;% do(
  queue_lengths(.$arrivals, .$service, .$departures))

n_customers &lt;- 1000

queueoutput_df &lt;- data.frame(
  arrivals = runif(n_customers, 0, 300),
  service = rexp(n_customers),
  route = sample(c("a", "b"), n_customers, TRUE)
)

server_df &lt;- data.frame(
  route = c("a", "b"),
  servers = c(2, 3)
)

output &lt;- queueoutput_df %&gt;%
  left_join(server_df) %&gt;%
  group_by(route) %&gt;%
  mutate(
    departures = queue(arrivals, service, servers = servers[1])
  ) %&gt;%
  do(queue_lengths(.$arrivals, .$service, .$departures))


if(require(ggplot2, quietly = TRUE)){
    ggplot(output) +
      aes(x = times, y = queuelength) + geom_step() +
      facet_grid(~route)
}
</code></pre>

<hr>
<h2 id='queue_step'>Compute the departure times and queue lengths for a queueing system from arrival and service times.</h2><span id='topic+queue_step'></span>

<h3>Description</h3>

<p>Compute the departure times and queue lengths for a queueing system from arrival and service times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queue_step(arrivals, service, servers = 1, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queue_step_+3A_arrivals">arrivals</code></td>
<td>
<p>numeric vector of non-negative arrival times</p>
</td></tr>
<tr><td><code id="queue_step_+3A_service">service</code></td>
<td>
<p>numeric vector of service times with the same ordering as arrival_df.</p>
</td></tr>
<tr><td><code id="queue_step_+3A_servers">servers</code></td>
<td>
<p>a non-zero natural number, an object of class <code>server.stepfun</code>
or an object of class <code>server.list</code>.</p>
</td></tr>
<tr><td><code id="queue_step_+3A_labels">labels</code></td>
<td>
<p>character vector of customer labels (deprecated).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only departure times are needed, the <code><a href="#topic+queue">queue</a></code> function is faster.
</p>


<h3>Value</h3>

<p>An list object of class <code>queue_list</code> with the following components: <br />
<br />
</p>

<ul>
<li> <p><code>departures</code> - A vector of response times for the input of arrival times and service times.
</p>
</li>
<li> <p><code>server</code> - A vector of server assignments for the input of arrival times and service times.
</p>
</li>
<li> <p><code>departures_df</code> - A data frame with arrivals, service, departures, waiting, system time, and server assignments for each customer.
</p>
</li>
<li> <p><code>queuelength_df</code> - A data frame describing the evolution of queue length over time
</p>
</li>
<li> <p><code>systemlength_df</code> - A data frame describing the evolution of system length over time
</p>
</li>
<li> <p><code>servers_input</code> - A copy of the server argument
</p>
</li>
<li> <p><code>state</code> - A vector of availability times for the servers
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+queue">queue</a></code>, <code><a href="#topic+summary.queue_list">summary.queue_list</a></code>, <code><a href="#topic+plot.queue_list">plot.queue_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# With two servers
set.seed(1)
n &lt;- 100

arrivals &lt;- cumsum(rexp(n, 3))
service &lt;- rexp(n)


queue_obj &lt;- queue_step(arrivals,
    service = service, servers = 2)


summary(queue_obj)
plot(queue_obj, which = 5)

# It seems like the customers have a long wait.
# Let's put two more servers on after time 20


server_list &lt;- as.server.stepfun(c(20),c(2,4))

queue_obj2 &lt;- queue_step(arrivals,
    service = service,
    servers = server_list)

summary(queue_obj2)
if(require(ggplot2, quietly = TRUE)){

    plot(queue_obj2, which = 5)

}


</code></pre>

<hr>
<h2 id='summary.queue_list'>Summary method for queue_list object</h2><span id='topic+summary.queue_list'></span>

<h3>Description</h3>

<p>Summary method for queue_list object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'queue_list'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.queue_list_+3A_object">object</code></td>
<td>
<p>an object of class <code>queue_list</code>, the result of a call to <code>queue_step</code>.</p>
</td></tr>
<tr><td><code id="summary.queue_list_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='wait_step'>Compute maximum time for each row from two vectors of arrival times.</h2><span id='topic+wait_step'></span>

<h3>Description</h3>

<p>Compute maximum time for each row from two vectors of arrival times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wait_step(arrivals, service)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wait_step_+3A_arrivals">arrivals</code></td>
<td>
<p>Either a numeric vector or an object of class <code>queue_list</code>. It represents the arrival times.</p>
</td></tr>
<tr><td><code id="wait_step_+3A_service">service</code></td>
<td>
<p>A vector of times which represent the arrival times of the second type
of customers. The ordering of this vector should have the same ordering as <code>arrivals</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A good real-world example of this is finding the departure times for passengers
after they pick up their bags from the baggage carousel. The time at which they leave is
the maximum of the passenger and bag arrival times.
</p>


<h3>Value</h3>

<p>The maximum time from two vectors of arrival times.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lag_step">lag_step</a></code>, <code><a href="#topic+queue_step">queue_step</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(500)
arrivals &lt;- rlnorm(100, meanlog = 4)
service &lt;- rlnorm(100)

#Airport example ------------------------

# Create a number of bags for each of 100 customers
bags &lt;- rpois(100,1)

# Create a bags dataframe, with each bag associated with one customer.
bags.df &lt;- data.frame(BagID = 1:sum(bags),
   ID = rep(1:100, bags), times = rlnorm(sum(bags), meanlog = 2))

# Create a function which will return the maximum time from each customer's set of bags.

reduce_bags &lt;- function(bagdataset, number_of_passengers){
   ID = NULL
   times = NULL

   zerobags &lt;- data.frame(BagID = NA, ID = c(1:number_of_passengers), times = 0)
   reduced_df &lt;- as.data.frame(dplyr::summarise(dplyr::group_by(
   rbind(bagdataset, zerobags), ID), n = max(times, 0)))
   ord &lt;- order(reduced_df$ID)
   reduced_df &lt;- reduced_df[order(ord),]
   names(reduced_df) &lt;- c("ID", "times")
   return(reduced_df)
}


arrivals2 &lt;- reduce_bags(bags.df, 100)$times

# Find the time when customers can leave with their bags.
wait_step(arrivals = arrivals, service = arrivals2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
