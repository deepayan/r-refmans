<!DOCTYPE html><html><head><title>Help for package colordistance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {colordistance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chisqDistance'><p>Chi-square distance between vectors</p></a></li>
<li><a href='#colorDistance'><p>Sum of Euclidean distances between color clusters</p></a></li>
<li><a href='#combineClusters'><p>Average 3D color histograms by subdirectory</p></a></li>
<li><a href='#combineList'><p>Combine a list of cluster features into a single cluster set</p></a></li>
<li><a href='#convertColorSpace'><p>Convert between color spaces</p></a></li>
<li><a href='#EMDistance'><p>Earth mover's distance between two sets of color clusters</p></a></li>
<li><a href='#exportTree'><p>Export a distance matrix as a tree object</p></a></li>
<li><a href='#extractClusters'><p>Extract cluster values and sizes from kmeans fit objects</p></a></li>
<li><a href='#getColorDistanceMatrix'><p>Distance matrix for a list of color cluster sets</p></a></li>
<li><a href='#getHistColors'><p>Vector of hex colors for histogram bin coloration</p></a></li>
<li><a href='#getHistList'><p>Generate a list of cluster sets for multiple images</p></a></li>
<li><a href='#getImageHist'><p>Generate a 3D histogram based on color distribution in an image</p></a></li>
<li><a href='#getImagePaths'><p>Fetch paths to all valid images in a given directory</p></a></li>
<li><a href='#getKMeanColors'><p>Fit pixels to clusters using KMeans clustering</p></a></li>
<li><a href='#getKMeansList'><p>Get KMeans clusters for every image in a set</p></a></li>
<li><a href='#getLabHist'><p>Generate a 3D histogram based on CIE Lab color coordinates in an image</p></a></li>
<li><a href='#getLabHistList'><p>Generate a list of cluster sets in CIE Lab color space</p></a></li>
<li><a href='#heatmapColorDistance'><p>Plot a heatmap of a distance matrix</p></a></li>
<li><a href='#imageClusterPipeline'><p>Generate and plot a color distance matrix from a set of images</p></a></li>
<li><a href='#loadImage'><p>Import image and generate filtered 2D pixel array(s)</p></a></li>
<li><a href='#normalizeRGB'><p>Normalize pixel RGB ratios</p></a></li>
<li><a href='#orderClusters'><p>Order color clusters to minimize overall color distance between pairs</p></a></li>
<li><a href='#pause'><p>Pause and wait for user input</p></a></li>
<li><a href='#plotClusters'><p>Plot clusters in 3D color space</p></a></li>
<li><a href='#plotClustersMulti'><p>Plot several different cluster sets together</p></a></li>
<li><a href='#plotHist'><p>Color histogram of binned image</p></a></li>
<li><a href='#plotImage'><p>Display an image in a plot window</p></a></li>
<li><a href='#plotPixels'><p>Plot pixels in color space</p></a></li>
<li><a href='#removeBackground'><p>Remove background pixels in image</p></a></li>
<li><a href='#scatter3dclusters'><p>Plot 3D clusters in a 2D plot</p></a></li>
<li><a href='#weightedPairsDistance'><p>Distance between color clusters with user-specified color/size weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Distance Metrics for Image Color Similarity</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-19</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Loads and displays images, selectively masks specified background
    colors, bins pixels by color using either data-dependent or
    automatically generated color bins, quantitatively measures color
    similarity among images using one of several distance metrics for
    comparing pixel color clusters, and clusters images by object color
    similarity. Uses CIELAB, RGB, or HSV color spaces. Originally written
    for use with organism coloration (reef fish color diversity, butterfly
    mimicry, etc), but easily applicable for any image set.</td>
</tr>
<tr>
<td>Imports:</td>
<td>jpeg, png, stats, clue, ape, mgcv, emdist, scatterplot3d,
plotly, gplots, abind, magrittr, scales, qpdf, spatstat.geom</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-19 16:34:14 UTC; hannah</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannah Weller [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hannah Weller &lt;hannahiweller@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-20 20:40:23 UTC</td>
</tr>
</table>
<hr>
<h2 id='chisqDistance'>Chi-square distance between vectors</h2><span id='topic+chisqDistance'></span>

<h3>Description</h3>

<p>Computes the chi-squared distance between each element of a pair of vectors
which must be of the same length. Good for comparing color histograms if you
don't want to weight by color similarity. Probably hugely redundant; alas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisqDistance(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chisqDistance_+3A_a">a</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="chisqDistance_+3A_b">b</code></td>
<td>
<p>Numeric vector; must be the same length as a.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Chi-squared distance, <code class="reqn">(a - b)^2/(a + b)</code>, between vectors a and
b. If one or both elements are NA/NaN, contribution is counted as a 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colordistance:::chisqDistance(rnorm(10), rnorm(10))
</code></pre>

<hr>
<h2 id='colorDistance'>Sum of Euclidean distances between color clusters</h2><span id='topic+colorDistance'></span>

<h3>Description</h3>

<p>Calculates the Euclidean distance between each pair of points in two
dataframes as returned by extractClusters or getImageHist and returns the sum
of the distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorDistance(T1, T2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorDistance_+3A_t1">T1</code></td>
<td>
<p>Dataframe (especially a dataframe as returned by
<code>extractClusters()</code> or <code>getImageHist()</code>, but first three columns
must be coordinates).</p>
</td></tr>
<tr><td><code id="colorDistance_+3A_t2">T2</code></td>
<td>
<p>Another dataframe like T1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of Euclidean distances between each pair of points (rows) in the
provided dataframes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: cluster.list &lt;- colordistance::getHistList(system.file("extdata",
"Heliconius/Heliconius_B", package="colordistance"), lower=rep(0.8, 3),
upper=rep(1, 3))
colordistance:::colorDistance(cluster.list[[1]], cluster.list[[2]])
## End(Not run)
</code></pre>

<hr>
<h2 id='combineClusters'>Average 3D color histograms by subdirectory</h2><span id='topic+combineClusters'></span>

<h3>Description</h3>

<p>Calculates color histograms for images in immediate subdirectories of a
folder, and averages histograms for images in the same subdirectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineClusters(folder, method = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineClusters_+3A_folder">folder</code></td>
<td>
<p>Path to the folder containing subdirectories of images. Must be
a character vector.</p>
</td></tr>
<tr><td><code id="combineClusters_+3A_method">method</code></td>
<td>
<p>Method for combining color histograms. Default is
<code>"mean"</code>, but other generic functions (<code>"median"</code>, <code>"sum"</code>,
etc) will work. String is evaluated using <code>"eval"</code> so any appropriate
R function is accepted.</p>
</td></tr>
<tr><td><code id="combineClusters_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+getHistList">getHistList</a></code>,
including number of bins, HSV flag, etc.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>combined_clusters &lt;- colordistance::combineClusters(system.file("extdata",
"Heliconius", package="colordistance"), method="median", bins=2,
lower=rep(0.8, 3), upper=rep(1, 3))
</code></pre>

<hr>
<h2 id='combineList'>Combine a list of cluster features into a single cluster set</h2><span id='topic+combineList'></span>

<h3>Description</h3>

<p>Combine a list of cluster features as returned by <code><a href="#topic+getHistList">getHistList</a></code>
according to the specified method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineList(hist_list, method = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineList_+3A_hist_list">hist_list</code></td>
<td>
<p>A list of cluster dataframes as returned by
<code><a href="#topic+getHistList">getHistList</a></code>.</p>
</td></tr>
<tr><td><code id="combineList_+3A_method">method</code></td>
<td>
<p>Method for combining color histograms. Default is
<code>"mean"</code>, but other generic functions (<code>"median"</code>, <code>"sum"</code>,
etc) will work. String is evaluated using <code>"eval"</code> so any appropriate
R function is accepted.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>While the function can also accept clusters generated using kmeans
(<code><a href="#topic+getKMeansList">getKMeansList</a></code> followed by <code><a href="#topic+extractClusters">extractClusters</a></code>),
this is not recommended, as kmeans does not provide explicit analogous
pairs of clusters, and clusters are combined by row number (all row 1
clusters are treated as analogous, etc). Color histograms are appropriate
because the bins are defined the same way for each image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hist_list &lt;- getHistList(system.file("extdata", "Heliconius/Heliconius_A",
package="colordistance"), lower=rep(0.8, 3), upper=rep(1, 3))
median_clusters &lt;- combineList(hist_list, method="median")

</code></pre>

<hr>
<h2 id='convertColorSpace'>Convert between color spaces</h2><span id='topic+convertColorSpace'></span>

<h3>Description</h3>

<p>Wrapper for <code><a href="grDevices.html#topic+convertColor">convertColor</a></code> that builds in random
sampling, error messages, and removes default illuminant (D65) to enforce
manual specification of a reference white.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertColorSpace(
  color.coordinate.matrix,
  from = "sRGB",
  to = "Lab",
  sample.size = 1e+05,
  from.ref.white,
  to.ref.white
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertColorSpace_+3A_color.coordinate.matrix">color.coordinate.matrix</code></td>
<td>
<p>A color coordinate matrix with rows as colors
and channels as columns. If a color histogram (e.g. as returned by
<code><a href="#topic+getImageHist">getImageHist</a></code>) is passed, the 'Pct' column is ignored.</p>
</td></tr>
<tr><td><code id="convertColorSpace_+3A_from">from</code>, <code id="convertColorSpace_+3A_to">to</code></td>
<td>
<p>Input and output color spaces, passed to
<code><a href="grDevices.html#topic+convertColor">convertColor</a></code>. See details.</p>
</td></tr>
<tr><td><code id="convertColorSpace_+3A_sample.size">sample.size</code></td>
<td>
<p>Number of pixels to be randomly sampled from filtered pixel
array for conversion. If not numeric or larger than number of colors
provided (i.e. cluster matrix), all colors are converted. See details.</p>
</td></tr>
<tr><td><code id="convertColorSpace_+3A_from.ref.white">from.ref.white</code>, <code id="convertColorSpace_+3A_to.ref.white">to.ref.white</code></td>
<td>
<p>Reference whites passed to
<code><a href="grDevices.html#topic+convertColor">convertColor</a></code>. Unlike <code>convertColor</code>, no
default is provided. See details for explanation of different reference
whites.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Color spaces are all passed to
<code><a href="grDevices.html#topic+convertColor">convertColor</a></code>, and can be any of: <code>"XYZ"</code>,
<code>"sRGB"</code>, <code>"Apple RGB"</code>, <code>"CIE RGB"</code>, <code>"Lab"</code>, or
<code>"Luv"</code>.
</p>
<p><code>Lab</code> and <code>Luv</code> color spaces are approximately perceptually
uniform, meaning they usually do the best job of reflecting intuitive color
distances without the non-linearity problems of more familiar RGB spaces.
However, because they describe object colors, they require a reference
'white light' color (dimly and brightly lit photographs of the same object
will have very different RGB palettes, but similar Lab palettes if
appropriate white references are used). The idea here is that the apparent
colors in an image depend not just on the &quot;absolute&quot; color of an object,
but also on the available light in the scene. There are seven CIE
standardized illuminants available in <code>colordistance</code> (A, B, C, E, and
D50, D55, and D65), but the most common are: </p>
 <ul>
<li> <p><code>"A"</code>:
Standard incandescent lightbulb </p>
</li>
<li> <p><code>"D65"</code>: Average daylight </p>
</li>
<li>
<p><code>"D50"</code>: Direct sunlight</p>
</li></ul>

<p>Color conversions will be highly dependent on the reference white used, which
is why no default is provided. Users should look into
<a href="https://en.wikipedia.org/wiki/Standard_illuminant">standard
illuminants</a> to choose an appropriate reference for a dataset.
</p>
<p>The conversion from RGB to a standardized color space (XYZ, Lab, or Luv) is
approximate, non-linear, and relatively time-consuming. Converting a large
number of pixels can be computationally expensive, so
<code>convertColorSpace</code> will randomly sample a specified number of rows to
reduce the time. The default sample size, 100,000 rows, takes about 5 seconds
convert from sRGB to Lab space on an early 2015 Macbook with 8 GB of RAM.
Time scales about linearly with number of rows converted.
</p>


<h3>Value</h3>

<p>A 3- or 4-column matrix depending on whether
<code>color.coordinate.matrix</code> included a 'Pct' column (as from
<code><a href="#topic+getImageHist">getImageHist</a></code>), with one column per channel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a single RGB triplet and then back convert it
rgb_color &lt;- c(0, 1, 0)
lab_color &lt;- colordistance::convertColorSpace(rgb_color,
 from="sRGB", to="Lab", to.ref.white="D65")
rgb_again &lt;- colordistance::convertColorSpace(lab_color,
 from="Lab", to="sRGB", from.ref.white="D65")

# Convert pixels from loadImage() function
img &lt;- colordistance::loadImage(system.file("extdata",
"Heliconius/Heliconius_B/Heliconius_07.jpeg", package="colordistance"))
lab_pixels &lt;- colordistance::convertColorSpace(img$filtered.rgb.2d,
from="sRGB", to="XYZ", sample.size=5000)

# Convert clusters
img &lt;- colordistance::loadImage(system.file("extdata",
"Heliconius/Heliconius_B/Heliconius_07.jpeg", package="colordistance"))
img_hist &lt;- colordistance::getImageHist(img, bins=2, plotting=FALSE)
lab_clusters &lt;- colordistance::convertColorSpace(img_hist, to.ref.white="D55")

</code></pre>

<hr>
<h2 id='EMDistance'>Earth mover's distance between two sets of color clusters</h2><span id='topic+EMDistance'></span>

<h3>Description</h3>

<p>Calculates the
<a href="https://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/RUBNER/emd.htm">Earth
mover's distance</a> (briefly, the amount of work required to move the data from
one distribution to resemble the other distribution, or the amount of &quot;dirt&quot;
you have to shovel weighted by how far you have to shovel it). Accounts for
both color disparity and size disparity. Recommended unless <code>binAvg</code> is
off for histogram generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMDistance(T1, T2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EMDistance_+3A_t1">T1</code></td>
<td>
<p>Dataframe (especially a dataframe as returned by
<code>link{extractClusters}</code> or <code><a href="#topic+getImageHist">getImageHist</a></code>, but first three
columns must be coordinates).</p>
</td></tr>
<tr><td><code id="EMDistance_+3A_t2">T2</code></td>
<td>
<p>Another dataframe like T1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Earth mover's distance between the two dataframes (metric of overall
bin similarity for a pair of 3-dimensional histograms).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cluster.list &lt;- colordistance::getHistList(system.file("extdata",
"Heliconius/Heliconius_B", package="colordistance"), lower=rep(0.8, 3),
upper=rep(1, 3))
colordistance:::EMDistance(cluster.list[[1]], cluster.list[[2]])

## End(Not run)
</code></pre>

<hr>
<h2 id='exportTree'>Export a distance matrix as a tree object</h2><span id='topic+exportTree'></span>

<h3>Description</h3>

<p>Converts a symmetrical distance matrix to a tree and saves it in newick
format. Uses <code><a href="stats.html#topic+hclust">hclust</a></code> to form clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportTree(getColorDistanceMatrixObject, file, return.tree = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportTree_+3A_getcolordistancematrixobject">getColorDistanceMatrixObject</code></td>
<td>
<p>A distance matrix, especially as returned
by <code><a href="#topic+getColorDistanceMatrix">getColorDistanceMatrix</a></code>, but any numeric symmetrical matrix
will work.</p>
</td></tr>
<tr><td><code id="exportTree_+3A_file">file</code></td>
<td>
<p>Character vector of desired filename for saving tree. Should end
in &quot;.newick&quot;.</p>
</td></tr>
<tr><td><code id="exportTree_+3A_return.tree">return.tree</code></td>
<td>
<p>Logical. Should the tree object be returned to the working
environment in addition to being saved as a file?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Newick tree saved in specified location and <code>as.phylo</code> tree
object if <code>return.tree=TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
clusterList &lt;- colordistance::getHistList(dir(system.file("extdata",
"Heliconius/", package="colordistance"), full.names=TRUE), lower=rep(0.8, 3),
upper=rep(1, 3))
CDM &lt;- colordistance::getColorDistanceMatrix(clusterList, method="emd",
plotting=FALSE)

# Tree is both saved in current working directory and stored in
# heliconius_tree variable

heliconius_tree &lt;- colordistance::exportTree(CDM,
"./HeliconiusColorTree.newick", return.tree=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='extractClusters'>Extract cluster values and sizes from kmeans fit objects</h2><span id='topic+extractClusters'></span>

<h3>Description</h3>

<p>Extract a list of dataframes with the same format as those returned by
<code><a href="#topic+getHistList">getHistList</a></code>, where each dataframe has 3 color attributes (R, G,
B or H, S, V) and a size attribute (Pct) for every cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractClusters(getKMeansListObject, ordering = TRUE, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractClusters_+3A_getkmeanslistobject">getKMeansListObject</code></td>
<td>
<p>A list of <code><a href="stats.html#topic+kmeans">kmeans</a></code> fit objects
(especially as returned by getKMeansList).</p>
</td></tr>
<tr><td><code id="extractClusters_+3A_ordering">ordering</code></td>
<td>
<p>Logical. Should clusters by reordered by color similarity? If
<code>TRUE</code>, the Hungarian algorithm via <code><a href="clue.html#topic+solve_LSAP">solve_LSAP</a></code> is
applied to find the minimum sum of Euclidean distances between color pairs
for every pair of cluster objects and colors are reordered accordingly.</p>
</td></tr>
<tr><td><code id="extractClusters_+3A_normalize">normalize</code></td>
<td>
<p>Logical. Should each cluster be normalized to show R:G:B or
H:S:V ratios rather than absolute values? Can be helpful for inconsistent
lighting, but reduces variation. See <code><a href="#topic+normalizeRGB">normalizeRGB</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dataframes (same length as input list), each with 4
columns: R, G, B (or H, S, V) and Pct (cluster size), with one row per
cluster.
</p>


<h3>Note</h3>

<p>Names are inherited from the list passed to the function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clusterList &lt;- colordistance::getKMeansList(system.file("extdata",
"Heliconius/Heliconius_A", package="colordistance"), bins=3)

colordistance::extractClusters(clusterList)
</code></pre>

<hr>
<h2 id='getColorDistanceMatrix'>Distance matrix for a list of color cluster sets</h2><span id='topic+getColorDistanceMatrix'></span>

<h3>Description</h3>

<p>Calculates a distance matrix for a list of color cluster sets as returned by
<code><a href="#topic+extractClusters">extractClusters</a></code> or <code><a href="#topic+getHistList">getHistList</a></code> based on the
specified distance metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColorDistanceMatrix(
  cluster.list,
  method = "emd",
  ordering = "default",
  size.weight = 0.5,
  color.weight = 0.5,
  plotting = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColorDistanceMatrix_+3A_cluster.list">cluster.list</code></td>
<td>
<p>A list of identically sized dataframes with 4 columns each
(R, G, B, Pct or H, S, V, Pct) as output by <code>extractClusters</code> or
<code>getHistList</code>.</p>
</td></tr>
<tr><td><code id="getColorDistanceMatrix_+3A_method">method</code></td>
<td>
<p>One of four possible comparison methods for calculating the
color distances: <code>"emd"</code> (uses <code><a href="#topic+EMDistance">EMDistance</a></code>, recommended),
<code>"chisq"</code> (uses <code><a href="#topic+chisqDistance">chisqDistance</a></code>), <code>"color.dist"</code>
(uses <code><a href="#topic+colorDistance">colorDistance</a></code>; not appropriate if binAvg=F), or
<code>"weighted.pairs"</code> (<code><a href="#topic+weightedPairsDistance">weightedPairsDistance</a></code>).</p>
</td></tr>
<tr><td><code id="getColorDistanceMatrix_+3A_ordering">ordering</code></td>
<td>
<p>Logical if not left as &quot;default&quot;. Should the color clusters
in the list be reordered to minimize the distances between the pairs? If
left as default, ordering depends on distance method: &quot;emd&quot; and &quot;chisq&quot; do
not order clusters (&quot;emd&quot; orders on a case-by-case in the
<code><a href="#topic+EMDistance">EMDistance</a></code> function itself and reordering by size similarity
would make chi-squared meaningless); &quot;color.dist&quot; and &quot;weighted.pairs&quot; use
ordering. To override defaults, set to either <code>T</code> (for ordering) or
<code>F</code> (for no ordering).</p>
</td></tr>
<tr><td><code id="getColorDistanceMatrix_+3A_size.weight">size.weight</code></td>
<td>
<p>Same as in <code><a href="#topic+weightedPairsDistance">weightedPairsDistance</a></code>.</p>
</td></tr>
<tr><td><code id="getColorDistanceMatrix_+3A_color.weight">color.weight</code></td>
<td>
<p>Same as in <code><a href="#topic+weightedPairsDistance">weightedPairsDistance</a></code>.</p>
</td></tr>
<tr><td><code id="getColorDistanceMatrix_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Should a heatmap of the distance matrix be displayed
once the function finishes running?</p>
</td></tr>
<tr><td><code id="getColorDistanceMatrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to
<code><a href="#topic+heatmapColorDistance">heatmapColorDistance</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each cell represents the distance between a pair of color cluster
sets as measured using either chi-squared distance (cluster size only), earth
mover's distance (size and color), weighted pairs (size and color with
user-specified weights for each), or color distance (Euclidean distance
between clusters as 3-dimensional - RGB or HSV - color coordinates).
</p>
<p>Earth mover's distance is recommended unless <code>binAvg</code> is set to false
during cluster list generation (in which case all paired bins will have the
same colors across datasets), in which case chi-squared is recommended.
Weighted pairs or color distance may be appropriate depending on the
question, but generally give poorer results.
</p>


<h3>Value</h3>

<p>A distance matrix of image distance scores (the scales vary depending
on the distance metric chosen, but for all four methods, higher scores =
more different).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cluster.list &lt;- colordistance::getHistList(c(system.file("extdata",
"Heliconius/Heliconius_A", package="colordistance"), system.file("extdata",
"Heliconius/Heliconius_B", package="colordistance")), lower=rep(0.8, 3),
upper=rep(1, 3))

# Default values - recommended!
colordistance::getColorDistanceMatrix(cluster.list, main="EMD")

# Without plotting
colordistance::getColorDistanceMatrix(cluster.list, plotting=FALSE)

# Use chi-squared instead
colordistance::getColorDistanceMatrix(cluster.list, method="chisq", main="Chi-squared")

# Override ordering (throws a warning if you're trying to do this with
# chisq!)
colordistance::getColorDistanceMatrix(cluster.list, method="chisq",
ordering=TRUE, main="Chi-squared w/ ordering")

# Specify high size weight/low color weight for weighted pairs
colordistance::getColorDistanceMatrix(cluster.list, method="weighted.pairs",
color.weight=0.1, size.weight=0.9, main="Weighted pairs")

# Color distance only
colordistance::getColorDistanceMatrix(cluster.list, method="color.dist",
ordering=TRUE, main="Color distance only")

## End(Not run)
</code></pre>

<hr>
<h2 id='getHistColors'>Vector of hex colors for histogram bin coloration</h2><span id='topic+getHistColors'></span>

<h3>Description</h3>

<p>Gets a vector of colors for plotting histograms from
<code><a href="#topic+getImageHist">getImageHist</a></code> in helpful ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHistColors(bins, hsv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHistColors_+3A_bins">bins</code></td>
<td>
<p>Number of bins for each channel OR a vector of length 3 with bins
for each channel. Bins = 3 will result in 3^3 = 27 bins; bins = c(2, 2, 3) will
result in 2 * 2 * 3 = 12 bins (2 red, 2 green, 3 blue), etc.</p>
</td></tr>
<tr><td><code id="getHistColors_+3A_hsv">hsv</code></td>
<td>
<p>Logical. Should HSV be used instead of RGB?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of hex codes for bin colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colordistance:::getHistColors(bins = 3)
colordistance:::getHistColors(bins = c(8, 3, 3), hsv = TRUE)
</code></pre>

<hr>
<h2 id='getHistList'>Generate a list of cluster sets for multiple images</h2><span id='topic+getHistList'></span>

<h3>Description</h3>

<p>Applies <code><a href="#topic+getImageHist">getImageHist</a></code> to every image in a provided set of image
paths and/or directories containing images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHistList(
  images,
  bins = 3,
  bin.avg = TRUE,
  lower = c(0, 0.55, 0),
  upper = c(0.24, 1, 0.24),
  alpha.channel = TRUE,
  norm.pix = FALSE,
  plotting = FALSE,
  pausing = TRUE,
  hsv = FALSE,
  title = "path",
  img.type = FALSE,
  bounds = c(0, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHistList_+3A_images">images</code></td>
<td>
<p>Character vector of directories, image paths, or both.</p>
</td></tr>
<tr><td><code id="getHistList_+3A_bins">bins</code></td>
<td>
<p>Number of bins for each channel OR a vector of length 3 with bins
for each channel. Bins=3 will result in 3^3 = 27 bins; bins=c(2, 2, 3) will
result in 2*2*3=12 bins (2 red, 2 green, 3 blue), etc.</p>
</td></tr>
<tr><td><code id="getHistList_+3A_bin.avg">bin.avg</code></td>
<td>
<p>Logical. Should the returned color clusters be the average of
the pixels in that bin (bin.avg=<code>TRUE</code>) or the center of the bin
(FALSE)? If a bin is empty, the center of the bin is returned as the
cluster color regardless.</p>
</td></tr>
<tr><td><code id="getHistList_+3A_lower">lower</code></td>
<td>
<p>RGB or HSV triplet specifying the lower bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]).</p>
</td></tr>
<tr><td><code id="getHistList_+3A_upper">upper</code></td>
<td>
<p>RGB or HSV triplet specifying the upper bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]). Determining these bounds may
take some trial and error, but the following bounds may work for certain
common background colors: </p>
 <ul>
<li><p> Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) </p>
</li>
<li><p> White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1,
1) </p>
</li>
<li><p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) </p>
</li>
<li><p> Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li></ul>
<p> If no background filtering is
needed, set bounds to some non-numeric value (<code>NULL</code>, <code>FALSE</code>,
<code>"off"</code>, etc); any non-numeric value is interpreted as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getHistList_+3A_alpha.channel">alpha.channel</code></td>
<td>
<p>Logical. If available, should alpha channel transparency be
used to mask background? See <code><a href="#topic+removeBackground">removeBackground</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="getHistList_+3A_norm.pix">norm.pix</code></td>
<td>
<p>Logical. Should RGB or HSV cluster values be normalized using
<code><a href="#topic+normalizeRGB">normalizeRGB</a></code>?</p>
</td></tr>
<tr><td><code id="getHistList_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Should the histogram generated for each image be
displayed?</p>
</td></tr>
<tr><td><code id="getHistList_+3A_pausing">pausing</code></td>
<td>
<p>Logical. If <code>plotting=T</code>, should the function pause
between graphing and wait for user to hit <code>[enter]</code> before continuing?
Useful for data/histogram inspection.</p>
</td></tr>
<tr><td><code id="getHistList_+3A_hsv">hsv</code></td>
<td>
<p>Logical. Should HSV be used instead of RGB?</p>
</td></tr>
<tr><td><code id="getHistList_+3A_title">title</code></td>
<td>
<p>String for what the title the plots if plotting is on; defaults
to the image name.</p>
</td></tr>
<tr><td><code id="getHistList_+3A_img.type">img.type</code></td>
<td>
<p>Logical. Should the file extension for the images be retained
when naming the output list elements? If <code>FALSE</code>, just the image name
is used (so &quot;Heliconius_01.png&quot; becomes &quot;Heliconius_01&quot;).</p>
</td></tr>
<tr><td><code id="getHistList_+3A_bounds">bounds</code></td>
<td>
<p>Upper and lower limits for the channels; R reads in images with
intensities on a 0-1 scale, but 0-255 is common.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="#topic+getImageHist">getImageHist</a></code> dataframes, 1 per image, named
by image name.
</p>


<h3>Note</h3>

<p>For every image, the pixels are binned according to the specified bin
breaks. By providing the bounds for the bins rather than letting an algorithm
select centers (as in <code><a href="#topic+getKMeansList">getKMeansList</a></code>), clusters of nearly
redundant colors are avoided.
</p>
<p>So you don't end up with, say, 3 nearly-identical yellow clusters which are
treated as unrelated just because there's a lot of yellow in your image; you
just get a very large yellow cluster and empty non-yellow bins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Takes &gt;10 seconds if you run all examples
clusterList &lt;- colordistance::getHistList(system.file("extdata",
"Heliconius/Heliconius_B", package="colordistance"), upper = rep(1, 3),
lower = rep(0.8, 3))

clusterList &lt;- colordistance::getHistList(c(system.file("extdata",
"Heliconius/Heliconius_B", package="colordistance"), system.file("extdata",
"Heliconius/Heliconius_A", package="colordistance")), pausing = FALSE,
upper = rep(1, 3), lower = rep(0.8, 3))

clusterList &lt;- colordistance::getHistList(system.file("extdata",
"Heliconius/Heliconius_B", package = "colordistance"), plotting = TRUE,
upper = rep(1, 3), lower = rep(0.8, 3))

## End(Not run)

</code></pre>

<hr>
<h2 id='getImageHist'>Generate a 3D histogram based on color distribution in an image</h2><span id='topic+getImageHist'></span>

<h3>Description</h3>

<p>Computes a histogram in either RGB or HSV colorspace by sorting pixels into a
specified number of bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getImageHist(
  image,
  bins = 3,
  bin.avg = TRUE,
  defaultClusters = NULL,
  lower = c(0, 0.55, 0),
  upper = c(0.24, 1, 0.24),
  as.vec = FALSE,
  alpha.channel = TRUE,
  norm.pix = FALSE,
  plotting = TRUE,
  hsv = FALSE,
  title = "path",
  bounds = c(0, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getImageHist_+3A_image">image</code></td>
<td>
<p>Path to a valid image (PNG or JPG) or a <code><a href="#topic+loadImage">loadImage</a></code>
object.</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_bins">bins</code></td>
<td>
<p>Number of bins for each channel OR a vector of length 3 with bins
for each channel. Bins=3 will result in 3^3 = 27 bins; bins=c(2, 2, 3) will
result in 2*2*3=12 bins (2 red, 2 green, 3 blue), etc.</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_bin.avg">bin.avg</code></td>
<td>
<p>Logical. Should the returned color clusters be the average of
the pixels in that bin (bin.avg=<code>TRUE</code>) or the center of the bin
(<code>FALSE</code>)? If a bin is empty, the center of the bin is returned as the
cluster color regardless.</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_defaultclusters">defaultClusters</code></td>
<td>
<p>Optional dataframe of default color clusters to be
returned when a bin is empty. If <code>NULL</code>, the geometric centers of the
bins are used.</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_lower">lower</code></td>
<td>
<p>RGB or HSV triplet specifying the lower bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]).</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_upper">upper</code></td>
<td>
<p>RGB or HSV triplet specifying the upper bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]). Determining these bounds may
take some trial and error, but the following bounds may work for certain
common background colors: </p>
 <ul>
<li><p> Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) </p>
</li>
<li><p> White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1,
1) </p>
</li>
<li><p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) </p>
</li>
<li><p> Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li></ul>
<p> If no background filtering is
needed, set bounds to some non-numeric value (<code>NULL</code>, <code>FALSE</code>,
<code>"off"</code>, etc); any non-numeric value is interpreted as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_as.vec">as.vec</code></td>
<td>
<p>Logical. Should the bin sizes just be returned as a vector?
Much faster if only using <code><a href="#topic+chisqDistance">chisqDistance</a></code> for comparison metric.</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_alpha.channel">alpha.channel</code></td>
<td>
<p>Logical. If available, should alpha channel transparency be
used to mask background? See <code><a href="#topic+removeBackground">removeBackground</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_norm.pix">norm.pix</code></td>
<td>
<p>Logical. Should RGB or HSV cluster values be normalized using
<code><a href="#topic+normalizeRGB">normalizeRGB</a></code>?</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Should a histogram of the bin colors and sizes be
plotted?</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_hsv">hsv</code></td>
<td>
<p>Logical. Should HSV be used instead of RGB?</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_title">title</code></td>
<td>
<p>String for what to title the plots if plotting is on; defaults
to the image name.</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_bounds">bounds</code></td>
<td>
<p>Upper and lower limits for the channels; R reads in images with
intensities on a 0-1 scale, but 0-255 is common.</p>
</td></tr>
<tr><td><code id="getImageHist_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to the <code><a href="graphics.html#topic+barplot">barplot</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you choose 2 bins for each color channel, then each of R, G, and
B will be divided into 2 bins each, for a total of 2^3 = 8 bins.
</p>
<p>Once all pixels have been binned, the function will return either the size of
each bin, either in number of pixels or fraction of total pixels, and the
color of each bin, either as the geometric center of the bin or as the
average color of all pixels assigned to it.
</p>
<p>For example, if you input an image of a red square and used 8 bins, all red
pixels (RGB triplet of [1, 0, 0]) would be assigned to the bin with R bounds
(0.5, 1], G bounds [0, 0.5) and B bounds [0, 0.5). The average color of the
bin would be [0.75, 0.25, 0.25], but the average color of the pixels assigned
to that bin would be [1, 0, 0]. The latter option is obviously more
informative, but takes longer (about 1.5-2x longer depending on the images).
</p>


<h3>Value</h3>

<p>A vector or dataframe (depending on whether <code>as.vec=T</code>) of bin
sizes and color values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate HSV histogram for a single image
colordistance::getImageHist(system.file("extdata",
"Heliconius/Heliconius_B/Heliconius_07.jpeg", package="colordistance"),
upper=rep(1, 3), lower=rep(0.8, 3), bins=c(8, 3, 3), hsv=TRUE, plotting=TRUE)

# generate RGB histogram
colordistance::getImageHist(system.file("extdata",
"Heliconius/Heliconius_B/Heliconius_07.jpeg", package="colordistance"),
upper=rep(1, 3), lower=rep(0.8, 3), bins=2)
</code></pre>

<hr>
<h2 id='getImagePaths'>Fetch paths to all valid images in a given directory</h2><span id='topic+getImagePaths'></span>

<h3>Description</h3>

<p>Find all valid image paths (PNG and JPG) in a directory (does not search
subdirectories). Will recover any image ending in .PNG, .JPG, or .JPEG,
case-insensitive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getImagePaths(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getImagePaths_+3A_path">path</code></td>
<td>
<p>Path to directory in which to search for images. Absolute or
relative filepaths are fine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of absolute filepaths to JPG and PNG images in the given
directory.
</p>


<h3>Note</h3>

<p>In the event that no compatible images are found in the directory, it
returns a message to that effect instead of an empty vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>im.dir &lt;- colordistance::getImagePaths(system.file("extdata",
"Heliconius/Heliconius_A", package="colordistance"))
## Not run: 
im.dir &lt;- colordistance::getImagePaths("some/nonexistent/directory")

## End(Not run)
im.dir &lt;- colordistance::getImagePaths(getwd())

</code></pre>

<hr>
<h2 id='getKMeanColors'>Fit pixels to clusters using KMeans clustering</h2><span id='topic+getKMeanColors'></span>

<h3>Description</h3>

<p>Uses <a href="https://en.wikipedia.org/wiki/K-means_clustering">KMeans
clustering</a> to determine color clusters that minimize the sum of distances
between pixels and their assigned clusters. Useful for parsing common color
motifs in an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKMeanColors(
  path,
  n = 10,
  sample.size = 20000,
  plotting = TRUE,
  lower = c(0, 0.55, 0),
  upper = c(0.24, 1, 0.24),
  iter.max = 50,
  nstart = 5,
  return.clust = TRUE,
  color.space = "rgb",
  from = "sRGB",
  ref.white
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getKMeanColors_+3A_path">path</code></td>
<td>
<p>Path to an image (JPG or PNG).</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_n">n</code></td>
<td>
<p>Number of KMeans clusters to fit. Unlike <code><a href="#topic+getImageHist">getImageHist</a></code>,
this represents the actual final number of bins, rather than the number of
breaks in each channel.</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_sample.size">sample.size</code></td>
<td>
<p>Number of pixels to be randomly sampled from filtered pixel
array for performing fit. If set to <code>FALSE</code>, all pixels are fit, but
this can be time-consuming, especially for large images.</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Should the results of the KMeans fit (original image
+ histogram of colors and bin sizes) be plotted?</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_lower">lower</code></td>
<td>
<p>RGB triplet specifying the lower bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]).</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_upper">upper</code></td>
<td>
<p>RGB triplet specifying the upper bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]). Determining these bounds may
take some trial and error, but the following bounds may work for certain
common background colors: </p>
 <ul>
<li><p> Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) </p>
</li>
<li><p> White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1,
1) </p>
</li>
<li><p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) </p>
</li>
<li><p> Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li></ul>
<p> If no background filtering is
needed, set bounds to some non-numeric value (<code>NULL</code>, <code>FALSE</code>,
<code>"off"</code>, etc); any non-numeric value is interpreted as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_iter.max">iter.max</code></td>
<td>
<p>Inherited from <code><a href="stats.html#topic+kmeans">kmeans</a></code>. The maximum
number of iterations allowed.</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_nstart">nstart</code></td>
<td>
<p>Inherited from <code><a href="stats.html#topic+kmeans">kmeans</a></code>. How many random
sets should be chosen?</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_return.clust">return.clust</code></td>
<td>
<p>Logical. Should clusters be returned? If <code>FALSE</code>,
results are plotted but not returned.</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_color.space">color.space</code></td>
<td>
<p>The color space (<code>"rgb"</code>, <code>"hsv"</code>, or
<code>"lab"</code>) in which to cluster pixels.</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_from">from</code></td>
<td>
<p>Display color space of image if clustering in CIE Lab space,
probably either &quot;sRGB&quot; or &quot;Apple RGB&quot;, depending on your computer.</p>
</td></tr>
<tr><td><code id="getKMeanColors_+3A_ref.white">ref.white</code></td>
<td>
<p>The reference white passed to
<code><a href="#topic+convertColorSpace">convertColorSpace</a></code>; must be specified if using CIE
Lab space. See <a href="#topic+convertColorSpace">convertColorSpace</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+kmeans">kmeans</a></code> fit object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colordistance::getKMeanColors(system.file("extdata",
"Heliconius/Heliconius_B/Heliconius_07.jpeg", package="colordistance"), n=3,
return.clust=FALSE, lower=rep(0.8, 3), upper=rep(1, 3))
</code></pre>

<hr>
<h2 id='getKMeansList'>Get KMeans clusters for every image in a set</h2><span id='topic+getKMeansList'></span>

<h3>Description</h3>

<p>Performs <code><a href="#topic+getKMeanColors">getKMeanColors</a></code> on every image in a set of images and
returns a list of kmeans fit objects, where each dataframe contains the RGB
coordinates of the clusters and the percentage of pixels in the image
assigned to that cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKMeansList(
  images,
  bins = 10,
  sample.size = 20000,
  plotting = FALSE,
  lower = c(0, 0.55, 0),
  upper = c(0.24, 1, 0.24),
  iter.max = 50,
  nstart = 5,
  img.type = FALSE,
  color.space = "rgb",
  from = "sRGB",
  ref.white
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getKMeansList_+3A_images">images</code></td>
<td>
<p>A character vector of directories, image paths, or a
combination of both. Takes either absolute or relative filepaths.</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_bins">bins</code></td>
<td>
<p>Number of KMeans clusters to fit. Unlike <code><a href="#topic+getImageHist">getImageHist</a></code>,
this represents the actual final number of bins, rather than the number of
breaks in each channel.</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_sample.size">sample.size</code></td>
<td>
<p>Number of pixels to be randomly sampled from filtered pixel
array for performing fit. If set to <code>FALSE</code>, all pixels are fit, but
this can be time-consuming, especially for large images.</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Should the results of the KMeans fit (original image
+ histogram of colors and bin sizes) be plotted for each image?</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_lower">lower</code></td>
<td>
<p>RGB triplet specifying the lower bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]).</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_upper">upper</code></td>
<td>
<p>RGB triplet specifying the upper bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]). Determining these bounds may
take some trial and error, but the following bounds may work for certain
common background colors: </p>
 <ul>
<li><p> Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) </p>
</li>
<li><p> White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1,
1) </p>
</li>
<li><p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) </p>
</li>
<li><p> Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li></ul>
<p> If no background filtering is
needed, set bounds to some non-numeric value (<code>NULL</code>, <code>FALSE</code>,
<code>"off"</code>, etc); any non-numeric value is interpreted as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_iter.max">iter.max</code></td>
<td>
<p>Inherited from <code><a href="stats.html#topic+kmeans">kmeans</a></code>. The maximum
number of iterations allowed.</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_nstart">nstart</code></td>
<td>
<p>Inherited from <code><a href="stats.html#topic+kmeans">kmeans</a></code>. How many random
sets should be chosen?</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_img.type">img.type</code></td>
<td>
<p>Logical. Should the image extension (.PNG or .JPG) be retained
in the list names?</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_color.space">color.space</code></td>
<td>
<p>The color space (<code>"rgb"</code>, <code>"hsv"</code>, or
<code>"lab"</code>) in which to cluster pixels.</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_from">from</code></td>
<td>
<p>Original color space of images if clustering in CIE Lab space,
probably either &quot;sRGB&quot; or &quot;Apple RGB&quot;, depending on your computer.</p>
</td></tr>
<tr><td><code id="getKMeansList_+3A_ref.white">ref.white</code></td>
<td>
<p>The reference white passed to
<code><a href="#topic+convertColorSpace">convertColorSpace</a></code>; must be specified if using CIE
Lab space. See <a href="#topic+convertColorSpace">convertColorSpace</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of kmeans fit objects, where the list element names are the
original image names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Takes a few seconds to run
kmeans_list &lt;- colordistance::getKMeansList(dir(system.file("extdata",
"Heliconius/", package="colordistance"), full.names=TRUE), bins=3,
lower=rep(0.8, 3), upper=rep(1, 3), plotting=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getLabHist'>Generate a 3D histogram based on CIE Lab color coordinates in an image</h2><span id='topic+getLabHist'></span>

<h3>Description</h3>

<p>Computes a histogram in CIE Lab color space by sorting pixels into specified bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLabHist(
  image,
  bins = 3,
  sample.size = 10000,
  ref.white,
  from = "sRGB",
  bin.avg = TRUE,
  alpha.channel = TRUE,
  as.vec = FALSE,
  plotting = TRUE,
  lower = c(0, 0.55, 0),
  upper = c(0.24, 1, 0.24),
  title = "path",
  a.bounds = c(-128, 127),
  b.bounds = c(-128, 127),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLabHist_+3A_image">image</code></td>
<td>
<p>Path to a valid image (PNG or JPG) or a <code><a href="#topic+loadImage">loadImage</a></code>
object.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_bins">bins</code></td>
<td>
<p>Number of bins for each channel OR a vector of length 3 with bins
for each channel. Bins = 3 will result in 3^3 = 27 bins; bins = c(2, 2, 3) will
result in 2 * 2 * 3 = 12 bins (2 L, 2 a, 3 b), etc.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_sample.size">sample.size</code></td>
<td>
<p>Numeric. How many pixels should be randomly sampled from
the non-background part of the image and converted into CIE Lab
coordinates? If non-numeric, all pixels will be converted, but this can be
very slow (see details).</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_ref.white">ref.white</code></td>
<td>
<p>Reference white passed to <code><a href="#topic+convertColorSpace">convertColorSpace</a></code>.
Unlike <code>convertColor</code>, no default is provided. See details for
explanation of different reference whites.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_from">from</code></td>
<td>
<p>Original color space of image, probably either &quot;sRGB&quot; or &quot;Apple
RGB&quot;, depending on your computer.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_bin.avg">bin.avg</code></td>
<td>
<p>Logical. Should the returned color clusters be the average of
the pixels in that bin (bin.avg=<code>TRUE</code>) or the center of the bin
(<code>FALSE</code>)? If a bin is empty, the center of the bin is returned as the
cluster color regardless.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_alpha.channel">alpha.channel</code></td>
<td>
<p>Logical. If available, should alpha channel transparency be
used to mask background? See <code><a href="#topic+removeBackground">removeBackground</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_as.vec">as.vec</code></td>
<td>
<p>Logical. Should the bin sizes just be returned as a vector?
Much faster if only using <code><a href="#topic+chisqDistance">chisqDistance</a></code> for comparison metric.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Should a histogram of the bin colors and sizes be
plotted?</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_lower">lower</code>, <code id="getLabHist_+3A_upper">upper</code></td>
<td>
<p>RGB or HSV triplets specifying the lower and upper bounds
for background pixels. Default upper and lower bounds are set to values
that work well for a bright green background (RGB [0, 1, 0]). Determining
these bounds may take some trial and error, but the following bounds may
work for certain common background colors: </p>
 <ul>
<li><p> Black:
lower=c(0, 0, 0); upper=c(0.1, 0.1, 0.1) </p>
</li>
<li><p> White: lower=c(0.8, 0.8,
0.8); upper=c(1, 1, 1) </p>
</li>
<li><p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1,
0.24) </p>
</li>
<li><p> Blue: lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li></ul>
<p> If no
background filtering is needed, set bounds to some non-numeric value
(<code>NULL</code>, <code>FALSE</code>, <code>"off"</code>, etc); any non-numeric value is
interpreted as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_title">title</code></td>
<td>
<p>String for what the title the plot if plotting is on; defaults
to the image name.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_a.bounds">a.bounds</code>, <code id="getLabHist_+3A_b.bounds">b.bounds</code></td>
<td>
<p>Numeric ranges for the a (green-red) and b
(blue-yellow) channels of Lab color space. Technically, a and b have
infinite range, but in practice nearly all values fall between -128 and 127
(the default). Many images will have an even narrower range than this,
depending on the lighting conditions and conversion; setting narrower
ranges will result in finer-scale binning, without generating empty bins at
the edges of the channels.</p>
</td></tr>
<tr><td><code id="getLabHist_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getLabHist</code> uses <code><a href="#topic+convertColorSpace">convertColorSpace</a></code> to convert
pixels into CIE Lab coordinates, which requires a references white. There
are seven CIE standardized illuminants available in <code>colordistance</code>
(A, B, C, E, and D50, D55, and D65), but the most common are: </p>

<ul>
<li> <p><code>"A"</code>: Standard incandescent lightbulb </p>
</li>
<li> <p><code>"D65"</code>:
Average daylight </p>
</li>
<li> <p><code>"D50"</code>: Direct sunlight</p>
</li></ul>

<p>Color conversions will be highly dependent on the reference white used, which
is why no default is provided. Users should look into
<a href="https://en.wikipedia.org/wiki/Standard_illuminant">standard
illuminants</a> to choose an appropriate reference for a dataset.
</p>
<p>The conversion from RGB to a standardized color space (XYZ, Lab, or Luv) is
approximate, non-linear, and relatively time-consuming. Converting a large
number of pixels can be computationally expensive, so
<code>convertColorSpace</code> will randomly sample a specified number of rows to
reduce the time. The default sample size, 10,000 rows, takes about 1 second to
convert from sRGB to Lab space on an early 2015 Macbook with 8 GB of RAM.
Time scales about linearly with number of rows converted.
</p>
<p>Unlike RGB or HSV color spaces, the three channels of CIE Lab color space do
not all range between 0 and 1; instead, L (luminance) is always between 0 and
100, and the a (green-red) and b (blue-yellow) channels generally vary
between -128 and 127, but usually occupy a narrower range depending on the
reference white. To achieve the best results, ranges for a and b should be
restricted to avoid generating empty bins.
</p>


<h3>Value</h3>

<p>A vector or dataframe (depending on whether <code>as.vec = TRUE</code>) of bin
sizes and color coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("extdata", "Heliconius/Heliconius_B/Heliconius_07.jpeg",
package="colordistance")
getLabHist(path, ref.white = "D65", bins = c(2, 3, 3), lower = rep(0.8, 3),
upper = rep(1, 3), sample.size = 1000, ylim = c(0, 1))

</code></pre>

<hr>
<h2 id='getLabHistList'>Generate a list of cluster sets in CIE Lab color space</h2><span id='topic+getLabHistList'></span>

<h3>Description</h3>

<p>Applies <code><a href="#topic+getLabHist">getLabHist</a></code> to every image in a provided set of image
paths and/or directories containing images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLabHistList(
  images,
  bins = 3,
  sample.size = 10000,
  ref.white,
  from = "sRGB",
  bin.avg = TRUE,
  as.vec = FALSE,
  plotting = FALSE,
  pausing = TRUE,
  lower = c(0, 0.55, 0),
  upper = c(0.24, 1, 0.24),
  alpha.channel = TRUE,
  title = "path",
  a.bounds = c(-128, 127),
  b.bounds = c(-128, 127),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLabHistList_+3A_images">images</code></td>
<td>
<p>Character vector of directories, image paths, or both.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_bins">bins</code></td>
<td>
<p>Number of bins for each channel OR a vector of length 3 with bins
for each channel. Bins = 3 will result in 3^3 = 27 bins; bins = c(2, 2, 3) will
result in 2 * 2 * 3 = 12 bins (2 L, 2 a, 3 b), etc.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_sample.size">sample.size</code></td>
<td>
<p>Numeric. How many pixels should be randomly sampled from
the non-background part of the image and converted into CIE Lab
coordinates? If non-numeric, all pixels will be converted, but this can be
very slow (see details).</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_ref.white">ref.white</code></td>
<td>
<p>Reference white passed to <code><a href="#topic+convertColorSpace">convertColorSpace</a></code>.
Unlike <code>convertColor</code>, no default is provided. See details for
explanation of different reference whites.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_from">from</code></td>
<td>
<p>Original color space of image, probably either &quot;sRGB&quot; or &quot;Apple
RGB&quot;, depending on your computer.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_bin.avg">bin.avg</code></td>
<td>
<p>Logical. Should the returned color clusters be the average of
the pixels in that bin (bin.avg=<code>TRUE</code>) or the center of the bin
(<code>FALSE</code>)? If a bin is empty, the center of the bin is returned as the
cluster color regardless.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_as.vec">as.vec</code></td>
<td>
<p>Logical. Should the bin sizes just be returned as a vector?
Much faster if only using <code><a href="#topic+chisqDistance">chisqDistance</a></code> for comparison metric.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Should a histogram of the bin colors and sizes be
plotted?</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_pausing">pausing</code></td>
<td>
<p>Logical. If <code>plotting=T</code>, should the function pause
between graphing and wait for user to hit <code>[enter]</code> before continuing?
Useful for data/histogram inspection.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_lower">lower</code>, <code id="getLabHistList_+3A_upper">upper</code></td>
<td>
<p>RGB or HSV triplets specifying the lower and upper bounds
for background pixels. Default upper and lower bounds are set to values
that work well for a bright green background (RGB [0, 1, 0]). Determining
these bounds may take some trial and error, but the following bounds may
work for certain common background colors: </p>
 <ul>
<li><p> Black:
lower=c(0, 0, 0); upper=c(0.1, 0.1, 0.1) </p>
</li>
<li><p> White: lower=c(0.8, 0.8,
0.8); upper=c(1, 1, 1) </p>
</li>
<li><p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1,
0.24) </p>
</li>
<li><p> Blue: lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li></ul>
<p> If no
background filtering is needed, set bounds to some non-numeric value
(<code>NULL</code>, <code>FALSE</code>, <code>"off"</code>, etc); any non-numeric value is
interpreted as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_alpha.channel">alpha.channel</code></td>
<td>
<p>Logical. If available, should alpha channel transparency be
used to mask background? See <code><a href="#topic+removeBackground">removeBackground</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_title">title</code></td>
<td>
<p>String for what the title the plot if plotting is on; defaults
to the image name.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_a.bounds">a.bounds</code>, <code id="getLabHistList_+3A_b.bounds">b.bounds</code></td>
<td>
<p>Numeric ranges for the a (green-red) and b
(blue-yellow) channels of Lab color space. Technically, a and b have
infinite range, but in practice nearly all values fall between -128 and 127
(the default). Many images will have an even narrower range than this,
depending on the lighting conditions and conversion; setting narrower
ranges will result in finer-scale binning, without generating empty bins at
the edges of the channels.</p>
</td></tr>
<tr><td><code id="getLabHistList_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getLabHist</code> uses <code><a href="#topic+convertColorSpace">convertColorSpace</a></code> to convert
pixels into CIE Lab coordinates, which requires a references white. There
are seven CIE standardized illuminants available in <code>colordistance</code>
(A, B, C, E, and D50, D55, and D65), but the most common are: </p>

<ul>
<li> <p><code>"A"</code>: Standard incandescent lightbulb </p>
</li>
<li> <p><code>"D65"</code>:
Average daylight </p>
</li>
<li> <p><code>"D50"</code>: Direct sunlight</p>
</li></ul>

<p>Color conversions will be highly dependent on the reference white used, which
is why no default is provided. Users should look into
<a href="https://en.wikipedia.org/wiki/Standard_illuminant">standard
illuminants</a> to choose an appropriate reference for a dataset.
</p>
<p>Unlike RGB or HSV color spaces, the three channels of CIE Lab color space do
not all range between 0 and 1; instead, L (luminance) is always between 0 and
100, and the a (green-red) and b (blue-yellow) channels generally vary
between -128 and 127, but usually occupy a narrower range depending on the
reference white. The exception is reference white A (standard incandescent
lighting), which tends to have lower values when converting with
<code><a href="grDevices.html#topic+convertColor">convertColor</a></code>.
</p>


<h3>Value</h3>

<p>A list of <code><a href="#topic+getLabHist">getLabHist</a></code> dataframes, 1 per image, named
by image name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>images &lt;- system.file("extdata", "Heliconius/Heliconius_B",
package="colordistance")

colordistance::getLabHistList(images, bins = 2, sample.size = 1000, ref.white
= "D65", plotting = TRUE, pausing = FALSE, lower = rep(0.8, 3), upper =
rep(1, 3), a.bounds = c(-100, 100), b.bounds = c(-127, 100), ylim = c(0, 1))
</code></pre>

<hr>
<h2 id='heatmapColorDistance'>Plot a heatmap of a distance matrix</h2><span id='topic+heatmapColorDistance'></span>

<h3>Description</h3>

<p>Plots a heatmap of a symmetrical distance matrix in order to visualize
similarity/dissimilarity in scores. Values are clustered by similarity using
<code><a href="stats.html#topic+hclust">hclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmapColorDistance(
  clusterList_or_matrixObject,
  main = NULL,
  col = "default",
  margins = c(6, 8),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmapColorDistance_+3A_clusterlist_or_matrixobject">clusterList_or_matrixObject</code></td>
<td>
<p>Either a list of identically sized
dataframes with 4 columns each (3 color channels + Pct) as output by
<code><a href="#topic+extractClusters">extractClusters</a></code> or <code><a href="#topic+getHistList">getHistList</a></code>, or a
symmetrical distance matrix as output by
<code><a href="#topic+getColorDistanceMatrix">getColorDistanceMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="heatmapColorDistance_+3A_main">main</code></td>
<td>
<p>Title for heatmap plot.</p>
</td></tr>
<tr><td><code id="heatmapColorDistance_+3A_col">col</code></td>
<td>
<p>Color scale for heatmap from low to high. Default is
<code>colorRampPalette(c("royalblue4", "ghostwhite", "violetred2"))(299)</code>,
where pink is more dissimilar and blue is more similar.</p>
</td></tr>
<tr><td><code id="heatmapColorDistance_+3A_margins">margins</code></td>
<td>
<p>Margins for column and row labels.</p>
</td></tr>
<tr><td><code id="heatmapColorDistance_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="gplots.html#topic+heatmap.2">heatmap.2</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Heatmap representation of distance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Takes a few seconds to run
cluster.list &lt;- colordistance::getHistList(dir(system.file("extdata",
"Heliconius/", package="colordistance"), full.names=TRUE), lower=rep(0.8, 3),
upper=rep(1, 3))

CDM &lt;- colordistance::getColorDistanceMatrix(cluster.list, plotting=FALSE)

colordistance::heatmapColorDistance(CDM, main="Heliconius color similarity")
colordistance::heatmapColorDistance(cluster.list,
col=colorRampPalette(c("red", "cyan", "blue"))(n=299))

## End(Not run)

</code></pre>

<hr>
<h2 id='imageClusterPipeline'>Generate and plot a color distance matrix from a set of images</h2><span id='topic+imageClusterPipeline'></span>

<h3>Description</h3>

<p>Takes images, computes color clusters for each image, and calculates distance
matrix/dendrogram from those clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageClusterPipeline(
  images,
  cluster.method = "hist",
  distance.method = "emd",
  lower = c(0, 140/255, 0),
  upper = c(60/255, 1, 60/255),
  hist.bins = 3,
  kmeans.bins = 27,
  bin.avg = TRUE,
  norm.pix = FALSE,
  plot.bins = FALSE,
  pausing = TRUE,
  color.space = "rgb",
  ref.white,
  from = "sRGB",
  bounds = c(0, 1),
  sample.size = 20000,
  iter.max = 50,
  nstart = 5,
  img.type = FALSE,
  ordering = "default",
  size.weight = 0.5,
  color.weight = 0.5,
  plot.heatmap = TRUE,
  return.distance.matrix = TRUE,
  save.tree = FALSE,
  save.distance.matrix = FALSE,
  a.bounds = c(-127, 128),
  b.bounds = c(-127, 128)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageClusterPipeline_+3A_images">images</code></td>
<td>
<p>Character vector of directories, image paths, or both.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_cluster.method">cluster.method</code></td>
<td>
<p>Which method for getting color clusters from each image
should be used? Must be either <code>"hist"</code> (predetermined bins generated
by dividing each channel with equidistant bounds; calls
<code><a href="#topic+getHistList">getHistList</a></code>) or <code>"kmeans"</code> (determine clusters using
kmeans fitting on pixels; calls <code><a href="#topic+getKMeansList">getKMeansList</a></code>).</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_distance.method">distance.method</code></td>
<td>
<p>One of four possible comparison methods for calculating
the color distances: <code>"emd"</code> (uses <code><a href="#topic+EMDistance">EMDistance</a></code>,
recommended), <code>"chisq"</code> (uses <code><a href="#topic+chisqDistance">chisqDistance</a></code>),
<code>"color.dist"</code> (uses <code><a href="#topic+colorDistance">colorDistance</a></code>; not appropriate if
bin.avg=F), or <code>"weighted.pairs"</code>
(<code><a href="#topic+weightedPairsDistance">weightedPairsDistance</a></code>).</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_lower">lower</code></td>
<td>
<p>RGB or HSV triplet specifying the lower bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]).</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_upper">upper</code></td>
<td>
<p>RGB or HSV triplet specifying the upper bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]). Determining these bounds may
take some trial and error, but the following bounds may work for certain
common background colors: </p>
 <ul>
<li><p> Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) </p>
</li>
<li><p> White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1,
1) </p>
</li>
<li><p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) </p>
</li>
<li><p> Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li></ul>
<p> If no background filtering is
needed, set bounds to some non-numeric value (<code>NULL</code>, <code>FALSE</code>,
<code>"off"</code>, etc); any non-numeric value is interpreted as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_hist.bins">hist.bins</code></td>
<td>
<p>Only applicable if <code>cluster.method="hist"</code>. Number of
bins for each channel OR a vector of length 3 with bins for each channel.
Bins=3 will result in 3^3 = 27 bins; bins=c(2, 2, 3) will result in
2*2*3=12 bins (2 red, 2 green, 3 blue), etc. Passed to
<code><a href="#topic+getHistList">getHistList</a></code>.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_kmeans.bins">kmeans.bins</code></td>
<td>
<p>Only applicable if <code>cluster.method="kmeans"</code>. Number of
KMeans clusters to fit. Unlike <code><a href="#topic+getImageHist">getImageHist</a></code>, this represents
the actual final number of bins, rather than the number of breaks in each
channel.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_bin.avg">bin.avg</code></td>
<td>
<p>Logical. Should the color clusters used for the distance matrix
be the average of the pixels in that bin (bin.avg=<code>TRUE</code>) or the center
of the bin (FALSE)? If a bin is empty, the center of the bin is returned
as the cluster color regardless. Only applicable if
<code>cluster.method="hist"</code>, since <code>kmeans</code> clusters are at the center
of their assigned pixel clouds by definition.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_norm.pix">norm.pix</code></td>
<td>
<p>Logical. Should RGB or HSV cluster values be normalized using
<code><a href="#topic+normalizeRGB">normalizeRGB</a></code>?</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_plot.bins">plot.bins</code></td>
<td>
<p>Logical. Should the bins for each image be plotted as they
are calculated?</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_pausing">pausing</code></td>
<td>
<p>Logical. If <code>plot.bins=TRUE</code>, pause and wait for user
keystroke before plotting bins for next image?</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_color.space">color.space</code></td>
<td>
<p>The color space (<code>"rgb"</code>, <code>"hsv"</code>, or
<code>"lab"</code>) in which to plot pixels.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_ref.white">ref.white</code></td>
<td>
<p>The reference white passed to
<code><a href="#topic+convertColorSpace">convertColorSpace</a></code>; must be specified if using
<code>color.space = "lab"</code>.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_from">from</code></td>
<td>
<p>Display color space of image if clustering in CIE Lab space,
probably either &quot;sRGB&quot; or &quot;Apple RGB&quot;, depending on your computer.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_bounds">bounds</code></td>
<td>
<p>Upper and lower limits for the channels; R reads in images with
intensities on a 0-1 scale, but 0-255 is common.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_sample.size">sample.size</code></td>
<td>
<p>Only applicable if <code>cluster.method="kmeans"</code>. Number of
pixels to be randomly sampled from filtered pixel array for performing fit.
If set to <code>FALSE</code>, all pixels are fit, but this can be time-consuming,
especially for large images. Passed to <code><a href="#topic+getKMeansList">getKMeansList</a></code>.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_iter.max">iter.max</code></td>
<td>
<p>Only applicable if <code>cluster.method="kmeans"</code>. Inherited
from <code><a href="stats.html#topic+kmeans">kmeans</a></code>. The maximum number of iterations allowed
during kmeans fitting. Passed to <code><a href="#topic+getKMeansList">getKMeansList</a></code>.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_nstart">nstart</code></td>
<td>
<p>Only applicable if <code>cluster.method="kmeans"</code>. Inherited
from <code><a href="stats.html#topic+kmeans">kmeans</a></code>. How many random sets should be chosen?
Passed to <code><a href="#topic+getKMeansList">getKMeansList</a></code>.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_img.type">img.type</code></td>
<td>
<p>Logical. Should file extensions be retained with labels?</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_ordering">ordering</code></td>
<td>
<p>Logical if not left as &quot;default&quot;. Should the color clusters
in the list be reordered to minimize the distances between the pairs? If
left as default, ordering depends on distance method: &quot;emd&quot; and &quot;chisq&quot; do
not order clusters (&quot;emd&quot; orders on a case-by-case in the
<code><a href="#topic+EMDistance">EMDistance</a></code> function itself and reordering by size similarity
would make chi-squared meaningless); &quot;color.dist&quot; and &quot;weighted.pairs&quot; use
ordering. To override defaults, set to either <code>T</code> (for ordering) or
<code>F</code> (for no ordering).</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_size.weight">size.weight</code></td>
<td>
<p>Weight of size similarity in determining overall score and
ordering (if <code>ordering=T</code>).</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_color.weight">color.weight</code></td>
<td>
<p>Weight of color similarity in determining overall score
and ordering (if <code>ordering=T</code>). Color and size weights do not
necessarily have to sum to 1.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_plot.heatmap">plot.heatmap</code></td>
<td>
<p>Logical. Should a heatmap of the distance matrix be
plotted?</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_return.distance.matrix">return.distance.matrix</code></td>
<td>
<p>Logical. Should the distance matrix be returned
to the R environment or just plotted?</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_save.tree">save.tree</code></td>
<td>
<p>Either logical or a filepath for saving the tree; default if
set to <code>TRUE</code> is to save in current working directory as
&quot;ColorTree.newick&quot;.</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_save.distance.matrix">save.distance.matrix</code></td>
<td>
<p>Either logical or filepath for saving distance
matrix; default if set to <code>TRUE</code> is to save in current working
directory as &quot;ColorDistanceMatrix.csv&quot;</p>
</td></tr>
<tr><td><code id="imageClusterPipeline_+3A_a.bounds">a.bounds</code>, <code id="imageClusterPipeline_+3A_b.bounds">b.bounds</code></td>
<td>
<p>Passed to <code><a href="#topic+getLabHistList">getLabHistList</a></code>.Numeric
ranges for the a (green-red) and b (blue-yellow) channels of Lab color
space. Technically, a and b have infinite range, but in practice nearly all
values fall between -128 and 127 (the default). Many images will have an
even narrower range than this, depending on the lighting conditions and
conversion; setting narrower ranges will result in finer-scale binning,
without generating empty bins at the edges of the channels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Color distance matrix, heatmap, and saved distance matrix and tree
files if saving is <code>TRUE</code>.
</p>


<h3>Note</h3>

<p>This is the fastest way to get a distance matrix for color similarity
starting from a folder of images. Essentially, it just calls in a series of
other package functions in order: input images -&gt; <code><a href="#topic+getImagePaths">getImagePaths</a></code>
-&gt; <code><a href="#topic+getHistList">getHistList</a></code> or <code><a href="#topic+getKMeansList">getKMeansList</a></code> followed by
<code><a href="#topic+extractClusters">extractClusters</a></code> -&gt; <code><a href="#topic+getColorDistanceMatrix">getColorDistanceMatrix</a></code> -&gt;
plotting -&gt; return/save distance matrix. Sort of railroads you, but good for
testing different combinations of clustering methods and distance metrics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
colordistance::imageClusterPipeline(dir(system.file("extdata", "Heliconius/",
package="colordistance"), full.names=TRUE), color.space="hsv", lower=rep(0.8,
3), upper=rep(1, 3), cluster.method="hist", distance.method="emd",
hist.bins=3, plot.bins=TRUE, save.tree="example_tree.newick",
save.distance.matrix="example_DM.csv")

## End(Not run)

</code></pre>

<hr>
<h2 id='loadImage'>Import image and generate filtered 2D pixel array(s)</h2><span id='topic+loadImage'></span>

<h3>Description</h3>

<p>Imports a single image and returns a list with the original image as a 3D
array, a 2D matrix with background pixels removed, and the absolute path to
the original image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadImage(
  path,
  lower = c(0, 0.55, 0),
  upper = c(0.24, 1, 0.24),
  hsv = TRUE,
  CIELab = FALSE,
  sample.size = 1e+05,
  ref.white = NULL,
  alpha.channel = TRUE,
  alpha.message = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadImage_+3A_path">path</code></td>
<td>
<p>Path to image (a string).</p>
</td></tr>
<tr><td><code id="loadImage_+3A_lower">lower</code></td>
<td>
<p>RGB or HSV triplet specifying the lower bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]).</p>
</td></tr>
<tr><td><code id="loadImage_+3A_upper">upper</code></td>
<td>
<p>RGB or HSV triplet specifying the upper bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]). Determining these bounds may
take some trial and error, but the following bounds may work for certain
common background colors: </p>
 <ul>
<li><p> Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) </p>
</li>
<li><p> White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1,
1) </p>
</li>
<li><p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) </p>
</li>
<li><p> Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li></ul>
<p> If no background filtering is
needed, set bounds to some non-numeric value (<code>NULL</code>, <code>FALSE</code>,
<code>"off"</code>, etc); any non-numeric value is interpreted as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="loadImage_+3A_hsv">hsv</code></td>
<td>
<p>Logical. Should HSV pixel array also be calculated? Setting to
<code>FALSE</code> will shave some time off the analysis, but not much (a few
microseconds per image).</p>
</td></tr>
<tr><td><code id="loadImage_+3A_cielab">CIELab</code></td>
<td>
<p>Logical. Should CIEL*a*b color space pixels be calculated from
RGB? Requires specification of a reference white (see details).</p>
</td></tr>
<tr><td><code id="loadImage_+3A_sample.size">sample.size</code></td>
<td>
<p>Number of pixels to be randomly sampled from filtered pixel
array for conversion. If not numeric, all pixels are converted.</p>
</td></tr>
<tr><td><code id="loadImage_+3A_ref.white">ref.white</code></td>
<td>
<p>String; white reference for converting from RGB to CIEL*a*b
color space. Accepts any of the standard white references for
<code><a href="grDevices.html#topic+convertColor">convertColor</a></code> (see details).</p>
</td></tr>
<tr><td><code id="loadImage_+3A_alpha.channel">alpha.channel</code></td>
<td>
<p>Logical. If available, should alpha channel transparency be
used to mask background? See <code><a href="#topic+removeBackground">removeBackground</a></code> for more
details.</p>
</td></tr>
<tr><td><code id="loadImage_+3A_alpha.message">alpha.message</code></td>
<td>
<p>Logical. Output a message if using alpha channel
transparency to mask background? Helpful for troubleshooting with PNGs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The upper and lower limits for background pixel elimination set the
inclusive bounds for which pixels should be ignored for the 2D arrays; while
all background pixels are ideally a single color, images photographed against
&quot;uniform&quot; backgrounds often contain some variation, and even segmentation
done with photo editing software will produce some variance as a result of
image compression.
</p>
<p>The upper and lower bounds represent cutoffs: any pixel for which the first
channel falls between the first upper and lower bounds, the second channel
falls between the second upper and lower bounds, and the third channel falls
between the third upper and lower bounds, will be ignored. For example, if
you have a green pixel with RGB channel values [0.1, 0.9, 0.2], and your
upper and lower bounds were (0.2, 1, 0.2) and (0, 0.6, 0) respectively, the
pixel would be ignored because 0 &lt;= 0.1 &lt;= 0.2, 0.6 &lt;= 0.9 &lt;= 1, and 0 &lt;= 0.2
&lt;= 0.2. But a pixel with the RGB channel values [0.3, 0.9, 0.2] would not be
considered background because 0.3 &gt;= 0.2.
</p>
<p>CIEL*a*b color space requires a reference 'white light' color (dimly and
brightly lit photographs of the same object will have very different RGB
palettes, but similar Lab palettes if appropriate white references are used).
The idea here is that the apparent colors in an image depend not just on the
&quot;absolute&quot; color of an object (whatever that means), but also on the
available light in the scene. There are seven CIE standardized illuminants
available in <code>colordistance</code> (A, B, C, E, and D50, D55, and D60), but
the most common are: </p>
 <ul>
<li> <p><code>"A"</code>: Standard incandescent
lightbulb </p>
</li>
<li> <p><code>"D65"</code>: Average daylight </p>
</li>
<li> <p><code>"D50"</code>: Direct
sunlight</p>
</li></ul>

<p>Color conversions will be highly dependent on the reference white used, which
is why no default is provided. Users should look into
<a href="https://en.wikipedia.org/wiki/Standard_illuminant">standard
illuminants</a> to choose an appropriate reference for a dataset.
</p>


<h3>Value</h3>

<p>A list with original image ($original.rgb, 3D array), 2D matrix with
background pixels removed ($filtered.rgb.2d and $filtered.hsv.2d), and path
to the original image ($path).
</p>


<h3>Note</h3>

<p>The 3D array is useful for displaying the original image, while the 2D
arrays (RGB and HSV) are treated as rows of data for clustering in the rest
of the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loadedImg &lt;- colordistance::loadImage(system.file("extdata",
"Heliconius/Heliconius_A/Heliconius_01.jpeg", package="colordistance"),
upper=rep(1, 3), lower=rep(0.8, 3))

loadedImgNoHSV &lt;- colordistance::loadImage(system.file("extdata",
"Heliconius/Heliconius_A/Heliconius_01.jpeg", package="colordistance"),
upper=rep(1, 3), lower=rep(0.8, 3), hsv=FALSE)

</code></pre>

<hr>
<h2 id='normalizeRGB'>Normalize pixel RGB ratios</h2><span id='topic+normalizeRGB'></span>

<h3>Description</h3>

<p>Converts clusters from raw channel intensity to their fraction of the
intensity for that cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeRGB(extractClustersObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeRGB_+3A_extractclustersobject">extractClustersObject</code></td>
<td>
<p>A list of color clusters such as those returned
by <code><a href="#topic+extractClusters">extractClusters</a></code> or <code><a href="#topic+getHistList">getHistList</a></code>. List must
contain identically sized dataframes with color coordinates (R, G, B or H,
S, V) as the first three columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same size and structure as the input list, but with the
cluster normalized as described.
</p>


<h3>Note</h3>

<p>This is a useful option if your images have a lot of variation in lighting,
but obviously comes at the cost of reducing variation (if darker and lighter
colors are meaningful sources of variation in the dataset).
</p>
<p>For example, a bright yellow (R=1, G=1, B=0) and a darker yellow (R=0.8,
G=0.8, B=0) both have 50% red, 50% green, and 0% blue, so their normalized
values would be equivalent.
</p>
<p>A similar but less harsh alternative would be to use HSV rather than RGB for
pixel binning and color similarity clustering by setting <code>hsv=T</code> in
clustering functions and specifying a low number of 'value' bins (e.g.
<code>bins=c(8, 8, 2)</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cluster.list &lt;- colordistance::getKMeansList(c(system.file("extdata",
"Heliconius/Heliconius_A", package="colordistance"), lower=rep(0.8, 3),
upper=rep(1, 3)))
cluster.list &lt;- colordistance::extractClusters(cluster.list)
colordistance:::normalizeRGB(cluster.list)
</code></pre>

<hr>
<h2 id='orderClusters'>Order color clusters to minimize overall color distance between pairs</h2><span id='topic+orderClusters'></span>

<h3>Description</h3>

<p>Reorders clusters to minimize color distance using the
<a href="https://en.wikipedia.org/wiki/Hungarian_algorithm">Hungarian algorithm</a>
as implemented by <code><a href="clue.html#topic+solve_LSAP">solve_LSAP</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderClusters(extractClustersObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderClusters_+3A_extractclustersobject">extractClustersObject</code></td>
<td>
<p>A list of color clusters such as those returned
by <code><a href="#topic+extractClusters">extractClusters</a></code> or <code><a href="#topic+getHistList">getHistList</a></code>. List must
contain identically sized dataframes with color coordinates (R, G, B or H,
S, V) as the first three columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Briefly: Euclidean distances between every possible pair of clusters
across two dataframes are calculated, and pairs of clusters are chosen in
order to minimize the total sum of color distances between the cluster pairs
(i.e. A1-B1, A2-B2, etc).
</p>
<p>For example, if dataframe A has a black cluster, a white cluster, and a blue
cluster, in that order, and dataframe B has a white cluster, a blue cluster,
and a grey cluster, in that order, the final pairs might be A1-B3 (black and
grey), A2-B2 (blue and blue), and A3-B1 (white and white).
</p>
<p>Rows are reordered so that paired rows are in the same row index (in the
example, dataframe B would be reshuffled to go grey, blue, white instead of
white, grey, blue).
</p>


<h3>Value</h3>

<p>A list with identical data to the input list, but with rows in each
dataframe reordered to minimize color distances per cluster pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cluster.list &lt;- colordistance::getKMeansList(c(system.file("extdata",
"Heliconius/Heliconius_A", package="colordistance"), lower=rep(0.8, 3),
upper=rep(1, 3)))
cluster.list &lt;- colordistance::extractClusters(cluster.list)
colordistance:::orderClusters(cluster.list)
</code></pre>

<hr>
<h2 id='pause'>Pause and wait for user input</h2><span id='topic+pause'></span>

<h3>Description</h3>

<p>Tiny little function wrapper, mostly used for looping or when several plots
are output by a single function. Waits for user keystroke to move on to next
image or exit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pause()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>for (i in c(1:5)) {
  print(i)
  if (i &lt; 5) {
    colordistance:::pause()
  }
}
</code></pre>

<hr>
<h2 id='plotClusters'>Plot clusters in 3D color space</h2><span id='topic+plotClusters'></span>

<h3>Description</h3>

<p>Interactive, 3D <code><a href="plotly.html#topic+plot_ly">plot_ly</a></code> plots of cluster sizes and
colors for each image in a list of cluster dataframes in order to visualize
cluster output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClusters(
  cluster.list,
  color.space = "rgb",
  p = "all",
  pausing = TRUE,
  ref.white,
  to = "sRGB"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClusters_+3A_cluster.list">cluster.list</code></td>
<td>
<p>A list of identically sized dataframes with 4 columns each
(R, G, B, Pct or H, S, V, Pct) as output by <code>extractClusters</code> or
<code>getHistList</code>.</p>
</td></tr>
<tr><td><code id="plotClusters_+3A_color.space">color.space</code></td>
<td>
<p>The color space (<code>"rgb"</code>, <code>"hsv"</code>, or
<code>"lab"</code>) in which to plot pixels.</p>
</td></tr>
<tr><td><code id="plotClusters_+3A_p">p</code></td>
<td>
<p>Numeric vector of indices for which elements to plot; otherwise each
set of clusters is plotted in succession.</p>
</td></tr>
<tr><td><code id="plotClusters_+3A_pausing">pausing</code></td>
<td>
<p>Logical. Should the function pause and wait for user keystroke
before plotting the next plot?</p>
</td></tr>
<tr><td><code id="plotClusters_+3A_ref.white">ref.white</code></td>
<td>
<p>The reference white passed to
<code><a href="#topic+convertColorSpace">convertColorSpace</a></code>; must be specified if using
<code>color.space = "lab"</code>.</p>
</td></tr>
<tr><td><code id="plotClusters_+3A_to">to</code></td>
<td>
<p>Display color space of image if clustering in CIE Lab space,
probably either &quot;sRGB&quot; or &quot;Apple RGB&quot;, depending on your computer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D <code><a href="plotly.html#topic+plot_ly">plot_ly</a></code> plot of cluster sizes in the
specified colorspace for each cluster dataframe provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Takes &gt;10 seconds
cluster.list &lt;- colordistance::getHistList(dir(system.file("extdata",
"Heliconius/", package="colordistance"), full.names=TRUE), plotting=FALSE,
lower=rep(0.8, 3), upper=rep(1, 3))

colordistance::plotClusters(cluster.list, p=c(1:3, 7:8), pausing=FALSE)

clusterListHSV &lt;- colordistance::getHistList(dir(system.file("extdata",
"Heliconius/", package="colordistance"), full.names=TRUE), hsv=TRUE,
plotting=FALSE, lower=rep(0.8, 3), upper=rep(1, 3))

colordistance::plotClusters(clusterListHSV, p=c(1:3, 7:8), hsv=TRUE,
pausing=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotClustersMulti'>Plot several different cluster sets together</h2><span id='topic+plotClustersMulti'></span>

<h3>Description</h3>

<p>Plots cluster sets from several different dataframes on a single plot for
easy comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClustersMulti(
  cluster.list,
  color.space = "rgb",
  p = "all",
  title = "",
  ref.white,
  to = "sRGB"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClustersMulti_+3A_cluster.list">cluster.list</code></td>
<td>
<p>A list of identically sized dataframes with 4 columns
each as output by <code>extractClusters</code>, <code>getLabHistList</code>, or
<code>getHistList</code>.</p>
</td></tr>
<tr><td><code id="plotClustersMulti_+3A_color.space">color.space</code></td>
<td>
<p>The color space (<code>"rgb"</code>, <code>"hsv"</code>, or
<code>"lab"</code>) in which to plot pixels.</p>
</td></tr>
<tr><td><code id="plotClustersMulti_+3A_p">p</code></td>
<td>
<p>Numeric vector of indices for which elements to plot; otherwise all
of the cluster sets provided will be plotted together.</p>
</td></tr>
<tr><td><code id="plotClustersMulti_+3A_title">title</code></td>
<td>
<p>Optional title for the plot.</p>
</td></tr>
<tr><td><code id="plotClustersMulti_+3A_ref.white">ref.white</code></td>
<td>
<p>The reference white passed to
<code><a href="#topic+convertColorSpace">convertColorSpace</a></code>; must be specified if using
<code>color.space = "lab"</code>.</p>
</td></tr>
<tr><td><code id="plotClustersMulti_+3A_to">to</code></td>
<td>
<p>Display color space of image if clustering in CIE Lab space,
probably either &quot;sRGB&quot; or &quot;Apple RGB&quot;, depending on your computer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code><a href="plotly.html#topic+plot_ly">plot_ly</a></code> plot of every cluster in a
list of cluster sets. Each cluster is colored by cluster color,
proportional to cluster size, and labeled according to the image from which
it originated.
</p>


<h3>Note</h3>

<p>Each cluster plotted is colored according to its actual color, and
labeled according to the image from which it originated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Takes &gt;10 seconds
cluster.list &lt;- colordistance::getHistList(dir(system.file("extdata",
"Heliconius/", package="colordistance"), full.names=TRUE), plotting=FALSE,
lower=rep(0.8, 3), upper=rep(1, 3))

colordistance::plotClustersMulti(cluster.list, p=c(1:4), title="Orange and
black Heliconius")

colordistance::plotClustersMulti(cluster.list, p=c(5:8), title="Black, yellow,
and red Heliconius")

clusterListHSV &lt;- colordistance::getHistList(dir(system.file("extdata",
"Heliconius/", package="colordistance"), full.names=TRUE), hsv=TRUE,
plotting=FALSE, lower=rep(0.8, 3), upper=rep(1, 3))

colordistance::plotClustersMulti(clusterListHSV, p=c(1:3, 7:8), hsv=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotHist'>Color histogram of binned image</h2><span id='topic+plotHist'></span>

<h3>Description</h3>

<p>Plots a color histogram from a dataframe as returned by
<code><a href="#topic+getImageHist">getImageHist</a></code>, <code><a href="#topic+getHistList">getHistList</a></code>, or
<code><a href="#topic+extractClusters">extractClusters</a></code>. Bars are colored according to the color of the
bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHist(
  histogram,
  pausing = TRUE,
  color.space = "rgb",
  ref.white,
  from = "sRGB",
  main = "default",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHist_+3A_histogram">histogram</code></td>
<td>
<p>A single dataframe or a list of dataframes as returned by
<code><a href="#topic+getLabHist">getLabHist</a></code>, <code><a href="#topic+getLabHistList">getLabHistList</a></code>, or
<code><a href="#topic+extractClusters">extractClusters</a></code>. First three columns must be color
coordinates and fourth column must be cluster size.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_pausing">pausing</code></td>
<td>
<p>Logical. Pause and wait for keystroke before plotting the next
histogram?</p>
</td></tr>
<tr><td><code id="plotHist_+3A_color.space">color.space</code></td>
<td>
<p>The color space (<code>"rgb"</code>, <code>"hsv"</code>, or
<code>"lab"</code>) in which to plot cluster histogram.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_ref.white">ref.white</code></td>
<td>
<p>The reference white passed to
<code><a href="#topic+convertColorSpace">convertColorSpace</a></code>; must be specified if using CIE
Lab space. See <a href="#topic+convertColorSpace">convertColorSpace</a>.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_from">from</code></td>
<td>
<p>Display color space of image if clustering in CIE Lab space,
probably either &quot;sRGB&quot; or &quot;Apple RGB&quot;, depending on your computer.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_main">main</code></td>
<td>
<p>Title for plot. If <code>"default"</code>, the name of the cluster
histogram is used.</p>
</td></tr>
<tr><td><code id="plotHist_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to the <code><a href="graphics.html#topic+barplot">barplot</a></code> function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>color_df &lt;- as.data.frame(matrix(rep(seq(0, 1, length.out=3), 3), nrow=3,
ncol=3))

color_df$Pct &lt;- c(0.2, 0.5, 0.3)

colordistance::plotHist(color_df, main="Example plot")
</code></pre>

<hr>
<h2 id='plotImage'>Display an image in a plot window</h2><span id='topic+plotImage'></span>

<h3>Description</h3>

<p>Plots an image as an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImage(img)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotImage_+3A_img">img</code></td>
<td>
<p>Either a path to an image or a <code><a href="#topic+loadImage">loadImage</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Redundant, but a nice sanity check. Used in a few other functions in
<code>colordistance</code> package. Takes either a path to an image (RGB or PNG) or
an image object as read in by <code><a href="#topic+loadImage">loadImage</a></code>.
</p>


<h3>Value</h3>

<p>A plot of the provided image in the current plot window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colordistance::plotImage(system.file("extdata",
"Heliconius/Heliconius_A/Heliconius_01.jpeg", package="colordistance"))
colordistance::plotImage(loadImage(system.file("extdata",
"Heliconius/Heliconius_A/Heliconius_01.jpeg", package="colordistance"),
lower=rep(0.8, 3), upper=rep(1, 3)))
</code></pre>

<hr>
<h2 id='plotPixels'>Plot pixels in color space</h2><span id='topic+plotPixels'></span>

<h3>Description</h3>

<p>Plots non-background pixels according to their color coordinates, and colors
them according to their RGB or HSV values. Dimensions are either RGB or HSV
depending on flags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPixels(
  img,
  n = 10000,
  lower = c(0, 0.55, 0),
  upper = c(0.25, 1, 0.25),
  color.space = "rgb",
  ref.white = NULL,
  pch = 20,
  main = "default",
  from = "sRGB",
  xlim = "default",
  ylim = "default",
  zlim = "default",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPixels_+3A_img">img</code></td>
<td>
<p>Either a path to an image or a <code><a href="#topic+loadImage">loadImage</a></code> object.</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_n">n</code></td>
<td>
<p>Number of randomly selected pixels to plot; recommend &lt;20000 for
speed. If n exceeds the number of non-background pixels in the image, all
pixels are plotted. If n is not numeric, all pixels are plotted.</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_lower">lower</code></td>
<td>
<p>RGB or HSV triplet specifying the lower bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]).</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_upper">upper</code></td>
<td>
<p>RGB or HSV triplet specifying the upper bounds for background
pixels. Default upper and lower bounds are set to values that work well for
a bright green background (RGB [0, 1, 0]). Determining these bounds may
take some trial and error, but the following bounds may work for certain
common background colors: </p>
 <ul>
<li><p> Black: lower=c(0, 0, 0);
upper=c(0.1, 0.1, 0.1) </p>
</li>
<li><p> White: lower=c(0.8, 0.8, 0.8); upper=c(1, 1,
1) </p>
</li>
<li><p> Green: lower=c(0, 0.55, 0); upper=c(0.24, 1, 0.24) </p>
</li>
<li><p> Blue:
lower=c(0, 0, 0.55); upper=c(0.24, 0.24, 1) </p>
</li></ul>
<p> If no background filtering is
needed, set bounds to some non-numeric value (<code>NULL</code>, <code>FALSE</code>,
<code>"off"</code>, etc); any non-numeric value is interpreted as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_color.space">color.space</code></td>
<td>
<p>The color space (<code>"rgb"</code>, <code>"hsv"</code>, or
<code>"lab"</code>) to use for plotting.</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_ref.white">ref.white</code></td>
<td>
<p>The reference white passed to
<code><a href="grDevices.html#topic+convertColor">convertColor</a></code>; must be specified if <code>img</code> does
not already contain CIE Lab pixels. See <a href="#topic+convertColorSpace">convertColorSpace</a>.</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_pch">pch</code></td>
<td>
<p>Passed to <code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code>.</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_main">main</code></td>
<td>
<p>Plot title. If left as &quot;default&quot;, image name is used.</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_from">from</code></td>
<td>
<p>Original color space of image if plotting in CIE Lab space,
probably either &quot;sRGB&quot; or &quot;Apple RGB&quot;, depending on your computer.</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_xlim">xlim</code>, <code id="plotPixels_+3A_ylim">ylim</code>, <code id="plotPixels_+3A_zlim">zlim</code></td>
<td>
<p>Ranges for the X, Y, and Z axes. If &quot;default&quot;, the
widest ranges for each axis according to the specified color space (0-1 for
RGB and HSV, 0-100 for L of Lab, -128-127 for a and b of Lab) are used.</p>
</td></tr>
<tr><td><code id="plotPixels_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to
<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3D plot of pixels in either RGB or HSV color space, colored according
to their color in the image. Uses
<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> function.
</p>


<h3>Note</h3>

<p>If <code>n</code> is not numeric, then all pixels are plotted, but this is
not recommended. Unless the image has a low pixel count, it takes much
longer, and plotting this many points in the plot window can obscure
important details.
</p>
<p>There are seven CIE standardized illuminants available in
<code>colordistance</code> (A, B, C, E, and D50, D55, and D65), but the most
common are: </p>
 <ul>
<li> <p><code>"A"</code>: Standard incandescent lightbulb
</p>
</li>
<li> <p><code>"D65"</code>: Average daylight </p>
</li>
<li> <p><code>"D50"</code>: Direct sunlight</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>colordistance::plotPixels(system.file("extdata",
"Heliconius/Heliconius_B/Heliconius_07.jpeg", package="colordistance"),
n=20000, upper=rep(1, 3), lower=rep(0.8, 3), color.space = "rgb", angle = -45)
</code></pre>

<hr>
<h2 id='removeBackground'>Remove background pixels in image</h2><span id='topic+removeBackground'></span>

<h3>Description</h3>

<p>Take an image array (from <code><a href="png.html#topic+readPNG">readPNG</a></code> or
<code><a href="grDevices.html#topic+jpeg">jpeg</a>{readJPEG}</code>) and remove the background pixels based on
transparency (if a PNG with transparency) or color boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeBackground(
  img,
  lower = NULL,
  upper = NULL,
  quietly = FALSE,
  alpha.channel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeBackground_+3A_img">img</code></td>
<td>
<p>Image array, either output from <code><a href="png.html#topic+readPNG">readPNG</a></code> or
<code><a href="grDevices.html#topic+jpeg">jpeg</a>{readJPEG}</code>.</p>
</td></tr>
<tr><td><code id="removeBackground_+3A_lower">lower</code>, <code id="removeBackground_+3A_upper">upper</code></td>
<td>
<p>RGB or HSV triplets specifying the bounds for background
pixels. See <code><a href="#topic+loadImage">loadImage</a></code>.</p>
</td></tr>
<tr><td><code id="removeBackground_+3A_quietly">quietly</code></td>
<td>
<p>Logical. Display a message if using transparency?</p>
</td></tr>
<tr><td><code id="removeBackground_+3A_alpha.channel">alpha.channel</code></td>
<td>
<p>Logical. If available, should alpha channel transparency be
used to mask background? See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>alpha.channel = TRUE</code>, transparency takes precedence over
color masking. If you provide a PNG with any pixels with alpha &lt; 1,
<code>removeBackground</code> ignores any <code>lower</code> and <code>upper</code> color
boundaries and assumes transparent pixels are background. If all pixels are
opaque (alpha = 1), color masking will apply.
</p>


<h3>Value</h3>

<p>A list with a 3-dimensional RGB array and a 2-dimensional array of
non-background pixels with R, G, B columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# remove background by transparency
img_path &lt;- system.file("extdata/chrysochroa_NPL.png",
 package = "colordistance")
 
img_array &lt;- png::readPNG(img_path)

img_filtered &lt;- removeBackground(img_array)

# remove background by color
img_path &lt;- dir(system.file("extdata/Heliconius", 
package = "colordistance"), 
recursive = TRUE, full.names = TRUE)[1]

img_array &lt;- jpeg::readJPEG(img_path)

img_filtered &lt;- removeBackground(img_array,
lower = rep(0.8, 3), upper = rep(1, 3))

</code></pre>

<hr>
<h2 id='scatter3dclusters'>Plot 3D clusters in a 2D plot</h2><span id='topic+scatter3dclusters'></span>

<h3>Description</h3>

<p>Uses <code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code> to plot clusters in color
space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter3dclusters(
  clusters,
  color.space,
  ref.white = "D65",
  xlim = "default",
  ylim = "default",
  zlim = "default",
  main = "Color clusters",
  scaling = 10,
  opacity = 0.9,
  plus = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter3dclusters_+3A_clusters">clusters</code></td>
<td>
<p>A single dataframe or a list of dataframes as returned by
<code><a href="#topic+getLabHist">getLabHist</a></code>, <code><a href="#topic+getLabHistList">getLabHistList</a></code>, or
<code><a href="#topic+extractClusters">extractClusters</a></code>. First three columns must be color
coordinates and fourth column must be cluster size.</p>
</td></tr>
<tr><td><code id="scatter3dclusters_+3A_color.space">color.space</code></td>
<td>
<p>The color space (<code>"rgb"</code>, <code>"hsv"</code>, or
<code>"lab"</code>) in which to plot. If not specified, the function uses column
names to guess the color space.</p>
</td></tr>
<tr><td><code id="scatter3dclusters_+3A_ref.white">ref.white</code></td>
<td>
<p>Standard reference white for converting lab coordinates to
RGB coordinates for coloring clusters. One of either &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;E&quot;,
&quot;D50&quot;, &quot;D55&quot;, or &quot;D65&quot;.</p>
</td></tr>
<tr><td><code id="scatter3dclusters_+3A_xlim">xlim</code>, <code id="scatter3dclusters_+3A_ylim">ylim</code>, <code id="scatter3dclusters_+3A_zlim">zlim</code></td>
<td>
<p>X, Y, and Z-axis limits. If not specified, the defaults
are 0-1 for all channels in RGB and HSV space, or 0-100 for L and -100-100
for a and b channels of CIE Lab space.</p>
</td></tr>
<tr><td><code id="scatter3dclusters_+3A_main">main</code></td>
<td>
<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="scatter3dclusters_+3A_scaling">scaling</code></td>
<td>
<p>Scaling factor for size of clusters.</p>
</td></tr>
<tr><td><code id="scatter3dclusters_+3A_opacity">opacity</code></td>
<td>
<p>Transparency value for plotting; must be between 0 and 1.</p>
</td></tr>
<tr><td><code id="scatter3dclusters_+3A_plus">plus</code></td>
<td>
<p>Amount to add to percent column for plotting; can help to make
very small (or 0) clusters visible.</p>
</td></tr>
<tr><td><code id="scatter3dclusters_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to
<code><a href="scatterplot3d.html#topic+scatterplot3d">scatterplot3d</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plotClusters">plotClusters</a></code>, <code><a href="#topic+plotClustersMulti">plotClustersMulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clusters &lt;- data.frame(R = runif(20, min = 0, max = 1),
                       G = runif(20, min = 0, max = 1),
                       B = runif(20, min = 0, max = 1),
                       Pct = runif(20, min = 0, max = 1))
# plot in RGB space
scatter3dclusters(clusters, scaling = 15, plus = 0.05)

# overrule determined color space and plot in HSV space
scatter3dclusters(clusters, scaling = 15, plus = 0.05, color.space = "hsv")
</code></pre>

<hr>
<h2 id='weightedPairsDistance'>Distance between color clusters with user-specified color/size weights</h2><span id='topic+weightedPairsDistance'></span>

<h3>Description</h3>

<p>Distance metric with optional user input for specifying how much the bin size
similarity and color similarity should be weighted when pairing clusters from
different color cluster sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightedPairsDistance(
  T1,
  T2,
  ordering = FALSE,
  size.weight = 0.5,
  color.weight = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightedPairsDistance_+3A_t1">T1</code></td>
<td>
<p>Dataframe (especially a dataframe as returned by
<code>extractClusters</code> or <code>getImageHist</code>, but first three columns must
be coordinates).</p>
</td></tr>
<tr><td><code id="weightedPairsDistance_+3A_t2">T2</code></td>
<td>
<p>Another dataframe like T1.</p>
</td></tr>
<tr><td><code id="weightedPairsDistance_+3A_ordering">ordering</code></td>
<td>
<p>Logical. Should clusters by paired in order to minimize
overall distance scores or evaluated in the order given?</p>
</td></tr>
<tr><td><code id="weightedPairsDistance_+3A_size.weight">size.weight</code></td>
<td>
<p>Weight of size similarity in determining overall score and
ordering (if ordering=T).</p>
</td></tr>
<tr><td><code id="weightedPairsDistance_+3A_color.weight">color.weight</code></td>
<td>
<p>Weight of color similarity in determining overall score
and ordering (if ordering=T). Color and size weights do not necessarily
have to sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Similarity score based on size and color similarity of each pair of
points in provided dataframes.
</p>


<h3>Note</h3>

<p>Use with caution, since weights can easily swing distance scores more
dramatically than might be expected. For example, if <code>size.weight</code> = 1
and <code>color.weight</code> = 0, two clusters of identical color but different
sizes would not be compared.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cluster.list &lt;- colordistance::getKMeansList(system.file("extdata",
"Heliconius/Heliconius_B", package="colordistance"), lower=rep(0.8, 3),
upper=rep(1, 3))
cluster.list &lt;- colordistance::extractClusters(cluster.list, ordering=TRUE)
colordistance:::weightedPairsDistance(cluster.list[[1]], cluster.list[[2]],
size.weight=0.8, color.weight=0.2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
