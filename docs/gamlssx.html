<!DOCTYPE html><html><head><title>Help for package gamlssx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gamlssx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gamlssx-package'><p>gamlssx: Generalized Additive Extreme Value Models for Location, Scale and</p>
Shape</a></li>
<li><a href='#fitGEV'><p>Fit a Generalized Extreme value (GEV) GAMLSS Model</p></a></li>
<li><a href='#fremantle'><p>Annual Maximum Sea Levels at Fremantle, Western Australia</p></a></li>
<li><a href='#gamlssx-internal'><p>Internal gamlssx functions</p></a></li>
<li><a href='#GEV'><p>GEV family distribution for fitting a GAMLSS</p></a></li>
<li><a href='#gevExpInfo'><p>GEV Distribution Expected Information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Additive Extreme Value Models for Location, Scale
and Shape</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-25</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits generalized additive models for the location, scale and shape
    parameters of a generalized extreme value response distribution. The
    methodology is based on Rigby, R.A. and Stasinopoulos, D.M. (2005),
    &lt;<a href="https://doi.org/10.1111%2Fj.1467-9876.2005.00510.x">doi:10.1111/j.1467-9876.2005.00510.x</a>&gt; and implemented using functions from
    the 'gamlss' package &lt;<a href="https://doi.org/10.32614%2FCRAN.package.gamlss">doi:10.32614/CRAN.package.gamlss</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>gamlss, gamlss.dist, nieve, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paulnorthrop.github.io/gamlssx/">https://paulnorthrop.github.io/gamlssx/</a>,
<a href="https://github.com/paulnorthrop/gamlssx">https://github.com/paulnorthrop/gamlssx</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paulnorthrop/gamlssx/issues">https://github.com/paulnorthrop/gamlssx/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-25 13:19:36 UTC; Paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul J. Northrop [aut, cre, cph],
  Jennifer Ji [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul J. Northrop &lt;p.northrop@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-26 12:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='gamlssx-package'>gamlssx: Generalized Additive Extreme Value Models for Location, Scale and
Shape</h2><span id='topic+gamlssx'></span><span id='topic+gamlssx-package'></span>

<h3>Description</h3>

<p>Fits generalized additive models for the location, scale and shape
parameters of a generalized extreme value response distribution. The
methodology is based on Rigby and Stasinopoulos (2005) and implemented using
functions from the <code>gamlss</code> package <a href="https://doi.org/10.32614/CRAN.package.gamlss">doi:10.32614/CRAN.package.gamlss</a>.
</p>


<h3>Details</h3>

<p>The main function in <code>gamlssx</code> is <code><a href="#topic+fitGEV">fitGEV()</a></code>, which calls the
function <code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>.
See the <a href="https://paulnorthrop.github.io/gamlssx/">gamlssx package
page on Github</a> for more information.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paul J. Northrop <a href="mailto:p.northrop@ucl.ac.uk">p.northrop@ucl.ac.uk</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Jennifer Ji
</p>
</li></ul>



<h3>References</h3>

<p>Rigby R.A. and Stasinopoulos D.M. (2005). Generalized additive
models for location, scale and shape (with discussion), <em>Appl. Statist.</em>,
<strong>54</strong>, part 3, pages 507-554. <a href="https://doi.org/10.1111/j.1467-9876.2005.00510.x">doi:10.1111/j.1467-9876.2005.00510.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGEV">fitGEV()</a></code>, <code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>
</p>

<hr>
<h2 id='fitGEV'>Fit a Generalized Extreme value (GEV) GAMLSS Model</h2><span id='topic+fitGEV'></span>

<h3>Description</h3>

<p>Describe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGEV(
  formula,
  data,
  scoring = c("fisher", "quasi"),
  mu.link = "identity",
  sigma.link = "log",
  xi.link = "identity",
  stepLength = 1,
  stepAttempts = 2,
  stepReduce = 2,
  steps = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitGEV_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of an ~ operator, and the terms, separated by <code class="reqn">+</code> operators, on the right.
Nonparametric smoothing terms are indicated by <code>pb()</code> for penalised beta splines, <code>cs</code> for smoothing splines, <code>lo</code> for <code>loess</code> smooth terms and <code>random</code> or <code>ra</code>
for random terms, e.g. <code>y~cs(x,df=5)+x1+x2*x3</code>.  Additional smoothers can be added by creating the appropriate interface.
Interactions with nonparametric smooth terms are not fully supported, but will not produce errors;
they will simply produce the usual parametric interaction 
</p>
</td></tr>
<tr><td><code id="fitGEV_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables occurring in the formula, e.g. <code>data=aids</code>. If this is missing, the variables should be on the search list.</p>
</td></tr>
<tr><td><code id="fitGEV_+3A_scoring">scoring</code></td>
<td>
<p>A character scalar. If <code>scoring = "fisher"</code> then the weights
used in the fitting algorithm are based on the expected Fisher
information, that is, a Fisher's scoring algorithm is used.
If <code>scoring = "quasi"</code> then these weights are based on the cross products
of the first derivatives of the log-likelihood, leading to a quasi Newton
scoring algorithm.</p>
</td></tr>
<tr><td><code id="fitGEV_+3A_mu.link">mu.link</code>, <code id="fitGEV_+3A_sigma.link">sigma.link</code>, <code id="fitGEV_+3A_xi.link">xi.link</code></td>
<td>
<p>Character scalars to set the respective
link functions for the location (<code>mu</code>), scale (<code>sigma</code>) and shape (<code>xi</code>)
parameters. The latter is passed to <code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>
as <code>nu.link</code>.</p>
</td></tr>
<tr><td><code id="fitGEV_+3A_steplength">stepLength</code></td>
<td>
<p>A numeric vector of positive values. The initial
values of the step lengths <code>mu.step</code>, <code>sigma.step</code> and <code>nu.step</code> passed to
<code><a href="gamlss.html#topic+gamlss.control">gamlss::gamlss.control()</a></code> in the first attempt
to fit the model by calling <code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>. If
<code>stepLength</code> has a length that is less than 3 then <code>stepLength</code> is
recycled to have length 3.</p>
</td></tr>
<tr><td><code id="fitGEV_+3A_stepattempts">stepAttempts</code></td>
<td>
<p>A non-negative integer. If the first call to
<code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code> throws an error then we make
<code>stepAttempts</code> further attempts to fit the model, each time dividing by 2
the values of <code>mu.step</code>, <code>sigma.step</code> and <code>nu.step</code> supplied to
<code><a href="gamlss.html#topic+gamlss.control">gamlss::gamlss.control()</a></code>. If
<code>stepAttempts &lt; 1</code> then no further attempts are made.</p>
</td></tr>
<tr><td><code id="fitGEV_+3A_stepreduce">stepReduce</code></td>
<td>
<p>A number greater than 1. The factor by which the step
lengths in <code>stepLength</code> are reduced for each extra attempt to fit the
model. The default, <code>stepReduce = 2</code> means that the step lengths are
halved for each extra attempt.</p>
</td></tr>
<tr><td><code id="fitGEV_+3A_steps">steps</code></td>
<td>
<p>A logical scalar. Pass <code>steps = TRUE</code> to write to the
console the current value of <code>stepLength</code> for each call to
<code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>.</p>
</td></tr>
<tr><td><code id="fitGEV_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>, in particular <code>method</code>, which sets
the fitting algorithm, with options <code>RS()</code>, <code>CG()</code> or <code>mixed()</code>. The
default, <code>method = RS()</code> seems to work well, as does <code>method = mixed()</code>.
In contrast, <code>method = CG()</code> often requires the step length to be reduced
before convergence is achieved. <code>fitGEV()</code> attempts to do this
automatically. See <code>stepAttempts</code>. Pass <code>trace = FALSE</code>
(to <code><a href="gamlss.html#topic+gamlss.control">gamlss::gamlss.control()</a></code>) to avoid
writing to the console the global deviance after each outer iteration of
the gamlss fitting algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code> for information about
the model and the fitting algorithm.
</p>


<h3>Value</h3>

<p>Returns a <code>gamlss</code> object. See the <strong>Value</strong> section of
<code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>. The class of the returned object is
<code>c("gamlssx", "gamlss", "gam", "glm", "lm")</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GEV">GEV</a></code>,
<code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.dist::gamlss.family()</a></code>,
<code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load gamlss, for the function pb()
library(gamlss)

##### Simulated data

set.seed(17012023)
n &lt;- 100
x &lt;- stats::runif(n)
mu &lt;- 1 + 2 * x
sigma &lt;- 1
xi &lt;- 0.25
y &lt;- nieve::rGEV(n = 1, loc = mu, scale = sigma, shape = xi)
data &lt;- data.frame(y = as.numeric(y), x = x)
plot(x, y)

# Fit model using the default RS method with Fisher's scoring
mod &lt;- fitGEV(y ~ gamlss::pb(x), data = data)
# Summary of model fit
summary(mod)
# Residual diagnostic plots
plot(mod, xlab = "x", ylab = "y")
# Data plus fitted curve
plot(data$x, data$y, xlab = "x", ylab = "y")
lines(data$x, fitted(mod))

# Fit model using the mixed method and quasi-Newton scoring
# Use trace = FALSE to prevent writing the global deviance to the console
mod &lt;- fitGEV(y ~ pb(x), data = data, method = mixed(), scoring = "quasi",
              trace = FALSE)

# Fit model using the CG method
# The default step length of 1 needs to be reduced to enable convergence
# Use steps = TRUE to write the step lengths to the console
mod &lt;- fitGEV(y ~ pb(x), data = data, method = CG(), steps = TRUE)

##### Fremantle annual maximum sea levels
##### See also the gamlssx package README file

# Transform Year so that it is centred on 0
fremantle &lt;- transform(fremantle, cYear = Year - median(Year))

# Plot sea level against year and against SOI
plot(fremantle$Year, fremantle$SeaLevel, xlab = "year", ylab = "sea level (m)")
plot(fremantle$SOI, fremantle$SeaLevel, xlab = "SOI", ylab = "sea level (m)")

# Fit a model with P-spline effects of cYear and SOI on location and scale
# The default links are identity for location and log for scale
mod &lt;- fitGEV(SeaLevel ~ pb(cYear) + pb(SOI),
             sigma.formula = ~ pb(cYear) + pb(SOI),
             data = fremantle)

# Summary of model fit
summary(mod)
# Model diagnostic plots
plot(mod)
# Worm plot
wp(mod)
# Plot of the fitted component smooth functions
# Note: gamlss::term.plot() does not include uncertainty about the intercept
# Location mu
term.plot(mod, rug = TRUE, pages = 1)
# Scale sigma
term.plot(mod, what = "sigma", rug = TRUE, pages = 1)
</code></pre>

<hr>
<h2 id='fremantle'>Annual Maximum Sea Levels at Fremantle, Western Australia</h2><span id='topic+fremantle'></span>

<h3>Description</h3>

<p>This is a copy of the <code>fremantle</code> dataset from the <code>ismev</code> package.
The <code>fremantle</code> data frame has 86 rows and 3 columns. The second column
gives 86 annual maximum sea levels recorded at Fremantle, Western
Australia, within the period 1897 to 1989. The first column gives the
corresponding years. The third column gives annual mean values of the
Southern Oscillation Index (SOI), which is a proxy for meteorological
volatility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fremantle
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following:
</p>

<ul>
<li><p> Year: A numeric vector of years.
</p>
</li>
<li><p> SeaLevel: A numeric vector of annual sea level maxima.
</p>
</li>
<li><p> SOI: A numeric vector of annual mean values of the Southern
Oscillation Index.
</p>
</li></ul>



<h3>Source</h3>

<p>Coles, S. G. (2001) An Introduction to Statistical Modelling of
Extreme Values. London: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(fremantle)
</code></pre>

<hr>
<h2 id='gamlssx-internal'>Internal gamlssx functions</h2><span id='topic+gamlssx-internal'></span><span id='topic+EulersConstant'></span><span id='topic+AperysConstant'></span><span id='topic+pxi'></span><span id='topic+qxi'></span><span id='topic+gev22e0Fn'></span><span id='topic+gev22e0Constant'></span><span id='topic+gev22eFn'></span><span id='topic+gev33e0Fn'></span><span id='topic+gev33e0Constant'></span><span id='topic+gev33eFn'></span><span id='topic+gev12e0Fn'></span><span id='topic+gev12e0Constant'></span><span id='topic+gev12eFn'></span><span id='topic+gev13e0Fn'></span><span id='topic+gev13e0Constant'></span><span id='topic+gev13eFn'></span><span id='topic+gev23e0Fn'></span><span id='topic+gev23e0Constant'></span><span id='topic+gev23eFn'></span><span id='topic+gevExpInfoComp'></span><span id='topic+lagrangianInterpolation'></span>

<h3>Description</h3>

<p>Internal gamlssx functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EulersConstant

AperysConstant

pxi(xi)

qxi(xi)

gev22e0Fn()

gev22e0Constant

gev22eFn(xi)

gev33e0Fn()

gev33e0Constant

gev33eFn(xi)

gev12e0Fn()

gev12e0Constant

gev12eFn(xi)

gev13e0Fn()

gev13e0Constant

gev13eFn(xi)

gev23e0Fn()

gev23e0Constant

gev23eFn(xi)

gevExpInfoComp(fun, fun0, xi, eps = 0.003)

lagrangianInterpolation(x0, y0)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>
<p>An object of class <code>numeric</code> of length 1.
</p>


<h3>Details</h3>

<p>These functions are not intended to be called by the user.
</p>

<hr>
<h2 id='GEV'>GEV family distribution for fitting a GAMLSS</h2><span id='topic+GEV'></span><span id='topic+GEVfisher'></span><span id='topic+GEVquasi'></span><span id='topic+dGEV'></span><span id='topic+pGEV'></span><span id='topic+qGEV'></span><span id='topic+rGEV'></span>

<h3>Description</h3>

<p>The functions <code>GEVfisher()</code> and <code>GEVquasi()</code> each define the generalized
extreme value (GEV) family distribution, a three parameter distribution, for
a <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.dist::gamlss.family()</a></code> object to
be used in GAMLSS fitting using the function
<code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>. The only difference
between <code>GEVfisher()</code> and <code>GEVquasi()</code> is the form of scoring method used to
define the weights used in the fitting algorithm. Fisher's scoring,
based on the expected Fisher information is used in <code>GEVfisher()</code>, whereas
a quasi-Newton scoring, based on the cross products of the first derivatives
of the log-likelihood, is used in <code>GEVquasi()</code>. The functions
<code>dGEV</code>, <code>pGEV</code>, <code>qGEV</code> and <code>rGEV</code> define the density, distribution function,
quantile function and random generation for the specific parameterization of
the generalized extreme value distribution given in <strong>Details</strong> below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEVfisher(mu.link = "identity", sigma.link = "log", nu.link = "identity")

GEVquasi(mu.link = "identity", sigma.link = "log", nu.link = "identity")

dGEV(x, mu = 0, sigma = 1, nu = 0, log = FALSE)

pGEV(q, mu = 0, sigma = 1, nu = 0, lower.tail = TRUE, log.p = FALSE)

qGEV(p, mu = 0, sigma = 1, nu = 0, lower.tail = TRUE, log.p = FALSE)

rGEV(n, mu = 0, sigma = 1, nu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEV_+3A_mu.link">mu.link</code></td>
<td>
<p>Defines the <code>mu.link</code>, with <code>"identity"</code> link as the default
for the <code>mu</code> parameter.</p>
</td></tr>
<tr><td><code id="GEV_+3A_sigma.link">sigma.link</code></td>
<td>
<p>Defines the <code>sigma.link</code>, with <code>"log"</code> link as the default
for the <code>sigma</code> parameter.</p>
</td></tr>
<tr><td><code id="GEV_+3A_nu.link">nu.link</code></td>
<td>
<p>Defines the <code>nu.link</code>, with <code>"identity"</code> link as the default
for the <code>nu</code> parameter.</p>
</td></tr>
<tr><td><code id="GEV_+3A_x">x</code>, <code id="GEV_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="GEV_+3A_mu">mu</code>, <code id="GEV_+3A_sigma">sigma</code>, <code id="GEV_+3A_nu">nu</code></td>
<td>
<p>Vectors of location, scale and shape parameter values.</p>
</td></tr>
<tr><td><code id="GEV_+3A_log">log</code>, <code id="GEV_+3A_log.p">log.p</code></td>
<td>
<p>Logical. If <code>TRUE</code>, probabilities <code style="white-space: pre;">&#8288;eqn{p}&#8288;</code> are given as
<code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), probabilities are
<code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="GEV_+3A_n">n</code></td>
<td>
<p>Number of observations. If <code>length(n) &gt; 1</code>, the length is taken to
be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution function of a GEV distribution with parameters
<code>loc</code> = <code class="reqn">\mu</code>, <code>scale</code> = <code class="reqn">\sigma (&gt; 0)</code> and
<code>shape</code> = <code class="reqn">\xi</code> (<code class="reqn">= \nu</code>) is
</p>
<p style="text-align: center;"><code class="reqn">F(x) = P(X \leq x) = \exp\left\{ -\left[ 1+\xi\left(\frac{x-\mu}{\sigma}\right)
  \right]_+^{-1/\xi} \right\},</code>
</p>

<p>where <code class="reqn">x_+ = \max(x, 0)</code>. If <code class="reqn">\xi = 0</code> the
distribution function is defined as the limit as <code class="reqn">\xi</code> tends to zero.
The support of the distribution depends on <code class="reqn">\xi</code>: it is
<code class="reqn">x \leq \mu - \sigma / \xi</code> for <code class="reqn">\xi &lt; 0</code>;
<code class="reqn">x \geq \mu - \sigma / \xi</code> for <code class="reqn">\xi &gt; 0</code>;
and <code class="reqn">x</code> is unbounded for <code class="reqn">\xi = 0</code>.
See
<a href="https://en.wikipedia.org/wiki/Generalized_extreme_value_distribution">https://en.wikipedia.org/wiki/Generalized_extreme_value_distribution</a>
and/or Chapter 3 of Coles (2001) for further information.
</p>
<p>For each observation in the data, the restriction that <code class="reqn">\xi &gt; -1/2</code> is
imposed, which is necessary for the usual asymptotic likelihood theory to be
applicable.
</p>


<h3>Value</h3>

<p><code>GEVfisher()</code> and <code>GEVquasi()</code> each return a
<code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.dist::gamlss.family()</a></code> object
which can be used to fit a regression model with a GEV response
distribution using the
<code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code> function. <code>dGEV()</code> gives the density,
<code>pGEV()</code> gives the distribution function, <code>qGEV()</code> gives the quantile
function, and <code>rGEV()</code> generates random deviates.
</p>


<h3>Examples</h3>

<p>See the examples in <code><a href="#topic+fitGEV">fitGEV()</a></code>.
</p>


<h3>References</h3>

<p>Coles, S. G. (2001) <em>An Introduction to Statistical
Modeling of Extreme Values</em>, Springer-Verlag, London.
Chapter 3: <a href="https://doi.org/10.1007/978-1-4471-3675-0_3">doi:10.1007/978-1-4471-3675-0_3</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGEV">fitGEV</a></code>,
<code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.dist::gamlss.family()</a></code>,
<code><a href="gamlss.html#topic+gamlss">gamlss::gamlss()</a></code>
</p>

<hr>
<h2 id='gevExpInfo'>GEV Distribution Expected Information</h2><span id='topic+gevExpInfo'></span><span id='topic+gev11e'></span><span id='topic+gev22e'></span><span id='topic+gev33e'></span><span id='topic+gev12e'></span><span id='topic+gev13e'></span><span id='topic+gev23e'></span>

<h3>Description</h3>

<p>Calculates the expected information matrix for the GEV distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev11e(scale, shape)

gev22e(scale, shape, eps = 0.003)

gev33e(shape, eps = 0.003)

gev12e(scale, shape, eps = 0.003)

gev13e(scale, shape, eps = 0.003)

gev23e(scale, shape, eps = 0.003)

gevExpInfo(scale, shape, eps = 0.003)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gevExpInfo_+3A_scale">scale</code>, <code id="gevExpInfo_+3A_shape">shape</code></td>
<td>
<p>Numeric vectors. Respective values of the GEV parameters
scale parameter <code class="reqn">\sigma</code> and shape parameter <code class="reqn">\xi</code>. For
<code>gevExpInfo</code>, <code>scale</code> and <code>shape</code> must have length 1.</p>
</td></tr>
<tr><td><code id="gevExpInfo_+3A_eps">eps</code></td>
<td>
<p>A numeric scalar. For values of <code class="reqn">\xi</code> in <code>shape</code> that lie in
<code style="white-space: pre;">&#8288;(-eps, eps)&#8288;</code> an approximation is used instead of a direct calculation.
See <strong>Details</strong>. If <code>eps</code> is a vector then only the first element is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gevExpInfo</code> calculates, for single pair of values
<code class="reqn">(\sigma, \xi) = </code> <code style="white-space: pre;">&#8288;(scale, shape)&#8288;</code>, the expected information matrix for a
single observation from a GEV distribution with distribution function
</p>
<p style="text-align: center;"><code class="reqn">F(x) = P(X \leq x) = \exp\left\{ -\left[ 1+\xi\left(\frac{x-\mu}{\sigma}\right)
  \right]_+^{-1/\xi} \right\},</code>
</p>

<p>where <code class="reqn">x_+ = \max(x, 0)</code>.
The GEV expected information is defined only for <code class="reqn">\xi &gt; -0.5</code> and does
not depend on the value of <code class="reqn">\mu</code>.
</p>
<p>The other functions are vectorized and calculate the individual
contributions to the expected information matrix. For example, <code>gev11e</code>
calculates the expectation <code class="reqn">i_{\mu\mu}</code> of the negated second
derivative of the GEV log-density with respect to <code class="reqn">\mu</code>, that is, each
<code>1</code> indicates one derivative with respect to <code class="reqn">\mu</code>. Similarly, <code>2</code>
denotes one derivative with respect to <code class="reqn">\sigma</code> and <code>3</code> one derivative
with respect to <code class="reqn">\xi</code>, so that, for example, <code>gev23e</code> calculates the
expectation <code class="reqn">i_{\sigma\xi}</code> of the negated GEV log-density after one
taking one derivative with respect to <code class="reqn">\sigma</code> and one derivative with
respect to <code class="reqn">\xi</code>. Note that <code class="reqn">i_{\xi\xi}</code>, calculated using
<code>gev33e</code>, depends only on <code class="reqn">\xi</code>.
</p>
<p>The expectation in <code>gev11e</code> can be calculated in a direct way for all
<code class="reqn">\xi &gt; -0.5</code>. For the other components, direct calculation of the
expectation is unstable when <code class="reqn">\xi</code> is close to 0. Instead, we use
a quadratic approximation over <code style="white-space: pre;">&#8288;(-eps, eps)&#8288;</code>, from a Lagrangian
interpolation of the values from the direct calculation for <code class="reqn">\xi = </code>
<code>-eps</code>, <code class="reqn">0</code> and <code>eps</code>.
</p>


<h3>Value</h3>

<p><code>gevExpInfo</code> returns a 3 by 3 numeric matrix with row and column
named <code style="white-space: pre;">&#8288;loc, scale, shape&#8288;</code>. The other functions return a numeric vector of
length equal to the maximum of the lengths of the arguments, excluding
<code>eps</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Expected information matrices for ...
# ... scale = 2 and shape = -0.4
gevExpInfo(2, -0.4)
# ... scale = 3 and shape = 0.001
gevExpInfo(3, 0.001)
# ... scale = 3 and shape = 0
gevExpInfo(3, 0)
# ... scale = 1 and shape = 0.1
gevExpInfo(1, 0.1)

# The individual components of the latter matrix
gev11e(1, 0.1)
gev12e(1, 0.1)
gev13e(1, 0.1)
gev22e(1, 0.1)
gev23e(1, 0.1)
gev33e(0.1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
