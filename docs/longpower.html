<!DOCTYPE html><html><head><title>Help for package longpower</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {longpower}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#longpower-package'><p>longpower: Sample Size Calculations for Longitudinal Data</p></a></li>
<li><a href='#diggle.linear.power'><p>Sample size calculations for difference in slopes between two groups.</p></a></li>
<li><a href='#edland.linear.power'><p>Linear mixed model sample size calculations.</p></a></li>
<li><a href='#hu.mackey.thomas.linear.power'><p>Random coefficient regression models (RCRM) sample size calculations</p></a></li>
<li><a href='#liu.liang.linear.power'><p>Linear mixed model sample size calculations from Liu &amp; Liang (1997).</p></a></li>
<li><a href='#lmmpower'><p>Sample size calculations for linear mixed models of rate of change based on</p>
lmer, lme, or gee &quot;placebo&quot; pilot estimates.</a></li>
<li><a href='#power.longtest'><p>Constructor function for class <code>"power.longtest"</code></p></a></li>
<li><a href='#power.mmrm'><p>Linear mixed model sample size calculations.</p></a></li>
<li><a href='#power.mmrm.ar1'><p>Linear mixed model sample size calculations.</p></a></li>
<li><a href='#print.power.longtest'><p>Print method for longitudinal data power calculation object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sample Size Calculations for Longitudinal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.25</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute power and sample size for linear models of longitudinal
    data. Supported models include mixed-effects models and models fit by
    generalized least squares and generalized estimating equations. The package
    is described in Iddi and Donohue (2022) &lt;<a href="https://doi.org/10.32614%2FRJ-2022-022">doi:10.32614/RJ-2022-022</a>&gt;. Relevant
    formulas are derived by Liu and Liang (1997) &lt;<a href="https://doi.org/10.2307%2F2533554">doi:10.2307/2533554</a>&gt;, 
    Diggle et al (2002) &lt;ISBN:9780199676750&gt;, and Lu, Luo, and Chen (2008)
    &lt;<a href="https://doi.org/10.2202%2F1557-4679.1098">doi:10.2202/1557-4679.1098</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), lme4 (&ge; 1.0), nlme</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gee, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mcdonohue/longpower">https://github.com/mcdonohue/longpower</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'longpower-package.R' 'diggle.linear.power.R'
'edland.linear.power.R' 'liu.liang.linear.power.R'
'hu.mackey.thomas.linear.power.R' 'lmmpower.R' 'power_mmrm.R'
'print.power.longtest.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-24 00:27:07 UTC; mdonohue</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael C. Donohue [aut, cre],
  Steve D. Edland [ctb],
  Nan Hu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael C. Donohue &lt;mdonohue@usc.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 04:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='longpower-package'>longpower: Sample Size Calculations for Longitudinal Data</h2><span id='topic+longpower'></span><span id='topic+longpower-package'></span>

<h3>Description</h3>

<p>Compute power and sample size for linear models of longitudinal data. Supported models include mixed-effects models and models fit by generalized least squares and generalized estimating equations. The package is described in Iddi and Donohue (2022) <a href="https://doi.org/10.32614/RJ-2022-022">doi:10.32614/RJ-2022-022</a>. Relevant formulas are derived by Liu and Liang (1997) <a href="https://doi.org/10.2307/2533554">doi:10.2307/2533554</a>, Diggle et al (2002) &lt;ISBN:9780199676750&gt;, and Lu, Luo, and Chen (2008) <a href="https://doi.org/10.2202/1557-4679.1098">doi:10.2202/1557-4679.1098</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael C. Donohue <a href="mailto:mdonohue@usc.edu">mdonohue@usc.edu</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Steve D. Edland <a href="mailto:sedland@health.ucsd.edu">sedland@health.ucsd.edu</a> [contributor]
</p>
</li>
<li><p> Nan Hu <a href="mailto:hu.nan@gene.com">hu.nan@gene.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mcdonohue/longpower">https://github.com/mcdonohue/longpower</a>
</p>
</li></ul>


<hr>
<h2 id='diggle.linear.power'>Sample size calculations for difference in slopes between two groups.</h2><span id='topic+diggle.linear.power'></span>

<h3>Description</h3>

<p>This function performs the sample size calculation for difference in slopes 
between two groups. See Diggle, et al (2002) and package vignette for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diggle.linear.power(
  n = NULL,
  delta = NULL,
  t = NULL,
  sigma2 = 1,
  R = NULL,
  sig.level = 0.05,
  power = NULL,
  alternative = c("two.sided", "one.sided"),
  tol = .Machine$double.eps^2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diggle.linear.power_+3A_n">n</code></td>
<td>
<p>sample size per group</p>
</td></tr>
<tr><td><code id="diggle.linear.power_+3A_delta">delta</code></td>
<td>
<p>group difference in slopes</p>
</td></tr>
<tr><td><code id="diggle.linear.power_+3A_t">t</code></td>
<td>
<p>the observation times</p>
</td></tr>
<tr><td><code id="diggle.linear.power_+3A_sigma2">sigma2</code></td>
<td>
<p>the residual variance</p>
</td></tr>
<tr><td><code id="diggle.linear.power_+3A_r">R</code></td>
<td>
<p>the working correlation matrix (or variance-covariance matrix if
<code>sigma2</code> is 1). If <code>R</code> is a scalar, an exchangeable working
correlation matrix will be assumed.</p>
</td></tr>
<tr><td><code id="diggle.linear.power_+3A_sig.level">sig.level</code></td>
<td>
<p>Type I error</p>
</td></tr>
<tr><td><code id="diggle.linear.power_+3A_power">power</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="diggle.linear.power_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="diggle.linear.power_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of subject required per arm to attain the specified
<code>power</code> given <code>sig.level</code> and the other parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Michael C. Donohue, Steven D. Edland
</p>


<h3>References</h3>

<p>Diggle P.J., Heagerty P.J., Liang K., Zeger S.L. (2002)
<em>Analysis of longitudinal data</em>. Second Edition. Oxford Statistical
Science Series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmmpower">lmmpower</a></code>, <code><a href="#topic+diggle.linear.power">diggle.linear.power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
browseVignettes(package = "longpower")

## End(Not run)

# Reproduces the table on page 29 of Diggle et al
n &lt;- 3
t &lt;- c(0,2,5)
rho &lt;- c(0.2, 0.5, 0.8)
sigma2 &lt;- c(100, 200, 300)
tab &lt;- outer(rho, sigma2, 
      Vectorize(function(rho, sigma2){
        ceiling(diggle.linear.power(
          delta=0.5,
          t=t,
          sigma2=sigma2,
          R=rho,
          alternative="one.sided",
          power = 0.80)$n[1])}))
colnames(tab) &lt;- paste("sigma2 =", sigma2)
rownames(tab) &lt;- paste("rho =", rho)
tab

# An Alzheimer's Disease example using ADAS-cog pilot estimates
# var of random intercept
sig2.i &lt;- 55
# var of random slope
sig2.s &lt;- 24
# residual var
sig2.e &lt;- 10
# covariance of slope and intercep
cov.s.i &lt;- 0.8*sqrt(sig2.i)*sqrt(sig2.s)

cov.t &lt;- function(t1, t2, sig2.i, sig2.s, cov.s.i){
        sig2.i + t1*t2*sig2.s + (t1+t2)*cov.s.i 
}

t &lt;- seq(0,1.5,0.25)
n &lt;- length(t)
R &lt;- outer(t, t, function(x,y){cov.t(x,y, sig2.i, sig2.s, cov.s.i)})
R &lt;- R + diag(sig2.e, n, n)

diggle.linear.power(d=1.5, t=t, R=R, sig.level=0.05, power=0.80)

</code></pre>

<hr>
<h2 id='edland.linear.power'>Linear mixed model sample size calculations.</h2><span id='topic+edland.linear.power'></span>

<h3>Description</h3>

<p>This function performs sample size calculations for the linear mixed model
with random intercepts and slopes when used to test for differences in fixed
effects slope between groups. Input parameters are random effect variance
and residual error variance as estimated by a REML fit to representative
pilot data or data from a representative prior clinical trial or cohort
study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edland.linear.power(
  n = NULL,
  delta = NULL,
  power = NULL,
  t = NULL,
  lambda = 1,
  sig2.int = 0,
  sig2.s = NULL,
  sig.b0b1 = 0,
  sig2.e = NULL,
  sig2.int_2 = NULL,
  sig2.s_2 = NULL,
  sig.b0b1_2 = NULL,
  sig2.e_2 = NULL,
  sig.level = 0.05,
  p = NULL,
  p_2 = NULL,
  alternative = c("two.sided", "one.sided"),
  tol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edland.linear.power_+3A_n">n</code></td>
<td>
<p>sample size, group 1</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_delta">delta</code></td>
<td>
<p>group difference in fixed effect slopes</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_power">power</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_t">t</code></td>
<td>
<p>the observation times</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_lambda">lambda</code></td>
<td>
<p>allocation ratio (sample size group 1 divided by sample size group 2)</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_sig2.int">sig2.int</code></td>
<td>
<p>variance of random intercepts, group 1</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_sig2.s">sig2.s</code></td>
<td>
<p>variance of random slopes, group 1</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_sig.b0b1">sig.b0b1</code></td>
<td>
<p>covariance of random slopes and intercepts,group 1</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_sig2.e">sig2.e</code></td>
<td>
<p>residual variance, group 1</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_sig2.int_2">sig2.int_2</code></td>
<td>
<p>variance of random intercepts, group 2 (defaults to <code>sig2.int</code>)</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_sig2.s_2">sig2.s_2</code></td>
<td>
<p>variance of random slopes, group 2 (defaults to <code>sig2.s</code>)</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_sig.b0b1_2">sig.b0b1_2</code></td>
<td>
<p>covariance of random slopes and intercepts, group 2 (defaults to <code>sig.b0b1</code>)</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_sig2.e_2">sig2.e_2</code></td>
<td>
<p>residual variance, group 2 (defaults to <code>sig2.e</code>)</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_sig.level">sig.level</code></td>
<td>
<p>type one error</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_p">p</code></td>
<td>
<p>proportion vector for group 1, if i indexes visits, <code>p[i]</code> = the proportion whose last visit was at visit <code>i</code> (<code>p</code> sums to <code>1</code>)</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_p_2">p_2</code></td>
<td>
<p>proportion vector for group 2 (defaults to <code>p</code>)</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="edland.linear.power_+3A_tol">tol</code></td>
<td>
<p>not used (no root finding used in this implementation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default settings perform sample size / power / effect size calculations assuming
equal covariance of repeated measures in the 2 groups, equal residual error
variance across groups, equal allocation to groups, and assuming no study subject
attrition.  Specifically, variance parameters required for default settings
are <code>sig2.s</code>, the variance of random slopes, and <code>sig2.e</code>, the residual error
variance, both either known or estimated from a mixed model fit by REML
to prior data.
</p>
<p>This function will also provide sample size estimates for linear mixed
models with random intercept only by setting <code>sig2.s = 0</code>  (although,
this is not generally recommended).
</p>
<p>This function was generalized April 2020. The function is back compatible,
although the order of arguments has changed. The new function accommodates
different variance parameters across groups, unequal allocation across groups, and
study subject attrition (loss to followup), which may also vary across groups.
</p>

<ul>
<li><p> Unequal allocation is accommodated by the parameter <code>lambda</code>, where
<code>lambda</code> = (sample size group 1)/(sample size group 2). <code>lambda</code> defaults
to one (equal allocation).
</p>
</li>
<li><p> Study subject attrition is accommodated by the parameter '<code>p</code>', where
<code>p</code> is a vector of proportions.  If <code>i</code> indexes successive study visits,
<code>p[i]</code> = the proportion whose last visit is at visit <code>i</code>. <code>p</code> sums to 1. <code>p</code>
defaults to the case of no study subject attrition (everyone completes
all visits).
</p>
</li>
<li><p> differential study subject attrition is accommodated by the parameter <code>p_2</code>.
<code>p_2</code> is analogous to <code>p</code>, but for group 2. <code>p_2</code> defaults to <code>p</code> (equal pattern
of study subject attrition across groups).
</p>
</li>
<li><p> Note that when there is study subject attrition, sample size / power
calculations are also a function of the variance of random intercepts and
the covariance of random intercepts and slopes.  When <code>p</code> and/or <code>p_2</code> are
specified, <code>edland.linear.power</code> requires specification of these parameters.
(These are part of the standard output of lmer and other software fitting
REML models.)  These parameters are specified by <code>sig2.int</code> and <code>sig.b0b1</code> (group 1),
and <code>sig2.int_2</code> and <code>sigb0b1_2</code> (group 2).
</p>
</li>
<li><p> different variance parameters across groups is accommodated by the variance
arguments <code>sig2.int_2</code>, <code>sig.b0b1_2</code>, <code>sig2.s</code>_2 and <code>sig2.e_2</code>, analogous to the
the corresponding arguments within group 1.  These values default to
to the corresponding group 1 variables (equal variance across groups).
</p>
</li>
<li><p> The parameter <code>t</code> is the design vector. For example, a one year trial with
observations every three months would specify <code>t = c(0, .25, .5, .75, 1)</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>One of the number of subject required per arm, the <code>power</code>, or detectable effect size
given <code>sig.level</code> and the other parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Michael C. Donohue, Steven D. Edland
</p>


<h3>References</h3>

<p>Ard and Edland, S.D. (2011) Power calculations for clinical trials in Alzheimer's disease.
<em>Journal of Alzheimer's Disease.</em> 21:369-377.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmmpower">lmmpower</a></code>, <code><a href="#topic+diggle.linear.power">diggle.linear.power</a></code>, <code><a href="#topic+liu.liang.linear.power">liu.liang.linear.power</a></code>, <code><a href="#topic+hu.mackey.thomas.linear.power">hu.mackey.thomas.linear.power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
browseVignettes(package = "longpower")

## End(Not run)
# An Alzheimer's Disease example using ADAS-cog pilot estimates
t &lt;- seq(0,1.5,0.25)
edland.linear.power(delta=1.5, t=t, sig2.s = 24, sig2.e = 10, sig.level=0.05, power = 0.80)

</code></pre>

<hr>
<h2 id='hu.mackey.thomas.linear.power'>Random coefficient regression models (RCRM) sample size calculations</h2><span id='topic+hu.mackey.thomas.linear.power'></span>

<h3>Description</h3>

<p>This function computes sample size and power needed for the random coefficient
regression models (RCRM) based on the formula from Hu, Mackey, and Thomas (2021).
The RCRM assumes that the experimental and control arms have the same
population baseline value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hu.mackey.thomas.linear.power(
  n = NULL,
  delta = NULL,
  power = NULL,
  t = NULL,
  lambda = 1,
  sig2.i = 0,
  cor.s.i = NULL,
  sig2.s = 0,
  sig2.e = NULL,
  p = NULL,
  sig.level = 0.05,
  alternative = c("two.sided", "one.sided"),
  tol = .Machine$double.eps^2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_n">n</code></td>
<td>
<p>sample size, group 1. This formula can accommodate unbalanced
group allocation via <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_delta">delta</code></td>
<td>
<p>Effect size (absolute difference in rate of decline between tx and placebo)</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_power">power</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_t">t</code></td>
<td>
<p>Vector of visit time points (including time 0)</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_lambda">lambda</code></td>
<td>
<p>allocation ratio (sample size group 1 divided by sample size group 2)</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_sig2.i">sig2.i</code></td>
<td>
<p>Variance of random intercept</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_cor.s.i">cor.s.i</code></td>
<td>
<p>Correlation between random intercept &amp; slope</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_sig2.s">sig2.s</code></td>
<td>
<p>Variance of random slope</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_sig2.e">sig2.e</code></td>
<td>
<p>Variance of pure error</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_p">p</code></td>
<td>
<p>proportion vector for both groups; if <code>i</code> indexes visits, <code>p[i]</code> = the
proportion whose last visit was at visit <code>i</code> (<code>p</code> sums to 1)</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_sig.level">sig.level</code></td>
<td>
<p>type one error</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="hu.mackey.thomas.linear.power_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Hu. Mackey, and Thomas (2021) for parameter details.
</p>
<p>See Equations (7) and (8) in Hu, Mackey, and Thomas (2021)
</p>


<h3>Value</h3>

<p>One of the number of subject required per arm, the <code>power</code>, or
detectable effect size given <code>sig.level</code> and the other parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Monarch Shah
</p>


<h3>References</h3>

<p>Hu, N., Mackey, H., &amp; Thomas, R. (2021). Power and sample size
for random coefficient regression models in randomized experiments with
monotone missing data. <em>Biometrical Journal</em>, 63(4), 806-824.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmmpower">lmmpower</a></code>, <code><a href="#topic+diggle.linear.power">diggle.linear.power</a></code>, <code><a href="#topic+liu.liang.linear.power">liu.liang.linear.power</a></code>, <code><a href="#topic+edland.linear.power">edland.linear.power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
browseVignettes(package = "longpower")

## End(Not run)
# An Alzheimer's Disease example using ADAS-cog pilot estimates
t &lt;- seq(0,1.5,0.25)
p &lt;- c(rep(0, 6),1)

hu.mackey.thomas.linear.power(delta=1.5, t=t, 
  sig2.s=24, sig2.e=10, cor.s.i=0.5, p=p, power=0.80)
hu.mackey.thomas.linear.power(n=180, t=t, 
  sig2.s=24, sig2.e=10, cor.s.i=0.5, p=p, power=0.80)
hu.mackey.thomas.linear.power(n=180, delta=1.5, t=t, 
  sig2.s=24, sig2.e=10, cor.s.i=0.5, p=p)

hu.mackey.thomas.linear.power(delta=1.5, t=t, lambda=2, 
  sig2.s=24, sig2.e=10, cor.s.i=0.5, p=p, power=0.80)
hu.mackey.thomas.linear.power(n=270, t=t, lambda=2, 
  sig2.s=24, sig2.e=10, cor.s.i=0.5, p=p, power=0.80)
hu.mackey.thomas.linear.power(n=270, delta=1.5, t=t, lambda=2, 
  sig2.s=24, sig2.e=10, p=p, cor.s.i=0.5)

hu.mackey.thomas.linear.power(delta=1.5, t=t, 
  sig2.s=24, sig2.e=10, cor.s.i=0.5, p=p, power=0.80, alternative='one.sided')
hu.mackey.thomas.linear.power(n=142, t=t, 
  sig2.s=24, sig2.e=10, cor.s.i=0.5, p=p, power=0.80, alternative='one.sided')
hu.mackey.thomas.linear.power(n=142, delta=1.5, t=t, 
  sig2.s=24, sig2.e=10, cor.s.i=0.5, p=p, sig.level=0.05, alternative='one.sided')

</code></pre>

<hr>
<h2 id='liu.liang.linear.power'>Linear mixed model sample size calculations from Liu &amp; Liang (1997).</h2><span id='topic+liu.liang.linear.power'></span>

<h3>Description</h3>

<p>This function performs the sample size calculation for a linear mixed model.
See Liu and Liang (1997) for parameter definitions and other details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liu.liang.linear.power(
  N = NULL,
  delta = NULL,
  u = NULL,
  v = NULL,
  sigma2 = 1,
  R = NULL,
  R.list = NULL,
  sig.level = 0.05,
  power = NULL,
  Pi = rep(1/length(u), length(u)),
  alternative = c("two.sided", "one.sided"),
  tol = .Machine$double.eps^2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="liu.liang.linear.power_+3A_n">N</code></td>
<td>
<p>The total sample size. This formula can accommodate unbalanced
group allocation via <code>Pi</code>. See Liu and Liang (1997) for more details</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_delta">delta</code></td>
<td>
<p>group difference (possibly a vector of differences)</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_u">u</code></td>
<td>
<p>a list of covariate vectors or matrices associated with the
parameter of interest</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_v">v</code></td>
<td>
<p>a respective list of covariate vectors or matrices associated with
the nuisance parameter</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_sigma2">sigma2</code></td>
<td>
<p>the error variance</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_r">R</code></td>
<td>
<p>the variance-covariance matrix for the repeated measures</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_r.list">R.list</code></td>
<td>
<p>a list of variance-covariance matrices for the repeated
measures, if assumed different in two groups</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_sig.level">sig.level</code></td>
<td>
<p>type one error</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_power">power</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_pi">Pi</code></td>
<td>
<p>the proportion of covariates of each type</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="liu.liang.linear.power_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>u</code>, <code>v</code>, and <code>Pi</code> are expected to be the same
length and sorted with respect to each other. See Liu and Liang (1997) and
package vignette for more details.
</p>


<h3>References</h3>

<p>Liu, G. and Liang, K. Y. (1997) Sample size calculations for
studies with correlated observations. <em>Biometrics</em>, 53(3), 937-47.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmmpower">lmmpower</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
browseVignettes(package = "longpower")

## End(Not run)

# Reproduces the table on page 29 of Diggle et al for
# difference in slopes between groups

n &lt;- 3
t &lt;- c(0,2,5)
u &lt;- list(u1 = t, u2 = rep(0,n))
v &lt;- list(v1 = cbind(1,1,t),
         v2 = cbind(1,0,t))         
rho &lt;- c(0.2, 0.5, 0.8)
sigma2 &lt;- c(100, 200, 300)
tab &lt;- outer(rho, sigma2, 
      Vectorize(function(rho, sigma2){
        ceiling(liu.liang.linear.power(
          delta=0.5, u=u, v=v,
          sigma2=sigma2,
          R=rho, alternative="one.sided",
          power=0.80)$N/2)}))
colnames(tab) &lt;- paste("sigma2 =", sigma2)
rownames(tab) &lt;- paste("rho =", rho)
tab

# Reproduces the table on page 30 of Diggle et al for 
# difference in average response between groups.

n &lt;- 3
u &lt;- list(u1 = rep(1,n), u2 = rep(0,n))
v &lt;- list(v1 = rep(1,n),
         v2 = rep(1,n))
rho &lt;- c(0.2, 0.5, 0.8)
delta &lt;- c(20, 30, 40, 50)/100
tab &lt;- outer(rho, delta, 
     Vectorize(function(rho, delta){
       ceiling(liu.liang.linear.power(
         delta=delta, u=u, v=v,
         sigma2=1,
         R=rho, alternative="one.sided",
         power=0.80)$n[1])}))
colnames(tab) &lt;- paste("delta =", delta)
rownames(tab) &lt;- paste("rho =", rho)
tab

# An Alzheimer's Disease example using ADAS-cog pilot estimates
# var of random intercept
sig2.i &lt;- 55
# var of random slope
sig2.s &lt;- 24
# residual var
sig2.e &lt;- 10
# covariance of slope and intercep
cov.s.i &lt;- 0.8*sqrt(sig2.i)*sqrt(sig2.s)

cov.t &lt;- function(t1, t2, sig2.i, sig2.s, cov.s.i){
        sig2.i + t1*t2*sig2.s + (t1+t2)*cov.s.i 
}

t &lt;- seq(0,1.5,0.25)
n &lt;- length(t)
R &lt;- outer(t, t, function(x,y){cov.t(x,y, sig2.i, sig2.s, cov.s.i)})
R &lt;- R + diag(sig2.e, n, n)
u &lt;- list(u1 = t, u2 = rep(0,n))
v &lt;- list(v1 = cbind(1,1,t),
         v2 = cbind(1,0,t))         

liu.liang.linear.power(delta=1.5, u=u, v=v, R=R, sig.level=0.05, power=0.80)
liu.liang.linear.power(N=416, u=u, v=v, R=R, sig.level=0.05, power=0.80)
liu.liang.linear.power(N=416, delta = 1.5, u=u, v=v, R=R, sig.level=0.05)
liu.liang.linear.power(N=416, delta = 1.5, u=u, v=v, R=R, power=0.80, sig.level = NULL)

# Reproduces total sample sizes, m, of Table 1 of Liu and Liang 1997
tab1 &lt;- data.frame(cbind(
  n = c(rep(4, 4), rep(2, 4), 1),
  rho = c(0.0, 0.3, 0.5, 0.8)))
m &lt;- c()
for(i in 1:nrow(tab1)){
  R &lt;- matrix(tab1$rho[i], nrow = tab1$n[i], ncol = tab1$n[i])
  diag(R) &lt;- 1
  m &lt;- c(m, ceiling(liu.liang.linear.power(
    delta=0.5,
    u = list(u1 = rep(1, tab1$n[i]), # treatment
             u2 = rep(0, tab1$n[i])), # control       
    v = list(v1 = rep(1, tab1$n[i]), v2 = rep(1, tab1$n[i])), # intercept
    sigma2=1,
    R=R, alternative="two.sided",
    power=0.90)$N))
}
cbind(tab1, m)

# Reproduces total sample sizes, m, of Table 3.a. of Liu and Liang 1997
# with unbalanced design
tab3 &lt;- data.frame(cbind(
  rho = rep(c(0.0, 0.3, 0.5, 0.8), 2),
  pi1 = c(rep(0.8, 4), rep(0.2, 4))))
m &lt;- c()
for(i in 1:nrow(tab3)){
  R &lt;- matrix(tab3$rho[i], nrow = 4, ncol = 4)
  diag(R) &lt;- 1
  m &lt;- c(m, ceiling(liu.liang.linear.power(
    delta=0.5,
    u = list(u1 = rep(1, 4), # treatment
             u2 = rep(0, 4)), # control       
    v = list(v1 = rep(1, 4), v2 = rep(1, 4)), # intercept
    sigma2=1,
    Pi = c(tab3$pi1[i], 1-tab3$pi1[i]),
    R=R, alternative="two.sided",
    power=0.90)$N))
}
cbind(tab3, m)

</code></pre>

<hr>
<h2 id='lmmpower'>Sample size calculations for linear mixed models of rate of change based on
lmer, lme, or gee &quot;placebo&quot; pilot estimates.</h2><span id='topic+lmmpower'></span><span id='topic+lmmpower.default'></span><span id='topic+lmmpower-methods'></span><span id='topic+lmmpower+2CANY-method'></span><span id='topic+lmmpower+2CmerMod-method'></span><span id='topic+lmmpower.lme'></span><span id='topic+lmmpower.gee'></span><span id='topic+lmmpower.numeric'></span><span id='topic+lmmpower.double'></span>

<h3>Description</h3>

<p>These functions compute sample size for linear mixed models based on the
formula due to Diggle (2002) or Liu and Liang (1997).  These formulae are
expressed in terms of marginal model or Generalized Estimating Equations
(GEE) parameters.  These functions translate pilot mixed effect model
parameters (e.g. random intercept and/or slope, fixed effects, etc.)  into
marginal model parameters so that either formula can be applied to
equivalent affect. Pilot estimates are assumed to be from an appropriate
&quot;placebo&quot; group and the parameter of interest is assumed to be the rate of
change over time of the outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
lmmpower(
  object = NULL,
  n = NULL,
  parameter = 2,
  pct.change = NULL,
  delta = NULL,
  t = NULL,
  sig.level = 0.05,
  power = NULL,
  alternative = c("two.sided", "one.sided"),
  beta = NULL,
  beta.CI = NULL,
  delta.CI = NULL,
  sig2.i = NULL,
  sig2.s = NULL,
  sig2.e = NULL,
  cov.s.i = NULL,
  cor.s.i = NULL,
  R = NULL,
  p = NULL,
  method = c("diggle", "liuliang", "edland", "hu"),
  tol = .Machine$double.eps^2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmmpower_+3A_object">object</code></td>
<td>
<p>an object returned by lme4</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_n">n</code></td>
<td>
<p>sample size per group
of a mixed-effects model object to placebo data assumed to have either a
random intercept, or a random intercept and random effect for time (slope);
and fixed effect representing the rate of change in a placebo group.</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_parameter">parameter</code></td>
<td>
<p>the name or position
of the rate of change parameter of interest, e.g. (<code>"time"</code>,
<code>"t"</code>, or <code>2</code> if it is the second specified fixed effect).</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_pct.change">pct.change</code></td>
<td>
<p>the percent change
in the pilot estimate of the parameter of interest (<code>beta</code>, the
placebo/null effect)</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_delta">delta</code></td>
<td>
<p>the change in the pilot estimate
of the parameter of interest, computed from <code>pct.change</code> if left
missing.</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_t">t</code></td>
<td>
<p>vector of time points</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_sig.level">sig.level</code></td>
<td>
<p>Type I error</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_power">power</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_alternative">alternative</code></td>
<td>
<p><code>"two.sided"</code> or <code>"one.sided"</code></p>
</td></tr>
<tr><td><code id="lmmpower_+3A_beta">beta</code></td>
<td>
<p>pilot estimate of the placebo
effect (slope or rate of change in the outcome)</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_beta.ci">beta.CI</code></td>
<td>
<p>95% confidence limits of
the pilot estimate of beta</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_delta.ci">delta.CI</code></td>
<td>
<p>95% confidence limits of
the effect size</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_sig2.i">sig2.i</code></td>
<td>
<p>pilot estimate of variance
of random intercept</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_sig2.s">sig2.s</code></td>
<td>
<p>pilot estimate of variance
of random slope</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_sig2.e">sig2.e</code></td>
<td>
<p>pilot estimate of residual
variance</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_cov.s.i">cov.s.i</code></td>
<td>
<p>pilot estimate of
covariance of random slope and intercept</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_cor.s.i">cor.s.i</code></td>
<td>
<p>pilot estimate of
correlation of random slope and intercept</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_r">R</code></td>
<td>
<p>pilot estimate of a marginal
model working correlation matrix</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_p">p</code></td>
<td>
<p>proportion vector for both groups; if i indexes visits, p[i] = the 
proportion whose last visit was at visit i (p sums to 1)</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_method">method</code></td>
<td>
<p>the formula to use. Defaults
to <code>"diggle"</code> for Diggle et al (2002). Alternatively <code>"liuliang"</code>
can be selected for Liu &amp; Liang (1997), <code>"edland"</code> for Ard &amp; Edland (2011), 
or <code>"hu"</code> for Hu, Mackey &amp; Thomas (2021).</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding.</p>
</td></tr>
<tr><td><code id="lmmpower_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any parameters not explicitly stated are extracted from the fitted
<code>object</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>power.htest</code> giving the calculated sample
size, N, per group and other parameters.
</p>


<h3>Author(s)</h3>

<p>Michael C. Donohue
</p>


<h3>References</h3>

<p>Diggle P.J., Heagerty P.J., Liang K., Zeger S.L. (2002)
<em>Analysis of longitudinal data</em>. Second Edition. Oxford Statistical
Science Series.
</p>
<p>Liu, G., and Liang, K. Y. (1997) Sample size calculations for studies with
correlated observations. <em>Biometrics</em>, 53(3), 937-47.
</p>
<p>Ard, C. and Edland, S.D. (2011) Power calculations for clinical trials in Alzheimer's disease. 
<em>Journal of Alzheimer's Disease.</em> 21:369-377. 
</p>
<p>Hu, N., Mackey, H., &amp; Thomas, R. (2021). Power and sample size
for random coefficient regression models in randomized experiments with
monotone missing data. <em>Biometrical Journal</em>, 63(4), 806-824.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+liu.liang.linear.power">liu.liang.linear.power</a></code>,
<code><a href="#topic+diggle.linear.power">diggle.linear.power</a></code>, <code><a href="#topic+edland.linear.power">edland.linear.power</a></code>,
<code><a href="#topic+hu.mackey.thomas.linear.power">hu.mackey.thomas.linear.power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
browseVignettes(package = "longpower")

## End(Not run)

lmmpower(delta=1.5, t = seq(0,1.5,0.25),
	sig2.i = 55, sig2.s = 24, sig2.e = 10, cov.s.i=0.8*sqrt(55)*sqrt(24), power = 0.80)
lmmpower(n=208, t = seq(0,1.5,0.25),
	sig2.i = 55, sig2.s = 24, sig2.e = 10, cov.s.i=0.8*sqrt(55)*sqrt(24), power = 0.80)
lmmpower(beta = 5, pct.change = 0.30, t = seq(0,1.5,0.25),
	sig2.i = 55, sig2.s = 24, sig2.e = 10, cov.s.i=0.8*sqrt(55)*sqrt(24), power = 0.80)

## Not run: 
library(lme4)
fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
lmmpower(fm1, pct.change = 0.30, t = seq(0,9,1), power = 0.80)

library(nlme)
fm2 &lt;- lme(Reaction ~ Days, random=~Days|Subject, sleepstudy)
lmmpower(fm2, pct.change = 0.30, t = seq(0,9,1), power = 0.80)

# random intercept only
fm3 &lt;- lme(Reaction ~ Days, random=~1|Subject, sleepstudy)
lmmpower(fm3, pct.change = 0.30, t = seq(0,9,1), power = 0.80)

library(gee)
fm4 &lt;- gee(Reaction ~ Days, id = Subject,
            data = sleepstudy,
            corstr = "exchangeable")
lmmpower(fm4, pct.change = 0.30, t = seq(0,9,1), power = 0.80)

## End(Not run)

</code></pre>

<hr>
<h2 id='power.longtest'>Constructor function for class <code>"power.longtest"</code></h2><span id='topic+power.longtest'></span>

<h3>Description</h3>

<p>Constructor function for class <code>"power.longtest"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.longtest(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.longtest_+3A_object">object</code></td>
<td>
<p>a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"power.longtest"</code>
</p>

<hr>
<h2 id='power.mmrm'>Linear mixed model sample size calculations.</h2><span id='topic+power.mmrm'></span>

<h3>Description</h3>

<p>This function performs the sample size calculation for a mixed model of
repeated measures with general correlation structure. See Lu, Luo, &amp; Chen
(2008) for parameter definitions and other details. This function executes
Formula (3) on page 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.mmrm(
  N = NULL,
  Ra = NULL,
  ra = NULL,
  sigmaa = NULL,
  Rb = NULL,
  rb = NULL,
  sigmab = NULL,
  lambda = 1,
  delta = NULL,
  sig.level = 0.05,
  power = NULL,
  alternative = c("two.sided", "one.sided"),
  tol = .Machine$double.eps^2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.mmrm_+3A_n">N</code></td>
<td>
<p>total sample size</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_ra">Ra</code></td>
<td>
<p>correlation matrix for group a</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_ra">ra</code></td>
<td>
<p>retention in group a</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_sigmaa">sigmaa</code></td>
<td>
<p>standard deviation of observation of interest in group a</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_rb">Rb</code></td>
<td>
<p>correlation matrix for group a</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_rb">rb</code></td>
<td>
<p>retention in group b</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_sigmab">sigmab</code></td>
<td>
<p>standard deviation of observation of interest in group b. If
NULL, <code>sigmab</code> is assumed same as <code>sigmaa</code>. If not NULL,
<code>sigmaa</code> and <code>sigmab</code> are averaged.</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_lambda">lambda</code></td>
<td>
<p>allocation ratio</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_delta">delta</code></td>
<td>
<p>effect size</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_sig.level">sig.level</code></td>
<td>
<p>type one error</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_power">power</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="power.mmrm_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Lu, Luo, &amp; Chen (2008).
</p>


<h3>Value</h3>

<p>The number of subject required per arm to attain the specified
<code>power</code> given <code>sig.level</code> and the other parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Michael C. Donohue
</p>


<h3>References</h3>

<p>Lu, K., Luo, X., Chen, P.-Y. (2008) Sample size estimation for
repeated measures analysis in randomized clinical trials with missing data.
<em>International Journal of Biostatistics</em>, 4, (1)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+power.mmrm.ar1">power.mmrm.ar1</a></code>, <code><a href="#topic+lmmpower">lmmpower</a></code>,
<code><a href="#topic+diggle.linear.power">diggle.linear.power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# reproduce Table 1 from Lu, Luo, &amp; Chen (2008)
phi1 &lt;- c(rep(1, 6), 2, 2)
phi2 &lt;- c(1, 1, rep(2, 6))
lambda &lt;- c(1, 2, sqrt(1/2), 1/2, 1, 2, 1, 2)
ztest &lt;- ttest1 &lt;- c()
for(i in 1:8){
  Na &lt;- (phi1[i] + lambda[i] * phi2[i])*(qnorm(0.05/2) + qnorm(1-0.90))^2*(0.5^-2)
  Nb &lt;- Na/lambda[i]
  ztest &lt;- c(ztest, Na + Nb)
  v &lt;- Na + Nb - 2
  Na &lt;- (phi1[i] + lambda[i] * phi2[i])*(qt(0.05/2, df = v) + qt(1-0.90, df = v))^2*(0.5^-2)
  Nb &lt;- Na/lambda[i]
  ttest1 &lt;- c(ttest1, Na + Nb)
}
data.frame(phi1, phi2, lambda, ztest, ttest1)

Ra &lt;- matrix(0.25, nrow = 4, ncol = 4)
diag(Ra) &lt;- 1
ra &lt;- c(1, 0.90, 0.80, 0.70)
sigmaa &lt;- 1
power.mmrm(Ra = Ra, ra = ra, sigmaa = sigmaa, delta = 0.5, power = 0.80)
power.mmrm(N = 174, Ra = Ra, ra = ra, sigmaa = sigmaa, delta = 0.5)
power.mmrm(N = 174, Ra = Ra, ra = ra, sigmaa = sigmaa, power = 0.80)

power.mmrm(Ra = Ra, ra = ra, sigmaa = sigmaa, delta = 0.5, power = 0.80, lambda = 2)
power.mmrm(N = 174, Ra = Ra, ra = ra, sigmaa = sigmaa, delta = 0.5, lambda = 2)
power.mmrm(N = 174, Ra = Ra, ra = ra, sigmaa = sigmaa, power = 0.80, lambda = 2)

# Extracting paramaters from gls objects with general correlation

# Create time index:
Orthodont$t.index &lt;- as.numeric(factor(Orthodont$age, levels = c(8, 10, 12, 14)))
with(Orthodont, table(t.index, age))

fmOrth.corSym &lt;- gls( distance ~ Sex * I(age - 11), 
  Orthodont,
  correlation = corSymm(form = ~ t.index | Subject),
  weights = varIdent(form = ~ 1 | age) )
summary(fmOrth.corSym)$tTable

C &lt;- corMatrix(fmOrth.corSym$modelStruct$corStruct)[[1]]
sigmaa &lt;- fmOrth.corSym$sigma * 
          coef(fmOrth.corSym$modelStruct$varStruct, unconstrained = FALSE)['14']
ra &lt;- seq(1,0.80,length=nrow(C))
power.mmrm(N=100, Ra = C, ra = ra, sigmaa = sigmaa, power = 0.80)

# Extracting paramaters from gls objects with compound symmetric correlation

fmOrth.corCompSymm &lt;- gls( distance ~ Sex * I(age - 11), 
  Orthodont,
  correlation = corCompSymm(form = ~ t.index | Subject),
  weights = varIdent(form = ~ 1 | age) )
summary(fmOrth.corCompSymm)$tTable

C &lt;- corMatrix(fmOrth.corCompSymm$modelStruct$corStruct)[[1]]
sigmaa &lt;- fmOrth.corCompSymm$sigma *
          coef(fmOrth.corCompSymm$modelStruct$varStruct, unconstrained = FALSE)['14']
ra &lt;- seq(1,0.80,length=nrow(C))
power.mmrm(N=100, Ra = C, ra = ra, sigmaa = sigmaa, power = 0.80)

# Extracting paramaters from gls objects with AR1 correlation

fmOrth.corAR1 &lt;- gls( distance ~ Sex * I(age - 11), 
  Orthodont,
  correlation = corAR1(form = ~ t.index | Subject),
  weights = varIdent(form = ~ 1 | age) )
summary(fmOrth.corAR1)$tTable

C &lt;- corMatrix(fmOrth.corAR1$modelStruct$corStruct)[[1]]
sigmaa &lt;- fmOrth.corAR1$sigma *
          coef(fmOrth.corAR1$modelStruct$varStruct, unconstrained = FALSE)['14']
ra &lt;- seq(1,0.80,length=nrow(C))
power.mmrm(N=100, Ra = C, ra = ra, sigmaa = sigmaa, power = 0.80)
power.mmrm.ar1(N=100, rho = C[1,2], ra = ra, sigmaa = sigmaa, power = 0.80)

</code></pre>

<hr>
<h2 id='power.mmrm.ar1'>Linear mixed model sample size calculations.</h2><span id='topic+power.mmrm.ar1'></span>

<h3>Description</h3>

<p>This function performs the sample size calculation for a mixed model of
repeated measures with AR(1) correlation structure. See Lu, Luo, &amp; Chen
(2008) for parameter definitions and other details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.mmrm.ar1(
  N = NULL,
  rho = NULL,
  ra = NULL,
  sigmaa = NULL,
  rb = NULL,
  sigmab = NULL,
  lambda = 1,
  times = 1:length(ra),
  delta = NULL,
  sig.level = 0.05,
  power = NULL,
  alternative = c("two.sided", "one.sided"),
  tol = .Machine$double.eps^2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.mmrm.ar1_+3A_n">N</code></td>
<td>
<p>total sample size</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_rho">rho</code></td>
<td>
<p>AR(1) correlation parameter</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_ra">ra</code></td>
<td>
<p>retention in group a</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_sigmaa">sigmaa</code></td>
<td>
<p>standard deviation of observation of interest in group a</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_rb">rb</code></td>
<td>
<p>retention in group a (assumed same as <code>ra</code> if left blank)</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_sigmab">sigmab</code></td>
<td>
<p>standard deviation of observation of interest in group b. If
NULL, <code>sigmab</code> is assumed same as <code>sigmaa</code>. If not NULL,
<code>sigmaa</code> and <code>sigmab</code> are averaged.</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_lambda">lambda</code></td>
<td>
<p>allocation ratio</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_times">times</code></td>
<td>
<p>observation times</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_delta">delta</code></td>
<td>
<p>effect size</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_sig.level">sig.level</code></td>
<td>
<p>type one error</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_power">power</code></td>
<td>
<p>power</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_alternative">alternative</code></td>
<td>
<p>one- or two-sided test</p>
</td></tr>
<tr><td><code id="power.mmrm.ar1_+3A_tol">tol</code></td>
<td>
<p>numerical tolerance used in root finding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Lu, Luo, &amp; Chen (2008).
</p>


<h3>Value</h3>

<p>The number of subject required per arm to attain the specified
<code>power</code> given <code>sig.level</code> and the other parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Michael C. Donohue
</p>


<h3>References</h3>

<p>Lu, K., Luo, X., Chen, P.-Y. (2008) Sample size estimation for
repeated measures analysis in randomized clinical trials with missing data.
<em>International Journal of Biostatistics</em>, 4, (1)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+power.mmrm">power.mmrm</a></code>, <code><a href="#topic+lmmpower">lmmpower</a></code>,
<code><a href="#topic+diggle.linear.power">diggle.linear.power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# reproduce Table 2 from Lu, Luo, &amp; Chen (2008)
tab &lt;- c()
for(J in c(2,4))
for(aJ in (1:4)/10)
for(p1J in c(0, c(1, 3, 5, 7, 9)/10)){
  rJ &lt;- 1-aJ
  r &lt;- seq(1, rJ, length = J)
  # p1J = p^(J-1)
  tab &lt;- c(tab, power.mmrm.ar1(rho = p1J^(1/(J-1)), ra = r, sigmaa = 1, 
    lambda = 1, times = 1:J,
    delta = 1, sig.level = 0.05, power = 0.80)$phi1)
}
matrix(tab, ncol = 6, byrow = TRUE)

# approximate simulation results from Table 5 from Lu, Luo, &amp; Chen (2008)
ra &lt;- c(100, 76, 63, 52)/100
rb &lt;- c(100, 87, 81, 78)/100

power.mmrm.ar1(rho=0.6, ra=ra, sigmaa=1, rb = rb, 
               lambda = sqrt(1.25/1.75), power = 0.904, delta = 0.9)
power.mmrm.ar1(rho=0.6, ra=ra, sigmaa=1, rb = rb, 
               lambda = 1.25/1.75, power = 0.910, delta = 0.9)
power.mmrm.ar1(rho=0.6, ra=ra, sigmaa=1, rb = rb, 
               lambda = 1, power = 0.903, delta = 0.9)
power.mmrm.ar1(rho=0.6, ra=ra, sigmaa=1, rb = rb,
               lambda = 2, power = 0.904, delta = 0.9)

power.mmrm.ar1(N=81, ra=ra, sigmaa=1, rb = rb, 
               lambda = sqrt(1.25/1.75), power = 0.904, delta = 0.9)
power.mmrm.ar1(N=87, rho=0.6, ra=ra, sigmaa=1, rb = rb,
               lambda = 1.25/1.75, power = 0.910)
power.mmrm.ar1(N=80, rho=0.6, ra=ra, sigmaa=1, rb = rb, 
               lambda = 1, delta = 0.9)
power.mmrm.ar1(N=84, rho=0.6, ra=ra, sigmaa=1, rb = rb,
               lambda = 2, power = 0.904, delta = 0.9, sig.level = NULL)

# Extracting paramaters from gls objects with AR1 correlation

# Create time index:
Orthodont$t.index &lt;- as.numeric(factor(Orthodont$age, levels = c(8, 10, 12, 14)))
with(Orthodont, table(t.index, age))

fmOrth.corAR1 &lt;- gls( distance ~ Sex * I(age - 11), 
  Orthodont,
  correlation = corAR1(form = ~ t.index | Subject),
  weights = varIdent(form = ~ 1 | age) )
summary(fmOrth.corAR1)$tTable

C &lt;- corMatrix(fmOrth.corAR1$modelStruct$corStruct)[[1]]
sigmaa &lt;- fmOrth.corAR1$sigma *
          coef(fmOrth.corAR1$modelStruct$varStruct, unconstrained = FALSE)['14']
ra &lt;- seq(1,0.80,length=nrow(C))
power.mmrm(N=100, Ra = C, ra = ra, sigmaa = sigmaa, power = 0.80)
power.mmrm.ar1(N=100, rho = C[1,2], ra = ra, sigmaa = sigmaa, power = 0.80)

</code></pre>

<hr>
<h2 id='print.power.longtest'>Print method for longitudinal data power calculation object</h2><span id='topic+print.power.longtest'></span>

<h3>Description</h3>

<p>Print object of class <code>"power.longtest"</code> in nice layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'power.longtest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.power.longtest_+3A_x">x</code></td>
<td>
<p>Object of class <code>"power.longtest"</code>.</p>
</td></tr>
<tr><td><code id="print.power.longtest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>power.longtest</code> object is just a named list of numbers and character
strings, supplemented with <code>method</code> and <code>note</code> elements.  The
<code>method</code> is displayed as a title, the <code>note</code> as a footnote, and
the remaining elements are given in an aligned &lsquo;name = value&rsquo; format.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>See Also</h3>

<p><code><a href="#topic+liu.liang.linear.power">liu.liang.linear.power</a></code>,
<code><a href="#topic+diggle.linear.power">diggle.linear.power</a></code>, <code><a href="#topic+lmmpower">lmmpower</a></code>,
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
