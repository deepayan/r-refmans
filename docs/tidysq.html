<!DOCTYPE html><html><head><title>Help for package tidysq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidysq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidysq-package'><p>tidysq: tidy analysis of biological sequences</p></a></li>
<li><a href='#%has%'><p>Test sq object for presence of given motifs</p></a></li>
<li><a href='#==.sq'><p>Compare sq objects</p></a></li>
<li><a href='#alphabet'><p>Get alphabet of given sq object.</p></a></li>
<li><a href='#as.character.sq'><p>Convert sq object into character vector</p></a></li>
<li><a href='#as.matrix.sq'><p>Convert sq object into matrix</p></a></li>
<li><a href='#as.sq'><p>Convert an object to sq</p></a></li>
<li><a href='#bite'><p>Subset sequences from sq objects</p></a></li>
<li><a href='#collapse'><p>Collapse multiple sequences into one</p></a></li>
<li><a href='#complement'><p>Create complement sequence from dnasq or rnasq object</p></a></li>
<li><a href='#export_sq'><p>Export sq objects into other formats</p></a></li>
<li><a href='#find_invalid_letters'><p>Find elements which are not suitable for specified type.</p></a></li>
<li><a href='#find_motifs'><p>Find given motifs</p></a></li>
<li><a href='#get_sq_lengths'><p>Get lengths of sequences in sq object</p></a></li>
<li><a href='#get_standard_alphabet'><p>Get standard alphabet for given type.</p></a></li>
<li><a href='#get_tidysq_options'><p>Obtain current state of tidysq options</p></a></li>
<li><a href='#import_sq'><p>Import sq objects from other objects</p></a></li>
<li><a href='#is_empty_sq'><p>Test if sequence is empty</p></a></li>
<li><a href='#is.sq'><p>Check if object has specified type</p></a></li>
<li><a href='#paste'><p>Paste sequences in string-like fashion</p></a></li>
<li><a href='#random_sq'><p>Generate random sequences</p></a></li>
<li><a href='#read_fasta'><p>Read a FASTA file</p></a></li>
<li><a href='#remove_ambiguous'><p>Remove sequences that contain ambiguous elements</p></a></li>
<li><a href='#remove_na'><p>Remove sequences that contain NA values</p></a></li>
<li><a href='#reverse'><p>Reverse sequence</p></a></li>
<li><a href='#sq'><p>Construct sq object from character vector</p></a></li>
<li><a href='#sq_type'><p>Get type of an sq object</p></a></li>
<li><a href='#sq-class'><p>sq: class for keeping biological sequences tidy</p></a></li>
<li><a href='#sqapply'><p>Apply function to each sequence</p></a></li>
<li><a href='#sqconcatenate'><p>Concatenate sq objects</p></a></li>
<li><a href='#sqextract'><p>Extract parts of a sq object</p></a></li>
<li><a href='#sqprint'><p>Print sq object</p></a></li>
<li><a href='#substitute_letters'><p>Substitute letters in a sequence</p></a></li>
<li><a href='#translate'><p>Convert DNA or RNA into proteins using genetic code</p></a></li>
<li><a href='#typify'><p>Set type of an sq object</p></a></li>
<li><a href='#write_fasta'><p>Save sq to fasta file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tidy Processing and Analysis of Biological Sequences</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-29</td>
</tr>
<tr>
<td>Description:</td>
<td>A tidy approach to analysis of biological sequences. All processing and data-storage functions are heavily optimized to allow the fastest and most efficient data storage.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 1.9.0), cli (&ge; 2.0.0), crayon (&ge; 1.3.4), dplyr
(&ge; 1.0.2), pillar (&ge; 1.4.2), Rcpp (&ge; 1.0.1), tibble (&ge;
2.1.3), vctrs (&ge; 0.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape (&ge; 5.3), bioseq (&ge; 0.1.2), Biostrings (&ge; 2.52.0),
covr, knitr, lifecycle, purrr, seqinr (&ge; 3.4-5), spelling,
rmarkdown, testthat (&ge; 3.0.0), withr (&ge; 2.2.0), rlang, mockr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/BioGenies/tidysq">https://github.com/BioGenies/tidysq</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/BioGenies/tidysq/issues">https://github.com/BioGenies/tidysq/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, C++17</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-30 09:36:20 UTC; rafaczd</td>
</tr>
<tr>
<td>Author:</td>
<td>Dominik Rafacz <a href="https://orcid.org/0000-0003-0925-1909"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Michal Burdukiewicz
    <a href="https://orcid.org/0000-0001-8926-582X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Laura Bakala [aut],
  Leon Eyrich Jessen
    <a href="https://orcid.org/0000-0003-2879-2559"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Stefan Roediger <a href="https://orcid.org/0000-0002-1441-6512"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jadwiga Slowik <a href="https://orcid.org/0000-0003-3466-8933"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Weronika Puchala <a href="https://orcid.org/0000-0003-2163-1429"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Katarzyna Sidorczuk [ctb],
  Filip Pietluch [ctb],
  Jaroslaw Chilimoniuk
    <a href="https://orcid.org/0000-0001-5467-018X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominik Rafacz &lt;dominikrafacz@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-31 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidysq-package'>tidysq: tidy analysis of biological sequences</h2><span id='topic+tidysq-package'></span><span id='topic+tidysq'></span>

<h3>Description</h3>

<p>The <code>tidysq</code> package is a toolbox for the analysis of 
biological sequences in a tidy way.
</p>


<h3>Author(s)</h3>

<p>Michal Burdukiewicz, Dominik Rafacz, Laura Bąkała, Leon Eyrich Jessen
</p>

<hr>
<h2 id='+25has+25'>Test sq object for presence of given motifs</h2><span id='topic++25has+25'></span>

<h3>Description</h3>

<p>Tests if elements of a <code><a href="#topic+sq-class">sq</a></code> object
contain given motifs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %has% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25has+2B25_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="+2B25has+2B25_+3A_y">y</code></td>
<td>
<p>[<code>character</code>]<br />
Motifs to be searched for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows testing if elements of a <code>sq</code> object contain the
given motif or motifs. It returns a <code>logical</code> value for every element
of the <code>sq</code> object - <code>TRUE</code> if tested sequence contains searched
motif and <code>FALSE</code> otherwise. When multiple motifs are searched,
<code>TRUE</code> will be returned only for sequences that contain all given
motifs.
</p>
<p>This function only indicates if a motif is present within a sequence, to find
all motifs and their positions within sequences use
<code><a href="#topic+find_motifs">find_motifs</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+logical">logical</a></code> vector of the same length as input <code>sq</code>,
indicating which elements contain all given motifs.
</p>


<h3>Motif capabilities and restrictions</h3>

<p>There are more options than to simply create a motif that is a string
representation of searched subsequence. For example, when using this function
with any of standard types, i.e. <strong>ami</strong>, <strong>dna</strong> or <strong>rna</strong>,
the user can create a motif with ambiguous letters. In this case the engine
will try to match any of possible meanings of this letter. For example, take
&quot;B&quot; from extended DNA alphabet. It means &quot;not A&quot;, so it can be matched with
&quot;C&quot;, &quot;G&quot; and &quot;T&quot;, but also &quot;B&quot;, &quot;Y&quot; (either &quot;C&quot; or &quot;T&quot;), &quot;K&quot; (either &quot;G&quot; or
&quot;T&quot;) and &quot;S&quot; (either &quot;C&quot; or &quot;G&quot;).
</p>
<p>Full list of ambiguous letters with their meaning can be found on IUPAC site.
</p>
<p>Motifs are also restricted in that the alphabets of <code>sq</code> objects on
which search operations are conducted cannot contain &quot;^&quot; and &quot;$&quot; symbols.
These two have a special meaning - they are used to indicate beginning and
end of sequence respectively and can be used to limit the position of matched
subsequences.
</p>


<h3>See Also</h3>

<p>Functions interpreting sq in biological context:
<code><a href="#topic+complement">complement</a>()</code>,
<code><a href="#topic+find_motifs">find_motifs</a>()</code>,
<code><a href="#topic+translate">translate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGNBAACGAN", "TGACGAGCTTAG"),
             alphabet = "dna_bsc")
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_atp &lt;- sq(c("mAmYmY", "nbAnsAmA", ""),
             alphabet = c("mA", "mY", "nbA", "nsA"))

# Testing if DNA sequences contain motif "ATG":
sq_dna %has% "ATG"

# Testing if DNA sequences begin with "ATG":
sq_dna %has% "^ATG"

# Testing if DNA sequences end with "TAG" (one of the stop codons):
sq_dna %has% "TAG$"

# Test if amino acid sequences contain motif of two alanines followed by
# aspartic acid or asparagine ("AAB" motif matches "AAB", "AAD" and "AAN"):
sq_ami %has% "AAB"

# Test if amino acid sequences contain both motifs:
sq_ami %has% c("AAXG", "MAT")

# Test for sequences with multicharacter alphabet:
sq_atp %has% c("nsA", "mYmY$")

</code></pre>

<hr>
<h2 id='+3D+3D.sq'>Compare sq objects</h2><span id='topic++3D+3D.sq'></span>

<h3>Description</h3>

<p>Compares input <code><a href="#topic+sq-class">sq</a></code> object with either
another <code>sq</code> object or <code>character</code> vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sq'
e1 == e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B3D+2B3D.sq_+3A_e1">e1</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this comparison is applied to.</p>
</td></tr>
<tr><td><code id="+2B3D+2B3D.sq_+3A_e2">e2</code></td>
<td>
<p>[<code>sq</code> || <code>character</code>]<br />
An object to compare with <code>x1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>`==`</code> compares compatible object for equality of their respective
sequences. Objects are considered compatible, when either both have same
length or one of them is a scalar value (i.e. a vector of length 1).
Moreover, not every <code>e1</code> sq type can be compared to any <code>e2</code> sq
type.
</p>
<p>To see which types are compatible, see Details of
<code><a href="#topic+sq-concatenate">sq-concatenate</a></code>.
</p>
<p><code>`==`</code> returns logical vector, where each element describes whether
elements at position <code>n</code> of both <code>e1</code> and <code>e2</code> are equal in
meaning (that is, they may be represented differently, but their biological
interpretation must be identical). If one of compared objects is a scalar,
then said logical vector describes comparison for each element of the other,
longer vector.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+logical">logical</a></code> vector indicating on which positions these
objects are equal.
</p>


<h3>See Also</h3>

<p>Functions from utility module:
<code><a href="#topic+get_sq_lengths">get_sq_lengths</a>()</code>,
<code><a href="#topic+is.sq">is.sq</a>()</code>,
<code><a href="#topic+sqconcatenate">sqconcatenate</a></code>,
<code><a href="#topic+sqextract">sqextract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna_1 &lt;- sq(c("ACTGCTG", "CTTAGA", "CCCT", "CTGAATGT"),
               alphabet = "dna_bsc")
sq_dna_2 &lt;- sq(c("ACTGCTG", "CTTAGA", "CCCT", "CTGAATGT"),
               alphabet = "dna_bsc")
sq_dna_3 &lt;- sq(c("ACTGCTG", "CTTAGA", "GGAA"),
               alphabet = "dna_bsc")
sq_dna_4 &lt;- sq(c("ACTGCTG", "CTTAGA", "CCCT", "GTNANN"),
               alphabet = "dna_ext")
sq_ami_1 &lt;- sq(c("ACTGCTG", "NIKAAR", "CCCT", "CTGAATGT"),
               alphabet = "ami_bsc")
sq_unt &lt;- sq(c("AHSNLVSCTK$SH%&amp;VS", "YQTVKA&amp;#BSKJGY",
               "CCCT", "AVYI#VSV&amp;*DVGDJCFA"))

# Comparing sq object with an object of the same length:
sq_dna_1 == sq_dna_2
sq_dna_1 == c("ACTGCTG", "CTTAGA", "CCCT", "CTGAATGT")

# Cannot compare sq objects of different lengths:
## Not run: 
sq_dna_1 == sq_dna_3
sq_dna_1 == c("AAA", "CCC")

## End(Not run)

# Unless comparing sq object with scalar value:
sq_dna_1 == "CTTAGA"

# It's possible to compare basic and extended types:
sq_dna_1 == sq_dna_4

# Mixing DNA, RNA and amino acid types throws an error, however:
## Not run: 
sq_dna_1 == sq_ami_1

## End(Not run)

# On the other hand, unt sq is acceptable everywhere:
sq_dna_1 == sq_unt
sq_dna_4 == sq_unt
sq_ami_1 == sq_unt

</code></pre>

<hr>
<h2 id='alphabet'>Get alphabet of given sq object.</h2><span id='topic+alphabet'></span>

<h3>Description</h3>

<p>Returns <code>alphabet</code> attribute of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphabet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphabet_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object to extract alphabet from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each <code>sq</code> object have an <strong>alphabet</strong> associated with it. Alphabet
is a set of possible <strong>letters</strong> that can appear in sequences contained
in object. Alphabet is kept mostly as a character vector, where each element
represents one <strong>letter</strong>.
</p>
<p><code>sq</code> objects of type <strong>ami</strong>, <strong>dna</strong> or <strong>rna</strong> have
fixed, predefined alphabets. In other words, if two <code>sq</code> objects have
exactly the same type - <strong>ami_bsc</strong>, <strong>dna_ext</strong>, <strong>rna_bsc</strong>
or any other combination - they are ensured to have the same alphabet.
</p>
<p>Below are listed alphabets for these types:
</p>

<ul>
<li> <p><strong>ami_bsc</strong> - ACDEFGHIKLMNPQRSTVWY-*
</p>
</li>
<li> <p><strong>ami_ext</strong> - ABCDEFGHIJKLMNOPQRSTUVWXYZ-*
</p>
</li>
<li> <p><strong>dna_bsc</strong> - ACGT-
</p>
</li>
<li> <p><strong>dna_ext</strong> - ACGTWSMKRYBDHVN-
</p>
</li>
<li> <p><strong>rna_bsc</strong> - ACGU-
</p>
</li>
<li> <p><strong>rna_ext</strong> - ACGUWSMKRYBDHVN-
</p>
</li></ul>

<p>Other types of <code>sq</code> objects are allowed to have different alphabets.
Furthermore, having an alphabet exactly identical to one of those above does
not automatically indicate that the type of the sequence is one of those -
e.g., there might be an <strong>atp</strong> <code>sq</code> that has an alphabet
identical to <strong>ami_bsc</strong> alphabet. To set the type, one should
use the <code><a href="#topic+typify">typify</a></code> or <code>`sq_type&lt;-`</code> function.
</p>
<p>The purpose of co-existence of <strong>unt</strong> and <strong>atp</strong> alphabets is
the fact that although there is a standard for format of <em>fasta</em> files,
sometimes there are other types of symbols, which do not match the standard.
Thanks to these types, tidysq can import files with customized alphabets.
Moreover, the user may want to group amino acids with similar properties
(e.g., for machine learning) and replace the standard alphabet with symbols
for whole groups. To check details, see <code><a href="#topic+read_fasta">read_fasta</a></code>,
<code><a href="#topic+sq">sq</a></code> and <code><a href="#topic+substitute_letters">substitute_letters</a></code>.
</p>
<p><strong>Important note:</strong> in <strong>atp</strong> alphabets there is a possibility
of letters appearing that consist of more than one character - this
functionality is provided in order to handle situations like
post-translational modifications, (e.g., using &quot;<code>mA</code>&quot; to indicate
methylated alanine).
</p>
<p><strong>Important note:</strong> alphabets of <strong>atp</strong> and <strong>unt</strong>
<code>sq</code> objects are case sensitive. Thus, in their alphabets both
lowercase and uppercase characters can appear simultaneously and they are
treated as different letters. Alphabets of <strong>dna</strong>, <strong>rna</strong> and
<strong>ami</strong> types are always uppercase and all functions converts other
parameters to uppercase when working with <strong>dna</strong>, <strong>rna</strong> or
<strong>ami</strong> - e.g. <code><a href="#topic++25has+25">%has%</a></code> operator converts lower letters to
upper when searching for motifs in <strong>dna</strong>, <strong>rna</strong> or
<strong>ami</strong> object.
</p>
<p><strong>Important note:</strong> maximum length of an alphabet is
<strong>30 letters</strong>. The user is not allowed to read fasta files or
construct <code>sq</code> objects from character vectors that have more than 30
distinct characters in sequences (unless creating <strong>ami</strong>, <strong>dna</strong>
or <strong>rna</strong> objects with <code>ignore_case</code> parameter set equal to
<code>TRUE</code>).
</p>


<h3>Value</h3>

<p>A character vector of letters of the alphabet.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sq-class">sq class</a></code>
</p>
<p>Functions from alphabet module:
<code><a href="#topic+get_standard_alphabet">get_standard_alphabet</a>()</code>
</p>

<hr>
<h2 id='as.character.sq'>Convert sq object into character vector</h2><span id='topic+as.character.sq'></span>

<h3>Description</h3>

<p>Coerces sequences from an <code><a href="#topic+sq-class">sq</a></code> object to
<code><a href="base.html#topic+character">character</a></code> vector of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sq'
as.character(x, ..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.sq_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="as.character.sq_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="as.character.sq_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method for <code><a href="#topic+sq-class">sq</a></code> class allows converting sequences
from the <code>sq</code> object into a character vector of length equal to the
length of input. Each element of resulting vector is a separate sequence.
All attributes of the input sq are lost during the conversion to character
vector.
</p>


<h3>Value</h3>

<p>A <code>character</code> vector where each element represents the content
of respective sequence in input <code>sq</code> object.
</p>


<h3>See Also</h3>

<p>Functions from output module:
<code><a href="#topic+as.matrix.sq">as.matrix.sq</a>()</code>,
<code><a href="#topic+as.sq">as.sq</a>()</code>,
<code><a href="#topic+export_sq">export_sq</a>()</code>,
<code><a href="#topic+write_fasta">write_fasta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating an object to work on:
sq_dna &lt;- sq(c("CTGAATGCAGTACCGTAAT", "ATGCCGTAAATGCCAT", "CAGACCANNNATAG"),
             alphabet = "dna_ext")

# Converting sq object into a character vector:
as.character(sq_dna)

</code></pre>

<hr>
<h2 id='as.matrix.sq'>Convert sq object into matrix</h2><span id='topic+as.matrix.sq'></span>

<h3>Description</h3>

<p>Coerces sequences from a <code><a href="#topic+sq-class">sq</a></code> object to
a <code><a href="base.html#topic+matrix">matrix</a></code>, in which rows correspond to sequences and columns to
positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sq'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.sq_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="as.matrix.sq_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method for class <code>sq</code> allows converting sequences from the
<code>sq</code> object into a matrix. Each row corresponds to the separate sequence
from the <code>sq</code> object, whereas each column indicates a single position
within a sequence. Dimensions of matrix are determined by the number of
sequences (rows) and the length of the longest sequence (columns). If length
of a sequence is smaller than the length of the longest sequence, the
remaining columns are filled with <code>NA</code>. All attributes of the input
<code>sq</code> are lost during the conversion to matrix.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> with number of rows the same as number of
sequences and number of columns corresponding to the length of the longest
sequence in the converted sq object.
</p>


<h3>See Also</h3>

<p>Functions from output module:
<code><a href="#topic+as.character.sq">as.character.sq</a>()</code>,
<code><a href="#topic+as.sq">as.sq</a>()</code>,
<code><a href="#topic+export_sq">export_sq</a>()</code>,
<code><a href="#topic+write_fasta">write_fasta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna &lt;- sq(c("CGATAGACA", "TGACAAAAC", "GTGACCGTA"),
             alphabet = "dna_bsc")
sq_rna &lt;- sq(c("CUGAAUGCAGUACCGUAAU", "AUGCCGUAAAUGCCAU", "CAGACCANNNAUAG"),
             alphabet = "rna_ext")

# Sequences of the same lengths can be converted easily:
as.matrix(sq_dna)

# Sequences that differ in length are filled with NA to the maximum length:
as.matrix(sq_rna)

</code></pre>

<hr>
<h2 id='as.sq'>Convert an object to sq</h2><span id='topic+as.sq'></span><span id='topic+as.sq.default'></span><span id='topic+as.sq.character'></span>

<h3>Description</h3>

<p>Takes an object of arbitrary type and returns an
<code><a href="#topic+sq-class">sq</a></code> object as an output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sq(x, ...)

## Default S3 method:
as.sq(x, ...)

## S3 method for class 'character'
as.sq(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sq_+3A_x">x</code></td>
<td>
<p>[<code>any</code>]
An object of a class that supports conversion to <code>sq</code> class.</p>
</td></tr>
<tr><td><code id="as.sq_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two possible cases: if <code>x</code> is a character vector, then this
method calls <code><a href="#topic+sq">sq</a></code> function, else it passes <code>x</code> to
<code><a href="#topic+import_sq">import_sq</a></code> and hopes it works.
</p>


<h3>Value</h3>

<p>An <code>sq</code> object.
</p>


<h3>See Also</h3>

<p>Functions from output module:
<code><a href="#topic+as.character.sq">as.character.sq</a>()</code>,
<code><a href="#topic+as.matrix.sq">as.matrix.sq</a>()</code>,
<code><a href="#topic+export_sq">export_sq</a>()</code>,
<code><a href="#topic+write_fasta">write_fasta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constructing an example sequence in the usual way:
sq_1 &lt;- sq("CTGA")

# Using a method for character vector:
sq_2 &lt;- as.sq("CTGA")

# Checking that both objects are identical:
identical(sq_1, sq_2)

</code></pre>

<hr>
<h2 id='bite'>Subset sequences from sq objects</h2><span id='topic+bite'></span><span id='topic+bite.sq'></span>

<h3>Description</h3>

<p>Extracts a defined range of elements from all sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bite(x, indices, ...)

## S3 method for class 'sq'
bite(
  x,
  indices,
  ...,
  NA_letter = getOption("tidysq_NA_letter"),
  on_warning = getOption("tidysq_on_warning")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bite_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="bite_+3A_indices">indices</code></td>
<td>
<p>[<code>integer</code>]<br />
Indices to extract from each sequence. The function follows the normal R
conventions for indexing vectors, including negative indices.</p>
</td></tr>
<tr><td><code id="bite_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="bite_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
<tr><td><code id="bite_+3A_on_warning">on_warning</code></td>
<td>
<p>[<code>"silent" || "message" || "warning" || "error"</code>]<br />
Determines the method of handling warning message. Default value is
<code>"warning"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bite</code> function allows user to access specific elements from multiple
sequences at once.
</p>
<p>By passing positive indices the user can choose, which elements they want
from each sequence. If a sequence is shorter than an index, then <code>NA</code>
value is inserted into the result in this place and a warning is issued.
The user can specify behavior of R in this case by specifying
<code>on_warning</code> parameter.
</p>
<p>Negative indices are supported as well. Their interpretation is &quot;to select
all elements except those on positions specified by these negative indices&quot;.
This means that e.g. <code>c(-1, -3, -5)</code> vector will be used to bite all
sequence elements except the first, the third and the fifth. If a sequence
is shorter than any index, then nothing happens, as it's physically
impossible to extract an element at said index.
</p>
<p>As per normal R convention, it isn't accepted to mix positive and negative
indices, because there is no good interpretation possible for that.
</p>


<h3>Value</h3>

<p><code><a href="#topic+sq-class">sq</a></code> object of the same type as input
<code>sq</code>, where each element is a subsequence created by indexing
corresponding sequence from input <code>sq</code> object with input indices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remove_na">remove_na</a></code>
</p>
<p>Functions that affect order of elements:
<code><a href="#topic+collapse">collapse</a>()</code>,
<code><a href="#topic+paste">paste</a>()</code>,
<code><a href="#topic+reverse">reverse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGNBAACGAN", "TGACGAGCTTA"),
             alphabet = "dna_bsc")
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_unt &lt;- sq(c("ATGCAGGA?", "TGACGAGCTTA", "", "TIAALGNIIYRAIE"))

# Extracting first five letters:
bite(sq_dna, 1:5)

# If a sequence is shorter than 5, then NA is introduced:
bite(sq_unt, 1:5)

# Selecting fourth, seventh and fourth again letter:
bite(sq_ami, c(4, 7, 4))

# Selecting all letters except first four:
bite(sq_dna, -1:-4)

</code></pre>

<hr>
<h2 id='collapse'>Collapse multiple sequences into one</h2><span id='topic+collapse'></span><span id='topic+collapse.sq'></span>

<h3>Description</h3>

<p>Joins sequences from a vector into a single sequence. Sequence
type remains unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(x, ...)

## S3 method for class 'sq'
collapse(x, ..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="collapse_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="collapse_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>collapse()</code> joins sequences from supplied <code>sq</code> object in the same
order as they appear in said vector. That is, if there are three sequences
AGGCT, ATCCGT and GAACGT, then resulting sequence will be AGGCTATCCGTGAACGT.
This operation does not alter the type of the input object nor its alphabet.
</p>


<h3>Value</h3>

<p><code><a href="#topic+sq-class">sq</a></code> object of the same type as input but with
exactly one sequence.
</p>


<h3>See Also</h3>

<p>Functions that affect order of elements:
<code><a href="#topic+bite">bite</a>()</code>,
<code><a href="#topic+paste">paste</a>()</code>,
<code><a href="#topic+reverse">reverse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGAACGAN", ""), alphabet = "dna_ext")
sq_unt &lt;- sq(c("ATGCAGGA?", "TGACGAGCTTA", "", "TIAALGNIIYRAIE"))

# Collapsing sequences:
collapse(sq_ami)
collapse(sq_dna)
collapse(sq_unt)

# Empty sq objects are collapsed as well (into empty string - ""):
sq_empty &lt;- sq(character(), alphabet = "rna_bsc")
collapse(sq_empty)

</code></pre>

<hr>
<h2 id='complement'>Create complement sequence from dnasq or rnasq object</h2><span id='topic+complement'></span><span id='topic+complement.sq_dna_bsc'></span><span id='topic+complement.sq_dna_ext'></span><span id='topic+complement.sq_rna_bsc'></span><span id='topic+complement.sq_rna_ext'></span>

<h3>Description</h3>

<p>Creates the complementary sequence from a given RNA or DNA 
sequence. The function keeps the type of sequence intact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complement(x, ...)

## S3 method for class 'sq_dna_bsc'
complement(x, ..., NA_letter = getOption("tidysq_NA_letter"))

## S3 method for class 'sq_dna_ext'
complement(x, ..., NA_letter = getOption("tidysq_NA_letter"))

## S3 method for class 'sq_rna_bsc'
complement(x, ..., NA_letter = getOption("tidysq_NA_letter"))

## S3 method for class 'sq_rna_ext'
complement(x, ..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complement_+3A_x">x</code></td>
<td>
<p>[<code>sq_dna_bsc</code> || <code>sq_rna_bsc</code> || <code>sq_dna_ext</code> ||
<code>sq_rna_ext</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="complement_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="complement_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function matches elements of sequence to their complementary letters.
For unambiguous letters, &quot;<code>C</code>&quot; is matched with &quot;<code>G</code>&quot; and &quot;<code>A</code>&quot;
is matched with either &quot;<code>T</code>&quot; (thymine) or &quot;<code>U</code>&quot; (uracil), depending
on whether input is of <strong>dna</strong> or <strong>rna</strong> type.
</p>
<p>Ambiguous letters are matched as well, for example &quot;<code>N</code>&quot; (any
nucleotide) is matched with itself, while &quot;<code>B</code>&quot; (not alanine) is matched
with &quot;<code>V</code>&quot; (not thymine/uracil).
</p>


<h3>Value</h3>

<p><code><a href="#topic+sq-class">sq</a></code> object of the same type as input but
built of nucleotides complementary to those in the entered sequences.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sq-class">sq</a></code>
</p>
<p>Functions interpreting sq in biological context:
<code><a href="#topic++25has+25">%has%</a>()</code>,
<code><a href="#topic+find_motifs">find_motifs</a>()</code>,
<code><a href="#topic+translate">translate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating DNA and RNA sequences to work on:
sq_dna &lt;- sq(c("ACTGCTG", "CTTAGA", "CCCT", "CTGAATGT"),
             alphabet = "dna_bsc")
sq_rna &lt;- sq(c("BRAUDUG", "URKKBKUCA", "ANKRUGBNNG", "YYAUNAAAG"),
             alphabet = "rna_ext")

# Here complement() function is used to make PCR (Polymerase Chain Reaction)
# primers. Every sequence is rewritten to its complementary equivalent as
# in the following example: AAATTTGGG -&gt; TTTAAACCC.

complement(sq_dna)
complement(sq_rna)

# Each sequence have now a complementary equivalent, which can be helpful
# during constructing PCR primers.

</code></pre>

<hr>
<h2 id='export_sq'>Export sq objects into other formats</h2><span id='topic+export_sq'></span>

<h3>Description</h3>

<p>Converts object of class <code><a href="#topic+sq-class">sq</a></code> to a class
from another package. Currently supported packages are <span class="pkg">ape</span>,
<span class="pkg">bioseq</span>, <span class="pkg">Bioconductor</span> and <span class="pkg">seqinr</span>. For exact list of
supported classes and resulting types, see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_sq(x, export_format, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_sq_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="export_sq_+3A_export_format">export_format</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string indicating desired class (with specified package for clarity).</p>
</td></tr>
<tr><td><code id="export_sq_+3A_name">name</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of sequence names. Must be of the same length as <code>sq</code> object.
Can be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="export_sq_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supported formats are as follows (grouped by <code>sq</code> types):
</p>

<ul>
<li> <p><strong>ami</strong>:
</p>

<ul>
<li> <p><code>"ape::AAbin"</code>
</p>
</li>
<li> <p><code>"bioseq::bioseq_aa"</code>
</p>
</li>
<li> <p><code>"Biostrings::AAString"</code>
</p>
</li>
<li> <p><code>"Biostrings::AAStringSet"</code>
</p>
</li>
<li> <p><code>"seqinr::SeqFastaAA"</code>
</p>
</li></ul>

</li>
<li> <p><strong>dna</strong>:
</p>

<ul>
<li> <p><code>"ape::DNAbin"</code>
</p>
</li>
<li> <p><code>"bioseq::bioseq_dna"</code>
</p>
</li>
<li> <p><code>"Biostrings::DNAString"</code>
</p>
</li>
<li> <p><code>"Biostrings::DNAStringSet"</code>
</p>
</li>
<li> <p><code>"seqinr::SeqFastadna"</code>
</p>
</li></ul>

</li>
<li> <p><strong>rna</strong>:
</p>

<ul>
<li> <p><code>"bioseq::bioseq_rna"</code>
</p>
</li>
<li> <p><code>"Biostrings::RNAString"</code>
</p>
</li>
<li> <p><code>"Biostrings::RNAStringSet"</code>
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>An object with the format specified in the parameter. To find 
information about the detailed structure of this object, see documentation 
of these objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sq-class">sq class</a></code>
</p>
<p>Functions from output module:
<code><a href="#topic+as.character.sq">as.character.sq</a>()</code>,
<code><a href="#topic+as.matrix.sq">as.matrix.sq</a>()</code>,
<code><a href="#topic+as.sq">as.sq</a>()</code>,
<code><a href="#topic+write_fasta">write_fasta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DNA and amino acid sequences can be exported to most packages
sq_ami &lt;- sq(c("MVVGL", "LAVPP"), alphabet = "ami_bsc")
export_sq(sq_ami, "ape::AAbin")
export_sq(sq_ami, "bioseq::bioseq_aa")
export_sq(sq_ami, "Biostrings::AAStringSet", c("one", "two"))
export_sq(sq_ami, "seqinr::SeqFastaAA")

sq_dna &lt;- sq(c("TGATGAAGCGCA", "TTGATGGGAA"), alphabet = "dna_bsc")
export_sq(sq_dna, "ape::DNAbin", name = c("one", "two"))
export_sq(sq_dna, "bioseq::bioseq_dna")
export_sq(sq_dna, "Biostrings::DNAStringSet")
export_sq(sq_dna, "seqinr::SeqFastadna")

# RNA sequences are limited to Biostrings and bioseq
sq_rna &lt;- sq(c("NUARYGCB", "", "DRKCNYBAU"), alphabet = "rna_ext")
export_sq(sq_rna, "bioseq::bioseq_rna")
export_sq(sq_rna, "Biostrings::RNAStringSet")

# Biostrings can export single sequences to simple strings as well
export_sq(sq_dna[1], "Biostrings::DNAString")

</code></pre>

<hr>
<h2 id='find_invalid_letters'>Find elements which are not suitable for specified type.</h2><span id='topic+find_invalid_letters'></span><span id='topic+find_invalid_letters.sq'></span>

<h3>Description</h3>

<p>Finds elements in given sequence not contained in amino acid or
nucleotide alphabet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_invalid_letters(x, dest_type, ...)

## S3 method for class 'sq'
find_invalid_letters(
  x,
  dest_type,
  ...,
  NA_letter = getOption("tidysq_NA_letter")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_invalid_letters_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="find_invalid_letters_+3A_dest_type">dest_type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The name of destination type - one of <code>"dna_bsc"</code>, <code>"dna_ext"</code>,
<code>"rna_bsc"</code>, <code>"rna_ext"</code>, <code>"ami_bsc"</code> and <code>"ami_ext"</code>.</p>
</td></tr>
<tr><td><code id="find_invalid_letters_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="find_invalid_letters_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Amino acid, DNA and RNA standard alphabets have predefined letters. This
function allows the user to check which letters from input sequences are not
contained in selected one of these alphabets.
</p>
<p>Returned list contains a character vector for each input sequence. Each
element of a vector is a letter that appear in corresponding sequence and not
in the target alphabet.
</p>
<p>You can check which letters are valid for specified type in
<code><a href="#topic+alphabet">alphabet</a></code> documentation.
</p>


<h3>Value</h3>

<p>A list of mismatched elements for every sequence from
<code><a href="#topic+sq-class">sq</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alphabet">alphabet</a>()</code>
</p>
<p>Functions that manipulate type of sequences:
<code><a href="#topic+is.sq">is.sq</a>()</code>,
<code><a href="#topic+sq_type">sq_type</a>()</code>,
<code><a href="#topic+substitute_letters">substitute_letters</a>()</code>,
<code><a href="#topic+typify">typify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_unt &lt;- sq(c("ACGPOIUATTAGACG","GGATFGHA"), alphabet = "unt")
sq_ami &lt;- sq(c("QWERTYUIZXCVBNM","LKJHGFDSAZXCVBN"), alphabet = "ami_ext")

# Mismatched elements might be from basic type:
find_invalid_letters(sq_ami, "ami_bsc")

# But also from type completely unrelated to the current one:
find_invalid_letters(sq_unt, "dna_ext")

</code></pre>

<hr>
<h2 id='find_motifs'>Find given motifs</h2><span id='topic+find_motifs'></span><span id='topic+find_motifs.sq'></span>

<h3>Description</h3>

<p>Finds all given motifs in sequences and returns their positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_motifs(x, name, motifs, ...)

## S3 method for class 'sq'
find_motifs(x, name, motifs, ..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_motifs_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="find_motifs_+3A_name">name</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of sequence names. Must be of the same length as <code>sq</code> object.</p>
</td></tr>
<tr><td><code id="find_motifs_+3A_motifs">motifs</code></td>
<td>
<p>[<code>character</code>]<br />
Motifs to be searched for.</p>
</td></tr>
<tr><td><code id="find_motifs_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="find_motifs_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows search of a given motif or motifs in the <code>sq</code>
object. It returns all motifs found with their start and end positions within
a sequence.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with following columns:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>name of the sequence in which a motif was found</p>
</td></tr>
<tr><td><code>sought</code></td>
<td>
<p>sought motif</p>
</td></tr>
<tr><td><code>found</code></td>
<td>
<p>found subsequence, may differ from sought if the motif
contained ambiguous letters</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>position of first element of found motif</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>position of last element of found motif</p>
</td></tr>
</table>


<h3>Motif capabilities and restrictions</h3>

<p>There are more options than to simply create a motif that is a string
representation of searched subsequence. For example, when using this function
with any of standard types, i.e. <strong>ami</strong>, <strong>dna</strong> or <strong>rna</strong>,
the user can create a motif with ambiguous letters. In this case the engine
will try to match any of possible meanings of this letter. For example, take
&quot;B&quot; from extended DNA alphabet. It means &quot;not A&quot;, so it can be matched with
&quot;C&quot;, &quot;G&quot; and &quot;T&quot;, but also &quot;B&quot;, &quot;Y&quot; (either &quot;C&quot; or &quot;T&quot;), &quot;K&quot; (either &quot;G&quot; or
&quot;T&quot;) and &quot;S&quot; (either &quot;C&quot; or &quot;G&quot;).
</p>
<p>Full list of ambiguous letters with their meaning can be found on IUPAC site.
</p>
<p>Motifs are also restricted in that the alphabets of <code>sq</code> objects on
which search operations are conducted cannot contain &quot;^&quot; and &quot;$&quot; symbols.
These two have a special meaning - they are used to indicate beginning and
end of sequence respectively and can be used to limit the position of matched
subsequences.
</p>


<h3>See Also</h3>

<p>Functions interpreting sq in biological context:
<code><a href="#topic++25has+25">%has%</a>()</code>,
<code><a href="#topic+complement">complement</a>()</code>,
<code><a href="#topic+translate">translate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGNBAACGAN", "TGACGAGCTTAG"),
             alphabet = "dna_bsc")
sq_ami &lt;- sq(c("AGNTYIKFGGAYTI", "MATEGILIAADGYTWIL", "MIPADHICAANGIENAGIK"),
             alphabet = "ami_bsc")
sq_atp &lt;- sq(c("mAmYmY", "nbAnsAmA", ""),
             alphabet = c("mA", "mY", "nbA", "nsA"))
sq_names &lt;- c("sq1", "sq2", "sq3")

# Finding motif of two alanines followed by aspartic acid or asparagine
# ("AAB" motif matches "AAB", "AAD" and "AAN"):
find_motifs(sq_ami, sq_names, "AAB")

# Finding "C" at fourth position:
find_motifs(sq_dna, sq_names, "^NNNC")

# Finding motif "I" at second-to-last position:
find_motifs(sq_ami, sq_names, "IX$")

# Finding multiple motifs:
find_motifs(sq_dna, sq_names, c("^ABN", "ANCBY", "BAN$"))

# Finding multicharacter motifs:
find_motifs(sq_atp, sq_names, c("nsA", "mYmY$"))

</code></pre>

<hr>
<h2 id='get_sq_lengths'>Get lengths of sequences in sq object</h2><span id='topic+get_sq_lengths'></span>

<h3>Description</h3>

<p>Returns number of elements in each sequence in given
<code><a href="#topic+sq-class">sq</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sq_lengths(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sq_lengths_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to storage implementation, using <code><a href="base.html#topic+lengths">lengths</a></code> method
returns length of stored raw vectors instead of real sequence lengths. This
function accesses <code>original_length</code> attribute of each sequence, which
attribute stores information about how many elements are there in given
sequence.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector, where each element gives length of
corresponding sequence from <code><a href="#topic+sq-class">sq</a></code> object.
</p>


<h3>See Also</h3>

<p>Functions from utility module:
<code><a href="#topic++3D+3D.sq">==.sq</a>()</code>,
<code><a href="#topic+is.sq">is.sq</a>()</code>,
<code><a href="#topic+sqconcatenate">sqconcatenate</a></code>,
<code><a href="#topic+sqextract">sqextract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGAACGAN", "TGACGAGCTTA", "ACTNNAGCN"),
             alphabet = "dna_ext")

# Counting number of elements in sq object:
get_sq_lengths(sq_dna)
get_sq_lengths(sq_ami)

</code></pre>

<hr>
<h2 id='get_standard_alphabet'>Get standard alphabet for given type.</h2><span id='topic+get_standard_alphabet'></span>

<h3>Description</h3>

<p>Returns <code>alphabet</code> attribute of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_standard_alphabet(type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_standard_alphabet_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The name of standard sq type - one of <code>"dna_bsc"</code>, <code>"dna_ext"</code>,
<code>"rna_bsc"</code>, <code>"rna_ext"</code>, <code>"ami_bsc"</code> and <code>"ami_ext"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of standard sq types has exactly one predefined alphabet. It allows
<span class="pkg">tidysq</span> to package to optimize type-specific operations like
<code><a href="#topic+complement">complement</a>()</code> or <code><a href="#topic+translate">translate</a>()</code>. This function
enables the user to access <code>alphabet</code> attribute common for all <code>sq</code>
objects of given type.
</p>
<p>For list of letters specific to any of these standard alphabets, see
<code><a href="#topic+alphabet">alphabet</a>()</code>.
</p>


<h3>Value</h3>

<p>An <code>sq_alphabet</code> object related to passed sq type.
</p>


<h3>See Also</h3>

<p>Functions from alphabet module:
<code><a href="#topic+alphabet">alphabet</a>()</code>
</p>

<hr>
<h2 id='get_tidysq_options'>Obtain current state of tidysq options</h2><span id='topic+get_tidysq_options'></span><span id='topic+tidysq-options'></span>

<h3>Description</h3>

<p>Subsets all global options to display those related to
<span class="pkg">tidysq</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tidysq_options()
</code></pre>


<h3>Details</h3>

<p>The user can display value of selected option by calling
<code>getOptions(option_name)</code> and set its value with
<code>options(option_name = value)</code>, where <code>option_name</code> is an option
name and <code>value</code> is a value to assign to an option.
</p>
<p>Full list of options included in <span class="pkg">tidysq</span> package is listed below:
</p>

<ul>
<li><p> tidysq_NA_letter [<code>character(1)</code>]<br />
A letter to be used when printing, constructing or interpreting <code>NA</code>
value. Defaults to <code>"!"</code>.
</p>
</li>
<li><p> tidysq_on_warning [<code>"silent" || "message" || "warning" || "error"</code>]<br />
Determines the method of handling warning message. Setting <code>"error"</code>
makes any warning throw an exception and stop execution of the code. The
difference between <code>"message"</code> and <code>"warning"</code> is that while both
display warning text to the console, only the latter registers it so that
it can be accessed with a call to <code>warnings()</code>. Lastly, <code>"silent"</code>
setting causes any warnings to be completely ignored. Default value is
<code>"warning"</code>.
</p>
</li>
<li><p> tidysq_pillar_max_width [codeinteger(1)]<br />
Determines max width of a column of <code>sq</code> class within a
<code><a href="tibble.html#topic+tibble">tibble</a></code>. Default value is 15.
</p>
</li>
<li><p> tidysq_print_max_sequences [<code>integer(1)</code>]<br />
Controls maximum number of sequences printed to console. If an <code>sq</code>
object is longer than this value, then only first
<code>tidysq_print_max_sequences</code> are printed, just like in any R vector.
Default value is 10.
</p>
</li>
<li><p> tidysq_print_use_color [<code>logical(1)</code>]<br />
Determines whether coloring should be used to increase readability of text
printed to console. While it is advised to keep this option turned on due
to above concern, some environments may not support coloring and thus
turning it off can be necessary. Defaults to <code>TRUE</code>.
</p>
</li>
<li><p> tidysq_safe_mode [<code>logical(1)</code>]<br />
Default value is <code>FALSE</code>. When turned on, safe mode guarantees that
<code>NA</code> appears within a sequence if and only if input sequence contains
value passed with <code>NA_letter</code>. This means that resulting type might be
different to the one passed as argument, if there are letters in a sequence
that does not appear in the original alphabet.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code><a href="methods.html#topic+namedList-class">named list</a></code> with selected option
values.
</p>


<h3>See Also</h3>

<p>Functions that display sequence info:
<code><a href="#topic+sqprint">sqprint</a></code>
</p>

<hr>
<h2 id='import_sq'>Import sq objects from other objects</h2><span id='topic+import_sq'></span>

<h3>Description</h3>

<p>Creates <code><a href="#topic+sq-class">sq</a></code> object from object of class
from another package. Currently supported packages are <span class="pkg">ape</span>,
<span class="pkg">bioseq</span>, <span class="pkg">Bioconductor</span> and <span class="pkg">seqinr</span>. For exact list of
supported classes and resulting types, see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_sq(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_sq_+3A_object">object</code></td>
<td>
<p>[<code>any(1)</code>]<br />
An object of one of supported classes.</p>
</td></tr>
<tr><td><code id="import_sq_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supported classes are as follows:
</p>

<ul>
<li> <p><code>ape</code>:
</p>

<ul>
<li> <p><code>AAbin</code> - imported as <strong>ami_bsc</strong>
</p>
</li>
<li> <p><code>DNAbin</code> - imported as <strong>dna_bsc</strong>
</p>
</li>
<li> <p><code>alignment</code> - exact type is guessed within <code><a href="#topic+sq">sq</a></code>
function
</p>
</li></ul>

</li>
<li> <p><code>bioseq</code>:
</p>

<ul>
<li> <p><code>bioseq_aa</code> - imported as <strong>ami_ext</strong>
</p>
</li>
<li> <p><code>bioseq_dna</code> - imported as <strong>dna_ext</strong>
</p>
</li>
<li> <p><code>bioseq_rna</code> - imported as <strong>rna_ext</strong>
</p>
</li></ul>

</li>
<li> <p><code>Biostrings</code>:
</p>

<ul>
<li> <p><code>AAString</code> - imported as <strong>ami_ext</strong> with exactly one
sequence
</p>
</li>
<li> <p><code>AAStringSet</code> - imported as <strong>ami_ext</strong>
</p>
</li>
<li> <p><code>DNAString</code> - imported as <strong>dna_ext</strong> with exactly one
sequence
</p>
</li>
<li> <p><code>DNAStringSet</code> - imported as <strong>dna_ext</strong>
</p>
</li>
<li> <p><code>RNAString</code> - imported as <strong>rna_ext</strong> with exactly one
sequence
</p>
</li>
<li> <p><code>RNAStringSet</code> - imported as <strong>rna_ext</strong>
</p>
</li>
<li> <p><code>BString</code> - imported as <strong>unt</strong> with exactly one
sequence
</p>
</li>
<li> <p><code>BStringSet</code> - imported as <strong>unt</strong>
</p>
</li>
<li> <p><code>XStringSetList</code> - each element of a list can be imported as
a separate <code><a href="tibble.html#topic+tibble">tibble</a></code>, resulting in a list of tibbles;
if passed argument <code>separate = FALSE</code>, these tibbles are bound into
one bigger tibble
</p>
</li></ul>

</li>
<li> <p><code>seqinr</code>:
</p>

<ul>
<li> <p><code>SeqFastaAA</code> - imported as <strong>ami_bsc</strong>
</p>
</li>
<li> <p><code>SeqFastadna</code> - imported as <strong>dna_bsc</strong>
</p>
</li></ul>

</li></ul>

<p>Providing object of class other than specified will result in an error.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with <code>sq</code> column of
<code><a href="#topic+sq-class">sq</a></code> type representing the same sequences as given
object; the object has a type corresponding to the input type; if given
sequences have names, output <code><a href="tibble.html#topic+tibble">tibble</a></code> will also have
another column <code>name</code> with those names
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sq-class">sq class</a></code>
</p>
<p>Functions from input module:
<code><a href="#topic+random_sq">random_sq</a>()</code>,
<code><a href="#topic+read_fasta">read_fasta</a>()</code>,
<code><a href="#topic+sq">sq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ape example
library(ape)
ape_dna &lt;- as.DNAbin(list(one = c("C", "T", "C", "A"), two = c("T", "G", "A", "G", "G")))
import_sq(ape_dna)

# bioseq example
library(bioseq)
bioseq_rna &lt;- new_rna(c(one = "ANBRY", two = "YUTUGGN"))
import_sq(bioseq_rna)

# Biostrings example
library(Biostrings)
Biostrings_ami &lt;- AAStringSet(c(one = "FEAPQLIWY", two = "EGITENAK"))
import_sq(Biostrings_ami)

# seqinr example
library(seqinr)
seqinr_dna &lt;- as.SeqFastadna(c("C", "T", "C", "A"), name = "one")
import_sq(seqinr_dna)

</code></pre>

<hr>
<h2 id='is_empty_sq'>Test if sequence is empty</h2><span id='topic+is_empty_sq'></span>

<h3>Description</h3>

<p>Test an <code><a href="#topic+sq-class">sq</a></code> object for presence of
empty sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_empty_sq(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_empty_sq_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows identification of empty sequences (that have
length 0) represented by the <code>NULL sq</code> values in the sq object. It
returns a logical value for every element of the <code>sq</code> object -
<code>TRUE</code> if its value is <code>NULL sq</code> and <code>FALSE</code> otherwise.
<code>NULL sq</code> values may be introduced as a result of
<code><a href="#topic+remove_ambiguous">remove_ambiguous</a></code> and <code><a href="#topic+remove_na">remove_na</a></code> functions. The
former replaces sequences containing ambiguous elements with <code>NULL sq</code>
values, whereas the latter replaces sequences with <code>NA</code> values with
<code>NULL sq</code>.
</p>


<h3>Value</h3>

<p>A logical vector of the same length as input <code>sq</code>, indicating
whether elements are empty sequences (of length 0).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sq-class">sq class</a></code>
</p>
<p>Functions that clean sequences:
<code><a href="#topic+remove_ambiguous">remove_ambiguous</a>()</code>,
<code><a href="#topic+remove_na">remove_na</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating an object to work on:
sq_dna_ext &lt;- sq(c("ACGATTAGACG", "", "GACGANTCCAGNTAC"),
                 alphabet = "dna_ext")

# Testing for presence of empty sequences:
is_empty_sq(sq_dna_ext)

# Testing for presence of empty sequences after cleaning - sequence
# containing ambiguous elements is replaced by NULL sq:
sq_dna_bsc &lt;- remove_ambiguous(sq_dna_ext)
is_empty_sq(sq_dna_bsc)

# Testing for presence of empty sequences after using bite and removing NA.
# Extracting letters from first to fifteenth - NA introduced:
bitten_sq &lt;- bite(sq_dna_ext, 1:15)
# Removing NA:
rm_bitten_sq &lt;- remove_na(bitten_sq)
# Testing for presence of empty sequences:
is_empty_sq(rm_bitten_sq)

</code></pre>

<hr>
<h2 id='is.sq'>Check if object has specified type</h2><span id='topic+is.sq'></span><span id='topic+is.sq_dna_bsc'></span><span id='topic+is.sq_dna_ext'></span><span id='topic+is.sq_dna'></span><span id='topic+is.sq_rna_bsc'></span><span id='topic+is.sq_rna_ext'></span><span id='topic+is.sq_rna'></span><span id='topic+is.sq_ami_bsc'></span><span id='topic+is.sq_ami_ext'></span><span id='topic+is.sq_ami'></span><span id='topic+is.sq_unt'></span><span id='topic+is.sq_atp'></span>

<h3>Description</h3>

<p>Checks if object is an <code><a href="#topic+sq-class">sq</a></code> object
without specifying type or if it is an <code>sq</code> object with specific type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.sq(x)

is.sq_dna_bsc(x)

is.sq_dna_ext(x)

is.sq_dna(x)

is.sq_rna_bsc(x)

is.sq_rna_ext(x)

is.sq_rna(x)

is.sq_ami_bsc(x)

is.sq_ami_ext(x)

is.sq_ami(x)

is.sq_unt(x)

is.sq_atp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.sq_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are mostly simply calls to class checks. There are also
grouped checks, i.e. <code>is.sq_dna</code>, <code>is.sq_rna</code> and <code>is.sq_ami</code>.
These check for sq type regardless of if the type is basic or extended.
</p>


<h3>Value</h3>

<p>A <code>logical</code> value - <code>TRUE</code> if <code>x</code> has specified type,
<code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p>Functions that manipulate type of sequences:
<code><a href="#topic+find_invalid_letters">find_invalid_letters</a>()</code>,
<code><a href="#topic+sq_type">sq_type</a>()</code>,
<code><a href="#topic+substitute_letters">substitute_letters</a>()</code>,
<code><a href="#topic+typify">typify</a>()</code>
</p>
<p>Functions from utility module:
<code><a href="#topic++3D+3D.sq">==.sq</a>()</code>,
<code><a href="#topic+get_sq_lengths">get_sq_lengths</a>()</code>,
<code><a href="#topic+sqconcatenate">sqconcatenate</a></code>,
<code><a href="#topic+sqextract">sqextract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna &lt;- sq(c("GGCAT", "TATC-A", "TGA"), alphabet = "dna_bsc")
sq_rna &lt;- sq(c("CGAUUACG", "UUCUAGA", "UUCA"), alphabet = "rna_bsc")
sq_ami &lt;- sq(c("CVMPQGQQ", "AHLC--PPQ"), alphabet = "ami_ext")
sq_unt &lt;- sq("BAHHAJJ&amp;HAN&amp;JD&amp;", alphabet = "unt")
sq_atp &lt;- sq(c("mALPVQAmAmA", "mAmAPQ"), alphabet = c("mA", LETTERS))

# What is considered sq:
is.sq(sq_dna)
is.sq(sq_rna)
is.sq(sq_ami)
is.sq(sq_unt)
is.sq(sq_atp)

# What is not:
is.sq(c(1,2,3))
is.sq(LETTERS)
is.sq(TRUE)
is.sq(NULL)

# Checking for exact class:
is.sq_dna_bsc(sq_dna)
is.sq_dna_ext(sq_rna)
is.sq_rna_bsc(sq_ami)
is.sq_rna_ext(sq_rna)
is.sq_ami_bsc(sq_ami)
is.sq_ami_ext(sq_atp)
is.sq_atp(sq_atp)
is.sq_unt(sq_unt)

# Checking for generalized type:
is.sq_dna(sq_atp)
is.sq_rna(sq_rna)
is.sq_ami(sq_ami)

</code></pre>

<hr>
<h2 id='paste'>Paste sequences in string-like fashion</h2><span id='topic+paste'></span><span id='topic+paste.sq'></span>

<h3>Description</h3>

<p>Joins multiple vectors of sequences into one vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sq'
paste(..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste_+3A_...">...</code></td>
<td>
<p>[<code>sq</code>]<br />
Sequences to paste together.</p>
</td></tr>
<tr><td><code id="paste_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>paste()</code> joins sequences in the same way as it does with strings.
All <code>sq</code> objects must have the same length, that is, contain the same
number of sequences. An exception is made for scalar (length 1) <code>sq</code>
objects, which are replicated instead.
</p>


<h3>Value</h3>

<p><code><a href="#topic+sq-class">sq</a></code> object of common type of input objects.
Common type is determined in the same process as for
<code><a href="#topic+sq-concatenate">c.sq</a>()</code>.
</p>


<h3>See Also</h3>

<p>Functions that affect order of elements:
<code><a href="#topic+bite">bite</a>()</code>,
<code><a href="#topic+collapse">collapse</a>()</code>,
<code><a href="#topic+reverse">reverse</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna_1 &lt;- sq(c("TTCAGGGCTAG", "CGATTGC", "CAGTTTA"),
               alphabet = "dna_bsc")
sq_dna_2 &lt;- sq(c("ATCTTGAAG", "CATATGCGCTA", "ACGTGTCGA"),
               alphabet = "dna_bsc")
sq_unt_1 &lt;- sq(c("ATGCAGGA?", "TGACGAGCTTA", "", "TIAALGNIIYRAIE"))
sq_unt_2 &lt;- sq(c("OVNU!!OK!!J", "GOK!MI!N!BB!", "DPOFIN!!", "??!?"))

# Pasting sequences:
collapse(sq_dna_1, sq_dna_2)
collapse(sq_unt_1, sq_unt_2)
collapse(sq_dna_2, sq_unt_2, sq_dna_1)

</code></pre>

<hr>
<h2 id='random_sq'>Generate random sequences</h2><span id='topic+random_sq'></span>

<h3>Description</h3>

<p>Generates an <code><a href="#topic+sq-class">sq</a></code> object with specified
number of sequences of given length and alphabet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_sq(n, len, alphabet, sd = NULL, use_gap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_sq_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
A number of sequences to generate - must be non-negative.</p>
</td></tr>
<tr><td><code id="random_sq_+3A_len">len</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Length of each sequence if <code>sd</code> not specified and mean length of
sequences if <code>sd</code> specified - must be non-negative.</p>
</td></tr>
<tr><td><code id="random_sq_+3A_alphabet">alphabet</code></td>
<td>
<p>[<code>character</code>]<br />
If provided value is a single string, it will be interpreted as type (see
details). If provided value has length greater than one, it will be treated
as atypical alphabet for <code>sq</code> object and <code>sq</code> type will be
<code>atp</code>.</p>
</td></tr>
<tr><td><code id="random_sq_+3A_sd">sd</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
If specified, gives standard deviation of length of generated sequences -
must be non-negative.</p>
</td></tr>
<tr><td><code id="random_sq_+3A_use_gap">use_gap</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, sequences will be generated with random gaps inside
(commonly denoted as &quot;<code>-</code>&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Letter '*' is not used in generating <strong>ami</strong> sequences. If parameter
<code>sd</code> is passed, then all generated negative values are replaced with 0s.
</p>


<h3>Value</h3>

<p>An object of class <code>sq</code> with type as specified.
</p>


<h3>See Also</h3>

<p>Functions from input module:
<code><a href="#topic+import_sq">import_sq</a>()</code>,
<code><a href="#topic+read_fasta">read_fasta</a>()</code>,
<code><a href="#topic+sq">sq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setting seed for reproducibility
set.seed(16)

# Generating random sequences
random_sq(10, 10, "ami_bsc")
random_sq(25, 18, "rna_bsc", sd = 6)
random_sq(50, 8, "dna_ext", sd = 3)
random_sq(6, 100, "ami_bsc", use_gap = TRUE)

# Passing whole alphabet instead of type
random_sq(4, 12, c("Pro", "Gly", "Ala", "Met", "Cys"))

# Generating empty sequences (why would anyone though)
random_sq(8, 0, "rna_ext")

</code></pre>

<hr>
<h2 id='read_fasta'>Read a FASTA file</h2><span id='topic+read_fasta'></span>

<h3>Description</h3>

<p>Reads a FASTA file that contains nucleotide or amino acid
sequences and returns a <code><a href="tibble.html#topic+tibble">tibble</a></code> with obtained data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fasta(
  file_name,
  alphabet = NULL,
  NA_letter = getOption("tidysq_NA_letter"),
  safe_mode = getOption("tidysq_safe_mode"),
  on_warning = getOption("tidysq_on_warning"),
  ignore_case = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_fasta_+3A_file_name">file_name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Absolute path to file or url to read from.</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_alphabet">alphabet</code></td>
<td>
<p>[<code>character</code>]<br />
If provided value is a single string, it will be interpreted as type (see
details). If provided value has length greater than one, it will be treated
as atypical alphabet for <code>sq</code> object and <code>sq</code> type will be
<code>atp</code>. If provided value is <code>NULL</code>, type
guessing will be performed (see details).</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_safe_mode">safe_mode</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Default value is <code>FALSE</code>. When turned on, safe mode guarantees that
<code>NA</code> appears within a sequence if and only if input sequence contains
value passed with <code>NA_letter</code>. This means that resulting type might be
different to the one passed as argument, if there are letters in a sequence
that does not appear in the original alphabet.</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_on_warning">on_warning</code></td>
<td>
<p>[<code>"silent" || "message" || "warning" || "error"</code>]<br />
Determines the method of handling warning message. Default value is
<code>"warning"</code>.</p>
</td></tr>
<tr><td><code id="read_fasta_+3A_ignore_case">ignore_case</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If turned on, lowercase letters are turned into respective uppercase ones
and interpreted as such. If not, either <code>sq</code> object must be of type
<strong>unt</strong> or all lowercase letters are interpreted as <code>NA</code> values.
Default value is <code>FALSE</code>. Ignoring case does not work with <strong>atp</strong>
alphabets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All rules of creating <code>sq</code> objects are the same as in <code><a href="#topic+sq">sq</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble</a></code> with number of rows equal to the
number of sequences and two columns:
</p>

<ul>
<li><p>namespecifies name of a sequence, used in functions like
<code><a href="#topic+find_motifs">find_motifs</a></code>
</p>
</li>
<li><p>sqcontains extracted sequence itself
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+readLines">readLines</a></code>
</p>
<p>Functions from input module:
<code><a href="#topic+import_sq">import_sq</a>()</code>,
<code><a href="#topic+random_sq">random_sq</a>()</code>,
<code><a href="#topic+sq">sq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fasta_file &lt;- system.file(package = "tidysq", "examples/example_aa.fasta")

# In this case, these two calls are equivalent in result:
read_fasta(fasta_file)
read_fasta(fasta_file, alphabet = "ami_bsc")

## Not run: 
# It's possible to read FASTA file from URL:
read_fasta("https://www.uniprot.org/uniprot/P28307.fasta")

## End(Not run)

</code></pre>

<hr>
<h2 id='remove_ambiguous'>Remove sequences that contain ambiguous elements</h2><span id='topic+remove_ambiguous'></span><span id='topic+remove_ambiguous.sq'></span>

<h3>Description</h3>

<p>This function replaces sequences with ambiguous elements by
empty (<code>NULL</code>) sequences or removes ambiguous elements from sequences
in an <code>sq</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_ambiguous(x, by_letter = FALSE, ...)

## S3 method for class 'sq'
remove_ambiguous(
  x,
  by_letter = FALSE,
  ...,
  NA_letter = getOption("tidysq_NA_letter")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_ambiguous_+3A_x">x</code></td>
<td>
<p>[<code>sq_dna_bsc || sq_rna_bsc || sq_dna_ext || sq_rna_ext || sq_ami_bsc || sq_ami_ext</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="remove_ambiguous_+3A_by_letter">by_letter</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>FALSE</code>, filter condition is applied to sequence as a whole. If
<code>TRUE</code>, each letter is applied filter to separately.</p>
</td></tr>
<tr><td><code id="remove_ambiguous_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="remove_ambiguous_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Biological sequences, whether of DNA, RNA or amino acid elements, are not
always exactly determined. Sometimes the only information the user has about
an element is that it's one of given set of possible elements. In this case
the element is described with one of special letters, here called
<strong>ambiguous</strong>.
</p>
<p>The inclusion of these letters is the difference between extended and basic
alphabets (and, conversely, types). For amino acid alphabet these letters
are: B, J, O, U, X, Z; whereas for DNA and RNA: W, S, M, K, R, Y, B, D, H, V,
N.
</p>
<p><code>remove_ambiguous()</code> is used to create sequences without any of the
elements above. Depending on value of <code>by_letter</code> argument, the function
either replaces &quot;ambiguous&quot; sequences with empty sequences (if
<code>by_letter</code> is equal to <code>TRUE</code>) or shortens original sequence by
retaining only unambiguous letters (if opposite is true).
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+sq-class">sq</a></code> object with the <strong>_bsc</strong>
version of inputted type.
</p>


<h3>See Also</h3>

<p>Functions that clean sequences:
<code><a href="#topic+is_empty_sq">is_empty_sq</a>()</code>,
<code><a href="#topic+remove_na">remove_na</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGAACGAN", "TGACGAGCTTA", "ACTNNAGCN"),
             alphabet = "dna_ext")

# Removing whole sequences with ambiguous elements:
remove_ambiguous(sq_ami)
remove_ambiguous(sq_dna)

# Removing ambiguous elements from sequences:
remove_ambiguous(sq_ami, by_letter = TRUE)
remove_ambiguous(sq_dna, by_letter = TRUE)

# Analysis of the result
sq_clean &lt;- remove_ambiguous(sq_ami)
is_empty_sq(sq_clean)
sq_type(sq_clean)

</code></pre>

<hr>
<h2 id='remove_na'>Remove sequences that contain NA values</h2><span id='topic+remove_na'></span><span id='topic+remove_na.sq'></span>

<h3>Description</h3>

<p>This function replaces sequences with <code>NA</code> values by
empty (<code>NULL</code>) sequences or removes <code>NA</code> values from sequences
in an <code>sq</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_na(x, by_letter = FALSE, ...)

## S3 method for class 'sq'
remove_na(x, by_letter = FALSE, ..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_na_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="remove_na_+3A_by_letter">by_letter</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>FALSE</code>, filter condition is applied to sequence as a whole. If
<code>TRUE</code>, each letter is applied filter to separately.</p>
</td></tr>
<tr><td><code id="remove_na_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="remove_na_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NA</code> may be introduced as a result of using functions like
<code><a href="#topic+substitute_letters">substitute_letters</a></code> or <code><a href="#topic+bite">bite</a></code>. They can also appear
in sequences if the user reads FASTA file using <code><a href="#topic+read_fasta">read_fasta</a></code> or
constructs <code>sq</code> object from <code><a href="base.html#topic+character">character</a></code> vector with
<code><a href="#topic+sq">sq</a></code> function without <code>safe_mode</code> turned on - and there are
letters in file or strings other than specified in the alphabet.
</p>
<p><code>remove_na()</code> is used to filter out sequences or elements that have
<code>NA</code> value(s). By default, if any letter in a sequence is <code>NA</code>,
then whole sequence is replaced by empty (<code>NULL</code>) sequence. However, if
<code>by_letter</code> parameter is set to <code>TRUE</code>, then sequences are
only shortened by excluding <code>NA</code> values.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+sq-class">sq</a></code> object with the same type as the
input type. Sequences that do not contain any <code>NA</code> values are left
unchanged.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sq-class">sq</a></code>
</p>
<p>Functions that clean sequences:
<code><a href="#topic+is_empty_sq">is_empty_sq</a>()</code>,
<code><a href="#topic+remove_ambiguous">remove_ambiguous</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGAACGAN", "TGACGAGCTTA", "ACTNNAGCN"),
             alphabet = "dna_ext")

# Substituting some letters with NA
sq_ami_sub &lt;- substitute_letters(sq_ami, c(E = NA_character_, R = NA_character_))
sq_dna_sub &lt;- substitute_letters(sq_dna, c(N = NA_character_))

# Biting sequences out of range
sq_bitten &lt;- bite(sq_ami, 1:15)

# Printing the sequences
sq_ami_sub
sq_dna_sub

# Removing sequences containing NA
remove_na(sq_ami_sub)
remove_na(sq_dna_sub)
remove_na(sq_bitten)

# Removing only NA elements
remove_na(sq_ami_sub, by_letter = TRUE)
remove_na(sq_dna_sub, TRUE)
remove_na(sq_bitten, TRUE)

</code></pre>

<hr>
<h2 id='reverse'>Reverse sequence</h2><span id='topic+reverse'></span><span id='topic+reverse.sq'></span>

<h3>Description</h3>

<p>Reverse given list of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse(x, ...)

## S3 method for class 'sq'
reverse(x, ..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="reverse_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="reverse_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>reverse()</code> function reverses each sequence in supplied <code>sq</code> object
(e.q. transforms <code>"MIAANYTWIL"</code> to <code>"LIWTYNAAIM"</code>). This operation
does not alter the type of the input object nor its alphabet.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+sq-class">sq</a></code> object of the same type as input
object but each sequence is reversed.
</p>


<h3>See Also</h3>

<p>Functions that affect order of elements:
<code><a href="#topic+bite">bite</a>()</code>,
<code><a href="#topic+collapse">collapse</a>()</code>,
<code><a href="#topic+paste">paste</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGAACGAN", ""), alphabet = "dna_ext")
sq_unt &lt;- sq(c("ATGCAGGA?", "TGACGAGCTTA", "", "TIAALGNIIYRAIE"))

# Reversing sequences:
reverse(sq_ami)
reverse(sq_dna)
reverse(sq_unt)

</code></pre>

<hr>
<h2 id='sq'>Construct sq object from character vector</h2><span id='topic+sq'></span>

<h3>Description</h3>

<p>This function allows the user to construct objects of 
<code><a href="#topic+sq-class">class sq</a></code> from a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sq(
  x,
  alphabet = NULL,
  NA_letter = getOption("tidysq_NA_letter"),
  safe_mode = getOption("tidysq_safe_mode"),
  on_warning = getOption("tidysq_on_warning"),
  ignore_case = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sq_+3A_x">x</code></td>
<td>
<p>[<code>character</code>]<br />
Vector to construct <code>sq</code> object from.</p>
</td></tr>
<tr><td><code id="sq_+3A_alphabet">alphabet</code></td>
<td>
<p>[<code>character</code>]<br />
If provided value is a single string, it will be interpreted as type (see
details). If provided value has length greater than one, it will be treated
as atypical alphabet for <code>sq</code> object and <code>sq</code> type will be
<code>atp</code>. If provided value is <code>NULL</code>, type
guessing will be performed (see details).</p>
</td></tr>
<tr><td><code id="sq_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
<tr><td><code id="sq_+3A_safe_mode">safe_mode</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Default value is <code>FALSE</code>. When turned on, safe mode guarantees that
<code>NA</code> appears within a sequence if and only if input sequence contains
value passed with <code>NA_letter</code>. This means that resulting type might be
different to the one passed as argument, if there are letters in a sequence
that does not appear in the original alphabet.</p>
</td></tr>
<tr><td><code id="sq_+3A_on_warning">on_warning</code></td>
<td>
<p>[<code>"silent" || "message" || "warning" || "error"</code>]<br />
Determines the method of handling warning message. Default value is
<code>"warning"</code>.</p>
</td></tr>
<tr><td><code id="sq_+3A_ignore_case">ignore_case</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If turned on, lowercase letters are turned into respective uppercase ones
and interpreted as such. If not, either <code>sq</code> object must be of type
<strong>unt</strong> or all lowercase letters are interpreted as <code>NA</code> values.
Default value is <code>FALSE</code>. Ignoring case does not work with <strong>atp</strong>
alphabets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>sq</code> covers all possibilities of standard and non-standard
types and alphabets. You can check what 'type' and 'alphabet' exactly are in
<code><a href="#topic+sq-class">sq class</a></code> documentation. There is a guide below on
how function operates and how the program behaves depending on arguments
passed and letters in the sequences.
</p>
<p><code>x</code> parameter should be a character vector. Each element of this vector
is a biological sequence. If this parameter has length 0, object of class
<code>sq</code> with 0 sequences will be created (if not specified, it will have
<strong>dna_bsc</strong> type, which is a result of rules written below). If it
contains sequences of length 0, <code>NULL</code> sequences will be introduced (see
<em>NULL (empty) sequences</em> section in <code><a href="#topic+sq-class">sq class</a></code>).
</p>
<p><strong>Important note:</strong> in all below cases word 'letter' stands for an
element of an alphabet. Letter might consist of more than one character, for
example &quot;<code>Ala</code>&quot; might be a single letter. However, if the user wants to
construct or read sequences with multi-character letters, one has to specify
all letters in <code>alphabet</code> parameter. Details of letters, alphabet and
types can be found in <code><a href="#topic+sq-class">sq class</a></code> documentation.
</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+sq-class">class sq</a></code> with appropriate type.
</p>


<h3>Simple guide to construct</h3>

<p>In many cases, just the <code>x</code> parameter needs to be specified - type of
sequences will be guessed according to rules described below. The user needs
to pay attention, however, because for short sequences type may be guessed
incorrectly - in this case they should specify type in <code>alphabet</code>
parameter.
</p>
<p>If your sequences contain non-standard letters, where each non-standard
letter is one character long (that is, any character that is not an uppercase
letter), you also don't need to specify any parameter. Optionally, you can
explicitly do it by setting <code>alphabet</code> to <code>"unt"</code>.
</p>
<p>In <code>safe mode</code> it is guaranteed that only letters which are equal to
<code>NA_letter</code> argument are interpreted as <code>NA</code> values. Due to that,
resulting alphabet might be different from the <code>alphabet</code> argument.
</p>


<h3>Detailed guide to construct</h3>

<p>Below are listed all possibilities that can occur during the construction of
a <code>sq</code> object:
</p>

<ul>
<li><p> If you don't specify any other parameter than <code>x</code>, function will
try to guess sequence type (it will check in exactly this order):
</p>

<ol>
<li><p> If it contains only ACGT- letters, type will be set to
<strong>dna_bsc</strong>.
</p>
</li>
<li><p> If it contains only ACGU- letters, type will be set to
<strong>rna_bsc</strong>.
</p>
</li>
<li><p> If it contains any letters from 1. and 2. and additionally letters
DEFHIKLMNPQRSVWY*, type will be set to <strong>ami_bsc</strong>.
</p>
</li>
<li><p> If it contains any letters from 1. and additionally letters
WSMKRYBDHVN, type will be set to <strong>dna_ext</strong>.
</p>
</li>
<li><p> If it contains any letters from 2. and additionally letters
WSMKRYBDHVN, type will be set to <strong>rna_ext</strong>.
</p>
</li>
<li><p> If it contains any letters from previous points and additionally
letters JOUXZ, type will be set to <strong>ami_ext</strong>.
</p>
</li>
<li><p> If it contains any letters that exceed all groups mentioned above,
type will be set to <strong>unt</strong>.
</p>
</li></ol>

</li>
<li><p> If you specify <code>alphabet</code> parameter as any of <code>"dna_bsc"</code>,
<code>"dna_ext"</code>, <code>"rna_bsc"</code>, <code>"rna_ext"</code>, <code>"ami_bsc"</code>,
<code>"ami_ext"</code>; then:
</p>

<ul>
<li><p> If <code>safe_mode</code> is <code>FALSE</code>, then sequences will be built
with standard alphabet for given type.
</p>
</li>
<li><p> If <code>safe_mode</code> is <code>TRUE</code>, then sequences will be scanned
for letters not in standard alphabet:
</p>

<ul>
<li><p> If no such letters are found, then sequences will be built with
standard alphabet for given type.
</p>
</li>
<li><p> If at least one such letter is found, then sequences are built with
real alphabet and with type set to <strong>unt</strong>.
</p>
</li></ul>

</li></ul>

</li>
<li><p> If you specify <code>alphabet</code> parameter as <code>"unt"</code>, then
sequences are scanned for alphabet and subsequently built with obtained
alphabet and type <strong>unt</strong>.
</p>
</li>
<li><p> If you specify <code>alphabet</code> parameter as <code>character</code> vector
longer than 1, then type is set to <strong>atp</strong> and alphabet is equal to
letters in said parameter.
</p>
</li></ul>

<p>If <code>ignore_case</code> is set to <code>TRUE</code>, then lowercase letters are
turned into uppercase during their interpretation, unless type is set to
<strong>atp</strong>.
</p>


<h3>Handling <strong>unt</strong> and <strong>atp</strong> types and <code>NA</code> values</h3>

<p>You can convert letters into another using <code><a href="#topic+substitute_letters">substitute_letters</a></code>
and then use <code><a href="#topic+typify">typify</a></code> or <code>sq_type&lt;-</code> function to set type of
<code>sq</code> to <strong>dna_bsc</strong>, <strong>dna_ext</strong>, <strong>rna_bsc</strong>,
<strong>rna_ext</strong>, <strong>ami_bsc</strong> or <strong>ami_ext</strong>. If your sequences
contain <code>NA</code> values, use <code><a href="#topic+remove_na">remove_na</a></code>.
</p>


<h3>See Also</h3>

<p>Functions from input module:
<code><a href="#topic+import_sq">import_sq</a>()</code>,
<code><a href="#topic+random_sq">random_sq</a>()</code>,
<code><a href="#topic+read_fasta">read_fasta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># constructing sq without specifying alphabet:
# Correct sq type will be guessed from appearing letters
## dna_bsc
sq(c("ATGC", "TCGTTA", "TT--AG"))

## rna_bsc
sq(c("CUUAC", "UACCGGC", "GCA-ACGU"))

## ami_bsc
sq(c("YQQPAVVM", "PQCFL"))

## ami cln sq can contain "*" - a letter meaning end of translation:
sq(c("MMDF*", "SYIHR*", "MGG*"))

## dna_ext
sq(c("TMVCCDA", "BASDT-CNN"))

## rna_ext
sq(c("WHDHKYN", "GCYVCYU"))

## ami_ext
sq(c("XYOQWWKCNJLO"))

## unt - assume that one wants to mark some special element in sequence with "%"
sq(c("%%YAPLAA", "PLAA"))

# passing type as alphabet parameter:
# All above examples yield an identical result if type specified is the same as guessed
sq(c("ATGC", "TCGTTA", "TT--AG"), "dna_bsc")
sq(c("CUUAC", "UACCGGC", "GCA-ACGU"), "rna_bsc")
sq(c("YQQPAVVM", "PQCFL"), "ami_bsc")
sq(c("MMDF*", "SYIHR*", "MGG*"), "ami_bsc")
sq(c("TMVCCDA", "BASDT-CNN"), "dna_ext")
sq(c("WHDHKYN", "GCYVCYU"), "rna_ext")
sq(c("XYOQWWKCNJLO"), "ami_ext")
sq(c("%%YAPLAA", "PLAA"), "unt")

# Type doesn't have to be the same as the guessed one if letters fit in the destination alphabet
sq(c("ATGC", "TCGTTA", "TT--AG"), "dna_ext")
sq(c("ATGC", "TCGTTA", "TT--AG"), "ami_bsc")
sq(c("ATGC", "TCGTTA", "TT--AG"), "ami_ext")
sq(c("ATGC", "TCGTTA", "TT--AG"), "unt")

# constructing sq with specified letters of alphabet:
# In sequences below "mA" denotes methyled alanine - two characters are treated as single letter
sq(c("LmAQYmASSR", "LmASMKLKFmAmA"), alphabet = c("mA", LETTERS))
# Order of alphabet letters are not meaningful in most cases
sq(c("LmAQYmASSR", "LmASMKLKFmAmA"), alphabet = c(LETTERS, "mA"))

# reading sequences with three-letter names:
sq(c("ProProGlyAlaMetAlaCys"), alphabet = c("Pro", "Gly", "Ala", "Met", "Cys"))

# using safe mode:
# Safe mode guarantees that no element is read as NA
# But resulting alphabet might be different to the passed one (albeit with warning/error)
sq(c("CUUAC", "UACCGGC", "GCA-ACGU"), alphabet = "dna_bsc", safe_mode = TRUE)
sq(c("CUUAC", "UACCGGC", "GCA-ACGU"), alphabet = "dna_bsc")

# Safe mode guesses alphabet based on whole sequence
long_sequence &lt;- paste0(paste0(rep("A", 4500), collapse = ""), "N")
sq(long_sequence, safe_mode = TRUE)
sq(long_sequence)

# ignoring case:
# By default, lower- and uppercase letters are treated separately
# This behavior can be changed by setting ignore_case = TRUE
sq(c("aTGc", "tcgTTA", "tt--AG"), ignore_case = TRUE)
sq(c("XYOqwwKCNJLo"), ignore_case = TRUE)

# It is possible to construct sq with length 0
sq(character())

# As well as sq with empty sequences
sq(c("AGTGGC", "", "CATGA", ""))

</code></pre>

<hr>
<h2 id='sq_type'>Get type of an sq object</h2><span id='topic+sq_type'></span><span id='topic+sq_type.sq'></span><span id='topic+sq_type+3C-'></span><span id='topic+sq_type+3C-.sq'></span>

<h3>Description</h3>

<p>Returns type of sequences/alphabet contained in
<code><a href="#topic+sq-class">sq</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sq_type(x, ...)

## S3 method for class 'sq'
sq_type(x, ...)

sq_type(x) &lt;- value

## S3 replacement method for class 'sq'
sq_type(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sq_type_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="sq_type_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="sq_type_+3A_value">value</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The name of destination type - any valid sq type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Types returned by this function can be passed as argument to functions like
<code><a href="#topic+random_sq">random_sq</a></code> and <code><a href="#topic+find_invalid_letters">find_invalid_letters</a></code>.
</p>


<h3>Value</h3>

<p>A string, one of: &quot;ami_bsc&quot;, &quot;ami_ext&quot;, &quot;dna_bsc&quot;, &quot;dna_ext&quot;,
&quot;rna_bsc&quot;, &quot;rna_ext&quot;, &quot;unt&quot; or &quot;atp&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sq-class">sq class</a></code>
</p>
<p>Functions that manipulate type of sequences:
<code><a href="#topic+find_invalid_letters">find_invalid_letters</a>()</code>,
<code><a href="#topic+is.sq">is.sq</a>()</code>,
<code><a href="#topic+substitute_letters">substitute_letters</a>()</code>,
<code><a href="#topic+typify">typify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGAACGA", "TGACGAGCTTA", "ACTTTAGC"),
             alphabet = "dna_bsc")

# Extracting type of sq objects:
sq_type(sq_ami)
sq_type(sq_dna)

# Classes are tightly related to these types:
class(sq_ami)[1]
class(sq_dna)[1]

</code></pre>

<hr>
<h2 id='sq-class'>sq: class for keeping biological sequences tidy</h2><span id='topic+sq-class'></span>

<h3>Description</h3>

<p>An object of class <strong>sq</strong> represents a list of biological sequences. It
is the main internal format of the <span class="pkg">tidysq</span> package and most functions
operate on it. The storage method is memory-optimized so that objects
require as little memory as possible (details below).
</p>


<h3>Construction/reading/import of sq objects</h3>

<p>There are multiple ways of obtaining <code>sq</code> objects:
</p>

<ul>
<li><p> constructing from a <code><a href="base.html#topic+character">character</a></code> vector with
<code><a href="#topic+sq">sq</a></code> method,
</p>
</li>
<li><p> constructing from another object with <code><a href="#topic+as.sq">as.sq</a></code> method,
</p>
</li>
<li><p> reading from the FASTA file with <code><a href="#topic+read_fasta">read_fasta</a></code>,
</p>
</li>
<li><p> importing from a format of other package like <span class="pkg">ape</span> or
<span class="pkg">Biostrings</span> with <code><a href="#topic+import_sq">import_sq</a></code>.
</p>
</li></ul>

<p><strong>Important note:</strong> A manual assignment of a class <code>sq</code> to an
object is <strong>strongly discouraged</strong> - due to the usage of low-level
functions for bit packing such assignment may lead to calling one of those
functions during operating on object or even printing it which can cause
a crash of R session and, in consequence, loss of data.
</p>


<h3>Export/writing of sq objects</h3>

<p>There are multiple ways of saving <code>sq</code> objects or converting them into
other formats:
</p>

<ul>
<li><p> converting into a character vector with
<code><a href="#topic+as.character.sq">as.character</a></code> method,
</p>
</li>
<li><p> converting into a character matrix with
<code><a href="#topic+as.matrix.sq">as.matrix</a></code> method,
</p>
</li>
<li><p> saving as FASTA file with <code><a href="#topic+write_fasta">write_fasta</a></code>,
</p>
</li>
<li><p> exporting into a format of other package like <code>ape</code> or
<code>Biostrings</code> with <code><a href="#topic+export_sq">export_sq</a></code>.
</p>
</li></ul>



<h3>Ambiguous letters</h3>

<p>This package is meant to handle amino acid, DNA and RNA sequences. IUPAC
standard for one letter codes includes ambiguous bases that are used to
describe more than one basic standard base. For example, &quot;<code>B</code>&quot; in the
context of DNA code means &quot;any of C, G or T&quot;. As there are operations that
make sense only for unambiguous bases (like <code><a href="#topic+translate">translate</a></code>), this
package has separate types for sequences with &quot;basic&quot; and &quot;extended&quot;
alphabet.
</p>


<h3>Types of sq</h3>

<p>There is need to differentiate <code>sq</code> objects that keep different types
of sequences (DNA, RNA, amino acid), as they use different alphabets.
Furthermore, there are special types for handling non-standard sequence
formats.
</p>
<p>Each <strong>sq</strong> object has exactly one of <strong>types</strong>:
</p>

<ul>
<li> <p><strong>ami_bsc</strong> - (<em>amino acids</em>) represents a list of sequences
of amino acids (peptides or proteins),
</p>
</li>
<li> <p><strong>ami_ext</strong> - same as above, but with possible usage of
ambiguous letters,
</p>
</li>
<li> <p><strong>dna_bsc</strong> - (<em>DNA</em>) represents a list of DNA sequences,
</p>
</li>
<li> <p><strong>dna_ext</strong> - same as above, but with possible usage of
ambiguous letters,
</p>
</li>
<li> <p><strong>rna_bsc</strong> - (<em>RNA</em>) represents a list of RNA sequences
(together with DNA above often collectively called &quot;nucleotide sequences&quot;),
</p>
</li>
<li> <p><strong>rna_ext</strong> - same as above, but with possible usage of
ambiguous letters,
</p>
</li>
<li> <p><strong>unt</strong> - (<em>untyped</em>) represents a list of sequences that do
not have specified type. They are mainly result of reading sequences from
a file that contains some letters that are not in standard nucleotide or
amino acid alphabets and user has not specified them explicitly. They should
be converted to other <strong>sq</strong> classes (using functions like
<code><a href="#topic+substitute_letters">substitute_letters</a></code> or <code><a href="#topic+typify">typify</a></code>),
</p>
</li>
<li> <p><strong>atp</strong> - (<em>atypical</em>) represents sequences that have an
alphabet different from standard alphabets - similarly to <strong>unt</strong>, but
user has been explicitly informed about it. They are result of constructing
sequences or reading from file with provided custom alphabet (for details
see <code><a href="#topic+read_fasta">read_fasta</a></code> and <code><a href="#topic+sq">sq</a></code> function). They are also
result of using function <code><a href="#topic+substitute_letters">substitute_letters</a></code> - users can use
it to for example simplify an alphabet and replace several letters by one.
</p>
</li></ul>

<p>For clarity, <strong>ami_bsc</strong> and <strong>ami_ext</strong> types are often referred
to collectively as <strong>ami</strong> when there is no need to explicitly specify
every possible type. The same applies to <strong>dna</strong> and <strong>rna</strong>.
</p>
<p><code>sq</code> object type is printed when using overloaded method
<code><a href="#topic+sq-print">print</a></code>. It can be also checked and obtained as
a value (that may be passed as argument to function) by using
<code><a href="#topic+sq_type">sq_type</a></code>.
</p>


<h3>Alphabet</h3>

<p>See <code><a href="#topic+alphabet">alphabet</a></code>.
</p>
<p>The user can obtain an alphabet of the <code>sq</code> object using the
<code><a href="#topic+alphabet">alphabet</a></code> function. The user can check which letters are
invalid (i.e. not represented in standard amino acid or nucleotide
alphabet) in each sequence of given <code>sq</code> object by using
<code><a href="#topic+find_invalid_letters">find_invalid_letters</a></code>. To substitute one letter with another
use <code><a href="#topic+substitute_letters">substitute_letters</a></code>.
</p>


<h3>Missing/Not Available values</h3>

<p>There is a possibility of introducing <code><a href="base.html#topic+NA">NA</a></code> values into
sequences. <code>NA</code> value does not represents gap (which are represented by
&quot;<code>-</code>&quot;) or wildcard elements (&quot;<code>N</code>&quot; in the case of nucleotides and
&quot;<code>X</code>&quot; in the case of amino acids), but is used as a representation of
an empty position or invalid letters (not represented in nucleotide or amino
acid alphabet).
</p>
<p><code>NA</code> does not belong to any alphabet. It is printed as &quot;<code>!</code>&quot; and,
thus, it is highly unrecommended to use &quot;<code>!</code>&quot; as special letter in
<strong>atp</strong> sequences (but print character can be changed in options, see
<code><a href="#topic+tidysq-options">tidysq-options</a></code>).
</p>
<p><code>NA</code> might be introduced by:
</p>

<ul>
<li><p> reading fasta file with non-standard letters with
<code><a href="#topic+read_fasta">read_fasta</a></code> with <code>safe_mode</code> argument set to <code>TRUE</code>,
</p>
</li>
<li><p> replacing a letter with <code>NA</code> value with
<code><a href="#topic+substitute_letters">substitute_letters</a></code>,
</p>
</li>
<li><p> subsetting sequences beyond their lengths with <code><a href="#topic+bite">bite</a></code>.
</p>
</li></ul>

<p>The user can convert sequences that contain <code>NA</code> values into
<code>NULL</code> sequences with <code><a href="#topic+remove_na">remove_na</a></code>.
</p>


<h3>NULL (empty) sequences</h3>

<p><code>NULL</code> sequence is a sequence of length 0.
</p>
<p><code>NULL</code> sequences might be introduced by:
</p>

<ul>
<li><p> constructing <code>sq</code> object from character string of length zero,
</p>
</li>
<li><p> using the <code><a href="#topic+remove_ambiguous">remove_ambiguous</a></code> function,
</p>
</li>
<li><p> using the <code><a href="#topic+remove_na">remove_na</a></code> function,
</p>
</li>
<li><p> subsetting <code>sq</code> object with <code><a href="#topic+bite">bite</a></code> function (and
negative indices that span at least <code>-1:-length(sequence)</code>.
</p>
</li></ul>



<h3>Storage format</h3>

<p><code>sq</code> object is, in fact, <strong>list of raw vectors</strong>. The fact that it
is list implies that the user can concatenate <code>sq</code> objects using
<code><a href="#topic+sq-concatenate">c</a></code> method and subset them using
<code><a href="#topic+sq-extract">extract operator</a></code>. Alphabet is kept as an
attribute of the object.
</p>
<p>Raw vectors are the most efficient way of storage - each letter of a
sequence is assigned an integer (its index in alphabet of <code>sq</code> object).
Those integers in binary format fit in less than 8 bits, but normally are
stored on 16 bits. However, thanks to bit packing it is possible to remove
unused bits and store numbers more tightly. This means that all operations
must either be implemented with this packing in mind or accept a little time
overhead induced by unpacking and repacking sequences. However, this cost
is relatively low in comparison to amount of saved memory.
</p>
<p>For example - <strong>dna_bsc</strong> alphabet consists of 5 values: ACGT-. They
are assigned numbers 0 to 4 respectively. Those numbers in binary format
take form: <code>000</code>, <code>001</code>, <code>010</code>, <code>011</code>, <code>100</code>. Each
of these letters can be coded with just 3 bits instead of 8 which is
demanded by <code>char</code> - this allows us to save more than 60% of memory
spent on storage of basic nucleotide sequences.
</p>


<h3>tibble compatibility</h3>

<p><code>sq</code> objects are compatible with <code><a href="tibble.html#topic+tibble">tibble</a></code> class -
that means one can have an <code>sq</code> object as a column of a <code>tibble</code>.
There are overloaded print methods, so that it is printed in pretty format.
</p>

<hr>
<h2 id='sqapply'>Apply function to each sequence</h2><span id='topic+sqapply'></span>

<h3>Description</h3>

<p>Applies given function to each sequence. Sequences are passed to function as character vectors
(or numeric, if type of <code>sq</code> is <strong>enc</strong>) or single character strings, depending on 
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqapply(
  x,
  fun,
  ...,
  single_string = FALSE,
  NA_letter = getOption("tidysq_NA_letter")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqapply_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="sqapply_+3A_fun">fun</code></td>
<td>
<p>[<code>function(1)</code>]<br />
A function to apply to each sequence in <code>sq</code> object; it should
take a character vector, numeric vector or single character string as an input.</p>
</td></tr>
<tr><td><code id="sqapply_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="sqapply_+3A_single_string">single_string</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
A value indicating in which form sequences should be
passed to the function <code>fun</code>; if <code>FALSE</code> (default), they will be treated as character
vectors, if <code>TRUE</code>, they will be pasted into a single string.</p>
</td></tr>
<tr><td><code id="sqapply_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values returned by function for each sequence in corresponding order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sq-class">sq</a></code> <code><a href="base.html#topic+lapply">lapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGNBAACGAN", "TGACGAGCTTA"),
             alphabet = "dna_bsc")
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_unt &lt;- sq(c("ATGCAGGA?", "TGACGAGCTTA", "", "TIAALGNIIYRAIE"))

# Counting how may "A" elements are present in sequences:

sqapply(sq_dna, function(sequence) sum(sequence == "A"))
sqapply(sq_ami, function(sequence) sum(sequence == "A"))
sqapply(sq_unt, function(sequence) sum(sequence == "A"))

</code></pre>

<hr>
<h2 id='sqconcatenate'>Concatenate sq objects</h2><span id='topic+sqconcatenate'></span><span id='topic+sq-concatenate'></span>

<h3>Description</h3>

<p>Merges multiple <code><a href="#topic+sq-class">sq</a></code> and possibly
<code>character</code> objects into one larger <code>sq</code> object.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqconcatenate_+3A_...">...</code></td>
<td>
<p>[<code>sq</code> || <code>character</code>]<br />
Multiple objects. For exact behavior, check Details section. First argument
must be of <code>sq</code> class due to R mechanism of single dispatch. If this is
a problem, recommended alternative is <code><a href="vctrs.html#topic+vec_c">vec_c</a></code> method from
<code><a href="vctrs.html#topic+vctrs-package">vctrs-package</a></code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whenever all passed objects are of one of standard types (that is,
<strong>dna_bsc</strong>, <strong>dna_ext</strong>, <strong>rna_bsc</strong>, <strong>rna_ext</strong>,
<strong>ami_bsc</strong> or <strong>ami_ext</strong>), returned object is of the same class,
as no changes to alphabet are needed.
</p>
<p>It's possible to mix both basic and extended types within one call to
<code>c()</code>, however they all must be of the same type (that is, either
<strong>dna</strong>, <strong>rna</strong> or <strong>ami</strong>). In this case, returned object
is of extended type.
</p>
<p>Mixing <strong>dna</strong>, <strong>rna</strong> and <strong>ami</strong> types is prohibited, as
interpretation of letters differ depending on the type.
</p>
<p>Whenever all objects are either of <strong>atp</strong> type, returned object is also
of this class and resulting alphabet is equal to set union of all input
alphabets.
</p>
<p><strong>unt</strong> type can be mixed with any other type, resulting in <strong>unt</strong>
object with alphabet equal to set union of all input alphabets. In this case,
it is possible to concatenate <strong>dna</strong> and <strong>ami</strong> objects, for
instance, by concatenating one of them first with <strong>unt</strong> object.
However, it is strongly discouraged, as it may result in unwanted
concatenation of DNA and amino acid sequences.
</p>
<p>Whenever a character vector appears, it does not influence resulting sq type.
Each element is treated as separate sequence. If any of letters in this
vector does not appear in resulting alphabet, it is silently replaced with
<code>NA</code>.
</p>
<p>Due to R dispatch mechanism passing character vector as first will return
class-less list. This behavior is effectively impossible and definitely
unrecommended to fix, as fixing it would involve changing <code>c</code> primitive.
If such possibility is necessary, <code><a href="vctrs.html#topic+vec_c">vec_c</a></code> is a better
alternative.
</p>


<h3>Value</h3>

<p><code><a href="#topic+sq-class">sq</a></code> object with length equal to sum of
lengths of individual objects passed as parameters. Elements of
<code><a href="#topic+sq-class">sq</a></code> are concatenated just as if they were normal
lists (see <code><a href="base.html#topic+c">c</a></code>).
</p>


<h3>See Also</h3>

<p>Functions from utility module:
<code><a href="#topic++3D+3D.sq">==.sq</a>()</code>,
<code><a href="#topic+get_sq_lengths">get_sq_lengths</a>()</code>,
<code><a href="#topic+is.sq">is.sq</a>()</code>,
<code><a href="#topic+sqextract">sqextract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna_1 &lt;- sq(c("GGACTGCA", "CTAGTA", ""), alphabet = "dna_bsc")
sq_dna_2 &lt;- sq(c("ATGACA", "AC-G", "-CCAT"), alphabet = "dna_bsc")
sq_dna_3 &lt;- sq(character(), alphabet = "dna_bsc")
sq_dna_4 &lt;- sq(c("BNACV", "GDBADHH"), alphabet = "dna_ext")
sq_rna_1 &lt;- sq(c("UAUGCA", "UAGCCG"), alphabet = "rna_bsc")
sq_rna_2 &lt;- sq(c("-AHVRYA", "G-U-HYR"), alphabet = "rna_ext")
sq_rna_3 &lt;- sq("AUHUCHYRBNN--", alphabet = "rna_ext")
sq_ami &lt;- sq("ACHNK-IFK-VYW", alphabet = "ami_bsc")
sq_unt &lt;- sq("AF:gf;PPQ^&amp;XN")

# Concatenating dna_bsc sequences:
c(sq_dna_1, sq_dna_2, sq_dna_3)
# Concatenating rna_ext sequences:
c(sq_rna_2, sq_rna_3)
# Mixing dna_bsc and dna_ext:
c(sq_dna_1, sq_dna_4, sq_dna_2)

# Mixing DNA and RNA sequences doesn't work:
## Not run: 
c(sq_dna_3, sq_rna_1)

## End(Not run)

# untsq can be mixed with DNA, RNA and amino acids:
c(sq_ami, sq_unt)
c(sq_unt, sq_rna_1, sq_rna_2)
c(sq_dna_2, sq_unt, sq_dna_3)

# Character vectors are also acceptable:
c(sq_dna_2, "TGCA-GA")
c(sq_rna_2, c("UACUGGGACUG", "AUGUBNAABNRYYRAU"), sq_rna_3)
c(sq_unt, "&amp;#JIA$O02t30,9ec", sq_ami)

</code></pre>

<hr>
<h2 id='sqextract'>Extract parts of a sq object</h2><span id='topic+sqextract'></span><span id='topic+sq-extract'></span>

<h3>Description</h3>

<p>Operator to extract subsets of sq objects.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqextract_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="sqextract_+3A_i">i</code>, <code id="sqextract_+3A_j">j</code>, <code id="sqextract_+3A_...">...</code></td>
<td>
<p>[<code>numeric</code> || <code>logical</code>]<br />
Indices specifying elements to extract.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function follows <code><a href="vctrs.html#topic+vctrs-package">vctrs-package</a></code> conventions
regarding argument interpretation for indexing vectors, which are a bit
stricter that normal R conventions, for example implicit argument recycling
is prohibited. Subsetting of the <code>sq</code> object does not affect its
attributes (class and alphabet of the object). Attempt to extract elements
using indices not present in the object will return an error.
</p>


<h3>Value</h3>

<p><code><a href="#topic+sq-class">sq</a></code> object of the same type as the input,
containing extracted elements
</p>


<h3>See Also</h3>

<p>Functions from utility module:
<code><a href="#topic++3D+3D.sq">==.sq</a>()</code>,
<code><a href="#topic+get_sq_lengths">get_sq_lengths</a>()</code>,
<code><a href="#topic+is.sq">is.sq</a>()</code>,
<code><a href="#topic+sqconcatenate">sqconcatenate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating object to work on:
sq_unt &lt;- sq(c("AHSNLVSCTK$SH%&amp;VS", "YQTVKA&amp;#BSKJGY",
               "IAKVGDCTWCTY&amp;GT", "AVYI#VSV&amp;*DVGDJCFA"))

# Subsetting using numeric vectors
# Extracting second element of the object:
sq_unt[2]

# Extracting elements from second to fourth:
sq_unt[2:4]

# Extracting all elements except the third:
sq_unt[-3]

# Extracting first and third element:
sq_unt[c(1,3)]

# Subsetting using logical vectors
# Extracing first and third element:
sq_unt[c(TRUE, FALSE, TRUE, FALSE)]

# Subsetting using empty vector returns all values:
sq_unt[]

# Using NULL, on the other hand, returns empty sq:
sq_unt[NULL]

</code></pre>

<hr>
<h2 id='sqprint'>Print sq object</h2><span id='topic+sqprint'></span><span id='topic+sq-print'></span>

<h3>Description</h3>

<p>Prints input <code><a href="#topic+sq-class">sq</a></code> object in a
human-friendly form.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqprint_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="sqprint_+3A_max_sequences">max_sequences</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
How many sequences should be printed.</p>
</td></tr>
<tr><td><code id="sqprint_+3A_use_color">use_color</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should sequences be colored?</p>
</td></tr>
<tr><td><code id="sqprint_+3A_letters_sep">letters_sep</code></td>
<td>
<p>[<code>character(1)</code>]<br />
How the letters should be separated.</p>
</td></tr>
<tr><td><code id="sqprint_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
<tr><td><code id="sqprint_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print</code> method is often called implicitly by calling variable name.
Only explicit calling of this method allows its parameters to be changed.
</p>
<p>Printed information consists of three parts:
</p>

<ul>
<li><p> First line is always a header that contains info about the type of
sequences contained.
</p>
</li>
<li><p> The next part is the content. Each sequence has its own line, but not
all sequences are printed. The number of printed sequences is limited by
parameter <code>max_sequences</code>, defaulting to 10. These sequences are
printed with:
</p>

<ul>
<li><p> left-aligned index of sequence in square brackets (e.g. <code>[3]</code>),
</p>
</li>
<li><p> left-aligned sequence data (more about it in paragraph below),
</p>
</li>
<li><p> right-aligned sequence length in angle brackets (e.g. <code>&lt;27&gt;</code>).
</p>
</li></ul>

</li>
<li><p> Finally, if number of sequences is greater than <code>max_sequences</code>,
then a footer is displayed with how many sequences are there and how many
were printed.
</p>
</li></ul>

<p>Each sequence data is printed as letters. If sequence is too long to fit in
one line, then only a subsequence is displayed - a subsequence that begins
from the first letter. Sequence printing is controlled by <code>letters_sep</code>
and <code>NA_letter</code> parameters. The first one specifies a string that should
be inserted between any two letters. By default it's empty when all letters
are one character in length; and a space otherwise. <code>NA_letter</code> dictates
how <code>NA</code> values are displayed, by default it's an exclamation mark
(&quot;<code>!</code>&quot;).
</p>
<p>Most consoles support color printing, but when any of these do not, then the
user might use <code>use_color</code> parameter set to <code>FALSE</code> - or better
yet, change related option value, where said option is called
<code>"tidysq_print_use_color"</code>.
</p>


<h3>Value</h3>

<p>An object that was passed as the first argument to the function.
It is returned invisibly (equivalent of <code>invisible(x)</code>)
</p>


<h3>See Also</h3>

<p>Functions that display sequence info:
<code><a href="#topic+get_tidysq_options">get_tidysq_options</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_ami &lt;- sq(c("MIAANYTWIL","TIAALGNIIYRAIE", "NYERTGHLI", "MAYXXXIALN"),
             alphabet = "ami_ext")
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGNBAACGAN", "TGACGAGCTTA"),
             alphabet = "dna_bsc")
sq_unt &lt;- sq(c("ATGCAGGA?", "TGACGAGCTTA", "", "TIAALGNIIYRAIE"))

# Printing without explicit function calling with default parameters:
sq_ami
sq_dna
sq_unt

# Printing with explicit function calling and specific parameters:
print(sq_ami)
print(sq_dna, max_sequences = 1, use_color = FALSE)
print(sq_unt, letters_sep = ":")

</code></pre>

<hr>
<h2 id='substitute_letters'>Substitute letters in a sequence</h2><span id='topic+substitute_letters'></span><span id='topic+substitute_letters.sq'></span>

<h3>Description</h3>

<p>Replaces all occurrences of a letter with another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substitute_letters(x, encoding, ...)

## S3 method for class 'sq'
substitute_letters(x, encoding, ..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substitute_letters_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="substitute_letters_+3A_encoding">encoding</code></td>
<td>
<p>[<code>character</code> || <code>numeric</code>]<br />
A dictionary (named vector), where names are letters to be replaced and
elements are their respective replacements.</p>
</td></tr>
<tr><td><code id="substitute_letters_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="substitute_letters_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>substitute_letters</code> allows to replace unwanted letters in any sequence
with user-defined or IUPAC  symbols. Letters can also be replaced with
<code><a href="base.html#topic+NA">NA</a></code> values, so that they  can be later removed from the sequence
by <code><a href="#topic+remove_na">remove_na</a></code> function.
</p>
<p>It doesn't matter whether replaced or replacing letter is single or multiple
character. However, the user cannot replace multiple letters with one nor one
letter with more than one.
</p>
<p>Of course, multiple different letters can be encoded to the same symbol, so
<code>c(A = "rep1", H = "rep1", G = "rep1")</code> is allowed, but
<code>c(AHG = "rep1")</code> is not (unless there is a letter &quot;<code>AHG</code>&quot; in
the alphabet). By doing that any information of separateness of original
letters is lost, so it isn't possible to retrieve original sequence after
this operation.
</p>
<p>All encoding names must be letters contained within the alphabet, otherwise
an error will be thrown.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+sq-class">sq</a></code> object of <strong>atp</strong> type with
updated alphabet.
</p>


<h3>See Also</h3>

<p>Functions that manipulate type of sequences:
<code><a href="#topic+find_invalid_letters">find_invalid_letters</a>()</code>,
<code><a href="#topic+is.sq">is.sq</a>()</code>,
<code><a href="#topic+sq_type">sq_type</a>()</code>,
<code><a href="#topic+typify">typify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating objects to work on:
sq_dna &lt;- sq(c("ATGCAGGA", "GACCGAACGAN", "TGACGAGCTTA", "ACTNNAGCN"),
             alphabet = "dna_ext")
sq_ami &lt;- sq(c("MIOONYTWIL","TIOOLGNIIYROIE", "NYERTGHLI", "MOYXXXIOLN"),
             alphabet = "ami_ext")
sq_atp &lt;- sq(c("mALPVQAmAmA", "mAmAPQ"), alphabet = c("mA", LETTERS))

# Not all letters must have their encoding specified:
substitute_letters(sq_dna, c(T = "t", A = "a", C = "c", G = "g"))
substitute_letters(sq_ami, c(M = "X"))

# Multiple character letters are supported in encodings:
substitute_letters(sq_atp, c(mA = "-"))
substitute_letters(sq_ami, c(I = "ough", O = "eau"))

# Numeric substitutions are allowed too, these are coerced to characters:
substitute_letters(sq_dna, c(N = 9, G = 7))

# It's possible to replace a letter with NA value:
substitute_letters(sq_ami, c(X = NA_character_))

</code></pre>

<hr>
<h2 id='translate'>Convert DNA or RNA into proteins using genetic code</h2><span id='topic+translate'></span><span id='topic+translate.sq_dna_bsc'></span><span id='topic+translate.sq_rna_bsc'></span>

<h3>Description</h3>

<p>This function allows the user to input DNA or RNA sequences and
acquire sequences of corresponding proteins, where correspondence is encoded
in specified table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate(x, table = 1, ...)

## S3 method for class 'sq_dna_bsc'
translate(x, table = 1, ..., NA_letter = getOption("tidysq_NA_letter"))

## S3 method for class 'sq_rna_bsc'
translate(x, table = 1, ..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_+3A_x">x</code></td>
<td>
<p>[<code>sq_dna_bsc</code> || <code>sq_rna_bsc</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="translate_+3A_table">table</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
The number of translation table used, as specified
<a href="https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi">here</a>.</p>
</td></tr>
<tr><td><code id="translate_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="translate_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DNA and RNA sequences use combinations of three consecutive nucleic acids to
encode one of 22 amino acids. This encoding is called &quot;genetic code&quot;.
</p>
<p><code>translate()</code> first splits passed DNA or RNA sequences into
three-letter chunks. Then searches the codon table for the entry where the
key is equal to the current chunk and the value is one letter that encodes
the corresponding protein. These resulting letters are then pasted into one
sequence for each input sequence.
</p>
<p>Due to how the tables works, <code>translate()</code> does not support inputting
sequences with extended alphabets, as ambiguous letters in most cases cannot
be translated into exactly one protein.
</p>
<p>Moreover, this function raises an error whenever input sequence contain
either &quot;<code>-</code>&quot; or <code>NA</code> value.
</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+sq-class">class sq</a></code> with <strong>ami_bsc</strong>
type.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remove_ambiguous">remove_ambiguous</a></code>, <code><a href="#topic+substitute_letters">substitute_letters</a></code> and
<code><a href="#topic+typify">typify</a></code> for necessary actions before using <code>translate()</code>
</p>
<p>Functions interpreting sq in biological context:
<code><a href="#topic++25has+25">%has%</a>()</code>,
<code><a href="#topic+complement">complement</a>()</code>,
<code><a href="#topic+find_motifs">find_motifs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sq_dna &lt;- sq(c("TACTGGGCATGA", "CAGGTC", "TAGTCCTAG"), alphabet = "dna_bsc")
translate(sq_dna)

</code></pre>

<hr>
<h2 id='typify'>Set type of an sq object</h2><span id='topic+typify'></span><span id='topic+typify.sq'></span>

<h3>Description</h3>

<p>Sets sequence type (and, consequently, alphabet attribute) to
one of <strong>ami</strong>, <strong>dna</strong> or <strong>rna</strong> types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typify(x, dest_type, ...)

## S3 method for class 'sq'
typify(x, dest_type, ..., NA_letter = getOption("tidysq_NA_letter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typify_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="typify_+3A_dest_type">dest_type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The name of destination type - one of <code>"dna_bsc"</code>, <code>"dna_ext"</code>,
<code>"rna_bsc"</code>, <code>"rna_ext"</code>, <code>"ami_bsc"</code> and <code>"ami_ext"</code>.</p>
</td></tr>
<tr><td><code id="typify_+3A_...">...</code></td>
<td>
<p>further arguments to be passed from or to other methods.</p>
</td></tr>
<tr><td><code id="typify_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes functions from I/O module return sequences of incorrect type, most
often <strong>unt</strong> (which indicates no type). It happens mostly whenever
there are letters that don't fit into target alphabet. After replacing wrong
letters with correct ones with <code><a href="#topic+substitute_letters">substitute_letters</a></code> the user has
sequences of type <strong>atp</strong>, even if their alphabet is contained in the
target one. At the same time, many functions demand sequences to be of
standard type (i.e. <strong>ami</strong>, <strong>dna</strong> or <strong>rna</strong>) or behave
differently for these.
</p>
<p><code>typify()</code> is used to help with these situations by allowing the user
to convert their sequences to target type. There are some conditions that
must be met to use this function. The most important is that typified
<code>sq</code> object must not contain invalid letters. If this condition is not
satisfied, an error is thrown.
</p>
<p>If <code>dest_type</code> is equal to type of <code>sq</code>, function simply returns
input value.
</p>


<h3>Value</h3>

<p><code><a href="#topic+sq-class">sq</a></code> object with the same letters as input
<code>x</code>, but with type as specified in <code>dest_type</code>.
</p>


<h3>See Also</h3>

<p>Functions that manipulate type of sequences:
<code><a href="#topic+find_invalid_letters">find_invalid_letters</a>()</code>,
<code><a href="#topic+is.sq">is.sq</a>()</code>,
<code><a href="#topic+sq_type">sq_type</a>()</code>,
<code><a href="#topic+substitute_letters">substitute_letters</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Constructing sq object with strange characters (type will be set to "unt"):
sq_unt &lt;- sq(c("&amp;VPLG&amp;#", "##LCG"))

# Substituting letters with "X", which stands for unknown amino acid:
sq_sub &lt;- substitute_letters(sq_unt, c(`&amp;` = "X", `#` = "X"))

# Setting extended amino acid type (only extended one has "X" letter):
typify(sq_sub, "ami_ext")

</code></pre>

<hr>
<h2 id='write_fasta'>Save sq to fasta file</h2><span id='topic+write_fasta'></span>

<h3>Description</h3>

<p>Writes <code><a href="#topic+sq-class">sq</a></code> objects with their names to
a fasta file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_fasta(
  x,
  name,
  file,
  width = 80,
  NA_letter = getOption("tidysq_NA_letter")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_fasta_+3A_x">x</code></td>
<td>
<p>[<code>sq</code>]<br />
An object this function is applied to.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_name">name</code></td>
<td>
<p>[<code>character</code>]<br />
Vector of sequence names. Must be of the same length as <code>sq</code> object.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_file">file</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Absolute path to file to write to.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_width">width</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
Maximum number of characters to put in each line of file. Must be positive.</p>
</td></tr>
<tr><td><code id="write_fasta_+3A_na_letter">NA_letter</code></td>
<td>
<p>[<code>character(1)</code>]<br />
A string that is used to interpret and display <code>NA</code> value in the
context of <code><a href="#topic+sq-class">sq class</a></code>. Default value equals to
&quot;<code>!</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whenever a name has more letters than <code>width</code> parameter, nothing
happens, as only sequences are split to fit within designated space.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>See Also</h3>

<p>Functions from output module:
<code><a href="#topic+as.character.sq">as.character.sq</a>()</code>,
<code><a href="#topic+as.matrix.sq">as.matrix.sq</a>()</code>,
<code><a href="#topic+as.sq">as.sq</a>()</code>,
<code><a href="#topic+export_sq">export_sq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sq_dna &lt;- sq(c("ACTGCTG", "CTTAGA", "CCCT", "CTGAATGT"),
             alphabet = "dna_bsc")
write_fasta(sq_dna,
            c("bat", "cat", "rat", "elephant_swallowed_by_A_snake"),
            "~/fasta_rubbish/example.fasta")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
