<!DOCTYPE html><html><head><title>Help for package countries</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {countries}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auto_melt'><p>Automatic pivoting of country and year columns to a long format</p></a></li>
<li><a href='#auto_merge'><p>Simplified merging supporting different country nomenclatures and date formats</p></a></li>
<li><a href='#check_countries_api'><p>Check if the connection to Countries REST API is working</p></a></li>
<li><a href='#check_wide_format'><p>Check for wide country data formats</p></a></li>
<li><a href='#country_info'><p>Get information about countries</p></a></li>
<li><a href='#country_name'><p>Convert and translate country names</p></a></li>
<li><a href='#country_reference_list'><p>Conversion table</p></a></li>
<li><a href='#country_reference_list_long'><p>Conversion table in long format</p></a></li>
<li><a href='#find_countrycol'><p>Finds columns containing country names</p></a></li>
<li><a href='#find_keycol'><p>Find a set of columns that uniquely identifies table entries</p></a></li>
<li><a href='#find_timecol'><p>Finds columns containing date and year data</p></a></li>
<li><a href='#is_country'><p>Tests whether a string is a country name</p></a></li>
<li><a href='#is_date'><p>Test whether the input is a date</p></a></li>
<li><a href='#is_keycol'><p>Test whether a set of column could be a data frame key</p></a></li>
<li><a href='#list_countries'><p>Get a list of country names</p></a></li>
<li><a href='#list_fields'><p>List of accepted fields for the function country_info</p></a></li>
<li><a href='#match_table'><p>Create a conversion table for country names</p></a></li>
<li><a href='#Mode'><p>Statistical mode of a vector</p></a></li>
<li><a href='#palettes_countries'><p>Discrete colour palettes</p></a></li>
<li><a href='#quick_map'><p>Easily visualise country data with a map</p></a></li>
<li><a href='#random_countries'><p>Output random country names</p></a></li>
<li><a href='#which_min'><p>Return location of minimum, maximum and mode values' index</p></a></li>
<li><a href='#world'><p>World map data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Deal with Country Data in an Easy Way</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Wrangle country data more effectively and quickly. 
    This package contains functions to easily identify and convert country names,
    download country information, merge country data from different sources, 
    and make quick world maps.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringdist, tidyr, stringr, dplyr, knitr, fastmatch,
lubridate, utils, methods, stats, httr, jsonlite, ggplot2,
viridis, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.table, rmarkdown, testthat, curl</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fbellelli.github.io/countries/">https://fbellelli.github.io/countries/</a>,
<a href="https://github.com/fbellelli/countries">https://github.com/fbellelli/countries</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fbellelli/countries/issues">https://github.com/fbellelli/countries/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-21 10:37:44 UTC; fsb</td>
</tr>
<tr>
<td>Author:</td>
<td>Francesco Saverio Bellelli [aut, cre, cph] (https://fbellelli.com/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francesco Saverio Bellelli &lt;fsabellelli@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 11:02:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='auto_melt'>Automatic pivoting of country and year columns to a long format</h2><span id='topic+auto_melt'></span>

<h3>Description</h3>

<p>When at least 3 country names or years are found in the column names, the function will automatically transform the table from a wide to a long format by pivoting the country/year columns.
This is equivalent to applying <code>tidyr::pivot_longer()</code> or <code>data.table::melt()</code> on the columns with years or countries as names.
The function is able to detect years also when they are preceded by a prefix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_melt(
  x,
  names_to = "pivoted_colnames",
  values_to = "pivoted_data",
  verbose = TRUE,
  pivoting_info = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_melt_+3A_x">x</code></td>
<td>
<p>A data.frame object to check and pivot country or year columns.</p>
</td></tr>
<tr><td><code id="auto_melt_+3A_names_to">names_to</code></td>
<td>
<p>String indicating how the column holding the name of the pivoted columns should be called in the output table. Default is <code>"pivoted_colnames"</code></p>
</td></tr>
<tr><td><code id="auto_melt_+3A_values_to">values_to</code></td>
<td>
<p>String indicating how the column containing the values of the pivoted columns should be called in the output table. Default is <code>"pivoted_data"</code></p>
</td></tr>
<tr><td><code id="auto_melt_+3A_verbose">verbose</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code> (the default), a message will be displayed on the console indicating which columns are being pivoted. If set to <code>FALSE</code>, the messages are turned off.</p>
</td></tr>
<tr><td><code id="auto_melt_+3A_pivoting_info">pivoting_info</code></td>
<td>
<p>Logical value indicating whether to return the list of names of the column that have been pivoted. Default is <code>FALSE</code>. If set to <code>TRUE</code>, the output will be a list instead of simple data.frame. Teh list will contain 1) the pivoted table, 2) the list of pivoted columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table transformed into a &quot;long&quot; format by pivoting country or year columns. If year columns are found, a numeric column called <code>"year_pivoted_colnames"</code> is added isolating the years extracted from the table header's.
</p>


<h3>See Also</h3>

<p><a href="#topic+auto_merge">auto_merge</a>, <a href="#topic+find_countrycol">find_countrycol</a>,<a href="#topic+find_timecol">find_timecol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
example &lt;- data.frame(Date = c("01.01.2019", "01.02.2019", "01.03.2019"),
                      Japan = 1:3,
                      Norway = 2:4,
                      Germany = 3:5,
                      US = 4:6)
example2 &lt;- data.frame(Sector = c("Agriculture", "Mining", "Forestry"),
                       X2000 = 1:3,
                       X2001 = 2:4,
                       X2002 = 3:5,
                       X2003 = 4:6)

# examples pivotting countries and years from column names
auto_melt(example)
auto_melt(example2)
</code></pre>

<hr>
<h2 id='auto_merge'>Simplified merging supporting different country nomenclatures and date formats</h2><span id='topic+auto_merge'></span>

<h3>Description</h3>

<p>The aim of this function is to simplify country data merging for quick analyses. Compared to a normal merge function <code>auto_merge()</code>:
</p>

<ul>
<li><p> Is able to perform the merging of multiple data tables at once.
</p>
</li>
<li><p> Supports automatic detection of columns to merge.
</p>
</li>
<li><p> It is able to handle different country naming conventions and date formats. For example, it will be able to recognise that &quot;Italy&quot; and &quot;ITA&quot; refer to the same country and will merge the two entries across tables.
</p>
</li>
<li><p> It detects if data is in a wide format with country names or years in the column names and will automatically pivot the data.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>auto_merge(
  ...,
  by = NULL,
  country_to = "ISO3",
  inner_join = FALSE,
  merging_info = FALSE,
  verbose = TRUE,
  auto_melt = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_merge_+3A_...">...</code></td>
<td>
<p>Data to be merged. Inputs need to be data frames or coercible to data frame. Tables can also be provided into a single list e.g. <code>tab1, tab2, tab3</code> or <code>list(tab1, tab2, tab3)</code>.</p>
</td></tr>
<tr><td><code id="auto_merge_+3A_by">by</code></td>
<td>
<p>A list or a vector indicating the columns to be used for merging the data. <em>If not provided, the function will try to automatically detect columns to be merged</em>. For more information, refer to the details sections.</p>
</td></tr>
<tr><td><code id="auto_merge_+3A_country_to">country_to</code></td>
<td>
<p>Nomenclature to which country names should be converted to in the output. Default is <code>ISO3</code>. For a description of possible options, refer to the table in the vignette <a href="https://fbellelli.github.io/countries/articles/dealing_with_names.html">Dealing with country names</a>.</p>
</td></tr>
<tr><td><code id="auto_merge_+3A_inner_join">inner_join</code></td>
<td>
<p>Logical value indicating whether to perform an inner join. The default is <code>FALSE</code>, which results in a full join of the provided tables.</p>
</td></tr>
<tr><td><code id="auto_merge_+3A_merging_info">merging_info</code></td>
<td>
<p>Logical value. If <code>TRUE</code>, the function will output a list containing the merged data and information generated during the merging process, such as information on columns that have been merged or the conversion table used for country names. The default is <code>FALSE</code>, which results into a single merged table being returned.</p>
</td></tr>
<tr><td><code id="auto_merge_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to print status messages on the console. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="auto_merge_+3A_auto_melt">auto_melt</code></td>
<td>
<p>Logical value indicating whether to automatically pivot country names or years present in the column names. Default is <code>TRUE</code>. When at least 3 country names or years are found in the column names, the function will automatically transform the table from a wide to a long format by pivoting the country/year columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Automatic detection of columns to merge</strong>.
The automatic detection process starts by first identifying the key of each table, i.e. a set of variables identifying the entries in the table. This process is optimised for common formats of country data.
The function will then try to match key columns across tables based on their values.
Columns containing country names and time information are identified and are processed to take into account different nomenclatures and time formats.
This automatic process works for the most common dataset structures, but it is not foolproof. Therefore, we always advise to check the columns that are being merged by setting <code>verbose = TRUE</code> and reading the printout.
Moreover, users should be aware that this automatic detection process can increase the overall merging time considerably. This can be especially long for tables containing many columns or when a large number of tables is being merged.
</p>
<p><strong>Formatting of <code>by</code> argument</strong>
If an argument is provided to <code>by</code>, it needs to be either 1) a list of column names, or 2) a vector of regular expressions. The format requirements are the following:
</p>

<ol>
<li><p> In case a <strong>list</strong> is passed, each element of the list must be a vector of length equal to the number of tables being merged (i.e., if 3 tables are being merged, the list needs to contain all vectors of length 3). The vectors should contain the names of columns to be merged in each table, <code>NA</code> can be inserted for tables that do not contain the variable, and names should be ordered in the same order of the tables that are being merged (i.e. the first column name should be present in the first table being merged). The name of the merged columns can be modified by assigning a name to the elements of the list. For example, <code>list("countries"=c("Nation",NA,"COUNTRY"), "sector"=c("Industry","industry",NA))</code> is requesting to merge the columns <code>tab1$Nation</code> and <code>tab3$COUNTRY</code>, and the columns <code>tab1$Industry</code> and <code>tab2$industry</code>. These two merged columns will be named <code>"countries"</code> and <code>"sector"</code> in the output, as requested by the user.
</p>
</li>
<li><p> In case a <strong>vector</strong> is passed, each element is interpreted as a regular expression to be used for matching the columns to be merged. For example, the same order provided in the list example could be written as <code>c("countries"="Nation|COUNTRY", "sector"="[Ii]ndustry")</code>. This will merge the first column in each table whose name matches the pattern described by the regular expression and will name the two resulting columns as <code>"countries"</code> and <code>"sector"</code> respectively.
</p>
</li></ol>



<h3>Value</h3>

<p>If <code>merging_info = FALSE</code> a single merged table is returned. If <code>merging_info = TRUE</code>, a list object is returned, containing the merged table (<code>merged_table</code>), a table summarising which columns have been merged (<code>info_merged_columns</code>), a table summarising the conversion of country names (<code>info_country_names</code>), a table summarising the conversion of time columns to a common format (<code>info_time_formats</code>), a list of all the columns that have been pivoted when wide tables with country or years in column names were detected (<code>pivoted_columns</code>), a list recapitulating the inputs passed to the function (<code>call</code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+country_name">country_name</a>, <a href="#topic+find_keycol">find_keycol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample data
tab1 &lt;- data.frame(Industry = c(1, 1, 2, 2), Nation = c("ITA", "FRA", "ITA", "FRA"), tot = runif(4))
tab2 &lt;- data.frame(industry = 1:4, rate = runif(1:4))
tab3 &lt;- data.frame(COUNTRY = c("United States", "France", "India"), national_avg = runif(3))

# examples of merging orders
auto_merge(tab1, tab2, tab3)
auto_merge(list(tab1, tab2, tab3))
auto_merge(tab1, tab2, tab3, by = c("countries"="Nation|COUNTRY", "sector"="[Ii]ndustry"))
auto_merge(tab1, tab2, tab3, country_to = "UN_fr")
</code></pre>

<hr>
<h2 id='check_countries_api'>Check if the connection to Countries REST API is working</h2><span id='topic+check_countries_api'></span>

<h3>Description</h3>

<p>Check if the connection to <a href="https://restcountries.com/">REST Countries API</a> is working. The function checks if the user has an internet connection and if any answer is returned from the Countries REST API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_countries_api(warnings = TRUE, timeout = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_countries_api_+3A_warnings">warnings</code></td>
<td>
<p>Logical value indicating whether to output a warning when there is no connection. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="check_countries_api_+3A_timeout">timeout</code></td>
<td>
<p>Numeric value giving the timeout in seconds for attempting connection to the API. Default is <code>4</code> second.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical value: <code>TRUE</code> if there is a connection, <code>FALSE</code> if there is no connection.
</p>


<h3>See Also</h3>

<p><a href="#topic+list_fields">list_fields</a>, <a href="#topic+country_info">country_info</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_countries_api()
</code></pre>

<hr>
<h2 id='check_wide_format'>Check for wide country data formats</h2><span id='topic+check_wide_format'></span>

<h3>Description</h3>

<p>The function looks for country names or year information in the column names. This function is designed for simple panel country data, in which countries' time series are arranged side by side on columns or stacked on rows.
The function will only return year/country column names if at least 3 country/year column names are detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_wide_format(x, adjacency = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_wide_format_+3A_x">x</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="check_wide_format_+3A_adjacency">adjacency</code></td>
<td>
<p>Logical value indicating whether column names containing country or year information need to be adjacent to each other. Default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame identifying the columns names that contain country or year information.
</p>


<h3>See Also</h3>

<p><a href="#topic+find_keycol">find_keycol</a>, <a href="#topic+find_countrycol">find_countrycol</a>, <a href="#topic+find_timecol">find_timecol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example &lt;- data.frame(Year=2000:2010, China=0:10, US=10:20, Vietnam=30:40)
check_wide_format(x=example)
</code></pre>

<hr>
<h2 id='country_info'>Get information about countries</h2><span id='topic+country_info'></span>

<h3>Description</h3>

<p>This function is an interface for <a href="https://restcountries.com/">REST Countries API</a>.
It allows to request and download information about countries, such as: currency, capital city, language spoken, flag, neighbouring countries, and much more.
<strong>NOTE:</strong> Internet access is needed to download information from the API. At times the API may be unstable or slow to respond.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country_info(
  countries = NULL,
  fields = NULL,
  fuzzy_match = TRUE,
  match_info = FALSE,
  collapse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="country_info_+3A_countries">countries</code></td>
<td>
<p>A vector of countries for which we wish to download information. The function also supports fuzzy matching capabilities to facilitate querying. Information is only returned for the 249 countries in the ISO standard <code>3166</code>.</p>
</td></tr>
<tr><td><code id="country_info_+3A_fields">fields</code></td>
<td>
<p>Character vector indicating the fields to query. A description of the <a href="https://gitlab.com/restcountries/restcountries/-/blob/master/FIELDS.md">accepted fields can be found here</a>. Alternatively, a list of accepted field names can be obtained with the function <code>list_fields()</code>.</p>
</td></tr>
<tr><td><code id="country_info_+3A_fuzzy_match">fuzzy_match</code></td>
<td>
<p>Logical value indicating whether to allow fuzzy matching of country names. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="country_info_+3A_match_info">match_info</code></td>
<td>
<p>Logical value indicating whether to return information on country names matched to each input in <code>countries</code>. If <code>TRUE</code>, two additional columns will be added to the output (<code>matched_country</code> and <code>is_country</code>). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="country_info_+3A_collapse">collapse</code></td>
<td>
<p>Logical value indicating whether to collapse multiple columns relating to a same field together. Default is <code>TRUE</code>. For some specific fields (currencies, languages, names), multiple columns will be returned. This happens because countries can take multiple values for these fields. For example, <code>country_info("Switzerland", "languages", collapse = FALSE)</code> will return 4 columns for the field languages. When <code>collapse = TRUE</code>, these four columns will be collapsed into one string, with values separated by semicolons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the requested information about the countries in a table. The rows of the table correspond to entries in <code>countries</code>, columns correspond to requested <code>fields</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+list_fields">list_fields</a>, <a href="#topic+check_countries_api">check_countries_api</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run examples only if a connection to the API is available:
if (check_countries_api(warnings = FALSE)){

# The example below queries information on the currency used in Brazil, US and France:
info &lt;- country_info(countries = "Brazil", fields = "capital")

# data for multiple countries can be requested
info &lt;- country_info(countries = c("Brazil", "USA", "FR"), fields = "capital")

#' # Data can be returned for all countries by leaving - countries - empty
info &lt;- country_info(fields = "capital")

# All available fields can be requested by leaving fields empty
info &lt;- country_info(countries = c("Brazil", "USA", "FR"))

# All information for all countries can be downloaded by leaving both arguments empty
info &lt;- country_info()

}
</code></pre>

<hr>
<h2 id='country_name'>Convert and translate country names</h2><span id='topic+country_name'></span>

<h3>Description</h3>

<p>This function recognises and converts country names to different nomenclatures and languages using a fuzzy matching algorithm.
<code>country_name()</code> can identify countries even when they are provided in mixed formats or in different languages. It is robust to small misspellings and recognises many alternative country names and old nomenclatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country_name(
  x,
  to = "ISO3",
  fuzzy_match = TRUE,
  verbose = FALSE,
  simplify = TRUE,
  poor_matches = FALSE,
  na_fill = FALSE,
  custom_table = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="country_name_+3A_x">x</code></td>
<td>
<p>A vector of country names</p>
</td></tr>
<tr><td><code id="country_name_+3A_to">to</code></td>
<td>
<p>A string containing the desired naming conventions to which <code>x</code> should be converted to (e.g. <code>"ISO3"</code>, <code>"name_en"</code>, <code>"UN_fr"</code>, ...). For a list of all possible values <a href="https://fbellelli.github.io/countries/articles/dealing_with_names.html">click here</a> or refer to the vignette on country names <code>vignette("dealing_with_names")</code>. Default is <code>"ISO3"</code>, which converts to the 249 3-letter country codes currently in ISO standard 3166.</p>
</td></tr>
<tr><td><code id="country_name_+3A_fuzzy_match">fuzzy_match</code></td>
<td>
<p>Logical value indicating whether fuzzy matching of country names should be allowed (<code>TRUE</code>), or only exact matches are allowed (<code>FALSE</code>). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="country_name_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether the function should print to the console a full report. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="country_name_+3A_simplify">simplify</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code> the function will return a vector of converted names. If set to <code>FALSE</code>, the function will return a list object containing the converted vector and additional details on the country matching process. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="country_name_+3A_poor_matches">poor_matches</code></td>
<td>
<p>Logical value. If set to <code>FALSE</code> (the default), the function will return <code>NA</code> in case of poor matching. If set to <code>TRUE</code>, the function will always return the closest matching country name, even if the match is poor.</p>
</td></tr>
<tr><td><code id="country_name_+3A_na_fill">na_fill</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, any <code>NA</code> in the output names will be filled with the original country name supplied in <code>x</code>. The default is <code>FALSE</code> (no filling). In general, <code>NA</code>s are produced if: 1) the country is not present in the nomenclature requested in <code>to</code> (e.g. <code>country_name("Abkhazia", to = "ISO3")</code>), 2) the input country name is <code>NA</code>, 3) No exact match is found and the user sets the option <code>fuzzy_match = FALSE</code>, 4) When the fuzzy match algorithm does not find a good match and the user sets the option <code>poor_match = FALSE</code>. The <code>na_fill</code> argument gives the option to replace the resulting NA with the original value in <code>x</code>.</p>
</td></tr>
<tr><td><code id="country_name_+3A_custom_table">custom_table</code></td>
<td>
<p>Custom conversion table to be used. This needs to be a <code>data.frame</code> object. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of converted country names. If multiple nomenclatures are passed to the argument <code>to</code>, the vectors are arranged in a data frame. If <code>simplify=FALSE</code>, the function will return a list object.
</p>


<h3>See Also</h3>

<p><a href="#topic+is_country">is_country</a>, <a href="#topic+match_table">match_table</a>, <a href="#topic+find_countrycol">find_countrycol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Convert country names to a single nomenclatures: (e.g. 3-letters ISO code)
country_name(x=c("UK","Estados Unidos","Zaire","C#te d^ivoire"), to= "ISO3")

#When multiple arguments are provided to the - to - argument, a data frame is returned:
country_name(x=c("UK","Estados Unidos","Zaire","C#te d^ivoire"), to= c("UN_en","UN_fr","ISO3"))

#This function can also be used to translate country names: (e.g. translating all to Chinese)
country_name(x=c("UK","Estados Unidos","Zaire","C#te d^ivoire"), to= "name_zh")
</code></pre>

<hr>
<h2 id='country_reference_list'>Conversion table</h2><span id='topic+country_reference_list'></span>

<h3>Description</h3>

<p>A table containing country names in different naming conventions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country_reference_list
</code></pre>


<h3>Format</h3>

<p>A data frame with columns corresponding to different country naming conventions.
</p>

<dl>
<dt>simple</dt><dd><p>Reference name for the geographic unit. The names in this column contain only ASCII characters. This nomenclature is available for all countries.</p>
</dd>
<dt>ISO3</dt><dd><p>3-letter country codes as defined in ISO standard <code>3166-1 alpha-3</code>. This nomenclature is available for the territories in the standard (currently 249 territories).</p>
</dd>
<dt>ISO2</dt><dd><p>2-letter country codes as defined in ISO standard <code>3166-1 alpha-2</code>. This nomenclature is available for the territories in the standard (currently 249 territories).</p>
</dd>
<dt>ISO_code</dt><dd><p>Numeric country codes as defined in ISO standard <code>3166-1 numeric</code>. This country code is the same as the UN's country number (<a href="https://unstats.un.org/unsd/methodology/m49/">M49 standard</a>). This nomenclature is available for the territories in the ISO standard (currently 249 countries).</p>
</dd>
<dt>UN_ar</dt><dd><p>Official UN name in <strong>Arabic</strong>.  This nomenclature is only available for countries in the <a href="https://unstats.un.org/unsd/methodology/m49/">M49 standard</a> (currently 249 territories).</p>
</dd>
<dt>UN_zh</dt><dd><p>Official UN name in <strong>Chinese</strong>. This nomenclature is only available for countries in the <a href="https://unstats.un.org/unsd/methodology/m49/">M49 standard</a> (currently 249 territories).</p>
</dd>
<dt>UN_en</dt><dd><p>Official UN name in <strong>English</strong>. This nomenclature is only available for countries in the <a href="https://unstats.un.org/unsd/methodology/m49/">M49 standard</a> (currently 249 territories).</p>
</dd>
<dt>UN_fr</dt><dd><p>Official UN name in <strong>French</strong>. This nomenclature is only available for countries in the <a href="https://unstats.un.org/unsd/methodology/m49/">M49 standard</a> (currently 249 territories).</p>
</dd>
<dt>UN_es</dt><dd><p>Official UN name in <strong>Spanish</strong>. This nomenclature is only available for countries in the <a href="https://unstats.un.org/unsd/methodology/m49/">M49 standard</a> (currently 249 territories).</p>
</dd>
<dt>UN_ru</dt><dd><p>Official UN name in <strong>Russian</strong>. This nomenclature is only available for countries in the <a href="https://unstats.un.org/unsd/methodology/m49/">M49 standard</a> (currently 249 territories).</p>
</dd>
<dt>WTO_en</dt><dd><p>Official WTO name in <strong>English</strong>. This nomenclature is only available for <a href="https://www.wto.org/english/thewto_e/whatis_e/tif_e/org6_e.htm">WTO members and observers</a> (currently 189 entities).</p>
</dd>
<dt>WTO_fr</dt><dd><p>Official WTO name in <strong>French</strong>. This nomenclature is only available for <a href="https://www.wto.org/english/thewto_e/whatis_e/tif_e/org6_e.htm">WTO members and observers</a> (currently 189 entities).</p>
</dd>
<dt>WTO_es</dt><dd><p>Official WTO name in <strong>Spanish</strong>. This nomenclature is only available for <a href="https://www.wto.org/english/thewto_e/whatis_e/tif_e/org6_e.htm">WTO members and observers</a> (currently 189 entities).</p>
</dd>
<dt>name_ar</dt><dd><p>Translation of ISO country names in <strong>Arabic</strong>. (currently 249 territories)</p>
</dd>
<dt>name_bg</dt><dd><p>Translation of ISO country names in <strong>Bulgarian</strong>. (currently 249 territories)</p>
</dd>
<dt>name_cs</dt><dd><p>Translation of ISO country names in <strong>Czech</strong>. (currently 249 territories)</p>
</dd>
<dt>name_da</dt><dd><p>Translation of ISO country names in <strong>Danish</strong>. (currently 249 territories)</p>
</dd>
<dt>name_de</dt><dd><p>Translation of ISO country names in <strong>German</strong>. (currently 249 territories)</p>
</dd>
<dt>name_el</dt><dd><p>Translation of ISO country names in <strong>Greek</strong>. (currently 249 territories)</p>
</dd>
<dt>name_en</dt><dd><p>Translation of ISO country names in <strong>English</strong>. (currently 249 territories)</p>
</dd>
<dt>name_es</dt><dd><p>Translation of ISO country names in <strong>Spanish</strong>. (currently 249 territories)</p>
</dd>
<dt>name_et</dt><dd><p>Translation of ISO country names in <strong>Estonian</strong>. (currently 249 territories)</p>
</dd>
<dt>name_eu</dt><dd><p>Translation of ISO country names in <strong>Basque</strong>. (currently 249 territories)</p>
</dd>
<dt>name_fi</dt><dd><p>Translation of ISO country names in <strong>Finnish</strong>. (currently 249 territories)</p>
</dd>
<dt>name_fr</dt><dd><p>Translation of ISO country names in <strong>French</strong>. (currently 249 territories)</p>
</dd>
<dt>name_hu</dt><dd><p>Translation of ISO country names in <strong>Hungarian</strong>. (currently 249 territories)</p>
</dd>
<dt>name_it</dt><dd><p>Translation of ISO country names in <strong>Italian</strong>. (currently 249 territories)</p>
</dd>
<dt>name_ja</dt><dd><p>Translation of ISO country names in <strong>Japanese</strong>. (currently 249 territories)</p>
</dd>
<dt>name_ko</dt><dd><p>Translation of ISO country names in <strong>Korean</strong>. (currently 249 territories)</p>
</dd>
<dt>name_lt</dt><dd><p>Translation of ISO country names in <strong>Lithuanian</strong>. (currently 249 territories)</p>
</dd>
<dt>name_nl</dt><dd><p>Translation of ISO country names in <strong>Dutch</strong>. (currently 249 territories)</p>
</dd>
<dt>name_no</dt><dd><p>Translation of ISO country names in <strong>Norwegian</strong>. (currently 249 territories)</p>
</dd>
<dt>name_pl</dt><dd><p>Translation of ISO country names in <strong>Polish</strong>. (currently 249 territories)</p>
</dd>
<dt>name_pt</dt><dd><p>Translation of ISO country names in <strong>Portuguese</strong>. (currently 249 territories)</p>
</dd>
<dt>name_ro</dt><dd><p>Translation of ISO country names in <strong>Romanian</strong>. (currently 249 territories)</p>
</dd>
<dt>name_ru</dt><dd><p>Translation of ISO country names in <strong>Russian</strong>. (currently 249 territories)</p>
</dd>
<dt>name_sk</dt><dd><p>Translation of ISO country names in <strong>Slovak</strong>. (currently 249 territories)</p>
</dd>
<dt>name_sv</dt><dd><p>Translation of ISO country names in <strong>Swedish</strong>. (currently 249 territories)</p>
</dd>
<dt>name_th</dt><dd><p>Translation of ISO country names in <strong>Thai</strong>. (currently 249 territories)</p>
</dd>
<dt>name_uk</dt><dd><p>Translation of ISO country names in <strong>Ukranian</strong>. (currently 249 territories)</p>
</dd>
<dt>name_zh</dt><dd><p>Translation of ISO country names in <strong>simplified Chinese</strong>. (currently 249 territories)</p>
</dd>
<dt>name_zh-tw</dt><dd><p>Translation of ISO country names in <strong>traditional Chinese</strong>. (currently 249 territories)</p>
</dd>
<dt>GTAP</dt><dd><p><a href="https://www.gtap.agecon.purdue.edu/databases/regions.aspx?version=9.211">GTAP</a> country and region codes.</p>
</dd>
<dt>Name0</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name1</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name2</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name3</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name4</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name5</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name6</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name7</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name8</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name9</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name10</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name11</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name12</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name13</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name14</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name15</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name16</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name17</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name18</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
<dt>Name19</dt><dd><p>Other variants of the country name included to improve the matching process</p>
</dd>
</dl>


<hr>
<h2 id='country_reference_list_long'>Conversion table in long format</h2><span id='topic+country_reference_list_long'></span>

<h3>Description</h3>

<p>A table containing country names in different naming conventions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>country_reference_list_long
</code></pre>


<h3>Format</h3>

<p>A data frame with three columns providing information on country naming conventions. This table is a long-format version of &quot;country_reference_list&quot;.
</p>

<dl>
<dt>ID</dt><dd><p>Numeric value that uniquely identifies entity. This corresponds to the row number in table &quot;country_reference_list&quot;.</p>
</dd>
<dt>nomenclature</dt><dd><p>Country naming convention (e.g. UN english, ISO 3-digit code, etc.).</p>
</dd>
<dt>name</dt><dd><p>Country names</p>
</dd>
</dl>


<hr>
<h2 id='find_countrycol'>Finds columns containing country names</h2><span id='topic+find_countrycol'></span>

<h3>Description</h3>

<p>This function takes a data frame as argument and returns the column name (or index) of all columns containing country names.
It can be used to automate the search of country columns in data frames.
For the purpose of this function, a country is any of the 249 territories designated in the ISO standard <code>3166</code>.
On large datasets a random sample is used for evaluating the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_countrycol(
  x,
  return_index = FALSE,
  allow_NA = TRUE,
  min_share = 0.8,
  sample_size = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_countrycol_+3A_x">x</code></td>
<td>
<p>A data frame object</p>
</td></tr>
<tr><td><code id="find_countrycol_+3A_return_index">return_index</code></td>
<td>
<p>A logical value indicating whether the function should return the index of country columns instead of the column names. Default is <code>FALSE</code>, column names are returned.</p>
</td></tr>
<tr><td><code id="find_countrycol_+3A_allow_na">allow_NA</code></td>
<td>
<p>Logical value indicating whether columns containing <code>NA</code> values are to be considered as country columns. Default is <code>allow_NA=FALSE</code>, the function will not return country column containing <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="find_countrycol_+3A_min_share">min_share</code></td>
<td>
<p>A value between <code>0</code> and <code>1</code> indicating the minimum share of country names in columns that are returned. A value of <code>0</code> will return any column containing a country name. A value of <code>1</code> will return only columns whose entries are all country names. Default is <code>0.9</code>, i.e. at least 90 percent of the column entries need to be country names.</p>
</td></tr>
<tr><td><code id="find_countrycol_+3A_sample_size">sample_size</code></td>
<td>
<p>Either <code>NA</code> or a numeric value indicating the sample size used for evaluating columns. Default is <code>1000</code>. If <code>NA</code> is passed, the function will evaluate the full table. The minimum accepted value is <code>100</code> (i.e. 100 randomly sampled rows are used to evaluate the columns). This parameter can be tuned to speed up computation on long datasets. Taking a sample could result in inexact identification of key columns, accuracy improves with larger samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of country names (<code>return_index=FALSE</code>) or column indices (<code>return_index=TRUE</code>) of columns containing country names.
</p>


<h3>See Also</h3>

<p><a href="#topic+is_country">is_country</a>, <a href="#topic+country_name">country_name</a>, <a href="#topic+find_keycol">find_keycol</a>, <a href="#topic+find_timecol">find_timecol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_countrycol(x=data.frame(a=c("Brésil","Tonga","FRA"), b=c(1,2,3)))
</code></pre>

<hr>
<h2 id='find_keycol'>Find a set of columns that uniquely identifies table entries</h2><span id='topic+find_keycol'></span>

<h3>Description</h3>

<p>This function takes a data frame as argument and returns the column names (or indices) of a set of columns that uniquely identify the table entries (i.e. table key). It can be used to automate the search of table keys.
Since the function was designed for country data, it will first search for columns containing country names and dates/years. These columns will be given priority in the search for keys. Next, the function prioritises left-most columns in the table.
For time efficiency, the function does not test all possible combination of columns, it just tests the most likely combinations. The function will look for the most common country data formats (e.g. cross-sectional, time-series, panel data, dyadic, etc.) and searches for up to 2 additional key columns beyond country and time columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_keycol(
  x,
  return_index = FALSE,
  search_only = NA,
  sample_size = 1000,
  allow_NA = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_keycol_+3A_x">x</code></td>
<td>
<p>A data frame object</p>
</td></tr>
<tr><td><code id="find_keycol_+3A_return_index">return_index</code></td>
<td>
<p>A logical value indicating whether the function should return the index of country columns instead of the column names. Default is <code>FALSE</code>, column names are returned.</p>
</td></tr>
<tr><td><code id="find_keycol_+3A_search_only">search_only</code></td>
<td>
<p>This parameter can be used to restrict the search of table keys to a subset of columns. The default is <code>NA</code>, which will result in the entire table being searched. Alternatively, users may restrict the search by providing a vector containing the name or the numeric index of columns to check. For example, search could be restricted to the first ten columns by passing <code>1:10</code>. This could be useful in speeding up the search in wide tables.</p>
</td></tr>
<tr><td><code id="find_keycol_+3A_sample_size">sample_size</code></td>
<td>
<p>Either <code>NA</code> or a numeric value indicating the sample size used for evaluating columns. Default is <code>1000</code>. If <code>NA</code> is passed, the function will evaluate the full table. The minimum accepted value is <code>100</code> (i.e. 100 randomly sampled rows are used to evaluate the columns). This parameter can be tuned to speed up computation on long datasets. Taking a sample could result in inexact identification of key columns, accuracy improves with larger samples.</p>
</td></tr>
<tr><td><code id="find_keycol_+3A_allow_na">allow_NA</code></td>
<td>
<p>Logical value indicating whether to allow key columns to have <code>NA</code> values. Default is <code>allow_NA=FALSE</code>. If set to <code>TRUE</code>, <code>NA</code> is considered as a distinct value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of column names (or indices) that uniquely identify the entries in the table. If no key is found, the function will return <code>NULL</code>. The output is a named vector indicating whether the identified key columns contain country names (<code>"country"</code>), year and dates (<code>"time"</code>), or other type of information (<code>"other"</code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+find_timecol">find_timecol</a>, <a href="#topic+find_countrycol">find_countrycol</a>, <a href="#topic+is_keycol">is_keycol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example &lt;-data.frame(nation=rep(c("FRA","ALB","JOR"),3),
                     year=c(rep(2000,3),rep(2005,3),rep(2010,3)),
                     var=runif(9))
find_keycol(x=example)
</code></pre>

<hr>
<h2 id='find_timecol'>Finds columns containing date and year data</h2><span id='topic+find_timecol'></span>

<h3>Description</h3>

<p>This function takes a data frame as argument and returns the column names (or indices) of all columns containing dates and the most likely column containing year information, if any.
It can be used to automate the search of date and year columns in data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_timecol(x, return_index = FALSE, allow_NA = TRUE, sample_size = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_timecol_+3A_x">x</code></td>
<td>
<p>A data frame object</p>
</td></tr>
<tr><td><code id="find_timecol_+3A_return_index">return_index</code></td>
<td>
<p>A logical value indicating whether the function should return the index of time columns instead of the column names. Default is <code>FALSE</code>, column names are returned.</p>
</td></tr>
<tr><td><code id="find_timecol_+3A_allow_na">allow_NA</code></td>
<td>
<p>Logical value indicating whether to allow time columns to contain <code>NA</code> values. Default is <code>allow_NA=FALSE</code>, the function will not return time column containing <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="find_timecol_+3A_sample_size">sample_size</code></td>
<td>
<p>Either <code>NA</code> or a numeric value indicating the sample size used for evaluating columns. Default is <code>1000</code>. If <code>NA</code> is passed, the function will evaluate the full table. The minimum accepted value is <code>100</code> (i.e. 100 randomly sampled rows are used to evaluate the columns). This parameter can be tuned to speed up computation on long datasets. Taking a sample could result in inexact identification of key columns, accuracy improves with larger samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of names (<code>return_index=FALSE</code>) or indices (<code>return_index=TRUE</code>) of columns containing date or year information. Only the most likely year column is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+is_date">is_date</a>, <a href="#topic+find_countrycol">find_countrycol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_timecol(x=data.frame(a=1970:2020, year=1970:2020, b=rep("2020-01-01",51),c=sample(1:1000,51)))
</code></pre>

<hr>
<h2 id='is_country'>Tests whether a string is a country name</h2><span id='topic+is_country'></span>

<h3>Description</h3>

<p>This function checks whether the string is a country name. It supports different languages and naming conventions.
The function returns <code>TRUE</code> if it relates to one of the 249 countries currently in the ISO standard <code>3166</code>.
Alternatively, the argument <code>check_for</code> allows to narrow down the test to a subset of countries.
Fuzzy matching can be used to allow a small margin of error in the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_country(x, check_for = NULL, fuzzy_match = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_country_+3A_x">x</code></td>
<td>
<p>A character vector to be tested (also supports UN/ISO country codes)</p>
</td></tr>
<tr><td><code id="is_country_+3A_check_for">check_for</code></td>
<td>
<p>A vector of country names to narrow down testing. The function will return <code>TRUE</code> only if the string relates to a country in this vector. Default is NULL.</p>
</td></tr>
<tr><td><code id="is_country_+3A_fuzzy_match">fuzzy_match</code></td>
<td>
<p>A logical value indicating whether to tolerate small discrepancies in the country name matching. The default and fastest option is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical vector indicating whether the string is a country name
</p>


<h3>See Also</h3>

<p><a href="#topic+match_table">match_table</a>, <a href="#topic+country_name">country_name</a>, <a href="#topic+find_countrycol">find_countrycol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Detect strings that are country names
is_country(x=c("ITA","Estados Unidos","Estado Unidos","bungalow","dog",542), fuzzy_match=FALSE)
is_country(x=c("ITA","Estados Unidos","Estado Unidos","bungalow","dog",542), fuzzy_match=TRUE)
#Checking for a specific subset of countries
is_country(x=c("Ceylon","LKA","Indonesia","Inde"), check_for=c("India","Sri Lanka"))
</code></pre>

<hr>
<h2 id='is_date'>Test whether the input is a date</h2><span id='topic+is_date'></span>

<h3>Description</h3>

<p>This function checks if a value is a date by attempting to convert it to a date format. The user can specify which date formats should be tested with the argument <code>formats</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_date(
  x,
  formats = c("%Y-%m-%d", "%y-%m-%d", "%m-%d-%Y", "%m-%d-%y", "%d-%m-%Y",
    "%d-%m-%y", "%Y/%m/%d", "%y/%m/%d", "%m/%d/%Y", "%m/%d/%y",
    "%d/%m/%Y", "%d/%m/%y", "%Y.%m.%d", "%y.%m.%d", "%m.%d.%Y",
    "%m.%d.%y", "%d.%m.%Y", "%d.%m.%y", "%d %b %Y", "%d %B %Y",
    "%b %d %Y", "%B %d %Y", "%b %d, %Y", "%B %d, %Y", "%d%b%Y",
    "%d%B%Y", "%Y%B%d", "%Y%b%d", "%b %Y", "%B %Y", "%b %y", "%B %y",
    "%m-%Y", "%Y-%m", "%m/%Y", "%Y/%m")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_date_+3A_x">x</code></td>
<td>
<p>A vector of values to be tested</p>
</td></tr>
<tr><td><code id="is_date_+3A_formats">formats</code></td>
<td>
<p>Date formats to be checked for (expressed in R date notation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical vector indicating whether the values can be converted to any of the date formats provided. Notice that unless specified, the default allowed formats do not include simple year numbers (e.g. 2022 or 1993) because number vectors could wrongly be identified as dates. Also, notice that testing <code>NA</code> values will return <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+find_timecol">find_timecol</a>, <a href="#topic+find_keycol">find_keycol</a>, <a href="#topic+is_country">is_country</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_date(c("2020-01-01","test",2020,"March 2030"))
</code></pre>

<hr>
<h2 id='is_keycol'>Test whether a set of column could be a data frame key</h2><span id='topic+is_keycol'></span>

<h3>Description</h3>

<p>This function takes a data frame and a vector of column names as argument and returns a logical value indicating whether the indicated columns uniquely identify entries in the data frame.
If the output is <code>TRUE</code>, the indicated columns could be the keys of the table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_keycol(x, cols, allow_NA = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_keycol_+3A_x">x</code></td>
<td>
<p>A data frame object</p>
</td></tr>
<tr><td><code id="is_keycol_+3A_cols">cols</code></td>
<td>
<p>A vector of column names or indices to be tested.</p>
</td></tr>
<tr><td><code id="is_keycol_+3A_allow_na">allow_NA</code></td>
<td>
<p>Logical value indicating whether to allow key columns to have <code>NA</code> values. Default is <code>allow_NA=FALSE</code>, the function will return <code>FALSE</code> if any <code>NA</code> value is present in <code>colnames</code>.</p>
</td></tr>
<tr><td><code id="is_keycol_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether messages should be printed on the console. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical value. If <code>TRUE</code>, the columns indicated in <code>colnames</code> uniquely identify the entries in <code>x</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+find_keycol">find_keycol</a>, <a href="#topic+find_countrycol">find_countrycol</a>, <a href="#topic+find_timecol">find_timecol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_keycol(data.frame(a=1:10,b=sample(c("a","b","c"),10, replace=TRUE)), cols="a")
is_keycol(data.frame(a=1:10,b=sample(c("a","b","c"),10, replace=TRUE)), cols="b")
is_keycol(
data.frame(a=c(1:5,1:5),
b=sample(c("a","b","c"),10, replace=TRUE),
c=c(rep("a",5),rep("b",5))),
cols=c("a","c"))
</code></pre>

<hr>
<h2 id='list_countries'>Get a list of country names</h2><span id='topic+list_countries'></span>

<h3>Description</h3>

<p>This function returns a vector of country names in different nomenclatures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_countries(nomenclature = "name_en")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_countries_+3A_nomenclature">nomenclature</code></td>
<td>
<p>String indicating the nomenclature from which the list of countries should be taken. Not all countries are present in all nomenclatures, for example Taiwan is not recognised by the UN, so it will not be returned with <code>"WTO_en"</code>. The function accepts any of the nomenclatures supported country_name. For a list of accepted values, refer to <a href="https://fbellelli.github.io/countries/articles/dealing_with_names.html">this page</a>. The default is <code>name_en</code>, which is the English list of names in the ISO standard 3166.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of country names in the desired nomenclature.
</p>


<h3>See Also</h3>

<p><a href="#topic+random_countries">random_countries</a>, <a href="#topic+country_name">country_name</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list_countries("ISO3")
list_countries("UN_en")
list_countries()
</code></pre>

<hr>
<h2 id='list_fields'>List of accepted fields for the function country_info</h2><span id='topic+list_fields'></span>

<h3>Description</h3>

<p>This function queries <a href="https://restcountries.com/">REST Countries API</a> and returns a list of all possible fields that can be used in the function <code>country_info</code>.
<strong>NOTE:</strong> Internet access is needed to download information from the API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_fields()
</code></pre>


<h3>Value</h3>

<p>A vector of accepted fields for the function <code>country_info()</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+country_info">country_info</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run example only if a connection to the API is available
if (check_countries_api(warnings = FALSE)){

list_fields()

}
</code></pre>

<hr>
<h2 id='match_table'>Create a conversion table for country names</h2><span id='topic+match_table'></span>

<h3>Description</h3>

<p>This function returns a conversion table for country names to the desired naming conventions and languages.
The use of fuzzy matching allows more flexibility in recognising and identifying country names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_table(
  x,
  to = c("simple", "ISO3"),
  fuzzy_match = TRUE,
  verbose = FALSE,
  matching_info = FALSE,
  simplify = TRUE,
  na_fill = FALSE,
  poor_matches = TRUE,
  custom_table = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_table_+3A_x">x</code></td>
<td>
<p>A vector of country names</p>
</td></tr>
<tr><td><code id="match_table_+3A_to">to</code></td>
<td>
<p>A vector containing one or more desired naming conventions to which <code>x</code> should be converted to (e.g. <code>"ISO3"</code>, <code>"name_en"</code>, <code>"UN_fr"</code>, ...). For a list of all possible values <a href="https://fbellelli.github.io/countries/articles/dealing_with_names.html">click here</a> or refer to the vignette on country names <code>vignette("dealing_with_names")</code>. Default is <code>c("simple", "ISO3")</code>.</p>
</td></tr>
<tr><td><code id="match_table_+3A_fuzzy_match">fuzzy_match</code></td>
<td>
<p>Logical value indicating whether fuzzy matching of country names should be allowed (<code>TRUE</code>), or only exact matches are allowed (<code>FALSE</code>). Default is <code>TRUE</code>. Switching to <code>FALSE</code> will result in much faster execution.</p>
</td></tr>
<tr><td><code id="match_table_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether the function should print to the console a report on the matching process. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="match_table_+3A_matching_info">matching_info</code></td>
<td>
<p>Logical value. If set to true the output match table will include additional information on the matching of <code>x</code>'s entries. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="match_table_+3A_simplify">simplify</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code> the function will return the match table as a <code>data.frame</code> object. If set to <code>FALSE</code>, the function will return a list object containing the match table and additional details on the country matching process. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="match_table_+3A_na_fill">na_fill</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code>, any <code>NA</code> in the output names will be filled with the original country name supplied in <code>x</code>. The default is <code>FALSE</code> (no filling). In general, <code>NA</code>s are produced if: 1) the country is not present in the nomenclature requested in <code>to</code> (e.g. <code>country_name("Abkhazia", to = "ISO3")</code>), 2) the input country name is <code>NA</code>, 3) No exact match is found and the user sets the option <code>fuzzy_match = FALSE</code>, 4) When the fuzzy match algorithm does not find a good match and the user sets the option <code>poor_match = FALSE</code>. The <code>na_fill</code> argument gives the option to replace the resulting NA with the original value in <code>x</code>.</p>
</td></tr>
<tr><td><code id="match_table_+3A_poor_matches">poor_matches</code></td>
<td>
<p>Logical value. If set to <code>TRUE</code> (the default option), the function will always return the closest matching country name, even if the matching is poor. If set to <code>FALSE</code>, the function will return <code>NA</code> in case of poor matching.</p>
</td></tr>
<tr><td><code id="match_table_+3A_custom_table">custom_table</code></td>
<td>
<p>Custom conversion table to be used. This needs to be a data.frame object. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a conversion table for countries names to the desired naming conventions. If <code>simplify=FALSE</code> it returns a list object.
</p>


<h3>See Also</h3>

<p><a href="#topic+country_name">country_name</a>, <a href="#topic+is_country">is_country</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>match_table(x=c("UK","Estados Unidos","Zaire","C#te d^ivoire"), to= c("UN_en","ISO3"))
</code></pre>

<hr>
<h2 id='Mode'>Statistical mode of a vector</h2><span id='topic+Mode'></span>

<h3>Description</h3>

<p>This function returns the mode of vectors. That is to say, for any given vector of values, it returns the value that appears most frequently.
The function works with strings, numerical and mixed inputs. <code>NA</code> values are treated as distinct values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mode(x, na.rm = FALSE, first_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mode_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="Mode_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical value indicating whether <code>NA</code> values should be omitted. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Mode_+3A_first_only">first_only</code></td>
<td>
<p>Logical value indicating whether only the first mode should be returned if <code>x</code> has multiple modes (i.e. there are multiple values with the highest number of observations). Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the mode of the vector <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>countries::Mode(c("a","a",2,3))
countries::Mode(c(1,1,2,3,NA,2))
countries::Mode(c(NA,NA,NA,1,1,2))
</code></pre>

<hr>
<h2 id='palettes_countries'>Discrete colour palettes</h2><span id='topic+palettes_countries'></span>

<h3>Description</h3>

<p>This function provides access to the discrete colours palettes used in this packages' 11 themes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palettes_countries(n, theme = 1, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palettes_countries_+3A_n">n</code></td>
<td>
<p>Number of desired colours</p>
</td></tr>
<tr><td><code id="palettes_countries_+3A_theme">theme</code></td>
<td>
<p>A numeric value or name identifying the theme's colours. Can be a number between 1 and 11, or one of the theme's names: <code>c("Default", "Greyscale", "Candy", "RedBlue", "Dark", "Reds", "Blues", "Greens", "Viridis", "Cividis", "Distinct", "Distinct2", "Paired")</code>.</p>
</td></tr>
<tr><td><code id="palettes_countries_+3A_reverse">reverse</code></td>
<td>
<p>Logical value indicating whether to reverse the order of the palette's colours Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns n colours from the requested theme
</p>


<h3>See Also</h3>

<p><a href="#topic+quick_map">quick_map</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>palettes_countries(5, theme = 1)
</code></pre>

<hr>
<h2 id='quick_map'>Easily visualise country data with a map</h2><span id='topic+quick_map'></span>

<h3>Description</h3>

<p><code>quick_map()</code> allows to plot country <a href="https://en.wikipedia.org/wiki/Choropleth_map">chloropleth maps</a> with one line of code.
The only inputs required are a <code>data.frame</code> object and the name of the column to plot.
The function uses <code>country_name()</code>'s capabilities to automatically match country names to one of the territories in the <a href="https://en.wikipedia.org/wiki/ISO_3166-1">ISO standard 3166-1</a>. This allows fuzzy matching of country names in multiple languages and nomenclatures.
For some map examples, see <a href="https://fbellelli.github.io/countries/articles/quick_map.html">this article</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quick_map(
  data,
  plot_col,
  theme = 1,
  zoom = "Default",
  verbose = FALSE,
  save_to = NULL,
  width_plot = 30,
  name_legend = NULL,
  reverse_palette = FALSE,
  col_breaks = NULL,
  col_border = "black",
  col_na = "grey97",
  width_border = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quick_map_+3A_data">data</code></td>
<td>
<p>Table (data.frame) containing the data to plot. Each row in the table should correspond to a country. One of the columns should contain country names.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_plot_col">plot_col</code></td>
<td>
<p>Name of the column to plot.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_theme">theme</code></td>
<td>
<p>A numeric value or name identifying one of the predefined visual themes for the map. Can be a number between 1 and 11, or one of the predefined theme's names: <code>c("Default", "Greyscale", "Candy", "RedBlue", "Dark", "Reds", "Blues", "Greens", "Viridis", "Cividis", "Distinct", "Distinct2", "Paired")</code>. If <code>0</code> or <code>"NoTheme"</code> is passed, no theme will be applied (default &lsquo;ggplot2'&rsquo;s settings are used).</p>
</td></tr>
<tr><td><code id="quick_map_+3A_zoom">zoom</code></td>
<td>
<p>This argument defines the zoom applied to the map. It can be either a string identifying one of the predefined zoom boxes (<code>"Default", "World", "Africa", "Asia", "Europe", "SEAsia", "NAmerica", "CAmerica", "SAmerica", "Oceania"</code>). Alternatively, the user may provide a numeric vector of length 4 describing the min/max longitude and latitude (e.g. <code>c(-80, -35, -55, 10)</code> defines a zoom on South America).</p>
</td></tr>
<tr><td><code id="quick_map_+3A_verbose">verbose</code></td>
<td>
<p>Logical value indicating whether to print messages to the console. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_save_to">save_to</code></td>
<td>
<p>Path to the file where the plot is to be saved. This need to be in an existing directory. The default is <code>NULL</code>, which does not save the plot.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_width_plot">width_plot</code></td>
<td>
<p>Width (in cm) when plot is saved to a file. The ratio between height and width is fixed. This argument is only relevant if <code>save_to</code> is different from <code>NULL</code>. Default is <code>30</code>. For custom saving options the function <code>ggsave()</code> can be used.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_name_legend">name_legend</code></td>
<td>
<p>String giving the name to be used for the plotted variable in the legend of the map. If nothing is provided, the default is to use the name in <code>plot_col</code>.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_reverse_palette">reverse_palette</code></td>
<td>
<p>Logical value indicating whether to reverse the order of the colours in the palette. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_col_breaks">col_breaks</code></td>
<td>
<p>Only relevant for numeric data. This argument allows the user to provide manual breaks for the colour scale. Needs to be a numeric vector (<code>c(0, 100, 500, 1000)</code>). Default is <code>NULL</code>, which will result in breaks being automatically selected by the function. Note that data with 6 or less unique values will be treated as factor by the function.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_col_border">col_border</code></td>
<td>
<p>Colour of border line separating countries and landmasses. Default is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_col_na">col_na</code></td>
<td>
<p>Colour for countries with missing data (NAs). Default is <code>"grey97"</code>.</p>
</td></tr>
<tr><td><code id="quick_map_+3A_width_border">width_border</code></td>
<td>
<p>Numeric value giving the width of the border lines between countries. Default is '0.1'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Good to know</strong>
</p>
<p><code>quick_map()</code> only allows plotting of territories in the ISO standard 3166-1. It does not support plotting of other regions.
The output of the function is a ggplot object. This means means that users can then customise the look of the output by applying any of ggplot's methods.
</p>
<p><strong>Disclaimer</strong>
</p>
<p>Territories' borders and shapes are intended for illustrative purpose. They might be outdated and do not imply the expression of any opinion on the part of the package developers.
</p>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating some sample data to plot
example_data &lt;- data.frame(country = random_countries(100), population = runif(100))

# make a map
quick_map(example_data, "population")

# The function provides several predefined themes
quick_map(example_data, "population", theme = 3)
quick_map(example_data, "population", theme = "Reds")

# provide breaks for the colour scale
quick_map(example_data, "population", col_breaks = c(0, 1e5, 1e6, 1e7, 1e8, 1e9))
</code></pre>

<hr>
<h2 id='random_countries'>Output random country names</h2><span id='topic+random_countries'></span>

<h3>Description</h3>

<p>This function returns the mode of vectors. That is to say, for any given vector of values, it returns the value that appears most frequently.
The function works with strings, numerical and mixed inputs. <code>NA</code> values are treated as distinct values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_countries(n, replace = FALSE, nomenclature = "name_en", seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_countries_+3A_n">n</code></td>
<td>
<p>Number of desired (pseudo)random country names.</p>
</td></tr>
<tr><td><code id="random_countries_+3A_replace">replace</code></td>
<td>
<p>Logical value indicating whether sampling should be with replacement.</p>
</td></tr>
<tr><td><code id="random_countries_+3A_nomenclature">nomenclature</code></td>
<td>
<p>Nomenclature from which the list of countries should be taken. Not all countries are present in all nomenclature, for example Taiwan is not recognised by the UN, so it will not be returned with <code>"WTO_en"</code>. The function accept any of the nomenclatures of country_name. For a list of accepted values, refer to <a href="https://fbellelli.github.io/countries/articles/dealing_with_names.html">this page</a>. The default is <code>name_en</code>, which is the English list of names in the ISO standard 3166.</p>
</td></tr>
<tr><td><code id="random_countries_+3A_seed">seed</code></td>
<td>
<p>Single numerical value to be used as seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of n (pseudo)random country names.
</p>


<h3>See Also</h3>

<p><a href="#topic+list_countries">list_countries</a>, <a href="#topic+country_name">country_name</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_countries(10)
random_countries(n = 500, replace = TRUE)
random_countries(n = 5, nomenclature = "ISO3", seed = 5)
</code></pre>

<hr>
<h2 id='which_min'>Return location of minimum, maximum and mode values' index</h2><span id='topic+which_min'></span><span id='topic+which_max'></span><span id='topic+which_mode'></span>

<h3>Description</h3>

<p>These function return the position (index) of all the minimum, maximum, and mode values of the vector <code>x</code>. <code>which_min()</code> and <code>which_max()</code> only support numeric and logical vectors.
These functions are identical to <code>which.min()</code> and <code>which.max()</code>, except that ALL minima/maxima are returned instead of only the first one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_min(x, first_only = FALSE)

which_max(x, first_only = FALSE)

which_mode(x, first_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_min_+3A_x">x</code></td>
<td>
<p>A numeric or vector</p>
</td></tr>
<tr><td><code id="which_min_+3A_first_only">first_only</code></td>
<td>
<p>Logical value indicating whether only the first value should be returned (i.e. if <code>TRUE</code> the function behaves like <code>which.min()</code> and <code>which.max()</code>). Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the position of the minimum, maximum and mode values of a vector <code>x</code>
</p>


<h3>See Also</h3>

<p><a href="#topic+Mode">Mode</a>, <a href="base.html#topic+which.min">which.min</a>, <a href="base.html#topic+which.max">which.max</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>which_mode(c("a","a",2,3))
which_min(c(1,1,2,3,NA,2))
which_max(c(NA,NA,NA,1,1,2))
</code></pre>

<hr>
<h2 id='world'>World map data</h2><span id='topic+world'></span>

<h3>Description</h3>

<p>A table containing points to draw a world map. The data comes from the package maps (&quot;world&quot;) An additional column is added with ISO 3-digit country codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>world
</code></pre>


<h3>Format</h3>

<p>A data frame with six columns providing information to plot world maps.
</p>

<dl>
<dt>long</dt><dd><p>Longitude</p>
</dd>
<dt>lat</dt><dd><p>Latitude</p>
</dd>
<dt>group</dt><dd><p>Numeric value used to identify polygons</p>
</dd>
<dt>order</dt><dd><p>Order in which lines should be traced</p>
</dd>
<dt>region</dt><dd><p>Name of the polygon's geographic region</p>
</dd>
<dt>ISO3</dt><dd><p>3-digits ISO country code for the region</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
