<!DOCTYPE html><html><head><title>Help for package MVNBayesian</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MVNBayesian}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MVNBayesian-package'>
<p>Bayesian Analysis Framework for MVN (Mixture) Distribution</p></a></li>
<li><a href='#Ascending_Num'>
<p>Renumbering vector by elemental frequency</p></a></li>
<li><a href='#dataset1'>
<p>Dataset for MVN test</p></a></li>
<li><a href='#dataset2'>
<p>Dataset for MVN mixture test</p></a></li>
<li><a href='#MatrixAlternative'>
<p>Interchanging specified rows and columns</p></a></li>
<li><a href='#MixMVN_BayesianPosteriori'>
<p>Calculate Bayesian posteriori MVN mixture distribution</p></a></li>
<li><a href='#MixMVN_GibbsSampler'>
<p>Gibbs sampler for MVN mixture distribution</p></a></li>
<li><a href='#MixMVN_MCMC'>
<p>MCMC simulation for MVN mixture distribution</p></a></li>
<li><a href='#MVN_BayesianIterator'>
<p>Parameter estimation using Bayesian iteration</p></a></li>
<li><a href='#MVN_BayesianPosteriori'>
<p>Calculate Bayesian posteriori MVN distribution</p></a></li>
<li><a href='#MVN_FConditional'>
<p>Calculate full conditional normal ditribution of MVN</p></a></li>
<li><a href='#MVN_GibbsSampler'>
<p>Gibbs sampler for MVN distribution</p></a></li>
<li><a href='#MVN_MCMC'>
<p>MCMC simulation for MVN distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Analysis Framework for MVN (Mixture) Distribution</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.8-11</td>
</tr>
<tr>
<td>Author:</td>
<td>ZHANG Chen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>ZHANG Chen &lt;447974102@qq.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools of Bayesian analysis framework using the method
  suggested by Berger (1985) &lt;<a href="https://doi.org/10.1007%2F978-1-4757-4286-2">doi:10.1007/978-1-4757-4286-2</a>&gt; for
  multivariate normal (MVN) distribution and multivariate normal
  mixture (MixMVN) distribution:
  a) calculating Bayesian posteriori of (Mix)MVN distribution;
  b) generating random vectors of (Mix)MVN distribution;
  c) Markov chain Monte Carlo (MCMC) for (Mix)MVN distribution.</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, plyr, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, Rfast</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CubicZebra/MVNBayesian">https://github.com/CubicZebra/MVNBayesian</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-15 06:04:53 UTC; chen_zhang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-16 10:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='MVNBayesian-package'>
Bayesian Analysis Framework for MVN (Mixture) Distribution
</h2><span id='topic+MVNBayesian-package'></span><span id='topic+MVNBayesian'></span>

<h3>Description</h3>

<p>Tools of Bayesian analysis framework using the method
suggested by Berger (1985) &lt;doi:10.1007/978-1-4757-4286-2&gt; for
multivariate normal (MVN) distribution and multivariate normal
mixture (MixMVN) distribution:
a) calculating Bayesian posteriori of (Mix)MVN distribution;
b) generating random vectors of (Mix)MVN distribution;
c) Markov chain Monte Carlo (MCMC) for (Mix)MVN distribution.
</p>


<h3>Details</h3>

<p>This package is aimed to build a easy approach for MVN (mixture) distribution in Bayesian analysis framework. Bayesian posteriori MVN (mixture) distribution can be calculated in conditions of given priori MVN (mixture) informations. The conjugated property of MVN distribution makes it effective in parameter estimation using Bayesian iterator. Joint and marginal probability densities of a certain MVN (mixture) can be achieved through random vector generator, using Gibbs sampling. Conditional probability densities from a certain MVN (mixture) can be simulated using MCMC method.
</p>


<h3>Author(s)</h3>

<p>ZHANG Chen
</p>
<p>Maintainer: ZHANG Chen &lt;447974102@qq.com&gt;
</p>


<h3>References</h3>

<p>&quot;Statistical Inference&quot; by George Casella. Roger L. Berger;<br />
&quot;Statistical Decision Theory and Bayesian Analysis&quot; by James O. Berger;<br />
&quot;Matrix Computation&quot; by Gee H. Golub. Charles F. Van Loan;<br />
&quot;Bayesian Statistics&quot; by WEI Laisheng;<br />
&quot;Machine Learning&quot; by NAKAGAWA Hiroshi.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stats-package">stats</a></code>, <code><a href="mvtnorm.html#topic+Mvnorm">mvtnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Rfast)
library(mvtnorm)
library(plyr)

head(dataset1)

BP &lt;- MVN_BayesianPosteriori(dataset1)
BP

BP_Gibbs &lt;- MVN_GibbsSampler(5000, BP)
colMeans(BP_Gibbs)
colrange(BP_Gibbs)

result &lt;- MVN_MCMC(BP, 5000, c(1), c(77.03))
result$Accept
</code></pre>

<hr>
<h2 id='Ascending_Num'>
Renumbering vector by elemental frequency
</h2><span id='topic+Ascending_Num'></span>

<h3>Description</h3>

<p>Renumbering vector by elemental frequency in ascending order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Tidy vector by elemental frequency:
Ascending_Num(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ascending_Num_+3A_data">data</code></td>
<td>

<p>An 1d-vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a renumbered vector by elemental frequency. Factors will be positive integers arrayed in ascending order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(plyr)

x &lt;- c(1,2,2,2,2,2,2,2,3,3,3,1,3,3,3)
x
Ascending_Num(x)
</code></pre>

<hr>
<h2 id='dataset1'>
Dataset for MVN test
</h2><span id='topic+dataset1'></span>

<h3>Description</h3>

<p>Dataset built for MVN mixture test, which contains 3 variables and 25 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataset1")</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations on 3 independent variables, named as <code>fac1</code>, <code>fac2</code> and <code>fac3</code>.
</p>

<dl>
<dt><code>fac1</code></dt><dd><p>The 1st factor.</p>
</dd>
<dt><code>fac2</code></dt><dd><p>The 2nd factor.</p>
</dd>
<dt><code>fac3</code></dt><dd><p>The 3rd factor.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  dataset1
</code></pre>

<hr>
<h2 id='dataset2'>
Dataset for MVN mixture test
</h2><span id='topic+dataset2'></span>

<h3>Description</h3>

<p>Dataset built for MVN mixture test, which contains 4 variables (the first 4 columns), clustering (the last column) and 96 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dataset2")</code></pre>


<h3>Format</h3>

<p>A data frame with 96 pseudo-observations generated by random number generator. All observations come from 3 different centers which have been marked in the last column &quot;species&quot;. More specifically, data of species=1 comes from the center (1,1,1,1); data of species=2 comes from the center (2,2,2,0); data of species=3 comes from the center (1,0,2,2).
</p>

<dl>
<dt><code>dimen1</code></dt><dd><p>the 1st variable</p>
</dd>
<dt><code>dimen2</code></dt><dd><p>the 2nd variable</p>
</dd>
<dt><code>dimen3</code></dt><dd><p>the 3rd variable</p>
</dd>
<dt><code>dimen4</code></dt><dd><p>the 4th variable</p>
</dd>
<dt><code>species</code></dt><dd><p>clustering label</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>dataset2
</code></pre>

<hr>
<h2 id='MatrixAlternative'>
Interchanging specified rows and columns
</h2><span id='topic+MatrixAlternative'></span>

<h3>Description</h3>

<p>Interchange all elements between two specified rows and columns in a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># A matrix-like data
MatrixAlternative(data, sub, rep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatrixAlternative_+3A_data">data</code></td>
<td>

<p>A matrix to be processed.
</p>
</td></tr>
<tr><td><code id="MatrixAlternative_+3A_sub">sub</code></td>
<td>

<p>A positive integer. The first selected dimension.
</p>
</td></tr>
<tr><td><code id="MatrixAlternative_+3A_rep">rep</code></td>
<td>

<p>A positive integer. The second selected dimension. Default value is 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a matrix with interchanged rows and columns in two specified dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(plyr)

M &lt;- matrix(1:9,3,3,1)
M
MatrixAlternative(M, 2)
</code></pre>

<hr>
<h2 id='MixMVN_BayesianPosteriori'>
Calculate Bayesian posteriori MVN mixture distribution
</h2><span id='topic+MixMVN_BayesianPosteriori'></span>

<h3>Description</h3>

<p>The function to export the mixture probabilities, the mean vectors and covariance matrices of Bayesian posteriori MVN mixture distribution in the basis of given priori information (priori MVN mixture) and observation data (a design matrix containing all variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># paramtric columns-only as input data:
# data &lt;- dataset2[,1:4]

# Specify species to get parameters of MVN mixture model:
MixMVN_BayesianPosteriori(data, species, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixMVN_BayesianPosteriori_+3A_data">data</code></td>
<td>

<p>A data.frame or matrix-like data: obervations should be arrayed in rows while variables should be arrayed in columns.
</p>
</td></tr>
<tr><td><code id="MixMVN_BayesianPosteriori_+3A_species">species</code></td>
<td>

<p>A positive integer. The number of clusters for import data. It will be only called once by the next argument <code>idx</code> through <code><a href="stats.html#topic+kmeans">kmeans</a></code> clustering algrithm in this function. Default value is 1, which means no clustering algrithm is used.
</p>
</td></tr>
<tr><td><code id="MixMVN_BayesianPosteriori_+3A_idx">idx</code></td>
<td>

<p>A vector-like data to import for accepting clustering result. Default value is generated by <code><a href="stats.html#topic+kmeans">kmeans</a></code> clustering. Notice the length of idx should be the same as observation numbers of data (rows).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a matrix-like result containing all parameters of Bayesian posteriori MVN mixture distribution:
Clusters are arrayed in rows, while the mixture probabilities, posteriori mean vectors and posteriori covariance matrices are arrayed in columns.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="#topic+MVN_BayesianPosteriori">MVN_BayesianPosteriori</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(plyr)

# Design matrix should only contain columns of variables
# Export will be a matrix-like data
# Using kmeans (default) clustering algrithm
data_dim &lt;- dataset2[,1:4]
result &lt;- MixMVN_BayesianPosteriori(data=data_dim, species=3)
result

# Get the parameters of the cluster1:
result[1,]

# Get the mixture probability of cluster2:
# (Attention to the difference between
# result[2,1][[1]] and result[2,1])
result[2,1][[1]]

# Get the mean vector of cluster1:
result[1,2][[1]]

# Get the covariance matrix of cluster3:
result[3,3][[1]]
</code></pre>

<hr>
<h2 id='MixMVN_GibbsSampler'>
Gibbs sampler for MVN mixture distribution
</h2><span id='topic+MixMVN_GibbsSampler'></span>

<h3>Description</h3>

<p>Generating random vectors on the basis of a given MVN mixture distribution, through Gibbs sampling algorithm or matrix factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Bayesian posteriori MVN mixture model as input data:
# data &lt;- MixMVN_BayesianPosteriori(dataset2[,1:4], species=3)

# Generate random vectors based on Bayesian posteriori MVN mixture:
MixMVN_GibbsSampler(n, data, random_method = c("Gibbs", "Fast"), reject_rate=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixMVN_GibbsSampler_+3A_n">n</code></td>
<td>

<p>A positive integer. The numbers of random vectors to be generated.
</p>
</td></tr>
<tr><td><code id="MixMVN_GibbsSampler_+3A_data">data</code></td>
<td>

<p>A matrix-like data which contains the mixture probability, mean vector and covariance matrix for each cluster in each row.
</p>
</td></tr>
<tr><td><code id="MixMVN_GibbsSampler_+3A_random_method">random_method</code></td>
<td>

<p>The method to generate random vectors. Options are <code>"Gibbs"</code>: Gibbs sampling for MVN mixture model; and <code>"Fast"</code>: call <code><a href="mvtnorm.html#topic+Mvnorm">rmvnorm()</a></code> to generate random vectors based on matrix factorization.
</p>
</td></tr>
<tr><td><code id="MixMVN_GibbsSampler_+3A_reject_rate">reject_rate</code></td>
<td>

<p>A numeric value which will be efficient if the <code>random_method</code> is &quot;Gibbs&quot;: Determine the discarded items in burn-in period by ratio. Default value is 0. For details see <code><a href="#topic+MVN_GibbsSampler">MVN_GibbsSampler</a></code>.
</p>
</td></tr>
<tr><td><code id="MixMVN_GibbsSampler_+3A_...">...</code></td>
<td>

<p>Other arguments to control the process in Gibbs sampling if the <code>random_method</code> is &quot;Gibbs&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommanded using the random method of &quot;Fast&quot; due to the high efficiency. The time complexity of &quot;Gibbs&quot; method is O(k*n) where the k means dimensionality of MVN mixture model and n means generated numbers of random vectors; while that of the &quot;Fast&quot; method is only O(n), without considering the effect of burn-in period. this discrepancy will be even further significant when we use MCMC methods to do some further analysis in which random vectors will be generated every time when we set conditions.
</p>


<h3>Value</h3>

<p>return a series random vectors in the basis of given MVN mixture distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ascending_Num">Ascending_Num</a></code>, <code><a href="#topic+MixMVN_BayesianPosteriori">MixMVN_BayesianPosteriori</a></code>, <code><a href="#topic+MVN_BayesianPosteriori">MVN_BayesianPosteriori</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(plyr)
library(mvtnorm)
library(stats)

# Use dataset2 for demonstration. Get parameters of Bayesian
# posteriori multivariate normal mixture distribution
head(dataset2)
dataset2_par &lt;- dataset2[,1:4] # only parameter columns are premitted
MixBPos &lt;- MixMVN_BayesianPosteriori(dataset2_par, species=3)
MixBPos

# Generate random vectors using Gibbs sampling:
MixBPos_Gibbs &lt;- MixMVN_GibbsSampler(5000, MixBPos, random_method = "Gibbs")
head(MixBPos_Gibbs)

# Compared generation speed of "Gibbs" to that of "Fast"
MixBPos_Fast &lt;- MixMVN_GibbsSampler(5000, MixBPos, random_method = "Fast")
head(MixBPos_Fast)

# Visulization by clusters:
library(rgl)
dimen1 &lt;- MixBPos_Gibbs[,1]
dimen2 &lt;- MixBPos_Gibbs[,2]
dimen3 &lt;- MixBPos_Gibbs[,3]
dimen4 &lt;- MixBPos_Gibbs[,4]
plot3d(x=dimen1, y=dimen2, z=dimen3, col=MixBPos_Gibbs[,5], size=2)

</code></pre>

<hr>
<h2 id='MixMVN_MCMC'>
MCMC simulation for MVN mixture distribution
</h2><span id='topic+MixMVN_MCMC'></span>

<h3>Description</h3>

<p>Function to get a MCMC simulation results based on the imported MVN mixture distribution. It is commonly used for inquiring the specified conditional probability of MVN mixture distribuiton calculated through Bayesian posteriori.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Bayesian posteriori mix MVN as input data:
# data &lt;- MixMVN_BayesianPosteriori(dataset2[,1:4], 3)

# run MCMC simulation based on Bayesian posteriori mix MVN:
MixMVN_MCMC(data, steps, pars, values, tol, random_method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MixMVN_MCMC_+3A_data">data</code></td>
<td>

<p>A matrix-like data containing the mixture probability, mean vector and covariance matrix for each cluster in each row.
</p>
</td></tr>
<tr><td><code id="MixMVN_MCMC_+3A_steps">steps</code></td>
<td>

<p>A positive integer. The numbers of random vectors to be generated for MCMC step.
</p>
</td></tr>
<tr><td><code id="MixMVN_MCMC_+3A_pars">pars</code></td>
<td>

<p>A integer vector to declare fixed dimension(s). For example if the desired dimensions are 1st=7 and 3rd=10, set this argument as c(1,3).
</p>
</td></tr>
<tr><td><code id="MixMVN_MCMC_+3A_values">values</code></td>
<td>

<p>A numeric vector to assign value(s) to declared dimension(s). For example if the desired dimensions are 1st=7 and 3rd=10, set this argument as c(7,10).
</p>
</td></tr>
<tr><td><code id="MixMVN_MCMC_+3A_tol">tol</code></td>
<td>

<p>Tolerance. A numeric value to control the generated vectors to be accepted or rejected. Criterion uses Euclidean distance in declared dimension(s). Default value is 0.3.
</p>
</td></tr>
<tr><td><code id="MixMVN_MCMC_+3A_random_method">random_method</code></td>
<td>

<p>The method to generate random vectors. Options are <code>"Gibbs"</code>: Gibbs sampling for MVN mixture model; and <code>"Fast"</code>: call <code><a href="mvtnorm.html#topic+Mvnorm">rmvnorm()</a></code> to generate random vectors based on matrix factorization. Default option is <code>"Fast"</code>.
</p>
</td></tr>
<tr><td><code id="MixMVN_MCMC_+3A_...">...</code></td>
<td>

<p>Other arguments to control the process in Gibbs sampling if the <code>random_method</code> is &quot;Gibbs&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list which contains:
</p>
<table>
<tr><td><code>AcceptRate</code></td>
<td>
<p>Acceptance of declared conditions of MCMC</p>
</td></tr>
<tr><td><code>MCMCdata</code></td>
<td>
<p>All generated random vectors in MCMC step based on MVN mixture distribution</p>
</td></tr>
<tr><td><code>Accept</code></td>
<td>
<p>Subset of accepted sampling in MCMCdata</p>
</td></tr>
<tr><td><code>Reject</code></td>
<td>
<p>Subset of rejected sampling in MCMCdata</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MixMVN_BayesianPosteriori">MixMVN_BayesianPosteriori</a></code>, <code><a href="#topic+MixMVN_GibbsSampler">MixMVN_GibbsSampler</a></code>, <code><a href="#topic+MVN_GibbsSampler">MVN_GibbsSampler</a></code>, <code><a href="#topic+MVN_FConditional">MVN_FConditional</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(plyr)
library(mvtnorm)
library(stats)

# dataset2 has 4 parameters: dimen1, dimen2, dimen3 and dimen4:
head(dataset2)
dataset2_dim &lt;- dataset2[,1:4] # extract parametric columns

# Get posteriori parameters of dataset2 using kmeans 3 clustering:
MixBPos &lt;- MixMVN_BayesianPosteriori(dataset2_dim, 3)

# If we want to know when dimen1=1, which clusters are accepted, run:
MixBPos_MCMC &lt;- MixMVN_MCMC(MixBPos, steps=5000, pars=c(1), values=c(1), tol=0.3)
MixBPos_MCMC$AcceptRate
result &lt;- MixBPos_MCMC$MCMCdata
head(result)

# count accepted samples by clustering:
count(result[which(result[,7]==1),5])

library(rgl)
# Visualization using plot3d() if necessary:
# Clustering result in the rest 3 dimensions:
plot3d(result[,2], result[,3], z=result[,4], col=result[,5], size=2)

# Acceptance rejection visualization:
plot3d(result[,2], result[,3], z=result[,4], col=result[,7]+1, size=2)

</code></pre>

<hr>
<h2 id='MVN_BayesianIterator'>
Parameter estimation using Bayesian iteration
</h2><span id='topic+MVN_BayesianIterator'></span>

<h3>Description</h3>

<p>Function to execute parameter estimation for MVN distribution, under Bayesian analysis framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Get parameters of Bayesian posteriori MVN:
MVN_BayesianIterator(data, pri_mean=colMeans(data), Gibbs_nums=5000,
pseudo_nums=dim(data)[1], threshold=1e-04, iteration=100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVN_BayesianIterator_+3A_data">data</code></td>
<td>

<p>A data.frame or matrix-like data: obervations should be arrayed in rows while variables should be arrayed in columns.
</p>
</td></tr>
<tr><td><code id="MVN_BayesianIterator_+3A_pri_mean">pri_mean</code></td>
<td>

<p>A numeric vector to assign priori mean for MVN. Default value applies <code><a href="base.html#topic+colSums">colMeans()</a></code> to data.
</p>
</td></tr>
<tr><td><code id="MVN_BayesianIterator_+3A_gibbs_nums">Gibbs_nums</code></td>
<td>

<p>A positive integer. The numbers of random vectors to be generated for each iteration step. Defult value is 5000.
</p>
</td></tr>
<tr><td><code id="MVN_BayesianIterator_+3A_pseudo_nums">pseudo_nums</code></td>
<td>

<p>A positive integer. The argument to determine numbers of generated vectors used for each iteration step. Default value keeps the same scale as input data. Notice that a too small value can result in singular matrix.
</p>
</td></tr>
<tr><td><code id="MVN_BayesianIterator_+3A_threshold">threshold</code></td>
<td>

<p>A numeric value to control stoping the iteration loop. Default value used 0.0001. While the Euclidean distance of mean vectors between pseudo-data (the last <code>pseudo_nums</code> items) and Bayesian posteriori is less than threshold, iteration stops.
</p>
</td></tr>
<tr><td><code id="MVN_BayesianIterator_+3A_iteration">iteration</code></td>
<td>

<p>A positive integer. Argument to assign the maximum steps for iteration. Default value is 100 after which the iteration loop will compulsively exit.
</p>
</td></tr>
<tr><td><code id="MVN_BayesianIterator_+3A_...">...</code></td>
<td>

<p>Other arguments to control the process in Gibbs sampling.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because that MVN distribution possess conjugated property in Bayesian analysis framework, the convergence of Bayesian iterator for MVN distribution can be ensured, accoumpanied with the shrink of 2nd-norm of Bayesian posteriori covariance matrix. But pay attention to the fact that pseudo-data leads to the randomness, the argument <code>pseudo_nums</code> should be set carefully.
</p>


<h3>Value</h3>

<p>return a double level list containing Bayesian posteriori after iteration process:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>Bayesian posteriori mean vector</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Bayesian posteriori covariance matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If the parameter values are the only interested thing we concerned, this iterator makes sense. Since it can significantly help us decrease the scale of covariance matrix, to obtain a more reliable estimation for the parameters. However, in more cases, some correlationships of a certain group of pamameters are more valuable, which are usually clued by the covariance matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MVN_BayesianPosteriori">MVN_BayesianPosteriori</a></code>, <code><a href="#topic+MVN_GibbsSampler">MVN_GibbsSampler</a></code>, <code><a href="#topic+MVN_FConditional">MVN_FConditional</a></code>, <code><a href="#topic+MatrixAlternative">MatrixAlternative</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)

# Bayesian posteriori before iteration using dataset1 as example,
# c(80, 16, 3) as priori mean:
# View 2-norm of covariance matrix of Bayesian posteriori:
BPos_init &lt;- MVN_BayesianPosteriori(dataset1, c(80,16,3))
BPos_init
norm(as.matrix(BPos_init$var), type = "2")

# Bayesian posteriori after iteration using c(80,16,3) as priori
# Using 30 last samples generated by GibbsSampler for each step:
BPos_fina1 &lt;- MVN_BayesianIterator(dataset1, c(80,16,3), 5000, 30)
BPos_fina1
norm(as.matrix(BPos_fina1$var), type = "2")

# Too small pseudo_nums setting can results in singular system, try:
MVN_BayesianIterator(dataset1, pseudo_nums=3)

</code></pre>

<hr>
<h2 id='MVN_BayesianPosteriori'>
Calculate Bayesian posteriori MVN distribution
</h2><span id='topic+MVN_BayesianPosteriori'></span>

<h3>Description</h3>

<p>The function to export the mean vector and covariance matrix of Bayesian posteriori MVN distribution in the basis of given priori information (priori MVN) and observation data (a design matrix containing all variables).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Given the data as design matrix, priori mean vector and priori covariance
# matrix, this function will export a list which contains mean ($mean) and
# covariance ($var) of Bayesian posteriori multivariate normal distribution.

MVN_BayesianPosteriori(data, pri_mean, pri_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVN_BayesianPosteriori_+3A_data">data</code></td>
<td>

<p>A data.frame or matrix-like data: obervations should be arrayed in rows while variables should be arrayed in columns.
</p>
</td></tr>
<tr><td><code id="MVN_BayesianPosteriori_+3A_pri_mean">pri_mean</code></td>
<td>

<p>A numeric vector to assign priori mean for MVN. Default value applies <code><a href="base.html#topic+colSums">colMeans()</a></code> to data.
</p>
</td></tr>
<tr><td><code id="MVN_BayesianPosteriori_+3A_pri_var">pri_var</code></td>
<td>

<p>A matrix-like parameter to assign priori covariance matrix. Default value uses unit matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a double level list containing:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>mean vector of Bayesian posteriori MVN distribution</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>covariance of Bayesian posteriori MVN distribution</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is strongly recommanded that users should have some prior knowledge of ill-conditioned system before using this function. Simply, ill-conditioned system, or singular matrix, is caused by a) insufficient data or b) almostly linear dependency of two certain parameters, which two can result in a excessively small eigenvalue then cause a ill-conditioned (singular) system. Therefore users must diagnose their data firstly to confirm the fact that the it contains enough observations, and the degree of freedom is strictly equal to the number of parameters as well. Additionally, for the argument <code>pri_var</code>, a real symmetric matrix is desired by definition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Demo using dataset1:
head(dataset1)
BPos &lt;- MVN_BayesianPosteriori(dataset1, c(80,16,3))
BPos$mean
BPos$var

# Singular system caused by insufficient data
eigen(var(dataset1[1:3,]))$values
rcond(var(dataset1[1:3,]))
eigen(var(dataset1[1:6,]))$values
rcond(var(dataset1[1:6,]))

# Singular system caused by improper degree of freedom
K &lt;- cbind(dataset1, dataset1[,3]*(-2)+3)
eigen(var(K[,2:4]))$values
rcond(var(K[,2:4]))
</code></pre>

<hr>
<h2 id='MVN_FConditional'>
Calculate full conditional normal ditribution of MVN
</h2><span id='topic+MVN_FConditional'></span>

<h3>Description</h3>

<p>Function to export parameters of full conditional normal distribution in basis of given MVN distribution, the undecided dimension, as well as all values in the rest dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Bayesian posteriori as input data:
# data &lt;- MVN_BayesianPosteriori(dataset1, c(80,16,3))

# inquire parameters of full-conditional distribution based on Bayesian posteriori:
MVN_FConditional(data, variable, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVN_FConditional_+3A_data">data</code></td>
<td>

<p>A double level list containing all parameters of MVN distribution: mean vector (<code>data$mean</code>) and covariance matrix (<code>data$var</code>).
</p>
</td></tr>
<tr><td><code id="MVN_FConditional_+3A_variable">variable</code></td>
<td>

<p>A integer to specify the undecided dimension.
</p>
</td></tr>
<tr><td><code id="MVN_FConditional_+3A_z">z</code></td>
<td>

<p>A nd-vector to assign conditions (n = dimensions of given MVN distribution). It should be noted that the value in dimension specified by <code>variable</code> doesn't participate in the calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can be proved that any full conditional distribution from a given MVN will degenerate to an 1d-normal distribution.
</p>


<h3>Value</h3>

<p>return a double level list containing the following parameters of full conditional normal distributions of given MVN in specified dimension:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>a numberic mean of a normal distribution</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>a numberic variance of a normal distribution</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MVN_BayesianPosteriori">MVN_BayesianPosteriori</a></code>, <code><a href="#topic+MatrixAlternative">MatrixAlternative</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(dataset1)
BPos &lt;- MVN_BayesianPosteriori(dataset1, c(80,16,3))
BPos # Bayesian Posteriori
result &lt;- MVN_FConditional(BPos, variable = 1, z=c(75, 13, 4))
result$mean
class(result$mean)
result$var
class(result$var)

# compare the following results:
MVN_FConditional(BPos, variable = 2, z=c(75, 13, 4))
MVN_FConditional(BPos, variable = 2, z=c(75, 88, 4))
MVN_FConditional(BPos, variable = 1, z=c(75, 88, 4))
</code></pre>

<hr>
<h2 id='MVN_GibbsSampler'>
Gibbs sampler for MVN distribution
</h2><span id='topic+MVN_GibbsSampler'></span>

<h3>Description</h3>

<p>Generating random vectors on the basis of a given MVN distribution, through Gibbs sampling algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Bayesian posteriori as data
# data &lt;- MVN_BayesianPosteriori(dataset1)

# Using Gibbs sampler to generate random vectors based on Bayesian posteriori:
MVN_GibbsSampler(n, data, initial, reject_rate, burn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVN_GibbsSampler_+3A_n">n</code></td>
<td>

<p>A positive integer. The numbers of random vectors to be generated.
</p>
</td></tr>
<tr><td><code id="MVN_GibbsSampler_+3A_data">data</code></td>
<td>

<p>A double level list which contains the mean vector (<code>data$mean</code>) and the covariance matrix (<code>data$var</code>) of a given MVN distribution.
</p>
</td></tr>
<tr><td><code id="MVN_GibbsSampler_+3A_initial">initial</code></td>
<td>

<p>Initial vector where Markov chain starts. Default value use a random vector generated by <code><a href="mvtnorm.html#topic+Mvnorm">rmvnorm()</a></code>.
</p>
</td></tr>
<tr><td><code id="MVN_GibbsSampler_+3A_reject_rate">reject_rate</code></td>
<td>

<p>A numeric to control burn-in period by ratio. Default value is 0.2, namely the first 20% generated vectors will be rejected. If this arg was customized, the next arg <code>burn</code> should maintain the default value.
</p>
</td></tr>
<tr><td><code id="MVN_GibbsSampler_+3A_burn">burn</code></td>
<td>

<p>A numeric to control burn-in period by numbers. If this arg was customized, final result will be generated by this manner in which it will drop the first n numbers (n=<code>burn</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There're also some literatures suggest using the mean or mode of priori as initial vector. Users can customize this setting according to their own needs.
</p>


<h3>Value</h3>

<p>return a series random vectors in the basis of given MVN distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MVN_FConditional">MVN_FConditional</a></code>, <code><a href="#topic+MatrixAlternative">MatrixAlternative</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)

# Get parameters of Bayesian posteriori multivariate normal distribution
BPos &lt;- MVN_BayesianPosteriori(dataset1)
BPos

# Using previous result (BPos) to generate random vectors through Gibbs
# sampling: 7000 observations, start from c(1,1,2), use 0.3 burning rate
BPos_Gibbs &lt;- MVN_GibbsSampler(7000, BPos, initial=c(1,1,2), 0.3)
tail(BPos_Gibbs)

# Check for convergence of Markov chain
BPos$mean
colMeans(BPos_Gibbs)
BPos$var
var(BPos_Gibbs)

# 3d Visulization:
library(rgl)
fac1 &lt;- BPos_Gibbs[,1]
fac2 &lt;- BPos_Gibbs[,2]
fac3 &lt;- BPos_Gibbs[,3]
plot3d(x=fac1, y=fac2, z=fac3, col="red", size=2)

</code></pre>

<hr>
<h2 id='MVN_MCMC'>
MCMC simulation for MVN distribution
</h2><span id='topic+MVN_MCMC'></span>

<h3>Description</h3>

<p>Function to get a MCMC simulation results based on the imported MVN distribution. It is commonly used for inquiring the specified conditional probability of MVN distribuiton calculated through Bayesian posteriori.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Bayesian posteriori as input data
# data &lt;- MVN_BayesianPosteriori(dataset1, pri_mean=c(80,16,3))

# run MCMC simulation using Bayesian posteriori:
MVN_MCMC(data, steps, pars, values, tol, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MVN_MCMC_+3A_data">data</code></td>
<td>

<p>A double level list which contains the mean vector (<code>data$mean</code>) and the covariance matrix (<code>data$var</code>) of a given MVN distribution.
</p>
</td></tr>
<tr><td><code id="MVN_MCMC_+3A_steps">steps</code></td>
<td>

<p>A positive integer. The numbers of random vectors to be generated for MCMC step.
</p>
</td></tr>
<tr><td><code id="MVN_MCMC_+3A_pars">pars</code></td>
<td>

<p>A integer vector to declare fixed dimension(s). For example if the desired dimensions are 1st=7 and 3rd=10, set this argument as c(1,3).
</p>
</td></tr>
<tr><td><code id="MVN_MCMC_+3A_values">values</code></td>
<td>

<p>A numeric vector to assign value(s) to declared dimension(s). For example if the desired dimensions are 1st=7 and 3rd=10, set this argument as c(7,10).
</p>
</td></tr>
<tr><td><code id="MVN_MCMC_+3A_tol">tol</code></td>
<td>

<p>Tolerance. A numeric value to control the generated vectors to be accepted or rejected. Criterion uses Euclidean distance in declared dimension(s). Default value is 0.3.
</p>
</td></tr>
<tr><td><code id="MVN_MCMC_+3A_...">...</code></td>
<td>

<p>Other arguments to control the process in Gibbs sampling.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list which contains:
</p>
<table>
<tr><td><code>AcceptRate</code></td>
<td>
<p>Acceptance of declared conditions of MCMC</p>
</td></tr>
<tr><td><code>MCMCdata</code></td>
<td>
<p>All generated random vectors in MCMC step based on MVN distribution</p>
</td></tr>
<tr><td><code>Accept</code></td>
<td>
<p>Subset of accepted sampling in MCMCdata</p>
</td></tr>
<tr><td><code>Reject</code></td>
<td>
<p>Subset of rejected sampling in MCMCdata</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+MVN_GibbsSampler">MVN_GibbsSampler</a></code>, <code><a href="#topic+MVN_FConditional">MVN_FConditional</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
library(plyr)

# dataset1 has three parameters: fac1, fac2 and fac3:
head(dataset1)

# Get posteriori parameters of dataset1 using prior of c(80,16,3):
BPos &lt;- MVN_BayesianPosteriori(dataset1, pri_mean=c(80,16,3))

# If we want to know when fac1=78, how fac2 responses to fac3, run:
BPos_MCMC &lt;- MVN_MCMC(BPos, steps=8000, pars=c(1), values=c(78), tol=0.3)
MCMC &lt;- BPos_MCMC$MCMCdata
head(MCMC)

# Visualization using plot3d() if necessary:
library(rgl)
plot3d(MCMC[,1], MCMC[,2], z=MCMC[,3], col=MCMC[,5]+1, size=2)

# Visualization: 2d scatter plot
MCMC_2d &lt;- BPos_MCMC$Accept
head(MCMC_2d)
plot(MCMC_2d[,3], MCMC_2d[,2], pch=20, col="red", xlab = "fac3", ylab = "fac2")

# Compared to the following scatter plot when fac1 is not fixed:
plot(BPos_MCMC$MCMCdata[,3], BPos_MCMC$MCMCdata[,2], pch=20, col="red", xlab = "fac3",
ylab = "fac2")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
