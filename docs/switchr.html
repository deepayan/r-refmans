<!DOCTYPE html><html><head><title>Help for package switchr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {switchr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.libPaths2'><p>.libpaths2</p></a></li>
<li><a href='#addPkg'><p>addPkg</p></a></li>
<li><a href='#archive_retries'><p>archive_retries</p></a></li>
<li><a href='#archive_timing'><p>archive_timing</p></a></li>
<li><a href='#BiocDevel'><p>BiocDevel</p></a></li>
<li><a href='#BiocRelease'><p>BiocRelease</p></a></li>
<li><a href='#biocReposForVers'><p>biocReposForVers</p></a></li>
<li><a href='#BiocSVNManifest'><p>DEPCRECATED - Create a manifest of Bioc SVN locations</p></a></li>
<li><a href='#BiocVers'><p>BiocVers</p></a></li>
<li><a href='#branch'><p>branch</p></a></li>
<li><a href='#c+2CSessionManifest-method'><p>cmethods</p></a></li>
<li><a href='#checkIsPkgDir'><p>Check if a directory contains package sources</p></a></li>
<li><a href='#cranPkgVersManifest'><p>cranPkgVersManifest</p></a></li>
<li><a href='#currentCompEnv'><p>currentCompEnv</p></a></li>
<li><a href='#defaultRepos'><p>defaultRepos</p></a></li>
<li><a href='#dep_repos'><p>dep_repos</p></a></li>
<li><a href='#dl_method'><p>dl_method</p></a></li>
<li><a href='#errorOrNonZero'><p>Identify error states from R or external programs</p></a></li>
<li><a href='#fileFromFileURL'><p>Get path from file URL</p></a></li>
<li><a href='#findNewestPkgInds'><p>Find newest packages in a package info data.frame</p></a></li>
<li><a href='#findPkgDir'><p>Find a package directory within an SCM checkout</p></a></li>
<li><a href='#findPkgVersionInRepo'><p>findPkgVersionInRepo</p></a></li>
<li><a href='#flushSession'><p>flushSession</p></a></li>
<li><a href='#full_libpaths'><p>full_libpaths</p></a></li>
<li><a href='#getPkgDir'><p>Construct pockage directory path</p></a></li>
<li><a href='#GithubManifest'><p>GithubManifest</p></a></li>
<li><a href='#gotoVersCommit'><p>gotoVersCommit</p></a></li>
<li><a href='#graceful_inet'><p>Internal internet harness</p></a></li>
<li><a href='#head'><p>Head and tail operations on manifests</p></a></li>
<li><a href='#install_packages'><p>install_packages</p></a></li>
<li><a href='#lazyRepo'><p>lazyRepo</p></a></li>
<li><a href='#libManifest'><p>libManifest</p></a></li>
<li><a href='#library_paths'><p>library_paths</p></a></li>
<li><a href='#loadGRAN'><p>Load a GRAN repo package</p></a></li>
<li><a href='#loadManifest'><p>loadManifest</p></a></li>
<li><a href='#locatePkgVersion'><p>locatePkgVersion</p></a></li>
<li><a href='#location'><p>location</p></a></li>
<li><a href='#logfun'><p>logfun</p></a></li>
<li><a href='#makeBiocSVNURL'><p>Make a Bioconductor SVN url for a package</p></a></li>
<li><a href='#makeFileURL'><p>make file url</p></a></li>
<li><a href='#makeLibraryCtx'><p>makeLibraryCtx</p></a></li>
<li><a href='#makeManifest'><p>Manifest constructor</p></a></li>
<li><a href='#makePkgCheckout'><p>Create a checkout of a package and all it's dependencies from a manifest</p></a></li>
<li><a href='#makePkgDir'><p>makePkgDir</p></a></li>
<li><a href='#makeSeedMan'><p>makeSeedMan</p></a></li>
<li><a href='#makeSource'><p>Create a PkgSource object for a package</p></a></li>
<li><a href='#manifest'><p>Get or set the manifest associated with an object</p></a></li>
<li><a href='#manifest_df'><p>manifest_df</p></a></li>
<li><a href='#manifestFromCheckoutDir'><p>Create Manifest from 'checkedout' directory containing many pkg dirs</p></a></li>
<li><a href='#ManifestRow'><p>ManifestRow</p></a></li>
<li><a href='#normalizePath2'><p>normalizePath2</p></a></li>
<li><a href='#notrack'><p>Notrack directory</p></a></li>
<li><a href='#nrow'><p>Number of rows</p></a></li>
<li><a href='#packages'><p>packages</p></a></li>
<li><a href='#parsedSessionInfo-class'><p>Parsed sessionInfo output</p></a></li>
<li><a href='#parseSessionInfoString'><p>Parse text output from printing SessionInfo objects</p></a></li>
<li><a href='#PkgManifest'><p>PkgManifest</p></a></li>
<li><a href='#pkgname'><p>pkgname</p></a></li>
<li><a href='#PkgSource-class'><p>PkgSource</p></a></li>
<li><a href='#publishManifest'><p>publishManifest</p></a></li>
<li><a href='#removeLib'><p>removeLib</p></a></li>
<li><a href='#RepoSubset'><p>RepoSubset</p></a></li>
<li><a href='#rVersionManifest'><p>rVersionManifest</p></a></li>
<li><a href='#SessionManifest'><p>SessionManifest</p></a></li>
<li><a href='#sh_init_script'><p>shell init</p></a></li>
<li><a href='#shell_timing'><p>Get or set the number of seconds to wait between successive shell commands</p></a></li>
<li><a href='#subdir'><p>subdir</p></a></li>
<li><a href='#switchBack'><p>switchBack</p></a></li>
<li><a href='#switchDeps'><p>switchrDeps</p></a></li>
<li><a href='#switchrBaseDir'><p>Get or set the base directory for switchr libraries</p></a></li>
<li><a href='#SwitchrCtx'><p>SwitchrCtx</p></a></li>
<li><a href='#switchrDontUnload'><p>Get or set packages to not unload when flushing the system</p></a></li>
<li><a href='#switchrManifest'><p>switchrManifest</p></a></li>
<li><a href='#switchrNoUnload'><p>Skip unloading of packages in session</p></a></li>
<li><a href='#SwitchrParam-class'><p>SwitchrParam</p></a></li>
<li><a href='#switchTo'><p>switchTo</p></a></li>
<li><a href='#system_w_init'><p>system_w_init</p></a></li>
<li><a href='#update_PACKAGES'><p>update existing package repository</p></a></li>
<li><a href='#updateManifest'><p>updateManifest</p></a></li>
<li><a href='#versions_df'><p>versions_df</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Installing, Managing, and Switching Between Distinct Sets of
Installed Packages</td>
</tr>
<tr>
<td>Version:</td>
<td>0.14.8</td>
</tr>
<tr>
<td>Author:</td>
<td>Gabriel Becker[aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabriel Becker &lt;gabembecker@gmail.com&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Genentech Inc</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an abstraction for managing, installing,
    and switching between sets of installed R packages. This allows users to
    maintain multiple package libraries simultaneously, e.g. to maintain
    strict, package-version-specific reproducibility of many analyses, or
    work within a development/production release paradigm. Introduces a
    generalized package installation process which supports multiple repository
    and non-repository sources and tracks package provenance.</td>
</tr>
<tr>
<td>Imports:</td>
<td>tools, RJSONIO, RCurl</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocManager</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>git, svn</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gmbecker/switchr">https://github.com/gmbecker/switchr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gmbecker/switchr/issues">https://github.com/gmbecker/switchr/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-20 00:26:22 UTC; gabrielbecker</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-21 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.libPaths2'>.libpaths2</h2><span id='topic+.libPaths2'></span>

<h3>Description</h3>

<p>A version of .libPaths which allows for excluding the site library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.libPaths2(fulllp, exclude.site = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".libPaths2_+3A_fulllp">fulllp</code></td>
<td>
<p>The libpath to use, as in .libPaths</p>
</td></tr>
<tr><td><code id=".libPaths2_+3A_exclude.site">exclude.site</code></td>
<td>
<p>logical. Should the site library be suppressed.
Defaults to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Behaves exactly as the .libPaths function does, with the exception
of optionally excluding the site library
</p>


<h3>Value</h3>

<p>a vector of library paths currently in use, optionally
excluding the site library.
</p>

<hr>
<h2 id='addPkg'>addPkg</h2><span id='topic+addPkg'></span><span id='topic+addPkg+2CPkgManifest-method'></span><span id='topic+addPkg+2CPkgManifest'></span><span id='topic+addPkg+2CSessionManifest-method'></span><span id='topic+addPkg+2CSessionManifest'></span>

<h3>Description</h3>

<p>Add a package to an object associated with a manifest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPkg(
  x,
  ...,
  rows = makeManifest(...),
  versions = data.frame(name = manifest_df(rows)$name, version = NA_character_,
    stringsAsFactors = FALSE),
  replace = FALSE
)

## S4 method for signature 'PkgManifest'
addPkg(
  x,
  ...,
  rows = makeManifest(...),
  versions = data.frame(name = manifest_df(rows)$name, version = NA_character_,
    stringsAsFactors = FALSE),
  replace = FALSE
)

## S4 method for signature 'SessionManifest'
addPkg(
  x,
  ...,
  rows = makeManifest(...),
  versions = data.frame(name = manifest_df(rows)$name, version = NA_character_,
    stringsAsFactors = FALSE),
  replace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPkg_+3A_x">x</code></td>
<td>
<p>A manifest or manifest-associate objec tto add the pkg 2</p>
</td></tr>
<tr><td><code id="addPkg_+3A_...">...</code></td>
<td>
<p>The information regarding the package to place in the manifest</p>
</td></tr>
<tr><td><code id="addPkg_+3A_rows">rows</code></td>
<td>
<p>An already-created data.frame to add to the manifest</p>
</td></tr>
<tr><td><code id="addPkg_+3A_versions">versions</code></td>
<td>
<p>A data.frame of package names and versions, if adding to
a SessionManifest, ignored otherwise</p>
</td></tr>
<tr><td><code id="addPkg_+3A_replace">replace</code></td>
<td>
<p>logical. If true, the specified package info will replace
any already in the manifest in the case of duplicates. Otherwise, an error
is thrown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, with the relevant package(s) added to it (in the case
of a manifest) or its associated manifest.
</p>

<hr>
<h2 id='archive_retries'>archive_retries</h2><span id='topic+archive_retries'></span><span id='topic+archive_retries+2CSwitchrParam-method'></span><span id='topic+archive_retries+2CSwitchrParam'></span><span id='topic+archive_retries+3C-'></span><span id='topic+archive_retries+3C-+2CSwitchrParam-method'></span><span id='topic+archive_retries+3C-+2CSwitchrParam'></span>

<h3>Description</h3>

<p>Get or set the number of times to retry downloading a file from
the CRAN archive
</p>
<p>This is intended to stop intermittent install failures
due to failing to retrieve files that *are* in the
archive but are not downloading properly when a larger
number of packages is being retrieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archive_retries(x)

## S4 method for signature 'SwitchrParam'
archive_retries(x)

archive_retries(x) &lt;- value

## S4 replacement method for signature 'SwitchrParam'
archive_retries(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archive_retries_+3A_x">x</code></td>
<td>
<p>A SwitchrParam object</p>
</td></tr>
<tr><td><code id="archive_retries_+3A_value">value</code></td>
<td>
<p>The new number of seconds to wait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When getting, the number of seconds to wait,
when setting, a new, updated SwitchrParam object.
</p>

<hr>
<h2 id='archive_timing'>archive_timing</h2><span id='topic+archive_timing'></span><span id='topic+archive_timing+2CSwitchrParam-method'></span><span id='topic+archive_timing+2CSwitchrParam'></span><span id='topic+archive_timing+3C-'></span><span id='topic+archive_timing+3C-+2CSwitchrParam-method'></span><span id='topic+archive_timing+3C-+2CSwitchrParam'></span>

<h3>Description</h3>

<p>Get or set the number of seconds to wait after trying to
retrieve a file from the CRAN Archive.
</p>
<p>This is intended to stop intermittent install failures
due to failing to retrieve files that *are* in the
archive but are not downloading properly when a larger
number of packages is being retrieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>archive_timing(x)

## S4 method for signature 'SwitchrParam'
archive_timing(x)

archive_timing(x) &lt;- value

## S4 replacement method for signature 'SwitchrParam'
archive_timing(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archive_timing_+3A_x">x</code></td>
<td>
<p>A SwitchrParam object</p>
</td></tr>
<tr><td><code id="archive_timing_+3A_value">value</code></td>
<td>
<p>The new number of seconds to wait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When getting, the number of seconds to wait,
when setting, a new, updated SwitchrParam object.
</p>

<hr>
<h2 id='BiocDevel'>BiocDevel</h2><span id='topic+BiocDevel'></span>

<h3>Description</h3>

<p>An object representing the current Bioc devel version. Can be passed to switchTo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiocDevel
</code></pre>


<h3>Format</h3>

<p>An object of class <code>RepoSubset</code> of length 1.
</p>

<hr>
<h2 id='BiocRelease'>BiocRelease</h2><span id='topic+BiocRelease'></span>

<h3>Description</h3>

<p>An object representing the current Bioc release. Can be passed to switchTo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiocRelease
</code></pre>


<h3>Format</h3>

<p>An object of class <code>RepoSubset</code> of length 1.
</p>

<hr>
<h2 id='biocReposForVers'>biocReposForVers</h2><span id='topic+biocReposForVers'></span>

<h3>Description</h3>

<p>Generate the URLs of the repositories associated with
a specific Bioconductor release
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biocReposForVers(version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biocReposForVers_+3A_version">version</code></td>
<td>
<p>The Bioconductor release to generate URLs for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the repositories associated with the specified Bioconductor version.
</p>


<h3>Note</h3>

<p>This function will only work if some version of Bioconductor (&gt;2.9)
was installed when switchr was installed. It will return NULL otherwise.
</p>

<hr>
<h2 id='BiocSVNManifest'>DEPCRECATED - Create a manifest of Bioc SVN locations</h2><span id='topic+BiocSVNManifest'></span>

<h3>Description</h3>

<p>DEPCRECATED - Create a manifest of Bioc SVN locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiocSVNManifest(bioc_vers = "devel", software_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiocSVNManifest_+3A_bioc_vers">bioc_vers</code></td>
<td>
<p>A version number for a bioc release, or <code>"devel"</code> to
for the current devel trunk</p>
</td></tr>
<tr><td><code id="BiocSVNManifest_+3A_software_only">software_only</code></td>
<td>
<p>logical. Should only software packages be
included in the manifest? Defaults to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In combination with the <code>lazyRepo</code> function, this
manifest can be used to work from a local, working checkout of a
set of inter-dependent Bioconductor packages.
</p>


<h3>Value</h3>

<p>A PkgManifest which contains SVN locations for all
packages found in the specified bioc repositories, as well
as those listed in <code>not_in_repo</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lazyRepo">lazyRepo</a></code>
</p>

<hr>
<h2 id='BiocVers'>BiocVers</h2><span id='topic+BiocVers'></span>

<h3>Description</h3>

<p>A constructor for creating a RepoSubset object for a
specified release of Bioconductor, which includes only the
BiocInstaller package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiocVers(
  version = getBiocReleaseVr(),
  name = paste("BioC", version, sep = "_"),
  repos = biocReposForVers(version)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiocVers_+3A_version">version</code></td>
<td>
<p>The version of Bioconductor</p>
</td></tr>
<tr><td><code id="BiocVers_+3A_name">name</code></td>
<td>
<p>The default name for switchr libraries created with this object</p>
</td></tr>
<tr><td><code id="BiocVers_+3A_repos">repos</code></td>
<td>
<p>The urls of the Bioconductor repositories. these will be
modified automatically to match the specified version</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A RepoSubset object for the specified release of Bioconductor,
which contains only the BiocInstaller or BiocManager package, as
appropriate for that version.
</p>

<hr>
<h2 id='branch'>branch</h2><span id='topic+branch'></span><span id='topic+branch+2CPkgSource-method'></span><span id='topic+branch+2CPkgSource'></span><span id='topic+branch+3C-'></span><span id='topic+branch+3C-+2CPkgSource-method'></span><span id='topic+branch+3C-+2CPkgSource'></span>

<h3>Description</h3>

<p>Get or set the branch associated with a Package Source
</p>


<h3>Usage</h3>

<pre><code class='language-R'>branch(x)

## S4 method for signature 'PkgSource'
branch(x)

branch(x) &lt;- value

## S4 replacement method for signature 'PkgSource'
branch(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branch_+3A_x">x</code></td>
<td>
<p>A source</p>
</td></tr>
<tr><td><code id="branch_+3A_value">value</code></td>
<td>
<p>The new branch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for the getter, the branch associated with the source
object, for the setter, the object updated to use the specified
branch.
</p>

<hr>
<h2 id='c+2CSessionManifest-method'>cmethods</h2><span id='topic+c+2CSessionManifest-method'></span><span id='topic+c+2CPkgManifest-method'></span>

<h3>Description</h3>

<p>Combine 2 or more manifests of the same type (PkgManifest or SessionManifest)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SessionManifest'
c(x, ..., recursive = FALSE)

## S4 method for signature 'PkgManifest'
c(x, ..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c+2B2CSessionManifest-method_+3A_x">x</code></td>
<td>
<p>An object (indicates the type of all objects to be combined)</p>
</td></tr>
<tr><td><code id="c+2B2CSessionManifest-method_+3A_...">...</code></td>
<td>
<p>more objects</p>
</td></tr>
<tr><td><code id="c+2B2CSessionManifest-method_+3A_recursive">recursive</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>
containing the combined contents of <code>x</code> and
all elements of <code>...</code>.
</p>

<hr>
<h2 id='checkIsPkgDir'>Check if a directory contains package sources</h2><span id='topic+checkIsPkgDir'></span>

<h3>Description</h3>

<p>Check if a directory contains package sources
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIsPkgDir(dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIsPkgDir_+3A_dir">dir</code></td>
<td>
<p>The directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any directory containing a <code>DESCRIPTION</code>
file as a direct child is considered a package source
directory, while any that do not are not.
</p>


<h3>Value</h3>

<p>Logical scalar indicating if the directory
contains the source code for a package.
</p>

<hr>
<h2 id='cranPkgVersManifest'>cranPkgVersManifest</h2><span id='topic+cranPkgVersManifest'></span>

<h3>Description</h3>

<p>Create a Pkg manifest which points to tarballs representing a particular
version of a CRAN package and versions of its (recursive) dependencies
that were contemporary on the first or last day the specified package
version resided on CRAN
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cranPkgVersManifest(
  pkg,
  vers,
  earliest = TRUE,
  cur_avail = available.packages(),
  verbose = FALSE,
  suggests = c("direct", "none"),
  delay = 1,
  erronfail = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cranPkgVersManifest_+3A_pkg">pkg</code></td>
<td>
<p>The package on which to base the generated manifest</p>
</td></tr>
<tr><td><code id="cranPkgVersManifest_+3A_vers">vers</code></td>
<td>
<p>The version of <code>pkg</code> to construct the cohort around. Note
this must match the the version string exactly, i.e. 1.3.1 and 1.3-1 are
*not* equivalent.</p>
</td></tr>
<tr><td><code id="cranPkgVersManifest_+3A_earliest">earliest</code></td>
<td>
<p>Should the package dependencies be contemporary with the
first (TRUE) or last (FALSE) day the specified package version was
(the latest version) on CRAN?</p>
</td></tr>
<tr><td><code id="cranPkgVersManifest_+3A_cur_avail">cur_avail</code></td>
<td>
<p>The output from available.packages(). Used to identify
whether the necessary version is in the CRAN archive or normal repository</p>
</td></tr>
<tr><td><code id="cranPkgVersManifest_+3A_verbose">verbose</code></td>
<td>
<p>Should debugging information about the recursive traversal of
package dependencies be printed (defaults to FALSE).</p>
</td></tr>
<tr><td><code id="cranPkgVersManifest_+3A_suggests">suggests</code></td>
<td>
<p>Which Suggests'ed packages should be included. Currently
supported possibilites are direct, indicating Suggestions of <code>pkg</code>
should be included, and none, indicating that no Suggests'ed packages
should be counted.</p>
</td></tr>
<tr><td><code id="cranPkgVersManifest_+3A_delay">delay</code></td>
<td>
<p>Number of seconds to delay between successive REST calls
to the crandb database. Defaults to 1 second</p>
</td></tr>
<tr><td><code id="cranPkgVersManifest_+3A_erronfail">erronfail</code></td>
<td>
<p>how should connection errors be handled. <code>TRUE</code> (the default) throws an error, <code>NA</code> throws a warning, <code>FALSE</code> emits a message.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SessionManifest object
</p>


<h3>Note</h3>

<p>Some packages retain the same version on CRAN for long periods of
time. The cohort in the manifest represents a gross proxy for the cohort
used in conjunction within an analysis which used a the <code>vers</code> version
of the specified package. In general it will *not* perfectly recreate
the set of package versions originally used.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>References</h3>

<p>&quot;Gabor Csardi&quot; (2014). crandb: Query the unofficial CRAN metadata
database. R package version 1.0.0. https://github.com/metacran/crandb
</p>
<p>Becker G, Barr C, Gentleman R, Lawrence M; Enhancing Reproducibility and Collaboration via Management of R Package Cohorts. Journal of Statistical Software, 81(1). 2017. doi: 10.18637/jss.v082.i01
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
man = cranPkgVersManifest("devtools", "1.6")

## End(Not run)
</code></pre>

<hr>
<h2 id='currentCompEnv'>currentCompEnv</h2><span id='topic+currentCompEnv'></span>

<h3>Description</h3>

<p>Display the computing environment currently in use. If switchTo has not been
called, a new SwitchrCtx object describing the current environment is
created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>currentCompEnv()
</code></pre>


<h3>Value</h3>

<p>A <code>SwitchrCtx</code> object representing the current computing
environment.
</p>

<hr>
<h2 id='defaultRepos'>defaultRepos</h2><span id='topic+defaultRepos'></span>

<h3>Description</h3>

<p>Get default repositories for use as dependency repos and within
install_packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultRepos()
</code></pre>


<h3>Value</h3>

<p>A character vector of package repository urls
</p>

<hr>
<h2 id='dep_repos'>dep_repos</h2><span id='topic+dep_repos'></span><span id='topic+dep_repos+2CPkgManifest-method'></span><span id='topic+dep_repos+2CPkgManifest'></span><span id='topic+dep_repos+2CSessionManifest-method'></span><span id='topic+dep_repos+2CSessionManifest'></span><span id='topic+dep_repos+3C-'></span><span id='topic+dep_repos+3C-+2CPkgManifest-method'></span><span id='topic+dep_repos+3C-+2CPkgManifest'></span><span id='topic+dep_repos+3C-+2CSessionManifest-method'></span><span id='topic+dep_repos+3C-+2CSessionManifest'></span>

<h3>Description</h3>

<p>Get or set repositories to be used to fullfill dependencies beyond packages
within the manifest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dep_repos(x)

## S4 method for signature 'PkgManifest'
dep_repos(x)

## S4 method for signature 'SessionManifest'
dep_repos(x)

dep_repos(x) &lt;- value

## S4 replacement method for signature 'PkgManifest'
dep_repos(x) &lt;- value

## S4 replacement method for signature 'SessionManifest'
dep_repos(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dep_repos_+3A_x">x</code></td>
<td>
<p>A package or session manifest</p>
</td></tr>
<tr><td><code id="dep_repos_+3A_value">value</code></td>
<td>
<p>A character vector with the new dependency repos</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with existing repository urls
</p>

<hr>
<h2 id='dl_method'>dl_method</h2><span id='topic+dl_method'></span><span id='topic+dl_method+2CSwitchrParam-method'></span><span id='topic+dl_method+2CSwitchrParam'></span><span id='topic+dl_method+3C-'></span><span id='topic+dl_method+3C-+2CSwitchrParam-method'></span><span id='topic+dl_method+3C-+2CSwitchrParam'></span>

<h3>Description</h3>

<p>Get or set the download method for retreiving files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dl_method(x)

## S4 method for signature 'SwitchrParam'
dl_method(x)

dl_method(x) &lt;- value

## S4 replacement method for signature 'SwitchrParam'
dl_method(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dl_method_+3A_x">x</code></td>
<td>
<p>A SwitchrParam object</p>
</td></tr>
<tr><td><code id="dl_method_+3A_value">value</code></td>
<td>
<p>The new number of seconds to wait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for the getter, the download method specified in the
<code>SwitchrParam</code> object, for the setter, the object
updated with the new download method.
</p>

<hr>
<h2 id='errorOrNonZero'>Identify error states from R or external programs</h2><span id='topic+errorOrNonZero'></span>

<h3>Description</h3>

<p>Identify error states from R or external programs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorOrNonZero(out)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorOrNonZero_+3A_out">out</code></td>
<td>
<p>An R object representing output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if out is an error object, or has an attribute called &quot;status&quot; which is &gt; 0
</p>

<hr>
<h2 id='fileFromFileURL'>Get path from file URL</h2><span id='topic+fileFromFileURL'></span>

<h3>Description</h3>

<p>Get path from file URL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fileFromFileURL(fileurl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fileFromFileURL_+3A_fileurl">fileurl</code></td>
<td>
<p>A file url (beginning in file://)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The system directory path that <code>fileurl</code> points to
</p>

<hr>
<h2 id='findNewestPkgInds'>Find newest packages in a package info data.frame</h2><span id='topic+findNewestPkgInds'></span><span id='topic+findNewestPkgRows'></span>

<h3>Description</h3>

<p>Find newest packages in a package info data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findNewestPkgInds(df, pkgcol = "package", verscol = "version")

findNewestPkgRows(
  df,
  pkgcol = "package",
  verscol = "version",
  newcol = "new",
  verbose = FALSE,
  logfun = message
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNewestPkgInds_+3A_df">df</code></td>
<td>
<p>data.frame. Table of package information</p>
</td></tr>
<tr><td><code id="findNewestPkgInds_+3A_pkgcol">pkgcol</code></td>
<td>
<p>string. Name of column containing package name</p>
</td></tr>
<tr><td><code id="findNewestPkgInds_+3A_verscol">verscol</code></td>
<td>
<p>string. Name of column containing package version in version-string form.</p>
</td></tr>
<tr><td><code id="findNewestPkgInds_+3A_newcol">newcol</code></td>
<td>
<p>character. Experimental. column name for the column indicating that the version is new.</p>
</td></tr>
<tr><td><code id="findNewestPkgInds_+3A_verbose">verbose</code></td>
<td>
<p>logical. Should debugging information be written using <code>logfun</code> during this process.</p>
</td></tr>
<tr><td><code id="findNewestPkgInds_+3A_logfun">logfun</code></td>
<td>
<p>function. Logging function (closure) which should be called to write verbose logging messages during the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the same columns as <code>df</code> which contains
only the most recent row for each unique package name, as determined
by the contents of <code>df[[verscol]]</code>
</p>
<p>for <code>findNewestPkgInds</code>, the indices of the rows representing
the newest version of each package within <code>df</code>. For
<code>findNewestPkgRows</code>, the rows themselves from <code>df</code> representing
the newest version of each package.
</p>

<hr>
<h2 id='findPkgDir'>Find a package directory within an SCM checkout</h2><span id='topic+findPkgDir'></span>

<h3>Description</h3>

<p>Find a package directory within an SCM checkout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPkgDir(rootdir, branch, subdir, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPkgDir_+3A_rootdir">rootdir</code></td>
<td>
<p>The directory of the checkout</p>
</td></tr>
<tr><td><code id="findPkgDir_+3A_branch">branch</code></td>
<td>
<p>The branch to navigate to</p>
</td></tr>
<tr><td><code id="findPkgDir_+3A_subdir">subdir</code></td>
<td>
<p>The subdirectory to navigate to</p>
</td></tr>
<tr><td><code id="findPkgDir_+3A_param">param</code></td>
<td>
<p>a SwitchrParam object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A path to the Package sources
</p>

<hr>
<h2 id='findPkgVersionInRepo'>findPkgVersionInRepo</h2><span id='topic+findPkgVersionInRepo'></span><span id='topic+findPkgVersionInRepo+2Ccharacter-method'></span><span id='topic+findPkgVersionInRepo+2Ccharacter'></span><span id='topic+findPkgVersionInRepo+2CNULL-method'></span><span id='topic+findPkgVersionInRepo+2CNULL'></span>

<h3>Description</h3>

<p>findPkgVersionInRepo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPkgVersionInRepo(repo, name, version, param, dir)

## S4 method for signature 'character'
findPkgVersionInRepo(repo, name, version, param, dir)

## S4 method for signature ''NULL''
findPkgVersionInRepo(repo, name, version, param, dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPkgVersionInRepo_+3A_repo">repo</code></td>
<td>
<p>The repository</p>
</td></tr>
<tr><td><code id="findPkgVersionInRepo_+3A_name">name</code></td>
<td>
<p>The name of the package</p>
</td></tr>
<tr><td><code id="findPkgVersionInRepo_+3A_version">version</code></td>
<td>
<p>The version of the package to find</p>
</td></tr>
<tr><td><code id="findPkgVersionInRepo_+3A_param">param</code></td>
<td>
<p>A SwitchrParam object</p>
</td></tr>
<tr><td><code id="findPkgVersionInRepo_+3A_dir">dir</code></td>
<td>
<p>The directory to download the located package tarball into</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A path to the downloaded tarball, or NULL
</p>

<hr>
<h2 id='flushSession'>flushSession</h2><span id='topic+flushSession'></span>

<h3>Description</h3>

<p>Unload currently loaded packages from the current R session
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flushSession(dontunload = switchrDontUnload())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flushSession_+3A_dontunload">dontunload</code></td>
<td>
<p>Non-base packages to ignore (not detatch/unload)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attached packages are detached (and unloaded) first. After this is
done, loaded packages, such as those imported by (previously) attached
packages, are unloaded.
</p>
<p>Finally, after all packages have been unloaded, native libraries
loaded by those packages are unloaded (on systems where this is supported).
</p>


<h3>Value</h3>

<p>NULL, called for its side-effect of unloading packages
</p>


<h3>Note</h3>

<p>Failing to include switchr, any of its dependencies, or any base
packages (available as a vector in the <code><a href="#topic+switchDeps">switchDeps</a></code> object)
in <code>dontunload</code> will result in undefined, likely erroneous behavior.
</p>

<hr>
<h2 id='full_libpaths'>full_libpaths</h2><span id='topic+full_libpaths'></span><span id='topic+full_libpaths+2CSwitchrCtx-method'></span><span id='topic+full_libpaths+2CSwitchrCtx'></span>

<h3>Description</h3>

<p>Accessor for the full library path associate with a SwitchrCtx, including
the R library and (if not excluded) the site library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_libpaths(seed)

## S4 method for signature 'SwitchrCtx'
full_libpaths(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_libpaths_+3A_seed">seed</code></td>
<td>
<p>a SwitchrCtx</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the getter, the full set of library paths associated with the
<code>SwitchrCtx</code> object, for the setter, the object, updated with the
new set of full lib paths.
</p>

<hr>
<h2 id='getPkgDir'>Construct pockage directory path</h2><span id='topic+getPkgDir'></span>

<h3>Description</h3>

<p>Construct pockage directory path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPkgDir(basepath, name, subdir, scm_type, branch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPkgDir_+3A_basepath">basepath</code></td>
<td>
<p>The parent directory for the package directory</p>
</td></tr>
<tr><td><code id="getPkgDir_+3A_name">name</code></td>
<td>
<p>The name of the package</p>
</td></tr>
<tr><td><code id="getPkgDir_+3A_subdir">subdir</code></td>
<td>
<p>The subdirectory within a package source that
the actual package root directory will reside in.</p>
</td></tr>
<tr><td><code id="getPkgDir_+3A_scm_type">scm_type</code></td>
<td>
<p>Tye type of scm the package sources will be
checked out from</p>
</td></tr>
<tr><td><code id="getPkgDir_+3A_branch">branch</code></td>
<td>
<p>The branch from which the package will be retrieved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A path
</p>


<h3>Note</h3>

<p>Unlike <code><a href="#topic+findPkgDir">findPkgDir</a></code> this does not look for existing
package source directories. It only constructs the path.
</p>

<hr>
<h2 id='GithubManifest'>GithubManifest</h2><span id='topic+GithubManifest'></span>

<h3>Description</h3>

<p>Create a package manifest containing only github packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GithubManifest(..., pkgrepos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GithubManifest_+3A_...">...</code></td>
<td>
<p>Combined to populate <code>pkgrepos</code></p>
</td></tr>
<tr><td><code id="GithubManifest_+3A_pkgrepos">pkgrepos</code></td>
<td>
<p>Github repositories in the form &quot;&lt;user&gt;/&lt;reponame&gt;&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any names of the pkgrepos vector are assumed to be
pkg names for the manifest. For unnamed elements, the pkg
name is assumed to be the repository name.
</p>


<h3>Value</h3>

<p>A GithubManifest object representing the specified github repos.
</p>


<h3>Note</h3>

<p>This is a convenience wrapper for <code><a href="#topic+makeManifest">makeManifest</a></code>.
It uses the <code>username/repo[/subdir][@ref]</code> shorthand for specifying
package locations in github repositories introduced by Wickham's
devtools. Unlike devtools, username is not optional, and  only branch
names are currently supported in the <code>@ref</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ghman = GithubManifest("gmbecker/switchr", "hadley/devtools")
ghman


</code></pre>

<hr>
<h2 id='gotoVersCommit'>gotoVersCommit</h2><span id='topic+gotoVersCommit'></span><span id='topic+gotoVersCommit+2Ccharacter+2CSVNSource-method'></span><span id='topic+gotoVersCommit+2Ccharacter+2CSVNSource'></span><span id='topic+gotoVersCommit+2Ccharacter+2CCRANSource-method'></span><span id='topic+gotoVersCommit+2Ccharacter+2CCRANSource'></span><span id='topic+gotoVersCommit+2Ccharacter+2CBiocSource-method'></span><span id='topic+gotoVersCommit+2Ccharacter+2CBiocSource'></span><span id='topic+gotoVersCommit+2Ccharacter+2CGitSource-method'></span><span id='topic+gotoVersCommit+2Ccharacter+2CGitSource'></span>

<h3>Description</h3>

<p>This is a low-level function not intended for direct use by the end user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gotoVersCommit(dir, src, version, param = SwitchrParam())

## S4 method for signature 'character,SVNSource'
gotoVersCommit(dir, src, version, param = SwitchrParam())

## S4 method for signature 'character,CRANSource'
gotoVersCommit(dir, src, version, param = SwitchrParam())

## S4 method for signature 'character,BiocSource'
gotoVersCommit(dir, src, version, param = SwitchrParam())

## S4 method for signature 'character,GitSource'
gotoVersCommit(dir, src, version, param = SwitchrParam())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gotoVersCommit_+3A_dir">dir</code></td>
<td>
<p>Directory</p>
</td></tr>
<tr><td><code id="gotoVersCommit_+3A_src">src</code></td>
<td>
<p>A PkgSource (or subclass) object</p>
</td></tr>
<tr><td><code id="gotoVersCommit_+3A_version">version</code></td>
<td>
<p>The exact version to locate</p>
</td></tr>
<tr><td><code id="gotoVersCommit_+3A_param">param</code></td>
<td>
<p>A SwitchrParam</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dir</code>, after the side-effect of checking out the commit
associated with the specified version is complete.
</p>

<hr>
<h2 id='graceful_inet'>Internal internet harness</h2><span id='topic+graceful_inet'></span><span id='topic+warning2'></span>

<h3>Description</h3>

<p>This function should never be called by code outside of tests/vignettes
in this package or packages that depend on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graceful_inet(val, silent)

warning2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graceful_inet_+3A_val">val</code></td>
<td>
<p>logical. NA means no additional handling, TRUE, means careful handling
but actually attempt the call, FALSE means force immedate failure without evaling
expressions wrapped in inet_handlers() calls</p>
</td></tr>
<tr><td><code id="graceful_inet_+3A_silent">silent</code></td>
<td>
<p>logical(1). Should errors and warnings be emitted as messages (FALSE)
or be fully suppressed (TRUE).</p>
</td></tr>
<tr><td><code id="graceful_inet_+3A_...">...</code></td>
<td>
<p>passed to message or base::warning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>varies, these are internal functions not intended for end users.
</p>

<hr>
<h2 id='head'>Head and tail operations on manifests</h2><span id='topic+head'></span><span id='topic+head+2CSessionManifest-method'></span><span id='topic+head+2CSessionManifest'></span><span id='topic+head+2CPkgManifest-method'></span><span id='topic+head+2CPkgManifest'></span><span id='topic+tail'></span><span id='topic+tail+2CSessionManifest-method'></span><span id='topic+tail+2CSessionManifest'></span><span id='topic+tail+2CPkgManifest-method'></span><span id='topic+tail+2CPkgManifest'></span>

<h3>Description</h3>

<p>Head and tail operations on manifests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head(x, ...)

## S4 method for signature 'SessionManifest'
head(x, n = 5, ...)

## S4 method for signature 'PkgManifest'
head(x, n = 5, ...)

tail(x, ...)

## S4 method for signature 'SessionManifest'
tail(x, n = 5, ...)

## S4 method for signature 'PkgManifest'
tail(x, n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_+3A_x">x</code></td>
<td>
<p>A manifest object</p>
</td></tr>
<tr><td><code id="head_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="head_+3A_n">n</code></td>
<td>
<p>The number of packages to keep</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of a <code>PkgManifest</code>, the first or last <code>n</code>
packages are retained in the manifest, while all others are removed.
</p>
<p>In the case of a <code>SessionManifest</code>, <code>n</code> specified versions
are retained, while the underlying <code>PkgManifest</code> is unchanged.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>x</code> containing <code>n</code> packages
</p>

<hr>
<h2 id='install_packages'>install_packages</h2><span id='topic+install_packages'></span><span id='topic+install_packages+2Ccharacter+2Ccharacter-method'></span><span id='topic+install_packages+2Ccharacter+2Ccharacter'></span><span id='topic+install_packages+2Ccharacter+2Cmissing-method'></span><span id='topic+install_packages+2Ccharacter+2Cmissing'></span><span id='topic+install_packages+2CSessionManifest+2CANY-method'></span><span id='topic+install_packages+2CSessionManifest+2CANY'></span><span id='topic+install_packages+2Ccharacter+2CSessionManifest-method'></span><span id='topic+install_packages+2Ccharacter+2CSessionManifest'></span><span id='topic+install_packages+2Ccharacter+2CPkgManifest-method'></span><span id='topic+install_packages+2Ccharacter+2CPkgManifest'></span>

<h3>Description</h3>

<p>Install packages from a set of traditional repositories, or a Just-in-time
repository constructed using a PkgManifest or SessionManifest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_packages(pkgs, repos, versions = NULL, verbose = FALSE, ...)

## S4 method for signature 'character,character'
install_packages(pkgs, repos, versions = NULL, verbose = FALSE, ...)

## S4 method for signature 'character,missing'
install_packages(pkgs, repos, versions = NULL, verbose = FALSE, ...)

## S4 method for signature 'SessionManifest,ANY'
install_packages(pkgs, repos, versions = NULL, verbose = FALSE, ...)

## S4 method for signature 'character,SessionManifest'
install_packages(pkgs, repos, versions = NULL, verbose = FALSE, ...)

## S4 method for signature 'character,PkgManifest'
install_packages(pkgs, repos, versions = NULL, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_packages_+3A_pkgs">pkgs</code></td>
<td>
<p>The names of the packages to install</p>
</td></tr>
<tr><td><code id="install_packages_+3A_repos">repos</code></td>
<td>
<p>The (generalized) repositor(ies) to install the packages from.
Can be a character vector of traditional package repositories (as with install.packages)
or a PkgManifest or SessionManifest (or a url thereof)</p>
</td></tr>
<tr><td><code id="install_packages_+3A_versions">versions</code></td>
<td>
<p>An optional named character vector or data.frame specifying exact versions of the packages to install</p>
</td></tr>
<tr><td><code id="install_packages_+3A_verbose">verbose</code></td>
<td>
<p>Should extra information be printed during the console during installation</p>
</td></tr>
<tr><td><code id="install_packages_+3A_...">...</code></td>
<td>
<p>extra parameters passed directly to install.packages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to installing the specified packages, this function
annotates the installed DESCRIPTION files with provenance information
about where the packages were installed from. This retains the information
necessary to generate a manifest of installed packages for publication or
reinstallation.
</p>
<p>When <code>repos</code> is a vector of traditional repositories, this function -
with the exception of the provenance mentioned above - behaves identically
to <code><a href="utils.html#topic+install.packages">install.packages</a></code>. Otherwise, a Just-in-Time package
repository is constructed using the information in the manifest(s) passed
to <code>repos</code>, which is then used in conjuction with
<code>link{install.packages}</code> to do the actual installation.
</p>


<h3>Value</h3>

<p>a vector of names of the packages installed.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>References</h3>

<p>Becker G, Barr C, Gentleman R, Lawrence M; Enhancing Reproducibility and Collaboration via Management of R Package Cohorts. Journal of Statistical Software, 81(1). 2017. doi: 10.18637/jss.v082.i01
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## equivalent to install.packages, except it stores
## package provenance and knows about bioconductor repos
install_packages("nlme")

## install from a manifest
man = GithubManifest("gmbecker/fastdigest")
install_packages("fastdigest", man)

## install a full seeding manifest
man2 = makeSeedMan("myotherlib")
install_packages(man2)

## End(Not run)
</code></pre>

<hr>
<h2 id='lazyRepo'>lazyRepo</h2><span id='topic+lazyRepo'></span><span id='topic+lazyRepo+2CSessionManifest+2CANY-method'></span><span id='topic+lazyRepo+2CSessionManifest+2CANY'></span><span id='topic+lazyRepo+2CPkgManifest+2CANY-method'></span><span id='topic+lazyRepo+2CPkgManifest+2CANY'></span><span id='topic+lazyRepo+2Ccharacter+2CSessionManifest-method'></span><span id='topic+lazyRepo+2Ccharacter+2CSessionManifest'></span><span id='topic+lazyRepo+2Ccharacter+2CPkgManifest-method'></span><span id='topic+lazyRepo+2Ccharacter+2CPkgManifest'></span>

<h3>Description</h3>

<p>Create a lazy repository for installing directly from a package
manifest. Most users will want to call <code>Install</code> directly,
which will call this as needed behind the scenes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lazyRepo(
  pkgs,
  pkg_manifest,
  versions = rep(NA, times = length(pkgs)),
  dir = tempdir(),
  rep_path = file.path(dir, "repo"),
  get_suggests = FALSE,
  verbose = FALSE,
  scm_auths = list(bioconductor = c("readonly", "readonly")),
  param = SwitchrParam(),
  force_refresh = FALSE
)

## S4 method for signature 'SessionManifest,ANY'
lazyRepo(
  pkgs,
  pkg_manifest,
  versions = rep(NA, times = length(pkgs)),
  dir = tempdir(),
  rep_path = file.path(dir, "repo"),
  get_suggests = FALSE,
  verbose = FALSE,
  scm_auths = list(bioconductor = c("readonly", "readonly")),
  param = SwitchrParam(),
  force_refresh = FALSE
)

## S4 method for signature 'PkgManifest,ANY'
lazyRepo(
  pkgs,
  pkg_manifest,
  versions = rep(NA, times = length(pkgs)),
  dir = tempdir(),
  rep_path = file.path(dir, "repo"),
  get_suggests = FALSE,
  verbose = FALSE,
  scm_auths = list(bioconductor = c("readonly", "readonly")),
  param = SwitchrParam(),
  force_refresh = FALSE
)

## S4 method for signature 'character,SessionManifest'
lazyRepo(
  pkgs,
  pkg_manifest,
  versions = rep(NA, times = length(pkgs)),
  dir = tempdir(),
  rep_path = file.path(dir, "repo"),
  get_suggests = FALSE,
  verbose = FALSE,
  scm_auths = list(bioconductor = c("readonly", "readonly")),
  param = SwitchrParam(),
  force_refresh = FALSE
)

## S4 method for signature 'character,PkgManifest'
lazyRepo(
  pkgs,
  pkg_manifest,
  versions = rep(NA, times = length(pkgs)),
  dir = tempdir(),
  rep_path = file.path(dir, "repo"),
  get_suggests = FALSE,
  verbose = FALSE,
  scm_auths = list(bioconductor = c("readonly", "readonly")),
  param = SwitchrParam(),
  force_refresh = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lazyRepo_+3A_pkgs">pkgs</code></td>
<td>
<p>The packages to install</p>
</td></tr>
<tr><td><code id="lazyRepo_+3A_pkg_manifest">pkg_manifest</code></td>
<td>
<p>The manifest to use</p>
</td></tr>
<tr><td><code id="lazyRepo_+3A_versions">versions</code></td>
<td>
<p>Specific versions of the packages to install. Should be a
vector of the same length as <code>pkgs</code> (and in the same order). Defaults
to NA (any version) for all packages.</p>
</td></tr>
<tr><td><code id="lazyRepo_+3A_dir">dir</code></td>
<td>
<p>The directory packages should be downloaded/checkedout/built into</p>
</td></tr>
<tr><td><code id="lazyRepo_+3A_rep_path">rep_path</code></td>
<td>
<p>The path of the final repository</p>
</td></tr>
<tr><td><code id="lazyRepo_+3A_get_suggests">get_suggests</code></td>
<td>
<p>Whether suggested packages should be included
in the lazy repository. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="lazyRepo_+3A_verbose">verbose</code></td>
<td>
<p>Should extra information be printed to the user during
the construction process</p>
</td></tr>
<tr><td><code id="lazyRepo_+3A_scm_auths">scm_auths</code></td>
<td>
<p>Named list of username/password credentials for checking
out package sources from one or more sources listed in <code>manifest</code>
Defaults to readonly access to Bioconductor SVN</p>
</td></tr>
<tr><td><code id="lazyRepo_+3A_param">param</code></td>
<td>
<p>A SwitchrParam object</p>
</td></tr>
<tr><td><code id="lazyRepo_+3A_force_refresh">force_refresh</code></td>
<td>
<p>If a package already appears in the lazy repo area,
it be updated (e.g. from SCM) and built again? Defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When checking building from SVN or git checkouts, this function
will first look for existing checkouts for the relevant packages in
<code>dir</code>. If found, these will be updated (in the case of conflicts, the
behavior is undefined and will likely fail if they are not resolvable). This
allows the user to have an existing, checkout directory where he or she
works on development versions of multiple, interrelated packages, as local
changes WILL be reflected in the packages built into the lazy repository.
</p>


<h3>Value</h3>

<p>A path to the populated lazy repository, suitable for 'coercing' to
a url and installing from.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>References</h3>

<p>Becker G, Barr C, Gentleman R, Lawrence M; Enhancing Reproducibility and Collaboration via Management of R Package Cohorts. Journal of Statistical Software, 81(1). 2017. doi: 10.18637/jss.v082.i01
</p>

<hr>
<h2 id='libManifest'>libManifest</h2><span id='topic+libManifest'></span><span id='topic+libManifest+2Cmissing-method'></span><span id='topic+libManifest+2Cmissing'></span><span id='topic+libManifest+2Ccharacter-method'></span><span id='topic+libManifest+2Ccharacter'></span><span id='topic+libManifest+2CSwitchrCtx-method'></span><span id='topic+libManifest+2CSwitchrCtx'></span>

<h3>Description</h3>

<p>Create a Session- or PkgManifest for the contents of a switchr
library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>libManifest(
  lib = currentCompEnv(),
  record_versions = TRUE,
  known_manifest = makeManifest(dep_repos = repos),
  repos = defaultRepos(),
  ...
)

## S4 method for signature 'missing'
libManifest(
  lib = currentCompEnv(),
  record_versions = TRUE,
  known_manifest = makeManifest(dep_repos = repos),
  repos = defaultRepos(),
  ...
)

## S4 method for signature 'character'
libManifest(
  lib = currentCompEnv(),
  record_versions = TRUE,
  known_manifest = makeManifest(dep_repos = repos),
  repos = defaultRepos(),
  ...
)

## S4 method for signature 'SwitchrCtx'
libManifest(
  lib = currentCompEnv(),
  record_versions = TRUE,
  known_manifest = makeManifest(dep_repos = repos),
  repos = defaultRepos(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="libManifest_+3A_lib">lib</code></td>
<td>
<p>A SwitchrCtx object, or the name of a switchr library. Defaults
to the currently active switchr library.</p>
</td></tr>
<tr><td><code id="libManifest_+3A_record_versions">record_versions</code></td>
<td>
<p>Should the exact versions of installed packages be
recorded in the manifest (TRUE)</p>
</td></tr>
<tr><td><code id="libManifest_+3A_known_manifest">known_manifest</code></td>
<td>
<p>An existing manifest, used when imputing
location information for packages not
installed via <code><a href="#topic+install_packages">install_packages</a></code></p>
</td></tr>
<tr><td><code id="libManifest_+3A_repos">repos</code></td>
<td>
<p>A vector of traditional package repositories. Used when imputing
location information for packages not installed via
<code><a href="#topic+install_packages">install_packages</a></code></p>
</td></tr>
<tr><td><code id="libManifest_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>SessionManifest</code> object containing version-specified
entries for all packages installed in the specified library path(s).
</p>


<h3>Note</h3>

<p>The manifest generated by this function will not include
base packages, as they are part of R and not installable in the
traditional sense.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive()) {
  man = libManifest()
  man
}

## Not run: 
man2 = libManifest("myotherlib")
man2

## End(Not run)
</code></pre>

<hr>
<h2 id='library_paths'>library_paths</h2><span id='topic+library_paths'></span><span id='topic+library_paths+2CSwitchrCtx-method'></span><span id='topic+library_paths+2CSwitchrCtx'></span>

<h3>Description</h3>

<p>Accessor for which directories an SwitchrCtx is associated with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>library_paths(seed)

## S4 method for signature 'SwitchrCtx'
library_paths(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="library_paths_+3A_seed">seed</code></td>
<td>
<p>An SwitchrCtx</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for the getter, the set of library paths associated with
the <code>SwitchrCtx</code> object, for the setter, said context udpated
with the new full set of library paths.
</p>

<hr>
<h2 id='loadGRAN'>Load a GRAN repo package</h2><span id='topic+loadGRAN'></span>

<h3>Description</h3>

<p>Load a GRAN repo package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadGRAN(nm = "current")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadGRAN_+3A_nm">nm</code></td>
<td>
<p>The name of the repository for which to load the package. Defaults
<code>"current"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience to load the package GRAN&lt;nm&gt;, which
will provide the contained GRAN repository as default repository within
the switchr framework.
</p>


<h3>Value</h3>

<p>NULL. Called for the side-effect of loading the specified package
</p>

<hr>
<h2 id='loadManifest'>loadManifest</h2><span id='topic+loadManifest'></span>

<h3>Description</h3>

<p>Load a package or session manifest from a file (local or URL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadManifest(fil)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadManifest_+3A_fil">fil</code></td>
<td>
<p>The path or URL to the file or a gist containing it</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PkgManifest or SessionManifest object
</p>

<hr>
<h2 id='locatePkgVersion'>locatePkgVersion</h2><span id='topic+locatePkgVersion'></span>

<h3>Description</h3>

<p>Locate and download/build the exact version of a single package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locatePkgVersion(
  name,
  version,
  pkg_manifest,
  param = SwitchrParam(),
  dir = notrack(repo),
  repo = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locatePkgVersion_+3A_name">name</code></td>
<td>
<p>package name</p>
</td></tr>
<tr><td><code id="locatePkgVersion_+3A_version">version</code></td>
<td>
<p>package version string</p>
</td></tr>
<tr><td><code id="locatePkgVersion_+3A_pkg_manifest">pkg_manifest</code></td>
<td>
<p>A manifest containing locations to search for the
package</p>
</td></tr>
<tr><td><code id="locatePkgVersion_+3A_param">param</code></td>
<td>
<p>A SwitchrParam object</p>
</td></tr>
<tr><td><code id="locatePkgVersion_+3A_dir">dir</code></td>
<td>
<p>directory to download package into</p>
</td></tr>
<tr><td><code id="locatePkgVersion_+3A_repo">repo</code></td>
<td>
<p>(optional) GRANRepository object to search</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full path to the downloaded file , or NULL if unable to
locate the package
</p>


<h3>Note</h3>

<p>Locating and attempting to install a non-current version of a single
will not work in general, due to dependency issues. In most cases a
Just-in-Time repository should be created and used instead, e.g. via
<code><a href="#topic+install_packages">install_packages</a></code>
</p>
<p>This function is called internally during the construction of Just-in-Time
repositories and during the installation of specific package versions.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>

<hr>
<h2 id='location'>location</h2><span id='topic+location'></span><span id='topic+location+2CPkgSource-method'></span>

<h3>Description</h3>

<p>Retreive the directory associated with an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location(repo)

## S4 method for signature 'PkgSource'
location(repo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_+3A_repo">repo</code></td>
<td>
<p>An object associated with a path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character containing the associated path
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>

<hr>
<h2 id='logfun'>logfun</h2><span id='topic+logfun'></span><span id='topic+logfun+2CSwitchrParam-method'></span><span id='topic+logfun+2CSwitchrParam'></span><span id='topic+logfun+3C-'></span><span id='topic+logfun+3C-+2CSwitchrParam-method'></span><span id='topic+logfun+3C-+2CSwitchrParam'></span>

<h3>Description</h3>

<p>Get or set the logging function in an object associated with a SwitchrParam
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logfun(x)

## S4 method for signature 'SwitchrParam'
logfun(x)

logfun(x) &lt;- value

## S4 replacement method for signature 'SwitchrParam'
logfun(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logfun_+3A_x">x</code></td>
<td>
<p>An object with a SwitchrParam</p>
</td></tr>
<tr><td><code id="logfun_+3A_value">value</code></td>
<td>
<p>The new logging function</p>
</td></tr>
</table>

<hr>
<h2 id='makeBiocSVNURL'>Make a Bioconductor SVN url for a package</h2><span id='topic+makeBiocSVNURL'></span>

<h3>Description</h3>

<p>Make SVN url for a Bioconductor package given the name, bioc version, and
type of package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBiocSVNURL(name, biocVers = getBiocvrFromRvr(), pkgtype = "software")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBiocSVNURL_+3A_name">name</code></td>
<td>
<p>A vector of bioconductor package names The name of the package</p>
</td></tr>
<tr><td><code id="makeBiocSVNURL_+3A_biocvers">biocVers</code></td>
<td>
<p>The version (release) of bioconductor, or <code>'trunk'</code> (the default) for
Bioc devel.</p>
</td></tr>
<tr><td><code id="makeBiocSVNURL_+3A_pkgtype">pkgtype</code></td>
<td>
<p>character. Which type of packages to retrieve the SVN root url for. Should be
<code>"software"</code> or <code>"data"</code> for software and experimental data packages,
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of urls for the specified packages within the Bioconductor SVN repository
</p>

<hr>
<h2 id='makeFileURL'>make file url</h2><span id='topic+makeFileURL'></span>

<h3>Description</h3>

<p>make file url
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFileURL(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFileURL_+3A_path">path</code></td>
<td>
<p>The path to wrap in a file:// URL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A valid file URL
</p>

<hr>
<h2 id='makeLibraryCtx'>makeLibraryCtx</h2><span id='topic+makeLibraryCtx'></span>

<h3>Description</h3>

<p>Locate or create a specified switchr library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLibraryCtx(
  name,
  seed = NULL,
  pkgs = NULL,
  exclude.site = TRUE,
  contains,
  rvers = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeLibraryCtx_+3A_name">name</code></td>
<td>
<p>The name for the library</p>
</td></tr>
<tr><td><code id="makeLibraryCtx_+3A_seed">seed</code></td>
<td>
<p>The object to seed the library from</p>
</td></tr>
<tr><td><code id="makeLibraryCtx_+3A_pkgs">pkgs</code></td>
<td>
<p>Pkgs to install upon creation. Deprecated, use a seeding object
instead.</p>
</td></tr>
<tr><td><code id="makeLibraryCtx_+3A_exclude.site">exclude.site</code></td>
<td>
<p>Whether the site library should be excluded when
switching to this library</p>
</td></tr>
<tr><td><code id="makeLibraryCtx_+3A_contains">contains</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="makeLibraryCtx_+3A_rvers">rvers</code></td>
<td>
<p>Optional R version. If specified, existing libraries much be
associated with the same R version to be considered a match.</p>
</td></tr>
<tr><td><code id="makeLibraryCtx_+3A_verbose">verbose</code></td>
<td>
<p>Should informative messages be emitted to the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not intended to be called directly in most cases; switchTo
calls it automatically.
</p>

<hr>
<h2 id='makeManifest'>Manifest constructor</h2><span id='topic+makeManifest'></span>

<h3>Description</h3>

<p>Create a package manifest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeManifest(..., dep_repos = defaultRepos())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeManifest_+3A_...">...</code></td>
<td>
<p>Vectors containing package information. Passed to <code><a href="#topic+ManifestRow">ManifestRow</a></code></p>
</td></tr>
<tr><td><code id="makeManifest_+3A_dep_repos">dep_repos</code></td>
<td>
<p>The dependency repos for the package.</p>
</td></tr>
</table>

<hr>
<h2 id='makePkgCheckout'>Create a checkout of a package and all it's dependencies from a manifest</h2><span id='topic+makePkgCheckout'></span>

<h3>Description</h3>

<p>Create a checkout of a package and all it's dependencies from a manifest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePkgCheckout(
  pkgs,
  pkg_manifest,
  dir,
  get_suggests = c("none", "first", "all"),
  param = SwitchrParam(),
  scm_auths = list(bioconductor = c("readonly", "readonly")),
  repos = defaultRepos()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePkgCheckout_+3A_pkgs">pkgs</code></td>
<td>
<p>character - The packages you will be working on</p>
</td></tr>
<tr><td><code id="makePkgCheckout_+3A_pkg_manifest">pkg_manifest</code></td>
<td>
<p>Pkgmanifest|SessionManifest - The manifest containing the pkgs and dependencies to checkout</p>
</td></tr>
<tr><td><code id="makePkgCheckout_+3A_dir">dir</code></td>
<td>
<p>character - The directory in which to place the checkouts of packages</p>
</td></tr>
<tr><td><code id="makePkgCheckout_+3A_get_suggests">get_suggests</code></td>
<td>
<p>character - Should 'Suggests' dependencies be retrieved? Options are &quot;none&quot; (never), &quot;first&quot; (for packages in <code>pkgs</code> but not for dependencies, or &quot;all&quot; (always).</p>
</td></tr>
<tr><td><code id="makePkgCheckout_+3A_param">param</code></td>
<td>
<p>SwitchrParam - The SwitchrParam to use during the checkout process,</p>
</td></tr>
<tr><td><code id="makePkgCheckout_+3A_scm_auths">scm_auths</code></td>
<td>
<p>list -  A named list of user-password pairs to use during the checkout process</p>
</td></tr>
<tr><td><code id="makePkgCheckout_+3A_repos">repos</code></td>
<td>
<p>character - The package repositories to retrieve dependnecy information from for pkgs/dependnecies which do not appear in <code>pkg_manifest</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of all packages (incl. recursive dependnecies) checked out into <code>dir</code>
</p>

<hr>
<h2 id='makePkgDir'>makePkgDir</h2><span id='topic+makePkgDir'></span><span id='topic+makePkgDir+2CANY+2CSVNSource-method'></span><span id='topic+makePkgDir+2CANY+2CSVNSource'></span><span id='topic+makePkgDir+2CANY+2CGithubSource-method'></span><span id='topic+makePkgDir+2CANY+2CGithubSource'></span><span id='topic+makePkgDir+2CANY+2CGitSource-method'></span><span id='topic+makePkgDir+2CANY+2CGitSource'></span><span id='topic+makePkgDir+2CANY+2CANY-method'></span><span id='topic+makePkgDir+2CANY+2CANY'></span><span id='topic+makePkgDir+2CANY+2CCRANSource-method'></span><span id='topic+makePkgDir+2CANY+2CCRANSource'></span><span id='topic+makePkgDir+2CANY+2CBiocSource-method'></span><span id='topic+makePkgDir+2CANY+2CBiocSource'></span><span id='topic+makePkgDir+2CANY+2CTarballSource-method'></span><span id='topic+makePkgDir+2CANY+2CTarballSource'></span><span id='topic+makePkgDir+2CANY+2CLocalSource-method'></span><span id='topic+makePkgDir+2CANY+2CLocalSource'></span>

<h3>Description</h3>

<p>This is an internal function not intended to be called directly by end users
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePkgDir(
  name,
  source,
  path,
  latest_only,
  param = SwitchrParam(),
  forceRefresh = FALSE
)

## S4 method for signature 'ANY,SVNSource'
makePkgDir(
  name,
  source,
  path,
  latest_only = FALSE,
  param = SwitchrParam(),
  forceRefresh = FALSE
)

## S4 method for signature 'ANY,GithubSource'
makePkgDir(
  name,
  source,
  path,
  latest_only = FALSE,
  param = SwitchrParam(),
  forceRefresh = FALSE
)

## S4 method for signature 'ANY,GitSource'
makePkgDir(
  name,
  source,
  path,
  latest_only = FALSE,
  param = SwitchrParam(),
  forceRefresh = FALSE
)

## S4 method for signature 'ANY,ANY'
makePkgDir(
  name,
  source,
  path,
  latest_only,
  param = SwitchrParam(),
  forceRefresh = FALSE
)

## S4 method for signature 'ANY,CRANSource'
makePkgDir(
  name,
  source,
  path,
  latest_only,
  param = SwitchrParam(),
  forceRefresh = FALSE
)

## S4 method for signature 'ANY,BiocSource'
makePkgDir(
  name,
  source,
  path,
  latest_only,
  param = SwitchrParam(),
  forceRefresh = FALSE
)

## S4 method for signature 'ANY,TarballSource'
makePkgDir(
  name,
  source,
  path,
  latest_only,
  param = SwitchrParam(),
  forceRefresh = FALSE
)

## S4 method for signature 'ANY,LocalSource'
makePkgDir(
  name,
  source,
  path,
  latest_only,
  param = SwitchrParam(),
  forceRefresh = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePkgDir_+3A_name">name</code></td>
<td>
<p>The package</p>
</td></tr>
<tr><td><code id="makePkgDir_+3A_source">source</code></td>
<td>
<p>A PkgSource</p>
</td></tr>
<tr><td><code id="makePkgDir_+3A_path">path</code></td>
<td>
<p>The path to place the directory</p>
</td></tr>
<tr><td><code id="makePkgDir_+3A_latest_only">latest_only</code></td>
<td>
<p>Should a fastpath for downloading the latest commit
in a SCM package without a formal checkout be used?</p>
</td></tr>
<tr><td><code id="makePkgDir_+3A_param">param</code></td>
<td>
<p>A SwitchrParam</p>
</td></tr>
<tr><td><code id="makePkgDir_+3A_forcerefresh">forceRefresh</code></td>
<td>
<p>Should an existing instance of the package source be
deleted/refreshed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a directory and populate it with package source code from the
specified source
</p>


<h3>Value</h3>

<p>logical scalar indicating success (<code>TRUE</code>) or failure of
the operation.
</p>

<hr>
<h2 id='makeSeedMan'>makeSeedMan</h2><span id='topic+makeSeedMan'></span><span id='topic+makeSeedMan+2Cmissing-method'></span><span id='topic+makeSeedMan+2Cmissing'></span><span id='topic+makeSeedMan+2CsessionInfo-method'></span><span id='topic+makeSeedMan+2CsessionInfo'></span><span id='topic+makeSeedMan+2CparsedSessionInfo-method'></span><span id='topic+makeSeedMan+2CparsedSessionInfo'></span><span id='topic+makeSeedMan+2Cdata.frame-method'></span><span id='topic+makeSeedMan+2Cdata.frame'></span>

<h3>Description</h3>

<p>makeSeedMan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSeedMan(x, known_manifest = PkgManifest(), ...)

## S4 method for signature 'missing'
makeSeedMan(x, known_manifest = PkgManifest(), ...)

## S4 method for signature 'sessionInfo'
makeSeedMan(x, known_manifest = PkgManifest(), ...)

## S4 method for signature 'parsedSessionInfo'
makeSeedMan(x, known_manifest = PkgManifest(), ...)

## S4 method for signature 'data.frame'
makeSeedMan(x, known_manifest = PkgManifest(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSeedMan_+3A_x">x</code></td>
<td>
<p>The object to generate a seeding manifest from, if missing, the
output from sessionInfo() is used.</p>
</td></tr>
<tr><td><code id="makeSeedMan_+3A_known_manifest">known_manifest</code></td>
<td>
<p>A manifest containing known locations of package sources.
makeSeedMan will attempt to determine locations of packages listed in x using both
known_manifest and official repositories.</p>
</td></tr>
<tr><td><code id="makeSeedMan_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>SessionManifest</code> specifying a set of packages and their
specific versions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>man = makeSeedMan()
</code></pre>

<hr>
<h2 id='makeSource'>Create a PkgSource object for a package</h2><span id='topic+makeSource'></span>

<h3>Description</h3>

<p>Create a PkgSource object for a package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSource(
  url,
  type,
  user,
  password,
  scm_auth = list(),
  prefer_svn = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSource_+3A_url">url</code></td>
<td>
<p>The url of the package sources</p>
</td></tr>
<tr><td><code id="makeSource_+3A_type">type</code></td>
<td>
<p>The source type.</p>
</td></tr>
<tr><td><code id="makeSource_+3A_user">user</code></td>
<td>
<p>A function which, when called, returns the username to use when
when checking the soources out</p>
</td></tr>
<tr><td><code id="makeSource_+3A_password">password</code></td>
<td>
<p>A function which returns the password to use when checking
out the sources</p>
</td></tr>
<tr><td><code id="makeSource_+3A_scm_auth">scm_auth</code></td>
<td>
<p>A list of username-password pairs, named with regular
expressions to match against url when constructing the
defaults for <code>user</code> and <code>password</code></p>
</td></tr>
<tr><td><code id="makeSource_+3A_prefer_svn">prefer_svn</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="makeSource_+3A_...">...</code></td>
<td>
<p>Passed directly to constructors for PkgSource superclasses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object inheriting from <code>PkgSource</code> for the specified
location of a package's source code.
</p>

<hr>
<h2 id='manifest'>Get or set the manifest associated with an object</h2><span id='topic+manifest'></span><span id='topic+manifest+3C-'></span><span id='topic+manifest+2CSessionManifest-method'></span><span id='topic+manifest+2CSessionManifest'></span><span id='topic+manifest+3C-+2CSessionManifest-method'></span><span id='topic+manifest+3C-+2CSessionManifest'></span>

<h3>Description</h3>

<p>Get or set manifest associated with an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manifest(x)

manifest(x) &lt;- value

## S4 method for signature 'SessionManifest'
manifest(x)

## S4 replacement method for signature 'SessionManifest'
manifest(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manifest_+3A_x">x</code></td>
<td>
<p>An object which contains a manifest</p>
</td></tr>
<tr><td><code id="manifest_+3A_value">value</code></td>
<td>
<p>A PkgManifest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A PkgManifest or SessionManifest object
</p>

<hr>
<h2 id='manifest_df'>manifest_df</h2><span id='topic+manifest_df'></span><span id='topic+manifest_df+2CSessionManifest-method'></span><span id='topic+manifest_df+2CSessionManifest'></span><span id='topic+manifest_df+2CPkgManifest-method'></span><span id='topic+manifest_df+2CPkgManifest'></span><span id='topic+manifest_df+3C-'></span><span id='topic+manifest_df+3C-+2CSessionManifest-method'></span><span id='topic+manifest_df+3C-+2CSessionManifest'></span><span id='topic+manifest_df+3C-+2CPkgManifest-method'></span><span id='topic+manifest_df+3C-+2CPkgManifest'></span>

<h3>Description</h3>

<p>Get or set the package location manifest (data.frame) associated with an
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manifest_df(x, ...)

## S4 method for signature 'SessionManifest'
manifest_df(x, session_only = TRUE, ...)

## S4 method for signature 'PkgManifest'
manifest_df(x)

manifest_df(x) &lt;- value

## S4 replacement method for signature 'SessionManifest'
manifest_df(x) &lt;- value

## S4 replacement method for signature 'PkgManifest'
manifest_df(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manifest_df_+3A_x">x</code></td>
<td>
<p>The object</p>
</td></tr>
<tr><td><code id="manifest_df_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="manifest_df_+3A_session_only">session_only</code></td>
<td>
<p>Only return manifest rows associated with the
versioned cohort defined in <code>x</code> (<code>SessionManifest</code>s only).</p>
</td></tr>
<tr><td><code id="manifest_df_+3A_value">value</code></td>
<td>
<p>A data.frame of package manifest information.
See <code><a href="#topic+ManifestRow">ManifestRow</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>for the getter, the manifest data.frame corresponding to the manifest,
for the setter, a manifest updated with the new manifest data.frame.
</p>

<hr>
<h2 id='manifestFromCheckoutDir'>Create Manifest from 'checkedout' directory containing many pkg dirs</h2><span id='topic+manifestFromCheckoutDir'></span>

<h3>Description</h3>

<p>This function is useful when a developer has a 'checkout' directory
where the sources for multiple packages live. Particularly, it
allows one to work on multiple interlocking packages at the same
time and have a manifest which will install them all together
automatically when time for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manifestFromCheckoutDir(pdir, recursive = FALSE, excl_pat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manifestFromCheckoutDir_+3A_pdir">pdir</code></td>
<td>
<p>character(1). Parent directory which contains package source directories.</p>
</td></tr>
<tr><td><code id="manifestFromCheckoutDir_+3A_recursive">recursive</code></td>
<td>
<p>logical(1). Should directories within <code>pdir</code> be searched recursively
to find package source directories. Defaults to <code>FALSE</code> for efficiency reasons.</p>
</td></tr>
<tr><td><code id="manifestFromCheckoutDir_+3A_excl_pat">excl_pat</code></td>
<td>
<p>character(1) or NULL. A regular expression for directories/packages to
exclude from the manifest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Package manifest with 'local' type entries for each package found within <code>pdir</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
manifestFromCheckoutDir(".")

## End(Not run)
</code></pre>

<hr>
<h2 id='ManifestRow'>ManifestRow</h2><span id='topic+ManifestRow'></span>

<h3>Description</h3>

<p>Create one or more rows of a manifest data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ManifestRow(
  name,
  url = NA_character_,
  type = NA_character_,
  branch = NA_character_,
  subdir = ".",
  extra = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ManifestRow_+3A_name">name</code></td>
<td>
<p>name of the package.</p>
</td></tr>
<tr><td><code id="ManifestRow_+3A_url">url</code></td>
<td>
<p>location of the package sources</p>
</td></tr>
<tr><td><code id="ManifestRow_+3A_type">type</code></td>
<td>
<p>type of location (svn, git, local, etc)</p>
</td></tr>
<tr><td><code id="ManifestRow_+3A_branch">branch</code></td>
<td>
<p>name of the branch to use to build the package</p>
</td></tr>
<tr><td><code id="ManifestRow_+3A_subdir">subdir</code></td>
<td>
<p>subdirectory to use to build the package</p>
</td></tr>
<tr><td><code id="ManifestRow_+3A_extra">extra</code></td>
<td>
<p>currently ignored. extra commands for building or
installing the package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If name is missing, an empty (0 row) manifest data.frame
is returned. All other fields default to values indicating no information-
<code>NA_character</code> in most cases, and <code>"."</code> for <code>subdir</code>
</p>


<h3>Value</h3>

<p>A valid Package manifest data.frame
</p>

<hr>
<h2 id='normalizePath2'>normalizePath2</h2><span id='topic+normalizePath2'></span>

<h3>Description</h3>

<p>Attempt to normalize a relative path to an absolute one. Optionally without
resolving symlinks on non-Windows systems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizePath2(path, follow.symlinks = FALSE, winslash = "\\", mustWork = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizePath2_+3A_path">path</code></td>
<td>
<p>The path to normalize</p>
</td></tr>
<tr><td><code id="normalizePath2_+3A_follow.symlinks">follow.symlinks</code></td>
<td>
<p>Should symlinks (other than . and ..)
be resolved to their physical locations? (FALSE)</p>
</td></tr>
<tr><td><code id="normalizePath2_+3A_winslash">winslash</code></td>
<td>
<p>The value of winslash to be passed down to normalizePath
on windows systems</p>
</td></tr>
<tr><td><code id="normalizePath2_+3A_mustwork">mustWork</code></td>
<td>
<p>logical. Passed to normalizePath on windows. Ignored otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalized path.
</p>

<hr>
<h2 id='notrack'>Notrack directory</h2><span id='topic+notrack'></span><span id='topic+notrack+2CNULL-method'></span><span id='topic+notrack+2CNULL'></span>

<h3>Description</h3>

<p>This function is not intended to be called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notrack(repo)

## S4 method for signature ''NULL''
notrack(repo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="notrack_+3A_repo">repo</code></td>
<td>
<p>The object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the path where retrieved package versions should be. If <code>repo</code>
is NULL, a notrack directory is constructed within a temp directory.
</p>

<hr>
<h2 id='nrow'>Number of rows</h2><span id='topic+nrow'></span><span id='topic+nrow+2CPkgManifest-method'></span><span id='topic+nrow+2CPkgManifest'></span><span id='topic+nrow+2CSessionManifest-method'></span><span id='topic+nrow+2CSessionManifest'></span>

<h3>Description</h3>

<p>Number of rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrow(x)

## S4 method for signature 'PkgManifest'
nrow(x)

## S4 method for signature 'SessionManifest'
nrow(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrow_+3A_x">x</code></td>
<td>
<p>A tabular data structure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of rows in the structure
</p>

<hr>
<h2 id='packages'>packages</h2><span id='topic+packages'></span><span id='topic+packages+2CSwitchrCtx-method'></span><span id='topic+packages+2CSwitchrCtx'></span>

<h3>Description</h3>

<p>List the packages installed in a switchr context (library)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packages(seed)

## S4 method for signature 'SwitchrCtx'
packages(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="packages_+3A_seed">seed</code></td>
<td>
<p>A switchr context</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of package names installed in the
specified switchr context.
</p>

<hr>
<h2 id='parsedSessionInfo-class'>Parsed sessionInfo output</h2><span id='topic+parsedSessionInfo-class'></span>

<h3>Description</h3>

<p>An object representing the information in printed sessionInfo() output
</p>

<hr>
<h2 id='parseSessionInfoString'>Parse text output from printing SessionInfo objects</h2><span id='topic+parseSessionInfoString'></span>

<h3>Description</h3>

<p>Parse text output from printing SessionInfo objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseSessionInfoString(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseSessionInfoString_+3A_string">string</code></td>
<td>
<p>The text output from sessionInfo()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>parsedSessionInfo</code> object encoding the
information <code>string</code> (ie print output of a
<code>sessionInfo</code> call).
</p>

<hr>
<h2 id='PkgManifest'>PkgManifest</h2><span id='topic+PkgManifest'></span><span id='topic+PkgManifest-class'></span>

<h3>Description</h3>

<p>Construct a PkgManifest, which can be installed from using <code><a href="#topic+install_packages">install_packages</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PkgManifest(
  manifest = ManifestRow(...),
  dep_repos = defaultRepos(),
  ...,
  dl_method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PkgManifest_+3A_manifest">manifest</code></td>
<td>
<p>The manifest (data.frame) of packages and their locations</p>
</td></tr>
<tr><td><code id="PkgManifest_+3A_dep_repos">dep_repos</code></td>
<td>
<p>A list of traditional pkg repositories which can contain dependencies
for the packages listed in <code>manifest</code>.</p>
</td></tr>
<tr><td><code id="PkgManifest_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+ManifestRow">ManifestRow</a></code> if <code>manifest</code> is not specified</p>
</td></tr>
<tr><td><code id="PkgManifest_+3A_dl_method">dl_method</code></td>
<td>
<p>Download method. Ignored unless <code>manifest</code> is a
character scalar containing a URL to a serialized manifest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a package is found in both the manifest dataf.frame and the dependency
repositories, the version in the manifest will always take precidence within the
switchr framework.
</p>


<h3>Value</h3>

<p>a <code>PkgManifest</code> object.
</p>

<hr>
<h2 id='pkgname'>pkgname</h2><span id='topic+pkgname'></span><span id='topic+pkgname+2CPkgSource-method'></span><span id='topic+pkgname+2CPkgSource'></span><span id='topic+pkgname+3C-'></span><span id='topic+pkgname+3C-+2CPkgSource-method'></span><span id='topic+pkgname+3C-+2CPkgSource'></span>

<h3>Description</h3>

<p>Get or set the package name associated with a Package Source
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkgname(x)

## S4 method for signature 'PkgSource'
pkgname(x)

pkgname(x) &lt;- value

## S4 replacement method for signature 'PkgSource'
pkgname(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkgname_+3A_x">x</code></td>
<td>
<p>A source</p>
</td></tr>
<tr><td><code id="pkgname_+3A_value">value</code></td>
<td>
<p>The new pkgname</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for the getter, the package name as a string, for the setter,
an updated <code>PkgSource</code> (or subclass) object with the new
package name.
</p>

<hr>
<h2 id='PkgSource-class'>PkgSource</h2><span id='topic+PkgSource-class'></span><span id='topic+SVNSource-class'></span><span id='topic+GitSource-class'></span><span id='topic+GithubSource-class'></span><span id='topic+CVSSource-class'></span><span id='topic+LocalSource-class'></span><span id='topic+CRANSource-class'></span><span id='topic+BiocSource-class'></span><span id='topic+TarballSource-class'></span>

<h3>Description</h3>

<p>An object representing the source location of a package. This is a virtual
used exlusively through its subclasses, which are used to differentiate the
different types of package source locations.
</p>

<hr>
<h2 id='publishManifest'>publishManifest</h2><span id='topic+publishManifest'></span><span id='topic+publishManifest+2CPkgManifest+2Ccharacter-method'></span><span id='topic+publishManifest+2CPkgManifest+2Ccharacter'></span><span id='topic+publishManifest+2CSessionManifest+2Ccharacter-method'></span><span id='topic+publishManifest+2CSessionManifest+2Ccharacter'></span><span id='topic+publishManifest+2Cmissing+2CANY-method'></span><span id='topic+publishManifest+2Cmissing+2CANY'></span><span id='topic+publishManifest+2CSwitchrCtx+2CANY-method'></span><span id='topic+publishManifest+2CSwitchrCtx+2CANY'></span>

<h3>Description</h3>

<p>Publish a package or session manifest to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>publishManifest(manifest, dest = "./pkg_manifest.rman", ...)

## S4 method for signature 'PkgManifest,character'
publishManifest(manifest, dest = "./pkg_manifest.rman", ...)

## S4 method for signature 'SessionManifest,character'
publishManifest(manifest, dest = "./pkg_manifest.rman", ...)

## S4 method for signature 'missing,ANY'
publishManifest(manifest, dest = "./pkg_manifest.rman", ...)

## S4 method for signature 'SwitchrCtx,ANY'
publishManifest(manifest, dest = "./pkg_manifest.rman", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="publishManifest_+3A_manifest">manifest</code></td>
<td>
<p>The object to save as a serialized package or session
manifest. Defaulst to the currently in use switchr library.
A session manifest will be generated by libManifest as necessary.</p>
</td></tr>
<tr><td><code id="publishManifest_+3A_dest">dest</code></td>
<td>
<p>The destination <code>manifest</code> will be published to. Typically
a character value indicating a file name (including path) to write to.</p>
</td></tr>
<tr><td><code id="publishManifest_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the file written
</p>

<hr>
<h2 id='removeLib'>removeLib</h2><span id='topic+removeLib'></span>

<h3>Description</h3>

<p>Remove a switchr library and update the manifest of existing libraries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeLib(name = NULL, repos = NULL, compEnv = NULL, fromStack = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeLib_+3A_name">name</code></td>
<td>
<p>The name of the switchr library to remove</p>
</td></tr>
<tr><td><code id="removeLib_+3A_repos">repos</code></td>
<td>
<p>the url used to seed the library</p>
</td></tr>
<tr><td><code id="removeLib_+3A_compenv">compEnv</code></td>
<td>
<p>a SwitchrCtx representing the library to remove</p>
</td></tr>
<tr><td><code id="removeLib_+3A_fromstack">fromStack</code></td>
<td>
<p>Whether the library should be removed if it
currently appears in the Context stack Defaults to false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, called for its side-effect of removing/destroying a switchr
library
</p>


<h3>Note</h3>

<p>Only one of <code>name</code>, <code>repos</code> and <code>compEnv</code> should be
specified. An error will be thrown otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
removeLib("mylibrary")

## End(Not run)
</code></pre>

<hr>
<h2 id='RepoSubset'>RepoSubset</h2><span id='topic+RepoSubset'></span><span id='topic+RepoSubset-class'></span>

<h3>Description</h3>

<p>An object that represents a subset of packages available in a repo. When switched to, switchr will default to only installing the
specified packages, rather than all packages in the repository.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RepoSubset(repos, pkgs, default_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RepoSubset_+3A_repos">repos</code></td>
<td>
<p>The traditional repositories to select the packages from</p>
</td></tr>
<tr><td><code id="RepoSubset_+3A_pkgs">pkgs</code></td>
<td>
<p>The packages included in the subset</p>
</td></tr>
<tr><td><code id="RepoSubset_+3A_default_name">default_name</code></td>
<td>
<p>The default name to use when the RepoSubset is used to
seed a switchr context</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>RepoSubset</code> object.
</p>

<hr>
<h2 id='rVersionManifest'>rVersionManifest</h2><span id='topic+rVersionManifest'></span>

<h3>Description</h3>

<p>Create a Pkg manifest which points to tarballs representing the
cohort of packages associated with a particular release of R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rVersionManifest(vers, curr_avail = available.packages())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rVersionManifest_+3A_vers">vers</code></td>
<td>
<p>The version of R to create a manifest for</p>
</td></tr>
<tr><td><code id="rVersionManifest_+3A_curr_avail">curr_avail</code></td>
<td>
<p>The output from available.packages(). Used to identify
whether the necessary version is in the CRAN archive or normal repository</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SessionManifest object
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>References</h3>

<p>&quot;Gabor Csardi&quot; (2014). crandb: Query the unofficial CRAN metadata
database. R package version 1.0.0. https://github.com/metacran/crandb
</p>
<p>Becker G, Barr C, Gentleman R, Lawrence M; Enhancing Reproducibility and Collaboration via Management of R Package Cohorts. Journal of Statistical Software, 81(1). 2017. doi: 10.18637/jss.v082.i01
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
man = rVersionManifest("3.1.1")
man

## End(Not run)
</code></pre>

<hr>
<h2 id='SessionManifest'>SessionManifest</h2><span id='topic+SessionManifest'></span><span id='topic+SessionManifest-class'></span>

<h3>Description</h3>

<p>A manifest which includes both a PkgManifest containing package source
information, and a data.frame defining a filter with exact versions
of some or all packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SessionManifest(manifest, versions = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SessionManifest_+3A_manifest">manifest</code></td>
<td>
<p>A PkgManifest</p>
</td></tr>
<tr><td><code id="SessionManifest_+3A_versions">versions</code></td>
<td>
<p>A data.frame with 2 columns: name and version, or a named
character vector. In the case of a character vector, the names are taken to
be package names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SessionManifest object
</p>

<hr>
<h2 id='sh_init_script'>shell init</h2><span id='topic+sh_init_script'></span><span id='topic+sh_init_script+2CSwitchrParam-method'></span><span id='topic+sh_init_script+2CSwitchrParam'></span><span id='topic+sh_init_script+3C-'></span><span id='topic+sh_init_script+3C-+2CSwitchrParam-method'></span><span id='topic+sh_init_script+3C-+2CSwitchrParam+2CANY'></span>

<h3>Description</h3>

<p>Set or Retrieve the shell initialization script for an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sh_init_script(x)

## S4 method for signature 'SwitchrParam'
sh_init_script(x)

sh_init_script(x) &lt;- value

## S4 replacement method for signature 'SwitchrParam'
sh_init_script(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sh_init_script_+3A_x">x</code></td>
<td>
<p>An object associated with a SwitchrParam object</p>
</td></tr>
<tr><td><code id="sh_init_script_+3A_value">value</code></td>
<td>
<p>The new value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the getter, the shell initialization script/commands,
for the setter, an updated <code>SwitchrParam</code> object with the
new shell initialization set.
</p>

<hr>
<h2 id='shell_timing'>Get or set the number of seconds to wait between successive shell commands</h2><span id='topic+shell_timing'></span><span id='topic+shell_timing+2CSwitchrParam-method'></span><span id='topic+shell_timing+2CSwitchrParam'></span><span id='topic+shell_timing+3C-'></span><span id='topic+shell_timing+3C-+2CSwitchrParam-method'></span><span id='topic+shell_timing+3C-+2CSwitchrParam'></span>

<h3>Description</h3>

<p>This is intended to stop intermittent install failures
due to network drive latency interacting with git commands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shell_timing(x)

## S4 method for signature 'SwitchrParam'
shell_timing(x)

shell_timing(x) &lt;- value

## S4 replacement method for signature 'SwitchrParam'
shell_timing(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shell_timing_+3A_x">x</code></td>
<td>
<p>A SwitchrParam object</p>
</td></tr>
<tr><td><code id="shell_timing_+3A_value">value</code></td>
<td>
<p>The new number of seconds to wait</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When getting, the number of seconds to wait,
when setting, a new, updated SwitchrParam object.
</p>

<hr>
<h2 id='subdir'>subdir</h2><span id='topic+subdir'></span><span id='topic+subdir+2CPkgSource-method'></span><span id='topic+subdir+2CPkgSource'></span><span id='topic+subdir+3C-'></span><span id='topic+subdir+3C-+2CPkgSource-method'></span><span id='topic+subdir+3C-+2CPkgSource'></span>

<h3>Description</h3>

<p>accessor for subdirectory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subdir(x)

## S4 method for signature 'PkgSource'
subdir(x)

subdir(x) &lt;- value

## S4 replacement method for signature 'PkgSource'
subdir(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subdir_+3A_x">x</code></td>
<td>
<p>An object associated with a subdirectory, typically a PkgSource</p>
</td></tr>
<tr><td><code id="subdir_+3A_value">value</code></td>
<td>
<p>The new subdirectory to associate with the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the getter, the subdirectory within the overall source to
find the actual package source code, for the setter, an updated
<code>PkgSource</code> object with the new subdirectory set.
</p>

<hr>
<h2 id='switchBack'>switchBack</h2><span id='topic+switchBack'></span>

<h3>Description</h3>

<p>A convenience function to switch back to the previously used computing
environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchBack()
</code></pre>


<h3>Value</h3>

<p>silently, the name of the switchr context now active.
</p>

<hr>
<h2 id='switchDeps'>switchrDeps</h2><span id='topic+switchDeps'></span>

<h3>Description</h3>

<p>The base packages, as well as switchr and its dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchDeps
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 20.
</p>


<h3>Value</h3>

<p>the base packages, plus the set of packages switchr itself has dependencies on
</p>

<hr>
<h2 id='switchrBaseDir'>Get or set the base directory for switchr libraries</h2><span id='topic+switchrBaseDir'></span>

<h3>Description</h3>

<p>Get or set the base directory for switchr libraries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchrBaseDir(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switchrBaseDir_+3A_value">value</code></td>
<td>
<p>A new value for the base directory</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>value</code> is missing, the current base directory
is returned. Otherwise the <code>value</code> is set as the default directory
and returned.
</p>


<h3>Value</h3>

<p>The current base directory for switchr to create context-specific
library paths under (<em>after</em> setting it if <code>value</code> is not missing).
</p>

<hr>
<h2 id='SwitchrCtx'>SwitchrCtx</h2><span id='topic+SwitchrCtx'></span><span id='topic+SwitchrCtx-class'></span>

<h3>Description</h3>

<p>A constructor for class SwitchrCtx, represenging a switchr installed-package library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SwitchrCtx(name, libpaths, exclude.site = TRUE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SwitchrCtx_+3A_name">name</code></td>
<td>
<p>The name to associate with the context</p>
</td></tr>
<tr><td><code id="SwitchrCtx_+3A_libpaths">libpaths</code></td>
<td>
<p>The directories where the installed packages are located</p>
</td></tr>
<tr><td><code id="SwitchrCtx_+3A_exclude.site">exclude.site</code></td>
<td>
<p>Should the current site library be included in the
context when it is switched to (TRUE) '</p>
</td></tr>
<tr><td><code id="SwitchrCtx_+3A_seed">seed</code></td>
<td>
<p>An object representing the list of packages the switchr context
was seeded with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>SwitchrCtx</code> object.
</p>


<h3>References</h3>

<p>Becker G, Barr C, Gentleman R, Lawrence M; Enhancing Reproducibility and Collaboration via Management of R Package Cohorts. Journal of Statistical Software, 81(1). 2017. doi: 10.18637/jss.v082.i01
</p>

<hr>
<h2 id='switchrDontUnload'>Get or set packages to not unload when flushing the system</h2><span id='topic+switchrDontUnload'></span>

<h3>Description</h3>

<p>Get or set packages which should NOT be unloaded when flushing the system,
e.g., when switching between libraries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchrDontUnload(value, add = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switchrDontUnload_+3A_value">value</code></td>
<td>
<p>The packages to not unload when switching libraries.</p>
</td></tr>
<tr><td><code id="switchrDontUnload_+3A_add">add</code></td>
<td>
<p>Should <code>value</code> be added to the existing list?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the set of packages switchr will not attempt to unload which changing
contexts (after setting it, if <code>value</code> is missing)
</p>


<h3>Note</h3>

<p>By default switchr will not attempt to unload any base packages,
itself, or any of its dependencies. Attempting to unload any of these
packages (e.g. <code>add=FALSE</code>) will result in undefined behavior and
is not recommended.
</p>

<hr>
<h2 id='switchrManifest'>switchrManifest</h2><span id='topic+switchrManifest'></span>

<h3>Description</h3>

<p>Generate a manifest of all currently available (existing) swtichr libraries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchrManifest()
</code></pre>


<h3>Value</h3>

<p>A data.frame with information about the located switchr libraries
</p>


<h3>Note</h3>

<p>This function reads cached metadata from the current switchr base
directory (~/.switchr by default). This cache is updated whenever
the switchr framework is used to create or destroy a switchr library,
but will not be updated if one is added or removed manually. In
such cases <code><a href="#topic+updateManifest">updateManifest</a></code> must be called first
</p>

<hr>
<h2 id='switchrNoUnload'>Skip unloading of packages in session</h2><span id='topic+switchrNoUnload'></span>

<h3>Description</h3>

<p>Set whether or not ANY packages are unloaded when switching libraries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchrNoUnload(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switchrNoUnload_+3A_value">value</code></td>
<td>
<p>A logical value, or missing to return the current option</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This should be set to TRUE  when using switchr in the context of dynamic documents such as .Rnw and .Rmd files.
</p>


<h3>Value</h3>

<p>A logical indicating whether or not calling <code>flushSession</code> will skipped during the library switching process.
</p>

<hr>
<h2 id='SwitchrParam-class'>SwitchrParam</h2><span id='topic+SwitchrParam-class'></span><span id='topic+SwitchrParam'></span>

<h3>Description</h3>

<p>A contstructor for a SwitchrParam object representing a number of common
parameters understood by the switchr framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SwitchrParam(
  logfun = function(...) NULL,
  shell_init = character(),
  archive_timing = 2,
  archive_retries = 2,
  dl_method,
  shell_timing = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SwitchrParam-class_+3A_logfun">logfun</code></td>
<td>
<p>The function to be called to write to logs</p>
</td></tr>
<tr><td><code id="SwitchrParam-class_+3A_shell_init">shell_init</code></td>
<td>
<p>A character containing the location of a shell script to
be sourced before any system commands.</p>
</td></tr>
<tr><td><code id="SwitchrParam-class_+3A_archive_timing">archive_timing</code></td>
<td>
<p>The timeout after downloading a package from the CRAN Archive.</p>
</td></tr>
<tr><td><code id="SwitchrParam-class_+3A_archive_retries">archive_retries</code></td>
<td>
<p>Number of times to retry retrieving a package from the CRAN Archive.</p>
</td></tr>
<tr><td><code id="SwitchrParam-class_+3A_dl_method">dl_method</code></td>
<td>
<p>The download method to use when retrieve package
source files. See <code><a href="utils.html#topic+download.file">download.file</a></code> If none is specified,
the method defaults to &quot;curl&quot; if the RCurl package is installed and &quot;auto&quot; otherwise.</p>
</td></tr>
<tr><td><code id="SwitchrParam-class_+3A_shell_timing">shell_timing</code></td>
<td>
<p>numeric. The numer of seconds to wait between certain shell commands.
Defaults to 1, this should only need to be changed in the case of, e.g., networked drive latency issues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SwitchrParam object.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>

<hr>
<h2 id='switchTo'>switchTo</h2><span id='topic+switchTo'></span><span id='topic+switchTo+2Ccharacter+2Ccharacter-method'></span><span id='topic+switchTo+2Ccharacter+2Ccharacter'></span><span id='topic+switchTo+2Ccharacter+2CSwitchrCtx-method'></span><span id='topic+switchTo+2Ccharacter+2CSwitchrCtx'></span><span id='topic+switchTo+2Ccharacter+2Cmissing-method'></span><span id='topic+switchTo+2Ccharacter+2Cmissing'></span><span id='topic+switchTo+2CSwitchrCtx+2CANY-method'></span><span id='topic+switchTo+2CSwitchrCtx+2CANY'></span><span id='topic+switchTo+2Ccharacter+2CRepoSubset-method'></span><span id='topic+switchTo+2Ccharacter+2CRepoSubset'></span><span id='topic+switchTo+2Ccharacter+2CPkgManifest-method'></span><span id='topic+switchTo+2Ccharacter+2CPkgManifest'></span><span id='topic+switchTo+2Ccharacter+2CSessionManifest-method'></span><span id='topic+switchTo+2Ccharacter+2CSessionManifest'></span>

<h3>Description</h3>

<p>Switch to a different computing environment (set of installed R packages
and library location paths for new pkg installs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchTo(
  name,
  seed = NULL,
  reverting = FALSE,
  ignoreRVersion = FALSE,
  exclude.site = TRUE,
  ...
)

## S4 method for signature 'character,character'
switchTo(
  name,
  seed = NULL,
  reverting = FALSE,
  ignoreRVersion = FALSE,
  exclude.site = TRUE,
  ...
)

## S4 method for signature 'character,SwitchrCtx'
switchTo(
  name,
  seed = NULL,
  reverting = FALSE,
  ignoreRVersion = FALSE,
  exclude.site = TRUE,
  ...
)

## S4 method for signature 'character,missing'
switchTo(
  name,
  seed = NULL,
  reverting = FALSE,
  ignoreRVersion = FALSE,
  exclude.site = TRUE,
  ...
)

## S4 method for signature 'SwitchrCtx,ANY'
switchTo(
  name,
  seed = NULL,
  reverting = FALSE,
  ignoreRVersion = FALSE,
  exclude.site = TRUE,
  ...
)

## S4 method for signature 'character,RepoSubset'
switchTo(
  name,
  seed = NULL,
  reverting = FALSE,
  ignoreRVersion = FALSE,
  exclude.site = TRUE,
  ...
)

## S4 method for signature 'character,PkgManifest'
switchTo(
  name,
  seed = NULL,
  reverting = FALSE,
  ignoreRVersion = FALSE,
  exclude.site = TRUE,
  ...
)

## S4 method for signature 'character,SessionManifest'
switchTo(
  name,
  seed = NULL,
  reverting = FALSE,
  ignoreRVersion = FALSE,
  exclude.site = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switchTo_+3A_name">name</code></td>
<td>
<p>The name associated (or to associate) with the computing
environment.</p>
</td></tr>
<tr><td><code id="switchTo_+3A_seed">seed</code></td>
<td>
<p>The seed, indicating packages to install into a newly created
package library
No effect if the library already exists</p>
</td></tr>
<tr><td><code id="switchTo_+3A_reverting">reverting</code></td>
<td>
<p>Indicates whether we are reverting to the environment in
use before the current one. Typically not set directly by the user.</p>
</td></tr>
<tr><td><code id="switchTo_+3A_ignorerversion">ignoreRVersion</code></td>
<td>
<p>Should the R version in use be ignored when checking
for existing computing environmeSnts. This is experimental.</p>
</td></tr>
<tr><td><code id="switchTo_+3A_exclude.site">exclude.site</code></td>
<td>
<p>Should the Site library be excluded when creating
and switching to the specified library. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="switchTo_+3A_...">...</code></td>
<td>
<p>Passed directly to <code>makeLibraryCtx</code> if an existing
computing environment is not found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If switchr does not now about the specified computing environment, a new one
will be created via installCompEnv. This includes
creating a directory under the switchr base directory and installing
packages into it. See <code>installCompEnv</code> for more details.
</p>
<p>This function has the side effect of unloading all loaded
packages (other than base packages, GRAN or GRANBAse,  switchr itself, and
switchr's dependencies) and the associated DLLs. It also changes the library
location R will use to search for packages, e.g. when you call
<code>library</code>.
</p>
<p>This means you will have to reinstall packages after switching, which is
important and intended (e.g. when switching to using Bioc devel from Bioc
release).
</p>


<h3>Value</h3>

<p>Invisibly returns the SwitchrCtx object representing the new
computing environment
</p>


<h3>Note</h3>

<p>By default, this process involves a call to <code>flushSession</code> which will
attempt to unload all loaded packages. While some support of configuring
what is unloaded is provided via <code>switchrDontUnload</code>, it is recommended
that you turn this feature entirely off via <code>switchrNoUnload(TRUE)</code> when
using switchr within dyanmic documents (.Rnw/.Rmd files, etc), particularly
when using the knitr package.
</p>


<h3>References</h3>

<p>Becker G, Barr C, Gentleman R, Lawrence M; Enhancing Reproducibility and Collaboration via Management of R Package Cohorts. Journal of Statistical Software, 81(1). 2017. doi: 10.18637/jss.v082.i01
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeLibraryCtx">makeLibraryCtx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
switchTo("mynewlibrary")
switchBack()

fdman = GithubManifest("gmbecker/fastdigest")
switchTo("fastdigestlib", seed = fdman)

## End(Not run)
</code></pre>

<hr>
<h2 id='system_w_init'>system_w_init</h2><span id='topic+system_w_init'></span>

<h3>Description</h3>

<p>Run a system command with an optional intialization script (e.g. a .bashrc
sourced first).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>system_w_init(
  cmd,
  dir,
  init = character(),
  args = NULL,
  env = NULL,
  ...,
  param = SwitchrParam()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="system_w_init_+3A_cmd">cmd</code></td>
<td>
<p>The text of the command. Must be length 1.</p>
</td></tr>
<tr><td><code id="system_w_init_+3A_dir">dir</code></td>
<td>
<p>The directory that the command should be executed in. The working directory will be temporarily changed to this dir,
but will be changed back upon exit of system_w_init.</p>
</td></tr>
<tr><td><code id="system_w_init_+3A_init">init</code></td>
<td>
<p>(optional) a character value indicating the
location of an initialization shell script.</p>
</td></tr>
<tr><td><code id="system_w_init_+3A_args">args</code></td>
<td>
<p>character. Arguments to be passed to the command</p>
</td></tr>
<tr><td><code id="system_w_init_+3A_env">env</code></td>
<td>
<p>character. Environmental variables to be set when running the command</p>
</td></tr>
<tr><td><code id="system_w_init_+3A_...">...</code></td>
<td>
<p>additional parameters passed directly to <code><a href="base.html#topic+system">system</a></code>.</p>
</td></tr>
<tr><td><code id="system_w_init_+3A_param">param</code></td>
<td>
<p>A SwitchrParam object. The shell initialization
script associated with this object is used when <code>init</code> is
not specified (length 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends, see <code><a href="base.html#topic+system">system</a></code> for details.
</p>

<hr>
<h2 id='update_PACKAGES'>update existing package repository</h2><span id='topic+update_PACKAGES'></span>

<h3>Description</h3>

<p>Update an existing repository by reading the PACKAGES
file and only processing built package tarballs which do not
match existing entries.
</p>
<p><code>update_PACKAGES</code> can be much faster than
<code>write_PACKAGES</code> for small-moderate changes to large
repository indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_PACKAGES(
  dir = ".",
  fields = NULL,
  type = c("source", "mac.binary", "win.binary"),
  verbose = dryrun,
  unpacked = FALSE,
  subdirs = FALSE,
  latestOnly = TRUE,
  addFiles = FALSE,
  strict = TRUE,
  dryrun = FALSE,
  logfun = message,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_PACKAGES_+3A_dir">dir</code></td>
<td>
<p>See <code>write_PACKAGES</code></p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_fields">fields</code></td>
<td>
<p>See <code>write_PACKAGES</code></p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_type">type</code></td>
<td>
<p>See <code>write_PACKAGES</code></p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_verbose">verbose</code></td>
<td>
<p>Should informative messages be displayed throughout
the proccess. Defaults to the value of <code>dryrun</code> (whose
own default is <code>FALSE</code>) NOT passed to <code>write_PACKAGES</code></p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_unpacked">unpacked</code></td>
<td>
<p>See <code>write_PACKAGES</code></p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_subdirs">subdirs</code></td>
<td>
<p>See <code>write_PACKAGES</code></p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_latestonly">latestOnly</code></td>
<td>
<p>See <code>write_PACKAGES</code></p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_addfiles">addFiles</code></td>
<td>
<p>See <code>write_PACKAGES</code></p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_strict">strict</code></td>
<td>
<p>logical. Should 'strict mode' be used when checking
existing PACKAGES entries. See details. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_dryrun">dryrun</code></td>
<td>
<p>logical. Should should the necessary updates be
calculated but NOT applied. (default <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_logfun">logfun</code></td>
<td>
<p>function. If <code>verbose</code> is <code>TRUE</code>, the
function to be used to emit the informative messages. Defaults
to <code>message</code></p>
</td></tr>
<tr><td><code id="update_PACKAGES_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>write_PACKAGES</code> -  e.g., the relatively new
rds_compress argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Throughout this section, <em>package tarball</em> is taken to mean a tarball
file in <code>dir</code> whose name can be interpreted as
<code>&lt;package&gt;_&lt;version&gt;.&lt;ext&gt;</code> (or that is pointed to by the <code>File</code>
field of an existing PACKAGES entry). <em>Novel package tarballs</em> are
those which do not match an existing <code>PACKAGES</code> file entry.
</p>
<p><code>update_PACKAGES</code> avoids (re)processing package tarballs in cases where
a <code>PACKAGES</code> file entry already exists and appears to remain valid. The
logic for detecting still-valid entries is as follows:
</p>
<p>Currently <code>update_PACKAGES</code> calls directly down to
<code>write_PACKAGES</code> (and thus no speedup should be expected)
if any of the following conditions hold:
</p>

<ul>
<li><p> No <code>PACKAGES</code> file exists under <code>dir</code>
</p>
</li>
<li> <p><code>unpacked</code> is <code>TRUE</code>
</p>
</li>
<li> <p><code>subdirs</code> is anything other than <code>FALSE</code>
</p>
</li>
<li> <p><code>fields</code> is not <code>NULL</code> and one or more specified fields
are not present in the existing <code>PACKAGES</code> file
</p>
</li></ul>

<p>All package tarballs whose last modify times are later than that
of the existing PACKAGES file are considered novel and no attempt
is made to identify or retain any corresponding <code>PACKAGES</code>
entries. Similarly, all <code>PACKAGES</code> entries which have no
corresponding package tarball are definitionally invalid.
</p>
<p>When <code>strict = TRUE</code>, <code>PACKAGES</code> entries which appear to
match a package tarball are confirmed via MD5 checksum; those that
pass are retained as valid. All novel package tarballs are fully
proccessed by the standard <code>write_PACKAGES</code> machinery, and
the resulting entries are added. Finally, if <code>latestOnly =
TRUE</code>, package-version pruning is performed across the entries.
</p>
<p>When <code>strict = FALSE</code>, package tarballs are assumed to encode
correct metadata in their filenames. <code>PACKAGES</code> entries which
appear to match a package tarball are retained as valid (No MD5sum
checking occurs). If <code>latestOnly = TRUE</code>, package-version
pruning across the full set of retained entries and novel package
tarballs <em>before</em> the processing of the novel tarballs, at
significant computational and time savings in some
situations. After the optional pruning, any relevant novel package
tarballs are processed via <code>write_PACKAGES</code> and added to the
set of retained entries.
</p>
<p>After the above process concludes, the final database of
<code>PACKAGES</code> entries is written to all three PACKAGES files,
overwriting the existing files.
</p>


<h3>Value</h3>

<p>Called for its side-effect of updating a package repository index
<code>PACKAGES</code> file and siblings.
</p>


<h3>Note</h3>

<p>While both strict and nonstrict modes offer speedups when
updating small percentages of large repositories, non-strict
mode is <em>much</em> faster and is recommended in situations where the
assumptions it makes are safe.
</p>
<p>For versions of R <code>3.6.0</code> and later, use <code>tools::update_PACKAGES</code>,
which was adapted from this fuction, instead.
</p>


<h3>Author(s)</h3>

<p>Gabriel Becker
</p>


<h3>See Also</h3>

<p><a href="tools.html#topic+write_PACKAGES">write_PACKAGES</a>
</p>

<hr>
<h2 id='updateManifest'>updateManifest</h2><span id='topic+updateManifest'></span>

<h3>Description</h3>

<p>Update the cached information regarding available switchr libraries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateManifest()
</code></pre>


<h3>Value</h3>

<p>NULL, used for it's side-effect of updating the switchr library
metadata cache.
</p>

<hr>
<h2 id='versions_df'>versions_df</h2><span id='topic+versions_df'></span><span id='topic+versions_df+2CSessionManifest-method'></span><span id='topic+versions_df+2CSessionManifest'></span><span id='topic+versions_df+3C-'></span><span id='topic+versions_df+3C-+2CSessionManifest-method'></span><span id='topic+versions_df+3C-+2CSessionManifest'></span>

<h3>Description</h3>

<p>Get or set the the versions information in a SessionManifest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>versions_df(x)

## S4 method for signature 'SessionManifest'
versions_df(x)

versions_df(x) &lt;- value

## S4 replacement method for signature 'SessionManifest'
versions_df(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="versions_df_+3A_x">x</code></td>
<td>
<p>An object containing package version information</p>
</td></tr>
<tr><td><code id="versions_df_+3A_value">value</code></td>
<td>
<p>A data.frame of package version information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the getter, a data.frame indicating the versions-specific cohort
of packages defined by <code>x</code>, for the setter, the <code>SessionManifest</code> object
updated with the new versions data.frame.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
