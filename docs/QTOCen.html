<!DOCTYPE html><html lang="en"><head><title>Help for package QTOCen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QTOCen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bnk_func'><p>Generate biquadratic kernel weights for a univariate variable</p></a></li>
<li><a href='#est_mean_ipwe'><p>Estimate the marginal mean response of a linear static treatment regime</p></a></li>
<li><a href='#est_quant_ipwe'><p>Estimate the marginal quantile response of a linear static treatment regime</p></a></li>
<li><a href='#est_quant_TwoStg_ipwe'><p>Estimate the marginal quantile response of a specific dynamic TR</p></a></li>
<li><a href='#Gene_Mean_CenIPWE'><p>A low-level function for the generic optimization step in estimating Mean-optimal</p>
treatment regime for censored data</a></li>
<li><a href='#Gene_Quantile_CenIPWE'><p>A low-level function for the generic optimization step in</p>
estimating Quanilte-optimal treatment regime for censored data</a></li>
<li><a href='#Gene_Quantile_CenIPWE_DTR'><p>A low-level function for the generic optimization step in</p>
estimating dynamic Quanilte-optimal treatment regime for censored data</a></li>
<li><a href='#IPWE_mean_IndCen'><p>Estimate the mean-optimal treatment regime for data with independently censored response</p></a></li>
<li><a href='#IPWE_Qopt_DepCen_general'><p>Estimate Quantile-optimal Treatment Regime for covariates-dependent random censoring data</p></a></li>
<li><a href='#IPWE_Qopt_DepCen_trt'><p>Estimate the Quantile-opt Treatment Regime under the assumption that the censoring</p>
time's distribution only depends on treatment level</a></li>
<li><a href='#IPWE_Qopt_DTR_IndCen'><p>Function to estimate the two-stage quantile-optimal dynamic treatment</p>
regime for censored data: the independent censoring Case</a></li>
<li><a href='#IPWE_Qopt_IndCen'><p>Function to estimate the quantile-optimal treatment regime:</p>
the independent censoring Case</a></li>
<li><a href='#LocalKM'><p>Kernel-based Local Kaplan-Meier Estimator</p></a></li>
<li><a href='#simJLSDdata'><p>Function to generate simulation data from a sequentially randomized</p>
experiment designed in (Jiang et al. 2017)</a></li>
<li><a href='#tauhat_func'><p>Kernel-based Local Kaplan-Meier Estimator for the Conditional Probability of the Survival Time</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantile-Optimal Treatment Regimes with Censored Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Yu Zhou [cre, aut],
  Lan Wang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yu Zhou &lt;zhou0269@umn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for estimation of mean- and quantile-optimal treatment regimes from censored data. 
    Specifically, we have developed distinct functions for three types of right censoring for static treatment using quantile criterion: (1) independent/random censoring, (2) treatment-dependent random censoring, and (3) covariates-dependent random censoring. It also includes a function to estimate quantile-optimal dynamic treatment regimes for independent censored data. Finally, this package also includes a simulation data generative model of a dynamic treatment experiment proposed in literature.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>survival, rgenoud (&ge; 5.8), quantreg (&ge; 5.18), stats,
grDevices, methods, Rdpack, MatrixModels</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3), utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, stringr, testthat, faraway, quantoptr (&ge; 0.1.3),
survminer</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-06-03 15:56:38 UTC; yuzhou</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-06-04 12:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bnk_func'>Generate biquadratic kernel weights for a univariate variable</h2><span id='topic+Bnk_func'></span>

<h3>Description</h3>

<p>This is the biquadratic kernel function, that weights
observations by their distances to the target observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bnk_func(x0k, Xk, bw.bnk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bnk_func_+3A_x0k">x0k</code></td>
<td>
<p>Numeric scalar. One univariate covariate value of interest 
from one observation.</p>
</td></tr>
<tr><td><code id="Bnk_func_+3A_xk">Xk</code></td>
<td>
<p>Numerical vector. The vector of the same covariate from observations</p>
</td></tr>
<tr><td><code id="Bnk_func_+3A_bw.bnk">bw.bnk</code></td>
<td>
<p>The bandwith scalar parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of kernel weights with the same length of input <code>Xk</code>.
</p>


<h3>Note</h3>

<p>This function is widely used for generating kernel weights for 
nonparametrically estimating conditional survival functions. See 
Section 2.3 of (Wang and Wang 2009).
</p>


<h3>References</h3>

<p>Wang HJ, Wang L (2009).
&ldquo;Locally weighted censored quantile regression.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>104</b>(487), 1117&ndash;1128.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
Bnk_func(x0k=0, Xk=c(-5:5), bw.bnk=10)

</code></pre>

<hr>
<h2 id='est_mean_ipwe'>Estimate the marginal mean response of a linear static treatment regime</h2><span id='topic+est_mean_ipwe'></span>

<h3>Description</h3>

<p>Assume we have binary treatment options for each subject in the target population.
This function evaluates a given treatment regime by the estimated 
marginal mean response. 
We assume the space of treatment regimes are linear
decision functions indexed by parametric coefficients.
</p>
<p>This R function is an empirical <em>value function</em> in the 
literature of optimal treatment regime estimation. Since the goal here
is to maximize population's <strong>marginal mean</strong> response, this function, which estimates 
the performance of a set of parameters in terms of the <strong>marginal mean</strong>,
is the objective function in a nonparametric policy-search method.
</p>
<p>The user facing application which utilizes this function is <code><a href="#topic+IPWE_mean_IndCen">IPWE_mean_IndCen</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_mean_ipwe(beta, x, censor_y, delta, ph, a, ghat,
  check_complete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_mean_ipwe_+3A_beta">beta</code></td>
<td>
<p>Numeric vector. A set of parameter that indexes the regime.</p>
</td></tr>
<tr><td><code id="est_mean_ipwe_+3A_x">x</code></td>
<td>
<p>Numeric Matrix. The baseline covariates from all observed data.</p>
</td></tr>
<tr><td><code id="est_mean_ipwe_+3A_censor_y">censor_y</code></td>
<td>
<p>Numeric vector. The censored survival times from all observed data, i.e. <code>censor_y = min(Y, C)</code></p>
</td></tr>
<tr><td><code id="est_mean_ipwe_+3A_delta">delta</code></td>
<td>
<p>Numeric vector. The censoring indicators from all observed data. We use 1 for uncensored, 0 for censored.</p>
</td></tr>
<tr><td><code id="est_mean_ipwe_+3A_ph">ph</code></td>
<td>
<p>Numeric vector. The estimated propensity score of being assigned treatment <code>A=1</code> 
by the original data generation mechanism for all observed data.</p>
</td></tr>
<tr><td><code id="est_mean_ipwe_+3A_a">a</code></td>
<td>
<p>Numeric vector. The vector of observed treatment level for all observed data. Treatment levels
should be coded as 0/1.</p>
</td></tr>
<tr><td><code id="est_mean_ipwe_+3A_ghat">ghat</code></td>
<td>
<p>Numeric vector. The conditional/unconditional probabilities of 
event that the censoring variable is larger than the observed survival time given covariates 
for each observation.
a.k.a  <code class="reqn">F(T &gt; y_0 \mid x_0).</code>
This can be calculated by function <code><a href="#topic+LocalKM">LocalKM</a></code>. 
Estimation of conditional cumulative function value at <code class="reqn">y_0</code> is
implemented in <code><a href="#topic+tauhat_func">tauhat_func</a></code>.</p>
</td></tr>
<tr><td><code id="est_mean_ipwe_+3A_check_complete">check_complete</code></td>
<td>
<p>logical. Since this value estimation method is purely
nonparametric, we need at least one unit in collected data such that the observed
treatment assignment is the same what the regime parameter suggests. If <code>check_complete</code>
is <code>TRUE</code>. It will check if any observation satisfies this criterion. 
When none observation satisfies, a message is printed to console to raise users
awareness that the input regime parameter <code>beta</code> does not agree with any observed treatment level assignment.
Then a sufficiently small number is returned from this function, to keep
the genetic algorithm running smoothly.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 1)
  ph &lt;- rep(0.5,n)
  a &lt;- rbinom(n = n, size = 1, prob=ph)
  c &lt;- 1.5 +  + runif(n = n, min=0, max=2)
  cmplt_y &lt;-  pmin(2+x1+x2 +  a*(1 - x1 - x2) +  (0.2 + a*(1+x1+x2)) * error, 4.4)
  censor_y &lt;- pmin(cmplt_y, c)
  delta &lt;- as.numeric(c &gt; cmplt_y)
  return(data.frame(x1=x1,x2=x2,a=a, censor_y = censor_y, delta=delta))
}
n &lt;- 100
data &lt;- GenerateData(n)

# here the value for argument ghat uses 0.5 vector for brevity.
mean_hat &lt;- est_mean_ipwe(c(-1,0,2), x=cbind(1, data$x1, data$x2), 
                          censor_y = data$censor_y, delta = data$delta, ph = rep(0.5,n), 
                          a = data$a, ghat = rep(0.5,n))  


</code></pre>

<hr>
<h2 id='est_quant_ipwe'>Estimate the marginal quantile response of a linear static treatment regime</h2><span id='topic+est_quant_ipwe'></span>

<h3>Description</h3>

<p>Assume we have binary treatment options for each subject in the target population.
This function evaluates a given treatment regime by the estimated 
marginal mean response. 
We assume the space of treatment regimes are linear
decision functions indexed by parametric coefficients.
</p>
<p>This R function is an empirical <em>value function</em> in the 
literature of optimal treatment regime estimation. Since the goal here
is to maximize population's <strong>marginal quantile</strong>, this function, which estimates the perforamce
of a set of parameters in terms of <strong>marginal quantile</strong>,
is the objective function in a nonparametric policy-search method.
</p>
<p>The user facing application which utilizes this function is <code><a href="#topic+IPWE_Qopt_IndCen">IPWE_Qopt_IndCen</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_quant_ipwe(beta, sign_beta1, x, censor_y, delta, epsi, a, tau,
  check_complete = TRUE, Penalty.level = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_quant_ipwe_+3A_beta">beta</code></td>
<td>
<p>Numerical vector. Exclude the coefficient for the first nontrivial covariate. So if
there are <code>k</code> covariates, the length of <code>beta</code> should equal <code>k+1-1=k</code> because
the intercept needs one coefficient as well.</p>
</td></tr>
<tr><td><code id="est_quant_ipwe_+3A_sign_beta1">sign_beta1</code></td>
<td>
<p>logical. FALSE if the coefficient for the first continuous variable 
is fixed to be negative one; TRUE if positive one.</p>
</td></tr>
<tr><td><code id="est_quant_ipwe_+3A_x">x</code></td>
<td>
<p>Numeric Matrix. The baseline covariates from all observed data.</p>
</td></tr>
<tr><td><code id="est_quant_ipwe_+3A_censor_y">censor_y</code></td>
<td>
<p>Numeric vector. The censored survival times from all observed data, i.e. <code>censor_y = min(Y, C)</code></p>
</td></tr>
<tr><td><code id="est_quant_ipwe_+3A_delta">delta</code></td>
<td>
<p>Numeric vector. The censoring indicators from all observed data. We use 1 for uncensored, 0 for censored.</p>
</td></tr>
<tr><td><code id="est_quant_ipwe_+3A_epsi">epsi</code></td>
<td>
<p>the product of (1) the probability of being assigned the 
observed treatment level through the original treatment assignment mechanism 
and (2) the conditional survival probability of the censoring variable at <code>censor_y</code>.</p>
</td></tr>
<tr><td><code id="est_quant_ipwe_+3A_a">a</code></td>
<td>
<p>Numeric vector. The vector of observed treatment level for all observed data. Treatment levels
should be coded as 0/1.</p>
</td></tr>
<tr><td><code id="est_quant_ipwe_+3A_tau">tau</code></td>
<td>
<p>a value between 0 and 1. This is the quantile of interest.</p>
</td></tr>
<tr><td><code id="est_quant_ipwe_+3A_check_complete">check_complete</code></td>
<td>
<p>logical. Since this value estimation method is purely
nonparametric, we need at least one unit in collected data such that the observed
treatment assignment is the same what the regime parameter suggests. If <code>check_complete</code>
is <code>TRUE</code>. It will check if any observation satisfies this criterion. 
When none observation satisfies, a message is printed to console to raise users
awareness that the input regime parameter <code>beta</code> does not agree with any observed treatment level assignment.
Then a sufficiently small number is returned from this function, to keep
the genetic algorithm running smoothly.</p>
</td></tr>
<tr><td><code id="est_quant_ipwe_+3A_penalty.level">Penalty.level</code></td>
<td>
<p>the level that determines which objective function to use. 
<code>Penalty.level = 0</code> indicates no regularization;
<code>Penalty.level = 1</code> indicates the value function estimation minus the means absolute average coefficient 
is the output, which is useful trick to achieve uniqueness of estimated optimal TR
when resolution of input response is low.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 1)
  ph &lt;- rep(0.5,n)
  a &lt;- rbinom(n = n, size = 1, prob=ph)
  c &lt;- 1.5 +  + runif(n = n, min=0, max=2)
  cmplt_y &lt;-  pmin(2+x1+x2 +  a*(1 - x1 - x2) +  (0.2 + a*(1+x1+x2)) * error, 4.4)
  censor_y &lt;- pmin(cmplt_y, c)
  delta &lt;- as.numeric(c &gt; cmplt_y)
  return(data.frame(x1=x1,x2=x2,a=a, censor_y = censor_y, delta=delta))
}
n &lt;- 100
data &lt;- GenerateData(n)

# here the value for argument epsi uses 0.5 vector for brevity in notation.
quant_hat &lt;- est_quant_ipwe(beta=c(-1,2), sign_beta1=TRUE, x=cbind(1, data$x1, data$x2), 
                            censor_y = data$censor_y, delta = data$delta, tau=0.5,
                            epsi = rep(0.5,n), a = data$a)  

</code></pre>

<hr>
<h2 id='est_quant_TwoStg_ipwe'>Estimate the marginal quantile response of a specific dynamic TR</h2><span id='topic+est_quant_TwoStg_ipwe'></span>

<h3>Description</h3>

<p>Assume we have binary treatment options for two sequential stages with a fixed time duration between them.
This means for each subject in the target population if the censored survival time or the time-to-event is beyond
the timepoint of the second treatment.
</p>
<p>This function evaluates a given dynamic treatment regime and returns the estimated 
marginal quantile response. 
</p>
<p>We assume the space of two-stage treatment regimes is a cartesian product of two
single-stage linear treatment regime space.
</p>
<p>The user facing function that applies this function is <code><a href="#topic+IPWE_Qopt_DTR_IndCen">IPWE_Qopt_DTR_IndCen</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_quant_TwoStg_ipwe(n, beta, sign_beta1.stg1, sign_beta1.stg2, txVec1,
  txVec2_na_omit, s_Diff_Time, nvars.stg1, nvars.stg2, p.data1, p.data2,
  censor_y, delta, ELG, w_di_vec, tau, check_complete = TRUE,
  Penalty.level = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_n">n</code></td>
<td>
<p>the sample size</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_beta">beta</code></td>
<td>
<p>the vector of coefficients indexing a two-stage treatment regime</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_sign_beta1.stg1">sign_beta1.stg1</code></td>
<td>
<p>Is sign of the coefficient for the first non-intercept 
variable for the first stage known? Default is NULL, meaning user does not have contraint on
the sign;
FALSE if the coefficient for the first continuous variable 
is fixed to be <code>-1</code>; TRUE if <code>1</code>. We can make the search space discrete because we employ
<code class="reqn">|\beta_1| = 1</code> scale normalizaion.</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_sign_beta1.stg2">sign_beta1.stg2</code></td>
<td>
<p>Default is NULL. Similar to <code>sign_beta1.stg1</code>.</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_txvec1">txVec1</code></td>
<td>
<p>the vector of treatment received at the first stage</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_txvec2_na_omit">txVec2_na_omit</code></td>
<td>
<p>the vector of second stage treatment for patients who indeed 
second stage treatment</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_s_diff_time">s_Diff_Time</code></td>
<td>
<p>the length of time between the first stage treatment and the
second stage treatment</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_nvars.stg1">nvars.stg1</code></td>
<td>
<p>number of coeffients for the decision rule of the first stage</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_nvars.stg2">nvars.stg2</code></td>
<td>
<p>number of coeffients for the decision rule of the second stage</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_p.data1">p.data1</code></td>
<td>
<p>the design matrix to be used for decision in stage one</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_p.data2">p.data2</code></td>
<td>
<p>the design matrix to be used for decision in stage two</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_censor_y">censor_y</code></td>
<td>
<p>Numeric vector. The censored survival times from all observed data, i.e. <code>censor_y = min(Y, C)</code></p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_delta">delta</code></td>
<td>
<p>Numeric vector. The censoring indicators from all observed data. We use 1 for uncensored, 0 for censored.</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_elg">ELG</code></td>
<td>
<p>the boolean vector of whether patients get the second stage treatment</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_w_di_vec">w_di_vec</code></td>
<td>
<p>the inverse probability weight for two stage experiments</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_tau">tau</code></td>
<td>
<p>a value between 0 and 1. This is the quantile of interest.</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_check_complete">check_complete</code></td>
<td>
<p>logical. Since this value estimation method is purely
nonparametric, we need at least one unit in collected data such that the observed
treatment assignment is the same what the regime parameter suggests. If <code>check_complete</code>
is <code>TRUE</code>. It will check if any observation satisfies this criterion. 
When none observation satisfies, a message is printed to console to raise users
awareness that the input regime parameter <code>beta</code> does not agree with any observed treatment level assignment.
Then a sufficiently small number is returned from this function, to keep
the genetic algorithm running smoothly.</p>
</td></tr>
<tr><td><code id="est_quant_TwoStg_ipwe_+3A_penalty.level">Penalty.level</code></td>
<td>
<p>the level that determines which objective function to use. 
<code>Penalty.level = 0</code> indicates no regularization;
<code>Penalty.level = 1</code> indicates the value function estimation minus the means absolute average coefficient 
is the output, which is useful trick to achieve uniqueness of estimated optimal TR
when resolution of input response is low.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##########################################################################
# Note: the preprocessing steps prior to calling est_quant_TwoStg_ipwe() #
# are wrapped up in IPWE_Qopt_DTR_IndCen().                              #
# w_di_vec is the inverse probability weight for two stage experiments   #
# We recommend users to use function IPWE_Qopt_DTR_IndCen() directly.    #
# Below is a simple customized calculation of the weight that only works #
# for this example                                                       #
##########################################################################

library(survival)
# Simulate data
n=200
s_Diff_Time = 1
D &lt;- simJLSDdata(n, case="a")

# give regime classes
regimeClass.stg1 &lt;- as.formula(a0~x0)
regimeClass.stg2 &lt;- as.formula(a1~x1)

# extract columns that matches each stage's treatment regime formula
p.data1 &lt;- model.matrix(regimeClass.stg1, D)

# p.data2 would only contain observations with non-null value.
p.data2 &lt;- model.matrix(regimeClass.stg2, D)

txVec1 &lt;- D[, "a0"]
# get none-na second stage treatment levels in data
txVec2 &lt;- D[, "a1"]
txVec2_na_omit &lt;- txVec2[which(!is.na(txVec2))]

# Eligibility flag
ELG &lt;- (D$censor_y  &gt;  s_Diff_Time)

# Build weights
D$deltaC &lt;- 1 - D$delta
survfit_all &lt;- survfit(Surv(censor_y, event = deltaC)~1, data=D)
survest &lt;- stepfun(survfit_all$time, c(1, survfit_all$surv))
D$ghat &lt;- survest(D$censor_y)
g_s_Diff_Time &lt;- survest(s_Diff_Time)
D$w_di_vec &lt;- rep(-999, n)
for(i in 1:n){
  if (!ELG[i]) {
      D$w_di_vec[i] &lt;- 0.5 * D$ghat[i]} else {
         D$w_di_vec[i] &lt;- 0.5* D$ghat[i] * 0.5
 }
}


qhat &lt;- est_quant_TwoStg_ipwe(n=n, beta=c(2.5,2.8), 
             sign_beta1.stg1 = FALSE, sign_beta1.stg2=FALSE,
             txVec1=txVec1, txVec2_na_omit=txVec2_na_omit, s_Diff_Time=1, 
             nvars.stg1=2, nvars.stg2=2, 
             p.data1=p.data1, 
             p.data2=p.data2, 
             censor_y=D$censor_y, 
             delta=D$delta, 
             ELG=ELG, w_di_vec=D$w_di_vec, 
             tau=0.3)
</code></pre>

<hr>
<h2 id='Gene_Mean_CenIPWE'>A low-level function for the generic optimization step in estimating Mean-optimal
treatment regime for censored data</h2><span id='topic+Gene_Mean_CenIPWE'></span>

<h3>Description</h3>

<p>This function supports the <code>IPWE_mean_IndCen</code> function.
It does the genetic algorithm based method with inverse probability weighting for censored data. 
In the future, if more complicated applications/scenarios is sought after for mean optimality, 
users may create their own wrapper function
based on <code>Gene_Mean_CenIPWE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gene_Mean_CenIPWE(data_aug, ph, p_level, regimeClass, Domains = NULL,
  cluster = FALSE, s.tol = 1e-04, it.num = 8, pop.size = 3000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gene_Mean_CenIPWE_+3A_data_aug">data_aug</code></td>
<td>
<p>a data.frame of the observed data after preprocessing. It should include be
augmented with two new columns: <code>ph</code> for the enstimated propensity scores and 
<code>ghat</code> for the estimated conditional survival probabilities.</p>
</td></tr>
<tr><td><code id="Gene_Mean_CenIPWE_+3A_ph">ph</code></td>
<td>
<p>propensity score estimates. For example, if the treatment is denoted by <code>A</code>,
then <code>ph</code> should be P(A=1|X)</p>
</td></tr>
<tr><td><code id="Gene_Mean_CenIPWE_+3A_p_level">p_level</code></td>
<td>
<p>printing level</p>
</td></tr>
<tr><td><code id="Gene_Mean_CenIPWE_+3A_regimeclass">regimeClass</code></td>
<td>
<p>a formula indicating the form of treatment regimes</p>
</td></tr>
<tr><td><code id="Gene_Mean_CenIPWE_+3A_domains">Domains</code></td>
<td>
<p>default is NULL. Otherwise, the object should be a <code>nvars *2</code> 
matrix used as the space of parameters, which will be supplied to <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="Gene_Mean_CenIPWE_+3A_cluster">cluster</code></td>
<td>
<p>default is FALSE. This can also be an object of the 'cluster' class 
returned by one of the makeCluster commands in the parallel package or
a vector of machine names so rgenoud::genoud can setup the cluster automatically.</p>
</td></tr>
<tr><td><code id="Gene_Mean_CenIPWE_+3A_s.tol">s.tol</code></td>
<td>
<p>tolerance level for the GA algorithm. This is input for parameter <code>solution.tolerance</code>
in function <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="Gene_Mean_CenIPWE_+3A_it.num">it.num</code></td>
<td>
<p>the maximum GA iteration number</p>
</td></tr>
<tr><td><code id="Gene_Mean_CenIPWE_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is roughly the 
number individuals for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 1)
  ph &lt;- rep(0.5,n)
  a &lt;- rbinom(n = n, size = 1, prob=ph)
  c &lt;- 1.5 +  + runif(n = n, min=0, max=2)
  cmplt_y &lt;-  pmin(2+x1+x2 +  a*(1 - x1 - x2) +  (0.2 + a*(1+x1+x2)) * error, 4.4)
  censor_y &lt;- pmin(cmplt_y, c)
  delta &lt;- as.numeric(c &gt; cmplt_y)
  return(data.frame(x1=x1,x2=x2,a=a, censor_y = censor_y, delta=delta))
}
n &lt;- 100
data &lt;- GenerateData(n)

# preprocessing
data_aug &lt;- data
data_aug$ph &lt;- rep(mean(data$a), n)
data_aug$deltaC &lt;- 1 - data_aug$delta
library(survival)
survfit_all &lt;- survfit(Surv(censor_y, event = deltaC)~1, data=data_aug)
survest &lt;- stepfun(survfit_all$time, c(1, survfit_all$surv))
data_aug$ghat &lt;- survest(data_aug$censor_y)

# estimate the mean-optimal treatment regime
meanopt_fit &lt;- Gene_Mean_CenIPWE(data=data_aug, ph = data_aug$ph, p_level=1, regimeClass=a~x1*x2) 

</code></pre>

<hr>
<h2 id='Gene_Quantile_CenIPWE'>A low-level function for the generic optimization step in 
estimating Quanilte-optimal treatment regime for censored data</h2><span id='topic+Gene_Quantile_CenIPWE'></span>

<h3>Description</h3>

<p>This function supports several user facing functions for Quantile-optimal
treatment regime estimation, namely
</p>
<p><code><a href="#topic+IPWE_Qopt_IndCen">IPWE_Qopt_IndCen</a>(), <a href="#topic+IPWE_Qopt_DTR_IndCen">IPWE_Qopt_DTR_IndCen</a>(), <a href="#topic+IPWE_Qopt_DepCen_trt">IPWE_Qopt_DepCen_trt</a>(), and <a href="#topic+IPWE_Qopt_DepCen_general">IPWE_Qopt_DepCen_general</a>()</code>. 
</p>
<p>It implements the genetic algorithm based policy-search method with 
inverse probability weighting for censored data, such that the estimator is cube root consistent
under the assumption that the propensity score model and the model for the 
survival distriution of the censoring time variable are both correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gene_Quantile_CenIPWE(data_aug, tau, p_level, regimeClass,
  cluster = FALSE, s.tol = 1e-04, it.num = 8, pop.size = 5000,
  Domains = NULL, sign_beta1 = NULL, Penalty.level = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_data_aug">data_aug</code></td>
<td>
<p>a data.frame of the observed data after preprocessing. It should include be
augmented with a new column: <code>epsi</code> for the composite weights.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_tau">tau</code></td>
<td>
<p>a value between 0 and 1. This is the quantile of interest.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug).</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_regimeclass">regimeClass</code></td>
<td>
<p>a formula specifying the class of treatment regimes to search,
e.g. if <code>regimeClass = a~x1+x2</code>, and then this function will 
search the class of treatment regimes
of the form 
</p>
<p style="text-align: center;"><code class="reqn">d(x) = I \left(\beta_0 +\beta_1  x_1 + \beta_2  x_2 &gt; 0\right).
</code>
</p>

<p>Polynomial arguments are also supported.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_cluster">cluster</code></td>
<td>
<p>default is FALSE, meaning do not use parallel computing for the genetic algorithm(GA).</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_s.tol">s.tol</code></td>
<td>
<p>tolerance level for the GA algorithm. This is input for parameter <code>solution.tolerance</code>
in function <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_it.num">it.num</code></td>
<td>
<p>the maximum GA iteration number</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is roughly the 
number individuals for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_domains">Domains</code></td>
<td>
<p>default is NULL. Otherwise, the object should be a <code>nvars *2</code> 
matrix used as the space of parameters, which will be supplied to <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_sign_beta1">sign_beta1</code></td>
<td>
<p>logical. FALSE if the coefficient for the first continuous variable 
is fixed to be negative one; TRUE if positive one.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_+3A_penalty.level">Penalty.level</code></td>
<td>
<p>the level that determines which objective function to use. 
<code>Penalty.level = 0</code> indicates no regularization;
<code>Penalty.level = 1</code> indicates the value function estimation minus the means absolute average coefficient 
is the output, which is useful trick to achieve uniqueness of estimated optimal TR
when resolution of input response is low.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 1)
  ph &lt;- rep(0.5,n)
  a &lt;- rbinom(n = n, size = 1, prob=ph)
  c &lt;- 1.5 +  + runif(n = n, min=0, max=2)
  cmplt_y &lt;-  pmin(2+x1+x2 +  a*(1 - x1 - x2) +  (0.2 + a*(1+x1+x2)) * error, 4.4)
  censor_y &lt;- pmin(cmplt_y, c)
  delta &lt;- as.numeric(c &gt; cmplt_y)
  return(data.frame(x1=x1,x2=x2,a=a, censor_y = censor_y, delta=delta))
}
n &lt;- 100
data &lt;- GenerateData(n)

# preprocessing
data_aug &lt;- data
data_aug$ph &lt;- rep(mean(data$a), n)
data_aug$deltaC &lt;- 1 - data_aug$delta
library(survival)
survfit_all &lt;- survfit(Surv(censor_y, event = deltaC)~1, data=data_aug)
survest &lt;- stepfun(survfit_all$time, c(1, survfit_all$surv))
data_aug$ghat &lt;- survest(data_aug$censor_y)
data_aug$epsi &lt;- (data_aug$ph * data_aug$a + (1 - data_aug$ph) * (1 - data_aug$a)) * data_aug$ghat

# estimate the median-optimal treatment regime

quantopt_fit &lt;- Gene_Quantile_CenIPWE(data_aug=data_aug,tau=0.5,
                                      p_level=1, regimeClass=a~x1+x2^2, 
                                      sign_beta1=FALSE)


</code></pre>

<hr>
<h2 id='Gene_Quantile_CenIPWE_DTR'>A low-level function for the generic optimization step in 
estimating dynamic Quanilte-optimal treatment regime for censored data</h2><span id='topic+Gene_Quantile_CenIPWE_DTR'></span>

<h3>Description</h3>

<p>This function supports wrapper functions for two stage Quantile-optimal
treatment regime estimation, namely
<code>IPWE_Qopt_DTR_IndCen</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gene_Quantile_CenIPWE_DTR(data, max, tau, regimeClass.stg1,
  regimeClass.stg2, s_Diff_Time, txVec1, txVec2, nvars.stg1, nvars.stg2,
  p.data1, p.data2, sign_beta1.stg1, sign_beta1.stg2, p_level, cluster,
  s.tol, it.num, pop.size, Domains1 = NULL, Domains2 = NULL,
  Penalty.level = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_data">data</code></td>
<td>
<p>raw data.frame</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_max">max</code></td>
<td>
<p>Maximization (TRUE) or Minimizing (FALSE). Determines if genoud minimizes or maximizes the objective function.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_tau">tau</code></td>
<td>
<p>a quantile level of interest</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_regimeclass.stg1">regimeClass.stg1</code></td>
<td>
<p>the class of treatment regimes for stage one</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_regimeclass.stg2">regimeClass.stg2</code></td>
<td>
<p>the class of treatment regimes for stage two</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_s_diff_time">s_Diff_Time</code></td>
<td>
<p>the length of time between the first stage treatment and the
second stage treatment</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_txvec1">txVec1</code></td>
<td>
<p>the vector of treatment received at the first stage</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_txvec2">txVec2</code></td>
<td>
<p>the vector of treatment received at the second stage, it expects entries
to be <code>NA</code> for patients who did not receive the second treatment</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_nvars.stg1">nvars.stg1</code></td>
<td>
<p>number of coeffients for the decision rule of the first stage</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_nvars.stg2">nvars.stg2</code></td>
<td>
<p>number of coeffients for the decision rule of the second stage</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_p.data1">p.data1</code></td>
<td>
<p>the design matrix to be used for decision in stage one</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_p.data2">p.data2</code></td>
<td>
<p>the design matrix to be used for decision in stage two</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_sign_beta1.stg1">sign_beta1.stg1</code></td>
<td>
<p>Is sign of the coefficient for the first non-intercept 
variable for the first stage known? Default is NULL, meaning user does not have contraint on
the sign;
FALSE if the coefficient for the first continuous variable 
is fixed to be <code>-1</code>; TRUE if <code>1</code>. We can make the search space discrete because we employ
<code class="reqn">|\beta_1| = 1</code> scale normalizaion.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_sign_beta1.stg2">sign_beta1.stg2</code></td>
<td>
<p>Default is NULL. Similar to <code>sign_beta1.stg1</code>.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug).</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_cluster">cluster</code></td>
<td>
<p>default is FALSE, meaning do not use parallel computing for the genetic algorithm(GA).</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_s.tol">s.tol</code></td>
<td>
<p>tolerance level for the GA algorithm. This is input for parameter <code>solution.tolerance</code>
in function <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_it.num">it.num</code></td>
<td>
<p>the maximum GA iteration number</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is roughly the 
number individuals for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_domains1">Domains1</code></td>
<td>
<p>This is optional. If not NULL, please provide 
the two-column matrix for the searching range of coeffients in stage one.
The coefficient taking value of positive/negative one should not be included.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_domains2">Domains2</code></td>
<td>
<p>This is optional. If not NULL, please provide 
the two-column matrix for the searching range of coeffients in stage two.
The coefficient taking value of positive/negative one should not be included.</p>
</td></tr>
<tr><td><code id="Gene_Quantile_CenIPWE_DTR_+3A_penalty.level">Penalty.level</code></td>
<td>
<p>the level that determines which objective function to use. 
<code>Penalty.level = 0</code> indicates no regularization;
<code>Penalty.level = 1</code> indicates the value function estimation minus the means absolute average coefficient 
is the output, which is useful trick to achieve uniqueness of estimated optimal TR
when resolution of input response is low.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
# Simulate data
n=200
s_Diff_Time = 1
D &lt;- simJLSDdata(n, case="a")

# give regime classes
regimeClass.stg1 &lt;- as.formula(a0~x0)
regimeClass.stg2 &lt;- as.formula(a1~x1)

# extract columns that matches each stage's treatment regime formula
p.data1 &lt;- model.matrix(regimeClass.stg1, D)

# p.data2 would only contain observations with non-null value.
p.data2 &lt;- model.matrix(regimeClass.stg2, D)

txVec1 &lt;- D[, "a0"]
txVec2 &lt;- D[, "a1"]

# Eligibility flag
ELG &lt;- (D$censor_y  &gt;  s_Diff_Time)

# Build weights
D$deltaC &lt;- 1 - D$delta
survfit_all &lt;- survfit(Surv(censor_y, event = deltaC)~1, data=D)
survest &lt;- stepfun(survfit_all$time, c(1, survfit_all$surv))
D$ghat &lt;- survest(D$censor_y)
g_s_Diff_Time &lt;- survest(s_Diff_Time)
D$w_di_vec &lt;- rep(-999, n)
for(i in 1:n){
  if (!ELG[i]) {
      D$w_di_vec[i] &lt;- 0.5 * D$ghat[i]} else {
         D$w_di_vec[i] &lt;- 0.5* D$ghat[i] * 0.5
 }
}


 
fit1  &lt;- Gene_Quantile_CenIPWE_DTR(data=D, max=TRUE,
  tau=0.3,
  regimeClass.stg1 = regimeClass.stg1,
  regimeClass.stg2 = regimeClass.stg2,
  s_Diff_Time = s_Diff_Time,
  txVec1 = txVec1,
  txVec2 = txVec2,
  nvars.stg1=2,
  nvars.stg2=2,
  p.data1=p.data1,
  p.data2=p.data2,
  sign_beta1.stg1=FALSE,
  sign_beta1.stg2=NULL,
  p_level=1,
  cluster=FALSE,
  s.tol=1e-6,
  it.num=5,
  pop.size=6000,
  Domains1 = NULL,
  Domains2 = NULL,
  Penalty.level = 0
  )
 

</code></pre>

<hr>
<h2 id='IPWE_mean_IndCen'>Estimate the mean-optimal treatment regime for data with independently censored response</h2><span id='topic+IPWE_mean_IndCen'></span>

<h3>Description</h3>

<p>This function estimates the Mean-optimal Treatment Regime 
with censored response. 
The implemented function only works for scenarios in which 
treatment is binary and the censoring time
is independent of baseline covariates, treatment group and all potential survival times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPWE_mean_IndCen(data, regimeClass, moPropen = "BinaryRandom",
  Domains = NULL, cluster = FALSE, p_level = 1, s.tol = 1e-04,
  it.num = 8, pop.size = 3000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IPWE_mean_IndCen_+3A_data">data</code></td>
<td>
<p>a data.frame, containing variables in the <code>moPropen</code> and 
<code>RegimeClass</code> and also the response variables, namely <code>censor_y</code> as the censored response, 
and <code>delta</code> as the censoring indicator.</p>
</td></tr>
<tr><td><code id="IPWE_mean_IndCen_+3A_regimeclass">regimeClass</code></td>
<td>
<p>a formula specifying the class of treatment regimes to search,
e.g. if <code>regimeClass = a~x1+x2</code>, and then this function will 
search the class of treatment regimes
of the form 
</p>
<p style="text-align: center;"><code class="reqn">d(x) = I \left(\beta_0 +\beta_1  x_1 + \beta_2  x_2 &gt; 0\right).
</code>
</p>

<p>Polynomial arguments are also supported.</p>
</td></tr>
<tr><td><code id="IPWE_mean_IndCen_+3A_mopropen">moPropen</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1.
When <code>moPropen</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample will be plugged in as an estimate
of the propensity.
Otherwise, this argument should be a formula/string, based on which this function
will fit a logistic regression on the treatment level.  e.g. <code>a1~x1</code>.</p>
</td></tr>
<tr><td><code id="IPWE_mean_IndCen_+3A_domains">Domains</code></td>
<td>
<p>default is NULL. Otherwise, the object should be a <code>nvars *2</code> 
matrix used as the space of parameters, which will be supplied to <code>rgenoud::genoud</code>. 
<code>nvars</code> is the total number of parameters.</p>
</td></tr>
<tr><td><code id="IPWE_mean_IndCen_+3A_cluster">cluster</code></td>
<td>
<p>default is FALSE, meaning do not use parallel computing for the genetic algorithm(GA).</p>
</td></tr>
<tr><td><code id="IPWE_mean_IndCen_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug).</p>
</td></tr>
<tr><td><code id="IPWE_mean_IndCen_+3A_s.tol">s.tol</code></td>
<td>
<p>tolerance level for the GA algorithm. This is input for parameter <code>solution.tolerance</code>
in function <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="IPWE_mean_IndCen_+3A_it.num">it.num</code></td>
<td>
<p>the maximum GA iteration number</p>
</td></tr>
<tr><td><code id="IPWE_mean_IndCen_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is roughly the 
number individuals for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an object with 6 objects: 
</p>

<ul>
<li><p><code>coefficients</code> the estimated parameter indexing the mean-optimal treatment regime. 
Since we focus the space of linear treatment regimes, the estimated decision rule
cannot be uniquely identified without scale normalized. In this package,
we normalized by <code class="reqn">|\beta_1| = 1</code>, which was proposed in Horowitz (Horowitz 1992).     
</p>
</li>
<li><p><code>hatQ</code>  the estimated optimal marginal mean response 
</p>
</li>
<li><p><code>moPropen</code> log of the input argument of <code>moPropen</code>
</p>
</li>
<li><p><code>regimeClass</code> log of the input argument of <code>regimeClass</code>
</p>
</li>
<li><p><code>data_aug</code> Training data with additional columns used in the algorithm. Note that <code>data_aug</code> is used for plotting 
of survival function of the censoring time
</p>
</li>
<li><p><code>survfitCensorTime</code> the estimated survival function of the censoring time
</p>
</li></ul>



<h3>References</h3>

<p>Zhou Y (2018).
<em>Quantile-Optimal Treatment Regimes with Censored Data</em>.
Ph.D. thesis, University of Minnesota.
</p>
<p>Horowitz JL (1992).
&ldquo;A smoothed maximum score estimator for the binary response model.&rdquo;
<em>Econometrica: journal of the Econometric Society</em>, 505&ndash;531.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 1)
  ph &lt;- exp(-0.5+1*(x1+x2))/(1+exp(-0.5 + 1*(x1+x2)))
  a &lt;- rbinom(n = n, size = 1, prob=ph)
  c &lt;- 1.5 +  + runif(n = n, min=0, max=2)
  cmplt_y &lt;-  pmin(2+x1+x2 +  a*(1 - x1 - x2) +  (0.2 + a*(1+x1+x2)) * error, 4.4)
  censor_y &lt;- pmin(cmplt_y, c)
  delta &lt;- as.numeric(c &gt; cmplt_y)
  return(data.frame(x1=x1,x2=x2,a=a, censor_y = censor_y, delta=delta))
}
n &lt;- 400

D &lt;- GenerateData(n)
fit1 &lt;- IPWE_mean_IndCen(data = D, regimeClass = a~x1+x2)
                                 
   
</code></pre>

<hr>
<h2 id='IPWE_Qopt_DepCen_general'>Estimate Quantile-optimal Treatment Regime for covariates-dependent random censoring data</h2><span id='topic+IPWE_Qopt_DepCen_general'></span>

<h3>Description</h3>

<p>This function estimates the Quantile-optimal Treatment Regime 
for a given quantile level of interest
under the
assumption that the distribution of censoring time is independent of the set of potential
survival times given a set of baseline covariates and treatment actually received.
</p>
<p>More specifically, we do stratification by treatment first and then
used kernel smoothing to estimate local survival function of censoring time
for each treatment group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPWE_Qopt_DepCen_general(data, regimeClass, tau, Domains = NULL, bw,
  moPropen = "BinaryRandom", DepCens = NULL, UseTrueG = FALSE,
  trueG_value = NULL, cluster = FALSE, p_level = 1, s.tol = 1e-05,
  it.num = 8, pop.size = 5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_data">data</code></td>
<td>
<p>raw data.frame</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_regimeclass">regimeClass</code></td>
<td>
<p>the class of treatment regimes. e.g., 'txname ~ x1+x2'.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_tau">tau</code></td>
<td>
<p>the quantile of interest</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_domains">Domains</code></td>
<td>
<p>default is NULL.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_bw">bw</code></td>
<td>
<p>the bandwidth of local KM model (e.g. see Wang-wang 2008)</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_mopropen">moPropen</code></td>
<td>
<p>an optional string for the working model of treatment assignment</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_depcens">DepCens</code></td>
<td>
<p>an optional vector of baseline variable names that the censoring variable 
depends on. Note that
the treatment variable is always treated as dependent with the censoring time. 
If unspecified (<code>DepCens=NULL</code>), then all variables on the right side of 
<code>regimeClass</code> are used for <code>DepCens</code></p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_usetrueg">UseTrueG</code></td>
<td>
<p>logical. Whether the true survival probability of each patient is provided.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_trueg_value">trueG_value</code></td>
<td>
<p>default is NULL. 
IF <code>UseTrueG=FALSE</code>, <code>trueG_value</code> should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_cluster">cluster</code></td>
<td>
<p>default is FALSE. This can also be an object of the 'cluster' class 
returned by one of the makeCluster commands in the parallel package or
a vector of machine names so rgenoud::genoud can setup the cluster automatically.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_p_level">p_level</code></td>
<td>
<p>print level</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_s.tol">s.tol</code></td>
<td>
<p>tolerance level</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_it.num">it.num</code></td>
<td>
<p>the maximum iteration number</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_general_+3A_pop.size">pop.size</code></td>
<td>
<p>the initial population size</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 1)
  ph &lt;- exp(-0.5+1*(x1+x2))/(1+exp(-0.5 + 1*(x1+x2)))
  a &lt;- rbinom(n = n, size = 1, prob=ph)
  c &lt;- 1.5 +  + runif(n = n, min=0, max=2)
  cmplt_y &lt;-  pmin(2+x1+x2 +  a*(1 - x1 - x2) +  (0.2 + a*(1+x1+x2)) * error, 4.4)
  censor_y &lt;- pmin(cmplt_y, c)
  delta &lt;- as.numeric(c &gt; cmplt_y)
  return(data.frame(x1=x1,x2=x2,a=a, censor_y = censor_y, delta=delta))
}

                        
          

n &lt;- 400
data &lt;- GenerateData(n)
fit1 &lt;- IPWE_Qopt_DepCen_general(data = data, regimeClass = a~x1+x2, moPropen = a~x1+x2,
                                 tau = 0.2, bw = 20/n, 
                                 pop.size=3000, it.num = 3)
                                 
</code></pre>

<hr>
<h2 id='IPWE_Qopt_DepCen_trt'>Estimate the Quantile-opt Treatment Regime under the assumption that the censoring
time's distribution only depends on treatment level</h2><span id='topic+IPWE_Qopt_DepCen_trt'></span>

<h3>Description</h3>

<p>Here we assume the censoring variable is independent of covariates 
and potential outcomes 
given the treatment assignment. For example, if evidence shows that patients at 
certain treatment level are prone to experience censoring earlier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPWE_Qopt_DepCen_trt(data, regimeClass, tau, moPropen = "BinaryRandom",
  cluster = FALSE, p_level = 1, s.tol = 1e-04, it.num = 8,
  pop.size = 6000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IPWE_Qopt_DepCen_trt_+3A_data">data</code></td>
<td>
<p>raw data.frame</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_trt_+3A_regimeclass">regimeClass</code></td>
<td>
<p>a formula specifying the class of treatment regimes to search,
e.g. if <code>regimeClass = a~x1+x2</code>, and then this function will 
search the class of treatment regimes
of the form 
</p>
<p style="text-align: center;"><code class="reqn">d(x) = I \left(\beta_0 +\beta_1  x_1 + \beta_2  x_2 &gt; 0\right).
</code>
</p>

<p>Polynomial arguments are also supported.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_trt_+3A_tau">tau</code></td>
<td>
<p>the quantile of interest</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_trt_+3A_mopropen">moPropen</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1.
When <code>moPropen</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample will be plugged in as an estimate
of the propensity.
Otherwise, this argument should be a formula/string, based on which this function
will fit a logistic regression on the treatment level.  e.g. <code>a1~x1</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_trt_+3A_cluster">cluster</code></td>
<td>
<p>default is FALSE, meaning do not use parallel computing for the genetic algorithm(GA).</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_trt_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug).</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_trt_+3A_s.tol">s.tol</code></td>
<td>
<p>tolerance level for the GA algorithm. This is input for parameter <code>solution.tolerance</code>
in function <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_trt_+3A_it.num">it.num</code></td>
<td>
<p>the maximum GA iteration number</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DepCen_trt_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is roughly the 
number individuals for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>data is a dataframe that contains:
a(observed treatment assignment), 
censor_y, and
delta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData_DepCen_trt &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 1)
  ph &lt;- exp(-0.5+1*(x1+x2))/(1+exp(-0.5 + 1*(x1+x2)))
  a &lt;- rbinom(n = n, size = 1, prob=ph)
  c &lt;- 1 + 1*a + runif(n = n, min=0, max=2)
   # distribution of `c' depends on treatment level `a'
  cmplt_y &lt;-  pmin(2+x1+x2 +  a*(1 - x1 - x2) +  (0.2 + a*(1+x1+x2)) * error, 4.4)
  censor_y &lt;- pmin(cmplt_y, c)
  delta &lt;- as.numeric(c &gt; cmplt_y)
  return(data.frame(x1=x1,x2=x2,a=a, censor_y = censor_y, delta=delta))
}
                        

n &lt;- 400
data &lt;- GenerateData_DepCen_trt(n)
fit1 &lt;- IPWE_Qopt_DepCen_trt(data = data, regimeClass = a~x1+x2, moPropen = a~x1+x2,
                                 tau = 0.2)
                                 
   
</code></pre>

<hr>
<h2 id='IPWE_Qopt_DTR_IndCen'>Function to estimate the two-stage quantile-optimal dynamic treatment 
regime for censored data: the independent censoring Case</h2><span id='topic+IPWE_Qopt_DTR_IndCen'></span>

<h3>Description</h3>

<p>This function inplements the estimator of
two-stage quantile-optimal treatment regime with censored outcome 
by inverse probability of weighting, which is proposed in Chapter 3 of
(Zhou 2018).
We assume the censoring is independent of everything else, including the treatment
covariates, and potential outcomes.
</p>
<p>Specifically, we do grid search on the sign of the coefficient for the first non-intercept variables
in stage 1 and stage 2 and apply genetic algorithm on the remaining coeffients simultaneously.
So if stage one has d1 covariates excluding the intercept, stage two has d2, the
resulting coefficient has dimension d1+d2+2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPWE_Qopt_DTR_IndCen(data, tau, regimeClass.stg1, regimeClass.stg2,
  s_Diff_Time = 1, moPropen1 = "BinaryRandom",
  moPropen2 = "BinaryRandom", sign_beta1.stg1 = NULL,
  sign_beta1.stg2 = NULL, Penalty.level = 0, s.tol = 1e-06,
  it.num = 4, max = TRUE, Domains1 = NULL, Domains2 = NULL,
  cluster = FALSE, p_level = 1, pop.size = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_data">data</code></td>
<td>
<p>a data.frame, containing variables in the <code>moPropen</code> and 
<code>RegimeClass</code> and also the response variables, namely <code>censor_y</code> as the censored response, 
and <code>delta</code> as the censoring indicator.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_tau">tau</code></td>
<td>
<p>a value between 0 and 1. This is the quantile of interest.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_regimeclass.stg1">regimeClass.stg1</code></td>
<td>
<p>a formula specifying the class of treatment regimes for the first stage. 
For details of the general formulation of a linear treatment regime
see <code>regimeClass</code> in <code><a href="#topic+IPWE_Qopt_IndCen">IPWE_Qopt_IndCen</a></code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_regimeclass.stg2">regimeClass.stg2</code></td>
<td>
<p>a formula specifying the class of treatment regimes for the second stage</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_s_diff_time">s_Diff_Time</code></td>
<td>
<p>Numeric. The fixed length of time between the first stage treatment and the
second stage treatment</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_mopropen1">moPropen1</code></td>
<td>
<p>the first stage propensity score model. Default is &quot;BinaryRandom&quot;.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_mopropen2">moPropen2</code></td>
<td>
<p>the second stage propensity score model. Default is &quot;BinaryRandom&quot;.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_sign_beta1.stg1">sign_beta1.stg1</code></td>
<td>
<p>Is sign of the coefficient for the first non-intercept 
variable for the first stage known? Default is NULL, meaning user does not have contraint on
the sign;
FALSE if the coefficient for the first continuous variable 
is fixed to be <code>-1</code>; TRUE if <code>1</code>. We can make the search space discrete because we employ
<code class="reqn">|\beta_1| = 1</code> scale normalizaion.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_sign_beta1.stg2">sign_beta1.stg2</code></td>
<td>
<p>Default is NULL. Similar to <code>sign_beta1.stg1</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_penalty.level">Penalty.level</code></td>
<td>
<p>0: stop if the marginal quantiles cannot be further optimized; 1: continue
the search among treatment regimes with with same value for the TR
with the smallest intended proportion of treatment.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_s.tol">s.tol</code></td>
<td>
<p>tolerance level for the GA algorithm. This is input for parameter <code>solution.tolerance</code>
in function <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_it.num">it.num</code></td>
<td>
<p>the maximum GA iteration number</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_max">max</code></td>
<td>
<p>logical. TRUE if the goal is maximization of the quantile. FALSE is the goal is minimization of the quantile.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_domains1">Domains1</code></td>
<td>
<p>This is optional. If not NULL, please provide 
the two-column matrix for the searching range of coeffients in stage one.
The coefficient taking value of positive/negative one should not be included.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_domains2">Domains2</code></td>
<td>
<p>This is optional. If not NULL, please provide 
the two-column matrix for the searching range of coeffients in stage two.
The coefficient taking value of positive/negative one should not be included.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_cluster">cluster</code></td>
<td>
<p>default is FALSE, meaning do not use parallel computing for the genetic algorithm(GA).</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug).</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_DTR_IndCen_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is roughly the 
number individuals for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In our setting, if a subject was censored or had experienced the event of interest
before <code>s_Diff_Time</code> units of time had elapsed after the first stage of treatment,
s/he would not be eligible to receive a second stage treatment.
</p>


<h3>Author(s)</h3>

<p>Yu Zhou, <a href="mailto:zhou0269@umn.edu">zhou0269@umn.edu</a>
</p>


<h3>References</h3>

<p>Zhou Y (2018).
<em>Quantile-Optimal Treatment Regimes with Censored Data</em>.
Ph.D. thesis, University of Minnesota.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
D &lt;- simJLSDdata(400, case="a")
fit_2stage &lt;-IPWE_Qopt_DTR_IndCen(data=D, tau= 0.3, regimeClass.stg1 = a0~x0,
                     regimeClass.stg2 = a1~x1,
                     sign_beta1.stg1 = FALSE,
                     sign_beta1.stg2 = FALSE)




</code></pre>

<hr>
<h2 id='IPWE_Qopt_IndCen'>Function to estimate the quantile-optimal treatment regime: 
the independent censoring Case</h2><span id='topic+IPWE_Qopt_IndCen'></span>

<h3>Description</h3>

<p>This function implements the estimation method proposed in Chapter 2 of
(Zhou 2018). It estimates the quantile-optimal treatment regime 
for a given quantile level of interest from a single-stage clinical randomized
experiment or 
a single-stage observational study under the independent censoring assumption. In other
words, we estimate the parameters indexing the quantile-optimal treatment regime.
</p>
<p>Our assumption of independent censoring means
the distribution of the censoring time is the same 
conditional on baseline covariates, treatment group and the two potential survival times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPWE_Qopt_IndCen(data, regimeClass, tau, moPropen = "BinaryRandom",
  Domains = NULL, cluster = FALSE, p_level = 1, s.tol = 1e-04,
  it.num = 8, pop.size = 6000, sign_beta1 = NULL,
  Penalty.level = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IPWE_Qopt_IndCen_+3A_data">data</code></td>
<td>
<p>a data.frame, containing variables in the <code>moPropen</code> and 
<code>RegimeClass</code> and also the response variables, namely <code>censor_y</code> as the censored response, 
and <code>delta</code> as the censoring indicator.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_regimeclass">regimeClass</code></td>
<td>
<p>a formula specifying the class of treatment regimes to search,
e.g. if <code>regimeClass = a~x1+x2</code>, and then this function will 
search the class of treatment regimes
of the form 
</p>
<p style="text-align: center;"><code class="reqn">d(x) = I \left(\beta_0 +\beta_1  x_1 + \beta_2  x_2 &gt; 0\right).
</code>
</p>

<p>Polynomial arguments are also supported.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_tau">tau</code></td>
<td>
<p>a value between 0 and 1. This is the quantile of interest.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_mopropen">moPropen</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1.
When <code>moPropen</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample will be plugged in as an estimate
of the propensity.
Otherwise, this argument should be a formula/string, based on which this function
will fit a logistic regression on the treatment level.  e.g. <code>a1~x1</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_domains">Domains</code></td>
<td>
<p>default is NULL. Otherwise, the object should be a <code>nvars *2</code> 
matrix used as the space of parameters, which will be supplied to <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_cluster">cluster</code></td>
<td>
<p>default is FALSE, meaning do not use parallel computing for the genetic algorithm(GA).</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug).</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_s.tol">s.tol</code></td>
<td>
<p>tolerance level for the GA algorithm. This is input for parameter <code>solution.tolerance</code>
in function <code>rgenoud::genoud</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_it.num">it.num</code></td>
<td>
<p>the maximum GA iteration number</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is roughly the 
number individuals for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_sign_beta1">sign_beta1</code></td>
<td>
<p>logical. Default is NULL. FALSE if the coefficient for the first continuous variable is fixed to be negative one; TRUE if positive one.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_IndCen_+3A_penalty.level">Penalty.level</code></td>
<td>
<p>0: stop if the marginal quantiles cannot be further optimized; 1: continue
the search among treatment regimes with with same value for the TR
with the smallest intended proportion of treatment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input argument <code>data</code> is the dataframe that contains:
</p>
    
<ol>
<li> <p><code>a</code> observed treatment assignment
</p>
</li>
<li> <p><code>censor_y</code> the censored response variable
</p>
</li>
<li> <p><code>delta</code> the censoring indicator
</p>
</li></ol>

<p>The naming of these three columns should be strict.
</p>
<p>Note that this function currently only works for scenarios in which 
treatment is binary.
</p>


<h3>References</h3>

<p>Zhou Y (2018).
<em>Quantile-Optimal Treatment Regimes with Censored Data</em>.
Ph.D. thesis, University of Minnesota.
</p>
<p>Horowitz JL (1992).
&ldquo;A smoothed maximum score estimator for the binary response model.&rdquo;
<em>Econometrica: journal of the Econometric Society</em>, 505&ndash;531.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     
GenerateData &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 1)
  ph &lt;- exp(-0.5+1*(x1+x2))/(1+exp(-0.5 + 1*(x1+x2)))
  a &lt;- rbinom(n = n, size = 1, prob=ph)
  c &lt;- 1 + 1*a + runif(n = n, min=0, max=2)
  cmplt_y &lt;-  pmin(2+x1+x2 +  a*(1 - x1 - x2) +  (0.2 + a*(1+x1+x2)) * error, 4.4)
  censor_y &lt;- pmin(cmplt_y, c)
  delta &lt;- as.numeric(c &gt; cmplt_y)
  return(data.frame(x1=x1,x2=x2,a=a, censor_y = censor_y, delta=delta))
}
n &lt;- 400

data &lt;- GenerateData(n)
fit1 &lt;- IPWE_Qopt_IndCen(data = data, regimeClass = a~x1+x2, tau=0.25)

# We can used the returned model to visualize the Kaplan-meier
# estimate of survival function of the censoring time variable,
# justified by the independent censoring assumption.
library(survminer)
ggsurvplot(fit1$survfitCensorTime, data=fit1$data_aug, risk.table = TRUE)
 

 
</code></pre>

<hr>
<h2 id='LocalKM'>Kernel-based Local Kaplan-Meier Estimator</h2><span id='topic+LocalKM'></span>

<h3>Description</h3>

<p>This is the local KM estimator customized for this library to run
in batch mode.
It returns the estimated conditional survival probabilities given a user specified
set of covariate names that the survival time depends on,
a.k.a  <code class="reqn">F(T &gt; y_0 \mid x_0).</code>
</p>
<p>More specifically, for uncensored data points, we return <code> (1 - <a href="#topic+tauhat_func">tauhat_func</a>()) </code>.
If the observed data point is censored, then this function returns value -1
as a flag meaning we cannot .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocalKM(D, bw, NamesCov)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LocalKM_+3A_d">D</code></td>
<td>
<p>a data.frame with column <code>censor_y</code>, column <code>delta</code>, and additional covaraites.</p>
</td></tr>
<tr><td><code id="LocalKM_+3A_bw">bw</code></td>
<td>
<p>the bandwidth parameter</p>
</td></tr>
<tr><td><code id="LocalKM_+3A_namescov">NamesCov</code></td>
<td>
<p>the vector of column names in data.frame <code>D</code> such that the
survival time depends on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of estimated conditional survival probability evaluated at the 
observed actual survival time on the same individual
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 1)
  ph &lt;- exp(-0.5+1*(x1+x2))/(1+exp(-0.5 + 1*(x1+x2)))
  a &lt;- rbinom(n = n, size = 1, prob=ph)
  c &lt;- 1.5 +  + runif(n = n, min=0, max=2)
  cmplt_y &lt;-  pmin(2+x1+x2 +  a*(1 - x1 - x2) +  (0.2 + a*(1+x1+x2)) * error, 4.4)
  censor_y &lt;- pmin(cmplt_y, c)
  delta &lt;- as.numeric(c &gt; cmplt_y)
  return(data.frame(x1=x1,x2=x2,a=a, censor_y = censor_y, delta=delta))
}
n &lt;- 20
D &lt;- GenerateData(n)
mean_hat &lt;- LocalKM(D, 5, c("x1","x2"))


</code></pre>

<hr>
<h2 id='simJLSDdata'>Function to generate simulation data from a sequentially randomized
experiment designed in (Jiang et al. 2017)</h2><span id='topic+simJLSDdata'></span>

<h3>Description</h3>

<p>Function to generate simulation data from a sequentially randomized
experiment designed in (Jiang et al. 2017)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simJLSDdata(n, case = "a", s_Diff_Time = 1, C_max = 5,
  Censored = TRUE, fix_x0_value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simJLSDdata_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simJLSDdata_+3A_case">case</code></td>
<td>
<p>string. One of &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, corresponding to three models.</p>
</td></tr>
<tr><td><code id="simJLSDdata_+3A_s_diff_time">s_Diff_Time</code></td>
<td>
<p>Numeric. Default is 1. This is the length of time between two stages of treatment</p>
</td></tr>
<tr><td><code id="simJLSDdata_+3A_c_max">C_max</code></td>
<td>
<p>Numeric. Default is 5. This the upper bound of the uniform distribution of the 
censoring time variable. Changing this value shifts the overall censoring rate easily.</p>
</td></tr>
<tr><td><code id="simJLSDdata_+3A_censored">Censored</code></td>
<td>
<p>Boolean. Default is TRUE. Whether the data has censoring or not. If TRUE, all survival time
would not be censored at all in the returned data.</p>
</td></tr>
<tr><td><code id="simJLSDdata_+3A_fix_x0_value">fix_x0_value</code></td>
<td>
<p>Numeric. Default is Null. If supplied, it will generate simulated 
data with a fixed value, <code>fix_x0_value</code>, of the univariate baseline covarate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generative model is proposed in (Jiang et al. 2017), Section 5, the second example. 
It uniformly defined three
sets of conditional distributions of the survival times given the observable
covariates at each stage within the same framework.
</p>
<p>All three models satisfy the independent censoring assumption.
</p>


<h3>Value</h3>

<p>This function returns a data.frame with simulated subject trajectories.
</p>

<ul>
<li><p><code>x0</code> the baseline covariate, always observable at relative time point 0; 
</p>
</li>
<li><p><code>a0</code> the observed first-stage treatment level at relative time point 0;
</p>
</li>
<li><p><code>x1</code> an updated covariate observable to the relative time point 
<code>s_Diff_Time</code>, when the 
a second stage treatment is scheduled
</p>
</li>
<li><p><code>a1</code> the observed second-stage treatment level at relative time point <code>s_Diff_Time</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Jiang R, Lu W, Song R, Davidian M (2017).
&ldquo;On estimation of optimal treatment regimes for maximizing t-year survival probability.&rdquo;
<em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, <b>79</b>(4), 1165&ndash;1185.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataA &lt;- simJLSDdata(500,case="a")
dataB &lt;- simJLSDdata(500,case="b")
dataC &lt;- simJLSDdata(500,case="c")

</code></pre>

<hr>
<h2 id='tauhat_func'>Kernel-based Local Kaplan-Meier Estimator for the Conditional Probability of the Survival Time</h2><span id='topic+tauhat_func'></span>

<h3>Description</h3>

<p>This function estimates the value of
</p>
<p style="text-align: center;"><code class="reqn">F(T &lt;= y_0 \mid x_0),</code>
</p>

<p>the conditional cumulative distribution function of a survival time <code class="reqn">T</code> 
given covaraites vector <code class="reqn">x_0</code> 
at value <code class="reqn">y_0</code>.
This estimator is described in detail in (Wang and Wang 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauhat_func(y0, x0, z, x, delta, bw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tauhat_func_+3A_y0">y0</code></td>
<td>
<p>the vector of censored outcome of a single observation</p>
</td></tr>
<tr><td><code id="tauhat_func_+3A_x0">x0</code></td>
<td>
<p>the vector of given covariate of a single observation</p>
</td></tr>
<tr><td><code id="tauhat_func_+3A_z">z</code></td>
<td>
<p>observed vector of response variable from observed data</p>
</td></tr>
<tr><td><code id="tauhat_func_+3A_x">x</code></td>
<td>
<p>the observed matrix of covariates, the dimension is # of observations by number of covariates. 
Note that the vector of ones should NOT be included in <code>x</code>.</p>
</td></tr>
<tr><td><code id="tauhat_func_+3A_delta">delta</code></td>
<td>
<p>the vector of censoring indicators</p>
</td></tr>
<tr><td><code id="tauhat_func_+3A_bw">bw</code></td>
<td>
<p>the scalar bandwidth parameter in kernel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For cases with multivariate covariates, we adopted a product kernel. 
For example, in the bivariate case we use </p>
<p style="text-align: center;"><code class="reqn">K(x_1, x_2) = K_1(x_1) K_2(x_2),</code>
</p>

<p>where <code class="reqn">K_1</code> and <code class="reqn">K_2</code> are both biquadratickernel functions.
</p>


<h3>References</h3>

<p>Wang HJ, Wang L (2009).
&ldquo;Locally weighted censored quantile regression.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>104</b>(487), 1117&ndash;1128.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tauhat_func(y0=10, x0=c(2,3), z=c(10, 12, 11), 
            x=matrix(c(1,1,2,2,3,3), nrow=3, byrow=TRUE), 
            delta=c(1,1,0), bw=10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
