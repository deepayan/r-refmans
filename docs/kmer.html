<!DOCTYPE html><html><head><title>Help for package kmer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kmer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cluster'><p>Divisive k-means clustering.</p></a></li>
<li><a href='#kcount'><p>K-mer counting.</p></a></li>
<li><a href='#kdistance'><p>K-mer distance matrix computation.</p></a></li>
<li><a href='#kmer'><p>Fast K-mer Counting and Clustering for Biological Sequence Analysis.</p></a></li>
<li><a href='#mbed'><p>Convert sequences to vectors of distances to a subset of seed sequences.</p></a></li>
<li><a href='#otu'><p>Cluster sequences into operational taxonomic units.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast K-Mer Counting and Clustering for Biological Sequence
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Shaun Wilkinson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shaun Wilkinson &lt;shaunpwilkinson@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains tools for rapidly computing distance matrices 
    and clustering large sequence datasets using fast alignment-free 
    k-mer counting and recursive k-means partitioning. 
    See Vinga and Almeida (2003) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtg005">doi:10.1093/bioinformatics/btg005</a>&gt; 
    for a review of k-mer counting methods and applications for 
    biological sequence analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/shaunpwilkinson/kmer">http://github.com/shaunpwilkinson/kmer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/shaunpwilkinson/kmer/issues">http://github.com/shaunpwilkinson/kmer/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>openssl, phylogram, Rcpp (&ge; 0.12.13)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape (&ge; 4.0), dendextend, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-20 01:35:03 UTC; shaun</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-20 05:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cluster'>Divisive k-means clustering.</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>This function recursively splits a sequence set into smaller and smaller subsets,
returning a &quot;dendrogram&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(x, k = 5, residues = NULL, gap = "-", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_x">x</code></td>
<td>
<p>a list or matrix of sequences, possibly an object of class
<code>"DNAbin"</code> or <code>"AAbin"</code>.</p>
</td></tr>
<tr><td><code id="cluster_+3A_k">k</code></td>
<td>
<p>integer. The k-mer size required.</p>
</td></tr>
<tr><td><code id="cluster_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Specifying the residue alphabet is therefore
recommended unless the sequence list is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="cluster_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix
(if applicable). Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects.
Defaults to &quot;-&quot; otherwise.</p>
</td></tr>
<tr><td><code id="cluster_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>kmeans</code> (not including
<code>centers</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a tree by successively splitting
the dataset into smaller and smaller subsets (recursive
partitioning). This is a divisive, or &quot;top-down&quot; approach to tree-building,
as opposed to agglomerative &quot;bottom-up&quot; methods such as neighbor joining
and UPGMA. It is particularly useful for large large datasets with many sequences
(<em>n</em> &gt; 10,000) since the need to compute a large <em>n</em> * <em>n</em>
distance matrix is circumvented.
Instead, a matrix of k-mer counts is computed, and split recursively row-wise
using a k-means clustering algorithm (<em>k</em> = 2). This effectively reduces
the time and memory complexity from quadratic to linear, while generally
maintaining comparable accuracy.
</p>
<p>If a more accurate tree is required, users can increase the value
of <code>nstart</code> passed to <code>kmeans</code> <em>via</em> the <code>...</code> argument.
While this can increase computation time, it can improve tree accuracy
considerably.
</p>
<p>DNA and amino acid sequences can be passed to the function either as
a list of non-aligned sequences or a matrix of aligned sequences,
preferably in the &quot;DNAbin&quot; or &quot;AAbin&quot; raw-byte format
(Paradis et al 2004, 2012; see the <code><a href="ape.html#topic+ape">ape</a></code> package
documentation for more information on these S3 classes).
Character sequences are supported; however ambiguity codes may
not be recognized or treated appropriately, since raw ambiguity
codes are counted according to their underlying residue frequencies
(e.g. the 5-mer &quot;ACRGT&quot; would contribute 0.5 to the tally for &quot;ACAGT&quot;
and 0.5 to that of &quot;ACGGT&quot;).
</p>
<p>To minimize computation time when counting longer k-mers (k &gt; 3),
amino acid sequences in the raw &quot;AAbin&quot; format are automatically
compressed using the Dayhoff-6 alphabet as detailed in Edgar (2004).
Note that amino acid sequences will not be compressed if they
are supplied as a list of character vectors rather than an &quot;AAbin&quot;
object, in which case the k-mer length should be reduced
(k &lt; 4) to avoid excessive memory use and computation time.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"dendrogram"</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Edgar RC (2004) Local homology recognition and distance measures in
linear time using compressed amino acid alphabets.
<em>Nucleic Acids Research</em>, <strong>32</strong>, 380-385.
</p>
<p>Paradis E, Claude J, Strimmer K, (2004) APE: analyses of phylogenetics
and evolution in R language. <em>Bioinformatics</em> <strong>20</strong>, 289-290.
</p>
<p>Paradis E (2012) Analysis of Phylogenetics and Evolution with R
(Second Edition). Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kcount">kcount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Cluster the woodmouse dataset (ape package)
library(ape)
data(woodmouse)
## trim gappy ends to subset global alignment
woodmouse &lt;- woodmouse[, apply(woodmouse, 2, function(v) !any(v == 0xf0))]
## build tree divisively
suppressWarnings(RNGversion("3.5.0"))
set.seed(999)
woodmouse.tree &lt;- cluster(woodmouse, nstart = 5)
## plot tree
op &lt;- par(no.readonly = TRUE)
par(mar = c(5, 2, 4, 8) + 0.1)
plot(woodmouse.tree, main = "Woodmouse phylogeny", horiz = TRUE)
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='kcount'>K-mer counting.</h2><span id='topic+kcount'></span>

<h3>Description</h3>

<p>Count all k-letter words in a sequence or set of sequences
with a sliding window of length k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kcount(x, k = 5, residues = NULL, gap = "-", named = TRUE,
  compress = TRUE, encode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kcount_+3A_x">x</code></td>
<td>
<p>a matrix of aligned sequences, a list of unaligned sequences,
or a vector representing a single sequence.
Accepted modes are &quot;character&quot; and &quot;raw&quot; (the latter being applicable
for &quot;DNAbin&quot; and &quot;AAbin&quot; objects).</p>
</td></tr>
<tr><td><code id="kcount_+3A_k">k</code></td>
<td>
<p>integer representing the k-mer size. Defaults to 5.
Note that high values of k may be slow to compute and use a lot of
memory due to the large numbers of calculations required,
particularly when the residue alphabet is also large.</p>
</td></tr>
<tr><td><code id="kcount_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; the residue alphabet is automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Specifying the residue alphabet is therefore
recommended unless x is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="kcount_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix
(if applicable). Ignored for <code>"DNAbin"</code> and <code>"AAbin"</code> objects.
Defaults to &quot;-&quot; otherwise.</p>
</td></tr>
<tr><td><code id="kcount_+3A_named">named</code></td>
<td>
<p>logical. Should the k-mers be returned as column names in
the returned matrix? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="kcount_+3A_compress">compress</code></td>
<td>
<p>logical indicating whether to compress AAbin sequences
using the Dayhoff(6) alphabet for k-mer sizes exceeding 4.
Defaults to TRUE to avoid memory overflow and excessive computation time.</p>
</td></tr>
<tr><td><code id="kcount_+3A_encode">encode</code></td>
<td>
<p>logical indicating if the resulting matrix should be encoded
in raw bytes (output matrix can be decoded with <code>kmer:::.decodekc()</code>).
Note that the output will be rounded and have maximum k-mer count of 15.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a vector or matrix of k-mer counts
from a sequence or set of sequences using a sliding a window of length k.
DNA and amino acid sequences can be passed to the function either as
a list of non-aligned sequences or a matrix of aligned sequences,
preferably in the &quot;DNAbin&quot; or &quot;AAbin&quot; raw-byte format
(Paradis et al 2004, 2012; see the <code><a href="ape.html#topic+ape">ape</a></code> package
documentation for more information on these S3 classes).
Character sequences are supported; however ambiguity codes may
not be recognized or treated appropriately, since raw ambiguity
codes are counted according to their underlying residue frequencies
(e.g. the 5-mer &quot;ACRGT&quot; would contribute 0.5 to the tally for &quot;ACAGT&quot;
and 0.5 to that of &quot;ACGGT&quot;).
</p>
<p>To minimize computation time when counting longer k-mers (k &gt; 3),
amino acid sequences in the raw &quot;AAbin&quot; format are automatically
compressed using the Dayhoff-6 alphabet as detailed in Edgar (2004).
Note that amino acid sequences will not be compressed if they
are supplied as a list of character vectors rather than an &quot;AAbin&quot;
object, in which case the k-mer length should be reduced
(k &lt; 4) to avoid excessive memory use and computation time.
</p>


<h3>Value</h3>

<p>Returns a matrix of k-mer counts with one row for each sequence
and <em>n</em>^<em>k</em> columns (where <em>n</em> is the size of the
residue alphabet and <em>k</em> is the k-mer size)
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Edgar RC (2004) Local homology recognition and distance measures in
linear time using compressed amino acid alphabets.
<em>Nucleic Acids Research</em>, <strong>32</strong>, 380-385.
</p>
<p>Paradis E, Claude J, Strimmer K, (2004) APE: analyses of phylogenetics
and evolution in R language. <em>Bioinformatics</em> <strong>20</strong>, 289-290.
</p>
<p>Paradis E (2012) Analysis of Phylogenetics and Evolution with R
(Second Edition). Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdistance">kdistance</a></code> for k-mer distance matrix computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## compute a matrix of k-mer counts for the woodmouse
  ## data (ape package) using a k-mer size of 3
  library(ape)
  data(woodmouse)
  x &lt;- kcount(woodmouse, k = 3)
  x
  ## 64 columns for nucleotide 3-mers AAA, AAC, ... TTT
  ## convert to AAbin object and repeat the operation
  y &lt;- kcount(ape::trans(woodmouse, 2), k = 2)
  y
  ## 400 columns for amino acid 2-mers AA, AB, ... , YY
</code></pre>

<hr>
<h2 id='kdistance'>K-mer distance matrix computation.</h2><span id='topic+kdistance'></span>

<h3>Description</h3>

<p>Computes the matrix of k-mer distances between all pairwise comparisons
of a set of sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kdistance(x, k = 5, method = "edgar", residues = NULL, gap = "-",
  compress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdistance_+3A_x">x</code></td>
<td>
<p>a matrix of aligned sequences or a list of unaligned sequences.
Accepted modes are &quot;character&quot; and &quot;raw&quot; (the latter being applicable
for &quot;DNAbin&quot; and &quot;AAbin&quot; objects).</p>
</td></tr>
<tr><td><code id="kdistance_+3A_k">k</code></td>
<td>
<p>integer representing the k-mer size to be used for calculating
the distance matrix. Defaults to 5. Note that high values of k
may be slow to compute and use a lot of memory due to the large numbers
of calculations required, particularly when the residue alphabet is
also large.</p>
</td></tr>
<tr><td><code id="kdistance_+3A_method">method</code></td>
<td>
<p>a character string giving the k-mer distance measure
to be used. Currently the available options are <code>"edgar"</code> (default;
see Edgar (2004) for details) and the standard methods available for
the base function &quot;dist&quot; (&quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;,
&quot;binary&quot; and &quot;minkowski&quot;).</p>
</td></tr>
<tr><td><code id="kdistance_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; the residue alphabet is automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Specifying the residue alphabet is therefore
recommended unless x is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="kdistance_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix
(if applicable). Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects.
Defaults to &quot;-&quot; otherwise.</p>
</td></tr>
<tr><td><code id="kdistance_+3A_compress">compress</code></td>
<td>
<p>logical indicating whether to compress AAbin sequences
using the Dayhoff(6) alphabet for k-mer sizes exceeding 4.
Defaults to TRUE to avoid memory overflow and excessive computation time.</p>
</td></tr>
<tr><td><code id="kdistance_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>"as.dist"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the <em>n</em> * <em>n</em> k-mer distance matrix
(where <em>n</em> is the number of sequences), returning an object of class
<code>"dist"</code>. DNA and amino acid sequences can be passed to the function
either as a list of non-aligned sequences or as a matrix of aligned sequences,
preferably in the &quot;DNAbin&quot; or &quot;AAbin&quot; raw-byte format
(Paradis et al 2004, 2012; see the <code><a href="ape.html#topic+ape">ape</a></code> package
documentation for more information on these S3 classes).
Character sequences are supported; however ambiguity codes may
not be recognized or treated appropriately, since raw ambiguity
codes are counted according to their underlying residue frequencies
(e.g. the 5-mer &quot;ACRGT&quot; would contribute 0.5 to the tally for &quot;ACAGT&quot;
and 0.5 to that of &quot;ACGGT&quot;).
</p>
<p>To minimize computation time when counting longer k-mers (k &gt; 3),
amino acid sequences in the raw &quot;AAbin&quot; format are automatically
compressed using the Dayhoff-6 alphabet as detailed in Edgar (2004).
Note that amino acid sequences will not be compressed if they
are supplied as a list of character vectors rather than an &quot;AAbin&quot;
object, in which case the k-mer length should be reduced
(k &lt; 4) to avoid excessive memory use and computation time.
</p>


<h3>Value</h3>

<p>an object of class <code>"dist"</code>.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Edgar RC (2004) Local homology recognition and distance measures in
linear time using compressed amino acid alphabets.
<em>Nucleic Acids Research</em>, <strong>32</strong>, 380-385.
</p>
<p>Paradis E, Claude J, Strimmer K, (2004) APE: analyses of phylogenetics
and evolution in R language. <em>Bioinformatics</em> <strong>20</strong>, 289-290.
</p>
<p>Paradis E (2012) Analysis of Phylogenetics and Evolution with R
(Second Edition). Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kcount">kcount</a></code> for k-mer counting, and
<code><a href="#topic+mbed">mbed</a></code> for leaner distance matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## compute a k-mer distance matrix for the woodmouse
  ## dataset (ape package) using a k-mer size of 5
  library(ape)
  data(woodmouse)
  ### subset global alignment by removing gappy ends
  woodmouse &lt;- woodmouse[, apply(woodmouse, 2, function(v) !any(v == 0xf0))]
  ### compute the distance matrix
  woodmouse.dist &lt;- kdistance(woodmouse, k = 5)
  ### cluster and plot UPGMA tree
  woodmouse.tree &lt;- as.dendrogram(hclust(woodmouse.dist, "average"))
  plot(woodmouse.tree)
</code></pre>

<hr>
<h2 id='kmer'>Fast K-mer Counting and Clustering for Biological Sequence Analysis.</h2><span id='topic+kmer'></span><span id='topic+kmer-package'></span>

<h3>Description</h3>

<p>The kmer package contains tools for rapidly computing
distance matrices, building large trees, and clustering
operational taxonomic units using fast alignment-free
k-mer counting and divisive clustering techniques.
</p>


<h3>Functions</h3>

<p>A breif description of the primary <span class="pkg">kmer</span> functions are
provided with links to their help pages below.
</p>


<h3>K-mer counting</h3>


<ul>
<li> <p><code><a href="#topic+kcount">kcount</a></code> counts all k-letter words in a
sequence or set of sequences using a sliding window of
length k
</p>
</li></ul>



<h3>Distance matrix computation</h3>


<ul>
<li> <p><code><a href="#topic+kdistance">kdistance</a></code> calculates pairwise
distances between sequences based on k-mer counts
</p>
</li>
<li> <p><code><a href="#topic+mbed">mbed</a></code> embeds sequences as vectors of
k-mer distances to a set of seed' sequences
</p>
</li></ul>



<h3>Alignment-free clustering</h3>


<ul>
<li> <p><code><a href="#topic+cluster">cluster</a></code> builds a phylogenetic tree by
successively splitting a set of sequences
(recursive partitioning) based on k-mer counts
</p>
</li>
<li> <p><code><a href="#topic+otu">otu</a></code> heirarchically clusters a set of sequences
until a predefined furthest neighbor dissimilarity threshold is reached.
</p>
</li></ul>


<hr>
<h2 id='mbed'>Convert sequences to vectors of distances to a subset of seed sequences.</h2><span id='topic+mbed'></span>

<h3>Description</h3>

<p>This function computes a matrix of
distances from each sequence to a subset of 'seed' sequences using
the method outlined in Blacksheilds et al (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbed(x, seeds = NULL, k = 5, residues = NULL, gap = "-",
  counts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbed_+3A_x">x</code></td>
<td>
<p>a matrix of aligned sequences or a list of unaligned sequences.
Accepted modes are &quot;character&quot; and &quot;raw&quot; (the latter is for &quot;DNAbin&quot;
and &quot;AAbin&quot; objects).</p>
</td></tr>
<tr><td><code id="mbed_+3A_seeds">seeds</code></td>
<td>
<p>optional integer vector indicating which sequences should
be used as the seed sequences. If <code>seeds = NULL</code> a set of
log(<em>n</em>, 2)^2 non-identical sequences is randomly selected from the
sequence set (where <em>n</em> is the number of sequences; see Blacksheilds et al.
2010). Alternatively, if <code>seeds = 'all'</code> a standard <em>n</em> * <em>n</em>
distance matrix is computed.</p>
</td></tr>
<tr><td><code id="mbed_+3A_k">k</code></td>
<td>
<p>integer representing the k-mer size to be used for calculating
the distance matrix. Defaults to 5. Note that high values of k
may be slow to compute and use a lot of memory due to the large numbers
of calculations required, particularly when the residue alphabet is
also large.</p>
</td></tr>
<tr><td><code id="mbed_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Specifying the residue alphabet is therefore
recommended unless x is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="mbed_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix
(if applicable). Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects.
Defaults to &quot;-&quot; otherwise.</p>
</td></tr>
<tr><td><code id="mbed_+3A_counts">counts</code></td>
<td>
<p>logical indicating whether the (usually large) matrix of
k-mer counts should be returned as an attribute of the returned
object. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a <em>n</em> * log(<em>n</em>, 2)^2 k-mer distance matrix
(where <em>n</em> is the number of sequences), returning an object of class
<code>"mbed"</code>. If the number of sequences is less than or equal to 19, the full
<em>n</em> * <em>n</em> distance matrix is produced (since the rounded up value of
log(<em>19</em>, 2)^2 is 19). Currently the only distance measure supported is
that of Edgar (2004).
</p>
<p>For maximum information retention following the embedding process
it is generally desirable to select the seed sequences based on their
uniqueness, rather than simply selecting a random subset
(Blackshields et al. 2010).
Hence if 'seeds' is set to NULL (the default setting) the the 'mbed'
function selects the subset by clustering the sequence set into
<em>t</em> groups using the k-means algorithm (<em>k</em> = <em>t</em>),
and choosing one representative from each group.
Users can alternatively pass an integer vector (as in the above example)
to specify the seeds manually. See Blackshields et al (2010) for other
seed selection options.
</p>
<p>DNA and amino acid sequences can be passed to the function
either as a list of non-aligned sequences or as a matrix of aligned sequences,
preferably in the &quot;DNAbin&quot; or &quot;AAbin&quot; raw-byte format
(Paradis et al 2004, 2012; see the <code><a href="ape.html#topic+ape">ape</a></code> package
documentation for more information on these S3 classes).
Character sequences are supported; however ambiguity codes may
not be recognized or treated appropriately, since raw ambiguity
codes are counted according to their underlying residue frequencies
(e.g. the 5-mer &quot;ACRGT&quot; would contribute 0.5 to the tally for &quot;ACAGT&quot;
and 0.5 to that of &quot;ACGGT&quot;).
</p>
<p>To minimize computation time when counting longer k-mers (k &gt; 3),
amino acid sequences in the raw &quot;AAbin&quot; format are automatically
compressed using the Dayhoff-6 alphabet as detailed in Edgar (2004).
Note that amino acid sequences will not be compressed if they
are supplied as a list of character vectors rather than an &quot;AAbin&quot;
object, in which case the k-mer length should be reduced
(k &lt; 4) to avoid excessive memory use and computation time.
</p>
<p>Note that agglomerative (bottom-up) tree-building methods
such as neighbor-joining and UPGMA depend on a full
<em>n</em> * <em>n</em> distance matrix.
See the <code><a href="#topic+kdistance">kdistance</a></code> function for details on computing
symmetrical distance matrices.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"mbed"</code>, whose primary object is
an <em>n</em> * log(<em>n</em>, 2)^2 matrix
(where <em>n</em> is the number of sequences). The returned
object contains additional attributes including an
integer vector of seed sequence indices (&quot;seeds&quot;), a logical vector
identifying the duplicated sequences (&quot;duplicates&quot;), an integer vector
giving the matching indices of the non-duplicated sequences (&quot;pointers&quot;),
a character vector of MD5 digests of the sequences (&quot;hashes&quot;),
an integer vector of sequence lengths (&quot;seqlengths&quot;), and if
<code>counts = TRUE</code>, the matrix of k-mer counts (&quot;kcounts&quot;;
see <code><a href="#topic+kcount">kcount</a></code> for details).
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Blackshields G, Sievers F, Shi W, Wilm A, Higgins DG (2010) Sequence embedding
for fast construction of guide trees for multiple sequence alignment.
<em>Algorithms for Molecular Biology</em>, <strong>5</strong>, 21.
</p>
<p>Edgar RC (2004) Local homology recognition and distance measures in
linear time using compressed amino acid alphabets.
<em>Nucleic Acids Research</em>, <strong>32</strong>, 380-385.
</p>
<p>Paradis E, Claude J, Strimmer K, (2004) APE: analyses of phylogenetics
and evolution in R language. <em>Bioinformatics</em> <strong>20</strong>, 289-290.
</p>
<p>Paradis E (2012) Analysis of Phylogenetics and Evolution with R
(Second Edition). Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kdistance">kdistance</a></code> for full <em>n</em> * <em>n</em> distance
matrix computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## compute an embedded k-mer distance matrix for the woodmouse
  ## dataset (ape package) using a k-mer size of 5
  library(ape)
  data(woodmouse)
  ## randomly select three sequences as seeds
  suppressWarnings(RNGversion("3.5.0"))
  set.seed(999)
  seeds &lt;- sample(1:15, size = 3)
  ## embed the woodmouse dataset in three dimensions
  woodmouse.mbed &lt;- mbed(woodmouse, seeds = seeds, k = 5)
  ## print the distance matrix (without attributes)
  print(woodmouse.mbed[,], digits = 2)
</code></pre>

<hr>
<h2 id='otu'>Cluster sequences into operational taxonomic units.</h2><span id='topic+otu'></span>

<h3>Description</h3>

<p>This function performs divisive heirarchical clustering on a set of
DNA sequences using sequential k-means partitioning,
returning an integer vector of OTU membership.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>otu(x, k = 5, threshold = 0.97, method = "central",
  residues = NULL, gap = "-", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="otu_+3A_x">x</code></td>
<td>
<p>a &quot;DNAbin&quot; object.</p>
</td></tr>
<tr><td><code id="otu_+3A_k">k</code></td>
<td>
<p>integer giving the k-mer size used to generate the input matrix
for k-means clustering.</p>
</td></tr>
<tr><td><code id="otu_+3A_threshold">threshold</code></td>
<td>
<p>numeric between 0 and 1 giving the OTU identity cutoff.
Defaults to 0.97.</p>
</td></tr>
<tr><td><code id="otu_+3A_method">method</code></td>
<td>
<p>the maximum distance criterion to use for terminating the
recursive partitioning procedure. Accepted options are &quot;central&quot; (splitting
stops if the similarity between the central sequence
and its farthest neighbor within the cluster is greater than the threshold),
&quot;centroid&quot; (splitting stops if the similarity between the centroid
and its farthest neighbor within the cluster is greater than the threshold),
and &quot;farthest&quot; (splitting
stops if the similarity between the two farthest sequences within the cluster
is greater than the threshold). Defaults to &quot;central&quot;.</p>
</td></tr>
<tr><td><code id="otu_+3A_residues">residues</code></td>
<td>
<p>either NULL (default; emitted residues are automatically
detected from the sequences), a case sensitive character vector
specifying the residue alphabet, or one of the character strings
&quot;RNA&quot;, &quot;DNA&quot;, &quot;AA&quot;, &quot;AMINO&quot;. Note that the default option can be slow for
large lists of character vectors. Specifying the residue alphabet is therefore
recommended unless the sequence list is a &quot;DNAbin&quot; or &quot;AAbin&quot; object.</p>
</td></tr>
<tr><td><code id="otu_+3A_gap">gap</code></td>
<td>
<p>the character used to represent gaps in the alignment matrix
(if applicable). Ignored for <code>"DNAbin"</code> or <code>"AAbin"</code> objects.
Defaults to &quot;-&quot; otherwise.</p>
</td></tr>
<tr><td><code id="otu_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>kmeans</code> (not including
<code>centers</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function clusters sequences into OTUs by first
generating a matrix of k-mer counts, and then splitting the matrix
into two subsets (row-wise) using the k-means algorithm (<em>k</em> = 2).
The splitting continues recursively until the farthest k-mer distance
in every cluster is below the threshold value.
</p>
<p>This is a divisive, or &quot;top-down&quot; approach to OTU clustering,
as opposed to agglomerative &quot;bottom-up&quot; methods.
It is particularly useful for large large datasets with many sequences
(<em>n</em> &gt; 10, 000) since the need to compute a large <em>n</em> * <em>n</em>
distance matrix is circumvented.
This effectively reduces the time and memory complexity from quadratic to linear,
while generally maintaining comparable accuracy.
</p>
<p>It is recommended to increase the value
of <code>nstart</code> passed to <code>kmeans</code> <em>via</em> the <code>...</code> argument
to at least 20.
While this can increase computation time, it can improve clustering accuracy
considerably.
</p>
<p>DNA and amino acid sequences can be passed to the function either as
a list of non-aligned sequences or a matrix of aligned sequences,
preferably in the &quot;DNAbin&quot; or &quot;AAbin&quot; raw-byte format
(Paradis et al 2004, 2012; see the <code><a href="ape.html#topic+ape">ape</a></code> package
documentation for more information on these S3 classes).
Character sequences are supported; however ambiguity codes may
not be recognized or treated appropriately, since raw ambiguity
codes are counted according to their underlying residue frequencies
(e.g. the 5-mer &quot;ACRGT&quot; would contribute 0.5 to the tally for &quot;ACAGT&quot;
and 0.5 to that of &quot;ACGGT&quot;).
</p>
<p>To minimize computation time when counting longer k-mers (k &gt; 3),
amino acid sequences in the raw &quot;AAbin&quot; format are automatically
compressed using the Dayhoff-6 alphabet as detailed in Edgar (2004).
Note that amino acid sequences will not be compressed if they
are supplied as a list of character vectors rather than an &quot;AAbin&quot;
object, in which case the k-mer length should be reduced
(k &lt; 4) to avoid excessive memory use and computation time.
</p>


<h3>Value</h3>

<p>a named integer vector of cluster membership with values ranging from 1 to
the total number of OTUs. Asterisks indicate the representative sequence within
each cluster.
</p>


<h3>Author(s)</h3>

<p>Shaun Wilkinson
</p>


<h3>References</h3>

<p>Edgar RC (2004) Local homology recognition and distance measures in
linear time using compressed amino acid alphabets.
<em>Nucleic Acids Research</em>, <strong>32</strong>, 380-385.
</p>
<p>Paradis E, Claude J, Strimmer K, (2004) APE: analyses of phylogenetics
and evolution in R language. <em>Bioinformatics</em> <strong>20</strong>, 289-290.
</p>
<p>Paradis E (2012) Analysis of Phylogenetics and Evolution with R
(Second Edition). Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Cluster the woodmouse dataset (from the ape package) into OTUs
library(ape)
data(woodmouse)
## trim gappy ends to subset global alignment
woodmouse &lt;- woodmouse[, apply(woodmouse, 2, function(v) !any(v == 0xf0))]
## cluster sequences into OTUs at 0.97 threshold with kmer size = 5
suppressWarnings(RNGversion("3.5.0"))
set.seed(999)
woodmouse.OTUs &lt;- otu(woodmouse, k = 5, threshold = 0.97, nstart = 20)
woodmouse.OTUs

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
