<!DOCTYPE html><html lang="en"><head><title>Help for package sovereign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sovereign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#covid_volatility_correction'><p>Lenza-Primiceri Covid Shock Correction</p></a></li>
<li><a href='#FEVD'><p>Estimate forecast error variance decomposition</p></a></li>
<li><a href='#HD'><p>Estimate historical decomposition</p></a></li>
<li><a href='#IRF'><p>Estimate impulse response functions</p></a></li>
<li><a href='#LP'><p>Estimate local projections</p></a></li>
<li><a href='#lp_irf'><p>Estimate impulse response functions</p></a></li>
<li><a href='#plot_error'><p>Chart residuals</p></a></li>
<li><a href='#plot_fevd'><p>Chart FEVDs</p></a></li>
<li><a href='#plot_forecast'><p>Chart forecasts</p></a></li>
<li><a href='#plot_hd'><p>Chart HDs</p></a></li>
<li><a href='#plot_individual_error'><p>Chart individual residuals</p></a></li>
<li><a href='#plot_individual_fevd'><p>Plot an individual FEVD</p></a></li>
<li><a href='#plot_individual_forecast'><p>Chart individual forecast</p></a></li>
<li><a href='#plot_individual_hd'><p>Plot an individual HD</p></a></li>
<li><a href='#plot_individual_irf'><p>Plot an individual IRF</p></a></li>
<li><a href='#plot_irf'><p>Chart IRFs</p></a></li>
<li><a href='#regimes'><p>Identify regimes via unsupervised ML algorithms</p></a></li>
<li><a href='#RLP'><p>Estimate regime-dependent local projections</p></a></li>
<li><a href='#rlp_irf'><p>Estimate regime-dependent impulse response functions</p></a></li>
<li><a href='#RVAR'><p>Estimate regime-dependent VAR, SVAR, or Proxy-SVAR</p></a></li>
<li><a href='#rvar_fevd'><p>Estimate regime-dependent forecast error variance decomposition</p></a></li>
<li><a href='#rvar_hd'><p>Estimate regime-dependent historical decomposition</p></a></li>
<li><a href='#rvar_irf'><p>Estimate regime-dependent impulse response functions</p></a></li>
<li><a href='#VAR'><p>Estimate VAR, SVAR, or Proxy-SVAR</p></a></li>
<li><a href='#var_fevd'><p>Estimate forecast error variance decomposition</p></a></li>
<li><a href='#var_hd'><p>Estimate historical decomposition</p></a></li>
<li><a href='#var_irf'><p>Estimate impulse response functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>State-Dependent Empirical Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for state-dependent 
  empirical analysis through both VAR- and local projection-based 
  state-dependent forecasts, impulse response functions, 
  historical decompositions, and forecast error variance decompositions.   </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tylerJPike/sovereign">https://github.com/tylerJPike/sovereign</a>,
<a href="https://tylerjpike.github.io/sovereign/">https://tylerjpike.github.io/sovereign/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tylerJPike/sovereign/issues">https://github.com/tylerJPike/sovereign/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, dplyr, future, furrr, ggplot2, gridExtra, lmtest,
lubridate, magrittr, mclust, purrr, randomForest, sandwich,
stats, stringr, strucchange, tidyr, xts, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, quantmod, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-04 15:38:06 UTC; tjpik</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler J. Pike [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler J. Pike &lt;tjpike7@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-04 17:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='covid_volatility_correction'>Lenza-Primiceri Covid Shock Correction</h2><span id='topic+covid_volatility_correction'></span>

<h3>Description</h3>

<p>Implement the deterministic volatility correction method of Lenza, Michele
and Giorgio Primiceri &quot;How to Estimate a VAR after March 2020&quot; (2020) [<a href="https://www.nber.org/papers/w27771">NBER Working Paper</a>].
Correction factors are estimated via maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covid_volatility_correction(var, theta_initial = c(5, 2, 1.5, 0.8))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covid_volatility_correction_+3A_var">var</code></td>
<td>
<p>VAR object</p>
</td></tr>
<tr><td><code id="covid_volatility_correction_+3A_theta_initial">theta_initial</code></td>
<td>
<p>double: four element vector with scaling parameters, theta in Lenza and Primiceri (2020)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>var object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_irf">var_irf()</a></code>
</p>
<p><code><a href="#topic+var_fevd">var_fevd()</a></code>
</p>
<p><code><a href="#topic+var_hd">var_hd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2018-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)

 # estimate VAR
 var =
   sovereign::VAR(
     data = Data,
     horizon = 10,
     freq = 'month',
     lag.ic = 'BIC',
     lag.max = 4)

# correct VAR for COVID shock
var = sovereign::covid_volatility_correction(var)

# impulse response functions
var.irf = sovereign::var_irf(var)

# forecast error variance decomposition
var.fevd = sovereign::var_fevd(var)

# historical shock decomposition
var.hd = sovereign::var_hd(var)



</code></pre>

<hr>
<h2 id='FEVD'>Estimate forecast error variance decomposition</h2><span id='topic+FEVD'></span>

<h3>Description</h3>

<p>Estimate the forecast error variance decomposition for VARs with
either short or 'IV-short' structural errors. See VAR
and RVAR documentation for details regarding structural errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEVD(model, horizon = 10, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FEVD_+3A_model">model</code></td>
<td>
<p>VAR or RVAR class object</p>
</td></tr>
<tr><td><code id="FEVD_+3A_horizon">horizon</code></td>
<td>
<p>int: number of periods</p>
</td></tr>
<tr><td><code id="FEVD_+3A_scale">scale</code></td>
<td>
<p>boolean: scale variable contribution as percent of total error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>long-form data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_fevd">var_fevd()</a></code>
</p>
<p><code><a href="#topic+RVAR">RVAR()</a></code>
</p>
<p><code><a href="#topic+rvar_fevd">rvar_fevd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)

 # estimate VAR
  var =
    sovereign::VAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      lag.ic = 'BIC',
      lag.max = 4)

# impulse response functions
var.irf = sovereign::IRF(var)

# forecast error variance decomposition
var.fevd = sovereign::FEVD(var)

# historical shock decomposition
var.hd = sovereign::HD(var)



</code></pre>

<hr>
<h2 id='HD'>Estimate historical decomposition</h2><span id='topic+HD'></span>

<h3>Description</h3>

<p>Estimate the historical decomposition for VARs with
either 'short' or 'IV-short' structural errors. See VAR
and RVAR documentation for details regarding structural errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HD(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HD_+3A_model">model</code></td>
<td>
<p>VAR or RVAR class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>long-from data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_hd">var_hd()</a></code>
</p>
<p><code><a href="#topic+RVAR">RVAR()</a></code>
</p>
<p><code><a href="#topic+rvar_hd">rvar_hd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)

 # estimate VAR
  var =
    sovereign::VAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      lag.ic = 'BIC',
      lag.max = 4)

# impulse response functions
var.irf = sovereign::IRF(var)

# forecast error variance decomposition
var.fevd = sovereign::FEVD(var)

# historical shock decomposition
var.hd = sovereign::HD(var)



</code></pre>

<hr>
<h2 id='IRF'>Estimate impulse response functions</h2><span id='topic+IRF'></span>

<h3>Description</h3>

<p>See VAR, RVAR, LP, and RLP documentation for details
regarding models and structural errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRF(
  model,
  horizon = 10,
  CI = c(0.1, 0.9),
  bootstrap.type = "auto",
  bootstrap.num = 100,
  bootstrap.parallel = FALSE,
  bootstrap.cores = -1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRF_+3A_model">model</code></td>
<td>
<p>VAR, RVAR, LP, or RLP class object</p>
</td></tr>
<tr><td><code id="IRF_+3A_horizon">horizon</code></td>
<td>
<p>int: number of periods</p>
</td></tr>
<tr><td><code id="IRF_+3A_ci">CI</code></td>
<td>
<p>numeric vector: c(lower ci bound, upper ci bound)</p>
</td></tr>
<tr><td><code id="IRF_+3A_bootstrap.type">bootstrap.type</code></td>
<td>
<p>string: bootstrapping technique to use ('auto', 'standard', or 'wild'); if auto then wild is used for IV or IV-short, else standard is used</p>
</td></tr>
<tr><td><code id="IRF_+3A_bootstrap.num">bootstrap.num</code></td>
<td>
<p>int: number of bootstraps</p>
</td></tr>
<tr><td><code id="IRF_+3A_bootstrap.parallel">bootstrap.parallel</code></td>
<td>
<p>boolean: create IRF draws in parallel</p>
</td></tr>
<tr><td><code id="IRF_+3A_bootstrap.cores">bootstrap.cores</code></td>
<td>
<p>int: number of cores to use in parallel processing; -1 detects and uses half the available cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with columns <code>target</code>, <code>shock</code>, <code>horizon</code>, <code>response.lower</code>, <code>response</code>, <code>response.upper</code>; regime-based models return a list with a data frame per regime.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var_irf">var_irf()</a></code>
</p>
<p><code><a href="#topic+rvar_irf">rvar_irf()</a></code>
</p>
<p><code><a href="#topic+lp_irf">lp_irf()</a></code>
</p>
<p><code><a href="#topic+rlp_irf">rlp_irf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)

 # estimate VAR
  var =
    sovereign::VAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      lag.ic = 'BIC',
      lag.max = 4
    )

 # impulse response function
 var.irf = sovereign::IRF(var)

  # local projection forecasts
  lp =
    sovereign::LP(
      data = Data,
      horizon = c(1:10),
      lag.ic = 'AIC',
      lag.max = 4,
      type =  'both',
      freq = 'month')

  # LP impulse response function
  lp.irf = sovereign::IRF(lp)



</code></pre>

<hr>
<h2 id='LP'>Estimate local projections</h2><span id='topic+LP'></span>

<h3>Description</h3>

<p>Estimate local projections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LP(
  data,
  horizons = 1,
  freq = "month",
  type = "const",
  p = 1,
  lag.ic = NULL,
  lag.max = NULL,
  NW = FALSE,
  NW_lags = NULL,
  NW_prewhite = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LP_+3A_data">data</code></td>
<td>
<p>data.frame, matrix, ts, xts, zoo: Endogenous regressors</p>
</td></tr>
<tr><td><code id="LP_+3A_horizons">horizons</code></td>
<td>
<p>int: forecast horizons</p>
</td></tr>
<tr><td><code id="LP_+3A_freq">freq</code></td>
<td>
<p>string: frequency of data ('day', 'week', 'month', 'quarter', or 'year')</p>
</td></tr>
<tr><td><code id="LP_+3A_type">type</code></td>
<td>
<p>string: type of deterministic terms to add ('none', 'const', 'trend', or 'both')</p>
</td></tr>
<tr><td><code id="LP_+3A_p">p</code></td>
<td>
<p>int: lags</p>
</td></tr>
<tr><td><code id="LP_+3A_lag.ic">lag.ic</code></td>
<td>
<p>string: information criterion to choose the optimal number of lags ('AIC' or 'BIC')</p>
</td></tr>
<tr><td><code id="LP_+3A_lag.max">lag.max</code></td>
<td>
<p>int: maximum number of lags to test in lag selection</p>
</td></tr>
<tr><td><code id="LP_+3A_nw">NW</code></td>
<td>
<p>boolean: Newey-West correction on variance-covariance matrix</p>
</td></tr>
<tr><td><code id="LP_+3A_nw_lags">NW_lags</code></td>
<td>
<p>int: number of lags to use in Newey-West correction</p>
</td></tr>
<tr><td><code id="LP_+3A_nw_prewhite">NW_prewhite</code></td>
<td>
<p>boolean: TRUE prewhite option for Newey-West correction (see sandwich::NeweyWest)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list object with elements <code>data</code>, <code>model</code>, <code>forecasts</code>, <code>residuals</code>; if there is more than one forecast horizon estimated, then <code>model</code>, <code>forecasts</code>, <code>residuals</code> will each be a list where each element corresponds to a single horizon
</p>


<h3>References</h3>


<ol>
<li><p> Jorda, Oscar &quot;<a href="https://www.aeaweb.org/articles?id=10.1257/0002828053828518">Estimation and Inference of Impulse Responses by Local Projections</a>&quot; 2005.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+LP">LP()</a></code>
</p>
<p><code><a href="#topic+lp_irf">lp_irf()</a></code>
</p>
<p><code><a href="#topic+RLP">RLP()</a></code>
</p>
<p><code><a href="#topic+rlp_irf">rlp_irf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # simple time series
  AA = c(1:100) + rnorm(100)
  BB = c(1:100) + rnorm(100)
  CC = AA + BB + rnorm(100)
  date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
  Data = data.frame(date = date, AA, BB, CC)

  # local projection forecasts
  lp =
    sovereign::LP(
      data = Data,
      horizon = c(1:10),
      lag.ic = 'AIC',
      lag.max = 4,
      type =  'both',
      freq = 'month')

  # impulse response function
  irf = sovereign::lp_irf(lp)



</code></pre>

<hr>
<h2 id='lp_irf'>Estimate impulse response functions</h2><span id='topic+lp_irf'></span>

<h3>Description</h3>

<p>Estimate impulse response functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_irf(lp, CI = c(0.1, 0.9), regime = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp_irf_+3A_lp">lp</code></td>
<td>
<p>LP output</p>
</td></tr>
<tr><td><code id="lp_irf_+3A_ci">CI</code></td>
<td>
<p>numeric vector: c(lower ci bound, upper ci bound)</p>
</td></tr>
<tr><td><code id="lp_irf_+3A_regime">regime</code></td>
<td>
<p>string: indicates regime index column of data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>long-form data.frame with one row per target-shock-horizon identifier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LP">LP()</a></code>
</p>
<p><code><a href="#topic+lp_irf">lp_irf()</a></code>
</p>
<p><code><a href="#topic+RLP">RLP()</a></code>
</p>
<p><code><a href="#topic+rlp_irf">rlp_irf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # simple time series
  AA = c(1:100) + rnorm(100)
  BB = c(1:100) + rnorm(100)
  CC = AA + BB + rnorm(100)
  date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
  Data = data.frame(date = date, AA, BB, CC)

  # local projection forecasts
  lp =
    sovereign::LP(
      data = Data,
      horizon = c(1:10),
      lag.ic = 'AIC',
      lag.max = 4,
      type =  'both',
      freq = 'month')

  # impulse response function
  irf = sovereign::lp_irf(lp)



</code></pre>

<hr>
<h2 id='plot_error'>Chart residuals</h2><span id='topic+plot_error'></span>

<h3>Description</h3>

<p>Chart residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_error(residuals, series = NULL, verticle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_error_+3A_residuals">residuals</code></td>
<td>
<p>data.frame: sovereign residuals object</p>
</td></tr>
<tr><td><code id="plot_error_+3A_series">series</code></td>
<td>
<p>string: series to plot  (default to all series)</p>
</td></tr>
<tr><td><code id="plot_error_+3A_verticle">verticle</code></td>
<td>
<p>boolean: If true then stack all plots into one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grid of ggplot2 graphs
</p>

<hr>
<h2 id='plot_fevd'>Chart FEVDs</h2><span id='topic+plot_fevd'></span>

<h3>Description</h3>

<p>Chart FEVDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fevd(fevd, responses = NULL, verticle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_fevd_+3A_fevd">fevd</code></td>
<td>
<p>fevd object</p>
</td></tr>
<tr><td><code id="plot_fevd_+3A_responses">responses</code></td>
<td>
<p>string vector: responses to plot</p>
</td></tr>
<tr><td><code id="plot_fevd_+3A_verticle">verticle</code></td>
<td>
<p>boolean: If true then stack all plots into one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grid of ggplot2 graphs
</p>

<hr>
<h2 id='plot_forecast'>Chart forecasts</h2><span id='topic+plot_forecast'></span>

<h3>Description</h3>

<p>Chart forecasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_forecast(forecasts, series = NULL, verticle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_forecast_+3A_forecasts">forecasts</code></td>
<td>
<p>data.frame: sovereign forecast object</p>
</td></tr>
<tr><td><code id="plot_forecast_+3A_series">series</code></td>
<td>
<p>string: series to plot (default to all series)</p>
</td></tr>
<tr><td><code id="plot_forecast_+3A_verticle">verticle</code></td>
<td>
<p>boolean: If true then stack all plots into one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grid of ggplot2 graphs
</p>

<hr>
<h2 id='plot_hd'>Chart HDs</h2><span id='topic+plot_hd'></span>

<h3>Description</h3>

<p>Chart HDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_hd(hd, verticle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_hd_+3A_hd">hd</code></td>
<td>
<p>hd object</p>
</td></tr>
<tr><td><code id="plot_hd_+3A_verticle">verticle</code></td>
<td>
<p>boolean: If true then stack all plots into one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grid of ggplot2 graphs
</p>

<hr>
<h2 id='plot_individual_error'>Chart individual residuals</h2><span id='topic+plot_individual_error'></span>

<h3>Description</h3>

<p>Chart individual residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_individual_error(
  data,
  target,
  title = NULL,
  ylab = NULL,
  freq = NULL,
  zeroline = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_individual_error_+3A_data">data</code></td>
<td>
<p>data.frame: sovereign residuals object</p>
</td></tr>
<tr><td><code id="plot_individual_error_+3A_target">target</code></td>
<td>
<p>string: series to plot</p>
</td></tr>
<tr><td><code id="plot_individual_error_+3A_title">title</code></td>
<td>
<p>string: chart title</p>
</td></tr>
<tr><td><code id="plot_individual_error_+3A_ylab">ylab</code></td>
<td>
<p>string: y-axis label</p>
</td></tr>
<tr><td><code id="plot_individual_error_+3A_freq">freq</code></td>
<td>
<p>string: frequency (acts as sub-title)</p>
</td></tr>
<tr><td><code id="plot_individual_error_+3A_zeroline">zeroline</code></td>
<td>
<p>boolean: if TRUE then add a horizontal line at zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 chart
</p>

<hr>
<h2 id='plot_individual_fevd'>Plot an individual FEVD</h2><span id='topic+plot_individual_fevd'></span>

<h3>Description</h3>

<p>Plot an individual FEVD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_individual_fevd(fevd, response.var, title, ylab)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_individual_fevd_+3A_fevd">fevd</code></td>
<td>
<p>fevd object</p>
</td></tr>
<tr><td><code id="plot_individual_fevd_+3A_response.var">response.var</code></td>
<td>
<p>string: name of variable to treat as the response</p>
</td></tr>
<tr><td><code id="plot_individual_fevd_+3A_title">title</code></td>
<td>
<p>string: title of the chart</p>
</td></tr>
<tr><td><code id="plot_individual_fevd_+3A_ylab">ylab</code></td>
<td>
<p>string: y-axis label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 graph
</p>

<hr>
<h2 id='plot_individual_forecast'>Chart individual forecast</h2><span id='topic+plot_individual_forecast'></span>

<h3>Description</h3>

<p>Chart individual forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_individual_forecast(
  data,
  target,
  title = NULL,
  ylab = NULL,
  freq = NULL,
  zeroline = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_individual_forecast_+3A_data">data</code></td>
<td>
<p>data.frame: sovereign model forecast</p>
</td></tr>
<tr><td><code id="plot_individual_forecast_+3A_target">target</code></td>
<td>
<p>string: series to plot</p>
</td></tr>
<tr><td><code id="plot_individual_forecast_+3A_title">title</code></td>
<td>
<p>string: chart title</p>
</td></tr>
<tr><td><code id="plot_individual_forecast_+3A_ylab">ylab</code></td>
<td>
<p>string: y-axis label</p>
</td></tr>
<tr><td><code id="plot_individual_forecast_+3A_freq">freq</code></td>
<td>
<p>string: frequency (acts as sub-title)</p>
</td></tr>
<tr><td><code id="plot_individual_forecast_+3A_zeroline">zeroline</code></td>
<td>
<p>boolean: if TRUE then add a horizontal line at zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 chart
</p>

<hr>
<h2 id='plot_individual_hd'>Plot an individual HD</h2><span id='topic+plot_individual_hd'></span>

<h3>Description</h3>

<p>Plot an individual HD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_individual_hd(hd, target.var, title)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_individual_hd_+3A_hd">hd</code></td>
<td>
<p>hd object</p>
</td></tr>
<tr><td><code id="plot_individual_hd_+3A_target.var">target.var</code></td>
<td>
<p>string: name of variable to decompose into shocks</p>
</td></tr>
<tr><td><code id="plot_individual_hd_+3A_title">title</code></td>
<td>
<p>string: title of the chart</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 graph
</p>

<hr>
<h2 id='plot_individual_irf'>Plot an individual IRF</h2><span id='topic+plot_individual_irf'></span>

<h3>Description</h3>

<p>Plot an individual IRF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_individual_irf(irf, shock.var, response.var, title, ylab)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_individual_irf_+3A_irf">irf</code></td>
<td>
<p>irf object</p>
</td></tr>
<tr><td><code id="plot_individual_irf_+3A_shock.var">shock.var</code></td>
<td>
<p>string: name of variable to treat as the shock</p>
</td></tr>
<tr><td><code id="plot_individual_irf_+3A_response.var">response.var</code></td>
<td>
<p>string: name of variable to treat as the response</p>
</td></tr>
<tr><td><code id="plot_individual_irf_+3A_title">title</code></td>
<td>
<p>string: title of the chart</p>
</td></tr>
<tr><td><code id="plot_individual_irf_+3A_ylab">ylab</code></td>
<td>
<p>string: y-axis label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 graph
</p>

<hr>
<h2 id='plot_irf'>Chart IRFs</h2><span id='topic+plot_irf'></span>

<h3>Description</h3>

<p>Chart IRFs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_irf(irf, shocks = NULL, responses = NULL, verticle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_irf_+3A_irf">irf</code></td>
<td>
<p>irf object</p>
</td></tr>
<tr><td><code id="plot_irf_+3A_shocks">shocks</code></td>
<td>
<p>string vector: shocks to plot</p>
</td></tr>
<tr><td><code id="plot_irf_+3A_responses">responses</code></td>
<td>
<p>string vector: responses to plot</p>
</td></tr>
<tr><td><code id="plot_irf_+3A_verticle">verticle</code></td>
<td>
<p>boolean: If true then stack all plots into one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grid of ggplot2 graphs
</p>

<hr>
<h2 id='regimes'>Identify regimes via unsupervised ML algorithms</h2><span id='topic+regimes'></span>

<h3>Description</h3>

<p>Regime assignment (clustering) methods available include the
<a href="https://www.rdocumentation.org/packages/randomForest/versions/4.6-14/topics/randomForest">unsupervised random forest</a>,
<a href="https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/kmeans">k-mean clustering</a>,
Fraley and Raftery Model-based clustering <a href="https://www.rdocumentation.org/packages/mclust/versions/5.4.7/topics/Mclust">EM algorithm</a>,
and the <a href="https://www.rdocumentation.org/packages/strucchange/versions/1.5-2/topics/breakpoints">Bai &amp; Perron (2003)</a> method for simultaneous estimation of multiple breakpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regimes(data, method = "rf", regime.n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regimes_+3A_data">data</code></td>
<td>
<p>data.frame, matrix, ts, xts, zoo: Endogenous regressors</p>
</td></tr>
<tr><td><code id="regimes_+3A_method">method</code></td>
<td>
<p>string: regime assignment technique ('rf', 'kmeans', 'EM', or 'BP)</p>
</td></tr>
<tr><td><code id="regimes_+3A_regime.n">regime.n</code></td>
<td>
<p>int: number of regimes to estimate (applies to kmeans and EM)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> as a data.frame with a regime column assigning rows to mutually exclusive regimes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)

 # estimate reigme
 regime =
  sovereign::regimes(
     data = Data,
     method = 'kmeans',
     regime.n = 3)


</code></pre>

<hr>
<h2 id='RLP'>Estimate regime-dependent local projections</h2><span id='topic+RLP'></span>

<h3>Description</h3>

<p>Estimate a regime-dependent local projection (i.e. a state-dependent LP), with an exogenous state indicator, of the specification:
</p>
<p style="text-align: center;"><code class="reqn">Y_{t+h} = X_t \beta_{s_t} + \epsilon_t</code>
</p>

<p>where <em>t</em> is the time index, and <em>s</em> is a mutually exclusive state of the world observed at time <em>t</em>. When the regime vector is
not supplied by the user, then a two-state regime series is estimated via random forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RLP(
  data,
  horizons = 1,
  freq = "month",
  type = "const",
  p = 1,
  lag.ic = NULL,
  lag.max = NULL,
  NW = FALSE,
  NW_lags = NULL,
  NW_prewhite = NULL,
  regime = NULL,
  regime.method = "rf",
  regime.n = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RLP_+3A_data">data</code></td>
<td>
<p>data.frame, matrix, ts, xts, zoo: Endogenous regressors</p>
</td></tr>
<tr><td><code id="RLP_+3A_horizons">horizons</code></td>
<td>
<p>int: forecast horizons</p>
</td></tr>
<tr><td><code id="RLP_+3A_freq">freq</code></td>
<td>
<p>string: frequency of data ('day', 'week', 'month', 'quarter', or 'year')</p>
</td></tr>
<tr><td><code id="RLP_+3A_type">type</code></td>
<td>
<p>string: type of deterministic terms to add ('none', 'const', 'trend', or 'both')</p>
</td></tr>
<tr><td><code id="RLP_+3A_p">p</code></td>
<td>
<p>int: lags</p>
</td></tr>
<tr><td><code id="RLP_+3A_lag.ic">lag.ic</code></td>
<td>
<p>string: information criterion to choose the optimal number of lags ('AIC' or 'BIC')</p>
</td></tr>
<tr><td><code id="RLP_+3A_lag.max">lag.max</code></td>
<td>
<p>int: maximum number of lags to test in lag selection</p>
</td></tr>
<tr><td><code id="RLP_+3A_nw">NW</code></td>
<td>
<p>boolean: Newey-West correction on variance-covariance matrix</p>
</td></tr>
<tr><td><code id="RLP_+3A_nw_lags">NW_lags</code></td>
<td>
<p>int: number of lags to use in Newey-West correction</p>
</td></tr>
<tr><td><code id="RLP_+3A_nw_prewhite">NW_prewhite</code></td>
<td>
<p>boolean: TRUE prewhite option for Newey-West correction (see sandwich::NeweyWest)</p>
</td></tr>
<tr><td><code id="RLP_+3A_regime">regime</code></td>
<td>
<p>string: name or regime assignment vector in the design matrix (data)</p>
</td></tr>
<tr><td><code id="RLP_+3A_regime.method">regime.method</code></td>
<td>
<p>string: regime assignment technique ('rf', 'kmeans', 'EM', 'BP')</p>
</td></tr>
<tr><td><code id="RLP_+3A_regime.n">regime.n</code></td>
<td>
<p>int: number of regimes to estimate (applies to kmeans and EM)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of lists, one list per regime, each regime with objects with elements <code>data</code>, <code>model</code>, <code>forecasts</code>, <code>residuals</code>;
if there is more than one forecast horizon estimated, then <code>model</code>, <code>forecasts</code>, <code>residuals</code>
will each be a list where each element corresponds to a single horizon
</p>


<h3>References</h3>


<ol>
<li><p> Jorda, Oscar &quot;<a href="https://www.aeaweb.org/articles?id=10.1257/0002828053828518">Estimation and Inference of Impulse Responses by Local Projections</a>&quot; 2005.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+LP">LP()</a></code>
</p>
<p><code><a href="#topic+lp_irf">lp_irf()</a></code>
</p>
<p><code><a href="#topic+RLP">RLP()</a></code>
</p>
<p><code><a href="#topic+rlp_irf">rlp_irf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # simple time series
  AA = c(1:100) + rnorm(100)
  BB = c(1:100) + rnorm(100)
  CC = AA + BB + rnorm(100)
  date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
  Data = data.frame(date = date, AA, BB, CC)
  # add regime
  Data = dplyr::mutate(Data, reg = dplyr::if_else(AA &gt; median(AA), 1, 0))

  # local projection forecasts
  rlp =
    sovereign::RLP(
      data = Data,
      regime = 'reg',
      horizon = c(1:10),
      freq = 'month',
      p = 1,
      type =  'const',
      NW = TRUE,
      NW_lags = 1,
      NW_prewhite = FALSE)

 # impulse response function
 rirf = sovereign::rlp_irf(rlp)



</code></pre>

<hr>
<h2 id='rlp_irf'>Estimate regime-dependent impulse response functions</h2><span id='topic+rlp_irf'></span>

<h3>Description</h3>

<p>Estimate regime-dependent impulse response functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlp_irf(rlp, CI = c(0.1, 0.9))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlp_irf_+3A_rlp">rlp</code></td>
<td>
<p>RLP output</p>
</td></tr>
<tr><td><code id="rlp_irf_+3A_ci">CI</code></td>
<td>
<p>numeric vector: c(lower ci bound, upper ci bound)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of long-form data.frame with one row per target-shock-horizon identifier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LP">LP()</a></code>
</p>
<p><code><a href="#topic+lp_irf">lp_irf()</a></code>
</p>
<p><code><a href="#topic+RLP">RLP()</a></code>
</p>
<p><code><a href="#topic+rlp_irf">rlp_irf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # simple time series
  AA = c(1:100) + rnorm(100)
  BB = c(1:100) + rnorm(100)
  CC = AA + BB + rnorm(100)
  date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
  Data = data.frame(date = date, AA, BB, CC)
  # add regime
  Data = dplyr::mutate(Data, reg = dplyr::if_else(AA &gt; median(AA), 1, 0))

  # local projection forecasts
  rlp =
    sovereign::RLP(
      data = Data,
      regime = 'reg',
      horizon = c(1:10),
      freq = 'month',
      p = 1,,
      type =  'const',
      NW = TRUE,
      NW_lags = 1,
      NW_prewhite = FALSE)

 # impulse response function
 rirf = sovereign::rlp_irf(rlp)


</code></pre>

<hr>
<h2 id='RVAR'>Estimate regime-dependent VAR, SVAR, or Proxy-SVAR</h2><span id='topic+RVAR'></span>

<h3>Description</h3>

<p>Estimate a regime-dependent VAR (i.e. a state-dependent VAR), with an exogenous state indicator, of the specification:
</p>
<p style="text-align: center;"><code class="reqn">Y_{t+1} = X_t \beta_{s_t} + \epsilon_t</code>
</p>

<p>where <em>t</em> is the time index, <em>Y</em> is the set of outcome vectors, <em>X</em> the design matrix (of <em>p</em> lagged values of Y), and
<em>s</em> is a mutually exclusive state of the world observed at time <em>t</em>. When the regime vector is not supplied by the user, then a two-state
regime series is estimated via random forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVAR(
  data,
  horizon = 10,
  freq = "month",
  type = "const",
  p = 1,
  lag.ic = NULL,
  lag.max = NULL,
  regime = NULL,
  regime.method = "rf",
  regime.n = 2,
  structure = "short",
  instrument = NULL,
  instrumented = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RVAR_+3A_data">data</code></td>
<td>
<p>data.frame, matrix, ts, xts, zoo: Endogenous regressors</p>
</td></tr>
<tr><td><code id="RVAR_+3A_horizon">horizon</code></td>
<td>
<p>int: forecast horizons</p>
</td></tr>
<tr><td><code id="RVAR_+3A_freq">freq</code></td>
<td>
<p>string: frequency of data ('day', 'week', 'month', 'quarter', or 'year')</p>
</td></tr>
<tr><td><code id="RVAR_+3A_type">type</code></td>
<td>
<p>string: type of deterministic terms to add ('none', 'const', 'trend', or 'both')</p>
</td></tr>
<tr><td><code id="RVAR_+3A_p">p</code></td>
<td>
<p>int: lags</p>
</td></tr>
<tr><td><code id="RVAR_+3A_lag.ic">lag.ic</code></td>
<td>
<p>string: information criterion to choose the optimal number of lags ('AIC' or 'BIC')</p>
</td></tr>
<tr><td><code id="RVAR_+3A_lag.max">lag.max</code></td>
<td>
<p>int: maximum number of lags to test in lag selection</p>
</td></tr>
<tr><td><code id="RVAR_+3A_regime">regime</code></td>
<td>
<p>string: name or regime assignment vector in the design matrix (data)</p>
</td></tr>
<tr><td><code id="RVAR_+3A_regime.method">regime.method</code></td>
<td>
<p>string: regime assignment technique ('rf', 'kmeans', 'EM', or 'BP')</p>
</td></tr>
<tr><td><code id="RVAR_+3A_regime.n">regime.n</code></td>
<td>
<p>int: number of regimes to estimate (applies to kmeans and EM)</p>
</td></tr>
<tr><td><code id="RVAR_+3A_structure">structure</code></td>
<td>
<p>string: type of structural identification strategy to use in model analysis (NA, 'short', 'IV', or 'IV-short')</p>
</td></tr>
<tr><td><code id="RVAR_+3A_instrument">instrument</code></td>
<td>
<p>string: name of instrumental variable contained in the data matrix</p>
</td></tr>
<tr><td><code id="RVAR_+3A_instrumented">instrumented</code></td>
<td>
<p>string: name of variable to be instrumented in IV and IV-short procedure; default is the first non-date variable in data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regime-dependent VAR is a generalization of the popular threshold VAR - which trades off estimating a threshold value for an
endogenous variable for accepting an exogenous regime that can be based on information from inside or outside of the system, with or without parametric
assumptions, and with or without timing restrictions. Moreover, the RVAR may be extended to include structural shocks, including the use of instrumental
variables.
</p>
<p><strong>State dependence.</strong> The RVAR augments the traditional VAR by allowing state-dependence in the coefficient matrix. The RVAR differs from the more common threshold VAR (TVAR), due
to the fact that states are exegonesouly determined. As a result, the states (i.e. regimes) do not need to be based on information inside the model, moreover, regimes can be
determined by any process the user determines best fits their needs. For example, regimes based on NBER dated recessions and expansions are based on a judgmental process
considering hundreds of series, potentially none of which are in the VAR being modeled. Alternatively, a user may use unsupervised machine learning to assign regimes - this is
the process the <code>sovereign::regimes</code> function facilitates.
</p>
<p><strong>Structural shocks.</strong> See Sims (1980) for details regarding the baseline vector-autoregression (VAR) model. The VAR may be augmented to become a structural VAR (SVAR) with one of three different structural identification strategies:
</p>

<ol>
<li><p> short-term impact restrictions via Cholesky decomposition, see Christiano et al (1999) for details <strong>(structure = 'short')</strong>
</p>
</li>
<li><p> external instrument identification, i.e. a Proxy-SVAR strategy, see Mertens and Ravn (2013) for details <strong>(structure = 'IV')</strong>
</p>
</li>
<li><p> or a combination of short-term and IV identification via Lunsford (2015) <strong>(structure = 'IV-short')</strong>
</p>
</li></ol>

<p>Note that including structure does not change the estimation of model coefficients or forecasts, but does change impulse response functions, forecast error variance decomposition,
and historical decompositions. Historical decompositions will not be available for models using the 'IV' structure. Additionally note that only one instrument may be used in this
estimation routine.
</p>


<h3>Value</h3>

<p>List of lists, where each regime is a list with items:
</p>

<ol>
<li><p> data: data.frame with endogenous variables and 'date' column.
</p>
</li>
<li><p> model: list with data.frame of model coefficients (in psuedo-companion form), data.frame of coefficient standard errors, integer of lags p, integer of horizons, string of frequency, string of deterministic term type, numeric of log-likelihood, regime indicator
</p>
</li>
<li><p> forecasts: list of data.frames per horizon; data.frame with column for date (day the forecast was made), forecast.date (the date being forecasted), target (variable forecasted), and forecast
</p>
</li>
<li><p> residuals: list of data.frames per horizon; data.frame of residuals
</p>
</li>
<li><p> structure: string denoting which structural identification strategy will be used in analysis  (or NA)
</p>
</li>
<li><p> instrument: data.frame with 'date' column and 'instrument' column (or NULL)
</p>
</li>
<li><p> instrumented: string denoting which column will be instrumted in 'IV' and 'IV-short' strategies (or NULL)
</p>
</li></ol>



<h3>References</h3>


<ol>
<li><p> Christiano, Lawrence, Martin Eichenbaum, and Charles Evans &quot;<a href="https://www.sciencedirect.com/science/article/pii/S1574004899010058">Monetary policy shocks: What have we learned and to what end?</a>&quot; Handbook of Macroeconomics, Vol 1, Part A, 1999.
</p>
</li>
<li><p> Lunsford, Kurt &quot;<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2699452#">Identifying Structural VARs with a Proxy Variable and a Test for a Weak Proxy</a>&quot; 2015.
</p>
</li>
<li><p> Mertens, Karel and Morten Ravn &quot;<a href="https://www.aeaweb.org/articles?id=10.1257/aer.103.4.1212">The Dynamic Effects of Personal and Corporate Income Tax Changes in the United States</a>&quot; 2013.
</p>
</li>
<li><p> Sims, Christopher &quot;<a href="https://www.jstor.org/stable/1912017">Macroeconomics and Reality</a>&quot; 1980.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+RVAR">RVAR()</a></code>
</p>
<p><code><a href="#topic+IRF">IRF()</a></code>
</p>
<p><code><a href="#topic+FEVD">FEVD()</a></code>
</p>
<p><code><a href="#topic+HD">HD()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)
 Data = dplyr::mutate(Data, reg = dplyr::if_else(AA &gt; median(AA), 1, 0))

 # estimate regime-dependent VAR
  rvar =
    sovereign::RVAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      regime.method = 'rf',
      regime.n = 2,
      lag.ic = 'BIC',
      lag.max = 4)

 # impulse response functions
 rvar.irf = sovereign::rvar_irf(rvar)

 # forecast error variance decomposition
 rvar.fevd = sovereign::rvar_fevd(rvar)

 # historical shock decomposition
 rvar.hd = sovereign::rvar_hd(rvar)



</code></pre>

<hr>
<h2 id='rvar_fevd'>Estimate regime-dependent forecast error variance decomposition</h2><span id='topic+rvar_fevd'></span>

<h3>Description</h3>

<p>Estimate forecast error variance decomposition for RVARs
with either short or 'IV-short' structural errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar_fevd(rvar, horizon = 10, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rvar_fevd_+3A_rvar">rvar</code></td>
<td>
<p>RVAR output</p>
</td></tr>
<tr><td><code id="rvar_fevd_+3A_horizon">horizon</code></td>
<td>
<p>int: number of periods</p>
</td></tr>
<tr><td><code id="rvar_fevd_+3A_scale">scale</code></td>
<td>
<p>boolean: scale variable contribution as percent of total error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, each regime returns its own long-form data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_irf">var_irf()</a></code>
</p>
<p><code><a href="#topic+var_fevd">var_fevd()</a></code>
</p>
<p><code><a href="#topic+var_hd">var_hd()</a></code>
</p>
<p><code><a href="#topic+RVAR">RVAR()</a></code>
</p>
<p><code><a href="#topic+rvar_irf">rvar_irf()</a></code>
</p>
<p><code><a href="#topic+rvar_fevd">rvar_fevd()</a></code>
</p>
<p><code><a href="#topic+rvar_hd">rvar_hd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)
 Data = dplyr::mutate(Data, reg = dplyr::if_else(AA &gt; median(AA), 1, 0))

 # estimate VAR
  rvar =
    sovereign::RVAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      regime.method = 'rf',
      regime.n = 2,
      lag.ic = 'BIC',
      lag.max = 4)

# impulse response functions
rvar.irf = sovereign::rvar_irf(rvar)

# forecast error variance decomposition
rvar.fevd = sovereign::rvar_fevd(rvar)

# historical shock decomposition
rvar.hd = sovereign::rvar_hd(rvar)



</code></pre>

<hr>
<h2 id='rvar_hd'>Estimate regime-dependent historical decomposition</h2><span id='topic+rvar_hd'></span>

<h3>Description</h3>

<p>Estimate historical decomposition for RVARs with
either short or 'IV-short' structural errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar_hd(rvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rvar_hd_+3A_rvar">rvar</code></td>
<td>
<p>RVAR output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>long form data.frames
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_irf">var_irf()</a></code>
</p>
<p><code><a href="#topic+var_fevd">var_fevd()</a></code>
</p>
<p><code><a href="#topic+var_hd">var_hd()</a></code>
</p>
<p><code><a href="#topic+RVAR">RVAR()</a></code>
</p>
<p><code><a href="#topic+rvar_irf">rvar_irf()</a></code>
</p>
<p><code><a href="#topic+rvar_fevd">rvar_fevd()</a></code>
</p>
<p><code><a href="#topic+rvar_hd">rvar_hd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)
 Data = dplyr::mutate(Data, reg = dplyr::if_else(AA &gt; median(AA), 1, 0))

 # estimate VAR
  rvar =
    sovereign::RVAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      regime.method = 'rf',
      regime.n = 2,
      lag.ic = 'BIC',
      lag.max = 4)

# impulse response functions
rvar.irf = sovereign::rvar_irf(rvar)

# forecast error variance decomposition
rvar.fevd = sovereign::rvar_fevd(rvar)

# historical shock decomposition
rvar.hd = sovereign::rvar_hd(rvar)



</code></pre>

<hr>
<h2 id='rvar_irf'>Estimate regime-dependent impulse response functions</h2><span id='topic+rvar_irf'></span>

<h3>Description</h3>

<p>Estimate regime-dependent impulse response functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvar_irf(
  rvar,
  horizon = 10,
  CI = c(0.1, 0.9),
  bootstrap.type = "auto",
  bootstrap.num = 100,
  bootstrap.parallel = FALSE,
  bootstrap.cores = -1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rvar_irf_+3A_rvar">rvar</code></td>
<td>
<p>RVAR output</p>
</td></tr>
<tr><td><code id="rvar_irf_+3A_horizon">horizon</code></td>
<td>
<p>int: number of periods</p>
</td></tr>
<tr><td><code id="rvar_irf_+3A_ci">CI</code></td>
<td>
<p>numeric vector: c(lower ci bound, upper ci bound)</p>
</td></tr>
<tr><td><code id="rvar_irf_+3A_bootstrap.type">bootstrap.type</code></td>
<td>
<p>string: bootstrapping technique to use ('auto', 'standard', or 'wild'); if auto then wild is used for IV or IV-short, else standard is used</p>
</td></tr>
<tr><td><code id="rvar_irf_+3A_bootstrap.num">bootstrap.num</code></td>
<td>
<p>int: number of bootstraps</p>
</td></tr>
<tr><td><code id="rvar_irf_+3A_bootstrap.parallel">bootstrap.parallel</code></td>
<td>
<p>boolean: create IRF draws in parallel</p>
</td></tr>
<tr><td><code id="rvar_irf_+3A_bootstrap.cores">bootstrap.cores</code></td>
<td>
<p>int: number of cores to use in parallel processing; -1 detects and uses half the available cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of regimes, each with data.frame of columns <code>target</code>, <code>shock</code>, <code>horizon</code>, <code>response.lower</code>, <code>response</code>, <code>response.upper</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_irf">var_irf()</a></code>
</p>
<p><code><a href="#topic+var_fevd">var_fevd()</a></code>
</p>
<p><code><a href="#topic+RVAR">RVAR()</a></code>
</p>
<p><code><a href="#topic+rvar_irf">rvar_irf()</a></code>
</p>
<p><code><a href="#topic+rvar_fevd">rvar_fevd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)
 Data = dplyr::mutate(Data, reg = dplyr::if_else(AA &gt; median(AA), 1, 0))

 # estimate VAR
  rvar =
    sovereign::RVAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      regime.method = 'rf',
      regime.n = 2,
      lag.ic = 'BIC',
      lag.max = 4)

 # impulse response functions
 rvar.irf = sovereign::rvar_irf(rvar)

 # forecast error variance decomposition
 rvar.fevd = sovereign::rvar_fevd(rvar)

 # historical shock decomposition
 rvar.hd = sovereign::rvar_hd(rvar)



</code></pre>

<hr>
<h2 id='VAR'>Estimate VAR, SVAR, or Proxy-SVAR</h2><span id='topic+VAR'></span>

<h3>Description</h3>

<p>Estimate VAR, SVAR, or Proxy-SVAR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR(
  data,
  horizon = 10,
  freq = "month",
  type = "const",
  p = 1,
  lag.ic = NULL,
  lag.max = NULL,
  structure = "short",
  instrument = NULL,
  instrumented = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VAR_+3A_data">data</code></td>
<td>
<p>data.frame, matrix, ts, xts, zoo: Endogenous regressors</p>
</td></tr>
<tr><td><code id="VAR_+3A_horizon">horizon</code></td>
<td>
<p>int: forecast horizons</p>
</td></tr>
<tr><td><code id="VAR_+3A_freq">freq</code></td>
<td>
<p>string: frequency of data ('day', 'week', 'month', 'quarter', or 'year')</p>
</td></tr>
<tr><td><code id="VAR_+3A_type">type</code></td>
<td>
<p>string: type of deterministic terms to add ('none', 'const', 'trend', or 'both')</p>
</td></tr>
<tr><td><code id="VAR_+3A_p">p</code></td>
<td>
<p>int: lags</p>
</td></tr>
<tr><td><code id="VAR_+3A_lag.ic">lag.ic</code></td>
<td>
<p>string: information criterion to choose the optimal number of lags ('AIC' or 'BIC')</p>
</td></tr>
<tr><td><code id="VAR_+3A_lag.max">lag.max</code></td>
<td>
<p>int: maximum number of lags to test in lag selection</p>
</td></tr>
<tr><td><code id="VAR_+3A_structure">structure</code></td>
<td>
<p>string: type of structural identification strategy to use in model analysis (NA, 'short', 'IV', or 'IV-short')</p>
</td></tr>
<tr><td><code id="VAR_+3A_instrument">instrument</code></td>
<td>
<p>string: name of instrumental variable contained in the data matrix</p>
</td></tr>
<tr><td><code id="VAR_+3A_instrumented">instrumented</code></td>
<td>
<p>string: name of variable to be instrumented in IV and IV-short procedure; default is the first non-date variable in data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Sims (1980) for details regarding the baseline vector-autoregression (VAR) model. The VAR may be augmented to become a structural VAR (SVAR) with one of three different structural identification strategies:
</p>

<ol>
<li><p> short-term impact restrictions via Cholesky decomposition, see Christiano et al (1999) for details <strong>(structure = 'short')</strong>
</p>
</li>
<li><p> external instrument identification, i.e. a Proxy-SVAR strategy, see Mertens and Ravn (2013) for details <strong>(structure = 'IV')</strong>
</p>
</li>
<li><p> or a combination of short-term and IV identification via Lunsford (2015) <strong>(structure = 'IV-short')</strong>
</p>
</li></ol>

<p>Note that including structure does not change the estimation of model coefficients or forecasts, but does change impulse response functions, forecast error variance decomposition,
and historical decompositions. Historical decompositions will not be available for models using the 'IV' structure. Additionally note that only one instrument may be used in this
estimation routine.
</p>


<h3>Value</h3>


<ol>
<li><p> data: data.frame with endogenous variables and 'date' column.
</p>
</li>
<li><p> model: list with data.frame of model coefficients (in psuedo-companion form), data.frame of coefficient standard errors, integer of lags p, integer of horizons, string of frequency, string of deterministic term type, numeric of log-likelihood
</p>
</li>
<li><p> forecasts: list of data.frames per horizon; data.frame with column for date (day the forecast was made), forecast.date (the date being forecasted), target (variable forecasted), and forecast
</p>
</li>
<li><p> residuals: list of data.frames per horizon; data.frame of residuals
</p>
</li>
<li><p> structure: string denoting which structural identification strategy will be used in analysis  (or NA)
</p>
</li>
<li><p> instrument: data.frame with 'date' column and 'instrument' column (or NULL)
</p>
</li>
<li><p> instrumented: string denoting which column will be instrumted in 'IV' and 'IV-short' strategies (or NA)
</p>
</li></ol>



<h3>References</h3>


<ol>
<li><p> Christiano, Lawrence, Martin Eichenbaum, and Charles Evans &quot;<a href="https://www.sciencedirect.com/science/article/pii/S1574004899010058">Monetary policy shocks: What have we learned and to what end?</a>&quot; Handbook of Macroeconomics, Vol 1, Part A, 1999.
</p>
</li>
<li><p> Lunsford, Kurt &quot;<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2699452#">Identifying Structural VARs with a Proxy Variable and a Test for a Weak Proxy</a>&quot; 2015.
</p>
</li>
<li><p> Mertens, Karel and Morten Ravn &quot;<a href="https://www.aeaweb.org/articles?id=10.1257/aer.103.4.1212">The Dynamic Effects of Personal and Corporate Income Tax Changes in the United States</a>&quot; 2013.
</p>
</li>
<li><p> Sims, Christopher &quot;<a href="https://www.jstor.org/stable/1912017">Macroeconomics and Reality</a>&quot; 1980.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_irf">var_irf()</a></code>
</p>
<p><code><a href="#topic+var_fevd">var_fevd()</a></code>
</p>
<p><code><a href="#topic+var_hd">var_hd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)

 # estimate VAR
  var =
    sovereign::VAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      lag.ic = 'BIC',
      lag.max = 4)

  # impulse response functions
  var.irf = sovereign::var_irf(var)

  # forecast error variance decomposition
  var.fevd = sovereign::var_fevd(var)

  # historical shock decomposition
  var.hd = sovereign::var_hd(var)


</code></pre>

<hr>
<h2 id='var_fevd'>Estimate forecast error variance decomposition</h2><span id='topic+var_fevd'></span>

<h3>Description</h3>

<p>Estimate forecast error variance decomposition for VARs
with either short or 'IV-short' structural errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_fevd(var, horizon = 10, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_fevd_+3A_var">var</code></td>
<td>
<p>VAR output</p>
</td></tr>
<tr><td><code id="var_fevd_+3A_horizon">horizon</code></td>
<td>
<p>int: number of periods</p>
</td></tr>
<tr><td><code id="var_fevd_+3A_scale">scale</code></td>
<td>
<p>boolean: scale variable contribution as percent of total error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>long-form data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_irf">var_irf()</a></code>
</p>
<p><code><a href="#topic+var_fevd">var_fevd()</a></code>
</p>
<p><code><a href="#topic+var_hd">var_hd()</a></code>
</p>
<p><code><a href="#topic+RVAR">RVAR()</a></code>
</p>
<p><code><a href="#topic+rvar_irf">rvar_irf()</a></code>
</p>
<p><code><a href="#topic+rvar_fevd">rvar_fevd()</a></code>
</p>
<p><code><a href="#topic+rvar_hd">rvar_hd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)

 # estimate VAR
  var =
    sovereign::VAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      lag.ic = 'BIC',
      lag.max = 4)

# impulse response functions
var.irf = sovereign::var_irf(var)

# forecast error variance decomposition
var.fevd = sovereign::var_fevd(var)

# historical shock decomposition
var.hd = sovereign::var_hd(var)



</code></pre>

<hr>
<h2 id='var_hd'>Estimate historical decomposition</h2><span id='topic+var_hd'></span>

<h3>Description</h3>

<p>Estimate historical decomposition for VARs with
either short or 'IV-short' structural errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_hd(var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_hd_+3A_var">var</code></td>
<td>
<p>VAR output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>long-from data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_irf">var_irf()</a></code>
</p>
<p><code><a href="#topic+var_fevd">var_fevd()</a></code>
</p>
<p><code><a href="#topic+var_hd">var_hd()</a></code>
</p>
<p><code><a href="#topic+RVAR">RVAR()</a></code>
</p>
<p><code><a href="#topic+rvar_irf">rvar_irf()</a></code>
</p>
<p><code><a href="#topic+rvar_fevd">rvar_fevd()</a></code>
</p>
<p><code><a href="#topic+rvar_hd">rvar_hd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)

 # estimate VAR
  var =
    sovereign::VAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      lag.ic = 'BIC',
      lag.max = 4)

# impulse response functions
var.irf = sovereign::var_irf(var)

# forecast error variance decomposition
var.fevd = sovereign::var_fevd(var)

# historical shock decomposition
var.hd = sovereign::var_hd(var)



</code></pre>

<hr>
<h2 id='var_irf'>Estimate impulse response functions</h2><span id='topic+var_irf'></span>

<h3>Description</h3>

<p>Estimate impulse response functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_irf(
  var,
  horizon = 10,
  CI = c(0.1, 0.9),
  bootstrap.type = "auto",
  bootstrap.num = 100,
  bootstrap.parallel = FALSE,
  bootstrap.cores = -1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_irf_+3A_var">var</code></td>
<td>
<p>VAR output</p>
</td></tr>
<tr><td><code id="var_irf_+3A_horizon">horizon</code></td>
<td>
<p>int: number of periods</p>
</td></tr>
<tr><td><code id="var_irf_+3A_ci">CI</code></td>
<td>
<p>numeric vector: c(lower ci bound, upper ci bound)</p>
</td></tr>
<tr><td><code id="var_irf_+3A_bootstrap.type">bootstrap.type</code></td>
<td>
<p>string: bootstrapping technique to use ('auto', 'standard', or 'wild'); if auto then wild is used for IV or IV-short, else standard is used</p>
</td></tr>
<tr><td><code id="var_irf_+3A_bootstrap.num">bootstrap.num</code></td>
<td>
<p>int: number of bootstraps</p>
</td></tr>
<tr><td><code id="var_irf_+3A_bootstrap.parallel">bootstrap.parallel</code></td>
<td>
<p>boolean: create IRF draws in parallel</p>
</td></tr>
<tr><td><code id="var_irf_+3A_bootstrap.cores">bootstrap.cores</code></td>
<td>
<p>int: number of cores to use in parallel processing; -1 detects and uses half the available cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns <code>target</code>, <code>shock</code>, <code>horizon</code>, <code>response.lower</code>, <code>response</code>, <code>response.upper</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR()</a></code>
</p>
<p><code><a href="#topic+var_irf">var_irf()</a></code>
</p>
<p><code><a href="#topic+var_fevd">var_fevd()</a></code>
</p>
<p><code><a href="#topic+var_hd">var_hd()</a></code>
</p>
<p><code><a href="#topic+RVAR">RVAR()</a></code>
</p>
<p><code><a href="#topic+rvar_irf">rvar_irf()</a></code>
</p>
<p><code><a href="#topic+rvar_fevd">rvar_fevd()</a></code>
</p>
<p><code><a href="#topic+rvar_hd">rvar_hd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 AA = c(1:100) + rnorm(100)
 BB = c(1:100) + rnorm(100)
 CC = AA + BB + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, AA, BB, CC)

 # estimate VAR
  var =
    sovereign::VAR(
      data = Data,
      horizon = 10,
      freq = 'month',
      lag.ic = 'BIC',
      lag.max = 4)

 # impulse response functions
 var.irf = sovereign::var_irf(var)

 # forecast error variance decomposition
 var.fevd = sovereign::var_fevd(var)

 # historical shock decomposition
 var.hd = sovereign::var_hd(var)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
