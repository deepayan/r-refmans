<!DOCTYPE html><html lang="en"><head><title>Help for package bespatial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bespatial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bespatial-package'><p>bespatial: Boltzmann Entropy for Spatial Data</p></a></li>
<li><a href='#bes_g_cushman'><p>Configurational entropy for surfaces</p></a></li>
<li><a href='#bes_g_gao'><p>Boltzmann entropy of a landscape gradient</p></a></li>
<li><a href='#bes_m_cushman'><p>Configurational entropy for landscape mosaics</p></a></li>
<li><a href='#bes_m_zhao'><p>Zhao's entropy for landscape mosaics</p></a></li>
<li><a href='#bes_p_cushman'><p>Configurational entropy for point patterns</p></a></li>
<li><a href='#get_distance'><p>Calculates an average distance between non-NA cells</p></a></li>
<li><a href='#get_slope'><p>Calculate a slope</p></a></li>
<li><a href='#get_total_edge'><p>Calculate total edge based on the input matrix</p></a></li>
<li><a href='#permute_raster'><p>Permute values in the input raster</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Boltzmann Entropy for Spatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates several entropy metrics for spatial data 
  inspired by Boltzmann's entropy formula.
  It includes metrics introduced by Cushman for landscape mosaics 
  (Cushman (2015) &lt;<a href="https://doi.org/10.1007%2Fs10980-015-0305-2">doi:10.1007/s10980-015-0305-2</a>&gt;), 
  and landscape gradients and point patterns
  (Cushman (2021) &lt;<a href="https://doi.org/10.3390%2Fe23121616">doi:10.3390/e23121616</a>&gt;); by Zhao and Zhang for 
  landscape mosaics (Zhao and Zhang (2019) &lt;<a href="https://doi.org/10.1007%2Fs10980-019-00876-x">doi:10.1007/s10980-019-00876-x</a>&gt;);
  and by Gao et al. for landscape gradients
  (Gao et al. (2018) &lt;<a href="https://doi.org/10.1111%2Ftgis.12315">doi:10.1111/tgis.12315</a>&gt;; Gao and Li (2019) &lt;<a href="https://doi.org/10.1007%2Fs10980-019-00854-3">doi:10.1007/s10980-019-00854-3</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>comat (&ge; 0.9.2), Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>belg, comat, Rcpp, terra (&ge; 1.5-13), tibble, landscapemetrics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jakubnowosad.com/bespatial/">https://jakubnowosad.com/bespatial/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Nowosad/bespatial/issues">https://github.com/Nowosad/bespatial/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-07 12:53:48 UTC; jn</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakub Nowosad <a href="https://orcid.org/0000-0002-1057-3721"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakub Nowosad &lt;nowosad.jakub@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-07 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bespatial-package'>bespatial: Boltzmann Entropy for Spatial Data</h2><span id='topic+bespatial'></span><span id='topic+bespatial-package'></span>

<h3>Description</h3>

<p>Calculates several entropy metrics for spatial data inspired by Boltzmann's entropy formula. It includes metrics introduced by Cushman for landscape mosaics (Cushman (2015) <a href="https://doi.org/10.1007/s10980-015-0305-2">doi:10.1007/s10980-015-0305-2</a>), and landscape gradients and point patterns (Cushman (2021) <a href="https://doi.org/10.3390/e23121616">doi:10.3390/e23121616</a>); by Zhao and Zhang for landscape mosaics (Zhao and Zhang (2019) <a href="https://doi.org/10.1007/s10980-019-00876-x">doi:10.1007/s10980-019-00876-x</a>); and by Gao et al. for landscape gradients (Gao et al. (2018) <a href="https://doi.org/10.1111/tgis.12315">doi:10.1111/tgis.12315</a>; Gao and Li (2019) <a href="https://doi.org/10.1007/s10980-019-00854-3">doi:10.1007/s10980-019-00854-3</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jakub Nowosad <a href="mailto:nowosad.jakub@gmail.com">nowosad.jakub@gmail.com</a> (<a href="https://orcid.org/0000-0002-1057-3721">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jakubnowosad.com/bespatial/">https://jakubnowosad.com/bespatial/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Nowosad/bespatial/issues">https://github.com/Nowosad/bespatial/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bes_g_cushman'>Configurational entropy for surfaces</h2><span id='topic+bes_g_cushman'></span>

<h3>Description</h3>

<p>Calculates Cushman's configurational entropy for surfaces (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bes_g_cushman(x, nr_of_permutations = 1000, independent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bes_g_cushman_+3A_x">x</code></td>
<td>
<p>SpatRaster, stars, RasterLayer, RasterStack, RasterBrick, matrix, or array containing one or more continuous rasters</p>
</td></tr>
<tr><td><code id="bes_g_cushman_+3A_nr_of_permutations">nr_of_permutations</code></td>
<td>
<p>Number of permutations performed on each input raster to calculate
possible distribution of &quot;slope&quot; values</p>
</td></tr>
<tr><td><code id="bes_g_cushman_+3A_independent">independent</code></td>
<td>
<p>Should an independent set of permutations be performed for each input raster?
<code>TRUE</code>/<code>FALSE</code>.
Use <code>FALSE</code> (default) when each of your input rasters has the same configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>References</h3>

<p>Cushman, S. A. (2021). Generalizing Boltzmann Configurational Entropy to Surfaces, Point Patterns and Landscape Mosaics. In Entropy (Vol. 23, Issue 12, p. 1616). MDPI AG. https://doi.org/10.3390/e23121616
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(bespatial)
  library(terra)
  gradient = rast(system.file("raster/gradient.tif", package = "bespatial"),
                       lyrs = 1)
  ce2 = bes_g_cushman(gradient, 100)
  plot(gradient, main = round(ce2$value, 2))
  bes_g_cushman(gradient, 1000, independent = TRUE)

</code></pre>

<hr>
<h2 id='bes_g_gao'>Boltzmann entropy of a landscape gradient</h2><span id='topic+bes_g_gao'></span>

<h3>Description</h3>

<p>Calculates the Boltzmann entropy of a landscape gradient by Gao (2017, 2019)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bes_g_gao(
  x,
  method = "aggregation",
  na_adjust = TRUE,
  base = "log10",
  relative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bes_g_gao_+3A_x">x</code></td>
<td>
<p>SpatRaster, stars, RasterLayer, RasterStack, RasterBrick, matrix, or array.</p>
</td></tr>
<tr><td><code id="bes_g_gao_+3A_method">method</code></td>
<td>
<p>A method used. Either &quot;hierarchy&quot; for
the hierarchy-based method (Gao et al., 2017) or &quot;aggregation&quot; (default)
for the aggregation-based method (Gao et al., 2019).</p>
</td></tr>
<tr><td><code id="bes_g_gao_+3A_na_adjust">na_adjust</code></td>
<td>
<p>Should the output value be adjusted to the proportion of not missing cells? Either TRUE (default) or FALSE</p>
</td></tr>
<tr><td><code id="bes_g_gao_+3A_base">base</code></td>
<td>
<p>A logarithm base (&quot;log&quot;, &quot;log2&quot; or &quot;log10&quot;).</p>
</td></tr>
<tr><td><code id="bes_g_gao_+3A_relative">relative</code></td>
<td>
<p>Should a relative or absolute entropy be calculated? TRUE or FALSE (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for computing the Boltzmann entropy of a landscape
gradient works on integer values that are either positive or equals to zero.
This function automatically rounds values to the nearest integer value
(rounding halfway cases away from zero) and negative values are shifted to
positive values.
</p>


<h3>Value</h3>

<p>A tibble
</p>


<h3>References</h3>

<p>Gao, Peichao, Hong Zhang, and Zhilin Li. &quot;A hierarchy-based
solution to calculate the configurational entropy of landscape gradients.&quot;
Landscape Ecology 32.6 (2017): 1133-1146.
</p>
<p>Gao, Peichao, Hong Zhang, and Zhilin Li. &quot;An efficient
analytical method for computing the Boltzmann entropy of a landscape
gradient.&quot; Transactions in GIS (2018).
</p>
<p>Gao, Peichao and Zhilin Li. &quot;Aggregation-based method
for computing absolute Boltzmann entropy of landscape gradient
with full thermodynamic consistency&quot;
Landscape Ecology (2019)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(bespatial)
gradient = rast(system.file("raster/gradient.tif", package = "bespatial"))
gg1 = bes_g_gao(gradient)
plot(gradient, main = round(gg1$value, 2))
</code></pre>

<hr>
<h2 id='bes_m_cushman'>Configurational entropy for landscape mosaics</h2><span id='topic+bes_m_cushman'></span>

<h3>Description</h3>

<p>Calculates Cushman's configurational entropy for landscape mosaics (2015)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bes_m_cushman(x, nr_of_permutations, independent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bes_m_cushman_+3A_x">x</code></td>
<td>
<p>SpatRaster, stars, RasterLayer, RasterStack, RasterBrick, matrix, or array containing one or more categorical rasters</p>
</td></tr>
<tr><td><code id="bes_m_cushman_+3A_nr_of_permutations">nr_of_permutations</code></td>
<td>
<p>Number of permutations performed on each input raster to calculate
possible distribution of total edge values</p>
</td></tr>
<tr><td><code id="bes_m_cushman_+3A_independent">independent</code></td>
<td>
<p>Should an independent set of permutations be performed for each input raster?
<code>TRUE</code>/<code>FALSE</code>.
Use <code>FALSE</code> (default) when each of your input rasters has the same configuration (proportion of categories).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>References</h3>

<p>Cushman, S. A. (2015). Calculating the configurational entropy of a landscape mosaic. In Landscape Ecology (Vol. 31, Issue 3, pp. 481â€“489). Springer Science and Business Media LLC. https://doi.org/10.1007/s10980-015-0305-2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(bespatial)
mosaic = rast(system.file("raster/mosaic.tif", package = "bespatial"))
ce1 = bes_m_cushman(mosaic, 1000)
plot(mosaic, main = round(ce1$value, 2))
bes_m_cushman(mosaic, 1000, independent = TRUE)
</code></pre>

<hr>
<h2 id='bes_m_zhao'>Zhao's entropy for landscape mosaics</h2><span id='topic+bes_m_zhao'></span>

<h3>Description</h3>

<p>Calculates Zhao's entropy for landscape mosaics based on the Wasserstein metric (2019)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bes_m_zhao(x, neighbourhood = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bes_m_zhao_+3A_x">x</code></td>
<td>
<p>SpatRaster, stars, RasterLayer, RasterStack, RasterBrick, matrix, or array containing one or more categorical rasters</p>
</td></tr>
<tr><td><code id="bes_m_zhao_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are
considered as neighbours: 4 (rook's case), 8 (queen's case)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>References</h3>

<p>Zhao, Y., &amp; Zhang, X. (2019). Calculating spatial configurational entropy of a landscape mosaic based on the Wasserstein metric. Landscape Ecology, 34(8), 1849-1858. https://doi.org/10.1007/s10980-019-00876-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(bespatial)
mosaic = rast(system.file("raster/mosaic.tif", package = "bespatial"))
w_dists1 = bes_m_zhao(mosaic)
plot(mosaic, main = round(w_dists1$value, 2))
</code></pre>

<hr>
<h2 id='bes_p_cushman'>Configurational entropy for point patterns</h2><span id='topic+bes_p_cushman'></span>

<h3>Description</h3>

<p>Calculates Cushman's configurational entropy for point patterns (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bes_p_cushman(x, nr_of_permutations, independent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bes_p_cushman_+3A_x">x</code></td>
<td>
<p>SpatRaster, stars, RasterLayer, RasterStack, RasterBrick, matrix, or array containing one or more rasters with one value and NAs</p>
</td></tr>
<tr><td><code id="bes_p_cushman_+3A_nr_of_permutations">nr_of_permutations</code></td>
<td>
<p>Number of permutations performed on each input raster to calculate
possible distribution of the number of nearest neighbors</p>
</td></tr>
<tr><td><code id="bes_p_cushman_+3A_independent">independent</code></td>
<td>
<p>Should an independent set of permutations be performed for each input raster?
<code>TRUE</code>/<code>FALSE</code>.
Use <code>FALSE</code> (default) when each of your input rasters has the same configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>References</h3>

<p>Cushman, S. A. (2021). Generalizing Boltzmann Configurational Entropy to Surfaces, Point Patterns and Landscape Mosaics. In Entropy (Vol. 23, Issue 12, p. 1616). MDPI AG. https://doi.org/10.3390/e23121616
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(terra)
  library(bespatial)
  point_pattern = rast(system.file("raster/point_pattern.tif", package = "bespatial"))
  ce3 = bes_p_cushman(point_pattern, 100)
  plot(point_pattern, main = round(ce3$value, 2))
  ce3b = bes_p_cushman(point_pattern, 100, independent = TRUE)
  plot(point_pattern, main = round(ce3b$value, 2))

</code></pre>

<hr>
<h2 id='get_distance'>Calculates an average distance between non-NA cells</h2><span id='topic+get_distance'></span>

<h3>Description</h3>

<p>Calculates an average distance between non-NA cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distance(p, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_distance_+3A_p">p</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="get_distance_+3A_x">x</code></td>
<td>
<p>A SpatRaster with proper metadata (e.g., extent and CRS)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It converts permuted matrix into a vector dataset, and
calculates an average distance between the points
</p>


<h3>Value</h3>

<p>An average distance between points
</p>

<hr>
<h2 id='get_slope'>Calculate a slope</h2><span id='topic+get_slope'></span>

<h3>Description</h3>

<p>Calculate a slope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_slope(x, neighbourhood = matrix(4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_slope_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="get_slope_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are
considered as neighbours: 4 (rook's case), 8 (queen's case) or a binary matrix
where the ones define the neighbourhood. The default is 4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;Slope&quot; is calculated as follows:
</p>

<ol>
<li><p> For each cell, the algorithm looks at its 4 neighbors and
calculates the absolute difference between the main cell and its neighbors.
</p>
</li>
<li><p> Next, it sums these four values.
</p>
</li>
<li><p> After repeating this operation for every cell, it calculates
an average of the sum of the absolute differences for the whole raster.
</p>
</li></ol>



<h3>Value</h3>

<p>A slope value
</p>

<hr>
<h2 id='get_total_edge'>Calculate total edge based on the input matrix</h2><span id='topic+get_total_edge'></span>

<h3>Description</h3>

<p>Calculate total edge based on the input matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_total_edge(x, resolution, neighbourhood = as.matrix(4))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_total_edge_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="get_total_edge_+3A_resolution">resolution</code></td>
<td>
<p>A numeric vector with two values representing the input matrix
resolution on the x and y axis</p>
</td></tr>
<tr><td><code id="get_total_edge_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are
considered as neighbours: 4 (rook's case), 8 (queen's case) or a binary matrix
where the ones define the neighbourhood. The default is 4.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A total edge value
</p>

<hr>
<h2 id='permute_raster'>Permute values in the input raster</h2><span id='topic+permute_raster'></span>

<h3>Description</h3>

<p>Permute values in the input raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute_raster(x, nr_of_permutations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permute_raster_+3A_x">x</code></td>
<td>
<p>SpatRaster object (<code><a href="terra.html#topic+rast">terra::rast()</a></code>) containing one or more rasters</p>
</td></tr>
<tr><td><code id="permute_raster_+3A_nr_of_permutations">nr_of_permutations</code></td>
<td>
<p>Number of permutations performed on each input raster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
