<!DOCTYPE html><html><head><title>Help for package maditr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {maditr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#maditr-package'><p>maditr: Pipe-Style Interface for 'data.table'</p></a></li>
<li><a href='#coalesce'><p>Return first non-missing element</p></a></li>
<li><a href='#columns'><p>Selects columns or rows from the data set</p></a></li>
<li><a href='#copy'><p>Copy an entire object</p></a></li>
<li><a href='#dcast'><p>Convert data between wide and long forms.</p></a></li>
<li><a href='#dt_count'><p>Additional useful functions</p></a></li>
<li><a href='#dt_left_join'><p>Join two data.frames by common columns.</p></a></li>
<li><a href='#dt_mutate'><p>'dplyr'-like interface for data.table.</p></a></li>
<li><a href='#let_if'><p>Modify, aggregate, select or filter data.frame/data.table</p></a></li>
<li><a href='#query_if'><p>One-to-one interface for data.table '[' method</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#text_expand'><p>Evaluate expressions in curly brackets inside strings</p></a></li>
<li><a href='#to_list'><p>Apply an expression to each element of a list or vector</p></a></li>
<li><a href='#to_long'><p>Convert data to long or to wide form</p></a></li>
<li><a href='#vlookup'><p>Look up values in dictionary.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Data Aggregation, Modification, and Filtering with Pipes
and 'data.table'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Demin &lt;gdemin@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.12.6), magrittr (&ge; 1.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, tinytest, utils, rmarkdown, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides pipe-style interface for 'data.table'. Package preserves all 'data.table' features without
              significant impact on performance. 'let' and 'take' functions are simplified interfaces for most common data
              manipulation tasks. For example, you can write 'take(mtcars, mean(mpg), by = am)' for aggregation or 
              'let(mtcars, hp_wt = hp/wt, hp_wt_mpg = hp_wt/mpg)' for modification. Use 'take_if/let_if' for conditional
              aggregation/modification. Additionally there are some conveniences such as automatic 'data.frame' 
              conversion to 'data.table'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gdemin/maditr">https://github.com/gdemin/maditr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gdemin/maditr/issues">https://github.com/gdemin/maditr/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 22:07:54 UTC; gregory</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Demin [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-11 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='maditr-package'>maditr: Pipe-Style Interface for 'data.table'</h2><span id='topic+maditr'></span><span id='topic+maditr-package'></span>

<h3>Description</h3>

<p>Package provides pipe-style interface for <code>data.table</code>. It preserves
all data.table features without significant impact on performance. '<code>let</code>'
and '<code>take</code>' functions are simplified interfaces for most common data
manipulation tasks.
</p>


<h3>Details</h3>


<ul>
<li><p> To select rows from data: <code>rows(mtcars, am==0)</code>
</p>
</li>
<li><p> To select columns from data: <code>columns(mtcars, mpg, vs:carb)</code>
</p>
</li>
<li><p> To aggregate data: <code>take(mtcars, mean_mpg = mean(mpg), by = am)</code>
</p>
</li>
<li><p> To aggregate all non-grouping columns: <code>take_all(mtcars, mean, by = am)</code>
</p>
</li>
<li><p> To aggregate several columns with one summary: <code>take(mtcars, mpg, hp, fun = mean, by = am)</code>
</p>
</li>
<li><p> To get total summary skip <code>by</code> argument: <code>take_all(mtcars, mean)</code>
</p>
</li>
<li><p> Use magrittr pipe '%&gt;%' to chain several operations:
</p>
</li></ul>

<div class="sourceCode"><pre>     mtcars %&gt;%
        let(mpg_hp = mpg/hp) %&gt;%
        take(mean(mpg_hp), by = am)
</pre></div>

<ul>
<li><p> To modify variables or add new variables:
</p>
</li></ul>

<div class="sourceCode"><pre>      mtcars %&gt;%
         let(new_var = 42,
             new_var2 = new_var*hp) %&gt;%
          head()
</pre></div>

<ul>
<li><p> To modify all non-grouping variables:
</p>
</li></ul>

<div class="sourceCode"><pre>      iris %&gt;%
         let_all(
             scaled = (.x - mean(.x))/sd(.x),
             by = Species) %&gt;%
          head()
</pre></div>

<ul>
<li><p> To drop variable assign NULL: <code>let(mtcars, am = NULL) %&gt;% head()</code>
</p>
</li>
<li><p> To aggregate all variables conditionally on name:
</p>
</li></ul>

<div class="sourceCode"><pre>      iris %&gt;%
          take_all(
              mean = if(startsWith(.name, "Sepal")) mean(.x),
              median = if(startsWith(.name, "Petal")) median(.x),
              by = Species
          )
</pre></div>

<ul>
<li><p> For parametric assignment use ':=':
</p>
</li></ul>

<div class="sourceCode"><pre>     new_var = "my_var"
     old_var = "mpg"
     mtcars %&gt;%
         let((new_var) := get(old_var)*2) %&gt;%
         head()
</pre></div>

<ul>
<li><p> For more sophisticated operations see 'query'/'query_if': these
functions translates its arguments one-to-one to '<code style="white-space: pre;">&#8288;[.data.table&#8288;</code>'
method. Additionally there are some conveniences such as automatic
'data.frame' conversion to 'data.table'.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gregory Demin <a href="mailto:gdemin@gmail.com">gdemin@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/gdemin/maditr">https://github.com/gdemin/maditr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/gdemin/maditr/issues">https://github.com/gdemin/maditr/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># examples form 'dplyr' package
data(mtcars)

# Newly created variables are available immediately
mtcars %&gt;%
    let(
        cyl2 = cyl * 2,
        cyl4 = cyl2 * 2
    ) %&gt;%
    head()

# You can also use let() to remove variables and
# modify existing variables
mtcars %&gt;%
    let(
        mpg = NULL,
        disp = disp * 0.0163871 # convert to litres
    ) %&gt;%
    head()


# window functions are useful for grouped computations
mtcars %&gt;%
    let(rank = rank(-mpg, ties.method = "min"),
        by = cyl) %&gt;%
    head()

# You can drop variables by setting them to NULL
mtcars %&gt;% let(cyl = NULL) %&gt;% head()

# keeps all existing variables
mtcars %&gt;%
    let(displ_l = disp / 61.0237) %&gt;%
    head()

# keeps only the variables you create
mtcars %&gt;%
    take(displ_l = disp / 61.0237)


# can refer to both contextual variables and variable names:
var = 100
mtcars %&gt;%
    let(cyl = cyl * var) %&gt;%
    head()

# select rows
mtcars %&gt;%
    rows(am==0) %&gt;%
    head()

# select rows with compound condition
mtcars %&gt;%
    rows(am==0 &amp; mpg&gt;mean(mpg))

# select columns
mtcars %&gt;%
    columns(vs:carb, cyl)

mtcars %&gt;%
    columns(-am, -cyl)

# regular expression pattern
columns(iris, "^Petal") # variables which start from 'Petal'
columns(iris, "Width$") # variables which end with 'Width'

# move Species variable to the front
# pattern "^." matches all variables
columns(iris, Species, "^.")

# pattern "^.*al" means "contains 'al'"
columns(iris, "^.*al")

# numeric indexing - all variables except Species
columns(iris, 1:4)

# A 'take' with summary functions applied without 'by' argument returns an aggregated data
mtcars %&gt;%
    take(mean = mean(disp), n = .N)

# Usually, you'll want to group first
mtcars %&gt;%
    take(mean = mean(disp), n = .N, by = cyl)

# You can group by expressions:
mtcars %&gt;%
    take_all(mean, by = list(vsam = vs + am))

# modify all non-grouping variables in-place
mtcars %&gt;%
    let_all((.x - mean(.x))/sd(.x), by = am) %&gt;%
    head()

# modify all non-grouping variables to new variables
mtcars %&gt;%
    let_all(scaled = (.x - mean(.x))/sd(.x), by = am) %&gt;%
    head()

# conditionally modify all variables
iris %&gt;%
    let_all(mean = if(is.numeric(.x)) mean(.x)) %&gt;%
    head()

# modify all variables conditionally on name
iris %&gt;%
    let_all(
        mean = if(startsWith(.name, "Sepal")) mean(.x),
        median = if(startsWith(.name, "Petal")) median(.x),
        by = Species
    ) %&gt;%
    head()

# aggregation with 'take_all'
mtcars %&gt;%
    take_all(mean = mean(.x), sd = sd(.x), n = .N, by = am)

# conditionally aggregate all variables
iris %&gt;%
    take_all(mean = if(is.numeric(.x)) mean(.x))

# aggregate all variables conditionally on name
iris %&gt;%
    take_all(
        mean = if(startsWith(.name, "Sepal")) mean(.x),
        median = if(startsWith(.name, "Petal")) median(.x),
        by = Species
    )

# parametric evaluation:
var = quote(mean(cyl))
mtcars %&gt;%
    let(mean_cyl = eval(var)) %&gt;%
    head()
take(mtcars, eval(var))

# all together
new_var = "mean_cyl"
mtcars %&gt;%
    let((new_var) := eval(var)) %&gt;%
    head()
take(mtcars, (new_var) := eval(var))

########################################
# variable selection

# range selection
iris %&gt;%
    let(
        avg = rowMeans(Sepal.Length %to% Petal.Width)
    ) %&gt;%
    head()

# multiassignment
iris %&gt;%
    let(
        # starts with Sepal or Petal
        multipled1 %to% multipled4 := cols("^(Sepal|Petal)")*2
    ) %&gt;%
    head()


mtcars %&gt;%
    let(
        # text expansion
        cols("scaled_{names(mtcars)}") := lapply(cols("{names(mtcars)}"), scale)
    ) %&gt;%
    head()

# range selection in 'by'
# range selection  + additional column
mtcars %&gt;%
    take(
        res = sum(cols(mpg, disp %to% drat)),
        by = vs %to% gear
    )

</code></pre>

<hr>
<h2 id='coalesce'>Return first non-missing element</h2><span id='topic+coalesce'></span>

<h3>Description</h3>

<p>It is an alias for data.table <code>fcoalesce</code>. For details see <a href="data.table.html#topic+coalesce">fcoalesce</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalesce_+3A_...">...</code></td>
<td>
<p>vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as the first ... argument with NA
values replaced by the first non-missing value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples from dplyr
x = sample(c(1:5, NA, NA, NA))
coalesce(x, 0L)

y = c(1, 2, NA, NA, 5)
z = c(NA, NA, 3, 4, 5)
coalesce(y, z)
</code></pre>

<hr>
<h2 id='columns'>Selects columns or rows from the data set</h2><span id='topic+columns'></span><span id='topic+cols'></span><span id='topic+rows'></span>

<h3>Description</h3>


<ul>
<li> <p><code>columns</code>: select columns from dataset. There are four ways of column selection:
</p>
</li></ul>


<ol>
<li><p> Simply by column names
</p>
</li>
<li><p> By variable ranges, e. g. vs:carb. Alternatively, you can use '%to%'
instead of colon: 'vs %to% carb'.
</p>
</li>
<li><p> With regular expressions. Characters which start with '^' or end with '$'
considered as Perl-style regular expression patterns. For example, '^Petal'
returns all variables started with 'Petal'. 'Width$' returns all variables
which end with 'Width'. Pattern '^.' matches all variables and pattern
'^.*my_str' is equivalent to contains &quot;my_str&quot;'.
</p>
</li>
<li><p> By character variables with interpolated parts. Expression in the curly
brackets inside characters will be evaluated in the parent frame with
<a href="#topic+text_expand">text_expand</a>. For example, <code style="white-space: pre;">&#8288;a{1:3}&#8288;</code> will be transformed to the names 'a1',
'a2', 'a3'. 'cols' is just a shortcut for 'columns'. See examples.
</p>
</li></ol>

<div class="sourceCode"></div>

<ul>
<li> <p><code>rows</code>: select rows from dataset by logical conditions.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>columns(data, ...)

cols(data, ...)

rows(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="columns_+3A_data">data</code></td>
<td>
<p>data.table/data.frame</p>
</td></tr>
<tr><td><code id="columns_+3A_...">...</code></td>
<td>
<p>unquoted or quoted column names, regex selectors or variable
ranges for 'columns' and logical conditions for 'rows'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame/data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## columns
mtcars %&gt;%
    columns(vs:carb, cyl)
mtcars %&gt;%
    columns(-am, -cyl)

# regular expression pattern
columns(iris, "^Petal") %&gt;% head() # variables which start from 'Petal'
columns(iris, "Width$") %&gt;% head() # variables which end with 'Width'
# move Species variable to the front.
# pattern "^." matches all variables
columns(iris, Species, "^.") %&gt;% head()
# pattern "^.*i" means "contains 'i'"
columns(iris, "^.*i") %&gt;% head()
# numeric indexing - all variables except Species
columns(iris, 1:4) %&gt;% head()

# variable expansion
dims = c("Width", "Length")
columns(iris, "Petal.{dims}") %&gt;% head()

# rows

mtcars %&gt;%
    rows(am==0) %&gt;%
    head()

# select rows with compound condition
mtcars %&gt;%
    rows(am==0 &amp; mpg&gt;mean(mpg))

</code></pre>

<hr>
<h2 id='copy'>Copy an entire object</h2><span id='topic+copy'></span>

<h3>Description</h3>

<p>Mainly intended to copy data.table objects because by default they are modified by reference. See example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>copy of the object 'x'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
dt_mtcars = as.data.table(mtcars)
dt_mtcars2 = dt_mtcars
dt_mtcars3 = copy(dt_mtcars)
let(dt_mtcars, new = 1)

head(dt_mtcars2) # we see 'new' column
head(dt_mtcars3) # no 'new' column
</code></pre>

<hr>
<h2 id='dcast'>Convert data between wide and long forms.</h2><span id='topic+dcast'></span><span id='topic+melt'></span><span id='topic+guess'></span>

<h3>Description</h3>

<p>The <code>dcast</code> formula takes the form <code>LHS ~ RHS</code>, ex: <code>var1 + var2 ~ var3</code>. The
order of entries in the formula is essential. There are two special
variables: <code>.</code> and <code>...</code>. <code>.</code> represents no variable; <code>...</code> represents all
variables not otherwise mentioned in formula. LHS variable values will be in
rows. RHS variables values will become column names.
<code>fun.aggregate(value.var)</code> will be cell values. For details see
<a href="data.table.html#topic+dcast.data.table">dcast</a> and <a href="data.table.html#topic+melt.data.table">melt</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcast(
  data,
  formula,
  fun.aggregate = NULL,
  sep = "_",
  ...,
  margins = NULL,
  subset = NULL,
  fill = NULL,
  drop = TRUE,
  value.var = guess(data),
  verbose = getOption("datatable.verbose")
)

melt(
  data,
  id.vars,
  measure.vars,
  variable.name = "variable",
  value.name = "value",
  ...,
  na.rm = FALSE,
  variable.factor = TRUE,
  value.factor = FALSE,
  verbose = getOption("datatable.verbose")
)

guess(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcast_+3A_data">data</code></td>
<td>
<p>A data.table/data.frame. <code>data.frame</code> will be automatically
converted to data.table.</p>
</td></tr>
<tr><td><code id="dcast_+3A_formula">formula</code></td>
<td>
<p>A formula of the form LHS ~ RHS to cast. For details see <a href="data.table.html#topic+dcast.data.table">dcast</a>.</p>
</td></tr>
<tr><td><code id="dcast_+3A_fun.aggregate">fun.aggregate</code></td>
<td>
<p>Should the data be aggregated before casting? If the
formula doesn't identify a single observation for each cell, then
aggregation defaults to length with a message.</p>
</td></tr>
<tr><td><code id="dcast_+3A_sep">sep</code></td>
<td>
<p>Character vector of length 1, indicating the separating character
in variable names generated during casting. Default is _ for backwards
compatibility.</p>
</td></tr>
<tr><td><code id="dcast_+3A_...">...</code></td>
<td>
<p>Any other arguments that may be passed to the aggregating function.</p>
</td></tr>
<tr><td><code id="dcast_+3A_margins">margins</code></td>
<td>
<p>For details see <a href="data.table.html#topic+dcast.data.table">dcast</a>.</p>
</td></tr>
<tr><td><code id="dcast_+3A_subset">subset</code></td>
<td>
<p>Specified if casting should be done on a subset of the data.</p>
</td></tr>
<tr><td><code id="dcast_+3A_fill">fill</code></td>
<td>
<p>Value with which to fill missing cells. If fun.aggregate is
present, takes the value by applying the function on a 0-length vector.</p>
</td></tr>
<tr><td><code id="dcast_+3A_drop">drop</code></td>
<td>
<p>FALSE will cast by including all missing combinations. c(FALSE,
TRUE) will only include all missing combinations of formula LHS. And
c(TRUE, FALSE) will only include all missing combinations of formula RHS.</p>
</td></tr>
<tr><td><code id="dcast_+3A_value.var">value.var</code></td>
<td>
<p>Name of the column whose values will be filled to cast.
Function 'guess()' tries to, well, guess this column automatically, if none
is provided. It is possible to cast multiple 'value.var&ldquo; columns
simultaneously. For details see <a href="data.table.html#topic+dcast.data.table">dcast</a>.</p>
</td></tr>
<tr><td><code id="dcast_+3A_verbose">verbose</code></td>
<td>
<p>For details see <a href="data.table.html#topic+dcast.data.table">dcast</a>.</p>
</td></tr>
<tr><td><code id="dcast_+3A_id.vars">id.vars</code></td>
<td>
<p>vector of id variables. Can be integer (corresponding id
column numbers) or character (id column names) vector. If missing, all
non-measure columns will be assigned to it. If integer, must be positive;
see Details.</p>
</td></tr>
<tr><td><code id="dcast_+3A_measure.vars">measure.vars</code></td>
<td>
<p>Measure variables for melting. Can be missing, vector,
list, or pattern-based. For details see <a href="data.table.html#topic+dcast.data.table">dcast</a>.</p>
</td></tr>
<tr><td><code id="dcast_+3A_variable.name">variable.name</code></td>
<td>
<p>name for the measured variable names column. The default name is 'variable'.</p>
</td></tr>
<tr><td><code id="dcast_+3A_value.name">value.name</code></td>
<td>
<p>name for the molten data values column(s). The default name
is 'value'. Multiple names can be provided here for the case when
measure.vars is a list, though note well that the names provided in
measure.vars take precedence.</p>
</td></tr>
<tr><td><code id="dcast_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA values will be removed from the molten data.</p>
</td></tr>
<tr><td><code id="dcast_+3A_variable.factor">variable.factor</code></td>
<td>
<p>If TRUE, the variable column will be converted to
factor, else it will be a character column.</p>
</td></tr>
<tr><td><code id="dcast_+3A_value.factor">value.factor</code></td>
<td>
<p>If TRUE, the value column will be converted to factor,
else the molten value type is left unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>Author(s)</h3>

<p>Matt Dowle <a href="mailto:mattjdowle@gmail.com">mattjdowle@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples from 'tidyr' package
stocks = data.frame(
    time = as.Date('2009-01-01') + 0:9,
    X = rnorm(10, 0, 1),
    Y = rnorm(10, 0, 2),
    Z = rnorm(10, 0, 4)
)
stocksm = stocks %&gt;%
    melt(id.vars = "time", variable.name = "stock", value.name = "price")
stocksm %&gt;% dcast(time ~ stock)
stocksm %&gt;% dcast(stock ~ time)

# dcast and melt are complements
df = data.frame(x = c("a", "b"), y = c(3, 4), z = c(5, 6))
df %&gt;%
    dcast(z ~ x, value.var = "y") %&gt;%
    melt(id.vars = "z", variable.name = "x", value.name = "y", na.rm = TRUE)
</code></pre>

<hr>
<h2 id='dt_count'>Additional useful functions</h2><span id='topic+dt_count'></span><span id='topic+dt_add_count'></span><span id='topic+dt_top_n'></span>

<h3>Description</h3>


<ul>
<li> <p><code>dt_count</code> calculates number of cases by groups, possibly
weighted. <code>dt_add_count</code> adds number of cases to existing dataset.
</p>
</li>
<li> <p><code>dt_top_n</code> returns top n rows from each group.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dt_count(data, ..., weight = NULL, sort = FALSE, name = "n")

dt_add_count(data, ..., weight = NULL, sort = FALSE, name = "n")

dt_top_n(data, n, by, order_by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt_count_+3A_data">data</code></td>
<td>
<p>data.table/data.frame data.frame will be automatically converted
to data.table.</p>
</td></tr>
<tr><td><code id="dt_count_+3A_...">...</code></td>
<td>
<p>variables to group by.</p>
</td></tr>
<tr><td><code id="dt_count_+3A_weight">weight</code></td>
<td>
<p>optional. Unquoted variable name. If provided result will be the sum of this variable by groups.</p>
</td></tr>
<tr><td><code id="dt_count_+3A_sort">sort</code></td>
<td>
<p>logical. If TRUE result will be sorted in desending order by resulting variable.</p>
</td></tr>
<tr><td><code id="dt_count_+3A_name">name</code></td>
<td>
<p>character. Name of resulting variable.</p>
</td></tr>
<tr><td><code id="dt_count_+3A_n">n</code></td>
<td>
<p>numeric. number of top cases. If n is negative then bottom values will be returned.</p>
</td></tr>
<tr><td><code id="dt_count_+3A_by">by</code></td>
<td>
<p>list or vector of grouping variables</p>
</td></tr>
<tr><td><code id="dt_count_+3A_order_by">order_by</code></td>
<td>
<p>unquoted variable name by which result will be sorted. If not
specified, defaults to the last variable in the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtcars)

# dt_count
dt_count(mtcars, am, vs)
dt_add_count(mtcars, am, vs, name = "am_vs")[] # [] for autoprinting

# dt_top_n
dt_top_n(mtcars, 2, by  = list(am, vs))
dt_top_n(mtcars, 2, order_by = mpg, by  = list(am, vs))
</code></pre>

<hr>
<h2 id='dt_left_join'>Join two data.frames by common columns.</h2><span id='topic+dt_left_join'></span><span id='topic+dt_right_join'></span><span id='topic+dt_inner_join'></span><span id='topic+dt_full_join'></span><span id='topic+dt_semi_join'></span><span id='topic+dt_anti_join'></span>

<h3>Description</h3>

<p>Do different versions of SQL join operations. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_left_join(x, y, by = NULL, suffix = c(".x", ".y"))

dt_right_join(x, y, by = NULL, suffix = c(".x", ".y"))

dt_inner_join(x, y, by = NULL, suffix = c(".x", ".y"))

dt_full_join(x, y, by = NULL, suffix = c(".x", ".y"))

dt_semi_join(x, y, by = NULL)

dt_anti_join(x, y, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt_left_join_+3A_x">x</code></td>
<td>
<p>data.frame or data.table</p>
</td></tr>
<tr><td><code id="dt_left_join_+3A_y">y</code></td>
<td>
<p>data.frame or data.table</p>
</td></tr>
<tr><td><code id="dt_left_join_+3A_by">by</code></td>
<td>
<p>a character vector of variables to join by. If NULL, the default,
*_join() will do a natural join, using all variables with common names
across the two tables. A message lists the variables so that you can check
they're right (to suppress the message, simply explicitly list the
variables that you want to join). To join by different variables on x and y
use a named vector. For example, <code>by = c("a" = "b")</code> will match x.a to y.b.</p>
</td></tr>
<tr><td><code id="dt_left_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in x and y, these
suffixes will be added to the output to disambiguate them. Should be a
character vector of length 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>workers = fread("
    name company
    Nick Acme
    John Ajax
    Daniela Ajax
")

positions = fread("
    name position
    John designer
    Daniela engineer
    Cathie manager
")

workers %&gt;% dt_inner_join(positions)
workers %&gt;% dt_left_join(positions)
workers %&gt;% dt_right_join(positions)
workers %&gt;% dt_full_join(positions)

# filtering joins
workers %&gt;% dt_anti_join(positions)
workers %&gt;% dt_semi_join(positions)

# To suppress the message, supply 'by' argument
workers %&gt;% dt_left_join(positions, by = "name")

# Use a named 'by' if the join variables have different names
positions2 = setNames(positions, c("worker", "position")) # rename first column in 'positions'
workers %&gt;% dt_inner_join(positions2, by = c("name" = "worker"))
</code></pre>

<hr>
<h2 id='dt_mutate'>'dplyr'-like interface for data.table.</h2><span id='topic+dt_mutate'></span><span id='topic+dt_summarize'></span><span id='topic+dt_summarize_all'></span><span id='topic+dt_summarise'></span><span id='topic+dt_summarise_all'></span><span id='topic+dt_select'></span><span id='topic+dt_filter'></span><span id='topic+dt_arrange'></span>

<h3>Description</h3>

<p>Subset of 'dplyr' verbs to work with data.table. Note that there is no
<code>group_by</code> verb - use <code>by</code> or <code>keyby</code> argument when needed.
</p>

<ul>
<li> <p><code>dt_mutate</code> adds new variables or modify existing variables. If
<code>data</code> is data.table then it modifies in-place.
</p>
</li>
<li> <p><code>dt_summarize</code> computes summary statistics. Splits the data into
subsets, computes summary statistics for each, and returns the result in the
&quot;data.table&quot; form.
</p>
</li>
<li> <p><code>dt_summarize_all</code> is the same as <code>dt_summarize</code> but work over all non-grouping variables.
</p>
</li>
<li> <p><code>dt_filter</code> selects rows/cases where conditions are true. Rows
where the condition evaluates to NA are dropped.
</p>
</li>
<li> <p><code>dt_select</code> selects column/variables from the data set. Range of
variables are supported, e. g. vs:carb. Characters which start with '^' or
end with '$' considered as Perl-style regular expression patterns. For
example, '^Petal' returns all variables started with 'Petal'. 'Width$'
returns all variables which end with 'Width'. Pattern '^.' matches all
variables and pattern '^.*my_str' is equivalent to <code style="white-space: pre;">&#8288;contains "my_str"&#8288;</code>. See
examples.
</p>
</li>
<li> <p><code>dt_arrange</code> sorts dataset by variable(-s). Use '-' to sort in
descending order. If <code>data</code> is data.table then it modifies in-place.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dt_mutate(data, ..., by)

dt_summarize(data, ..., by, keyby, fun = NULL)

dt_summarize_all(data, fun, by, keyby)

dt_summarise(data, ..., by, keyby, fun = NULL)

dt_summarise_all(data, fun, by, keyby)

dt_select(data, ...)

dt_filter(data, ...)

dt_arrange(data, ..., na.last = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt_mutate_+3A_data">data</code></td>
<td>
<p>data.table/data.frame data.frame will be automatically converted
to data.table. <code>dt_mutate</code> modify data.table object in-place.</p>
</td></tr>
<tr><td><code id="dt_mutate_+3A_...">...</code></td>
<td>
<p>List of variables or name-value pairs of summary/modifications
functions. The name will be the name of the variable in the result. In the
<code>mutate</code> function we can use <code>a = b</code> or <code>a := b</code> notation.
Advantages of <code style="white-space: pre;">&#8288;:=&#8288;</code> are multiassignment (<code>c("a", "b") := list(1,2)</code>)
and parametric assignment (<code>(a) := 2</code>).</p>
</td></tr>
<tr><td><code id="dt_mutate_+3A_by">by</code></td>
<td>
<p>unquoted name of grouping variable of list of unquoted names of
grouping variables. For details see <a href="data.table.html#topic+data.table">data.table</a></p>
</td></tr>
<tr><td><code id="dt_mutate_+3A_keyby">keyby</code></td>
<td>
<p>Same as <code>by</code>, but with an additional <code>setkey()</code> run on the by
columns of the result, for convenience. It is common practice to use
'keyby=' routinely when you wish the result to be sorted. For details see
<a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="dt_mutate_+3A_fun">fun</code></td>
<td>
<p>function which will be applied to all variables in
<code>dt_summarize</code> and <code>dt_summarize_all</code>.</p>
</td></tr>
<tr><td><code id="dt_mutate_+3A_na.last">na.last</code></td>
<td>
<p>logical. FALSE by default. If TRUE, missing values in the data
are put last; if FALSE, they are put first.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples from 'dplyr'
# newly created variables are available immediately
mtcars  %&gt;%
    dt_mutate(
        cyl2 = cyl * 2,
        cyl4 = cyl2 * 2
    ) %&gt;%
    head()


# you can also use dt_mutate() to remove variables and
# modify existing variables
mtcars %&gt;%
    dt_mutate(
        mpg = NULL,
        disp = disp * 0.0163871 # convert to litres
    ) %&gt;%
    head()


# window functions are useful for grouped mutates
mtcars %&gt;%
    dt_mutate(
        rank = rank(-mpg, ties.method = "min"),
        keyby = cyl) %&gt;%
    print()


# You can drop variables by setting them to NULL
mtcars %&gt;% dt_mutate(cyl = NULL) %&gt;% head()

# A summary applied without by returns a single row
mtcars %&gt;%
    dt_summarise(mean = mean(disp), n = .N)

# Usually, you'll want to group first
mtcars %&gt;%
    dt_summarise(mean = mean(disp), n = .N, by = cyl)


# Multiple 'by' - variables
mtcars %&gt;%
    dt_summarise(cyl_n = .N, by = list(cyl, vs))

# Newly created summaries immediately
# doesn't overwrite existing variables
mtcars %&gt;%
    dt_summarise(disp = mean(disp),
                  sd = sd(disp),
                  by = cyl)

# You can group by expressions:
mtcars %&gt;%
    dt_summarise_all(mean, by = list(vsam = vs + am))

# filter by condition
mtcars %&gt;%
    dt_filter(am==0)

# filter by compound condition
mtcars %&gt;%
    dt_filter(am==0,  mpg&gt;mean(mpg))


# select
mtcars %&gt;% dt_select(vs:carb, cyl)
mtcars %&gt;% dt_select(-am, -cyl)

# regular expression pattern
dt_select(iris, "^Petal") # variables which start from 'Petal'
dt_select(iris, "Width$") # variables which end with 'Width'
# move Species variable to the front.
# pattern "^." matches all variables
dt_select(iris, Species, "^.")
# pattern "^.*i" means "contains 'i'"
dt_select(iris, "^.*i")
dt_select(iris, 1:4) # numeric indexing - all variables except Species

# sorting
dt_arrange(mtcars, cyl, disp)
dt_arrange(mtcars, -disp)
</code></pre>

<hr>
<h2 id='let_if'>Modify, aggregate, select or filter data.frame/data.table</h2><span id='topic+let_if'></span><span id='topic+take_if'></span><span id='topic+take'></span><span id='topic+let'></span><span id='topic+let.data.frame'></span><span id='topic+let.etable'></span><span id='topic+sort_by'></span><span id='topic+let_all'></span><span id='topic+take_all'></span>

<h3>Description</h3>


<ul>
<li> <p><code>let</code> adds new variables or modify existing variables. 'let_if' make
the same thing on the subset of rows.
</p>
</li>
<li> <p><code>take/take_if</code> aggregate data or aggregate subset of the data.
</p>
</li>
<li> <p><code>let_all</code> applies expressions to all variables in the dataset. It is also
possible to modify the subset of the variables.
</p>
</li>
<li> <p><code>take_all</code> aggregates all variables in the dataset. It is also possible
to aggregate the subset of the variables.
</p>
</li></ul>

<div class="sourceCode"></div>
<p>All functions return <code>data.table</code>. Expression in the 'take_all' and
'let_all' can use predefined variables: '.x' is a value of current variable ,
'.name' is a name of the variable and '.index' is sequential number of the
variable. '.value' is is an alias to '.x'.
</p>

<ul>
<li><p> Add new variables: <code>let(mtcars, new_var = 42, new_var2 = new_var*hp)</code>
</p>
</li>
<li><p> Select variables: <code>take(mtcars, am, vs, mpg)</code>
</p>
</li>
<li><p> Aggregate data: <code>take(mtcars, mean_mpg = mean(mpg), by = am)</code>
</p>
</li>
<li><p> Aggregate all non-grouping columns: <code>take_all(mtcars, mean = mean(.x), sd = sd(.x), n = .N, by = am)</code>
</p>
</li>
<li><p> Aggregate all numeric columns: <code>take_all(iris, if(is.numeric(.x)) mean(.x))</code>
</p>
</li>
<li><p> To modify all non-grouping variables:
</p>
</li></ul>

<div class="sourceCode"><pre>      iris %&gt;%
         let_all(
             scaled = (.x - mean(.x))/sd(.x),
             by = Species) %&gt;%
          head()
</pre></div>

<ul>
<li><p> Aggregate specific columns: <code>take_all(iris, if(startsWith(.name, "Sepal")) mean(.x))</code>
</p>
</li></ul>

<div class="sourceCode"></div>
<p>You can use 'columns' inside expression in the 'take'/'let'. 'columns' will
be replaced with data.table with selected columns. In 'let' in the
expressions with ':=', 'cols' or '%to%' can be placed in the left part of the
expression. It is usefull for multiple assignment.
There are four ways of column selection:
</p>

<ol>
<li><p> Simply by column names
</p>
</li>
<li><p> By variable ranges, e. g. vs:carb. Alternatively, you can use '%to%'
instead of colon: 'vs %to% carb'.
</p>
</li>
<li><p> With regular expressions. Characters which start with '^' or end with '$'
considered as Perl-style regular expression patterns. For example, '^Petal'
returns all variables started with 'Petal'. 'Width$' returns all variables
which end with 'Width'. Pattern '^.' matches all variables and pattern
'^.*my_str' is equivalent to contains &quot;my_str&quot;'.
</p>
</li>
<li><p> By character variables with interpolated parts. Expression in the curly
brackets inside characters will be evaluated in the parent frame with
<a href="#topic+text_expand">text_expand</a>. For example, <code style="white-space: pre;">&#8288;a{1:3}&#8288;</code> will be transformed to the names 'a1',
'a2', 'a3'. 'cols' is just a shortcut for 'columns'. See examples.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>let_if(data, i, ..., by, keyby)

take_if(data, i, ..., by, keyby, .SDcols, autoname = TRUE, fun = NULL)

take(data, ..., by, keyby, .SDcols, autoname = TRUE, fun = NULL)

let(data, ..., by, keyby)

## S3 method for class 'data.frame'
let(data, ..., by, keyby, i)

## S3 method for class 'etable'
let(data, ..., by, keyby, i)

sort_by(data, ..., na.last = FALSE)

let_all(data, ..., by, keyby, .SDcols, suffix = TRUE, sep = "_", i)

take_all(data, ..., by, keyby, .SDcols, suffix = TRUE, sep = "_", i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="let_if_+3A_data">data</code></td>
<td>
<p>data.table/data.frame data.frame will be automatically converted
to data.table. <code>let</code> modify data.table object in-place.</p>
</td></tr>
<tr><td><code id="let_if_+3A_i">i</code></td>
<td>
<p>integer/logical vector. Supposed to use to subset/conditional
modifications of <code>data</code>. For details see <a href="data.table.html#topic+data.table">data.table</a></p>
</td></tr>
<tr><td><code id="let_if_+3A_...">...</code></td>
<td>
<p>List of variables or name-value pairs of summary/modifications
functions. The name will be the name of the variable in the result. In the
<code>let</code> and <code>take</code> functions we can use <code>a = b</code> or <code>a := b</code> notation. Advantages of <code style="white-space: pre;">&#8288;:=&#8288;</code> is parametric assignment, e. g.
<code>(a) := 2</code> create variable with name which are stored in <code>a</code>. In
<code>let</code> <code style="white-space: pre;">&#8288;:=&#8288;</code> can be used for multiassignment (<code>c("a", "b")  := list(1,2)</code>). Expression in the 'take_all' and 'let_all' can use predefined
variables: '.x' is a value of current variable, '.name' is a name of
the variable and '.index' is sequential number of the variable. '.value' is
is an alias to '.x'.</p>
</td></tr>
<tr><td><code id="let_if_+3A_by">by</code></td>
<td>
<p>unquoted name of grouping variable of list of unquoted names of
grouping variables. For details see <a href="data.table.html#topic+data.table">data.table</a></p>
</td></tr>
<tr><td><code id="let_if_+3A_keyby">keyby</code></td>
<td>
<p>Same as <code>by</code>, but with an additional <code>setkey()</code> run on the by
columns of the result, for convenience. It is common practice to use
'keyby=' routinely when you wish the result to be sorted. For details see
<a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="let_if_+3A_.sdcols">.SDcols</code></td>
<td>
<p>Specifies the columns of x to be included in the special
symbol .SD which stands for Subset of data.table. May be character column
names or numeric positions. For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="let_if_+3A_autoname">autoname</code></td>
<td>
<p>logical. TRUE by default. Should we create names for  unnamed expressions in <code>take</code>?</p>
</td></tr>
<tr><td><code id="let_if_+3A_fun">fun</code></td>
<td>
<p>Function which will be applied to all variables in <code>take</code>. If
there are no variables in <code>take</code> then it will be applied to all
non-grouping variables in the <code>data</code>.</p>
</td></tr>
<tr><td><code id="let_if_+3A_na.last">na.last</code></td>
<td>
<p>logical. FALSE by default. If TRUE, missing values in the data
are put last; if FALSE, they are put first.</p>
</td></tr>
<tr><td><code id="let_if_+3A_suffix">suffix</code></td>
<td>
<p>logical TRUE by default. For 'let_all'/'take_all'. If TRUE than
we append summary name to the end of the variable name. If FALSE summary
name will be added at the begining of the variable name.</p>
</td></tr>
<tr><td><code id="let_if_+3A_sep">sep</code></td>
<td>
<p>character. &quot;_&quot; by default. Separator between the old variables
name and prefix or suffix for 'let_all' and 'take_all'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table. <code>let</code> returns its result invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples form 'dplyr' package
data(mtcars)

# Newly created variables are available immediately
mtcars %&gt;%
    let(
        cyl2 = cyl * 2,
        cyl4 = cyl2 * 2
    ) %&gt;% head()

# You can also use let() to remove variables and
# modify existing variables
mtcars %&gt;%
    let(
        mpg = NULL,
        disp = disp * 0.0163871 # convert to litres
    ) %&gt;% head()


# window functions are useful for grouped computations
mtcars %&gt;%
    let(rank = rank(-mpg, ties.method = "min"),
        by = cyl) %&gt;%
    head()

# You can drop variables by setting them to NULL
mtcars %&gt;% let(cyl = NULL) %&gt;% head()

# keeps all existing variables
mtcars %&gt;%
    let(displ_l = disp / 61.0237) %&gt;%
    head()

# keeps only the variables you create
mtcars %&gt;%
    take(displ_l = disp / 61.0237)


# can refer to both contextual variables and variable names:
var = 100
mtcars %&gt;%
    let(cyl = cyl * var) %&gt;%
    head()


# A 'take' with summary functions applied without 'by' argument returns an aggregated data
mtcars %&gt;%
    take(mean = mean(disp), n = .N)

# Usually, you'll want to group first
mtcars %&gt;%
    take(mean = mean(disp), n = .N, by = cyl)

# You can group by expressions:
mtcars %&gt;%
    take_all(mean, by = list(vsam = vs + am))

# modify all non-grouping variables in-place
mtcars %&gt;%
    let_all((.x - mean(.x))/sd(.x), by = am) %&gt;%
    head()

# modify all non-grouping variables to new variables
mtcars %&gt;%
    let_all(scaled = (.x - mean(.x))/sd(.x), by = am) %&gt;%
    head()

# conditionally modify all variables
iris %&gt;%
    let_all(mean = if(is.numeric(.x)) mean(.x)) %&gt;%
    head()

# modify all variables conditionally on name
iris %&gt;%
    let_all(
        mean = if(startsWith(.name, "Sepal")) mean(.x),
        median = if(startsWith(.name, "Petal")) median(.x),
        by = Species
    ) %&gt;%
    head()

# aggregation with 'take_all'
mtcars %&gt;%
    take_all(mean = mean(.x), sd = sd(.x), n = .N, by = am)

# conditionally aggregate all variables
iris %&gt;%
    take_all(mean = if(is.numeric(.x)) mean(.x))

# aggregate all variables conditionally on name
iris %&gt;%
    take_all(
        mean = if(startsWith(.name, "Sepal")) mean(.x),
        median = if(startsWith(.name, "Petal")) median(.x),
        by = Species
    )

# parametric evaluation:
var = quote(mean(cyl))
mtcars %&gt;%
    let(mean_cyl = eval(var)) %&gt;%
    head()
take(mtcars, eval(var))

# all together
new_var = "mean_cyl"
mtcars %&gt;%
    let((new_var) := eval(var)) %&gt;%
    head()
take(mtcars, (new_var) := eval(var))

########################################

# variable selection

# range selection
iris %&gt;%
    let(
        avg = rowMeans(Sepal.Length %to% Petal.Width)
    ) %&gt;%
    head()

# multiassignment
iris %&gt;%
    let(
        # starts with Sepal or Petal
        multipled1 %to% multipled4 := cols("^(Sepal|Petal)")*2
    ) %&gt;%
    head()


mtcars %&gt;%
    let(
        # text expansion
        cols("scaled_{names(mtcars)}") := lapply(cols("{names(mtcars)}"), scale)
    ) %&gt;%
    head()

# range selection in 'by'
# range selection  + additional column
mtcars %&gt;%
    take(
        res = sum(cols(mpg, disp %to% drat)),
        by = vs %to% gear
    )

########################################

# examples from data.table
dat = data.table(
    x=rep(c("b","a","c"), each=3),
    y=c(1,3,6),
    v=1:9
)

# basic row subset operations
take_if(dat, 2)                         # 2nd row
take_if(dat, 3:2)                       # 3rd and 2nd row
take_if(dat, order(x))                  # no need for order(dat$x)
take_if(dat, y&gt;2)                       # all rows where dat$y &gt; 2
take_if(dat, y&gt;2 &amp; v&gt;5)                 # compound logical expressions
take_if(dat, !2:4)                      # all rows other than 2:4
take_if(dat, -(2:4))                    # same

# select|compute columns
take(dat, v)                  # v column (as data.table)
take(dat, sum(v))             # return data.table with sum of v (column autonamed 'sum(v)')
take(dat, sv = sum(v))        # same, but column named "sv"
take(dat, v, v*2)             # return two column data.table, v and v*2

# subset rows and select|compute
take_if(dat, 2:3, sum(v))      # sum(v) over rows 2 and 3
take_if(dat, 2:3, sv = sum(v)) # same, but return data.table with column sv

# grouping operations
take(dat, sum(v), by = x)             # ad hoc by, order of groups preserved in result
take(dat, sum(v), keyby = x)          # same, but order the result on by cols


# all together now
take_if(dat, x!="a", sum(v), by=x)                       # get sum(v) by "x" for each x != "a"

# more on special symbols, see also ?"data.table::special-symbols"
take_if(dat, .N)                           # last row
take(dat, .N)                              # total number of rows in DT
take(dat, .N, by=x)                        # number of rows in each group

take(dat, .I[1], by=x)                     # row number in DT corresponding to each group


# add/update/delete by reference
# [] at the end of expression is for autoprinting
let(dat, grp = .GRP, by=x)[]          # add a group counter column
let(dat, z = 42L)[]                   # add new column by reference
let(dat, z = NULL)[]                  # remove column by reference
let_if(dat, x=="a", v = 42L)[]        # subassign to existing v column by reference
let_if(dat, x=="b", v2 = 84L)[]       # subassign to new column by reference (NA padded)

let(dat, m = mean(v), by=x)[]         # add new column by reference by group

# advanced usage
dat = data.table(x=rep(c("b","a","c"), each=3),
                 v=c(1,1,1,2,2,1,1,2,2),
                 y=c(1,3,6),
                 a=1:9,
                 b=9:1)

take(dat, sum(v), by=list(y%%2))              # expressions in by
take(dat, sum(v), by=list(bool = y%%2))       # same, using a named list to change by column name
take_all(dat, sum, by=x)                      # sum of all (other) columns for each group
take(dat,
     MySum=sum(v),
     MyMin=min(v),
     MyMax=max(v),
     by = list(x, y%%2)               # by 2 expressions
)

take(dat, seq = min(a):max(b), by=x)  # j is not limited to just aggregations
dat %&gt;%
    take(V1 = sum(v), by=x) %&gt;%
    take_if(V1&lt;20)                    # compound query

dat %&gt;%
    take(V1 = sum(v), by=x) %&gt;%
    sort_by(-V1) %&gt;%                  # ordering results
    head()


</code></pre>

<hr>
<h2 id='query_if'>One-to-one interface for data.table '[' method</h2><span id='topic+query_if'></span><span id='topic+query'></span>

<h3>Description</h3>

<p>Quote from <a href="data.table.html#topic+data.table">data.table</a>:
</p>
<div class="sourceCode"><pre>query(data, j,  by) # + extra arguments
            |   |
            |    -------&gt; grouped by what?
             -------&gt; what to do?
</pre></div>
<p>or,
</p>
<div class="sourceCode"><pre>query_if(data, i,  j,  by) # + extra arguments
               |   |   |
               |   |    -------&gt; grouped by what?
               |    -------&gt; what to do?
                ---&gt; on which rows?
</pre></div>
<p>If you don't need '<code>i</code>' argument, use '<code>query</code>'. In this case you can
avoid printing leading comma inside brackets to denote empty '<code>i</code>'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_if(
  data,
  i,
  j,
  by,
  keyby,
  with = TRUE,
  nomatch = getOption("datatable.nomatch"),
  mult = "all",
  roll = FALSE,
  rollends = if (roll == "nearest") c(TRUE, TRUE) else if (roll &gt;= 0) c(FALSE, TRUE) else
    c(TRUE, FALSE),
  which = FALSE,
  .SDcols,
  verbose = getOption("datatable.verbose"),
  allow.cartesian = getOption("datatable.allow.cartesian"),
  drop = NULL,
  on = NULL
)

query(
  data,
  j,
  by,
  keyby,
  with = TRUE,
  nomatch = getOption("datatable.nomatch"),
  mult = "all",
  roll = FALSE,
  rollends = if (roll == "nearest") c(TRUE, TRUE) else if (roll &gt;= 0) c(FALSE, TRUE) else
    c(TRUE, FALSE),
  which = FALSE,
  .SDcols,
  verbose = getOption("datatable.verbose"),
  allow.cartesian = getOption("datatable.allow.cartesian"),
  drop = NULL,
  on = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_if_+3A_data">data</code></td>
<td>
<p>data.table/data.frame data.frame will be automatically converted
to data.table.</p>
</td></tr>
<tr><td><code id="query_if_+3A_i">i</code></td>
<td>
<p>Integer, logical or character vector, single column numeric matrix,
expression of column names, list, data.frame or data.table. integer and
logical vectors work the same way they do in [.data.frame except logical
NAs are treated as FALSE. expression is evaluated within the frame of the
data.table (i.e. it sees column names as if they are variables) and can
evaluate to any of the other types. For details see
<a href="data.table.html#topic+data.table">data.table</a></p>
</td></tr>
<tr><td><code id="query_if_+3A_j">j</code></td>
<td>
<p>When with=TRUE (default), j is evaluated within the frame of the
data.table; i.e., it sees column names as if they are variables. This
allows to not just select columns in j, but also compute on them e.g., <code>x[,a]</code>
and <code>x[, sum(a)]</code> returns <code>x$a</code> and <code>sum(x$a)</code> as a vector respectively.
<code>x[, .(a, b)]</code> and <code>x[, .(sa=sum(a), sb=sum(b))]</code> returns a two column data.table
each, the first simply selecting columns a, b and the second computing
their sums. For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_by">by</code></td>
<td>
<p>unquoted name of grouping variable of list of unquoted names of
grouping variables. For details see <a href="data.table.html#topic+data.table">data.table</a></p>
</td></tr>
<tr><td><code id="query_if_+3A_keyby">keyby</code></td>
<td>
<p>Same as by, but with an additional <code>setkey()</code> run on the by
columns of the result, for convenience. It is common practice to use
'keyby=' routinely when you wish the result to be sorted. For details see
<a href="data.table.html#topic+data.table">data.table</a></p>
</td></tr>
<tr><td><code id="query_if_+3A_with">with</code></td>
<td>
<p>logical. For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_nomatch">nomatch</code></td>
<td>
<p>Same as nomatch in match. For details see
<a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_mult">mult</code></td>
<td>
<p>For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_roll">roll</code></td>
<td>
<p>For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_rollends">rollends</code></td>
<td>
<p>For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_which">which</code></td>
<td>
<p>For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_.sdcols">.SDcols</code></td>
<td>
<p>Specifies the columns of x to be included in the special
symbol .SD which stands for Subset of data.table. May be character column
names or numeric positions. For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_verbose">verbose</code></td>
<td>
<p>logical. For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_allow.cartesian">allow.cartesian</code></td>
<td>
<p>For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_drop">drop</code></td>
<td>
<p>For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
<tr><td><code id="query_if_+3A_on">on</code></td>
<td>
<p>For details see <a href="data.table.html#topic+data.table">data.table</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It depends. For details see <a href="data.table.html#topic+data.table">data.table</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# examples from data.table
dat = data.table(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
dat
# basic row subset operations
query_if(dat, 2)                        # 2nd row
query_if(dat, 3:2)                        # 3rd and 2nd row
query_if(dat, order(x))                   # no need for order(dat$x)
query_if(dat, y&gt;2)                        # all rows where dat$y &gt; 2
query_if(dat, y&gt;2 &amp; v&gt;5)                  # compound logical expressions
query_if(dat, !2:4)                       # all rows other than 2:4
query_if(dat, -(2:4))                     # same

# select|compute columns data.table way
query(dat, v)                        # v column (as vector)
query(dat, list(v))                  # v column (as data.table)
query(dat, sum(v))                   # sum of column v, returned as vector
query(dat, list(sum(v)))             # same, but return data.table (column autonamed V1)
query(dat, list(v, v*2))             # return two column data.table, v and v*2

# subset rows and select|compute data.table way
query_if(dat, 2:3, sum(v))                # sum(v) over rows 2 and 3, return vector
query_if(dat, 2:3, list(sum(v)))             # same, but return data.table with column V1
query_if(dat, 2:3, list(sv=sum(v)))          # same, but return data.table with column sv
query_if(dat, 2:5, cat(v, "\n"))          # just for j's side effect

# select columns the data.frame way
query(dat, 2, with=FALSE)            # 2nd column, returns a data.table always
colNum = 2
query(dat, colNum, with=FALSE)       # same, equivalent to DT[, .SD, .SDcols=colNum]

# grouping operations - j and by
query(dat, sum(v), by=x)             # ad hoc by, order of groups preserved in result
query(dat, sum(v), keyby=x)          # same, but order the result on by cols
query(dat, sum(v), by=x) %&gt;%
    query_if(order(x))               # same but by chaining expressions together

# fast ad hoc row subsets (subsets as joins)
# same as x == "a" but uses binary search (fast)
query_if(dat, "a", on="x")
# same, for convenience, no need to quote every column
query_if(dat, "a", on=list(x))
query_if(dat, .("a"), on="x")                          # same
# same, single "==" internally optimised to use binary search (fast)
query_if(dat, x=="a")
# not yet optimized, currently vector scan subset
query_if(dat, x!="b" | y!=3)
# join on columns x,y of 'dat'; uses binary search (fast)
query_if(dat, .("b", 3), on=c("x", "y"))
query_if(dat, .("b", 3), on=list(x, y))                # same, but using on=list()
query_if(dat, .("b", 1:2), on=c("x", "y"))             # no match returns NA
query_if(dat, .("b", 1:2), on=.(x, y), nomatch=0)      # no match row is not returned
# locf, nomatch row gets rolled by previous row
query_if(dat, .("b", 1:2), on=c("x", "y"), roll=Inf)
query_if(dat, .("b", 1:2), on=.(x, y), roll=-Inf)      # nocb, nomatch row gets rolled by next row
# on rows where dat$x=="b", calculate sum(v*y)
query_if(dat, "b", sum(v*y), on="x")

# all together now
query_if(dat, x!="a", sum(v), by=x)                    # get sum(v) by "x" for each i != "a"
query_if(dat, !"a", sum(v), by=.EACHI, on="x")         # same, but using subsets-as-joins
query_if(dat, c("b","c"), sum(v), by=.EACHI, on="x")   # same
query_if(dat, c("b","c"), sum(v), by=.EACHI, on=.(x))  # same, using on=.()

# joins as subsets
X = data.table(x=c("c","b"), v=8:7, foo=c(4,2))
X

query_if(dat, X, on="x")                         # right join
query_if(X, dat, on="x")                         # left join
query_if(dat, X, on="x", nomatch=0)              # inner join
query_if(dat, !X, on="x")                        # not join
# join using column "y" of 'dat' with column "v" of X
query_if(dat, X, on=c(y="v"))
query_if(dat,X, on="y==v")                       # same as above (v1.9.8+)

query_if(dat, X, on = .(y&lt;=foo))                 # NEW non-equi join (v1.9.8+)
query_if(dat, X, on="y&lt;=foo")                    # same as above
query_if(dat, X, on=c("y&lt;=foo"))                 # same as above
query_if(dat, X, on=.(y&gt;=foo))                   # NEW non-equi join (v1.9.8+)
query_if(dat, X, on=.(x, y&lt;=foo))                # NEW non-equi join (v1.9.8+)
query_if(dat, X, .(x,y,x.y,v), on=.(x, y&gt;=foo))  # Select x's join columns as well

query_if(dat, X, on="x", mult="first")           # first row of each group
query_if(dat, X, on="x", mult="last")            # last row of each group
query_if(dat, X, sum(v), by=.EACHI, on="x")      # join and eval j for each row in i
query_if(dat, X, sum(v)*foo, by=.EACHI, on="x")  # join inherited scope
query_if(dat, X, sum(v)*i.v, by=.EACHI, on="x")  # 'i,v' refers to X's v column
query_if(dat, X, on=.(x, v&gt;=v), sum(y)*foo, by=.EACHI) # NEW non-equi join with by=.EACHI (v1.9.8+)


# more on special symbols, see also ?"special-symbols"
query_if(dat, .N)                           # last row
query(dat, .N)                              # total number of rows in DT
query(dat, .N, by=x)                        # number of rows in each group
query(dat, .SD, .SDcols=x:y)                # select columns 'x' and 'y'
query(dat, .SD[1])                          # first row of all columns
query(dat, .SD[1], by=x)                    # first row of 'y' and 'v' for each group in 'x'
query(dat, c(.N, lapply(.SD, sum)), by=x)   # get rows *and* sum columns 'v' and 'y' by group
query(dat, .I[1], by=x)                     # row number in DT corresponding to each group
query(dat, grp := .GRP, by=x) %&gt;% head()    # add a group counter column
query(X, query_if(dat, .BY, y, on="x"), by=x)               # join within each group

# add/update/delete by reference (see ?assign)
query(dat, z:=42L) %&gt;% head()         # add new column by reference
query(dat, z:=NULL) %&gt;% head()        # remove column by reference
query_if(dat, "a", v:=42L, on="x") %&gt;% head()  # subassign to existing v column by reference
query_if(dat, "b", v2:=84L, on="x") %&gt;% head() # subassign to new column by reference (NA padded)

# NB: postfix [] is shortcut to print()
query(dat, m:=mean(v), by=x)[]              # add new column by reference by group

# advanced usage
dat = data.table(x=rep(c("b","a","c"),each=3),
                 v=c(1,1,1,2,2,1,1,2,2),
                 y=c(1,3,6),
                 a=1:9,
                 b=9:1)
dat
query(dat, sum(v), by=.(y%%2))              # expressions in by
query(dat, sum(v), by=.(bool = y%%2))       # same, using a named list to change by column name
query(dat, .SD[2], by=x)                    # get 2nd row of each group
query(dat, tail(.SD,2), by=x)               # last 2 rows of each group
query(dat, lapply(.SD, sum), by=x)          # sum of all (other) columns for each group
query(dat, .SD[which.min(v)], by=x)         # nested query by group

query(dat, list(MySum=sum(v),
                MyMin=min(v),
                MyMax=max(v)),
      by=.(x, y%%2)
)                    # by 2 expressions

query(dat, .(a = .(a), b = .(b)), by=x)      # list columns
query(dat, .(seq = min(a):max(b)), by=x)     # j is not limited to just aggregations
query(dat, sum(v), by=x) %&gt;%
    query_if(V1&lt;20) # compound query
query(dat, sum(v), by=x) %&gt;%
    setorder(-V1) %&gt;%
    head()          # ordering results
query(dat, c(.N, lapply(.SD,sum)), by=x)     # get number of observations and sum per group

# anonymous lambda in 'j', j accepts any valid
# expression. TO REMEMBER: every element of
# the list becomes a column in result.
query(dat,
      {tmp = mean(y);
      .(a = a-tmp, b = b-tmp)
      },
      by=x)

# using rleid, get max(y) and min of all cols in .SDcols for each consecutive run of 'v'
query(dat,
      c(.(y=max(y)), lapply(.SD, min)),
      by=rleid(v),
      .SDcols=v:b
)

## Not run: 
    pdf("new.pdf")
    query(dat, plot(a,b), by=x)                # can also plot in 'j'
    dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic++25+3C+3E+25'></span><span id='topic++25+24+25'></span><span id='topic++25T+3E+25'></span><span id='topic+data.table'></span><span id='topic+as.data.table'></span><span id='topic+is.data.table'></span><span id='topic+last'></span><span id='topic+first'></span><span id='topic++25like+25'></span><span id='topic+between'></span><span id='topic++between+'></span><span id='topic+inrange'></span><span id='topic++25inrange+25'></span><span id='topic++3A+3D'></span><span id='topic+setnames'></span><span id='topic+setcolorder'></span><span id='topic+set'></span><span id='topic+setDT'></span><span id='topic+setDF'></span><span id='topic+setorder'></span><span id='topic+setorderv'></span><span id='topic+setkey'></span><span id='topic+setkeyv'></span><span id='topic+setindex'></span><span id='topic+setindexv'></span><span id='topic+chmatch'></span><span id='topic++25chin+25'></span><span id='topic+rbindlist'></span><span id='topic+fread'></span><span id='topic+fwrite'></span><span id='topic+foverlaps'></span><span id='topic+shift'></span><span id='topic+transpose'></span><span id='topic+tstrsplit'></span><span id='topic+frank'></span><span id='topic+frankv'></span><span id='topic+.SD'></span><span id='topic+.N'></span><span id='topic+.I'></span><span id='topic+.GRP'></span><span id='topic+.BY'></span><span id='topic+rleid'></span><span id='topic+rleidv'></span><span id='topic+rowid'></span><span id='topic+rowidv'></span><span id='topic+uniqueN'></span><span id='topic+setDTthreads'></span><span id='topic+getDTthreads'></span><span id='topic+fintersect'></span><span id='topic+fsetdiff'></span><span id='topic+funion'></span><span id='topic+fsetequal'></span><span id='topic+shouldPrint'></span><span id='topic+fsort'></span><span id='topic+groupingsets'></span><span id='topic+cube'></span><span id='topic+rollup'></span><span id='topic+nafill'></span><span id='topic+setnafill'></span><span id='topic+frollmean'></span><span id='topic+frollsum'></span><span id='topic+fcoalesce'></span><span id='topic+fifelse'></span><span id='topic+frollapply'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+between">%between%</a></code>, <code><a href="data.table.html#topic+chmatch">%chin%</a></code>, <code><a href="data.table.html#topic+between">%inrange%</a></code>, <code><a href="data.table.html#topic+like">%like%</a></code>, <code><a href="data.table.html#topic+special-symbols">.BY</a></code>, <code><a href="data.table.html#topic+special-symbols">.GRP</a></code>, <code><a href="data.table.html#topic+special-symbols">.I</a></code>, <code><a href="data.table.html#topic+special-symbols">.N</a></code>, <code><a href="data.table.html#topic+special-symbols">.SD</a></code>, <code><a href="data.table.html#topic+assign">:=</a></code>, <code><a href="data.table.html#topic+as.data.table">as.data.table</a></code>, <code><a href="data.table.html#topic+between">between</a></code>, <code><a href="data.table.html#topic+chmatch">chmatch</a></code>, <code><a href="data.table.html#topic+groupingsets">cube</a></code>, <code><a href="data.table.html#topic+data.table">data.table</a></code>, <code><a href="data.table.html#topic+coalesce">fcoalesce</a></code>, <code><a href="data.table.html#topic+fifelse">fifelse</a></code>, <code><a href="data.table.html#topic+setops">fintersect</a></code>, <code><a href="data.table.html#topic+last">first</a></code>, <code><a href="data.table.html#topic+foverlaps">foverlaps</a></code>, <code><a href="data.table.html#topic+frank">frank</a></code>, <code><a href="data.table.html#topic+frank">frankv</a></code>, <code><a href="data.table.html#topic+fread">fread</a></code>, <code><a href="data.table.html#topic+froll">frollapply</a></code>, <code><a href="data.table.html#topic+froll">frollmean</a></code>, <code><a href="data.table.html#topic+froll">frollsum</a></code>, <code><a href="data.table.html#topic+setops">fsetdiff</a></code>, <code><a href="data.table.html#topic+setops">fsetequal</a></code>, <code><a href="data.table.html#topic+fsort">fsort</a></code>, <code><a href="data.table.html#topic+setops">funion</a></code>, <code><a href="data.table.html#topic+fwrite">fwrite</a></code>, <code><a href="data.table.html#topic+openmp-utils">getDTthreads</a></code>, <code><a href="data.table.html#topic+groupingsets">groupingsets</a></code>, <code><a href="data.table.html#topic+between">inrange</a></code>, <code><a href="data.table.html#topic+as.data.table">is.data.table</a></code>, <code><a href="data.table.html#topic+last">last</a></code>, <code><a href="data.table.html#topic+nafill">nafill</a></code>, <code><a href="data.table.html#topic+rbindlist">rbindlist</a></code>, <code><a href="data.table.html#topic+rleid">rleid</a></code>, <code><a href="data.table.html#topic+rleid">rleidv</a></code>, <code><a href="data.table.html#topic+groupingsets">rollup</a></code>, <code><a href="data.table.html#topic+rowid">rowid</a></code>, <code><a href="data.table.html#topic+rowid">rowidv</a></code>, <code><a href="data.table.html#topic+assign">set</a></code>, <code><a href="data.table.html#topic+setDF">setDF</a></code>, <code><a href="data.table.html#topic+setDT">setDT</a></code>, <code><a href="data.table.html#topic+openmp-utils">setDTthreads</a></code>, <code><a href="data.table.html#topic+setcolorder">setcolorder</a></code>, <code><a href="data.table.html#topic+setkey">setindex</a></code>, <code><a href="data.table.html#topic+setkey">setindexv</a></code>, <code><a href="data.table.html#topic+setkey">setkey</a></code>, <code><a href="data.table.html#topic+setkey">setkeyv</a></code>, <code><a href="data.table.html#topic+nafill">setnafill</a></code>, <code><a href="data.table.html#topic+setattr">setnames</a></code>, <code><a href="data.table.html#topic+setorder">setorder</a></code>, <code><a href="data.table.html#topic+setorder">setorderv</a></code>, <code><a href="data.table.html#topic+shift">shift</a></code>, <code><a href="data.table.html#topic+shouldPrint">shouldPrint</a></code>, <code><a href="data.table.html#topic+transpose">transpose</a></code>, <code><a href="data.table.html#topic+tstrsplit">tstrsplit</a></code>, <code><a href="data.table.html#topic+duplicated">uniqueN</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+exposition">%$%</a></code>, <code><a href="magrittr.html#topic+compound">%&lt;&gt;%</a></code>, <code><a href="magrittr.html#topic+pipe">%&gt;%</a></code>, <code><a href="magrittr.html#topic+tee">%T&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='text_expand'>Evaluate expressions in curly brackets inside strings</h2><span id='topic+text_expand'></span>

<h3>Description</h3>

<p><code>text_expand</code> is simple string interpolation function. It searches in its
arguments expressions in curly brackets <code>{expr}</code>, evaluate them and substitute with
the result of evaluation. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_expand(..., delim = c("\\{", "\\}"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_expand_+3A_...">...</code></td>
<td>
<p>character vectors</p>
</td></tr>
<tr><td><code id="text_expand_+3A_delim">delim</code></td>
<td>
<p>character vector of length 2 - pair of opening and closing
delimiters for the templating tags. By default it is curly brackets. Note
that <code>delim</code> will be used in the perl-style regular expression so you
need to escape special characters, e. g. use &quot;\\{&quot; instead of
&quot;{&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of characters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i = 1:5
text_expand("q{i}")

i = 1:3
j = 1:3
text_expand("q1_{i}_{j}")

data(iris)
text_expand("'iris' has {nrow(iris)} rows.")
</code></pre>

<hr>
<h2 id='to_list'>Apply an expression to each element of a list or vector</h2><span id='topic+to_list'></span><span id='topic+to_vec'></span><span id='topic+to_df'></span><span id='topic+to_dfr'></span><span id='topic+to_dfc'></span>

<h3>Description</h3>


<ul>
<li> <p><code>to_list</code> always returns a list, each element of which is the
result of expression <code>expr</code> on the elements of data. By
default, NULL's will be removed from the result. You can change this behavior
with <code>skip_null</code> argument.
</p>
</li>
<li> <p><code>to_vec</code> is the same as <code>to_list</code> but tries to convert its result
to vector via <a href="base.html#topic+unlist">unlist</a>.
</p>
</li>
<li> <p><code>to_df</code> and <code>to_dfr</code> try to combine its results to data.table by rows.
</p>
</li>
<li> <p><code>to_dfc</code> tries to combine its result to data.table by columns.
</p>
</li></ul>

<div class="sourceCode"></div>
<p>Expression can use predefined variables: '.x' is a value of current list
element, '.name' is a name of the element and '.index' is sequential number
of the element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_list(
  data,
  expr = NULL,
  ...,
  skip_null = TRUE,
  trace = FALSE,
  trace_step = 1L
)

to_vec(
  data,
  expr = NULL,
  ...,
  skip_null = TRUE,
  trace = FALSE,
  trace_step = 1L,
  recursive = TRUE,
  use.names = TRUE
)

to_df(
  data,
  expr = NULL,
  ...,
  trace = FALSE,
  trace_step = 1L,
  idvalue = NULL,
  idname = "item_id"
)

to_dfr(
  data,
  expr = NULL,
  ...,
  trace = FALSE,
  trace_step = 1L,
  idvalue = NULL,
  idname = "item_id"
)

to_dfc(data, expr = NULL, ..., trace = FALSE, trace_step = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_list_+3A_data">data</code></td>
<td>
<p>data.frame/list/vector</p>
</td></tr>
<tr><td><code id="to_list_+3A_expr">expr</code></td>
<td>
<p>expression or function. Expression can use predefined variables:
'.x' is a value of current list element, '.name' is a name of the element
and '.index' is sequential number of the element.</p>
</td></tr>
<tr><td><code id="to_list_+3A_...">...</code></td>
<td>
<p>further arguments provided if 'expr' is function.</p>
</td></tr>
<tr><td><code id="to_list_+3A_skip_null">skip_null</code></td>
<td>
<p>logical Should we skip NULL's from result? Default is TRUE</p>
</td></tr>
<tr><td><code id="to_list_+3A_trace">trace</code></td>
<td>
<p>FALSE by default. Should we report progress during execution?
Possible values are TRUE, FALSE, &quot;pb&quot; (progress bar) or custom expression in 'quote', e. g. 'quote(print(.x))'.
Expression can contain '.x', '.name', and '.index' variables.</p>
</td></tr>
<tr><td><code id="to_list_+3A_trace_step">trace_step</code></td>
<td>
<p>integer. 1 by default.  Step for reporting progress. Ignored if 'trace' argument is equal to FALSE.</p>
</td></tr>
<tr><td><code id="to_list_+3A_recursive">recursive</code></td>
<td>
<p>logical. Should unlisting be applied to list components of x? For details see <a href="base.html#topic+unlist">unlist</a>.</p>
</td></tr>
<tr><td><code id="to_list_+3A_use.names">use.names</code></td>
<td>
<p>logical. TRUE by default. Should names of source list be
preserved? Setting it to FALSE in some cases can greatly increase
performance. For details see <a href="base.html#topic+unlist">unlist</a>.</p>
</td></tr>
<tr><td><code id="to_list_+3A_idvalue">idvalue</code></td>
<td>
<p>expression for calculation id column. Usually it is just
unquoted symbols: one of the '.name', '.index' or '.x'.</p>
</td></tr>
<tr><td><code id="to_list_+3A_idname">idname</code></td>
<td>
<p>character, 'item_id' by default. Name for the id column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'to_list' returns list, 'to_vec' tries to return vector and other functions return data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>1:5 %&gt;%
    to_list(rnorm(n = 3, .x))

# or in 'lapply' style
1:5 %&gt;%
    to_list(rnorm, n = 3) %&gt;%
    to_vec(mean)

# or use an anonymous function
1:5 %&gt;%
    to_list(function(x) rnorm(3, x))

# Use to_vec() to reduce output to a vector instead
# of a list:
# filtering - return only even numbers
to_vec(1:10, if(.x %% 2 == 0) .x)

# filtering - calculate mean only on the numeric columns
to_vec(iris, if(is.numeric(.x)) mean(.x))

# mean for numerics, number of distincts for others
to_vec(iris, if(is.numeric(.x)) mean(.x) else uniqueN(.x))

# means for Sepal
to_vec(iris, if(startsWith(.name, "Sepal")) mean(.x))

# A more realistic example: split a data frame into pieces, fit a
# model to each piece, summarise and extract R^2
mtcars %&gt;%
    split(.$cyl) %&gt;%
    to_list(summary(lm(mpg ~ wt, data = .x))) %&gt;%
    to_vec(.x$r.squared)

# If each element of the output is a data frame, use
# to_df to row-bind them together:
mtcars %&gt;%
    split(.$cyl) %&gt;%
    to_list(lm(mpg ~ wt, data = .x)) %&gt;%
    to_df(c(cyl = .name, coef(.x)))

## Not run: 
# read all csv files in "data" to data.frame
all_files = dir("data", pattern = "csv$", full.names = TRUE) %&gt;%
    to_df(fread,
          idvalue = basename(.x),
          idname = "filename",
          trace = "pb"
          )

## End(Not run)
</code></pre>

<hr>
<h2 id='to_long'>Convert data to long or to wide form</h2><span id='topic+to_long'></span><span id='topic+to_wide'></span>

<h3>Description</h3>

<p><code>to_long</code> increases number of rows in the dataset and reduce number of
columns. <code>to_wide</code> makes invert transformation. You can use <a href="#topic+cols">cols</a> for
selecting variables in the arguments. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_long(
  data,
  columns = NULL,
  keep = NULL,
  names_in = "variable",
  values_in = "value",
  drop_na = FALSE,
  names_factor = TRUE,
  value_factor = FALSE,
  ...
)

to_wide(
  data,
  keep = NULL,
  names_in = variable,
  values_in = value,
  fun = identity,
  sep = "_",
  fill = NA,
  missing_comb = c("none", "rows", "columns", "all"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_long_+3A_data">data</code></td>
<td>
<p>A data.frame to convert</p>
</td></tr>
<tr><td><code id="to_long_+3A_columns">columns</code></td>
<td>
<p>unquoted names of variables for stacking. When missing, we
will stack all columns outside <code>keep</code> columns.</p>
</td></tr>
<tr><td><code id="to_long_+3A_keep">keep</code></td>
<td>
<p>unquoted names of columns which will be kept as is, e. g. only
recycled or deduplicated. If missing, it is all columns except stacked or
unstacked. If <code>FALSE</code> then nothing will be kept.</p>
</td></tr>
<tr><td><code id="to_long_+3A_names_in">names_in</code></td>
<td>
<p>name of the stacked variable names column. The default name
is 'variable'. It is quoted in the <code>to_long</code> and unquoted in <code>to_wide</code>. If
<code>FALSE</code> in the <code>to_wide</code> than nothing will be widening.</p>
</td></tr>
<tr><td><code id="to_long_+3A_values_in">values_in</code></td>
<td>
<p>name(-s) of the stacked data values column(s). The default
name is 'value'. Multiple names can be provided here for the case when
<code>columns</code> is a list, though note well that the names provided in
<code>columns</code> take precedence. It is quoted in the <code>to_long</code> and unqoted in <code>to_wide</code></p>
</td></tr>
<tr><td><code id="to_long_+3A_drop_na">drop_na</code></td>
<td>
<p>If TRUE, NA values will be removed from the stacked data.</p>
</td></tr>
<tr><td><code id="to_long_+3A_names_factor">names_factor</code></td>
<td>
<p>If TRUE, the column with names will be converted to
factor, else it will be a character column. TRUE by default.</p>
</td></tr>
<tr><td><code id="to_long_+3A_value_factor">value_factor</code></td>
<td>
<p>If TRUE, the value column will be converted to factor,
else the stacked values type is left unchanged. FALSE by default.</p>
</td></tr>
<tr><td><code id="to_long_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>data.table::melt</code>/<code>data.table::dcast</code></p>
</td></tr>
<tr><td><code id="to_long_+3A_fun">fun</code></td>
<td>
<p>Should the data be aggregated before casting? By default, it is
<code>identity</code> - no aggregation. To use multiple aggregation functions, pass a
list; see Examples.</p>
</td></tr>
<tr><td><code id="to_long_+3A_sep">sep</code></td>
<td>
<p>Character vector of length 1, indicating the separating character
in variable names generated during casting. Default is &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="to_long_+3A_fill">fill</code></td>
<td>
<p>Value with which to fill missing cells. <code>NA</code> by default. If <code>fun</code> is
present, takes the value by applying the function on a 0-length vector.</p>
</td></tr>
<tr><td><code id="to_long_+3A_missing_comb">missing_comb</code></td>
<td>
<p>One of &quot;none&quot; (the default), &quot;rows&quot; - include missing
combinations in rows, &quot;columns&quot; - include missing combinations in columns,
and &quot;all&quot; include all missing combinations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table in the wide or long form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)

# 'to_long'

long_iris = iris %&gt;%
    to_long(keep = Species)

long_iris

iris_with_stat = long_iris %&gt;%
    take(mean = mean(value),
         sd = sd(value),
         n = .N*1.0,
         by = .(Species, variable)
    ) %&gt;%
    to_long(columns = c(mean, sd, n), names_in = "stat")

# 'to_wide' - table with multiple stats
iris_with_stat %&gt;%
    to_wide()


iris_with_stat %&gt;%
    to_wide(names_in = c(variable, stat))

iris_with_stat %&gt;%
    to_wide(names_in = c(variable, Species))

# 'to_wide' - aggregation function
long_iris %&gt;%
    to_wide(fun = list(Mean = mean, SD = sd, N = length))

# multiple variables
iris %&gt;%
    to_long(list(Sepal = cols("^Sepal"), Petal = cols("^Petal"))) %&gt;%
    let(
        variable = factor(variable, levels = 1:2, labels = c("Length", "Width"))
    ) %&gt;%
    to_wide(values_in = c(Sepal, Petal))

# '%to%' selector - example from tidyr::pivot_longer

data(anscombe)
anscombe %&gt;%
    to_long(
        list(x = x1 %to% x4, y = y1 %to% y4),
        names_in = "set"
    )

######################################
## Examples from data.table melt/dcast
######################################

set.seed(45)
DT = data.table(
    i_1 = c(1:5, NA)*1.0,
    i_2 = c(NA,6,7,8,9,10)*1.0,
    f_1 = factor(sample(c(letters[1:3], NA), 6, TRUE)),
    f_2 = factor(c("z", "a", "x", "c", "x", "x"), ordered=TRUE),
    c_1 = sample(c(letters[1:3], NA), 6, TRUE),
    d_1 = as.Date(c(1:3,NA,4:5), origin="2013-09-01"),
    d_2 = as.Date(6:1, origin="2012-01-01")
)

# id, values as character/integer/numeric vectors

to_long(DT, f_1, keep = 1:2)
to_long(DT, f_1, keep = c(i_1, i_2))
to_long(DT, f_1, keep = i_1 %to% i_2)
to_long(DT, f_1, keep = cols(i_1:i_2), names_factor = FALSE)
to_long(DT, f_1, keep = cols("i_{1:2}"))
to_long(DT, f_1, keep = cols("^i_"))
to_long(DT, f_1, keep = cols("^i_"), names_in = "var", values_in = "val")

col_var = "^i_"
to_long(DT, 3, keep = cols(col_var))

to_long(DT, cols("^f_"), keep = cols("^i_"), value_factor = TRUE)

to_long(mtcars)
to_long(mtcars, keep = am)
to_long(mtcars, columns = c(am, vs, mpg))
to_long(mtcars, columns = c(am, vs, mpg), keep = FALSE)
to_long(DT, keep = f_1, columns = c(i_1, i_2), drop_na = TRUE)
to_long(DT, keep=1:2, columns = list(cols("^f_"), cols("^d_")), value_factor=TRUE)

data("ChickWeight")
names(ChickWeight) = tolower(names(ChickWeight))
DT = to_long(ChickWeight, keep=2:4)

to_wide(DT, keep = time, fun = mean)
to_wide(DT, keep = FALSE, fun = mean)
to_wide(DT, keep = diet, fun = mean)
to_wide(DT, keep = c(diet, chick), names_in = time, missing_comb = "all")
to_wide(DT, keep = c(diet, chick), names_in = time, missing_comb = "all", fill = 0)
to_wide(DT, chick, time, fun = mean)



# using FALSE
DT = data.table(v1 = rep(1:2, each = 6),
                v2 = rep(rep(1:3, 2), each = 2),
                v3 = rep(1:2, 6),
                v4 = rnorm(6))

## for each combination of (v1, v2), add up all values of v4
to_wide(DT,
        cols("^v(1|2)"),
        names_in = FALSE,
        values_in = v4,
        fun = sum
)

# multiple values_in and multiple fun
DT = data.table(x=sample(5,20,TRUE),
                y=sample(2,20,TRUE),
                z=sample(letters[1:2], 20,TRUE),
                d1 = runif(20),
                d2=1L)

# multiple values_in
to_wide(DT,
        keep = c(x, y),
        names_in = z,
        values_in = c(d1, d2),
        fun = sum,
        fill = 0)

# multiple funs
to_wide(DT,
        keep = c(x, y),
        names_in = z,
        values_in = d1,
        fun = list(sum = sum, mean = mean),
        fill = NULL)

# multiple fun and values_in (all combinations)
to_wide(DT,
        keep = c(x, y),
        names_in = z,
        values_in = c(d1, d2),
        fun = list(sum = sum, mean = mean)
)

# multiple fun and values_in (one-to-one)
to_wide(DT,
        keep = c(x, y),
        names_in = z,
        values_in = list(d1, d2),
        fun = list(sum = sum, mean = mean)
)
</code></pre>

<hr>
<h2 id='vlookup'>Look up values in dictionary.</h2><span id='topic+vlookup'></span><span id='topic+xlookup'></span>

<h3>Description</h3>

<p><code>vlookup</code> function is inspired by VLOOKUP spreadsheet
function. It looks for a <code>lookup_value</code> in the <code>lookup_column</code> of
the <code>dict</code>, and then returns values in the same rows from
<code>result_column</code>.
<code>xlookup</code> is simplified version of <code>vlookup</code>. It searches for a
<code>lookup_value</code> in the <code>lookup_vector</code> and return values in the same
position from the <code>result_vector</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlookup(
  lookup_value,
  dict,
  result_column = 2,
  lookup_column = 1,
  no_match = NA
)

xlookup(lookup_value, lookup_vector, result_vector, no_match = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vlookup_+3A_lookup_value">lookup_value</code></td>
<td>
<p>Vector of looked up values</p>
</td></tr>
<tr><td><code id="vlookup_+3A_dict">dict</code></td>
<td>
<p>data.frame. Dictionary.</p>
</td></tr>
<tr><td><code id="vlookup_+3A_result_column">result_column</code></td>
<td>
<p>numeric or character. Resulting columns in the
<code>dict</code>. Default  value for <code>result_column</code> is 2 - for frequent
case of dictionary with keys in the first column and results in the second
column.</p>
</td></tr>
<tr><td><code id="vlookup_+3A_lookup_column">lookup_column</code></td>
<td>
<p>Column of <code>dict</code> in which lookup value will be
searched. By default, it is the first column of the <code>dict</code>.</p>
</td></tr>
<tr><td><code id="vlookup_+3A_no_match">no_match</code></td>
<td>
<p>vector of length one. NA by default. Where a valid match is
not found, return the 'no_match' value you supply.</p>
</td></tr>
<tr><td><code id="vlookup_+3A_lookup_vector">lookup_vector</code></td>
<td>
<p>vector in which 'lookup_value' will be searched during 'xlookup'.</p>
</td></tr>
<tr><td><code id="vlookup_+3A_result_vector">result_vector</code></td>
<td>
<p>vector with resulting values for 'xlookup'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>xlookup</code> always return vector, <code>vlookup</code> returns vector if
the <code>result_column</code> is single value. In the opposite case data.frame will
be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># with data.frame
dict = data.frame(num=1:26, small=letters, cap=LETTERS)
vlookup(1:3, dict)
vlookup(c(45,1:3,58), dict, result_column='cap')
vlookup(c(45,1:3,58), dict, result_column='cap', no_match = "Not found")

# the same with xlookup
xlookup(1:3, dict$num, dict$small)
xlookup(c(45,1:3,58), dict$num, dict$cap)
xlookup(c(45,1:3,58), dict$num, dict$cap, no_match = "Not found")


# example from base 'merge'
authors = data.table(
    surname = c("Tukey", "Venables", "Tierney", "Ripley", "McNeil"),
    nationality = c("US", "Australia", "US", "UK", "Australia"),
    deceased = c("yes", rep("no", 4))
)

books = data.table(
    surname = c("Tukey", "Venables", "Tierney",
                "Ripley", "Ripley", "McNeil", "R Core"),
    title = c("Exploratory Data Analysis",
              "Modern Applied Statistics ...",
              "LISP-STAT",
              "Spatial Statistics", "Stochastic Simulation",
              "Interactive Data Analysis",
              "An Introduction to R")
)

let(books,
     c("author_nationality", "author_deceased") := vlookup(surname,
             dict = authors,
             result_column = 2:3
         )
)[]

# Just for fun. Examples borrowed from Microsoft Excel.
# It is not the R way of doing things.

# Example 2

ex2 = fread("
    Item_ID Item Cost Markup
    ST-340 Stroller 145.67  0.30
    BI-567 Bib 3.56  0.40
    DI-328 Diapers  21.45  0.35
    WI-989 Wipes  5.12  0.40
    AS-469 Aspirator 2.56  0.45
")

# Calculates the retail price of diapers by adding the markup percentage to the cost.
vlookup("DI-328", ex2, 3) * (1 + vlookup("DI-328", ex2, 4)) # 28.9575

# Calculates the sale price of wipes by subtracting a specified discount from
# the retail price.
(vlookup("WI-989", ex2, "Cost") * (1 + vlookup("WI-989", ex2, "Markup"))) * (1 - 0.2)  # 5.7344

A2 = ex2[["Item_ID"]][1]
A3 = ex2[["Item_ID"]][2]

# If the cost of an item is greater than or equal to $20.00, displays the string
# "Markup is nn%"; otherwise, displays the string "Cost is under $20.00".
ifelse(vlookup(A2, ex2, "Cost") &gt;= 20,
       paste0("Markup is " , 100 * vlookup(A2, ex2, "Markup"),"%"),
       "Cost is under $20.00") # Markup is 30%


# If the cost of an item is greater than or equal to $20.00, displays the string
# Markup is nn%"; otherwise, displays the string "Cost is $n.nn".
ifelse(vlookup(A3, ex2, "Cost") &gt;= 20,
       paste0("Markup is: " , 100 * vlookup(A3, ex2, "Markup") , "%"),
       paste0("Cost is $", vlookup(A3, ex2, "Cost"))) #Cost is $3.56


# Example 3

ex3 = fread('
    ID  Last_name  First_name  Title Birth_date
    1 Davis Sara "Sales Rep."  12/8/1968
    2 Fontana Olivier "V.P. of Sales" 2/19/1952
    3 Leal Karina "Sales Rep." 8/30/1963
    4 Patten Michael "Sales Rep." 9/19/1958
    5 Burke Brian "Sales Mgr." 3/4/1955
    6 Sousa Luis "Sales Rep."  7/2/1963
')

# If there is an employee with an ID of 5, displays the employee's last name;
# otherwise, displays the message "Employee not found".
vlookup(5, ex3, "Last_name", no_match = "Employee not found") # Burke

# Many employees
vlookup(1:10, ex3, "Last_name", no_match =  "Employee not found")

# For the employee with an ID of 4, concatenates the values of three cells into
# a complete sentence.
paste0(vlookup(4, ex3, "First_name"), " ",
       vlookup(4, ex3, "Last_name"), " is a ",
       vlookup(4, ex3, "Title")) # Michael Patten is a Sales Rep.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
