<!DOCTYPE html><html><head><title>Help for package mapmisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mapmisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#col2html'><p>Convert colours to HTML hex</p></a></li>
<li><a href='#colourScale'><p>Create colour scales</p></a></li>
<li><a href='#crsMerc'><p>Some coordinate reference systems and bounding boxes</p></a></li>
<li><a href='#geocode'><p>Georeferencing with Google</p></a></li>
<li><a href='#GNcities'><p>Retrieve city names and locations</p></a></li>
<li><a href='#gridlinesWrap'>
<p>Adds long-lat grid for projected data</p></a></li>
<li><a href='#legendBreaks'><p>Legends for colour scale</p></a></li>
<li><a href='#legendTable'><p>Table for colour scales</p></a></li>
<li><a href='#map.new'>
<p>Start a new map</p></a></li>
<li><a href='#modis'><p>MODIS tiles and projection</p></a></li>
<li><a href='#netherlands'>
<p>Data from the Netherlands</p></a></li>
<li><a href='#omerc'><p>Oblique Mercator, Cylindrical, and Mollweide projections</p></a></li>
<li><a href='#openmap'><p>Download map tiles</p></a></li>
<li><a href='#persistentCache'><p>Set a persistent cache</p></a></li>
<li><a href='#scaleBar'>
<p>Scale bar and inset map</p></a></li>
<li><a href='#tonerToTrans'>
<p>Convert RGB maps to semi-transparent</p></a></li>
<li><a href='#tpeqd'><p>Two point equidistant and tilted perspective projections</p></a></li>
<li><a href='#worldMap'>
<p>Country boundaries</p></a></li>
<li><a href='#wrapPoly'><p>Reproject polygons with wrapping</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities for Producing Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-06</td>
</tr>
<tr>
<td>Depends:</td>
<td>terra, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, grDevices, stats, utils, graphics, geosphere</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RColorBrewer, geonames, classInt, knitr</td>
</tr>
<tr>
<td>Enhances:</td>
<td>XML, RCurl</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a minimal, light-weight set of tools for producing nice looking maps in R, with support for map projections.  See Brown (2016) &lt;<a href="https://doi.org/10.32614%2FRJ-2016-005">doi:10.32614/RJ-2016-005</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 22:06:17 UTC; patrick</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Brown [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Brown &lt;patrick.brown@utoronto.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='col2html'>Convert colours to HTML hex</h2><span id='topic+col2html'></span>

<h3>Description</h3>

<p>Converts any object interpretable as a colour to an HTML hex string, i.e. 'red' to '#FF0000'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2html(col, opacity=1, alpha)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col2html_+3A_col">col</code></td>
<td>
<p>Either a character vector of colour names 
as listed by <code><a href="grDevices.html#topic+colors">colours</a>()</code>
or an integer vector of colour indexes. Passed to <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>.</p>
</td></tr>
<tr><td><code id="col2html_+3A_opacity">opacity</code></td>
<td>
<p>scalar or vector of colour opacities between 0 and 1.</p>
</td></tr>
<tr><td><code id="col2html_+3A_alpha">alpha</code></td>
<td>
<p>Integer between 0 and 255, or a character giving a 2-digit hex value.  
Overrides <code>opacity</code> and passed to <code><a href="grDevices.html#topic+rgb">rgb</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 6 or 8 digit hex codes specifying HTML colours.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>,<code><a href="grDevices.html#topic+rgb">rgb</a></code><code><a href="base.html#topic+hexmode">hexmode</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>col2html(1:10)
col2html(c('red','blue'),0.5)
col2html(c(2,4),0.5)
col2html(c(stuff='red',foo='blue'),alpha=128)
col2html(c('red','blue'),alpha='80')
col2html(c(2,4),alpha='80')

N = length(palette())
plot(1:N, rep(1,N),xlim=c(0,N),pch=16,cex=5,
col=col2html(1:N))
points(1:N, rep(1,N),pch=15,cex=4.5, col=palette())
text(-0.5+1:10, rep(1,10), col2html(1:10),srt=90)
text(1:N, rep(0.7,N), palette())
text(1:N-0.5, rep(1.3, N), col2html(palette()), cex=0.7)
</code></pre>

<hr>
<h2 id='colourScale'>Create colour scales</h2><span id='topic+colourScale'></span><span id='topic+colorScale'></span><span id='topic+breaksForRates'></span>

<h3>Description</h3>

<p>Produces a scale of colours for plotting maps</p>


<h3>Usage</h3>

<pre><code class='language-R'>	colourScale(x, breaks=5, style=c("quantile","equal","unique", "fixed"),
	 col="YlOrRd", opacity=1, dec=NULL, digits = 6, firstBreak=NULL, 
	 transform=NULL, revCol=FALSE, exclude=NULL, labels=NULL, ...)
	colorScale(...)
	breaksForRates(x, breaks = 10, transform = 0.1,
      multiples = c(2, 4, 5, 10)) 
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colourScale_+3A_x">x</code></td>
<td>
<p>A vector or single-layer Raster, numeric or factor,  for which a colour scale will be created</p>
</td></tr>
<tr><td><code id="colourScale_+3A_breaks">breaks</code></td>
<td>
<p>For <code>colourScale</code> either the number of or vector of breaks.
for <code>legendBreaks</code> usually the output of <code>colourScale</code>, or a vector of breaks</p>
</td></tr>
<tr><td><code id="colourScale_+3A_style">style</code></td>
<td>
<p>Style for breaks, see Details</p>
</td></tr>
<tr><td><code id="colourScale_+3A_col">col</code></td>
<td>
<p>Colours to use, either a function or 
argument for <code><a href="RColorBrewer.html#topic+ColorBrewer">brewer.pal</a></code></p>
</td></tr>
<tr><td><code id="colourScale_+3A_opacity">opacity</code></td>
<td>
<p>adds transparency to colours, either a single number,
vector of length 2, or vector of same length as <code>breaks</code></p>
</td></tr>
<tr><td><code id="colourScale_+3A_dec">dec</code></td>
<td>
<p>Number of decimal places for the breaks</p>
</td></tr>	
<tr><td><code id="colourScale_+3A_digits">digits</code></td>
<td>
<p>Number of significant figures</p>
</td></tr>
<tr><td><code id="colourScale_+3A_firstbreak">firstBreak</code></td>
<td>
<p>If non-null, force the first break to take this value (often zero).</p>
</td></tr>
<tr><td><code id="colourScale_+3A_transform">transform</code></td>
<td>
<p>A list of two functions to transform <code>x</code> and inverse transform the breaks, or a numeric value specifying a Box-Cox parameter.</p>
</td></tr>
<tr><td><code id="colourScale_+3A_revcol">revCol</code></td>
<td>
<p>Reverse the order of the colours.</p>
</td></tr>
<tr><td><code id="colourScale_+3A_exclude">exclude</code></td>
<td>
<p>A vector of values to change to NA when they appear in <code>x</code></p>
</td></tr>
<tr><td><code id="colourScale_+3A_labels">labels</code></td>
<td>
<p>Vector of names of levels, useful when <code>style='unique'</code></p>
</td></tr>
<tr><td><code id="colourScale_+3A_multiples">multiples</code></td>
<td>
<p>break points must be multiples of these numbers times a power of 10</p>
</td></tr>
<tr><td><code id="colourScale_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="classInt.html#topic+classIntervals">classIntervals</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>colourScale</code> produces intervals from <code>x</code>, each with a unique colour. Categories are determined with break points according to the following <code>style</code> options:
</p>

<ul>
<li> <p><code>quantile</code>: <code>quantile(x, prob=seq(0,1,len=breaks), )</code> 
</p>
</li></ul>

<p><code>equal</code>: <code>seq(min(x), max(x), len=breaks)</code> 
</p>
<p><code>unique</code>: <code>sort(table(unique(x)))[1:breaks]</code> 
</p>
<p><code>fixed</code>: <code>breaks</code>
</p>
<p>any other string: is passed to <code><a href="classInt.html#topic+classIntervals">classIntervals</a></code>
</p>
<p><code>colorScale</code> passes all it's arguments to <code>colourScale</code>
</p>
<p><code>breaksForRates</code> returns break points suitable for mapping incidence rates, which are positive and always
include 1.0.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>plot</code></td>
<td>
<p>Vector of same length of <code>x</code> containing colours (RGB hex)</p>
</td></tr>
<tr><td><code>breaks</code></td>
<td>
<p>vector of break points</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>vector of unique colour values corresponding to <code>breaks</code></p>
</td></tr>
<tr><td><code>colWithOpacity</code></td>
<td>
<p>as <code>col</code>, but with two digit transparency values appended.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+legendBreaks">legendBreaks</a></code>,<code><a href="#topic+scaleBar">scaleBar</a></code>, <code><a href="classInt.html#topic+classIntervals">classIntervals</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
breaksForRates(13.6, breaks = 7) 

Npoints = 20

myPoints = vect(
	cbind(runif(Npoints), 51+runif(Npoints)), 
	atts=data.frame(
		y1=c(NA, rnorm(Npoints-1)), 
	    y2=c(sample(0:5, Npoints-1,replace=TRUE), NA)
	),
	crs=crsLL)



if(require('RColorBrewer', quietly=TRUE)) {
	theCol = 'RdYlBu'
} else {
	theCol = grDevices::heat.colors
}

myscale = colourScale(myPoints$y1, breaks=4, col=theCol,
 style="quantile", revCol=TRUE,dec=1)


data("netherlands")
nldElev = terra::unwrap(nldElev)
myscale = colourScale(nldElev, breaks=4, col=theCol, style='equal', dec=0)

oldpar = map.new(myPoints)
plot(myPoints, col=myscale$plot, pch=16,add=TRUE)
legendBreaks("topleft", myscale)


myscale2 = colourScale(myPoints$y1, breaks=8, col=rainbow, style="equal",
opacity=0.8, dec=2, revCol=TRUE)

map.new(myPoints)
plot(myPoints, col=myscale2$plot, pch=16,add=TRUE)
legendBreaks("topleft", myscale2)

if(require('RColorBrewer', quietly=TRUE)) {
	theCol = 'Set2'
} else {
	theCol = grDevices::heat.colors
}

myscale3 = colourScale(myPoints$y2,  breaks=3,col=theCol, style="unique",
	opacity=c(0.1, 0.9))

map.new(myPoints)
plot(myPoints, col=myscale3$plot, pch=16,add=TRUE)
legendBreaks("topleft", myscale3)

myPoints$y3 = exp(myPoints$y1)
myscale4 = colourScale(myPoints$y3,  breaks=4, style="equal",
	opacity=c(0.1, 0.9), transform=1.25,dec=0, firstBreak=0)

map.new(myPoints)
plot(myPoints, col=myscale4$plot, pch=16,add=TRUE)
legendBreaks("topleft", myscale4)


# raster with colour table

x = rast(extent=ext(0,15,0,10), res=1)
values(x) = sample(1:4, ncell(x), replace=TRUE)
myScale = colourScale(x, breaks=3, style='unique', col=c('red','blue','orange'))
if(utils::packageVersion("terra") &gt;= "1.7-40" ) {
	terra::coltab(x) = myScale$colourtable
	plot(x)
} else {
	plot(x, breaks = myScale$breaks, col=myScale$col)
}
legendBreaks('topright', myScale)

par(oldpar)
</code></pre>

<hr>
<h2 id='crsMerc'>Some coordinate reference systems and bounding boxes</h2><span id='topic+crsMerc'></span><span id='topic+crsCanada'></span><span id='topic+crsLL'></span><span id='topic+bboxLL'></span><span id='topic+bboxLLsafe'></span><span id='topic+extentMerc'></span>

<h3>Description</h3>

<p>Defines CRS's for the several map projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crsMerc 
crsLL 
crsCanada 
extentMerc
bboxLLsafe
bboxLL
</code></pre>


<h3>Format</h3>

<p><code>crsMerc</code> spherical Mercator projection used by web mapping services, epsg:3857
<code>crsLL</code> long-lat, epsg:4326 
<code>crsCanada</code> customized oblique mercator for Canada
<code>bboxLL</code> polygon of bounding box of long-lat, -180 to 180, -90 to 90
<code>bboxLLsafe</code> as bboxLL, but slightly away from the edges
<code>extentMerc</code> extent of spherical mercator projections
</p>


<h3>Details</h3>

<p>these objects are used internally and may be of interest to the user
</p>


<h3>Value</h3>

<p>objects of class <code><a href="terra.html#topic+crs">crs</a></code> or numeric vectors.</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Web_Mercator">https://en.wikipedia.org/wiki/Web_Mercator</a>,
<a href="https://spatialreference.org/ref/epsg/4326/">https://spatialreference.org/ref/epsg/4326/</a>
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+crs">crs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>terra::crs(crsMerc, proj=TRUE)
terra::crs(crsLL, proj=TRUE)
terra::crs(crsCanada, proj=TRUE)
terra::ext(extentMerc)

bboxLLsafe = terra::unwrap(bboxLLsafe)
plot(bboxLLsafe)
plot(terra::project(bboxLLsafe, crsMerc))

</code></pre>

<hr>
<h2 id='geocode'>Georeferencing with Google</h2><span id='topic+geocode'></span>

<h3>Description</h3>

<p>Uses the dismo package to geocode with Google
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	geocode(x, extent,
	  lang = gsub("(_|[:]).*", "", Sys.getenv('LANGUAGE')))
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geocode_+3A_x">x</code></td>
<td>
<p>Vector of character strings to search for</p>
</td></tr>
<tr><td><code id="geocode_+3A_extent">extent</code></td>
<td>
<p>Currently unused.  an Extent object, or any object from which an Extent can be obtained.</p>
</td></tr>
<tr><td><code id="geocode_+3A_lang">lang</code></td>
<td>
<p>Language for place names in result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the option  
<code>getOption('mapmiscCachePath')</code> is set, it will be used
to specify the folder to save downloaded 
data. <code>getOption('mapmiscVerbose')</code> for printing progress.
</p>
<p>Data are retreived from Openstreetmap.org, see <a href="https://wiki.openstreetmap.org/wiki/Nominatim">https://wiki.openstreetmap.org/wiki/Nominatim</a>.
</p>


<h3>Value</h3>

<p>A <code>SpatialPointsDataFrame</code> with coordinates in the 
projection of <code>extent</code> if possible, or long-lat
otherwise.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

cities=try(geocode('Ulan batar'), silent=TRUE)
data('worldMap')
worldMap = terra::unwrap(worldMap)

if(!all(class(cities) == 'try-error') ) { 
citiesT = project(cities, crs(worldMap))
oldpar=map.new(citiesT, buffer=5000*1000)
plot(worldMap, add=TRUE)
points(citiesT, col='red')
suppressWarnings(text(citiesT, labels=citiesT$name, col='red',pos=4))
## Not run: 
	# uses unicode symbols
	text(citiesT, labels=citiesT$display_name, col='red',pos=1))

## End(Not run)
par(oldpar)
}



</code></pre>

<hr>
<h2 id='GNcities'>Retrieve city names and locations</h2><span id='topic+GNcities'></span><span id='topic+GNsearch'></span>

<h3>Description</h3>

<p>This function uses the geonames package to  provide city names and locations
from  www.geonames.org.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	GNcities(north, east, south, west, lang = "en", maxRows = 10, buffer=0)
	GNsearch(..., crs=crsLL)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GNcities_+3A_north">north</code></td>
<td>

<p>A bounding box or  
SpatialPoints or SpatialPolygons or 
Extent or  Raster object, or a decimal degree of longitude.</p>
</td></tr>
<tr><td><code id="GNcities_+3A_east">east</code>, <code id="GNcities_+3A_south">south</code>, <code id="GNcities_+3A_west">west</code></td>
<td>
<p>If <code>north</code> is numeric, decimal degree bounding box.</p>
</td></tr>
<tr><td><code id="GNcities_+3A_lang">lang</code></td>
<td>
<p>Language for internationalised returned text</p>
</td></tr>
<tr><td><code id="GNcities_+3A_maxrows">maxRows</code></td>
<td>
<p>Limit on returned rows</p>
</td></tr>
<tr><td><code id="GNcities_+3A_buffer">buffer</code></td>
<td>
<p>passed to <code><a href="terra.html#topic+extend">extend</a></code></p>
</td></tr>
<tr><td><code id="GNcities_+3A_...">...</code></td>
<td>
<p>Various search arguments</p>
</td></tr>
<tr><td><code id="GNcities_+3A_crs">crs</code></td>
<td>
<p>projection for the output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatialPointsDataFrame with the sampe projection  <code>north</code> if it exists, otherwise in 
long-lat.</p>


<h3>See Also</h3>

<p><code><a href="geonames.html#topic+GNcities">GNcities</a></code>, <code><a href="geonames.html#topic+GNsearch">GNsearch</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
	GNsearch(q="Toronto Ontario", maxRows = 3)

## End(Not run)


library('terra')
myraster = rast(
	matrix(1:100,10,10),
	extent=ext(8,18,0,10), crs=crsLL)

options(geonamesUsername="myusernamehere") 
if(file.exists("~/geonamesUsername.R")) source("~/geonamesUsername.R")

if(requireNamespace("geonames", quietly = TRUE)) { 

cities=try(GNcities(myraster, max=5), silent=TRUE)
mytiles = openmap(myraster, zoom=5, buffer=1)

oldpar=map.new(mytiles)
plot(mytiles, add=TRUE)
if(!all(class(cities)=='try-error')) {
points(cities, col='red')
text(cities, labels=cities$name, col='red',pos=4)
}


par(oldpar)

}



</code></pre>

<hr>
<h2 id='gridlinesWrap'>
Adds long-lat grid for projected data
</h2><span id='topic+gridlinesWrap'></span>

<h3>Description</h3>

<p>long-lat grid lines are added to a map in the coordinate system specified, 
allowing for map projections wrapped differently from the 180 meridian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridlinesWrap(crs, 
		easts=seq(-180,180,by=60),
		norths=seq(-90,90,by=30),
		ndiscr=40, plotLines=TRUE, 
		plotLabels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridlinesWrap_+3A_crs">crs</code></td>
<td>

<p>A character string representing a CRS
</p>
</td></tr>
<tr><td><code id="gridlinesWrap_+3A_easts">easts</code></td>
<td>
<p>vector of longitudes</p>
</td></tr>
<tr><td><code id="gridlinesWrap_+3A_norths">norths</code></td>
<td>
<p>vector of latitudes</p>
</td></tr>
<tr><td><code id="gridlinesWrap_+3A_ndiscr">ndiscr</code></td>
<td>
<p>number of intermediate points per line</p>
</td></tr>
<tr><td><code id="gridlinesWrap_+3A_plotlines">plotLines</code></td>
<td>
<p>add lines to existing plot</p>
</td></tr>
<tr><td><code id="gridlinesWrap_+3A_plotlabels">plotLabels</code></td>
<td>
<p>add labels to existing plot</p>
</td></tr>
<tr><td><code id="gridlinesWrap_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>lines</code> or <code>text</code>, 
for example <code>lty=2</code> 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>lines</code>, containg the graticule lines, and <code>points</code> containing the locations and labels for longitude and latitude values.</p>


<h3>Author(s)</h3>

<p>Patrick Brown
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+graticule">graticule</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data('worldMap')
worldMap = terra::unwrap(worldMap)
crsMoll = moll(-100)
worldMapT = wrapPoly(worldMap, crsMoll, buffer.width=200*1000)

plot(attributes(crsMoll)$ellipse)
plot(worldMapT, add=TRUE)
gridlinesWrap(crsMoll, lty=3, col='red', cex=0.6)


</code></pre>

<hr>
<h2 id='legendBreaks'>Legends for colour scale</h2><span id='topic+legendBreaks'></span>

<h3>Description</h3>

<p>Legends where N+1 labels are supplied as the limits of N bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendBreaks(pos, 
	breaks,     
	col,    legend,
    rev=TRUE,
    outer=TRUE,
    pch=15,
    bg='white',
    cex=par('cex'),
    pt.cex=2.5*cex,
    text.col=par('fg'),
    title=NULL,
    inset=0.05,
    title.col=text.col,
    adj=0,
    width=Inf,
    lines=Inf,
    y.intersp,
	...)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legendBreaks_+3A_pos">pos</code></td>
<td>

<p>Position, as specified in the <code><a href="graphics.html#topic+legend">legend</a></code> function.
</p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_breaks">breaks</code></td>
<td>
<p>Optional list with elements <code>col</code> and <code>legend</code>, such as the 
output from  <code><a href="#topic+colourScale">colourScale</a></code> </p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_col">col</code></td>
<td>
<p>Single colour or vector of colours for each bin</p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_legend">legend</code></td>
<td>
<p>vector of labels for the legend, one more element than there are 
colours</p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_rev">rev</code></td>
<td>
<p>if <code>TRUE</code>, labels and colours are ordered from bottom to top, otherwise top to bottom. </p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_outer">outer</code></td>
<td>
<p>If <code>TRUE</code>, put legend in the margin of the plot</p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_pch">pch</code></td>
<td>
<p>see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_bg">bg</code></td>
<td>
<p>background colour see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_cex">cex</code></td>
<td>
<p>see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_pt.cex">pt.cex</code></td>
<td>
<p>see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_text.col">text.col</code></td>
<td>
<p>see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_title">title</code></td>
<td>
<p>see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_inset">inset</code></td>
<td>
<p>see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_title.col">title.col</code></td>
<td>
<p>see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_adj">adj</code></td>
<td>
<p>Adjustment of the legend labels relative to plotting symbols.</p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_width">width</code></td>
<td>
<p>Maximum number of characters before a line break is added to the legend labels</p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_lines">lines</code></td>
<td>
<p>Maximum number of lines in each legend label</p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_y.intersp">y.intersp</code></td>
<td>
<p>see <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="legendBreaks_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A legend for 'z-axis' colour scales.
</p>


<h3>Value</h3>

<p>Result of call to <code><a href="graphics.html#topic+legend">legend</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourScale">colourScale</a></code></p>

<hr>
<h2 id='legendTable'>Table for colour scales</h2><span id='topic+legendTable'></span>

<h3>Description</h3>

<p>A table in html or Latex showing values associated with colours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendTable(x,
    type=c('latex',  'html'),
    box = c(-0.2, 1, 2),
    unit = 'em',
    collapse=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legendTable_+3A_x">x</code></td>
<td>

<p>a <code>data.frame</code> with columns <code>col</code> and <code>label</code>, possibly 
produced by <code><a href="#topic+colourScale">colourScale</a></code>
</p>
</td></tr>
<tr><td><code id="legendTable_+3A_type">type</code></td>
<td>
<p>html or latex compatible output</p>
</td></tr>
<tr><td><code id="legendTable_+3A_box">box</code></td>
<td>
<p>dimensions of colour boxes, passed as 
depth, height and width to <code>rule</code> in Latex, or 
width (first two elements ignored) for html. 
</p>
</td></tr>
<tr><td><code id="legendTable_+3A_unit">unit</code></td>
<td>
<p>Units for box dimensions</p>
</td></tr>
<tr><td><code id="legendTable_+3A_collapse">collapse</code></td>
<td>
<p>If non-NULL, passed to <code>paste</code> to produce a character 
vector instead of table</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> or character vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colourScale">colourScale</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
mytable = data.frame(col=col2html(1:5), label=1:5)

legendTable(mytable)
legendTable(mytable, collapse=';')
legendTable(mytable, type='html')

</code></pre>

<hr>
<h2 id='map.new'>
Start a new map
</h2><span id='topic+map.new'></span>

<h3>Description</h3>

<p>Prepare a plotting window suitable for a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.new(x,legendRight=FALSE, buffer=0, mar=c(0,0,0,0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.new_+3A_x">x</code></td>
<td>

<p>A spatial object from which an extent can be extracted.
</p>
</td></tr>
<tr><td><code id="map.new_+3A_legendright">legendRight</code></td>
<td>
<p>Leave room to the right for 
the legend produced by plotting a Raster object</p>
</td></tr>
<tr><td><code id="map.new_+3A_buffer">buffer</code></td>
<td>
<p>passed to <code><a href="terra.html#topic+extend">extend</a></code> to increase the plotting area</p>
</td></tr>
<tr><td><code id="map.new_+3A_mar">mar</code></td>
<td>
<p>see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="map.new_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>plot</code> 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>map.new</code> initiates a plot intended to contain a map covering the extent of <code>x</code>, 
with no margins.
</p>


<h3>Value</h3>

<p>A list of the graphical parameters prior to calling <code>map.new</code></p>


<h3>Author(s)</h3>

<p>Patrick Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nldTiles = terra::unwrap(nldTiles)
nldCities = terra::unwrap(nldCities)


oldpar = map.new(nldCities)
plot(nldTiles, add=TRUE)
points(nldCities)
par(oldpar)

</code></pre>

<hr>
<h2 id='modis'>MODIS tiles and projection</h2><span id='topic+modis'></span><span id='topic+crsModis'></span><span id='topic+getModisRaster'></span><span id='topic+getModisTiles'></span><span id='topic+getDegreeRaster'></span>

<h3>Description</h3>

<p>Raster containing MODIS tile ID's
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModisTiles(x, tiles)
crsModis
getModisRaster()
getDegreeRaster()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modis_+3A_x">x</code></td>
<td>
<p>A spatial object which modis tiles will cover.</p>
</td></tr>
<tr><td><code id="modis_+3A_tiles">tiles</code></td>
<td>
<p>A raster with modis (or other) tiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides information on tiles which can be downloaded from MODIS.
</p>


<h3>Value</h3>

<p><code>getModisTiles</code> returns a matrix with modis tiles.
</p>
<p><code>getModisRaster</code> shows horizontal and vertical tile names for downloading data from MODIS.
</p>
<p><code>getDegreeRaster</code> shows horizontal and vertical tiles in long-lat, for downloading elevation.
</p>


<h3>References</h3>

<p><a href="https://modis-land.gsfc.nasa.gov/MODLAND_grid.html">https://modis-land.gsfc.nasa.gov/MODLAND_grid.html</a>,
<a href="https://spatialreference.org/ref/esri/54008/">https://spatialreference.org/ref/esri/54008/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
crsModis

myPointLL = vect(cbind(c(5:6),10:11), crs = crsLL)


getModisTiles(myPointLL)

getModisTiles(myPointLL, getDegreeRaster())



modisUrl = 	'https://e4ftl01.cr.usgs.gov/MOTA/MCD12Q1.061/2002.01.01/'
desiredTiles = paste0("(",
	paste(getModisTiles(myPointLL, getModisRaster())[,'tile'], collapse='|'), 
	").*.hdf$")

if(requireNamespace("RCurl", quietly=TRUE) &amp; requireNamespace("XML", quietly=TRUE)) {
theFiles = 	grep(desiredTiles,
	XML::getHTMLLinks(RCurl::getURL(
	    modisUrl,ftp.use.epsv=FALSE,
	    dirlistonly = TRUE)), value=TRUE)
paste0(modisUrl, theFiles)
}

</code></pre>

<hr>
<h2 id='netherlands'>
Data from the Netherlands
</h2><span id='topic+netherlands'></span><span id='topic+nldElev'></span><span id='topic+nldTiles'></span><span id='topic+nldCities'></span><span id='topic+nldCmap'></span><span id='topic+meuse'></span>

<h3>Description</h3>

<p>Elevation data and map tiles for the Netherlands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("netherlands")</code></pre>


<h3>Format</h3>

<p><code>nldElev</code> is a raster of elevation
<code>nltTiles</code> is a background map
<code>meuse</code> classic Meuse river data set from the sp package 
<code>nldCities</code> is a SpatialPointsDataFrame of city locations.
</p>


<h3>Details</h3>

<p>The inclusion of these datasets is intended to allow the package to build 
when an internet connection is not present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
meuse = terra::unwrap(meuse)
nldTiles = terra::unwrap(nldTiles)
nldCities = terra::unwrap(nldCities)

oldpar=map.new(meuse, buffer=1*1000)
plot(nldTiles,add=TRUE)
points(nldCities, pch=4, col='blue')
text(nldCities,label=nldCities$name, pos=2, col='blue')
points(meuse, pch=15, col=as.integer(meuse$soil))

legend('topleft', fill=1:nlevels(meuse$soil),
	legend=levels(meuse$soil), inset=0.2, bg='white', title='Soil type')
par(oldpar)


</code></pre>

<hr>
<h2 id='omerc'>Oblique Mercator, Cylindrical, and Mollweide projections</h2><span id='topic+omerc'></span><span id='topic+moll'></span><span id='topic+ocea'></span>

<h3>Description</h3>

<p>Defines an appropriate Oblique Mercator, Oblique Cylindrical Equal Area, and Mollweide projections
for a supplied Spatial object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	omerc(x, angle,  
	post=c('none', 'north', 'wide','tall'),
    preserve=NULL, ellipse=TRUE) 
    ocea(x, angle, flip=FALSE)
    moll(x=0, angle=NULL, flip=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omerc_+3A_x">x</code></td>
<td>
<p>A <code><a href="terra.html#topic+SpatVector">SpatVector</a></code> object or a vector of length 2 giving the 
centroid of the projection. </p>
</td></tr>
<tr><td><code id="omerc_+3A_angle">angle</code></td>
<td>
<p>angle of rotation or vector of angles</p>
</td></tr>
<tr><td><code id="omerc_+3A_post">post</code></td>
<td>
<p>post-projection angle rotation</p>
</td></tr>
<tr><td><code id="omerc_+3A_flip">flip</code></td>
<td>
<p>post-projection flipping of coordinates</p>
</td></tr>
<tr><td><code id="omerc_+3A_preserve">preserve</code></td>
<td>
<p>A <code><a href="terra.html#topic+SpatVector">SpatVector</a></code> object, the resulting projection is scaled
so as to preserve the distances between these points as best as possible. </p>
</td></tr>
<tr><td><code id="omerc_+3A_ellipse">ellipse</code></td>
<td>
<p>compute projection region and areas to crop when projecting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>omerc</code>, an Oblique Mercator map projection is produced which warps the world onto a cylinder, with the north-south axis 
rotated by the specified angle.  If <code>angle</code> is a vector, the optimal 
angle for reducing the size
of the bounding box is returned.   
</p>
<p>If <code>post = 'north'</code>, an inverse rotation will preserve the north direction at the origin.
</p>
<p>If <code>post = 'wide'</code>, an inverse rotation
makes the smallest possible bounding box which is wider than tall.  
</p>
<p>If <code>post = 'tall'</code>, the bounding box is taller than it is wide
</p>
<p>If <code>post</code> is numeric, it specifies an angle for inverse rotation.
</p>
<p><code>ocea</code> produces an Oblique Cylindrical Equal Area projection and <code>moll</code> a Mollweide projections
</p>


<h3>Value</h3>

<p>An object of class <code><a href="terra.html#topic+crs">crs</a></code>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/w/index.php?title=Space-oblique_Mercator_projection">https://en.wikipedia.org/w/index.php?title=Space-oblique_Mercator_projection</a>
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+crs">crs</a></code>,
<code><a href="terra.html#topic+project">project</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('worldMap')
worldMap = terra::unwrap(worldMap)


myProj = omerc(c(-100,-70), angle=-45)
crs(myProj, proj=TRUE)

plot(project(worldMap, crsLL))
plot(attributes(myProj)$crop, col='red', add=TRUE)



</code></pre>

<hr>
<h2 id='openmap'>Download map tiles</h2><span id='topic+openmap'></span><span id='topic+osmTiles'></span><span id='topic+openmapAttribution'></span>

<h3>Description</h3>

<p>Downloads map tiles from Openstreetmap.org and other servers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	openmap(x, zoom, 
	  path="http://tile.openstreetmap.org/",
	  maxTiles = 9, 
	  crs=terra::crs(x),   
	  buffer=0, fact=1, 
	 verbose=getOption('mapmiscVerbose'),
	  cachePath=getOption('mapmiscCachePath'),
	  suffix=NULL
)

	osmTiles(name, xyz, suffix)

	openmapAttribution(name, 
	  type=c('text','latex','markdown','html', 'auto'), 
	  short=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="openmap_+3A_x">x</code></td>
<td>

<p>An a spatial object  
from which an extent and crs can be obtained.  </p>
</td></tr>
<tr><td><code id="openmap_+3A_zoom">zoom</code></td>
<td>

<p>the zoom level, when missing it will be determined by maxTiles.</p>
</td></tr>
<tr><td><code id="openmap_+3A_path">path</code></td>
<td>
	
<p>Source of map tiles, see <a href="http://diseasemapping.r-forge.r-project.org/mapLayers.html">http://diseasemapping.r-forge.r-project.org/mapLayers.html</a>.</p>
</td></tr>
<tr><td><code id="openmap_+3A_maxtiles">maxTiles</code></td>
<td>
	
<p>If zoom is missing, zoom will be chosen such that the 
number of map tiles is less than or equl to this number.</p>
</td></tr>
<tr><td><code id="openmap_+3A_crs">crs</code></td>
<td>
<p>Projection for the output, defaulting to the same projection as
<code>x</code>.  If <code>x</code> has no projection, 
for instance when <code>x</code> is a matrix or extent, 
<code>crs</code> is also used as the projection of <code>x</code>.  If <code>crs</code> is <code>NA</code> or missing and <code>x</code> has no crs, long-lat is used.  </p>
</td></tr>
<tr><td><code id="openmap_+3A_buffer">buffer</code></td>
<td>
<p>Extend the extent for which the map is requested, in units
of <code>x</code>.  Can be negative, or a vector of length 2 for different x and y 
extensions</p>
</td></tr>
<tr><td><code id="openmap_+3A_fact">fact</code></td>
<td>
<p>Passed to increase or decrease resolution, values above 1
help to produce a clearer image.</p>
</td></tr>
<tr><td><code id="openmap_+3A_verbose">verbose</code></td>
<td>

<p>Print information about map images being downloaded, defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="openmap_+3A_cachepath">cachePath</code></td>
<td>
<p>Location to store downloaded map images, defaults to <code>tempdir()</code></p>
</td></tr>
<tr><td><code id="openmap_+3A_name">name</code></td>
<td>
<p>name of a tile path, if missing a vector of all available tile paths
is returned.  <code>name</code> can be any of the names of the vector returned when 
<code>name</code> is unspecified.</p>
</td></tr>
<tr><td><code id="openmap_+3A_type">type</code></td>
<td>
<p>format for the attribution</p>
</td></tr>
<tr><td><code id="openmap_+3A_short">short</code></td>
<td>
<p>short or long attribution</p>
</td></tr>
<tr><td><code id="openmap_+3A_xyz">xyz</code></td>
<td>
<p>format of xyz coordinates in URL's</p>
</td></tr>
<tr><td><code id="openmap_+3A_suffix">suffix</code></td>
<td>
<p>string to append to URL's, i.e. <code>'.png'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions download, display, and manipulate map tiles stored in a
standard way either on a web server or a local folder.
</p>
<p>Map tiles are a set of PNG images that span the world at a set of zoom
levels. Zoom level 1 has four 256x256 pixel tiles
in a 2x2 pattern over the whole world. In general, zoom level n has <code class="reqn">2^n</code>
by <code class="reqn">2^n</code> tiles. Zoom levels go up to about 17 or 18 depending on the tile
server.
</p>
<p>See <a href="https://mc.bbbike.org/mc/">https://mc.bbbike.org/mc/</a> for a more possible map tiles (not all of which are compatible with openmap)
</p>
<p>Be sure to attribute any maps you publish, the <code>osmAttribution</code> function will assist.  If <code>type = 'auto'</code> then markdown format will be used unless a variable <code>mdToTex</code> is defined and equal to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p><code>openmap</code> returns a <code>SpatRaster</code> with indexed colours or RGB layers.
</p>
<p><code>openmapAttribution</code> returns a character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("netherlands")
nldTiles = terra::unwrap(nldTiles)
plot(nldTiles)

openmapAttribution('osm', short=TRUE, type='markdown')

openmapAttribution("stamen-toner", type='text')


myraster = rast(matrix(1:100,10,10),extent=ext(8, 18, 0, 10), crs=crsLL)

myPoints = as.points(myraster)[seq(1, ncell(myraster), len=12)]

names(osmTiles())


	mytiles = try(openmap(myraster, zoom=5, verbose=TRUE))

oldpar =	map.new(myraster)
	plot(mytiles, add=TRUE)
	points(myPoints,col='red')

	myPoints = project(myPoints, crsMerc)
	map.new(myPoints)

	mytiles = try(openmap(myPoints,
		path='https://livemap-tiles1.waze.com/tiles', verbose=TRUE, buffer=5))
	plot(mytiles, add=TRUE)

	points(myPoints, col='red')

par(oldpar)


</code></pre>

<hr>
<h2 id='persistentCache'>Set a persistent cache</h2><span id='topic+persistentCache'></span><span id='topic+mapmiscCache'></span><span id='topic+mapmiscCachePath'></span>

<h3>Description</h3>

<p>Sets a cache folder in temporary space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	persistentCache(verbose=TRUE)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persistentCache_+3A_verbose">verbose</code></td>
<td>
<p>print location of the cache folder</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default cache for map images is tempdir()/mapmiscCache, which will be deleted when an R session ends.  Running this function sets a cache in /tmp/mapmiscCache_[username], which will re-use cached data across R sessions.
</p>


<h3>Value</h3>

<p><code>persistentCache</code> returns the path to the cach folder.  </p>


<h3>Examples</h3>

<pre><code class='language-R'># current cache
getOption("mapmiscCachePath")

# set a new cache
myCache = file.path(tempdir(), 'myCache')
dir.create(myCache)
options(mapmiscCachePath = myCache)
getOption("mapmiscCachePath")

# create a persistent cache

persistentCache(verbose=TRUE)

getOption("mapmiscCachePath")
</code></pre>

<hr>
<h2 id='scaleBar'>
Scale bar and inset map
</h2><span id='topic+scaleBar'></span><span id='topic+insetMap'></span>

<h3>Description</h3>

<p>Utilities for plotting a map, adding a scale bar and north arrow, 
and adding a legend of colour scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleBar(crs, pos = "bottomright",   
	cex=1,
    pt.cex = 1.1*cex,
    seg.len=5*cex,
    title.cex=cex,
    outer=TRUE,...)
insetMap(crs, pos="bottomright",map="osm",zoom=0, 
		width=max(c(0.2, 1-par('plt')[2])), 
		col="#FF000090", borderMap=NULL,
			cropInset = terra::ext(-180, 180,  -47, 71),
			outer=TRUE, inset = c(0.1, 0.1), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleBar_+3A_crs">crs</code></td>
<td>

<p>A character string from which a projection 
can be extracted with <code>terra::crs</code>
</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_pos">pos</code></td>
<td>

<p>Position, as specified in the <code>legend</code> function.
</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_cex">cex</code></td>
<td>
<p>scaling factor for the legend</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_pt.cex">pt.cex</code></td>
<td>

<p>Scaling factor north arrow (can be zero).
</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_seg.len">seg.len</code></td>
<td>
<p>approximate length (in character units) of the scale bar.  can be zero.</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_title.cex">title.cex</code></td>
<td>
<p>scaling for the distance text</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_outer">outer</code></td>
<td>
<p>If <code>TRUE</code>, put bar or map in the margin of the plot</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_map">map</code></td>
<td>
<p>Either a Raster for the inset map or a string 
passed to <code><a href="#topic+openmap">openmap</a></code>'s path argument</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_zoom">zoom</code></td>
<td>
<p>Zoom level if retrieving inset map from <code><a href="#topic+openmap">openmap</a></code></p>
</td></tr>
<tr><td><code id="scaleBar_+3A_width">width</code></td>
<td>
<p>Width of the inset map, as a fraction of the plot window</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_col">col</code></td>
<td>
<p>Colour for shaded region of inset map</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_bordermap">borderMap</code></td>
<td>
<p>border style for the inset map (passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>)</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_cropinset">cropInset</code></td>
<td>
<p>Crop the insert map to this extent</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_inset">inset</code></td>
<td>
<p>how far from the border to put the inset map</p>
</td></tr>
<tr><td><code id="scaleBar_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code> for <code>scaleBar</code> 
or <code><a href="graphics.html#topic+polygon">polygon</a></code> (for <code>insetMap</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scaleBar</code> produces a scale bar reflecting the distance travelling on a great circle
from the centre of the plot and travelling to the right.  The length of the bar is the width 
of 6 characters times <code>scale.cex</code>.  
</p>


<h3>Value</h3>

<p>A list containig coordinates of the elements of the scale bar.</p>


<h3>Author(s)</h3>

<p>Patrick Brown
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Npoints = 20
set.seed(0)
myPoints = vect(
	cbind(runif(Npoints)-0.1, 51+runif(Npoints)), 
	atts=data.frame(
		y1=c(NA, rnorm(Npoints-1)), 
	    y2=c(sample(0:5, Npoints-1,replace=TRUE), NA)
	),
	crs=crsLL)



breaks = c(-100, -1, 1, Inf)
thecol = c('red','orange','blue')


oldpar = map.new(myPoints)
plot(myPoints,col = as.character(cut(
	myPoints$y1, breaks, thecol
)),add=TRUE)
scaleBar(myPoints, "bottomright",cex=1.25, seg.len=2)
legendBreaks("topleft", legend=breaks, col=thecol)

thedot = insetMap(crs=myPoints, pos="bottomleft",
	 col='#00000000', lty=0, outer=FALSE, width=0.5)
points(thedot)

par(oldpar)
</code></pre>

<hr>
<h2 id='tonerToTrans'>
Convert RGB maps to semi-transparent
</h2><span id='topic+tonerToTrans'></span>

<h3>Description</h3>

<p>Stamen-toner maps are 3-layer RGB rasters, which are converted
to single-layer rasters with indexed colours with whites becoming transparent. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tonerToTrans(x,  pattern="(red|green|blue)$", power = 0.5, col='black',  threshold=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tonerToTrans_+3A_x">x</code></td>
<td>

<p>A <code>RasterStack</code> with RGB colours, such as from <code><a href="#topic+openmap">openmap</a></code> with <code>path='stamen-toner'</code></p>
</td></tr>
<tr><td><code id="tonerToTrans_+3A_pattern">pattern</code></td>
<td>
<p>string passed to <code><a href="base.html#topic+grep">grep</a></code> to find RGB layers.</p>
</td></tr>
<tr><td><code id="tonerToTrans_+3A_power">power</code></td>
<td>

<p>Values below 1 increase opacity, above 1 increases transparency
</p>
</td></tr>
<tr><td><code id="tonerToTrans_+3A_col">col</code></td>
<td>
<p>colour for resulting map</p>
</td></tr>
<tr><td><code id="tonerToTrans_+3A_threshold">threshold</code></td>
<td>
<p>colours above this value are transparent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended for <code>'stamen-toner'</code> maps.
</p>


<h3>Value</h3>

<p>A <code>SpatRast</code> with indexed colours
</p>


<h3>Author(s)</h3>

<p>Patrick Brown
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openmap">openmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	data('worldMap');worldMap = unwrap(worldMap)

	origMap = openmap(worldMap[worldMap$NAME == 'Sierra Leone',],
	 path='cartodb-nolabels',   
		buffer=100*1000
	)
	oldpar=	map.new(origMap, bg='green')
	plot(origMap, add=TRUE)
	
	transMap = tonerToTrans(origMap)
	names(transMap)
  map.new(transMap, bg='green')
	plot(transMap, add=TRUE)
	par(oldpar)


</code></pre>

<hr>
<h2 id='tpeqd'>Two point equidistant and tilted perspective projections</h2><span id='topic+tpeqd'></span><span id='topic+tpers'></span>

<h3>Description</h3>

<p>Defines map projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpeqd(x, offset=c(0,0), axis='enu')
tpers(x,  hKm = 100*1000, tilt = -10,   azi, offset=c(0,0), axis='enu')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpeqd_+3A_x">x</code></td>
<td>
<p>A SpatialPoints* object of length 2 or a 
matrix with two columns. </p>
</td></tr>
<tr><td><code id="tpeqd_+3A_hkm">hKm</code></td>
<td>
<p>Height veiwing the Earth from</p>
</td></tr>
<tr><td><code id="tpeqd_+3A_tilt">tilt</code></td>
<td>
<p>Viewing angle</p>
</td></tr>
<tr><td><code id="tpeqd_+3A_azi">azi</code></td>
<td>
<p>Azimuth, defaults to direction of first two points in x</p>
</td></tr>
<tr><td><code id="tpeqd_+3A_offset">offset</code></td>
<td>
<p>2 coordinates to define the origin</p>
</td></tr>
<tr><td><code id="tpeqd_+3A_axis">axis</code></td>
<td>
<p>defaults to east, north, up.  'swu' would rotateo 90 degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coordinate reference system is returned
</p>


<h3>Value</h3>

<p>Caracther string representing a <code><a href="terra.html#topic+crs">crs</a></code>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Two-point_equidistant_projection">https://en.wikipedia.org/wiki/Two-point_equidistant_projection</a>
<a href="https://proj.org/operations/projections/tpers.html">https://proj.org/operations/projections/tpers.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+crs">crs</a></code>,<code><a href="terra.html#topic+project">project</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('worldMap');worldMap=unwrap(worldMap)

thepoints = vect(rbind(cbind(150, -40), cbind(-70,-40)), crs=crsLL)
crsOne = tpeqd(thepoints)
worldMapTrans = wrapPoly(worldMap, crsOne)

oldpar=map.new(crsOne, col='lightblue')
plot(worldMapTrans, add=TRUE, col='grey')
points(project(thepoints, crsOne), col='red')
gridlinesWrap(crsOne, col='orange')



thepoints = vect(rbind(cbind(-40, 65), cbind(139,35)), crs=crsLL)
crsTwo = tpeqd(thepoints)


map.new(crsTwo, col='lightblue')
plot(wrapPoly(worldMap, crsTwo), add=TRUE, col='grey')
points(project(thepoints, crsTwo), col='red')
gridlinesWrap(crsTwo, col='orange')

par(oldpar)
</code></pre>

<hr>
<h2 id='worldMap'>
Country boundaries
</h2><span id='topic+worldMap'></span><span id='topic+worldmap'></span><span id='topic+isohedron'></span>

<h3>Description</h3>

<p>Country borders from naturalearthdata.com
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("worldMap")</code></pre>


<h3>Source</h3>

<p><a href="https://www.naturalearthdata.com/downloads/110m-cultural-vectors/">https://www.naturalearthdata.com/downloads/110m-cultural-vectors/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# soil data

data("worldMap")
worldMap = terra::unwrap(worldMap)
oldpar=map.new(worldMap)
plot(worldMap, border='red', lwd=3, add=TRUE)
plot(worldMap[worldMap$NAME ==  'Brazil',],
	add=TRUE, col='green')
par(oldpar)

</code></pre>

<hr>
<h2 id='wrapPoly'>Reproject polygons with wrapping</h2><span id='topic+wrapPoly'></span><span id='topic+llCropBox'></span>

<h3>Description</h3>

<p>Reprojects a SpatialPolygons object to a projection with longitude wrapping other than 180 degreess
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapPoly(x,crs, buffer.width = 100*1000)
llCropBox(crs, 
  buffer.width=50*1000, densify.interval = 25*1000, 
  crop.distance = 2.1e7, crop.poles = FALSE, crop.leftright=FALSE,
  remove.holes=TRUE, cycles = 2, ellipse=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapPoly_+3A_x">x</code></td>
<td>
<p>A Spatial object</p>
</td></tr>
<tr><td><code id="wrapPoly_+3A_crs">crs</code></td>
<td>
<p>Caracther string representing a  <code><a href="terra.html#topic+crs">crs</a></code>.</p>
</td></tr>
<tr><td><code id="wrapPoly_+3A_buffer.width">buffer.width</code></td>
<td>
<p>buffer to add to points on border when cropping poloygons, defaults to 100km</p>
</td></tr>
<tr><td><code id="wrapPoly_+3A_densify.interval">densify.interval</code></td>
<td>
<p>interval when densifying</p>
</td></tr>
<tr><td><code id="wrapPoly_+3A_crop.distance">crop.distance</code></td>
<td>
<p>crop coordinates larger than this value</p>
</td></tr>
<tr><td><code id="wrapPoly_+3A_crop.poles">crop.poles</code></td>
<td>
<p>remove areas near the poles</p>
</td></tr>
<tr><td><code id="wrapPoly_+3A_crop.leftright">crop.leftright</code></td>
<td>
<p>remove points near 180 longitute line</p>
</td></tr>
<tr><td><code id="wrapPoly_+3A_remove.holes">remove.holes</code></td>
<td>
<p>fill holes in the crop region</p>
</td></tr>
<tr><td><code id="wrapPoly_+3A_cycles">cycles</code></td>
<td>
<p>iterations adding denser points</p>
</td></tr>
<tr><td><code id="wrapPoly_+3A_ellipse">ellipse</code></td>
<td>
<p>boundary of the world in crs coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reprojected Spatial object.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+project">project</a></code>, examples in <code><a href="#topic+tpeqd">tpeqd</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
