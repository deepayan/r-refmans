<!DOCTYPE html><html lang="en"><head><title>Help for package jomo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jomo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cldata'>
<p>A simulated clustered dataset</p></a></li>
<li><a href='#ExamScores'>
<p>Exam results for six inner London Education Authorities</p></a></li>
<li><a href='#jomo'>
<p>Joint Modelling Imputation</p></a></li>
<li><a href='#jomo.clmm'>
<p>Joint Modelling Imputation Compatible with Cumulative Link Mixed Model</p></a></li>
<li><a href='#jomo.clmm.MCMCchain'>
<p>clmm Compatible JM Imputation - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo.coxph'>
<p>Joint Modelling Imputation Compatible with Cox Proportional Hazards Model</p></a></li>
<li><a href='#jomo.coxph.MCMCchain'>
<p>coxph Compatible JM Imputation - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo.glm'>
<p>Joint Modelling Imputation Compatible with glm Model</p></a></li>
<li><a href='#jomo.glm.MCMCchain'>
<p>glm Compatible JM Imputation - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo.glmer'>
<p>Joint Modelling Imputation Compatible with Generalized Linear Mixed Model</p></a></li>
<li><a href='#jomo.glmer.MCMCchain'>
<p>glmer Compatible JM Imputation - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo.lm'>
<p>Joint Modelling Imputation Compatible with Linear Regression Model</p></a></li>
<li><a href='#jomo.lm.MCMCchain'>
<p>lm Compatible JM Imputation - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo.lmer'>
<p>Joint Modelling Imputation Compatible with Linear Mixed-effects Regression Model</p></a></li>
<li><a href='#jomo.lmer.MCMCchain'>
<p>lmer Compatible JM Imputation - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo.MCMCchain'>
<p>JM Imputation - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo.polr'>
<p>Joint Modelling Imputation Compatible with Proportional Odds Ordinal Probit Regression</p></a></li>
<li><a href='#jomo.polr.MCMCchain'>
<p>polr Compatible JM Imputation - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo.smc'>
<p>Joint Modelling Substantive Model Compatible Imputation</p></a></li>
<li><a href='#jomo.smc.MCMCchain'>
<p>Substantive Model Compatible JM Imputation - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo1'>
<p>JM Imputation of single level data</p></a></li>
<li><a href='#jomo1.MCMCchain'>
<p>JM Imputation of single level data - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo1cat'>
<p>JM Imputation of single level data with categorical variables</p></a></li>
<li><a href='#jomo1cat.MCMCchain'>
<p>JM Imputation of single level data with categorical variables -</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#jomo1con'>
<p>JM Imputation of single level data with continuous variables only</p></a></li>
<li><a href='#jomo1con.MCMCchain'>
<p>JM Imputation of single level data with continuous variables only -</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#jomo1mix'>
<p>JM Imputation of single level data with mixed variable types</p></a></li>
<li><a href='#jomo1mix.MCMCchain'>
<p>JM Imputation of single level data with mixed variable types</p></a></li>
<li><a href='#jomo1ran'>
<p>JM Imputation of clustered data</p></a></li>
<li><a href='#jomo1ran.MCMCchain'>
<p>JM Imputation of clustered data - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo1rancat'>
<p>JM Imputation of clustered data with categorical variables</p></a></li>
<li><a href='#jomo1rancat.MCMCchain'>
<p>JM Imputation of clustered data with categorical variables -</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#jomo1rancathr'>
<p>JM Imputation of clustered data with categorical variables with cluster-specific covariance matrices</p></a></li>
<li><a href='#jomo1rancathr.MCMCchain'>
<p>JM Imputation of clustered data with categorical variables with cluster-specific covariance matrices -</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#jomo1rancon'>
<p>JM Imputation of clustered data with continuous variables only</p></a></li>
<li><a href='#jomo1rancon.MCMCchain'>
<p>JM Imputation of clustered data with continuous variables only -</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#jomo1ranconhr'>
<p>JM Imputation of clustered data with continuous variables only with cluster-specific covariance matrices</p></a></li>
<li><a href='#jomo1ranconhr.MCMCchain'>
<p>JM Imputation of clustered data with continuous variables only with cluster-specific covariance matrices -</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#jomo1ranmix'>
<p>JM Imputation of clustered data with mixed variable types</p></a></li>
<li><a href='#jomo1ranmix.MCMCchain'>
<p>JM Imputation of clustered data with mixed variable types -</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#jomo1ranmixhr'>
<p>JM Imputation of clustered data with mixed variable types with cluster-specific covariance matrices</p></a></li>
<li><a href='#jomo1ranmixhr.MCMCchain'>
<p>JM Imputation of clustered data with mixed variable types with cluster-specific covariance matrices -</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#jomo2'>
<p>JM Imputation of 2-level data</p></a></li>
<li><a href='#jomo2.MCMCchain'>
<p>JM Imputation of 2-level data - A tool to check convergence of the MCMC</p></a></li>
<li><a href='#jomo2com'>
<p>JM Imputation of 2-level data assuming a common level-1 covariance matrix across level-2 units.</p></a></li>
<li><a href='#jomo2com.MCMCchain'>
<p>JM Imputation of 2-level data assuming a common level-1 covariance matrix across level-2 units -</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#jomo2hr'>
<p>JM Imputation of 2-level data assuming cluster-specific level-1 covariance matrices across level-2 unit</p></a></li>
<li><a href='#jomo2hr.MCMCchain'>
<p>JM Imputation of 2-level data assuming cluster-specific level-1 covariance matrices across level-2 units-</p>
A tool to check convergence of the MCMC</a></li>
<li><a href='#JSPmiss'>
<p>Exam results for six inner London Education Authorities</p></a></li>
<li><a href='#sldata'>
<p>A simulated single level dataset</p></a></li>
<li><a href='#surdata'>
<p>A simulated dataset with survival data</p></a></li>
<li><a href='#tldata'>
<p>A simulated 2-level dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multilevel Joint Modelling Multiple Imputation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.7-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Matteo Quartagno, James Carpenter</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matteo Quartagno &lt;m.quartagno@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Similarly to package 'pan', 'jomo' is a package for multilevel joint modelling multiple imputation (Carpenter and Kenward, 2013) &lt;<a href="https://doi.org/10.1002%2F9781119942283">doi:10.1002/9781119942283</a>&gt;.
 Novel aspects of 'jomo' are the possibility of handling binary and categorical data through latent normal variables, the option to use cluster-specific covariance matrices and to impute compatibly with the substantive model. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mitml</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, lme4, survival, MASS, ordinal, tibble</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-14 08:57:20 UTC; rmjlmqu</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-15 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cldata'>
A simulated clustered dataset 
</h2><span id='topic+cldata'></span>

<h3>Description</h3>

<p>A simulated dataset to test functions for imputation of clustered data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cldata)</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations on the following 6 variables.
</p>

<dl>
<dt><code>age</code></dt><dd><p>A numeric variable with (centered) age. Fully observed.</p>
</dd>
<dt><code>measure</code></dt><dd><p>A numeric variable with some measure of interest (unspecified). This is partially observed.</p>
</dd>
<dt><code>sex</code></dt><dd><p>A binary variable with gender indicator. Fully observed.</p>
</dd>
<dt><code>social</code></dt><dd><p>A 4-category variable with some social status indicator. This is partially observed.</p>
</dd>
<dt><code>city</code></dt><dd><p>The cluster indicator vector. 10 cities are indexed 0 to 9.</p>
</dd>
<dt><code>id</code></dt><dd><p>The id for individuals within each city.</p>
</dd>
</dl>



<h3>Details</h3>

<p>These are not real data, they are simulated to illustrate the use of the main functions of the package.</p>

<hr>
<h2 id='ExamScores'>
Exam results for six inner London Education Authorities
</h2><span id='topic+ExamScores'></span>

<h3>Description</h3>

<p>A partially observed version of the tutorial dataset in package R2MLwiN.It includes examination results from six inner London Education Authorities (school boards).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cldata)</code></pre>


<h3>Format</h3>

<p>A data frame with 4059 observations on the following 6 variables.
</p>

<dl>
<dt><code>school</code></dt><dd><p>A school identifier.</p>
</dd>
<dt><code>student</code></dt><dd><p>A student ID.</p>
</dd>
<dt><code>normexam</code></dt><dd><p>Students' exam score at age 16, normalised and partially observed.</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex of pupil; a factor with levels boy, girl.</p>
</dd>
<dt><code>cons</code></dt><dd><p>A column of 1s. Useful to add an intercept to th eimputation model.</p>
</dd>
<dt><code>standlrt</code></dt><dd><p>Students' score at age 11 on the London Reading Test (LRT), standardised.</p>
</dd>
<dt><code>schgend</code></dt><dd><p>Schools' gender; a factor with levels corresponding to mixed school (mixedsch), boys' school (boysch), and girls' school (girlsch).</p>
</dd>
<dt><code>avslrt</code></dt><dd><p>Average LRT score in school.</p>
</dd>
<dt><code>schav</code></dt><dd><p>Average LRT score in school, coded into 3 categories: low = bottom 25%, mid = middle 50%, high = top 25%.</p>
</dd>
<dt><code>vrband</code></dt><dd><p>Students' score in test of verbal reasoning at age 11, a factor with 3 levels: vb1 = top 25%, vb2 = middle 50%, vb3 = bottom 25%.</p>
</dd>
</dl>



<h3>Details</h3>

<p>These fully observed verison of the data is available with package R2MLwiN.</p>


<h3>Source</h3>

<p>Browne, W. J. (2012) MCMC Estimation in MLwiN Version 2.26. University of Bristol: Centre for Multilevel Modelling.
</p>
<p>Goldstein, H., Rasbash, J., Yang, M., Woodhouse, G., Pan, H., Nuttall, D., Thomas, S. (1993) A multilevel analysis of school examination results. Oxford Review of Education, 19, 425-433.
</p>
<p>Rasbash, J., Charlton, C., Browne, W.J., Healy, M. and Cameron, B. (2009) MLwiN Version 2.1. Centre for Multilevel Modelling, University of Bristol.
</p>

<hr>
<h2 id='jomo'>
Joint Modelling Imputation 
</h2><span id='topic+jomo'></span>

<h3>Description</h3>

<p>A wrapper function linking all the functions for JM imputation. The matrix of responses Y, must be a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'> jomo(Y, Y2=NULL, X=NULL, X2=NULL, Z=NULL, clus=NULL, beta.start=NULL, 
      l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, 
      l1cov.prior=NULL, l2cov.prior=NULL, nburn=1000, nbetween=1000, nimp=5,
      a=NULL, a.prior=NULL, meth="common", output=1, out.iter=10) 
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo_+3A_y">Y</code></td>
<td>

<p>A data.frame containing the (level-1) outcomes of the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo_+3A_y2">Y2</code></td>
<td>

<p>A data.frame containing the level-2 outcomes of the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_x2">X2</code></td>
<td>

<p>A data frame, or matrix, with level-2 covariates of the joint imputation model. Rows correspond to different level-1 observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. If missing, functions for single level imputation are automatically used.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects. Rows index different covariates and columns index different level-2 outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects plus the number of level-2 outcomes. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a wrapper function to link all the functions in the package. Format of the columns of Y is crucial in order for the function to be using the right sub-function. </p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed and random effects estimates and of the covariance matrices are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # define all the inputs:
  
  Y&lt;-cldata[,c("measure","age")]
  clus&lt;-cldata[,c("city")]
  nburn=as.integer(200);
  nbetween=as.integer(200);
  nimp=as.integer(5);
  
  
  #And finally we run the imputation function:
  imp&lt;-jomo(Y,clus=clus,nburn=nburn,nbetween=nbetween,nimp=nimp)
  
  # Finally we show how to fit the model and combine estimate with Rubin's rules
  # Here we use mitml, other options are available in mice, mitools, etc etc

  #if (requireNamespace("mitml", quietly = TRUE)&amp;requireNamespace("lme4", quietly = TRUE)) {
    #imp.mitml&lt;-jomo2mitml.list(imp)
    #fit.i&lt;-with(imp.mitml, lmer(measure~age+(1|clus)))
    #fit.MI&lt;-testEstimates(fit.i, var.comp=T)
 # }

  #we could even run imputation with fixed or random cluster-specific covariance matrices:
  
  #imp&lt;-jomo(Y,clus=clus,nburn=nburn,nbetween=nbetween,nimp=nimp, meth="fixed")
  #or:
  #imp&lt;-jomo(Y,clus=clus,nburn=nburn,nbetween=nbetween,nimp=nimp, meth="random")
  
  #if we do not add clus as imput, functions for single level imputation are used:
  
  #imp&lt;-jomo(Y)
  
  

  
  
</code></pre>

<hr>
<h2 id='jomo.clmm'>
Joint Modelling Imputation Compatible with Cumulative Link Mixed Model
</h2><span id='topic+jomo.clmm'></span>

<h3>Description</h3>

<p>A function for substantive model compatible JM imputation, when the substantive model of interest is a cumulative link mixed model. Interactions and polynomial functions of the covariates are allowed. Data must be passed as a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.clmm(formula, data, level=rep(1,ncol(data)), beta.start=NULL,
            l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, 
            l2cov.start=NULL, l1cov.prior=NULL, l2cov.prior=NULL, 
            a.start=NULL, a.prior=NULL, nburn=1000, nbetween=1000, 
            nimp=5, meth="common", output=1, out.iter=10) 
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.clmm_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_level">level</code></td>
<td>

<p>A vector, indicating whether each variable is either a level 1 or a level 2 variable. The value assigned to the cluster indicator is irrelevant.    
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster of the random effects estimates u for the joint model for the covariates. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of level-1 covariates (continuous plus latent normals) in the analysis model times the number of random effects plus the number of level-2 covariates. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_a.start">a.start</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.clmm_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for substantive model compatible imputation when the substantive model is a cumulative link mixed-effects model. It can deal with interactions and polynomial terms through the usual lmer syntax in the formula argument. 
Format of the columns of data is crucial in order for the function to deal with binary/categorical covariates appropriately in the imputation algorithm.  
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effect estimates and of the residual variance are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # make sure social is a factor:
  
  cldata&lt;-within(cldata, social&lt;-factor(social))
  
  # we define the data frame with all the variables 
  
  data&lt;-cldata[,c("measure","age", "social", "city")]
  
  # And the formula of the substantive lm model 
  # social as an outcome only because it is the only ordinal variable in the dataset...
  
  formula&lt;-as.formula(social~age+measure+(1|city))
  
  #And finally we run the imputation function:
  
  # imp&lt;-jomo.clmm(formula,data, nburn=1000, nbetween=1000, nimp=2)
  
  # Note the function is commented out to avoid time consuming examples, 
  # which go against CRAN policies. 
  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules
  
  
  
</code></pre>

<hr>
<h2 id='jomo.clmm.MCMCchain'>
clmm Compatible JM Imputation - A tool to check convergence of the MCMC
</h2><span id='topic+jomo.clmm.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to the jomo.clmm function, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.clmm.MCMCchain(formula, data, level=rep(1,ncol(data)), 
                      beta.start=NULL, l2.beta.start=NULL, u.start=NULL,
                      l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL,
                      l2cov.prior=NULL, a.start=NULL, a.prior=NULL,
                      betaY.start=NULL,  covuY.start=NULL,
                      uY.start=NULL, nburn=1000, meth="common", 
                      start.imp=NULL, start.imp.sub=NULL, l2.start.imp=NULL,
                      output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.clmm.MCMCchain_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_level">level</code></td>
<td>

<p>A vector, indicating whether each variable is either a level 1 or a level 2 variable. The value assigned to the cluster indicator is irrelevant.   
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster of the random effects estimates u for the joint model for the covariates. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of level-1 covariates (continuous plus latent normals) in the analysis model times the number of random effects plus the number of level-2 covariates. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_a.start">a.start</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_betay.start">betaY.start</code></td>
<td>

<p>Starting value for betaY, the vector of fixed effects for the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_covuy.start">covuY.start</code></td>
<td>

<p>Starting value for covuY, the random effects covariance matrix of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_uy.start">uY.start</code></td>
<td>

<p>Starting value for uY, the random effects matrix of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the missing data in the covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_l2.start.imp">l2.start.imp</code></td>
<td>

<p>Starting value for the missing data in the level-2 covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.clmm.MCMCchain_+3A_start.imp.sub">start.imp.sub</code></td>
<td>

<p>Starting value for the missing data in the outcome of the substantive model. For family=&quot;binomial&quot;, these are the values of the latent normals. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are fixed effect parameters of the covariates beta (collectbeta), level 1 covariance matrices (collectomega), fixed effect estimates of the substantive model and associated residual variances. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # make sure social is a factor:
  
  cldata&lt;-within(cldata, social&lt;-factor(social))
  
  # we define the data frame with all the variables 
  
  data&lt;-cldata[,c("measure","age", "social", "city")]
  
  # And the formula of the substantive lm model 
  # social as an outcome only because it is the only ordinal variable in the dataset...
  
  formula&lt;-as.formula(social~age+measure+(1|city))
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.clmm.MCMCchain(formula,data, nburn=100)
  
  # We can check, for example, the convergence of the first element of beta:
  
  # plot(c(1:100),imp$collectbeta[1,1,1:100],type="l")
  
  
</code></pre>

<hr>
<h2 id='jomo.coxph'>
Joint Modelling Imputation Compatible with Cox Proportional Hazards Model
</h2><span id='topic+jomo.coxph'></span>

<h3>Description</h3>

<p>A function for substantive model compatible JM imputation, when the substantive model of interest is a Cox Proportional Hazards Model. Interactions and polynomial functions of the covariates are allowed. Data must be passed as a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.coxph(formula, data,  beta.start=NULL, l1cov.start=NULL, l1cov.prior=NULL, 
          nburn=1000, nbetween=1000, nimp=5, output=1, out.iter=10) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.coxph_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.coxph_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.coxph_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.coxph_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. 
</p>
</td></tr>
<tr><td><code id="jomo.coxph_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.coxph_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.coxph_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.coxph_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo.coxph_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.coxph_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function allows for substantive model compatible imputation when the substantive model is a Cox PH model. It can deal with interactions and polynomial terms through the usual lm syntax in the formula argument. 
Format of the columns of data is crucial in order for the function to deal with binary/categorical covariates appropriately in the imputation algorithm.  </p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effect estimates and of the residual variance are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define substantive model
formula&lt;-as.formula(Surv(time, status) ~ measure + sex + I(measure^2))

#Run imputation
if (requireNamespace("survival", quietly = TRUE)) {
  library(survival)
  #imp&lt;-jomo.coxph(formula,surdata, nburn = 100, nbetween = 100, nimp=5)
}
  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules

</code></pre>

<hr>
<h2 id='jomo.coxph.MCMCchain'>
coxph Compatible JM Imputation - A tool to check convergence of the MCMC
</h2><span id='topic+jomo.coxph.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to the jomo.coxph function, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.coxph.MCMCchain(formula, data, beta.start = NULL, l1cov.start = NULL,
                 l1cov.prior = NULL, nburn = 1000, start.imp = NULL,
                 betaY.start = NULL, output = 1, out.iter = 10)
  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.coxph.MCMCchain_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.coxph.MCMCchain_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.coxph.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.coxph.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. 
</p>
</td></tr>
<tr><td><code id="jomo.coxph.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.coxph.MCMCchain_+3A_betay.start">betaY.start</code></td>
<td>

<p>Starting value for betaY, the vector of fixed effects for the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.coxph.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.coxph.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.coxph.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.coxph.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the missing data in the covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are fixed effect parameters of the covariates beta (collectbeta), level 1 covariance matrices (collectomega), fixed effect estimates of the substantive model. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # define substantive model

    formula&lt;-as.formula(Surv(time, status) ~ measure + sex + I(measure^2))
    
    #Run imputation
    
if (requireNamespace("survival", quietly = TRUE)) {
  library(survival)
  #imp&lt;-jomo.coxph.MCMCchain(formula,surdata, nburn = 100)
  }
    
</code></pre>

<hr>
<h2 id='jomo.glm'>
Joint Modelling Imputation Compatible with glm Model
</h2><span id='topic+jomo.glm'></span>

<h3>Description</h3>

<p>A function for substantive model compatible JM imputation, when the substantive model of interest is a simple generalized linear regression model. Interactions and polynomial functions of the covariates are allowed. Data must be passed as a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'> jomo.glm(formula, data, beta.start=NULL, l1cov.start=NULL, 
        l1cov.prior=NULL,nburn=1000, nbetween=1000, nimp=5, 
        output=1, out.iter=10, family="binomial") 
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.glm_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. 
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.glm_+3A_family">family</code></td>
<td>

<p>One of either &quot;gaussian&quot;&quot; or &quot;binomial&quot;. For binomial family, a probit link is assumed. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for substantive model compatible imputation when the substantive model is a simple linear regression model. It can deal with interactions and polynomial terms through the usual lm syntax in the formula argument. 
Format of the columns of data is crucial in order for the function to deal with binary/categorical covariates appropriately in the imputation algorithm.  </p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effect estimates and of the residual variance are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   # make sure sex is a factor:
  
  sldata&lt;-within(sldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-sldata[,c("measure","age", "sex")]
  
  # And the formula of the substantive lm model 
  # sex as an outcome only because it is the only binary variable in the dataset...
  
  formula&lt;-as.formula(sex~age+measure)
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.glm(formula,data, nburn=10, nbetween=10, nimp=2)
  
  # Note we are using only 10 iterations to avoid time consuming examples, 
  # which go against CRAN policies. In real applications we would use
  # much larger burn-ins (around 1000) and at least 5 imputations.
  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules

  
</code></pre>

<hr>
<h2 id='jomo.glm.MCMCchain'>
glm Compatible JM Imputation - A tool to check convergence of the MCMC
</h2><span id='topic+jomo.glm.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to the jomo.glm function, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.glm.MCMCchain(formula, data, beta.start=NULL, l1cov.start=NULL, 
  l1cov.prior=NULL, betaY.start=NULL, nburn=1000, 
  start.imp=NULL, start.imp.sub=NULL, output=1, out.iter=10, 
  family="binomial") 
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.glm.MCMCchain_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed covariates. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_start.imp.sub">start.imp.sub</code></td>
<td>

<p>Starting value for the imputations of the outcome. When using binomial family, this is the value of the latent normal.
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. 
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_betay.start">betaY.start</code></td>
<td>

<p>Starting value for betaY, the vector of fixed effects for the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.glm.MCMCchain_+3A_family">family</code></td>
<td>

<p>One of either &quot;gaussian&quot;&quot; or &quot;binomial&quot;. For binomial family, a probit link is assumed. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are fixed effect parameters of the covariates beta (collectbeta), level 1 covariance matrices (collectomega), fixed effect estimates of the substantive model and associated residual variances. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # make sure sex is a factor:
  
  sldata&lt;-within(sldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-sldata[,c("measure","age", "sex")]
  
  # And the formula of the substantive lm model 
  # sex as an outcome only because it is the only binary variable in the dataset...
  
  formula&lt;-as.formula(sex~age+measure)
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.glm.MCMCchain(formula,data, nburn=10)
  
  # Note we are using only 10 iterations to avoid time consuming examples,
  # which go against CRAN policies. In real applications we would use
  # much larger burn-ins (around 1000, to say the least).
  
  # We can check, for example, the convergence of the first element of beta:
  
  plot(c(1:10),imp$collectbeta[1,1,1:10],type="l")
  
  
</code></pre>

<hr>
<h2 id='jomo.glmer'>
Joint Modelling Imputation Compatible with Generalized Linear Mixed Model
</h2><span id='topic+jomo.glmer'></span>

<h3>Description</h3>

<p>A function for substantive model compatible JM imputation, when the substantive model of interest is a generalized linear mixed-effects regression model. Interactions and polynomial functions of the covariates are allowed. Data must be passed as a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.glmer(formula, data, level=rep(1,ncol(data)), beta.start=NULL,
            l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, 
            l2cov.start=NULL, l1cov.prior=NULL, l2cov.prior=NULL, 
            a.start=NULL, a.prior=NULL, nburn=1000, nbetween=1000, 
            nimp=5, meth="common", output=1, out.iter=10, 
            family="binomial") 
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.glmer_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_level">level</code></td>
<td>

<p>A vector, indicating whether each variable is either a level 1 or a level 2 variable. The value assigned to the cluster indicator is irrelevant.    
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster of the random effects estimates u for the joint model for the covariates. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of level-1 covariates (continuous plus latent normals) in the analysis model times the number of random effects plus the number of level-2 covariates. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_a.start">a.start</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.glmer_+3A_family">family</code></td>
<td>

<p>One of either &quot;gaussian&quot;&quot; or &quot;binomial&quot;. For binomial family, a probit link is assumed. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for substantive model compatible imputation when the substantive model is a linear mixed-effects model. It can deal with interactions and polynomial terms through the usual lmer syntax in the formula argument. 
Format of the columns of data is crucial in order for the function to deal with binary/categorical covariates appropriately in the imputation algorithm.  
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effect estimates and of the residual variance are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # make sure sex is a factor:
  
  cldata&lt;-within(cldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-cldata[,c("measure","age", "sex", "city")]
  
  # And the formula of the substantive lm model 
  # sex as an outcome only because it is the only binary variable in the dataset...
  
  formula&lt;-as.formula(sex~age+measure+(1|city))
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.glmer(formula,data, nburn=2, nbetween=2, nimp=2)
  
  # Note we are using only 2 iterations to avoid time consuming examples, 
  # which go against CRAN policies. In real applications we would use
  # much larger burn-ins (around 1000) and at least 5 imputations.
  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules

  
  
</code></pre>

<hr>
<h2 id='jomo.glmer.MCMCchain'>
glmer Compatible JM Imputation - A tool to check convergence of the MCMC
</h2><span id='topic+jomo.glmer.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to the jomo.glmer function, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.glmer.MCMCchain(formula, data, level=rep(1,ncol(data)), 
                      beta.start=NULL, l2.beta.start=NULL, u.start=NULL,
                      l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL,
                      l2cov.prior=NULL, a.start=NULL, a.prior=NULL,
                      betaY.start=NULL, covuY.start=NULL,
                      uY.start=NULL, nburn=1000, meth="common", 
                      start.imp=NULL, start.imp.sub=NULL, l2.start.imp=NULL,
                      output=1, out.iter=10, family="binomial") 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.glmer.MCMCchain_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_level">level</code></td>
<td>

<p>A vector, indicating whether each variable is either a level 1 or a level 2 variable. The value assigned to the cluster indicator is irrelevant.   
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster of the random effects estimates u for the joint model for the covariates. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of level-1 covariates (continuous plus latent normals) in the analysis model times the number of random effects plus the number of level-2 covariates. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_a.start">a.start</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_betay.start">betaY.start</code></td>
<td>

<p>Starting value for betaY, the vector of fixed effects for the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_covuy.start">covuY.start</code></td>
<td>

<p>Starting value for covuY, the random effects covariance matrix of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_uy.start">uY.start</code></td>
<td>

<p>Starting value for uY, the random effects matrix of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the missing data in the covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_l2.start.imp">l2.start.imp</code></td>
<td>

<p>Starting value for the missing data in the level-2 covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_start.imp.sub">start.imp.sub</code></td>
<td>

<p>Starting value for the missing data in the outcome of the substantive model. For family=&quot;binomial&quot;, these are the values of the latent normals. 
</p>
</td></tr>
<tr><td><code id="jomo.glmer.MCMCchain_+3A_family">family</code></td>
<td>

<p>One of either &quot;gaussian&quot;&quot; or &quot;binomial&quot;. For binomial family, a probit link is assumed. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are fixed effect parameters of the covariates beta (collectbeta), level 1 covariance matrices (collectomega), fixed effect estimates of the substantive model and associated residual variances. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # make sure sex is a factor:
  
  cldata&lt;-within(cldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-cldata[,c("measure","age", "sex", "city")]
  
  # And the formula of the substantive lm model 
  # sex as an outcome only because it is the only binary variable in the dataset...
  
  formula&lt;-as.formula(sex~age+measure+(1|city))
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.glmer.MCMCchain(formula,data, nburn=100)
  
  # We can check, for example, the convergence of the first element of beta:
  
  # plot(c(1:100),imp$collectbeta[1,1,1:100],type="l")
  
  
</code></pre>

<hr>
<h2 id='jomo.lm'>
Joint Modelling Imputation Compatible with Linear Regression Model
</h2><span id='topic+jomo.lm'></span>

<h3>Description</h3>

<p>A function for substantive model compatible JM imputation, when the substantive model of interest is a simple linear regression model. Interactions and polynomial functions of the covariates are allowed. Data must be passed as a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'> jomo.lm(formula, data,  beta.start=NULL, l1cov.start=NULL,
        l1cov.prior=NULL, nburn=1000, nbetween=1000, nimp=5, 
        output=1, out.iter=10) 
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.lm_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.lm_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.lm_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.lm_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. 
</p>
</td></tr>
<tr><td><code id="jomo.lm_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.lm_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.lm_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.lm_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo.lm_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.lm_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for substantive model compatible imputation when the substantive model is a simple linear regression model. It can deal with interactions and polynomial terms through the usual lm syntax in the formula argument. 
Format of the columns of data is crucial in order for the function to deal with binary/categorical covariates appropriately in the imputation algorithm.  </p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effect estimates and of the residual variance are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   # make sure sex is a factor:
  
  sldata&lt;-within(sldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-sldata[,c("measure","age", "sex")]
  
  # And the formula of the substantive lm model
  
  formula&lt;-as.formula(measure~sex+age+I(age^2))
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.lm(formula,data, nburn=100, nbetween=100)
  
  # Note we are using only 100 iterations to avoid time consuming examples, 
  # which go against CRAN policies. 
  # If we were interested in a model with interactions:
  
  formula2&lt;-as.formula(measure~sex*age)
  imp2&lt;-jomo.lm(formula2,data, nburn=100, nbetween=100)
  
  # The analysis and combination steps are as for all the other functions
  # (see e.g. help file for function jomo)

  
  
</code></pre>

<hr>
<h2 id='jomo.lm.MCMCchain'>
lm Compatible JM Imputation - A tool to check convergence of the MCMC
</h2><span id='topic+jomo.lm.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to the jomo.lm function, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.lm.MCMCchain(formula, data, beta.start=NULL, l1cov.start=NULL,
  l1cov.prior=NULL, betaY.start=NULL, varY.start=NULL, nburn=1000,
  start.imp=NULL, start.imp.sub=NULL, output=1, out.iter=10) 
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.lm.MCMCchain_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. 
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_betay.start">betaY.start</code></td>
<td>

<p>Starting value for betaY, the vector of fixed effects for the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_vary.start">varY.start</code></td>
<td>

<p>Starting value for varY, the residual variance of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the missing data in the covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.lm.MCMCchain_+3A_start.imp.sub">start.imp.sub</code></td>
<td>

<p>Starting value for the missing data in the outcome of the substantive model.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are fixed effect parameters of the covariates beta (collectbeta), level 1 covariance matrices (collectomega), fixed effect estimates of the substantive model and associated residual variances. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   # make sure sex is a factor:
  
  sldata&lt;-within(sldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-sldata[,c("measure","age", "sex")]
  
  # And the formula of the substantive lm model
  
  formula&lt;-as.formula(measure~sex+age+I(age^2))
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.lm.MCMCchain(formula,data, nburn=100)
  
  # Note we are using only 100 iterations to avoid time consuming examples,
  # which go against CRAN policies. 
  
  # We can check, for example, the convergence of the first element of beta:
  
  plot(c(1:100),imp$collectbeta[1,1,1:100],type="l")
  
  
</code></pre>

<hr>
<h2 id='jomo.lmer'>
Joint Modelling Imputation Compatible with Linear Mixed-effects Regression Model
</h2><span id='topic+jomo.lmer'></span>

<h3>Description</h3>

<p>A function for substantive model compatible JM imputation, when the substantive model of interest is a linear mixed-effects regression model. Interactions and polynomial functions of the covariates are allowed. Data must be passed as a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.lmer(formula, data, level=rep(1,ncol(data)), beta.start=NULL, 
            l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL,
            l1cov.prior=NULL, l2cov.prior=NULL, a.start=NULL, a.prior=NULL, 
            nburn=1000, nbetween=1000, nimp=5, meth="common", output=1, out.iter=10) 
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.lmer_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_level">level</code></td>
<td>

<p>A vector, indicating whether each variable is either a level 1 or a level 2 variable. The value assigned to the cluster indicator is irrelevant.    
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster of the random effects estimates u for the joint model for the covariates. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of level-1 covariates (continuous plus latent normals) in the analysis model times the number of random effects plus the number of level-2 covariates. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_a.start">a.start</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.lmer_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for substantive model compatible imputation when the substantive model is a linear mixed-effects model. It can deal with interactions and polynomial terms through the usual lmer syntax in the formula argument. 
Format of the columns of data is crucial in order for the function to deal with binary/categorical covariates appropriately in the imputation algorithm.  
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effect estimates and of the residual variance are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # make sure sex is a factor:
  
  cldata&lt;-within(cldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-cldata[,c("measure","age", "sex", "city")]
  mylevel&lt;-c(1,1,1,1)
  
  # And the formula of the substantive lm model
  
  formula&lt;-as.formula(measure~sex+age+I(age^2)+(1|city))
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.lmer(formula,data, level=mylevel, nburn=10, nbetween=10)
  
  # Note we are using only 10 iterations to avoid time consuming examples, 
  # which go against CRAN policies. 
  # If we were interested in a model with interactions:
  
  # formula2&lt;-as.formula(measure~sex*age+(1|city))
  # imp2&lt;-jomo.lmer(formula2,data, level=mylevel, nburn=10, nbetween=10)
  
  # The analysis and combination steps are as for all the other functions
  # (see e.g. help file for function jomo)
  
  
  
</code></pre>

<hr>
<h2 id='jomo.lmer.MCMCchain'>
lmer Compatible JM Imputation - A tool to check convergence of the MCMC
</h2><span id='topic+jomo.lmer.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to the jomo.lmer function, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.lmer.MCMCchain(formula, data, level=rep(1,ncol(data)), beta.start=NULL, 
                      l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, 
                      l2cov.start=NULL, l1cov.prior=NULL, l2cov.prior=NULL, 
                      a.start=NULL, a.prior=NULL, betaY.start=NULL, 
                      varY.start=NULL, covuY.start=NULL, uY.start=NULL, 
                      nburn=1000, meth="common", start.imp=NULL, 
                      start.imp.sub=NULL, l2.start.imp=NULL, output=1, 
                      out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.lmer.MCMCchain_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_level">level</code></td>
<td>

<p>A vector, indicating whether each variable is either a level 1 or a level 2 variable. The value assigned to the cluster indicator is irrelevant. 
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster of the random effects estimates u for the joint model for the covariates. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of level-1 covariates (continuous plus latent normals) in the analysis model times the number of random effects plus the number of level-2 covariates. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_a.start">a.start</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_betay.start">betaY.start</code></td>
<td>

<p>Starting value for betaY, the vector of fixed effects for the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_vary.start">varY.start</code></td>
<td>

<p>Starting value for varY, the residual variance of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_covuy.start">covuY.start</code></td>
<td>

<p>Starting value for covuY, the random effects covariance matrix of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_uy.start">uY.start</code></td>
<td>

<p>Starting value for uY, the random effects matrix of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the missing data in the covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_l2.start.imp">l2.start.imp</code></td>
<td>

<p>Starting value for the missing data in the level-2 covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.lmer.MCMCchain_+3A_start.imp.sub">start.imp.sub</code></td>
<td>

<p>Starting value for the missing data in the outcome of the substantive model.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are fixed effect parameters of the covariates beta (collectbeta), level 1 covariance matrices (collectomega), fixed effect estimates of the substantive model and associated residual variances. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # make sure sex is a factor:
  
  cldata&lt;-within(cldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-cldata[,c("measure","age", "sex", "city")]
  mylevel&lt;-c(1,1,1,1)
  
  # And the formula of the substantive lm model
  
  formula&lt;-as.formula(measure~sex+age+I(age^2)+(1|city))
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.lmer.MCMCchain(formula,data, level=mylevel, nburn=100)
  
  # Note we are using only 100 iterations to avoid time consuming examples, 
  # which go against CRAN policies. 
  
  # We can check, for example, the convergence of the first element of beta:
  
  plot(c(1:100),imp$collectbeta[1,1,1:100],type="l")
  
  
</code></pre>

<hr>
<h2 id='jomo.MCMCchain'>
JM Imputation - A tool to check convergence of the MCMC
</h2><span id='topic+jomo.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to the jomo function, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.MCMCchain(Y, Y2=NULL, X=NULL, X2=NULL, Z=NULL, clus=NULL, 
                 beta.start=NULL, l2.beta.start=NULL, u.start=NULL,
                 l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL, 
                l2cov.prior=NULL, start.imp=NULL, l2.start.imp=NULL, 
    nburn=1000, a=NULL, a.prior=NULL, meth="common",output=1, out.iter=10) 
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.MCMCchain_+3A_y">Y</code></td>
<td>

<p>A data.frame containing the outcomes of the imputation model, i.e. the partially observed level 1 variables. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_y2">Y2</code></td>
<td>

<p>A data.frame containing the level-2 outcomes of the imputation model, i.e. the partially observed level-2 variables. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_x2">X2</code></td>
<td>

<p>A data frame, or matrix, with level-2 covariates of the joint imputation model. Rows correspond to different level-1 observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. If missing, functions for single level imputation are automatically used.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects. Rows index different covariates and columns index different level-2 outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects plus the number of level-2 outcomes. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_l2.start.imp">l2.start.imp</code></td>
<td>

<p>Starting value for the level-2 imputed variables. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are, potentially, fixed effect parameters beta (collectbeta), random effects (collectu), level 1 (collectomega) and level 2 covariance matrices (collectcovu) and level-2 fixed effect parameters. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # define all the inputs:
  
  Y&lt;-cldata[,c("measure","age")]
  clus&lt;-cldata[,c("city")]
  nburn=as.integer(200);
  
  #And finally we run the imputation function:
  imp&lt;-jomo.MCMCchain(Y,clus=clus,nburn=nburn)
  #We can check the convergence of the first element of beta:
  
  plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")
  
  #Or similarly we can check the convergence of any element of the level 2 covariance matrix:
  
  plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='jomo.polr'>
Joint Modelling Imputation Compatible with Proportional Odds Ordinal Probit Regression 
</h2><span id='topic+jomo.polr'></span>

<h3>Description</h3>

<p>A function for substantive model compatible JM imputation, when the substantive model of interest is a simple ordinal regression model. Interactions and polynomial functions of the covariates are allowed. Data must be passed as a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'> jomo.polr(formula, data, beta.start=NULL, l1cov.start=NULL, 
        l1cov.prior=NULL,nburn=1000, nbetween=1000, nimp=5, 
        output=1, out.iter=10) 
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.polr_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.polr_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.polr_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.polr_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. 
</p>
</td></tr>
<tr><td><code id="jomo.polr_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.polr_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.polr_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.polr_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo.polr_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.polr_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for substantive model compatible imputation when the substantive model is a simple ordinal regression model. It can deal with interactions and polynomial terms through the usual lm syntax in the formula argument. 
Format of the columns of data is crucial in order for the function to deal with binary/categorical covariates appropriately in the imputation algorithm.  </p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effect estimates and of the residual variance are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
   # make sure social is a factor:
  
  sldata&lt;-within(sldata, social&lt;-factor(social))
  
  # we define the data frame with all the variables 
  
  data&lt;-sldata[,c("measure","age", "social")]
  
  # And the formula of the substantive lm model 
  # social as an outcome only because it is the only binary variable in the dataset...
  
  formula&lt;-as.formula(social~age+measure)
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.polr(formula,data, nburn=100, nbetween=100, nimp=2)
  
  # Note we are using only 100 iterations to avoid time consuming examples, 
  # which go against CRAN policies. In real applications we would use
  # much larger burn-ins (around 1000) and at least 5 imputations.
  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules

  
</code></pre>

<hr>
<h2 id='jomo.polr.MCMCchain'>
polr Compatible JM Imputation - A tool to check convergence of the MCMC
</h2><span id='topic+jomo.polr.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to the jomo.polr function, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.polr.MCMCchain(formula, data, beta.start=NULL, l1cov.start=NULL, 
  l1cov.prior=NULL, betaY.start=NULL, nburn=1000, 
  start.imp=NULL, start.imp.sub=NULL, output=1, out.iter=10) 
  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.polr.MCMCchain_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed covariates. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_start.imp.sub">start.imp.sub</code></td>
<td>

<p>Starting value for the imputations of the outcome. When using binomial family, this is the value of the latent normal.
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. 
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_betay.start">betaY.start</code></td>
<td>

<p>Starting value for betaY, the vector of fixed effects for the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.polr.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are fixed effect parameters of the covariates beta (collectbeta), level 1 covariance matrices (collectomega), fixed effect estimates of the substantive model and associated residual variances. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # make sure social is a factor:
  
  sldata&lt;-within(sldata, social&lt;-factor(social))
  
  # we define the data frame with all the variables 
  
  data&lt;-sldata[,c("measure","age", "social")]
  
  # And the formula of the substantive lm model 
  # social as an outcome only because it is the only ordinal variable in the dataset...
  
  formula&lt;-as.formula(social~age+measure)
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.polr.MCMCchain(formula,data, nburn=100)
  
  # Note we are using only 100 iterations to avoid time consuming examples,
  # which go against CRAN policies. In real applications we would use
  # much larger burn-ins (around 1000, to say the least).
  
  # We can check, for example, the convergence of the first element of beta:
  
  plot(c(1:100),imp$collectbeta[1,1,1:100],type="l")
  
  
</code></pre>

<hr>
<h2 id='jomo.smc'>
Joint Modelling Substantive Model Compatible Imputation 
</h2><span id='topic+jomo.smc'></span>

<h3>Description</h3>

<p>A wrapper function for all the substantive model compatible JM imputation functions. The substantive model of interest is either lm, glm, polr, lmer, clmm, glmer or coxph. Interactions and polynomial functions of the covariates are allowed. Data must be passed as a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.smc(formula, data, level=rep(1,ncol(data)), beta.start=NULL,
  l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL,
  l1cov.prior=NULL, l2cov.prior=NULL, a.start=NULL, a.prior=NULL, 
  nburn=1000, nbetween=1000, nimp=5, meth="common", family="binomial",
  output=1, out.iter=10, model) 
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.smc_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_level">level</code></td>
<td>

<p>If the dataset is multilevel, this must be a vector indicating whether each variable is either a level 1 or a level 2 variable. The value assigned to the cluster indicator is irrelevant.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster of the random effects estimates u for the joint model for the covariates. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of level-1 covariates (continuous plus latent normals) in the analysis model times the number of random effects plus the number of level-2 covariates. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_a.start">a.start</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_model">model</code></td>
<td>

<p>The type of model we want to impute compatibly with. It can currently be one of lm, glm (binomial), polr, coxph, lmer, clmm or glmer (binomial).
</p>
</td></tr>
<tr><td><code id="jomo.smc_+3A_family">family</code></td>
<td>

<p>One of either &quot;gaussian&quot;&quot; or &quot;binomial&quot;. For binomial family, a probit link is assumed. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows for substantive model compatible imputation. It can deal with interactions and polynomial terms through the usual lmer syntax in the formula argument. 
Format of the columns of data is crucial in order for the function to deal with binary/categorical covariates appropriately in the imputation algorithm.  </p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effect estimates and of the residual variance are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # make sure sex is a factor:
  
  cldata&lt;-within(cldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-cldata[,c("measure","age", "sex", "city")]
  mylevel&lt;-c(1,1,1,1)
  
  # And the formula of the substantive lm model
  
  formula&lt;-as.formula(measure~sex+age+I(age^2)+(1|city))
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.smc(formula,data, level=mylevel, nburn=100, nbetween=100, model="lmer")
  
  # Note we are using only 100 iterations to avoid time consuming examples, 
  # which go against CRAN policies. 
  # If we were interested in a model with interactions:
  
  # formula2&lt;-as.formula(measure~sex*age+(1|city))
  # imp2&lt;-jomo.smc(formula2,data, level=mylevel, nburn=100, nbetween=100, model="lmer")
  
  # The analysis and combination steps are as for all the other functions
  # (see e.g. help file for function jomo)

  
  
  
</code></pre>

<hr>
<h2 id='jomo.smc.MCMCchain'>
Substantive Model Compatible JM Imputation - A tool to check convergence of the MCMC
</h2><span id='topic+jomo.smc.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to the jomo.smc function, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jomo.smc.MCMCchain(formula, data, level=rep(1,ncol(data)), beta.start=NULL,
  l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, 
  l1cov.prior=NULL, l2cov.prior=NULL, a.start=NULL, a.prior=NULL, 
  betaY.start=NULL, varY.start=NULL, covuY.start=NULL, uY.start=NULL, 
  nburn=1000,  meth="common", family="binomial", 
  start.imp=NULL, start.imp.sub=NULL, l2.start.imp=NULL, output=1, 
  out.iter=10, model) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo.smc.MCMCchain_+3A_formula">formula</code></td>
<td>

<p>an object of class formula: a symbolic description of the model to be fitted. It is possible to include in this formula interactions (through symbols '*' and '
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_data">data</code></td>
<td>

<p>A data.frame containing all the variables to include in the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_level">level</code></td>
<td>

<p>If the dataset is multilevel, this must be a vector indicating whether each variable is either a level 1 or a level 2 variable. The value assigned to the cluster indicator is irrelevant.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects for the joint model for the covariates. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster of the random effects estimates u for the joint model for the covariates. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value of the level-1 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of covariates (continuous plus latent normals) in the imputation model. The default is the identity matrix. Functions for imputation with random cluster-specific covariance matrices are an exception, because we need to pass the starting values for all of the matrices stacked one above the other. 
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix of the joint model for the covariates. Dimension of this square matrix is equal to the number of level-1 covariates (continuous plus latent normals) in the analysis model times the number of random effects plus the number of level-2 covariates. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_a.start">a.start</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only with clustered data and when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_betay.start">betaY.start</code></td>
<td>

<p>Starting value for betaY, the vector of fixed effects for the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_vary.start">varY.start</code></td>
<td>

<p>Starting value for varY, the residual variance of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_covuy.start">covuY.start</code></td>
<td>

<p>Starting value for covuY, the random effects covariance matrix of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_uy.start">uY.start</code></td>
<td>

<p>Starting value for uY, the random effects matrix of the substantive analysis model.  The default is the complete records estimate.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to 0, no output is shown on screen at the end of the process. When set to 1, only the parameter estimates related to the substantive model are shown (default). When set to 2, all parameter estimates (posterior means) are displayed.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the missing data in the covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_l2.start.imp">l2.start.imp</code></td>
<td>

<p>Starting value for the missing data in the level-2 covariates of the substantive model. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_start.imp.sub">start.imp.sub</code></td>
<td>

<p>Starting value for the missing data in the outcome of the substantive model.
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_model">model</code></td>
<td>

<p>The type of model we want to impute compatibly with. It can currently be one of lm, glm (binomial), polr, coxph, lmer, clmm or glmer (binomial).
</p>
</td></tr>
<tr><td><code id="jomo.smc.MCMCchain_+3A_family">family</code></td>
<td>

<p>One of either &quot;gaussian&quot;&quot; or &quot;binomial&quot;. For binomial family, a probit link is assumed. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are fixed effect parameters of the covariates beta (collectbeta), level 1 covariance matrices (collectomega), fixed effect estimates of the substantive model and associated residual variances. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # make sure sex is a factor:
  
  cldata&lt;-within(cldata, sex&lt;-factor(sex))
  
  # we define the data frame with all the variables 
  
  data&lt;-cldata[,c("measure","age", "sex", "city")]
  mylevel&lt;-c(1,1,1,1)
  
  # And the formula of the substantive lm model
  
  formula&lt;-as.formula(measure~sex+age+I(age^2)+(1|city))
  
  #And finally we run the imputation function:
  
  imp&lt;-jomo.smc.MCMCchain(formula,data, level=mylevel, nburn=100, model="lmer")
  
  # Note we are using only 100 iterations to avoid time consuming examples, 
  # which go against CRAN policies. 
  
  # We can check, for example, the convergence of the first element of beta:
  
  plot(c(1:100),imp$collectbeta[1,1,1:100],type="l")
 
  
</code></pre>

<hr>
<h2 id='jomo1'>
JM Imputation of single level data
</h2><span id='topic+jomo1'></span>

<h3>Description</h3>

<p>A wrapper function linking the 3 single level JM Imputation functions. The matrix of responses Y, must be a data.frame where continuous variables are numeric and binary/categorical variables are factors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1 (Y, X=NULL, beta.start=NULL, l1cov.start=NULL, l1cov.prior=NULL, 
      nburn=100, nbetween=100, nimp=5, output=1, out.iter=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1_+3A_y">Y</code></td>
<td>

<p>A data.frame containing the outcomes of the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo1_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a wrapper function to link jomo1con, jomo1cat and jomo1mix. Format of the columns of Y is crucial in order for the function to be using the right sub-function. 
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 3-5, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define all the inputs:
  
Y&lt;-sldata[,c("measure","age")]
nburn=as.integer(200);
nbetween=as.integer(200);
nimp=as.integer(5);

# Then we run the function:

imp&lt;-jomo1(Y,nburn=nburn,nbetween=nbetween,nimp=nimp)

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules

</code></pre>

<hr>
<h2 id='jomo1.MCMCchain'>
JM Imputation of single level data - A tool to check convergence of the MCMC
</h2><span id='topic+jomo1.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1.MCMCchain(Y, X=NULL, beta.start=NULL, l1cov.start=NULL, l1cov.prior=NULL,
start.imp=NULL, nburn=100, output=1, out.iter=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1.MCMCchain_+3A_y">Y</code></td>
<td>

<p>A data.frame containing the outcomes of the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo1.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo1.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements is returned: the final imputed dataset (finimp) and three 3-dimensional matrices, containing all the values for beta (collectbeta) and omega (collectomega). If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define all the inputs:
  
Y&lt;-sldata[,c("measure","age")]
nburn=as.integer(200);

# Then we run the function:

imp&lt;-jomo1.MCMCchain(Y,nburn=nburn)

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of omega:

plot(c(1:nburn),imp$collectomega[1,2,1:nburn],type="l")


</code></pre>

<hr>
<h2 id='jomo1cat'>
JM Imputation of single level data with categorical variables
</h2><span id='topic+jomo1cat'></span>

<h3>Description</h3>

<p>Impute a single level dataset with categorical variables as outcomes. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler where the covariance matrix is updated with a Metropolis-Hastings step. Fully observed categorical covariates can be included in the imputation model as covariates as well, but in that case dummy variables have to be created first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1cat(Y.cat, Y.numcat, X=NULL, beta.start=NULL, l1cov.start=NULL, 
l1cov.prior=NULL, nburn=100, nbetween=100, nimp=5,output=1, out.iter=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1cat_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1cat_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gibbs sampler algorithm used is described in detail in Chapter 5 of Carpenter and Kenward (2013). Regarding the choice of the priors, a flat prior is considered for beta and for the covariance matrix. A Metropolis Hastings step is implemented to update the covariance matrix, as described in the book. Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only. 
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 5, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make sure sex is a factor:

sldata&lt;-within(sldata, sex&lt;-factor(sex))


# we define all the inputs:
# nimp, nburn and nbetween are smaller than they should. This is
#just because of CRAN policies on the examples.

Y.cat=sldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,300),sldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
beta.start&lt;-matrix(0,2,3)
l1cov.start&lt;-diag(1,3)
l1cov.prior=diag(1,3);
nburn=as.integer(100);
nbetween=as.integer(100);
nimp=as.integer(5);

# Finally we run the sampler:

imp&lt;-jomo1cat(Y.cat,Y.numcat,X,beta.start,l1cov.start,l1cov.prior,nburn,nbetween,nimp)

#See one of the imputed values:

cat("Original value was missing (",imp[16,1],"), imputed value:", imp[316,1])

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules


</code></pre>

<hr>
<h2 id='jomo1cat.MCMCchain'>
JM Imputation of single level data with categorical variables -
A tool to check convergence of the MCMC
</h2><span id='topic+jomo1cat.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1cat, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1cat.MCMCchain(Y.cat, Y.numcat, X=NULL, beta.start=NULL, 
l1cov.start=NULL, l1cov.prior=NULL, start.imp=NULL,
nburn=100, output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1cat.MCMCchain_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1cat.MCMCchain_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1cat.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1cat.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1cat.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1cat.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1cat.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo1cat.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1cat.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1cat.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four elements is returned: the final imputed dataset (finimp) and three 3-dimensional matrices, containing all the values drawn at each iteration for fixed effect parameters beta (collectbeta) and covariance matrix omega (collectomega). Finally, in finimp.latnorm, it is stored the final state of the imputed dataset with the latent normals in place of the categorical variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make sure sex is a factor:

sldata&lt;-within(sldata, sex&lt;-factor(sex))

# we define all the inputs:
#  nburn is smaller than necessary. This is
#just because of CRAN policies on the examples.

Y.cat=sldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,300),sldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
beta.start&lt;-matrix(0,2,3)
l1cov.start&lt;-diag(1,3)
l1cov.prior=diag(1,3);
nburn=as.integer(100);

# Finally we run the sampler:

imp&lt;-jomo1cat.MCMCchain(Y.cat,Y.numcat,X,beta.start,l1cov.start,l1cov.prior,nburn=nburn)

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")


</code></pre>

<hr>
<h2 id='jomo1con'>
JM Imputation of single level data with continuous variables only
</h2><span id='topic+jomo1con'></span>

<h3>Description</h3>

<p>Impute a single level dataset with continuous outcomes only. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler. Categorical covariates may be considered, but they have to be included with dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1con(Y, X=NULL, beta.start=NULL, l1cov.start=NULL, l1cov.prior=NULL, 
nburn=100, nbetween=100, nimp=5, output=1, out.iter=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1con_+3A_y">Y</code></td>
<td>

<p>A data frame, or matrix, with responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1con_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1con_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1con_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1con_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1con_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1con_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1con_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1con_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1con_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gibbs sampler algorithm used is described in detail in Chapter 3 of Carpenter and Kenward (2013). Regarding the choice of the priors, a flat prior is considered for beta, while an inverse-Wishart prior is given to the covariance matrix, with p-1 degrees of freedom, aka the minimum possible, to guarantee the greatest uncertainty. Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included through dummy variables (binary indicators) only. 
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 3, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#We define all the inputs:

Y=sldata[,c("measure", "age")]
X=data.frame(rep(1,300),sldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
beta.start&lt;-matrix(0,2,2)
l1cov.start&lt;-diag(1,2)
l1cov.prior=diag(1,2);
nburn=as.integer(200);
nbetween=as.integer(200);
nimp=as.integer(5);

# Then we run he function:

imp&lt;-jomo1con(Y,X,beta.start,l1cov.start,l1cov.prior,nburn,nbetween,nimp)

cat("Original value was missing(",imp[1,1],"), imputed value:", imp[301,1])

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules


</code></pre>

<hr>
<h2 id='jomo1con.MCMCchain'>
JM Imputation of single level data with continuous variables only -
A tool to check convergence of the MCMC
</h2><span id='topic+jomo1con.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1con, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1con.MCMCchain(Y, X=NULL, beta.start=NULL, l1cov.start=NULL, 
l1cov.prior=NULL, start.imp=NULL, nburn=100, output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1con.MCMCchain_+3A_y">Y</code></td>
<td>

<p>A data frame, or matrix, with responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1con.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1con.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1con.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1con.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1con.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. 
</p>
</td></tr>
<tr><td><code id="jomo1con.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1con.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1con.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements is returned: the final imputed dataset (finimp) and three 3-dimensional matrices, containing all the values for the fixed effect parameters beta (collectbeta) and the covariance matrix omega (collectomega).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#We define all the inputs:

Y=sldata[,c("measure", "age")]
X=data.frame(rep(1,300),sldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")

beta.start&lt;-matrix(0,2,2)
l1cov.start&lt;-diag(1,2)
l1cov.prior=diag(1,2);
nburn=as.integer(200);

# Then we run he function:

imp&lt;-jomo1con.MCMCchain(Y,X,beta.start,l1cov.start,l1cov.prior,nburn=nburn)

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of omega:

plot(c(1:nburn),imp$collectomega[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='jomo1mix'>
JM Imputation of single level data with mixed variable types 
</h2><span id='topic+jomo1mix'></span>

<h3>Description</h3>

<p>Impute a single level dataset with mixed data types as outcome. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler where the covariance matrix is updated  with a Metropolis-Hastings step. Fully observed categorical variables may be considered as covariates as well, but they have to be included as dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1mix(Y.con, Y.cat, Y.numcat, X=NULL, beta.start=NULL, l1cov.start=NULL, 
l1cov.prior=NULL, nburn=100, nbetween=100, nimp=5, output=1,out.iter=10)
 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1mix_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA. If no continuous outcomes are present in the model, jomo1cat should be used instead.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1mix_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regarding the choice of the priors, a flat prior is considered for beta and for the covariance matrix. A Metropolis Hastings step is implemented to update the covariance matrix, as described in the book. Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only. 
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 5, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Then, we define all the inputs:
# nburn is smaller than needed. This is
#just because of CRAN policies on the examples.

Y.con=sldata[,c("measure","age")]
Y.cat=sldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,300),sldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
beta.start&lt;-matrix(0,2,5)
l1cov.start&lt;-diag(1,5)
l1cov.prior=diag(1,5);
nburn=as.integer(100);
nbetween=as.integer(100);
nimp=as.integer(5);

#Then we run the sampler:

imp&lt;-jomo1mix(Y.con,Y.cat,Y.numcat,X,beta.start,l1cov.start,
      l1cov.prior,nburn,nbetween,nimp)

cat("Original value was missing(",imp[1,1],"), imputed value:", imp[301,1])

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules


</code></pre>

<hr>
<h2 id='jomo1mix.MCMCchain'>
JM Imputation of single level data with mixed variable types 
</h2><span id='topic+jomo1mix.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1mix, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1mix.MCMCchain(Y.con, Y.cat, Y.numcat, X=NULL, beta.start=NULL, 
l1cov.start=NULL, l1cov.prior=NULL, start.imp=NULL, nburn=100, 
output=1, out.iter=10) 
 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1mix.MCMCchain_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA. If no continuous outcomes are present in the model, jomo1cat should be used instead.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 100.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1mix.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four elements is returned: the final imputed dataset (finimp) and three 3-dimensional matrices, containing all the values for beta (collectbeta) and omega (collectomega). Finally, in finimp.latnorm it is stored the final state of the imputed dataset with the latent normals in place of the categorical variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Then, we define all the inputs:
# nburn is smaller than needed. This is
#just because of CRAN policies on the examples.

Y.con=sldata[,c("measure","age")]
Y.cat=sldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,300),sldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
beta.start&lt;-matrix(0,2,5)
l1cov.start&lt;-diag(1,5)
l1cov.prior=diag(1,5);
nburn=as.integer(100);


#Then we run the sampler:

imp&lt;-jomo1mix.MCMCchain(Y.con,Y.cat,Y.numcat,X,beta.start,l1cov.start,l1cov.prior,nburn=nburn)

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of omega:

plot(c(1:nburn),imp$collectomega[1,1,1:nburn],type="l")


</code></pre>

<hr>
<h2 id='jomo1ran'>
JM Imputation of clustered data
</h2><span id='topic+jomo1ran'></span>

<h3>Description</h3>

<p>A wrapper function linking the six 2-level JM Imputation functions. The matrix of responses Y, must be a data.frame where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1ran(Y, X=NULL, Z=NULL,clus, 
      beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, 
      l1cov.prior=NULL, l2cov.prior=NULL, nburn=1000, nbetween=1000, nimp=5, 
      a=NULL, a.prior=NULL, meth="common", output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1ran_+3A_y">Y</code></td>
<td>

<p>A data.frame containing the outcomes of the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is the starting value for a.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1ran_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a wrapper function to link jomo1rancon, jomo1rancat and jomo1ranmix and the respective &quot;hr&quot; (heterogeneity in covariance matrices) versions. Format of the columns of Y is crucial in order for the function to be using the right sub-function. </p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# define all the inputs:
  
Y&lt;-cldata[,c("measure","age")]
clus&lt;-cldata[,c("city")]
nburn=as.integer(200);
nbetween=as.integer(200);
nimp=as.integer(5);


#And finally we run the imputation function:
imp&lt;-jomo1ran(Y,clus=clus,nburn=nburn,nbetween=nbetween,nimp=nimp)

#we could even run it with fixed or random cluster-specific covariance matrices:

#imp&lt;-jomo1ran(Y,clus=clus,nburn=nburn,nbetween=nbetween,nimp=nimp, meth="fixed")
#or:
#imp&lt;-jomo1ran(Y,clus=clus,nburn=nburn,nbetween=nbetween,nimp=nimp, meth="random")

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules


</code></pre>

<hr>
<h2 id='jomo1ran.MCMCchain'>
JM Imputation of clustered data - A tool to check convergence of the MCMC
</h2><span id='topic+jomo1ran.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1ran, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1ran.MCMCchain(Y, X=NULL, Z=NULL,clus, beta.start=NULL, u.start=NULL, 
l1cov.start=NULL,l2cov.start=NULL, l1cov.prior=NULL, l2cov.prior=NULL, 
start.imp=NULL, nburn=1000, a=NULL,a.prior=NULL, meth="common", output=1, 
out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1ran.MCMCchain_+3A_y">Y</code></td>
<td>

<p>A data.frame containing the outcomes of the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is the starting value for a.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (functions jomo1rancon, jomo1rancat and jomo1ranmix). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with coption meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo1ranconhr, jomo1rancathr and jomo1ranmixhr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1ran.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with six elements is returned: the final imputed dataset (finimp) and four 3-dimensional matrices, containing all the values for beta (collectbeta), the random effects (collectu) and the level 1 (collectomega) and level 2 covariance matrices (collectcovu). Finally, for cases where categorical variabels are present, the final state of the imputed dataset with the latent normals in place of the categorical variables is stored in finimp.latnorm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # define all the inputs:
  
  Y&lt;-cldata[,c("measure","age")]
  clus&lt;-cldata[,c("city")]
nburn=as.integer(200);

#And finally we run the imputation function:
imp&lt;-jomo1ran.MCMCchain(Y,clus=clus,nburn=nburn)
#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of the level 2 covariance matrix:

plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='jomo1rancat'>
JM Imputation of clustered data with categorical variables
</h2><span id='topic+jomo1rancat'></span>

<h3>Description</h3>

<p>Impute a clustered dataset with categorical variables as outcome. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler where the covariance matrix is updated with a Metropolis-Hastings step. Fully observed categorical covariates may be considered as covariates as well, but they have to be included as dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1rancat( Y.cat, Y.numcat, X=NULL, Z=NULL, clus, beta.start=NULL, 
u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL, 
l2cov.prior=NULL, nburn=1000, nbetween=1000, nimp=5, output=1, out.iter=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1rancat_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1rancat_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gibbs sampler algorithm used is described in detail in Chapter 9 of Carpenter and Kenward (2013). Regarding the choice of the priors, a flat prior is considered for beta and for the covariance matrix. A Metropolis Hastings step is implemented to update the covariance matrix, as described in the book. Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only.
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#we define all the inputs:
# nimp, nburn and nbetween are smaller than they should. This is
#just because of CRAN policies on the examples.

Y.cat=cldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
clus&lt;-cldata[,c("city")]
beta.start&lt;-matrix(0,2,3)
u.start&lt;-matrix(0,10,3)
l1cov.start&lt;-diag(1,3)
l2cov.start&lt;-diag(1,3)
l1cov.prior=diag(1,3);
l2cov.prior=diag(1,3);
nburn=as.integer(100);
nbetween=as.integer(100);
nimp=as.integer(4);

#And finally we run the imputation function:

imp&lt;-jomo1rancat(Y.cat, Y.numcat, X,Z,clus,beta.start,u.start,l1cov.start, 
               l2cov.start,l1cov.prior,l2cov.prior,nburn,nbetween,nimp)

 cat("Original value was missing (",imp[3,1],"), imputed value:", imp[1003,1])
 
  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules
             

</code></pre>

<hr>
<h2 id='jomo1rancat.MCMCchain'>
JM Imputation of clustered data with categorical variables - 
A tool to check convergence of the MCMC
</h2><span id='topic+jomo1rancat.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1rancat, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1rancat.MCMCchain(Y.cat, Y.numcat, X=NULL, Z=NULL,clus, beta.start=NULL, 
u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL, 
l2cov.prior=NULL, start.imp=NULL,nburn=1000, output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1rancat.MCMCchain_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1rancat.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with six elements is returned: the final imputed dataset (finimp) and four 3-dimensional matrices, containing all the values for beta (collectbeta), the random effects (collectu) and the level 1 (collectomega) and level 2 covariance matrices (collectcovu). Finally, the final state of the imputed dataset with the latent normals in place of the categorical variables is stored in finimp.latnorm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define all the inputs:
# nburn  smaller than needed. This is
#just because of CRAN policies on the examples.

Y.cat=cldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
clus&lt;-cldata[,c("city")]
beta.start&lt;-matrix(0,2,3)
u.start&lt;-matrix(0,10,3)
l1cov.start&lt;-diag(1,3)
l2cov.start&lt;-diag(1,3)
l1cov.prior=diag(1,3);
l2cov.prior=diag(1,3);
nburn=as.integer(100);

#And finally we run the imputation function:

imp&lt;-jomo1rancat.MCMCchain(Y.cat, Y.numcat, X,Z,clus,beta.start,u.start,l1cov.start, 
l2cov.start,l1cov.prior,l2cov.prior,nburn=nburn)
#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of the level 2 covariance matrix:

plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='jomo1rancathr'>
JM Imputation of clustered data with categorical variables with cluster-specific covariance matrices
</h2><span id='topic+jomo1rancathr'></span>

<h3>Description</h3>

<p>Impute a clustered dataset with categorical variables as outcome. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler where a different covariance matrix is sampled within each cluster. Fully observed categorical covariates may be considered as covariates as well, but they have to be included as dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1rancathr( Y.cat, Y.numcat, X=NULL, Z=NULL, clus, beta.start=NULL, 
u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL, 
l2cov.prior=NULL, nburn=1000, nbetween=1000, nimp=5, a=NULL,
a.prior=NULL, meth="random", output=1, out.iter=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1rancathr_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrices, stacked one above the other. Dimension of each square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix for each cluster.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrices. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_meth">meth</code></td>
<td>

<p>When set to &quot;fixed&quot;, a flat prior is put on the study-specific covariance matrices and each matrix is updated separately with a different MH-step.
When set to &quot;random&quot;, we are assuming that all the covariance matrices are draws from an inverse-Wishart distribution, whose parameter values are updated with 2 steps similar to the ones presented in the case of continuous data only for function jomo1ranconhr.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gibbs sampler algorithm used is obtained is a mixture of the ones described in chapter 5 and 9 of Carpenter and Kenward (2013). We update the covariance matrices element-wise with a Metropolis-Hastings step. When meth=&quot;fixed&quot;, we use a flat prior for rhe matrices, while with meth=&quot;random&quot; we use an inverse-Wishar tprior and we assume that all the covariance matrices are drawn from an inverse Wishart distribution. We update values of a and A, degrees of freedom and scale matrix of the inverse Wishart distribution from which all the covariance matrices are sampled, from the proper conditional distributions. A flat prior is considered for beta.   Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only. 
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>
<p>Yucel R.M., (2011), Random-covariances and mixed-effects models for imputing multivariate multilevel continuous data, Statistical Modelling, 11 (4), 351-370, DOI: 10.1177/1471082X100110040.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# we define the inputs
# nimp, nburn and nbetween are smaller than they should. This is
#just because of CRAN policies on the examples.

Y.cat=cldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
clus&lt;-cldata[,c("city")]
beta.start&lt;-matrix(0,2,3)
u.start&lt;-matrix(0,10,3)
l1cov.start&lt;-matrix(diag(1,3),30,3,2)
l2cov.start&lt;-diag(1,3)
l1cov.prior=diag(1,3);
l2cov.prior=diag(1,3);
a=5
nburn=as.integer(100);
nbetween=as.integer(100);
nimp=as.integer(4);

#Finally we run either the model with fixed or random cluster-specific cov. matrices:

imp&lt;-jomo1rancathr(Y.cat, Y.numcat, X,Z,clus,beta.start,u.start,l1cov.start, 
      l2cov.start,l1cov.prior,l2cov.prior,nburn,nbetween,nimp, a, meth="fixed")
      
cat("Original value was missing (",imp[3,1],"), imputed value:", imp[1003,1])

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules


</code></pre>

<hr>
<h2 id='jomo1rancathr.MCMCchain'>
JM Imputation of clustered data with categorical variables with cluster-specific covariance matrices -
A tool to check convergence of the MCMC
</h2><span id='topic+jomo1rancathr.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1rancathr, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1rancathr.MCMCchain(Y.cat, Y.numcat, X=NULL, Z=NULL, clus, beta.start=NULL, 
u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL, 
l2cov.prior=NULL, start.imp=NULL, nburn=1000, a=NULL, a.prior=NULL, meth="random", 
output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrices, stacked one above the other. Dimension of each square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix for each cluster. 
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrices. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>When set to &quot;fixed&quot;, a flat prior is put on the study-specific covariance matrices and each matrix is updated separately with a different MH-step.
When set to &quot;random&quot;, we are assuming that all the covariance matrices are draws from an inverse-Wishart distribution, whose parameter values are updated with 2 steps similar to the ones presented in the case of continuous data only for function jomo1ranconhr.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1rancathr.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with six elements is returned: the final imputed dataset (finimp) and four 3-dimensional matrices, containing all the values for beta (collectbeta), the random effects (collectu) and the level 1 (collectomega) and level 2 covariance matrices (collectcovu). Finally, the final state of the imputed dataset with the latent normals in place of the categorical variables is stored in finimp.latnorm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#we define the inputs
#  nburn is smaller than needed. This is
#just because of CRAN policies on the examples.

Y.cat=cldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
clus&lt;-cldata[,c("city")]
beta.start&lt;-matrix(0,2,3)
u.start&lt;-matrix(0,10,3)
l1cov.start&lt;-matrix(diag(1,3),30,3,2)
l2cov.start&lt;-diag(1,3)
l1cov.prior=diag(1,3);
l2cov.prior=diag(1,3);
a=5
nburn=as.integer(100);

#Finally we run either the model with fixed or random cluster-specific covariance matrices:

imp&lt;-jomo1rancathr.MCMCchain(Y.cat, Y.numcat, X,Z,clus,beta.start,
          u.start,l1cov.start, l2cov.start,l1cov.prior,l2cov.prior,nburn=nburn, a=a, meth="fixed")

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of th elevel 2 covariance matrix:

plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='jomo1rancon'>
JM Imputation of clustered data with continuous variables only
</h2><span id='topic+jomo1rancon'></span>

<h3>Description</h3>

<p>Impute a clustered dataset with continuous outcomes only. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler. Categorical covariates may be considered, but they have to be included with dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1rancon(Y, X=NULL, Z=NULL, clus, beta.start=NULL,u.start=NULL, 
l1cov.start=NULL,l2cov.start=NULL, l1cov.prior=NULL, l2cov.prior=NULL,
nburn=1000, nbetween=1000, nimp=5, output=1, out.iter=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1rancon_+3A_y">Y</code></td>
<td>

<p>A data frame, or matrix, with responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1rancon_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gibbs sampler algorithm used is a simplification of the one described in detail in Chapter 9 of Carpenter and Kenward (2013), where we exclude the presence of level 2 variables. Regarding the choice of the priors, a flat prior is considered for beta, while an inverse-Wishart prior is given to the covariance matrices, with p-1 degrees of freedom, aka the minimum possible, to guarantee the greatest uncertainty. Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only. 
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# we define all the inputs:
Y&lt;-cldata[,c("measure","age")]
clus&lt;-cldata[,c("city")]
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
beta.start&lt;-matrix(0,2,2)
u.start&lt;-matrix(0,10,2)
l1cov.start&lt;-diag(1,2)
l2cov.start&lt;-diag(1,2)
l1cov.prior=diag(1,2);
nburn=as.integer(200);
nbetween=as.integer(200);
nimp=as.integer(5);
l2cov.prior=diag(1,5);

#And finally we run the imputation function:
imp&lt;-jomo1rancon(Y,X,Z,clus,beta.start,u.start,l1cov.start, l2cov.start,l1cov.prior,
             l2cov.prior,nburn,nbetween,nimp)

cat("Original value was missing(",imp[4,1],"), imputed value:", imp[1004,1])

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules

</code></pre>

<hr>
<h2 id='jomo1rancon.MCMCchain'>
JM Imputation of clustered data with continuous variables only -
A tool to check convergence of the MCMC
</h2><span id='topic+jomo1rancon.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1rancon, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1rancon.MCMCchain(Y, X=NULL, Z=NULL, clus, beta.start=NULL, 
u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL, 
l2cov.prior=NULL, start.imp=NULL, nburn=1000, output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1rancon.MCMCchain_+3A_y">Y</code></td>
<td>

<p>A data frame, or matrix, with responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. 
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1rancon.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with five elements is returned: the final imputed dataset (finimp) and four 3-dimensional matrices, containing all the values for beta (collectbeta), the random effects (collectu) and the level 1 (collectomega) and level 2 covariance matrices (collectcovu).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define all the inputs:
  
Y&lt;-cldata[,c("measure","age")]
clus&lt;-cldata[,c("city")]
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
beta.start&lt;-matrix(0,2,2)
u.start&lt;-matrix(0,10,2)
l1cov.start&lt;-diag(1,2)
l2cov.start&lt;-diag(1,2)
l1cov.prior=diag(1,2);
nburn=as.integer(200);

l2cov.prior=diag(1,5);

#And finally we run the imputation function:
imp&lt;-jomo1rancon.MCMCchain(Y,X,Z,clus,beta.start,u.start,l1cov.start, 
          l2cov.start,l1cov.prior,l2cov.prior,nburn=nburn)

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of the level 2 covariance matrix:

plot(c(1:nburn),imp$collectcovu[1,1,1:nburn],type="l")

</code></pre>

<hr>
<h2 id='jomo1ranconhr'>
JM Imputation of clustered data with continuous variables only with cluster-specific covariance matrices
</h2><span id='topic+jomo1ranconhr'></span>

<h3>Description</h3>

<p>Impute a clustered dataset with continuous outcomes only. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler. A different covariance matrix is estimated within each cluster. Categorical covariates may be considered, but they have to be included with dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1ranconhr(Y, X=NULL, Z=NULL, clus, beta.start=NULL, u.start=NULL,
l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL, l2cov.prior=NULL, 
nburn=1000, nbetween=1000, nimp=5, a=(ncol(Y)+50),a.prior=NULL, 
meth="random", output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1ranconhr_+3A_y">Y</code></td>
<td>

<p>A data frame, or matrix, with responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrices, stacked one above the other. Dimension of each square matrix is equal to the number of outcomes in the imputation model. The default is the identity matrix for each cluster.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrices. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_meth">meth</code></td>
<td>

<p>This can be set to &quot;Fixed&quot; or &quot;Random&quot;. In the first case the function will consider fixed study-specific covariance matrices, in the second, random study-specific distributed according to an inverse-Wishart distribution.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gibbs sampler algorithm used is similar to the one described in detail in Chapter 9 of Carpenter and Kenward (2013), where we exclude the presence of level 2 variables and we estimate separetely different covariance matrices within each study. When option meth=&quot;random&quot; is specified, all the covariance matrices ae assumed to be random draws from the same underlying inverse Wishart distributions. Details of this algorithm may be found in (Yucel, 2011). Regarding the choice of the priors, a flat prior is considered for beta, while an inverse-Wishart prior is given to the covariance matrices, with p-1 degrees of freedom, aka the minimum possible, to guarantee the greatest uncertainty. Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only. 
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>
<p>Yucel R.M., (2011), Random-covariances and mixed-effects models for imputing multivariate multilevel continuous data, Statistical Modelling, 11 (4), 351-370, DOI: 10.1177/1471082X100110040.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# we define the inputs
# nimp, nburn and nbetween are smaller than they should. This is
#just because of CRAN policies on the examples.

Y&lt;-cldata[,c("measure","age")]
clus&lt;-cldata[,c("city")]
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
beta.start&lt;-matrix(0,2,2)
u.start&lt;-matrix(0,10,2)
l1cov.start&lt;-matrix(diag(1,2),20,2,2)
l2cov.start&lt;-diag(1,2)
l1cov.prior=diag(1,2);
nburn=as.integer(50);
nbetween=as.integer(20);
nimp=as.integer(5);
l2cov.prior=diag(1,5);
a=3

# Finally we run either the model with fixed or random cluster-specific covariance matrices:

imp&lt;-jomo1ranconhr(Y,X,Z,clus,beta.start,u.start,l1cov.start, l2cov.start,
         l1cov.prior,l2cov.prior,nburn,nbetween,nimp,meth="fixed")

cat("Original value was missing(",imp[4,1],"), imputed value:", imp[1004,1])

#or:

#imp&lt;-jomo1ranconhr(Y,X,Z,clus,beta.start,u.start,l1cov.start, l2cov.start,
#        l1cov.prior,l2cov.prior,nburn,nbetween,nimp,a,meth="random")

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules


</code></pre>

<hr>
<h2 id='jomo1ranconhr.MCMCchain'>
JM Imputation of clustered data with continuous variables only with cluster-specific covariance matrices -
A tool to check convergence of the MCMC
</h2><span id='topic+jomo1ranconhr.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1ranconhr, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1ranconhr.MCMCchain(Y, X=NULL, Z=NULL, clus, 
beta.start=NULL, u.start=NULL, l1cov.start=NULL, 
l2cov.start=NULL, l1cov.prior=NULL, l2cov.prior=NULL,start.imp=NULL,  
nburn=1000, a=(ncol(Y)+50),a.prior=NULL, meth="random", output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_y">Y</code></td>
<td>

<p>A data frame, or matrix, with responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>
<p> in column. Dimension of each square matrix is equal to the number of outcomes in the imputation model. The default is the identity matrix for each cluster.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrices. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. 
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>This can be set to &quot;Fixed&quot; or &quot;Random&quot;. In the first case the function will consider fixed study-specific covariance matrices, in the second, random study-specific distributed according to an inverse-Wishart distribution.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1ranconhr.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with five elements is returned: the final imputed dataset (finimp) and four 3-dimensional matrices, containing all the values for beta (collectbeta), the random effects (collectu) and the level 1 (collectomega) and level 2 covariance matrices (collectcovu).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# we define the inputs
# nburn is smaller than needed. This is
#just because of CRAN policies on the examples.

Y&lt;-cldata[,c("measure","age")]
clus&lt;-cldata[,c("city")]
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
nburn=as.integer(200);
a=3

# Finally we run either the model with fixed or random cluster-specific cov. matrices:

imp&lt;-jomo1ranconhr.MCMCchain(Y,X,Z,clus,nburn=nburn,meth="random")
          
#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of the level 2 cov. matrix:

plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='jomo1ranmix'>
JM Imputation of clustered data with mixed variable types
</h2><span id='topic+jomo1ranmix'></span>

<h3>Description</h3>

<p>Impute a clustered dataset with mixed data types as outcome. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler where the covariance matrix is updated with a Metropolis-Hastings step. Fully observed categorical covariates may be considered as covariates as well, but they have to be included as dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1ranmix(Y.con, Y.cat, Y.numcat, X=NULL, Z=NULL, clus, 
beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, 
l1cov.prior=NULL, l2cov.prior=NULL, nburn=1000, nbetween=1000, nimp=5, 
output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1ranmix_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA. 
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Categories must be integer numbers from 1 to N. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TThe Gibbs sampler algorithm used is described in detail in Chapter 9 of Carpenter and Kenward (2013). Regarding the choice of the priors, a flat prior is considered for beta and for the covariance matrix. A Metropolis Hastings step is implemented to update the covariance matrix, as described in the book. Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only.
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# we define the inputs:
# nimp, nburn and nbetween are smaller than they should. This is
#just because of CRAN policies on the examples.

Y.con=cldata[,c("measure","age")]
Y.cat=cldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
clus&lt;-cldata[,c("city")]
beta.start&lt;-matrix(0,2,5)
u.start&lt;-matrix(0,10,5)
l1cov.start&lt;-diag(1,5)
l2cov.start&lt;-diag(1,5)
l1cov.prior=diag(1,5);
l2cov.prior=diag(1,5);
nburn=as.integer(50);
nbetween=as.integer(50);
nimp=as.integer(5);

#Then we can run the sampler:

imp&lt;-jomo1ranmix(Y.con, Y.cat, Y.numcat, X,Z,clus,beta.start,u.start,l1cov.start, 
          l2cov.start,l1cov.prior,l2cov.prior,nburn,nbetween,nimp)

cat("Original value was missing (",imp[4,1],"), imputed value:", imp[1004,1])

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules


</code></pre>

<hr>
<h2 id='jomo1ranmix.MCMCchain'>
JM Imputation of clustered data with mixed variable types -
A tool to check convergence of the MCMC
</h2><span id='topic+jomo1ranmix.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1ranmix, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1ranmix.MCMCchain(Y.con, Y.cat, Y.numcat, X=NULL, Z=NULL, clus, 
beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, 
l1cov.prior=NULL, l2cov.prior=NULL, start.imp=NULL, nburn=1000, 
output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. If no continuous outcomes are present in the model, jomo1rancat must be used instead.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Categories must be integer numbers from 1 to N. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1ranmix.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with six elements is returned: the final imputed dataset (finimp) and four 3-dimensional matrices, containing all the values for beta (collectbeta), the random effects (collectu) and the level 1 (collectomega) and level 2 covariance matrices (collectcovu). Finally, the final state of the imputed dataset with the latent normals in place of the categorical variables is stored in finimp.latnorm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#we define the inputs:
#  nburn is smaller than necessary. This is
#just because of CRAN policies on the examples.

Y.con=cldata[,c("measure","age")]
Y.cat=cldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
clus&lt;-cldata[,c("city")]
beta.start&lt;-matrix(0,2,5)
u.start&lt;-matrix(0,10,5)
l1cov.start&lt;-diag(1,5)
l2cov.start&lt;-diag(1,5)
l1cov.prior=diag(1,5);
l2cov.prior=diag(1,5);
nburn=as.integer(100);

#Then we can run the sampler:

imp&lt;-jomo1ranmix.MCMCchain(Y.con, Y.cat, Y.numcat, X,Z,clus,beta.start,u.start,
             l1cov.start, l2cov.start,l1cov.prior,l2cov.prior,nburn=nburn)

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of the level 2 covariance matrix:

plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='jomo1ranmixhr'>
JM Imputation of clustered data with mixed variable types with cluster-specific covariance matrices
</h2><span id='topic+jomo1ranmixhr'></span>

<h3>Description</h3>

<p>Impute a clustered dataset with mixed data types as outcome. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler where a different covariance matrix is sampled within each cluster. Fully observed categorical covariates may be considered as covariates as well, but they have to be included as dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1ranmixhr(Y.con, Y.cat, Y.numcat, X=NULL, Z=NULL, clus,
beta.start=NULL, u.start=NULL, l1cov.start=NULL,l2cov.start=NULL, 
l1cov.prior=NULL, l2cov.prior=NULL, nburn=1000, nbetween=1000,nimp=5,
a=NULL,a.prior=NULL,meth="random", output=1, out.iter=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1ranmixhr_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA. If no continuous outcomes are present in the model, jomo1rancathr must be used instead.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrices, stacked one above the other. Dimension of each square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix for each cluster.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrices. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_meth">meth</code></td>
<td>

<p>When set to &quot;fixed&quot;, a flat prior is put on the study-specific covariance matrices and each matrix is updated separately with a different MH-step.
When set to &quot;random&quot;, we are assuming that all the covariance matrices are draws from an inverse-Wishart distribution, whose parameter values are updated with 2 steps similar to the ones presented in the case of continuous data only for function jomo1ranconhr.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gibbs sampler algorithm used is obtained is a mixture of the ones described in chapter 5 and 9 of Carpenter and Kenward (2013). We update the covariance matrices element-wise with a Metropolis-Hastings step. When meth=&quot;fixed&quot;, we use a flat prior for rhe matrices, while with meth=&quot;random&quot; we use an inverse-Wishar tprior and we assume that all the covariance matrices are drawn from an inverse Wishart distribution. We update values of a and A, degrees of freedom and scale matrix of the inverse Wishart distribution from which all the covariance matrices are sampled, from the proper conditional distributions. A flat prior is considered for beta.   Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only.
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>
<p>Yucel R.M., (2011), Random-covariances and mixed-effects models for imputing multivariate multilevel continuous data, Statistical Modelling, 11 (4), 351-370, DOI: 10.1177/1471082X100110040.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


#we define all the inputs:
# nimp, nburn and nbetween are smaller than they should. This is
#just because of CRAN policies on the examples.

Y.con=cldata[,c("measure","age")]
Y.cat=cldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
clus&lt;-cldata[,c("city")]
beta.start&lt;-matrix(0,2,5)
u.start&lt;-matrix(0,10,5)
l1cov.start&lt;-matrix(diag(1,5),50,5,2)
l2cov.start&lt;-diag(1,5)
l1cov.prior=diag(1,5);
l2cov.prior=diag(1,5);
nburn=as.integer(50);
nbetween=as.integer(50);
nimp=as.integer(5);
a=6

# And we are finally able to run the imputation:

imp&lt;-jomo1ranmixhr(Y.con, Y.cat, Y.numcat, X,Z,clus,beta.start,u.start,l1cov.start, 
        l2cov.start,l1cov.prior,l2cov.prior,nburn,nbetween,nimp, a, meth="random")

cat("Original value was missing (",imp[4,1],"), imputed value:", imp[1004,1])

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules


</code></pre>

<hr>
<h2 id='jomo1ranmixhr.MCMCchain'>
JM Imputation of clustered data with mixed variable types with cluster-specific covariance matrices -
A tool to check convergence of the MCMC
</h2><span id='topic+jomo1ranmixhr.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo1ranmixhr, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo1ranmixhr.MCMCchain(Y.con, Y.cat, Y.numcat, X=NULL, Z=NULL, clus, 
beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, 
l1cov.prior=NULL, l2cov.prior=NULL, start.imp=NULL,
nburn=1000, a=NULL,a.prior=NULL,meth="random", output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA. If no continuous outcomes are present in the model, jomo1rancathr must be used instead.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we define n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrices, stacked one above the other. Dimension of each square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix for each cluster.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrices. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>When set to &quot;fixed&quot;, a flat prior is used for the study-specific covariance matrices and each matrix is updated separately with a different MH-step.
When set to &quot;random&quot;, we are assuming that all the covariance matrices are draws from an inverse-Wishart distribution, whose parameter values are updated with 2 steps similar to the ones presented in the case of continuous data only for function jomo1ranconhr.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo1ranmixhr.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with six elements is returned: the final imputed dataset (finimp) and four 3-dimensional matrices, containing all the values for beta (collectbeta), the random effects (collectu) and the level 1 (collectomega) and level 2 covariance matrices (collectcovu). Finally, the final state of the imputed dataset with the latent normals in place of the categorical variables is stored in finimp.latnorm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# we define all the inputs:
# nburn is smaller than needed. This is
#just because of CRAN policies on the examples.

Y.con=cldata[,c("measure","age")]
Y.cat=cldata[,c("social"), drop=FALSE]
Y.numcat=matrix(4,1,1)
X=data.frame(rep(1,1000),cldata[,c("sex")])
colnames(X)&lt;-c("const", "sex")
Z&lt;-data.frame(rep(1,1000))
clus&lt;-cldata[,c("city")]
beta.start&lt;-matrix(0,2,5)
u.start&lt;-matrix(0,10,5)
l1cov.start&lt;-matrix(diag(1,5),50,5,2)
l2cov.start&lt;-diag(1,5)
l1cov.prior=diag(1,5);
l2cov.prior=diag(1,5);
nburn=as.integer(80);

a=6

# And we are finally able to run the imputation:

imp&lt;-jomo1ranmixhr.MCMCchain(Y.con, Y.cat, Y.numcat, X,Z,clus,beta.start,u.start,
    l1cov.start, l2cov.start,l1cov.prior,l2cov.prior,nburn=nburn, a=a)
    
#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of the level 2 covariance matrix:

plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='jomo2'>
JM Imputation of 2-level data
</h2><span id='topic+jomo2'></span>

<h3>Description</h3>

<p>A wrapper function linking the 2-level JM Imputation functions. The matrices of responses Y and Y2, must be data.frames where continuous variables are numeric and binary/categorical variables are factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo2(Y, Y2, X=NULL, X2=NULL, Z=NULL,clus, beta.start=NULL, l2.beta.start=NULL,
u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL, 
l2cov.prior=NULL, nburn=1000, nbetween=1000, nimp=5, a=NULL, a.prior=NULL,
meth="common", output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo2_+3A_y">Y</code></td>
<td>

<p>A data.frame with the level-1 outcomes of the imputation model, where columns related to continuous variables are numeric and columns related to binary/categorical variables are factors. 
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_y2">Y2</code></td>
<td>

<p>A data.frame containing the level-2 outcomes of the imputation model, i.e. the partially observed level-2 variables. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_x2">X2</code></td>
<td>

<p>A data frame, or matrix, with level-2 covariates of the joint imputation model. Rows correspond to different level-1 observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects. Rows index different covariates and columns index different level-2 outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects plus the number of level-2 outcomes. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (function jomo2com). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo2hr with option meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo2hr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo2_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a wrapper function to link jomo1rancon, jomo1rancat and jomo1ranmix and the respective &quot;hr&quot; (heterogeneity in covariance matrices) versions. Format of the columns of Y is crucial in order for the function to be using the right sub-function. </p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Y&lt;-tldata[,c("measure.a"), drop=FALSE]
Y2&lt;-tldata[,c("big.city"), drop=FALSE]
clus&lt;-tldata[,c("city")]
nburn=10
nbetween=10
nimp=2

#now we run the imputation function. Note that we would typically use an higher 
#number of nburn iterations in real applications (at least 1000)

imp&lt;-jomo2(Y=Y, Y2=Y2, clus=clus,nburn=nburn, nbetween=nbetween, nimp=nimp)

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules


</code></pre>

<hr>
<h2 id='jomo2.MCMCchain'>
JM Imputation of 2-level data - A tool to check convergence of the MCMC
</h2><span id='topic+jomo2.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo2, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo2.MCMCchain(Y, Y2, X=NULL, X2=NULL, Z=NULL, clus, beta.start=NULL, 
l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL,l2cov.start=NULL, 
l1cov.prior=NULL, l2cov.prior=NULL, start.imp=NULL, l2.start.imp=NULL,
nburn=1000, a=NULL, a.prior=NULL, meth="common", output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo2.MCMCchain_+3A_y">Y</code></td>
<td>

<p>A data.frame with level-1 outcomes of the imputation model, where columns related to continuous variables are numeric and columns related to binary/categorical variables are factors. 
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_y2">Y2</code></td>
<td>

<p>A data.frame containing the level-2 outcomes of the imputation model. Columns related to continuous variables have to be numeric and columns related to binary/categorical variables have to be factors. 
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_x2">X2</code></td>
<td>

<p>A data frame, or matrix, with level-2 covariates of the joint imputation model. Rows correspond to different level-1 observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects. Rows index different covariates and columns index different level-2 outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects plus the number of level-2 outcomes. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_l2.start.imp">l2.start.imp</code></td>
<td>

<p>Starting value for the level-2 imputed variables. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices. This is used only when option meth is set to &quot;random&quot;.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>Method used to deal with level 1 covariance matrix. When set to &quot;common&quot;, a common matrix across clusters is used (function jomo2com). When set to &quot;fixed&quot;, fixed study-specific matrices are considered (jomo2hr with option meth=&quot;fixed&quot;). Finally, when set to &quot;random&quot;, random study-specific matrices are considered (jomo2hr with option meth=&quot;random&quot;)
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo2.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are, potentially, fixed effect parameters beta (collectbeta), random effects (collectu), level 1 (collectomega) and level 2 covariance matrices (collectcovu) and level-2 fixed effect parameters. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Y&lt;-tldata[,c("measure.a"), drop=FALSE]
Y2&lt;-tldata[,c("big.city"), drop=FALSE]
clus&lt;-tldata[,c("city")]
nburn=20

#now we run the imputation function. Note that we would typically use an higher 
#number of nburn iterations in real applications (at least 100)

imp&lt;-jomo2.MCMCchain(Y=Y, Y2=Y2, clus=clus,nburn=nburn)

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of the level 2 covariance matrix:

plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='jomo2com'>
JM Imputation of 2-level data assuming a common level-1 covariance matrix across level-2 units.
</h2><span id='topic+jomo2com'></span>

<h3>Description</h3>

<p>Impute a 2-level dataset with mixed data types as outcome. A joint multivariate model for partially observed data is assumed and imputations are generated through the use of a Gibbs sampler where the covariance matrix is updated with a Metropolis-Hastings step. Fully observed categorical covariates may be considered as covariates as well, but they have to be included as dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo2com(Y.con=NULL, Y.cat=NULL, Y.numcat=NULL, Y2.con=NULL, Y2.cat=NULL,
Y2.numcat=NULL,X=NULL, X2=NULL, Z=NULL, clus, beta.start=NULL, l2.beta.start=NULL, 
u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, l1cov.prior=NULL, 
l2cov.prior=NULL, nburn=1000, nbetween=1000, nimp=5, output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo2com_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with level-1 continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. 
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_y2.con">Y2.con</code></td>
<td>

<p>A data frame, or matrix, with level-2 continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. 
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_y2.cat">Y2.cat</code></td>
<td>

<p>A data frame, or matrix, with level-2 categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_y2.numcat">Y2.numcat</code></td>
<td>

<p>A vector with the number of categories in each level-2 categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_x2">X2</code></td>
<td>

<p>A data frame, or matrix, with level-2 covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects. Rows index different covariates and columns index different level-2 outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects plus the number of level-2 outcomes. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo2com_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TThe Gibbs sampler algorithm used is described in detail in Chapter 9 of Carpenter and Kenward (2013). Regarding the choice of the priors, a flat prior is considered for beta and for the covariance matrix. A Metropolis Hastings step is implemented to update the covariance matrix, as described in the book. Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only.
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Y&lt;-tldata[,c("measure.a"), drop=FALSE]
Y2&lt;-tldata[,c("big.city"), drop=FALSE]
clus&lt;-tldata[,c("city")]

#now we run the imputation function. Note that we would typically use an higher 
#number of nburn iterations in real applications (at least 1000)

imp&lt;-jomo2com(Y.con=Y, Y2.cat=Y2, Y2.numcat=2, clus=clus,nburn=10, nbetween=10, nimp=2)
  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules

</code></pre>

<hr>
<h2 id='jomo2com.MCMCchain'>
JM Imputation of 2-level data assuming a common level-1 covariance matrix across level-2 units -
A tool to check convergence of the MCMC
</h2><span id='topic+jomo2com.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo2com, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo2com.MCMCchain(Y.con=NULL, Y.cat=NULL, Y.numcat=NULL, Y2.con=NULL, 
Y2.cat=NULL, Y2.numcat=NULL, X=NULL, X2=NULL, Z=NULL, clus, beta.start=NULL,
l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, 
l1cov.prior=NULL, l2cov.prior=NULL, start.imp=NULL, l2.start.imp=NULL, nburn=1000, 
output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo2com.MCMCchain_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with level-1 continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. 
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_y2.con">Y2.con</code></td>
<td>

<p>A data frame, or matrix, with level-2 continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. 
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_y2.cat">Y2.cat</code></td>
<td>

<p>A data frame, or matrix, with level-2 categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_y2.numcat">Y2.numcat</code></td>
<td>

<p>A vector with the number of categories in each level-2 categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_x2">X2</code></td>
<td>

<p>A data frame, or matrix, with level-2 covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects. Rows index different covariates and columns index different level-2 outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects plus the number of level-2 outcomes. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_l2.start.imp">l2.start.imp</code></td>
<td>

<p>Starting value for the level-2 imputed variables. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo2com.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are, potentially, fixed effect parameters beta (collectbeta), random effects (collectu), level 1 (collectomega) and level 2 covariance matrices (collectcovu) and level-2 fixed effect parameters. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Y&lt;-tldata[,c("measure.a"), drop=FALSE]
Y2&lt;-tldata[,c("big.city"), drop=FALSE]
clus&lt;-tldata[,c("city")]
nburn=20

#now we run the imputation function. Note that we would typically use an higher 
#number of nburn iterations in real applications (at least 100)

imp&lt;-jomo2com.MCMCchain(Y.con=Y, Y2.cat=Y2, Y2.numcat=2, clus=clus,nburn=nburn)

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of the level 2 covariance matrix:

plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")

</code></pre>

<hr>
<h2 id='jomo2hr'>
JM Imputation of 2-level data assuming cluster-specific level-1 covariance matrices across level-2 unit
</h2><span id='topic+jomo2hr'></span>

<h3>Description</h3>

<p>Impute a 2-level dataset with mixed data types as outcome. A joint multivariate normal model for partially observed data, with (either fixed or random) study-specific covariance matrices is assumed and imputations are generated through the use of a Gibbs sampler where a different covariance matrix is sampled within each cluster. Fully observed categorical covariates may be considered as covariates as well, but they have to be included as dummy variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo2hr(Y.con=NULL, Y.cat=NULL, Y.numcat=NULL, Y2.con=NULL, 
Y2.cat=NULL, Y2.numcat=NULL,X=NULL, X2=NULL, Z=NULL, clus, beta.start=NULL, 
l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, 
l1cov.prior=NULL, l2cov.prior=NULL, nburn=1000, nbetween=1000, nimp=5,
a=NULL, a.prior=NULL, meth="random", output=1, out.iter=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo2hr_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with level-1 continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. 
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_y2.con">Y2.con</code></td>
<td>

<p>A data frame, or matrix, with level-2 continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. 
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_y2.cat">Y2.cat</code></td>
<td>

<p>A data frame, or matrix, with level-2 categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_y2.numcat">Y2.numcat</code></td>
<td>

<p>A vector with the number of categories in each level-2 categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_x2">X2</code></td>
<td>

<p>A data frame, or matrix, with level-2 covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects. Rows index different covariates and columns index different level-2 outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrices, stacked one above the other. Dimension of each square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix for each cluster.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects plus the number of level-2 outcomes. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrices. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_nburn">nburn</code></td>
<td>

<p>Number of burn in iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_nbetween">nbetween</code></td>
<td>

<p>Number of iterations between two successive imputations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_nimp">nimp</code></td>
<td>

<p>Number of Imputations. Default is 5.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices..
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_meth">meth</code></td>
<td>

<p>When set to &quot;fixed&quot;, a flat prior is put on the cluster-specific covariance matrices and each matrix is updated separately with a different MH-step.
When set to &quot;random&quot;, we are assuming that all the cluster-specific level-1 covariance matrices are draws from an inverse-Wishart distribution, whose parameter values are updated with 2 steps similar to the ones presented in the case of clustered data for function jomo1ranconhr.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo2hr_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gibbs sampler algorithm used is obtained is a mixture of the ones described in chapter 5 and 9 of Carpenter and Kenward (2013). We update the covariance matrices element-wise with a Metropolis-Hastings step. When meth=&quot;fixed&quot;, we use a flat prior for rhe matrices, while with meth=&quot;random&quot; we use an inverse-Wishar tprior and we assume that all the covariance matrices are drawn from an inverse Wishart distribution. We update values of a and A, degrees of freedom and scale matrix of the inverse Wishart distribution from which all the covariance matrices are sampled, from the proper conditional distributions. A flat prior is considered for beta.   Binary or continuous covariates in the imputation model may be considered without any problem, but when considering a categorical covariate it has to be included with dummy variables (binary indicators) only.
</p>


<h3>Value</h3>

<p>On screen, the posterior mean of the fixed effects estimates and of the covariance matrix are shown. The only argument returned is the imputed dataset in long format. Column &quot;Imputation&quot; indexes the imputations. Imputation number 0 are the original data.
</p>


<h3>References</h3>

<p>Carpenter J.R., Kenward M.G., (2013), Multiple Imputation and its Application. Chapter 9, Wiley, ISBN: 978-0-470-74052-1.
</p>
<p>Yucel R.M., (2011), Random-covariances and mixed-effects models for imputing multivariate multilevel continuous data, Statistical Modelling, 11 (4), 351-370, DOI: 10.1177/1471082X100110040.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Y&lt;-tldata[,c("measure.a"), drop=FALSE]
Y2&lt;-tldata[,c("big.city"), drop=FALSE]
clus&lt;-tldata[,c("city")]

#now we run the imputation function. Note that we would typically use an higher 
#number of nburn iterations in real applications (at least 1000)

imp&lt;-jomo2hr(Y.con=Y, Y2.cat=Y2, Y2.numcat=2, clus=clus,nburn=10, nbetween=10, nimp=2)

  # Check help page for function jomo to see how to fit the model and 
  # combine estimates with Rubin's rules

</code></pre>

<hr>
<h2 id='jomo2hr.MCMCchain'>
JM Imputation of 2-level data assuming cluster-specific level-1 covariance matrices across level-2 units-
A tool to check convergence of the MCMC
</h2><span id='topic+jomo2hr.MCMCchain'></span>

<h3>Description</h3>

<p>This function is similar to jomo2hr, but it returns the values of all the parameters in the model at each step of the MCMC instead of the imputations. It is useful to check the convergence of the MCMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jomo2hr.MCMCchain(Y.con=NULL, Y.cat=NULL, Y.numcat=NULL, Y2.con=NULL, 
Y2.cat=NULL, Y2.numcat=NULL, X=NULL, X2=NULL, Z=NULL, clus, beta.start=NULL, 
l2.beta.start=NULL, u.start=NULL, l1cov.start=NULL, l2cov.start=NULL, 
l1cov.prior=NULL, l2cov.prior=NULL, start.imp=NULL, l2.start.imp=NULL,
nburn=1000, a=NULL,a.prior=NULL,meth="random", output=1, out.iter=10) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jomo2hr.MCMCchain_+3A_y.con">Y.con</code></td>
<td>

<p>A data frame, or matrix, with level-1 continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. 
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_y.cat">Y.cat</code></td>
<td>

<p>A data frame, or matrix, with categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_y.numcat">Y.numcat</code></td>
<td>

<p>A vector with the number of categories in each categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_y2.con">Y2.con</code></td>
<td>

<p>A data frame, or matrix, with level-2 continuous responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. 
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_y2.cat">Y2.cat</code></td>
<td>

<p>A data frame, or matrix, with level-2 categorical (or binary) responses of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are coded as NA.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_y2.numcat">Y2.numcat</code></td>
<td>

<p>A vector with the number of categories in each level-2 categorical (or binary) variable.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_x">X</code></td>
<td>

<p>A data frame, or matrix, with covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_x2">X2</code></td>
<td>

<p>A data frame, or matrix, with level-2 covariates of the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_z">Z</code></td>
<td>

<p>A data frame, or matrix, for covariates associated to random effects in the joint imputation model. Rows correspond to different observations, while columns are different variables. Missing values are not allowed in these variables. In case we want an intercept, a column of 1 is needed. The default is a column of 1.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_clus">clus</code></td>
<td>

<p>A data frame, or matrix, containing the cluster indicator for each observation. 
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_beta.start">beta.start</code></td>
<td>

<p>Starting value for beta, the vector(s) of level-1 fixed effects. Rows index different covariates and columns index different outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_l2.beta.start">l2.beta.start</code></td>
<td>

<p>Starting value for beta2, the vector(s) of level-2 fixed effects. Rows index different covariates and columns index different level-2 outcomes. For each n-category variable we have a fixed effect parameter for each of the n-1 latent normals. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_u.start">u.start</code></td>
<td>

<p>A matrix where different rows are the starting values within each cluster for the random effects estimates u. The default is a matrix of zeros.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_l1cov.start">l1cov.start</code></td>
<td>

<p>Starting value for the covariance matrices, stacked one above the other. Dimension of each square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model. The default is the identity matrix for each cluster.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_l2cov.start">l2cov.start</code></td>
<td>

<p>Starting value for the level 2 covariance matrix. Dimension of this square matrix is equal to the number of outcomes (continuous plus latent normals) in the imputation model times the number of random effects plus the number of level-2 outcomes. The default is an identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_l1cov.prior">l1cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the covariance matrices. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_l2cov.prior">l2cov.prior</code></td>
<td>

<p>Scale matrix for the inverse-Wishart prior for the level 2 covariance matrix. The default is the identity matrix.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_start.imp">start.imp</code></td>
<td>

<p>Starting value for the imputed dataset. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_l2.start.imp">l2.start.imp</code></td>
<td>

<p>Starting value for the level-2 imputed variables. n-level categorical variables are substituted by n-1 latent normals.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_nburn">nburn</code></td>
<td>

<p>Number of iterations. Default is 1000.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_a">a</code></td>
<td>

<p>Starting value for the degrees of freedom of the inverse Wishart distribution of the cluster-specific covariance matrices. Default is 50+D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_a.prior">a.prior</code></td>
<td>

<p>Hyperparameter (Degrees of freedom) of the chi square prior distribution for the degrees of freedom of the inverse Wishart distribution for the cluster-specific covariance matrices. Default is D, with D being the dimension of the covariance matrices.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_meth">meth</code></td>
<td>

<p>When set to &quot;fixed&quot;, a flat prior is put on the cluster-specific covariance matrices and each matrix is updated separately with a different MH-step.
When set to &quot;random&quot;, we are assuming that all the cluster-specific level-1 covariance matrices are draws from an inverse-Wishart distribution, whose parameter values are updated with 2 steps similar to the ones presented in the case of clustered data for function jomo1ranconhr.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_output">output</code></td>
<td>

<p>When set to any value different from 1 (default), no output is shown on screen at the end of the process.
</p>
</td></tr>
<tr><td><code id="jomo2hr.MCMCchain_+3A_out.iter">out.iter</code></td>
<td>

<p>When set to K, every K iterations a dot is printed on screen. Default is 10. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is returned; this contains the final imputed dataset (finimp) and several 3-dimensional matrices, containing all the values drawn for each parameter at each iteration: these are, potentially, fixed effect parameters beta (collectbeta), random effects (collectu), level 1 (collectomega) and level 2 covariance matrices (collectcovu) and level-2 fixed effect parameters. If there are some categorical outcomes, a further output is included in the list, finimp.latnorm, containing the final state of the imputed dataset with the latent normal variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Y&lt;-tldata[,c("measure.a"), drop=FALSE]
Y2&lt;-tldata[,c("big.city"), drop=FALSE]
clus&lt;-tldata[,c("city")]
nburn=20

#now we run the imputation function. Note that we would typically use an higher 
#number of nburn iterations in real applications (at least 100)

imp&lt;-jomo2hr.MCMCchain(Y.con=Y, Y2.cat=Y2, Y2.numcat=2, clus=clus,nburn=nburn)

#We can check the convergence of the first element of beta:

plot(c(1:nburn),imp$collectbeta[1,1,1:nburn],type="l")

#Or similarly we can check the convergence of any element of the level 2 covariance matrix:

plot(c(1:nburn),imp$collectcovu[1,2,1:nburn],type="l")
</code></pre>

<hr>
<h2 id='JSPmiss'>
Exam results for six inner London Education Authorities
</h2><span id='topic+JSPmiss'></span>

<h3>Description</h3>

<p>A partially observed version of the jspmix1 dataset in package R2MLwiN. This is an educational dataset of pupils' test scores, a subset of the Junior School Project (Mortimore et al, 1988).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cldata)</code></pre>


<h3>Format</h3>

<p>A data frame with 4059 observations on the following 6 variables.
</p>

<dl>
<dt><code>school</code></dt><dd><p>A school identifier.</p>
</dd>
<dt><code>id</code></dt><dd><p>A student ID.</p>
</dd>
<dt><code>fluent</code></dt><dd><p>Fluency in English indicator, where 0 = beginner, 1 = intermediate, 2 = fully fluent; measured in Year 1.</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex of pupil; numeric with levels 0 (boy), 1 (girl).</p>
</dd>
<dt><code>cons</code></dt><dd><p>A column of 1s. Useful to add an intercept to th eimputation model.</p>
</dd>
<dt><code>ravens</code></dt><dd><p>Test score, out of 40; measured in Year 1.</p>
</dd>
<dt><code>english</code></dt><dd><p>Pupils' English test score, out of 100; measured in Year 3.</p>
</dd>
<dt><code>behaviour</code></dt><dd><p>Pupils' behaviour score, where lowerquarter = pupil rated in bottom 25%, and upper otherwise; measured in Year 3.</p>
</dd>
</dl>



<h3>Details</h3>

<p>These fully observed verison of the data is available with package R2MLwiN.</p>


<h3>Source</h3>

<p>Browne, W. J. (2012) MCMC Estimation in MLwiN Version 2.26. University of Bristol: Centre for Multilevel Modelling.
</p>
<p>Mortimore, P., Sammons, P., Stoll, L., Lewis, D., Ecob, R. (1988) School Matters. Wells: Open Books.
</p>
<p>Rasbash, J., Charlton, C., Browne, W.J., Healy, M. and Cameron, B. (2009) MLwiN Version 2.1. Centre for Multilevel Modelling, University of Bristol.
</p>

<hr>
<h2 id='sldata'>
A simulated single level dataset 
</h2><span id='topic+sldata'></span>

<h3>Description</h3>

<p>A simulated dataset to test single level functions, i.e. jomo1con, jomo1cat and jomo1mix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sldata)</code></pre>


<h3>Format</h3>

<p>A data frame with 300 observations on the following 4 variables.
</p>

<dl>
<dt><code>age</code></dt><dd><p>A numeric variable with age. Fully observed.</p>
</dd>
<dt><code>measure</code></dt><dd><p>A numeric variable with some measure of interest (unspecified). This is partially observed.</p>
</dd>
<dt><code>sex</code></dt><dd><p>A binary variable for gender indicator. Fully observed.</p>
</dd>
<dt><code>social</code></dt><dd><p>A 4-category variable with a social status indicator. This is partially observed.</p>
</dd>
</dl>



<h3>Details</h3>

<p>These are not real data, they are simulated to illustrate the use of the main functions of the package.</p>

<hr>
<h2 id='surdata'>
A simulated dataset with survival data
</h2><span id='topic+surdata'></span>

<h3>Description</h3>

<p>A simulated dataset to test functions for imputation compatible with cox model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cldata)</code></pre>


<h3>Format</h3>

<p>A data frame with 500 observations on the following 5 variables.
</p>

<dl>
<dt><code>measure</code></dt><dd><p>A numeric variable with some measure of interest (unspecified). This is partially observed.</p>
</dd>
<dt><code>sex</code></dt><dd><p>A binary variable with gender indicator. Partially observed.</p>
</dd>
<dt><code>id</code></dt><dd><p>The id for individuals within each city.</p>
</dd>
<dt><code>time</code></dt><dd><p>Time to event (death or censoring).</p>
</dd>
<dt><code>status</code></dt><dd><p>Binary variables, which takes value 0 for censored observations and 1 for deaths/events.</p>
</dd>
</dl>



<h3>Details</h3>

<p>These are not real data, they are simulated to illustrate the use of the main functions of the package.</p>

<hr>
<h2 id='tldata'>
A simulated 2-level dataset 
</h2><span id='topic+tldata'></span>

<h3>Description</h3>

<p>A simulated dataset to test 2-level functions, i.e. jomo2com and jomo2hr. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tldata)</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations on the following 6 variables.
</p>

<dl>
<dt><code>measure.a</code></dt><dd><p>A numeric variable with some measure of interest (unspecified). This is partially observed.</p>
</dd>
<dt><code>measure.b</code></dt><dd><p>A numeric variable with some measure of interest (unspecified). This is fully observed.</p>
</dd>
<dt><code>measure.a2</code></dt><dd><p>A numeric variable with some level-2 measure of interest (unspecified). This is partially observed.</p>
</dd>
<dt><code>previous.events</code></dt><dd><p>A binary variable indicating if a patient has previous history of (unspecified) events. Patially observed.</p>
</dd>
<dt><code>group</code></dt><dd><p>A 3-category variable indicating to which group each patient belongs. This is partially observed.</p>
</dd>
<dt><code>big.city</code></dt><dd><p>A binary variable indicating if each city has more than 100000 inhabitants. Patially observed.</p>
</dd>
<dt><code>region</code></dt><dd><p>A 3-category variable indicating to which region each city belongs. This is fully observed.</p>
</dd>
<dt><code>city</code></dt><dd><p>The cluster indicator vector. 200 cities are indexed 0 to 199.</p>
</dd>
<dt><code>id</code></dt><dd><p>The id for each individual within each city.</p>
</dd>
</dl>



<h3>Details</h3>

<p>These are not real data, they are simulated to illustrate the use of the main functions of the package.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
