<!DOCTYPE html><html><head><title>Help for package stringfish</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stringfish}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#convert_to_sf'><p>convert_to_sf</p></a></li>
<li><a href='#get_string_type'><p>get_string_type</p></a></li>
<li><a href='#materialize'><p>materialize</p></a></li>
<li><a href='#random_strings'><p>random_strings</p></a></li>
<li><a href='#sf_assign'><p>sf_assign</p></a></li>
<li><a href='#sf_collapse'><p>sf_collapse</p></a></li>
<li><a href='#sf_compare'><p>sf_compare</p></a></li>
<li><a href='#sf_concat'><p>sf_concat</p></a></li>
<li><a href='#sf_ends'><p>sf_ends</p></a></li>
<li><a href='#sf_grepl'><p>sf_grepl</p></a></li>
<li><a href='#sf_gsub'><p>sf_gsub</p></a></li>
<li><a href='#sf_iconv'><p>sf_iconv</p></a></li>
<li><a href='#sf_match'><p>sf_match</p></a></li>
<li><a href='#sf_nchar'><p>sf_nchar</p></a></li>
<li><a href='#sf_paste'><p>sf_paste</p></a></li>
<li><a href='#sf_readLines'><p>sf_readLines</p></a></li>
<li><a href='#sf_split'><p>sf_split</p></a></li>
<li><a href='#sf_starts'><p>sf_starts</p></a></li>
<li><a href='#sf_substr'><p>sf_substr</p></a></li>
<li><a href='#sf_tolower'><p>sf_tolower</p></a></li>
<li><a href='#sf_toupper'><p>sf_toupper</p></a></li>
<li><a href='#sf_trim'><p>sf_trim</p></a></li>
<li><a href='#sf_vector'><p>sf_vector</p></a></li>
<li><a href='#sf_writeLines'><p>sf_writeLines</p></a></li>
<li><a href='#string_identical'><p>string_identical</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Alt String Implementation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.16.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Travers Ching &lt;traversc@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an extendable, performant and multithreaded 'alt-string' implementation backed by 'C++' vectors and strings.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.18.3), RcppParallel (&ge; 5.1.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>qs, knitr, rmarkdown, usethis, dplyr, stringr, rlang</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Copyright for the bundled 'PCRE2' library is held by
University of Cambridge, Zoltan Herczeg and Tilera Coporation
(Stack-less Just-In-Time compiler); Copyright for the bundled
'xxHash' code is held by Yann Collet.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/traversc/stringfish">https://github.com/traversc/stringfish</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/traversc/stringfish/issues">https://github.com/traversc/stringfish/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 20:22:48 UTC; tching</td>
</tr>
<tr>
<td>Author:</td>
<td>Travers Ching [aut, cre, cph],
  Phillip Hazel [ctb] (Bundled PCRE2 code),
  Zoltan Herczeg [ctb, cph] (Bundled PCRE2 code),
  University of Cambridge [cph] (Bundled PCRE2 code),
  Tilera Corporation [cph] (Stack-less Just-In-Time compiler bundled with
    PCRE2),
  Yann Collet [ctb, cph] (Yann Collet is the author of the bundled xxHash
    code)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='convert_to_sf'>convert_to_sf</h2><span id='topic+convert_to_sf'></span><span id='topic+sf_convert'></span>

<h3>Description</h3>

<p>Converts a character vector to a stringfish vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_to_sf(x)

sf_convert(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_to_sf_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a character vector to a stringfish vector. The opposite of 'materialize'.
</p>


<h3>Value</h3>

<p>The converted character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- convert_to_sf(letters)
}
</code></pre>

<hr>
<h2 id='get_string_type'>get_string_type</h2><span id='topic+get_string_type'></span>

<h3>Description</h3>

<p>Returns the type of the character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_string_type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_string_type_+3A_x">x</code></td>
<td>
<p>the vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function that returns the type of character vector. Possible values are &quot;normal vector&quot;, &quot;stringfish vector&quot;, &quot;stringfish vector (materialized)&quot; or &quot;other alt-rep vector&quot;
</p>


<h3>Value</h3>

<p>The type of vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- sf_vector(10)
get_string_type(x) # returns "stringfish vector"
x &lt;- character(10)
get_string_type(x) # returns "normal vector"
}
</code></pre>

<hr>
<h2 id='materialize'>materialize</h2><span id='topic+materialize'></span>

<h3>Description</h3>

<p>Materializes an alt-rep object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>materialize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="materialize_+3A_x">x</code></td>
<td>
<p>An alt-rep object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Materializes any alt-rep object and then returns it. 
Note: the object is materialized regardless of whether the return value is assigned to a variable.
</p>


<h3>Value</h3>

<p>x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- sf_vector(10)
sf_assign(x, 1, "hello world")
sf_assign(x, 2, "another string")
x &lt;- materialize(x)
}
</code></pre>

<hr>
<h2 id='random_strings'>random_strings</h2><span id='topic+random_strings'></span>

<h3>Description</h3>

<p>A function that generates random strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_strings(N, string_size = 50, charset = "abcdefghijklmnopqrstuvwxyz", 
                      vector_mode = "stringfish")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_strings_+3A_n">N</code></td>
<td>
<p>The number of strings to generate</p>
</td></tr>
<tr><td><code id="random_strings_+3A_string_size">string_size</code></td>
<td>
<p>The length of the strings</p>
</td></tr>
<tr><td><code id="random_strings_+3A_charset">charset</code></td>
<td>
<p>The characters used to generate the random strings (default: abcdefghijklmnopqrstuvwxyz)</p>
</td></tr>
<tr><td><code id="random_strings_+3A_vector_mode">vector_mode</code></td>
<td>
<p>The type of character vector to generate (either stringfish or normal, default: stringfish)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the PCRE2 library, which is also used internally by R. 
Note: the order of paramters is switched compared to the 'gsub' base R function, with subject being first. 
See also: https://www.pcre.org/current/doc/html/pcre2api.html for more documentation on match syntax.
</p>


<h3>Value</h3>

<p>A character vector of the random strings
</p>


<h3>See Also</h3>

<p>gsub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
set.seed(1)
x &lt;- random_strings(1e6, 80, "ACGT", vector_mode = "stringfish")
}
</code></pre>

<hr>
<h2 id='sf_assign'>sf_assign</h2><span id='topic+sf_assign'></span>

<h3>Description</h3>

<p>Assigns a new string to a stringfish vector or any other character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_assign(x, i, e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_assign_+3A_x">x</code></td>
<td>
<p>the vector</p>
</td></tr>
<tr><td><code id="sf_assign_+3A_i">i</code></td>
<td>
<p>the index to assign to</p>
</td></tr>
<tr><td><code id="sf_assign_+3A_e">e</code></td>
<td>
<p>the new string to replace at i in x</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function to assign a new element to an existing character vector. If the the vector is a stringfish vector, it does so without materialization.
</p>


<h3>Value</h3>

<p>No return value, the function assigns an element to an existing stringfish vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- sf_vector(10)
sf_assign(x, 1, "hello world")
sf_assign(x, 2, "another string")
}
</code></pre>

<hr>
<h2 id='sf_collapse'>sf_collapse</h2><span id='topic+sf_collapse'></span>

<h3>Description</h3>

<p>Pastes a series of strings together separated by the 'collapse' parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_collapse(x, collapse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_collapse_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="sf_collapse_+3A_collapse">collapse</code></td>
<td>
<p>A single string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works the same way as 'paste0(x, collapse=collapse)'
</p>


<h3>Value</h3>

<p>A single string with all values in 'x' pasted together, separated by 'collapse'.
</p>


<h3>See Also</h3>

<p>paste0, paste
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- c("hello", "\\xe4\\xb8\\x96\\xe7\\x95\\x8c")
Encoding(x) &lt;- "UTF-8"
sf_collapse(x, " ") # "hello world" in Japanese
sf_collapse(letters, "") # returns the alphabet
}
</code></pre>

<hr>
<h2 id='sf_compare'>sf_compare</h2><span id='topic+sf_compare'></span><span id='topic+sf_equals'></span>

<h3>Description</h3>

<p>Returns a logical vector testing equality of strings from two string vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_compare(x, y, nthreads = getOption("stringfish.nthreads", 1L))

sf_equals(x, y, nthreads = getOption("stringfish.nthreads", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_compare_+3A_x">x</code></td>
<td>
<p>A character vector of length 1 or the same non-zero length as y</p>
</td></tr>
<tr><td><code id="sf_compare_+3A_y">y</code></td>
<td>
<p>Another character vector of length 1 or the same non-zero length as y</p>
</td></tr>
<tr><td><code id="sf_compare_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the function tests for both string and encoding equality
</p>


<h3>Value</h3>

<p>A logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
sf_compare(letters, "a")
}
</code></pre>

<hr>
<h2 id='sf_concat'>sf_concat</h2><span id='topic+sf_concat'></span><span id='topic+sfc'></span>

<h3>Description</h3>

<p>Appends vectors together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_concat(...)

sfc(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_concat_+3A_...">...</code></td>
<td>
<p>Any number of vectors, coerced to character vector if necessary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A concatenated stringfish vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
sf_concat(letters, 1:5)
}
</code></pre>

<hr>
<h2 id='sf_ends'>sf_ends</h2><span id='topic+sf_ends'></span>

<h3>Description</h3>

<p>A function for detecting a pattern at the end of a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_ends(subject, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_ends_+3A_subject">subject</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="sf_ends_+3A_pattern">pattern</code></td>
<td>
<p>A string to look for at the start</p>
</td></tr>
<tr><td><code id="sf_ends_+3A_...">...</code></td>
<td>
<p>Parameters passed to sf_grepl</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector true if there is a match, false if no match, NA is the subject was NA
</p>


<h3>See Also</h3>

<p>endsWith, sf_starts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- c("alpha", "beta", "gamma", "delta", "epsilon")
sf_ends(x, "a")
}
</code></pre>

<hr>
<h2 id='sf_grepl'>sf_grepl</h2><span id='topic+sf_grepl'></span>

<h3>Description</h3>

<p>A function that matches patterns and returns a logical vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_grepl(subject, pattern, encode_mode = "auto", fixed = FALSE, 
nthreads = getOption("stringfish.nthreads", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_grepl_+3A_subject">subject</code></td>
<td>
<p>The subject character vector to search</p>
</td></tr>
<tr><td><code id="sf_grepl_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to search for</p>
</td></tr>
<tr><td><code id="sf_grepl_+3A_encode_mode">encode_mode</code></td>
<td>
<p>&quot;auto&quot;, &quot;UTF-8&quot; or &quot;byte&quot;. Determines multi-byte (UTF-8) characters or single-byte characters are used.</p>
</td></tr>
<tr><td><code id="sf_grepl_+3A_fixed">fixed</code></td>
<td>
<p>determines whether the pattern parameter should be interpreted literally or as a regular expression</p>
</td></tr>
<tr><td><code id="sf_grepl_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the PCRE2 library, which is also used internally by R. 
The encoding is based on the pattern string (or forced via the encode_mode parameter). 
Note: the order of paramters is switched compared to the 'grepl' base R function, with subject being first. 
See also: https://www.pcre.org/current/doc/html/pcre2api.html for more documentation on match syntax.
</p>


<h3>Value</h3>

<p>A logical vector with the same length as subject
</p>


<h3>See Also</h3>

<p>grepl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- sf_vector(10)
sf_assign(x, 1, "hello world")
pattern &lt;- "^hello"
sf_grepl(x, pattern)
}
</code></pre>

<hr>
<h2 id='sf_gsub'>sf_gsub</h2><span id='topic+sf_gsub'></span>

<h3>Description</h3>

<p>A function that performs pattern substitution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_gsub(subject, pattern, replacement, encode_mode = "auto", fixed = FALSE, 
nthreads = getOption("stringfish.nthreads", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_gsub_+3A_subject">subject</code></td>
<td>
<p>The subject character vector to search</p>
</td></tr>
<tr><td><code id="sf_gsub_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to search for</p>
</td></tr>
<tr><td><code id="sf_gsub_+3A_replacement">replacement</code></td>
<td>
<p>The replacement string</p>
</td></tr>
<tr><td><code id="sf_gsub_+3A_encode_mode">encode_mode</code></td>
<td>
<p>&quot;auto&quot;, &quot;UTF-8&quot; or &quot;byte&quot;. Determines multi-byte (UTF-8) characters or single-byte characters are used.</p>
</td></tr>
<tr><td><code id="sf_gsub_+3A_fixed">fixed</code></td>
<td>
<p>determines whether the pattern parameter should be interpreted literally or as a regular expression</p>
</td></tr>
<tr><td><code id="sf_gsub_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the PCRE2 library, which is also used internally by R. However, syntax may be slightly different. 
E.g.: capture groups: &quot;\1&quot; in R, but &quot;$1&quot; in PCRE2 (as in Perl). 
The encoding of the output is determined by the pattern (or forced using encode_mode parameter) and encodings should be compatible. 
E.g: mixing ASCII and UTF-8 is okay, but not UTF-8 and latin1. 
Note: the order of paramters is switched compared to the 'gsub' base R function, with subject being first. 
See also: https://www.pcre.org/current/doc/html/pcre2api.html for more documentation on match syntax.
</p>


<h3>Value</h3>

<p>A stringfish vector of the replacement string
</p>


<h3>See Also</h3>

<p>gsub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- "hello world"
pattern &lt;- "^hello (.+)"
replacement &lt;- "goodbye $1"
sf_gsub(x, pattern, replacement)
}
</code></pre>

<hr>
<h2 id='sf_iconv'>sf_iconv</h2><span id='topic+sf_iconv'></span>

<h3>Description</h3>

<p>Converts encoding of one character vector to another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_iconv(x, from, to, nthreads = getOption("stringfish.nthreads", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_iconv_+3A_x">x</code></td>
<td>
<p>An alt-rep object</p>
</td></tr>
<tr><td><code id="sf_iconv_+3A_from">from</code></td>
<td>
<p>the encoding to assume of 'x'</p>
</td></tr>
<tr><td><code id="sf_iconv_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use</p>
</td></tr>
<tr><td><code id="sf_iconv_+3A_to">to</code></td>
<td>
<p>the new encoding</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an analogue to the base R function 'iconv'. It converts a string from one encoding (e.g. latin1 or UTF-8) to another
</p>


<h3>Value</h3>

<p>the converted character vector as a stringfish vector
</p>


<h3>See Also</h3>

<p>iconv
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- "fa\xE7ile"
Encoding(x) &lt;- "latin1"
sf_iconv(x, "latin1", "UTF-8")
}
</code></pre>

<hr>
<h2 id='sf_match'>sf_match</h2><span id='topic+sf_match'></span>

<h3>Description</h3>

<p>Returns a vector of the positions of x in table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_match(x, table, nthreads = getOption("stringfish.nthreads", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_match_+3A_x">x</code></td>
<td>
<p>A character vector to search for in table</p>
</td></tr>
<tr><td><code id="sf_match_+3A_table">table</code></td>
<td>
<p>A character vector to be matched against x</p>
</td></tr>
<tr><td><code id="sf_match_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: similarly to the base R function, long &quot;table&quot; vectors are not supported. This is due to the maximum integer value that can be returned ('.Machine$integer.max')
</p>


<h3>Value</h3>

<p>An integer vector of the indicies of each x element's position in table
</p>


<h3>See Also</h3>

<p>match
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
sf_match("c", letters)
}
</code></pre>

<hr>
<h2 id='sf_nchar'>sf_nchar</h2><span id='topic+sf_nchar'></span>

<h3>Description</h3>

<p>Counts the number of characters in a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_nchar(x, type = "chars", nthreads = getOption("stringfish.nthreads", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_nchar_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="sf_nchar_+3A_type">type</code></td>
<td>
<p>The type of counting to perform (&quot;chars&quot; or &quot;bytes&quot;, default: &quot;chars&quot;)</p>
</td></tr>
<tr><td><code id="sf_nchar_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the number of characters per string. The type of counting only matters for UTF-8 strings, where a character can be represented by multiple bytes.
</p>


<h3>Value</h3>

<p>An integer vector of the number of characters
</p>


<h3>See Also</h3>

<p>nchar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- "fa\xE7ile"
Encoding(x) &lt;- "latin1"
x &lt;- sf_iconv(x, "latin1", "UTF-8")
}
</code></pre>

<hr>
<h2 id='sf_paste'>sf_paste</h2><span id='topic+sf_paste'></span>

<h3>Description</h3>

<p>Pastes a series of strings together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_paste(..., sep = "", nthreads = getOption("stringfish.nthreads", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_paste_+3A_...">...</code></td>
<td>
<p>Any number of character vector strings</p>
</td></tr>
<tr><td><code id="sf_paste_+3A_sep">sep</code></td>
<td>
<p>The seperating string between strings</p>
</td></tr>
<tr><td><code id="sf_paste_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works the same way as 'paste0(..., sep=sep)'
</p>


<h3>Value</h3>

<p>A character vector where elements of the arguments are pasted together
</p>


<h3>See Also</h3>

<p>paste0, paste
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- letters
y &lt;- LETTERS
sf_paste(x,y, sep = ":")
}
</code></pre>

<hr>
<h2 id='sf_readLines'>sf_readLines</h2><span id='topic+sf_readLines'></span>

<h3>Description</h3>

<p>A function that reads a file line by line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_readLines(file, encoding = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_readLines_+3A_file">file</code></td>
<td>
<p>The file name</p>
</td></tr>
<tr><td><code id="sf_readLines_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use (Default: UTF-8)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function for reading in text data using 'std::ifstream'.
</p>


<h3>Value</h3>

<p>A stringfish vector of the lines in a file
</p>


<h3>See Also</h3>

<p>readLines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
file &lt;- tempfile()
sf_writeLines(letters, file)
sf_readLines(file)
}
</code></pre>

<hr>
<h2 id='sf_split'>sf_split</h2><span id='topic+sf_split'></span>

<h3>Description</h3>

<p>A function to split strings by a delimiter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_split(subject, split, encode_mode = "auto", fixed = FALSE, 
nthreads = getOption("stringfish.nthreads", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_split_+3A_subject">subject</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="sf_split_+3A_split">split</code></td>
<td>
<p>A delimiter to split the string by</p>
</td></tr>
<tr><td><code id="sf_split_+3A_encode_mode">encode_mode</code></td>
<td>
<p>&quot;auto&quot;, &quot;UTF-8&quot; or &quot;byte&quot;. Determines multi-byte (UTF-8) characters or single-byte characters are used.</p>
</td></tr>
<tr><td><code id="sf_split_+3A_fixed">fixed</code></td>
<td>
<p>determines whether the split parameter should be interpreted literally or as a regular expression</p>
</td></tr>
<tr><td><code id="sf_split_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of stringfish character vectors
</p>


<h3>See Also</h3>

<p>strsplit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
sf_split(datasets::state.name, "\\s") # split U.S. state names by any space character
}
</code></pre>

<hr>
<h2 id='sf_starts'>sf_starts</h2><span id='topic+sf_starts'></span>

<h3>Description</h3>

<p>A function for detecting a pattern at the start of a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_starts(subject, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_starts_+3A_subject">subject</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="sf_starts_+3A_pattern">pattern</code></td>
<td>
<p>A string to look for at the start</p>
</td></tr>
<tr><td><code id="sf_starts_+3A_...">...</code></td>
<td>
<p>Parameters passed to sf_grepl</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector true if there is a match, false if no match, NA is the subject was NA
</p>


<h3>See Also</h3>

<p>startsWith, sf_ends
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- c("alpha", "beta", "gamma", "delta", "epsilon")
sf_starts(x, "a")
}
</code></pre>

<hr>
<h2 id='sf_substr'>sf_substr</h2><span id='topic+sf_substr'></span>

<h3>Description</h3>

<p>Extracts substrings from a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_substr(x, start, stop, nthreads = getOption("stringfish.nthreads", 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_substr_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="sf_substr_+3A_start">start</code></td>
<td>
<p>The begining to extract from</p>
</td></tr>
<tr><td><code id="sf_substr_+3A_stop">stop</code></td>
<td>
<p>The end to extract from</p>
</td></tr>
<tr><td><code id="sf_substr_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of threads to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works the same way as 'substr', but in addition allows negative indexing. 
Negative indicies count backwards from the end of the string, with -1 being the last character.
</p>


<h3>Value</h3>

<p>A stringfish vector of substrings
</p>


<h3>See Also</h3>

<p>substr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- c("fa\xE7ile", "hello world")
Encoding(x) &lt;- "latin1"
x &lt;- sf_iconv(x, "latin1", "UTF-8")
sf_substr(x, 4, -1) # extracts from the 4th character to the last
## [1] "ile"  "lo world"
}
</code></pre>

<hr>
<h2 id='sf_tolower'>sf_tolower</h2><span id='topic+sf_tolower'></span>

<h3>Description</h3>

<p>A function converting a string to all lowercase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_tolower(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_tolower_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the function only converts ASCII characters.
</p>


<h3>Value</h3>

<p>A stringfish vector where all uppercase is converted to lowercase
</p>


<h3>See Also</h3>

<p>tolower
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- LETTERS
sf_tolower(x)
}
</code></pre>

<hr>
<h2 id='sf_toupper'>sf_toupper</h2><span id='topic+sf_toupper'></span>

<h3>Description</h3>

<p>A function converting a string to all uppercase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_toupper(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_toupper_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the function only converts ASCII characters.
</p>


<h3>Value</h3>

<p>A stringfish vector where all lowercase is converted to uppercase
</p>


<h3>See Also</h3>

<p>toupper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- letters
sf_toupper(x)
}
</code></pre>

<hr>
<h2 id='sf_trim'>sf_trim</h2><span id='topic+sf_trim'></span>

<h3>Description</h3>

<p>A function to remove leading/trailing whitespace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_trim(subject, which = c("both", "left", "right"), whitespace = "[ \\t\\r\\n]", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_trim_+3A_subject">subject</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="sf_trim_+3A_which">which</code></td>
<td>
<p>&quot;both&quot;, &quot;left&quot;, or &quot;right&quot; determines which white space is removed</p>
</td></tr>
<tr><td><code id="sf_trim_+3A_whitespace">whitespace</code></td>
<td>
<p>Whitespace characters (default: &quot;[ \\t\\r\\n]&quot;)</p>
</td></tr>
<tr><td><code id="sf_trim_+3A_...">...</code></td>
<td>
<p>Parameters passed to sf_gsub</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stringfish vector of trimmed whitespace
</p>


<h3>See Also</h3>

<p>trimws
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- c(" alpha ", " beta", " gamma ", "delta ", "epsilon ")
sf_trim(x)
}
</code></pre>

<hr>
<h2 id='sf_vector'>sf_vector</h2><span id='topic+sf_vector'></span>

<h3>Description</h3>

<p>Creates a new stringfish vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_vector(len)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_vector_+3A_len">len</code></td>
<td>
<p>length of the new vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new stringfish vector, an alt-rep character vector backed by a C++ &quot;std::vector&quot; as the internal memory representation. 
The vector type is &quot;sfstring&quot;, which is a simple C++ class containing a &quot;std::string&quot; and a single byte (uint8_t) representing the encoding.
</p>


<h3>Value</h3>

<p>A new (empty) stringfish vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
x &lt;- sf_vector(10)
sf_assign(x, 1, "hello world")
sf_assign(x, 2, "another string")
}
</code></pre>

<hr>
<h2 id='sf_writeLines'>sf_writeLines</h2><span id='topic+sf_writeLines'></span>

<h3>Description</h3>

<p>A function that reads a file line by line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_writeLines(text, file, sep = "\n", na_value = "NA", encode_mode = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_writeLines_+3A_text">text</code></td>
<td>
<p>A character to write to file</p>
</td></tr>
<tr><td><code id="sf_writeLines_+3A_file">file</code></td>
<td>
<p>Name of the file to write to</p>
</td></tr>
<tr><td><code id="sf_writeLines_+3A_sep">sep</code></td>
<td>
<p>The line separator character(s)</p>
</td></tr>
<tr><td><code id="sf_writeLines_+3A_na_value">na_value</code></td>
<td>
<p>What to write in case of a NA string</p>
</td></tr>
<tr><td><code id="sf_writeLines_+3A_encode_mode">encode_mode</code></td>
<td>
<p>&quot;UTF-8&quot; or &quot;byte&quot;. If &quot;UTF-8&quot;, all strings are re-encoded as UTF-8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function for writing text data using 'std::ofstream'.
</p>


<h3>See Also</h3>

<p>writeLines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(getRversion() &gt;= "3.5.0") {
file &lt;- tempfile()
sf_writeLines(letters, file)
sf_readLines(file)
}
</code></pre>

<hr>
<h2 id='string_identical'>string_identical</h2><span id='topic+string_identical'></span>

<h3>Description</h3>

<p>A stricter comparison of string equality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_identical(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_identical_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="string_identical_+3A_y">y</code></td>
<td>
<p>Another character to compare to x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if strings are identical, including encoding
</p>


<h3>See Also</h3>

<p>identical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "fa\xE7ile"
Encoding(x) &lt;- "latin1"
y &lt;- iconv(x, "latin1", "UTF-8")
identical(x, y) # TRUE
string_identical(x, y) # FALSE
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
