<!DOCTYPE html><html><head><title>Help for package stratallo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stratallo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stratallo-package'><p>Functions for Optimum Sample Allocation in Stratified Sampling</p></a></li>
<li><a href='#asummary'><p>Summarizing the Allocation</p></a></li>
<li><a href='#CapacityScaling'><p>Integer-valued Optimal Univariate Allocation Under Constraints for Stratified</p>
Sampling</a></li>
<li><a href='#fpia'><p>Optimal Univariate Allocation Under Constraints for Stratified</p>
Sampling</a></li>
<li><a href='#opt'><p>Optimum Sample Allocation in Stratified Sampling</p></a></li>
<li><a href='#opt_1sided'><p>Algorithms for Optimum Sample Allocation Under One-Sided Bounds</p></a></li>
<li><a href='#optcost'><p>Minimum Cost Allocation in Stratified Sampling</p></a></li>
<li><a href='#pop10_mM'><p>Example Population with 10 Strata and Lower and Upper Bounds</p></a></li>
<li><a href='#pop507'><p>Example Population with 507 Strata</p></a></li>
<li><a href='#pop969'><p>Example Population with 969 Strata</p></a></li>
<li><a href='#ran_round'><p>Random Rounding of Numbers</p></a></li>
<li><a href='#rna_prior'><p>RNA in version that uses prior information about violations</p></a></li>
<li><a href='#rna_rec'><p>RNA - Recursive Implementation</p></a></li>
<li><a href='#rnabox'><p>Recursive Neyman Algorithm for Optimal Sample Allocation Under Box Constraints</p></a></li>
<li><a href='#round_oric'><p>Optimal Rounding under Integer Constraints</p></a></li>
<li><a href='#SimpleGreedy'><p>Integer-valued Optimal Univariate Allocation Under Constraints for Stratified</p>
Sampling</a></li>
<li><a href='#var_st'><p>Variance of the Stratified Estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Optimum Sample Allocation in Stratified Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions in this package provide solution to classical problem in
  survey methodology - an optimum sample allocation in stratified sampling. In
  this context, the optimum allocation is in the classical Tschuprow-Neyman's
  sense and it satisfies additional lower or upper bounds restrictions imposed
  on sample sizes in strata. There are few different algorithms available to
  use, and one them is based on popular sample allocation method that applies
  Neyman allocation to recursively reduced set of strata.
  This package also provides the function that computes a solution to the
  minimum cost allocation problem, which is a minor modification of the
  classical optimum sample allocation. This problem lies in the determination
  of a vector of strata sample sizes that minimizes total cost of the survey,
  under assumed fixed level of the stratified estimator's variance. As in the
  case of the classical optimum allocation, the problem of minimum cost
  allocation can be complemented by imposing upper-bounds constraints on sample
  sizes in strata.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wwojciech/stratallo">https://github.com/wwojciech/stratallo</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wwojciech/stratallo/issues">https://github.com/wwojciech/stratallo/issues</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>Wojciech Wójciak</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, lifecycle</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'helpers.R' 'algorithms_1sided.R' 'algorithms_2sided.R'
'algorithms_of_other_authors.R' 'data.R' 'opt.R'
'stratallo-package.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-25 17:11:21 UTC; wojtek</td>
</tr>
<tr>
<td>Author:</td>
<td>Wojciech Wójciak [aut, cre],
  Jacek Wesołowski [sad],
  Robert Wieczorkowski [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wojciech Wójciak &lt;wojciech.wojciak@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-26 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stratallo-package'>Functions for Optimum Sample Allocation in Stratified Sampling</h2><span id='topic+stratallo-package'></span><span id='topic+stratallo'></span>

<h3>Description</h3>

<p>Optimum Sample Allocation in Stratified Sampling
</p>


<h3>Author(s)</h3>

<p>Wojciech Wójciak <a href="mailto:wojciech.wojciak@gmail.com">wojciech.wojciak@gmail.com</a>
</p>


<h3>References</h3>

<p>Stenger, H., Gabler, S. (2005).
Combining random sampling and census strategies -
Justification of inclusion probabilities equal to 1.
<em>Metrika</em>, 61(2), pp. 137–156.
<a href="https://doi.org/10.1007/s001840400328">doi:10.1007/s001840400328</a> <br />
</p>
<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>, Springer, New York. <br />
</p>
<p>Wesołowski, J., Wieczorkowski, R., Wójciak, W. (2021).
Optimality of the Recursive Neyman Allocation.
<em>Journal of Survey Statistics and Methodology</em>, 10(5), pp. 1263–1275.
<a href="https://doi.org/10.1093/jssam/smab018">doi:10.1093/jssam/smab018</a>,
<a href="https://doi.org/10.48550/arXiv.2105.14486">doi:10.48550/arXiv.2105.14486</a> <br />
</p>
<p>Wesołowski, J., Wieczorkowski, R., Wójciak, W. (2023).
R Package stratallo - source code (Version 2.2.0).
<a href="https://github.com/wwojciech/stratallo">https://github.com/wwojciech/stratallo</a> <br />
</p>
<p>Wesołowski, J., Wieczorkowski, R., Wójciak, W. (2023).
Numerical Performance of the RNABOX Algorithm (Version 1.0.1).
<a href="https://github.com/rwieczor/recursive_Neyman_rnabox">https://github.com/rwieczor/recursive_Neyman_rnabox</a> <br />
</p>
<p>Wójciak, W. (2023).
Another Solution of Some Optimum Allocation Problem.
<em>Statistics in Transition new series</em>, 24(5) (in press).
<a href="https://arxiv.org/abs/2204.04035">https://arxiv.org/abs/2204.04035</a> <br />
</p>
<p>Wójciak, W. (2019). Optimal Allocation in Stratified Sampling Schemes.
<em>MSc Thesis</em>, Warsaw University of Technology, Warsaw, Poland.
<a href="http://home.elka.pw.edu.pl/~wwojciak/msc_optimal_allocation.pdf">http://home.elka.pw.edu.pl/~wwojciak/msc_optimal_allocation.pdf</a>
</p>

<hr>
<h2 id='asummary'>Summarizing the Allocation</h2><span id='topic+asummary'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>A helper function that returns a simple <code><a href="base.html#topic+data.frame">data.frame</a></code> with summary of the
allocation as returned by the <code><a href="#topic+opt">opt()</a></code> or <code><a href="#topic+optcost">optcost()</a></code>. See the illustrate
example below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asummary(x, A, m = NULL, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asummary_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> sample allocations <code class="reqn">x_1,\ldots,x_H</code> in strata.</p>
</td></tr>
<tr><td><code id="asummary_+3A_a">A</code></td>
<td>
<p>(<code>numeric</code>)<br /> population constants <code class="reqn">A_1,\ldots,A_H</code>.</p>
</td></tr>
<tr><td><code id="asummary_+3A_m">m</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> lower bounds <code class="reqn">m_1,\ldots,m_H</code>,
optionally imposed on sample sizes in strata.</p>
</td></tr>
<tr><td><code id="asummary_+3A_m">M</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> upper bounds <code class="reqn">M_1,\ldots,M_H</code>,
optionally imposed on sample sizes in strata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with as many rows as number of strata <code class="reqn">H</code> + 1,
and up to 7 variables. A single row corresponds to a given stratum
<code class="reqn">h \in \{1,\ldots,H\}</code>, whilst the last row contains sums of all of the
numerical values from the above rows (wherever feasible).
Summary table has the following columns (* indicates that the column may
not be present):
</p>

<dl>
<dt>A</dt><dd><p>population constant <code class="reqn">A_h</code></p>
</dd>
<dt>m*</dt><dd><p>lower bound imposed on sample size in stratum</p>
</dd>
<dt>M*</dt><dd><p>upper bound imposed on sample size in stratum</p>
</dd>
<dt>allocation</dt><dd><p>sample size for a given stratum</p>
</dd>
<dt>take_min*</dt><dd><p>indication whether the allocation is of <code>take-min</code> type,
i.e. <code class="reqn">x_h = m_h</code></p>
</dd>
<dt>take_max*</dt><dd><p>indication whether the allocation is of <code>take-max</code> type,
i.e. <code class="reqn">x_h = M_h</code></p>
</dd>
<dt>take_Neyman</dt><dd><p>indication whether the allocation is of <code>take-Neyman</code>
type, i.e. <code class="reqn">m_h &lt; x_h &lt; M_h</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+opt">opt()</a></code>, <code><a href="#topic+optcost">optcost()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- c(3000, 4000, 5000, 2000)
m &lt;- c(100, 90, 70, 80)
M &lt;- c(200, 150, 300, 210)

xopt_1 &lt;- opt(n = 400, A, m)
asummary(xopt_1, A, m)

xopt_2 &lt;- opt(n = 540, A, m, M)
asummary(xopt_2, A, m, M)
</code></pre>

<hr>
<h2 id='CapacityScaling'>Integer-valued Optimal Univariate Allocation Under Constraints for Stratified
Sampling</h2><span id='topic+CapacityScaling'></span><span id='topic+CapacityScaling2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Better algorithm from paper Friedrich et al. (2015) for integer-valued
optimal allocation in stratified sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CapacityScaling(n, Ah, mh = rep(1, length(Ah)), Mh = rep(Inf, length(Ah)))

CapacityScaling2(
  v0,
  Nh,
  Sh,
  mh = rep(1, length(Nh)),
  Mh = rep(Inf, length(Nh))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CapacityScaling_+3A_n">n</code></td>
<td>

<ul>
<li><p> target sample size for allocation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CapacityScaling_+3A_ah">Ah</code></td>
<td>

<ul>
<li><p> population strata sizes * standard deviations of a given variable in strata.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CapacityScaling_+3A_mh">mh</code></td>
<td>

<ul>
<li><p> lower constraints for sample sizes in strata.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CapacityScaling_+3A_mh">Mh</code></td>
<td>

<ul>
<li><p> upper constraints for sample sizes in strata.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CapacityScaling_+3A_v0">v0</code></td>
<td>

<ul>
<li><p> upper limit for value of variance which must be attained for
computed optimal allocation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CapacityScaling_+3A_nh">Nh</code></td>
<td>

<ul>
<li><p> population strata sizes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CapacityScaling_+3A_sh">Sh</code></td>
<td>

<ul>
<li><p> standard deviations of a given variable in strata.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of optimal allocation sizes.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>CapacityScaling2()</code>: 
</p>
</li></ul>


<h3>References</h3>

<p>Friedrich, U., Münnich, R., de Vries, S. and Wagner, M. (2015)
Fast integer-valued algorithms for optimal allocations under constraints in
stratified sampling,
<em>Computational Statistics and Data Analysis</em>, 92, pp. 1–12.
<a href="https://www.sciencedirect.com/science/article/pii/S0167947315001413">https://www.sciencedirect.com/science/article/pii/S0167947315001413</a>
</p>

<hr>
<h2 id='fpia'>Optimal Univariate Allocation Under Constraints for Stratified
Sampling</h2><span id='topic+fpia'></span><span id='topic+fpia2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Algorithm for optimal allocation in stratified sampling with lower and upper
constraints based on fixed point iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpia(
  n,
  Ah,
  mh = NULL,
  Mh = NULL,
  lambda0 = NULL,
  maxiter = 100,
  tol = .Machine$double.eps * 1000
)

fpia2(v0, Nh, Sh, mh = NULL, Mh = NULL, lambda0 = NULL, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpia_+3A_n">n</code></td>
<td>

<ul>
<li><p> target sample size for allocation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fpia_+3A_ah">Ah</code></td>
<td>

<ul>
<li><p> population strata sizes * standard deviations of a given variable in strata.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fpia_+3A_mh">mh</code></td>
<td>

<ul>
<li><p> lower constraints for sample sizes in strata.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fpia_+3A_mh">Mh</code></td>
<td>

<ul>
<li><p> upper constraints for sample sizes in strata.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fpia_+3A_lambda0">lambda0</code></td>
<td>

<ul>
<li><p> initial parameter 'lambda' (optional).
</p>
</li></ul>
</td></tr>
<tr><td><code id="fpia_+3A_maxiter">maxiter</code></td>
<td>

<ul>
<li><p> maximal number of iterations for algorithm.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fpia_+3A_tol">tol</code></td>
<td>

<ul>
<li><p> the desired accuracy (convergence tolerance).
</p>
</li></ul>
</td></tr>
<tr><td><code id="fpia_+3A_v0">v0</code></td>
<td>

<ul>
<li><p> upper limit for value of variance which must be attained for
computed optimal allocation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fpia_+3A_nh">Nh</code></td>
<td>

<ul>
<li><p> population strata sizes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fpia_+3A_sh">Sh</code></td>
<td>

<ul>
<li><p> standard deviations of a given variable in strata.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of optimal allocation sizes, and number of iterations.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fpia2()</code>: 
</p>
</li></ul>


<h3>References</h3>

<p>Münnich, R. T., Sachs, E.W. and Wagner, M. (2012)
Numerical solution of optimal allocation problems in stratified sampling
under box constraints,
<em>AStA Advances in Statistical Analysis</em>, 96(3), pp. 435-450.
<a href="https://doi.org/10.1007/s10182-011-0176-z">doi:10.1007/s10182-011-0176-z</a>
</p>

<hr>
<h2 id='opt'>Optimum Sample Allocation in Stratified Sampling</h2><span id='topic+opt'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>A classical problem in survey methodology in stratified sampling is optimum
sample allocation. This problem is formulated as determination of strata
sample sizes that minimize the variance of the
<em>stratified <code class="reqn">\pi</code> estimator</em> of the population total (or mean) of a
given study variable, under certain constraints on sample sizes in strata.
</p>
<p>The <code>opt()</code> user function solves the following optimum sample allocation
problem, formulated below in the language of mathematical optimization.
</p>
<p>Minimize
</p>
<p style="text-align: center;"><code class="reqn">f(x_1,\ldots,x_H) = \sum_{h=1}^H \frac{A^2_h}{x_h}</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">\sum_{h=1}^H x_h = n</code>
</p>

<p style="text-align: center;"><code class="reqn">m_h \leq x_h \leq M_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where <code class="reqn">n &gt; 0,\, A_h &gt; 0,\, m_h &gt; 0,\, M_h &gt; 0</code>, such that
<code class="reqn">m_h &lt; M_h,\, h = 1,\ldots,H</code>, and
<code class="reqn">\sum_{h=1}^H m_h \leq n \leq \sum_{h=1}^H M_h</code>, are given numbers.
The minimization is on <code class="reqn">\mathbb R_+^H</code>.
</p>
<p>The inequality constraints are optional and user can choose whether and how
they are to be added to the optimization problem. This is achieved by the
proper use of <code>m</code> and <code>M</code> arguments of this function, according to the
following rules:
</p>

<ul>
<li><p> no inequality constraints imposed: both <code>m</code> and <code>M</code> must be both set to
<code>NULL</code> (default).
</p>
</li>
<li><p> one-sided lower bounds <code class="reqn">m_h,\, h = 1,\ldots,H</code>, imposed:
lower bounds are specified with <code>m</code>, while <code>M</code> is set to <code>NULL</code>.
</p>
</li>
<li><p> one-sided upper bounds <code class="reqn">M_h,\, h = 1,\ldots,H</code>, imposed:
upper bounds are specified with <code>M</code>, while <code>m</code> is set to <code>NULL</code>.
</p>
</li>
<li><p> box-constraints imposed: lower and upper bounds must be specified with <code>m</code>
and <code>M</code>, respectively.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>opt(n, A, m = NULL, M = NULL, M_algorithm = "rna")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_+3A_n">n</code></td>
<td>
<p>(<code>number</code>)<br /> total sample size. A strictly positive scalar.
If <code>bounds1</code> is not <code>NULL</code>, it is then required that <code>n &gt;= sum(bounds1)</code>
(given that <code>bounds1</code> are treated as lower bounds) or <code>n &lt;= sum(bounds1)</code>
(given that <code>bounds1</code> are treated as upper bounds).
If <code>bounds2</code> is not <code>NULL</code>, it is then required that <code>n &gt;= sum(bounds2)</code>
(given that <code>bounds2</code> are treated as lower bounds) or <code>n &lt;= sum(bounds2)</code>
(given that <code>bounds2</code> are treated as upper bounds).</p>
</td></tr>
<tr><td><code id="opt_+3A_a">A</code></td>
<td>
<p>(<code>numeric</code>)<br /> population constants <code class="reqn">A_1,\ldots,A_H</code>. Strictly
positive numbers.</p>
</td></tr>
<tr><td><code id="opt_+3A_m">m</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> lower bounds <code class="reqn">m_1,\ldots,m_H</code>,
optionally imposed on sample sizes in strata. If no lower bounds should be
imposed, then <code>m</code> must be set to <code>NULL</code>. If <code>M</code> is not <code>NULL</code>, it is then
required that <code>m &lt; M</code>.</p>
</td></tr>
<tr><td><code id="opt_+3A_m">M</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> upper bounds <code class="reqn">M_1,\ldots,M_H</code>,
optionally imposed on sample sizes in strata. If no upper bounds should be
imposed, then <code>M</code> must be set to <code>NULL</code>. If <code>m</code> is not <code>NULL</code>, it is then
required that <code>m &lt; M</code>.</p>
</td></tr>
<tr><td><code id="opt_+3A_m_algorithm">M_algorithm</code></td>
<td>
<p>(<code>string</code>)<br /> the name of the underlying algorithm to be
used for computing sample allocation under one-sided upper-bounds
constraints.
It must be one of the following: <code>rna</code> (default), <code>sga</code>, <code>sgaplus</code>, <code>coma</code>.
This parameter is used only in case when <code>m</code> argument is <code>NULL</code> and <code>M</code> is
not <code>NULL</code> and number of strata <code class="reqn">H &gt; 1</code> and <code>n &lt; sum(M)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>opt()</code> function makes use of several allocation algorithms, depending
on which of the inequality constraints should be taken into account in the
optimization problem. Each algorithm is implemented in a separate R
function that in general should not be used directly by the end user.
The following is the list with the algorithms that are used along with the
name of the function that implements a given algorithm. See the description
of a specific function to find out more about the corresponding algorithm.
</p>

<ul>
<li><p> one-sided lower-bounds <code class="reqn">m_h,\, h = 1,\ldots,H</code>:
</p>

<ul>
<li> <p><code>LRNA</code> - <code><a href="#topic+rna">rna()</a></code>
</p>
</li></ul>

</li>
<li><p> one-sided upper-bounds <code class="reqn">M_h,\, h = 1,\ldots,H</code>:
</p>

<ul>
<li> <p><code>RNA</code> - <code><a href="#topic+rna">rna()</a></code>
</p>
</li>
<li> <p><code>SGA</code> - <code><a href="#topic+sga">sga()</a></code>
</p>
</li>
<li> <p><code>SGAPLUS</code> - <code><a href="#topic+sgaplus">sgaplus()</a></code>
</p>
</li>
<li> <p><code>COMA</code> - <code><a href="#topic+coma">coma()</a></code>
</p>
</li></ul>

</li>
<li><p> box constraints <code class="reqn">m_h, M_h,\, h = 1,\ldots,H</code>:
</p>

<ul>
<li> <p><code>RNABOX</code> - <code><a href="#topic+rnabox">rnabox()</a></code>
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>Numeric vector with optimal sample allocations in strata.
</p>


<h3>Note</h3>

<p>If no inequality constraints are added, the allocation is given by the
Neyman allocation as:
</p>
<p style="text-align: center;"><code class="reqn">x_h = A_h \frac{n}{\sum_{i=1}^H A_i}, \quad h = 1,\ldots,H.</code>
</p>

<p>For <em>stratified <code class="reqn">\pi</code> estimator</em> of the population total with
<em>stratified simple random sampling without replacement</em> design in use,
the parameters of the objective function <code class="reqn">f</code> are:
</p>
<p style="text-align: center;"><code class="reqn">A_h = N_h S_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where <code class="reqn">N_h</code> is the size of stratum <code class="reqn">h</code> and <code class="reqn">S_h</code> denotes
standard deviation of a given study variable in stratum <code class="reqn">h</code>.
</p>


<h3>References</h3>

<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optcost">optcost()</a></code>, <code><a href="#topic+rna">rna()</a></code>, <code><a href="#topic+sga">sga()</a></code>, <code><a href="#topic+sgaplus">sgaplus()</a></code>, <code><a href="#topic+coma">coma()</a></code>, <code><a href="#topic+rnabox">rnabox()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- c(3000, 4000, 5000, 2000)
m &lt;- c(100, 90, 70, 50)
M &lt;- c(300, 400, 200, 90)

# One-sided lower bounds.
opt(n = 340, A = A, m = m)
opt(n = 400, A = A, m = m)
opt(n = 700, A = A, m = m)

# One-sided upper bounds.
opt(n = 190, A = A, M = M)
opt(n = 700, A = A, M = M)

# Box-constraints.
opt(n = 340, A = A, m = m, M = M)
opt(n = 500, A = A, m = m, M = M)
xopt &lt;- opt(n = 800, A = A, m = m, M = M)
xopt
var_st(x = xopt, A = A, A0 = 45000) # Value of the variance for allocation xopt.

# Execution-time comparisons of different algorithms with microbenchmark R package.
## Not run: 
N &lt;- pop969[, "N"]
S &lt;- pop969[, "S"]
A &lt;- N * S
nfrac &lt;- c(0.005, seq(0.05, 0.95, 0.05))
n &lt;- setNames(as.integer(nfrac * sum(N)), nfrac)
lapply(
  n,
  function(ni) {
    microbenchmark::microbenchmark(
      RNA = opt(ni, A, M = N, M_algorithm = "rna"),
      SGA = opt(ni, A, M = N, M_algorithm = "sga"),
      SGAPLUS = opt(ni, A, M = N, M_algorithm = "sgaplus"),
      COMA = opt(ni, A, M = N, M_algorithm = "coma"),
      times = 200,
      unit = "us"
    )
  }
)

## End(Not run)
</code></pre>

<hr>
<h2 id='opt_1sided'>Algorithms for Optimum Sample Allocation Under One-Sided Bounds</h2><span id='topic+opt_1sided'></span><span id='topic+rna'></span><span id='topic+sga'></span><span id='topic+sgaplus'></span><span id='topic+coma'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Functions that implement selected optimal allocation algorithms that compute
a solution to the optimal allocation problem defined in the language of
mathematical optimization as follows.
</p>
<p>Minimize
</p>
<p style="text-align: center;"><code class="reqn">f(x_1,\ldots,x_H) = \sum_{h=1}^H \frac{A^2_h}{x_h}</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">\sum_{h=1}^H c_h x_h = c</code>
</p>

<p>and either
</p>
<p style="text-align: center;"><code class="reqn">x_h \leq M_h, \quad h = 1,\ldots,H</code>
</p>

<p>or
</p>
<p style="text-align: center;"><code class="reqn">x_h \geq m_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where
<code class="reqn">c &gt; 0,\, c_h &gt; 0,\, A_h &gt; 0,\, m_h &gt; 0,\, M_h &gt; 0,\, h = 1,\ldots,H</code>,
are given numbers. The minimization is on <code class="reqn">\mathbb R_+^H</code>.
</p>
<p>The inequality constraints are optional and user can choose whether and how
they are to be added to the optimization problem.
If one-sided lower bounds <code class="reqn">m_h,\, h = 1,\ldots,H</code>, must be imposed, it
is then required that <code class="reqn">c \geq \sum_{h=1}^H c_h m_h</code>.
If one-sided upper bounds <code class="reqn">M_h,\, h = 1,\ldots,H</code>, must be imposed, it
is then required that <code class="reqn">0 &lt; c \leq \sum_{h=1}^H c_h M_h</code>.
Lower bounds can be specified instead of the upper bounds only in case of the
<em>LRNA</em> algorithm. All other algorithms allow only for specification of
the upper bounds. For the sake of clarity, we emphasize that in the
optimization problem consider here, the lower and upper bounds cannot be
imposed jointly.
</p>
<p>Costs <code class="reqn">c_h,\, h = 1,\ldots,H</code>, of surveying one element in stratum, can
be specified by the user only in case of the <em>RNA</em> and <em>LRNA</em>
algorithms. For remaining algorithms, these costs are fixed at 1, i.e.
<code class="reqn">c_h = 1,\, h = 1,\ldots,H</code>.
</p>
<p>The following is the list of all the algorithms available to use along with
the name of the function that implements a given algorithm. See the
description of a specific function to find out more about the corresponding
algorithm.
</p>

<ul>
<li> <p><em>RNA</em> - <code>rna()</code>
</p>
</li>
<li> <p><em>LRNA</em>- <code>rna()</code>
</p>
</li>
<li> <p><em>SGA</em>- <code>sga()</code>
</p>
</li>
<li> <p><em>SGAPLUS</em> - <code>sgaplus()</code>
</p>
</li>
<li> <p><em>COMA</em> - <code>coma()</code>
</p>
</li></ul>

<p>Functions in this family should not be called directly by the user. Use
<code><a href="#topic+opt">opt()</a></code> or <code><a href="#topic+optcost">optcost()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rna(
  total_cost,
  A,
  bounds = NULL,
  unit_costs = 1,
  check_violations = .Primitive("&gt;="),
  details = FALSE
)

sga(total_cost, A, M)

sgaplus(total_cost, A, M)

coma(total_cost, A, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_1sided_+3A_total_cost">total_cost</code></td>
<td>
<p>(<code>number</code>)<br /> total cost <code class="reqn">c</code> of the survey. A strictly
positive scalar.</p>
</td></tr>
<tr><td><code id="opt_1sided_+3A_a">A</code></td>
<td>
<p>(<code>numeric</code>)<br /> population constants <code class="reqn">A_1,\ldots,A_H</code>. Strictly
positive numbers.</p>
</td></tr>
<tr><td><code id="opt_1sided_+3A_bounds">bounds</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>) <br /> optional lower bounds
<code class="reqn">m_1,\ldots,m_H</code>, or upper bounds <code class="reqn">M_1,\ldots,M_H</code>, or <code>NULL</code> to
indicate that there is no inequality constraints in the optimization
problem considered.
If not <code>NULL</code>, the <code>bounds</code> is to be treated either as:
</p>

<ul>
<li><p> lower bounds, if <code>check_violations = .Primitive("&lt;=")</code>. In this case, it
is required that <code>total_cost &gt;= sum(unit_costs * bounds)</code>, <br />
or
</p>
</li>
<li><p> upper bounds, if <code>check_violations = .Primitive("&gt;=")</code>. In this case, it
is required that <code>total_cost &lt;= sum(unit_costs * bounds)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="opt_1sided_+3A_unit_costs">unit_costs</code></td>
<td>
<p>(<code>numeric</code>)<br /> costs <code class="reqn">c_1,\ldots,c_H</code>, of surveying one
element in stratum. A strictly positive numbers. Can be also of length 1,
if all unit costs are the same for all strata. In this case, the elements
will be recycled to the length of <code>bounds</code>.</p>
</td></tr>
<tr><td><code id="opt_1sided_+3A_check_violations">check_violations</code></td>
<td>
<p>(<code>function</code>) <br /> 2-arguments binary operator function
that allows the comparison of values in atomic vectors. It must either be
set to <code>.Primitive("&lt;=")</code> or <code>.Primitive("&gt;=")</code>. The first of these choices
causes that <code>bounds</code> are treated as lower bounds and then <code>rna()</code> function
performs the <em>LRNA</em> algorithm. The latter option causes that <code>bounds</code>
are treated as upper bounds, and then <code>rna()</code> function performs the
<em>RNA</em> algorithm. This argument is ignored when <code>bounds</code> is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="opt_1sided_+3A_details">details</code></td>
<td>
<p>(<code>flag</code>) <br /> should detailed information about strata
assignments (either to take-Neyman or take-bound), values of set function
<code class="reqn">s</code> and number of iterations be added to the output?</p>
</td></tr>
<tr><td><code id="opt_1sided_+3A_m">M</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> upper bounds <code class="reqn">M_1,\ldots,M_H</code>,
optionally imposed on sample sizes in strata. If no upper bounds should be
imposed, then <code>M</code> must be set to <code>NULL</code>. Otherwise, it is required that
<code>total_cost &lt;= sum(unit_costs * M)</code>. Strictly positive numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with optimal sample allocations in strata. In case
of the <code>rna()</code> only, it can also be a <code><a href="base.html#topic+list">list</a></code> with optimal sample
allocations and strata assignments (either to take-Neyman or take-bound).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rna()</code>: <em>Recursive Neyman Algorithm</em> (<em>RNA</em>) and its
twin version, <em>Lower Recursive Neyman Algorithm</em> (<em>LRNA</em>)
dedicated to the allocation problem with one-sided lower-bounds constraints.
The <em>RNA</em> is described in Wesołowski et al. (2021), while <em>LRNA</em> is
introduced in Wójciak (2023).
</p>
</li>
<li> <p><code>sga()</code>: Stenger-Gabler type algorithm <em>SGA</em>, described in
Wesołowski et al. (2021) and in Stenger and Gabler (2005).
This algorithm solves the problem with one-sided upper-bounds constraints.
It also assumes unit costs are constant and equal to 1, i.e.
<code class="reqn">c_h = 1,\, h = 1,\ldots,H</code>.
</p>
</li>
<li> <p><code>sgaplus()</code>: modified Stenger-Gabler type algorithm, described in
Wójciak (2019) as <em>Sequential Allocation (version 1)</em> algorithm.
This algorithm solves the problem with one-sided upper-bounds constraints.
It also assumes unit costs are constant and equal to 1, i.e.
<code class="reqn">c_h = 1,\, h = 1,\ldots,H</code>.
</p>
</li>
<li> <p><code>coma()</code>: <em>Change of Monotonicity Algorithm</em> (<em>COMA</em>),
described in Wesołowski et al. (2021).
This algorithm solves the problem with one-sided upper-bounds constraints.
It also assumes unit costs are constant and equal to 1, i.e.
<code class="reqn">c_h = 1,\, h = 1,\ldots,H</code>.
</p>
</li></ul>


<h3>Note</h3>

<p>If no inequality constraints are added, the allocation is given by the
Neyman allocation as:
</p>
<p style="text-align: center;"><code class="reqn">x_h = \frac{A_h}{\sqrt{c_h}} \frac{n}{\sum_{i=1}^H A_i \sqrt{c_i}},
  \quad h = 1,\ldots,H.</code>
</p>

<p>For <em>stratified <code class="reqn">\pi</code> estimator</em> of the population total with
<em>stratified simple random sampling without replacement</em> design in use,
the parameters of the objective function <code class="reqn">f</code> are:
</p>
<p style="text-align: center;"><code class="reqn">A_h = N_h S_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where <code class="reqn">N_h</code> is the size of stratum <code class="reqn">h</code> and <code class="reqn">S_h</code> denotes
standard deviation of a given study variable in stratum <code class="reqn">h</code>.
</p>


<h3>References</h3>

<p>Wójciak, W. (2023).
Another Solution of Some Optimum Allocation Problem.
<em>Statistics in Transition new series</em>, 24(5) (in press).
<a href="https://arxiv.org/abs/2204.04035">https://arxiv.org/abs/2204.04035</a> <br />
</p>
<p>Wesołowski, J., Wieczorkowski, R., Wójciak, W. (2021).
Optimality of the Recursive Neyman Allocation.
<em>Journal of Survey Statistics and Methodology</em>, 10(5), pp. 1263–1275.
<a href="https://doi.org/10.1093/jssam/smab018">doi:10.1093/jssam/smab018</a>,
<a href="https://doi.org/10.48550/arXiv.2105.14486">doi:10.48550/arXiv.2105.14486</a> <br />
</p>
<p>Wójciak, W. (2019). Optimal Allocation in Stratified Sampling Schemes.
<em>MSc Thesis</em>, Warsaw University of Technology, Warsaw, Poland.
<a href="http://home.elka.pw.edu.pl/~wwojciak/msc_optimal_allocation.pdf">http://home.elka.pw.edu.pl/~wwojciak/msc_optimal_allocation.pdf</a> <br />
</p>
<p>Stenger, H., Gabler, S. (2005).
Combining random sampling and census strategies -
Justification of inclusion probabilities equal to 1.
<em>Metrika</em>, 61(2), pp. 137–156.
<a href="https://doi.org/10.1007/s001840400328">doi:10.1007/s001840400328</a> <br />
</p>
<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt">opt()</a></code>, <code><a href="#topic+optcost">optcost()</a></code>, <code><a href="#topic+rnabox">rnabox()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- c(3000, 4000, 5000, 2000)
m &lt;- c(50, 40, 10, 30) # lower bounds
M &lt;- c(100, 90, 70, 80) # upper bounds

rna(total_cost = 190, A = A, bounds = M)
rna(total_cost = 190, A = A, bounds = m, check_violations = .Primitive("&lt;="))
sga(total_cost = 190, A = A, M = M)
sgaplus(total_cost = 190, A = A, M = M)
coma(total_cost = 190, A = A, M = M)
</code></pre>

<hr>
<h2 id='optcost'>Minimum Cost Allocation in Stratified Sampling</h2><span id='topic+optcost'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Function that determines fixed strata sample sizes that minimize total cost
of the survey, under assumed level of the variance of the stratified
estimator and under optional one-sided upper bounds imposed on strata sample
sizes. Namely, the following optimization problem, formulated below in the
language of mathematical optimization, is solved by <code>optcost()</code> function.
</p>
<p>Minimize
</p>
<p style="text-align: center;"><code class="reqn">c(x_1,\ldots,x_H) = \sum_{h=1}^H c_h x_h</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">\sum_{h=1}^H \frac{A^2_h}{x_h} - A_0 = V</code>
</p>

<p style="text-align: center;"><code class="reqn">x_h \leq M_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where <code class="reqn">A_0,\, A_h &gt; 0,\, c_h &gt; 0,\, M_h &gt; 0,\, h = 1,\ldots,H</code>,
and <code class="reqn">V &gt; \sum_{h=1}^H \frac{A^2_h}{M_h} - A_0</code> are given numbers. The
minimization is on <code class="reqn">\mathbb R_+^H</code>.
The upper-bounds constraints <code class="reqn">x_h \leq M_h,\, h = 1,\ldots,H</code>, are
optional and can be skipped. In such a case, it is only required that
<code class="reqn">V &gt; 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optcost(V, A, A0, M = NULL, unit_costs = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optcost_+3A_v">V</code></td>
<td>
<p>(<code>number</code>)<br /> parameter <code class="reqn">V</code> of the equality constraint. A
strictly positive scalar. If <code>M</code> is not <code>NULL</code>, it is then required that
<code>V &gt;= sum(A^2/M) - A0</code>.</p>
</td></tr>
<tr><td><code id="optcost_+3A_a">A</code></td>
<td>
<p>(<code>numeric</code>)<br /> population constants <code class="reqn">A_1,\ldots,A_H</code>. Strictly
positive numbers.</p>
</td></tr>
<tr><td><code id="optcost_+3A_a0">A0</code></td>
<td>
<p>(<code>number</code>)<br /> population constant <code class="reqn">A_0</code>.</p>
</td></tr>
<tr><td><code id="optcost_+3A_m">M</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> upper bounds <code class="reqn">M_1,\ldots,M_H</code>,
optionally imposed on sample sizes in strata. If no upper bounds should be
imposed, then <code>M</code> must be set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="optcost_+3A_unit_costs">unit_costs</code></td>
<td>
<p>(<code>numeric</code>)<br /> costs <code class="reqn">c_1,\ldots,c_H</code>, of surveying one
element in stratum. A strictly positive numbers. Can be also of length 1,
if all unit costs are the same for all strata. In this case, the elements
will be recycled to the length of <code>bounds</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm that is used by <code>optcost()</code> is the <code>LRNA</code> and it is
described in Wójciak (2023). The allocation computed is valid for all
stratified sampling schemes for which the variance of the stratified
estimator is of the form:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{h=1}^H \frac{A^2_h}{x_h} - A_0,</code>
</p>

<p>where <code class="reqn">H</code> denotes total number of strata, <code class="reqn">x_1,\ldots,x_H</code> are
strata sample sizes and <code class="reqn">A_0,\, A_h &gt; 0,\, h = 1,\ldots,H</code>, do not
depend on <code class="reqn">x_h,\, h = 1,\ldots,H</code>.
</p>


<h3>Value</h3>

<p>Numeric vector with optimal sample allocations in strata.
</p>


<h3>Note</h3>

<p>For <em>stratified <code class="reqn">\pi</code> estimator</em> of the population total and
for <em>stratified simple random sampling without replacement</em> design,
the population parameters are as follows:
</p>
<p style="text-align: center;"><code class="reqn">A_h = N_h S_h, \quad h = 1,\ldots,H,</code>
</p>

<p style="text-align: center;"><code class="reqn">A_0 = \sum_{h=1}^H N_h S_h^2,</code>
</p>

<p>where <code class="reqn">N_h</code> is the size of stratum <code class="reqn">h</code> and <code class="reqn">S_h</code> denotes
standard deviation of a given study variable in stratum <code class="reqn">h</code>.
</p>


<h3>References</h3>

<p>Wójciak, W. (2023).
Another Solution of Some Optimum Allocation Problem.
<em>Statistics in Transition new series</em>, 24(5) (in press).
<a href="https://arxiv.org/abs/2204.04035">https://arxiv.org/abs/2204.04035</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rna">rna()</a></code>, <code><a href="#topic+opt">opt()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- c(3000, 4000, 5000, 2000)
M &lt;- c(100, 90, 70, 80)
xopt &lt;- optcost(1017579, A = A, A0 = 579, M = M)
xopt
</code></pre>

<hr>
<h2 id='pop10_mM'>Example Population with 10 Strata and Lower and Upper Bounds</h2><span id='topic+pop10_mM'></span>

<h3>Description</h3>

<p>A dataset containing the artificial population with 10 strata.
Additionally, the lower and upper bounds for samples in strata are
specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop10_mM
</code></pre>


<h3>Format</h3>

<p>A matrix with 10 rows and 5 variables:
</p>

<dl>
<dt>N</dt><dd><p>stratum size</p>
</dd>
<dt>S</dt><dd><p>standard deviation of study variable in stratum</p>
</dd>
<dt>m</dt><dd><p>lower bound for sample size in stratum</p>
</dd>
<dt>M</dt><dd><p>upper bound for sample size in stratum</p>
</dd>
<dt>unit_cost</dt><dd><p>cost of surveying one element in stratum</p>
</dd>
</dl>


<hr>
<h2 id='pop507'>Example Population with 507 Strata</h2><span id='topic+pop507'></span>

<h3>Description</h3>

<p>A dataset containing the artificial population with 507 strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop507
</code></pre>


<h3>Format</h3>

<p>A matrix with 507 rows and 3 variables:
</p>

<dl>
<dt>N</dt><dd><p>stratum size</p>
</dd>
<dt>S</dt><dd><p>standard deviation of study variable in stratum</p>
</dd>
<dt>unit_cost</dt><dd><p>cost of surveying one element in stratum</p>
</dd>
</dl>


<hr>
<h2 id='pop969'>Example Population with 969 Strata</h2><span id='topic+pop969'></span>

<h3>Description</h3>

<p>A dataset containing the artificial population with 969 strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop969
</code></pre>


<h3>Format</h3>

<p>A matrix with 969 rows and 3 variables:
</p>

<dl>
<dt>N</dt><dd><p>stratum size</p>
</dd>
<dt>S</dt><dd><p>standard deviation of study variable in stratum</p>
</dd>
<dt>unit_cost</dt><dd><p>cost of surveying one element in stratum</p>
</dd>
</dl>


<hr>
<h2 id='ran_round'>Random Rounding of Numbers</h2><span id='topic+ran_round'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>A number <code class="reqn">x</code> is rounded to integer <code class="reqn">y</code> according to the following
rule:
</p>
<p style="text-align: center;"><code class="reqn">y = \left\lfloor{x}\right\rfloor + I(u &lt; (x - \left\lfloor{x}\right\rfloor)),</code>
</p>

<p>where function <code class="reqn">I:\{TRUE, FALSE\} \to \{0, 1\}</code>, is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
 I(x) = \begin{cases}
 0,  &amp; x \text{ is } FALSE \\
 1, &amp; x \text{ is } TRUE,
 \end{cases}
</code>
</p>

<p>and <code class="reqn">u</code> is number that is generated from <code>Uniform(0, 1)</code> distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ran_round(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ran_round_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(4.5, 4.1, 4.9)
set.seed(5)
ran_round(x) # 5 4 4
set.seed(6)
ran_round(x) # 4 4 5
</code></pre>

<hr>
<h2 id='rna_prior'>RNA in version that uses prior information about violations</h2><span id='topic+rna_prior'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This is the version of the RNA that makes use of additional information
about strata for which the allocation can possibly be violated. For all other
strata allocation will not be violated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rna_prior(
  total_cost,
  A,
  bounds = NULL,
  check = NULL,
  check_violations = .Primitive("&gt;="),
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rna_prior_+3A_total_cost">total_cost</code></td>
<td>
<p>(<code>number</code>)<br /> total cost <code class="reqn">c</code> of the survey. A strictly
positive scalar.</p>
</td></tr>
<tr><td><code id="rna_prior_+3A_a">A</code></td>
<td>
<p>(<code>numeric</code>)<br /> population constants <code class="reqn">A_1,\ldots,A_H</code>. Strictly
positive numbers.</p>
</td></tr>
<tr><td><code id="rna_prior_+3A_bounds">bounds</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>) <br /> optional lower bounds
<code class="reqn">m_1,\ldots,m_H</code>, or upper bounds <code class="reqn">M_1,\ldots,M_H</code>, or <code>NULL</code> to
indicate that there is no inequality constraints in the optimization
problem considered.
If not <code>NULL</code>, the <code>bounds</code> is to be treated either as:
</p>

<ul>
<li><p> lower bounds, if <code>check_violations = .Primitive("&lt;=")</code>. In this case, it
is required that <code>total_cost &gt;= sum(unit_costs * bounds)</code>, <br />
or
</p>
</li>
<li><p> upper bounds, if <code>check_violations = .Primitive("&gt;=")</code>. In this case, it
is required that <code>total_cost &lt;= sum(unit_costs * bounds)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rna_prior_+3A_check">check</code></td>
<td>
<p>(<code>integer</code>)<br /> strata indices for which the allocation can
possible be violated. For other strata allocation cannot be violated.</p>
</td></tr>
<tr><td><code id="rna_prior_+3A_check_violations">check_violations</code></td>
<td>
<p>(<code>function</code>) <br /> 2-arguments binary operator function
that allows the comparison of values in atomic vectors. It must either be
set to <code>.Primitive("&lt;=")</code> or <code>.Primitive("&gt;=")</code>. The first of these choices
causes that <code>bounds</code> are treated as lower bounds and then <code>rna()</code> function
performs the <em>LRNA</em> algorithm. The latter option causes that <code>bounds</code>
are treated as upper bounds, and then <code>rna()</code> function performs the
<em>RNA</em> algorithm. This argument is ignored when <code>bounds</code> is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rna_prior_+3A_details">details</code></td>
<td>
<p>(<code>flag</code>) <br /> should detailed information about strata
assignments (either to take-Neyman or take-bound), values of set function
<code class="reqn">s</code> and number of iterations be added to the output?</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this coded was not extensively tested.
</p>

<hr>
<h2 id='rna_rec'>RNA - Recursive Implementation</h2><span id='topic+rna_rec'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rna_rec(
  total_cost,
  A,
  bounds = NULL,
  unit_costs = rep(1, length(A)),
  check_violations = .Primitive("&gt;=")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rna_rec_+3A_total_cost">total_cost</code></td>
<td>
<p>(<code>number</code>)<br /> total cost <code class="reqn">c</code> of the survey. A strictly
positive scalar.</p>
</td></tr>
<tr><td><code id="rna_rec_+3A_a">A</code></td>
<td>
<p>(<code>numeric</code>)<br /> population constants <code class="reqn">A_1,\ldots,A_H</code>. Strictly
positive numbers.</p>
</td></tr>
<tr><td><code id="rna_rec_+3A_bounds">bounds</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>) <br /> optional lower bounds
<code class="reqn">m_1,\ldots,m_H</code>, or upper bounds <code class="reqn">M_1,\ldots,M_H</code>, or <code>NULL</code> to
indicate that there is no inequality constraints in the optimization
problem considered.
If not <code>NULL</code>, the <code>bounds</code> is to be treated either as:
</p>

<ul>
<li><p> lower bounds, if <code>check_violations = .Primitive("&lt;=")</code>. In this case, it
is required that <code>total_cost &gt;= sum(unit_costs * bounds)</code>, <br />
or
</p>
</li>
<li><p> upper bounds, if <code>check_violations = .Primitive("&gt;=")</code>. In this case, it
is required that <code>total_cost &lt;= sum(unit_costs * bounds)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rna_rec_+3A_unit_costs">unit_costs</code></td>
<td>
<p>(<code>numeric</code>)<br /> costs <code class="reqn">c_1,\ldots,c_H</code>, of surveying one
element in stratum. A strictly positive numbers. Can be also of length 1,
if all unit costs are the same for all strata. In this case, the elements
will be recycled to the length of <code>bounds</code>.</p>
</td></tr>
<tr><td><code id="rna_rec_+3A_check_violations">check_violations</code></td>
<td>
<p>(<code>function</code>) <br /> 2-arguments binary operator function
that allows the comparison of values in atomic vectors. It must either be
set to <code>.Primitive("&lt;=")</code> or <code>.Primitive("&gt;=")</code>. The first of these choices
causes that <code>bounds</code> are treated as lower bounds and then <code>rna()</code> function
performs the <em>LRNA</em> algorithm. The latter option causes that <code>bounds</code>
are treated as upper bounds, and then <code>rna()</code> function performs the
<em>RNA</em> algorithm. This argument is ignored when <code>bounds</code> is set to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this coded was not extensively tested.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- c(3000, 4000, 5000, 2000)
M &lt;- c(100, 90, 70, 80) # upper bounds.
rna_rec(total_cost = 190, A = A, bounds = M)
rna_rec(total_cost = 312, A = A, bounds = M)
rna_rec(total_cost = 339, A = A, bounds = M)
rna_rec(total_cost = 340, A = A, bounds = M)
</code></pre>

<hr>
<h2 id='rnabox'>Recursive Neyman Algorithm for Optimal Sample Allocation Under Box Constraints</h2><span id='topic+rnabox'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>An internal function that implements the <code>RNABOX</code> algorithm that solves the
following optimal allocation problem, formulated below in the language of
mathematical optimization.
</p>
<p>Minimize
</p>
<p style="text-align: center;"><code class="reqn">f(x_1,\ldots,x_H) = \sum_{h=1}^H \frac{A^2_h}{x_h}</code>
</p>

<p>subject to
</p>
<p style="text-align: center;"><code class="reqn">\sum_{h=1}^H x_h = n</code>
</p>

<p style="text-align: center;"><code class="reqn">m_h \leq x_h \leq M_h, \quad h = 1,\ldots,H,</code>
</p>

<p>where <code class="reqn">n &gt; 0,\, A_h &gt; 0,\, m_h &gt; 0,\, M_h &gt; 0</code>, such that
<code class="reqn">m_h &lt; M_h,\, h = 1,\ldots,H</code>, and
<code class="reqn">\sum_{h=1}^H m_h \leq n \leq \sum_{h=1}^H M_h</code>, are given numbers.
The minimization is on <code class="reqn">\mathbb R_+^H</code>.
Inequality constraints are optional and can be skipped.
</p>
<p><code>rnabox()</code> function should not be called directly by the user. Use <code><a href="#topic+opt">opt()</a></code>
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnabox(
  n,
  A,
  bounds1 = NULL,
  bounds2 = NULL,
  check_violations1 = .Primitive("&gt;="),
  check_violations2 = .Primitive("&lt;=")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnabox_+3A_n">n</code></td>
<td>
<p>(<code>number</code>)<br /> total sample size. A strictly positive scalar.
If <code>bounds1</code> is not <code>NULL</code>, it is then required that <code>n &gt;= sum(bounds1)</code>
(given that <code>bounds1</code> are treated as lower bounds) or <code>n &lt;= sum(bounds1)</code>
(given that <code>bounds1</code> are treated as upper bounds).
If <code>bounds2</code> is not <code>NULL</code>, it is then required that <code>n &gt;= sum(bounds2)</code>
(given that <code>bounds2</code> are treated as lower bounds) or <code>n &lt;= sum(bounds2)</code>
(given that <code>bounds2</code> are treated as upper bounds).</p>
</td></tr>
<tr><td><code id="rnabox_+3A_a">A</code></td>
<td>
<p>(<code>numeric</code>)<br /> population constants <code class="reqn">A_1,\ldots,A_H</code>. Strictly
positive numbers.</p>
</td></tr>
<tr><td><code id="rnabox_+3A_bounds1">bounds1</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> lower bounds <code class="reqn">m_1,\ldots,m_H</code>,
or upper bounds <code class="reqn">M_1,\ldots,M_H</code> optionally imposed on sample sizes in
strata. The interpretation of <code>bounds1</code> depends on the value of
<code>check_violations1</code>. If no one-sided bounds 1 should be imposed, then
<code>bounds1</code> must be set to <code>NULL</code>. If <code>bounds2</code> is not <code>NULL</code>, it is then
required that either <code>bounds1 &lt; bounds2</code> (in case when <code>bounds1</code> is treated
as lower bounds) or <code>bounds1 &gt; bounds2</code> (in the opposite case).</p>
</td></tr>
<tr><td><code id="rnabox_+3A_bounds2">bounds2</code></td>
<td>
<p>(<code>numeric</code> or <code>NULL</code>)<br /> lower bounds <code class="reqn">m_1,\ldots,m_H</code>,
or upper bounds <code class="reqn">M_1,\ldots,M_H</code> optionally imposed on sample sizes in
strata. The interpretation of <code>bounds2</code> depends on the value of
<code>check_violations2</code>. If no one-sided bounds 2 should be imposed, then
<code>bounds2</code> must be set to <code>NULL</code>. If <code>bounds2</code> is not <code>NULL</code>, it is then
required that either <code>bounds1 &lt; bounds2</code> (in case when <code>bounds1</code> is treated
as lower bounds) or <code>bounds1 &gt; bounds2</code> (in the opposite case).</p>
</td></tr>
<tr><td><code id="rnabox_+3A_check_violations1">check_violations1</code></td>
<td>
<p>(<code>function</code>) <br /> 2-arguments binary operator function
that allows the comparison of values in atomic vectors. It must either be
set to <code>.Primitive("&lt;=")</code> or <code>.Primitive("&gt;=")</code>.
The first of these choices causes that <code>bounds1</code> are treated as lower
bounds and the <code>rnabox()</code> uses the <em>LRNA</em> algorithm as in interim
algorithm for the allocation problem with one-sided lower bounds <code>bounds1</code>.
The latter option causes that <code>bounds1</code> are treated as upper bounds and the
<code>rnabox()</code> uses the <em>RNA</em> algorithm as in interim algorithm for the
allocation problem with one-sided upper bounds <code>bounds1</code>.
This parameter is correlated with <code>check_violations2</code>. That is, these
arguments must be set against each other.
<code>check_violations1</code> is ignored when <code>bounds1</code> is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rnabox_+3A_check_violations2">check_violations2</code></td>
<td>
<p>(<code>function</code>) <br /> 2-arguments binary operator function
that allows the comparison of values in atomic vectors. It must either be
set to <code>.Primitive("&lt;=")</code> or <code>.Primitive("&gt;=")</code>.
The first of these choices causes that <code>bounds2</code> are treated as lower
bounds and the <code>rnabox()</code> uses the <em>LRNA</em> algorithm as in interim
algorithm for the allocation problem with one-sided lower bounds <code>bounds2</code>.
The latter option causes that <code>bounds2</code> are treated as upper bounds and the
<code>rnabox()</code> uses the <em>RNA</em> algorithm as in interim algorithm for the
allocation problem with one-sided upper bounds <code>bounds2</code>.
This parameter is correlated with <code>check_violations1</code>. That is, these
arguments must be set against each other.
<code>check_violations2</code> is ignored when <code>bounds2</code> is set to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with optimal sample allocations in strata.
</p>


<h3>References</h3>

<p>To be added soon.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt">opt()</a></code>, <code><a href="#topic+optcost">optcost()</a></code>, <code><a href="#topic+sga">sga()</a></code>, <code><a href="#topic+sgaplus">sgaplus()</a></code>, <code><a href="#topic+coma">coma()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- c(454, 10, 116, 2500, 2240, 260, 39, 3000, 2500, 400)
S &lt;- c(0.9, 5000, 32, 0.1, 3, 5, 300, 13, 20, 7)
A &lt;- N * S
m &lt;- c(322, 3, 57, 207, 715, 121, 9, 1246, 1095, 294) # lower bounds
M &lt;- N # upper bounds

# Regular allocation.
n &lt;- 6000
opt_regular &lt;- rnabox(n, A, M, m)

# Vertex allocation.
n &lt;- 4076
opt_vertex &lt;- rnabox(n, A, M, m)
</code></pre>

<hr>
<h2 id='round_oric'>Optimal Rounding under Integer Constraints</h2><span id='topic+round_oric'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_oric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_oric_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>References</h3>

<p>Cont, R., Heidari, M. (2014).
Optimal rounding under integer constraints.
<a href="https://doi.org/10.48550/arXiv.1501.00014">doi:10.48550/arXiv.1501.00014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(4.5, 4.1, 4.9)
round_oric(x) # 4 4 5
</code></pre>

<hr>
<h2 id='SimpleGreedy'>Integer-valued Optimal Univariate Allocation Under Constraints for Stratified
Sampling</h2><span id='topic+SimpleGreedy'></span><span id='topic+SimpleGreedy2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Simple algorithm from paper Friedrich et al. (2015) for integer-valued
optimal allocation in stratified sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimpleGreedy(
  n,
  Ah,
  mh = rep(1, length(Ah)),
  Mh = rep(Inf, length(Ah)),
  nh = mh
)

SimpleGreedy2(v0, Nh, Sh, mh = rep(1, length(Nh)), Mh = Nh, nh = mh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimpleGreedy_+3A_n">n</code></td>
<td>

<ul>
<li><p> target sample size for allocation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SimpleGreedy_+3A_ah">Ah</code></td>
<td>

<ul>
<li><p> population strata sizes * standard deviations of a given variable in strata.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SimpleGreedy_+3A_mh">mh</code></td>
<td>

<ul>
<li><p> lower constraints for sample sizes in strata.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SimpleGreedy_+3A_mh">Mh</code></td>
<td>

<ul>
<li><p> upper constraints for sample sizes in strata.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SimpleGreedy_+3A_nh">nh</code></td>
<td>

<ul>
<li><p> initial allocation (if not given then nh=mh).
</p>
</li></ul>
</td></tr>
<tr><td><code id="SimpleGreedy_+3A_v0">v0</code></td>
<td>

<ul>
<li><p> upper limit for value of variance which must be attained for
computed optimal allocation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SimpleGreedy_+3A_nh">Nh</code></td>
<td>

<ul>
<li><p> population strata sizes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SimpleGreedy_+3A_sh">Sh</code></td>
<td>

<ul>
<li><p> standard deviations of a given variable in strata.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of optimal allocation sizes.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>SimpleGreedy2()</code>: 
</p>
</li></ul>


<h3>References</h3>

<p>Friedrich, U., Münnich, R., de Vries, S. and Wagner, M. (2015)
Fast integer-valued algorithms for optimal allocations under constraints in
stratified sampling,
<em>Computational Statistics and Data Analysis</em>, 92, pp. 1–12.
<a href="https://www.sciencedirect.com/science/article/pii/S0167947315001413">https://www.sciencedirect.com/science/article/pii/S0167947315001413</a>
</p>

<hr>
<h2 id='var_st'>Variance of the Stratified Estimator</h2><span id='topic+var_st'></span><span id='topic+var_st_tsi'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#stable"><img src="../help/figures/lifecycle-stable.svg" alt='[Stable]' /></a>
</p>
<p>Compute the value of the variance function <code class="reqn">V</code> of the stratified
estimator, which is of the following generic form:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{h=1}^H \frac{A^2_h}{x_h} - A_0,</code>
</p>

<p>where <code class="reqn">H</code> denotes total number of strata, <code class="reqn">x_1,\ldots,x_H</code> are strata
sample sizes and <code class="reqn">A_0,\, A_h &gt; 0,\, h = 1,\ldots,H</code>, are population
constants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_st(x, A, A0)

var_st_tsi(x, N, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_st_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>)<br /> sample allocations <code class="reqn">x_1,\ldots,x_H</code> in strata.</p>
</td></tr>
<tr><td><code id="var_st_+3A_a">A</code></td>
<td>
<p>(<code>numeric</code>)<br /> population constants <code class="reqn">A_1,\ldots,A_H</code>.</p>
</td></tr>
<tr><td><code id="var_st_+3A_a0">A0</code></td>
<td>
<p>(<code>number</code>)<br /> population constant <code class="reqn">A_0</code>.</p>
</td></tr>
<tr><td><code id="var_st_+3A_n">N</code></td>
<td>
<p>(<code>numeric</code>)<br /> strata sizes <code class="reqn">N_1,\ldots,N_H</code>.</p>
</td></tr>
<tr><td><code id="var_st_+3A_s">S</code></td>
<td>
<p>(<code>numeric</code>)<br /> strata standard deviations of a given study variable
<code class="reqn">S_1,\ldots,S_H</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the variance <code class="reqn">V</code> for a given allocation vector
<code class="reqn">x_1,\ldots,x_H</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>var_st_tsi()</code>: computes value of variance <code class="reqn">V</code> for the case of
<em>stratified <code class="reqn">\pi</code> estimator</em> of the population total and
<em>stratified simple random sampling without replacement</em> design. This
particular case yields:
</p>
<p style="text-align: center;"><code class="reqn">A_h = N_h S_h, \quad h = 1,\ldots,H,</code>
</p>

<p style="text-align: center;"><code class="reqn">A_0 = \sum_{h=1}^H N_h S_h^2,</code>
</p>

<p>where <code class="reqn">N_h</code> is the size of stratum <code class="reqn">h</code>, and <code class="reqn">S_h</code> is stratum
standard deviation of a study variable, <code class="reqn">h = 1,\ldots,H</code>.
</p>
</li></ul>


<h3>References</h3>

<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992).
<em>Model Assisted Survey Sampling</em>,
Chapter 3.7 <em>Stratified Sampling</em>,
Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- c(3000, 4000, 5000, 2000)
S &lt;- rep(1, 4)
M &lt;- c(100, 90, 70, 80)
xopt &lt;- opt(n = 190, A = N * S, M = M)
var_st_tsi(x = xopt, N, S) # 1017579
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
