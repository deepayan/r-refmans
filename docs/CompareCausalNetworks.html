<!DOCTYPE html><html><head><title>Help for package CompareCausalNetworks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CompareCausalNetworks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CompareCausalNetworks-package'>
<p>Compare estimates of causal graphs using a unified interface to various methods</p></a></li>
<li><a href='#getParents'><p>Estimate the connectivity matrix of a causal graph</p></a></li>
<li><a href='#getParentsStable'><p>Estimate the connectivity matrix of a causal graph using stability selection.</p></a></li>
<li><a href='#getRanking'><p>Estimate a ranking of edges for causal relations in the underlying graph structure</p>
using stability ranking.</a></li>
<li><a href='#simDataInv'><p>Data from a causal model with interventions</p></a></li>
<li><a href='#simulateInterventions'><p>Simulate data of a causal (possibly cyclic model) under interventions.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface to Diverse Estimation Methods of Causal Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Heinze-Deml &lt;heinzedeml@stat.math.ethz.ch&gt;,
    Nicolai Meinshausen &lt;meinshausen@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Matrix, expm, data.table</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christina Heinze-Deml &lt;heinzedeml@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Unified interface for the estimation of causal networks, including
    the methods 'backShift' (from package 'backShift'), 'bivariateANM' (bivariate
    additive noise model), 'bivariateCAM' (bivariate causal additive model),
    'CAM' (causal additive model) (from package 'CAM'; the package is 
    temporarily unavailable on the CRAN repository; formerly available versions 
    can be obtained from the archive), 'hiddenICP' (invariant
    causal prediction with hidden variables), 'ICP' (invariant causal prediction)
    (from package 'InvariantCausalPrediction'), 'GES' (greedy equivalence
    search), 'GIES' (greedy interventional equivalence search), 'LINGAM', 'PC' (PC
    Algorithm), 'FCI' (fast causal inference), 
    'RFCI' (really fast causal inference) (all from package 'pcalg') and
    regression.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pcalg, InvariantCausalPrediction, glmnet, backShift, CAM,
kernlab, mgcv, mboost, bnlearn, testthat, huge, flare</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/christinaheinze/CompareCausalNetworks">https://github.com/christinaheinze/CompareCausalNetworks</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/christinaheinze/CompareCausalNetworks/issues">https://github.com/christinaheinze/CompareCausalNetworks/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-17 10:26:10 UTC; heinzec</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-17 19:00:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='CompareCausalNetworks-package'>
Compare estimates of causal graphs using a unified interface to various methods
</h2><span id='topic+CompareCausalNetworks-package'></span><span id='topic+CompareCausalNetworks'></span>

<h3>Description</h3>

<p>Provides a unified interface to various causal graph estimation methods.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CompareCausalNetworks</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-05-18</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The causal graphs can be estimated with function <code><a href="#topic+getParents">getParents</a></code> 
and a stability-selection version is available at <code><a href="#topic+getParentsStable">getParentsStable</a></code>. 
</p>
<p>The supported methods are provided through the packages listed in <code>Suggests</code>. 
Thus, to use a particular method the corresponding package needs to be installed 
on your machine. To run the examples, most of these packages need to be installed.
</p>


<h3>Author(s)</h3>

<p>Christina Heinze-Deml &lt;heinzedeml@stat.math.ethz.ch&gt;, 
Nicolai Meinshausen &lt;meinshausen@stat.math.ethz.ch&gt;
</p>

<hr>
<h2 id='getParents'>Estimate the connectivity matrix of a causal graph</h2><span id='topic+getParents'></span>

<h3>Description</h3>

<p>Estimates the connectivity matrix of a directed causal graph, 
using various possible methods. Supported methods at the moment are ARGES,
backShift, bivariateANM, bivariateCAM, CAM, FCI, FCI+, GES, GIES, hiddenICP, 
ICP, LINGAM, MMHC, rankARGES, rankFci, rankGES, rankGIES, rankPC, 
regression, RFCI and PC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParents(
  X,
  environment = NULL,
  interventions = NULL,
  parentsOf = 1:ncol(X),
  method = c("arges", "backShift", "bivariateANM", "bivariateCAM", "CAM", "fci",
    "fciplus", "ges", "gies", "hiddenICP", "ICP", "LINGAM", "mmhc", "rankArges",
    "rankFci", "rankGes", "rankGies", "rankPc", "rfci", "pc", "regression")[12],
  alpha = 0.1,
  mode = c("raw", "parental", "ancestral")[1],
  variableSelMat = NULL,
  excludeTargetInterventions = TRUE,
  onlyObservationalData = FALSE,
  indexObservationalData = 1,
  returnAsList = FALSE,
  sparse = FALSE,
  directed = FALSE,
  pointConf = FALSE,
  setOptions = list(),
  assumeNoSelectionVars = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParents_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">(n</code> x <code class="reqn">p)</code>-data matrix with n observations of  <code class="reqn">p</code> variables.</p>
</td></tr>
<tr><td><code id="getParents_+3A_environment">environment</code></td>
<td>
<p>An optional vector of length <code class="reqn">n</code>, where the entry for 
observation <code class="reqn">i</code> is an index for the environment in which observation <code class="reqn">i</code> took 
place (Simplest case: entries <code>1</code> for observational data and entries
<code>2</code> for interventional data of unspecified type. Encoding for observational
data can be changed with <code>indexObservationalData</code>). Is required for 
methods <code>ICP</code>, <code>hiddenICP</code> and <code>backShift</code>.</p>
</td></tr>
<tr><td><code id="getParents_+3A_interventions">interventions</code></td>
<td>
<p>A optional list of length <code class="reqn">n</code>. The entry for observation
<code class="reqn">i</code> is a numeric vector that specifies the variables on which interventions 
happened for observation <code class="reqn">i</code> (a scalar if an intervention happened on just 
one variable and <code>integer(0)</code> if no intervention occured for this 
observation). Is used for methods <code>gies</code>, <code>rankGies</code> and <code>CAM</code> and will 
generate the vector <code>environment</code> if the latter is set to <code>NULL</code>.
(However, this might generate too many different environments for some data 
sets, so a hand-picked vector <code>environment</code> is preferable). Is also used 
for <code>ICP</code> and <code>hiddenICP</code> to exclude interventions on the target 
variable of interest.</p>
</td></tr>
<tr><td><code id="getParents_+3A_parentsof">parentsOf</code></td>
<td>
<p>The variables for which we would like to estimate the 
parents. Default are all variables. Currently only used with <code>mode = "raw"</code>. 
Speeds up computation for methods <code>bivariateANM</code>,
<code>bivariateCAM</code>, <code>ICP</code>, <code>hiddenICP</code> and <code>regression</code>; 
for other methods only affects output. Also see <code>variableSelMat</code> for possibly
speeding up computational time by restricting the set of potential parents
for a variable.</p>
</td></tr>
<tr><td><code id="getParents_+3A_method">method</code></td>
<td>
<p>A string that specfies the method to use. The methods 
<code>pc</code> (PC-algorithm), <code>LINGAM</code> (LINGAM), <code>arges</code> (Adaptively 
restricted greedy equivalence search), <code>ges</code> 
(Greedy equivalence search), <code>gies</code> (Greedy interventional equivalence 
search),  <code>fci</code> (Fast causal inference), <code>fciplus</code>  
and <code>rfci</code> (Really fast causal inference) are imported from the 
package &quot;pcalg&quot; and are documented there in more detail, including the 
additional options that can be supplied via <code>setOptions</code>. 
The &quot;rank versions&quot; of arges, fci, ges, gies and pc are based on [1]. The method 
<code>CAM</code> (Causal additive models) is documented in the package &quot;CAM&quot; and 
the methods <code>ICP</code> (Invariant causal prediction), <code>hiddenICP</code> 
(Invariant causal prediction with hidden variables) are from the package 
&quot;InvariantCausalPrediction&quot;. The method <code>backShift</code> comes from the 
package &quot;backShift&quot;. The method <code>mmhc</code> comes from the 
package &quot;bnlearn&quot;. Finally, the methods <code>bivariateANM</code> and 
<code>bivariateCAM</code> are for now implemented internally but will hopefully 
be part of another package at some point in the near future.</p>
</td></tr>
<tr><td><code id="getParents_+3A_alpha">alpha</code></td>
<td>
<p>The level at which tests are done. This leads to confidence 
intervals for <code>ICP</code> and <code>hiddenICP</code> and is used internally for 
<code>pc</code>, <code>rankPc</code>, <code>mmhc</code>, <code>fci</code>, <code>rankFci</code>, <code>fciplus</code>
and <code>rfci</code>. For all other methods <code>alpha</code> is not used.</p>
</td></tr>
<tr><td><code id="getParents_+3A_mode">mode</code></td>
<td>
<p>Determines output type - can be &quot;raw&quot; or one of the queries &quot;isParent&quot;, 
&quot;isMaybeParent&quot;, &quot;isNoParent&quot;, &quot;isAncestor&quot;,&quot;isMaybeAncestor&quot;, &quot;isNoAncestor&quot;.
If &quot;raw&quot;, <code>getParents()</code> returns the connectivity matrix computed by the
specified method in sparse matrix format if <code>sparse</code> is set to <code>TRUE</code>; 
else in dense matrix format (or as list if <code>returnAsList = TRUE</code>). 
The options <code>directed</code> and  <code>pointConf</code> will be ignored for 
all modes except for &quot;raw&quot; if set to <code>TRUE</code>. The different mode types
are explained in the help for <code><a href="#topic+getRanking">getRanking</a></code>.</p>
</td></tr>
<tr><td><code id="getParents_+3A_variableselmat">variableSelMat</code></td>
<td>
<p>An optional logical matrix of dimension  <code class="reqn">(p</code> x <code class="reqn">p)</code>. An 
entry <code>TRUE</code> for entry <code class="reqn">(i,j)</code> says that variable <code class="reqn">i</code> should be considered 
as a potential parent for variable <code class="reqn">j</code> and vice versa for <code>FALSE</code>. If the 
default value of <code>NULL</code> is used, all variables will be considered, but 
this can be very slow, especially for methods <code>pc</code>, <code>ges</code>, 
<code>gies</code>, <code>rfci</code> and <code>CAM</code>. Ignored for methods <code>backShift</code>, 
<code>fciplus</code>, <code>LINGAM</code> and <code>CAM</code>.</p>
</td></tr>
<tr><td><code id="getParents_+3A_excludetargetinterventions">excludeTargetInterventions</code></td>
<td>
<p>When looking for parents of variable <code class="reqn">k</code> 
in <code class="reqn">1,...,p</code>, set to <code>TRUE</code> if observations where an intervention on 
variable <code class="reqn">k</code> occured should be excluded. Default is <code>TRUE</code>. Used
in  <code>ICP</code> and <code>hiddenICP</code>.</p>
</td></tr>
<tr><td><code id="getParents_+3A_onlyobservationaldata">onlyObservationalData</code></td>
<td>
<p>If set to <code>TRUE</code>, only observational data 
is used. It will take the index in <code>environment</code> specified by 
<code>indexObservationalData</code>. If <code>environment</code> is <code>NULL</code>, all 
observations are used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getParents_+3A_indexobservationaldata">indexObservationalData</code></td>
<td>
<p>Index in <code>environment</code> that encodes 
observational data. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="getParents_+3A_returnaslist">returnAsList</code></td>
<td>
<p>If set to <code>TRUE</code>, will return a list, where entry 
<code class="reqn">k</code> is a list containing the estimated parents of variable <code class="reqn">k</code>. 
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getParents_+3A_sparse">sparse</code></td>
<td>
<p>If set to <code>TRUE</code> and <code>returnAsList</code> is <code>FALSE</code>,
output matrix will be in sparse matrix format.</p>
</td></tr>
<tr><td><code id="getParents_+3A_directed">directed</code></td>
<td>
<p>If <code>TRUE</code>, an edge will be returned if and only if an 
edge has been detected to be directed. I.e. entry will be set to 0 for entry 
<code class="reqn">(j,k)</code> if both <code class="reqn">j -&gt; k</code> and <code class="reqn">k -&gt; j</code> are estimated 
(<code>ICP</code>, <code>hiddenICP</code>, <code>regression</code>), if <code class="reqn">j -- k</code> is undirected 
(in case of CPDAGs) or if the edge type is not of type <code class="reqn">i --&gt; j</code> in case of 
PAGs. If <code>assumeNoSelectionVars = TRUE</code> the edge type <code class="reqn">i --o j</code> is also 
considered 'directed' for methods returning PAGs.  Default is <code>FALSE</code>. 
Only supported in mode &quot;raw&quot;.</p>
</td></tr>
<tr><td><code id="getParents_+3A_pointconf">pointConf</code></td>
<td>
<p>If <code>TRUE</code>, numerical estimates will be returned if 
possible. For methods <code>ICP</code> and <code>hiddenICP</code>, these are the values 
in the individual confidence intervals (at chosen level <code>alpha</code>) that 
are closest to 0; for other methods these are point estimates. Some methods 
do not return numerical point estimates; for these the output will remain 
binary 0/1 (no-edge/edge). Default is <code>FALSE</code>. Only supported in mode &quot;raw&quot;.</p>
</td></tr>
<tr><td><code id="getParents_+3A_setoptions">setOptions</code></td>
<td>
<p>A list that can take method-specific options; see the 
individual documentations of the methods for more options and their 
possible values.</p>
</td></tr>
<tr><td><code id="getParents_+3A_assumenoselectionvars">assumeNoSelectionVars</code></td>
<td>
<p>Set to <code>TRUE</code> is you want to assume the absence 
of selection variables.</p>
</td></tr>
<tr><td><code id="getParents_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
<tr><td><code id="getParents_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to underlying method's function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If option <code>returnAsList</code> is <code>FALSE</code>, a sparse matrix, 
where a 0 entry in position (j,k) corresponds to an estimate of &quot;no edge&quot; 
<code>j</code> -&gt; <code>k</code>, while an entry 1 corresponds to an 
estimated egde. If option <code>pointConf</code> is <code>TRUE</code>, the 1 entries 
will be replaced by numerical values that are either point estimates of the 
causal coefficients or confidence bounds (see above). 
If option <code>returnAsList</code> is <code>TRUE</code>, a list will be returned. 
The k-th entry in the list is the numeric vector with the indices of the 
estimated parents of node <code>k</code>.
</p>


<h3>Author(s)</h3>

<p>Christina Heinze-Deml <a href="mailto:heinzedeml@stat.math.ethz.ch">heinzedeml@stat.math.ethz.ch</a>, 
Nicolai Meinshausen <a href="mailto:meinshausen@stat.math.ethz.ch">meinshausen@stat.math.ethz.ch</a>
</p>


<h3>References</h3>


<ol>
<li><p> Naftali Harris and Mathias Drton: PC Algorithm for Nonparanormal 
Graphical Models. J. Mach. Learn. Res. 14(1) 2013.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+getParentsStable">getParentsStable</a></code> for stability selection-based 
estimation of the causal graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the backShift package for data generation and plotting functionality
if(require(backShift) &amp; require(pcalg)){
  # Simulate data with connectivity matrix A with assumptions
  # 1) hidden variables present
  # 2) precise location of interventions is assumed unknown
  # 3) different environments can be distinguished
  
  ## simulate data
  myseed &lt;- 1
  
  # sample size n
  n &lt;- 10000
  
  # p=3 predictor variables and connectivity matrix A
  p &lt;- 3
  labels &lt;- c("1", "2", "3")
  A &lt;- diag(p)*0
  A[1,2] &lt;- 0.8
  A[2,3] &lt;- 0.8
  A[3,1] &lt;- -0.4
  
  # divide data in 10 different environments
  G &lt;- 10
  
  # simulate
  simResult &lt;- backShift::simulateInterventions(n, p, A, G, intervMultiplier = 3,
               noiseMult = 1, nonGauss = TRUE, hiddenVars = TRUE,
               knownInterventions = FALSE, fracVarInt = NULL, simulateObs = TRUE,
               seed = myseed)
  X &lt;- simResult$X
  environment &lt;- simResult$environment
  
  ## apply all  methods given in vector 'methods'
  ## (using all data pooled for pc/LINGAM/rfci/ges -- can be changed with option
  ## 'onlyObservationalData=TRUE')
  
  methods &lt;- c("backShift", "LINGAM") #c("pc", "rfci", "ges")
  
  # select whether you want to run stability selection
  stability &lt;- FALSE
  
  # arrange graphical output into a rectangular grid
  sq &lt;- ceiling(sqrt(length(methods)+1))
  par(mfrow=c(ceiling((length(methods)+1)/sq),sq))
  
  ## plot and print true graph
  cat("\n true graph is  ------  \n" )
  print(A)
  plotGraphEdgeAttr(A, plotStabSelec = FALSE, labels = labels, thres.point = 0,
   main = "TRUE GRAPH")
  
  ## loop over all methods and compute and print/plot estimate
  for (method in methods){
    cat("\n result for method", method,"  ------  \n" )
  
    if(!stability){
      # Option 1): use this estimator as a point estimate
      Ahat &lt;- getParents(X, environment, method=method, alpha=0.1, pointConf = TRUE)
    }else{
      # Option 2): use a stability selection based estimator
      # with expected number of false positives bounded by EV=2
      Ahat &lt;- getParentsStable(X, environment, EV=2, method=method, alpha=0.1)
    }
  
   # print and plot estimate (point estimate thresholded if numerical estimates
   # are returned)
    print(Ahat)
    if(!stability)
      plotGraphEdgeAttr(Ahat, plotStabSelec = FALSE, labels = labels,
       thres.point = 0.05,
       main=paste("POINT ESTIMATE FOR METHOD\n", toupper(method)))
    else
      plotGraphEdgeAttr(Ahat, plotStabSelec = TRUE, labels = labels,
       thres.point = 0, main = paste("STABILITY SELECTION
       ESTIMATE\n FOR METHOD", toupper(method)))
   }
}else{
    cat("\nThe packages 'backShift' and 'pcalg' are needed for the examples to
work. Please install them.")
}
 

 
</code></pre>

<hr>
<h2 id='getParentsStable'>Estimate the connectivity matrix of a causal graph using stability selection.</h2><span id='topic+getParentsStable'></span>

<h3>Description</h3>

<p>Estimates the connectivity matrix of a directed causal graph, 
using various possible methods. Supported methods at the moment are  ARGES,
backShift, bivariateANM, bivariateCAM, CAM, FCI, FCI+, GES, GIES, hiddenICP, 
ICP, LINGAM, MMHC, rankARGES, rankFci, rankGES, rankGIES, rankPC, 
regression, RFCI and PC.
Uses stability selection to select an appropriate sparseness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParentsStable(
  X,
  environment,
  interventions = NULL,
  EV = 1,
  nodewise = TRUE,
  threshold = 0.75,
  nsim = 100,
  sampleSettings = 1/sqrt(2),
  sampleObservations = 1/sqrt(2),
  parentsOf = 1:ncol(X),
  method = c("ICP", "hiddenICP", "backShift", "pc", "LINGAM", "ges", "gies", "CAM",
    "fci", "rfci", "regression", "bivariateANM", "bivariateCAM")[1],
  alpha = 0.1,
  mode = c("raw", "parental", "ancestral")[1],
  variableSelMat = NULL,
  excludeTargetInterventions = TRUE,
  onlyObservationalData = FALSE,
  indexObservationalData = NULL,
  setOptions = list(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParentsStable_+3A_x">X</code></td>
<td>
<p>A (nxp)-data matrix with n observations of p variables.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_environment">environment</code></td>
<td>
<p>A vector of length n, where the entry for 
observation i is an index for the environment in which observation i took 
place (simplest case entries <code>1</code> for observational data and entries
<code>2</code> for interventional data of unspecified type). Is required for 
methods <code>ICP</code>, <code>hiddenICP</code>, <code>backShift</code>.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_interventions">interventions</code></td>
<td>
<p>A optional list of length n. The entry for observation
i is a numeric vector that specifies the variables on which interventions 
happened for observation i (a scalar if an intervention happened on just 
one variable and <code>numeric(0)</code> if no intervention occured for this 
observation). Is used for method <code>gies</code> but will generate the vector 
<code>environment</code> if this is set to <code>NULL</code> (even though it might 
generate too many different environments for some data so a hand-picked 
vector <code>environment</code> is preferable). Is also used for <code>ICP</code> and 
<code>hiddenICP</code> to exclude interventions on the target variable of 
interest.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_ev">EV</code></td>
<td>
<p>A bound on the expected number of falsely selected edges.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_nodewise">nodewise</code></td>
<td>
<p>If <code>FALSE</code>, stability selection retains for each 
subsample the largest overall entries in the connectivity matrix. 
If <code>TRUE</code>, values are ordered row- and node-wise first and then the 
largest entries in each row and column are retained. Error control is 
valid (under exchangeability assumption) in both cases. The latter setting 
<code>TRUE</code> is perhaps more robust and is the default.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_threshold">threshold</code></td>
<td>
<p>The empirical selection frequency in (0.5,1) under 
subsampling that needs to be surpassed for an edge to be selected.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_nsim">nsim</code></td>
<td>
<p>The number of resamples for stability selection.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_samplesettings">sampleSettings</code></td>
<td>
<p>The fraction of different environments to resample 
in each resampling (at least two different environments will be selected so 
the argument is without effect if there are just two different environments 
in total).</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_sampleobservations">sampleObservations</code></td>
<td>
<p>The fraction of samples to resample in each 
environment.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_parentsof">parentsOf</code></td>
<td>
<p>The variables for which we would like to estimate the 
parents. Default are all variables.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_method">method</code></td>
<td>
<p>A string that specfies the method to use. The methods 
<code>pc</code> (PC-algorithm), <code>LINGAM</code> (LINGAM), <code>arges</code> (Adaptively 
restricted greedy equivalence search), <code>ges</code> 
(Greedy equivalence search), <code>gies</code> (Greedy interventional equivalence 
search),  <code>fci</code> (Fast causal inference)  
and <code>rfci</code> (Really fast causal inference) are imported from the 
package &quot;pcalg&quot; and are documented there in more detail, including the 
additional options that can be supplied via <code>setOptions</code>. The method 
<code>CAM</code> (Causal additive models) is documented in the package &quot;CAM&quot; and 
the methods <code>ICP</code> (Invariant causal prediction), <code>hiddenICP</code> 
(Invariant causal prediction with hidden variables) are from the package 
&quot;InvariantCausalPrediction&quot;. The method <code>backShift</code> comes from the 
package &quot;backShift&quot;. The method <code>mmhc</code> comes from the 
package &quot;bnlearn&quot;. 
Finally, the methods <code>bivariateANM</code> and 
<code>bivariateCAM</code> are for now implemented internally but will hopefully 
be part of another package at some point in the near future.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_alpha">alpha</code></td>
<td>
<p>The level at which tests are done. This leads to confidence 
intervals for <code>ICP</code> and <code>hiddenICP</code> and is used internally for 
<code>pc</code> and <code>rfci</code>.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_mode">mode</code></td>
<td>
<p>Output type - can be &quot;raw&quot;, &quot;parental&quot; or &quot;ancestral&quot;. If &quot;raw&quot;
output is the output of the underlying method, without modifications. If &quot;parental&quot;
output described parental relations; if &quot;ancestral&quot; output is casted to ancestral 
relations. #TODO explain further</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_variableselmat">variableSelMat</code></td>
<td>
<p>An optional logical matrix of dimension (pxp). An 
entry <code>TRUE</code> for entry (i,j) says that variable i should be considered 
as a potential parent for variable j and vice versa for <code>FALSE</code>. If the 
default value of <code>NULL</code> is used, all variables will be considered, but 
this can be very slow, especially for methods <code>pc</code>, <code>ges</code>, 
<code>gies</code>, <code>rfci</code> and <code>CAM</code>.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_excludetargetinterventions">excludeTargetInterventions</code></td>
<td>
<p>When looking for parents of variable k 
in 1,...,p, set to <code>TRUE</code> if observations where an intervention on 
variable k occured should be excluded. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_onlyobservationaldata">onlyObservationalData</code></td>
<td>
<p>If set to <code>TRUE</code>, only observational data 
is used. It will take the index in <code>environment</code> specified by 
<code>indexObservationalData</code>. If <code>environment</code> is <code>NULL</code>, all 
observations are used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_indexobservationaldata">indexObservationalData</code></td>
<td>
<p>Index in <code>environment</code> that encodes 
observational data. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_setoptions">setOptions</code></td>
<td>
<p>A list that can take method-specific options; see the 
individual documentations of the methods for more options and their 
possible values.</p>
</td></tr>
<tr><td><code id="getParentsStable_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix, where a 0 entry in (j,k) corresponds to an estimate 
of 'no edge' <code>j</code> -&gt; <code>parentsOf[k]</code>. Entries between 0 and 100 
give the selection percentage of this edge over all resamples (set to 0 if
below critical threshold) and all non-zero values are considered as selected
edges.
</p>


<h3>Author(s)</h3>

<p>Nicolai Meinshausen <a href="mailto:meinshausen@stat.math.ethz.ch">meinshausen@stat.math.ethz.ch</a>, Christina
Heinze-Deml <a href="mailto:heinzedeml@stat.math.ethz.ch">heinzedeml@stat.math.ethz.ch</a>
</p>


<h3>References</h3>

<p>Stability selection (2010):  N. Meinshausen and P. Buhlmann, 
Journal of the Royal Statistical Society: Series B, 72, 417-473
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParents">getParents</a></code> for the underlying point-estimate of 
the causal graph.
</p>

<hr>
<h2 id='getRanking'>Estimate a ranking of edges for causal relations in the underlying graph structure
using stability ranking.</h2><span id='topic+getRanking'></span>

<h3>Description</h3>

<p>Estimates a ranking of edges for a given query, e.g. for 
parental relations in the underlying causal graph structure, using 
various possible methods. 
</p>
<p>Supported methods at the moment are ARGES,
backShift, bivariateANM, bivariateCAM, CAM, FCI, FCI+, GES, GIES, hiddenICP, 
ICP, LINGAM, MMHC, rankARGES, rankFci, rankGES, rankGIES, rankPC, 
regression, RFCI and PC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRanking(
  X,
  environment,
  interventions = NULL,
  queries = c("isParent", "isMaybeParent", "isNoParent", "isAncestor",
    "isMaybeAncestor", "isNoAncestor"),
  method = c("ICP", "hiddenICP", "backShift", "pc", "LINGAM", "ges", "gies", "CAM",
    "fci", "rfci", "regression", "bivariateANM", "bivariateCAM")[1],
  alpha = 0.1,
  variableSelMat = NULL,
  excludeTargetInterventions = TRUE,
  onlyObservationalData = FALSE,
  indexObservationalData = NULL,
  setOptions = list(),
  assumeNoSelectionVars = TRUE,
  nsim = 100,
  sampleSettings = 1/sqrt(2),
  sampleObservations = 1/sqrt(2),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRanking_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">(n x p)</code>-data matrix with <code class="reqn">n</code> observations of <code class="reqn">p</code> variables.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_environment">environment</code></td>
<td>
<p>A vector of length <code class="reqn">n</code>, where the entry for 
observation <code class="reqn">i</code> is an index for the environment in which observation <code class="reqn">i</code> took 
place (simplest case entries <code>1</code> for observational data and entries
<code>2</code> for interventional data of unspecified type). Is required for 
methods <code>ICP</code>, <code>hiddenICP</code>, <code>backShift</code>.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_interventions">interventions</code></td>
<td>
<p>A optional list of length n. The entry for observation
i is a numeric vector that specifies the variables on which interventions 
happened for observation i (a scalar if an intervention happened on just 
one variable and <code>numeric(0)</code> if no intervention occured for this 
observation). Is used for method <code>gies</code> but will generate the vector 
<code>environment</code> if this is set to <code>NULL</code> (even though it might 
generate too many different environments for some data so a hand-picked 
vector <code>environment</code> is preferable). Is also used for <code>ICP</code> and 
<code>hiddenICP</code> to exclude interventions on the target variable of 
interest.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_queries">queries</code></td>
<td>
<p>One (or more of) &quot;isParent&quot;, &quot;isMaybeParent&quot;, &quot;isNoParent&quot;,
&quot;isAncestor&quot;,&quot;isMaybeAncestor&quot;, &quot;isNoAncestor&quot;</p>
</td></tr>
<tr><td><code id="getRanking_+3A_method">method</code></td>
<td>
<p>A string that specfies the method to use. The methods 
<code>pc</code> (PC-algorithm), <code>LINGAM</code> (LINGAM), <code>arges</code> (Adaptively 
restricted greedy equivalence search), <code>ges</code> 
(Greedy equivalence search), <code>gies</code> (Greedy interventional equivalence 
search),  <code>fci</code> (Fast causal inference)  
and <code>rfci</code> (Really fast causal inference) are imported from the 
package &quot;pcalg&quot; and are documented there in more detail, including the 
additional options that can be supplied via <code>setOptions</code>. The method 
<code>CAM</code> (Causal additive models) is documented in the package &quot;CAM&quot; and 
the methods <code>ICP</code> (Invariant causal prediction), <code>hiddenICP</code> 
(Invariant causal prediction with hidden variables) are from the package 
&quot;InvariantCausalPrediction&quot;. The method <code>backShift</code> comes from the 
package &quot;backShift&quot;. The method <code>mmhc</code> comes from the 
package &quot;bnlearn&quot;. 
Finally, the methods <code>bivariateANM</code> and 
<code>bivariateCAM</code> are for now implemented internally but will hopefully 
be part of another package at some point in the near future.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_alpha">alpha</code></td>
<td>
<p>The level at which tests are done. This leads to confidence 
intervals for <code>ICP</code> and <code>hiddenICP</code> and is used internally for 
<code>pc</code> and <code>rfci</code>.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_variableselmat">variableSelMat</code></td>
<td>
<p>An optional logical matrix of dimension (pxp). An 
entry <code>TRUE</code> for entry (i,j) says that variable i should be considered 
as a potential parent for variable j and vice versa for <code>FALSE</code>. If the 
default value of <code>NULL</code> is used, all variables will be considered, but 
this can be very slow, especially for methods <code>pc</code>, <code>ges</code>, 
<code>gies</code>, <code>rfci</code> and <code>CAM</code>.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_excludetargetinterventions">excludeTargetInterventions</code></td>
<td>
<p>When looking for parents of variable k 
in 1,...,p, set to <code>TRUE</code> if observations where an intervention on 
variable k occured should be excluded. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_onlyobservationaldata">onlyObservationalData</code></td>
<td>
<p>If set to <code>TRUE</code>, only observational data 
is used. It will take the index in <code>environment</code> specified by 
<code>indexObservationalData</code>. If <code>environment</code> is <code>NULL</code>, all 
observations are used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_indexobservationaldata">indexObservationalData</code></td>
<td>
<p>Index in <code>environment</code> that encodes 
observational data. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_setoptions">setOptions</code></td>
<td>
<p>A list that can take method-specific options; see the 
individual documentations of the methods for more options and their 
possible values.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_assumenoselectionvars">assumeNoSelectionVars</code></td>
<td>
<p>Set to <code>TRUE</code> is you want to assume the absence 
of selection variables.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_nsim">nsim</code></td>
<td>
<p>The number of resamples for stability selection.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_samplesettings">sampleSettings</code></td>
<td>
<p>The fraction of different environments to resample 
in each resampling (at least two different environments will be selected so 
the argument is without effect if there are just two different environments 
in total).</p>
</td></tr>
<tr><td><code id="getRanking_+3A_sampleobservations">sampleObservations</code></td>
<td>
<p>The fraction of samples to resample in each 
environment.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
<tr><td><code id="getRanking_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to underlying method's function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For both parental and ancestral relations, three queries are supported. 
The existence of a relation is assessed by the queries <code>isParent</code> and 
<code>isAncestor</code>; the absence of a relation is assessed by the queries 
<code>isNoParent</code> and <code>isNoAncestor</code>; the potential existence of a 
relation is addressed by the queries <code>isMaybeParent</code> and 
<code>isMaybeAncestor</code>.
</p>
<p>All queries return a connectivity matrix which we denote by <code class="reqn">A</code>. 
The interpretation of the entries of <code class="reqn">A</code> differs according to the considered query:
</p>
<p><strong>Parental relations:</strong> Queries concerning parental relations can only 
be answered by those methods under consideration that return a DAG, a CPDAG 
or a directed cyclic graph. When we say that a particular method cannot 
answer a given query, then the method's output with respect to this query 
will be the zero matrix. However, the eventual ranking for such a query will 
not necessarily be random due to the tie breaking scheme that is applied 
when ranking pairs of variables (see below).
</p>

<ol>
<li> <p><code>isParent</code> In the connectivity matrix <code class="reqn">A</code> returned by this 
query, the entry <code class="reqn">A_{i,j} = 1</code> means that there is <em>a directed edge</em> 
from node <code class="reqn">i</code> to node <code class="reqn">j</code> in the graph structure estimated by the 
method under consideration. Otherwise, <code class="reqn">A_{i,j} = 0</code>.
</p>
</li>
<li> <p><code>isMaybeParent</code> <code class="reqn">A_{i,j} = 1</code> means that there is 
<em>a directed or an undirected edge</em> from node <code class="reqn">i</code> to node <code class="reqn">j</code>
in the estimated graph structure. Otherwise, <code class="reqn">A_{i,j} = 0</code>.
</p>
</li>
<li> <p><code>isNoParent</code> <code class="reqn">A_{i,j} = 1</code> means that there is neither a 
directed nor an undirected edge from node <code class="reqn">i</code> to node <code class="reqn">j</code> in the 
estimated graph structure. Otherwise, <code class="reqn">A_{i,j} = 0</code>.
</p>
</li></ol>

<p><strong>Ancestral relations:</strong> Queries concerning ancestral relations can be 
answered by all methods under consideration.
</p>

<ol>
<li> <p><code>isAncestor</code> <code class="reqn">A_{i,j} = 1</code> means that there is a 
<em>directed path</em> from node <code class="reqn">i</code> to node <code class="reqn">j</code> in the estimated graph 
structure. Otherwise, <code class="reqn">A_{i,j} = 0</code>. In case of PAGs, directed paths can 
contain the edge types <code class="reqn">i --&gt; j</code> and <code class="reqn">i --o j</code>. Including the latter 
edge type in this category implies that we exclude the existence of selection 
variables.
</p>
</li>
<li> <p><code>isMaybeAncestor</code> <code class="reqn">A_{i,j} = 1</code> then means that there is a 
path from node <code class="reqn">i</code> to node <code class="reqn">j</code> that contains directed and/or undirected 
edges. Otherwise, <code class="reqn">A_{i,j} = 0</code>.	For PAGs, such paths can contain the edge 
types <code class="reqn">i --&gt; j</code>, <code class="reqn">i --o j</code>, <code class="reqn">i o-o j</code> and/or 
<code class="reqn">i o-&gt; j</code>. Otherwise, <code class="reqn">A_{i,j} = 0</code>.
</p>
</li>
<li> <p><code>isNoAncestor</code> <code class="reqn">A_{i,j} = 1</code> means that there is neither a 
directed path nor a partially directed path from node <code class="reqn">i</code> to node <code class="reqn">j</code>
in the estimated graph structure. Otherwise, <code class="reqn">A_{i,j} = 0</code>.
</p>
</li></ol>

<p><strong>Stability ranking:</strong> To obtain a ranking of edges for a given set of 
queries, we run the method under consideration on <code>nsims</code> random 
subsamples of the data. In each round, we draw samples from a fraction of 
settings, where the size of the fraction is specified by <code>sampleSettings</code>. 
In each chosen setting, we sample a fraction of observations 
uniformly at random without replacement, where the size of the fraction is 
specified by  <code>sampleObservations</code>. 
</p>
<p>For each subsample we randomly 
permute the order of the variables in the input. 
Methods that are order-dependent can therefore not exploit any potential 
advantage stemming from a data matrix with columns ordered according to the 
causal ordering or a similar one. We then run the method on each subsample. 
</p>
<p>For each subsample and a particular query, we obtain the corresponding 
connectivity matrix <code class="reqn">A</code>. We can then rank all pairs of nodes <code class="reqn">i,j</code> 
according to the frequency of the occurrence of <code class="reqn">A_{i,j} = 1</code> across 
subsamples. Ties between pairs of variables can be broken with the results 
of the other queries if they are also computed as specified by <code>queries</code>; 
otherwise ties are broken at random:
</p>

<ul>
<li><p> If the query is <code>isParent</code>, ties are broken with counts for 
<code>isMaybeParent</code>. 
</p>
</li>
<li><p> For the query <code>isMaybeParent</code> ties are broken with counts for 
<code>isParent</code>, i.e. in case of equal counts we give a preference to the 
edge that was considered more often to be a 'certain' parent. For methods 
returning DAGs this scheme makes the ranking for <code>isMaybeParent</code> equal 
to the result for <code>isParent</code>, up to the random tie breaking that is 
applied for <code>isParent</code>.
</p>
</li>
<li><p> If the query is <code>isNoParent</code>, ties are broken according to which 
edge was selected less often in the query <code>isMaybeParent</code>. 
</p>
</li>
<li><p> If the query is <code>isAncestor</code>, ties are broken with counts for 
<code>isMaybeAncestor</code>. 
</p>
</li>
<li><p> For the query <code>isMaybeAncestor</code> ties are broken with counts 
for <code>isAncestor</code>, i.e. in case of equal counts we give a preference 
to the edge that was considered more often to be a 'certain' ancestor. 
For methods returning DAGs this scheme makes the ranking for <code>isMaybeAncestor</code> 
equal to the result for <code>isAncestor</code>, up to the random tie breaking 
that is applied for <code>isAncestor</code>.
</p>
</li>
<li><p> If the query is <code>isNoAncestor</code>, ties are broken according to 
which one was selected less often in the query <code>isMaybeAncestor</code>. 
</p>
</li></ul>
 
<p>If the tie breaking matrix defined according to these rules is 0, 
a matrix with standard normal random entries is used to break ties. 
Similarly, if there are remaining ties after applying the tie breaking rules 
described above, ties are broken randomly.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<ul>
<li> <p><code>ranking</code> A list of length <code>length(queries)</code>. For each query,
the corresponding list entry contains a matrix of dimension <code class="reqn">(p x p) x 2</code> 
with the ranking of edges. E.g. the first row indicates that the edge from 
ranking$isParent[1,1] to ranking$isParent[1,2] is the most likely edge according
to the method under consideration. 
</p>
</li>
<li> <p><code>resList</code>  A list of length <code>length(queries)</code>. For each query,
the corresponding list entry contains a matrix  of dimension <code class="reqn">(p x p)</code> with the counts for 
<code class="reqn">A_{i,j} = 1</code> across the <code>nsim</code> subsamples.
</p>
</li>
<li> <p><code>simEstimates</code> A list of length <code>nsim</code> with the method's 
output for each of the <code>nsim</code> subsamples.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Christina Heinze-Deml <a href="mailto:heinzedeml@stat.math.ethz.ch">heinzedeml@stat.math.ethz.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getParents">getParents</a></code> for the underlying point-estimate of 
the causal graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("simDataInv")
X &lt;- simDataInv$X
set.seed(1)
if(require(pcalg)){
  rank &lt;- getRanking(X,
                environment = simDataInv$environment,
                queries = c("isParent","isMaybeParent"),
                method = c("LINGAM"),
                verbose = FALSE)
  # estimated ranking
  print(rank$ranking$isParent)
 
  # true adjacency matrix
  print(simDataInv$configs$trueA)
}else{
  cat("\nThe packages 'pcalg' is needed for the example to
work. Please install it.")
}

</code></pre>

<hr>
<h2 id='simDataInv'>Data from a causal model with interventions</h2><span id='topic+simDataInv'></span>

<h3>Description</h3>

<p>A dataset to run the tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simDataInv
</code></pre>


<h3>Format</h3>

<p>A list created by <code><a href="#topic+simulateInterventions">simulateInterventions</a></code>. 
All inputs are contained in the list element <code>configs</code>. For details
see the help page of <code><a href="#topic+simulateInterventions">simulateInterventions</a></code>.</p>

<hr>
<h2 id='simulateInterventions'>Simulate data of a causal (possibly cyclic model) under interventions.</h2><span id='topic+simulateInterventions'></span>

<h3>Description</h3>

<p>Simulate data of a causal (possibly cyclic model) under interventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateInterventions(
  n,
  p,
  df,
  rhoNoise,
  snrPar,
  sparse,
  doInterv,
  numberInt,
  strengthInt,
  cyclic,
  strengthCycle,
  modelMis = FALSE,
  modelMisPar = 1,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateInterventions_+3A_n">n</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_p">p</code></td>
<td>
<p>Number of variables.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_df">df</code></td>
<td>
<p>Degrees of freedom in t-distribution of noise and interventions.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_rhonoise">rhoNoise</code></td>
<td>
<p>Correlation between noise terms to model hidden variabkes. 
Set to 0 for independent noise.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_snrpar">snrPar</code></td>
<td>
<p>Signal-to-noise parameter: steers what proportion of the variance stems from 
the signal resp.\ from the noise: The SNR is given by $SNR = (1-<code>snrPar</code>)/<code>snrPar</code>$), 
see details. Only holds when <code>cyclic = FALSE</code>.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_sparse">sparse</code></td>
<td>
<p>Probability that an entry <code class="reqn">i,j</code> in adjacency matrix is 1.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_dointerv">doInterv</code></td>
<td>
<p>Set to TRUE if interventions should be do-interventions; otherwise
noise interventions (also called shift interventions) are generated.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_numberint">numberInt</code></td>
<td>
<p>Total number of settings.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_strengthint">strengthInt</code></td>
<td>
<p>Regulates the strength of the interventions, see details.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_cyclic">cyclic</code></td>
<td>
<p>Set to TRUE is resulting graph should contain a cycle.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_strengthcycle">strengthCycle</code></td>
<td>
<p>Steers strength of feedback, see details.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_modelmis">modelMis</code></td>
<td>
<p>Add a model misspecification that applies <code>tanh(modelMisPar*x)/modelMisPar)</code>
morginally to each variable after having generated X from the causal DAG.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_modelmispar">modelMisPar</code></td>
<td>
<p>Parameter steering the strength of the model misspecification.</p>
</td></tr>
<tr><td><code id="simulateInterventions_+3A_seed">seed</code></td>
<td>
<p>Random seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adjacency matrix <code class="reqn">A</code> is generated as follows. Assume the variables 
with indices <code class="reqn">{1, \ldots, p}</code> are causally ordered. For each edge from node 
<code class="reqn">i</code> to node <code class="reqn">j</code> where <code class="reqn">i</code> precedes <code class="reqn">j</code> in the causal ordering, 
we draw a sample from Bin(<code>sparse</code>) to determine whether to add an edge 
from node <code class="reqn">i</code> to node <code class="reqn">j</code>. After having sampled the non-zero entries 
of <code class="reqn">A</code> in this fashion, we sample the coefficients from Unif(-1,1). 
As described below, the edge weights are later rescaled to achieve a specified 
signal-to-noise ratio. We exclude the possibility of <code class="reqn">A = 0</code>, 
i.e. we resample until <code class="reqn">A</code> contains at least one non-zero entry.
</p>
<p>Second, the interventions are generated as follows. <code>numberInt</code> denotes the total 
number of (interventional and observational) settings that are generated. 
For each variable, we sample uniformly at random with replacement one setting 
in which this variable is intervened on. In other words, each variable is 
intervened on in exactly one setting. Hence it is possible that there are 
settings where no interventions take place which then correspond to the 
observational case. Similarly, there may be settings where interventions 
are performed on multiple variables at once. After defining the settings, 
we sample (uniformly at random with replacement) what setting each data point 
belongs to. So for each setting we generate approximately the same number of 
samples. In one generated data set, the interventions are all of the same 
type, i.e. they are either all shift interventions (when <code>doInterv = FALSE</code>) 
or do-interventions (when <code>doInterv = TRUE</code>). In both cases, an intervention 
on <code class="reqn">X_j</code> is modelled by generating <code class="reqn">Z_j</code> as <code class="reqn">Z_j ~</code> <code>strengthInt</code> <code class="reqn">* t</code>(<code>dfNoise</code>). 
If <code>strengthInt</code> = 0, all interventional settings correspond to purely 
observational data.
</p>
<p>Third, the noise terms <code class="reqn">\epsilon</code> are generated by first sampling from 
<code class="reqn">N(0,\Sigma)</code> where <code class="reqn">\Sigma_{i,i} = 1</code> and 
<code class="reqn">\Sigma_{i,j} =</code> <code>rhoNoise</code>. To steer the signal-to-noise ratio, 
we set the variance of the noise terms of all nodes except source nodes 
to <code>snrPar</code> where <code class="reqn">0 &lt; </code><code>snrPar</code><code class="reqn"> \le 1</code>. Stepping through the 
variables in causal order, for each variable <code class="reqn">X_j</code> that has parents, we 
uniformly rescale the edge weights <code class="reqn">\beta_{j,k}</code> for <code class="reqn">k = 1, \ldots, p</code> 
in the structural equation of variable <code class="reqn">X_j</code> such that the variance of 
the sum <code class="reqn">\sum_{k=1}^p  \beta_{j,k} X_k + \epsilon_j</code> is approximately 
1 in the observational setting. In other words, the parameter <code>snrPar</code>
steers what proportion of the variance stems from the signal given by  
<code class="reqn">\sum_{k=1}^p  \beta_{j,k} X_k</code> and what proportion stems from the 
noise <code class="reqn">\epsilon_j</code>. The signal-to-noise ratio can then be computed 
as SNR = (1-<code>snrPar</code>)/<code>snrPar</code>.
</p>
<p>Forth, a cycle is added to the causal graph if <code>cyclic = TRUE</code>. If the 
causal graph shall contain a cycle, we sample two nodes <code class="reqn">i</code> and <code class="reqn">j</code> 
such that adding an edge between them creates a cycle in the causal graph. 
We then compute the largest possible coefficient for this edge such that the 
cycle product is smaller than 1. Subsequently, we sample the sign of the 
coefficient and set the magnitude by scaling the largest possible coefficient 
by <code>strengthCycle</code> where <code class="reqn">0 &lt; </code><code>strengthCycle</code><code class="reqn">&lt; 1</code>.
</p>
<p>Fifth, we rescale the noise variables to obtain a <code class="reqn">t</code>-distribution with 
<code>dfNoise</code> degrees of freedom. <code class="reqn">X</code> is then generated as 
<code class="reqn">X  = (I-A)^{-1}\epsilon</code> in the observational case; under a shift 
interventions <code class="reqn">X</code> can be generated as <code class="reqn">X  = (I-A)^{-1}(\epsilon + Z)</code> 
where the coordinates of <code class="reqn">Z</code> are only non-zero for the variables 
that are intervened on. Under a do-intervention on <code class="reqn">X_j</code>, <code class="reqn">\beta_{j,k}</code>
for <code class="reqn">k = 1, \ldots, p</code> are set to 0 to yield <code class="reqn">A'</code> and <code class="reqn">\epsilon_j</code>
is set to <code class="reqn">Z_j</code> to yield <code class="reqn">\epsilon_j'</code>. We then obtain <code class="reqn">X</code> as 
<code class="reqn">X  = (I-A')^{-1}\epsilon'</code>.
</p>
<p>Lastly, if <code>modelMis = TRUE</code> a model misspecification is added to the 
data by marginally transforming all variables as <code>tanh(modelMisPar*x)/modelMisPar)</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements: 
</p>

<ul>
<li> <p><code>X</code> <code class="reqn">n x p</code>-dimensional data matrix
</p>
</li>
<li> <p><code>environment</code> Indicator of the experiment or the intervention type an 
observation belongs to. A numeric vector of length <code class="reqn">n</code>.  
</p>
</li>
<li> <p><code>interventions</code> A list of length <code class="reqn">n</code>. Indicates location of interventions
for each data point.
</p>
</li>
<li> <p><code>whereInt</code> A list of length  <code>numberInt</code>. Indicates location of interventions
in each setting.
</p>
</li>
<li> <p><code>noise</code>
</p>
</li>
<li> <p><code>configs</code> A list with the generated adjacency matrix (<code>trueA</code>)
as well as all input arguments.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
