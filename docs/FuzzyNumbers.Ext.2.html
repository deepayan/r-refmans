<!DOCTYPE html><html lang="en"><head><title>Help for package FuzzyNumbers.Ext.2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FuzzyNumbers.Ext.2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FuzzyNumbers.Ext.2-package'>
<p>Apply Two Fuzzy Numbers on a Monotone Function</p></a></li>
<li><a href='#f2apply'>
<p>Apply a two-variable function on two fuzzy numbers</p></a></li>
<li><a href='#is.decreasing'>
<p>Diagnosis a decreasing function</p></a></li>
<li><a href='#is.decreasing.on.x'>
<p>Diagnosis a decreasing two-variable function toward x</p></a></li>
<li><a href='#is.decreasing.on.y'>
<p>Diagnosis a decreasing two-variable function toward y</p></a></li>
<li><a href='#is.increasing'>
<p>Diagnosis an increasing function</p></a></li>
<li><a href='#is.increasing.on.x'>
<p>Diagnosis an increasing two-variable function toward x</p></a></li>
<li><a href='#is.increasing.on.y'>
<p>Diagnosis an increasing two-variable function toward y</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Apply Two Fuzzy Numbers on a Monotone Function</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-09-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Abbas Parchami (Department of Statistics, Faculty of Mathematics and Computer, Shahid Bahonar University of Kerman, Kerman, Iran)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Abbas Parchami &lt;parchami@uk.ac.ir&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>One can easily draw the membership function of f(x,y) by package 'FuzzyNumbers.Ext.2' in which f(.,.) is supposed monotone and x and y are two fuzzy numbers. This work is possible using function f2apply() which is an extension of function fapply() from Package 'FuzzyNumbers' for two-variable monotone functions. Moreover, this package has the ability of computing the core, support and alpha-cuts of the fuzzy-valued final result.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>FuzzyNumbers</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-09-03 15:32:54 UTC; parchami</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-09-05 07:29:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='FuzzyNumbers.Ext.2-package'>
Apply Two Fuzzy Numbers on a Monotone Function
</h2><span id='topic+FuzzyNumbers.Ext.2-package'></span><span id='topic+FuzzyNumbers.Ext.2'></span>

<h3>Description</h3>

<p>One can easily draw the membership function of f(x,y) by package 'FuzzyNumbers.Ext.2' in which f(.,.) is supposed monotone and x and y are two fuzzy numbers. This work is possible using function f2apply() which is an extension of function fapply() from Package 'FuzzyNumbers' for two-variable monotone functions. Moreover, this package has the ability of computing the core, support and alpha-cuts of the fuzzy-valued final result.
</p>


<h3>Details</h3>

<p>The main goal of Package <code>FuzzyNumbers.Ext.2</code> is apply two fuzzy numbers <code class="reqn">x</code> and <code class="reqn">y</code> into a monotone two-variable function <code class="reqn">f(x,y)</code> which is possible by using function <code>f2apply</code>.
</p>


<h3>Author(s)</h3>

<p>Abbas Parchami &lt;parchami@uk.ac.ir&gt;
</p>


<h3>References</h3>

<p>Gagolewski, M., Caha, J., FuzzyNumbers Package: Tools to Deal with Fuzzy Numbers in R. R package version 0.4-1, 2015. https://cran.r-project.org/web/packages=FuzzyNumbers
</p>
<p>Klir, G.J., Yuan, B., Fuzzy Sets and Fuzzy Logic: Theory and Applications, Prentice Hall PTR, New Jersey (1995).
</p>
<p>Viertl, R., Statistical methods for fuzzy data. New York: John Wiley &amp; Sons (2011)
</p>
<p>Zadeh, L.A., Fuzzy sets. Information and Control 8, 338-359 (1965)
</p>
<p>Zadeh, L.A., Probability measures of fuzzy events. Journal of Mathematical Analysis and Applications 23, 421-427 (1968)
</p>


<h3>See Also</h3>

<p><code>FuzzyNumbers</code>
</p>

<hr>
<h2 id='f2apply'>
Apply a two-variable function on two fuzzy numbers
</h2><span id='topic+f2apply'></span>

<h3>Description</h3>

<p>Suppose that we are going to put two fuzzy numbers <code class="reqn">x</code> and <code class="reqn">y</code> into the monotonic two-variable function <code class="reqn">f(x,y)</code>. A usual approach is using Zadeh's extension Principle which has a complex computation.
Function <code>f2apply</code> applies easily two fuzzy numbers to a monotonic two-variable function. Although the theory of <code>f2apply</code> computation is based on the Zadeh's extension Principle, but it works with the <code class="reqn">\alpha</code>-cuts of two inputted fuzzy numbers for all <code class="reqn">\alpha \in (0,1]</code>. It must be mentioned that the ability of computing <code class="reqn">\alpha</code>-cuts of the result is added to the Version 2.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f2apply(x, y, fun, knot.n=10, I.O.plot="TRUE", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f2apply_+3A_x">x</code></td>
<td>

<p>the first fuzzy number, which must be according to the format of <code>FuzzyNumbers</code> package
</p>
</td></tr>
<tr><td><code id="f2apply_+3A_y">y</code></td>
<td>

<p>the second fuzzy number, which must be according to the format of <code>FuzzyNumbers</code> package
</p>
</td></tr>
<tr><td><code id="f2apply_+3A_fun">fun</code></td>
<td>

<p>a two-variable function which is monotone function on the supports of <code>x</code> and <code>y</code> fuzzy numbers
</p>
</td></tr>
<tr><td><code id="f2apply_+3A_knot.n">knot.n</code></td>
<td>

<p>the number of knots; see package <code>FuzzyNumbers</code>
</p>
</td></tr>
<tr><td><code id="f2apply_+3A_i.o.plot">I.O.plot</code></td>
<td>

<p>a logical argument with default <code>TRUE</code>. If <code>I.O.plot=TRUE</code>, then three membership functions of <code class="reqn">x</code>, <code class="reqn">y</code> (Inputted fuzzy numbers) and <code class="reqn">f(x,y)</code> (Outputted fuzzy number) are drawn in a figure. If <code>I.O.plot=FALSE</code>, then just the membership function of Outputted fuzzy number <code class="reqn">f(x,y)</code> will be shown in figure.
</p>
</td></tr>
<tr><td><code id="f2apply_+3A_...">...</code></td>
<td>

<p>additional arguments passed from <code>plot</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns piecewise linear fuzzy number <code class="reqn">f(x,y)</code> and also plot the result.
</p>
<table role = "presentation">
<tr><td><code>fun.rep</code></td>
<td>
<p>describes the monotonic behavior of the considered function</p>
</td></tr>
<tr><td><code>cuts</code></td>
<td>
<p>returns the <code class="reqn">\alpha</code>-cuts of the computed fuzzy number <code class="reqn">f(x,y)</code> </p>
</td></tr>
<tr><td><code>core</code></td>
<td>
<p>returns the core of the computed fuzzy number <code class="reqn">f(x,y)</code> </p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>returns the support of the computed fuzzy number <code class="reqn">f(x,y)</code> </p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>f2apply</code> is an extended version of <code>fapply</code> from package <code>FuzzyNumbers</code>. The duty of functions <code>fapply</code> and <code>f2apply</code> are applying one-variable and two-variable function on fuzzy numbers. 
Two imported fuzzy numbers into <code>f2apply</code> must be piecewised by <code>PiecewiseLinearFuzzyNumber</code> function in package <code>FuzzyNumbers</code>. Moreover, the considered function <code class="reqn">f(x,y)</code> must be monotone on <code class="reqn">x</code> and <code class="reqn">y</code>. 
</p>


<h3>Author(s)</h3>

<p>Abbas Parchami
</p>


<h3>References</h3>

<p>Gagolewski, M., Caha, J., FuzzyNumbers Package: Tools to Deal with Fuzzy Numbers in R. R package version 0.4-1, 2015. https://cran.r-project.org/web/packages=FuzzyNumbers
</p>
<p>Klir, G.J., Yuan, B., Fuzzy Sets and Fuzzy Logic: Theory and Applications, Prentice Hall PTR, New Jersey (1995).
</p>
<p>Viertl, R., Statistical methods for fuzzy data. New York: John Wiley &amp; Sons (2011)
</p>
<p>Zadeh, L.A., Fuzzy sets. Information and Control 8, 338-359 (1965)
</p>
<p>Zadeh, L.A., Probability measures of fuzzy events. Journal of Mathematical Analysis and Applications 23, 421-427 (1968)
</p>


<h3>See Also</h3>

<p>See <code>PiecewiseLinearFuzzyNumber</code>, <code>as.PiecewiseLinearFuzzyNumber</code> and <code>piecewiseLinearApproximation</code> from package <code>FuzzyNumbers</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(FuzzyNumbers)   # For Loud 'FuzzyNumbers' package, after its instalation

# Example 1: Four different cases of function (in respect to increasing/decreasing on x and y)
x = TriangularFuzzyNumber(1,2,5)
y = TrapezoidalFuzzyNumber(3,4,5,6)

g1 = function(x,y) 2*x+y
f2apply(x, y, g1, knot.n=5, type="l", I.O.plot=TRUE)
f2apply(x, y, g1, knot.n=10, xlim=c(0,18), col=4, type="b", I.O.plot=FALSE)
plot(2*x+y, col=2, lty=4, lwd=3, add=TRUE) #Compare the result from "FuzzyNumbers" package

g2 = function(x,y) -2*pnorm(x)+y
f2apply(x, y, g2, type="b")

g3 = function(x,y) 2*x-punif(y, min=1, max=8)
f2apply(x, y, g3, type="l")

g4 = function(x,y) -2*x-y^3
f2apply(x, y, g4, knot.n=20, type="b" )



# Example 2: 
knot.n = 10
A &lt;- FuzzyNumber(-1, .5, 1, 3,
  lower=function(alpha) qbeta(alpha,0.4,3),
  upper=function(alpha) (1-alpha)^4
)
B = PowerFuzzyNumber(1,2,2.5,4, p.left=2, p.right=0.5)
f2apply(A, B, function(x,y) -2*x-y^3, knot.n=knot.n, type="l", col=2, lty=5, lwd=3, I.O.plot=FALSE)
f2apply(A, B, function(x,y) -2*x-y^3, knot.n=knot.n, type="l", col=2, lty=5, lwd=3)

# As another example, change the function and work with the cuts of result:
Result &lt;- f2apply(A, B, function(x,y) abs(y+x-10),knot.n=knot.n,type="l",I.O.plot=TRUE,col=3,lwd=2)
Result
class(Result)

#The result of alphacut for alpha=0.444:
Result$cuts["0.444",] #Or equivalently,  
Result$cuts[6,]  

# Upper bounds of alphacuts:
Result$cuts[,"U"] #Or equivalently,  
Result$cuts[,2]

#The core of the result:
Result$core  

# The support of the result:
Result$support # Or, equivalently:  Result$s


# Example 3: 
knot.n = 10
x = PowerFuzzyNumber(0,1,1,1.3, p.left=1, p.right=1) 
y = PowerFuzzyNumber(3,4,4,6, p.left=1, p.right=1) 
f = function(x,y) 3*x - 2*y
f2apply(x, y, f, knot.n=knot.n, type="l", I.O.plot=TRUE)

g = function(x,y) exp(x^2) + 3*log(sqrt(y+4))
f2apply(x, y, g, knot.n=knot.n, type="l", I.O.plot=TRUE)


# Example 4: 
knot.n = 20
A = PowerFuzzyNumber(.1,.5,.5,.6, p.left=2, p.right=0.5)
B &lt;- FuzzyNumber(.5, .6, .7, .9,
  lower=function(alpha) qbeta(alpha,0.4,3),
  upper=function(alpha) (1-alpha)^4
)
fun1 &lt;- function(x,y) qnorm(x)-qgamma(y,2,4)
f2apply(A, B, fun1, knot.n=knot.n, type="l", I.O.plot=TRUE, col=2, lwd=2)

fun2 &lt;- function(x,y) 0.3*sin(qnorm(x))+tan(qgamma(y,2,4))
f2apply(A, B, fun2, knot.n=knot.n, type="l", I.O.plot=TRUE)


# Example 5: It may be one of considered inputs are crisp.
knot.n = 10
A = 27
B = PowerFuzzyNumber(1,2,2.5,4, p.left=2, p.right=0.5)
f2apply(A, B, function(x,y) -2*x-y^3, knot.n=knot.n, I.O.plot=TRUE)

f2apply(x=4, y=3, function(x,y) sqrt(x)*y^2, knot.n=knot.n, I.O.plot=TRUE)
f2apply(x=4, y=TriangularFuzzyNumber(2,3,5), function(x,y) sqrt(x)-y^2,knot.n=knot.n,I.O.plot=TRUE)
f2apply(x=TriangularFuzzyNumber(2,4,6), y=3, function(x,y) sqrt(x)-y^2,knot.n=knot.n,I.O.plot=TRUE)
f2apply(x=TriangularFuzzyNumber(2,4,6), y=TriangularFuzzyNumber(2,3,5), function(x,y) sqrt(x)-y^2,
        knot.n=knot.n, I.O.plot=TRUE)


## The function is currently defined as
function (x, y, fun, knot.n = 10, I.O.plot = "TRUE", ...) 
{
    x.input &lt;- x
    y.input &lt;- y
    if (class(x) == "numeric") {
        x &lt;- x.input.fuzzy &lt;- TriangularFuzzyNumber(x, x, x)
    }
    if (class(x) == "TriangularFuzzyNumber" | class(x) == "TrapezoidalFuzzyNumber") {
        x.input.fuzzy &lt;- x
        x &lt;- as.PiecewiseLinearFuzzyNumber(x, knot.n)
    }
    if (class(x) == "FuzzyNumber" | class(x) == "PowerFuzzyNumber" |
        class(x) == "PiecewiseLinearFuzzyNumber"  ){
        x.input.fuzzy &lt;- x
        x &lt;- piecewiseLinearApproximation(x, method = "Naive")
    }
    if (class(y) == "numeric") {
        y &lt;- y.input.fuzzy &lt;- TriangularFuzzyNumber(y, y, y)
    }
    if (class(y) == "TriangularFuzzyNumber" | class(y) == "TrapezoidalFuzzyNumber") {
        y.input.fuzzy &lt;- y
        y &lt;- as.PiecewiseLinearFuzzyNumber(y, knot.n)
    }
    if (class(y) == "FuzzyNumber" | class(y) == "PowerFuzzyNumber" | 
        class(y) == "PiecewiseLinearFuzzyNumber"  ){
        y.input.fuzzy &lt;- y
        y &lt;- piecewiseLinearApproximation(y, method = "Naive")
    }
    step.x = length(supp(x))/30
    step.y = length(supp(y))/30
    if (class(x.input) == "numeric") {
        is.inc.on.x &lt;- TRUE
        is.dec.on.x &lt;- FALSE
    }
    else {
        is.inc.on.x = is.increasing.on.x(fun, x.bound = supp(x), 
            y.bound = supp(y), step.x)
        is.dec.on.x = is.decreasing.on.x(fun, x.bound = supp(x), 
            y.bound = supp(y), step.x)
    }
    if (class(y.input) == "numeric") {
        is.inc.on.y &lt;- TRUE
        is.dec.on.y &lt;- FALSE
    }
    else {
        is.inc.on.y = is.increasing.on.y(fun, x.bound = supp(x), 
            y.bound = supp(y), step.y)
        is.dec.on.y = is.decreasing.on.y(fun, x.bound = supp(x), 
            y.bound = supp(y), step.y)
    }
    if ((is.inc.on.x == TRUE) &amp; (is.inc.on.y == TRUE)) {
        fun.rep = "fun is an increasing function from x and y on introduced bounds"
        L.result = fun(alphacut(x.input.fuzzy, seq(0, 1, len = knot.n))[, 
            "L"], alphacut(y.input.fuzzy, seq(0, 1, len = knot.n))[, 
            "L"])
        U.result = fun(alphacut(x.input.fuzzy, seq(0, 1, len = knot.n))[, 
            "U"], alphacut(y.input.fuzzy, seq(0, 1, len = knot.n))[, 
            "U"])
        result = c(L.result, U.result[length(U.result):1])
    }
    else {
        if ((is.dec.on.x == TRUE) &amp; (is.inc.on.y == TRUE)) {
    fun.rep = "fun is a decreasing function on x and increasing function on y on introduced bounds"
            L.result = fun(alphacut(x.input.fuzzy, seq(0, 1, 
                len = knot.n))[, "U"], alphacut(y.input.fuzzy, 
                seq(0, 1, len = knot.n))[, "L"])
            U.result = fun(alphacut(x.input.fuzzy, seq(0, 1, 
                len = knot.n))[, "L"], alphacut(y.input.fuzzy, 
                seq(0, 1, len = knot.n))[, "U"])
            result = c(L.result, U.result[length(U.result):1])
        }
        else {
            if ((is.inc.on.x == TRUE) &amp; (is.dec.on.y == TRUE)) {
   fun.rep = "fun is an increasing function on x and decreasing function on y on introduced bounds"
                L.result = fun(alphacut(x.input.fuzzy, seq(0, 
                  1, len = knot.n))[, "L"], alphacut(y.input.fuzzy, 
                  seq(0, 1, len = knot.n))[, "U"])
                U.result = fun(alphacut(x.input.fuzzy, seq(0, 
                  1, len = knot.n))[, "U"], alphacut(y.input.fuzzy, 
                  seq(0, 1, len = knot.n))[, "L"])
                result = c(L.result, U.result[length(U.result):1])
            }
            else {
                if ((is.dec.on.x == TRUE) &amp; (is.dec.on.y == TRUE)) {
                  fun.rep = "fun is a decreasing function from x and y on introduced bounds"
                  L.result = fun(alphacut(x.input.fuzzy, seq(0, 
                    1, len = knot.n))[, "U"], alphacut(y.input.fuzzy, 
                    seq(0, 1, len = knot.n))[, "U"])
                  U.result = fun(alphacut(x.input.fuzzy, seq(0, 
                    1, len = knot.n))[, "L"], alphacut(y.input.fuzzy, 
                    seq(0, 1, len = knot.n))[, "L"])
                  result = c(L.result, U.result[length(U.result):1])
                }
                else {
                  return(print("fun is not a monoton function on x and y for the introduced bounds.
                                Therefore this function is not appliable for computation."))
                }
            }
        }
    }
    if (class(x.input) == "numeric" | class(y.input) == "numeric") {
        fun.rep = "supports of one/both inputted points are crisp and the exact report on function
                   is not needed"
    }
    Alphacuts = c(seq(0, 1, len = knot.n), seq(1, 0, len = knot.n))
    if (I.O.plot == TRUE) {
        op &lt;- par(mfrow = c(3, 1))
        if (class(x.input) == "numeric") {
            plot(TriangularFuzzyNumber(x.input, x.input, x.input), 
                ylab = "membership func. of x")
        }
        else {
            plot(x.input, ylab = "membership func. of x")
        }
        if (class(y.input) == "numeric") {
            plot(TriangularFuzzyNumber(y.input, y.input, y.input), 
                xlab = "y", ylab = "membership func. of y")
        }
        else {
            plot(y.input, col = 1, xlab = "y", ylab = "membership func. of y")
        }
        plot(result, Alphacuts, xlab = "fun(x,y)", ylab = "membership func. of fun(x,y)", 
            ...)
        abline(v = fun(core(x), core(y)), lty = 3)
        par(op)
    }
    if (I.O.plot == "FALSE") {
        plot(result, Alphacuts, xlab = "fun(x,y)", ylab = "membership func. of fun(x,y)", 
            ...)
    }
    result2 &lt;- c(L.result[length(L.result):1], U.result[length(U.result):1])
    cuts &lt;- matrix(result2, ncol = 2, byrow = FALSE, dimnames = list(round((length(L.result) - 
        1):0/(length(L.result) - 1), 3), c("L", "U")))
    return(list(fun.rep = noquote(fun.rep), cuts = cuts, core = cuts[1, 
        ], support = cuts[dim(cuts)[1], ]))
  }
</code></pre>

<hr>
<h2 id='is.decreasing'>
Diagnosis a decreasing function
</h2><span id='topic+is.decreasing'></span>

<h3>Description</h3>

<p><code>is.decreasing</code> tests if the introduced one-variable function is decreasing (or in fact, non-increasing) on the considered <code>x.bound</code> or not. 
In other words, <code>is.decreasing</code> returns <code>TRUE</code> if the introduced function is decreasing on the considered <code>x.bound</code>; and it returns <code>FALSE</code> otherwise.
The goal of introducing function <code>is.decreasing</code> in package <code>FuzzyNumbers.Ext.2</code> is using in function <code>f2apply</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.decreasing(fun, x.bound = c(-1, 1), step = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.decreasing_+3A_fun">fun</code></td>
<td>

<p>a one-variable R function
</p>
</td></tr>
<tr><td><code id="is.decreasing_+3A_x.bound">x.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on x-axis for checking the monotonic of the considered function
</p>
</td></tr>
<tr><td><code id="is.decreasing_+3A_step">step</code></td>
<td>

<p>a positive real-valued number which determine the increment of the considered sequence for checking the monotonic of the considered function. The default of <code>step</code> is 0.01. 
Increasing <code>step</code> value can cause the decreasing the time of computation and also couse the decreasing the precision of the calculations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for decreasing one-variable functions on the considered <code>x.bound</code>; otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code>is.increasing</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.decreasing(fun=function(x) -2*x+10, x.bound=c(4,6), step=.1)

g = function(x) x^3
is.decreasing(g, x.bound=c(-24,6))

## The function is currently defined as
function (fun, x.bound = c(-1, 1), step = 0.01) 
{
    x = seq(x.bound[1], x.bound[2], by = step)
    i = 1
    while (fun(x[i]) &gt;= fun(x[i + 1])) {
        if (i &lt; length(x) - 1) {
            i &lt;- i + 1
        }
        else (return(TRUE))
    }
    return(FALSE)
  }
</code></pre>

<hr>
<h2 id='is.decreasing.on.x'>
Diagnosis a decreasing two-variable function toward x
</h2><span id='topic+is.decreasing.on.x'></span>

<h3>Description</h3>

<p><code>is.decreasing.on.x</code> tests for any fixed <code class="reqn">y</code> from <code>y.bound</code>, if the introduced two-variable function <code class="reqn">f(x,y)</code> is decreasing toward <code class="reqn">x</code> on the considered <code>x.bound</code> or not. 
In other words, <code>is.decreasing.on.x</code> returns <code>TRUE</code> if the introduced function <code class="reqn">f(x,y)</code> is decreasing function of <code class="reqn">x</code> on the considered <code>x.bound</code> (for any fixed <code class="reqn">y</code> in <code>y.bound</code>); and it returns <code>FALSE</code> otherwise.
The goal of introducing function <code>is.increasing.on.x</code> in package <code>FuzzyNumbers.Ext.2</code> is using in function <code>f2apply</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.decreasing.on.x(fun, x.bound = c(-1, 1), y.bound = c(-1, 1), step = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.decreasing.on.x_+3A_fun">fun</code></td>
<td>

<p>a two-variable R function
</p>
</td></tr>
<tr><td><code id="is.decreasing.on.x_+3A_x.bound">x.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on x-axis for checking the monotonic
</p>
</td></tr>
<tr><td><code id="is.decreasing.on.x_+3A_y.bound">y.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on y-axis for checking the monotonic
</p>
</td></tr>
<tr><td><code id="is.decreasing.on.x_+3A_step">step</code></td>
<td>

<p>a positive real-valued number which determine the increment of the considered sequence for checking the monotonic of the considered function. The default of <code>step</code> is 0.01. 
Increasing <code>step</code> value can cause the decreasing the time of computation and also cause the decreasing the precision of the calculations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for two-variable function f(x,y) which is decreasing toward x on <code>x.bound</code> (for any fixed <code class="reqn">y</code> from <code>y.bound</code>); and otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code>is.decreasing</code>, <code>is.decreasing.on.y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.decreasing.on.x(fun=function(x,y) 2*x+y, x.bound=c(0,2), y.bound=c(1,2), step=.2)

f = function(x,y) -x^2+y
is.decreasing.on.x(f, x.bound=c(0,2), y.bound=c(0,2))
is.decreasing.on.x(f, x.bound=c(-2,2), y.bound=c(0,2))

## The function is currently defined as
function (fun, x.bound = c(-1, 1), y.bound = c(-1, 1), step = 0.01) 
{
    y = seq(y.bound[1], y.bound[2], by = step)
    for (i in 1:length(y)) {
        g = function(x) fun(x, y[i])
        if (is.decreasing(g, x.bound, step) == FALSE) {
            return(FALSE)
        }
    }
    return(TRUE)
  }
</code></pre>

<hr>
<h2 id='is.decreasing.on.y'>
Diagnosis a decreasing two-variable function toward y
</h2><span id='topic+is.decreasing.on.y'></span>

<h3>Description</h3>

<p><code>is.decreasing.on.y</code> tests for any fixed <code class="reqn">x</code> from <code>x.bound</code>, if the introduced two-variable function <code class="reqn">f(x,y)</code> is decreasing toward <code class="reqn">y</code> on the considered <code>y.bound</code> or not. 
In other words, <code>is.decreasing.on.y</code> returns <code>TRUE</code> if the introduced function <code class="reqn">f(x,y)</code> is decreasing function of <code class="reqn">y</code> on the considered <code>y.bound</code> (for any fixed <code class="reqn">x</code> in <code>x.bound</code>); and it returns <code>FALSE</code> otherwise.
The goal of introducing function <code>is.decreasing.on.y</code> in package <code>FuzzyNumbers.Ext.2</code> is using in function <code>f2apply</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.decreasing.on.y(fun, x.bound = c(-1, 1), y.bound = c(-1, 1), step = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.decreasing.on.y_+3A_fun">fun</code></td>
<td>

<p>a two-variable R function
</p>
</td></tr>
<tr><td><code id="is.decreasing.on.y_+3A_x.bound">x.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on x-axis for checking the monotonic
</p>
</td></tr>
<tr><td><code id="is.decreasing.on.y_+3A_y.bound">y.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on y-axis for checking the monotonic
</p>
</td></tr>
<tr><td><code id="is.decreasing.on.y_+3A_step">step</code></td>
<td>

<p>a positive real-valued number which determine the increment of the considered sequence for checking the monotonic of the considered function. The default of <code>step</code> is 0.01. 
Increasing <code>step</code> value can cause the decreasing the time of computation and also cause the decreasing the precision of the calculations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for two-variable function f(x,y) which is decreasing toward y on <code>y.bound</code> (for any fixed <code class="reqn">x</code> from <code>x.bound</code>); and otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code>is.decreasing</code>, <code>is.decreasing.on.x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.decreasing.on.y(fun=function(x,y) 2*x-y, x.bound=c(0,2), y.bound=c(1,2), step=.2)

H = function(x,y) pnorm(x)-pnorm(y)
is.decreasing.on.x(H)
is.decreasing.on.y(H)

## The function is currently defined as
function (fun, x.bound = c(-1, 1), y.bound = c(-1, 1), step = 0.01) 
{
    x = seq(x.bound[1], x.bound[2], by = step)
    for (i in 1:length(x)) {
        g = function(y) fun(x[i], y)
        if (is.decreasing(g, y.bound, step) == FALSE) {
            return(FALSE)
        }
    }
    return(TRUE)
  }
</code></pre>

<hr>
<h2 id='is.increasing'>
Diagnosis an increasing function
</h2><span id='topic+is.increasing'></span>

<h3>Description</h3>

<p><code>is.increasing</code> tests if the introduced one-variable function is increasing (or in fact, non-decreasing) on the considered <code>x.bound</code> or not. 
In other words, <code>is.increasing</code> returns <code>TRUE</code> if the introduced function is increasing on the considered <code>x.bound</code>; and it returns <code>FALSE</code> otherwise.
The goal of introducing function <code>is.increasing</code> in package <code>FuzzyNumbers.Ext.2</code> is using in function <code>f2apply</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.increasing(fun, x.bound = c(-1, 1), step = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.increasing_+3A_fun">fun</code></td>
<td>

<p>a one-variable R function
</p>
</td></tr>
<tr><td><code id="is.increasing_+3A_x.bound">x.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on x-axis for checking the monotonic of the considered function
</p>
</td></tr>
<tr><td><code id="is.increasing_+3A_step">step</code></td>
<td>

<p>a positive real-valued number which determine the increment of the considered sequence for checking the monotonic of the considered function. The default of <code>step</code> is 0.01. 
Increasing <code>step</code> value can cause the decreasing the time of computation and also couse the decreasing the precision of the calculations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for increasing one-variable functions on the considered <code>x.bound</code>; otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code>is.decreasing</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.increasing(fun=function(x) 2*x, x.bound=c(4,6), step=.1)

g = function(x) x^2
is.increasing(g, x.bound=c(-24,6), step=.01)

h = function(x) x^5
is.increasing(h, c(-24,6), .01)
curve(h(x), xlim=c(-2,2))


## The function is currently defined as
function (fun, x.bound = c(-1, 1), step = 0.01) 
{
    x = seq(x.bound[1], x.bound[2], by = step)
    i = 1
    while (fun(x[i]) &lt;= fun(x[i + 1])) {
        if (i &lt; length(x) - 1) {
            i &lt;- i + 1
        }
        else (return(TRUE))
    }
    return(FALSE)
  }
</code></pre>

<hr>
<h2 id='is.increasing.on.x'>
Diagnosis an increasing two-variable function toward x
</h2><span id='topic+is.increasing.on.x'></span>

<h3>Description</h3>

<p><code>is.increasing.on.x</code> tests for any fixed <code class="reqn">y</code> from <code>y.bound</code>, if the introduced two-variable function <code class="reqn">f(x,y)</code> is increasing toward <code class="reqn">x</code> on the considered <code>x.bound</code> or not. 
In other words, <code>is.increasing.on.x</code> returns <code>TRUE</code> if the introduced function <code class="reqn">f(x,y)</code> is increasing function of <code class="reqn">x</code> on the considered <code>x.bound</code> (for any fixed <code class="reqn">y</code> in <code>y.bound</code>); and it returns <code>FALSE</code> otherwise.
The goal of introducing function <code>is.increasing.on.x</code> in package <code>FuzzyNumbers.Ext.2</code> is using in function <code>f2apply</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.increasing.on.x(fun, x.bound = c(-1, 1), y.bound = c(-1, 1), step = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.increasing.on.x_+3A_fun">fun</code></td>
<td>

<p>a two-variable R function
</p>
</td></tr>
<tr><td><code id="is.increasing.on.x_+3A_x.bound">x.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on x-axis for checking the monotonic
</p>
</td></tr>
<tr><td><code id="is.increasing.on.x_+3A_y.bound">y.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on y-axis for checking the monotonic
</p>
</td></tr>
<tr><td><code id="is.increasing.on.x_+3A_step">step</code></td>
<td>

<p>a positive real-valued number which determine the increment of the considered sequence for checking the monotonic of the considered function. The default of <code>step</code> is 0.01. 
Increasing <code>step</code> value can cause the decreasing the time of computation and also cause the decreasing the precision of the calculations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for two-variable function f(x,y) which is increasing toward x on <code>x.bound</code> (for any fixed <code class="reqn">y</code> from <code>y.bound</code>); and otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code>is.increasing</code>, <code>is.increasing.on.y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.increasing.on.x(fun=function(x,y) 2*x+y, x.bound=c(0,2), y.bound=c(1,2), step=.2)

f = function(x,y) x^2+y
is.increasing.on.x(f, x.bound=c(0,2), y.bound=c(0,2))
is.increasing.on.x(f, x.bound=c(-2,2), y.bound=c(0,2))
is.increasing.on.x(f, x.bound=c(0,2), y.bound=c(-2,2))

## The function is currently defined as
function (fun, x.bound = c(-1, 1), y.bound = c(-1, 1), step = 0.01) 
{
    y = seq(y.bound[1], y.bound[2], by = step)
    for (i in 1:length(y)) {
        g = function(x) fun(x, y[i])
        if (is.increasing(g, x.bound, step) == FALSE) {
            return(FALSE)
        }
    }
    return(TRUE)
  }
</code></pre>

<hr>
<h2 id='is.increasing.on.y'>
Diagnosis an increasing two-variable function toward y
</h2><span id='topic+is.increasing.on.y'></span>

<h3>Description</h3>

<p><code>is.increasing.on.y</code> tests for any fixed <code class="reqn">x</code> from <code>x.bound</code>, if the introduced two-variable function <code class="reqn">f(x,y)</code> is increasing toward <code class="reqn">y</code> on the considered <code>y.bound</code> or not. 
In other words, <code>is.increasing.on.y</code> returns <code>TRUE</code> if the introduced function <code class="reqn">f(x,y)</code> is increasing function of <code class="reqn">y</code> on the considered <code>y.bound</code> (for any fixed <code class="reqn">x</code> in <code>x.bound</code>); and it returns <code>FALSE</code> otherwise.
The goal of introducing function <code>is.increasing.on.y</code> in package <code>FuzzyNumbers.Ext.2</code> is using in function <code>f2apply</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.increasing.on.y(fun, x.bound = c(-1, 1), y.bound = c(-1, 1), step = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.increasing.on.y_+3A_fun">fun</code></td>
<td>

<p>a two-variable R function
</p>
</td></tr>
<tr><td><code id="is.increasing.on.y_+3A_x.bound">x.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on x-axis for checking the monotonic
</p>
</td></tr>
<tr><td><code id="is.increasing.on.y_+3A_y.bound">y.bound</code></td>
<td>

<p>a vector with two real ordered elements which determine a bound on y-axis for checking the monotonic
</p>
</td></tr>
<tr><td><code id="is.increasing.on.y_+3A_step">step</code></td>
<td>

<p>a positive real-valued number which determine the increment of the considered sequence for checking the monotonic of the considered function. The default of <code>step</code> is 0.01. 
Increasing <code>step</code> value can cause the decreasing the time of computation and also cause the decreasing the precision of the calculations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for two-variable function f(x,y) which is increasing toward y on <code>y.bound</code> (for any fixed <code class="reqn">x</code> from <code>x.bound</code>); and otherwise <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code>is.increasing</code>, <code>is.increasing.on.x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.increasing.on.y(fun=function(x,y) 2*x+y, x.bound=c(0,2), y.bound=c(1,2), step=.2)

f = function(x,y) 5*x+y^2
is.increasing.on.y(f, x.bound=c(0,2), y.bound=c(0,2))
is.increasing.on.y(f, x.bound=c(-2,2), y.bound=c(0,2))
is.increasing.on.y(f, x.bound=c(0,2), y.bound=c(-2,2))

H = function(x,y) pnorm(x)+y^2
is.increasing.on.x(H)
is.increasing.on.y(H)
is.increasing.on.y(H, x.bound=c(-3,3), y.bound=c(0,3))

## The function is currently defined as
function (fun, x.bound = c(-1, 1), y.bound = c(-1, 1), step = 0.01) 
{
    x = seq(x.bound[1], x.bound[2], by = step)
    for (i in 1:length(x)) {
        g = function(y) fun(x[i], y)
        if (is.increasing(g, y.bound, step) == FALSE) {
            return(FALSE)
        }
    }
    return(TRUE)
  }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
