<!DOCTYPE html><html><head><title>Help for package SHAPforxgboost</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SHAPforxgboost}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binner'><p>Bins a variable into n_bins quantile groups.</p></a></li>
<li><a href='#dataXY_df'><p>Terra satellite data (X,Y) for running the xgboost model .</p></a></li>
<li><a href='#label.feature'><p>Modify labels for features under plotting</p></a></li>
<li><a href='#labels_within_package'><p>labels_within_package: Some labels package auther defined to make his plot, mainly serve the paper publication.</p></a></li>
<li><a href='#new_labels'><p>new_labels: a place holder default to NULL.</p></a></li>
<li><a href='#plot.label'><p>Internal-function to revise axis label for each feature</p></a></li>
<li><a href='#scatter.plot.diagonal'><p>Make customized scatter plot with diagonal line and R2 printed.</p></a></li>
<li><a href='#scatter.plot.simple'><p>Simple scatter plot, adding marginal histogram by default.</p></a></li>
<li><a href='#shap_int_iris'><p>The interaction effect SHAP values example using iris dataset.</p></a></li>
<li><a href='#shap_long_iris'><p>The long-format SHAP values example using iris dataset.</p></a></li>
<li><a href='#shap_score'><p>SHAP values example from dataXY_df .</p></a></li>
<li><a href='#shap_values_iris'><p>SHAP values example using iris dataset.</p></a></li>
<li><a href='#shap.importance'><p>Variable importance as measured by mean absolute SHAP value.</p></a></li>
<li><a href='#shap.plot.dependence'><p>SHAP dependence plot and interaction plot, optional to be colored by a</p>
selected feature</a></li>
<li><a href='#shap.plot.force_plot'><p>Make the SHAP force plot</p></a></li>
<li><a href='#shap.plot.force_plot_bygroup'><p>Make the stack plot, optional to zoom in at certain x or certain cluster</p></a></li>
<li><a href='#shap.plot.summary'><p>SHAP summary plot core function using the long format SHAP values</p></a></li>
<li><a href='#shap.plot.summary.wrap1'><p>A wrapped function to make summary plot from model object and predictors</p></a></li>
<li><a href='#shap.plot.summary.wrap2'><p>A wrapped function to make summary plot from given SHAP values matrix</p></a></li>
<li><a href='#shap.prep'><p>Prepare SHAP values into long format for plotting</p></a></li>
<li><a href='#shap.prep.interaction'><p>Prepare the interaction SHAP values from predict.xgb.Booster</p></a></li>
<li><a href='#shap.prep.stack.data'><p>Prepare data for SHAP force plot (stack plot)</p></a></li>
<li><a href='#shap.values'><p>Get SHAP scores from a trained XGBoost or LightGBM model</p></a></li>
<li><a href='#strongest_interaction'><p>Finds variable with presumably strongest interaction effect.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>SHAP Plots for 'XGBoost'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Aid in visual data investigations
 using SHAP (SHapley Additive exPlanation) visualization plots for 'XGBoost' and 'LightGBM'. 
 It provides summary plot, dependence plot, interaction plot, and force plot and relies on
 the SHAP implementation provided by 'XGBoost' and 'LightGBM'.
 Please refer to 'slundberg/shap' for the original implementation of SHAP in 'Python'. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/liuyanguu/SHAPforxgboost">https://github.com/liuyanguu/SHAPforxgboost</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/liuyanguu/SHAPforxgboost/issues">https://github.com/liuyanguu/SHAPforxgboost/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2 (&ge; 3.0.0), xgboost (&ge; 0.81.0.0), data.table
(&ge; 1.12.0), ggforce (&ge; 0.2.1.9000), ggExtra (&ge; 0.8),
RColorBrewer (&ge; 1.1.2), ggpubr, BBmisc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, gridExtra (&ge; 2.3), here, parallel,
lightgbm (&ge; 2.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-29 16:58:03 UTC; lyhel</td>
</tr>
<tr>
<td>Author:</td>
<td>Yang Liu <a href="https://orcid.org/0000-0001-6557-6439"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Allan Just <a href="https://orcid.org/0000-0003-4312-5957"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    ctb],
  Michael Mayer [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yang Liu &lt;lyhello@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-29 17:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='binner'>Bins a variable into n_bins quantile groups.</h2><span id='topic+binner'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binner(y, n_bins = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binner_+3A_y">y</code></td>
<td>
<p>Numeric vector to be binned.</p>
</td></tr>
<tr><td><code id="binner_+3A_n_bins">n_bins</code></td>
<td>
<p>If <code>y</code> has up to this number of unique values, no binning is done.</p>
</td></tr>
</table>

<hr>
<h2 id='dataXY_df'>Terra satellite data (X,Y) for running the xgboost model .</h2><span id='topic+dataXY_df'></span>

<h3>Description</h3>

<p>Data.table, contains 9 features, and about 10,000 observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataXY_df
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 10148 rows and 10 columns.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.5281/zenodo.3568449">doi:10.5281/zenodo.3568449</a>
</p>

<hr>
<h2 id='label.feature'>Modify labels for features under plotting</h2><span id='topic+label.feature'></span>

<h3>Description</h3>

<p><code>label.feature</code> helps to modify labels. If a list is created in the global
environment named <strong>new_labels</strong> (<code>!is.null(new_labels</code>), the plots will
use that list to replace default list of labels
<code><a href="#topic+labels_within_package">labels_within_package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.feature(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label.feature_+3A_x">x</code></td>
<td>
<p>variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character, e.g. &quot;date&quot;, &quot;Time Trend&quot;, etc.
</p>

<hr>
<h2 id='labels_within_package'>labels_within_package: Some labels package auther defined to make his plot, mainly serve the paper publication.</h2><span id='topic+labels_within_package'></span>

<h3>Description</h3>

<p>It contains a list that match each feature to its labels. It is used in the function <code><a href="#topic+label.feature">label.feature</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels_within_package
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 20.
</p>


<h3>Details</h3>

<p>labels_within_package &lt;- list(
dayint = &quot;Time trend&quot;,
diffcwv = &quot;delta CWV (cm)&quot;,
date = &quot;&quot;,
Column_WV = &quot;MAIAC CWV (cm)&quot;,
AOT_Uncertainty = &quot;Blue band uncertainty&quot;,
elev = &quot;Elevation (m)&quot;,
aod = &quot;Aerosol optical depth&quot;,
RelAZ = &quot;Relative azimuth angle&quot;,
DevAll_P1km = expression(paste(&quot;Proportion developed area in 1&quot;,km^2)),
dist_water_km = &quot;Distance to water (km)&quot;,
forestProp_1km = expression(paste(&quot;Proportion of forest in 1&quot;,km^2)),
Aer_optical_depth = &quot;DSCOVR EPIC MAIAC AOD400nm&quot;,
aer_aod440 = &quot;AERONET AOD440nm&quot;,
aer_aod500 = &quot;AERONET AOD500nm&quot;,
diff440 = &quot;DSCOVR MAIAC - AERONET AOD&quot;,
diff440_pred = &quot;Predicted Error&quot;,
aer_aod440_hat = &quot;Predicted AERONET AOD440nm&quot;,
AOD_470nm = &quot;AERONET AOD470nm&quot;,
Optical_Depth_047_t = &quot;MAIAC AOD470nm (Terra)&quot;,
Optical_Depth_047_a = &quot;MAIAC AOD470nm (Aqua)&quot;
)
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.5281/zenodo.3568449">doi:10.5281/zenodo.3568449</a>
</p>

<hr>
<h2 id='new_labels'>new_labels: a place holder default to NULL.</h2><span id='topic+new_labels'></span>

<h3>Description</h3>

<p>if supplied as a list, it offers user to rename labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_labels
</code></pre>


<h3>Format</h3>

<p>An object of class <code>NULL</code> of length 0.
</p>

<hr>
<h2 id='plot.label'>Internal-function to revise axis label for each feature</h2><span id='topic+plot.label'></span>

<h3>Description</h3>

<p>This function further fine-tune the format of each feature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'label'
plot(plot1, show_feature)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.label_+3A_plot1">plot1</code></td>
<td>
<p>ggplot2 object</p>
</td></tr>
<tr><td><code id="plot.label_+3A_show_feature">show_feature</code></td>
<td>
<p>feature to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns ggplot2 object with further mordified layers based on the feature
</p>

<hr>
<h2 id='scatter.plot.diagonal'>Make customized scatter plot with diagonal line and R2 printed.</h2><span id='topic+scatter.plot.diagonal'></span>

<h3>Description</h3>

<p>Make customized scatter plot with diagonal line and R2 printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter.plot.diagonal(
  data,
  x,
  y,
  size0 = 0.2,
  alpha0 = 0.3,
  dilute = FALSE,
  add_abline = FALSE,
  add_hist = TRUE,
  add_stat_cor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter.plot.diagonal_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="scatter.plot.diagonal_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="scatter.plot.diagonal_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="scatter.plot.diagonal_+3A_size0">size0</code></td>
<td>
<p>point size, default to 1 of nobs&lt;1000, 0.4 if nobs&gt;1000</p>
</td></tr>
<tr><td><code id="scatter.plot.diagonal_+3A_alpha0">alpha0</code></td>
<td>
<p>alpha of point</p>
</td></tr>
<tr><td><code id="scatter.plot.diagonal_+3A_dilute">dilute</code></td>
<td>
<p>a number or logical, dafault to TRUE, will plot
<code>nrow(data_long)/dilute</code> data. For example, if dilute = 5 will plot
1/5 of the data. if dilute = TRUE will plot half of the data.</p>
</td></tr>
<tr><td><code id="scatter.plot.diagonal_+3A_add_abline">add_abline</code></td>
<td>
<p>default to FALSE, add a diagonal line <code>ggExtra::ggMarginal</code>
but notice if add histogram, what is returned is no longer a ggplot2 object</p>
</td></tr>
<tr><td><code id="scatter.plot.diagonal_+3A_add_hist">add_hist</code></td>
<td>
<p>optional to add marginal histogram using
<code>ggExtra::ggMarginal</code> but notice if add histogram, what is returned is no
longer a ggplot2 object</p>
</td></tr>
<tr><td><code id="scatter.plot.diagonal_+3A_add_stat_cor">add_stat_cor</code></td>
<td>
<p>add correlation and p-value from <code>ggpubr::stat_cor</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object if <code>add_hist = FALSE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scatter.plot.diagonal(data = iris, x = "Sepal.Length", y = "Petal.Length")

</code></pre>

<hr>
<h2 id='scatter.plot.simple'>Simple scatter plot, adding marginal histogram by default.</h2><span id='topic+scatter.plot.simple'></span>

<h3>Description</h3>

<p>Simple scatter plot, adding marginal histogram by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter.plot.simple(
  data,
  x,
  y,
  size0 = 0.2,
  alpha0 = 0.3,
  dilute = FALSE,
  add_hist = TRUE,
  add_stat_cor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter.plot.simple_+3A_data">data</code></td>
<td>
<p>dataset</p>
</td></tr>
<tr><td><code id="scatter.plot.simple_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="scatter.plot.simple_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="scatter.plot.simple_+3A_size0">size0</code></td>
<td>
<p>point size, default to 1 of nobs&lt;1000, 0.4 if nobs&gt;1000</p>
</td></tr>
<tr><td><code id="scatter.plot.simple_+3A_alpha0">alpha0</code></td>
<td>
<p>alpha of point</p>
</td></tr>
<tr><td><code id="scatter.plot.simple_+3A_dilute">dilute</code></td>
<td>
<p>a number or logical, dafault to TRUE, will plot
<code>nrow(data_long)/dilute</code> data. For example, if dilute = 5 will plot
1/5 of the data. if dilute = TRUE will plot half of the data.</p>
</td></tr>
<tr><td><code id="scatter.plot.simple_+3A_add_hist">add_hist</code></td>
<td>
<p>optional to add marginal histogram using
<code>ggExtra::ggMarginal</code> but notice if add histogram, what is returned is no
longer a ggplot2 object</p>
</td></tr>
<tr><td><code id="scatter.plot.simple_+3A_add_stat_cor">add_stat_cor</code></td>
<td>
<p>add correlation and p-value from <code>ggpubr::stat_cor</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object if <code>add_hist = FALSE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scatter.plot.simple(data = iris, x = "Sepal.Length", y = "Petal.Length")

</code></pre>

<hr>
<h2 id='shap_int_iris'>The interaction effect SHAP values example using iris dataset.</h2><span id='topic+shap_int_iris'></span>

<h3>Description</h3>

<p>The interaction effect SHAP values example using iris dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap_int_iris
</code></pre>


<h3>Format</h3>

<p>An object of class <code>array</code> of dimension 150 x 5 x 5.
</p>

<hr>
<h2 id='shap_long_iris'>The long-format SHAP values example using iris dataset.</h2><span id='topic+shap_long_iris'></span>

<h3>Description</h3>

<p>The long-format SHAP values example using iris dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap_long_iris
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 600 rows and 6 columns.
</p>

<hr>
<h2 id='shap_score'>SHAP values example from dataXY_df .</h2><span id='topic+shap_score'></span>

<h3>Description</h3>

<p>SHAP values example from dataXY_df .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap_score
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 10148 rows and 9 columns.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.5281/zenodo.3568449">doi:10.5281/zenodo.3568449</a>
</p>

<hr>
<h2 id='shap_values_iris'>SHAP values example using iris dataset.</h2><span id='topic+shap_values_iris'></span>

<h3>Description</h3>

<p>SHAP values example using iris dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap_values_iris
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 150 rows and 4 columns.
</p>

<hr>
<h2 id='shap.importance'>Variable importance as measured by mean absolute SHAP value.</h2><span id='topic+shap.importance'></span>

<h3>Description</h3>

<p>Variable importance as measured by mean absolute SHAP value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.importance(data_long, names_only = FALSE, top_n = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.importance_+3A_data_long">data_long</code></td>
<td>
<p>a long format data of SHAP values from
<code><a href="#topic+shap.prep">shap.prep</a></code></p>
</td></tr>
<tr><td><code id="shap.importance_+3A_names_only">names_only</code></td>
<td>
<p>If <code>TRUE</code>, returns variable names only.</p>
</td></tr>
<tr><td><code id="shap.importance_+3A_top_n">top_n</code></td>
<td>
<p>How many variables to be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns <code>data.table</code> with average absolute SHAP
values per variable, sorted in decreasing order of importance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
shap.importance(shap_long_iris)

shap.importance(shap_long_iris, names_only = 1)

</code></pre>

<hr>
<h2 id='shap.plot.dependence'>SHAP dependence plot and interaction plot, optional to be colored by a
selected feature</h2><span id='topic+shap.plot.dependence'></span>

<h3>Description</h3>

<p>This function by default makes a simple dependence plot with feature values
on the x-axis and SHAP values on the y-axis, optional to color by another
feature. It is optional to use a different variable for SHAP values on the
y-axis, and color the points by the feature value of a designated variable.
Not colored if <code>color_feature</code> is not supplied. If <code>data_int</code> (the
SHAP interaction values dataset) is supplied, it will plot the interaction
effect between <code>y</code> and <code>x</code> on the y-axis. Dependence plot is easy
to make if you have the SHAP values dataset from <code>predict.xgb.Booster</code>
or <code>predict.lgb.Booster</code>.
It is not necessary to start with the long format data, but since that is
used for the summary plot, we just continue to use it here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.plot.dependence(
  data_long,
  x,
  y = NULL,
  color_feature = NULL,
  data_int = NULL,
  dilute = FALSE,
  smooth = TRUE,
  size0 = NULL,
  add_hist = FALSE,
  add_stat_cor = FALSE,
  alpha = NULL,
  jitter_height = 0,
  jitter_width = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.plot.dependence_+3A_data_long">data_long</code></td>
<td>
<p>the long format SHAP values from <code><a href="#topic+shap.prep">shap.prep</a></code></p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_x">x</code></td>
<td>
<p>which feature to show on x-axis, it will plot the feature value</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_y">y</code></td>
<td>
<p>which shap values to show on y-axis, it will plot the SHAP value of
that feature. y is default to x, if y is not provided, just plot the SHAP
values of x on the y-axis</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_color_feature">color_feature</code></td>
<td>
<p>which feature value to use for coloring, color by the
feature value. If &quot;auto&quot;, will select the feature &quot;c&quot; minimizing the
variance of the shap value given x and c, which can be viewed as a
heuristic for the strongest interaction.</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_data_int">data_int</code></td>
<td>
<p>the 3-dimention SHAP interaction values array. if <code>data_int</code>
is supplied, y-axis will plot the interaction values of y (vs. x).
<code>data_int</code> is obtained from either <code>predict.xgb.Booster</code> or
<code><a href="#topic+shap.prep.interaction">shap.prep.interaction</a></code></p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_dilute">dilute</code></td>
<td>
<p>a number or logical, dafault to TRUE, will plot
<code>nrow(data_long)/dilute</code> data. For example, if dilute = 5 will plot
20% of the data. As long as dilute != FALSE, will plot at most half the
data</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_smooth">smooth</code></td>
<td>
<p>optional to add a <em>loess</em> smooth line, default to TRUE.</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_size0">size0</code></td>
<td>
<p>point size, default to 1 if nobs&lt;1000, 0.4 if nobs&gt;1000</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_add_hist">add_hist</code></td>
<td>
<p>whether to add histogram using <code>ggMarginal</code>, default to
TRUE. But notice the plot after adding histogram is a <code>ggExtraPlot</code> object
instead of <code>ggplot2</code> so cannot add <code>geom</code> to that anymore. Turn the
histogram off if you wish to add more <code>ggplot2</code> geoms</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_add_stat_cor">add_stat_cor</code></td>
<td>
<p>add correlation and p-value from <code>ggpubr::stat_cor</code></p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_alpha">alpha</code></td>
<td>
<p>point transparancy, default to 1 if nobs&lt;1000 else 0.6</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_jitter_height">jitter_height</code></td>
<td>
<p>amount of vertical jitter (see hight in <code>geom_jitter</code>)</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_jitter_width">jitter_width</code></td>
<td>
<p>amount of horizontal jitter (see width in <code>geom_jitter</code>). Use values close to 0, e.g. 0.02</p>
</td></tr>
<tr><td><code id="shap.plot.dependence_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>geom_jitter</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>be default a <code>ggplot2</code> object, based on which you could add more geom
layers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># **SHAP dependence plot**

# 1. simple dependence plot with SHAP values of x on the y axis
shap.plot.dependence(data_long = shap_long_iris, x="Petal.Length",
                     add_hist = TRUE, add_stat_cor = TRUE)

# 2. can choose a different SHAP values on the y axis
shap.plot.dependence(data_long = shap_long_iris, x="Petal.Length",
                           y = "Petal.Width")

# 3. color by another feature's feature values
shap.plot.dependence(data_long = shap_long_iris, x="Petal.Length",
                           color_feature = "Petal.Width")

# 4. choose 3 different variables for x, y, and color
shap.plot.dependence(data_long = shap_long_iris, x="Petal.Length",
                           y = "Petal.Width", color_feature = "Petal.Width")

# Optional to add hist or remove smooth line, optional to plot fewer data (make plot quicker)
shap.plot.dependence(data_long = shap_long_iris, x="Petal.Length",
                     y = "Petal.Width", color_feature = "Petal.Width",
                     add_hist = TRUE, smooth = FALSE, dilute = 3)

# to make a list of plot
plot_list &lt;- lapply(names(iris)[2:3], shap.plot.dependence, data_long = shap_long_iris)

# **SHAP interaction effect plot **

# To get the interaction SHAP dataset for plotting, need to get `shap_int` first:
mod1 = xgboost::xgboost(
  data = as.matrix(iris[,-5]), label = iris$Species,
  gamma = 0, eta = 1, lambda = 0,nrounds = 1, verbose = FALSE, nthread = 1)
# Use either:
data_int &lt;- shap.prep.interaction(xgb_mod = mod1,
                                  X_train = as.matrix(iris[,-5]))
# or:
shap_int &lt;- predict(mod1, as.matrix(iris[,-5]),
                    predinteraction = TRUE)

# if data_int is supplied, y axis will plot the interaction values of y (vs. x)
shap.plot.dependence(data_long = shap_long_iris,
                           data_int = shap_int_iris,
                           x="Petal.Length",
                           y = "Petal.Width",
                           color_feature = "Petal.Width")
</code></pre>

<hr>
<h2 id='shap.plot.force_plot'>Make the SHAP force plot</h2><span id='topic+shap.plot.force_plot'></span>

<h3>Description</h3>

<p>The force/stack plot, optional to zoom in at certain x-axis location or zoom
in a specific cluster of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.plot.force_plot(
  shapobs,
  id = "sorted_id",
  zoom_in_location = NULL,
  y_parent_limit = NULL,
  y_zoomin_limit = NULL,
  zoom_in = TRUE,
  zoom_in_group = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.plot.force_plot_+3A_shapobs">shapobs</code></td>
<td>
<p>The dataset obtained by <code>shap.prep.stack.data</code>.</p>
</td></tr>
<tr><td><code id="shap.plot.force_plot_+3A_id">id</code></td>
<td>
<p>the id variable.</p>
</td></tr>
<tr><td><code id="shap.plot.force_plot_+3A_zoom_in_location">zoom_in_location</code></td>
<td>
<p>where to zoom in, default at place of 60 percent of
the data.</p>
</td></tr>
<tr><td><code id="shap.plot.force_plot_+3A_y_parent_limit">y_parent_limit</code></td>
<td>
<p>set y-axis limits.</p>
</td></tr>
<tr><td><code id="shap.plot.force_plot_+3A_y_zoomin_limit">y_zoomin_limit</code></td>
<td>
<p><code>c(a,b)</code> to limit the y-axis in zoom-in.</p>
</td></tr>
<tr><td><code id="shap.plot.force_plot_+3A_zoom_in">zoom_in</code></td>
<td>
<p>default to TRUE, zoom in by <code>ggforce::facet_zoom</code>.</p>
</td></tr>
<tr><td><code id="shap.plot.force_plot_+3A_zoom_in_group">zoom_in_group</code></td>
<td>
<p>optional to zoom in certain cluster.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# **SHAP force plot**
plot_data &lt;- shap.prep.stack.data(shap_contrib = shap_values_iris,
                                  n_groups = 4)
shap.plot.force_plot(plot_data)
shap.plot.force_plot(plot_data,  zoom_in_group = 2)

# plot all the clusters:
shap.plot.force_plot_bygroup(plot_data)
</code></pre>

<hr>
<h2 id='shap.plot.force_plot_bygroup'>Make the stack plot, optional to zoom in at certain x or certain cluster</h2><span id='topic+shap.plot.force_plot_bygroup'></span>

<h3>Description</h3>

<p>A collective display of zoom-in plots: one plot for every group of the
clustered observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.plot.force_plot_bygroup(shapobs, id = "sorted_id", y_parent_limit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.plot.force_plot_bygroup_+3A_shapobs">shapobs</code></td>
<td>
<p>The dataset obtained by <code>shap.prep.stack.data</code>.</p>
</td></tr>
<tr><td><code id="shap.plot.force_plot_bygroup_+3A_id">id</code></td>
<td>
<p>the id variable.</p>
</td></tr>
<tr><td><code id="shap.plot.force_plot_bygroup_+3A_y_parent_limit">y_parent_limit</code></td>
<td>
<p>set y-axis limits.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# **SHAP force plot**
plot_data &lt;- shap.prep.stack.data(shap_contrib = shap_values_iris,
                                  n_groups = 4)
shap.plot.force_plot(plot_data)
shap.plot.force_plot(plot_data,  zoom_in_group = 2)

# plot all the clusters:
shap.plot.force_plot_bygroup(plot_data)
</code></pre>

<hr>
<h2 id='shap.plot.summary'>SHAP summary plot core function using the long format SHAP values</h2><span id='topic+shap.plot.summary'></span>

<h3>Description</h3>

<p>The summary plot (a sina plot) uses a long format data of SHAP values. The
SHAP values could be obtained from either a XGBoost/LightGBM model or a SHAP value
matrix using <code><a href="#topic+shap.values">shap.values</a></code>. So this summary plot function
normally follows the long format dataset obtained using <code>shap.values</code>. If you
want to start with a model and data_X, use
<code><a href="#topic+shap.plot.summary.wrap1">shap.plot.summary.wrap1</a></code>. If you want to use a self-derived
dataset of SHAP values, use <code><a href="#topic+shap.plot.summary.wrap2">shap.plot.summary.wrap2</a></code>. If a list
named <strong>new_labels</strong> is provided in the global environment (<code>new_labels</code> is
pre-loaded by the package as <code>NULL</code>), the plots will use that list to
label the variables, here is an example of such a list (the default labels):
<code><a href="#topic+labels_within_package">labels_within_package</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.plot.summary(
  data_long,
  x_bound = NULL,
  dilute = FALSE,
  scientific = FALSE,
  my_format = NULL,
  min_color_bound = "#FFCC33",
  max_color_bound = "#6600CC",
  kind = c("sina", "bar")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.plot.summary_+3A_data_long">data_long</code></td>
<td>
<p>a long format data of SHAP values from
<code><a href="#topic+shap.prep">shap.prep</a></code></p>
</td></tr>
<tr><td><code id="shap.plot.summary_+3A_x_bound">x_bound</code></td>
<td>
<p>use to set horizontal axis limit in the plot</p>
</td></tr>
<tr><td><code id="shap.plot.summary_+3A_dilute">dilute</code></td>
<td>
<p>being numeric or logical (TRUE/FALSE), it aims to help make the test
plot for large amount of data faster. If dilute = 5 will plot 1/5 of the
data. If dilute = TRUE or a number, will plot at most half points per
feature, so the plotting won't be too slow. If you put dilute too high, at
least 10 points per feature would be kept. If the dataset is too small
after dilution, will just plot all the data</p>
</td></tr>
<tr><td><code id="shap.plot.summary_+3A_scientific">scientific</code></td>
<td>
<p>show the mean|SHAP| in scientific format. If TRUE, label
format is 0.0E-0, default to FALSE, and the format will be 0.000</p>
</td></tr>
<tr><td><code id="shap.plot.summary_+3A_my_format">my_format</code></td>
<td>
<p>supply your own number format if you really want</p>
</td></tr>
<tr><td><code id="shap.plot.summary_+3A_min_color_bound">min_color_bound</code></td>
<td>
<p>min color hex code for colormap. Color gradient is
scaled between min_color_bound and max_color_bound. Default is &quot;#FFCC33&quot;.</p>
</td></tr>
<tr><td><code id="shap.plot.summary_+3A_max_color_bound">max_color_bound</code></td>
<td>
<p>max color hex code for colormap. Color gradient is
scaled between min_color_bound and max_color_bound. Default is &quot;#6600CC&quot;.</p>
</td></tr>
<tr><td><code id="shap.plot.summary_+3A_kind">kind</code></td>
<td>
<p>By default, a &quot;sina&quot; plot is shown. As an alternative,
set <code>kind = "bar"</code> to visualize mean absolute SHAP values as a
barplot. Its color is controlled by <code>max_color_bound</code>. Other
arguments are ignored for this kind of plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a ggplot2 object, could add further layers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X1 = as.matrix(iris[,-5])
mod1 = xgboost::xgboost(
  data = X1, label = iris$Species, gamma = 0, eta = 1,
  lambda = 0, nrounds = 1, verbose = FALSE, nthread = 1)

# shap.values(model, X_dataset) returns the SHAP
# data matrix and ranked features by mean|SHAP|
shap_values &lt;- shap.values(xgb_model = mod1, X_train = X1)
shap_values$mean_shap_score
shap_values_iris &lt;- shap_values$shap_score

# shap.prep() returns the long-format SHAP data from either model or
shap_long_iris &lt;- shap.prep(xgb_model = mod1, X_train = X1)
# is the same as: using given shap_contrib
shap_long_iris &lt;- shap.prep(shap_contrib = shap_values_iris, X_train = X1)

# **SHAP summary plot**
shap.plot.summary(shap_long_iris, scientific = TRUE)
shap.plot.summary(shap_long_iris, x_bound  = 1.5, dilute = 10)

# Alternatives options to make the same plot:
# option 1: from the xgboost model
shap.plot.summary.wrap1(mod1, X = as.matrix(iris[,-5]), top_n = 3)

# option 2: supply a self-made SHAP values dataset
# (e.g. sometimes as output from cross-validation)
shap.plot.summary.wrap2(shap_score = shap_values_iris, X = X1, top_n = 3)
</code></pre>

<hr>
<h2 id='shap.plot.summary.wrap1'>A wrapped function to make summary plot from model object and predictors</h2><span id='topic+shap.plot.summary.wrap1'></span>

<h3>Description</h3>

<p><code>shap.plot.summary.wrap1</code> wraps up function <code><a href="#topic+shap.prep">shap.prep</a></code> and
<code><a href="#topic+shap.plot.summary">shap.plot.summary</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.plot.summary.wrap1(model, X, top_n, dilute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.plot.summary.wrap1_+3A_model">model</code></td>
<td>
<p>the model</p>
</td></tr>
<tr><td><code id="shap.plot.summary.wrap1_+3A_x">X</code></td>
<td>
<p>the dataset of predictors used for calculating SHAP</p>
</td></tr>
<tr><td><code id="shap.plot.summary.wrap1_+3A_top_n">top_n</code></td>
<td>
<p>how many predictors you want to show in the plot (ranked)</p>
</td></tr>
<tr><td><code id="shap.plot.summary.wrap1_+3A_dilute">dilute</code></td>
<td>
<p>being numeric or logical (TRUE/FALSE), it aims to help make the test
plot for large amount of data faster. If dilute = 5 will plot 1/5 of the
data. If dilute = TRUE or a number, will plot at most half points per
feature, so the plotting won't be too slow. If you put dilute too high, at
least 10 points per feature would be kept. If the dataset is too small
after dilution, will just plot all the data</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X1 = as.matrix(iris[,-5])
mod1 = xgboost::xgboost(
  data = X1, label = iris$Species, gamma = 0, eta = 1,
  lambda = 0, nrounds = 1, verbose = FALSE, nthread = 1)

# shap.values(model, X_dataset) returns the SHAP
# data matrix and ranked features by mean|SHAP|
shap_values &lt;- shap.values(xgb_model = mod1, X_train = X1)
shap_values$mean_shap_score
shap_values_iris &lt;- shap_values$shap_score

# shap.prep() returns the long-format SHAP data from either model or
shap_long_iris &lt;- shap.prep(xgb_model = mod1, X_train = X1)
# is the same as: using given shap_contrib
shap_long_iris &lt;- shap.prep(shap_contrib = shap_values_iris, X_train = X1)

# **SHAP summary plot**
shap.plot.summary(shap_long_iris, scientific = TRUE)
shap.plot.summary(shap_long_iris, x_bound  = 1.5, dilute = 10)

# Alternatives options to make the same plot:
# option 1: from the xgboost model
shap.plot.summary.wrap1(mod1, X = as.matrix(iris[,-5]), top_n = 3)

# option 2: supply a self-made SHAP values dataset
# (e.g. sometimes as output from cross-validation)
shap.plot.summary.wrap2(shap_score = shap_values_iris, X = X1, top_n = 3)
</code></pre>

<hr>
<h2 id='shap.plot.summary.wrap2'>A wrapped function to make summary plot from given SHAP values matrix</h2><span id='topic+shap.plot.summary.wrap2'></span>

<h3>Description</h3>

<p><code>shap.plot.summary.wrap2</code> wraps up function <code><a href="#topic+shap.prep">shap.prep</a></code> and
<code><a href="#topic+shap.plot.summary">shap.plot.summary</a></code>. Since SHAP matrix could be returned from
cross-validation instead of only one model, here the wrapped
<code><a href="#topic+shap.prep">shap.prep</a></code> takes the SHAP score matrix <code>shap_score</code> as input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.plot.summary.wrap2(shap_score, X, top_n, dilute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.plot.summary.wrap2_+3A_shap_score">shap_score</code></td>
<td>
<p>the SHAP values dataset, could be obtained by
<code>shap.prep</code></p>
</td></tr>
<tr><td><code id="shap.plot.summary.wrap2_+3A_x">X</code></td>
<td>
<p>the dataset of predictors used for calculating SHAP values</p>
</td></tr>
<tr><td><code id="shap.plot.summary.wrap2_+3A_top_n">top_n</code></td>
<td>
<p>how many predictors you want to show in the plot (ranked)</p>
</td></tr>
<tr><td><code id="shap.plot.summary.wrap2_+3A_dilute">dilute</code></td>
<td>
<p>being numeric or logical (TRUE/FALSE), it aims to help make the test
plot for large amount of data faster. If dilute = 5 will plot 1/5 of the
data. If dilute = TRUE or a number, will plot at most half points per
feature, so the plotting won't be too slow. If you put dilute too high, at
least 10 points per feature would be kept. If the dataset is too small
after dilution, will just plot all the data</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X1 = as.matrix(iris[,-5])
mod1 = xgboost::xgboost(
  data = X1, label = iris$Species, gamma = 0, eta = 1,
  lambda = 0, nrounds = 1, verbose = FALSE, nthread = 1)

# shap.values(model, X_dataset) returns the SHAP
# data matrix and ranked features by mean|SHAP|
shap_values &lt;- shap.values(xgb_model = mod1, X_train = X1)
shap_values$mean_shap_score
shap_values_iris &lt;- shap_values$shap_score

# shap.prep() returns the long-format SHAP data from either model or
shap_long_iris &lt;- shap.prep(xgb_model = mod1, X_train = X1)
# is the same as: using given shap_contrib
shap_long_iris &lt;- shap.prep(shap_contrib = shap_values_iris, X_train = X1)

# **SHAP summary plot**
shap.plot.summary(shap_long_iris, scientific = TRUE)
shap.plot.summary(shap_long_iris, x_bound  = 1.5, dilute = 10)

# Alternatives options to make the same plot:
# option 1: from the xgboost model
shap.plot.summary.wrap1(mod1, X = as.matrix(iris[,-5]), top_n = 3)

# option 2: supply a self-made SHAP values dataset
# (e.g. sometimes as output from cross-validation)
shap.plot.summary.wrap2(shap_score = shap_values_iris, X = X1, top_n = 3)
</code></pre>

<hr>
<h2 id='shap.prep'>Prepare SHAP values into long format for plotting</h2><span id='topic+shap.prep'></span>

<h3>Description</h3>

<p>Produce a dataset of 6 columns: ID of each observation, variable name, SHAP
value, variable values (feature value), deviation of the feature value for
each observation (for coloring the point), and the mean SHAP values for each
variable. You can view this example dataset included in the package:
<code><a href="#topic+shap_long_iris">shap_long_iris</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.prep(
  xgb_model = NULL,
  shap_contrib = NULL,
  X_train,
  top_n = NULL,
  var_cat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.prep_+3A_xgb_model">xgb_model</code></td>
<td>
<p>an XGBoost (or LightGBM) model object, will derive the SHAP values from it</p>
</td></tr>
<tr><td><code id="shap.prep_+3A_shap_contrib">shap_contrib</code></td>
<td>
<p>optional to directly supply a SHAP values dataset. If
supplied, it will overwrite the <code>xgb_model</code> if <code>xgb_model</code> is also supplied</p>
</td></tr>
<tr><td><code id="shap.prep_+3A_x_train">X_train</code></td>
<td>
<p>the dataset of predictors used to calculate SHAP values, it
provides feature values to the plot, must be supplied</p>
</td></tr>
<tr><td><code id="shap.prep_+3A_top_n">top_n</code></td>
<td>
<p>to choose top_n variables ranked by mean|SHAP| if needed</p>
</td></tr>
<tr><td><code id="shap.prep_+3A_var_cat">var_cat</code></td>
<td>
<p>if supplied, will provide long format data, grouped by this
categorical variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ID variable is added for each observation in the <code>shap_contrib</code> dataset
for better tracking, it is created as <code>1:nrow(shap_contrib)</code> before melting
<code>shap_contrib</code> into long format.
</p>


<h3>Value</h3>

<p>a long-format data.table, named as <code>shap_long</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X1 = as.matrix(iris[,-5])
mod1 = xgboost::xgboost(
  data = X1, label = iris$Species, gamma = 0, eta = 1,
  lambda = 0, nrounds = 1, verbose = FALSE, nthread = 1)

# shap.values(model, X_dataset) returns the SHAP
# data matrix and ranked features by mean|SHAP|
shap_values &lt;- shap.values(xgb_model = mod1, X_train = X1)
shap_values$mean_shap_score
shap_values_iris &lt;- shap_values$shap_score

# shap.prep() returns the long-format SHAP data from either model or
shap_long_iris &lt;- shap.prep(xgb_model = mod1, X_train = X1)
# is the same as: using given shap_contrib
shap_long_iris &lt;- shap.prep(shap_contrib = shap_values_iris, X_train = X1)

# **SHAP summary plot**
shap.plot.summary(shap_long_iris, scientific = TRUE)
shap.plot.summary(shap_long_iris, x_bound  = 1.5, dilute = 10)

# Alternatives options to make the same plot:
# option 1: from the xgboost model
shap.plot.summary.wrap1(mod1, X = as.matrix(iris[,-5]), top_n = 3)

# option 2: supply a self-made SHAP values dataset
# (e.g. sometimes as output from cross-validation)
shap.plot.summary.wrap2(shap_score = shap_values_iris, X = X1, top_n = 3)
####
#
# use `var_cat` to add a categorical variable, output the long-format data differently:
library("data.table")
data("iris")
set.seed(123)
iris$Group &lt;- 0
iris[sample(1:nrow(iris), nrow(iris)/2), "Group"] &lt;- 1

data.table::setDT(iris)
X_train = as.matrix(iris[,c(colnames(iris)[1:4], "Group"), with = FALSE])
mod1 = xgboost::xgboost(
  data = X_train, label = iris$Species, gamma = 0, eta = 1,
  lambda = 0, nrounds = 1, verbose = FALSE, nthread = 1)

shap_long2 &lt;- shap.prep(xgb_model = mod1, X_train = X_train, var_cat = "Group")
# **SHAP summary plot**
shap.plot.summary(shap_long2, scientific = TRUE) +
  ggplot2::facet_wrap(~ Group)
</code></pre>

<hr>
<h2 id='shap.prep.interaction'>Prepare the interaction SHAP values from predict.xgb.Booster</h2><span id='topic+shap.prep.interaction'></span>

<h3>Description</h3>

<p><code>shap.prep.interaction</code> just runs <code>shap_int &lt;- predict(xgb_mod, (X_train), predinteraction = TRUE)</code>, thus it may not be necessary.
Read more about the xgboost predict function at <code>xgboost::predict.xgb.Booster</code>. Note that this functionality is unavailable for LightGBM models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.prep.interaction(xgb_model, X_train)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.prep.interaction_+3A_xgb_model">xgb_model</code></td>
<td>
<p>a xgboost model object</p>
</td></tr>
<tr><td><code id="shap.prep.interaction_+3A_x_train">X_train</code></td>
<td>
<p>the dataset of predictors used for the xgboost model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3-dimention array: #obs x #features x #features
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To get the interaction SHAP dataset for plotting:
# fit the xgboost model

# options("Ncup" = 1)
mod1 = xgboost::xgboost(
  data = as.matrix(iris[,-5]), label = iris$Species,
  gamma = 0, eta = 1, lambda = 0, nrounds = 1, verbose = FALSE, nthread = 1)
# Use either:
data_int &lt;- shap.prep.interaction(xgb_mod = mod1,
                                  X_train = as.matrix(iris[,-5]))
# or:
shap_int &lt;- predict(mod1, as.matrix(iris[,-5]),
                    predinteraction = TRUE)

# **SHAP interaction effect plot **
shap.plot.dependence(data_long = shap_long_iris,
                           data_int = shap_int_iris,
                           x="Petal.Length",
                           y = "Petal.Width",
                           color_feature = "Petal.Width")
</code></pre>

<hr>
<h2 id='shap.prep.stack.data'>Prepare data for SHAP force plot (stack plot)</h2><span id='topic+shap.prep.stack.data'></span>

<h3>Description</h3>

<p>Make force plot for <code>top_n</code> features, optional to randomly plot certain
portion of the data in case the dataset is large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.prep.stack.data(
  shap_contrib,
  top_n = NULL,
  data_percent = 1,
  cluster_method = "ward.D",
  n_groups = 10L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.prep.stack.data_+3A_shap_contrib">shap_contrib</code></td>
<td>
<p>shap_contrib is the SHAP value data returned from
predict, here an ID variable is added for each observation in
the <code>shap_contrib</code> dataset for better tracking, it is created in the
begining as <code>1:nrow(shap_contrib)</code>. The ID matches the output from
<code><a href="#topic+shap.prep">shap.prep</a></code></p>
</td></tr>
<tr><td><code id="shap.prep.stack.data_+3A_top_n">top_n</code></td>
<td>
<p>integer, optional to show only top_n features, combine the rest</p>
</td></tr>
<tr><td><code id="shap.prep.stack.data_+3A_data_percent">data_percent</code></td>
<td>
<p>what percent of data to plot (to speed up the testing
plot). The accepted input range is (0,1], if observations left is too few,
there will be an error from the clustering function</p>
</td></tr>
<tr><td><code id="shap.prep.stack.data_+3A_cluster_method">cluster_method</code></td>
<td>
<p>default to ward.D, please refer to <code>stats::hclust</code> for
details</p>
</td></tr>
<tr><td><code id="shap.prep.stack.data_+3A_n_groups">n_groups</code></td>
<td>
<p>a integer, how many groups to plot in
<code><a href="#topic+shap.plot.force_plot_bygroup">shap.plot.force_plot_bygroup</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset for stack plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# **SHAP force plot**
plot_data &lt;- shap.prep.stack.data(shap_contrib = shap_values_iris,
                                  n_groups = 4)
shap.plot.force_plot(plot_data)
shap.plot.force_plot(plot_data,  zoom_in_group = 2)

# plot all the clusters:
shap.plot.force_plot_bygroup(plot_data)
</code></pre>

<hr>
<h2 id='shap.values'>Get SHAP scores from a trained XGBoost or LightGBM model</h2><span id='topic+shap.values'></span>

<h3>Description</h3>

<p><code>shap.values</code> returns a list of three objects from XGBoost or LightGBM
model: 1. a dataset (data.table) of SHAP scores. It has the same dimension as
the X_train); 2. the ranked variable vector by each variable's mean absolute
SHAP value, it ranks the predictors by their importance in the model; and 3.
The BIAS, which is like an intercept. The rowsum of SHAP values including the
BIAS would equal to the predicted value (y_hat) generally speaking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shap.values(xgb_model, X_train)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shap.values_+3A_xgb_model">xgb_model</code></td>
<td>
<p>an XGBoost or LightGBM model object</p>
</td></tr>
<tr><td><code id="shap.values_+3A_x_train">X_train</code></td>
<td>
<p>the data supplied to the <code>predict</code> function to get the
prediction. It should be a matrix. Notice that coercing the matrix to a
dense matrix by using <code>as.matrix</code> might lead to wrong behaviors in some
cases. See discussion in issues on this topic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of three elements: the SHAP values as data.table, ranked
mean|SHAP|, and BIAS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
X1 = as.matrix(iris[,-5])
mod1 = xgboost::xgboost(
  data = X1, label = iris$Species, gamma = 0, eta = 1,
  lambda = 0, nrounds = 1, verbose = FALSE, nthread = 1)

# shap.values(model, X_dataset) returns the SHAP
# data matrix and ranked features by mean|SHAP|
shap_values &lt;- shap.values(xgb_model = mod1, X_train = X1)
shap_values$mean_shap_score
shap_values_iris &lt;- shap_values$shap_score

# shap.prep() returns the long-format SHAP data from either model or
shap_long_iris &lt;- shap.prep(xgb_model = mod1, X_train = X1)
# is the same as: using given shap_contrib
shap_long_iris &lt;- shap.prep(shap_contrib = shap_values_iris, X_train = X1)

# **SHAP summary plot**
shap.plot.summary(shap_long_iris, scientific = TRUE)
shap.plot.summary(shap_long_iris, x_bound  = 1.5, dilute = 10)

# Alternatives options to make the same plot:
# option 1: from the xgboost model
shap.plot.summary.wrap1(mod1, X = as.matrix(iris[,-5]), top_n = 3)

# option 2: supply a self-made SHAP values dataset
# (e.g. sometimes as output from cross-validation)
shap.plot.summary.wrap2(shap_score = shap_values_iris, X = X1, top_n = 3)
</code></pre>

<hr>
<h2 id='strongest_interaction'>Finds variable with presumably strongest interaction effect.</h2><span id='topic+strongest_interaction'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strongest_interaction(X0, Xlong)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strongest_interaction_+3A_x0">X0</code></td>
<td>
<p>Data set corresponding to data0.</p>
</td></tr>
<tr><td><code id="strongest_interaction_+3A_xlong">Xlong</code></td>
<td>
<p>Data set corresponding to data_long.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
