<!DOCTYPE html><html><head><title>Help for package freqpcr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {freqpcr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.freqpcr_loglike'><p>Log-likelihood of obtaining Cq values under given parameter set.</p></a></li>
<li><a href='#.freqpcr_loglike_cont'><p>Log-likelihood when sample allele ratio is continuous.</p></a></li>
<li><a href='#.integrate_beta'><p>Integration of likelihood function based on the beta assumption.</p></a></li>
<li><a href='#.integrate_gamma'><p>Double integration of likelihood over the two DNA quantities obeying the gamma distributions.</p></a></li>
<li><a href='#.knownqpcr_loglike'><p>Log-likelihood of getting Cq values when exact allele mixing ratios are known.</p></a></li>
<li><a href='#.knownqpcr_loglike_duo'><p>Log-likelihood of getting Cq values when exact allele mixing ratios are known, lacking the quartet structure.</p></a></li>
<li><a href='#CqFreq-class'><p>Output object of <code>freqpcr()</code>.</p></a></li>
<li><a href='#CqList-class'><p>S4 class storing the dummy Cq data for performance test.</p></a></li>
<li><a href='#freqpcr'><p>Estimate population allele frequency from the set of Cq measurements.</p></a></li>
<li><a href='#freqpcr-package'><p>The freqpcr package</p></a></li>
<li><a href='#knownqpcr'><p>Estimate auxiliary parameters using samples with known allele ratios.</p></a></li>
<li><a href='#knownqpcr_unpaired'><p>Estimate auxiliary parameters when the sample pairs are incomplete.</p></a></li>
<li><a href='#make_dummy'><p>Generate dummy DNA dataset ready for allele-frequency estimation.</p></a></li>
<li><a href='#sim_dummy'><p>Simulate freqpcr estimation based on user-generated dummy data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimates Allele Frequency on qPCR DeltaDeltaCq from Bulk
Samples</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Masaaki Sudo &lt;masaaki@sudori.info&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Interval estimation of the population allele frequency from qPCR analysis based on the restriction enzyme digestion (RED)-DeltaDeltaCq method (Osakabe et al. 2017, &lt;<a href="https://doi.org/10.1016%2Fj.pestbp.2017.04.003">doi:10.1016/j.pestbp.2017.04.003</a>&gt;), as well as general DeltaDeltaCq analysis. Compatible with the Cq measurement of DNA extracted from multiple individuals at once, so called "group-testing", this model assumes that the quantity of DNA extracted from an individual organism follows a gamma distribution. Therefore, the point estimate is robust regarding the uncertainty of the DNA yield.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sudoms/freqpcr">https://github.com/sudoms/freqpcr</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6), cubature</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, remotes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-26 10:57:50 UTC; masaa</td>
</tr>
<tr>
<td>Author:</td>
<td>Masaaki Sudo <a href="https://orcid.org/0000-0001-9834-9857"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-27 10:30:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='.freqpcr_loglike'>Log-likelihood of obtaining Cq values under given parameter set.</h2><span id='topic+.freqpcr_loglike'></span>

<h3>Description</h3>

<p>The internal function is called from the optimizer, <code><a href="stats.html#topic+nlm">nlm</a>()</code>, running in <code><a href="#topic+freqpcr">freqpcr</a>()</code>. It defines the log-likelihood by obtaining the two <code class="reqn">\Delta</code>Cq values (differences in the four Cq measurements) provided that the allele mixing ratio for each bulk sample is given together with other parameters. This function is vectorized over multiple bulk samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.freqpcr_loglike(
  X,
  N,
  DCW,
  DCD,
  zeroAmount,
  para.fixed = NULL,
  beta = TRUE,
  diploid = FALSE,
  dummyDCW = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".freqpcr_loglike_+3A_x">X</code></td>
<td>
<p>Numeric vector that stores the parameter values to be optimized via <code><a href="stats.html#topic+nlm">nlm</a>()</code>: <code>P</code> in logit scale and <code>K</code>, <code>targetScale</code>, <code>sdMeasure</code>, and <code>EPCR</code> in log scale.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_+3A_n">N</code></td>
<td>
<p>Sample sizes as a numeric vector. <code>N[i]</code> signifies the number of individuals (both for haploidy and diploidy) contained in the <em>i</em>th bulk sample.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_+3A_dcw">DCW</code>, <code id=".freqpcr_loglike_+3A_dcd">DCD</code></td>
<td>
<p>Numeric vectors having the same length as <code>N</code>. They store the measured values of the two <code class="reqn">\Delta</code>Cq: <code>DCW (= target0 - housek0)</code> and <code>DCD (= target1 - housek1)</code>. They can contain NA (simply ignored in the calculation).</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_+3A_zeroamount">zeroAmount</code></td>
<td>
<p>(In RED-<code class="reqn">\Delta\Delta</code>Cq method) residue rate of restriction enzyme digestion, or (in general <code class="reqn">\Delta\Delta</code>Cq analyses) small portion of the off-target allele on the target locus of the test sample, which will be amplified in the PCR. It needs to be always specified by the user as a number between 0 and 1, usually near 0.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_+3A_para.fixed">para.fixed</code></td>
<td>
<p>Named numeric vector that stores the fixed parameters inherited from <code><a href="#topic+freqpcr">freqpcr</a>()</code>, if specified. By default (<code>NULL</code>), all the parameters (<code>P</code>, <code>K</code>, <code>targetScale</code>, <code>sdMeasure</code>, and <code>EPCR</code>) are unknown. Unlike <code>X</code>, each element value is set in linear scale.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_+3A_beta">beta</code></td>
<td>
<p>Whether to use the beta distribution to approximate the sample allele ratio instead of specifying individual gamma distribution for each of the allelic DNA amounts? Default is <code>TRUE</code>, which accelerates the calculation.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_+3A_diploid">diploid</code></td>
<td>
<p>Is the target organism diploidy? Default is <code>FALSE</code>, assuming haploidy. Current implementation of diploidy assumes i.i.d. between the amounts of R and S chromosomes owned by a heterozygote individual, which is unlikely in many animals but necessary for the calculation in a realistic time.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_+3A_dummydcw">dummyDCW</code></td>
<td>
<p>Whether the <code class="reqn">\Delta</code>Cq values of the control samples are dummy or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar of the log likelihood.
</p>

<hr>
<h2 id='.freqpcr_loglike_cont'>Log-likelihood when sample allele ratio is continuous.</h2><span id='topic+.freqpcr_loglike_cont'></span>

<h3>Description</h3>

<p>Called from <code><a href="#topic+freqpcr">freqpcr</a>()</code> instead of <code><a href="#topic+.freqpcr_loglike">.freqpcr_loglike</a>()</code> when the model is &lsquo;continuous&rsquo;. This function assumes that each sample does not consist of <code>n</code> individual organisms with certain genotypes, but the result of a direct DNA extraction from the sub-population having the allele ratio around <code>p:(1-p)</code>. Each sample allele ratio is considered to follow <code>Beta(apk, a(1-p)k)</code>, where <code>a</code> and <code>k</code> are the relative DNA content of the sample and the gamma shape parameter, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.freqpcr_loglike_cont(
  X,
  A,
  DCW,
  DCD,
  zeroAmount,
  para.fixed = NULL,
  beta = TRUE,
  dummyDCW = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".freqpcr_loglike_cont_+3A_x">X</code></td>
<td>
<p>Numeric vector that stores the parameter values to be optimized via <code><a href="stats.html#topic+nlm">nlm</a>()</code>: <code>P</code> in logit scale and <code>K</code>, <code>targetScale</code>, <code>sdMeasure</code>, and <code>EPCR</code> in log scale.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_cont_+3A_a">A</code></td>
<td>
<p>Relative DNA content between the samples. A continuous version of <code>N</code> in <code><a href="#topic+.freqpcr_loglike">.freqpcr_loglike</a>()</code>, as a numeric vector.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_cont_+3A_dcw">DCW</code>, <code id=".freqpcr_loglike_cont_+3A_dcd">DCD</code></td>
<td>
<p>Numeric vectors. They store the measured values of the two <code class="reqn">\Delta</code>Cq: <code>DCW (= target0 - housek0)</code> and <code>DCD (= target1 - housek1)</code>.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_cont_+3A_zeroamount">zeroAmount</code></td>
<td>
<p>(In RED-<code class="reqn">\Delta\Delta</code>Cq method) residue rate of restriction enzyme digestion, or (in general <code class="reqn">\Delta\Delta</code>Cq analyses) small portion of the off-target allele on the target locus of the test sample, which will be amplified in the PCR. It needs to be always specified by the user as a number between 0 and 1, usually near 0.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_cont_+3A_para.fixed">para.fixed</code></td>
<td>
<p>Named numeric vector that stores the fixed parameters inherited from <code><a href="#topic+freqpcr">freqpcr</a>()</code>, if specified. By default (<code>NULL</code>), all the parameters (<code>P</code>, <code>K</code>, <code>targetScale</code>, <code>sdMeasure</code>, and <code>EPCR</code>) are unknown. Unlike <code>X</code>, each element value is set in linear scale.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_cont_+3A_beta">beta</code></td>
<td>
<p>Whether to use the beta distribution to approximate the sample allele ratio instead of specifying individual gamma distribution for each of the allelic DNA amounts? Default is <code>TRUE</code>, which accelerates the calculation.</p>
</td></tr>
<tr><td><code id=".freqpcr_loglike_cont_+3A_dummydcw">dummyDCW</code></td>
<td>
<p>Whether the <code class="reqn">\Delta</code>Cq values of the control samples are dummy or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scalar of the log likelihood.
</p>

<hr>
<h2 id='.integrate_beta'>Integration of likelihood function based on the beta assumption.</h2><span id='topic+.integrate_beta'></span>

<h3>Description</h3>

<p>Internal function to integrate the likelihood getting the <code class="reqn">\Delta</code>Cq value (the argument <code>del</code>) over the entire range of the allele ratio (0 to 1). Vectorized for multiple bulk samples. Having the same arguments with .integrate_gamma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.integrate_beta(
  del,
  SHR,
  SHS,
  zeroAmount,
  targetScale,
  sdMeasure,
  xsm = 2,
  EPCR,
  cubmethod = "hcubature",
  relTol = 0.1,
  absTol = 1e-08,
  maxEval = 10^6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".integrate_beta_+3A_del">del</code></td>
<td>
<p>Numeric vector of the observed <code class="reqn">\Delta</code>Cq values.</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_shr">SHR</code></td>
<td>
<p>The gamma shape parameters for the mutant (R) portion of the bulk samples. Should be the same vector length as del. Each element of SHR is defined as K*(the assumed number of R allele in the bulk sample: 1, 2, 3, ..., n-1).</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_shs">SHS</code></td>
<td>
<p>The gamma shape parameters for the wild (S) portion of the bulk samples. Should be the same length as del. Each element of SHS is defined as K*(the assumed number of S allele in the bulk sample).</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_zeroamount">zeroAmount</code></td>
<td>
<p>(In RED-<code class="reqn">\Delta\Delta</code>Cq method) residue rate of restriction enzyme digestion, or (in general <code class="reqn">\Delta\Delta</code>Cq analyses) small portion of the off-target allele on the target locus of the test sample, which will be amplified in the PCR. It needs to be always specified by the user as a number between 0 and 1, usually near 0.</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_targetscale">targetScale</code></td>
<td>
<p>(<code class="reqn">\delta_{T}</code>) Scalar. The relative template DNA amount of the target locus to the houskeeping locus. If known, given as a positive numeric.</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_sdmeasure">sdMeasure</code></td>
<td>
<p>(<code class="reqn">\sigma_{c}</code>) Scalar. The measurement error (standard deviation) on each Cq value following Normal(0, <code class="reqn">\sigma_{c}^2</code>). If known, given as a positive numeric.</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_xsm">xsm</code></td>
<td>
<p>Specify the accumulation of the standard deviation of the Cq measuring errors when the *-Cq values are fed as difference. For <code class="reqn">\Delta</code>Cq values, sdMeasure times two. For <code class="reqn">\Delta\Delta</code>Cq, sdMeasure times four. Default is two and used in most cases.</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_epcr">EPCR</code></td>
<td>
<p>(<code class="reqn">\eta</code>) Scalar. Amplification efficiency per PCR cycle. If known, given as a positive numeric. When <code>EPCR = 1</code>, template DNA doubles every cycle (<code>EPCR + 1 = 2</code>).</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_cubmethod">cubmethod</code></td>
<td>
<p>Cubature method passed to the integrator function. See the section &quot;Methods for cubintegrate&quot;.</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_reltol">relTol</code></td>
<td>
<p>The maximum tolerance passed to the cubature method. Though the default of cubature::cubintegrate function is 1e-5, the accuracy is reduced here to acceralate the integration.</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_abstol">absTol</code></td>
<td>
<p>The absolute tolerance passed to the cubature method. The default is 1e-8, which is less accurate than the default of cubintegrate function (1e-12) but considered enough for the estimation.</p>
</td></tr>
<tr><td><code id=".integrate_beta_+3A_maxeval">maxEval</code></td>
<td>
<p>Maximum number of function evaluations needed. The default is 10^6, which is same as the cubintegrate default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of marginal likelihoods having the same length as <code>del</code>.
</p>


<h3>Methods for cubintegrate</h3>

<p>The following methods are available for <code><a href="cubature.html#topic+cubintegrate">cubintegrate</a>()</code>: cubmethod = c(&quot;hcubature&quot;, &quot;pcubature&quot;, &quot;cuhre&quot;, &quot;divonne&quot;, &quot;suave&quot;, &quot;vegas&quot;).
<br />
<code>hcubature</code> is considerably fast, but less accurate with larger <code>reltol</code>. <code>cuhre</code> is moderately fast and the most accurate in most <code>relTol</code> range. If you can wait longer, <code>hcubature</code> with <code>relTol = 1e-4</code> or <code>cuhre</code> with <code>relTol = 1e-1</code> is recommended.
At <code>reltol = 1e-1</code>, <code>hcubature</code> is three times faster than <code>cuhre</code>, but the log-likelihood fluctuate by 0.1 (by 0.001 in <code>cuhre</code>).
The speed and accuracy of <code>hcubature</code> at <code>reltol = 1e-5</code> is comparable with <code>cuhre</code> at <code>reltol = 1e-1</code>.
<br />
<code>pcubature</code> and <code>divonne</code> frequently returns <code>NaN</code> and are not recommended.
<br />
<code>suave</code> and <code>vegas</code> are Monte Carlo integration and slow. They are certainly accurate even at <code>reltol = 1</code>, but interior to <code>cuhre</code> with same <code>reltol</code>.
</p>


<h3>See Also</h3>

<p>Other integrators: 
<code><a href="#topic+.integrate_gamma">.integrate_gamma</a>()</code>
</p>

<hr>
<h2 id='.integrate_gamma'>Double integration of likelihood over the two DNA quantities obeying the gamma distributions.</h2><span id='topic+.integrate_gamma'></span>

<h3>Description</h3>

<p>Internal function to integrate the likelihood getting <code class="reqn">\Delta</code>Cq value (the argument <code>del</code>) over the entire range of the DNA quantities of the two alleles, 0 &lt;= x_S &lt; Inf and 0 &lt;= x_R &lt; Inf. Vectorized for multiple bulk samples. It shares the arguments with .integrate_beta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.integrate_gamma(
  del,
  SHR,
  SHS,
  zeroAmount,
  targetScale,
  sdMeasure,
  xsm = 2,
  EPCR,
  cubmethod = "hcubature",
  relTol = 0.1,
  absTol = 1e-08,
  maxEval = 10^6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".integrate_gamma_+3A_del">del</code></td>
<td>
<p>Numeric vector of the observed <code class="reqn">\Delta</code>Cq values.</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_shr">SHR</code></td>
<td>
<p>The gamma shape parameters for the mutant (R) portion of the bulk samples. Should be the same vector length as del. Each element of SHR is defined as K*(the assumed number of R allele in the bulk sample: 1, 2, 3, ..., n-1).</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_shs">SHS</code></td>
<td>
<p>The gamma shape parameters for the wild (S) portion of the bulk samples. Should be the same length as del. Each element of SHS is defined as K*(the assumed number of S allele in the bulk sample).</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_zeroamount">zeroAmount</code></td>
<td>
<p>(In RED-<code class="reqn">\Delta\Delta</code>Cq method) residue rate of restriction enzyme digestion, or (in general <code class="reqn">\Delta\Delta</code>Cq analyses) small portion of the off-target allele on the target locus of the test sample, which will be amplified in the PCR. It needs to be always specified by the user as a number between 0 and 1, usually near 0.</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_targetscale">targetScale</code></td>
<td>
<p>(<code class="reqn">\delta_{T}</code>) Scalar. The relative template DNA amount of the target locus to the houskeeping locus. If known, given as a positive numeric.</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_sdmeasure">sdMeasure</code></td>
<td>
<p>(<code class="reqn">\sigma_{c}</code>) Scalar. The measurement error (standard deviation) on each Cq value following Normal(0, <code class="reqn">\sigma_{c}^2</code>). If known, given as a positive numeric.</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_xsm">xsm</code></td>
<td>
<p>Specify the accumulation of the standard deviation of the Cq measuring errors when the *-Cq values are fed as difference. For <code class="reqn">\Delta</code>Cq values, sdMeasure times two. For <code class="reqn">\Delta\Delta</code>Cq, sdMeasure times four. Default is two and used in most cases.</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_epcr">EPCR</code></td>
<td>
<p>(<code class="reqn">\eta</code>) Scalar. Amplification efficiency per PCR cycle. If known, given as a positive numeric. When <code>EPCR = 1</code>, template DNA doubles every cycle (<code>EPCR + 1 = 2</code>).</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_cubmethod">cubmethod</code></td>
<td>
<p>Cubature method passed to the integrator function. See the section &quot;Methods for cubintegrate&quot;.</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_reltol">relTol</code></td>
<td>
<p>The maximum tolerance passed to the cubature method. Though the default of cubature::cubintegrate function is 1e-5, the accuracy is reduced here to acceralate the integration.</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_abstol">absTol</code></td>
<td>
<p>The absolute tolerance passed to the cubature method. The default is 1e-8, which is less accurate than the default of cubintegrate function (1e-12) but considered enough for the estimation.</p>
</td></tr>
<tr><td><code id=".integrate_gamma_+3A_maxeval">maxEval</code></td>
<td>
<p>Maximum number of function evaluations needed. The default is 10^6, which is same as the cubintegrate default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of marginal likelihoods having the same length as <code>del</code>.
</p>


<h3>See Also</h3>

<p>Other integrators: 
<code><a href="#topic+.integrate_beta">.integrate_beta</a>()</code>
</p>

<hr>
<h2 id='.knownqpcr_loglike'>Log-likelihood of getting Cq values when exact allele mixing ratios are known.</h2><span id='topic+.knownqpcr_loglike'></span>

<h3>Description</h3>

<p>Internal function to return the log-likelihood getting the four Cq measurements under true allele frequency for each bulk sample is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.knownqpcr_loglike(X, A, trueY, Digest, Gene, Cq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".knownqpcr_loglike_+3A_x">X</code></td>
<td>
<p>A numeric vector that stores the current parameter sizes of <code>meanDNA</code>, <code>targetScale</code>, <code>baseChange</code>, <code>sdMeasure</code>, <code>zeroAmount</code>, and <code>EPCR</code> in log scale.</p>
</td></tr>
<tr><td><code id=".knownqpcr_loglike_+3A_a">A</code></td>
<td>
<p>Optionally, you can specify relative DNA content between the samples, as a numeric vector having the same length as the Cq data. If present, <code>A</code> must not include missing values. It is the counterpart of the <code>N</code> argument in <code><a href="#topic+freqpcr">freqpcr</a>()</code>, whereas an element of <code>A</code> is not restricted to integer. Because the concentration as a whole is also adjusted with the parameter <code>meanDNA</code> (see Value section), <code>A</code> is used exclusively to reflect the relative contents between the sample solutions. Otherwise, <code>A</code> should be left unspecified (the default is 1 for all replicates).</p>
</td></tr>
<tr><td><code id=".knownqpcr_loglike_+3A_truey">trueY</code></td>
<td>
<p>A numeric vector having the same length as the Cq data. <code>trueY[i]</code> signifies the exact allele frequency in the <em>i</em>th sample. The values must be between 0 and 1, and <code>NA</code> is not allowed. To improve the estimation accuracy, it is better to include the settings y == 0 (pure S solution) and y == 1 (pure R) in your dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar of the log likelihood.
</p>

<hr>
<h2 id='.knownqpcr_loglike_duo'>Log-likelihood of getting Cq values when exact allele mixing ratios are known, lacking the quartet structure.</h2><span id='topic+.knownqpcr_loglike_duo'></span>

<h3>Description</h3>

<p>Internal function to return the log-likelihood getting the four Cq measurements under true allele frequency for each bulk sample is known. This is a variant for the 'duo' structure dataset and <code>baseChange</code> is absent. <code>obs.housek0</code> and <code>obs.target0</code> are defined for the parity of source code, but they actually accept no data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.knownqpcr_loglike_duo(X, A, trueY, Digest, Gene, Cq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".knownqpcr_loglike_duo_+3A_x">X</code></td>
<td>
<p>A numeric vector that stores the current parameter sizes of <code>meanDNA</code>, <code>targetScale</code>, <code>sdMeasure</code>, <code>zeroAmount</code>, and <code>EPCR</code> in log scale.</p>
</td></tr>
<tr><td><code id=".knownqpcr_loglike_duo_+3A_a">A</code></td>
<td>
<p>Optionally, you can specify relative DNA content between the samples, as a numeric vector having the same length as the Cq data. If present, <code>A</code> must not include missing values. It is the counterpart of the <code>N</code> argument in <code><a href="#topic+freqpcr">freqpcr</a>()</code>, whereas an element of <code>A</code> is not restricted to integer. Because the concentration as a whole is also adjusted with the parameter <code>meanDNA</code> (see Value section), <code>A</code> is used exclusively to reflect the relative contents between the sample solutions. Otherwise, <code>A</code> should be left unspecified (the default is 1 for all replicates).</p>
</td></tr>
<tr><td><code id=".knownqpcr_loglike_duo_+3A_truey">trueY</code></td>
<td>
<p>A numeric vector having the same length as the Cq data. <code>trueY[i]</code> signifies the exact allele frequency in the <em>i</em>th sample. The values must be between 0 and 1, and <code>NA</code> is not allowed. To improve the estimation accuracy, it is better to include the settings y == 0 (pure S solution) and y == 1 (pure R) in your dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar of the log likelihood.
</p>

<hr>
<h2 id='CqFreq-class'>Output object of <code><a href="#topic+freqpcr">freqpcr</a>()</code>.</h2><span id='topic+CqFreq-class'></span><span id='topic+CqFreq'></span>

<h3>Description</h3>

<p>Output object of <code><a href="#topic+freqpcr">freqpcr</a>()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>report</code></dt><dd><p>A matrix of the simultaneous parameter estimation result. The rows represent the parameters <code>P</code>, <code>K</code>, <code>targetScale</code> (<code class="reqn">\delta_{T}</code>), <code>sdMeasure</code> (<code class="reqn">\sigma_{c}</code>), and <code>EPCR</code> (<code class="reqn">\eta</code>).</p>
</dd>
<dt><code>obj</code></dt><dd><p>Returned value of the optimizer function <code><a href="stats.html#topic+nlm">nlm</a>()</code> as a list.</p>
</dd>
<dt><code>cal.time</code></dt><dd><p>Calculation time of <code><a href="stats.html#topic+nlm">nlm</a>()</code>, stored as a <code>proc_time</code> class object.</p>
</dd>
</dl>

<hr>
<h2 id='CqList-class'>S4 class storing the dummy Cq data for performance test.</h2><span id='topic+CqList-class'></span><span id='topic+CqList'></span>

<h3>Description</h3>

<p>A dummy Cq dataset suitable for a package test, typically obtained as the output of <code><a href="#topic+make_dummy">make_dummy</a>()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>N</code></dt><dd><p>Sample sizes as a numeric vector. The <code>ntrap</code> and  <code>npertrap</code> arguments of <code><a href="#topic+make_dummy">make_dummy</a>()</code> are inherited to the length of N and each <code>N[i]</code> element, the number of individuals (both for haploidy and diploidy) contained in the <em>i</em>th bulk sample, respectively.</p>
</dd>
<dt><code>m</code></dt><dd><p>Segregation ratio. As for haploidy, <code>m</code> is a matrix with 2 rows and <code>ntrap</code> columns. <code>m[1, i]</code> and <code>m[2, i]</code> stores the number of R (mutant) or S (wild type) individuals while <code>N[i] = sum(m[, i])</code> specifies the total in the bulk sample. It has 3 rows and <code>ntrap</code> columns as for diploidy. While <code>m[1, i]</code> stands for the number of RR hogozygote individuals, <code>m[2, i]</code> and <code>m[3, i]</code> stand for the numbers of RS heterozygotes and SS homozygotes, respectively.</p>
</dd>
<dt><code>xR,xS</code></dt><dd><p>Numeric vector of the same length with N. <code>xR[i]</code> stores the amount of the template DNA for R allele contained in the <em>i</em>th bulk sample.</p>
</dd>
<dt><code>housek0,target0,housek1,target1</code></dt><dd><p>Numeric vectors of the same lengths with N. Store the generated Cq values.</p>
</dd>
<dt><code>DCW</code></dt><dd><p><code class="reqn">\Delta</code>Cq values measured on the control samples (DNA extract without endonuclease digestion in the RED-<code class="reqn">\Delta\Delta</code>Cq method, or pure R solution in a general <code class="reqn">\Delta\Delta</code>Cq method), <code>DCW</code>, is defined as (<code>target0 - housek0</code>).</p>
</dd>
<dt><code>DCD</code></dt><dd><p><code class="reqn">\Delta</code>Cq values measured on the test samples (samples after endonuclease digestion in the RED-<code class="reqn">\Delta\Delta</code>Cq method, or samples with unknown allele mixing ratios in a general <code class="reqn">\Delta\Delta</code>Cq method), <code>DCD</code>, is defined as (<code>target1 - housek1</code>).</p>
</dd>
<dt><code>deldel</code></dt><dd><p><code class="reqn">\Delta\Delta</code>Cq value, defined as (<code>DCD - DCW</code>).</p>
</dd>
<dt><code>RFreqMeasure</code></dt><dd><p>A classical index of the allele frequency calculated for each bulk sample, which is defined as <code>(1.0+EPCR)^(-deldel)</code>. Note that the values of <code>EPCR</code> and other parameters, such as <code>P</code> or <code>K</code>, are not recorded in the object to avoid leakage of information.</p>
</dd>
<dt><code>ObsP</code></dt><dd><p>As <code>RFreqMeasure</code> can exceed 1 by definition, <code>ObsP</code> is defined as <code>min(RFreqMeasure, 1)</code>.</p>
</dd>
<dt><code>rand.seed</code></dt><dd><p>The seed of the random-number generator (RNG) which was fed to the current R session to generate dummy <code>m</code>, <code>xR</code> and <code>xS</code> data.</p>
</dd>
</dl>

<hr>
<h2 id='freqpcr'>Estimate population allele frequency from the set of Cq measurements.</h2><span id='topic+freqpcr'></span>

<h3>Description</h3>

<p>The function estimates the population allele frequency using the dataset of Cq values measured over <code>length(N)</code> bulk samples, each of which has a sample size of <code>N[i]</code> as the number of individuals included. <code>N[i]</code> can be 1, meaning that every individual is analyzed separately. For the <em>i</em>th sample, the four Cq values were measured as <code>housek0[i]</code>, <code>target0[i]</code>, <code>housek1[i]</code>, and <code>target1[i]</code>. The function can estimate up to five parameters simultaneously when the Cq sets are available for more than two (bulk) samples: <code>P</code>, <code>K</code>, <code>targetScale</code>, <code>sdMeasure</code>, and <code>EPCR</code>.
<br />
Since v0.3.2, user can also use an experimental &lsquo;continuous model&rsquo; by specifying <code>A</code> instead of <code>N</code>. That is, each sample DNA is directly extracted from the environment and the sample allele ratio <code>y</code> follows <code>y ~ Beta(apk, a(1-p)k)</code> instead of <code>y ~ Beta(mk, (n-m)k), m ~ Binomial(n, p)</code>, where <code>p</code> and <code>k</code> are the population allele frequency and the gamma shape parameter of the individual DNA yield, respectively. Each element of <code>A</code>, <code>a</code> is a scaling factor of relative DNA contents between the samples. The continuous model is likely when each sample directly comes from the environment e.g., water sampling in an eDNA analysis or cell culture in a petri dish.
<br />
Since v0.4.0, <code><a href="#topic+freqpcr">freqpcr</a>()</code> also works without specifying <code>housek0</code> and <code>target0</code> i.e., it can estimate population allele frequency from <code class="reqn">\Delta</code>Cq values instead of <code class="reqn">\Delta\Delta</code>Cq. In this setting, the sizes of <code>targetScale</code> and <code>sdMeasure</code> should be fixed in addition to <code>EPCR</code> and <code>zeroAmount</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqpcr(
  N,
  A,
  housek0,
  target0,
  housek1,
  target1,
  P = NULL,
  K = NULL,
  targetScale = NULL,
  sdMeasure = NULL,
  EPCR = 0.99,
  XInit0 = c(P = NULL, K = NULL, targetScale = NULL, sdMeasure = NULL, EPCR = NULL),
  zeroAmount = NULL,
  beta = TRUE,
  diploid = FALSE,
  pvalue = 0.05,
  gradtol = 1e-04,
  steptol = 1e-09,
  iterlim = 100,
  maxtime = 600,
  print.level = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqpcr_+3A_n">N</code></td>
<td>
<p>Sample sizes as a numeric vector. <code>N[i]</code> signifies the number of individuals (both for haploidy and diploidy) contained in the <em>i</em>th bulk sample. <code>N</code> must not contain a missing value (<code>NA</code>). If <code>N</code> is not applicable (= even not 1), feed <code>A</code> instead of <code>N</code> and then the estimation process runs with the &lsquo;continuous model&rsquo;.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_a">A</code></td>
<td>
<p>Use instead of <code>N</code> in the continuous model. This is a scale factor to control the relative DNA content between samples. <code>A[i]</code> can take any positive value, but must not be <code>NA</code>. Considering the case you have arranged each sample by e.g. water filrtation or extraction from a culture in a petri dish, it is convenient to define the unit size of <code>A[i]</code> == 1.0 to be same as the vessel volume (e.g. 2.0 for two petri dishs, 0.5 for half bottle of water, etc.). When neither <code>N</code> nor <code>A</code> is specified by the user, the function stops. If both <code>N</code> and <code>A</code> are specified, only <code>N</code> is evaluated.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_housek0">housek0</code></td>
<td>
<p>A numeric vector. In RED-<code class="reqn">\Delta\Delta</code>Cq method, <code>housek0</code> is the Cq values of the test sample without the restriction enzyme digestion, which is amplified with the primer set for a housekeeping gene. In general <code class="reqn">\Delta\Delta</code>Cq analyses, <code>housek0</code> is defined for the control sample (typically, 100% mutant) solution, which is also amplified with the primer set for the housekeeping gene. 
<br />
Since <code>v0.4.0</code>, you can run <code><a href="#topic+freqpcr">freqpcr</a>()</code> without specifying <code>housek0</code> and <code>target0</code> (a <code class="reqn">\Delta</code>Cq method). As this setting halves the effective data points, it is recommended to fix other parameters, especially <code>targetScale</code>. 
<br />
The four Cq arguments, <code>housek0</code>, <code>target0</code>, <code>housek1</code>, and <code>target1</code>, all must have the same data length. They also must be the same length as <code>N</code> or <code>A</code>. If the Cq dataset has missing values, they must be filled with NA so that the length of the data vectors will not differ.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_target0">target0</code></td>
<td>
<p>In RED-<code class="reqn">\Delta\Delta</code>Cq method, <code>target0[i]</code> signifies the measured Cq value of the <em>i</em>th bulk sample without the digestion, for which both alleles, wild-type (S: susceptible) and mutant (R: resistant to a pesticide), on the target locus are amplified. In general <code class="reqn">\Delta\Delta</code>Cq analyses, <code>target0</code> is the Cq values of the pure-S control sample, which is amplified with a R-allele-specific primer set.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_housek1">housek1</code></td>
<td>
<p>The Cq values of the test sample measured on the housekeeping gene after the restriction enzyme digestion (in RED-<code class="reqn">\Delta\Delta</code>Cq method), or the test sample amplified on the housekeeping gene (in general <code class="reqn">\Delta\Delta</code>Cq analyses).</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_target1">target1</code></td>
<td>
<p>For each test sample with unknown allele-ratio, <code>target1[i]</code> is defined as the Cq value for the target locus amplified after the restriction enzyme digestion (in RED-<code class="reqn">\Delta\Delta</code>Cq method), or the target locus amplified with the R-allele-specific primer set (in general <code class="reqn">\Delta\Delta</code>Cq analyses).</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_p">P</code></td>
<td>
<p>Scalar. Population allele frequency from which the test samples are derived. Default is <code>NULL</code> and to be estimated. If the parameter is known, it is given as a numeric between 0 and 1.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_k">K</code></td>
<td>
<p>Scalar. The gamma shape parameter of the individual DNA yield. Default is <code>NULL</code> and to be estimated. If known, given as a positive numeric.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_targetscale">targetScale</code></td>
<td>
<p>(<code class="reqn">\delta_{T}</code>) Scalar. The relative template DNA amount of the target locus to the houskeeping locus. If known, given as a positive numeric.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_sdmeasure">sdMeasure</code></td>
<td>
<p>(<code class="reqn">\sigma_{c}</code>) Scalar. The measurement error (standard deviation) on each Cq value following Normal(0, <code class="reqn">\sigma_{c}^2</code>). If known, given as a positive numeric.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_epcr">EPCR</code></td>
<td>
<p>(<code class="reqn">\eta</code>) Scalar. Amplification efficiency per PCR cycle. If known, given as a positive numeric. When <code>EPCR = 1</code>, template DNA doubles every cycle (<code>EPCR + 1 = 2</code>).</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_xinit0">XInit0</code></td>
<td>
<p>Optionally the initial value for the parameter optimization can be specified, but it is strongly recommended to keep the argument as is. Unlike <code>XInit</code> in <code><a href="#topic+knownqpcr">knownqpcr</a>()</code>, the argument is not directly passed to the optimizer; used only when each parameter is set unknown (the parameter is absent or specified as NULL).</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_zeroamount">zeroAmount</code></td>
<td>
<p>(In RED-<code class="reqn">\Delta\Delta</code>Cq method) residue rate of restriction enzyme digestion, or (in general <code class="reqn">\Delta\Delta</code>Cq analyses) small portion of the off-target allele on the target locus of the test sample, which will be amplified in the PCR. It needs to be always specified by the user as a number between 0 and 1, usually near 0.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_beta">beta</code></td>
<td>
<p>Whether to use the beta distribution to approximate the sample allele ratio instead of specifying individual gamma distribution for each of the allelic DNA amounts? Default is <code>TRUE</code>, which accelerates the calculation.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_diploid">diploid</code></td>
<td>
<p>Is the target organism diploidy? Default is <code>FALSE</code>, assuming haploidy. Current implementation of diploidy assumes i.i.d. between the amounts of R and S chromosomes owned by a heterozygote individual, which is unlikely in many animals but necessary for the calculation in a realistic time.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_pvalue">pvalue</code></td>
<td>
<p>The two-sided confidence interval is calculated at the last iteration at given significance level. Default is 0.05, which returns the 95% Wald's CI (2.5 to 97.5 percentile) based on the Hessian matrix.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_gradtol">gradtol</code>, <code id="freqpcr_+3A_steptol">steptol</code>, <code id="freqpcr_+3A_iterlim">iterlim</code></td>
<td>
<p>Control parameters passed to <code><a href="stats.html#topic+nlm">nlm</a>()</code>. <code>gradtol</code> and <code>steptol</code> are the positive scalars giving the tolerance to terminate the algorithm and the minimum allowable relative step length. <code>iterlim</code> specifies the maximum number of iterations to be performed before the program is terminated (and evaluated at the last iteration). Usually 30 iterations are enough.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_maxtime">maxtime</code></td>
<td>
<p>A positive scalar to set the maximum calculation time in seconds to abort the optimizer (and return error). The total calculation time largely depends on <code>N[i]</code>, the number of individuals contained in each bulk sample.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_print.level">print.level</code></td>
<td>
<p><code>print.level=1</code> (the default) shows the initial values of the parameters and likelihood as well as the output in the last iteration. <code>print.level=2</code> shows the parameter values and gradients in every step. <code>print.level=0</code> does not output any intermediate state to R console, simply returning the result summary.</p>
</td></tr>
<tr><td><code id="freqpcr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the S4 class <a href="#topic+CqFreq-class">CqFreq</a>. The slot <code>report</code> is a matrix and each row contains the estimated parameter value with 100*(1-pvalue)% confidence interval. The following parameters are returned:
</p>

<ol>
<li><p><code>P</code>, the population allele frequency from which the test samples are derived.
</p>
</li>
<li><p><code>K</code>, the gamma shape parameter of the individual DNA yield.
</p>
</li>
<li><p><code>targetScale</code> (<code class="reqn">\delta_{T}</code>), the relative template DNA amount of the target to the houskeeping loci.
</p>
</li>
<li><p><code>EPCR</code> (<code class="reqn">\eta</code>), the amplification efficiency per PCR cycle.
</p>
</li>
<li><p><code>sdMeasure</code> or &quot;Cq measurement error&quot; (<code class="reqn">\sigma_{c}</code>).
</p>
</li></ol>



<h3>Choise of the parameters to be estimated</h3>

<p>Estimation is conducted only for parameters where the values are not specified or specified explicitly as <code>NULL</code>. If one feeds a value e.g. <code>K=1</code> or <code>sdMeasure=0.24</code>, it is then treated as fixed parameter. Notwithstanding, <code>EPCR</code> is estimated only when <code>EPCR = NULL</code> is specified explicitly.
<br />
You must verify the size of <code>EPCR</code> and <code>zeroAmount</code> beforehand because they are not estimable from the experiments with unknown allele ratios. Although <code>targetScale</code> and <code>sdMeasure</code> are estimable within <code><a href="#topic+freqpcr">freqpcr</a>()</code>, it is better to feed the known values, especially when you have only a few bulk samples (length(N) &lt;= 3). Fixing <code>targetScale</code> and <code>sdMeasure</code> is also strongly recommended when <code>housek0</code> and <code>target0</code> are absent (<code class="reqn">\Delta</code>Cq method). The functions <code><a href="#topic+knownqpcr">knownqpcr</a>()</code> or <code><a href="#topic+knownqpcr_unpaired">knownqpcr_unpaired</a>()</code>, depending on your data format, provide the procedure to estimate the sizes of the experimental parameters using the DNA solutions of known allele mixing ratios. 
<br />
For the unknown parameters, <code>XInit0</code> optionally specifies initial values for the optimization using <code><a href="stats.html#topic+nlm">nlm</a>()</code> though the use of internal default is strongly recommended. The specification as a fixed parameter has higher priority than the specification in <code>XInit0</code>. Every user-specified parameter values, fixed or unknown, must be given in linear scale (e.g. between 0 and 1 for the allele frequency); they are transformed internally to log or logit.
</p>


<h3>See Also</h3>

<p>Other estimation procedures: 
<code><a href="#topic+knownqpcr_unpaired">knownqpcr_unpaired</a>()</code>,
<code><a href="#topic+knownqpcr">knownqpcr</a>()</code>,
<code><a href="#topic+sim_dummy">sim_dummy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Dummy Cq dataset with six bulk samples, each of which comprises of eight haploids.
EPCR &lt;- 0.95; zeroAmount &lt;- 0.0016; # True values for the two must be known.
P &lt;- 0.75
dmy_cq &lt;- make_dummy(   rand.seed=1, P=P, K=2, ntrap=6, npertrap=8,
                        scaleDNA=1e-07, targetScale=1.5, baseChange=0.3,
                        EPCR=EPCR, zeroAmount=zeroAmount,
                        sdMeasure=0.3, diploid=FALSE   )
print(dmy_cq)

# Estimation with freqpcr, where P, K, targetScale, and baseChange are marked unknown.
result &lt;- freqpcr( N=dmy_cq@N, housek0=dmy_cq@housek0, target0=dmy_cq@target0,
                   housek1=dmy_cq@housek1, target1=dmy_cq@target1,
                   EPCR=EPCR, zeroAmount=zeroAmount, beta=TRUE, print.level=0 )
print(result)

# Estimation with freqpcr, assuming diploidy.
result &lt;- freqpcr( N=dmy_cq@N, housek0=dmy_cq@housek0, target0=dmy_cq@target0,
                   housek1=dmy_cq@housek1, target1=dmy_cq@target1,
                   EPCR=EPCR, zeroAmount=zeroAmount, beta=TRUE, diploid=TRUE )

# Estimation where you have knowledge on the size of K.
result &lt;- freqpcr( N=dmy_cq@N, housek0=dmy_cq@housek0, target0=dmy_cq@target0,
                   housek1=dmy_cq@housek1, target1=dmy_cq@target1,
                   K=2,
                   EPCR=EPCR, zeroAmount=zeroAmount, beta=TRUE, print.level=2 )
# (&gt;= v0.3.2)
# Provided the model is continuous (specify A instead of N).
result &lt;- freqpcr( A=dmy_cq@N, housek0=dmy_cq@housek0, target0=dmy_cq@target0,
                   housek1=dmy_cq@housek1, target1=dmy_cq@target1,
                   K=2, EPCR=EPCR, zeroAmount=zeroAmount, beta=TRUE, print.level=1 )
# (&gt;= v0.4.0)
# If the dataset lacks control samples (housek0 and target0 are absent).
# Fixing the sizes of targetScale and sdMeasure is strongly recommended.
result &lt;- freqpcr( N=dmy_cq@N, housek1=dmy_cq@housek1, target1=dmy_cq@target1,
                   K=2, EPCR=EPCR, zeroAmount=zeroAmount,
                   targetScale=1.5, sdMeasure=0.3, beta=TRUE, print.level=1 )

</code></pre>

<hr>
<h2 id='freqpcr-package'>The freqpcr package</h2><span id='topic+freqpcr-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Allele Frequency Estimation on qPCR <code class="reqn">\Delta\Delta</code>Cq Values from Bulk Samples
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Masaaki Sudo <a href="mailto:masaaki@sudori.info">masaaki@sudori.info</a> (<a href="https://orcid.org/0000-0001-9834-9857">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/sudoms/freqpcr">https://github.com/sudoms/freqpcr</a>
</p>
</li></ul>


<hr>
<h2 id='knownqpcr'>Estimate auxiliary parameters using samples with known allele ratios.</h2><span id='topic+knownqpcr'></span>

<h3>Description</h3>

<p>The function to estimate the auxiliary experimental parameters using DNA solutions, provided the dataset contains samples with multiple allele mixing ratios and the exact mixing ratio are known for each sample. This function is used when all replicates in the  dataset comprise the complete observations on the <code class="reqn">2 \times 2</code> combinations of the qPCR conditions in a RED-<code class="reqn">\Delta\Delta</code>Cq analysis: (loci for target or housekeeping genes) and (the target gene is undigested or digested with endonuclease). The quartet of the four Cq data, <code>housek0</code>, <code>target0</code> (these two are undigested samples amplified with housekeeping and target genes, respectively), <code>housek1</code>, and <code>target1</code> (digested samples) should be prepared as four numeric vectors having the same length.
<br />
One more variable, <code>trueY</code> is needed to run the estimation process; it a numeric vector having the same length with the four Cq data. It holds the exact allele-mixing ratio for each quartet (also see the code example). Optionally, you can adjust the relative DNA concentration between the replicates with a parameter vector <code>A</code>.
<br />
Since version 0.3.2, the <code><a href="#topic+knownqpcr">knownqpcr</a>()</code> function can also deal with general <code class="reqn">\Delta\Delta</code>Cq analyses. In such cases, samples with any mixing ratios are generally marked as &lsquo;digested samples&rsquo; i.e., either of  <code>housek1</code> or <code>target1</code>, depending on the loci to be amplified. The arguments of the corresponding undigested samples, <code>housek0</code> and <code>target0</code>, must not be specified by the user. Then, the parameter <code>baseChange</code> (<code class="reqn">\delta_{B}</code>: the change rate of DNA contents before/after the endonuclease digestion) is not included in the estimation result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knownqpcr(
  housek0,
  target0,
  housek1,
  target1,
  trueY,
  A = rep(1, length(trueY)),
  XInit = c(meanDNA = -10, targetScale = 0, baseChange = 0, sdMeasure = 1, zeroAmount =
    -5, EPCR = 0),
  method = "BFGS",
  pvalue = 0.05,
  trace = 0,
  report = 10,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knownqpcr_+3A_housek0">housek0</code>, <code id="knownqpcr_+3A_target0">target0</code>, <code id="knownqpcr_+3A_housek1">housek1</code>, <code id="knownqpcr_+3A_target1">target1</code></td>
<td>
<p>Measured Cq values. Numeric vectors having the same length as <code>trueY</code>. Values must not be duplicated (any single Cq measure must not be recycled); if the dataset has missing Cq values, there are two ways. 1) Fill the missing values explicitly with NA and use <code><a href="#topic+knownqpcr">knownqpcr</a>()</code>, or 2) use another function <code><a href="#topic+knownqpcr_unpaired">knownqpcr_unpaired</a>()</code>, which accepts a &lsquo;long&rsquo; format dataset.
<br />
In RED-<code class="reqn">\Delta\Delta</code>Cq method, <code>housek0</code> and <code>target0</code> corresponds to the intact test samples (not digested with endonuclease) amplified with the housekeeping- and target-loci, respectively. In general <code class="reqn">\Delta\Delta</code>Cq analyses, <code>housek0</code> and <code>target0</code> are absent, and only test samples (<code>housek1</code> and <code>target1</code>) are input by the user. At a first glance, the test samples seem to be unaffected by endonuclease when <code>trueY[i] == 1</code>, but they must also be input as <code>housek1</code> or <code>target1</code> because in fact their Cq values are affected by <code>baseChange</code>.</p>
</td></tr>
<tr><td><code id="knownqpcr_+3A_truey">trueY</code></td>
<td>
<p>A numeric vector having the same length as the Cq data. <code>trueY[i]</code> signifies the exact allele frequency in the <em>i</em>th sample. The values must be between 0 and 1, and <code>NA</code> is not allowed. To improve the estimation accuracy, it is better to include the settings y == 0 (pure S solution) and y == 1 (pure R) in your dataset.</p>
</td></tr>
<tr><td><code id="knownqpcr_+3A_a">A</code></td>
<td>
<p>Optionally, you can specify relative DNA content between the samples, as a numeric vector having the same length as the Cq data. If present, <code>A</code> must not include missing values. It is the counterpart of the <code>N</code> argument in <code><a href="#topic+freqpcr">freqpcr</a>()</code>, whereas an element of <code>A</code> is not restricted to integer. Because the concentration as a whole is also adjusted with the parameter <code>meanDNA</code> (see Value section), <code>A</code> is used exclusively to reflect the relative contents between the sample solutions. Otherwise, <code>A</code> should be left unspecified (the default is 1 for all replicates).</p>
</td></tr>
<tr><td><code id="knownqpcr_+3A_xinit">XInit</code></td>
<td>
<p>Optionally, the named vector specifies the initial parameter values to be optimized. Defined in the natural log scale; e.g. <code>zeroAmount = -5</code> corresponds to the residue rate <code>exp(-5)</code> = 0.007. Keeping the default is highly recommended.</p>
</td></tr>
<tr><td><code id="knownqpcr_+3A_method">method</code></td>
<td>
<p>A string specifying the optimization algorithm used in <code><a href="stats.html#topic+optim">optim</a>()</code>. The default is <code>BFGS</code>, which is plausible in most situation.</p>
</td></tr>
<tr><td><code id="knownqpcr_+3A_pvalue">pvalue</code></td>
<td>
<p>The two-sided confidence interval is calculated at the last iteration at given significance level. Default is 0.05, which returns the 95% Wald's CI (2.5 to 97.5 percentile) based on the Hessian matrix.</p>
</td></tr>
<tr><td><code id="knownqpcr_+3A_trace">trace</code></td>
<td>
<p>Non-negative integer. If positive, <code><a href="stats.html#topic+optim">optim</a>()</code> outputs trace information. The default is 0 (no information).</p>
</td></tr>
<tr><td><code id="knownqpcr_+3A_report">report</code></td>
<td>
<p>The frequency of reports if <code>trace</code> is positive. Defaults to every 10 iterations.</p>
</td></tr>
<tr><td><code id="knownqpcr_+3A_verbose">verbose</code></td>
<td>
<p>Send messages to stdout? Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table containing the estimated values for the following parameters:
</p>

<ol>
<li><p><code>meanDNA</code> is the template DNA concentration (of housekeeping gene, per unit volume of sample solution) compared to the threshold line of PCR.
</p>
</li>
<li><p><code>targetScale</code> (<code class="reqn">\delta_{T}</code>) is the relative template DNA amount of the target to the houskeeping loci.
</p>
</li>
<li><p><code>baseChange</code> (<code class="reqn">\delta_{B}</code>) is the change rate in the DNA amount after endonuclease digestion in RED-<code class="reqn">\Delta\Delta</code>Cq method. In general <code class="reqn">\Delta\Delta</code>Cq analyses (neither <code>housek0</code> nor <code>target0</code> is input), this parameter is not returned. In both cases, <code>baseChange</code> is not required to run <code><a href="#topic+freqpcr">freqpcr</a>()</code>.
</p>
</li>
<li><p><code>sdMeasure</code> (<code class="reqn">\sigma_{c}</code>) is the measurement error (standard deviation) at each Cq value.
</p>
</li>
<li><p><code>zeroAmount</code> (<code class="reqn">z</code>) is the ratio of non-target allele amplified in qPCR (see the argument list of <code><a href="#topic+freqpcr">freqpcr</a>()</code>).
</p>
</li>
<li><p><code>EPCR</code> (<code class="reqn">\eta</code>) is the amplification efficiency per PCR cycle.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other estimation procedures: 
<code><a href="#topic+freqpcr">freqpcr</a>()</code>,
<code><a href="#topic+knownqpcr_unpaired">knownqpcr_unpaired</a>()</code>,
<code><a href="#topic+sim_dummy">sim_dummy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A dummy Cq dataset: four mixing ratios with four replicates.
# K:2, scaleDNA:1e-11, targetScale:1.5, baseChange:0.3, zeroAmount:1e-3,
# sdMeasure:0.3, and EPCR:0.95. Assuming a RED-DeltaDeltaCq analyses.
trueY &lt;- c(rep(0.1, 4), rep(0.25, 4), rep(0.5, 4), rep(1, 4))
housek0 &lt;- c( 19.39, 19.78, 19.28, 19.58,  18.95, 19.91, 19.66, 19.96,
              20.05, 19.86, 19.55, 19.61,  19.86, 19.27, 19.59, 20.21 )
target0 &lt;- c( 19.16, 19.08, 19.28, 19.03,  19.17, 19.67, 18.68, 19.52,
              18.92, 18.79, 18.8, 19.28,   19.57, 19.21, 19.05, 19.15 )
housek1 &lt;- c( 21.61, 21.78, 21.25, 21.07,  22.04, 21.45, 20.72, 21.6,
              21.51, 21.27, 21.08, 21.7,   21.44, 21.46, 21.5, 21.8 )
target1 &lt;- c( 24.3, 24.22, 24.13, 24.13,   22.74, 23.14, 23.02, 23.14,
              21.65, 22.62, 22.28, 21.65,  20.83, 20.82, 20.76, 21.3 )
d.cmp &lt;- data.frame(A=rep(1, 16), trueY, housek0, target0, housek1, target1)
print(d.cmp)

# In RED-DeltaDeltaCq analyses, four observations stem from one sample solution.
# Each argument must be specified with its name (name=source).
knownqpcr(  housek0=d.cmp$housek0, target0=d.cmp$target0,
            housek1=d.cmp$housek1, target1=d.cmp$target1,
            trueY=d.cmp$trueY, A=d.cmp$A, verbose=FALSE  )

# In general DeltaDeltaCq analyses, the experimental design will not include
# dedicated control samples. The function then runs without 'housek0' and 'target0'.
knownqpcr(  housek1=d.cmp$housek1, target1=d.cmp$target1,
            trueY=d.cmp$trueY, A=d.cmp$A, verbose=TRUE  )
</code></pre>

<hr>
<h2 id='knownqpcr_unpaired'>Estimate auxiliary parameters when the sample pairs are incomplete.</h2><span id='topic+knownqpcr_unpaired'></span>

<h3>Description</h3>

<p>A variant of <code><a href="#topic+knownqpcr">knownqpcr</a>()</code> that accepts the Cq values concatenated into a vector (the argument <code>Cq</code>) accompanied with the experimental conditions (the arguments <code>Digest</code> and <code>Gene</code>). Their exact allele mixing ratios are known as <code>trueY</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knownqpcr_unpaired(
  Digest,
  Gene,
  trueY,
  Cq,
  A = rep(1, length(Cq)),
  XInit = c(meanDNA = -10, targetScale = 0, baseChange = 0, sdMeasure = 1, zeroAmount =
    -5, EPCR = 0),
  method = "BFGS",
  pvalue = 0.05,
  trace = 0,
  report = 10,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knownqpcr_unpaired_+3A_digest">Digest</code></td>
<td>
<p>Numeric vector having the same length as <code>Gene</code>, <code>trueY</code>, and <code>Cq</code>. <code>NA</code> is not allowed. In the RED-<code class="reqn">\Delta\Delta</code>Cq method, it specify the sample is intact (= 0) or digested with endonuclease (= 1). In other <code class="reqn">\Delta\Delta</code>Cq-based analyses, there will be no control sample and all observations must be marked <code>Digest = 1</code>.</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_gene">Gene</code></td>
<td>
<p>Numeric vector that specify each Cq measure (element of <code>Cq</code>) was taken with housekeeping (= 0) or target (= 1) locus. <code>NA</code> is not allowed.</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_truey">trueY</code></td>
<td>
<p>A numeric vector. <code>trueY[i]</code> signifies the exact frequency of the mutant allele in the <em>i</em>th sample. The values must be between 0 and 1, and <code>NA</code> is not allowed. To improve the estimation accuracy, it is better to include the settings y == 0 (pure S solution) and y == 1 (pure R) in your dataset.</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_cq">Cq</code></td>
<td>
<p>Measured Cq values. This argument is a numeric vector and can contain <code>NA</code>s. The vector length must be the same as <code>Digest</code>, <code>Gene</code>, and <code>trueY</code> (i.e., missing values must be filled with <code>NA</code>).</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_a">A</code></td>
<td>
<p>Optionally, you can specify relative DNA content between the samples, as a numeric vector having the same length as <code>Cq</code>. If present, <code>A</code> must not include missing values. It is the counterpart of the <code>N</code> argument in <code><a href="#topic+freqpcr">freqpcr</a>()</code>, whereas an element of <code>A</code> is not restricted to integer. Because the concentration as a whole is also adjusted with the parameter <code>meanDNA</code> (see Value section), <code>A</code> is used exclusively to reflect the relative contents between the sample solutions. Otherwise, <code>A</code> should be left unspecified (the default is 1 for all replicates).</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_xinit">XInit</code></td>
<td>
<p>Optionally, the named vector specifies the initial parameter values to be optimized. Defined in the natural log scale; e.g. <code>zeroAmount = -5</code> corresponds to the residue rate <code>exp(-5)</code> = 0.007. Keeping the default is highly recommended.</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_method">method</code></td>
<td>
<p>A string specifying the optimization algorithm used in <code><a href="stats.html#topic+optim">optim</a>()</code>. The default is <code>BFGS</code>, which is plausible in most situation.</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_pvalue">pvalue</code></td>
<td>
<p>The two-sided confidence interval is calculated at the last iteration at given significance level. Default is 0.05, which returns the 95% Wald's CI (2.5 to 97.5 percentile) based on the Hessian matrix.</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_trace">trace</code></td>
<td>
<p>Non-negative integer. If positive, <code><a href="stats.html#topic+optim">optim</a>()</code> outputs trace information. The default is 0 (no information).</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_report">report</code></td>
<td>
<p>The frequency of reports if <code>trace</code> is positive. Defaults to every 10 iterations.</p>
</td></tr>
<tr><td><code id="knownqpcr_unpaired_+3A_verbose">verbose</code></td>
<td>
<p>Send messages to stdout? Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table containing the estimated parameter values. The format is same as <code><a href="#topic+knownqpcr">knownqpcr</a>()</code>.
</p>


<h3>See Also</h3>

<p>Other estimation procedures: 
<code><a href="#topic+freqpcr">freqpcr</a>()</code>,
<code><a href="#topic+knownqpcr">knownqpcr</a>()</code>,
<code><a href="#topic+sim_dummy">sim_dummy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A dummy Cq dataset: four mixing ratios with four replicates.
# K:2, scaleDNA:1e-11, targetScale:1.5, baseChange:0.3, zeroAmount:1e-3,
# sdMeasure:0.3, and EPCR:0.95. Assuming a RED-DeltaDeltaCq analyses.
trueY &lt;- c(rep(0.1, 4), rep(0.25, 4), rep(0.5, 4), rep(1, 4))
housek0 &lt;- c( 19.39, 19.78, 19.28, 19.58,  18.95, 19.91, 19.66, 19.96,
              20.05, 19.86, 19.55, 19.61,  19.86, 19.27, 19.59, 20.21 )
target0 &lt;- c( 19.16, 19.08, 19.28, 19.03,  19.17, 19.67, 18.68, 19.52,
              18.92, 18.79, 18.8, 19.28,   19.57, 19.21, 19.05, 19.15 )
housek1 &lt;- c( 21.61, 21.78, 21.25, 21.07,  22.04, 21.45, 20.72, 21.6,
              21.51, 21.27, 21.08, 21.7,   21.44, 21.46, 21.5, 21.8 )
target1 &lt;- c( 24.3, 24.22, 24.13, 24.13,   22.74, 23.14, 23.02, 23.14,
              21.65, 22.62, 22.28, 21.65,  20.83, 20.82, 20.76, 21.3 )

# Incomplete observation dataset, prepared as the "long" format.
# If the undegested (Digest == 0) samples were only analyzed when trueY == 1.
d.long.all &lt;- data.frame(
    trueY=rep(trueY, 4), Digest=c(rep(0, 16 + 16), rep(1, 16 + 16)),
    Gene=c(rep(0, 16), rep(1, 16), rep(0, 16), rep(1, 16)),
    A=rep(1, 16*4), Cq=c(housek0, target0, housek1, target1)  )
d.long &lt;- d.long.all[d.long.all$Digest == 1 | d.long.all$trueY == 1, ]
print(d.long)

knownqpcr_unpaired( Digest=d.long$Digest, Gene=d.long$Gene,
                    trueY=d.long$trueY, Cq=d.long$Cq, A=d.long$A )

# In general DeltaDeltaCq analyses, the experimental design will not include
# dedicated control samples (Digest == 0).
d.long &lt;- d.long.all[d.long.all$Digest == 1, ]
knownqpcr_unpaired( Digest=d.long$Digest, Gene=d.long$Gene,
                    trueY=d.long$trueY, Cq=d.long$Cq, A=d.long$A )
</code></pre>

<hr>
<h2 id='make_dummy'>Generate dummy DNA dataset ready for allele-frequency estimation.</h2><span id='topic+make_dummy'></span>

<h3>Description</h3>

<p>The function generates a dummy dataset of typical RED-<code class="reqn">\Delta\Delta</code>Cq analysis. You can directly feed the output of this function to the first argument of <code><a href="#topic+sim_dummy">sim_dummy</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dummy(
  rand.seed,
  P,
  K,
  ntrap,
  npertrap,
  scaleDNA = (1/K) * 1e-06,
  targetScale,
  baseChange,
  EPCR,
  zeroAmount,
  sdMeasure,
  diploid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_dummy_+3A_rand.seed">rand.seed</code></td>
<td>
<p>Seed for the R built-in random-number-generator.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_p">P</code></td>
<td>
<p>A numeric between 0 and 1 giving the population allele frequency from which the test samples are generated.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_k">K</code></td>
<td>
<p>A positive numeric of the gamma shape parameter of the individual DNA yield.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_ntrap">ntrap</code>, <code id="make_dummy_+3A_npertrap">npertrap</code></td>
<td>
<p>Scalar specifying the number of bulk samples (<code>ntrap</code>) and the numbers of individuals contained in each bulk sample (<code>npertrap</code>). Currently limited to the cases that all bulk samples have the same sample size: e.g. (4 + 4 + 4) when <code>ntrap = 3</code> and <code>npertrap = 4</code> hold.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_scaledna">scaleDNA</code></td>
<td>
<p>Small positive scalar that specifies the scale parameter of the gamma distribution appriximating the DNA yield from (per-haploid) individual. The yield of <code>2*scaleDNA</code> is expected from a diploid. The quantity is determined as the relative amount, in linear scale, to the termination threshold of the real-time PCR.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_targetscale">targetScale</code></td>
<td>
<p>(<code class="reqn">\delta_{T}</code>) The relative template DNA amount of the target gene to the houskeeping gene, given as a positive numeric.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_basechange">baseChange</code></td>
<td>
<p>(<code class="reqn">\delta_{B}</code>) The change rate in the template DNA quantities after the restriction enzyme digestion (in the RED-<code class="reqn">\Delta\Delta</code>Cq method), given as a positive numeric. This parameter is not used in <code><a href="#topic+freqpcr">freqpcr</a>()</code>.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_epcr">EPCR</code></td>
<td>
<p>(<code class="reqn">\eta</code>) Amplification efficiency per PCR cycle, given as a positive numeric. When <code>EPCR = 1</code>, template DNA doubles every cycle (<code>EPCR + 1 = 2</code>).</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_zeroamount">zeroAmount</code></td>
<td>
<p>A numeric between 0 and 1, usually near 0, giving the residue rate of restriction enzyme digestion in RED-<code class="reqn">\Delta\Delta</code>Cq method.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_sdmeasure">sdMeasure</code></td>
<td>
<p>(<code class="reqn">\sigma_{c}</code>) Scalar. The measurement error (standard deviation) on each Cq value following Normal(0, <code class="reqn">\sigma_{c}^2</code>). If known, given as a positive numeric.</p>
</td></tr>
<tr><td><code id="make_dummy_+3A_diploid">diploid</code></td>
<td>
<p>Is the target organism diploidy? Default is <code>FALSE</code>, assuming haploidy. Current implementation of diploidy assumes i.i.d. between the amounts of R and S chromosomes owned by a heterozygote individual, which is unlikely in many animals but necessary for the calculation in a realistic time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the S4 class <a href="#topic+CqList-class">CqList</a>, storing the dummy experiment data of Cq-based qPCR analysis. Note that a <a href="#topic+CqList-class">CqList</a> object in no way contains original information on <code>P</code>, <code>K</code>, <code>targetScale</code>, <code>sdMeasure</code>, and <code>EPCR</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- 0.25
# Just a test: segregation ratios for six bulk samples, 1000 individuals for each.
rmultinom(n=6, size=1000, prob=c(P, 1-P)) # haploidy
rmultinom(6, size=1000, prob=c(P^2, 2*P*(1-P), (1-P)^2)) # diploidy

# Dummy Cq dataset with six bulk samples, each of which comprises eight haploids.
dmy_cq &lt;- make_dummy( rand.seed=1, P=0.15, K=2, ntrap=6, npertrap=8,
                      scaleDNA=1e-07, targetScale=1.5, baseChange=0.3, EPCR=0.95,
                      zeroAmount=1e-3, sdMeasure=0.3, diploid=FALSE )
print(dmy_cq)
</code></pre>

<hr>
<h2 id='sim_dummy'>Simulate freqpcr estimation based on user-generated dummy data.</h2><span id='topic+sim_dummy'></span>

<h3>Description</h3>

<p>Wrapper of <code><a href="#topic+freqpcr">freqpcr</a>()</code> suitable for the performance test using a randomly-generated data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_dummy(
  CqList,
  EPCR,
  zeroAmount,
  P = NULL,
  K = NULL,
  targetScale = NULL,
  sdMeasure = NULL,
  beta,
  diploid,
  maxtime,
  print.level,
  aux = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_dummy_+3A_cqlist">CqList</code></td>
<td>
<p>Object belonging to the <a href="#topic+CqList-class">CqList</a> class, typically the output from <code><a href="#topic+make_dummy">make_dummy</a>()</code>. Having the slots <code>N</code>, <code>housek0</code>, <code>target0</code>, <code>housek1</code>, and <code>target1</code>, all of which are numeric vectors of the same length.</p>
</td></tr>
<tr><td><code id="sim_dummy_+3A_epcr">EPCR</code></td>
<td>
<p>(<code class="reqn">\eta</code>) Amplification efficiency per PCR cycle, given as a positive numeric. When <code>EPCR = 1</code>, template DNA doubles every cycle (<code>EPCR + 1 = 2</code>).</p>
</td></tr>
<tr><td><code id="sim_dummy_+3A_zeroamount">zeroAmount</code></td>
<td>
<p>A numeric between 0 and 1, usually near 0, giving the residue rate of restriction enzyme digestion in RED-<code class="reqn">\Delta\Delta</code>Cq method.</p>
</td></tr>
<tr><td><code id="sim_dummy_+3A_p">P</code>, <code id="sim_dummy_+3A_k">K</code>, <code id="sim_dummy_+3A_targetscale">targetScale</code>, <code id="sim_dummy_+3A_sdmeasure">sdMeasure</code></td>
<td>
<p>If NULL (default), the parameter is considered unknown and estimated via <code><a href="#topic+freqpcr">freqpcr</a>()</code>. If a value is specified, it is passed to <code><a href="#topic+freqpcr">freqpcr</a>()</code> as a fixed parameter. On the contrary, <code>EPCR</code> and <code>zeroAmount</code> are always treated as fixed parameters, for which values must be supplied.</p>
</td></tr>
<tr><td><code id="sim_dummy_+3A_beta">beta</code>, <code id="sim_dummy_+3A_diploid">diploid</code>, <code id="sim_dummy_+3A_maxtime">maxtime</code>, <code id="sim_dummy_+3A_print.level">print.level</code></td>
<td>
<p>Configuration parameters which are passed directly to <code><a href="#topic+freqpcr">freqpcr</a>()</code>.</p>
</td></tr>
<tr><td><code id="sim_dummy_+3A_aux">aux</code></td>
<td>
<p>Additional information to be displayed on the console. The default is <code>NULL</code>. If some value is input by the user, it is echoed to stdout together with the contents of the argument <code>CqList</code>. This option is convenient when you want to record the original dummy dataset and the corresponding result sequentially e.g. using <code>capture.output()</code>.</p>
</td></tr>
<tr><td><code id="sim_dummy_+3A_verbose">verbose</code></td>
<td>
<p>Prints more information e.g. system time. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sim_dummy_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+freqpcr">freqpcr</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the S4 class <a href="#topic+CqFreq-class">CqFreq</a>, which is same as <code><a href="#topic+freqpcr">freqpcr</a>()</code>.
</p>


<h3>See Also</h3>

<p>Other estimation procedures: 
<code><a href="#topic+freqpcr">freqpcr</a>()</code>,
<code><a href="#topic+knownqpcr_unpaired">knownqpcr_unpaired</a>()</code>,
<code><a href="#topic+knownqpcr">knownqpcr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare the parameter values.
K &lt;- 2 # You already know the size of K in this case.
EPCR &lt;- 0.97 # The sizes of EPCR and zeroAmount must always be supplied.
zeroAmount &lt;- 1.6e-03
is.diploid &lt;- FALSE

# First, make a dummy Cq dataset with six bulk DNA samples,
# each of which comprises of eight haploid individuals.
dmy_cq &lt;- make_dummy( rand.seed=1, P=0.75, K=K, ntrap=6, npertrap=8, scaleDNA=1e-07,
                      targetScale=1.5, baseChange=0.3, EPCR=EPCR,
                      zeroAmount=zeroAmount, sdMeasure=0.3, diploid=is.diploid )

# Estimate the population allele frequency on the dummy dataset, presupposing K = 2.
sim_dummy(  CqList=dmy_cq, EPCR=EPCR, zeroAmount=zeroAmount,
            K=K,
            beta=TRUE, diploid=is.diploid, maxtime=60, print.level=2, aux="test" )

# If the maximum calculation time was too short to converge, nlm() returns error.
# Then sim_dummy() returns a matrix filled with zeros.
sim_dummy(  CqList=dmy_cq, EPCR=EPCR, zeroAmount=zeroAmount,
            beta=TRUE, diploid=is.diploid, maxtime=0.01, print.level=2 )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
