<!DOCTYPE html><html><head><title>Help for package migest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {migest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#alabama_1970'><p>Alabama population totals in 1960 and 1970 by age, sex and race</p></a></li>
<li><a href='#birth_mat'><p>Calculate births for each element of place of birth - place of residence stock matrix</p></a></li>
<li><a href='#block_matrix'><p>Create a block matrix with non-uniform block sizes.</p></a></li>
<li><a href='#block_sum'><p>Sum over a selected block in a block matrix</p></a></li>
<li><a href='#bombay_1951'><p>Bombay population totals in 1941 and 1951 by age</p></a></li>
<li><a href='#cm_net'><p>Conditional maximization routine for the indirect estimation of origin-destination-type migration flow tables with known net migration totals.</p></a></li>
<li><a href='#cm_net_tot'><p>Conditional maximization routine for the indirect estimation of origin-destination-type migration flow tables with known net migration and grand totals.</p></a></li>
<li><a href='#cm2'><p>Conditional maximization routine for the indirect estimation of origin-destination migration flow table with known margins</p></a></li>
<li><a href='#cm3'><p>Conditional maximization routine for the indirect estimation of origin-destination-migrant type migration flow tables with known origin and destination margins.</p></a></li>
<li><a href='#death_mat'><p>Calculate deaths for each element of place of birth - place of residence stock matrix</p></a></li>
<li><a href='#dict_ims'><p>Dictionary to look up region geographies based on countries used in UN DESA International Migrant Stock.</p></a></li>
<li><a href='#ffs_demo'><p>Estimation of bilateral migrant flows from bilateral migrant stocks using demographic accounting approaches</p></a></li>
<li><a href='#ffs_diff'><p>Estimation of bilateral migrant flows from bilateral migrant stocks using stock differencing approaches</p></a></li>
<li><a href='#ffs_rates'><p>Estimation of bilateral migrant flows from bilateral migrant stocks using rates approaches</p></a></li>
<li><a href='#index_age'><p>Summary indices of migration age profile</p></a></li>
<li><a href='#index_age_rc'><p>Summary indices of age migration profile based on parameters from a Rogers and Castro schedule</p></a></li>
<li><a href='#index_connectivity'><p>Summary indices of migration connectivity</p></a></li>
<li><a href='#index_distance'><p>Summary indices of migration distance</p></a></li>
<li><a href='#index_impact'><p>Summary indices of migration impact</p></a></li>
<li><a href='#index_intensity'><p>Summary indices of migration intensity</p></a></li>
<li><a href='#indian_sub'><p>Lifetime migration totals for states and zones in the Indian 1901 to 1931</p></a></li>
<li><a href='#ipf_seed'><p>Quickly create IPF seed</p></a></li>
<li><a href='#ipf2'><p>Iterative proportional fitting routine for the indirect estimation of origin-destination migration flow table with known margins.</p></a></li>
<li><a href='#ipf2_block'><p>Iterative proportional fitting routine for the indirect estimation of origin-destination-type migration flow tables with known origin and destination margins and block diagonal elements.</p></a></li>
<li><a href='#ipf2_stripe'><p>iterative proportional fitting routine for the indirect estimation of origin-destination-type migration flow tables with known origin and destination margins and stripe elements.</p></a></li>
<li><a href='#ipf3'><p>Iterative proportional fitting routine for the indirect estimation of origin-destination-migrant type migration flow tables with known origin and destination margins.</p></a></li>
<li><a href='#ipf3_qi'><p>Iterative proportional fitting routine for the indirect estimation of origin-destination-migrant type migration flow tables with known origin and destination margins and diagonal elements.</p></a></li>
<li><a href='#ipumsi_age'><p>Age specific migration and population counts from two IPUMSI samples</p></a></li>
<li><a href='#italy_area'><p>Single year age-specific origin destination migration flows between Italian NUTS1 areas</p></a></li>
<li><a href='#korea_gravity'><p>Annual origin destination migration flows between Korean regions alongside selected geographic, economic and demographic variables.</p></a></li>
<li><a href='#manila_1970'><p>Manila female population 1970 by age</p></a></li>
<li><a href='#match_birthplace_tot'><p>Adjust migrant stock tables to have matching place of birth (origin) totals</p></a></li>
<li><a href='#mig_chord'><p>Chord diagram for directional origin-destination data</p></a></li>
<li><a href='#mig_matrix'><p>Helper function to format migration input</p></a></li>
<li><a href='#mig_tibble'><p>Helper function to format migration input</p></a></li>
<li><a href='#migest-package'>
<p>Methods for the Indirect Estimation of Bilateral Migration</p></a></li>
<li><a href='#multi_comp'><p>Multiplicative component description of origin-destination migration flow tables</p></a></li>
<li><a href='#multi_comp2'><p>Multiplicative component descriptions of origin-destination flow tables based on total reference coding system.</p></a></li>
<li><a href='#nb_non_zero'><p>Handle negative native born populations</p></a></li>
<li><a href='#nb_scale_global'><p>Scale native born populations to match global differences in births and deaths over period</p></a></li>
<li><a href='#nchars_wrap'><p>Count the number of characters per line</p></a></li>
<li><a href='#net_sr'><p>Estimate net migration from survival ratios applied to lifetime migration data</p></a></li>
<li><a href='#net_vs'><p>Estimate net migration from vital statistics</p></a></li>
<li><a href='#new_england_1960'><p>New England male white-native population totals in 1950 and 1960 by place of birth and age</p></a></li>
<li><a href='#quadratic_eqn'><p>Solutions from the quadratic equation</p></a></li>
<li><a href='#rc_model_fund'><p>Fundamental parameters for Rogers-Castro migration schedule</p></a></li>
<li><a href='#rc_model_un'><p>Model parameters for six Rogers-Castro migration schedules proposed by UN DESA</p></a></li>
<li><a href='#rescale_integer_sum'><p>Rescale integer vector to a set sum</p></a></li>
<li><a href='#rescale_net'><p>Rescale net migration total to a global zero sum</p></a></li>
<li><a href='#str_wrap_n'><p>Wrap character string to fit a target number of lines</p></a></li>
<li><a href='#str_wrap_n_single'><p>Single line wrap for string</p></a></li>
<li><a href='#stripe_matrix'><p>Create a stripped matrix with non-uniform block sizes.</p></a></li>
<li><a href='#sum_bilat'><p>Summary of bilateral flows, counter-flow and net migration flow</p></a></li>
<li><a href='#sum_expand'><p>Sum bilateral data to include aggregate bilateral totals for origin and destination meta areas</p></a></li>
<li><a href='#sum_lump'><p>Sum and lump together small flows into a &quot;other&quot; category</p></a></li>
<li><a href='#sum_net'><p>Calculate net migration from an origin-destination migration flow matrix.</p></a></li>
<li><a href='#sum_od'><p>Extract a classic origin-destination migration flow matrix.</p></a></li>
<li><a href='#sum_region'><p>Summary of regional in-, out-, turnover and net-migration totals from an origin-destination migration flow matrix or data frame.</p></a></li>
<li><a href='#uar_1960'><p>Lifetime migration data for Governorates of United Arab Republic in 1960</p></a></li>
<li><a href='#umbrella'><p>Umbrella colour scheme</p></a></li>
<li><a href='#usa_1960'><p>US population totals in 1950 and 1960 by place of birth, age, sex and race</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for the Indirect Estimation of Bilateral Migration</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guy J. Abel &lt;g.j.abel@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for estimating, measuring and working with migration data.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://guyabel.github.io/migest/">http://guyabel.github.io/migest/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/guyabel/migest/issues">https://github.com/guyabel/migest/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, purrr, tidyr, stringr, magrittr, stats, tibble,
forcats, utils, matrixStats, migration.indices, circlize,
graphics, grDevices, mipfp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, countrycode</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-18 07:26:37 UTC; Guy</td>
</tr>
<tr>
<td>Author:</td>
<td>Guy J. Abel <a href="https://orcid.org/0000-0002-4893-5687"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-18 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='alabama_1970'>Alabama population totals in 1960 and 1970 by age, sex and race</h2><span id='topic+alabama_1970'></span>

<h3>Description</h3>

<p>Population data for Alabama by age, sex and race in 1960 and 1970
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alabama_1970
</code></pre>


<h3>Format</h3>

<p>Data frame with 68 rows and 6 columns:
</p>

<dl>
<dt>age_1970</dt><dd><p>Age group in 1970</p>
</dd>
<dt>sex</dt><dd><p>Sex from 'male' or 'female'</p>
</dd>
<dt>race</dt><dd><p>Race from 'white' or 'non-white'</p>
</dd>
<dt>pop_1960</dt><dd><p>Enumerated population in 1960. Number of births in first and second half of 1960s used for age groups '0-4' and '5-9'.</p>
</dd>
<dt>pop_1970</dt><dd><p>Enumerated population in 1970</p>
</dd>
<dt>us_census_sr</dt><dd><p>Census survival ratio based on US population</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data scraped from Figure 2.3 and Table 1-3A of Bogue, D. J., Hinze, K., &amp; White, M. (1982). Techniques of Estimating Net Migration. Community and Family Study Center. University of Chicago.
</p>

<hr>
<h2 id='birth_mat'>Calculate births for each element of place of birth - place of residence stock matrix</h2><span id='topic+birth_mat'></span>

<h3>Description</h3>

<p>This function is predominantly intended to be used within the ffs routines in the migest package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>birth_mat(b_por = NULL, m2 = NULL, method = "native", non_negative = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="birth_mat_+3A_b_por">b_por</code></td>
<td>
<p>Vector of numeric values for births in each place of residence</p>
</td></tr>
<tr><td><code id="birth_mat_+3A_m2">m2</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>+1. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="birth_mat_+3A_method">method</code></td>
<td>
<p>Character string of either <code>"native"</code> or <code>"proportion"</code> to choose method to distribute births. The <code>"proportion"</code> method assumes the rate of non-migration increase in each place of birth sub-group (native born and all foreign born stocks) is the same. The <code>"native"</code> method ensures that all births (non-migration increases) in stocks belong to the native born population (they do not move straight after birth).</p>
</td></tr>
<tr><td><code id="birth_mat_+3A_non_negative">non_negative</code></td>
<td>
<p>Adjust birth matrix calculation to ensure all deductions from <code>m2</code> will result in positive population counts. On rare occasions when working with international stock data the number of births can exceed the increase in the number of native born population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of place of birth by place of residence for new-born’s
</p>

<hr>
<h2 id='block_matrix'>Create a block matrix with non-uniform block sizes.</h2><span id='topic+block_matrix'></span>

<h3>Description</h3>

<p>Creates a <code>matrix</code> with differing size blocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_matrix(x = NULL, b = NULL, byrow = FALSE, dimnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_matrix_+3A_x">x</code></td>
<td>
<p>Vector of numbers to identify each block.</p>
</td></tr>
<tr><td><code id="block_matrix_+3A_b">b</code></td>
<td>
<p>Numeric value for the size of the blocks within the matrix ordered depending on <code>byrow</code></p>
</td></tr>
<tr><td><code id="block_matrix_+3A_byrow">byrow</code></td>
<td>
<p>Logical value. If <code>FALSE</code> (the default) the blocks are filled by columns, otherwise the blocks in the matrix are filled by rows.</p>
</td></tr>
<tr><td><code id="block_matrix_+3A_dimnames">dimnames</code></td>
<td>
<p>Character string of name attribute for the basis of the block matrix. If <code>NULL</code> a vector of the same length of <code>b</code> provides the basis of row and column names.#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>matrix</code> with block sizes determined by the <code>b</code> argument. Each block is filled with the same value taken from <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stripe_matrix">stripe_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>block_matrix(x = 1:16, b = c(2,3,4,2))

block_matrix(x = 1:25, b = c(2,3,4,2,1))
</code></pre>

<hr>
<h2 id='block_sum'>Sum over a selected block in a block matrix</h2><span id='topic+block_sum'></span>

<h3>Description</h3>

<p>Returns of a sum of a block within a <code>matrix</code>. This function is predominantly intended to be used within the <code><a href="#topic+ipf2_block">ipf2_block</a></code> routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_sum(block = NULL, m = NULL, block_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_sum_+3A_block">block</code></td>
<td>
<p>Numeric value of block to summed. To be matched against the matrix in <code>block_id</code>.</p>
</td></tr>
<tr><td><code id="block_sum_+3A_m">m</code></td>
<td>
<p>Matrix of all blocks combined.</p>
</td></tr>
<tr><td><code id="block_sum_+3A_block_id">block_id</code></td>
<td>
<p>Matrix of the same dimensions of <code>m</code> used to identify blocks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value of the sum of a single block.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+block_matrix">block_matrix</a></code>, <code><a href="#topic+stripe_matrix">stripe_matrix</a></code>, <code><a href="#topic+ipf2_block">ipf2_block</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(data = 100:220, nrow = 11, ncol = 11)
b &lt;- block_matrix(x = 1:16, b = c(2, 3, 4, 2))
block_sum(block = 1, m = m, block_id = b)
block_sum(block = 4, m = m, block_id = b)
block_sum(block = 16, m = m, block_id = b)
</code></pre>

<hr>
<h2 id='bombay_1951'>Bombay population totals in 1941 and 1951 by age</h2><span id='topic+bombay_1951'></span>

<h3>Description</h3>

<p>Population data for Bombay by age in 1941 and 1951
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bombay_1951
</code></pre>


<h3>Format</h3>

<p>Data frame with 13 rows and 5 columns:
</p>

<dl>
<dt>age_1941</dt><dd><p>Age group in 1941</p>
</dd>
<dt>age_1951</dt><dd><p>Age group in 1951</p>
</dd>
<dt>pop_1941</dt><dd><p>Enumerated population in 1941</p>
</dd>
<dt>pop_1951</dt><dd><p>Enumerated population in 1951</p>
</dd>
<dt>sr</dt><dd><p>Census survival ratio derived from the United Nations model life table corresponding to a life expectancy at birth of45 years for males. See Manual III: Methods for Population Projections by Sex and Age (United Nations publication, Sales No.: 56.XIII.3).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Indian Population Census. Published in United Nations Department of Economic and Social Affairs Population Division. (1970). Methods of measuring internal migration. United Nations Department of Economic and Social Affairs Population Division - 1970 - Methods of measuring internal migration <a href="https://www.un.org/development/desa/pd/sites/www.un.org.development.desa.pd/files/files/documents/2020/Jan/manual_vi_methods_of_measuring_internal_migration.pdf">https://www.un.org/development/desa/pd/sites/www.un.org.development.desa.pd/files/files/documents/2020/Jan/manual_vi_methods_of_measuring_internal_migration.pdf</a>
</p>

<hr>
<h2 id='cm_net'>Conditional maximization routine for the indirect estimation of origin-destination-type migration flow tables with known net migration totals.</h2><span id='topic+cm_net'></span>

<h3>Description</h3>

<p>The <code>cm_net</code> function finds the maximum likelihood estimates for fitted values in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn">\log y_{ij} = \log \alpha_{i} + \log \alpha_{i}^{-1} + \log m_{ij} </code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>cm_net(
  net_tot = NULL,
  m = NULL,
  tol = 1e-06,
  maxit = 500,
  verbose = TRUE,
  alpha0 = rep(1, length(net_tot))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cm_net_+3A_net_tot">net_tot</code></td>
<td>
<p>Vector of net migration totals to constrain the sum of the imputed cell row and columns. Elements must sum to zero.</p>
</td></tr>
<tr><td><code id="cm_net_+3A_m">m</code></td>
<td>
<p>Array of auxiliary data. By default, set to 1 for all origin-destination-migrant typologies combinations.</p>
</td></tr>
<tr><td><code id="cm_net_+3A_tol">tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="cm_net_+3A_maxit">maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="cm_net_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cm_net_+3A_alpha0">alpha0</code></td>
<td>
<p>Vector of initial estimates for alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Conditional maximisation routine set up using the partial likelihood derivatives. The argument <code>net_tot</code> takes the known net migration totals.
The user must ensure that the net migration totals sum globally to zero.
</p>
<p>Returns a <code>list</code> object with
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Array of indirect estimates of origin-destination matrices by migrant characteristic</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>Iteration count</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>Tolerance level at final iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel, Peter W. F. Smith
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(data = 1:16, nrow = 4)
# m[lower.tri(m)] &lt;- t(m)[lower.tri(m)]
addmargins(m)
sum_net(m)

y &lt;- cm_net(net_tot = c(30, 40, -15, -55), m = m)
addmargins(y$n)
sum_net(y$n)

m &lt;- matrix(data = c(0, 100, 30, 70, 50, 0, 45, 5, 60, 35, 0, 40, 20, 25, 20, 0),
            nrow = 4, ncol = 4, byrow = TRUE,
            dimnames = list(orig = LETTERS[1:4], dest = LETTERS[1:4]))
addmargins(m)
sum_net(m)

y &lt;- cm_net(net_tot = c(-100, 125, -75, 50), m = m)
addmargins(y$n)
sum_net(y$n)
</code></pre>

<hr>
<h2 id='cm_net_tot'>Conditional maximization routine for the indirect estimation of origin-destination-type migration flow tables with known net migration and grand totals.</h2><span id='topic+cm_net_tot'></span>

<h3>Description</h3>

<p>The <code>cm_net</code> function finds the maximum likelihood estimates for fitted values in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn">\log y_{ij} = \log \alpha_{i} + \log \alpha_{i}^{-1} + \log m_{ij} </code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>cm_net_tot(
  net_tot = NULL,
  tot = NULL,
  m = NULL,
  tol = 1e-06,
  maxit = 500,
  verbose = TRUE,
  alpha0 = rep(1, length(net_tot)),
  lambda0 = 1,
  alpha_constrained = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cm_net_tot_+3A_net_tot">net_tot</code></td>
<td>
<p>Vector of net migration totals to constrain the sum of the imputed cell row and columns. Elements must sum to zero.</p>
</td></tr>
<tr><td><code id="cm_net_tot_+3A_tot">tot</code></td>
<td>
<p>Numeric value of grand total to constrain sum of all imputed cells.</p>
</td></tr>
<tr><td><code id="cm_net_tot_+3A_m">m</code></td>
<td>
<p>Array of auxiliary data. By default, set to 1 for all origin-destination-migrant typologies combinations.</p>
</td></tr>
<tr><td><code id="cm_net_tot_+3A_tol">tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="cm_net_tot_+3A_maxit">maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="cm_net_tot_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cm_net_tot_+3A_alpha0">alpha0</code></td>
<td>
<p>Vector of initial estimates for alpha</p>
</td></tr>
<tr><td><code id="cm_net_tot_+3A_lambda0">lambda0</code></td>
<td>
<p>Numeric value of initial estimates for lambda</p>
</td></tr>
<tr><td><code id="cm_net_tot_+3A_alpha_constrained">alpha_constrained</code></td>
<td>
<p>Logical value to indicate if the first alpha should be constrain to unity. By default <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Conditional maximisation routine set up using the partial likelihood derivatives. The argument <code>net_tot</code> takes the known net migration totals.
The user must ensure that the net migration totals sum globally to zero.
</p>
<p>Returns a <code>list</code> object with
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Array of indirect estimates of origin-destination matrices by migrant characteristic</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>Iteration count</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>Tolerance level at final iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel, Peter W. F. Smith
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(data = 1:16, nrow = 4)
# m[lower.tri(m)] &lt;- t(m)[lower.tri(m)]
addmargins(m)
sum_net(m)

y &lt;- cm_net_tot(net_tot = c(30, 40, -15, -55), tot = 200, m = m)
addmargins(y$n)
sum_net(y$n)

m &lt;- matrix(data = c(0, 100, 30, 70, 50, 0, 45, 5, 60, 35, 0, 40, 20, 25, 20, 0),
            nrow = 4, ncol = 4, byrow = TRUE,
            dimnames = list(orig = LETTERS[1:4], dest = LETTERS[1:4]))
addmargins(m)
sum_net(m)

y &lt;- cm_net_tot(net_tot = c(-100, 125, -75, 50), tot = 600, m = m)
addmargins(y$n)
sum_net(y$n)
</code></pre>

<hr>
<h2 id='cm2'>Conditional maximization routine for the indirect estimation of origin-destination migration flow table with known margins</h2><span id='topic+cm2'></span>

<h3>Description</h3>

<p>The <code>cm2</code> function finds the maximum likelihood estimates for parameters in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn"> \log y_{ij} = \log \alpha_i + \log \beta_j + \log m_{ij} </code>
</p>

<p>as introduced by Willekens (1999). The <code class="reqn">\alpha_i</code> and  <code class="reqn">\beta_j</code> represent background information related to  the characteristics of the origin and destinations respectively. The <code class="reqn">m_{ij}</code> factor represents auxiliary information on migration flows, which imposes its interaction structure onto the estimated flow matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm2(
  row_tot = NULL,
  col_tot = NULL,
  m = matrix(data = 1, nrow = length(row_tot), ncol = length(col_tot)),
  tol = 1e-06,
  maxit = 500,
  verbose = TRUE,
  rtot = row_tot,
  ctot = col_tot
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cm2_+3A_row_tot">row_tot</code></td>
<td>
<p>Vector of origin totals to constrain the sum of the imputed cell rows.</p>
</td></tr>
<tr><td><code id="cm2_+3A_col_tot">col_tot</code></td>
<td>
<p>Vector of destination totals to constrain the sum of the imputed cell columns.</p>
</td></tr>
<tr><td><code id="cm2_+3A_m">m</code></td>
<td>
<p>Matrix of auxiliary data. By default set to 1 for all origin-destination combinations.</p>
</td></tr>
<tr><td><code id="cm2_+3A_tol">tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="cm2_+3A_maxit">maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="cm2_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cm2_+3A_rtot">rtot</code></td>
<td>
<p>Depreciated. Use <code>row_tot</code></p>
</td></tr>
<tr><td><code id="cm2_+3A_ctot">ctot</code></td>
<td>
<p>Depreciated. Use <code>col_tot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter estimates are obtained using the EM algorithm outlined in Willekens (1999). This is equivalent to a conditional maximization of the likelihood, as discussed by Raymer et. al. (2007). It also provides identical indirect estimates to those obtained from the <code><a href="#topic+ipf2">ipf2</a></code> routine. 
</p>
<p>The user must ensure that the row and column totals are equal in sum. Care must also be taken to allow the dimension of the auxiliary matrix (<code>m</code>) to equal those provided in the row (<code>row_tot</code>) and column (<code>col_tot</code>) arguments.
</p>
<p>Returns a <code>list</code> object with
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>Origin-Destination matrix of indirect estimates</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Collection of parameter estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Raymer, J., G. J. Abel, and P. W. F. Smith (2007). Combining census and registration data to estimate detailed elderly migration flows in England and Wales. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em> 170 (4), 891&ndash;908.
</p>
<p>Willekens, F. (1999). Modelling Approaches to the Indirect Estimation of Migration Flows: From Entropy to EM. <em>Mathematical Population Studies</em> 7 (3), 239&ndash;78.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ipf2">ipf2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## with Willekens (1999) data
r &lt;- LETTERS[1:2]
y &lt;- cm2(row_tot = c(18, 20), col_tot = c(16, 22), 
         m = matrix(c(5, 1, 2, 7), ncol = 2, dimnames = list(orig = r, dest = r)))
y

## with all elements of offset equal (independence fit)
y &lt;- cm2(row_tot = c(18, 20), col_tot = c(16, 22))
y

## with bigger matrix
r &lt;- LETTERS[1:4]
y &lt;- cm2(row_tot = c(250, 100, 140, 110), col_tot = c(150, 150, 180, 120),
         m = matrix(data = c(0, 100, 30, 70, 50, 0, 45, 5, 60, 35, 0, 40, 20, 25, 20, 0),
                    nrow = 4, ncol = 4, dimnames = list(orig = r, dest = r), byrow = TRUE))
                    
# display with row and col totals
round(addmargins(y$n)) 
</code></pre>

<hr>
<h2 id='cm3'>Conditional maximization routine for the indirect estimation of origin-destination-migrant type migration flow tables with known origin and destination margins.</h2><span id='topic+cm3'></span>

<h3>Description</h3>

<p>The <code>cm3</code> function finds the maximum likelihood estimates for parameters in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn"> \log y_{ijk} = \log \alpha_{i} + \log \beta_{j} + \log m_{ijk} </code>
</p>

<p>as introduced by Abel (2005). The <code class="reqn">\alpha_{i}</code> and  <code class="reqn">\beta_{j}</code> represent background information related to  the characteristics of the origin and destinations respectively. The <code class="reqn">m_{ijk}</code> factor represents auxiliary information on origin-destination migration flows by a migrant characteristic (such as age, sex, disability, household type, economic status, etc.). This method is useful for combining data from detailed data collection processes (such as a Census) with more up-to-date information on migration inflows and outflows (where details on movements by migrant characteristics are not known).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cm3(
  row_tot = NULL,
  col_tot = NULL,
  m = NULL,
  tol = 1e-06,
  maxit = 500,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cm3_+3A_row_tot">row_tot</code></td>
<td>
<p>Vector of origin totals to constrain the sum of the imputed cell rows.</p>
</td></tr>
<tr><td><code id="cm3_+3A_col_tot">col_tot</code></td>
<td>
<p>Vector of destination totals to constrain the sum of the imputed cell columns.</p>
</td></tr>
<tr><td><code id="cm3_+3A_m">m</code></td>
<td>
<p>Array of auxiliary data. By default set to 1 for all origin-destination-migrant typology combinations.</p>
</td></tr>
<tr><td><code id="cm3_+3A_tol">tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="cm3_+3A_maxit">maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="cm3_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter estimates were obtained using the conditional maximization of the likelihood, as discussed by Abel (2005) and Raymer et. al. (2007). 
</p>
<p>The user must ensure that the row and column totals are equal in sum. Care must also be taken to allow the row and column dimension of the auxiliary matrix (<code>m</code>) to equal those provided in the row and column totals.
</p>
<p>Returns a <code>list</code> object with
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>Origin-Destination matrix of indirect estimates</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Collection of parameter estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Abel, G. J. (2005) <em>The Indirect Estimation of Elderly Migrant Flows in England and Wales</em> (MS.c. Thesis). University of Southampton
</p>
<p>Raymer, J., G. J. Abel, and P. W. F. Smith (2007). Combining census and registration data to estimate detailed elderly migration flows in England and Wales. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em> 170 (4), 891&ndash;908.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cm2">cm2</a></code>, <code><a href="#topic+ipf3">ipf3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## over two tables
r &lt;- LETTERS[1:2]
y &lt;- cm3(row_tot = c(18, 20) * 2, col_tot = c(16, 22) * 2,
         m = array(c(5, 1, 2, 7, 4, 2, 5, 9), dim = c(2, 2, 2),
                   dimnames = list(orig = r, dest = r, type = c("ILL", "HEALTHY"))))
# display with row, col and table totals
y

## over three tables
y &lt;- cm3(row_tot = c(170, 120, 410), col_tot = c(500, 140, 60),
         m = array(c(5, 1, 2, 7,  4, 2, 5, 9,  5, 4, 3, 1), dim = c(2, 2, 3),
                   dimnames = list(orig = r, dest = r, type = c("0--15", "15-60", "&gt;60"))),
                   verbose = FALSE)
# display with row, col and table totals
y
</code></pre>

<hr>
<h2 id='death_mat'>Calculate deaths for each element of place of birth - place of residence stock matrix</h2><span id='topic+death_mat'></span>

<h3>Description</h3>

<p>This function is predominantly intended to be used within the <code>ffs</code> routines in the migest package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>death_mat(
  d_por = NULL,
  m1 = NULL,
  method = "proportion",
  m2 = NULL,
  b_por = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="death_mat_+3A_d_por">d_por</code></td>
<td>
<p>Vector of numeric values for deaths in each place of residence.</p>
</td></tr>
<tr><td><code id="death_mat_+3A_m1">m1</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>. Used to distribute deaths proportionally to each migrant stock population.</p>
</td></tr>
<tr><td><code id="death_mat_+3A_method">method</code></td>
<td>
<p>Character string of either <code>"proportion"</code> or <code>"accounting"</code> to choose method to distribute deaths. The <code>"proportion"</code> method assumes the mortality rate in each place of birth sub-group (native born and all foreign born stocks) is the same. The <code>"accounting"</code> method ensures that the the deaths by place of birth matches that implied by demographic accounting. Still needs to be explored fully.</p>
</td></tr>
<tr><td><code id="death_mat_+3A_m2">m2</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>+1. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>+1. Used to distribute deaths proportionally to each migrant stock population. For use when <code>method = "accounting"</code></p>
</td></tr>
<tr><td><code id="death_mat_+3A_b_por">b_por</code></td>
<td>
<p>Vector of numeric values for births in each place of residence. For use when <code>method = "accounting"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of place of death by place of residence
</p>

<hr>
<h2 id='dict_ims'>Dictionary to look up region geographies based on countries used in UN DESA International Migrant Stock.</h2><span id='topic+dict_ims'></span>

<h3>Description</h3>

<p>Intended for use as a custom dictionary with the countrycode package, where the existing UN region and area codes do not match those used by UN DESA in the WPP, see <a href="https://github.com/vincentarelbundock/countrycode/issues/253">https://github.com/vincentarelbundock/countrycode/issues/253</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dict_ims
</code></pre>


<h3>Format</h3>

<p>Data frame with 243 rows and 18 columns. One of first three columns intended as input for <code>origin</code> in <code>countrycode</code>.
</p>

<dl>
<dt>name</dt><dd><p>Country name</p>
</dd>
<dt>iso3c</dt><dd><p>ISO numeric code</p>
</dd>
<dt>iso3n</dt><dd><p>ISO 3 letter code</p>
</dd>
</dl>

<p>Remaining columns intended as input for <code>destination</code> in <code>countrycode</code>.
</p>

<dl>
<dt>name_short</dt><dd><p>Short country name</p>
</dd>
<dt>ims</dt><dd><p>Country in UN DESA International Migration Stock data. Some codes added for older political geographies to match World Bank data and older country units in IMS</p>
</dd>
<dt>region</dt><dd><p>Geographic region of country (6)</p>
</dd>
<dt>region_sub</dt><dd><p>Geographic sub region of country (22). Filled using <code>region</code> if none given in original data</p>
</dd>
<dt>region_sdg</dt><dd><p>SDG region of country (8)</p>
</dd>
<dt>region_sdg_sub</dt><dd><p>Sub SDG region of country (9). Filled using <code>region_sdg</code> if none given in original data</p>
</dd>
<dt>region_wb</dt><dd><p>World Bank region</p>
</dd>
<dt>un_develop</dt><dd><p>UN development group of country (3)</p>
</dd>
<dt>wb_income</dt><dd><p>World Bank income group of country (3)</p>
</dd>
<dt>wb_income_detail</dt><dd><p>Detailled World Bank income group of country (4)</p>
</dd>
<dt>lldc</dt><dd><p>Indicator variable for Land-Locked Developing Countries (32)</p>
</dd>
<dt>sids</dt><dd><p>Indicator variable for Small Island Developing States (58)</p>
</dd>
<dt>region_as2014</dt><dd><p>Region grouping used for global chord diagram plots by Abel and Sander (2014)</p>
</dd>
<dt>region_sab2014</dt><dd><p>Region grouping used for global chord diagram plots by Sander, Abel and Bauer (2014)</p>
</dd>
<dt>region_a2018</dt><dd><p>Region grouping used for global chord diagram plots by Abel (2018)</p>
</dd>
<dt>region_ac2022</dt><dd><p>Region grouping used for global chord diagram plots by Abel and Cohen (2022)</p>
</dd>
</dl>



<h3>Source</h3>

<p>The aggregates_correspondence_table_2020_1.xlsx file of United Nations Department of Economic and Social Affairs, Population Division (2020). International Migrant Stock 2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidyverse)
library(countrycode)
# download Abel and Cohen (2019) estimates
f &lt;- read_csv("https://ndownloader.figshare.com/files/38016762", show_col_types = FALSE)
f

# use dictionary to get region to region flows
d &lt;- f %&gt;%
  mutate(
    orig = countrycode(
      sourcevar = orig, custom_dict = dict_ims,
      origin = "iso3c", destination = "region"),
    dest = countrycode(
      sourcevar = dest, custom_dict = dict_ims,
      origin = "iso3c", destination = "region")
  ) %&gt;%
  group_by(year0, orig, dest) %&gt;%
  summarise_all(sum)
d

## End(Not run)
</code></pre>

<hr>
<h2 id='ffs_demo'>Estimation of bilateral migrant flows from bilateral migrant stocks using demographic accounting approaches</h2><span id='topic+ffs_demo'></span><span id='topic+ffs'></span>

<h3>Description</h3>

<p>Estimates migrant transitions flows between two sequential migrant stock tables. Replaces old <code>ffs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffs_demo(
  stock_start = NULL,
  stock_end = NULL,
  births = NULL,
  deaths = NULL,
  seed = NULL,
  stayer_assumption = TRUE,
  match_global = "before-demo-adjust",
  match_birthplace_tot_method = "rescale",
  birth_method = "native",
  birth_non_negative = TRUE,
  death_method = "proportion",
  verbose = FALSE,
  return = "flow"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffs_demo_+3A_stock_start">stock_start</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>. Previously had argument name <code>m1</code>.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_stock_end">stock_end</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>+1. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>+1. Previously had argument name <code>m2</code>.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_births">births</code></td>
<td>
<p>Vector of the number of births between time <em>t</em> and <em>t</em>+1 in each region. Previously had argument name <code>b_por</code>.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_deaths">deaths</code></td>
<td>
<p>Vector of the number of deaths between time <em>t</em> and <em>t</em>+1 in each region. Previously had argument name <code>d_por</code>.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_seed">seed</code></td>
<td>
<p>Matrix of auxiliary data. By default set to 1 for all origin-destination combinations. Previously had argument name <code>m</code>.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_stayer_assumption">stayer_assumption</code></td>
<td>
<p>Logical value to indicate whether to use a quasi-independent or independent IPFP to estimate flows. By default uses quasi-independent, i.e. is set to <code>TRUE</code> and estimates the minimum migration. When set to <code>FALSE</code> estimates flows under the independent model as used as part of Azose and Raftery (2019).</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_match_global">match_global</code></td>
<td>
<p>Character string used to indicate whether to balance the change in stocks totals with the changes in births and deaths. Only applied when <code>match_birthplace_tot_method</code> is either <code>rescale</code> or <code>rescale-adjust-zero-fb</code>. By default uses <code>after-demo-adjust</code> rather than <code>before-demo-adjust</code> which I think minimises risk of negative values.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_match_birthplace_tot_method">match_birthplace_tot_method</code></td>
<td>
<p>Character string passed to <code>method</code> argument in <code>match_birthplace_tot</code> to ensure place of birth margins in stock tables match.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_birth_method">birth_method</code></td>
<td>
<p>Character string passed to <code>method</code> argument in <code>birth_mat</code>.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_birth_non_negative">birth_non_negative</code></td>
<td>
<p>Logical value passed to <code>non_negative</code> argument in <code>birth_mat</code>.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_death_method">death_method</code></td>
<td>
<p>Character string passed to <code>method</code> argument in <code>death_mat</code>.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to show progress of the estimation procedure. By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ffs_demo_+3A_return">return</code></td>
<td>
<p>Character string used to indicate whether to return the array of estimated flows when set to <code>flow</code> (default), array of demographic accounts when set to <code>account</code> or the demographic account, list of input settings and the origin-destination matrix when set to <code>classic</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates migrant transitions flows between two sequential migrant stock tables using various methods. See the example section for possible variations on estimation methods.
</p>
<p>Detail of returned object varies depending on the setting used in the <code>return</code> argument.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Abel and Cohen (2019) Bilateral international migration flow estimates for 200 countries <em>Scientific Data</em> 6 (1), 1-13
</p>
<p>Azose &amp; Raftery (2019) Estimation of emigration, return migration, and transit migration between all pairs of countries <em>Proceedings of the National Academy of Sciences</em> 116 (1) 116-122
</p>
<p>Abel, G. J. (2018). Estimates of Global Bilateral Migration Flows by Gender between 1960 and 2015. <em>International Migration Review</em> 52 (3), 809–852.
</p>
<p>Abel, G. J. and Sander, N. (2014). Quantifying Global International Migration Flows. <em>Science</em>, 343 (6178) 1520-1522
</p>
<p>Abel, G. J. (2013). Estimating Global Migration Flow Tables Using Place of Birth. <em>Demographic Research</em> 28, (18) 505-546
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffs_diff">ffs_diff</a></code>, <code><a href="#topic+ffs_rates">ffs_rates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## without births and deaths over period
##
# data as in demographic research and science paper papers
s1 &lt;- matrix(data = c(1000, 100, 10, 0, 55, 555, 50, 5, 80, 40, 800, 40, 20, 25, 20, 200),
             nrow = 4, ncol = 4, byrow = TRUE)
s2 &lt;- matrix(data = c(950, 100, 60, 0, 80, 505, 75, 5, 90, 30, 800, 40, 40, 45, 0, 180),
             nrow = 4, ncol = 4, byrow = TRUE)
b &lt;- d &lt;- rep(0, 4)
r &lt;- LETTERS[1:4]
dimnames(s1) &lt;- dimnames(s2) &lt;- list(birth =  r, dest = r)
names(b) &lt;- names(d) &lt;- r
addmargins(s1)
addmargins(s2)
b
d

# demographic research and science paper example
e0 &lt;- ffs_demo(stock_start = s1, stock_end = s2, births = b, deaths = d)
e0
sum_od(e0)

# international migration review paper example
s1[,] &lt;- c(100, 20, 10, 20, 10, 55, 40, 25, 10, 25, 140, 20, 0, 10, 65, 200)
s2[,] &lt;- c(70, 25, 10, 40, 30, 60, 55, 45, 10, 10, 140, 0, 10, 15, 50, 180)
addmargins(s1)
addmargins(s2)

e1 &lt;- ffs_demo(stock_start = s1, stock_end = s2, births = b, deaths = d)
sum_od(e1)

# international migration review supp. material example
# distance matrix
dd &lt;- matrix(data = c(0, 5, 50, 500, 5, 0, 45, 495, 50, 45, 0, 450, 500, 495, 450, 0),
             nrow = 4, ncol = 4, byrow = TRUE)
dimnames(dd) &lt;- list(orig = r, dest = r)
dd
e2 &lt;- ffs_demo(stock_start = s1, stock_end = s2, births = b, deaths = d, seed = dd)
sum_od(e2)

##
## with births and deaths over period
##
# demographic research paper example (with births and deaths)
s1[,] &lt;- c(1000, 55, 80, 20, 100, 555, 40, 25, 10, 50, 800, 20, 0, 5, 40, 200)
s2[,] &lt;- c(1060, 45, 70, 30, 60, 540, 75, 30, 10, 40, 770, 20, 10, 0, 70, 230)
b[] &lt;- c(80, 20, 40, 60)
d[] &lt;- c(70, 30, 50, 10)
e3 &lt;- ffs_demo(stock_start = s1, stock_end = s2, 
               births = b, deaths = d, 
               match_birthplace_tot_method = "open-dr")
sum_od(e3)
# makes more sense to use this method
e4 &lt;- ffs_demo(stock_start = s1, stock_end = s2, 
               births = b, deaths = d, 
               match_birthplace_tot_method = "open")
sum_od(e4)

# science paper  supp. material example
b[] &lt;- c(80, 20, 60, 60)
e5 &lt;- ffs_demo(stock_start = s1, stock_end = s2, births = b, deaths = d)
sum_od(e5)

# international migration review supp. material example (with births and deaths)
s1[,] &lt;- c(100, 20, 10, 20, 10, 55, 40, 25, 10, 25, 140, 20, 0, 10, 65, 200)
s2[,] &lt;- c(75, 20, 30, 30, 25, 45, 40, 30, 5, 30, 150, 20, 0, 15, 60, 230)
b[] &lt;- c(10, 50, 25, 60)
d[] &lt;- c(30, 10, 40, 10)
e6 &lt;- ffs_demo(stock_start = s1, stock_end = s2, births = b, deaths = d)
sum_od(e6)

# scientific data 2019 paper
s1[] &lt;- c(100, 80, 30, 60, 10, 180, 10, 70, 10, 10, 140, 10, 0, 90, 40, 160)
s2[] &lt;- c(95, 75, 55, 35, 5, 225, 0, 25, 15, 5, 115, 25, 5, 55, 50, 215)
b[] &lt;- c(0, 0, 0, 0)
d[] &lt;- c(0, 0, 0, 0)
e7 &lt;- ffs_demo(stock_start = s1, stock_end = s2, births = b, deaths = d)
sum_od(e7)
</code></pre>

<hr>
<h2 id='ffs_diff'>Estimation of bilateral migrant flows from bilateral migrant stocks using stock differencing approaches</h2><span id='topic+ffs_diff'></span>

<h3>Description</h3>

<p>Estimates migrant transitions flows between two sequential migrant stock tables using differencing approaches commonly used by economists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffs_diff(
  stock_start,
  stock_end,
  decrease = "return",
  include_native_born = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffs_diff_+3A_stock_start">stock_start</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em></p>
</td></tr>
<tr><td><code id="ffs_diff_+3A_stock_end">stock_end</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>+1. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="ffs_diff_+3A_decrease">decrease</code></td>
<td>
<p>How to treat decreases in bilateral stocks over the <em>t</em> to <em>t</em>+1 period (so as to avoid a negative bilateral flow estimates). See details for possible options. Default is <code>return</code></p>
</td></tr>
<tr><td><code id="ffs_diff_+3A_include_native_born">include_native_born</code></td>
<td>
<p>Logical value to indicate whether to include diagonal elements of <code>stock_start</code> and <code>stock_end</code>. Default of <code>FALSE</code> - not include.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates migrant transitions flows between two sequential migrant stock tables. 
</p>
<p>When <code>decrease = "zero"</code> all decreases in migrant stocks over there period are set to zero, following the approach of Bertoli and Fernandez-Huertas Moraga (2015) 
</p>
<p>When <code>decrease = "return"</code> all decreases in migrant stocks are assumed to correspond to return flows back to their place of birth, following the approach of Beine and Parsons (2015)
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Beine, Michel, Simone Bertoli, and Jesús Fernández-Huertas Moraga. (2016). A Practitioners’ Guide to Gravity Models of International Migration. <em>The World Economy</em> 39(4):496–512.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffs_demo">ffs_demo</a></code>, <code><a href="#topic+ffs_rates">ffs_rates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- matrix(data = c(100, 10, 10, 0, 20, 55, 25, 10, 10, 40, 140, 65, 20, 25, 20, 200),
             nrow = 4, ncol = 4, byrow = TRUE)
s2 &lt;- matrix(data = c(75, 25, 5, 15, 20, 45, 30, 15, 30, 40, 150, 35, 10, 50, 5, 200),
             nrow = 4, ncol = 4, byrow = TRUE)
r &lt;- LETTERS[1:4]
dimnames(s1) &lt;- dimnames(s2) &lt;- list(pob = r, por = r)
s1; s2

ffs_diff(stock_start = s1, stock_end = s2, decrease = "zero")
ffs_diff(stock_start = s1, stock_end = s2, decrease = "return")
</code></pre>

<hr>
<h2 id='ffs_rates'>Estimation of bilateral migrant flows from bilateral migrant stocks using rates approaches</h2><span id='topic+ffs_rates'></span>

<h3>Description</h3>

<p>Estimates migrant transitions flows between two sequential migrant stock tables using approached based on rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffs_rates(stock_start = NULL, stock_end = NULL, M = NULL, method = "dennett")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffs_rates_+3A_stock_start">stock_start</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em></p>
</td></tr>
<tr><td><code id="ffs_rates_+3A_stock_end">stock_end</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>+1. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="ffs_rates_+3A_m">M</code></td>
<td>
<p>Numeric value for the global sum of migration flows, used for <code>dennett</code> approach.</p>
</td></tr>
<tr><td><code id="ffs_rates_+3A_method">method</code></td>
<td>
<p>Method to estimate flows. Can take values <code>dennett</code> or <code>rogers-von-rabenau</code>. See details section for more information. Uses <code>dennett</code> as default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimates migrant transitions flows based on migration rates.
</p>
<p>When <code>method = "dennett"</code> migration are derived from the matrix supplied to <code>stock_start</code>. Dennett uses bilateral migrant stocks at beginning of period. Rates then multiplied by global migration flows supplied in <code>M</code>.
</p>
<p>When <code>method = "rogers-von-rabenau"</code> a matrix of growth rates are derived from the changes in initial populations stock <code>stock_start</code> to obtain <code>stock_end</code>;
</p>
<p style="text-align: center;"><code class="reqn">P^{t+1} = g P^{t}</code>
</p>

<p>and then multiplied by the corresponding populations at risk in <code>stock_start</code>. Can result in negative flows.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Dennett, A. (2015). Estimating an Annual Time Series of Global Migration Flows - An Alternative Methodology for Using Migrant Stock Data. <em>Global Dynamics: Approaches from Complexity Science</em>, 125–142. https://doi.org/10.1002/9781118937464.ch7
</p>
<p>Rogers, A., &amp; Von Rabenau, B. (1971). Estimation of interregional migration streams from place-of-birth-by-residence data. <em>Demography</em>, 8(2), 185–194.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffs_demo">ffs_demo</a></code>, <code><a href="#topic+ffs_rates">ffs_rates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- matrix(data = c(100, 10, 10, 0, 20, 55, 25, 10, 10, 40, 140, 65, 20, 25, 20, 200),
             nrow = 4, ncol = 4, byrow = TRUE)
s2 &lt;- matrix(data = c(75, 25, 5, 15, 20, 45, 30, 15, 30, 40, 150, 35, 10, 50, 5, 200),
             nrow = 4, ncol = 4, byrow = TRUE)
r &lt;- LETTERS[1:4]
dimnames(s1) &lt;- dimnames(s2) &lt;- list(pob = r, por = r)
s1; s2

# calculate total migration flows for dennett approach
n &lt;- colSums(s2) - colSums(s1)

ffs_rates(stock_start = s1, M =  sum(abs(n)), method = "dennett" )
ffs_rates(stock_start = s1, stock_end = s2, method = "rogers-von-rabenau" )
</code></pre>

<hr>
<h2 id='index_age'>Summary indices of migration age profile</h2><span id='topic+index_age'></span>

<h3>Description</h3>

<p>Summary measures of migration age profiles as proposed by Rogers (1975), Bell et. al. (2002), Bell and Muhidin (2009) and Bernard, Bell and Charles-Edwards (2014)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_age(
  d = NULL,
  age,
  mi,
  age_min = 5,
  age_max = 65,
  breadth = 5,
  age_col = "age",
  mi_col = "mi",
  long = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_age_+3A_d">d</code></td>
<td>
<p>Data frame of age specific migration intensities. If used, ensure the correct column names are passed to <code>age_col</code> and <code>mi_col</code>.</p>
</td></tr>
<tr><td><code id="index_age_+3A_age">age</code></td>
<td>
<p>Numeric vector of ages. Used if <code>d = NULL</code>.</p>
</td></tr>
<tr><td><code id="index_age_+3A_mi">mi</code></td>
<td>
<p>Numeric vector of migration intensities corresponding to each value of <code>age</code>. Used if <code>d = NULL</code>.</p>
</td></tr>
<tr><td><code id="index_age_+3A_age_min">age_min</code></td>
<td>
<p>Numeric value for minimum age for peak calculations. Taken as 5 by default.</p>
</td></tr>
<tr><td><code id="index_age_+3A_age_max">age_max</code></td>
<td>
<p>Numeric value for maximum age for peak calculations. Taken as 65 by default.</p>
</td></tr>
<tr><td><code id="index_age_+3A_breadth">breadth</code></td>
<td>
<p>Numeric value for number of age groups around peak to be used in breadth_peak measure. Default of <code>5</code>.</p>
</td></tr>
<tr><td><code id="index_age_+3A_age_col">age_col</code></td>
<td>
<p>Character string of the age column name (when <code>d</code> is provided)</p>
</td></tr>
<tr><td><code id="index_age_+3A_mi_col">mi_col</code></td>
<td>
<p>Character string of the migration intensities column name (when <code>d</code> is provided)</p>
</td></tr>
<tr><td><code id="index_age_+3A_long">long</code></td>
<td>
<p>Logical to return a long data frame with index values all in one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with 8 summary measures where
</p>
<table>
<tr><td><code>gmr</code></td>
<td>
<p>Gross migraproduction rate of Rogers (1975)</p>
</td></tr>
<tr><td><code>peak_mi</code></td>
<td>
<p>Peak migration intensities, from Bell et. al. (2002)</p>
</td></tr>
<tr><td><code>peak_age</code></td>
<td>
<p>Corresponding age of <code>peak_mi</code>, from Bell et. al. (2002)</p>
</td></tr>
<tr><td><code>peak_breadth</code></td>
<td>
<p>Breadth of peak, from Bell and Muhidin (2009)</p>
</td></tr>
<tr><td><code>peak_share</code></td>
<td>
<p>Percentage share of peak breadth of all migration, from Bell and Muhidin (2009)</p>
</td></tr>
<tr><td><code>murc</code></td>
<td>
<p>Maximum upward rate of change of Bernard, Bell and Charles-Edwards (2014)</p>
</td></tr>
<tr><td><code>mdrc</code></td>
<td>
<p>Maximum downward rate of change of Bernard, Bell and Charles-Edwards (2014)</p>
</td></tr>
<tr><td><code>asymmetry</code></td>
<td>
<p>Asymmetry between the <code>murc</code> and <code>mudc</code>, from Bernard, Bell and Charles-Edwards (2014)</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Rogers, A. (1975). Introduction to Multiregional Mathematical Demography. Wiley.
</p>
<p>Bell, M., Blake, M., Boyle, P., Duke-Williams, O., Rees, P. H., Stillwell, J., &amp; Hugo, G. J. (2002). Cross-national comparison of internal migration: issues and measures. Journal of the Royal Statistical Society: Series A (Statistics in Society), 165(3), 435–464. https://doi.org/10.1111/1467-985X.00247
</p>
<p>Bell, M., &amp; Muhidin, S. (2009). Cross-National Comparisons of Internal Migration (Research Paper 2009/30; Human Development Reports).
</p>
<p>Bernard, A., Bell, M., &amp; Charles-Edwards, E. (2014). Improved measures for the cross-national comparison of age profiles of internal migration. Population Studies, 68(2), 179–195. https://doi.org/10.1080/00324728.2014.890243
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
ipumsi_age %&gt;%
  filter(sample == "BRA2000") %&gt;%
  mutate(mi = migrants/population) %&gt;%
  index_age()
  
ipumsi_age %&gt;%
  group_by(sample) %&gt;%
  mutate(mi = migrants/population) %&gt;%
  index_age(long = FALSE)
</code></pre>

<hr>
<h2 id='index_age_rc'>Summary indices of age migration profile based on parameters from a Rogers and Castro schedule</h2><span id='topic+index_age_rc'></span>

<h3>Description</h3>

<p>Summary indices of age migration profile based on parameters from a Rogers and Castro schedule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_age_rc(pars = NULL, long = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_age_rc_+3A_pars">pars</code></td>
<td>
<p>Named vector or parameters parameters from a Rogers and Castro schedule</p>
</td></tr>
<tr><td><code id="index_age_rc_+3A_long">long</code></td>
<td>
<p>Logical to return a long data frame with index values all in one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with at least five summary measures
</p>


<h3>Source</h3>

<p>Rogers, A., &amp; Castro, L. J. (1981). Model Migration Schedules. In IIASA Research Report (Vol. 81, Issue RR-81-30). http://webarchive.iiasa.ac.at/Admin/PUB/Documents/RR-81-030.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)
rc_model_fund %&gt;%
  deframe() %&gt;%
  index_age_rc()
</code></pre>

<hr>
<h2 id='index_connectivity'>Summary indices of migration connectivity</h2><span id='topic+index_connectivity'></span>

<h3>Description</h3>

<p>Summary indices of migration connectivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_connectivity(
  m = NULL,
  gini_orig_all = FALSE,
  gini_dest_all = FALSE,
  gini_corrected = TRUE,
  orig_col = "orig",
  dest_col = "dest",
  flow_col = "flow",
  long = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_connectivity_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination flows. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>flow_col</code>.</p>
</td></tr>
<tr><td><code id="index_connectivity_+3A_gini_orig_all">gini_orig_all</code></td>
<td>
<p>Logical to include gini index values for all origin regions. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="index_connectivity_+3A_gini_dest_all">gini_dest_all</code></td>
<td>
<p>Logical to include gini index values for all destination regions. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="index_connectivity_+3A_gini_corrected">gini_corrected</code></td>
<td>
<p>Logical to use corrected denominator in Gini index of Bell (2002) or original of David A. Plane and Mulligan (1997)</p>
</td></tr>
<tr><td><code id="index_connectivity_+3A_orig_col">orig_col</code></td>
<td>
<p>Character string of the origin column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_connectivity_+3A_dest_col">dest_col</code></td>
<td>
<p>Character string of the destination column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_connectivity_+3A_flow_col">flow_col</code></td>
<td>
<p>Character string of the flow column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_connectivity_+3A_long">long</code></td>
<td>
<p>Logical to return a long data frame with index values all in one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with 12 summary measures:
</p>
<table>
<tr><td><code>connectivity</code></td>
<td>
<p>Migration connectivity index of Bell et. al. (2002) for the share of non-zero flows. A value of 0 means no connections (all zero flows) and 1 shows that all regions are connected by migrants.</p>
</td></tr>
<tr><td><code>inequality_equal</code></td>
<td>
<p>Migration inequality index of Bell et. al. (2002) based on a distributions of flows compared to equal distributions of expected flows . A value of 0 shows complete equality in flows and 1 shows maximum inequality.</p>
</td></tr>
<tr><td><code>inequality_sim</code></td>
<td>
<p>Migration inequality index of Bell et. al. (2002) based on a distributions of flows compared to distributions of expected flows from a Poisson regression independence fit <code>flow ~ orig +  dest</code>. A value of 0 shows complete equality in flows and 1 shows maximum inequality.</p>
</td></tr>
<tr><td><code>gini_total</code></td>
<td>
<p>Overall concentration of migration from Bell (2002), corrected from Plane and Mulligan (1997). A value of 0 means no spatial focusing and 1 shows that all migrants are found in one single flow. Calculated using <code>migration.indices::migration.gini.total()</code></p>
</td></tr>
<tr><td><code>gini_orig_standardized</code></td>
<td>
<p>Relative extent to which the origin selections of out-migrations are spatially focused. A value of 0 means no spatial focusing and 1 shows maximum focusing. Adapted from <code>migration.indices::migration.gini.row.standardized()</code>.</p>
</td></tr>
<tr><td><code>gini_dest_standardized</code></td>
<td>
<p>Relative extent to which the destination selections of in-migrations are spatially focused. A value of 0 means no spatial focusing and 1 shows maximum focusing. Adapted from <code>migration.indices::migration.gini.col.standardized()</code>.</p>
</td></tr>
<tr><td><code>mwg_orig</code></td>
<td>
<p>Origin spatial focusing, from Bell et. al. (2002). Calculated using <code>migration.indices::migration.weighted.gini.out()</code></p>
</td></tr>
<tr><td><code>mwg_dest</code></td>
<td>
<p>Destination spatial focusing, from Bell et. al. (2002). Calculated using <code>migration.indices::migration.weighted.gini.in()</code></p>
</td></tr>
<tr><td><code>mwg_mean</code></td>
<td>
<p>Mean spatial focusing, from Bell et. al. (2002). Average of the origin and destination migration weighted Gini indices (<code>mwg_orig</code> and <code>mwg_dest</code>). A value of 0 means no spatial focusing and 1 shows that all migrants are found in one region. Calculated using <code>migration.indices::migration.weighted.gini.mean()</code></p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>Coefficient of variation from Rogers and Raymer (1998).</p>
</td></tr>
<tr><td><code>acv</code></td>
<td>
<p>Aggregated system-wide coefficient of variation from Rogers and Sweeney (1998), using <code>migration.indices::migration.acv()</code></p>
</td></tr>
</table>


<h3>Source</h3>

<p>Bell, M., Blake, M., Boyle, P., Duke-Williams, O., Rees, P. H., Stillwell, J., &amp; Hugo, G. J. (2002). Cross-national comparison of internal migration: issues and measures. Journal of the Royal Statistical Society: Series A (Statistics in Society), 165(3), 435–464. https://doi.org/10.1111/1467-985X.00247 <br />
</p>
<p>Rogers, A., &amp; Raymer, J. (1998). The Spatial Focus of US Interstate Migration Flows. International Journal of Population Geography, 4(1), 63–80. https://doi.org/10.1002/(SICI)1099-1220(199803)4%3A1&lt;63%3A%3AAID-IJPG87&gt;3.0.CO%3B2-U  <br />
</p>
<p>Rogers, A., &amp; Sweeney, S. (1998). Measuring the Spatial Focus of Migration Patterns. Professional Geographer, 50(2), 232–242.  <br />
</p>
<p>Plane, D., &amp; Mulligan, G. F. (1997). Measuring spatial focusing in a migration system. Demography, 34(2), 251–262. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
korea_gravity %&gt;%
  filter(year == 2020) %&gt;%
  select(orig, dest, flow) %&gt;%
  index_connectivity()
</code></pre>

<hr>
<h2 id='index_distance'>Summary indices of migration distance</h2><span id='topic+index_distance'></span>

<h3>Description</h3>

<p>Summary indices of migration distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_distance(
  m = NULL,
  d = NULL,
  orig_col = "orig",
  dest_col = "dest",
  flow_col = "flow",
  dist_col = "dist",
  long = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_distance_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination flows. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>flow_col</code>.</p>
</td></tr>
<tr><td><code id="index_distance_+3A_d">d</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination distances. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>dist_col</code>. Region names should match those in <code>m</code>.</p>
</td></tr>
<tr><td><code id="index_distance_+3A_orig_col">orig_col</code></td>
<td>
<p>Character string of the origin column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_distance_+3A_dest_col">dest_col</code></td>
<td>
<p>Character string of the destination column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_distance_+3A_flow_col">flow_col</code></td>
<td>
<p>Character string of the flow column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_distance_+3A_dist_col">dist_col</code></td>
<td>
<p>Character string of the distance column name (when <code>dist</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_distance_+3A_long">long</code></td>
<td>
<p>Logical to return a long data frame with index values all in one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with 3 summary measures where
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>Mean migration distance from Bell et. al. (2002) - not discussed in text but given in Table 6</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>Mean migration distance from Bell et. al. (2002)</p>
</td></tr>
<tr><td><code>decay</code></td>
<td>
<p>Distance decay parameter obtained from a Poisson regression model (<code>flow ~ orig + dest + log(dist)</code>)</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Bell, M., Blake, M., Boyle, P., Duke-Williams, O., Rees, P. H., Stillwell, J., &amp; Hugo, G. J. (2002). Cross-national comparison of internal migration: issues and measures. Journal of the Royal Statistical Society: Series A (Statistics in Society), 165(3), 435–464. https://doi.org/10.1111/1467-985X.00247
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single year
index_distance(
  m = subset(korea_gravity, year == 2020),
  d = subset(korea_gravity, year == 2020),
  dist_col = "dist_cent"
)

# multiple years
library(dplyr)
library(tidyr)
library(purrr)

korea_gravity %&gt;%
  select(year, orig, dest, flow, dist_cent) %&gt;%
  group_nest(year) %&gt;%
  mutate(i = map2(
    .x = data, .y = data, 
    .f = ~index_distance(m = .x, d = .y, dist_col = "dist_cent", long = FALSE)
  )) %&gt;%
  select(-data) %&gt;%
  unnest(i)
</code></pre>

<hr>
<h2 id='index_impact'>Summary indices of migration impact</h2><span id='topic+index_impact'></span>

<h3>Description</h3>

<p>Summary indices of migration impact
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_impact(
  m,
  p,
  pop_col = "pop",
  reg_col = "region",
  orig_col = "orig",
  dest_col = "dest",
  flow_col = "flow",
  long = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_impact_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination flows. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>flow_col</code>.</p>
</td></tr>
<tr><td><code id="index_impact_+3A_p">p</code></td>
<td>
<p>A data frame or named vector for the total population. When data frame, column of populations labelled using <code>pop_col</code> and region names labelled <code>reg_col</code>.</p>
</td></tr>
<tr><td><code id="index_impact_+3A_pop_col">pop_col</code></td>
<td>
<p>Character string of the population column name</p>
</td></tr>
<tr><td><code id="index_impact_+3A_reg_col">reg_col</code></td>
<td>
<p>Character string of the region column name. Must match dimension names or values in origin and destination columns of <code>m</code>.</p>
</td></tr>
<tr><td><code id="index_impact_+3A_orig_col">orig_col</code></td>
<td>
<p>Character string of the origin column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_impact_+3A_dest_col">dest_col</code></td>
<td>
<p>Character string of the destination column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_impact_+3A_flow_col">flow_col</code></td>
<td>
<p>Character string of the flow column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="index_impact_+3A_long">long</code></td>
<td>
<p>Logical to return a long data frame with index values all in one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with 4 summary measures where
</p>
<table>
<tr><td><code>effectivness</code></td>
<td>
<p>Migration effectiveness index (MEI) from Shryock et al. (1975). Values range between 0 and 100. High values indicate migration is an efficient mechanism of population redistribution, generating a large net migration. Conversely, low values denote that migration is closely balanced, leading to comparatively little redistribution.</p>
</td></tr>
<tr><td><code>anmr</code></td>
<td>
<p>Aggregate net migration rate from Bell et. al. (2002). The population weighted version of <code>mei</code>.</p>
</td></tr>
<tr><td><code>perference</code></td>
<td>
<p>Index of preference, given in UN DESA (1983). From Bachi (1957) and Shryock et al. (1975) - measures size of migration compared to expected flows based on unifrom migration. Can go from 0 to infinity</p>
</td></tr>
<tr><td><code>velocity</code></td>
<td>
<p>Index of velocity, given in UN DESA (1983). From Bogue, Shryock, Jr. &amp; Hoermann (1957) - measures size of migration compared to expected flows based on population size alone. Can go from 0 to infinity</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Bell, M., Blake, M., Boyle, P., Duke-Williams, O., Rees, P. H., Stillwell, J., &amp; Hugo, G. J. (2002). Cross-national comparison of internal migration: issues and measures. Journal of the Royal Statistical Society: Series A (Statistics in Society), 165(3), 435–464. https://doi.org/10.1111/1467-985X.00247 <br />
</p>
<p>Shryock, H. S., &amp; Siegel, J. S. (1976). The Methods and Materials of Demography. (E. G. Stockwell (ed.); Condensed). Academic Press. <br />
</p>
<p>United Nations Department of Economic and Social Affairs Population Division. (1970). Methods of measuring internal migration. United Nations Department of Economic and Social Affairs Population Division - 1970 - Methods of measuring internal migration <a href="https://www.un.org/development/desa/pd/sites/www.un.org.development.desa.pd/files/files/documents/2020/Jan/manual_vi_methods_of_measuring_internal_migration.pdf">https://www.un.org/development/desa/pd/sites/www.un.org.development.desa.pd/files/files/documents/2020/Jan/manual_vi_methods_of_measuring_internal_migration.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single year
library(dplyr)
m &lt;- korea_gravity %&gt;%
  filter(year == 2020,
         orig != dest) %&gt;%
  select(orig, dest, flow)
m
p &lt;- korea_gravity %&gt;%
  filter(year == 2020) %&gt;%
  distinct(dest, dest_pop)
p
index_impact(m = m, p = p, pop_col = "dest_pop", reg_col = "dest")

# multiple years
library(tidyr)
library(purrr) 

korea_gravity %&gt;%
  select(year, orig, dest, flow, dest_pop) %&gt;%
  group_nest(year) %&gt;%
  mutate(m = map(.x = data, .f = ~select(.x, orig, dest, flow)),
         p = map(.x = data, .f = ~distinct(.x, dest, dest_pop)),
         i = map2(.x = m, .y = p,
                  .f = ~index_impact(
                    m = .x, p = .y, pop_col = "dest_pop", reg_col = "dest", long = FALSE
                  ))) %&gt;%
  select(-data, -m, -p) %&gt;%
  unnest(i)
</code></pre>

<hr>
<h2 id='index_intensity'>Summary indices of migration intensity</h2><span id='topic+index_intensity'></span>

<h3>Description</h3>

<p>Summary indices of migration intensity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_intensity(mig_total = NULL, pop_total = NULL, n = NULL, long = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_intensity_+3A_mig_total">mig_total</code></td>
<td>
<p>Numeric value for the total number of migrations.</p>
</td></tr>
<tr><td><code id="index_intensity_+3A_pop_total">pop_total</code></td>
<td>
<p>Numeric value for the total population.</p>
</td></tr>
<tr><td><code id="index_intensity_+3A_n">n</code></td>
<td>
<p>Numeric value for the number of regions used in the definition of migration for <code>mig_total</code>.</p>
</td></tr>
<tr><td><code id="index_intensity_+3A_long">long</code></td>
<td>
<p>Logical to return a long data frame with index values all in one column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with 2 summary measures where
</p>
<table>
<tr><td><code>cmp</code></td>
<td>
<p>Crude migration probability from Bell et. al. (2002), sometimes known as crude migration intensity, e.g. Bernard (2017)</p>
</td></tr>
<tr><td><code>courgeau_k</code></td>
<td>
<p>Intensity measure of Courgeau (1973)</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Bell, M., Blake, M., Boyle, P., Duke-Williams, O., Rees, P. H., Stillwell, J., &amp; Hugo, G. J. (2002). Cross-national comparison of internal migration: issues and measures. Journal of the Royal Statistical Society: Series A (Statistics in Society), 165(3), 435–464. https://doi.org/10.1111/1467-985X.00247
</p>
<p>Courgeau, D. (1973). Migrants et migrations. Population, 28(1), 95–129. https://doi.org/10.2307/1530972
</p>
<p>Bernard, A., Rowe, F., Bell, M., Ueffing, P., Charles-Edwards, E., &amp; Zhu, Y. (2017). Comparing internal migration across the countries of Latin America: A multidimensional approach. Plos One, 12(3), e0173895. https://doi.org/10.1371/journal.pone.0173895
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single year
library(dplyr)
m &lt;- korea_gravity %&gt;%
  filter(year == 2020,
         orig != dest)
m
p &lt;- korea_gravity %&gt;%
  filter(year == 2020) %&gt;%
  distinct(dest, dest_pop)
p
index_intensity(mig_total = sum(m$flow), pop_total = sum(p$dest_pop*1e6), n = nrow(p))

# multiple years
library(tidyr)
library(purrr) 
mm &lt;- korea_gravity  %&gt;%
 filter(orig != dest) %&gt;%
  group_by(year) %&gt;%
  summarise(m = sum(flow))
mm

pp &lt;- korea_gravity %&gt;%
  group_by(year) %&gt;%
  distinct(dest, dest_pop) %&gt;%
  summarise(p = sum(dest_pop)*1e6,
            n = n_distinct(dest))
pp

library(purrr)
library(tidyr)
mm %&gt;%
  left_join(pp) %&gt;%
  mutate(i = pmap(
    .l = list(m, p, n),
    .f = ~index_intensity(mig_total = ..1, pop_total = ..2,n = ..3, long = FALSE)
  )) %&gt;%
  unnest(cols = i)
</code></pre>

<hr>
<h2 id='indian_sub'>Lifetime migration totals for states and zones in the Indian 1901 to 1931</h2><span id='topic+indian_sub'></span>

<h3>Description</h3>

<p>Lifetime migration (stock) totals from India
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indian_sub
</code></pre>


<h3>Format</h3>

<p>Data frame with 164 rows and 7 columns:
</p>

<dl>
<dt>zone</dt><dd><p>Zone of state. In some cases the state and zone are the same entity</p>
</dd>
<dt>state</dt><dd><p>Indian state</p>
</dd>
<dt>sex</dt><dd><p>Migrant sex</p>
</dd>
<dt>in_migrants</dt><dd><p>In-migrant total based on birthplace</p>
</dd>
<dt>out_migrants</dt><dd><p>Out-migrant total based on birthplace</p>
</dd>
<dt>net_migrants</dt><dd><p>Net migrant total based on birthplace</p>
</dd>
</dl>



<h3>Source</h3>

<p>Zachariah, K. C. (1964). A Historical Study of Internal Migration in the Indian Sub-Continent 1901-1931. (Vol. 19). Asia Publishing House.
</p>
<p>Scraped from <a href="https://archive.org/details/in.ernet.dli.2015.130424/page/n73/mode/2up">https://archive.org/details/in.ernet.dli.2015.130424/page/n73/mode/2up</a>
</p>

<hr>
<h2 id='ipf_seed'>Quickly create IPF seed</h2><span id='topic+ipf_seed'></span>

<h3>Description</h3>

<p>This function is predominantly intended to be used within the ipf routines in the migest package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipf_seed(m = NULL, R = NULL, n_dim = NULL, dn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipf_seed_+3A_m">m</code></td>
<td>
<p>Matrix, Array or NULL to build seed. If NULL seed will be 1 for all elements.</p>
</td></tr>
<tr><td><code id="ipf_seed_+3A_r">R</code></td>
<td>
<p>Number of rows, columns and possibly n_dimensions for seed matrix or array.</p>
</td></tr>
<tr><td><code id="ipf_seed_+3A_n_dim">n_dim</code></td>
<td>
<p>Numeric integer for the number of n_dimensions - 2 for matrix, 3 or more for an array</p>
</td></tr>
<tr><td><code id="ipf_seed_+3A_dn">dn</code></td>
<td>
<p>Vector of character strings for n_dimension names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>array</code> or <code>matrix</code>
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>

<hr>
<h2 id='ipf2'>Iterative proportional fitting routine for the indirect estimation of origin-destination migration flow table with known margins.</h2><span id='topic+ipf2'></span>

<h3>Description</h3>

<p>The <code>ipf2</code> function finds the maximum likelihood estimates for fitted values in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn">\log y_{ij} = \log \alpha_{i} + \log \beta_{j} + \log m_{ij} </code>
</p>

<p>where <code class="reqn">m_{ij}</code> is a set of prior estimates for <code class="reqn">y_{ij}</code> and itself is no more complex than the one being fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipf2(
  row_tot = NULL,
  col_tot = NULL,
  m = matrix(1, length(row_tot), length(col_tot)),
  tol = 1e-05,
  maxit = 500,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipf2_+3A_row_tot">row_tot</code></td>
<td>
<p>Vector of origin totals to constrain the sum of the imputed cell rows.</p>
</td></tr>
<tr><td><code id="ipf2_+3A_col_tot">col_tot</code></td>
<td>
<p>Vector of destination totals to constrain the sum of the imputed cell columns.</p>
</td></tr>
<tr><td><code id="ipf2_+3A_m">m</code></td>
<td>
<p>Matrix of auxiliary data. By default set to 1 for all origin-destination combinations.</p>
</td></tr>
<tr><td><code id="ipf2_+3A_tol">tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf2_+3A_maxit">maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf2_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Iterative Proportional Fitting routine set up in a similar manner to Agresti (2002, p.343). This is equivalent to a conditional maximization of the likelihood, as discussed by Willekens (1999), and hence provides identical indirect estimates to those obtained from the <code><a href="#topic+cm2">cm2</a></code> routine. 
</p>
<p>The user must ensure that the row and column totals are equal in sum. Care must also be taken to allow the dimension of the auxiliary matrix (<code>m</code>) to equal those provided in the row and column totals.
</p>
<p>If only one of the margins is known, the function can still be run. The indirect estimates will correspond to the log-linear model without the <code class="reqn">\alpha_{i}</code> term if (<code>row_tot = NULL</code>) or without the <code class="reqn">\beta_{j}</code> term if (<code>col_tot = NULL</code>)
</p>
<p>Returns a <code>list</code> object with
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Origin-Destination matrix of indirect estimates</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>Iteration count</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>Tolerance level at final iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Agresti, A. (2002). <em>Categorical Data Analysis</em> 2nd edition. Wiley. 
</p>
<p>Willekens, F. (1999). Modelling Approaches to the Indirect Estimation of Migration Flows: From Entropy to EM. <em>Mathematical Population Studies</em> 7 (3), 239&ndash;78.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cm2">cm2</a></code>, <code><a href="#topic+ipf3">ipf3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## with Willekens (1999) data
dn &lt;- LETTERS[1:2]
y &lt;- ipf2(row_tot = c(18, 20), col_tot = c(16, 22), 
          m = matrix(c(5, 1, 2, 7), ncol = 2, 
                     dimnames = list(orig = dn, dest = dn)))
round(addmargins(y$mu),2)

## with all elements of offset equal
y &lt;- ipf2(row_tot = c(18, 20), col_tot = c(16, 22))
round(addmargins(y$mu),2)

## with bigger matrix
dn &lt;- LETTERS[1:3]
y &lt;- ipf2(row_tot = c(170, 120, 410), col_tot = c(500, 140, 60), 
          m = matrix(c(50, 10, 220, 120, 120, 30, 545, 0, 10), ncol = 3, 
                     dimnames = list(orig = dn, dest = dn)))
# display with row and col totals
round(addmargins(y$mu))

## only one margin known
dn &lt;- LETTERS[1:2]
y &lt;- ipf2(row_tot = c(18, 20), col_tot = NULL, 
          m = matrix(c(5, 1, 2, 7), ncol = 2, 
                     dimnames = list(orig = dn, dest = dn)))
round(addmargins(y$mu))
</code></pre>

<hr>
<h2 id='ipf2_block'>Iterative proportional fitting routine for the indirect estimation of origin-destination-type migration flow tables with known origin and destination margins and block diagonal elements.</h2><span id='topic+ipf2_block'></span>

<h3>Description</h3>

<p>The <code>ipf2.b</code> function finds the maximum likelihood estimates for fitted values in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn"> \log y_{pq} = \log \alpha_{p} + \log \beta_{q} + \log \lambda_{ij}I(p \in i, q \in j) + \log m_{pq} </code>
</p>

<p>where <code class="reqn">m_{pq}</code> is a prior estimate for <code class="reqn">y_{pq}</code> and is no more complex than the matrices being fitted. The <code class="reqn">\lambda_{ij}I(p \in i, q \in j)</code> term ensures a saturated fit on the block the <code class="reqn">(i,j)</code> block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipf2_block(
  row_tot = NULL,
  col_tot = NULL,
  block_tot = NULL,
  block = NULL,
  m = NULL,
  tol = 1e-05,
  maxit = 500,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipf2_block_+3A_row_tot">row_tot</code></td>
<td>
<p>Vector of origin totals to constrain the sum of the imputed cell rows.</p>
</td></tr>
<tr><td><code id="ipf2_block_+3A_col_tot">col_tot</code></td>
<td>
<p>Vector of destination totals to constrain the sum of the imputed cell columns.</p>
</td></tr>
<tr><td><code id="ipf2_block_+3A_block_tot">block_tot</code></td>
<td>
<p>Matrix of block totals to constrain the sum of the imputed cell blocks.</p>
</td></tr>
<tr><td><code id="ipf2_block_+3A_block">block</code></td>
<td>
<p>Matrix of block structure corresponding to <code>block_tot</code>.</p>
</td></tr>
<tr><td><code id="ipf2_block_+3A_m">m</code></td>
<td>
<p>Matrix of auxiliary data. By default set to 1 for all origin-destination combinations.</p>
</td></tr>
<tr><td><code id="ipf2_block_+3A_tol">tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf2_block_+3A_maxit">maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf2_block_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ipf2_block_+3A_...">...</code></td>
<td>
<p>Additional arguments passes to <code><a href="#topic+block_matrix">block_matrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Iterative Proportional Fitting routine set up using the partial likelihood derivatives. The arguments <code>row_tot</code> and <code>col_tot</code> take the row-table and column-table specific known margins. The <code>block_tot</code> take the totals over the blocks in the matrix defined with <code>b</code>. Diagonal values can be added by the user, but care must be taken to ensure resulting diagonals are feasible given the set of margins. 
</p>
<p>The user must ensure that the row and column totals in each table sum to the same value. Care must also be taken to allow the dimension of the auxiliary matrix (<code>m</code>) equal those provided in the row and column totals.
</p>
<p>Returns a <code>list</code> object with
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Array of indirect estimates of origin-destination matrices by migrant characteristic</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>Iteration count</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>Tolerance level at final iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+block_matrix">block_matrix</a></code>, <code><a href="#topic+stripe_matrix">stripe_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- ipf2_block(row_tot= c(30,20,30,10,20,5,0,10,5,5,5,10),
                col_tot = c(45,10,10,5,5,10,50,5,10,0,0,0),
                block_tot = matrix(data = c(0,0 ,50,0, 35,0,25,0, 10,10,0,0, 10,10,0,0),
                              nrow = 4, byrow = TRUE),
                block = block_matrix(x = 1:16, b = c(2,3,4,3)))
addmargins(y$mu)
</code></pre>

<hr>
<h2 id='ipf2_stripe'>iterative proportional fitting routine for the indirect estimation of origin-destination-type migration flow tables with known origin and destination margins and stripe elements.</h2><span id='topic+ipf2_stripe'></span>

<h3>Description</h3>

<p>The <code>ipf2.b</code> function finds the maximum likelihood estimates for fitted values in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn"> \log y_{pq} = \log \alpha_{p} + \log \beta_{q} + \log \lambda_{ij}I(p \in i, q \in j) + \log m_{pq} </code>
</p>

<p>where <code class="reqn">m_{pq}</code> is a prior estimate for <code class="reqn">y_{pq}</code> and is no more complex than the matrices being fitted. The <code class="reqn">\lambda_{ij}I(p \in i, q \in j)</code> term ensures a saturated fit on the block the <code class="reqn">(i,j)</code> block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipf2_stripe(
  row_tot = NULL,
  col_tot = NULL,
  stripe_tot = NULL,
  stripe = NULL,
  m = NULL,
  tol = 1e-05,
  maxit = 500,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipf2_stripe_+3A_row_tot">row_tot</code></td>
<td>
<p>Vector of origin totals to constrain the sum of the imputed cell rows.</p>
</td></tr>
<tr><td><code id="ipf2_stripe_+3A_col_tot">col_tot</code></td>
<td>
<p>Vector of destination totals to constrain the sum of the imputed cell columns.</p>
</td></tr>
<tr><td><code id="ipf2_stripe_+3A_stripe_tot">stripe_tot</code></td>
<td>
<p>Matrix of stripe totals to constrain the sum of the imputed cell blocks.</p>
</td></tr>
<tr><td><code id="ipf2_stripe_+3A_stripe">stripe</code></td>
<td>
<p>Matrix of stripe structure corresponding to <code>stripe_tot</code>.</p>
</td></tr>
<tr><td><code id="ipf2_stripe_+3A_m">m</code></td>
<td>
<p>Matrix of auxiliary data. By default set to 1 for all origin-destination combinations.</p>
</td></tr>
<tr><td><code id="ipf2_stripe_+3A_tol">tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf2_stripe_+3A_maxit">maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf2_stripe_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ipf2_stripe_+3A_...">...</code></td>
<td>
<p>Additional arguments passes to <code><a href="#topic+stripe_matrix">stripe_matrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Iterative Proportional Fitting routine set up using the partial likelihood derivatives. The arguments <code>row_tot</code> and <code>col_tot</code> take the row-table and column-table specific known margins. The <code>stripe_tot</code> take the totals over the stripes in the matrix defined with <code>b</code>. Diagonal values can be added by the user, but care must be taken to ensure resulting diagonals are feasible given the set of margins. 
The user must ensure that the row and column totals in each table sum to the same value. Care must also be taken to allow the dimension of the auxiliary matrix (<code>m</code>) equal those provided in the row and column totals.
Returns a <code>list</code> object with
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Array of indirect estimates of origin-destination matrices by migrant characteristic</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>Iteration count</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>Tolerance level at final iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stripe_matrix">stripe_matrix</a></code>, <code><a href="#topic+block_matrix">block_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- ipf2_stripe(row_tot = c(85, 70, 35, 30, 60, 55, 65),
 stripe_tot = matrix(c(15,20,50,
                35,10,25,
                5 ,0 ,30,
                10,10,10,
                30,30,0,
                15,30,10,
                35,25,5 ), ncol = 3, byrow = TRUE),
 stripe = stripe_matrix(x = 1:21, s = c(2,2,3), byrow = TRUE))
 addmargins(y$mu)
</code></pre>

<hr>
<h2 id='ipf3'>Iterative proportional fitting routine for the indirect estimation of origin-destination-migrant type migration flow tables with known origin and destination margins.</h2><span id='topic+ipf3'></span>

<h3>Description</h3>

<p>The <code>ipf3</code> function finds the maximum likelihood estimates for fitted values in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn"> \log y_{ijk} = \log \alpha_{i} + \log \beta_{j} + \log \lambda_{k} + \log \gamma_{ik} + \log \kappa_{jk} + \log m_{ijk} </code>
</p>

<p>where <code class="reqn">m_{ijk}</code> is a set of prior estimates for <code class="reqn">y_{ijk}</code> and is no more complex than the matrices being fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipf3(
  row_tot = NULL,
  col_tot = NULL,
  m = NULL,
  tol = 1e-05,
  maxit = 500,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipf3_+3A_row_tot">row_tot</code></td>
<td>
<p>Vector of origin totals to constrain the sum of the imputed cell rows.</p>
</td></tr>
<tr><td><code id="ipf3_+3A_col_tot">col_tot</code></td>
<td>
<p>Vector of destination totals to constrain the sum of the imputed cell columns.</p>
</td></tr>
<tr><td><code id="ipf3_+3A_m">m</code></td>
<td>
<p>Array of auxiliary data. By default set to 1 for all origin-destination-migrant typologies combinations.</p>
</td></tr>
<tr><td><code id="ipf3_+3A_tol">tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf3_+3A_maxit">maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf3_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Iterative Proportional Fitting routine set up in a similar manner to Agresti (2002, p.343). The arguments <code>row_tot</code> and <code>col_tot</code> take the row-table and column-table specific known margins.
</p>
<p>The user must ensure that the row and column totals in each table sum to the same value. Care must also be taken to allow the dimension of the auxiliary matrix (<code>m</code>) to equal those provided in the row and column totals.
</p>
<p>Returns a <code>list</code> object with
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Array of indirect estimates of origin-destination matrices by migrant characteristic</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>Iteration count</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>Tolerance level at final iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Abel and Cohen (2019) Bilateral international migration flow estimates for 200 countries <em>Scientific Data</em> 6 (1), 1-13
</p>
<p>Azose &amp; Raftery (2019) Estimation of emigration, return migration, and transit migration between all pairs of countries <em>Proceedings of the National Academy of Sciences</em> 116 (1) 116-122
</p>
<p>Abel, G. J. (2013). Estimating Global Migration Flow Tables Using Place of Birth. <em>Demographic Research</em> 28, (18) 505-546
</p>
<p>Agresti, A. (2002). <em>Categorical Data Analysis</em> 2nd edition. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ipf3_qi">ipf3_qi</a></code>, <code><a href="#topic+ipf2">ipf2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create row-table and column-table specific known margins.
dn &lt;- LETTERS[1:4]
P1 &lt;- matrix(c(1000, 100,  10,   0, 
               55,   555,  50,   5, 
               80,    40, 800 , 40, 
               20,    25,  20, 200), 
             nrow = 4, ncol = 4, byrow = TRUE, 
             dimnames = list(pob = dn, por = dn))
P2 &lt;- matrix(c(950, 100,  60,   0, 
                80, 505,  75,   5, 
                90,  30, 800,  40, 
                40,  45,   0, 180), 
             nrow = 4, ncol = 4, byrow = TRUE, 
             dimnames = list(pob = dn, por = dn))
# display with row and col totals
addmargins(P1)
addmargins(P2)

# run ipf
y &lt;- ipf3(row_tot = t(P1), col_tot = P2)
# display with row, col and table totals
round(addmargins(y$mu), 1)
# origin-destination flow table
round(sum_od(y$mu), 1)

## with alternative offset term
dis &lt;- array(c(1, 2, 3, 4, 2, 1, 5, 6, 3, 4, 1, 7, 4, 6, 7, 1), c(4, 4, 4))
y &lt;- ipf3(row_tot = t(P1), col_tot = P2, m = dis)
# display with row, col and table totals
round(addmargins(y$mu), 1)
# origin-destination flow table
round(sum_od(y$mu), 1)
</code></pre>

<hr>
<h2 id='ipf3_qi'>Iterative proportional fitting routine for the indirect estimation of origin-destination-migrant type migration flow tables with known origin and destination margins and diagonal elements.</h2><span id='topic+ipf3_qi'></span>

<h3>Description</h3>

<p>This function is predominantly intended to be used within the <code><a href="#topic+ffs">ffs</a></code> routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipf3_qi(
  row_tot = NULL,
  col_tot = NULL,
  diag_count = NULL,
  m = NULL,
  speed = TRUE,
  tol = 1e-05,
  maxit = 500,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipf3_qi_+3A_row_tot">row_tot</code></td>
<td>
<p>Vector of origin totals to constrain the sum of the imputed cell rows.</p>
</td></tr>
<tr><td><code id="ipf3_qi_+3A_col_tot">col_tot</code></td>
<td>
<p>Vector of destination totals to constrain the sum of the imputed cell columns.</p>
</td></tr>
<tr><td><code id="ipf3_qi_+3A_diag_count">diag_count</code></td>
<td>
<p>Array with counts on diagonal to constrain diagonal elements of the indirect estimates too. By default these are taken as their maximum possible values given the relevant margins totals in each table. If user specifies their own array of diagonal totals, values on the non-diagonals in the array can take any positive number (they are ultimately ignored).</p>
</td></tr>
<tr><td><code id="ipf3_qi_+3A_m">m</code></td>
<td>
<p>Array of auxiliary data. By default set to 1 for all origin-destination-migrant typologies combinations.</p>
</td></tr>
<tr><td><code id="ipf3_qi_+3A_speed">speed</code></td>
<td>
<p>Speeds up the IPF algorithm by minimizing sufficient statistics.</p>
</td></tr>
<tr><td><code id="ipf3_qi_+3A_tol">tol</code></td>
<td>
<p>Numeric value for the tolerance level used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf3_qi_+3A_maxit">maxit</code></td>
<td>
<p>Numeric value for the maximum number of iterations used in the parameter estimation.</p>
</td></tr>
<tr><td><code id="ipf3_qi_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ipf3</code> function finds the maximum likelihood estimates for fitted values in the log-linear model:
</p>
<p style="text-align: center;"><code class="reqn"> \log y_{ijk} = \log \alpha_{i} + \log \beta_{j} + \log \lambda_{k} + \log \gamma_{ik} + \log \kappa_{jk} + \log \delta_{ijk}I(i=j) + \log m_{ijk} </code>
</p>

<p>where <code class="reqn">m_{ijk}</code> is a set of prior estimates for <code class="reqn">y_{ijk}</code> and is no more complex than the matrices being fitted. The <code class="reqn">\delta_{ijk}I(i=j)</code> term ensures a saturated fit on the diagonal elements of each <code class="reqn">(i,j)</code> matrix.
</p>


<h3>Value</h3>

<p>Iterative Proportional Fitting routine set up using the partial likelihood derivatives illustrated in Abel (2013). The arguments <code>row_tot</code> and <code>col_tot</code> take the row-table and column-table specific known margins. By default the diagonal values are taken as their maximum possible values given the relevant margins totals in each table. Diagonal values can be added by the user, but care must be taken to ensure resulting diagonals are feasible given the set of margins. 
</p>
<p>The user must ensure that the row and column totals in each table sum to the same value. Care must also be taken to allow the dimension of the auxiliary matrix (<code>m</code>) equal those provided in the row and column totals.
</p>
<p>Returns a <code>list</code> object with
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>Array of indirect estimates of origin-destination matrices by migrant characteristic</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>Iteration count</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>Tolerance level at final iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Abel, G. J. (2013). Estimating Global Migration Flow Tables Using Place of Birth. <em>Demographic Research</em> 28, (18) 505-546
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ipf3">ipf3</a></code>, <code><a href="#topic+ffs_demo">ffs_demo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create row-table and column-table specific known margins.
dn &lt;- LETTERS[1:4]
P1 &lt;- matrix(c(1000, 100,  10,   0, 
               55,   555,  50,   5, 
               80,    40, 800 , 40, 
               20,    25,  20, 200), 
             nrow = 4, ncol = 4, byrow = TRUE, 
             dimnames = list(pob = dn, por = dn))
P2 &lt;- matrix(c(950, 100,  60,   0, 
                80, 505,  75,   5, 
                90,  30, 800,  40, 
                40,  45,   0, 180), 
             nrow = 4, ncol = 4, byrow = TRUE, 
             dimnames = list(pob = dn, por = dn))
# display with row and col totals
addmargins(P1)
addmargins(P2)

# # run ipf
# y &lt;- ipf3_qi(row_tot = t(P1), col_tot = P2)
# # display with row, col and table totals
# round(addmargins(y$mu), 1)
# # origin-destination flow table
# round(sum_od(y$mu), 1)

## with alternative offset term
# dis &lt;- array(c(1, 2, 3, 4, 2, 1, 5, 6, 3, 4, 1, 7, 4, 6, 7, 1), c(4, 4, 4))
# y &lt;- ipf3_qi(row_tot = t(P1), col_tot = P2, m = dis)
# # display with row, col and table totals
# round(addmargins(y$mu), 1)
# # origin-destination flow table
# round(sum_od(y$mu), 1)
 
</code></pre>

<hr>
<h2 id='ipumsi_age'>Age specific migration and population counts from two IPUMSI samples</h2><span id='topic+ipumsi_age'></span>

<h3>Description</h3>

<p>Age specific migration and population counts for Brazil 2000 and France 2006 IPUMS International samples. 
Attempt to recreate the unsmoothed data used in the appendix of Bernard, Bell and Charles-Edwards (2014)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipumsi_age
</code></pre>


<h3>Format</h3>

<p>Data frame with 202 rows and 4 columns:
</p>

<dl>
<dt>sample</dt><dd><p>IPUMS International sample - either BRA2000 or FRA2006</p>
</dd>
<dt>age</dt><dd><p>Age on census data</p>
</dd>
<dt>migrants</dt><dd><p>Number of migrants, defined by those who had changed usual place of residence to a different minor administrative region compared to usual place of residence five years prior to the census. Obtained by summing person weights for 'migrate5' variable equal to any of code 12, 20 or 30.</p>
</dd>
<dt>population</dt><dd><p>Population of each age group, obtained by summing person weights 'perwt' variable. </p>
</dd>
</dl>



<h3>Source</h3>

<p>Minnesota Population Center. (2015). Integrated Public Use Microdata Series, International: Version 6.4 [Machine-readable database]. <a href="https://international.ipums.org/international/">https://international.ipums.org/international/</a>
</p>
<p>Bernard, A., Bell, M., &amp; Charles-Edwards, E. (2014). Improved measures for the cross-national comparison of age profiles of internal migration. Population Studies, 68(2), 179–195.
</p>

<hr>
<h2 id='italy_area'>Single year age-specific origin destination migration flows between Italian NUTS1 areas</h2><span id='topic+italy_area'></span>

<h3>Description</h3>

<p>Origin-destination migration flows from 7 years between 1970 and 2000 by five-year age groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>italy_area
</code></pre>


<h3>Format</h3>

<p>Data frame with 3500 rows and 5 columns:
</p>

<dl>
<dt>orig</dt><dd><p>Origin area (NUTS1 region)</p>
</dd>
<dt>dest</dt><dd><p>Destination area (NUTS1 region)</p>
</dd>
<dt>year</dt><dd><p>Year of flow</p>
</dd>
<dt>age_grp</dt><dd><p>Five-year age group</p>
</dd>
<dt>flow</dt><dd><p>Migration flow</p>
</dd>
</dl>



<h3>Source</h3>

<p>Provided by James Raymer. Originally from ISTAT. 2003. Rapporto annuale: La situazione nel Paese nel 2003. ISTAT, Rome. 
</p>
<p>Data used in Raymer, J., Bonaguidi, A., &amp; Valentini, A. (2006). Describing and projecting the age and spatial structures of interregional migration in Italy. Population, Space and Place, 12(5), 371–388.
</p>

<hr>
<h2 id='korea_gravity'>Annual origin destination migration flows between Korean regions alongside selected geographic, economic and demographic variables.</h2><span id='topic+korea_gravity'></span>

<h3>Description</h3>

<p>Origin-destination migration flows between 2012 and 2020 based on first level administrative regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>korea_gravity
</code></pre>


<h3>Format</h3>

<p>Data frame with 2,601 rows and 20 columns:
</p>

<dl>
<dt>orig</dt><dd><p>Origin region</p>
</dd>
<dt>dest</dt><dd><p>Destination region</p>
</dd>
<dt>year</dt><dd><p>Year of flow</p>
</dd>
<dt>flow</dt><dd><p>Migration flow. Data obtained from KOSIS</p>
</dd>
<dt>dist_cent</dt><dd><p>Distance (in km) between geographic centroids, calculated from <code>geosphere::distm()</code></p>
</dd>
<dt>dist_min</dt><dd><p>Minimum distance (in km) between regions, calculated from <code>sf::st_distance()</code></p>
</dd>
<dt>dist_pw</dt><dd><p>Distance (in km) between population weighted centroids, calculated from <code>geosphere::distm()</code> using WorldPop estimates of 2020 regional population centroids</p>
</dd>
<dt>contig</dt><dd><p>Indicate if regions share a border</p>
</dd>
<dt>orig_pop</dt><dd><p>Population (in millions) of origin region. Data obtained from KOSIS.</p>
</dd>
<dt>dest_pop</dt><dd><p>Population (in millions) of destination region. Data obtained from KOSIS.</p>
</dd>
<dt>orig_area</dt><dd><p>Geographic area (in km^2) of origin region, calculated from <code>sf::st_area()</code></p>
</dd>
<dt>dest_area</dt><dd><p>Geographic area (in km^2) of destination region, calculated from <code>sf::st_area()</code></p>
</dd>
<dt>orig_gdp_pc</dt><dd><p>GDP per capita of origin region. Data obtained from KOSIS.</p>
</dd>
<dt>orig_ginc_pc</dt><dd><p>Gross regional income per capita of origin region. Data obtained from KOSIS.</p>
</dd>
<dt>orig_iinc_pc</dt><dd><p>Individual income per capita of origin region. Data obtained from KOSIS.</p>
</dd>
<dt>orig_pconsum_pc</dt><dd><p>Personal consumption per capita of origin region. Data obtained from KOSIS.</p>
</dd>
<dt>dest_gdp_pc</dt><dd><p>GDP per capita of destination region. Data obtained from KOSIS.</p>
</dd>
<dt>dest_ginc_pc</dt><dd><p>Gross regional income per capita of destination region. Data obtained from KOSIS.</p>
</dd>
<dt>dest_iinc_pc</dt><dd><p>Individual income per capita of destination region. Data obtained from KOSIS.</p>
</dd>
<dt>dest_pconsum_pc</dt><dd><p>Personal consumption per capita of destination region. Data obtained from KOSIS.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Statistics Korea, Internal Migration Statistics. Data downloaded from <a href="https://kosis.kr/eng">https://kosis.kr/eng</a> in July 2021.
</p>
<p>Robin Edwards, Maksym Bondarenko, Andrew J. Tatem and Alessandro Sorichetta. Unconstrained subnational Population Weighted Density in 2000, 2005, 2010, 2015 and 2020 ( 100m resolution ). WorldPop, University of Southampton, UK.
</p>
<p>Source: Statistics Korea, Population Statistics Based on Resident Registration. Data downloaded from <a href="https://kosis.kr/eng">https://kosis.kr/eng</a> in July 2021.
</p>
<p>Source: Statistics Korea, Regional GDP, Gross regional income and Individual income. Data downloaded from <a href="https://kosis.kr/eng">https://kosis.kr/eng</a> in November 2023.
</p>

<hr>
<h2 id='manila_1970'>Manila female population 1970 by age</h2><span id='topic+manila_1970'></span>

<h3>Description</h3>

<p>Population data for Manila by age in 1960 and 1970
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manila_1970
</code></pre>


<h3>Format</h3>

<p>Data frame with 13 rows and 5 columns:
</p>

<dl>
<dt>age_1970</dt><dd><p>Age group in 1970</p>
</dd>
<dt>pop_1960</dt><dd><p>Enumerated population in 1960</p>
</dd>
<dt>pop_1970</dt><dd><p>Enumerated population in 1970</p>
</dd>
<dt>phl_census_sr</dt><dd><p>Census survival ratio derived from the national data.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Scraped from Table 6 of United Nations Department of Economic and Social Affairs Population Division. (1992). Preparing Migration Data for Subnational Population Projections.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># match table 6 - perhaps small error in children net migration numbers in the published table?
net_sr(manila_1970, pop0_col = "pop_1960", pop1_col = "pop_1970", 
       survival_ratio_col = "phl_census_sr", net_children = TRUE)
</code></pre>

<hr>
<h2 id='match_birthplace_tot'>Adjust migrant stock tables to have matching place of birth (origin) totals</h2><span id='topic+match_birthplace_tot'></span>

<h3>Description</h3>

<p>This function is predominantly intended to be used within the ffs routines in the migest package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_birthplace_tot(m1, m2, method = "rescale", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_birthplace_tot_+3A_m1">m1</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="match_birthplace_tot_+3A_m2">m2</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>+1. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="match_birthplace_tot_+3A_method">method</code></td>
<td>
<p>Character string matching either <code>rescale</code>, <code>rescale-adjust-zero-fb</code>, <code>open</code> or <code>open-dr</code>. See details.</p>
</td></tr>
<tr><td><code id="match_birthplace_tot_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration of the rescale, as used in <code>ipf2</code>. By default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rescale</code> and <code>rescale-adjust-zero-fb</code> method ensure flow estimates closely match the net migration totals implied by the changes in population totals, births and deaths - as introduced in the Science paper. The <code>rescale-adjust-zero-fb</code> can adjust for rare cases when row total margins that are smaller than native born totals in countries where there are no foreign born populations (e.g. South Sudan 1990-1995).
The <code>open-dr</code> method allows for moves in and out of the global system - as introduced in the Demographic Research paper. The <code>open</code> method is a slight improvement over <code>open-dr</code> - the calculation of the moves and in and out using more sensible weights.
</p>


<h3>Value</h3>

<p>Returns a <code>list</code> object with:
</p>
<table>
<tr><td><code>m1_adj</code></td>
<td>
<p>Matrix of adjusted <code>m1</code> where rows (place of births) match <code>m2_adj</code>.</p>
</td></tr>
<tr><td><code>m2_adj</code></td>
<td>
<p>Matrix of adjusted <code>m2</code> where rows (place of births) match <code>m1_adj</code>.</p>
</td></tr>
<tr><td><code>in_mat</code></td>
<td>
<p>Matrix of estimated inflows into the system.</p>
</td></tr>
<tr><td><code>out_mat</code></td>
<td>
<p>Matrix of estimated outflows from the system.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Abel and Cohen (2019) Bilateral international migration flow estimates for 200 countries <em>Scientific Data</em> 6 (1), 1-13
</p>
<p>Azose &amp; Raftery (2019) Estimation of emigration, return migration, and transit migration between all pairs of countries <em>Proceedings of the National Academy of Sciences</em> 116 (1) 116-122
</p>
<p>Abel, G. J. (2018). Estimates of Global Bilateral Migration Flows by Gender between 1960 and 2015. <em>International Migration Review</em> 52 (3), 809–852.
</p>
<p>Abel, G. J. and Sander, N. (2014). Quantifying Global International Migration Flows. <em>Science</em>, 343 (6178) 1520-1522
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffs_demo">ffs_demo</a></code>
</p>

<hr>
<h2 id='mig_chord'>Chord diagram for directional origin-destination data</h2><span id='topic+mig_chord'></span>

<h3>Description</h3>

<p>Adaption of <code>circlize::chordDiagramFromDataFrame()</code> with defaults set to allow for more effective visualisation of directional origin-destination data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_chord(
  x,
  lab = NULL,
  lab_bend1 = NULL,
  lab_bend2 = NULL,
  label_size = 1,
  label_nudge = 0,
  label_squeeze = 0,
  axis_size = 0.8,
  axis_breaks = NULL,
  ...,
  no_labels = FALSE,
  no_axis = FALSE,
  clear_circos_par = TRUE,
  zero_margin = TRUE,
  start.degree = 90,
  gap.degree = 4,
  track.margin = c(-0.1, 0.1),
  points.overflow.warning = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mig_chord_+3A_x">x</code></td>
<td>
<p>Data frame with origin in first column, destination in second column and bilateral measure in third column</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_lab">lab</code></td>
<td>
<p>Named vector of labels for plot. If <code>NULL</code> will use names from <code>d</code></p>
</td></tr>
<tr><td><code id="mig_chord_+3A_lab_bend1">lab_bend1</code></td>
<td>
<p>Named vector of bending labels for plot. Note line breaks do not work with <code>facing = "bending"</code> in circlize.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_lab_bend2">lab_bend2</code></td>
<td>
<p>Named vector of second row of bending labels for plot.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_label_size">label_size</code></td>
<td>
<p>Font size of label text.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_label_nudge">label_nudge</code></td>
<td>
<p>Numeric value to nudge labels towards (negative number) or away (positive number) the sector axis.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_label_squeeze">label_squeeze</code></td>
<td>
<p>Numeric value to nudge <code>lab_bend1</code> and <code>lab_bend2</code> labels apart (negative number) or together (positive number).</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_axis_size">axis_size</code></td>
<td>
<p>Font size on axis labels.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_axis_breaks">axis_breaks</code></td>
<td>
<p>Numeric value for how often to add axis label breaks. Default not activated, uses default from <code>circlize::circos.axis()</code></p>
</td></tr>
<tr><td><code id="mig_chord_+3A_...">...</code></td>
<td>
<p>Arguments for <code>circlize::chordDiagramFromDataFrame()</code>.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_no_labels">no_labels</code></td>
<td>
<p>Logical to indicate if to include plot labels. Set to <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_no_axis">no_axis</code></td>
<td>
<p>Logical to indicate if to include plot axis. Set to <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_clear_circos_par">clear_circos_par</code></td>
<td>
<p>Logical to run <code>circlize::circos.clear()</code>. Set to <code>TRUE</code> by default. Set to <code>FALSE</code> if you wish to add further to the plot.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_zero_margin">zero_margin</code></td>
<td>
<p>Set margins of the plotting graphics device to zero. Set to <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_start.degree">start.degree</code></td>
<td>
<p>Argument for <code>circlize::circos.par()</code>.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_gap.degree">gap.degree</code></td>
<td>
<p>Argument for <code>circlize::chordDiagramFromDataFrame()</code>.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_track.margin">track.margin</code></td>
<td>
<p>Argument for <code>circlize::chordDiagramFromDataFrame()</code>.</p>
</td></tr>
<tr><td><code id="mig_chord_+3A_points.overflow.warning">points.overflow.warning</code></td>
<td>
<p>Argument for <code>circlize::chordDiagramFromDataFrame()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Chord diagram based on first three columns of <code>x</code>. The function tweaks the defaults of <code>circlize::chordDiagramFromDataFrame()</code> for easier plotting of directional origin-destination data. Users can override these defaults and pass additional tweaks using any of the <code>circlize::chordDiagramFromDataFrame()</code> arguments.
</p>
<p>The layout of the plots are designed to specifically work on plotting images into PDF devices with widths and heights of 7 inches (the default dimension when using the <code>pdf</code> function). See the end of the examples for converting PDF to PNG images in R. 
</p>
<p>Fitting the sector labels on the page is usually the most time consuming task. Use the different label options, including line breaks, <code>label_nudge</code>, track height in <code>preAllocateTracks</code> and font sizes in <code>label_size</code> and <code>axis_size</code> to find the best fit. If none of the label options produce desirable results, plot your own using <code>circlize::circos.text</code> having set <code>no_labels = TRUE</code> and <code>clear_circos_par = FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidyverse)
library(countrycode)
# download Abel and Cohen (2019) estimates
f &lt;- read_csv("https://ndownloader.figshare.com/files/38016762", show_col_types = FALSE)
f

# use dictionary to get region to region flows
d &lt;- f %&gt;%
  mutate(
    orig = countrycode(sourcevar = orig, custom_dict = dict_ims,
                       origin = "iso3c", destination = "region"),
    dest = countrycode(sourcevar = dest, custom_dict = dict_ims,
                       origin = "iso3c", destination = "region")
  ) %&gt;%
  group_by(year0, orig, dest) %&gt;%
  summarise_all(sum) %&gt;%
  ungroup()
d

# 2015-2020 pseudo-Bayesian estimates for plotting
pb &lt;- d %&gt;%
    filter(year0 == 2015) %&gt;%
    mutate(flow = da_pb_closed/1e6) %&gt;%
    select(orig, dest, flow)
pb
    
# pdf(file = "chord.pdf")
mig_chord(x = pb)
# dev.off()
# file.show("chord.pdf")

# pass arguments to circlize::chordDiagramFromDataFrame
# pdf(file = "chord.pdf")
mig_chord(x = pb,
          # order of regions
          order = unique(pb$orig)[c(1, 3, 2, 6, 4, 5)],
          # spacing for labels
          preAllocateTracks = list(track.height = 0.3),
          # colours
          grid.col = c("blue", "royalblue", "navyblue", "skyblue", "cadetblue", "darkblue")
          )
# dev.off()
# file.show("chord.pdf")

# multiple line labels to fit on longer labels
r &lt;- pb %&gt;%
  sum_region() %&gt;%
  mutate(lab = str_wrap_n(string = region, n = 2)) %&gt;%
  separate(col = lab, into = c("lab1", "lab2"), sep = "\n", remove = FALSE, fill = "right")
r

# pdf(file = "chord.pdf")
mig_chord(x = pb,
          lab = r %&gt;%
            select(region, lab) %&gt;%
            deframe(),
          preAllocateTracks = list(track.height = 0.25),
          label_size = 0.8,
          axis_size = 0.7
          )
# dev.off()
# file.show("chord.pdf")

# bending labels
# pdf(file = "chord.pdf")
mig_chord(x = pb,
          lab_bend1 = r %&gt;%
            select(region, lab1) %&gt;%
            deframe(),
          lab_bend2 = r %&gt;%
            select(region, lab2) %&gt;%
            deframe()
          )
# dev.off()
# file.show("chord.pdf")


# convert pdf to image file
# library(magick)
# p &lt;- image_read_pdf("chord.pdf")
# image_write(image = p, path = "chord.png")
# file.show("chord.png")

## End(Not run)
</code></pre>

<hr>
<h2 id='mig_matrix'>Helper function to format migration input</h2><span id='topic+mig_matrix'></span>

<h3>Description</h3>

<p>Helper function to format migration input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_matrix(
  m,
  array = TRUE,
  orig_col = "orig",
  dest_col = "dest",
  flow_col = "flow"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mig_matrix_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination flows. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>flow_col</code>.</p>
</td></tr>
<tr><td><code id="mig_matrix_+3A_array">array</code></td>
<td>
<p>Logical on return of array of all dimensions or origin-destination matrix (summed over all other dimensions)</p>
</td></tr>
<tr><td><code id="mig_matrix_+3A_orig_col">orig_col</code></td>
<td>
<p>Character string of the origin column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="mig_matrix_+3A_dest_col">dest_col</code></td>
<td>
<p>Character string of the destination column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="mig_matrix_+3A_flow_col">flow_col</code></td>
<td>
<p>Character string of the flow column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted matrix
</p>

<hr>
<h2 id='mig_tibble'>Helper function to format migration input</h2><span id='topic+mig_tibble'></span>

<h3>Description</h3>

<p>Helper function to format migration input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mig_tibble(m, orig_col = "orig", dest_col = "dest", flow_col = "flow")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mig_tibble_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination flows. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>flow_col</code>.</p>
</td></tr>
<tr><td><code id="mig_tibble_+3A_orig_col">orig_col</code></td>
<td>
<p>Character string of the origin column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="mig_tibble_+3A_dest_col">dest_col</code></td>
<td>
<p>Character string of the destination column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="mig_tibble_+3A_flow_col">flow_col</code></td>
<td>
<p>Character string of the flow column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted tibble
</p>

<hr>
<h2 id='migest-package'>
Methods for the Indirect Estimation of Bilateral Migration
</h2><span id='topic+migest-package'></span><span id='topic+migest'></span>

<h3>Description</h3>

<p>The migest package contains a collection of R functions for indirect methods to estimate bilateral migration flows in the presence of partial or missing data. Methods might be relevant to other categorical data situations on non-migration data, where for example, marginal totals are known and only auxiliary bilateral data is available.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> migest</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The estimation methods in this package can be grouped as 1) functions for origin-destination matrices (<code><a href="#topic+cm2">cm2</a></code> and <code><a href="#topic+ipf2">ipf2</a></code>) and 2) functions for origin-destination matrices categorized by a further set of characteristics, such as ethnicity, employment or health status (<code><a href="#topic+cm3">cm3</a></code>, <code><a href="#topic+ipf3">ipf3</a></code> and <code><a href="#topic+ipf3_qi">ipf3_qi</a></code>). Each of these routines are based on indirect estimation methods where marginal totals are known, and a Poisson regression (log-linear) model is assumed. 
</p>
<p>The <code><a href="#topic+ffs_diff">ffs_diff</a></code>, <code><a href="#topic+ffs_rates">ffs_rates</a></code> and <code><a href="#topic+ffs_demo">ffs_demo</a></code> functions provide different methods to estimate migration bilateral flows from changes in stocks, see Abel and Cohen (2019) for a review of different methods. The demo files, <code>demo(cfplot_reg2)</code>, <code>demo(cfplot_reg)</code> and <code>demo(cfplot_nat)</code>, produce circular migration flow plots for migration estimates from Abel(2018) and Abel and Sander (2014), which were derived using the <code><a href="#topic+ffs_demo">ffs_demo</a></code> function.
</p>
<p>Github repo:
<a href="https://github.com/guyabel/migest">https://github.com/guyabel/migest</a> 
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Abel and Cohen (2019) Bilateral international migration flow estimates for 200 countries <em>Scientific Data</em> 6 (1), 1-13
</p>
<p>Abel, G. J. (2018). Estimates of Global Bilateral Migration Flows by Gender between 1960 and 2015. <em>International Migration Review</em> 52 (3), 809–852.
</p>
<p>Abel, G. J. (2013). Estimating Global Migration Flow Tables Using Place of Birth. <em>Demographic Research</em> 28, (18) 505-546
</p>
<p>Abel, G. J. (2005) <em>The Indirect Estimation of Elderly Migrant Flows in England and Wales</em> (MS.c. Thesis). University of Southampton 
</p>
<p>Abel, G. J. and Sander, N. (2014). Quantifying Global International Migration Flows. <em>Science</em>, 343 (6178) 1520-1522
</p>
<p>Raymer, J., G. J. Abel, and P. W. F. Smith (2007). Combining census and registration data to estimate detailed elderly migration flows in England and Wales. <em>Journal of the Royal Statistical Society: Series A (Statistics in Society)</em> 170 (4), 891&ndash;908.
</p>
<p>Willekens, F. (1999). Modelling Approaches to the Indirect Estimation of Migration Flows: From Entropy to EM. <em>Mathematical Population Studies</em> 7 (3), 239&ndash;78.
</p>

<hr>
<h2 id='multi_comp'>Multiplicative component description of origin-destination migration flow tables</h2><span id='topic+multi_comp'></span>

<h3>Description</h3>

<p>Multiplicative component descriptions of *n*-dimension flow tables based on total reference coding system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_comp(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_comp_+3A_m">m</code></td>
<td>
<p><code>matrix</code> or <code>array</code> of migration flows</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> or <code>array</code> of multiplicative components of 'm'. When output is an array the total for each table of origin-destination flows is used.
</p>


<h3>References</h3>

<p>Rogers, A., Willekens, F., Little, J., &amp; Raymer, J. (2002). Describing migration spatial structure. Papers in Regional Science, 81(1), 29–48. https://doi.org/10.1007/s101100100090
</p>
<p>Raymer, J., Bonaguidi, A., &amp; Valentini, A. (2006). Describing and projecting the age and spatial structures of interregional migration in Italy. Population, Space and Place, 12(5), 371–388. https://doi.org/10.1002/psp.414
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- LETTERS[1:4]
m0 &lt;- matrix(data = c(0, 100, 30, 70, 50, 0, 45, 5, 60, 35, 0, 40, 20, 25, 20, 0), 
             nrow = 4, ncol = 4, byrow = TRUE, dimnames = list(orig = r, dest = r))
addmargins(m0)
multi_comp(m = m0)

# data frame
library(dplyr)
italy_area %&gt;%
  filter(year == 2000) %&gt;%
  multi_comp() %&gt;%
  round(digits = 3)
</code></pre>

<hr>
<h2 id='multi_comp2'>Multiplicative component descriptions of origin-destination flow tables based on total reference coding system.</h2><span id='topic+multi_comp2'></span>

<h3>Description</h3>

<p>Multiplicative component descriptions of origin-destination flow tables based on total reference coding system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_comp2(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_comp2_+3A_m">m</code></td>
<td>
<p><code>matrix</code> of migration flows</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> of multiplicative components of 'm'. When output is an array the total for each table of origin-destination flows is used.
</p>


<h3>References</h3>

<p>Rogers, A., Willekens, F., Little, J., &amp; Raymer, J. (2002). Describing migration spatial structure. Papers in Regional Science, 81(1), 29–48. https://doi.org/10.1007/s101100100090
</p>
<p>Raymer, J., Bonaguidi, A., &amp; Valentini, A. (2006). Describing and projecting the age and spatial structures of interregional migration in Italy. Population, Space and Place, 12(5), 371–388. https://doi.org/10.1002/psp.414
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- LETTERS[1:2]
m0 &lt;- array(c(5, 1, 2, 7, 4, 2, 5, 9), dim = c(2, 2, 2),
            dimnames = list(orig = r, dest = r, type = c("ILL", "HEALTHY")))
addmargins(m0)
multi_comp2(m = m0)
</code></pre>

<hr>
<h2 id='nb_non_zero'>Handle negative native born populations</h2><span id='topic+nb_non_zero'></span>

<h3>Description</h3>

<p>This function is predominantly intended to be used within the ffs routines in the migest package. Adjustment to ensure positive population counts in all elements of stock matrix. On rare occasions when working with international stock data the foreign born population can exceed the total population due to conflicting data sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb_non_zero(m, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb_non_zero_+3A_m">m</code></td>
<td>
<p>Matrix of migrant stock totals. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em></p>
</td></tr>
<tr><td><code id="nb_non_zero_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix which scales the elements in columns (places of residence) with a negative population to match the overall population (column total). Negative values will be replaced with zero. Positive values will be scaled down to ensure the column total matches the original <code>m</code>.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffs_demo">ffs_demo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## cant have examples if function not in namespace - i.e. without export 
## so comment all out for own use
# dn &lt;- LETTERS[1:4]
# P &lt;- matrix(data = c(1000, 100, 10, 0, 55, 555, 50, 5, 80, 40, 800, 40, 20, 25, 20, 200),
#             nrow = 4, ncol = 4, dimnames = list(pob = dn, por = dn), byrow = TRUE)
# # display with row and col totals
# addmargins(A = P)
# 
# # no change
# y &lt;- nb_non_zero(m = P)
# addmargins(A = y)
# 
# # adjust a native born population to negative
# P[4, 4] &lt;- -20
# # display with row and col totals
# addmargins(A = P)
# 
# y &lt;- nb_non_zero(m = P)
# addmargins(A = y)

</code></pre>

<hr>
<h2 id='nb_scale_global'>Scale native born populations to match global differences in births and deaths over period</h2><span id='topic+nb_scale_global'></span>

<h3>Description</h3>

<p>This function is predominantly intended to be used within the ffs routines in the migest package. Adjustment to ensure that global differences in stocks match the global demographic changes from births and deaths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb_scale_global(m1, m2, b, d, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb_scale_global_+3A_m1">m1</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em></p>
</td></tr>
<tr><td><code id="nb_scale_global_+3A_m2">m2</code></td>
<td>
<p>Matrix of migrant stock totals at time <em>t</em>+1. Rows in the matrix correspond to place of birth and columns to place of residence at time <em>t</em>+1.</p>
</td></tr>
<tr><td><code id="nb_scale_global_+3A_b">b</code></td>
<td>
<p>Vector of the number of births between time <em>t</em> and <em>t</em>+1 in each region.</p>
</td></tr>
<tr><td><code id="nb_scale_global_+3A_d">d</code></td>
<td>
<p>Vector of the number of deaths between time <em>t</em> and <em>t</em>+1 in each region.</p>
</td></tr>
<tr><td><code id="nb_scale_global_+3A_verbose">verbose</code></td>
<td>
<p>Logical value to indicate the print the parameter estimates at each iteration. By default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with adjusted <code>m1</code> and <code>m2</code>.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffs_demo">ffs_demo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## cant have examples if function not in namespace - i.e. without export 
## so comment all out for own use
# r &lt;- LETTERS[1:4]
# P1 &lt;- matrix(data = c(1000, 100, 10, 0, 55, 555, 50, 5, 80, 40, 800, 40, 20, 25, 20, 200),
#              nrow = 4, ncol = 4, dimnames = list(birth = r, dest = r), byrow = TRUE)
# P2 &lt;- matrix(data = c(950, 100, 60, 0, 80, 505, 75, 5, 90, 30, 800, 40, 40, 45, 0, 180),
#              nrow = 4, ncol = 4, dimnames = list(birth = r, dest = r), byrow = TRUE)
# # display with row and col totals
# addmargins(A = P1)
# addmargins(A = P2)
# 
# # births and deaths
# b &lt;- rep(x = 10, 4)
# d &lt;- rep(x = 5, 4)
# # no change in stocks, but 20 more births than deaths...
# sum(P2) - sum(P1) + sum(d) - sum(b)
# # scale
# y &lt;- nb_scale_global (m1 = P1, m2 = P2, b = b, d = d)
# y
# sum(y$m2_adj) - sum(y$m1_adj) + sum(d) - sum(b)
# 
# # check for when extra is positive and odd
# d[1] &lt;- 32
# d
# sum(P2 - P1) - sum(b - d)
# # scale
# y &lt;- nb_scale_global(m1 = P1, m2 = P2, b = b, d = d)
# sum(y$m2_adj) - sum(y$m1_adj) + sum(d) - sum(b)

</code></pre>

<hr>
<h2 id='nchars_wrap'>Count the number of characters per line</h2><span id='topic+nchars_wrap'></span>

<h3>Description</h3>

<p>Count the number of characters per line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchars_wrap(b, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nchars_wrap_+3A_b">b</code></td>
<td>
<p>Numeric vector for the position of line breaks between the words in <code>w</code></p>
</td></tr>
<tr><td><code id="nchars_wrap_+3A_w">w</code></td>
<td>
<p>Character string vector of words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with vectors for number of characters per line and the number of words per line
</p>

<hr>
<h2 id='net_sr'>Estimate net migration from survival ratios applied to lifetime migration data</h2><span id='topic+net_sr'></span>

<h3>Description</h3>

<p>Using survival ratios to estimate net migration from lifetime migration data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_sr(
  .data,
  pop0_col = "pop0",
  pop1_col = "pop1",
  survival_ratio_col = "sr",
  net_children = FALSE,
  maternal_exposure = c(0.25, 0.75),
  maternal_age_id = 4:9,
  maternal_col = pop1_col
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_sr_+3A_.data">.data</code></td>
<td>
<p>A data frame with two rows with the total number of lifetime in- and out-migrants in separate columns. The first row contains totals at the first time point and second row at the second time point.</p>
</td></tr>
<tr><td><code id="net_sr_+3A_pop0_col">pop0_col</code></td>
<td>
<p>Character string name of column containing name of initial populations. Default <code>"pop0"</code>.</p>
</td></tr>
<tr><td><code id="net_sr_+3A_pop1_col">pop1_col</code></td>
<td>
<p>Character string name of column containing name of end populations. Default <code>"pop1"</code>.</p>
</td></tr>
<tr><td><code id="net_sr_+3A_survival_ratio_col">survival_ratio_col</code></td>
<td>
<p>Character string name of column containing survivor ratios. Default <code>"sr"</code>.</p>
</td></tr>
<tr><td><code id="net_sr_+3A_net_children">net_children</code></td>
<td>
<p>Logical to indicate if to estimate net migration when no survival ratio exists. Default 'FALSE'.</p>
</td></tr>
<tr><td><code id="net_sr_+3A_maternal_exposure">maternal_exposure</code></td>
<td>
<p>Vector for maternal exposures to interval to be used to estimate net migration for each of the unknown children age groups. Length should correspond to the number of children age groups where net migration estimates are required.</p>
</td></tr>
<tr><td><code id="net_sr_+3A_maternal_age_id">maternal_age_id</code></td>
<td>
<p>Row numbers to indicate which rows correspond to maternal age groups at the end of the period.</p>
</td></tr>
<tr><td><code id="net_sr_+3A_maternal_col">maternal_col</code></td>
<td>
<p>Name of maternal population column, required for the estimation of net migration of children.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with estimates of net migration
</p>


<h3>References</h3>

<p>Bogue, D. J., Hinze, K., &amp; White, M. (1982). Techniques of Estimating Net Migration. Community and Family Study Center. University of Chicago.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># results to match un manual 1984 (table 24)
net_sr(bombay_1951, pop0_col = "pop_1941", pop1_col = "pop_1951")
  
# results to match Bogue, Hinze and White (1982)
library(dplyr)
alabama_1970 %&gt;%
  filter(race == "white", sex == "male") %&gt;%
  select(-race, -sex) %&gt;%
  group_by(age_1970) %&gt;%
  net_sr(pop0_col = "pop_1960", pop1_col = "pop_1970", 
         survival_ratio_col = "us_census_sr")
         
# results to match UN manual 1992 (table 6)
net_sr(manila_1970, pop0_col = "pop_1960", pop1_col = "pop_1970", 
       survival_ratio_col = "phl_census_sr")
       
# with children net migration estimate
net_sr(manila_1970, pop0_col = "pop_1960", pop1_col = "pop_1970", 
       survival_ratio_col = "phl_census_sr", net_children = TRUE)
</code></pre>

<hr>
<h2 id='net_vs'>Estimate net migration from vital statistics</h2><span id='topic+net_vs'></span>

<h3>Description</h3>

<p>Estimate net migration from vital statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_vs(
  .data,
  pop0_col = NULL,
  pop1_col = NULL,
  births_col = "births",
  deaths_col = "deaths"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_vs_+3A_.data">.data</code></td>
<td>
<p>A data frame with two rows with the total number of lifetime in- and out-migrants in separate columns. The first row contains totals at the first time point and second row at the second time point.</p>
</td></tr>
<tr><td><code id="net_vs_+3A_pop0_col">pop0_col</code></td>
<td>
<p>Character string name of column containing name of initial populations. Default <code>"pop0"</code>.</p>
</td></tr>
<tr><td><code id="net_vs_+3A_pop1_col">pop1_col</code></td>
<td>
<p>Character string name of column containing name of end populations. Default <code>"pop1"</code>.</p>
</td></tr>
<tr><td><code id="net_vs_+3A_births_col">births_col</code></td>
<td>
<p>Character string name of column containing name of births over the period. Default <code>"births"</code>.</p>
</td></tr>
<tr><td><code id="net_vs_+3A_deaths_col">deaths_col</code></td>
<td>
<p>Character string name of column containing name of deaths over the period. Default <code>"deaths"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with additional columns for the population change ('pop_change'), the natural population increase ('natural_inc') and the net migration ('net') over the period.
</p>


<h3>References</h3>

<p>Bogue, D. J., Hinze, K., &amp; White, M. (1982). Techniques of Estimating Net Migration. Community and Family Study Center. University of Chicago.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
d &lt;- alabama_1970 %&gt;%
  group_by(race, sex) %&gt;%
  summarise(births = sum(pop_1960[1:2]),
            pop_1960 = sum(pop_1960) - births,
            pop_1970 = sum(pop_1970)) %&gt;%
  ungroup()
d

d %&gt;%
  mutate(deaths = c(51449, 58845, 86880, 123220)) %&gt;%
  net_vs(pop0_col = "pop_1960", pop1_col = "pop_1970")
</code></pre>

<hr>
<h2 id='new_england_1960'>New England male white-native population totals in 1950 and 1960 by place of birth and age</h2><span id='topic+new_england_1960'></span>

<h3>Description</h3>

<p>New England population data for by place of birth and age in 1950 and 1960 for male white native born.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_england_1960
</code></pre>


<h3>Format</h3>

<p>Data frame with 72 rows and 4 columns:
</p>

<dl>
<dt>birthplace</dt><dd><p>Place of birth (US Census area)</p>
</dd>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>age_1960</dt><dd><p>Age group in 1960</p>
</dd>
<dt>pop_1950</dt><dd><p>Enumerated population in 1950</p>
</dd>
<dt>pop_1960</dt><dd><p>Enumerated population in 1960</p>
</dd>
</dl>



<h3>Source</h3>

<p>United States Bureau of the Census, United States Census of Population: 1960..Subject Reports..&quot;State of birth&quot; (Washington, D.C.), table 25, pp. 61-62. Persons with place of birth not reported were distributed pro rata among those with place of birth reported. 
</p>
<p>Published in United Nations Department of Economic and Social Affairs Population Division. (1970). Methods of measuring internal migration. United Nations Department of Economic and Social Affairs Population Division - 1970 - Methods of measuring internal migration <a href="https://www.un.org/development/desa/pd/sites/www.un.org.development.desa.pd/files/files/documents/2020/Jan/manual_vi_methods_of_measuring_internal_migration.pdf">https://www.un.org/development/desa/pd/sites/www.un.org.development.desa.pd/files/files/documents/2020/Jan/manual_vi_methods_of_measuring_internal_migration.pdf</a>
</p>

<hr>
<h2 id='quadratic_eqn'>Solutions from the quadratic equation</h2><span id='topic+quadratic_eqn'></span>

<h3>Description</h3>

<p>General function to solve classic quadratic equation:
</p>
<p style="text-align: center;"><code class="reqn"> a x^2 + b x + c = 0 </code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>quadratic_eqn(a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadratic_eqn_+3A_a">a</code></td>
<td>
<p>Numeric value for quadratic term of x.</p>
</td></tr>
<tr><td><code id="quadratic_eqn_+3A_b">b</code></td>
<td>
<p>Numeric value for multiplicative term of x.</p>
</td></tr>
<tr><td><code id="quadratic_eqn_+3A_c">c</code></td>
<td>
<p>Numeric value for constant term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of two values corresponding to the roots for the quadratic equation.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>Source</h3>

<p>Adapted from https://rpubs.com/kikihatzistavrou/80124
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quadratic_eqn(a = 2, b = 4, c = -6)
</code></pre>

<hr>
<h2 id='rc_model_fund'>Fundamental parameters for Rogers-Castro migration schedule</h2><span id='topic+rc_model_fund'></span>

<h3>Description</h3>

<p>Set of fundamental parameters for the Rogers-Castro migration age schedule, as suggested in Rogers and Castro (1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc_model_fund
</code></pre>


<h3>Format</h3>

<p>A <code>tibble</code> with two columns and seven rows:
</p>

<dl>
<dt>param</dt><dd><p>Character string for the seven parameters</p>
</dd>
<dt>value</dt><dd><p>Parameter values</p>
</dd>
</dl>



<h3>Source</h3>

<p>Rogers, A., and L. J. Castro. (1981). Model Migration Schedules. <em>IIASA Research Report 81</em> RR-81-30
</p>

<hr>
<h2 id='rc_model_un'>Model parameters for six Rogers-Castro migration schedules proposed by UN DESA</h2><span id='topic+rc_model_un'></span>

<h3>Description</h3>

<p>Sets of parameters for the Rogers-Castro migration age schedule proposed by UN DESA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc_model_un
</code></pre>


<h3>Format</h3>

<p>A <code>tibble</code> with five columns and 84 rows:
</p>

<dl>
<dt>schedule</dt><dd><p>Character string for full name of schedule</p>
</dd>
<dt>value</dt><dd><p>Character string for abbreviated name of schedule</p>
</dd>
<dt>param</dt><dd><p>Character string for sex of schedule</p>
</dd>
<dt>param</dt><dd><p>Character string for the seven parameters</p>
</dd>
<dt>value</dt><dd><p>Parameter values</p>
</dd>
</dl>



<h3>Source</h3>

<p>United Nations Department of Economic and Social Affairs Population Division. (1992). Preparing Migration Data for Subnational Population Projections. http://www.un.org/esa/population/techcoop/IntMig/migdata_popproj/migdata_popproj.html
</p>

<hr>
<h2 id='rescale_integer_sum'>Rescale integer vector to a set sum</h2><span id='topic+rescale_integer_sum'></span>

<h3>Description</h3>

<p>For when you want to rescale a set of numbers to sum to a given value and do not want all rescaled values to be integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_integer_sum(x, tot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_integer_sum_+3A_x">x</code></td>
<td>
<p>Vector of numeric values</p>
</td></tr>
<tr><td><code id="rescale_integer_sum_+3A_tot">tot</code></td>
<td>
<p>Numeric integer value to rescale sum to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector or integer values that sum to to <code>tot</code>
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ipf3_qi">ipf3_qi</a></code>, <code><a href="#topic+ffs_diff">ffs_diff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(n = 10, mean = 5, sd = 20)
y &lt;- rescale_integer_sum(x, tot = 10)
y
sum(y)

for(i in 1:10){
  y &lt;- rescale_integer_sum(x = rpois(n = 10, lambda = 10), tot = 1000)
  print(sum(y))
}
</code></pre>

<hr>
<h2 id='rescale_net'>Rescale net migration total to a global zero sum</h2><span id='topic+rescale_net'></span>

<h3>Description</h3>

<p>Modify a set of net migration (or any numbers) so that they sum to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_net(
  x,
  method = "no-switches",
  w = rep(1, length(x)),
  integer_result = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_net_+3A_x">x</code></td>
<td>
<p>Vector of net migration values</p>
</td></tr>
<tr><td><code id="rescale_net_+3A_method">method</code></td>
<td>
<p>Method used to adjust net migration values of <code>x</code> to obtain a global zero sum. By default <code>method="no-switches"</code>. Can also take values <code>method="switches"</code>. See details for explanation on each method.</p>
</td></tr>
<tr><td><code id="rescale_net_+3A_w">w</code></td>
<td>
<p>Weights used in rescaling method</p>
</td></tr>
<tr><td><code id="rescale_net_+3A_integer_result">integer_result</code></td>
<td>
<p>Logical operator to indicate if output should be integers, default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rescales net migration for a number of regions in vector <code>x</code> to sum to zero.  When <code>method="no-switches"</code> rescaling of values are done for the positive and negative values separately, to ensure the final global sum is zero. When <code>method="switches"</code> the mean of the unscaled net migration is subtracted from each value.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>References</h3>

<p>Abel, G. J. (2018). Non-zero trajectories for long-run net migration assumptions in global population projection models. <em>Demographic Research</em> 38, (54) 1635–1662
</p>


<h3>Examples</h3>

<pre><code class='language-R'># net migration in regions countries (does not add up to zero)
x &lt;- c(-200, -30, -5, 0, 10, 20, 60, 80)
x
sum(x)
# rescale 
y1 &lt;- rescale_net(x)
y1
sum(y1)
# rescale without integer restriction
y2 &lt;- rescale_net(x, integer_result = FALSE)
y2
sum(y2)
# rescale allowing switching of signs (small negative value becomes positive)
y3 &lt;- rescale_net(x, method = "switches")
y3
sum(y3)
</code></pre>

<hr>
<h2 id='str_wrap_n'>Wrap character string to fit a target number of lines</h2><span id='topic+str_wrap_n'></span>

<h3>Description</h3>

<p>Inserts line breaks for spaces, where the position of the line breaks are chosen to provide the most balanced length of each line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_wrap_n(string = NULL, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_wrap_n_+3A_string">string</code></td>
<td>
<p>Character string to be broken up</p>
</td></tr>
<tr><td><code id="str_wrap_n_+3A_n">n</code></td>
<td>
<p>Number of lines to break the string over</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is intended for a small number of line breaks. The <code>n</code> argument is not allowed to be greater than 8 as all combinations of possible line breaks are explored.
</p>
<p>When there a number of possible solutions that provide equally balanced number of characters in each line, the function returns the character string where the number of spaces are distributed most evenly.
</p>


<h3>Value</h3>

<p>The original <code>string</code> with line breaks inserted at optimal positions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_wrap_n(string = "a bb ccc dddd eeee ffffff", n = 2)
str_wrap_n(string = "a bb ccc dddd eeee ffffff", n = 4)
str_wrap_n(string = "a bb ccc dddd eeee ffffff", n = 8)
str_wrap_n(string = c("a bb", "a bb ccc"), n = 2)
</code></pre>

<hr>
<h2 id='str_wrap_n_single'>Single line wrap for string</h2><span id='topic+str_wrap_n_single'></span>

<h3>Description</h3>

<p>Single line wrap for string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_wrap_n_single(string = NULL, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_wrap_n_single_+3A_string">string</code></td>
<td>
<p>string from <code>str_wrap_n</code></p>
</td></tr>
<tr><td><code id="str_wrap_n_single_+3A_n">n</code></td>
<td>
<p>n from from <code>str_wrap_n</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>String with line breaks
</p>

<hr>
<h2 id='stripe_matrix'>Create a stripped matrix with non-uniform block sizes.</h2><span id='topic+stripe_matrix'></span>

<h3>Description</h3>

<p>Create a stripped matrix with non-uniform block sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stripe_matrix(x = NULL, s = NULL, byrow = FALSE, dimnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stripe_matrix_+3A_x">x</code></td>
<td>
<p>Vector of numbers to identify each stripe.</p>
</td></tr>
<tr><td><code id="stripe_matrix_+3A_s">s</code></td>
<td>
<p>Vector of values for the size of the stripes, order depending on <code>byrow</code></p>
</td></tr>
<tr><td><code id="stripe_matrix_+3A_byrow">byrow</code></td>
<td>
<p>Logical value. If <code>FALSE</code> (the default) the stripes are filled by columns, otherwise the stripes in the matrix are filled by rows.</p>
</td></tr>
<tr><td><code id="stripe_matrix_+3A_dimnames">dimnames</code></td>
<td>
<p>Character string of name attribute for the basis of the stripped matrix. If <code>NULL</code> a vector of the same length of <code>s</code> provides the basis of row and column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>matrix</code> with stripe sizes determined by the <code>s</code> argument. Each stripe is filled with the same value taken from <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+block_matrix">block_matrix</a></code>,  <code><a href="#topic+ipf2_stripe">ipf2_stripe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stripe_matrix(x = 1:44, s = c(2,3,4,2), dimnames = LETTERS[1:4], byrow = TRUE)
</code></pre>

<hr>
<h2 id='sum_bilat'>Summary of bilateral flows, counter-flow and net migration flow</h2><span id='topic+sum_bilat'></span>

<h3>Description</h3>

<p>Summary of bilateral flows, counter-flow and net migration flow
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_bilat(
  m,
  label = "flow",
  orig_col = "orig",
  dest_col = "dest",
  flow_col = "flow"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_bilat_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination flows. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>flow_col</code>.</p>
</td></tr>
<tr><td><code id="sum_bilat_+3A_label">label</code></td>
<td>
<p>Character string for the prefix of the calculated columns. Can take values <code>flow</code> or <code>stream</code></p>
</td></tr>
<tr><td><code id="sum_bilat_+3A_orig_col">orig_col</code></td>
<td>
<p>Character string of the origin column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_bilat_+3A_dest_col">dest_col</code></td>
<td>
<p>Character string of the destination column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_bilat_+3A_flow_col">flow_col</code></td>
<td>
<p>Character string of the flow column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with columns for orig, destination, corridor, flow, counter-flow and net flow in each bilateral pair.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matrix
r &lt;- LETTERS[1:4]
m &lt;- matrix(data = c(0, 100, 30, 70, 50, 0, 45, 5, 60, 35, 0, 40, 20, 25, 20, 0),
            nrow = 4, ncol = 4, dimnames = list(orig = r, dest = r), byrow = TRUE)
m           
sum_bilat(m)

# data frame
library(dplyr)
library(tidyr)
d &lt;- expand_grid(orig = r, dest = r, sex = c("female", "male")) %&gt;%
  mutate(flow = sample(x = 1:100, size = 32))
d

# use group_by to distinguish od tables
d %&gt;%
  group_by(sex) %&gt;%
  sum_bilat()
</code></pre>

<hr>
<h2 id='sum_expand'>Sum bilateral data to include aggregate bilateral totals for origin and destination meta areas</h2><span id='topic+sum_expand'></span>

<h3>Description</h3>

<p>Expand matrix of data frame of migration data to include aggregate sums for corresponding origin and destination meta regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_expand(
  m,
  return_matrix = FALSE,
  guess_order = TRUE,
  area_first = TRUE,
  orig_col = "orig",
  dest_col = "dest",
  flow_col = "flow",
  orig_area_col = "orig_area",
  dest_area_col = "dest_area",
  orig_area = NULL,
  dest_area = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_expand_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination flows. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>flow_col</code>.</p>
</td></tr>
<tr><td><code id="sum_expand_+3A_return_matrix">return_matrix</code></td>
<td>
<p>Logical to return a matrix. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sum_expand_+3A_guess_order">guess_order</code></td>
<td>
<p>Logical to return a matrix or data frame ordered by origin and destination with area names at the end of each block. Default <code>TRUE</code>. If <code>FALSE</code> returns matrix or data frame based on alphabetical order of origin and destinations.</p>
</td></tr>
<tr><td><code id="sum_expand_+3A_area_first">area_first</code></td>
<td>
<p>Order area sums to be placed before the origin and destination values. Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="sum_expand_+3A_orig_col">orig_col</code></td>
<td>
<p>Character string of the origin column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_expand_+3A_dest_col">dest_col</code></td>
<td>
<p>Character string of the destination column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_expand_+3A_flow_col">flow_col</code></td>
<td>
<p>Character string of the flow column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_expand_+3A_orig_area_col">orig_area_col</code></td>
<td>
<p>Character string of the origin area column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_expand_+3A_dest_area_col">dest_area_col</code></td>
<td>
<p>Character string of the destination area column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_expand_+3A_orig_area">orig_area</code></td>
<td>
<p>Vector of labels for the origin areas of each row of <code>m</code>.</p>
</td></tr>
<tr><td><code id="sum_expand_+3A_dest_area">dest_area</code></td>
<td>
<p>Vector of labels for the destination areas of each row of <code>m</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>matrix</code> with additional row and columns (for matrices) for aggregate sums for origin and destination meta-regions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## from matrix
##
m &lt;- block_matrix(x = 1:16, b = c(2,3,4,2))
m

# requires a vector of origin and destination areas
a &lt;- rep(LETTERS[1:4], times = c(2,3,4,2))
a
sum_expand(m = m, orig_area = a, dest_area = a)

# place area sums after regions
sum_expand(m = m, orig_area = a, dest_area = a, area_first = FALSE)

##
## from large data frame
##
## Not run: 
library(tidyverse)
library(countrycode)

# download Abel and Cohen (2019) estimates
f &lt;- read_csv("https://ndownloader.figshare.com/files/38016762", show_col_types = FALSE)
f

# 1990-1995 flow estimates
f %&gt;%
  filter(year0 == 1990) %&gt;%
  mutate(
    orig_area = countrycode(sourcevar = orig, custom_dict = dict_ims,
                            origin = "iso3c", destination = "region"),
    dest_area = countrycode(sourcevar = dest, custom_dict = dict_ims,
                            origin = "iso3c", destination = "region")
  ) %&gt;%
  sum_expand(flow_col = "da_pb_closed", return_matrix = FALSE)

# by group (period)
f %&gt;%
  mutate(
    orig_area = countrycode(sourcevar = orig, custom_dict = dict_ims,
                            origin = "iso3c", destination = "region"),
    dest_area = countrycode(sourcevar = dest, custom_dict = dict_ims,
                            origin = "iso3c", destination = "region")
  ) %&gt;%
  group_by(year0) %&gt;%
  sum_expand(flow_col = "da_pb_closed", return_matrix = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='sum_lump'>Sum and lump together small flows into a &quot;other&quot; category</h2><span id='topic+sum_lump'></span>

<h3>Description</h3>

<p>Lump together regions/countries if their flows are below a given threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_lump(
  m,
  threshold = 1,
  lump = "flow",
  other_level = "other",
  complete = FALSE,
  fill = 0,
  return_matrix = TRUE,
  orig_col = "orig",
  dest_col = "dest",
  flow_col = "flow"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_lump_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination flows. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>flow_col</code>.</p>
</td></tr>
<tr><td><code id="sum_lump_+3A_threshold">threshold</code></td>
<td>
<p>Numeric value used to determine small flows, origins or destinations that will be grouped (lumped) together.</p>
</td></tr>
<tr><td><code id="sum_lump_+3A_lump">lump</code></td>
<td>
<p>Character string to indicate where to apply the threshold. Choose from the <code>flow</code> values, <code>in</code> migration region and/or <code>out</code> migration region.</p>
</td></tr>
<tr><td><code id="sum_lump_+3A_other_level">other_level</code></td>
<td>
<p>Character string for the origin and/or destination label for the lumped values below the <code>threshold</code>. Default <code>"other"</code>.</p>
</td></tr>
<tr><td><code id="sum_lump_+3A_complete">complete</code></td>
<td>
<p>Logical value to return a <code>tibble</code> with complete the origin-destination combinations</p>
</td></tr>
<tr><td><code id="sum_lump_+3A_fill">fill</code></td>
<td>
<p>Numeric value for to fill small cells below the <code>threshold</code> when <code>complete = TRUE</code>. Default of zero.</p>
</td></tr>
<tr><td><code id="sum_lump_+3A_return_matrix">return_matrix</code></td>
<td>
<p>Logical to return a matrix. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sum_lump_+3A_orig_col">orig_col</code></td>
<td>
<p>Character string of the origin column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_lump_+3A_dest_col">dest_col</code></td>
<td>
<p>Character string of the destination column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_lump_+3A_flow_col">flow_col</code></td>
<td>
<p>Character string of the flow column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lump</code> argument can take values <code>flow</code> or <code>bilat</code> to apply the threshold to the data values for between region migration, <code>in</code> or <code>imm</code> to apply the threshold to the incoming region region and <code>out</code> or <code>emi</code> to apply the threshold to outgoing region region.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> with an additional <code>other</code> origins and/or destinations region based on the grouping together of small values below the <code>threshold</code> argument and the <code>lump</code> argument to indicate on where to apply the threshold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- LETTERS[1:4]
m &lt;- matrix(data = c(0, 100, 30, 10, 50, 0, 50, 5, 10, 40, 0, 40, 20, 25, 20, 0),
            nrow = 4, ncol = 4, dimnames = list(orig = r, dest = r), byrow = TRUE)
m

# threshold on in and out region
sum_lump(m, threshold = 100, lump = c("in", "out"))

# threshold on flows (default)
sum_lump(m, threshold = 40)

# return a matrix (only possible when input is a matrix and
# complete = TRUE) with small values replaced by zeros
sum_lump(m, threshold = 50, complete = TRUE)

# return a data frame with small values replaced with zero
sum_lump(m, threshold = 80, complete = TRUE, return_matrix = FALSE)

## Not run: 
# data frame (tidy) format
library(tidyverse)

# download Abel and Cohen (2019) estimates
f &lt;- read_csv("https://ndownloader.figshare.com/files/38016762", show_col_types = FALSE)
f

# large 1990-1995 flow estimates
f %&gt;%
  filter(year0 == 1990) %&gt;%
  sum_lump(flow_col = "da_pb_closed", threshold = 1e5)

# large flow estimates for each year
f %&gt;%
  group_by(year0) %&gt;%
  sum_lump(flow_col = "da_pb_closed", threshold = 1e5)

## End(Not run)
</code></pre>

<hr>
<h2 id='sum_net'>Calculate net migration from an origin-destination migration flow matrix.</h2><span id='topic+sum_net'></span>

<h3>Description</h3>

<p>Sums each regions flows to obtain net migration sums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_net(m, region = 1:dim(m)[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_net_+3A_m">m</code></td>
<td>
<p>Matrix of origin-destination flows, where the first and second dimensions correspond to origin and destination respectively.</p>
</td></tr>
<tr><td><code id="sum_net_+3A_region">region</code></td>
<td>
<p>Integer value corresponding to the region that the net migration sum is desired. Will return sums for all regions by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value of the sum of a single block.
</p>


<h3>Author(s)</h3>

<p>Guy J. Abel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- LETTERS[1:4]
m &lt;- matrix(data = 1:16, nrow = 4, ncol = 4,
            dimnames = list(orig = r, dest = r))
m
sum_net(m)
</code></pre>

<hr>
<h2 id='sum_od'>Extract a classic origin-destination migration flow matrix.</h2><span id='topic+sum_od'></span>

<h3>Description</h3>

<p>Extract a classic origin-destination migration flow matrix from a more detailed dis-aggregation of flows stored in an (<code>array</code>).
Primarily intended to work with output from <code><a href="#topic+ffs_demo">ffs_demo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_od(x = NULL, zero_diag = TRUE, add_margins = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_od_+3A_x">x</code></td>
<td>
<p>Array of origin-destination matrices, where the first and second dimensions correspond to origin and destination respectively. Higher dimension(s) refer to additional migrant characteristic(s).</p>
</td></tr>
<tr><td><code id="sum_od_+3A_zero_diag">zero_diag</code></td>
<td>
<p>Logical to indicate if to set diagonal terms to zero. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sum_od_+3A_add_margins">add_margins</code></td>
<td>
<p>Logical to indicate if to add row and column for immigration and emigration totals. Default <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix from summing over the first and second dimension. Set diagonals to zero.
</p>
<p>Returns a <code>matrix</code> object of origin-destination flows
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffs_demo">ffs_demo</a></code>
</p>

<hr>
<h2 id='sum_region'>Summary of regional in-, out-, turnover and net-migration totals from an origin-destination migration flow matrix or data frame.</h2><span id='topic+sum_region'></span><span id='topic+sum_country'></span>

<h3>Description</h3>

<p>Summary of regional in-, out-, turnover and net-migration totals from an origin-destination migration flow matrix or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_region(
  m,
  drop_diagonal = TRUE,
  orig_col = "orig",
  dest_col = "dest",
  flow_col = "flow",
  international = FALSE,
  include_net = TRUE
)

sum_country(
  m,
  drop_diagonal = TRUE,
  orig_col = "orig",
  dest_col = "dest",
  flow_col = "flow",
  include_net = TRUE,
  international = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_region_+3A_m">m</code></td>
<td>
<p>A <code>matrix</code> or data frame of origin-destination flows. For <code>matrix</code> the first and second dimensions correspond to origin and destination respectively. For a data frame ensure the correct column names are passed to <code>orig_col</code>, <code>dest_col</code> and <code>flow_col</code>.</p>
</td></tr>
<tr><td><code id="sum_region_+3A_drop_diagonal">drop_diagonal</code></td>
<td>
<p>Logical to indicate dropping of diagonal terms, where the origin and destination are the same, in the calculation of totals. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sum_region_+3A_orig_col">orig_col</code></td>
<td>
<p>Character string of the origin column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_region_+3A_dest_col">dest_col</code></td>
<td>
<p>Character string of the destination column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_region_+3A_flow_col">flow_col</code></td>
<td>
<p>Character string of the flow column name (when <code>m</code> is a data frame rather than a <code>matrix</code>)</p>
</td></tr>
<tr><td><code id="sum_region_+3A_international">international</code></td>
<td>
<p>Logical to indicate if flows are international.</p>
</td></tr>
<tr><td><code id="sum_region_+3A_include_net">include_net</code></td>
<td>
<p>Logical to indicate inclusion of a net migration total column for each region, in addition to the total in- and out-flows. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with total in-, out- and turnover of flows for each region.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matrix
r &lt;- LETTERS[1:4]
m &lt;- matrix(data = c(0, 100, 30, 70, 50, 0, 45, 5, 60, 35, 0, 40, 20, 25, 20, 0),
            nrow = 4, ncol = 4, dimnames = list(orig = r, dest = r), byrow = TRUE)
m
sum_region(m)
  
## Not run: 
# data frame (tidy) format
library(tidyverse)

# download Abel and Cohen (2019) estimates
f &lt;- read_csv("https://ndownloader.figshare.com/files/38016762", show_col_types = FALSE)
f

# single period
f %&gt;% 
  filter(year0 == 1990) %&gt;%
  sum_country(flow_col = "da_pb_closed")

# all periods using group_by
f %&gt;% 
  group_by(year0) %&gt;%
  sum_country(flow_col = "da_pb_closed")

## End(Not run)   
</code></pre>

<hr>
<h2 id='uar_1960'>Lifetime migration data for Governorates of United Arab Republic in 1960</h2><span id='topic+uar_1960'></span>

<h3>Description</h3>

<p>Lifetime migration (stock) bilateral data from Governorates of the United Arab Republic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uar_1960
</code></pre>


<h3>Format</h3>

<p>Matrix with 11 rows and columns
</p>

<dl>
<dt>orig</dt><dd><p>Governorate of birth</p>
</dd>
<dt>carat</dt><dd><p>Governorate of enumeration</p>
</dd>
</dl>



<h3>Source</h3>

<p>United Arab Republic, Department of Statistics and Census, 1960 Census of Population (Cairo, July 1963), vol. II, General tables, table 14, p. 50. 
</p>
<p>Published in United Nations Department of Economic and Social Affairs Population Division. (1970). Methods of measuring internal migration. United Nations Department of Economic and Social Affairs Population Division - 1970 - Methods of measuring internal migration <a href="https://www.un.org/development/desa/pd/sites/www.un.org.development.desa.pd/files/files/documents/2020/Jan/manual_vi_methods_of_measuring_internal_migration.pdf">https://www.un.org/development/desa/pd/sites/www.un.org.development.desa.pd/files/files/documents/2020/Jan/manual_vi_methods_of_measuring_internal_migration.pdf</a>
</p>

<hr>
<h2 id='umbrella'>Umbrella colour scheme</h2><span id='topic+umbrella'></span>

<h3>Description</h3>

<p>Vector of hexadecimal codes for a umbrella rainbow colour scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>umbrella
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 9.
</p>

<hr>
<h2 id='usa_1960'>US population totals in 1950 and 1960 by place of birth, age, sex and race</h2><span id='topic+usa_1960'></span>

<h3>Description</h3>

<p>Population data by place of birth, age, sex and race in 1950 and 1960
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usa_1960
</code></pre>


<h3>Format</h3>

<p>Data frame with 288 rows and 7 columns:
</p>

<dl>
<dt>birthplace</dt><dd><p>Place of birth (US Census area)</p>
</dd>
<dt>race</dt><dd><p>Race from 'white' or 'non-white'</p>
</dd>
<dt>sex</dt><dd><p>Sex from 'male' or 'female'</p>
</dd>
<dt>age_1950</dt><dd><p>Age group in 1950</p>
</dd>
<dt>age_1960</dt><dd><p>Age group in 1960</p>
</dd>
<dt>pop_1950</dt><dd><p>Enumerated population in 1950</p>
</dd>
<dt>pop_1960</dt><dd><p>Enumerated population in 1960</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data scraped from Table D, pp. 183-191 of Eldridge, H., &amp; Kim, Y. (1968). The estimation of intercensal migration from birth-residence statistics: a study of data for the United States, 1950 and 1960 (PSC Analytical and Technical Report Series, Issue 7). <a href="https://repository.upenn.edu/entities/publication/2a11a5f7-3ddf-47f3-a47d-1de5254f4cc5">https://repository.upenn.edu/entities/publication/2a11a5f7-3ddf-47f3-a47d-1de5254f4cc5</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
