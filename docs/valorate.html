<!DOCTYPE html><html lang="en"><head><title>Help for package valorate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {valorate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#new.valorate'><p>CREATE A VALORATE OBJECT</p></a></li>
<li><a href='#prepare.n1'><p>ESTIMATES THE LOG-RANK DISTRIBUTION AND STORE IT WITHIN A VALORATE OBJECT</p></a></li>
<li><a href='#valorate-internal'><p>Internal VALORATE Functions</p></a></li>
<li><a href='#valorate.p.value'><p>ESTIMATES THE P-VALUE OF THE LOG-RANK TEST</p></a></li>
<li><a href='#valorate.plot.empirical'><p>PLOT THE SAMPLED (EMPIRICAL) LOG-RANK DISTRIBUTION</p></a></li>
<li><a href='#valorate.plot.kaplan'><p>PLOT KAPLAN-MEIER CURVES</p></a></li>
<li><a href='#valorate.plot.sampling.densities'><p>PLOT CO-OCCURRENCE DENSITIES FORMING A LOG-RANK DISTRIBUTION</p></a></li>
<li><a href='#valorate.plot.subpop'><p>PLOT ALL ESTIMATED LOG-RANK DISTRIBUTIONS</p></a></li>
<li><a href='#valorate.risk'><p>ESTIMATES RISK</p></a></li>
<li><a href='#valorate.survdiff'><p>ESTIMATES THE P-VALUE AND STATISTICS OF THE LOG-RANK TEST</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-10-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Velocity and Accuracy of the LOg-RAnk TEst</td>
</tr>
<tr>
<td>Author:</td>
<td>Victor Trevino [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Victor Trevino &lt;vtrevino@itesm.mx&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>survival, graphics, utils, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>The algorithm implemented in this package was
    designed to quickly estimates the distribution of the 
    log-rank especially for heavy unbalanced groups. VALORATE 
    estimates the null distribution and the p-value of the 
    log-rank test based on a recent formulation. For a given 
    number of alterations that define the size of survival 
    groups, the estimation involves a weighted sum of 
    distributions that are conditional on a co-occurrence term 
    where mutations and events are both present. The estimation 
    of conditional distributions is quite fast allowing the 
    analysis of large datasets in few minutes 
    <a href="http://bioinformatica.mty.itesm.mx/valorate">http://bioinformatica.mty.itesm.mx/valorate</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://bioinformatica.mty.itesm.mx/valorate">http://bioinformatica.mty.itesm.mx/valorate</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-10-09 20:35:41 UTC; victortrevino</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-10-09 23:23:03</td>
</tr>
</table>
<hr>
<h2 id='new.valorate'>CREATE A VALORATE OBJECT</h2><span id='topic+valorate'></span><span id='topic+new.valorate'></span>

<h3>Description</h3>

<p>Creates a new valorate object from the survival information
and basic parameters.
<code>new.valorate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new.valorate(time, status, censored, rank, sampling.size=max(10000, 2e+05/events), 
	min.sampling.size=1000, tails=2, sampling.ties=30, 
	weights.method=c("logrank", "Wilcoxon", "Tarone-Ware", "Peto", 
		"Flemington-Harrington", "Trevino", "user")[1], 
	weights.parameters=list(p=1, q=1, t=3), weights, 
    verbose=FALSE, save.sampling=TRUE, method="C", 
    estimate.distribution.parameters=c("empirical","gaussian","beta","weibull")[1])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new.valorate_+3A_time">time</code></td>
<td>
<p>character or numeric vector representing the survival time. If character it could be &quot;76+&quot; representing 76 units of time and censored. In this case, the censored parameter should not be provided.</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_status">status</code></td>
<td>
<p>numeric or logical vector representing the status (1 for event and 0 for censoring). This should be specified in the same order than the time argument and only if time was specified and does not include the censoring &quot;+&quot; indicator within.</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_censored">censored</code></td>
<td>
<p>numeric or logical vector representing the censoring status (1 for censored and 0 for event). This should be specified in the same order than the time argument and only if time was specified and does not include the censoring &quot;+&quot; indicator within.</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_rank">rank</code></td>
<td>
<p>a numeric or logical vector representing time-ordered subjects and whether they are events (1 or TRUE) or censoring observations (0 or FALSE). If rank is provided, time and status, censored should not. This argument is basically the 'c' vector of the log-rank formulation in the VALORATE publication.</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_sampling.size">sampling.size</code></td>
<td>
<p>a numeric value representing the length of random samples of the survival group vector (basically the 'x' vector, see the publication and references) that will be used to estimate the log-rank distribution.  See the details section. The default is max(10000,200000/events).</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_min.sampling.size">min.sampling.size</code></td>
<td>
<p>a numeric value representing the minimum number of random samples of the survival group vector. See the details section. The default is 1000.</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_tails">tails</code></td>
<td>
<p>a numeric value indicating whether the p-values generated will represent a 1 tail or two-tails (the default is two-tails).</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_sampling.ties">sampling.ties</code></td>
<td>
<p>a numeric value indicating the number of permutations of tie positions used for the estimation of the log-rank distribution. The default is 30.</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_weights.method">weights.method</code></td>
<td>
<p>a character specifying the type of log-rank test (see books in references). It can be &quot;logrank&quot; (default), &quot;Wilcoxon&quot;, &quot;Tarone-Ware&quot;, &quot;Peto&quot;, &quot;Flemington-Harrington&quot;, &quot;Trevino&quot;,and &quot;user&quot;. In case of &quot;user&quot;, the 'weights' parameter should also be specified </p>
</td></tr>
<tr><td><code id="new.valorate_+3A_weights.parameters">weights.parameters</code></td>
<td>
<p>a list of values for 'weights.method'. &quot;Flemington-Harrington&quot; uses a p and q parameters. &quot;Trevino&quot; uses a t parameter. The default is list(p=1,q=1,t=3).</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_weights">weights</code></td>
<td>
<p>a numeric vector having order according to the 'time' or 'rank' parameter only for &quot;user&quot; weights.method</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether estimation should show messages of partial calculations. The default is FALSE.</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_save.sampling">save.sampling</code></td>
<td>
<p>a logical value indicating whether all sampling will be saved within the VALORATE object. The default is TRUE. This can be used to avoid saving all sampling and save memory. See details about memory usage.</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_method">method</code></td>
<td>
<p>a character value either &quot;R&quot; or &quot;C&quot; that specify the implemented method of calculation. Both should generate same values but &quot;C&quot; is by far faster (default=&quot;C&quot;). This can be used in cases where C calculations does not work for any reason or to compare methods and algorithms.</p>
</td></tr>
<tr><td><code id="new.valorate_+3A_estimate.distribution.parameters">estimate.distribution.parameters</code></td>
<td>
<p>a character vector containing subsets of &quot;empirical&quot;,&quot;gaussian&quot;,&quot;beta&quot;,and &quot;weibull&quot;. The default is &quot;empirical&quot;. This has not been extensively explored but attempts to fit the observed log-rank distribution using sums of other distributions whose parameters are estimated after sampling. The &quot;empirical&quot; means nothing basically whereas &quot;gaussian&quot; for example means the estimation of mean and standard deviation of the observed conditional log-ranks. The results of these estimations can be viewd by <a href="#topic+valorate.plot.empirical">valorate.plot.empirical</a> or within the corresponding variables of the @subpop environment. This is experimental and is not intended for most users and applictions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values in time and censored arguments do not need to be sorted by time but it is assumed that further specification of survival groups (e. g. calls to valorate.survdiff) will be provided in the corresponding order than that of this parameter. This function generates a VALORATE object prepared to run further analyses on the estimation of log-rank distributions for the specified population. See the 'value' section for details. 
</p>
<p>It is critical for computation time and memory the handling of the sampling. This can be managed by the sampling.size and min.sampling.size.
</p>
<p>To save memory, save.sampling can be set to FALSE. In this case, valorate will estimate a ~1000 breaks histogram to store each conditional log-rank distribution. However, this strategy will lead in loosing resolution and therefore precision in the estimation of p-values. Thus, save.sampling=FALSE is not recommended for most applications.
</p>


<h3>Value</h3>

<p>A valorate object.
</p>
<table role = "presentation">
<tr><td><code>s</code></td>
<td>
<p>numeric vector representing the subjects ordered in time. This is basically the same than 'rank' argument if specified. So, this is the 'c' vector of the log-rank formulation in the VALORATE publication.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the total number of subjects. It should be equal to the length of s.</p>
</td></tr>
<tr><td><code>events</code></td>
<td>
<p>the total number of events observed. It should be equal to the sum of s.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>this is a list of the parameters specified.</p>
</td></tr>
<tr><td><code>sampling.size</code></td>
<td>
<p>the 'total' number of sampling used to estimate the log-rank distribution. The computation time and memory depends largely in this value. Many numeric vectors will be created whose sum of their length will be approximately this value. This may be a copy of the original argument.</p>
</td></tr>
<tr><td><code>min.sampling.size</code></td>
<td>
<p>the minimum number of sampling that will be used to estimate a conditional log-rank distribution (conditional to 'k' co-occurrences, see publication and references below).  This may be a copy of the original argument.</p>
</td></tr>
<tr><td><code>wcensored</code></td>
<td>
<p>a numeric vector denoting the positions of the 's' vector having censored subjects.</p>
</td></tr>
<tr><td><code>wevents</code></td>
<td>
<p>a numeric vector denoting the positions of the 's' vector having events.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>the index positions of the time/censoring values needed to sort the subjects by time. This will be used in <a href="#topic+valorate.survdiff">valorate.survdiff</a> to re-accomodate the data specified.</p>
</td></tr>
<tr><td><code>subpop</code></td>
<td>
<p>an environment of currently estimated log-rank distributions. The names for each item is given by 'subpop#' where '#' is the number of subjects in the survival group of interest (basically the n1 value that is equal to the sum of 1's within the 'x' vector). Each 'subpop' contains a list of values needed for the estimations and many are further indexed by the value of co-occurrences 'k', including 'sampling' which stores all log-rank conditional samplings,  'emp.hist' a tiny 'histogram' version of the estimated conditional distribution, 'combinations' the number of combinations of each co-occurrence, and 'k.density' its corresponding density or weights. See the tutorial within references for details.</p>
</td></tr>
<tr><td><code>ties</code></td>
<td>
<p>a list of vectos having the positions of ties.</p>
</td></tr>
<tr><td><code>sampling.ties</code></td>
<td>
<p>this is a copy of the original argument.</p>
</td></tr>
<tr><td><code>tiesame</code></td>
<td>
<p>equal to ties.</p>
</td></tr>
<tr><td><code>tiesame.pos</code></td>
<td>
<p>all positions having ties.</p>
</td></tr>
<tr><td><code>tiesame.sampling</code></td>
<td>
<p>the actual value of samplings done to ties. 1 means no additional samplings.</p>
</td></tr>
<tr><td><code>verbose</code></td>
<td>
<p>this is a copy of the original argument.</p>
</td></tr>
<tr><td><code>save.sampling</code></td>
<td>
<p>this is a copy of the original argument.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>this is a copy of the original argument.</p>
</td></tr>
<tr><td><code>tails</code></td>
<td>
<p>this is a copy of the original argument.</p>
</td></tr>
<tr><td><code>weights.method</code></td>
<td>
<p>this is a copy of the original argument.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>this is a copy of the original argument.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>this is a copy of the original argument.</p>
</td></tr>
<tr><td><code>samplings</code></td>
<td>
<p>this is depracated and has been moved to each subpop.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Victor Trevino <a href="mailto:vtrevino@itesm.mx">vtrevino@itesm.mx</a></p>


<h3>References</h3>

<p>Trevino et al. 2016 <a href="http://bioinformatica.mty.itesm.mx/valorateR">http://bioinformatica.mty.itesm.mx/valorateR</a>
</p>
<p>David G. Kleinbaum and Mitchel Klein (2005). <em>Survival Analysis: A Self-Learning Text</em>. Second Edition. New York: Springer.
</p>
<p>David Collett (2004). <em>Modelling survival data in medical research Collett David</em>. Second Edition. Chapman &amp; Hall-CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+valorate.survdiff">valorate.survdiff</a></code>.
<code><a href="#topic+valorate.plot.empirical">valorate.plot.empirical</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a random population of 100 subjects 
## having 20 events
subjects &lt;- numeric(100)
subjects[sample(100,20)] &lt;- 1
vo &lt;- new.valorate(rank=subjects, sampling.size=100000)

## print the structure of properties
str(vo)

## print slots
slotNames(vo)

</code></pre>

<hr>
<h2 id='prepare.n1'>ESTIMATES THE LOG-RANK DISTRIBUTION AND STORE IT WITHIN A VALORATE OBJECT</h2><span id='topic+prepare.n1'></span>

<h3>Description</h3>

<p>This method  estimates the log-rank distribution for a minor size group equal to n1. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare.n1(vro, n1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepare.n1_+3A_vro">vro</code></td>
<td>
<p>the valorate object.</p>
</td></tr>
<tr><td><code id="prepare.n1_+3A_n1">n1</code></td>
<td>
<p>a numerical value (perhaps integer) of the size of the survival group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method actually estimates the log-rank distribution for a minor size group equal to n1. This method is internally called by all functions to first check and/or compute the log-rank distribution of n1. It is not intended to be used by final users unless it is intended to prepare the VALORATE object before p-value calculations (perhaps in separated threds or jobs and saving/restoring the object). 
</p>


<h3>Value</h3>

<p>The updated valorate object. This is a S4 method operating an object, so the valorate object specified in argument will be updated with the estimations of the distribution of the log-rank for n1 subjects.
</p>


<h3>Author(s)</h3>

<p>Victor Trevino <a href="mailto:vtrevino@itesm.mx">vtrevino@itesm.mx</a></p>


<h3>References</h3>

<p>Trevino et al. 2016 <a href="http://bioinformatica.mty.itesm.mx/valorateR">http://bioinformatica.mty.itesm.mx/valorateR</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new.valorate">new.valorate</a></code>.
<code><a href="#topic+valorate.survdiff">valorate.survdiff</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a random population of 100 subjects 
## having 20 events
subjects &lt;- numeric(100)
subjects[sample(100,20)] &lt;- 1
vo &lt;- new.valorate(rank=subjects, sampling.size=100000)
# and with verbose
vo &lt;- new.valorate(rank=subjects, sampling.size=100000, verbose=TRUE)

## print the initial subpop
ls(vo@subpop) # should be character(0)

## calculate
prepare.n1(vo, 10) # should show messages of partial calculations P(L|k)

## print the current subpop
ls(vo@subpop) #should show now: [1] "subpop10"

names(vo@subpop[["subpop10"]]) #should show the internal names of the estimated subpop

</code></pre>

<hr>
<h2 id='valorate-internal'>Internal VALORATE Functions</h2><span id='topic+valorate.p.overlap'></span><span id='topic+valorate.hyper.density'></span><span id='topic+valorate.comb'></span><span id='topic+valorate.perm'></span><span id='topic+valorate.cat'></span><span id='topic+valorate.mav'></span><span id='topic+plot.kaplan.valorate'></span><span id='topic+valorate.estimate.beta.parameters'></span><span id='topic+valorate.estimate.weibull.parameters'></span><span id='topic+valorate.psurvdiff'></span><span id='topic+valorate.plot.diff.empirical'></span>

<h3>Description</h3>

<p>Internal Valorate functions
</p>


<h3>Details</h3>

<p>Not to be called by user.
</p>

<hr>
<h2 id='valorate.p.value'>ESTIMATES THE P-VALUE OF THE LOG-RANK TEST</h2><span id='topic+valorate.p.value'></span><span id='topic+valorate.p.value.sampling'></span><span id='topic+valorate.p.value.normal'></span><span id='topic+valorate.p.value.chisq'></span><span id='topic+valorate.p.value.gaussian'></span><span id='topic+valorate.p.value.weibull'></span><span id='topic+valorate.p.value.beta'></span><span id='topic+valorate.p.value.all'></span>

<h3>Description</h3>

<p>Estimates the p-value using specific approximations to the log-rank. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valorate.p.value.sampling(vro, vrsubo, lrv, z)
valorate.p.value.chisq(vro, vrsubo, lrv, z)
valorate.p.value.normal(vro, vrsubo, lrv, z)
valorate.p.value.gaussian(vro, vrsubo, lrv, z)
valorate.p.value.weibull(vro, vrsubo, lrv, z)
valorate.p.value.beta(vro, vrsubo, lrv, z)
valorate.p.value.all(vro, vrsubo, lrv, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valorate.p.value_+3A_vro">vro</code></td>
<td>
<p>the valorate object.</p>
</td></tr>
<tr><td><code id="valorate.p.value_+3A_vrsubo">vrsubo</code></td>
<td>
<p>the subpop list object (see <a href="#topic+prepare.n1">prepare.n1</a>) or a numeric value representing n1 used to obtain the subpop.</p>
</td></tr>
<tr><td><code id="valorate.p.value_+3A_lrv">lrv</code></td>
<td>
<p>if provided, the log-rank value. It is needed for .sampling, .gaussian, .weibull, .beta, .normal, and .all .</p>
</td></tr>
<tr><td><code id="valorate.p.value_+3A_z">z</code></td>
<td>
<p>if provided, the log-rank value in z-score (divided by the approximated standard deviation). It is needed for .normal, .chisq, optionally to .all if normal and chisq are required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This family of functions estimates the p-value of the log-rank test using specific approximations.
The intended 'user' function in VALORATE is valorate.p.value.sampling, which is the function that is described in the publications. The rest of the functions are complementary for comparison with the classical approximations (chisq and normal) and for experimental purposes fitting each conditional log-rank distribution sampled (conditioned on k co-occurrences) with the specified distribution (gaussian, weibull, and beta). The function valorate.p.value.all is just a proxy to all calculations in the same function.
</p>


<h3>Value</h3>

<p>the estimated p-value (times tails).
</p>


<h3>Author(s)</h3>

<p>Victor Trevino <a href="mailto:vtrevino@itesm.mx">vtrevino@itesm.mx</a></p>


<h3>References</h3>

<p>Trevino et al. 2016 <a href="http://bioinformatica.mty.itesm.mx/valorateR">http://bioinformatica.mty.itesm.mx/valorateR</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new.valorate">new.valorate</a></code>.
<code><a href="#topic+valorate.survdiff">valorate.survdiff</a></code>.
<code><a href="#topic+valorate.plot.empirical">valorate.plot.empirical</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a random population of 100 subjects 
## having 20 events
subjects &lt;- numeric(100)
subjects[sample(100,20)] &lt;- 1
vo &lt;- new.valorate(rank=subjects, sampling.size=100000, verbose=TRUE)

groups &lt;- numeric(100)
groups[sample(100,4)] &lt;- 1  # only 4 subjects are within the 'mutated' group
pvr &lt;- valorate.survdiff(vo, groups)
print(pvr)

# the same than the value of pvr
valorate.p.value.sampling(vo, vo@subpop[["subpop4"]], attributes(pvr)[[1]]["LR"])

# the same than the value of pvr
valorate.p.value.sampling(vo, 4, attributes(pvr)[[1]]["LR"])

#classical approximations:
valorate.p.value.normal(vo, 4, attributes(pvr)[[1]]["LR"], attributes(pvr)[[1]]["Z"])
valorate.p.value.chisq(vo, 4, attributes(pvr)[[1]]["LR"], attributes(pvr)[[1]]["Z"])

# approximations of the conditional log-rank sampled density
valorate.p.value.gaussian(vo, 4, attributes(pvr)[[1]]["LR"])
valorate.p.value.beta(vo, 4, attributes(pvr)[[1]]["LR"])
valorate.p.value.weibull(vo, 4, attributes(pvr)[[1]]["LR"])

# all above can be get by:
valorate.p.value.all(vo, 4, attributes(pvr)[[1]]["LR"], attributes(pvr)[[1]]["Z"])

# Estimate a p-value a given log-rank
prepare.n1(vo, 50)
valorate.p.value.all(vo, 50, 0, 0) # 0 log-rank, 0 z-score

</code></pre>

<hr>
<h2 id='valorate.plot.empirical'>PLOT THE SAMPLED (EMPIRICAL) LOG-RANK DISTRIBUTION</h2><span id='topic+valorate.plot.empirical'></span>

<h3>Description</h3>

<p>Plots the estimated density of the log-rank distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valorate.plot.empirical(vro, n1, vstat, type, log, add, include, xlab, ylab, 
	main, samp, smooth, legends, shades, transparency, lwd, xlim, 
	minL=NA, minR=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valorate.plot.empirical_+3A_vro">vro</code></td>
<td>
<p>the valorate object.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_n1">n1</code></td>
<td>
<p>the size of the 'mutated' or interested survival group. It can be also the numerical/logical 'x' vector as in <a href="#topic+valorate.survdiff">valorate.survdiff</a> in which case n1 and vstat are estimated.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_vstat">vstat</code></td>
<td>
<p>log-rank statistic. If provided, a vertical mark on this value is shown and both sides of the density are filled to highlight areas.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_type">type</code></td>
<td>
<p>typical plot parameter: &quot;p&quot;=points, &quot;l&quot;=lines (default), &quot;o&quot;=overlap.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_log">log</code></td>
<td>
<p>typical plot parameter : specify which axis are shown in logarithm base 10.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_add">add</code></td>
<td>
<p>typical plot parameter : specify whether the plot is new or added to an existing one.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_include">include</code></td>
<td>
<p>specify which other estimations are included. This is experimental. Default &quot;none&quot;, possibles: &quot;none&quot;,&quot;gaussian&quot;,&quot;beta&quot;,&quot;weibull&quot;,&quot;all&quot;.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_xlab">xlab</code></td>
<td>
<p>typical plot parameter: how the x axis is labelled, the default is &quot;valorate LR&quot;.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_ylab">ylab</code></td>
<td>
<p>typical plot parameter: how the y axis is labelled, the default is &quot;density&quot;.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_main">main</code></td>
<td>
<p>typical plot parameter. The default is an expression depending on the parameters. </p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_samp">samp</code></td>
<td>
<p>a numeric value specifying the length of sampling when using other density functions. It is related to the include argument.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_smooth">smooth</code></td>
<td>
<p>the strength of density smoothing for display purposes. The default is 10.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_legends">legends</code></td>
<td>
<p>logical value that defines whether the legends for each curve should be displayed. The default is FALSE.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_shades">shades</code></td>
<td>
<p>define de colors used to shade the empirical distribution when the either 'vstat' argument is used or n1 represent the 'x' vector. The default is c(6,8). </p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_transparency">transparency</code></td>
<td>
<p>defines the transparency in shades. The default is 0.25.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_lwd">lwd</code></td>
<td>
<p>typical plot parameter: width of the lines. Default is 2.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_xlim">xlim</code></td>
<td>
<p>typical plot parameter.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_minl">minL</code>, <code id="valorate.plot.empirical_+3A_minr">minR</code></td>
<td>
<p>limits to the estimated empirical density.</p>
</td></tr>
<tr><td><code id="valorate.plot.empirical_+3A_...">...</code></td>
<td>
<p>arguments passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the estimated density of the log-rank distribution.
</p>


<h3>Value</h3>

<p>An invisible data frame of the density estimation.
</p>


<h3>Author(s)</h3>

<p>Victor Trevino <a href="mailto:vtrevino@itesm.mx">vtrevino@itesm.mx</a></p>


<h3>References</h3>

<p>Trevino et al. 2016 <a href="http://bioinformatica.mty.itesm.mx/valorateR">http://bioinformatica.mty.itesm.mx/valorateR</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new.valorate">new.valorate</a></code>.
<code><a href="#topic+valorate.p.value">valorate.p.value</a></code>.
<code><a href="#topic+valorate.plot.empirical">valorate.plot.empirical</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a random population of 100 subjects 
## having 20 events
subjects &lt;- numeric(100)
subjects[sample(100,20)] &lt;- 1
vo &lt;- new.valorate(rank=subjects, sampling.size=100000, verbose=TRUE)

groups &lt;- numeric(100)
groups[sample(100,4)] &lt;- 1  # only 4 subjects are within the 'mutated' group
pvr &lt;- valorate.survdiff(vo, groups) 
print(pvr)

# Crude density
## Not run: valorate.plot.empirical(vo, 4)

# Similar but marking the statistic 
# returned by groups and shading
## Not run: valorate.plot.empirical(vo, groups)

# Plot density and check symmetry
## Not run: valorate.plot.empirical(vo, 4, 0)

# Now should be almost symmetric
## Not run: valorate.plot.empirical(vo, 50, 0)

# Crude density plus gaussian, weibull, and beta estimations
## Not run: valorate.plot.empirical(vo, 4, include="all", legends=TRUE)

</code></pre>

<hr>
<h2 id='valorate.plot.kaplan'>PLOT KAPLAN-MEIER CURVES</h2><span id='topic+valorate.plot.kaplan'></span>

<h3>Description</h3>

<p>Plots the Kaplan-Meier Curves from two groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valorate.plot.kaplan(vro, clusters, p=valorate.survdiff(vro, clusters), 
  main, short.names=TRUE, draw.all=FALSE, mark="|", mark.cex=0.75, 
  margins=TRUE, col=2:3, col.all="skyblue")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valorate.plot.kaplan_+3A_vro">vro</code></td>
<td>
<p>the valorate object.</p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_clusters">clusters</code></td>
<td>
<p>a numerical or logical vector representing the two survival groups encoded in 1/TRUE for those 'mutated' (in the group of interest) or 1/FALSE for those who not. Basically this value is the 'x' vector in the VALORATE re-formulation. See references.</p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_p">p</code></td>
<td>
<p>the estimated p-value of the log-rank test. The default is valorate.survdiff(vro, clusters).</p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_main">main</code></td>
<td>
<p>typical plot parameter. The default is an expression depending on the parameters. </p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_short.names">short.names</code></td>
<td>
<p>if TRUE (default) use 'LR' instead or 'Log-Rank' and 'HR' instead or 'Hazard-Ratio' in legends.</p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_draw.all">draw.all</code></td>
<td>
<p>if TRUE, the plot includes also the survival curve of all subjects before stratification.</p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_mark">mark</code></td>
<td>
<p>character to mark censoring. The default is &quot;|&quot;.</p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_mark.cex">mark.cex</code></td>
<td>
<p>the character expansion. The default is 0.75</p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_margins">margins</code></td>
<td>
<p>if TRUE (default) set the margins properly.</p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_col">col</code></td>
<td>
<p>specifies the colors for survival curves. The default is 2:3 (red for cluster=0, green for cluster=1).</p>
</td></tr>
<tr><td><code id="valorate.plot.kaplan_+3A_col.all">col.all</code></td>
<td>
<p>specifies the color when draw.all is TRUE. The default is &quot;skyblue&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the estimated Kaplan-Meier survival curves from data.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Victor Trevino <a href="mailto:vtrevino@itesm.mx">vtrevino@itesm.mx</a></p>


<h3>References</h3>

<p>Trevino et al. 2016 <a href="http://bioinformatica.mty.itesm.mx/valorateR">http://bioinformatica.mty.itesm.mx/valorateR</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new.valorate">new.valorate</a></code>.
<code><a href="#topic+valorate.survdiff">valorate.survdiff</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a random population of 100 subjects 
## having 20 events
subjects &lt;- numeric(100)
subjects[sample(100,20)] &lt;- 1
vo &lt;- new.valorate(rank=subjects, sampling.size=100000, verbose=TRUE)

groups &lt;- numeric(100)
groups[sample(100,20)] &lt;- 1  # 20 to likely see some difference
pvr &lt;- valorate.survdiff(vo, groups) 
print(pvr)

## Not run: valorate.plot.kaplan(vo, groups, main="Two Curves")

## Not run: valorate.plot.kaplan(vo, groups, draw.all=TRUE, 
    main="Three Curves (Including All Data)")
## End(Not run)

</code></pre>

<hr>
<h2 id='valorate.plot.sampling.densities'>PLOT CO-OCCURRENCE DENSITIES FORMING A LOG-RANK DISTRIBUTION</h2><span id='topic+valorate.plot.sampling.densities'></span><span id='topic+valorate.plot.sampling.densities.figure'></span>

<h3>Description</h3>

<p>Plots the densities of each co-occurrence that shapes the final log-rank distribution for a n1 group size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valorate.plot.sampling.densities(vro, n1, 
  type, log, xlim, ylim, ncol, main, 
  rug, add, w.sum, sampling, 
  weighted,legends.cex, weights.cex,
  weights.pos, w.sum.lwd=3,
  y.limit=1e-13,
  ...)

valorate.plot.sampling.densities.figure(vro, n1, type, log, 
  xlim, ylim, main, rug, rug.size, 
  sub, w.sum, sampling, ncol, 
  y.limit=1e-13, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valorate.plot.sampling.densities_+3A_vro">vro</code></td>
<td>
<p>the valorate object.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_n1">n1</code></td>
<td>
<p>the size of the 'mutated' or interested survival group. It can be also the numerical/logical 'x' vector as in <a href="#topic+valorate.survdiff">valorate.survdiff</a> in which case n1 and vstat are estimated.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_type">type</code></td>
<td>
<p>typical plot parameter: &quot;p&quot;=points, &quot;l&quot;=lines (default), &quot;o&quot;=overlap.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_log">log</code></td>
<td>
<p>typical plot parameter : specify which axis are shown in logarithm base 10.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_xlim">xlim</code></td>
<td>
<p>typical plot parameter.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_ylim">ylim</code></td>
<td>
<p>typical plot parameter.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_ncol">ncol</code></td>
<td>
<p>number of columns for legends.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_main">main</code></td>
<td>
<p>typical plot parameter. The default is an expression depending on the parameters. </p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_rug">rug</code></td>
<td>
<p>if FALSE removes the drawing of rugs. </p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_add">add</code></td>
<td>
<p>if FALSE assumes plots are added to existing one. Not valid for all functions. </p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_w.sum">w.sum</code></td>
<td>
<p>if FALSE removes the drawing of the weighted sum distribution (the final log-rank distibution). </p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_sampling">sampling</code></td>
<td>
<p>if TRUE includes the drawing of a crude-histogram version of the overall distribution (the final log-rank distibution). </p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_weighted">weighted</code></td>
<td>
<p>if TRUE the densities of each co-occurrence is weighted to its overall contribution (proportion of combinations). Nice! to explain the overall distribution.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_legends.cex">legends.cex</code></td>
<td>
<p>the character expansion for legends.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_weights.cex">weights.cex</code></td>
<td>
<p>the character expansion for legends of the weights</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_weights.pos">weights.pos</code></td>
<td>
<p>the position of the weights &quot;middle&quot;=above each curve, &quot;left&quot;, or &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_w.sum.lwd">w.sum.lwd</code></td>
<td>
<p>the line width of the weighted sum line.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_...">...</code></td>
<td>
<p>parameters forwarded to plot.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_rug.size">rug.size</code></td>
<td>
<p>determine the size of rugs made in valorate.plot.sampling.densities.figure</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_sub">sub</code></td>
<td>
<p>specifies the character to include in each plot.</p>
</td></tr>
<tr><td><code id="valorate.plot.sampling.densities_+3A_y.limit">y.limit</code></td>
<td>
<p>specifies the lowest density value. The default is 1e-13. This is useful for log=&quot;y&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the densities of each co-occurrence that shapes the final log-rank distribution for a n1 group size.
<code>valorate.plot.sampling.densities</code> plots all co-occurrences in the same figure whereas <code>valorate.plot.sampling.densities.figure</code> plots all in separated figures.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Victor Trevino <a href="mailto:vtrevino@itesm.mx">vtrevino@itesm.mx</a></p>


<h3>References</h3>

<p>Trevino et al. 2016 <a href="http://bioinformatica.mty.itesm.mx/valorateR">http://bioinformatica.mty.itesm.mx/valorateR</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new.valorate">new.valorate</a></code>.
<code><a href="#topic+valorate.survdiff">valorate.survdiff</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a random population of 100 subjects 
## having 20 events
subjects &lt;- numeric(100)
subjects[sample(100,20)] &lt;- 1
vo &lt;- new.valorate(rank=subjects, sampling.size=100000, verbose=TRUE)

## Not run: valorate.plot.sampling.densities(vo, 5)
## Not run: valorate.plot.sampling.densities(vo, 10)
## Not run: valorate.plot.sampling.densities(vo, 20, weighted=TRUE)

## Not run: valorate.plot.sampling.densities.figure(vo, 5)

</code></pre>

<hr>
<h2 id='valorate.plot.subpop'>PLOT ALL ESTIMATED LOG-RANK DISTRIBUTIONS</h2><span id='topic+valorate.plot.subpop.'></span><span id='topic+valorate.plot.subpop.empirical'></span><span id='topic+valorate.plot.subpop.empirical.to.0'></span><span id='topic+valorate.plot.subpop.empirical.scaled'></span>

<h3>Description</h3>

<p>Plots all log-rank distributions estimated with the same object (different values of n1). This family of plots is commonly used to compare the estimated distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valorate.plot.subpop.empirical(vro, which, 
  type, log, xlim, smooth, legends, 
  density, ylim, ...)

valorate.plot.subpop.empirical.to.0(vro, which, 
  type, log, xlim, smooth, legends, density, ylim, ...)

valorate.plot.subpop.empirical.scaled(vro, which, 
  type, log, xlim, 
  smooth, legends, density, ylim, 
  scale.point, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valorate.plot.subpop_+3A_vro">vro</code></td>
<td>
<p>the valorate object.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_which">which</code></td>
<td>
<p>The values of n1 that will be shown. NULL to plot them all.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_type">type</code></td>
<td>
<p>typical plot parameter: &quot;p&quot;=points, &quot;l&quot;=lines (default), &quot;o&quot;=overlap.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_log">log</code></td>
<td>
<p>typical plot parameter : specify which axis are shown in logarithm base 10.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_xlim">xlim</code></td>
<td>
<p>typical plot parameter.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_ylim">ylim</code></td>
<td>
<p>typical plot parameter.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_smooth">smooth</code></td>
<td>
<p>the strength of density smoothing for display purposes. The default is 10.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_legends">legends</code></td>
<td>
<p>the number of columns in legends. 0 to omit legends.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_density">density</code></td>
<td>
<p>indicates whether all curves should represent density (default to TRUE). FALSE to scale to maximum.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_...">...</code></td>
<td>
<p>arguments passed to plot.</p>
</td></tr>
<tr><td><code id="valorate.plot.subpop_+3A_scale.point">scale.point</code></td>
<td>
<p>a double between 0 and 0.5 (exclusive) that determines the two points in quantiles in which all densities will be 'equalized'. The quantiles are scale.point and 1-scale.point. 0.5 should be avoided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>valorate.plot.subpop.empirical</code> plots all log-rank distributions estimated with the same object (different values of n1) in raw densities and scales.
<code>valorate.plot.subpop.empirical.to.0</code> is similar to <code>valorate.plot.subpop.empirical</code> but shift distributions to 0 and scale horizontal axis to similar limits. 
<code>valorate.plot.subpop.empirical.scaled</code> is similar to <code>valorate.plot.subpop.empirical</code> but scales the distributions to have the same scale.point(s) (in x) for all distributions. It also shifts all distribution to zero. This helps to compare the tendencies of the overall distributions. 
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Victor Trevino <a href="mailto:vtrevino@itesm.mx">vtrevino@itesm.mx</a></p>


<h3>References</h3>

<p>Trevino et al. 2016 <a href="http://bioinformatica.mty.itesm.mx/valorateR">http://bioinformatica.mty.itesm.mx/valorateR</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new.valorate">new.valorate</a></code>.
<code><a href="#topic+valorate.survdiff">valorate.survdiff</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a random population of 100 subjects 
## having 20 events
subjects &lt;- numeric(100)
subjects[sample(100,20)] &lt;- 1
vo &lt;- new.valorate(rank=subjects, sampling.size=100000, verbose=TRUE)

for (i in c(5,10,20,30,40,50)) {
  groups &lt;- numeric(100)
  groups[sample(100,i)] &lt;- 1 
  valorate.survdiff(vo, groups) 
}

## Not run: valorate.plot.subpop.empirical(vo)
## Not run: valorate.plot.subpop.empirical.to.0(vo)

</code></pre>

<hr>
<h2 id='valorate.risk'>ESTIMATES RISK</h2><span id='topic+valorate.risk'></span>

<h3>Description</h3>

<p>Estimates the risk (hazard ratio), and confidence interval of a 'mutated' group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valorate.risk(vro, clusters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valorate.risk_+3A_vro">vro</code></td>
<td>
<p>the valorate object.</p>
</td></tr>
<tr><td><code id="valorate.risk_+3A_clusters">clusters</code></td>
<td>
<p>a numerical or logical vector representing the two survival groups encoded in 1/TRUE for those 'mutated' (in the group of interest) or 1/FALSE for those who not. Basically this value is the 'x' vector in the VALORATE re-formulation. See references.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coxph model depending on clusters is run to establish the risk/hazard ratio.
</p>


<h3>Value</h3>

<p>A number representing the relative risk. The confidence interval, p-value, and the coxph model are included as attributes.
</p>


<h3>Author(s)</h3>

<p>Victor Trevino <a href="mailto:vtrevino@itesm.mx">vtrevino@itesm.mx</a></p>


<h3>References</h3>

<p>Trevino et al. 2016 <a href="http://bioinformatica.mty.itesm.mx/valorateR">http://bioinformatica.mty.itesm.mx/valorateR</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new.valorate">new.valorate</a></code>.
<code><a href="#topic+valorate.survdiff">valorate.survdiff</a></code>.
<code><a href="survival.html#topic+coxph">coxph</a></code> (survival package).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a random population of 100 subjects 
## having 20 events
subjects &lt;- numeric(100)
subjects[sample(100,20)] &lt;- 1
vo &lt;- new.valorate(rank=subjects, sampling.size=100000, verbose=TRUE)

groups &lt;- numeric(100)
groups[sample(100,20)] &lt;- 1  # 20 to likely see some difference
pvr &lt;- valorate.survdiff(vo, groups) 
print(pvr)

valorate.risk(vo, groups)

</code></pre>

<hr>
<h2 id='valorate.survdiff'>ESTIMATES THE P-VALUE AND STATISTICS OF THE LOG-RANK TEST</h2><span id='topic+valorate.survdiff'></span>

<h3>Description</h3>

<p>Estimates the p-value using the VALORATE calculation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valorate.survdiff(vro, clusters, p.func)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valorate.survdiff_+3A_vro">vro</code></td>
<td>
<p>the valorate object.</p>
</td></tr>
<tr><td><code id="valorate.survdiff_+3A_clusters">clusters</code></td>
<td>
<p>a numerical or logical vector representing the two survival groups encoded in 1/TRUE for those 'mutated' (in the group of interest) or 1/FALSE for those who not. Basically this value is the 'x' vector in the VALORATE re-formulation. See references.</p>
</td></tr>
<tr><td><code id="valorate.survdiff_+3A_p.func">p.func</code></td>
<td>
<p>the function that provides the estimation. The default is <a href="#topic+valorate.p.value.sampling">valorate.p.value.sampling</a>. See <a href="#topic+valorate.p.value">valorate.p.value</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main function to estimate the p-value of the difference of two survival curves under the VALORATE algorithm. Because the definition of the survival group as '1' or '0' is arbitrary, the actual calculation is performed over the less frequent group. From clusters and s=sum(clusters), n1 is determined as the min(s, length(clusters)-s). Then a call for prepare.n1 is performed and finally the p-value estimations. The statistics are added as attributes.
</p>


<h3>Value</h3>

<p>the estimated p-value.
</p>


<h3>Author(s)</h3>

<p>Victor Trevino <a href="mailto:vtrevino@itesm.mx">vtrevino@itesm.mx</a></p>


<h3>References</h3>

<p>Trevino et al. 2016 <a href="http://bioinformatica.mty.itesm.mx/valorateR">http://bioinformatica.mty.itesm.mx/valorateR</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new.valorate">new.valorate</a></code>.
<code><a href="#topic+valorate.p.value">valorate.p.value</a></code>.
<code><a href="#topic+valorate.plot.empirical">valorate.plot.empirical</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a random population of 100 subjects 
## having 20 events
subjects &lt;- numeric(100)
subjects[sample(100,20)] &lt;- 1
vo &lt;- new.valorate(rank=subjects, sampling.size=100000, verbose=TRUE)

groups &lt;- numeric(100)
groups[sample(100,4)] &lt;- 1  # only 4 subjects are within the 'mutated' group
pvr &lt;- valorate.survdiff(vo, groups) 
print(pvr)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
