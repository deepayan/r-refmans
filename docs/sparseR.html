<!DOCTYPE html><html><head><title>Help for package sparseR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparseR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sparseR-package'><p>sparseR: Implement ranked sparsity for selecting interactions and polynomials</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#datasets'><p>Data sets</p></a></li>
<li><a href='#EBIC'><p>Custom IC functions for stepwise models</p></a></li>
<li><a href='#effect_plot'><p>Plot relevant effects of a sparseR object</p></a></li>
<li><a href='#get_penalties'><p>Helper function to help set up penalties</p></a></li>
<li><a href='#plot.sparseR'><p>Plot relevant properties of sparseR objects</p></a></li>
<li><a href='#predict.sparseR'><p>Predict coefficients or responses for sparseR object</p></a></li>
<li><a href='#print.sparseR'><p>Print sparseR object</p></a></li>
<li><a href='#sparseR'><p>Fit a ranked-sparsity model with regularized regression</p></a></li>
<li><a href='#sparseR_prep'><p>Preprocess &amp; create a model matrix with interactions + polynomials</p></a></li>
<li><a href='#sparseRBIC_bootstrap'><p>Bootstrap procedure for stepwise regression</p></a></li>
<li><a href='#sparseRBIC_sampsplit'><p>Sample split procedure for stepwise regression</p></a></li>
<li><a href='#sparseRBIC_step'><p>Fit a ranked-sparsity model with forward stepwise RBIC (experimental)</p></a></li>
<li><a href='#step_center_to'><p>Centering numeric data to a value besides their mean</p></a></li>
<li><a href='#summary.sparseR'><p>Summary of sparseR model coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Variable Selection under Ranked Sparsity Principles for
Interactions and Polynomials</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
    An implementation of ranked sparsity methods, including
    penalized regression methods such as the sparsity-ranked lasso, its
    non-convex alternatives, and elastic net, as well as the sparsity-ranked
    Bayesian Information Criterion. As described in Peterson and
    Cavanaugh (2022) &lt;<a href="https://doi.org/10.1007%2Fs10182-021-00431-7">doi:10.1007/s10182-021-00431-7</a>&gt;, ranked
    sparsity is a philosophy with methods primarily useful for
    variable selection in the presence of prior informational
    asymmetry, which occurs in the context of trying to perform variable
    selection in the presence of interactions and/or polynomials. Ultimately,
    this package attempts to facilitate dealing with cumbersome interactions
    and polynomials while not avoiding them entirely. Typically, models
    selected under ranked sparsity principles will also be more transparent,
    having fewer falsely selected interactions and polynomials than other
    methods.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival, knitr, rmarkdown, kableExtra, testthat, covr,
modeldata, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>ncvreg, rlang, magrittr, dplyr, recipes (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://petersonr.github.io/sparseR/">https://petersonr.github.io/sparseR/</a>,
<a href="https://github.com/petersonR/sparseR/">https://github.com/petersonR/sparseR/</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-25</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-26 04:10:58 UTC; petryan</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Andrew Peterson
    <a href="https://orcid.org/0000-0002-4650-5798"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan Andrew Peterson &lt;ryan.a.peterson@cuanschutz.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-26 04:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sparseR-package'>sparseR: Implement ranked sparsity for selecting interactions and polynomials</h2><span id='topic+sparseR-package'></span>

<h3>Description</h3>

<p>The <code>sparseR</code> package implements various techniques for selecting from
a set of interaction and polynomial terms under ranked sparsity. Additional
tools for data pre-processing, post-selection inference, and visualization
are also included.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ryan Andrew Peterson <a href="mailto:ryan.a.peterson@cuanschutz.edu">ryan.a.peterson@cuanschutz.edu</a> (<a href="https://orcid.org/0000-0002-4650-5798">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://petersonr.github.io/sparseR/">https://petersonr.github.io/sparseR/</a>
</p>
</li>
<li> <p><a href="https://github.com/petersonR/sparseR/">https://github.com/petersonR/sparseR/</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='datasets'>Data sets</h2><span id='topic+datasets'></span><span id='topic+cleveland'></span><span id='topic+Z'></span><span id='topic+S'></span><span id='topic+va'></span><span id='topic+hungarian'></span><span id='topic+irlcs_radon_syn'></span><span id='topic+switzerland'></span>

<h3>Description</h3>

<p>Detrano data sets (cleveland, hungarian, switzerland, va);
The Iowa Radon Lung Cancer Study (irlcs_radon_syn): Data simulated to resemble the IRLCS study;
Sheddon survival data (Z: clinical covariates, S:survival outcome)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleveland

hungarian

switzerland

va

irlcs_radon_syn

Z

S
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 303 rows and 14 columns.
</p>
<p>An object of class <code>data.frame</code> with 294 rows and 14 columns.
</p>
<p>An object of class <code>data.frame</code> with 123 rows and 14 columns.
</p>
<p>An object of class <code>data.frame</code> with 200 rows and 14 columns.
</p>
<p>An object of class <code>data.frame</code> with 1027 rows and 16 columns.
</p>
<p>An object of class <code>data.frame</code> with 442 rows and 6 columns.
</p>
<p>An object of class <code>Surv</code> with 442 rows and 2 columns.
</p>


<h3>Source</h3>


<dl>
<dt>Detrano data</dt><dd><p><a href="https://archive.ics.uci.edu/ml/datasets/heart+disease">https://archive.ics.uci.edu/ml/datasets/heart+disease</a></p>
</dd>
<dt>IRLCS data sets</dt><dd><p><a href="https://cheec.uiowa.edu/research/residential-radon-and-lung-cancer-case-control-study">https://cheec.uiowa.edu/research/residential-radon-and-lung-cancer-case-control-study</a></p>
</dd>
<dt>Sheddon</dt><dd><p><a href="https://www.gsea-msigdb.org/gsea/msigdb/cards/SHEDDEN_LUNG_CANCER_POOR_SURVIVAL_A6">https://www.gsea-msigdb.org/gsea/msigdb/cards/SHEDDEN_LUNG_CANCER_POOR_SURVIVAL_A6</a></p>
</dd>
</dl>



<h3>References</h3>


<dl>
<dt>Detrano</dt><dd>
<p>Detrano, R., Janosi, A., Steinbrunn, W., Pfisterer, M., Schmid, J., Sandhu, S., Guppy, K.,
Lee, S., &amp; Froelicher, V. (1989). International application of a new probability algorithm
for the diagnosis of coronary artery disease. American Journal of Cardiology, 64,304&ndash;310.
</p>
</dd>
<dt>IRLCS</dt><dd>
<p>FIELD, R., SMITH, B., STECK, D. et al. Residential radon exposure and lung cancer:
Variation in risk estimates using alternative exposure scenarios. J Expo Sci Environ Epidemiol
12, 197–203 (2002). <a href="https://www.nature.com/articles/7500215">https://www.nature.com/articles/7500215</a>
</p>
</dd>
<dt>Shedden</dt><dd>
<p>Director's Challenge Consortium for the Molecular Classification of Lung Adenocarcinoma, Shedden, K.,
Taylor, J. M., Enkemann, S. A., Tsao, M. S., Yeatman, T. J., Gerald, W. L., Eschrich, S., Jurisica, I.,
Giordano, T. J., Misek, D. E., Chang, A. C., Zhu, C. Q., Strumpf, D., Hanash, S., Shepherd, F. A., Ding,
K., Seymour, L., Naoki, K., Pennell, N., … Beer, D. G. (2008). Gene expression-based survival prediction
in lung adenocarcinoma: a multi-site, blinded validation study. Nature medicine, 14(8), 822–827.
<a href="https://www.nature.com/articles/nm.1790">https://www.nature.com/articles/nm.1790</a>
</p>
</dd>
</dl>


<hr>
<h2 id='EBIC'>Custom IC functions for stepwise models</h2><span id='topic+EBIC'></span><span id='topic+RBIC'></span><span id='topic+RAIC'></span><span id='topic+EBIC.default'></span><span id='topic+RBIC.default'></span><span id='topic+RAIC.default'></span>

<h3>Description</h3>

<p>Custom IC functions for stepwise models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBIC(...)

## Default S3 method:
EBIC(fit, varnames, pen_info, gammafn = NULL, return_df = TRUE, ...)

RBIC(fit, ...)

## Default S3 method:
RBIC(fit, varnames, pen_info, gammafn = NULL, return_df = TRUE, ...)

RAIC(fit, ...)

## Default S3 method:
RAIC(fit, varnames, pen_info, gammafn = NULL, return_df = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EBIC_+3A_...">...</code></td>
<td>
<p>additional args</p>
</td></tr>
<tr><td><code id="EBIC_+3A_fit">fit</code></td>
<td>
<p>a fitted object</p>
</td></tr>
<tr><td><code id="EBIC_+3A_varnames">varnames</code></td>
<td>
<p>names of variables</p>
</td></tr>
<tr><td><code id="EBIC_+3A_pen_info">pen_info</code></td>
<td>
<p>penalty information</p>
</td></tr>
<tr><td><code id="EBIC_+3A_gammafn">gammafn</code></td>
<td>
<p>What to use for gamma in formula</p>
</td></tr>
<tr><td><code id="EBIC_+3A_return_df">return_df</code></td>
<td>
<p>should the deg. freedom be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values for the criterion requested, and the degrees of
freedom (appended to front of vector) if return_df == TRUE.
</p>

<hr>
<h2 id='effect_plot'>Plot relevant effects of a sparseR object</h2><span id='topic+effect_plot'></span><span id='topic+effect_plot.sparseR'></span><span id='topic+effect_plot.sparseRBIC'></span>

<h3>Description</h3>

<p>Plot relevant effects of a sparseR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect_plot(fit, ...)

## S3 method for class 'sparseR'
effect_plot(
  fit,
  coef_name,
  at = c("cvmin", "cv1se"),
  by = NULL,
  by_levels,
  nn = 101,
  plot.args = list(),
  resids = TRUE,
  legend_location = "bottomright",
  ...
)

## S3 method for class 'sparseRBIC'
effect_plot(
  fit,
  coef_name,
  by = NULL,
  by_levels,
  nn = 101,
  plot.args = list(),
  resids = TRUE,
  legend_location = "bottomright",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effect_plot_+3A_fit">fit</code></td>
<td>
<p>a 'sparseR' object</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_coef_name">coef_name</code></td>
<td>
<p>The name of the coefficient to plot along the x-axis</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_at">at</code></td>
<td>
<p>value of lambda to use</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_by">by</code></td>
<td>
<p>the variable(s) involved in the (possible) interaction</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_by_levels">by_levels</code></td>
<td>
<p>values to cut continuous by variable (defaults to 3 quantiles)</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_nn">nn</code></td>
<td>
<p>number of points to plot along prediction line</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_plot.args">plot.args</code></td>
<td>
<p>list of arguments passed to the plot itself</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_resids">resids</code></td>
<td>
<p>should residuals be plotted or not?</p>
</td></tr>
<tr><td><code id="effect_plot_+3A_legend_location">legend_location</code></td>
<td>
<p>location for legend passed to 'legend'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing returned
</p>
<p>Nothing (invisible) returned
</p>

<hr>
<h2 id='get_penalties'>Helper function to help set up penalties</h2><span id='topic+get_penalties'></span>

<h3>Description</h3>

<p>Helper function to help set up penalties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_penalties(
  varnames,
  poly,
  poly_prefix = "poly_",
  int_sep = "\\:",
  pool = FALSE,
  gamma = 0.5,
  cumulative_k = FALSE,
  cumulative_poly = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_penalties_+3A_varnames">varnames</code></td>
<td>
<p>names of the covariates in the model matrix</p>
</td></tr>
<tr><td><code id="get_penalties_+3A_poly">poly</code></td>
<td>
<p>max polynomial considered</p>
</td></tr>
<tr><td><code id="get_penalties_+3A_poly_prefix">poly_prefix</code></td>
<td>
<p>what comes before the polynomial specification in these
varnames?</p>
</td></tr>
<tr><td><code id="get_penalties_+3A_int_sep">int_sep</code></td>
<td>
<p>What denotes the multiplication for interactions?</p>
</td></tr>
<tr><td><code id="get_penalties_+3A_pool">pool</code></td>
<td>
<p>Should polynomials and interactions be pooled?</p>
</td></tr>
<tr><td><code id="get_penalties_+3A_gamma">gamma</code></td>
<td>
<p>How much should the penalty increase with group size (0.5
assumes equal contribution of prior information)</p>
</td></tr>
<tr><td><code id="get_penalties_+3A_cumulative_k">cumulative_k</code></td>
<td>
<p>Should penalties be increased cumulatively as order
interaction increases? (only used if !pool)</p>
</td></tr>
<tr><td><code id="get_penalties_+3A_cumulative_poly">cumulative_poly</code></td>
<td>
<p>Should penalties be increased cumulatively as order
polynomial increases? (only used if !pool)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is primarily a helper function for sparseR, but it may be
useful if doing the model matrix set up by hand.
</p>


<h3>Value</h3>

<p>a list of relevant information for the variables, including:
</p>
<table>
<tr><td><code>penalties</code></td>
<td>
<p>the numeric value of the penalties</p>
</td></tr>
<tr><td><code>vartype</code></td>
<td>
<p>Variable type (main effect, order k interaction, etc)</p>
</td></tr>
<tr><td><code>varname</code></td>
<td>
<p>names of variables</p>
</td></tr>
</table>

<hr>
<h2 id='plot.sparseR'>Plot relevant properties of sparseR objects</h2><span id='topic+plot.sparseR'></span>

<h3>Description</h3>

<p>Plot relevant properties of sparseR objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparseR'
plot(x, plot_type = c("both", "cv", "path"), cols = NULL, log.l = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sparseR_+3A_x">x</code></td>
<td>
<p>a 'sparseR' object</p>
</td></tr>
<tr><td><code id="plot.sparseR_+3A_plot_type">plot_type</code></td>
<td>
<p>should the solution path, CV results, or both be plotted?</p>
</td></tr>
<tr><td><code id="plot.sparseR_+3A_cols">cols</code></td>
<td>
<p>option to specify color of groups</p>
</td></tr>
<tr><td><code id="plot.sparseR_+3A_log.l">log.l</code></td>
<td>
<p>should the x-axis (lambda) be logged?</p>
</td></tr>
<tr><td><code id="plot.sparseR_+3A_...">...</code></td>
<td>
<p>extra plotting options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing returned
</p>

<hr>
<h2 id='predict.sparseR'>Predict coefficients or responses for sparseR object</h2><span id='topic+predict.sparseR'></span><span id='topic+coef.sparseR'></span>

<h3>Description</h3>

<p>Predict coefficients or responses for sparseR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparseR'
predict(object, newdata, lambda, at = c("cvmin", "cv1se"), ...)

## S3 method for class 'sparseR'
coef(object, lambda, at = c("cvmin", "cv1se"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sparseR_+3A_object">object</code></td>
<td>
<p>sparseR object</p>
</td></tr>
<tr><td><code id="predict.sparseR_+3A_newdata">newdata</code></td>
<td>
<p>new data on which to make predictions</p>
</td></tr>
<tr><td><code id="predict.sparseR_+3A_lambda">lambda</code></td>
<td>
<p>a particular value of lambda to predict with</p>
</td></tr>
<tr><td><code id="predict.sparseR_+3A_at">at</code></td>
<td>
<p>a &quot;smart&quot; guess to use for lambda</p>
</td></tr>
<tr><td><code id="predict.sparseR_+3A_...">...</code></td>
<td>
<p>additional arguments passed to predict.ncvreg</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predicted outcomes for 'newdata' (or coefficients)
at specified (or smart) lambda value
</p>

<hr>
<h2 id='print.sparseR'>Print sparseR object</h2><span id='topic+print.sparseR'></span>

<h3>Description</h3>

<p>Print sparseR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparseR'
print(x, prep = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sparseR_+3A_x">x</code></td>
<td>
<p>a sparseR object</p>
</td></tr>
<tr><td><code id="print.sparseR_+3A_prep">prep</code></td>
<td>
<p>Should the SR set-up information be printed as well?</p>
</td></tr>
<tr><td><code id="print.sparseR_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print.ncvreg</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns x invisibly
</p>

<hr>
<h2 id='sparseR'>Fit a ranked-sparsity model with regularized regression</h2><span id='topic+sparseR'></span>

<h3>Description</h3>

<p>Fit a ranked-sparsity model with regularized regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseR(
  formula,
  data,
  family = c("gaussian", "binomial", "poisson", "coxph"),
  penalty = c("lasso", "MCP", "SCAD"),
  alpha = 1,
  ncvgamma = 3,
  lambda.min = 0.005,
  k = 1,
  poly = 1,
  gamma = 0.5,
  cumulative_k = FALSE,
  cumulative_poly = TRUE,
  pool = FALSE,
  ia_formula = NULL,
  pre_process = TRUE,
  model_matrix = NULL,
  y = NULL,
  poly_prefix = "_poly_",
  int_sep = "\\:",
  pre_proc_opts = c("knnImpute", "scale", "center", "otherbin", "none"),
  filter = c("nzv", "zv"),
  extra_opts = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseR_+3A_formula">formula</code></td>
<td>
<p>Names of the terms</p>
</td></tr>
<tr><td><code id="sparseR_+3A_data">data</code></td>
<td>
<p>Data</p>
</td></tr>
<tr><td><code id="sparseR_+3A_family">family</code></td>
<td>
<p>The family of the model</p>
</td></tr>
<tr><td><code id="sparseR_+3A_penalty">penalty</code></td>
<td>
<p>What penalty should be used (lasso, MCP, or SCAD)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_alpha">alpha</code></td>
<td>
<p>The mix of L1 penalty (lower values introduce more L2 ridge
penalty)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_ncvgamma">ncvgamma</code></td>
<td>
<p>The tuning parameter for ncvreg (for MCP or SCAD)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_lambda.min">lambda.min</code></td>
<td>
<p>The minimum value to be used for lambda (as ratio of max,
see ?ncvreg)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_k">k</code></td>
<td>
<p>The maximum order of interactions to consider</p>
</td></tr>
<tr><td><code id="sparseR_+3A_poly">poly</code></td>
<td>
<p>The maximum order of polynomials to consider</p>
</td></tr>
<tr><td><code id="sparseR_+3A_gamma">gamma</code></td>
<td>
<p>The degree of extremity of sparsity rankings (see details)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_cumulative_k">cumulative_k</code></td>
<td>
<p>Should penalties be increased cumulatively as order
interaction increases?</p>
</td></tr>
<tr><td><code id="sparseR_+3A_cumulative_poly">cumulative_poly</code></td>
<td>
<p>Should penalties be increased cumulatively as order
polynomial increases?</p>
</td></tr>
<tr><td><code id="sparseR_+3A_pool">pool</code></td>
<td>
<p>Should interactions of order k and polynomials of order k+1 be
pooled together for calculating the penalty?</p>
</td></tr>
<tr><td><code id="sparseR_+3A_ia_formula">ia_formula</code></td>
<td>
<p>formula to be passed to step_interact (for interactions,
see details)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_pre_process">pre_process</code></td>
<td>
<p>Should the data be preprocessed (if FALSE, must provide
model_matrix)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_model_matrix">model_matrix</code></td>
<td>
<p>A data frame or matrix specifying the full model matrix
(used if !pre_process)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_y">y</code></td>
<td>
<p>A vector of responses (used if !pre_process)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_poly_prefix">poly_prefix</code></td>
<td>
<p>If model_matrix is specified, what is the prefix for
polynomial terms?</p>
</td></tr>
<tr><td><code id="sparseR_+3A_int_sep">int_sep</code></td>
<td>
<p>If model_matrix is specified, what is the separator for
interaction terms?</p>
</td></tr>
<tr><td><code id="sparseR_+3A_pre_proc_opts">pre_proc_opts</code></td>
<td>
<p>List of preprocessing steps (see details)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_filter">filter</code></td>
<td>
<p>The type of filter applied to main effects + interactions</p>
</td></tr>
<tr><td><code id="sparseR_+3A_extra_opts">extra_opts</code></td>
<td>
<p>A list of options for all preprocess steps (see details)</p>
</td></tr>
<tr><td><code id="sparseR_+3A_...">...</code></td>
<td>
<p>Additional arguments (passed to fitting function)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Selecting <code>gamma</code>: higher values of gamma will penalize &quot;group&quot; size more. By
default, this is set to 0.5, which yields equal contribution of prior
information across orders of interactions/polynomials (this is a good
default for most settings).
</p>
<p>Additionally, setting <code>cumulative_poly</code> or <code>cumulative_k</code> to <code>TRUE</code> increases
the penalty cumulatively based on the order of either polynomial or
interaction.
</p>
<p>The options that can be passed to <code>pre_proc_opts</code> are: - knnImpute (should
missing data be imputed?) - scale (should data be standardized)? - center
(should data be centered to the mean or another value?) - otherbin (should
factors with low prevalence be combined?) - none (should no preprocessing be
done? can also specify a null object)
</p>
<p>The options that can be passed to <code>extra_opts</code> are: - centers (named numeric
vector which denotes where each covariate should be centered) - center_fn
(alternatively, a function can be specified to calculate center such as <code>min</code>
or <code>median</code>) - freq_cut, unique_cut (see ?step_nzv - these get used by the
filtering steps) - neighbors (the number of neighbors for knnImpute) -
one_hot (see ?step_dummy), this defaults to cell-means coding which can be
done in regularized regression (change at your own risk) - raw (should
polynomials not be orthogonal? defaults to true because variables are
centered and scaled already by this point by default)
</p>
<p><code>ia_formula</code> will by default interact all variables with each other up
to order k. If specified, ia_formula will be passed as the <code>terms</code> argument
to <code>recipes::step_interact</code>, so the help documentation for that function
can be investigated for further assistance in specifying specific
interactions.
</p>


<h3>Value</h3>

<p>an object of class <code>sparseR</code> containing the following:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>the fit object returned by <code>ncvreg</code></p>
</td></tr>
<tr><td><code>srprep</code></td>
<td>
<p>a <code>recipes</code> object used to prep the data</p>
</td></tr>
<tr><td><code>pen_factors</code></td>
<td>
<p>the factor multiple on penalties for ranked sparsity</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>all coefficients and penalty factors at minimum CV lambda</p>
</td></tr>
<tr><td><code>results_summary</code></td>
<td>
<p>a tibble of summary results at minimum CV lambda</p>
</td></tr>
<tr><td><code>results1se</code></td>
<td>
<p>all coefficients and penalty factors at lambda_1se</p>
</td></tr>
<tr><td><code>results1se_summary</code></td>
<td>
<p>a tibble of summary results at lambda_1se</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the (unprocessed) data</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family argument (for non-normal, eg. poisson)</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>a list containing meta-info about the procedure</p>
</td></tr>
</table>


<h3>References</h3>

<p>For fitting functionality, the <code>ncvreg</code> package is used; see
Breheny, P. and Huang, J. (2011) Coordinate descent algorithms for nonconvex
penalized regression, with applications to biological feature selection. Ann.
Appl. Statist., 5: 232-253.
</p>

<hr>
<h2 id='sparseR_prep'>Preprocess &amp; create a model matrix with interactions + polynomials</h2><span id='topic+sparseR_prep'></span>

<h3>Description</h3>

<p>Preprocess &amp; create a model matrix with interactions + polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseR_prep(
  formula,
  data,
  k = 1,
  poly = 1,
  pre_proc_opts = c("knnImpute", "scale", "center", "otherbin", "none"),
  ia_formula = NULL,
  filter = c("nzv", "zv"),
  extra_opts = list(),
  family = "gaussian"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseR_prep_+3A_formula">formula</code></td>
<td>
<p>A formula of the main effects + outcome of the model</p>
</td></tr>
<tr><td><code id="sparseR_prep_+3A_data">data</code></td>
<td>
<p>A required data frame or tibble containing the variables in
<code>formula</code></p>
</td></tr>
<tr><td><code id="sparseR_prep_+3A_k">k</code></td>
<td>
<p>Maximum order of interactions to <em>numeric</em> variables</p>
</td></tr>
<tr><td><code id="sparseR_prep_+3A_poly">poly</code></td>
<td>
<p>the maximum order of polynomials to consider</p>
</td></tr>
<tr><td><code id="sparseR_prep_+3A_pre_proc_opts">pre_proc_opts</code></td>
<td>
<p>A character vector specifying methods for preprocessing
(see details)</p>
</td></tr>
<tr><td><code id="sparseR_prep_+3A_ia_formula">ia_formula</code></td>
<td>
<p>formula to be passed to step_interact (for interactions,
see details)</p>
</td></tr>
<tr><td><code id="sparseR_prep_+3A_filter">filter</code></td>
<td>
<p>which methods should be used to filter out variables with
(near) zero variance? (see details)</p>
</td></tr>
<tr><td><code id="sparseR_prep_+3A_extra_opts">extra_opts</code></td>
<td>
<p>extra options to be used for preprocessing</p>
</td></tr>
<tr><td><code id="sparseR_prep_+3A_family">family</code></td>
<td>
<p>family passed from sparseR</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pre_proc_opts acts as a wrapper for the corresponding procedures in the
<code>recipes</code> package. The currently supported options that can be passed to
pre_proc_opts are: knnImpute: Should k-nearest-neighbors be performed (if
necessary?) scale: Should variables be scaled prior to creating interactions
(does not scale factor variables or dummy variables) center: Should variables
be centered (will not center factor variables or dummy variables ) otherbin:
</p>
<p><code>ia_formula</code> will by default interact all variables with each other up
to order k. If specified, ia_formula will be passed as the <code>terms</code> argument
to <code>recipes::step_interact</code>, so the help documentation for that function
can be investigated for further assistance in specifying specific
interactions.
</p>
<p>The methods specified in filter are important; filtering is necessary to cut
down on extraneous polynomials and interactions (in cases where they really
don't make sense). This is true, for instance, when using dummy variables in
polynomials , or when using interactions of dummy variables that relate to
the same categorical variable.
</p>


<h3>Value</h3>

<p>an object of class <code>recipe</code>; see <code><a href="recipes.html#topic+recipe">recipes::recipe()</a></code>
</p>

<hr>
<h2 id='sparseRBIC_bootstrap'>Bootstrap procedure for stepwise regression</h2><span id='topic+sparseRBIC_bootstrap'></span>

<h3>Description</h3>

<p>Runs bootstrap on models selection procedure using RBIC to
find bootstrapped standard error (smoothed, see Efron 2014)
as well as selection percentage across candidate variables.
(experimental)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseRBIC_bootstrap(srbic_fit, B = 100, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseRBIC_bootstrap_+3A_srbic_fit">srbic_fit</code></td>
<td>
<p>An object fitted by sparseRBIC_step</p>
</td></tr>
<tr><td><code id="sparseRBIC_bootstrap_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples</p>
</td></tr>
<tr><td><code id="sparseRBIC_bootstrap_+3A_quiet">quiet</code></td>
<td>
<p>Should the display of a progress bar be silenced?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>a tibble containing coefficients, p-values, selection pct</p>
</td></tr>
<tr><td><code>bootstraps</code></td>
<td>
<p>a tibble of bootstrapped coefficients</p>
</td></tr>
</table>

<hr>
<h2 id='sparseRBIC_sampsplit'>Sample split procedure for stepwise regression</h2><span id='topic+sparseRBIC_sampsplit'></span>

<h3>Description</h3>

<p>Runs multiple on models selection procedures using RBIC to
achieve valid inferential results post-selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseRBIC_sampsplit(srbic_fit, S = 100, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseRBIC_sampsplit_+3A_srbic_fit">srbic_fit</code></td>
<td>
<p>An object fitted by sparseRBIC_step</p>
</td></tr>
<tr><td><code id="sparseRBIC_sampsplit_+3A_s">S</code></td>
<td>
<p>Number of splitting iterations</p>
</td></tr>
<tr><td><code id="sparseRBIC_sampsplit_+3A_quiet">quiet</code></td>
<td>
<p>Should the display of a progress bar be silenced?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>a tibble containing coefficients, p-values, selection pct</p>
</td></tr>
<tr><td><code>splits</code></td>
<td>
<p>a tibble of different split-based coefficients</p>
</td></tr>
</table>

<hr>
<h2 id='sparseRBIC_step'>Fit a ranked-sparsity model with forward stepwise RBIC (experimental)</h2><span id='topic+sparseRBIC_step'></span>

<h3>Description</h3>

<p>Fit a ranked-sparsity model with forward stepwise RBIC (experimental)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseRBIC_step(
  formula,
  data,
  family = c("gaussian", "binomial", "poisson"),
  k = 1,
  poly = 1,
  ic = c("RBIC", "RAIC", "BIC", "AIC", "EBIC"),
  hier = c("strong", "weak", "none"),
  sequential = (hier[1] != "none"),
  cumulative_k = FALSE,
  cumulative_poly = TRUE,
  pool = FALSE,
  ia_formula = NULL,
  pre_process = TRUE,
  model_matrix = NULL,
  y = NULL,
  poly_prefix = "_poly_",
  int_sep = "\\:",
  pre_proc_opts = c("knnImpute", "scale", "center", "otherbin", "none"),
  filter = c("nzv", "zv"),
  extra_opts = list(),
  trace = 0,
  message = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseRBIC_step_+3A_formula">formula</code></td>
<td>
<p>Names of the terms</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_data">data</code></td>
<td>
<p>Data</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_family">family</code></td>
<td>
<p>The family of the model</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_k">k</code></td>
<td>
<p>The maximum order of interactions to consider</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_poly">poly</code></td>
<td>
<p>The maximum order of polynomials to consider</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_ic">ic</code></td>
<td>
<p>The information criterion to use</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_hier">hier</code></td>
<td>
<p>Should hierarchy be enforced (weak or strong)? Must be set
with sequential == TRUE (see details)</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_sequential">sequential</code></td>
<td>
<p>Should the main effects be considered first, orders
sequentially added/considered?</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_cumulative_k">cumulative_k</code></td>
<td>
<p>Should penalties be increased cumulatively as order
interaction increases?</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_cumulative_poly">cumulative_poly</code></td>
<td>
<p>Should penalties be increased cumulatively as order
polynomial increases?</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_pool">pool</code></td>
<td>
<p>Should interactions of order k and polynomials of order k+1 be
pooled together for calculating the penalty?</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_ia_formula">ia_formula</code></td>
<td>
<p>formula to be passed to step_interact via terms argument</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_pre_process">pre_process</code></td>
<td>
<p>Should the data be preprocessed (if FALSE, must provide
model_matrix)</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_model_matrix">model_matrix</code></td>
<td>
<p>A data frame or matrix specifying the full model matrix
(used if !pre_process)</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_y">y</code></td>
<td>
<p>A vector of responses (used if !pre_process)</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_poly_prefix">poly_prefix</code></td>
<td>
<p>If model_matrix is specified, what is the prefix for
polynomial terms?</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_int_sep">int_sep</code></td>
<td>
<p>If model_matrix is specified, what is the separator for
interaction terms?</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_pre_proc_opts">pre_proc_opts</code></td>
<td>
<p>List of preprocessing steps (see details)</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_filter">filter</code></td>
<td>
<p>The type of filter applied to main effects + interactions</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_extra_opts">extra_opts</code></td>
<td>
<p>A list of options for all preprocess steps (see details)</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_trace">trace</code></td>
<td>
<p>Should intermediate results of model selection process be output</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_message">message</code></td>
<td>
<p>should experimental message be suppressed</p>
</td></tr>
<tr><td><code id="sparseRBIC_step_+3A_...">...</code></td>
<td>
<p>additional arguments for running stepwise selection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mirrors <code>sparseR</code> but uses stepwise selection guided by RBIC.
</p>
<p>Additionally, setting <code>cumulative_poly</code> or <code>cumulative_k</code> to <code>TRUE</code> increases
the penalty cumulatively based on the order of either polynomial or
interaction.
</p>
<p>The <code>hier</code> hierarchy enforcement will only work if <code>sequential == TRUE</code>, and
notably will only consider the &quot;first gen&quot; hierarchy, that is, that all
main effects which make up an interaction are already in the model. It
is therefore possible for a third order interaction (x1:x2:x3) to
enter a model without x1:x2 or x2:x3, so long as x1, x2, and x3 are all
in the model.
</p>
<p>The options that can be passed to <code>pre_proc_opts</code> are:
</p>

<ul>
<li><p> knnImpute (should
missing data be imputed?)
</p>
</li>
<li><p> scale (should data be standardized)?
</p>
</li>
<li><p> center
(should data be centered to the mean or another value?)
</p>
</li>
<li><p> otherbin (should
factors with low prevalence be combined?)
</p>
</li>
<li><p> none (should no preprocessing be
done? can also specify a null object)
</p>
</li></ul>

<p>The options that can be passed to <code>extra_opts</code> are:
</p>

<ul>
<li><p> centers (named numeric
vector which denotes where each covariate should be centered)
</p>
</li>
<li><p> center_fn
(alternatively, a function can be specified to calculate center such as <code>min</code>
or <code>median</code>)
</p>
</li>
<li><p> freq_cut, unique_cut (see ?step_nzv - these get used by the
filtering steps)
</p>
</li>
<li><p> neighbors (the number of neighbors for knnImpute)
</p>
</li>
<li><p> one_hot (see ?step_dummy), this defaults to cell-means coding which can be
done in regularized regression (change at your own risk)
</p>
</li>
<li><p> raw (should polynomials not be orthogonal? defaults to true because variables are
centered and scaled already by this point by default)
</p>
</li></ul>



<h3>Value</h3>

<p>an object of class <code>sparseRBIC</code> containing the following:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>the final fit object</p>
</td></tr>
<tr><td><code>srprep</code></td>
<td>
<p>a <code>recipes</code> object used to prep the data</p>
</td></tr>
<tr><td><code>pen_info</code></td>
<td>
<p>coefficient-level variable counts, types + names</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the (unprocessed) data</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family argument (for non-normal, eg. poisson)</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>a list containing meta-info about the procedure</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>the IC for each fit and respective terms included</p>
</td></tr>
</table>

<hr>
<h2 id='step_center_to'>Centering numeric data to a value besides their mean</h2><span id='topic+step_center_to'></span><span id='topic+tidy.step_center_to'></span>

<h3>Description</h3>

<p>'step_center_to' generalizes 'step_center' to allow for a different function
than the 'mean' function to calculate centers. It creates a *specification*
of a recipe step that will normalize numeric data to have a 'center' of zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_center_to(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  centers = NULL,
  center_fn = mean,
  na_rm = TRUE,
  skip = FALSE,
  id = rand_id("center_to")
)

## S3 method for class 'step_center_to'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_center_to_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the sequence of
operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_center_to_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which variables are
affected by the step. See [selections()] for more details. For the 'tidy'
method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_center_to_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are created.</p>
</td></tr>
<tr><td><code id="step_center_to_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for preprocessing have
been estimated.</p>
</td></tr>
<tr><td><code id="step_center_to_+3A_centers">centers</code></td>
<td>
<p>A named numeric vector of centers. This is 'NULL' until
computed by [prep.recipe()] (or it can be specified as a named
numeric vector as well?).</p>
</td></tr>
<tr><td><code id="step_center_to_+3A_center_fn">center_fn</code></td>
<td>
<p>a function to be used to calculate where the center should be</p>
</td></tr>
<tr><td><code id="step_center_to_+3A_na_rm">na_rm</code></td>
<td>
<p>A logical value indicating whether 'NA' values should be removed
during computations.</p>
</td></tr>
<tr><td><code id="step_center_to_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe is baked by
[bake.recipe()]? While all operations are baked when [prep.recipe()] is
run, some operations may not be able to be conducted on new data (e.g.
processing the outcome variable(s)). Care should be taken when using 'skip
= TRUE' as it may affect the computations for subsequent operations</p>
</td></tr>
<tr><td><code id="step_center_to_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_center_to_+3A_x">x</code></td>
<td>
<p>A 'step_center_to' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Centering data means that the average of a variable is subtracted
from the data. 'step_center_to' estimates the variable centers from the
data used in the 'training' argument of 'prep.recipe'. 'bake.recipe' then
applies the centering to new data sets using these centers.
</p>


<h3>Value</h3>

<p>An updated version of 'recipe' with the new step added to the
sequence of existing steps (if any). For the 'tidy' method, a tibble with
columns 'terms' (the selectors or variables selected) and 'value' (the
centers).
</p>


<h3>See Also</h3>

<p>[recipe()] [prep.recipe()] [bake.recipe()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biomass, package = "modeldata")

biomass_tr &lt;- biomass[biomass$dataset == "Training",]
biomass_te &lt;- biomass[biomass$dataset == "Testing",]

rec &lt;- recipes::recipe(
 HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
 data = biomass_tr)

center_trans &lt;- rec %&gt;%
  step_center_to(carbon, contains("gen"), -hydrogen)

center_obj &lt;- recipes::prep(center_trans, training = biomass_tr)

transformed_te &lt;- recipes::bake(center_obj, biomass_te)

biomass_te[1:10, names(transformed_te)]
transformed_te

recipes::tidy(center_trans)
recipes::tidy(center_obj)
</code></pre>

<hr>
<h2 id='summary.sparseR'>Summary of sparseR model coefficients</h2><span id='topic+summary.sparseR'></span>

<h3>Description</h3>

<p>Summary of sparseR model coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sparseR'
summary(object, lambda, at = c("cvmin", "cv1se"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sparseR_+3A_object">object</code></td>
<td>
<p>a sparseR object</p>
</td></tr>
<tr><td><code id="summary.sparseR_+3A_lambda">lambda</code></td>
<td>
<p>a particular value of lambda to predict with</p>
</td></tr>
<tr><td><code id="summary.sparseR_+3A_at">at</code></td>
<td>
<p>a &quot;smart&quot; guess to use for lambda</p>
</td></tr>
<tr><td><code id="summary.sparseR_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to summary.ncvreg</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'summary.ncvreg' at specified or smart value of
lambda.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
