<!DOCTYPE html><html><head><title>Help for package SmoothWin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SmoothWin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#expWeight'>
<p>This function computes the smooth windowing weights</p></a></li>
<li><a href='#plot.SmoothWin'>
<p>Plot function for the SmoothWin object</p></a></li>
<li><a href='#SmoothWin'>
<p>Implementation of the soft windowing for linear models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-07-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Hamed Haselimashhadi &lt;hamedhm@ebi.ac.uk&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hamed Haselimashhadi &lt;hamedhm@ebi.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Description:</td>
<td>The main function in the package utilizes a windowing function in the form of an exponential weighting function to linear models. The bandwidth and sharpness of the window are controlled by two parameters. Then, a series of tests are used to identify the right parameters of the window (see Hamed Haselimashhadi et al (2019) <a href="https://www.biorxiv.org/content/10.1101/656678v1">https://www.biorxiv.org/content/10.1101/656678v1</a>).</td>
</tr>
<tr>
<td>Title:</td>
<td>Soft Windowing on Linear Regression</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-27 18:35:10 UTC; My</td>
</tr>
<tr>
<td>Imports:</td>
<td>nlme, Rfast</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://hamedhaseli.webs.com">http://hamedhaseli.webs.com</a>, <a href="https://www.mousephenotype.org/">https://www.mousephenotype.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-27 21:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='expWeight'>
This function computes the smooth windowing weights
</h2><span id='topic+expWeight'></span>

<h3>Description</h3>

<p>The symmetric weight generating function (SWGF). This function computes the exponential weights/kernel (soft windowing weights) for different shapes (k)  and bandwidth (l) and plots the weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expWeight(
      t                        ,
      k                        ,
      l                        ,
      m = 0                    ,
      direction = c(1, 1)      ,
      plot = FALSE             ,
      zeroCompensation = 0     ,
      cdf   = plogis           ,
      progress         = FALSE ,
      ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expWeight_+3A_t">t</code></td>
<td>

<p>Vector of numeric time. A vector of positive continuous values for time 
</p>
</td></tr>
<tr><td><code id="expWeight_+3A_k">k</code></td>
<td>

<p>A single positive value for sharpness
</p>
</td></tr>
<tr><td><code id="expWeight_+3A_l">l</code></td>
<td>

<p>A single non-negative value for bandwidth
</p>
</td></tr>
<tr><td><code id="expWeight_+3A_m">m</code></td>
<td>

<p>Vector of indices. The index of the modes on 't' (modes are the peak of the windows)
</p>
</td></tr>  
<tr><td><code id="expWeight_+3A_direction">direction</code></td>
<td>

<p>Vector of two numeric values. A vector of the form on (Left,right). The first element specifies the speed of expansion of the window(s) from the left and the second value for the right expansion. Setting to (0,1) and (1,0) lead to right and left expansions of the windows respectively. Default (1,1) that is the window(s) expand symmetrically from both sides. 
</p>
</td></tr>
<tr><td><code id="expWeight_+3A_plot">plot</code></td>
<td>

<p>Logical flag. Setting to TRUE shows a plot of the weights
</p>
</td></tr>
<tr><td><code id="expWeight_+3A_zerocompensation">zeroCompensation</code></td>
<td>

<p>Single non-negative value. Setting to any non-negative value would replace all (weights =&lt; zeroCompensation) with zeroCompensation. Default 0 (zero)
</p>
</td></tr>
<tr><td><code id="expWeight_+3A_cdf">cdf</code></td>
<td>

<p>A cdf function preferably symmetric. The cdf function is used for the (window) weight generating function. The function must have two parameters precisely a location such as mean and a scale. Standard cdf functions such as pnorm, pcauchy and plogis (default) can be used. For an example of custom made function we define uniform function as below:<br /><br />
</p>
<p style="text-align: center;"><code class="reqn">
      punif0 = function(x,mean=0.5,sd=sqrt(1/12)){
             a = mean - sqrt(3) *sd;
             b = mean + sqrt(3) *sd;
             r =  punif(q = x,min = a,max = b) ;
             return(r)    
          }
    </code>
</p>

</td></tr>
<tr><td><code id="expWeight_+3A_progress">progress</code></td>
<td>

<p>Logical flag. Setting to TRUE shows the progress of the function
</p>
</td></tr>
<tr><td><code id="expWeight_+3A_...">...</code></td>
<td>

<p>Other parameters that can be passed to the 'plot()' function such as pch, colour etc.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of weights
</p>


<h3>Author(s)</h3>

<p>Hamed Haselimashhadi &lt;hamedhm@ebi.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SmoothWin">SmoothWin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  par(mfrow = c(4, 1))
  ##################################################
  # Example 1 - no merging happends between windows
  ##################################################
  weight = expWeight(
    t = 1:100                                       ,
    k = 5                                           ,
    l = 10                                          ,
    m = c(25, 50, 75)                               ,
    plot = TRUE                                     ,
    ### Passed parameters to the plot function
    type = 'l'                                      ,
    lty = 2                                         ,
    lwd = 3                                         ,
    main = '1. If windows do not intersect, then wont merge! (l=10, k=5)'
  )
  
  ##################################################
  # Example 2 - merging in windows
  ##################################################
  weight = expWeight(
    t = 1:100                                       ,
    k = 5                                           ,
    l = 15                                          ,
    m = c(25, 50, 75)                               ,
    plot = TRUE                                     ,
    ### Passed parameters to the plot function
    type = 'l'                                      ,
    lty = 2                                         ,
    lwd = 3                                         ,
    main = '2. If windows intersect, then merge! (l=15, k=5)'
  )
  
  ##################################################
  # Example 3.1  - partial merging in windows
  ##################################################
  weight = expWeight(
    t = 1:100                                       ,
    k = 1                                           ,
    l = 12                                          ,
    m = c(25, 50, 75)                               ,
    plot = TRUE                                     ,
    ### Passed parameters to the plot function
    type = 'l'                                      ,
    lty = 2                                         ,
    lwd = 3                                         ,
    main = '3.1 If windows intersect with small k, then partially merge! (l=12, k=1)'
  )
  
  ##################################################
  # Example 3.2  - partial merging in windows
  ##################################################
    weight = expWeight(
    t = 1:100                                       ,
    k = .1                                           ,
    l = 12                                          ,
    m = c(25, 50, 75)                               ,
    plot = TRUE                                     ,
    ### Passed parameters to the plot function
    type = 'l'                                      ,
    lty = 2                                         ,
    lwd = 3                                         ,
    main = '3.2 If windows intersect with small k, then partially merge! (l=12, k=0.1)'
  )
  
</code></pre>

<hr>
<h2 id='plot.SmoothWin'>
Plot function for the SmoothWin object
</h2><span id='topic+plot.SmoothWin'></span>

<h3>Description</h3>

<p>This function plots a SmoothWin object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'SmoothWin'
plot(x, 
                           ylab   = 'Response'              , 
                           xlab   = 'Time (continuous)'     ,
                           sub    = NULL                    ,
                           col    = NULL                    , 
                           digits = 2                       , 
                           ...
                           )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SmoothWin_+3A_x">x</code></td>
<td>

<p>SmoothWin object
</p>
</td></tr>
<tr><td><code id="plot.SmoothWin_+3A_ylab">ylab</code></td>
<td>

<p>Label on the y axis. Default 'Response'
</p>
</td></tr>
<tr><td><code id="plot.SmoothWin_+3A_xlab">xlab</code></td>
<td>

<p>Label on the x axis. Default 'Time (continuous)'
</p>
</td></tr>  
<tr><td><code id="plot.SmoothWin_+3A_sub">sub</code></td>
<td>

<p>See the 'sub' parameter in 'plot()' function. If left NULL then some information about the final window will be shown. Default NULL
</p>
</td></tr>
<tr><td><code id="plot.SmoothWin_+3A_col">col</code></td>
<td>

<p>Colour parameter for the points. Set to NULL to use the default colouring (spectrum colouring). Default NULL
</p>
</td></tr>
<tr><td><code id="plot.SmoothWin_+3A_digits">digits</code></td>
<td>

<p>The number of visible digits for l, k and SWS. Default 2
</p>
</td></tr>
<tr><td><code id="plot.SmoothWin_+3A_...">...</code></td>
<td>

<p>Optional parameters that can be passed to the 'plot'/'qqPlot' function. See 'car' package for the qqPlot function
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hamed Haselimashhadi &lt;hamedhm@ebi.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SmoothWin">SmoothWin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	example(SmoothWin)
</code></pre>

<hr>
<h2 id='SmoothWin'>
Implementation of the soft windowing for linear models
</h2><span id='topic+SmoothWin'></span>

<h3>Description</h3>

<p>Implementation of the (symmetric) soft windowing on a range of methods/models by imposing weights on the model.<br /><br />
- The function accepts a model fit, such as 'lm', 'lme', 'glm' etc., as the input and fits a window to it.<br /><br />
- The parameters &quot;k&quot; and &quot;l&quot; control the shape and bandwidth of the windowing function respectively.<br /><br />
- There are several other parameters to cope with the different scenarios/models/window shapes.<br /><br />
- The default settings of the function is adapted to International Mouse Phenotyping Consortium (IMPC) statistical pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SmoothWin(object                                          ,
         data                                             ,
         t                                                ,
         m                                                ,
         l = function(ignore.me.in.default) {
           r = SmoothWin:::lseq(
             from = 1                                     ,
             to = max(abs(t[m] - min(t, na.rm = TRUE))    , 
             abs(t[m] - max(t, na.rm = TRUE)), 1)         ,
             length.out = min(500, max(1, diff(range(
               t,na.rm = TRUE
             ))))
           )
           r = unique(round(r))
           return(r)
         }                                                ,
         k = SmoothWin:::lseq(from = .5                   ,
                              to = 10                     ,
                              length.out = 50)            ,
         min.obs   = function(ignore.me.in.default) {
           lutm = length(unique(t[m]))
           r = ifelse(lutm &gt; 1, 35, max(pi * sqrt(length(t)), 35))
           r = max(r * lutm, length(m), na.rm = TRUE)
           r = min(r       , length(t), na.rm = TRUE)
           return(r)
         }                                                ,
         direction = c(1, 1)                              ,
         weightFUN = function(x) {
           x
         }                                                ,
         residFun = function(x) {
           resid(x)
         }                                                ,
         predictFun = function(x) {
           predict(x)
         }                                                ,
         weightORthreshold = 'weight'                     ,
         cdf = plogis                                     ,
         check = 2                                        ,
         sensitivity   = c(1, 1, 1, 0)                    ,
         pvalThreshold = c(0, 0, 0, 0)                    ,
         threshold     = sqrt(.Machine$double.eps) * 10   ,
         zeroCompensation = 0                             ,
         messages      = TRUE                             ,
         seed          = NULL                             ,
         simple.output = FALSE                            ,
         debug         = FALSE                            ,
         ...) 
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SmoothWin_+3A_object">object</code></td>
<td>

<p>The fitted model. The object must support 'update(weights =)'. See examples
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_data">data</code></td>
<td>

<p>data.frame. Input data that is used to fit the initial model
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_t">t</code></td>
<td>

<p>Vector of (numeric) time values.
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_m">m</code></td>
<td>

<p>Vector of integers (peaks). Mode indices on the time component. For example 10, 11, 12. Note that it is different from t[10], t[11], t[12]
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_l">l</code></td>
<td>

<p>Vector of numeric values for the bandwidth parameter, l. The default uses the maximum distance of the modes (t[m]) from the time boundaries, max(max(t)-t[m],t[m]-min(t)) split on 500 points on the logarithmic scale.
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_k">k</code></td>
<td>

<p>Vector of numeric values for the shape parameter, k. The default uses 50 splits of the values from 0.5 to 10 on the logarithmic scale.
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_min.obs">min.obs</code></td>
<td>

<p>Single value. The minimum observations/sum weight scores (SWS) that must be in the total window(s). The default uses the following steps.<br /><br />
1. If there are more than one modes (peaks) in the data, then: 35*(the number of the unique modes)<br /><br />
2. If there is a single mode in the data, then: max(pi * sqrt(length(t)), 35)<br /><br />
* min.obs must not be less than the total number of observations in the mode time(s). For example, it can not be less than the number of mutant animals in the IMPC application.<br /><br />
** to function properly, min.obs should be less than the total number of observations<br /><br />
*** min.obs is applied on the total number of observations on all windows NOT each single window<br /><br />
**** if weightORthreshold='weight' then min.obs will be evaluated against SWS<br /><br />
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_direction">direction</code></td>
<td>

<p>Vector of two non-negative values. A non-negative vector of the form c(Left,right), for example c(1,1) [default] or c(0.5,0.5) or c(0,1). The first element specifies the speed of expansion of the window(s) from the left and the second value for the right expansion. Setting to c(0,1) and c(1,0) lead to right and left expansions of the window(s) respectively. Default c(1,1) that is the window(s) expand symmetrically from both sides. 
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_weightfun">weightFUN</code></td>
<td>

<p>Weight function. By default, a vector of weights called &quot;ModelWeight&quot; is passed to this function. See the examples. 
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_residfun">residFun</code></td>
<td>

<p>Residual computation function. The default is 'resid()'. However, the the user can define its own function. Note that the input of the function is the model object. The default is residFun = function(object){resid(object)}
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_predictfun">predictFun</code></td>
<td>

<p>Similar to residFun but instead defines the 'predict()' function. The default is predictFun = function(object){predict(object)}
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_weightorthreshold">weightORthreshold</code></td>
<td>

<p>select between 'weight' (default) or 'threshold'. If set to 'weight' then the sum of weights (Sum Weight Score (SWS)) would be used as the total number of (active) observations in the window, otherwise, total number of weights (count of weights) that are greater than a threshold (see 'threshold' below) (count weights&gt;=threshold) would be used for the total number of samples in the window (see 'threshold').
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_cdf">cdf</code></td>
<td>

<p>A cdf function preferably symmetric. The cdf function is used for the (window) weight generating function (WGF). The cdf function must have two parameters precisely a location such as mean and a scale. Standard cdf functions such as 'pnorm', 'pcauchy' and 'plogis' (default) can be used. For an example of custom made function we define uniform function as below:<br /><br />
<code class="reqn">punif0 = function(x,mean=.5,sd=sqrt(1/12)){
         a = mean - sqrt(3) *sd; 
         b = mean + sqrt(3) *sd; 
      r =  punif(q = x,min = a,max = b);  
      return(r)
    }
    </code>
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_check">check</code></td>
<td>

<p>Single integer in {0,1,2}: <br /><br />
- check=1, the function selects the times (t) with more than one observations. Further, the function only selects the values with weights greater than the 'threshold' (see threshold below). Mostly useful in fitting linear mixed model<br /><br />
- check=2 (default), the function only selects the values with weights greater than the 'threshold' parameter<br /><br /> 
- check=0, disables all checks
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_sensitivity">sensitivity</code></td>
<td>

<p>(Default window selection criteria) Vector of four values (m, v, m*v, normality_test). For example (default) c(1,1,1,0) specifies the same weights for mean, variance, mean*variance interaction and zero weight for the test of normality (shapiro.test) in determining the optimal (final) window. We should stress that the window size is calculated by detecting the changes amongst the consecutive means (two sample t.test) and variances (two sample var.test) (as well as the normality of the first set) from each of predictFun() and residFun() combined together. For example, (m, v, m*v, normality_test) is calculated for predictFun() and the same for residFun(), then two means are combined under the 'sensitivity'[1]; and the same for variance, interactions and the normality.
</p>
</td></tr>  
<tr><td><code id="SmoothWin_+3A_pvalthreshold">pvalThreshold</code></td>
<td>

<p>Vector of four values. It would be used as the significant level for the mean, variation and normality tests (for more details see 'sensitivity' above). If all zero (default) or (all) negative (&lt;= 0) then the internal adaptive method (sensitivity - see above) would be used.
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_threshold">threshold</code></td>
<td>

<p>Single positive value. The minimum value for weights before removing the corresponded samples, given check=1 or check=2 and also in 'weightORthreshold'. Default sqrt(.Machine$double.eps)*10 ~ 10^-7
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_zerocompensation">zeroCompensation</code></td>
<td>

<p>Single non-negative value. Setting to any non-negative value would replace all (weights =&lt; zeroCompensation) with 'zeroCompensation'. Useful for algorithms that have difficulties with zero. Default 0.
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_messages">messages</code></td>
<td>

<p>Logical value. Set to TRUE (default) to see the errors and warnings
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_seed">seed</code></td>
<td>

<p>seed. Default NULL
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_simple.output">simple.output</code></td>
<td>

<p>Logical flag. Setting to TRUE leads to not exporting the list of models for l and k. Useful for preventing memory overflow. Default FALSE
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_debug">debug</code></td>
<td>

<p>Logical flag. Setting to TRUE will show some plots for the parameter selection step. Useful for debuging. Default FALSE
</p>
</td></tr>
<tr><td><code id="SmoothWin_+3A_...">...</code></td>
<td>

<p>Other parameters that can be passed to the weightFUN()
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>final.k</code>, <code>final.l</code></td>
<td>
<p>Final values for k and l</p>
</td></tr>
<tr><td><code>model.l</code>, <code>model.k</code>, <code>finalModel</code></td>
<td>
<p>List of models for l, k and the final model. </p>
</td></tr>
<tr><td><code>others</code></td>
<td>
<p>The input parameters such as x, y, t and so on</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hamed Haselimashhadi &lt;hamedhm@ebi.ac.uk&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expWeight">expWeight</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
#################### Example in the manuscript
#################################################
set.seed(1234)
par(mfrow = c(3, 1))
#############################
# Simulating data
#############################
n = 60
t = 1:n
sd = 1
m = n / 2
x = t
y = c(0 * x[t &lt;= n / 3]                        ,
      x[t &lt; 2 * n / 3 &amp; t &gt; n / 3] * 1         ,
      0 * x[t &gt;= 2 * n / 3]) + rnorm(n, 0, sd)
# True weights
w = weights = expWeight(
  t = t                                        ,
  k = 5                                        ,
  l = n/6                                      ,
  m = m                                        ,
  plot = 0
)
#############################
# Fitting and ploting data and models
#############################
l = lm(y ~ x, weights = w)
plot(
  x                                             ,
  y                                             ,
  ylim = c(min(y), max(y) * 1.5)                ,
  col = t %in% seq(n / 3 + 1, 2 * n / 3 - 1) + 1,
  cex = 1.5                                     ,
  pch = 16                                      ,
  xlab = 'Time'                                 ,
  main = 'Simulated data'
)
abline(v = x[c(n / 3 + 1, 2 * n / 3 - 1)],
       lty = 2    ,
       lwd = 4    ,
       col = 'gray')
abline(l, col = 2 , lty = 2, lwd = 4)
abline(lm(y ~ x)  ,
       col = 3    ,
       lty = 3    ,
       lwd = 4)
plot(
  t,
  w ,
  type = 'b'         ,
  main = 'True weights',
  ylab = 'Weight'    ,
  xlab = 'Time'
)
#############################
# Fitting the Windowing model
#############################
r = SmoothWin(
  object = l                     ,
  data = data.frame(y = y, x = x),
  t = t                          ,
  m = m                          ,
  min.obs = 4                    ,
  debug = FALSE
)
#############################
# Plot fitted (windowed) model
#############################
plot(r, main = 'Estimated weights from WGF')


#################################################
#################### Other examples
#################################################
# All examples import the Orthodont dataset from the nlme package
library(nlme)
# Sort the data on the time component (age)
Orthodont =  Orthodont[order(Orthodont$age), ]
#############################
# Modes
#############################
mode = which(Orthodont$age  %in%  c(12))
#############################
# Time component
#############################
time = Orthodont$age
f  = formula(distance ~ Sex)


#################################################
#################### Examples ###################
#################################################
### Example 1. Linear model
#############################
# Method 1 (recommanded)
#############################
lm = do.call('lm', list(formula = f, data = Orthodont))
rm(f)

#############################
# Method 2 (can cause error if you pass the formula to the lm function)
# lm = lm(distance ~ Sex, data = Orthodont)
#############################

lm.result = SmoothWin(
  object = lm,
  data = Orthodont,
  t = time,
  m = mode,
  check = 0,
  weightFUN = function(x) {
    x
  },
  debug = TRUE
)
plot(
  lm.result,
  col = Orthodont$Sex,
  pch = as.integer(Orthodont$Sex),
  main = 'Simple liner model'
)

#############################
#### Example 2. Linear Model Using Generalized Least Squares
# Method 1 (recommanded)
#############################
f   = formula(distance ~ Sex)
gls = do.call('gls', list(model = f, data = Orthodont))
rm(f)

#############################
# Method 2 (can cause error if you pass the formula to the gls function)
# gls = gls(distance ~ Sex, data = Orthodont)
#############################
gls.result = SmoothWin(
  object = gls,
  data = Orthodont,
  t = time,
  m = mode,
  check = 2,
  weightFUN = function(ignore.me) {
    varFixed(~ 1 / ModelWeight) #nlme package uses the inverse weights
  },
  debug = TRUE
)
plot(
  gls.result,
  col = Orthodont$Sex,
  pch = as.integer(Orthodont$Sex),
  main = 'Linear model using GLS'
)

#################################################
#### Example 3. Linear mixed model
#################################################
# Method 1 (recommanded)
#############################
fixed  = formula(distance ~ Sex)
random = formula(~ 1 | Subject)
lme = do.call('lme', list(
  fixed = fixed,
  random = random,
  data = Orthodont
))
rm(fixed, random)

#############################
# Method 2 (can cause error if you pass the formula to the lme function)
# lme = lme(fixed = distance ~ Sex, random=~1|Subject , data = Orthodont)
#############################
lme.result = SmoothWin(
  object = lme,
  data = Orthodont,
  t = time,
  m = mode,
  # Remove zero weights as well as single observation dates
  check = 1,
  weightFUN = function(ignore.me) {
    varFixed(~ 1 / ModelWeight)
  },
  debug = TRUE
)
plot(
  lme.result,
  col = Orthodont$Sex,
  pch = as.integer(Orthodont$Sex),
  main = 'Linear mixed model'
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
