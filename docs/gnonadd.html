<!DOCTYPE html><html lang="en"><head><title>Help for package gnonadd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gnonadd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha.calc'><p>Genetic variance effects</p></a></li>
<li><a href='#alpha.cond'><p>Conditional analysis for genetic variance effects</p></a></li>
<li><a href='#alpha.continuous.cond'><p>variance effect conditioned on continuous variables</p></a></li>
<li><a href='#alpha.multi.est'><p>Variance parameters</p></a></li>
<li><a href='#corr.calibration'><p>Calibration for the correlation test</p></a></li>
<li><a href='#dominance_CC.calc'><p>Genetic dominance effects on a case control variable</p></a></li>
<li><a href='#dominance.calc'><p>Genetic dominance effects</p></a></li>
<li><a href='#ellipse.by.gen'><p>Ellipse best fit plot</p></a></li>
<li><a href='#env_interaction_CC.calc'><p>Variant-Environmental interaction effects on a case control variable</p></a></li>
<li><a href='#env_interaction.calc'><p>Variant-Environmental interaction effects</p></a></li>
<li><a href='#expected.variance.effect'><p>Expected variance effect from additive effect</p></a></li>
<li><a href='#hist_by_gen'><p>Histogram by genotype</p></a></li>
<li><a href='#interaction_CC.calc'><p>Variant-Variant interaction effects on a case control variable</p></a></li>
<li><a href='#interaction.calc'><p>Variant-Variant interaction effects</p></a></li>
<li><a href='#kappa_calc'><p>Genetic correlation effects</p></a></li>
<li><a href='#pairwise_env_int_CC.calc'><p>Pairwise environmental interaction effects for a case control variable</p></a></li>
<li><a href='#pairwise_env_int.calc'><p>Pairwise environmental interaction effects</p></a></li>
<li><a href='#pairwise_int_CC.calc'><p>Pairwise interaction effects for a case control variable</p></a></li>
<li><a href='#pairwise_int.calc'><p>Pairwise interaction effects</p></a></li>
<li><a href='#PRS_creator'><p>Creates poligenic risk scores</p></a></li>
<li><a href='#train_and_impute_PRS'><p>Trains and imputes a poligenic risk score (PRS)</p></a></li>
<li><a href='#var.adj'><p>Mean and variance effect adjustments.</p></a></li>
<li><a href='#Var.assoc'><p>Uncertanty association</p></a></li>
<li><a href='#var.summary'><p>Variance summary statistics</p></a></li>
<li><a href='#VarGS.plot'><p>Actual variance vs predicted variance plot</p></a></li>
<li><a href='#Viol.by.gen'><p>Violin plot by genotype</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Various Non-Additive Models for Genetic Associations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>The goal of 'gnonadd' is to simplify workflows in the analysis of non-additive effects of sequence variants. This includes variance effects (Ivarsdottir et. al (2017) &lt;<a href="https://doi.org/10.1038%2Fng.3928">doi:10.1038/ng.3928</a>&gt;), correlation effects, interaction effects and dominance effects. The package also includes convenience functions for visualization.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DecodeGenetics/gnonadd">https://github.com/DecodeGenetics/gnonadd</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DecodeGenetics/gnonadd/issues">https://github.com/DecodeGenetics/gnonadd/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-18 23:28:43 UTC; gudmundureinarsson</td>
</tr>
<tr>
<td>Author:</td>
<td>Audunn S. Snaebjarnarson [aut, cre, ctb],
  Gudmundur Einarsson [aut, ctb],
  Daniel F. Gudbjartsson [aut, ctb],
  deCODE Genetics/AMGEN [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Audunn S. Snaebjarnarson &lt;audunn.snaebjarnarson@decode.is&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-19 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha.calc'>Genetic variance effects</h2><span id='topic+alpha.calc'></span>

<h3>Description</h3>

<p>This function estimates the variance effect of a genetic variant on a quantitative trait.
The genotype is coded as 0 (non-carrier), 1 (single copy of effect allele) and 2 (two copies of effect allele).
The variance effect (alpha) is modelled to be multiplicitive.
We use a likelihood ratio test with 1 degree of freedom,
* H0: y~N(mu_g,sigma^2)
* H1: y~N(mu_g,sigma^2\*alpha^g)
Under the alternative model, the variance of the trait changes multiplicatively
with genotype:
Var(y|g=j)=alpha^j*sigma^2, j in 0,1,2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.calc(qt, g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha.calc_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="alpha.calc_+3A_g">g</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the values:
</p>
<p>* alpha, the estimated variance effect
* sigma2_alt, The variance estimated for non-carriers
* pval, the p-value of the likelihood ratio test
* chi2, the chi squared statistics (with one degree of freedom) corrisponding to the p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 50000L
geno_vec &lt;- sample(c(0, 1, 2), size = n_val, replace = TRUE)
qt_vec &lt;- rnorm(n_val) * (1.1^geno_vec)
res &lt;- alpha.calc(qt_vec, geno_vec)
</code></pre>

<hr>
<h2 id='alpha.cond'>Conditional analysis for genetic variance effects</h2><span id='topic+alpha.cond'></span>

<h3>Description</h3>

<p>We estimate the variance effect of a primary variant conditioned on one or more secondary variants.
We apply a likelyhood ratio test with one degree of freedom
</p>
<p>H0: All secondary variants have a variance effect, but not the primary one.
H1: All variants have a variance effect, including the primary one
</p>
<p>Under both models we assume a full mean effect model. That is, the number of mean-value parameters is 3^(n+1), where n is the number of covariates
Thus the null model has 3^(n+1)+n degrees of freedom whereas the alternative model has 3^(n+1)+n+1
Due to the exponential growth of free parameters, the test might have low statistical power if many covariates are used
</p>
<p>IMPORTANT NOTE: We use the Gauss-Newton algorithm to estimate many parameters.
We do not check if the algorithm converges to the true minimum values, or if it converges at all.
Thus, we advise against blindly believing all results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.cond(qt, g, g_covar, iter_num = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha.cond_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="alpha.cond_+3A_g">g</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="alpha.cond_+3A_g_covar">g_covar</code></td>
<td>
<p>An integer matrix where each column corresponds to a genetic covariate</p>
</td></tr>
<tr><td><code id="alpha.cond_+3A_iter_num">iter_num</code></td>
<td>
<p>An integer. Represents the number of iterations performed in the Gauss-Newton algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the values:
* alpha, the estimated variance effect, conditioned on the covariates
* pval, the p-value corresponding to alpha
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10000
qt &lt;- rnorm(n)
g &lt;- rbinom(n, 2, 0.3)
qt &lt;- qt * 1.2^g
g_covar &lt;- as.data.frame(matrix(0, nrow = n, ncol = 3))
for(i in 1:ncol(g_covar)){
  freq &lt;- runif(1, min = 0, max = 1)
  g_covar[, i] &lt;- rbinom(n, 2, freq)
}
res &lt;- alpha.cond(qt, g, g_covar)
</code></pre>

<hr>
<h2 id='alpha.continuous.cond'>variance effect conditioned on continuous variables</h2><span id='topic+alpha.continuous.cond'></span>

<h3>Description</h3>

<p>We estimate the variance effect of a variant conditioned on one or more continous variable
We apply a likelyhood ratio test with one degree of freedom
</p>
<p>H0: All covariates have a variance effect, but not the variant
H1: The variant has a variance effect, and the covariates as well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.continuous.cond(qt, g, x, iter_num = 50, eps_param = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha.continuous.cond_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="alpha.continuous.cond_+3A_g">g</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="alpha.continuous.cond_+3A_x">x</code></td>
<td>
<p>A numeric matrix, each column represents a covariate.</p>
</td></tr>
<tr><td><code id="alpha.continuous.cond_+3A_iter_num">iter_num</code></td>
<td>
<p>An integer. Represents the number of iterations performed in the Gauss-Newton algorithm</p>
</td></tr>
<tr><td><code id="alpha.continuous.cond_+3A_eps_param">eps_param</code></td>
<td>
<p>A number. The Gauss-Newton algorithm terminates if the incriment change of all variance estimates is smaller than this number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the values:
* alpha, the estimated variance effect, conditioned on the covariates
* pval, the p-value corresponding to alpha
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 50000
x &lt;- matrix(0,nrow = n_val, ncol = 4)
for(i in 1:4) {
x[, i] &lt;- rnorm(n_val)
}
g_vec &lt;- rbinom(n_val,2,0.3)
var_vec &lt;- exp(0.2 * x[, 1] - 0.3 * x[, 4] + 0.3 * g_vec)
qt_vec &lt;- rnorm(n_val, 0, sqrt(var_vec))
res &lt;- alpha.continuous.cond(qt_vec, g_vec, x)
</code></pre>

<hr>
<h2 id='alpha.multi.est'>Variance parameters</h2><span id='topic+alpha.multi.est'></span>

<h3>Description</h3>

<p>This function jointly estimates the variance effect of a set of (continuous) variables on a qt trait.
More precisely. It finds the maximum likelyhood estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.multi.est(
  qt,
  x,
  iter_num = 50,
  eps_param = 1e-10,
  initial_guess = rep(0, ncol(x))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha.multi.est_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="alpha.multi.est_+3A_x">x</code></td>
<td>
<p>A numeric matrix, each column represents a covariate.</p>
</td></tr>
<tr><td><code id="alpha.multi.est_+3A_iter_num">iter_num</code></td>
<td>
<p>An integer. Represents the number of iterations performed in the Gauss-Newton algorithm</p>
</td></tr>
<tr><td><code id="alpha.multi.est_+3A_eps_param">eps_param</code></td>
<td>
<p>A number. The Gauss-Newton algorithm terminates if the incriment change of all variance estimates is smaller than this number.</p>
</td></tr>
<tr><td><code id="alpha.multi.est_+3A_initial_guess">initial_guess</code></td>
<td>
<p>A vector of length ncol(x). Represents the initial guess of parameters for the Gauss-Newton algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with a variance estimate for each variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 50000
x &lt;- matrix(0,nrow = n_val, ncol = 4)
for(i in 1:4) {
x[, i] &lt;- rnorm(n_val)
}
var_vec &lt;- exp(0.2 * x[, 1] - 0.3 * x[, 4])
qt_vec &lt;- rnorm(n_val, 0, sqrt(var_vec))
res &lt;- alpha.multi.est(qt_vec, x)
</code></pre>

<hr>
<h2 id='corr.calibration'>Calibration for the correlation test</h2><span id='topic+corr.calibration'></span>

<h3>Description</h3>

<p>This function finds appropriate scaling_parameters for the kappa_calc function by means of bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr.calibration(qt1, qt2, reps = 10000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corr.calibration_+3A_qt1">qt1</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="corr.calibration_+3A_qt2">qt2</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="corr.calibration_+3A_reps">reps</code></td>
<td>
<p>The number of repeates we want to perform for each sample size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the values:
</p>
<p>* bias_scale, a value to determine the bias for the correlation estimators
* weight_scale, a value to determine how much weight we assign to each correlation estimator
* safe_weight_scale, same as weight scale, but larger. Using this weight decreases the chance of type 1 error, with the cost of statistical power.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 10000
Q &lt;- MASS::mvrnorm(n = n_val, mu = c(0,0), Sigma = matrix(c(1,0.3,0.3,1),
                   nrow = 2, ncol = 2))
qt1_val &lt;- Q[,1]
qt2_val &lt;- Q[,2]
res &lt;- corr.calibration(qt1_val, qt2_val, 10)
</code></pre>

<hr>
<h2 id='dominance_CC.calc'>Genetic dominance effects on a case control variable</h2><span id='topic+dominance_CC.calc'></span>

<h3>Description</h3>

<p>This function estimates the dominance effect of a genetic variant on a case-control variable
We apply a logistic regression model to estimate dominance effects.
We include a linear term, coded as 0,1 and 2 for non-carriers, heterozygotes and homozygous carriers of the effect allele.
We also include a dominance term, coded as 1 for homozygous carriers and 0 for others.
Effect size and significance is based on the dominance term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominance_CC.calc(
  cc,
  g,
  yob = rep(-1, length(cc)),
  sex = rep(-1, length(cc)),
  round_imputed = FALSE,
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dominance_CC.calc_+3A_cc">cc</code></td>
<td>
<p>A case control vector, containing 0's and 1's</p>
</td></tr>
<tr><td><code id="dominance_CC.calc_+3A_g">g</code></td>
<td>
<p>A vector with (possibly imputed) genotype values. All entries should be larger than 0 and smaller than 2.</p>
</td></tr>
<tr><td><code id="dominance_CC.calc_+3A_yob">yob</code></td>
<td>
<p>A numerical vector containing year of birth. If some are unknown they should be marked as -1</p>
</td></tr>
<tr><td><code id="dominance_CC.calc_+3A_sex">sex</code></td>
<td>
<p>A numerical vector containing sex, coded 0 for males, 1 for females and -1 for unknown</p>
</td></tr>
<tr><td><code id="dominance_CC.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis</p>
</td></tr>
<tr><td><code id="dominance_CC.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any other covariates that should be used; one column per covariate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the dominanc effect (on log-scale) and corresponding standard error, z statistic and p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_vec &lt;- rbinom(100000, 2, 0.3)
cc_vec &lt;- rbinom(100000, 1, 0.1 * (1.2 ^ (g_vec^2)))
res &lt;- dominance_CC.calc(cc_vec, g_vec)
</code></pre>

<hr>
<h2 id='dominance.calc'>Genetic dominance effects</h2><span id='topic+dominance.calc'></span>

<h3>Description</h3>

<p>This function estimates the dominance effect of a genetic variant on a quantitatvie trait
Nothing fancy here. We apply a simple linear regression model to estimate dominance effects.
We include a linear term, coded as 0,1 and 2 for non-carriers, heterozygotes and homozygous carriers of the effect allele.
We also include a dominance term, coded as 1 for homozygous carriers and 0 for others.
Effect size and significance is based on the dominance term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominance.calc(
  qt,
  g,
  round_imputed = FALSE,
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dominance.calc_+3A_qt">qt</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="dominance.calc_+3A_g">g</code></td>
<td>
<p>A vector with (possibly imputed) genotype values. All entries should be larger than 0 and smaller than 2.</p>
</td></tr>
<tr><td><code id="dominance.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis</p>
</td></tr>
<tr><td><code id="dominance.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any covariates that should be used; one column per covariate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the dominanc effect and corresponding standard error, t statistic and p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_vec &lt;- rbinom(100000, 2, 0.3)
qt_vec &lt;- rnorm(100000) + 0.2 * g_vec^2
res &lt;- dominance.calc(qt_vec, g_vec)
</code></pre>

<hr>
<h2 id='ellipse.by.gen'>Ellipse best fit plot</h2><span id='topic+ellipse.by.gen'></span>

<h3>Description</h3>

<p>This tool creates a scatter plot along with regression lines. Additionally it finds and plots the best ellipses that fit the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse.by.gen(
  qt1,
  qt2,
  g,
  trait_name1 = "qt trait 1",
  trait_name2 = "qt trait 2",
  title = "",
  sample_size = 500
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipse.by.gen_+3A_qt1">qt1</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="ellipse.by.gen_+3A_qt2">qt2</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="ellipse.by.gen_+3A_g">g</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="ellipse.by.gen_+3A_trait_name1">trait_name1</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="ellipse.by.gen_+3A_trait_name2">trait_name2</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="ellipse.by.gen_+3A_title">title</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="ellipse.by.gen_+3A_sample_size">sample_size</code></td>
<td>
<p>A positive integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scatter plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 10000L
geno_vec &lt;- c(rep(0, n_val), rep(1, n_val), rep(2, n_val))
qt_g0 &lt;- MASS::mvrnorm(n_val, mu = c(0, 0), Sigma = matrix(c(0.93, 0.88, 0.88, 0.92), ncol = 2))
qt_g1 &lt;- MASS::mvrnorm(n_val, mu = c(0, 0), Sigma = matrix(c(0.98, 0.88, 0.88, 0.90), ncol = 2))
qt_g2 &lt;- MASS::mvrnorm(n_val, mu = c(0, 0), Sigma = matrix(c(1.57, 0.81, 0.81, 0.59), ncol = 2))
qt_vec &lt;- rbind(qt_g0, qt_g1)
qt_vec &lt;- rbind(qt_vec, qt_g2)
res &lt;- ellipse.by.gen(qt_vec[, 1], qt_vec[, 2], geno_vec)
</code></pre>

<hr>
<h2 id='env_interaction_CC.calc'>Variant-Environmental interaction effects on a case control variable</h2><span id='topic+env_interaction_CC.calc'></span>

<h3>Description</h3>

<p>This function estimates the interaction effect of a genetic variant with an environmental factor on a case control variable
We apply a simple logistic regression model to estimate interaction effects.
We include a linear term for the variant and environmental variable seperately.
The variant is coded as 0,1 and 2 for non-carriers, heterozygotes and homozygous carriers of the effect allele.
The environmental variable is rank-normalized automatically as part of the function.
The interaction term is defined as the product of the genetic and the (normalized) environmental variable.
Effect size and significance is based on the interaction term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_interaction_CC.calc(
  cc,
  g,
  env,
  yob = rep(-1, length(cc)),
  sex = rep(-1, length(cc)),
  round_imputed = FALSE,
  dominance_term = FALSE,
  square_env = FALSE,
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="env_interaction_CC.calc_+3A_cc">cc</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="env_interaction_CC.calc_+3A_g">g</code></td>
<td>
<p>A vector with (possibly imputed) genotype values. All entries should be larger than 0 and smaller than 2.</p>
</td></tr>
<tr><td><code id="env_interaction_CC.calc_+3A_env">env</code></td>
<td>
<p>A numeric vector with an environmental variable</p>
</td></tr>
<tr><td><code id="env_interaction_CC.calc_+3A_yob">yob</code></td>
<td>
<p>A numerical vector containing year of birth. If some are unknown they should be marked as -1</p>
</td></tr>
<tr><td><code id="env_interaction_CC.calc_+3A_sex">sex</code></td>
<td>
<p>A numerical vector containing sex, coded 0 for males, 1 for females and -1 for unknown</p>
</td></tr>
<tr><td><code id="env_interaction_CC.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis.</p>
</td></tr>
<tr><td><code id="env_interaction_CC.calc_+3A_dominance_term">dominance_term</code></td>
<td>
<p>A boolian variable determining whether a dominance term for the variant should be included as a covariates in the analysis</p>
</td></tr>
<tr><td><code id="env_interaction_CC.calc_+3A_square_env">square_env</code></td>
<td>
<p>A boolian variable determining whether the square of the environmental trait should be included as a covariate in the analysis</p>
</td></tr>
<tr><td><code id="env_interaction_CC.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any other covariates that should be used; one column per covariate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the environmental interaction effect and corresponding standard error, t statistic and p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_vec &lt;- rbinom(100000, 2, 0.9)
env_vec &lt;- round(runif(100000, min = 0, max = 6))
cc_vec &lt;- rbinom(100000,1,0.1 * (1.05^g_vec) *
          (1.1^env_vec)* (1.1 ^ (g_vec * env_vec)))
res &lt;- env_interaction_CC.calc(cc_vec, g_vec, env_vec)
</code></pre>

<hr>
<h2 id='env_interaction.calc'>Variant-Environmental interaction effects</h2><span id='topic+env_interaction.calc'></span>

<h3>Description</h3>

<p>This function estimates the interaction effect of a genetic variant with an environmental factor on a quantitatvie trait
We apply a simple linear regression model to estimate interaction effects.
We include a linear term for the variant and environmental variable seperately.
The variant is coded as 0,1 and 2 for non-carriers, heterozygotes and homozygous carriers of the effect allele.
The environmental variable is rank-normalized automatically as part of the function.
The interaction term is defined as the product of the genetic and the (normalized) environmental variables.
Effect size and significance is based on the interaction term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_interaction.calc(
  qt,
  g,
  env,
  round_imputed = FALSE,
  dominance_term = FALSE,
  square_env = FALSE,
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="env_interaction.calc_+3A_qt">qt</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="env_interaction.calc_+3A_g">g</code></td>
<td>
<p>A vector with (possibly imputed) genotype values. All entries should be larger than 0 and smaller than 2.</p>
</td></tr>
<tr><td><code id="env_interaction.calc_+3A_env">env</code></td>
<td>
<p>A numeric vector with an environmental variable</p>
</td></tr>
<tr><td><code id="env_interaction.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis.</p>
</td></tr>
<tr><td><code id="env_interaction.calc_+3A_dominance_term">dominance_term</code></td>
<td>
<p>A boolian variable determining whether a dominance term for the variant should be included as a covariates in the analysis</p>
</td></tr>
<tr><td><code id="env_interaction.calc_+3A_square_env">square_env</code></td>
<td>
<p>A boolian variable determining whether the square of the environmental trait should be included as a covariate in the analysis</p>
</td></tr>
<tr><td><code id="env_interaction.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any other covariates that should be used; one column per covariate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the environmental interaction effect and corresponding standard error, t statistic and p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_vec &lt;- rbinom(100000, 2, 0.1)
env_vec &lt;- round(runif(100000,min=0,max=6))
qt_vec &lt;- rnorm(100000) + 0.1 * g_vec + 0.05 * env_vec + 0.05 * g_vec * env_vec
res &lt;- env_interaction.calc(qt_vec, g_vec, env_vec)
</code></pre>

<hr>
<h2 id='expected.variance.effect'>Expected variance effect from additive effect</h2><span id='topic+expected.variance.effect'></span>

<h3>Description</h3>

<p>This function interpolates data from a simple simulation to give an estimate
of the variance effect induced by an additive effect. The simulation code
is stored under inst/raw/. We assume that the trait has been inverse normal
transformed. Under the simulation, there is no variance effect, so the variance
effect is fully induced by the inverse normal transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expected.variance.effect(maf, beta_add)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expected.variance.effect_+3A_maf">maf</code></td>
<td>
<p>Minor allele frequency of the variant, should be in the range 0 to 0.5.</p>
</td></tr>
<tr><td><code id="expected.variance.effect_+3A_beta_add">beta_add</code></td>
<td>
<p>Additive effect of the variant, should be in the range 0 to 3.5.
This variable can be a vector of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected variance effect for the variant from the given maf, beta combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maf &lt;- 0.1
beta_val &lt;- 0.3
expected_var &lt;- expected.variance.effect(maf, beta_val)

beta_vec &lt;- seq(0.1,2, length.out = 20)
expected_var &lt;- expected.variance.effect(maf, beta_vec)
</code></pre>

<hr>
<h2 id='hist_by_gen'>Histogram by genotype</h2><span id='topic+hist_by_gen'></span>

<h3>Description</h3>

<p>This tool creates three histogram plots. One per genotype. Additionally, outliers are colored red (by default subjects that are in the top and bottom 2.5
and blue lines are added to indicate the mean and (by default) one standard deviation in each direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_by_gen(
  qt,
  g,
  bins = 100,
  trait_name = "qt trait",
  title = "",
  outlier_quantiles = c(0.025, 0.975),
  sd_lines = c(1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist_by_gen_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="hist_by_gen_+3A_g">g</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="hist_by_gen_+3A_bins">bins</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="hist_by_gen_+3A_trait_name">trait_name</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="hist_by_gen_+3A_title">title</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="hist_by_gen_+3A_outlier_quantiles">outlier_quantiles</code></td>
<td>
<p>A vector with length 2.</p>
</td></tr>
<tr><td><code id="hist_by_gen_+3A_sd_lines">sd_lines</code></td>
<td>
<p>A vector with length 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A histgram plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 50000L
geno_vec &lt;- sample(c(0, 1, 2), size = n_val, replace = TRUE)
qt_vec &lt;- rnorm(n_val) * (1.3^geno_vec) + 1 * geno_vec
hist_by_gen(qt_vec, geno_vec)
</code></pre>

<hr>
<h2 id='interaction_CC.calc'>Variant-Variant interaction effects on a case control variable</h2><span id='topic+interaction_CC.calc'></span>

<h3>Description</h3>

<p>This function estimates the interaction effect of a pair of genetic variant on a case-control variable
We apply a logistic regression model to estimate interaction effects.
We include a linear term for each variant seperately, coded as 0,1 and 2 for non-carriers, heterozygotes and homozygous carriers of the effect allele.
We also include an interaction term, coded as the product of the two genotype values.
Effect size and significance is based on the interaction term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interaction_CC.calc(
  cc,
  g1,
  g2,
  yob = rep(-1, length(cc)),
  sex = rep(-1, length(cc)),
  round_imputed = FALSE,
  dominance_terms = FALSE,
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interaction_CC.calc_+3A_cc">cc</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="interaction_CC.calc_+3A_g1">g1</code></td>
<td>
<p>A vector with (possibly imputed) genotype values. All entries should be larger than 0 and smaller than 2.</p>
</td></tr>
<tr><td><code id="interaction_CC.calc_+3A_g2">g2</code></td>
<td>
<p>A vector with (possibly imputed) genotype values. All entries should be larger than 0 and smaller than 2.</p>
</td></tr>
<tr><td><code id="interaction_CC.calc_+3A_yob">yob</code></td>
<td>
<p>A numerical vector containing year of birth. If some are unknown they should be marked as -1</p>
</td></tr>
<tr><td><code id="interaction_CC.calc_+3A_sex">sex</code></td>
<td>
<p>A numerical vector containing sex, coded 0 for males, 1 for females and -1 for unknown</p>
</td></tr>
<tr><td><code id="interaction_CC.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis.</p>
</td></tr>
<tr><td><code id="interaction_CC.calc_+3A_dominance_terms">dominance_terms</code></td>
<td>
<p>A boolian variable determining whether dominance terms for the variants should be included as covariates in the analysis</p>
</td></tr>
<tr><td><code id="interaction_CC.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any other covariates that should be used; one column per covariate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the interaction effect (on log-scale) and corresponding standard error, z statistic and p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1_vec &lt;- rbinom(100000, 2, 0.9)
g2_vec &lt;- rbinom(100000, 2, 0.1)
cc_vec &lt;- rbinom(100000,1,0.1 * (1.05^g1_vec) *
          (1.05^g2_vec) * (1.3 ^ (g1_vec * g2_vec)))
res &lt;- interaction_CC.calc(cc_vec, g1_vec, g2_vec)
</code></pre>

<hr>
<h2 id='interaction.calc'>Variant-Variant interaction effects</h2><span id='topic+interaction.calc'></span>

<h3>Description</h3>

<p>This function estimates the interaction effect of a pair of genetic variant on a quantitatvie trait
We apply a simple linear regression model to estimate interaction effects.
We include a linear term for each variant seperately, coded as 0,1 and 2 for non-carriers, heterozygotes and homozygous carriers of the effect allele.
We also include an interaction term, coded as the product of the two genotype values.
Effect size and significance is based on the interaction term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interaction.calc(
  qt,
  g1,
  g2,
  round_imputed = FALSE,
  dominance_terms = FALSE,
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interaction.calc_+3A_qt">qt</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="interaction.calc_+3A_g1">g1</code></td>
<td>
<p>A vector with (possibly imputed) genotype values. All entries should be larger than or equal to 0 and smaller than or equal to 2.</p>
</td></tr>
<tr><td><code id="interaction.calc_+3A_g2">g2</code></td>
<td>
<p>A vector with (possibly imputed) genotype values. All entries should be larger than or equal to 0 and smaller than or equal to 2.</p>
</td></tr>
<tr><td><code id="interaction.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis.</p>
</td></tr>
<tr><td><code id="interaction.calc_+3A_dominance_terms">dominance_terms</code></td>
<td>
<p>A boolian variable determining whether dominance terms for the variants should be included as covariates in the analysis</p>
</td></tr>
<tr><td><code id="interaction.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any other covariates that should be used; one column per covariate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the interaction effect and corresponding standard error, t statistic and p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1_vec &lt;- rbinom(100000, 2, 0.9)
g2_vec &lt;- rbinom(100000, 2, 0.1)
qt_vec &lt;- rnorm(100000) + 0.1 * g1_vec + 0.2 * g2_vec +0.4 * g1_vec * g2_vec
res &lt;- interaction.calc(qt_vec, g1_vec, g2_vec)
</code></pre>

<hr>
<h2 id='kappa_calc'>Genetic correlation effects</h2><span id='topic+kappa_calc'></span>

<h3>Description</h3>

<p>This function estimates the correlation effect of a genetic variant on a pair of quantitative traits.
The effect (kappa) is measured on Fisher transformed correlation values.
The genotype is coded as 0 (non-carrier), 1 (single copy of effect allele) and 2 (two copies of effect allele).
We use a likelihood ratio test with 1 degree of freedom:
* H0: z_0 = z_1 = z_2,
* H1: z_j = z_null +kappa*j,
where z_j is the Fisher-transformed correlation between the traits amongst subjects of genotype j.
</p>
<p>If the traits follow a joint normal distribution, then (thoretically) the Fisher-transformed sample correlation (z) is approximately normally distributed with mean 0 and
standard error 1/sqrt(n-3).
Otherwise, we have to correct for possible bias in the estimators and scale the weights we assign to them appropriately
</p>
<p>Note, that even though each trait follows a normal distribution individually, that does not necessarily imply that the pair of them follow a joint normal distirbution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappa_calc(qt1, qt2, g, weight_scale = 1, bias_scale = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kappa_calc_+3A_qt1">qt1</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="kappa_calc_+3A_qt2">qt2</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="kappa_calc_+3A_g">g</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="kappa_calc_+3A_weight_scale">weight_scale</code></td>
<td>
<p>Used to appropriately scale the weight assigned to the correlation estimators</p>
</td></tr>
<tr><td><code id="kappa_calc_+3A_bias_scale">bias_scale</code></td>
<td>
<p>Used to appropriately scale the bias of the correlation estimators</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the values:
</p>
<p>* kappa, the estimated correlation effect
* pval, the p-value of the likelihood ratio test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma0 &lt;- matrix(c(1,0,0,1),nrow=2,ncol=2)
Sigma1 &lt;- matrix(c(1,0.3,0.3,1),nrow=2,ncol=2)
Sigma2 &lt;- matrix(c(1,0.6,0.6,1),nrow=2,ncol=2)
geno_vec &lt;- c(rep(0,10000),rep(1,1000),rep(2,100))
Q0 &lt;- MASS::mvrnorm(n = 10000, mu = c(0,0), Sigma = Sigma0)
Q1 &lt;- MASS::mvrnorm(n = 1000, mu = c(0,0), Sigma = Sigma1)
Q2 &lt;- MASS::mvrnorm(n = 100, mu = c(0,0), Sigma = Sigma2)
Q &lt;- rbind(Q0,Q1)
Q &lt;- rbind(Q,Q2)
qt1_val &lt;- Q[,1]
qt2_val &lt;- Q[,2]
res &lt;- kappa_calc(qt1_val, qt2_val, geno_vec)
</code></pre>

<hr>
<h2 id='pairwise_env_int_CC.calc'>Pairwise environmental interaction effects for a case control variable</h2><span id='topic+pairwise_env_int_CC.calc'></span>

<h3>Description</h3>

<p>Given a set of variants and environmental traits, and a single case control variable, this function calculates the interaction effect of all possible variant-environmental pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_env_int_CC.calc(
  cc,
  g,
  env,
  yob = rep(-1, length(cc)),
  sex = rep(-1, length(cc)),
  round_imputed = FALSE,
  dominance_term = FALSE,
  square_env = FALSE,
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0)),
  variant_names = paste(rep("variant", ncol(g)), as.character(1:ncol(g)), sep = "_"),
  env_names = paste(rep("env", ncol(env)), as.character(1:ncol(env)), sep = "_")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_env_int_CC.calc_+3A_cc">cc</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_g">g</code></td>
<td>
<p>A matrix, where each colomn represents a variant</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_env">env</code></td>
<td>
<p>A matrix, where each row represents an environmental variable</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_yob">yob</code></td>
<td>
<p>A numerical vector containing year of birth. If some are unknown they should be marked as -1</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_sex">sex</code></td>
<td>
<p>A numerical vector containing sex, coded 0 for males, 1 for females and -1 for unknown</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis.</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_dominance_term">dominance_term</code></td>
<td>
<p>A boolian variable determining whether a dominance term for the variant should be included as a covariates in the analysis</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_square_env">square_env</code></td>
<td>
<p>A boolian variable determining whether the square of the environmental trait should be included as a covariate in the analysis</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any other covariates that should be used; one column per covariate</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_variant_names">variant_names</code></td>
<td>
<p>A list of the names of the variants</p>
</td></tr>
<tr><td><code id="pairwise_env_int_CC.calc_+3A_env_names">env_names</code></td>
<td>
<p>A list of the names of the environmental variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with all possible variant-environmental pairs and their estimated interaction effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N_run &lt;- 25000
g_vec &lt;- matrix(0, nrow = N_run, ncol = 3)
freqs &lt;- runif(ncol(g_vec), min = 0, max = 1)
env_vec &lt;- matrix(0, nrow = N_run, ncol = 3)
for(i in 1:ncol(g_vec)){
 g_vec[, i] &lt;- rbinom(N_run, 2, freqs[i])
}
for( i in 1:ncol(env_vec)){
 env_vec[, i] &lt;- round(runif(N_run,min=0,max=6))
}
cc_vec &lt;- rbinom(N_run,1,0.1 * (1.05 ^ g_vec[, 1]) *
          (1.06 ^ env_vec[,1]) * (0.95 ^ g_vec[, 2]) *
          (1.1^(g_vec[, 1] * env_vec[, 1])))
res &lt;- pairwise_env_int_CC.calc(cc_vec, g_vec, env_vec)
</code></pre>

<hr>
<h2 id='pairwise_env_int.calc'>Pairwise environmental interaction effects</h2><span id='topic+pairwise_env_int.calc'></span>

<h3>Description</h3>

<p>Given a set of variants and environmental traits, and a single quantitative trait, this function calculates the interaction effect of all possible variant-environmental pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_env_int.calc(
  qt,
  g,
  env,
  round_imputed = FALSE,
  dominance_term = FALSE,
  square_env = FALSE,
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0)),
  variant_names = paste(rep("variant", ncol(g)), as.character(1:ncol(g)), sep = "_"),
  env_names = paste(rep("env", ncol(env)), as.character(1:ncol(env)), sep = "_")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_env_int.calc_+3A_qt">qt</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="pairwise_env_int.calc_+3A_g">g</code></td>
<td>
<p>A matrix, where each colomn represents a variant</p>
</td></tr>
<tr><td><code id="pairwise_env_int.calc_+3A_env">env</code></td>
<td>
<p>A matrix, where each row represents an environmental variable</p>
</td></tr>
<tr><td><code id="pairwise_env_int.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis.</p>
</td></tr>
<tr><td><code id="pairwise_env_int.calc_+3A_dominance_term">dominance_term</code></td>
<td>
<p>A boolian variable determining whether a dominance term for the variant should be included as a covariates in the analysis</p>
</td></tr>
<tr><td><code id="pairwise_env_int.calc_+3A_square_env">square_env</code></td>
<td>
<p>A boolian variable determining whether the square of the environmental trait should be included as a covariate in the analysis</p>
</td></tr>
<tr><td><code id="pairwise_env_int.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any other covariates that should be used; one column per covariate</p>
</td></tr>
<tr><td><code id="pairwise_env_int.calc_+3A_variant_names">variant_names</code></td>
<td>
<p>A list of the names of the variants</p>
</td></tr>
<tr><td><code id="pairwise_env_int.calc_+3A_env_names">env_names</code></td>
<td>
<p>A list of the names of the environmental variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with all possible variant-environmental pairs and their estimated interaction effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_vec &lt;- matrix(0, nrow = 100000, ncol = 3)
freqs &lt;- runif(ncol(g_vec), min = 0, max = 1)
env_vec &lt;- matrix(0, nrow = 100000, ncol = 3)
for(i in 1:ncol(g_vec)){
 g_vec[, i] &lt;- rbinom(100000, 2, freqs[i])
}
for( i in 1:ncol(env_vec)){
 env_vec[, i] &lt;- round(runif(100000,min=0,max=6))
}

qt_vec &lt;- rnorm(100000) + 0.1 * g_vec[, 1] + 0.2 *
          g_vec[, 2] -0.1 * env_vec[, 3] + 0.1 *
          env_vec[, 1] + 0.1 * g_vec[, 1] * env_vec[, 1]
res &lt;- pairwise_env_int.calc(qt_vec, g_vec, env_vec)
</code></pre>

<hr>
<h2 id='pairwise_int_CC.calc'>Pairwise interaction effects for a case control variable</h2><span id='topic+pairwise_int_CC.calc'></span>

<h3>Description</h3>

<p>Given a set of variants and a case control variable, this function calculates the interaction effect of all possible variant-variant pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_int_CC.calc(
  cc,
  g,
  yob = rep(-1, length(cc)),
  sex = rep(-1, length(cc)),
  round_imputed = FALSE,
  dominance_terms = FALSE,
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0)),
  variant_names = paste(rep("variant", ncol(g)), as.character(1:ncol(g)), sep = "_")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_int_CC.calc_+3A_cc">cc</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="pairwise_int_CC.calc_+3A_g">g</code></td>
<td>
<p>A matrix, where each colomn represents a variant</p>
</td></tr>
<tr><td><code id="pairwise_int_CC.calc_+3A_yob">yob</code></td>
<td>
<p>A numerical vector containing year of birth. If some are unknown they should be marked as -1</p>
</td></tr>
<tr><td><code id="pairwise_int_CC.calc_+3A_sex">sex</code></td>
<td>
<p>A numerical vector containing sex, coded 0 for males, 1 for females and -1 for unknown</p>
</td></tr>
<tr><td><code id="pairwise_int_CC.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis.</p>
</td></tr>
<tr><td><code id="pairwise_int_CC.calc_+3A_dominance_terms">dominance_terms</code></td>
<td>
<p>A boolian variable determining whether dominance terms for the variants should be included as covariates in the analysis</p>
</td></tr>
<tr><td><code id="pairwise_int_CC.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any other covariates that should be used; one column per covariate</p>
</td></tr>
<tr><td><code id="pairwise_int_CC.calc_+3A_variant_names">variant_names</code></td>
<td>
<p>A list of the names of the variants</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with all possible variant pairs and their estimated interaction effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N_run &lt;- 25000
g_vec &lt;- matrix(0, nrow = N_run, ncol = 5)
freqs &lt;- runif(ncol(g_vec), min = 0,max = 1)
for(i in 1:ncol(g_vec)){
 g_vec[, i] &lt;- rbinom(N_run, 2, freqs[i])
}
cc_vec &lt;- rbinom(N_run,1,0.1 * (1.05 ^ g_vec[, 1]) *
          (1.06 ^ g_vec[,2]) * (0.95 ^ g_vec[, 3]) *
          (1.5^(g_vec[,1] * g_vec[,2])))
res &lt;- pairwise_int_CC.calc(cc_vec, g_vec)
</code></pre>

<hr>
<h2 id='pairwise_int.calc'>Pairwise interaction effects</h2><span id='topic+pairwise_int.calc'></span>

<h3>Description</h3>

<p>Given a set of variants and a quantitative trait, this function calculates the interaction effect of all possible variant-variant pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_int.calc(
  qt,
  g,
  round_imputed = FALSE,
  dominance_terms = FALSE,
  variant_names = paste(rep("variant", ncol(g)), as.character(1:ncol(g)), sep = "_"),
  covariates = as.data.frame(matrix(0, nrow = 0, ncol = 0))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairwise_int.calc_+3A_qt">qt</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="pairwise_int.calc_+3A_g">g</code></td>
<td>
<p>A matrix, where each colomn represents a variant</p>
</td></tr>
<tr><td><code id="pairwise_int.calc_+3A_round_imputed">round_imputed</code></td>
<td>
<p>A boolian variable determining whether imputed genotype values should be rounded to the nearest integer in the analysis.</p>
</td></tr>
<tr><td><code id="pairwise_int.calc_+3A_dominance_terms">dominance_terms</code></td>
<td>
<p>A boolian variable determining whether dominance terms for the variants should be included as covariates in the analysis</p>
</td></tr>
<tr><td><code id="pairwise_int.calc_+3A_variant_names">variant_names</code></td>
<td>
<p>A list of the names of the variants</p>
</td></tr>
<tr><td><code id="pairwise_int.calc_+3A_covariates">covariates</code></td>
<td>
<p>A dataframe containing any other covariates that should be used; one column per covariate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with all possible variant pairs and their estimated interaction effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_vec &lt;- matrix(0, nrow = 100000, ncol = 5)
freqs &lt;- runif(ncol(g_vec), min = 0, max = 1)
for(i in 1:ncol(g_vec)){
 g_vec[,i] &lt;- rbinom(100000, 2, freqs[i])
}

qt_vec &lt;- rnorm(100000) + 0.1 * g_vec[, 1] + 0.2 *
          g_vec[, 2] -0.1 * g_vec[, 3] + 0.2 *
          g_vec[, 1] * g_vec[, 2]
res &lt;- pairwise_int.calc(qt_vec, g_vec)
</code></pre>

<hr>
<h2 id='PRS_creator'>Creates poligenic risk scores</h2><span id='topic+PRS_creator'></span>

<h3>Description</h3>

<p>This function creates genetic risk scores, with the option of including interactions or dominance effects.
The score is automatically shifted to have mean 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRS_creator(
  g,
  betas,
  dominance_effects = rep(0, length(betas)),
  interaction_effects = matrix(0, nrow = 0, ncol = 0),
  log_scale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PRS_creator_+3A_g">g</code></td>
<td>
<p>A matrix, where each colomn represents a variant and each line represents a subject</p>
</td></tr>
<tr><td><code id="PRS_creator_+3A_betas">betas</code></td>
<td>
<p>A numeric vector, representing the (additive) effects of the variants</p>
</td></tr>
<tr><td><code id="PRS_creator_+3A_dominance_effects">dominance_effects</code></td>
<td>
<p>A numeric vector, representing dominance effects of the variants</p>
</td></tr>
<tr><td><code id="PRS_creator_+3A_interaction_effects">interaction_effects</code></td>
<td>
<p>A matrix with three columns. First two columns are integers that correspond to the variants that are interacting. The third column is the effect size.</p>
</td></tr>
<tr><td><code id="PRS_creator_+3A_log_scale">log_scale</code></td>
<td>
<p>A Boolian variabe. If true all analysis is done on log-transformed effect values and the resulting score is transformed back to an exponential scale in the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with a poligenic risk score for each subject
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_vec &lt;- matrix(0, nrow = 100000, ncol = 5)
freqs &lt;- runif(ncol(g_vec), min = 0, max = 1)
for(i in 1:ncol(g_vec)){
 g_vec[,i] &lt;- rbinom(100000, 2, freqs[i])
}
beta_vec &lt;- runif(5, min = -0.5, max = 0.5)
dom_vec &lt;- runif(5, min = -0.5, max = 0.5)
int_vec &lt;- matrix(0,nrow = 2, ncol = 3)
int_vec[, 1] &lt;- c(1, 3)
int_vec[, 2] &lt;- c(2, 5)
int_vec[, 3] &lt;- runif(2, min = -0.5, max = 0.5)
res &lt;- PRS_creator(g_vec, beta_vec, dominance_effects = dom_vec, interaction_effects = int_vec)
</code></pre>

<hr>
<h2 id='train_and_impute_PRS'>Trains and imputes a poligenic risk score (PRS)</h2><span id='topic+train_and_impute_PRS'></span>

<h3>Description</h3>

<p>This function trains a poligenic risk score model on a dataset, and then imputes the risk score into another dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_and_impute_PRS(
  qt_training,
  g_training,
  g_impute,
  dominance_effects = rep(FALSE, ncol(g_training)),
  interaction_effects = matrix(0, nrow = 0, ncol = 0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="train_and_impute_PRS_+3A_qt_training">qt_training</code></td>
<td>
<p>A numeric vector. Represents the qt values of the data we train the model on.</p>
</td></tr>
<tr><td><code id="train_and_impute_PRS_+3A_g_training">g_training</code></td>
<td>
<p>A matrix, where each colomn represents a variant and each line represents a subject in the training data</p>
</td></tr>
<tr><td><code id="train_and_impute_PRS_+3A_g_impute">g_impute</code></td>
<td>
<p>A matrix, where each column represents a variant and each line represents a subject.</p>
</td></tr>
<tr><td><code id="train_and_impute_PRS_+3A_dominance_effects">dominance_effects</code></td>
<td>
<p>A Boolian vector, each term determines whether a dominance term for the corresponding variant is used in the model.</p>
</td></tr>
<tr><td><code id="train_and_impute_PRS_+3A_interaction_effects">interaction_effects</code></td>
<td>
<p>An integer matrix with two columns. Each line represents a pair of interacting variants that should be included in the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following objects
* PRS_imputed, the imputed PRS values
* PRS_training, the PRS values for the training data
* Residuals_training, the residuals from the model in the training data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g_train_vec &lt;- matrix(0, nrow = 100000, ncol = 5)
freqs &lt;- runif(ncol(g_train_vec), min = 0, max = 1)
for(i in 1:ncol(g_train_vec)){
 g_train_vec[,i] &lt;- rbinom(100000, 2, freqs[i])
}
g_impute_vec &lt;- matrix(0, nrow = 50000, ncol = 5)
for(i in 1:ncol(g_impute_vec)){
 g_impute_vec[,i] &lt;- rbinom(50000, 2, freqs[i])
}
dom_vec &lt;- c(TRUE, FALSE, FALSE, TRUE, FALSE)

int_vec &lt;- matrix(c(1, 2, 4, 5), nrow = 2 , ncol = 2)

qt_vec &lt;- rnorm(100000) + 0.2 * g_train_vec[, 1] + 0.3 * g_train_vec[, 1] * g_train_vec[, 4]

res &lt;- train_and_impute_PRS(qt_vec, g_train_vec, g_impute_vec,
       dominance_effects = dom_vec, interaction_effects = int_vec)
</code></pre>

<hr>
<h2 id='var.adj'>Mean and variance effect adjustments.</h2><span id='topic+var.adj'></span>

<h3>Description</h3>

<p>Given is a set of (continuous) variables and a qt trait. First, this function adjusts the trait for the mean effects of the variables with a linear model.
Next, the variance effect of the variables are estimated and the trait is adjusted further by scaling it in accordance with the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.adj(qt, x, iter_num = 50, eps_param = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.adj_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="var.adj_+3A_x">x</code></td>
<td>
<p>A numeric matrix, each column represents a covariate.</p>
</td></tr>
<tr><td><code id="var.adj_+3A_iter_num">iter_num</code></td>
<td>
<p>An integer. Represents the number of iterations performed in the Gauss-Newton algorithm</p>
</td></tr>
<tr><td><code id="var.adj_+3A_eps_param">eps_param</code></td>
<td>
<p>A number. The Gauss-Newton algorithm terminates if the incriment change of all variance estimates is smaller than this number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, representing the adjusted trait.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 50000
x &lt;- matrix(0,nrow = n_val, ncol = 4)
for(i in 1:4) {
x[, i] &lt;- rnorm(n_val)
}
var_vec &lt;- exp(0.2 * x[, 1] - 0.3 * x[, 4])
qt_vec &lt;- rnorm(n_val, 0, sqrt(var_vec))
res &lt;- var.adj(qt_vec, x)
</code></pre>

<hr>
<h2 id='Var.assoc'>Uncertanty association</h2><span id='topic+Var.assoc'></span>

<h3>Description</h3>

<p>This function finds the association between the predicted uncertanty of some estimates of a trait to the &quot;actual uncertanty&quot; of the estimates.
Suppose we have estimates of some trait (this might be a polygenic risk score).
Moreover, suppose we have assigned a variance value to each estimate (this might be a variance risk score) to reflect
how certain we believe we are about each estimate. Given the true trait values, this function evaluates how well the assigned
variance values reflect reality.
</p>
<p>We use a likelihood ratio test with 1 degree of freedom
* H0: y~N(mu+b*m_score,sigma_sq),
* H1: y~N(mu+b*m_score,sigma_sq*(v_score)^a),
where y is the trait m_score is the estimate of the trait and v_score is the variance assigned to the estimate.
Thus H0 has three degrees of freedom (mu,b,sigma_sq), whereas H1 has four (mu,b,sigma_sq,a)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Var.assoc(qt, m_score, v_score, iter = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Var.assoc_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="Var.assoc_+3A_m_score">m_score</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="Var.assoc_+3A_v_score">v_score</code></td>
<td>
<p>A numeric vector with positive values</p>
</td></tr>
<tr><td><code id="Var.assoc_+3A_iter">iter</code></td>
<td>
<p>A number of iterations for the Gauss-Newton algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the values:
</p>
<p>* a, the association between v_score and the actual variance.
* pval, the p-value of the likelihood ratio test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n_val &lt;- 50000L
trait_vec &lt;- rnorm(n_val,0,1)
var_vec &lt;- exp(rnorm(n_val,0,0.1))
est_vec &lt;- trait_vec+rnorm(n_val,0,var_vec)
res &lt;- Var.assoc(trait_vec,est_vec,var_vec, iter = 20)
</code></pre>

<hr>
<h2 id='var.summary'>Variance summary statistics</h2><span id='topic+var.summary'></span>

<h3>Description</h3>

<p>Estimates the variance effect of several continuous variables jointly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.summary(qt, x, iter_num = 50, eps_param = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.summary_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="var.summary_+3A_x">x</code></td>
<td>
<p>A data frame, each column represents a covariate that should be numeric.</p>
</td></tr>
<tr><td><code id="var.summary_+3A_iter_num">iter_num</code></td>
<td>
<p>An integer. Represents the number of iterations performed in the Gauss-Newton algorithm</p>
</td></tr>
<tr><td><code id="var.summary_+3A_eps_param">eps_param</code></td>
<td>
<p>A number. The Gauss-Newton algorithm terminates if the incriment change of all variance estimates is smaller than this number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following objects:
* summary, a dataframe with a variance effect estimate for each variable and summary statistics
* chi2, the chi2 statistic obtained by considering all parameteres jointly
* df, degrees of freedom for the chi2 statistic
* pval, p-value of the model
* adjusted_values, a vector with qt values that have been adjusted for both mean and variance effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 50000
x &lt;- as.data.frame(matrix(0,nrow = n_val, ncol = 4))
colnames(x) &lt;- c('A','B','C','D')
for(i in 1:4) {
x[, i] &lt;- rnorm(n_val)
}
var_vec &lt;- exp(0.2 * x[, 1] - 0.3 * x[, 4])
qt_vec &lt;- rnorm(n_val, 0, sqrt(var_vec))
res &lt;- var.summary(qt_vec, x)
</code></pre>

<hr>
<h2 id='VarGS.plot'>Actual variance vs predicted variance plot</h2><span id='topic+VarGS.plot'></span>

<h3>Description</h3>

<p>This tool creates a line plot that compares the predicted variance of data to its actual variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarGS.plot(
  qt,
  v_score,
  bins = 10,
  xlab = "Predicted variance",
  ylab = "Variance",
  title = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VarGS.plot_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="VarGS.plot_+3A_v_score">v_score</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="VarGS.plot_+3A_bins">bins</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="VarGS.plot_+3A_xlab">xlab</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="VarGS.plot_+3A_ylab">ylab</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="VarGS.plot_+3A_title">title</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot comparing predicted variance to actual variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 100000L
v_vec &lt;- exp(rnorm(n_val, 0, 0.1))
qt_vec &lt;- stats::rnorm(n_val, 0, sqrt(v_vec))
VarGS.plot(qt_vec, v_vec)
</code></pre>

<hr>
<h2 id='Viol.by.gen'>Violin plot by genotype</h2><span id='topic+Viol.by.gen'></span>

<h3>Description</h3>

<p>This tool creates violin plots corresponding to each genotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Viol.by.gen(qt, g, trait_name = "qt trait", title = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Viol.by.gen_+3A_qt">qt</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="Viol.by.gen_+3A_g">g</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="Viol.by.gen_+3A_trait_name">trait_name</code></td>
<td>
<p>A string.</p>
</td></tr>
<tr><td><code id="Viol.by.gen_+3A_title">title</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A violin plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_val &lt;- 50000L
geno_vec &lt;- sample(c(0, 1, 2), size = n_val, replace = TRUE)
qt_vec &lt;- rnorm(n_val) * (1.3^geno_vec) + 1 * geno_vec
Viol.by.gen(qt_vec, geno_vec)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
