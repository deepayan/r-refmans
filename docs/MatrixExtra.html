<!DOCTYPE html><html><head><title>Help for package MatrixExtra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MatrixExtra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assignment'><p>Assignment operator for CSR matrices</p></a></li>
<li><a href='#cbind2-method'><p>Concatenate sparse matrices by columns</p></a></li>
<li><a href='#check_sparse_matrix'><p>Check if the underlying data behind a sparse matrix constitutes a valid object</p></a></li>
<li><a href='#conversions'><p>Conversions between matrix types</p></a></li>
<li><a href='#csr-linalg'><p>Linear Algebra functions for CSR matrices</p></a></li>
<li><a href='#deepcopy_sparse_object'><p>Deep copy sparse matrices and vectors</p></a></li>
<li><a href='#emptySparse'><p>Create Empty Sparse Matrix</p></a></li>
<li><a href='#filterSparse'><p>Filter values of a sparse matrix or vector</p></a></li>
<li><a href='#mapSparse'><p>Map values of a sparse matrix/vector</p></a></li>
<li><a href='#mathematical-functions'><p>Mathematical functions for CSR and COO matrices</p></a></li>
<li><a href='#matmult'><p>Multithreaded Sparse-Dense Matrix and Vector Multiplications</p></a></li>
<li><a href='#MatrixExtra'><p>MatrixExtra package</p></a></li>
<li><a href='#MatrixExtra-options'><p>MatrixExtra internal options</p></a></li>
<li><a href='#operators'><p>Mathematical operators on sparse matrices and sparse vectors</p></a></li>
<li><a href='#rbind_csr'><p>Concatenate inputs by rows into a CSR matrix</p></a></li>
<li><a href='#rbind2-method'><p>Concatenate sparse matrices/vectors by rows</p></a></li>
<li><a href='#remove_sparse_zeros'><p>Remove Zeros from a Sparse Matrix or Sparse Vector</p></a></li>
<li><a href='#show'><p>Quick Glance at Sparse Objects</p></a></li>
<li><a href='#slice'><p>Sparse Matrices Slicing</p></a></li>
<li><a href='#sort_sparse_indices'><p>Sort the indices of a sparse matrix or sparse vector</p></a></li>
<li><a href='#t_shallow'><p>Transpose a sparse matrix by changing its format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extra Methods for Sparse Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Cortes &lt;david.cortes.rivera@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends sparse matrix and vector classes from the 'Matrix' package by providing: 
  (a) Methods and operators that work natively on CSR formats (compressed sparse row, 
  a.k.a. 'RsparseMatrix') such as slicing/sub-setting, assignment, rbind(), 
  mathematical operators for CSR and COO such as addition ("+") or sqrt(), and methods such as diag(); 
  (b) Multi-threaded matrix multiplication and cross-product for many &lt;sparse, dense&gt; types, 
  including the 'float32' type from 'float'; 
  (c) Coercion methods between pairs of classes which are not present in 'Matrix', 
  such as 'dgCMatrix' -&gt; 'ngRMatrix', as well as convenience conversion functions; 
  (d) Utility functions for sparse matrices such as sorting the indices or removing 
  zero-valued entries; 
  (e) Fast transposes that work by outputting in the opposite storage format;
  (f) Faster replacements for many 'Matrix' methods for all sparse types, such as
  slicing and elementwise multiplication.
  (g) Convenience functions for sparse objects, such as 'mapSparse' or a shorter 'show' method.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix (&ge; 1.3), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, RhpcBLASctl, float</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, data.table, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/david-cortes/MatrixExtra">https://github.com/david-cortes/MatrixExtra</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/david-cortes/MatrixExtra/issues">https://github.com/david-cortes/MatrixExtra/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 18:50:55 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Cortes [aut, cre, cph],
  Dmitry Selivanov [cph],
  Thibaut Goetghebuer-Planchon [cph] (Copyright holder of included robinmap
    library),
  Martin Maechler [cph] (Copyright holder of 'Matrix' package from which some code
    was taken),
  Robert Gentleman [cph] (Copyright holder of mathematical functions used by base R
    which were copied),
  Ross Ihaka [cph] (Copyright holder of mathematical functions used by base R which
    were copied)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 21:02:32 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-01-02 07:38:31 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='assignment'>Assignment operator for CSR matrices</h2><span id='topic+assignment'></span><span id='topic++5B+3C-+2CdgRMatrix+2Cindex+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CdgRMatrix+2Cmissing+2Cindex+2CreplValue-method'></span><span id='topic++5B+3C-+2CdgRMatrix+2Cindex+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CdgRMatrix+2Cmissing+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CdgRMatrix+2Cindex+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CdgRMatrix+2Cmissing+2Cindex+2CsparseVector-method'></span><span id='topic++5B+3C-+2CdgRMatrix+2Cindex+2Cmissing+2CsparseVector-method'></span><span id='topic++5B+3C-+2CdgRMatrix+2Cmissing+2Cmissing+2CsparseVector-method'></span><span id='topic++5B+3C-+2CANY+2CnsparseVector+2CnsparseVector+2CreplValue-method'></span><span id='topic++5B+3C-+2CANY+2Cmissing+2CnsparseVector+2CreplValue-method'></span><span id='topic++5B+3C-+2CANY+2CnsparseVector+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CANY+2ClsparseVector+2ClsparseVector+2CreplValue-method'></span><span id='topic++5B+3C-+2CANY+2Cmissing+2ClsparseVector+2CreplValue-method'></span><span id='topic++5B+3C-+2CANY+2ClsparseVector+2Cmissing+2CreplValue-method'></span><span id='topic++5B+3C-+2CANY+2CnsparseVector+2CnsparseVector+2CANY-method'></span><span id='topic++5B+3C-+2CANY+2Cmissing+2CnsparseVector+2CANY-method'></span><span id='topic++5B+3C-+2CANY+2CnsparseVector+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CANY+2ClsparseVector+2ClsparseVector+2CANY-method'></span><span id='topic++5B+3C-+2CANY+2Cmissing+2ClsparseVector+2CANY-method'></span><span id='topic++5B+3C-+2CANY+2ClsparseVector+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>Assign values to a CSR matrix.
Note: this will only be a relatively fast operation when
assigning contiguous row sequences. Only some of the potential
assignment cases to a CSR matrix are replaced here - for example,
cases that involve uneven recycling of vectors will be left to
the 'Matrix' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'dgRMatrix,index,index,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dgRMatrix,missing,index,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dgRMatrix,index,missing,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dgRMatrix,missing,missing,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dgRMatrix,index,index,sparseVector'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dgRMatrix,missing,index,sparseVector'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dgRMatrix,index,missing,sparseVector'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'dgRMatrix,missing,missing,sparseVector'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,nsparseVector,nsparseVector,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,missing,nsparseVector,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,nsparseVector,missing,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,lsparseVector,lsparseVector,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,missing,lsparseVector,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,lsparseVector,missing,replValue'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,nsparseVector,nsparseVector,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,missing,nsparseVector,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,nsparseVector,missing,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,lsparseVector,lsparseVector,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,missing,lsparseVector,ANY'
x[i, j, ...] &lt;- value

## S4 replacement method for signature 'ANY,lsparseVector,missing,ANY'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignment_+3A_x">x</code></td>
<td>
<p>A CSR matrix whose values are to be replaced.</p>
</td></tr>
<tr><td><code id="assignment_+3A_i">i</code></td>
<td>
<p>The indices of the rows to replace.</p>
</td></tr>
<tr><td><code id="assignment_+3A_j">j</code></td>
<td>
<p>The indices of the columns to replace.</p>
</td></tr>
<tr><td><code id="assignment_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="assignment_+3A_value">value</code></td>
<td>
<p>The values to replace with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same 'x' input with the values '[i,j]' set to 'value'.
If the result is a full matrix (e.g. 'x[,] &lt;- 1'), the object will
be a dense matrix from base R.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)
set.seed(1)
X &lt;- rsparsematrix(5, 3, .5, repr="R")
X[1:3] &lt;- 0
print(X)
</code></pre>

<hr>
<h2 id='cbind2-method'>Concatenate sparse matrices by columns</h2><span id='topic+cbind2-method'></span><span id='topic+cbind2+2CTsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+cbind2+2CTsparseMatrix+2CsparseVector-method'></span><span id='topic+cbind2+2CsparseVector+2CTsparseMatrix-method'></span><span id='topic+cbind2+2CCsparseMatrix+2CsparseVector-method'></span><span id='topic+cbind2+2CsparseVector+2CCsparseMatrix-method'></span><span id='topic+cbind2+2CsparseVector+2CsparseVector-method'></span><span id='topic+cbind2+2CRsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+cbind2+2CTsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+cbind2+2CRsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+cbind2+2CRsparseMatrix+2Cnumeric-method'></span><span id='topic+cbind2+2CRsparseMatrix+2Cinteger-method'></span><span id='topic+cbind2+2CRsparseMatrix+2Clogical-method'></span><span id='topic+cbind2+2CRsparseMatrix+2CsparseVector-method'></span><span id='topic+cbind2+2Cnumeric+2CRsparseMatrix-method'></span><span id='topic+cbind2+2Cinteger+2CRsparseMatrix-method'></span><span id='topic+cbind2+2Clogical+2CRsparseMatrix-method'></span><span id='topic+cbind2+2CsparseVector+2CRsparseMatrix-method'></span>

<h3>Description</h3>

<p>'cbind2' method for the CSR and COO sparse matrix and
sparse vector classes from 'Matrix',
taking the most efficient route for the concatenation according to the input types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TsparseMatrix,TsparseMatrix'
cbind2(x, y)

## S4 method for signature 'TsparseMatrix,sparseVector'
cbind2(x, y)

## S4 method for signature 'sparseVector,TsparseMatrix'
cbind2(x, y)

## S4 method for signature 'CsparseMatrix,sparseVector'
cbind2(x, y)

## S4 method for signature 'sparseVector,CsparseMatrix'
cbind2(x, y)

## S4 method for signature 'sparseVector,sparseVector'
cbind2(x, y)

## S4 method for signature 'RsparseMatrix,RsparseMatrix'
cbind2(x, y)

## S4 method for signature 'TsparseMatrix,RsparseMatrix'
cbind2(x, y)

## S4 method for signature 'RsparseMatrix,TsparseMatrix'
cbind2(x, y)

## S4 method for signature 'RsparseMatrix,numeric'
cbind2(x, y)

## S4 method for signature 'RsparseMatrix,integer'
cbind2(x, y)

## S4 method for signature 'RsparseMatrix,logical'
cbind2(x, y)

## S4 method for signature 'RsparseMatrix,sparseVector'
cbind2(x, y)

## S4 method for signature 'numeric,RsparseMatrix'
cbind2(x, y)

## S4 method for signature 'integer,RsparseMatrix'
cbind2(x, y)

## S4 method for signature 'logical,RsparseMatrix'
cbind2(x, y)

## S4 method for signature 'sparseVector,RsparseMatrix'
cbind2(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind2-method_+3A_x">x</code></td>
<td>
<p>First matrix to concatenate.</p>
</td></tr>
<tr><td><code id="cbind2-method_+3A_y">y</code></td>
<td>
<p>Second matrix to concatenate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix (storage order varying depending on the input types).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)
set.seed(1)
X &lt;- rsparsematrix(3, 4, .3)
X &lt;- as(X, "TsparseMatrix")
inherits(cbind2(X, X), "TsparseMatrix")
</code></pre>

<hr>
<h2 id='check_sparse_matrix'>Check if the underlying data behind a sparse matrix constitutes a valid object</h2><span id='topic+check_sparse_matrix'></span>

<h3>Description</h3>

<p>Check if the underlying data behind a sparse matrix constitutes a valid object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_sparse_matrix(X, sort = TRUE, remove_zeros = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_sparse_matrix_+3A_x">X</code></td>
<td>
<p>A sparse matrix or sparse vector whose underlying arrays are to be checked.</p>
</td></tr>
<tr><td><code id="check_sparse_matrix_+3A_sort">sort</code></td>
<td>
<p>Whether to sort the indices of 'X' along the way. For this, will make
deep copies of the indices and values so that there are no issues with external
references being updated along the way.</p>
</td></tr>
<tr><td><code id="check_sparse_matrix_+3A_remove_zeros">remove_zeros</code></td>
<td>
<p>Whether to remove entries in 'X' which have a value of zero
but are nevertheless still present in the sparse representation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Makes checks on the data contained in the sparse matrix or sparse vector
object for whether the data constitutes a valid matrix - e.g. indices must not be
negative or larger than the dimensions, index pointer must match with the indices,
etc.
</p>
<p>As a short-hand, can also sort the matrix and remove zeros by calling the respective
functions <a href="MatrixExtra.html#topic+sort_sparse_indices">sort_sparse_indices</a> and <a href="MatrixExtra.html#topic+remove_sparse_zeros">remove_sparse_zeros</a>.
</p>
<p>A sparse matrix or sparse vector should never come out with invalid data from
functions from 'Matrix' and 'MatrixExtra', with one exception: some 'MatrixExtra'
functions might modify indices in-place, which can cause problems if the same
array of indices / values is also used by another matrix or R object elsewhere.
</p>
<p>Otherwise, this function is aimed at making checks on matrices that are manually
constructed.
</p>


<h3>Value</h3>

<p>The same matrix or vector 'X' (perhaps sorted or with zeros removed depending
on the parameters). If &lsquo;X' contains data that doesn&rsquo;t make for a valid sparse matrix
(e.g. different number of values and indices), it will throw an error.
</p>

<hr>
<h2 id='conversions'>Conversions between matrix types</h2><span id='topic+conversions'></span><span id='topic+as.csr.matrix'></span><span id='topic+as.csc.matrix'></span><span id='topic+as.coo.matrix'></span><span id='topic+as.sparse.vector'></span>

<h3>Description</h3>

<p>Convenience functions for converting to different sparse matrix formats,
between pairs of classes which might not be supported in the 'Matrix' package.
</p>
<p>These come in the form of explicit functions 'as.&lt;type&gt;.matrix' (see below),
as well as registered conversion methods to use along with 'as(object, type)', adding
extra conversion routes which are missing in the 'Matrix' package for output
types 'dgRMatrix', 'lgRMatrix', and 'ngRMatrix'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.csr.matrix(x, binary = FALSE, logical = FALSE, sort = FALSE)

as.csc.matrix(x, binary = FALSE, logical = FALSE, sort = FALSE)

as.coo.matrix(x, binary = FALSE, logical = FALSE, sort = FALSE)

as.sparse.vector(x, binary = FALSE, logical = FALSE, integer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversions_+3A_x">x</code></td>
<td>
<p>A matrix which is to be converted to a different format.
</p>
<p>Supported input types are:</p>

<ul>
<li><p> Sparse matrices from 'Matrix' package, in any format.
</p>
</li>
<li><p> Sparse vectors from 'Matrix' in any format.
</p>
</li>
<li><p> Dense matrices from base R (class 'matrix').
</p>
</li>
<li><p> Dense vectors from base R (classes 'numeric', 'integer', 'logical').
</p>
</li>
<li><p> Dense matrix or vector from package 'float' (class 'float32').
</p>
</li>
<li><p> 'data.frame', 'data.table', and 'tibble'.
</p>
</li></ul>
</td></tr>
<tr><td><code id="conversions_+3A_binary">binary</code></td>
<td>
<p>Whether the result should be a binary-only matrix/vector (inheriting from
class &lsquo;nsparseMatrix'/'nsparseVector' - these don&rsquo;t have slot 'x').
Can only pass one of 'binary' or 'logical'.</p>
</td></tr>
<tr><td><code id="conversions_+3A_logical">logical</code></td>
<td>
<p>Whether the result should be a matrix/vector with logical (boolean) type
(inheriting from 'lsparseMatrix'/'lsparseVector').
Can only pass one of 'binary' or 'logical'.</p>
</td></tr>
<tr><td><code id="conversions_+3A_sort">sort</code></td>
<td>
<p>Whether to sort the indices in case they are not sorted. Note that it will
perform deep copies of the indices and values along the way.</p>
</td></tr>
<tr><td><code id="conversions_+3A_integer">integer</code></td>
<td>
<p>Whether the result should be a vector with integer type ('isparseVector').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions internally might use some routes of 'as(x, &quot;?sparseMatrix&quot;)', so they might work
with other object classes if they register a conversion method for 'Matrix' base
types.
</p>
<p>When passed a vector, the functions 'as.csr.matrix' and 'as.coo.matrix' will
assume that it is a row vector, while &lsquo;as.csc.matrix' will assume it&rsquo;s a column vector.
</p>


<h3>Value</h3>

<p>A sparse matrix/vector, with format:</p>

<ul>
<li><p> CSR (a.k.a. 'RsparseMatrix') when calling 'as.csr.matrix'
(class 'dgRMatrix', 'ngRMatrix', or 'lgRMatrix', depending on parameters 'binary' and 'logical').
</p>
</li>
<li><p> CSC (a.k.a. 'CsparseMatrix') when calling 'as.csc.matrix'
(class 'dgCMatrix', 'ngCMatrix', or 'lgCMatrix', depending on parameters 'binary' and 'logical').
</p>
</li>
<li><p> COO (a.k.a. 'TsparseMatrix') when calling 'as.coo.matrix'
(class 'dgTMatrix', 'ngTMatrix', or 'lgTMatrix', depending on parameters 'binary' and 'logical').
</p>
</li>
<li><p> sparse vector (class dependant on input) when calling 'as.sparse.vector'.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)

m.coo &lt;- as(matrix(1:3), "TsparseMatrix")
as.csr.matrix(m.coo)
as.csr.matrix(1:3) # &lt;- assumes it's a row vector
as.csc.matrix(1:3) # &lt;- assumes it's a column vector

### Using the new conversion methods
### (these would fail if 'MatrixExtra' is not loaded)
as(matrix(1:3), "ngRMatrix")
as(as.csc.matrix(m.coo), "dgRMatrix")
</code></pre>

<hr>
<h2 id='csr-linalg'>Linear Algebra functions for CSR matrices</h2><span id='topic+csr-linalg'></span><span id='topic+norm+2CRsparseMatrix+2Ccharacter-method'></span><span id='topic+norm+2CRsparseMatrix+2Cmissing-method'></span><span id='topic+diag+2CRsparseMatrix-method'></span><span id='topic+diag+3C-+2CRsparseMatrix-method'></span>

<h3>Description</h3>

<p>Short wrappers around some linear algebra operators from 'Matrix'
that take CSC matrices, adapted to work for CSR matrices without involving any
data duplication or deep format conversion, thus saving time and memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RsparseMatrix,character'
norm(x, type = "O", ...)

## S4 method for signature 'RsparseMatrix,missing'
norm(x, type = "O", ...)

## S4 method for signature 'RsparseMatrix'
diag(x)

## S4 replacement method for signature 'RsparseMatrix'
diag(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csr-linalg_+3A_x">x</code></td>
<td>
<p>A sparse matrix in CSR format.</p>
</td></tr>
<tr><td><code id="csr-linalg_+3A_type">type</code></td>
<td>
<p>Type of the norm to calculate (see <a href="Matrix.html#topic+norm">norm</a>).</p>
</td></tr>
<tr><td><code id="csr-linalg_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to 'norm'</p>
</td></tr>
<tr><td><code id="csr-linalg_+3A_value">value</code></td>
<td>
<p>Replacement value for the matrix diagonal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same value that 'Matrix' would return for CSC matrices.
</p>

<hr>
<h2 id='deepcopy_sparse_object'>Deep copy sparse matrices and vectors</h2><span id='topic+deepcopy_sparse_object'></span>

<h3>Description</h3>

<p>Generates a deep copy of a sparse matrix or sparse vector
object, which can come useful when the matrix is to later be passed to
functions that will potentially modify it in-place, such as <a href="MatrixExtra.html#topic+sort_sparse_indices">sort_sparse_indices</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deepcopy_sparse_object(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deepcopy_sparse_object_+3A_x">X</code></td>
<td>
<p>A sparse matrix or sparse vector from the 'Matrix' package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same input 'X' with the fields replaced with deep copies.
</p>

<hr>
<h2 id='emptySparse'>Create Empty Sparse Matrix</h2><span id='topic+emptySparse'></span>

<h3>Description</h3>

<p>Creates an empty sparse matrix (all values being zeros)
with the requested format and dimensions. This is a faster alternative
to calling 'Matrix::Matrix(0, ...)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emptySparse(nrow = 0L, ncol = 0L, format = "R", dtype = "d")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emptySparse_+3A_nrow">nrow</code></td>
<td>
<p>Desired number of rows for the matrix.</p>
</td></tr>
<tr><td><code id="emptySparse_+3A_ncol">ncol</code></td>
<td>
<p>Desired number of columns for the matrix.</p>
</td></tr>
<tr><td><code id="emptySparse_+3A_format">format</code></td>
<td>
<p>Storage format for the matrix. Options are:</p>

<ul>
<li><p> &quot;R&quot;, which will output a CSR Matrix (&quot;RsparseMatrix&quot;).
</p>
</li>
<li><p> &quot;C&quot;, which will output a CSC Matrix (&quot;CsparseMatrix&quot;).
</p>
</li>
<li><p> &quot;T&quot;, which will output a COO/triplets Matrix (&quot;TsparseMatrix&quot;).
</p>
</li></ul>
</td></tr>
<tr><td><code id="emptySparse_+3A_dtype">dtype</code></td>
<td>
<p>Data type for the matrix. Options are:</p>

<ul>
<li><p> &quot;d&quot;, which will output a numeric/double type (e.g. &quot;dgRMatrix&quot;).
</p>
</li>
<li><p> &quot;l&quot;, which will output a logical/boolean type.
</p>
</li>
<li><p> &quot;n&quot;, which will output a binary type.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix of general type, with the specific class
determined by 'format' and 'dtype'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### This is very fast despite the large dimensions,
### as no data is held in the resulting object
library(MatrixExtra)
X &lt;- emptySparse(nrow=2^20, ncol=2^25, format="T")
</code></pre>

<hr>
<h2 id='filterSparse'>Filter values of a sparse matrix or vector</h2><span id='topic+filterSparse'></span>

<h3>Description</h3>

<p>Filters the non-zero values of a sparse matrix or sparse
vector object according to a user-provided function (e.g. to take only
values above a certain threshold, or only greater than the mean), returning
a sparse object with the same dimension as the input, but having only
the non-zero values that meet the desired criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterSparse(X, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterSparse_+3A_x">X</code></td>
<td>
<p>A sparse matrix or sparse vector.</p>
</td></tr>
<tr><td><code id="filterSparse_+3A_fn">fn</code></td>
<td>
<p>A function taking as first argument a vector of non-zero values
(which will be extracted from 'X') and returning a logical/boolean vector of
the same length as the first argument, returning 'TRUE' for values that are
to be kept and 'FALSE' for values that are to be discarded.
</p>
<p>Alternatively, can pass a logical/boolean vector of the same length as 'X@x'.
</p>
<p>If any of the returned values is 'NA', will put a 'NA' value at that position.</p>
</td></tr>
<tr><td><code id="filterSparse_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to 'fn'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix or sparse vector of the same class as 'X' and with the
same dimensions, but having only the non-zero values that meet the condition
specificed by 'fn'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)

### Random sparse matrix
set.seed(1)
X &lt;- rsparsematrix(nrow=20, ncol=10, density=0.3)

### Take only values above 0.5
X_filtered &lt;- filterSparse(X, function(x) x &gt;= 0.5)

### Only elements with absolute values less than 0.3
X_filtered &lt;- filterSparse(X, function(x) abs(x) &lt;= 0.3)

### Only values above the mean (among non-zeros)
X_filtered &lt;- filterSparse(X, function(x) x &gt; mean(x))
</code></pre>

<hr>
<h2 id='mapSparse'>Map values of a sparse matrix/vector</h2><span id='topic+mapSparse'></span>

<h3>Description</h3>

<p>Applies a function to the non-zero values of a sparse
object, returning the transformed input with the new non-zero values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapSparse(X, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapSparse_+3A_x">X</code></td>
<td>
<p>A sparse matrix or sparse vector, whose non-zero values will
be transformed/mapped according to 'fn'.</p>
</td></tr>
<tr><td><code id="mapSparse_+3A_fn">fn</code></td>
<td>
<p>A function taking as first argument a vector of non-zero values
(which will be extracted from 'X') and returning another vector of
the same length as the first argument, which will become the non-zero values
of the output.
</p>
<p>Alternatively, can pass a vector of the same length as 'X@x'.
</p>
<p>If the results are of a different type than the input (e.g. input
is 'lsparseMatrix', but 'fn' returns a numeric vector), the type will
be automatically converted to match the type returned by 'fn'.</p>
</td></tr>
<tr><td><code id="mapSparse_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to 'fn'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse object with the same storage order (T/C/R), dimension,
and number of non-zero entries as 'X', but with its non-zero values substituted
by the output from 'fn', and the exact class determined by the type returned
by 'fn'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)

set.seed(1)
X &lt;- rsparsematrix(10, 5, .5)
print(mapSparse(X, function(x) abs(x)+1))
</code></pre>

<hr>
<h2 id='mathematical-functions'>Mathematical functions for CSR and COO matrices</h2><span id='topic+mathematical-functions'></span><span id='topic+sqrt+2CRsparseMatrix-method'></span><span id='topic+sqrt+2CTsparseMatrix-method'></span><span id='topic+abs+2CRsparseMatrix-method'></span><span id='topic+abs+2CTsparseMatrix-method'></span><span id='topic+log1p+2CRsparseMatrix-method'></span><span id='topic+log1p+2CTsparseMatrix-method'></span><span id='topic+sin+2CRsparseMatrix-method'></span><span id='topic+sin+2CTsparseMatrix-method'></span><span id='topic+tan+2CRsparseMatrix-method'></span><span id='topic+tan+2CTsparseMatrix-method'></span><span id='topic+tanh+2CRsparseMatrix-method'></span><span id='topic+tanh+2CTsparseMatrix-method'></span><span id='topic+tanpi+2CRsparseMatrix-method'></span><span id='topic+tanpi+2CTsparseMatrix-method'></span><span id='topic+sinh+2CRsparseMatrix-method'></span><span id='topic+sinh+2CTsparseMatrix-method'></span><span id='topic+atanh+2CRsparseMatrix-method'></span><span id='topic+atanh+2CTsparseMatrix-method'></span><span id='topic+expm1+2CRsparseMatrix-method'></span><span id='topic+expm1+2CTsparseMatrix-method'></span><span id='topic+sign+2CRsparseMatrix-method'></span><span id='topic+sign+2CTsparseMatrix-method'></span><span id='topic+ceiling+2CRsparseMatrix-method'></span><span id='topic+ceiling+2CTsparseMatrix-method'></span><span id='topic+floor+2CRsparseMatrix-method'></span><span id='topic+floor+2CTsparseMatrix-method'></span><span id='topic+trunc+2CRsparseMatrix-method'></span><span id='topic+trunc+2CTsparseMatrix-method'></span><span id='topic+round+2CRsparseMatrix-method'></span><span id='topic+round+2CTsparseMatrix-method'></span><span id='topic+signif+2CRsparseMatrix-method'></span><span id='topic+signif+2CTsparseMatrix-method'></span>

<h3>Description</h3>

<p>Implements some mathematical functions for CSR
(a.k.a. &quot;RsparseMatrix&quot;) and COO (a.k.a. &quot;TsparseMatrix&quot;) matrix types
without converting them to CSC matrices in the process.
</p>
<p>The functions here reduce to applying the same operation over the non-zero elements only,
and as such do not benefit from any storage format conversion as done implicitly
in the 'Matrix' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RsparseMatrix'
sqrt(x)

## S4 method for signature 'TsparseMatrix'
sqrt(x)

## S4 method for signature 'RsparseMatrix'
abs(x)

## S4 method for signature 'TsparseMatrix'
abs(x)

## S4 method for signature 'RsparseMatrix'
log1p(x)

## S4 method for signature 'TsparseMatrix'
log1p(x)

## S4 method for signature 'RsparseMatrix'
sin(x)

## S4 method for signature 'TsparseMatrix'
sin(x)

## S4 method for signature 'RsparseMatrix'
tan(x)

## S4 method for signature 'TsparseMatrix'
tan(x)

## S4 method for signature 'RsparseMatrix'
tanh(x)

## S4 method for signature 'TsparseMatrix'
tanh(x)

## S4 method for signature 'RsparseMatrix'
tanpi(x)

## S4 method for signature 'TsparseMatrix'
tanpi(x)

## S4 method for signature 'RsparseMatrix'
sinh(x)

## S4 method for signature 'TsparseMatrix'
sinh(x)

## S4 method for signature 'RsparseMatrix'
atanh(x)

## S4 method for signature 'TsparseMatrix'
atanh(x)

## S4 method for signature 'RsparseMatrix'
expm1(x)

## S4 method for signature 'TsparseMatrix'
expm1(x)

## S4 method for signature 'RsparseMatrix'
sign(x)

## S4 method for signature 'TsparseMatrix'
sign(x)

## S4 method for signature 'RsparseMatrix'
ceiling(x)

## S4 method for signature 'TsparseMatrix'
ceiling(x)

## S4 method for signature 'RsparseMatrix'
floor(x)

## S4 method for signature 'TsparseMatrix'
floor(x)

## S4 method for signature 'RsparseMatrix'
trunc(x)

## S4 method for signature 'TsparseMatrix'
trunc(x)

## S4 method for signature 'RsparseMatrix'
round(x, digits = 0)

## S4 method for signature 'TsparseMatrix'
round(x, digits = 0)

## S4 method for signature 'RsparseMatrix'
signif(x, digits = 6)

## S4 method for signature 'TsparseMatrix'
signif(x, digits = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mathematical-functions_+3A_x">x</code></td>
<td>
<p>A CSR or COO matrix.</p>
</td></tr>
<tr><td><code id="mathematical-functions_+3A_digits">digits</code></td>
<td>
<p>See <a href="base.html#topic+round">round</a> and <a href="base.html#topic+signif">signif</a>. If passing more than one value,
will call the corresponding function from the 'Matrix' package, which implies first
converting 'x' to CSC format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A CSR or COO matrix depending on the input. They will be of the 'dg' type
('dgRMatrix' or 'dgTMatrix').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)
options("MatrixExtra.quick_show" = FALSE)
set.seed(1)
X &lt;- as.csr.matrix(rsparsematrix(4, 3, .4))
abs(X)
sqrt(X^2)
### This will output CSC
round(X, 1:2)
</code></pre>

<hr>
<h2 id='matmult'>Multithreaded Sparse-Dense Matrix and Vector Multiplications</h2><span id='topic+matmult'></span><span id='topic++25+2A+25+2Cmatrix+2CCsparseMatrix-method'></span><span id='topic++25+2A+25+2Cfloat32+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic+tcrossprod+2Cfloat32+2CRsparseMatrix-method'></span><span id='topic+crossprod+2Cmatrix+2CCsparseMatrix-method'></span><span id='topic+crossprod+2Cfloat32+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2Cfloat32-method'></span><span id='topic+tcrossprod+2CRsparseMatrix+2Cfloat32-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2Cnumeric-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2Clogical-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2Cinteger-method'></span><span id='topic++25+2A+25+2CRsparseMatrix+2CsparseVector-method'></span>

<h3>Description</h3>

<p>Multithreaded &lt;matrix, matrix&gt; multiplications
('%*%', 'crossprod', and 'tcrossprod')
and &lt;matrix, vector&gt; multiplications ('%*%'),
for &lt;sparse, dense&gt; matrix combinations and &lt;sparse, vector&gt; combinations
(See signatures for supported combinations).
</p>
<p>Objects from the 'float' package are also supported for some combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,CsparseMatrix'
x %*% y

## S4 method for signature 'float32,CsparseMatrix'
x %*% y

## S4 method for signature 'matrix,RsparseMatrix'
tcrossprod(x, y)

## S4 method for signature 'float32,RsparseMatrix'
tcrossprod(x, y)

## S4 method for signature 'matrix,CsparseMatrix'
crossprod(x, y)

## S4 method for signature 'float32,CsparseMatrix'
crossprod(x, y)

## S4 method for signature 'RsparseMatrix,matrix'
tcrossprod(x, y)

## S4 method for signature 'RsparseMatrix,matrix'
x %*% y

## S4 method for signature 'RsparseMatrix,float32'
x %*% y

## S4 method for signature 'RsparseMatrix,float32'
tcrossprod(x, y)

## S4 method for signature 'RsparseMatrix,numeric'
x %*% y

## S4 method for signature 'RsparseMatrix,logical'
x %*% y

## S4 method for signature 'RsparseMatrix,integer'
x %*% y

## S4 method for signature 'RsparseMatrix,sparseVector'
x %*% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matmult_+3A_x">x</code>, <code id="matmult_+3A_y">y</code></td>
<td>
<p>dense (<code>matrix</code> / <code>float32</code>)
and sparse (<code>RsparseMatrix</code> / <code>CsparseMatrix</code>) matrices or vectors
(<code>sparseVector</code>, <code>numeric</code>, <code>integer</code>, <code>logical</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Will try to use the maximum available number of threads for the computations
when appropriate. The number of threads can be controlled through the package options
(e.g. 'options(&quot;MatrixExtra.nthreads&quot; = 1)' - see <a href="MatrixExtra.html#topic+MatrixExtra-options">MatrixExtra-options</a>) and will
be set to 1 after running <a href="MatrixExtra.html#topic+restore_old_matrix_behavior">restore_old_matrix_behavior</a>.
</p>
<p>Be aware that sparse-dense matrix multiplications might suffer from reduced
numerical precision, especially when using objects of type 'float32'
(from the 'float' package).
</p>
<p>Internally, these functions use BLAS level-1 routines, so their speed might depend on
the BLAS backend being used (e.g. MKL, OpenBLAS) - that means: they might be quite slow
on a default install of R for Windows (see
<a href="https://github.com/david-cortes/R-openblas-in-windows">this link</a> for
a tutorial about getting OpenBLAS in R for Windows).
</p>
<p>Doing computations in float32 precision depends on the package
<a href="https://cran.r-project.org/package=float">float</a>, and as such comes
with some caveats:</p>

<ul>
<li><p> On Windows, if installing 'float' from CRAN, it will use very unoptimized
routines which will likely result in a slowdown compared to using regular
double (numeric) type. Getting it to use an optimized BLAS library is not as
simple as substituting the Rblas DLL - see the
<a href="https://github.com/wrathematics/float">package's README</a> for details.
</p>
</li>
<li><p> On macOS, it will use static linking for 'float', thus if changing the BLAS
library used by R, it will not change the float32 functions, and getting good
performance out of it might require compiling it from source with '-march=native'
flag.
</p>
</li></ul>

<p>When multiplying a sparse matrix by a sparse vector, their indices
will be sorted in-place (see <a href="MatrixExtra.html#topic+sort_sparse_indices">sort_sparse_indices</a>).
</p>
<p>In order to match exactly with base R's behaviors, when passing vectors to these
operators, will assume their shape as follows:</p>

<ul>
<li><p> MatMult(Matrix, vector): column vector if the matrix has more than one column
or is empty, row vector if the matrix has only one column.
</p>
</li>
<li><p> MatMult(vector, Matrix): row vector if the matrix has more than one row,
column vector if the matrix has only one row.
</p>
</li>
<li><p> MatMul(vector, vector): LHS is a row vector, RHS is a column vector.
</p>
</li>
<li><p> crossprod(Matrix, vector): column vector if the matrix has more than one row,
row vector if the matrix has only one row.
</p>
</li>
<li><p> crossprod(vector, Matrix): column vector.
</p>
</li>
<li><p> crossprod(vector, vector): column vector.
</p>
</li>
<li><p> tcrossprod(Matrix, vector): row vector if the matrix has only one row,
column vector if the matrix has only one column, and will throw an error otherwise.
</p>
</li>
<li><p> tcrossprod(vector, Matrix): row vector if the matrix has more than one column,
column vector if the matrix has only one column.
</p>
</li>
<li><p> tcrossprod(vector, vector): column vector.
</p>
</li></ul>

<p>In general, the output returned by these functions will be a dense matrix from base R,
or a dense matrix from 'float' when one of the inputs is also from the 'float' package,
with the following exceptions:</p>

<ul>
<li><p> MatMult(RsparseMatrix[n,1], vector) -&gt; 'dgRMatrix'.
</p>
</li>
<li><p> MatMult(RsparseMatrix[n,1], sparseVector) -&gt; 'dgCMatrix'.
</p>
</li>
<li><p> MatMult(float32[n], CsparseMatrix[1,m]) -&gt; 'dgCMatrix'.
</p>
</li>
<li><p> tcrossprod(float32[n], RsparseMatrix[m,1]) -&gt; 'dgCMatrix'.
</p>
</li></ul>



<h3>Value</h3>

<p>A dense <code>matrix</code> object in most cases, with some exceptions which might
come in sparse format (see the 'Details' section).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)
### To use all available threads (default)
options("MatrixExtra.nthreads" = parallel::detectCores())
### Example will run with only 1 thread (CRAN policy)
options("MatrixExtra.nthreads" = 1)

## Generate random matrices
set.seed(1)
A &lt;- rsparsematrix(5,4,.5)
B &lt;- rsparsematrix(4,3,.5)

## Now multiply in some supported combinations
as.matrix(A) %*% as.csc.matrix(B)
as.csr.matrix(A) %*% as.matrix(B)
crossprod(as.matrix(B), as.csc.matrix(B))
tcrossprod(as.csr.matrix(A), as.matrix(A))

### Restore the number of threads
options("MatrixExtra.nthreads" = parallel::detectCores())
</code></pre>

<hr>
<h2 id='MatrixExtra'>MatrixExtra package</h2><span id='topic+MatrixExtra'></span><span id='topic+MatrixExtra-package'></span>

<h3>Description</h3>

<p>Additional methods for the sparse matrices and sparse vector classes
from the 'Matrix' package, with an emphasis on the CSR (compressed sparse row) format
(a.k.a. &quot;RsparseMatrix&quot; in 'Matrix' parlance).
</p>
<p>This package provides, among others:</p>

<ul>
<li><p> Fast and multi-threaded matrix multiplications for various combinations of
'&lt;sparse,dense&gt;' and '&lt;dense,sparse&gt;' types (see <a href="#topic+matmult">matmult</a>),
including the dense 'float32' types from the 'float' package
(see <a href="float.html#topic+float-package">float-package</a>).
</p>
</li>
<li><p> Operations that work efficiently in the CSR format, such as concatenating by rows
(see <a href="#topic+rbind2-method">rbind2-method</a>) or selecting rows (see <a href="#topic+slice">slice</a>).
</p>
</li>
<li><p> Convenience conversion functions for the different sparse matrix types
(see <a href="#topic+conversions">conversions</a>).
</p>
</li>
<li><p> Overloaded operators such as &quot;+&quot; or &quot;*&quot; for many combinations of
'&lt;RsparseMatrix,RsparseMatrix&gt;', '&lt;RsparseMatrix,TsparseMatrix&gt;',
'&lt;RsparseMatrix,matrix&gt;', and '&lt;RsparseMatrix,scalar&gt;' (see <a href="#topic+operators">operators</a>).
</p>
</li>
<li><p> Overloaded mathematical functions that work only on the non-zero entries of matrices
(see <a href="#topic+mathematical-functions">mathematical-functions</a>).
</p>
</li>
<li><p> Fast transposes which change the storage format (see <a href="#topic+t_shallow">t_shallow</a>).
</p>
</li>
<li><p> Utility functions for sparse matrices (see e.g.
<a href="#topic+sort_sparse_indices">sort_sparse_indices</a> and <a href="#topic+remove_sparse_zeros">remove_sparse_zeros</a>).
</p>
</li>
<li><p> Faster replacements for many methods from 'Matrix' for all the sparse formats
(COO, CSR, CSC), such as '[' (<a href="#topic+slice">slice</a>), addition ('+'),
elementwise multiplication ('*'), among others (see <a href="#topic+operators">operators</a>).
</p>
</li>
<li><p> Convenience functions for sparse objects, such as <a href="#topic+mapSparse">mapSparse</a>,
<a href="#topic+emptySparse">emptySparse</a>, and a shorter <a href="#topic+show">show</a> method for sparse objects.
</p>
</li></ul>

<p><b>Important:</b> 'MatrixExtra' modifies some important behaviors from the
'Matrix' library, which might cause some functions from 'Matrix' or other
packages to stop working under the default options of 'MatrixExtra'.
See <a href="MatrixExtra.html#topic+MatrixExtra-options">MatrixExtra-options</a> for details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Cortes <a href="mailto:david.cortes.rivera@gmail.com">david.cortes.rivera@gmail.com</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Dmitry Selivanov [copyright holder]
</p>
</li>
<li><p> Thibaut Goetghebuer-Planchon (Copyright holder of included robinmap library) [copyright holder]
</p>
</li>
<li><p> Martin Maechler (Copyright holder of 'Matrix' package from which some code was taken) [copyright holder]
</p>
</li>
<li><p> Robert Gentleman (Copyright holder of mathematical functions used by base R which were copied) [copyright holder]
</p>
</li>
<li><p> Ross Ihaka (Copyright holder of mathematical functions used by base R which were copied) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/david-cortes/MatrixExtra">https://github.com/david-cortes/MatrixExtra</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/david-cortes/MatrixExtra/issues">https://github.com/david-cortes/MatrixExtra/issues</a>
</p>
</li></ul>


<hr>
<h2 id='MatrixExtra-options'>MatrixExtra internal options</h2><span id='topic+MatrixExtra-options'></span><span id='topic+set_new_matrix_behavior'></span><span id='topic+restore_old_matrix_behavior'></span>

<h3>Description</h3>

<p>Controls some of the behaviors when calling methods from
'MatrixExtra' which differ very significantly from the same methods in
'Matrix' and which have the potential for breaking existing code in other packages.
</p>
<p>For example, the function 'Matrix::sparse.model.matrix' might throw errors
if it is called after loading 'library(MatrixExtra)' with the default options,
and the default transpose behavior needs to be modified from 'MatrixExtra' to
make it work again.
</p>
<p>The 'Matrix' package has some particular choice of behaviors which can
inadvertently make operations very inefficient. Particularly:</p>

<ul>
<li><p> When transposing a sparse matrix in CSR or CSC formats, 'Matrix' will
output a transpose in the same storage order. This is a slow operation, as it
requires duplicating the data, creating a new index, and sorting it. In general,
one might not care about the storage order of a sparse matrix until it comes the
time of performing an operation which is more efficient in one format, or one
might want to pass a sparse matrix object to a function from another package which
is not under one's control, for which a slow 't(.)' is undesirable.
</p>
<p>'MatrixExtra' will instead make the default for 't(CSR)' and 't(CSC)' to output
in the opposite format ('t(CSR)' -&gt; 'CSC'; 't(CSC' -&gt; 'CSR'), which does not
involve any changes or duplication in the data, and it's thus much faster.
This in particular could break code in existing packages, particularly in
<b>the 'Matrix' package itself</b>.
The old 'Matrix' behavior can be brought back through
'options(&quot;MatrixExtra.fast_transpose&quot; = FALSE)'.
</p>
<p>For example, the function 'Matrix::sparse.model.matrix' is unlikely to work
under the default fast transpose option, and getting it to work again will
require setting 'options(&quot;MatrixExtra.fast_transpose&quot; = FALSE)' or calling
'MatrixExtra::restore_old_matrix_behavior()'.
</p>
</li>
<li><p> When selecting slices of a sparse matrix with only one row or only one
column, 'Matrix' will by default simplify them to a <b>dense</b> vector, which goes
against the purpose of using sparse structures. With this being the default,
it's possible to inadvertently do this and end up losing all the benefits of
a sparse data structure.
</p>
<p>'MatrixExtra' instead will make the default to simplify them to a <b>sparse</b>
vector (see <a href="dplyr.html#topic+slice">slice</a>). It can be changed back to the 'Matrix' behavior
through 'options(&quot;MatrixExtra.drop_sparse&quot; = FALSE)'.
</p>
</li>
<li><p> When doing some operations which require the indices of sparse matrices to
be sorted, such as elementwise addition and multiplication, 'Matrix' will create
deep copies of the indices and values, which takes extra time but ensures that
no external references to the same objects are impacted, thus playing well with
R's pass-by-value and copy-on-modify semantics, but at the expense of extra time
and memory requirements.
</p>
<p>'MatrixExtra' will instead sort the indices in-place when needed, only doing
deep copies when the values are to be cast to a different type, so that the
object being passed to a given function or operator will always remain usable
(having the same values at the same indices). However, when the indices of a given
object are unsorted and get sorted in-place, if any other R object has references
to the same vector of indices separately from the vector of values or vice-versa,
those objects will see a new vector which is modified, potentially rendering
those external objects unusable.
</p>
<p>If this behavior is problematic, it can be changed back to always making deep copies
through 'options(&quot;MatrixExtra.inplace_sort&quot; = FALSE)'.
</p>
</li>
<li><p> When doing elementwise multiplication ('*') of a sparse matrix by a
dense matrix or vice-versa, if the dense matrix has a 'NA' or 'NaN' element
in a coordinate at which the sparse matrix has no entry, 'Matrix' will preserve
the 'NA' in the resulting output, as does base R. This also applies with the
propagation of 1s when using the '^' operator with zeros in the RHS, and with
propagation of infinities in division by zero.
</p>
<p>'MatrixExtra' will instead ignore such 'NA's, which makes the operation much
faster. The old 'Matrix' behavior can be brought back through
'options(&quot;MatrixExtra.ignore_na&quot; = FALSE)'.
</p>
</li>
<li><p> When doing sparse-dense matrix multiplications, 'Matrix' will run
single-threaded, which is typically undesirable as modern CPUs have the capacity
to perform such operations much faster by exploiting both multi-threading and SIMD
instructions.
</p>
<p>'MatrixExtra' will by default use all the available threads in the system.
The number of threads can be controlled through 'options(&quot;MatrixExtra.nthreads&quot; = 1L)'.
</p>
</li>
<li><p> When calling method 'show' on a sparse matrix object (for example, by typing the
corresponding variable name in an R console and pressing 'Enter', 'Matrix' will
take a glance at the object by printing the values in some or all of the rows and columns,
typically involving a long output which, for a mid-to-large sparse matrix, will typically be
larger than the available screen space and can make it very inconvenient to quickly inspect
sparse objects.
</p>
<p>'MatrixExtra' will instead override this method with a quicker one that will only show
the type, dimensions, and number of entries in a sparse object, without printing the
values per-se as 'Matrix' would do. Note that this only overrides the 'show' method, while
'print' remains the same as it was. It can be changed back to the same 'show' that is
provided by 'Matrix' through 'options(&quot;MatrixExtra.quick_show&quot; = FALSE)'.
</p>
</li></ul>

<p>These behaviors will change at the moment one loads 'MatrixExtra' through
'library(MatrixExtra)', save for the number of threads which will also be set
to the maximum when calling functions as e.g. 'MatrixExtra::&lt;function&gt;(&lt;args&gt;)'
</p>
<p>The package provides two short-hand functions to switch all these options
simultaneously:</p>

<ul>
<li><p> 'restore_old_matrix_behavior': Will change the transpose behavior to deep
transposes in the same format, drop behavior to dense vectors, avoid in-place
sorting of sparse indices, preserve NAs that are not in a sparse matrix in
elementwise multiplication, and set the number of threads to 1.
</p>
<p>These all match with how the 'Matrix' package behaves in such situations.
</p>
</li>
<li><p> 'set_new_matrix_behavior': Will change the transpose behavior to shallow
transposes in the opposite format, drop behavior to sparse vectors, sort sparse
indices in-place when possible, ignore NAs that are not in a sparse matrix in
elementwise multiplication, and set the number of threads to the available
number of threads in the system.
</p>
<p>These all differ with how the 'Matrix' package behaves in such situations.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>set_new_matrix_behavior()

restore_old_matrix_behavior()
</code></pre>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>All options</h3>

<p>List of options with the short-hand command to make them match with 'Matrix'.
</p>

<ul>
<li><p> 'options(&quot;MatrixExtra.fast_transpose&quot; = FALSE)' :
Option for behavior of 't(CSR)' and 't(CSC)'.
</p>
</li>
<li><p> 'options(&quot;MatrixExtra.drop_sparse&quot; = FALSE)' :
Option for behavior of 'drop=TRUE' when subsetting.
</p>
</li>
<li><p> 'options(&quot;MatrixExtra.inplace_sort&quot; = FALSE)' :
Option for behavior of inplace-vs-copy operations.
</p>
</li>
<li><p> 'options(&quot;MatrixExtra.ignore_na&quot; = FALSE)' :
Option for behavior of 'NA's in elementwise
sparse-dense multipliction.
</p>
</li>
<li><p> 'options(&quot;MatrixExtra.nthreads&quot; = 1L)' :
Number of parallel threads to use in sparse-dense matrix
</p>
</li>
<li><p> 'options(&quot;MatrixExtra.quick_show&quot; = FALSE)' :
Option for behavior of 'show' method for sparse objects.
</p>
</li></ul>


<hr>
<h2 id='operators'>Mathematical operators on sparse matrices and sparse vectors</h2><span id='topic+operators'></span><span id='topic++2A+2CRsparseMatrix+2CsparseMatrix-method'></span><span id='topic++2A+2CngRMatrix+2CsparseMatrix-method'></span><span id='topic++2A+2ClgRMatrix+2CsparseMatrix-method'></span><span id='topic++2A+2CsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++2A+2CsparseMatrix+2CngRMatrix-method'></span><span id='topic++2A+2CsparseMatrix+2ClgRMatrix-method'></span><span id='topic++2A+2CCsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++2A+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++26+2CRsparseMatrix+2CsparseMatrix-method'></span><span id='topic++26+2CngRMatrix+2CsparseMatrix-method'></span><span id='topic++26+2ClgRMatrix+2CsparseMatrix-method'></span><span id='topic++26+2CsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++26+2CsparseMatrix+2CngRMatrix-method'></span><span id='topic++26+2CsparseMatrix+2ClgRMatrix-method'></span><span id='topic++26+2CCsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++26+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++2A+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++2A+2CngRMatrix+2Cmatrix-method'></span><span id='topic++2A+2ClgRMatrix+2Cmatrix-method'></span><span id='topic++2A+2CRsparseMatrix+2Cfloat32-method'></span><span id='topic++2A+2CngRMatrix+2Cfloat32-method'></span><span id='topic++2A+2ClgRMatrix+2Cfloat32-method'></span><span id='topic++2A+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic++2A+2Cmatrix+2CngRMatrix-method'></span><span id='topic++2A+2Cmatrix+2ClgRMatrix-method'></span><span id='topic++2A+2Cfloat32+2CRsparseMatrix-method'></span><span id='topic++2A+2Cfloat32+2CngRMatrix-method'></span><span id='topic++2A+2Cfloat32+2ClgRMatrix-method'></span><span id='topic++26+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++26+2CngRMatrix+2Cmatrix-method'></span><span id='topic++26+2ClgRMatrix+2Cmatrix-method'></span><span id='topic++26+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic++26+2Cmatrix+2CngRMatrix-method'></span><span id='topic++26+2Cmatrix+2ClgRMatrix-method'></span><span id='topic++2A+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic++2A+2CTsparseMatrix+2Cfloat32-method'></span><span id='topic++2A+2CngTMatrix+2Cmatrix-method'></span><span id='topic++2A+2ClgTMatrix+2Cmatrix-method'></span><span id='topic++2A+2CngTMatrix+2Cfloat32-method'></span><span id='topic++2A+2ClgTMatrix+2Cfloat32-method'></span><span id='topic++2A+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic++2A+2Cfloat32+2CTsparseMatrix-method'></span><span id='topic++2A+2Cmatrix+2CngTMatrix-method'></span><span id='topic++2A+2Cmatrix+2ClgTMatrix-method'></span><span id='topic++2A+2Cfloat32+2CngTMatrix-method'></span><span id='topic++2A+2Cfloat32+2ClgTMatrix-method'></span><span id='topic++26+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic++26+2CngTMatrix+2Cmatrix-method'></span><span id='topic++26+2ClgTMatrix+2Cmatrix-method'></span><span id='topic++26+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic++26+2Cmatrix+2CngTMatrix-method'></span><span id='topic++26+2Cmatrix+2ClgTMatrix-method'></span><span id='topic++2A+2CCsparseMatrix+2Cmatrix-method'></span><span id='topic++2A+2CCsparseMatrix+2Cfloat32-method'></span><span id='topic++2A+2Cmatrix+2CCsparseMatrix-method'></span><span id='topic++2A+2Cfloat32+2CCsparseMatrix-method'></span><span id='topic++26+2CCsparseMatrix+2Cmatrix-method'></span><span id='topic++26+2CCsparseMatrix+2Cfloat32-method'></span><span id='topic++26+2Cmatrix+2CCsparseMatrix-method'></span><span id='topic++26+2Cfloat32+2CCsparseMatrix-method'></span><span id='topic++2B+2CRsparseMatrix+2CsparseMatrix-method'></span><span id='topic++2B+2CngRMatrix+2CsparseMatrix-method'></span><span id='topic++2B+2ClgRMatrix+2CsparseMatrix-method'></span><span id='topic++2B+2CsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++2B+2CsparseMatrix+2CngRMatrix-method'></span><span id='topic++2B+2CsparseMatrix+2ClgRMatrix-method'></span><span id='topic++2B+2CCsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++2B+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+-+2CRsparseMatrix+2CsparseMatrix-method'></span><span id='topic+-+2CngRMatrix+2CsparseMatrix-method'></span><span id='topic+-+2ClgRMatrix+2CsparseMatrix-method'></span><span id='topic+-+2CsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+-+2CsparseMatrix+2CngRMatrix-method'></span><span id='topic+-+2CsparseMatrix+2ClgRMatrix-method'></span><span id='topic+-+2CCsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+-+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++7C+2CRsparseMatrix+2CsparseMatrix-method'></span><span id='topic++7C+2CngRMatrix+2CsparseMatrix-method'></span><span id='topic++7C+2ClgRMatrix+2CsparseMatrix-method'></span><span id='topic++7C+2CsparseMatrix+2CRsparseMatrix-method'></span><span id='topic++7C+2CsparseMatrix+2CngRMatrix-method'></span><span id='topic++7C+2CsparseMatrix+2ClgRMatrix-method'></span><span id='topic++7C+2CCsparseMatrix+2CTsparseMatrix-method'></span><span id='topic++7C+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic++2A+2CRsparseMatrix+2Cinteger-method'></span><span id='topic++2A+2CRsparseMatrix+2Cnumeric-method'></span><span id='topic++2A+2CRsparseMatrix+2Clogical-method'></span><span id='topic++2A+2Cinteger+2CRsparseMatrix-method'></span><span id='topic++2A+2Cnumeric+2CRsparseMatrix-method'></span><span id='topic++2A+2Clogical+2CRsparseMatrix-method'></span><span id='topic++26+2CRsparseMatrix+2Cinteger-method'></span><span id='topic++26+2CRsparseMatrix+2Cnumeric-method'></span><span id='topic++26+2CRsparseMatrix+2Clogical-method'></span><span id='topic++26+2Cinteger+2CRsparseMatrix-method'></span><span id='topic++26+2Cnumeric+2CRsparseMatrix-method'></span><span id='topic++26+2Clogical+2CRsparseMatrix-method'></span><span id='topic++2F+2CRsparseMatrix+2Cinteger-method'></span><span id='topic++2F+2CRsparseMatrix+2Cnumeric-method'></span><span id='topic++2F+2CRsparseMatrix+2Clogical-method'></span><span id='topic++2F+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++2F+2Cinteger+2CRsparseMatrix-method'></span><span id='topic++2F+2Cnumeric+2CRsparseMatrix-method'></span><span id='topic++2F+2Clogical+2CRsparseMatrix-method'></span><span id='topic++2F+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic++25+25+2CRsparseMatrix+2Cinteger-method'></span><span id='topic++25+25+2CRsparseMatrix+2Cnumeric-method'></span><span id='topic++25+25+2CRsparseMatrix+2Clogical-method'></span><span id='topic++25+25+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++25+25+2Cinteger+2CRsparseMatrix-method'></span><span id='topic++25+25+2Cnumeric+2CRsparseMatrix-method'></span><span id='topic++25+25+2Clogical+2CRsparseMatrix-method'></span><span id='topic++25+25+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic++25+2F+25+2CRsparseMatrix+2Cinteger-method'></span><span id='topic++25+2F+25+2CRsparseMatrix+2Cnumeric-method'></span><span id='topic++25+2F+25+2CRsparseMatrix+2Clogical-method'></span><span id='topic++25+2F+25+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++25+2F+25+2Cinteger+2CRsparseMatrix-method'></span><span id='topic++25+2F+25+2Cnumeric+2CRsparseMatrix-method'></span><span id='topic++25+2F+25+2Clogical+2CRsparseMatrix-method'></span><span id='topic++25+2F+25+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic++5E+2CRsparseMatrix+2Cinteger-method'></span><span id='topic++5E+2CRsparseMatrix+2Cnumeric-method'></span><span id='topic++5E+2CRsparseMatrix+2Clogical-method'></span><span id='topic++5E+2CRsparseMatrix+2Cmatrix-method'></span><span id='topic++5E+2Cinteger+2CRsparseMatrix-method'></span><span id='topic++5E+2Cnumeric+2CRsparseMatrix-method'></span><span id='topic++5E+2Clogical+2CRsparseMatrix-method'></span><span id='topic++5E+2Cmatrix+2CRsparseMatrix-method'></span><span id='topic++2A+2CTsparseMatrix+2Cinteger-method'></span><span id='topic++2A+2CTsparseMatrix+2Cnumeric-method'></span><span id='topic++2A+2CTsparseMatrix+2Clogical-method'></span><span id='topic++2A+2Cinteger+2CTsparseMatrix-method'></span><span id='topic++2A+2Cnumeric+2CTsparseMatrix-method'></span><span id='topic++2A+2Clogical+2CTsparseMatrix-method'></span><span id='topic++26+2CTsparseMatrix+2Cinteger-method'></span><span id='topic++26+2CTsparseMatrix+2Cnumeric-method'></span><span id='topic++26+2CTsparseMatrix+2Clogical-method'></span><span id='topic++26+2Cinteger+2CTsparseMatrix-method'></span><span id='topic++26+2Cnumeric+2CTsparseMatrix-method'></span><span id='topic++26+2Clogical+2CTsparseMatrix-method'></span><span id='topic++2F+2CTsparseMatrix+2Cinteger-method'></span><span id='topic++2F+2CTsparseMatrix+2Cnumeric-method'></span><span id='topic++2F+2CTsparseMatrix+2Clogical-method'></span><span id='topic++2F+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic++2F+2Cinteger+2CTsparseMatrix-method'></span><span id='topic++2F+2Cnumeric+2CTsparseMatrix-method'></span><span id='topic++2F+2Clogical+2CTsparseMatrix-method'></span><span id='topic++2F+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic++25+25+2CTsparseMatrix+2Cinteger-method'></span><span id='topic++25+25+2CTsparseMatrix+2Cnumeric-method'></span><span id='topic++25+25+2CTsparseMatrix+2Clogical-method'></span><span id='topic++25+25+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic++25+25+2Cinteger+2CTsparseMatrix-method'></span><span id='topic++25+25+2Cnumeric+2CTsparseMatrix-method'></span><span id='topic++25+25+2Clogical+2CTsparseMatrix-method'></span><span id='topic++25+25+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic++25+2F+25+2CTsparseMatrix+2Cinteger-method'></span><span id='topic++25+2F+25+2CTsparseMatrix+2Cnumeric-method'></span><span id='topic++25+2F+25+2CTsparseMatrix+2Clogical-method'></span><span id='topic++25+2F+25+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic++25+2F+25+2Cinteger+2CTsparseMatrix-method'></span><span id='topic++25+2F+25+2Cnumeric+2CTsparseMatrix-method'></span><span id='topic++25+2F+25+2Clogical+2CTsparseMatrix-method'></span><span id='topic++25+2F+25+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic++5E+2CTsparseMatrix+2Cinteger-method'></span><span id='topic++5E+2CTsparseMatrix+2Cnumeric-method'></span><span id='topic++5E+2CTsparseMatrix+2Clogical-method'></span><span id='topic++5E+2CTsparseMatrix+2Cmatrix-method'></span><span id='topic++5E+2Cinteger+2CTsparseMatrix-method'></span><span id='topic++5E+2Cnumeric+2CTsparseMatrix-method'></span><span id='topic++5E+2Clogical+2CTsparseMatrix-method'></span><span id='topic++5E+2Cmatrix+2CTsparseMatrix-method'></span><span id='topic++2A+2CRsparseMatrix+2CsparseVector-method'></span><span id='topic++2A+2CsparseVector+2CRsparseMatrix-method'></span><span id='topic++2A+2Cmatrix+2CsparseVector-method'></span><span id='topic++2A+2CsparseVector+2Cmatrix-method'></span><span id='topic++2A+2Cfloat32+2CsparseVector-method'></span><span id='topic++2A+2CsparseVector+2Cfloat32-method'></span>

<h3>Description</h3>

<p>Implements some mathematical operators between sparse-sparse and sparse-dense
matrices and vectors, such as 'CSR + CSR', 'CSR + COO', 'CSR * vector', 'CSR * dense', among
others, which typically work natively in the storage order of the inputs without data duplication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RsparseMatrix,sparseMatrix'
e1 * e2

## S4 method for signature 'ngRMatrix,sparseMatrix'
e1 * e2

## S4 method for signature 'lgRMatrix,sparseMatrix'
e1 * e2

## S4 method for signature 'sparseMatrix,RsparseMatrix'
e1 * e2

## S4 method for signature 'sparseMatrix,ngRMatrix'
e1 * e2

## S4 method for signature 'sparseMatrix,lgRMatrix'
e1 * e2

## S4 method for signature 'CsparseMatrix,TsparseMatrix'
e1 * e2

## S4 method for signature 'TsparseMatrix,CsparseMatrix'
e1 * e2

## S4 method for signature 'RsparseMatrix,sparseMatrix'
e1 &amp; e2

## S4 method for signature 'ngRMatrix,sparseMatrix'
e1 &amp; e2

## S4 method for signature 'lgRMatrix,sparseMatrix'
e1 &amp; e2

## S4 method for signature 'sparseMatrix,RsparseMatrix'
e1 &amp; e2

## S4 method for signature 'sparseMatrix,ngRMatrix'
e1 &amp; e2

## S4 method for signature 'sparseMatrix,lgRMatrix'
e1 &amp; e2

## S4 method for signature 'CsparseMatrix,TsparseMatrix'
e1 &amp; e2

## S4 method for signature 'TsparseMatrix,CsparseMatrix'
e1 &amp; e2

## S4 method for signature 'RsparseMatrix,matrix'
e1 * e2

## S4 method for signature 'ngRMatrix,matrix'
e1 * e2

## S4 method for signature 'lgRMatrix,matrix'
e1 * e2

## S4 method for signature 'RsparseMatrix,float32'
e1 * e2

## S4 method for signature 'ngRMatrix,float32'
e1 * e2

## S4 method for signature 'lgRMatrix,float32'
e1 * e2

## S4 method for signature 'matrix,RsparseMatrix'
e1 * e2

## S4 method for signature 'matrix,ngRMatrix'
e1 * e2

## S4 method for signature 'matrix,lgRMatrix'
e1 * e2

## S4 method for signature 'float32,RsparseMatrix'
e1 * e2

## S4 method for signature 'float32,ngRMatrix'
e1 * e2

## S4 method for signature 'float32,lgRMatrix'
e1 * e2

## S4 method for signature 'RsparseMatrix,matrix'
e1 &amp; e2

## S4 method for signature 'ngRMatrix,matrix'
e1 &amp; e2

## S4 method for signature 'lgRMatrix,matrix'
e1 &amp; e2

## S4 method for signature 'matrix,RsparseMatrix'
e1 &amp; e2

## S4 method for signature 'matrix,ngRMatrix'
e1 &amp; e2

## S4 method for signature 'matrix,lgRMatrix'
e1 &amp; e2

## S4 method for signature 'TsparseMatrix,matrix'
e1 * e2

## S4 method for signature 'TsparseMatrix,float32'
e1 * e2

## S4 method for signature 'ngTMatrix,matrix'
e1 * e2

## S4 method for signature 'lgTMatrix,matrix'
e1 * e2

## S4 method for signature 'ngTMatrix,float32'
e1 * e2

## S4 method for signature 'lgTMatrix,float32'
e1 * e2

## S4 method for signature 'matrix,TsparseMatrix'
e1 * e2

## S4 method for signature 'float32,TsparseMatrix'
e1 * e2

## S4 method for signature 'matrix,ngTMatrix'
e1 * e2

## S4 method for signature 'matrix,lgTMatrix'
e1 * e2

## S4 method for signature 'float32,ngTMatrix'
e1 * e2

## S4 method for signature 'float32,lgTMatrix'
e1 * e2

## S4 method for signature 'TsparseMatrix,matrix'
e1 &amp; e2

## S4 method for signature 'ngTMatrix,matrix'
e1 &amp; e2

## S4 method for signature 'lgTMatrix,matrix'
e1 &amp; e2

## S4 method for signature 'matrix,TsparseMatrix'
e1 &amp; e2

## S4 method for signature 'matrix,ngTMatrix'
e1 &amp; e2

## S4 method for signature 'matrix,lgTMatrix'
e1 &amp; e2

## S4 method for signature 'CsparseMatrix,matrix'
e1 * e2

## S4 method for signature 'CsparseMatrix,float32'
e1 * e2

## S4 method for signature 'matrix,CsparseMatrix'
e1 * e2

## S4 method for signature 'float32,CsparseMatrix'
e1 * e2

## S4 method for signature 'CsparseMatrix,matrix'
e1 &amp; e2

## S4 method for signature 'CsparseMatrix,float32'
e1 &amp; e2

## S4 method for signature 'matrix,CsparseMatrix'
e1 &amp; e2

## S4 method for signature 'float32,CsparseMatrix'
e1 &amp; e2

## S4 method for signature 'RsparseMatrix,sparseMatrix'
e1 + e2

## S4 method for signature 'ngRMatrix,sparseMatrix'
e1 + e2

## S4 method for signature 'lgRMatrix,sparseMatrix'
e1 + e2

## S4 method for signature 'sparseMatrix,RsparseMatrix'
e1 + e2

## S4 method for signature 'sparseMatrix,ngRMatrix'
e1 + e2

## S4 method for signature 'sparseMatrix,lgRMatrix'
e1 + e2

## S4 method for signature 'CsparseMatrix,TsparseMatrix'
e1 + e2

## S4 method for signature 'TsparseMatrix,CsparseMatrix'
e1 + e2

## S4 method for signature 'RsparseMatrix,sparseMatrix'
e1 - e2

## S4 method for signature 'ngRMatrix,sparseMatrix'
e1 - e2

## S4 method for signature 'lgRMatrix,sparseMatrix'
e1 - e2

## S4 method for signature 'sparseMatrix,RsparseMatrix'
e1 - e2

## S4 method for signature 'sparseMatrix,ngRMatrix'
e1 - e2

## S4 method for signature 'sparseMatrix,lgRMatrix'
e1 - e2

## S4 method for signature 'CsparseMatrix,TsparseMatrix'
e1 - e2

## S4 method for signature 'TsparseMatrix,CsparseMatrix'
e1 - e2

## S4 method for signature 'RsparseMatrix,sparseMatrix'
e1 | e2

## S4 method for signature 'ngRMatrix,sparseMatrix'
e1 | e2

## S4 method for signature 'lgRMatrix,sparseMatrix'
e1 | e2

## S4 method for signature 'sparseMatrix,RsparseMatrix'
e1 | e2

## S4 method for signature 'sparseMatrix,ngRMatrix'
e1 | e2

## S4 method for signature 'sparseMatrix,lgRMatrix'
e1 | e2

## S4 method for signature 'CsparseMatrix,TsparseMatrix'
e1 | e2

## S4 method for signature 'TsparseMatrix,CsparseMatrix'
e1 | e2

## S4 method for signature 'RsparseMatrix,integer'
e1 * e2

## S4 method for signature 'RsparseMatrix,numeric'
e1 * e2

## S4 method for signature 'RsparseMatrix,logical'
e1 * e2

## S4 method for signature 'integer,RsparseMatrix'
e1 * e2

## S4 method for signature 'numeric,RsparseMatrix'
e1 * e2

## S4 method for signature 'logical,RsparseMatrix'
e1 * e2

## S4 method for signature 'RsparseMatrix,integer'
e1 &amp; e2

## S4 method for signature 'RsparseMatrix,numeric'
e1 &amp; e2

## S4 method for signature 'RsparseMatrix,logical'
e1 &amp; e2

## S4 method for signature 'integer,RsparseMatrix'
e1 &amp; e2

## S4 method for signature 'numeric,RsparseMatrix'
e1 &amp; e2

## S4 method for signature 'logical,RsparseMatrix'
e1 &amp; e2

## S4 method for signature 'RsparseMatrix,integer'
e1 / e2

## S4 method for signature 'RsparseMatrix,numeric'
e1 / e2

## S4 method for signature 'RsparseMatrix,logical'
e1 / e2

## S4 method for signature 'RsparseMatrix,matrix'
e1 / e2

## S4 method for signature 'integer,RsparseMatrix'
e1 / e2

## S4 method for signature 'numeric,RsparseMatrix'
e1 / e2

## S4 method for signature 'logical,RsparseMatrix'
e1 / e2

## S4 method for signature 'matrix,RsparseMatrix'
e1 / e2

## S4 method for signature 'RsparseMatrix,integer'
e1 %% e2

## S4 method for signature 'RsparseMatrix,numeric'
e1 %% e2

## S4 method for signature 'RsparseMatrix,logical'
e1 %% e2

## S4 method for signature 'RsparseMatrix,matrix'
e1 %% e2

## S4 method for signature 'integer,RsparseMatrix'
e1 %% e2

## S4 method for signature 'numeric,RsparseMatrix'
e1 %% e2

## S4 method for signature 'logical,RsparseMatrix'
e1 %% e2

## S4 method for signature 'matrix,RsparseMatrix'
e1 %% e2

## S4 method for signature 'RsparseMatrix,integer'
e1 %/% e2

## S4 method for signature 'RsparseMatrix,numeric'
e1 %/% e2

## S4 method for signature 'RsparseMatrix,logical'
e1 %/% e2

## S4 method for signature 'RsparseMatrix,matrix'
e1 %/% e2

## S4 method for signature 'integer,RsparseMatrix'
e1 %/% e2

## S4 method for signature 'numeric,RsparseMatrix'
e1 %/% e2

## S4 method for signature 'logical,RsparseMatrix'
e1 %/% e2

## S4 method for signature 'matrix,RsparseMatrix'
e1 %/% e2

## S4 method for signature 'RsparseMatrix,integer'
e1 ^ e2

## S4 method for signature 'RsparseMatrix,numeric'
e1 ^ e2

## S4 method for signature 'RsparseMatrix,logical'
e1 ^ e2

## S4 method for signature 'RsparseMatrix,matrix'
e1 ^ e2

## S4 method for signature 'integer,RsparseMatrix'
e1 ^ e2

## S4 method for signature 'numeric,RsparseMatrix'
e1 ^ e2

## S4 method for signature 'logical,RsparseMatrix'
e1 ^ e2

## S4 method for signature 'matrix,RsparseMatrix'
e1 ^ e2

## S4 method for signature 'TsparseMatrix,integer'
e1 * e2

## S4 method for signature 'TsparseMatrix,numeric'
e1 * e2

## S4 method for signature 'TsparseMatrix,logical'
e1 * e2

## S4 method for signature 'integer,TsparseMatrix'
e1 * e2

## S4 method for signature 'numeric,TsparseMatrix'
e1 * e2

## S4 method for signature 'logical,TsparseMatrix'
e1 * e2

## S4 method for signature 'TsparseMatrix,integer'
e1 &amp; e2

## S4 method for signature 'TsparseMatrix,numeric'
e1 &amp; e2

## S4 method for signature 'TsparseMatrix,logical'
e1 &amp; e2

## S4 method for signature 'integer,TsparseMatrix'
e1 &amp; e2

## S4 method for signature 'numeric,TsparseMatrix'
e1 &amp; e2

## S4 method for signature 'logical,TsparseMatrix'
e1 &amp; e2

## S4 method for signature 'TsparseMatrix,integer'
e1 / e2

## S4 method for signature 'TsparseMatrix,numeric'
e1 / e2

## S4 method for signature 'TsparseMatrix,logical'
e1 / e2

## S4 method for signature 'TsparseMatrix,matrix'
e1 / e2

## S4 method for signature 'integer,TsparseMatrix'
e1 / e2

## S4 method for signature 'numeric,TsparseMatrix'
e1 / e2

## S4 method for signature 'logical,TsparseMatrix'
e1 / e2

## S4 method for signature 'matrix,TsparseMatrix'
e1 / e2

## S4 method for signature 'TsparseMatrix,integer'
e1 %% e2

## S4 method for signature 'TsparseMatrix,numeric'
e1 %% e2

## S4 method for signature 'TsparseMatrix,logical'
e1 %% e2

## S4 method for signature 'TsparseMatrix,matrix'
e1 %% e2

## S4 method for signature 'integer,TsparseMatrix'
e1 %% e2

## S4 method for signature 'numeric,TsparseMatrix'
e1 %% e2

## S4 method for signature 'logical,TsparseMatrix'
e1 %% e2

## S4 method for signature 'matrix,TsparseMatrix'
e1 %% e2

## S4 method for signature 'TsparseMatrix,integer'
e1 %/% e2

## S4 method for signature 'TsparseMatrix,numeric'
e1 %/% e2

## S4 method for signature 'TsparseMatrix,logical'
e1 %/% e2

## S4 method for signature 'TsparseMatrix,matrix'
e1 %/% e2

## S4 method for signature 'integer,TsparseMatrix'
e1 %/% e2

## S4 method for signature 'numeric,TsparseMatrix'
e1 %/% e2

## S4 method for signature 'logical,TsparseMatrix'
e1 %/% e2

## S4 method for signature 'matrix,TsparseMatrix'
e1 %/% e2

## S4 method for signature 'TsparseMatrix,integer'
e1 ^ e2

## S4 method for signature 'TsparseMatrix,numeric'
e1 ^ e2

## S4 method for signature 'TsparseMatrix,logical'
e1 ^ e2

## S4 method for signature 'TsparseMatrix,matrix'
e1 ^ e2

## S4 method for signature 'integer,TsparseMatrix'
e1 ^ e2

## S4 method for signature 'numeric,TsparseMatrix'
e1 ^ e2

## S4 method for signature 'logical,TsparseMatrix'
e1 ^ e2

## S4 method for signature 'matrix,TsparseMatrix'
e1 ^ e2

## S4 method for signature 'RsparseMatrix,sparseVector'
e1 * e2

## S4 method for signature 'sparseVector,RsparseMatrix'
e1 * e2

## S4 method for signature 'matrix,sparseVector'
e1 * e2

## S4 method for signature 'sparseVector,matrix'
e1 * e2

## S4 method for signature 'float32,sparseVector'
e1 * e2

## S4 method for signature 'sparseVector,float32'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operators_+3A_e1">e1</code></td>
<td>
<p>A sparse or dense matrix or vector/</p>
</td></tr>
<tr><td><code id="operators_+3A_e2">e2</code></td>
<td>
<p>Another sparse or dense matrix or vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, when doing elementwise multiplication ('*') between a sparse and a dense
matrix or vice-versa, if the dense matrix has missing values ('NA' / 'NaN') at some coordinate in
which the sparse matrix has no present entry, the resulting output will not have an entry there either,
which differs from the behavior of 'Matrix' and base R, but makes the operation much faster.
The same applies to division by zero and exponentiation to zero.
</p>
<p>If such missing values (or infinites and ones) are to be preserved, this behavior can be
changed through the package options (i.e. 'options(&quot;MatrixExtra.ignore_na&quot; = FALSE)' - see
<a href="MatrixExtra.html#topic+MatrixExtra-options">MatrixExtra-options</a>).
</p>
<p>The indices of the matrices might be sorted in-place for some operations
(see <a href="MatrixExtra.html#topic+sort_sparse_indices">sort_sparse_indices</a>).
</p>


<h3>Value</h3>

<p>A CSR or COO matrix depending on the input type and operation. Some operations
(blocked by default) will produce dense matrices as outputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)
set.seed(1)
X &lt;- rsparsematrix(4, 3, .5, repr="R")
options("MatrixExtra.quick_show" = FALSE)
X + X
X * X
X * as.coo.matrix(X)
X * 2
X * 1:4
X ^ 2
X ^ (1:4)

### Beware
set_new_matrix_behavior()
print(suppressWarnings(X / 0))
restore_old_matrix_behavior()
print(suppressWarnings(X / 0))
</code></pre>

<hr>
<h2 id='rbind_csr'>Concatenate inputs by rows into a CSR matrix</h2><span id='topic+rbind_csr'></span>

<h3>Description</h3>

<p>Concatenate two or more matrices and/or vectors by rows, giving a CSR matrix
as result.
</p>
<p>This is aimed at concatenating several CSR matrices or sparse vectors at a time,
as it will be faster than calling 'rbind' which will only concatenate one at a
time, resulting in unnecessary allocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_csr(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind_csr_+3A_...">...</code></td>
<td>
<p>Inputs to concatenate. The function is aimed at CSR matrices ('dgRMatrix',
'ngRMatrix', 'lgRMatrix') and sparse vectors ('sparseVector'). It will work with other classes
(such as 'dgCMatrix') but will not be as efficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will not preserve the column names, if any were present.
</p>


<h3>Value</h3>

<p>A CSR matrix (class 'dgRMatrix', 'lgRMatrix', or 'ngRMatrix' depending on the inputs) with
the inputs concatenated by rows.
</p>


<h3>See Also</h3>

<p><a href="MatrixExtra.html#topic+rbind2-method">rbind2-method</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)
options("MatrixExtra.quick_show" = FALSE)
v &lt;- as(1:10, "sparseVector")
rbind_csr(v, v, v)

X &lt;- matrix(1:20, nrow=2)
rbind_csr(X, v)
</code></pre>

<hr>
<h2 id='rbind2-method'>Concatenate sparse matrices/vectors by rows</h2><span id='topic+rbind2-method'></span><span id='topic+rbind2+2CRsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+rbind2+2CsparseVector+2CRsparseMatrix-method'></span><span id='topic+rbind2+2CRsparseMatrix+2CsparseVector-method'></span><span id='topic+rbind2+2CsparseVector+2CsparseVector-method'></span><span id='topic+rbind2+2CCsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+rbind2+2CsparseVector+2CCsparseMatrix-method'></span><span id='topic+rbind2+2CCsparseMatrix+2CsparseVector-method'></span><span id='topic+rbind2+2CRsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+rbind2+2CCsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+rbind2+2CRsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+rbind2+2CTsparseMatrix+2CRsparseMatrix-method'></span><span id='topic+rbind2+2CRsparseMatrix+2Cnumeric-method'></span><span id='topic+rbind2+2CRsparseMatrix+2Cinteger-method'></span><span id='topic+rbind2+2CRsparseMatrix+2Clogical-method'></span><span id='topic+rbind2+2Cnumeric+2CRsparseMatrix-method'></span><span id='topic+rbind2+2Cinteger+2CRsparseMatrix-method'></span><span id='topic+rbind2+2Clogical+2CRsparseMatrix-method'></span><span id='topic+rbind2+2CTsparseMatrix+2CTsparseMatrix-method'></span><span id='topic+rbind2+2CTsparseMatrix+2CsparseVector-method'></span><span id='topic+rbind2+2CsparseVector+2CTsparseMatrix-method'></span><span id='topic+rbind2+2CTsparseMatrix+2CCsparseMatrix-method'></span><span id='topic+rbind2+2CCsparseMatrix+2CTsparseMatrix-method'></span>

<h3>Description</h3>

<p>'rbind2' method for the sparse matrix and sparse vector classes from 'Matrix',
taking the most efficient route for the concatenation according to the input types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RsparseMatrix,RsparseMatrix'
rbind2(x, y)

## S4 method for signature 'sparseVector,RsparseMatrix'
rbind2(x, y)

## S4 method for signature 'RsparseMatrix,sparseVector'
rbind2(x, y)

## S4 method for signature 'sparseVector,sparseVector'
rbind2(x, y)

## S4 method for signature 'CsparseMatrix,CsparseMatrix'
rbind2(x, y)

## S4 method for signature 'sparseVector,CsparseMatrix'
rbind2(x, y)

## S4 method for signature 'CsparseMatrix,sparseVector'
rbind2(x, y)

## S4 method for signature 'CsparseMatrix,CsparseMatrix'
rbind2(x, y)

## S4 method for signature 'RsparseMatrix,CsparseMatrix'
rbind2(x, y)

## S4 method for signature 'CsparseMatrix,RsparseMatrix'
rbind2(x, y)

## S4 method for signature 'RsparseMatrix,TsparseMatrix'
rbind2(x, y)

## S4 method for signature 'TsparseMatrix,RsparseMatrix'
rbind2(x, y)

## S4 method for signature 'RsparseMatrix,numeric'
rbind2(x, y)

## S4 method for signature 'RsparseMatrix,integer'
rbind2(x, y)

## S4 method for signature 'RsparseMatrix,logical'
rbind2(x, y)

## S4 method for signature 'numeric,RsparseMatrix'
rbind2(x, y)

## S4 method for signature 'integer,RsparseMatrix'
rbind2(x, y)

## S4 method for signature 'logical,RsparseMatrix'
rbind2(x, y)

## S4 method for signature 'TsparseMatrix,TsparseMatrix'
rbind2(x, y)

## S4 method for signature 'TsparseMatrix,sparseVector'
rbind2(x, y)

## S4 method for signature 'sparseVector,TsparseMatrix'
rbind2(x, y)

## S4 method for signature 'TsparseMatrix,CsparseMatrix'
rbind2(x, y)

## S4 method for signature 'CsparseMatrix,TsparseMatrix'
rbind2(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind2-method_+3A_x">x</code></td>
<td>
<p>First matrix to concatenate.</p>
</td></tr>
<tr><td><code id="rbind2-method_+3A_y">y</code></td>
<td>
<p>Second matrix to concatenate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix, usually in CSR format but some combinations
might return COO or CSC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)
set.seed(1)
X &lt;- rsparsematrix(3, 4, .3)
X &lt;- as(X, "RsparseMatrix")
inherits(rbind2(X, X), "RsparseMatrix")
inherits(rbind(X, X, as.csc.matrix(X), X), "RsparseMatrix")
inherits(rbind2(as.coo.matrix(X), as.coo.matrix(X)), "TsparseMatrix")
inherits(rbind2(as.csc.matrix(X), as.csc.matrix(X)), "CsparseMatrix")
</code></pre>

<hr>
<h2 id='remove_sparse_zeros'>Remove Zeros from a Sparse Matrix or Sparse Vector</h2><span id='topic+remove_sparse_zeros'></span>

<h3>Description</h3>

<p>Removes the entries in a sparse matrix or sparse vector which
have a value of zero but nevertheless are still among the object's values,
in any case there are any. Can also remove missing values if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_sparse_zeros(X, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_sparse_zeros_+3A_x">X</code></td>
<td>
<p>A sparse matrix (COO, CSR, CSC) or sparse vector (any type)
from the 'Matrix' package, whose values will be removed (left as non-present in the
sparse representation) if they are zeros.</p>
</td></tr>
<tr><td><code id="remove_sparse_zeros_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to also remove missing values ('NA' / 'NaN') from 'X'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same matrix / vector X with its zeros removed from the sparse representation.
</p>

<hr>
<h2 id='show'>Quick Glance at Sparse Objects</h2><span id='topic+show'></span><span id='topic+show+2CsparseMatrix-method'></span><span id='topic+show+2CsparseVector-method'></span><span id='topic+print+2CsparseVector-method'></span>

<h3>Description</h3>

<p>Shows some basic information about a sparse matrix or sparse vector object,
without printing a subset of its entries as 'Matrix' would do.
</p>
<p>Note that this package will by default override the 'show' methods of sparse objects, but not
the &lsquo;print' methods - for example, if one defines a variable &rsquo;X' containing a sparse matrix, and
then types 'X' in the console, that calls the 'show' method, but one can still print it by calling
'print(X)'.
</p>
<p>In order to restore the 'show' method provided by 'Matrix', call 'options(&quot;MatrixExtra.quick_show&quot; = FALSE)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sparseMatrix'
show(object)

## S4 method for signature 'sparseVector'
show(object)

## S4 method for signature 'sparseVector'
print(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_object">object</code></td>
<td>
<p>A sparse matrix or sparse vector.</p>
</td></tr>
<tr><td><code id="show_+3A_x">x</code></td>
<td>
<p>A sparse vector (same method as in matrix, readded here to avoid naming conflicts).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same object that was passed as input, as invisible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)

set.seed(1)
X &lt;- Matrix::rsparsematrix(5, 5, .2)
set_new_matrix_behavior()
show(X)
print(X)
X

restore_old_matrix_behavior()
show(X)
print(X)
X
</code></pre>

<hr>
<h2 id='slice'>Sparse Matrices Slicing</h2><span id='topic+slice'></span><span id='topic++5B+2CRsparseMatrix+2Cindex+2Cindex+2Clogical-method'></span><span id='topic++5B+2CRsparseMatrix+2Cmissing+2Cindex+2Clogical-method'></span><span id='topic++5B+2CRsparseMatrix+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CRsparseMatrix+2Cmissing+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CRsparseMatrix+2Cindex+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CRsparseMatrix+2Cmissing+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CRsparseMatrix+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CRsparseMatrix+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CANY+2CnsparseVector+2CnsparseVector+2Clogical-method'></span><span id='topic++5B+2CANY+2Cmissing+2CnsparseVector+2Clogical-method'></span><span id='topic++5B+2CANY+2CnsparseVector+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CANY+2Cindex+2CnsparseVector+2Clogical-method'></span><span id='topic++5B+2CANY+2CnsparseVector+2Cindex+2Clogical-method'></span><span id='topic++5B+2CANY+2CnsparseVector+2CnsparseVector+2Cmissing-method'></span><span id='topic++5B+2CANY+2Cmissing+2CnsparseVector+2Cmissing-method'></span><span id='topic++5B+2CANY+2CnsparseVector+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CANY+2Cindex+2CnsparseVector+2Cmissing-method'></span><span id='topic++5B+2CANY+2CnsparseVector+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CANY+2ClsparseVector+2ClsparseVector+2Clogical-method'></span><span id='topic++5B+2CANY+2Cmissing+2ClsparseVector+2Clogical-method'></span><span id='topic++5B+2CANY+2ClsparseVector+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CANY+2Cindex+2ClsparseVector+2Clogical-method'></span><span id='topic++5B+2CANY+2ClsparseVector+2Cindex+2Clogical-method'></span><span id='topic++5B+2CANY+2ClsparseVector+2ClsparseVector+2Cmissing-method'></span><span id='topic++5B+2CANY+2Cmissing+2ClsparseVector+2Cmissing-method'></span><span id='topic++5B+2CANY+2ClsparseVector+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CANY+2Cindex+2ClsparseVector+2Cmissing-method'></span><span id='topic++5B+2CANY+2ClsparseVector+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CCsparseMatrix+2Cindex+2Cindex+2Clogical-method'></span><span id='topic++5B+2CCsparseMatrix+2Cmissing+2Cindex+2Clogical-method'></span><span id='topic++5B+2CCsparseMatrix+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CCsparseMatrix+2Cmissing+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CCsparseMatrix+2Cindex+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CCsparseMatrix+2Cmissing+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CCsparseMatrix+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CCsparseMatrix+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CTsparseMatrix+2Cindex+2Cindex+2Clogical-method'></span><span id='topic++5B+2CTsparseMatrix+2Cmissing+2Cindex+2Clogical-method'></span><span id='topic++5B+2CTsparseMatrix+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CTsparseMatrix+2Cmissing+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CTsparseMatrix+2Cindex+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CTsparseMatrix+2Cmissing+2Cindex+2Cmissing-method'></span><span id='topic++5B+2CTsparseMatrix+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CTsparseMatrix+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Natively slice CSR/CSC/COO matrices without changing the storage order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RsparseMatrix,index,index,logical'
x[i, j, drop]

## S4 method for signature 'RsparseMatrix,missing,index,logical'
x[i, j, drop]

## S4 method for signature 'RsparseMatrix,index,missing,logical'
x[i, j, drop]

## S4 method for signature 'RsparseMatrix,missing,missing,logical'
x[i, j, drop]

## S4 method for signature 'RsparseMatrix,index,index,missing'
x[i, j, drop]

## S4 method for signature 'RsparseMatrix,missing,index,missing'
x[i, j, drop]

## S4 method for signature 'RsparseMatrix,index,missing,missing'
x[i, j, drop]

## S4 method for signature 'RsparseMatrix,missing,missing,missing'
x[i, j, drop]

## S4 method for signature 'ANY,nsparseVector,nsparseVector,logical'
x[i, j, drop]

## S4 method for signature 'ANY,missing,nsparseVector,logical'
x[i, j, drop]

## S4 method for signature 'ANY,nsparseVector,missing,logical'
x[i, j, drop]

## S4 method for signature 'ANY,index,nsparseVector,logical'
x[i, j, drop]

## S4 method for signature 'ANY,nsparseVector,index,logical'
x[i, j, drop]

## S4 method for signature 'ANY,nsparseVector,nsparseVector,missing'
x[i, j, drop]

## S4 method for signature 'ANY,missing,nsparseVector,missing'
x[i, j, drop]

## S4 method for signature 'ANY,nsparseVector,missing,missing'
x[i, j, drop]

## S4 method for signature 'ANY,index,nsparseVector,missing'
x[i, j, drop]

## S4 method for signature 'ANY,nsparseVector,index,missing'
x[i, j, drop]

## S4 method for signature 'ANY,lsparseVector,lsparseVector,logical'
x[i, j, drop]

## S4 method for signature 'ANY,missing,lsparseVector,logical'
x[i, j, drop]

## S4 method for signature 'ANY,lsparseVector,missing,logical'
x[i, j, drop]

## S4 method for signature 'ANY,index,lsparseVector,logical'
x[i, j, drop]

## S4 method for signature 'ANY,lsparseVector,index,logical'
x[i, j, drop]

## S4 method for signature 'ANY,lsparseVector,lsparseVector,missing'
x[i, j, drop]

## S4 method for signature 'ANY,missing,lsparseVector,missing'
x[i, j, drop]

## S4 method for signature 'ANY,lsparseVector,missing,missing'
x[i, j, drop]

## S4 method for signature 'ANY,index,lsparseVector,missing'
x[i, j, drop]

## S4 method for signature 'ANY,lsparseVector,index,missing'
x[i, j, drop]

## S4 method for signature 'CsparseMatrix,index,index,logical'
x[i, j, drop]

## S4 method for signature 'CsparseMatrix,missing,index,logical'
x[i, j, drop]

## S4 method for signature 'CsparseMatrix,index,missing,logical'
x[i, j, drop]

## S4 method for signature 'CsparseMatrix,missing,missing,logical'
x[i, j, drop]

## S4 method for signature 'CsparseMatrix,index,index,missing'
x[i, j, drop]

## S4 method for signature 'CsparseMatrix,missing,index,missing'
x[i, j, drop]

## S4 method for signature 'CsparseMatrix,index,missing,missing'
x[i, j, drop]

## S4 method for signature 'CsparseMatrix,missing,missing,missing'
x[i, j, drop]

## S4 method for signature 'TsparseMatrix,index,index,logical'
x[i, j, drop]

## S4 method for signature 'TsparseMatrix,missing,index,logical'
x[i, j, drop]

## S4 method for signature 'TsparseMatrix,index,missing,logical'
x[i, j, drop]

## S4 method for signature 'TsparseMatrix,missing,missing,logical'
x[i, j, drop]

## S4 method for signature 'TsparseMatrix,index,index,missing'
x[i, j, drop]

## S4 method for signature 'TsparseMatrix,missing,index,missing'
x[i, j, drop]

## S4 method for signature 'TsparseMatrix,index,missing,missing'
x[i, j, drop]

## S4 method for signature 'TsparseMatrix,missing,missing,missing'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_+3A_x">x</code></td>
<td>
<p>A sparse matrix to subset, in any format.</p>
</td></tr>
<tr><td><code id="slice_+3A_i">i</code></td>
<td>
<p>row indices to subset.</p>
</td></tr>
<tr><td><code id="slice_+3A_j">j</code></td>
<td>
<p>column indices to subset.</p>
</td></tr>
<tr><td><code id="slice_+3A_drop">drop</code></td>
<td>
<p>whether to simplify 1d matrix to a vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Important:</b> When slicing sparse matrices with 'drop=TRUE' (the default),
'Matrix' will drop 1-d matrices to <b>dense</b> dense vectors, whereas
this package allows dropping them to either dense or <b>sparse</b> vectors,
the latter of which is more efficient and is the default option.
</p>
<p>The 'drop' behavior can be changed back to dense vectors like 'Matrix' does,
through <a href="MatrixExtra.html#topic+restore_old_matrix_behavior">restore_old_matrix_behavior</a> or through the package options
(e.g. 'options(&quot;MatrixExtra.drop_sparse&quot; = FALSE)' - see <a href="MatrixExtra.html#topic+MatrixExtra-options">MatrixExtra-options</a>).
</p>
<p><b>Note:</b> Trying to slice a sparse matrix without supplying any parameter for the
second axis (e.g. 'X[1:10]') will <b>select whole rows</b> (as if it were 'X[1:10,]')
instead of selecting entries as if the input were a flattened array (which is what
'Matrix' and base R do).
</p>
<p>This package will override the subsetting methods from 'Matrix' for all
sparse matrix types. It is usually much faster for all three storage orders (especially
CSR) but in some situations could end up being slightly slower. Be aware that, in the
case of COO matrices (a.k.a. &quot;TsparseMatrix&quot;), the resulting object will <b>not</b>
have sorted indices, which 'Matrix' will oftentimes do in addition to subsetting,
at a large speed penalty.
</p>
<p>In general, it's much faster to select rows when the input is a CSR matrix (&quot;RsparseMatrix&quot;),
and much faster to select columns when the input is a CSC matrix (&quot;CsparseMatrix&quot;).
Slicing COO matrices is typically not efficient, but could end up being faster when
the slice involves random rows and random columns with repeated entries.
</p>


<h3>Value</h3>

<p>A sparse matrix with the same storage order and dtype as 'x'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)
m &lt;- rsparsematrix(20, 20, 0.1, repr="R")
inherits(m[1:2, ], "RsparseMatrix")
inherits(m[1:2, 3:4], "RsparseMatrix")
inherits(as.coo.matrix(m)[1:2, 3:4], "TsparseMatrix")
inherits(as.csc.matrix(m)[1:2, 3:4], "CsparseMatrix")

### New: slice with a sparse vector
m[as(c(TRUE,FALSE), "sparseVector"), ]

### Important!!!
### This differs from Matrix
set_new_matrix_behavior()
inherits(m[1,,drop=TRUE], "sparseVector")

### To bring back the old behavior:
restore_old_matrix_behavior()
inherits(m[1,,drop=TRUE], "numeric")
</code></pre>

<hr>
<h2 id='sort_sparse_indices'>Sort the indices of a sparse matrix or sparse vector</h2><span id='topic+sort_sparse_indices'></span>

<h3>Description</h3>

<p>Will sort the indices of a sparse matrix or sparse vector.
</p>
<p>In general, the indices of sparse CSR and CSC matrices are always meant to be sorted, and
it should be rare to have a matrix with unsorted indices when the matrix is the
output of some built-in operation from either 'Matrix' or 'MatrixExtra', but when
the matrices are constructed manually this function can come in handy.
</p>
<p><b>Important:</b> the input matrix will be modified in-place, unless passing
'copy=TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_sparse_indices(X, copy = FALSE, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_sparse_indices_+3A_x">X</code></td>
<td>
<p>A sparse matrix in CSR, CSC, or COO format; or a sparse vector
(from the 'Matrix' package.)</p>
</td></tr>
<tr><td><code id="sort_sparse_indices_+3A_copy">copy</code></td>
<td>
<p>Whether to make a deep copy of the indices and the values before sorting
them, so that the in-place modifications will not affect any potential external
references to the same arrays.</p>
</td></tr>
<tr><td><code id="sort_sparse_indices_+3A_byrow">byrow</code></td>
<td>
<p>When passing a COO matrix (&quot;TsparseMatrix&quot;), whether to sort it
with rows as the major axis, which differs from 'Matrix' that usually
sorts them with columns as the major axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same input 'X' with its indices sorted, as invisible (no auto print).
Note that the input is itself modified, so there is no need to reassign it.
</p>

<hr>
<h2 id='t_shallow'>Transpose a sparse matrix by changing its format</h2><span id='topic+t_shallow'></span><span id='topic+t_deep'></span><span id='topic+t+2CRsparseMatrix-method'></span><span id='topic+t+2CCsparseMatrix-method'></span><span id='topic+t+2CTsparseMatrix-method'></span><span id='topic+t+2CdgCMatrix-method'></span><span id='topic+t+2CngCMatrix-method'></span><span id='topic+t+2ClgCMatrix-method'></span><span id='topic+t+2CdtCMatrix-method'></span><span id='topic+t+2CntCMatrix-method'></span><span id='topic+t+2CltCMatrix-method'></span><span id='topic+t+2CdsCMatrix-method'></span><span id='topic+t+2CnsCMatrix-method'></span><span id='topic+t+2ClsCMatrix-method'></span><span id='topic+t+2CsparseVector-method'></span>

<h3>Description</h3>

<p>Transposes a sparse matrix in CSC (a.k.a. &quot;CsparseMatrix&quot;)
or CSR (a.k.a. &quot;RsparseMatrix&quot;) formats by converting it to the opposite format
(i.e. CSC -&gt; CSR, CSR -&gt; CSC).
</p>
<p>This implies only a shallow copy (i.e. it's much faster), as the only necessary thing to make
such transpose operation is to swap the number of rows and columns and change the class
of the object (all data remains the same), avoiding any deep copying and
format conversion as when e.g. creating a CSC transpose of a CSC matrix.
</p>
<p>If the input is neither a CSR not CSC matrix, it will just call the generic 't()' method.
</p>
<p>Also provided is a function 't_deep' which outputs a transpose with the same storage order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_shallow(x)

t_deep(x)

## S4 method for signature 'RsparseMatrix'
t(x)

## S4 method for signature 'CsparseMatrix'
t(x)

## S4 method for signature 'TsparseMatrix'
t(x)

## S4 method for signature 'dgCMatrix'
t(x)

## S4 method for signature 'ngCMatrix'
t(x)

## S4 method for signature 'lgCMatrix'
t(x)

## S4 method for signature 'dtCMatrix'
t(x)

## S4 method for signature 'ntCMatrix'
t(x)

## S4 method for signature 'ltCMatrix'
t(x)

## S4 method for signature 'dsCMatrix'
t(x)

## S4 method for signature 'nsCMatrix'
t(x)

## S4 method for signature 'lsCMatrix'
t(x)

## S4 method for signature 'sparseVector'
t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_shallow_+3A_x">x</code></td>
<td>
<p>A sparse matrix. If 'x' is of a different type, will just invoke its generic
't()' method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Important:</b> When loading this package ('library(MatrixExtra)'), it will
change the behavior of 't(sparseMatrix)' towards calling 't_shallow'.
</p>
<p>This makes it more efficient, but has the potential of breaking existing code in other
packages, particularly in the 'Matrix' package itself when calling some arbitrary
function or method which would internally transpose a CSC matrix and rely on the assumption
that its output is also CSC.
</p>
<p>This behavior can be changed through <a href="MatrixExtra.html#topic+restore_old_matrix_behavior">restore_old_matrix_behavior</a> or
the package options (e.g. 'options(&quot;MatrixExtra.fast_transpose&quot; = FALSE)' -
ee <a href="MatrixExtra.html#topic+MatrixExtra-options">MatrixExtra-options</a>) to have 't_deep' as the default, just like in 'Matrix'.
</p>
<p>Additionally, under the new behavior ('t_shallow' as the default for 't'),
transposing a 'sparseVector' object will yield a CSR matrix (&quot;RsparseMatrix&quot;),
which differs from 'Matrix' that would yield a COO matrix (&quot;TsparseMatrix&quot;).
</p>


<h3>Value</h3>

<p>The transpose of 'x' (rows become columns and columns become rows),
but in the opposite format (CSC -&gt; CSR, CSR -&gt; CSC); or the same format if calling 't_deep'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Matrix)
library(MatrixExtra)
set.seed(1)
X &lt;- rsparsematrix(3, 4, .5, repr="C")
inherits(X, "CsparseMatrix")
Xtrans &lt;- t_shallow(X)
inherits(Xtrans, "RsparseMatrix")
nrow(X) == ncol(Xtrans)
ncol(X) == nrow(Xtrans)

Xorig &lt;- t_shallow(Xtrans)
inherits(Xorig, "CsparseMatrix")
inherits(t_deep(Xtrans), "RsparseMatrix")

### Important!!!
### This package makes 't_shallow' the default
set_new_matrix_behavior()
inherits(X, "CsparseMatrix")
inherits(t(X), "RsparseMatrix")

### Can be changed back to 't_deep' like this:
restore_old_matrix_behavior()
inherits(t(X), "CsparseMatrix")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
