<!DOCTYPE html><html><head><title>Help for package cholera</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cholera}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cholera-package'><p>cholera: amend, augment and aid analysis of John Snow's cholera map</p></a></li>
<li><a href='#addCase'><p>Add observed case(s) to plot.</p></a></li>
<li><a href='#addDelaunay'><p>Add Delaunay triangles.</p></a></li>
<li><a href='#addEuclideanPath'><p>Add the path for the Euclidean distance between cases and/or pumps.</p></a></li>
<li><a href='#addFrame'><p>Add map border to plot.</p></a></li>
<li><a href='#addIndexCase'><p>Highlight index case at 40 Broad Street.</p></a></li>
<li><a href='#addKernelDensity'><p>Add 2D kernel density contours.</p></a></li>
<li><a href='#addLandmarks'><p>Add landmarks to plot.</p></a></li>
<li><a href='#addMilePosts'><p>Add distance or time based &quot;mileposts&quot; to an observed walking neighborhood plot.</p></a></li>
<li><a href='#addNeighborhoodCases'><p>Add observed cases by neighborhood.</p></a></li>
<li><a href='#addNeighborhoodEuclidean'><p>Add expected Euclidean pump neighborhoods.</p></a></li>
<li><a href='#addNeighborhoodWalking'><p>Add expected walking neighborhoods.</p></a></li>
<li><a href='#addPlaguePit'><p>Add plague pit (Marshall Street).</p></a></li>
<li><a href='#addPump'><p>Add selected pump(s) to plot.</p></a></li>
<li><a href='#addRoads'><p>Add all streets and roads to plot.</p></a></li>
<li><a href='#addSnow'><p>Adds Snow's graphical annotation of the Broad Street pump walking neighborhood.</p></a></li>
<li><a href='#addVoronoi'><p>Add Voronoi cells.</p></a></li>
<li><a href='#addWalkingPath'><p>Add the shortest walking path between a selected cases or pumps.</p></a></li>
<li><a href='#addWhitehead'><p>Add Rev. Henry Whitehead's Broad Street pump neighborhood.</p></a></li>
<li><a href='#anchor.case'><p>Anchor or base case of each stack of fatalities.</p></a></li>
<li><a href='#border'><p>Numeric IDs of line segments that create the map's border frame.</p></a></li>
<li><a href='#caseDistance'><p>Compute distance between case fatalities.</p></a></li>
<li><a href='#caseLocator'><p>Locate case by numerical ID.</p></a></li>
<li><a href='#euclideanPath'><p>Compute path of the Euclidean distance between cases and/or pumps.</p></a></li>
<li><a href='#fatalities'><p>Amended Dodson and Tobler's cholera data.</p></a></li>
<li><a href='#fatalities.address'><p>&quot;Unstacked&quot; amended cholera data with address as unit of observation.</p></a></li>
<li><a href='#fatalities.unstacked'><p>&quot;Unstacked&quot; amended cholera fatalities data with fatality as unit of observation.</p></a></li>
<li><a href='#fixFatalities'><p>Fix errors in Dodson and Tobler's digitization of Snow's map.</p></a></li>
<li><a href='#frame.data'><p>Map frame data c(&quot;x&quot;, &quot;y&quot;) and c(&quot;lon&quot;, &quot;lat&quot;).</p></a></li>
<li><a href='#frame.sample'><p>Partitioned map frame points (segment endpoints).</p></a></li>
<li><a href='#isoLines'><p>Plot isochrone and isodistance regions (prototype)</p></a></li>
<li><a href='#landmark.squares'><p>Centers of city squares.</p></a></li>
<li><a href='#landmarkData'><p>Landmark data.</p></a></li>
<li><a href='#landmarks'><p>Orthogonal projection of landmarks onto road network.</p></a></li>
<li><a href='#latlong.ortho.addr'><p>Orthogonal projection of observed address (latlong) cases onto road network.</p></a></li>
<li><a href='#latlong.ortho.pump'><p>Orthogonal projection of 13 original pumps (latlong).</p></a></li>
<li><a href='#latlong.ortho.pump.vestry'><p>Orthogonal projection of the 14 pumps from the Vestry Report (latlong).</p></a></li>
<li><a href='#latlongAddress'><p>Compute latitude and longitude of case &quot;addresses&quot; (prototype).</p></a></li>
<li><a href='#latlongFatalities'><p>Compute latitude and longitude of non-address fatalities (prototype).</p></a></li>
<li><a href='#latlongLandmarks'><p>Compute Georeferenced Latitude and Longitude (prototype).</p></a></li>
<li><a href='#latlongNearestPump'><p>Compute shortest georeferenced distances (and walking paths) to selected pumps (prototype).</p></a></li>
<li><a href='#latlongNeighborhoodData'><p>Compute network graph of roads, cases and pumps.</p></a></li>
<li><a href='#latlongNeighborhoodVoronoi'><p>Compute Voronoi pump neighborhoods (lat-long prototype).</p></a></li>
<li><a href='#latlongNeighborhoodWalking'><p>Compute walking path pump neighborhoods.</p></a></li>
<li><a href='#latlongPumps'><p>Compute Georeferenced Latitude and Longitude (prototype).</p></a></li>
<li><a href='#latlongRoads'><p>Compute latitude and longitude for unique road segment endpoints (prototype).</p></a></li>
<li><a href='#latlongVoronoi'><p>Compute Georeferenced Latitude and Longitude of vertices of Voronoi polygons.</p></a></li>
<li><a href='#latlongWalkingPath'><p>Plot walking path to nearest pump (prototype).</p></a></li>
<li><a href='#mapRange'><p>Compute xlim and ylim of Snow's map.</p></a></li>
<li><a href='#nearestPump'><p>Compute shortest distances or paths to selected pumps.</p></a></li>
<li><a href='#neighborhoodData'><p>Compute network graph of roads, cases and pumps.</p></a></li>
<li><a href='#neighborhoodEuclidean'><p>Compute Euclidean path pump neighborhoods.</p></a></li>
<li><a href='#neighborhoodVoronoi'><p>Compute Voronoi pump neighborhoods.</p></a></li>
<li><a href='#neighborhoodWalking'><p>Compute walking path pump neighborhoods.</p></a></li>
<li><a href='#ortho.proj'><p>Orthogonal projection of observed cases onto road network.</p></a></li>
<li><a href='#ortho.proj.pump'><p>Orthogonal projection of 13 original pumps.</p></a></li>
<li><a href='#ortho.proj.pump.vestry'><p>Orthogonal projection of the 14 pumps from the Vestry Report.</p></a></li>
<li><a href='#oxford.weather'><p>Oxford monthly weather data, January 1853 - December 2019.</p></a></li>
<li><a href='#oxfordWeather'><p>Weather data recorded in Oxford (Met Office UK).</p></a></li>
<li><a href='#plague.pit'><p>Plague pit coordinates.</p></a></li>
<li><a href='#plot.euclidean'><p>Plot method for neighborhoodEuclidean().</p></a></li>
<li><a href='#plot.euclidean_path'><p>Plot the path of the Euclidean distance between cases and/or pumps.</p></a></li>
<li><a href='#plot.latlong_neighborhood_data'><p>Plot method for latlongNeighborhoodData().</p></a></li>
<li><a href='#plot.latlong_walking'><p>Plot method for latlongNeighborhoodWalking().</p></a></li>
<li><a href='#plot.latlong_walking_path'><p>Plot the walking path between selected cases and/or pumps.</p></a></li>
<li><a href='#plot.latlongNeighborhoodVoronoi'><p>Plot method for latlongNeighborhoodVoronoi()</p></a></li>
<li><a href='#plot.neighborhood_data'><p>Plot method for neighborhoodData().</p></a></li>
<li><a href='#plot.oxfordWeather'><p>Plot method for oxfordWeather().</p></a></li>
<li><a href='#plot.povertyLondon'><p>Plot method for povertyLondon().</p></a></li>
<li><a href='#plot.profile_perspective'><p>Plot method for profilePerspective().</p></a></li>
<li><a href='#plot.time_series'><p>Plot aggregate time series data from Vestry report.</p></a></li>
<li><a href='#plot.voronoi'><p>Plot Voronoi neighborhoods.</p></a></li>
<li><a href='#plot.walking'><p>Plot method for neighborhoodWalking().</p></a></li>
<li><a href='#plot.walking_path'><p>Plot the walking path between selected cases and/or pumps.</p></a></li>
<li><a href='#plot.winterTemperatures'><p>Plot method for winterTemperatures().</p></a></li>
<li><a href='#povertyLondon'><p>Poverty and Born in London.</p></a></li>
<li><a href='#print.euclidean'><p>Print method for neighborhoodEuclidean().</p></a></li>
<li><a href='#print.euclidean_path'><p>Print method for euclideanPath().</p></a></li>
<li><a href='#print.iso'><p>Print method for isoVertices().</p></a></li>
<li><a href='#print.latlong_walking_path'><p>Print method for latlongWalkingPath().</p></a></li>
<li><a href='#print.latlongNeighborhoodVoronoi'><p>Print method for latlongNeighborhoodVoronoi().</p></a></li>
<li><a href='#print.time_series'><p>Print summary data for timeSeries().</p></a></li>
<li><a href='#print.voronoi'><p>Print method for neighborhoodVoronoi().</p></a></li>
<li><a href='#print.walking'><p>Print method for neighborhoodWalking().</p></a></li>
<li><a href='#print.walking_path'><p>Print method for walkingPath().</p></a></li>
<li><a href='#profile2D'><p>2D Profile .</p></a></li>
<li><a href='#profile3D'><p>3D Profile.</p></a></li>
<li><a href='#pumpCase'><p>Extract numeric case IDs by pump neighborhood.</p></a></li>
<li><a href='#pumpData'><p>Compute pump coordinates.</p></a></li>
<li><a href='#pumpFatalities'><p>Compute fatalities by pump.</p></a></li>
<li><a href='#pumpLocator'><p>Locate water pump by numerical ID.</p></a></li>
<li><a href='#pumps'><p>Dodson and Tobler's pump data with street name.</p></a></li>
<li><a href='#pumps.vestry'><p>Vestry report pump data.</p></a></li>
<li><a href='#rd.sample'><p>Sample of road intersections (segment endpoints).</p></a></li>
<li><a href='#rectangle.filter'><p>Rectangular filter data.</p></a></li>
<li><a href='#regular.cases'><p>&quot;Expected&quot; cases.</p></a></li>
<li><a href='#road.segments'><p>Dodson and Tobler's street data transformed into road segments.</p></a></li>
<li><a href='#roads'><p>Dodson and Tobler's street data with appended road names.</p></a></li>
<li><a href='#roadSegmentFix'><p>Bar orientation classification errors.</p></a></li>
<li><a href='#roadSegments'><p>Reshape 'roads' data frame into 'road.segments' data frame.</p></a></li>
<li><a href='#segmentHighlight'><p>Highlight segment by ID.</p></a></li>
<li><a href='#segmentLength'><p>Compute length of road segment.</p></a></li>
<li><a href='#segmentLocator'><p>Locate road segment by ID.</p></a></li>
<li><a href='#sim.ortho.proj'><p>Road &quot;address&quot; of simulated (i.e., &quot;expected&quot;) cases.</p></a></li>
<li><a href='#sim.pump.case'><p>List of &quot;simulated&quot; fatalities grouped by walking-distance pump neighborhood.</p></a></li>
<li><a href='#sim.walking.distance'><p>Walking distance to Broad Street Pump (#7).</p></a></li>
<li><a href='#simulateFatalities'><p>Generate simulated fatalities.</p></a></li>
<li><a href='#simulateWalkingDistance'><p>Compute walking distance for simulated cases.</p></a></li>
<li><a href='#snow.neighborhood'><p>Snow neighborhood fatalities.</p></a></li>
<li><a href='#snowColors'><p>Create a set of colors for pump neighborhoods.</p></a></li>
<li><a href='#snowMap'><p>Plot John Snow's cholera map.</p></a></li>
<li><a href='#snowNeighborhood'><p>Plotting data for Snow's graphical annotation of the Broad Street pump neighborhood.</p></a></li>
<li><a href='#streetHighlight'><p>Highlight road by name.</p></a></li>
<li><a href='#streetLength'><p>Compute length of selected street.</p></a></li>
<li><a href='#streetNameLocator'><p>Locate road by name.</p></a></li>
<li><a href='#streetNames'><p>Street names (alphabetized).</p></a></li>
<li><a href='#streetNumberLocator'><p>Locate road by numerical ID.</p></a></li>
<li><a href='#subsetRoadsSamples'><p>Sample for road segment endpoints.</p></a></li>
<li><a href='#summary.euclidean'><p>Summary method for neighborhoodEuclidean().</p></a></li>
<li><a href='#summary.voronoi'><p>Summary method for neighborhoodVoronoi().</p></a></li>
<li><a href='#summary.walking'><p>Summary method for neighborhoodWalking().</p></a></li>
<li><a href='#timeSeries'><p>Aggregate time series fatality data from the Vestry report.</p></a></li>
<li><a href='#unitMeter'><p>Convert nominal map distance to meters or yards.</p></a></li>
<li><a href='#unstackFatalities'><p>Unstack &quot;stacks&quot; in Snow's cholera map.</p></a></li>
<li><a href='#voronoi.polygons'><p>Coordinates of Voronoi polygon vertices for original map.</p></a></li>
<li><a href='#voronoi.polygons.vestry'><p>Coordinates of Voronoi polygon vertices for Vestry Report map.</p></a></li>
<li><a href='#voronoiPolygons'><p>Extract vertices of Delaunay triangles and Dirichelet (Voronoi) tiles.</p></a></li>
<li><a href='#walkingPath'><p>Compute the shortest walking path between cases and/or pumps.</p></a></li>
<li><a href='#winterTemperatures'><p>Average Winter Temperatures.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Amend, Augment and Aid Analysis of John Snow's Cholera Map</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Amends errors, augments data and aids analysis of John Snow's map
  of the 1854 London cholera outbreak.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lindbrook/cholera">https://github.com/lindbrook/cholera</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lindbrook/cholera/issues">https://github.com/lindbrook/cholera/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>deldir (&ge; 1.0-2), elevatr, geosphere, ggplot2, grDevices,
HistData (&ge; 0.7-8), igraph, KernSmooth, pracma, RColorBrewer,
sp, stats, tanaka, terra, tools, threejs, TSP, utils,
viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-01 12:23:37 UTC; peter</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Li [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Li &lt;lindbrook@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-01 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cholera-package'>cholera: amend, augment and aid analysis of John Snow's cholera map</h2><span id='topic+cholera-package'></span>

<h3>Description</h3>

<p>Amend, augment and aid the analysis of John Snow's cholera map.
</p>


<h3>Details</h3>

<p>Features:
</p>

<ul>
<li><p> Fixes three apparent coding errors in Dodson and Tobler's 1992 digitization of Snow's map.
</p>
</li>
<li><p> &quot;Unstacks&quot; the data in two ways to make analysis and visualization easier and more meaningful.
</p>
</li>
<li><p> Computes and visualizes &quot;pump neighborhoods&quot; based on Voronoi tessellation, Euclidean distance, and walking distance.
</p>
</li>
<li><p> Ability to overlay graphical elements and features like kernel density, Voronoi diagrams, Snow's Broad Street neighborhood, and notable landmarks (John Snow's residence, the Lion Brewery, etc.) via add*() functions.
</p>
</li>
<li><p> Includes a variety of functions to highlight specific cases, roads, pumps and paths.
</p>
</li>
<li><p> Appends actual street names to roads data.
</p>
</li>
<li><p> Includes the revised pump data used in the second version of Snow's map from the Vestry report, which includes the &quot;correct&quot; location of the Broad Street pump.
</p>
</li>
<li><p> Adds two different aggregate time series fatalities data sets, taken from the Vestry report.
</p>
</li>
<li><p> Support for parallel computation on Linux, macOS and Windows.
</p>
</li>
<li><p> PWith 'cholera' version &gt;= 0.8.0, preliminary and provisional support for georeferenced (longitude and latitude) versions of data and functions.
</p>
</li></ul>

<p>To learn more, see the vignettes:
</p>
<p><code>vignette("duplicate.missing.cases")</code>
</p>
<p><code>vignette("kernel.density")</code>
</p>
<p><code>vignette("parallelization")</code>
</p>
<p><code>vignette("pump.neighborhoods")</code>
</p>
<p><code>vignette("roads")</code>
</p>
<p><code>vignette("tiles.polygons")</code>
</p>
<p><code>vignette("time.series")</code>
</p>
<p><code>vignette("unstacking.bars")</code>
</p>

<hr>
<h2 id='addCase'>Add observed case(s) to plot.</h2><span id='topic+addCase'></span>

<h3>Description</h3>

<p>Add case(s), as &quot;address&quot; or &quot;fatalities&quot; as points or IDs, to a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCase(case = 1, type = "observed", token = "both", text.size = 0.5,
  pch = 1, cex = 1, point.lwd = 2, col = "black", pos = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCase_+3A_case">case</code></td>
<td>
<p>Numeric or Character. Vector of case ID(s). &quot;all&quot; plots all cases. &quot;anchor&quot; plots anchor cases.</p>
</td></tr>
<tr><td><code id="addCase_+3A_type">type</code></td>
<td>
<p>Character. Type of case: &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="addCase_+3A_token">token</code></td>
<td>
<p>Character. Type of token to plot: &quot;point&quot;, &quot;id&quot; or &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="addCase_+3A_text.size">text.size</code></td>
<td>
<p>Numeric. Size of case ID text.</p>
</td></tr>
<tr><td><code id="addCase_+3A_pch">pch</code></td>
<td>
<p>Numeric. pch.</p>
</td></tr>
<tr><td><code id="addCase_+3A_cex">cex</code></td>
<td>
<p>Numeric. cex.</p>
</td></tr>
<tr><td><code id="addCase_+3A_point.lwd">point.lwd</code></td>
<td>
<p>Numeric. Point lwd.</p>
</td></tr>
<tr><td><code id="addCase_+3A_col">col</code></td>
<td>
<p>Character. Color.</p>
</td></tr>
<tr><td><code id="addCase_+3A_pos">pos</code></td>
<td>
<p>Numeric. Text position.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>type, token, text.size, pch, cex, point.lwd and pos relevant only when case is numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap(add.cases = FALSE)
addCase(1)

snowMap(add.cases = FALSE)
addCase(100)
</code></pre>

<hr>
<h2 id='addDelaunay'>Add Delaunay triangles.</h2><span id='topic+addDelaunay'></span>

<h3>Description</h3>

<p>Add Delaunay triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addDelaunay(pump.select = NULL, vestry = FALSE, color = "black",
  line.type = "solid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addDelaunay_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Default is NULL; all pumps are used. Otherwise, selection by a vector of numeric IDs: 1 to 13 for <code>pumps</code>; 1 to 14 for <code>pumps.vestry</code>. Exclusion (negative selection) is possible (e.g., -6).</p>
</td></tr>
<tr><td><code id="addDelaunay_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>FALSE</code> for original 13 pumps. TRUE for 14 pumps in Vestry Report.</p>
</td></tr>
<tr><td><code id="addDelaunay_+3A_color">color</code></td>
<td>
<p>Character. Color of triangle edges.</p>
</td></tr>
<tr><td><code id="addDelaunay_+3A_line.type">line.type</code></td>
<td>
<p>Character. Type of line for triangle edges.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function uses <code>deldir::deldir()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
addDelaunay()
</code></pre>

<hr>
<h2 id='addEuclideanPath'>Add the path for the Euclidean distance between cases and/or pumps.</h2><span id='topic+addEuclideanPath'></span>

<h3>Description</h3>

<p>Add the path for the Euclidean distance between cases and/or pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEuclideanPath(origin, destination = NULL, type = "case-pump",
  observed = TRUE, case.location = "address", vestry = FALSE,
  distance.unit = "meter", time.unit = "second", walking.speed = 5,
  unit.posts = "distance", unit.interval = NULL, alpha.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addEuclideanPath_+3A_origin">origin</code></td>
<td>
<p>Numeric or Integer. Numeric ID of case or pump.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_destination">destination</code></td>
<td>
<p>Numeric or Integer. Numeric ID(s) of case(s) or pump(s). Exclusion is possible via negative selection (e.g., -7). Default is <code>NULL</code>: this returns closest pump or &quot;anchor&quot; case.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_type">type</code></td>
<td>
<p>Character &quot;case-pump&quot;, &quot;cases&quot; or &quot;pumps&quot;.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_observed">observed</code></td>
<td>
<p>Logical. Use observed or simulated expected data.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_case.location">case.location</code></td>
<td>
<p>Character. For <code>observed = FALSE</code>: &quot;address&quot; or &quot;nominal&quot;. &quot;address&quot; is the x-y coordinate of a stack's &quot;anchor&quot; case. &quot;nominal&quot; is the x-y coordinate of a bar.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 pumps from the original map.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on unit distances.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_unit.posts">unit.posts</code></td>
<td>
<p>Character. &quot;distance&quot; for mileposts; &quot;time&quot; for timeposts; <code>NULL</code> for no posts.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_unit.interval">unit.interval</code></td>
<td>
<p>Numeric. Sets interval between <code>unit.posts</code>.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for path: a value in [0, 1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list with 3 data frames: x-y coordinates for the origin and destination, and a summary of results.
</p>


<h3>Note</h3>

<p>Walking time is computed using <code>distanceTime()</code>.
</p>

<hr>
<h2 id='addFrame'>Add map border to plot.</h2><span id='topic+addFrame'></span>

<h3>Description</h3>

<p>Add map border to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addFrame(latlong = FALSE, col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addFrame_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
<tr><td><code id="addFrame_+3A_col">col</code></td>
<td>
<p>Character. Color</p>
</td></tr>
<tr><td><code id="addFrame_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='addIndexCase'>Highlight index case at 40 Broad Street.</h2><span id='topic+addIndexCase'></span>

<h3>Description</h3>

<p>Highlight index case at 40 Broad Street.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addIndexCase(cex = 2, col = "red", pch = 1, add.label = FALSE,
  text.size = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addIndexCase_+3A_cex">cex</code></td>
<td>
<p>Numeric. Size of point.</p>
</td></tr>
<tr><td><code id="addIndexCase_+3A_col">col</code></td>
<td>
<p>Character. Color of point.</p>
</td></tr>
<tr><td><code id="addIndexCase_+3A_pch">pch</code></td>
<td>
<p>Numeric. Type of of point.</p>
</td></tr>
<tr><td><code id="addIndexCase_+3A_add.label">add.label</code></td>
<td>
<p>Logical. Add text annotation: &quot;40 Broad Street&quot;</p>
</td></tr>
<tr><td><code id="addIndexCase_+3A_text.size">text.size</code></td>
<td>
<p>Numeric. Size of text label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Add base R point and (optionally) text to a graphics plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>segmentLocator("216-1")
addIndexCase()
</code></pre>

<hr>
<h2 id='addKernelDensity'>Add 2D kernel density contours.</h2><span id='topic+addKernelDensity'></span>

<h3>Description</h3>

<p>Add 2D kernel density contours based on selected sets of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addKernelDensity(pump.subset = "pooled", pump.select = NULL,
  neighborhood.type = "walking", data = "unstacked", bandwidth = 0.5,
  color = "black", line.type = "solid", multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addKernelDensity_+3A_pump.subset">pump.subset</code></td>
<td>
<p>Character or Numeric: &quot;pooled&quot;, &quot;individual&quot;, or numeric vector. &quot;pooled&quot; treats all observations as a single set. &quot;individual&quot; is a shortcut for all individual pump neighborhoods. Use of vector of numeric pump IDs to subset from the neighborhoods defined by <code>pump.select</code>. Negative selection possible. <code>NULL</code> selects all pumps in <code>pump.select</code>.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_neighborhood.type">neighborhood.type</code></td>
<td>
<p>Character. &quot;voronoi&quot; or &quot;walking&quot;</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_data">data</code></td>
<td>
<p>Character. Unit of observation: &quot;unstacked&quot; uses <code>fatalities.unstacked</code>; &quot;address&quot; uses <code>fatalities.address</code>; &quot;fatality&quot; uses <code>fatalities</code>.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Numeric. Bandwidth for kernel density estimation.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_color">color</code></td>
<td>
<p>Character. Color of contour lines.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_line.type">line.type</code></td>
<td>
<p>Character. Line type for contour lines.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Add contours to a graphics plot.
</p>


<h3>Note</h3>

<p>This function uses <code>KernSmooth::bkde2D()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
snowMap()
addKernelDensity()

snowMap()
addKernelDensity("individual")

snowMap()
addKernelDensity(c(6, 8))

snowMap()
addKernelDensity(pump.select = c(6, 8))

## End(Not run)
</code></pre>

<hr>
<h2 id='addLandmarks'>Add landmarks to plot.</h2><span id='topic+addLandmarks'></span>

<h3>Description</h3>

<p>Add landmarks to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLandmarks(text.size = 0.5, highlight.perimeter = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLandmarks_+3A_text.size">text.size</code></td>
<td>
<p>Numeric. cex for text labels.</p>
</td></tr>
<tr><td><code id="addLandmarks_+3A_highlight.perimeter">highlight.perimeter</code></td>
<td>
<p>Logical. Highlight Lion Brewery and Model Housing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Base R points and text.
</p>


<h3>Note</h3>

<p>The location of 18 Sackville Street and 28 Dean Street are approximate. Falconberg Court &amp; Mews form an isolate: they are not part of the network of roads and are technically unreachable. Adam and Eve Court and its pump also form an isolate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap(add.landmarks = FALSE)
addLandmarks()
</code></pre>

<hr>
<h2 id='addMilePosts'>Add distance or time based &quot;mileposts&quot; to an observed walking neighborhood plot.</h2><span id='topic+addMilePosts'></span>

<h3>Description</h3>

<p>Add distance or time based &quot;mileposts&quot; to an observed walking neighborhood plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMilePosts(pump.subset = NULL, pump.select = NULL, vestry = FALSE,
  unit = "distance", interval = NULL, walking.speed = 5,
  type = "arrows", multi.core = TRUE, dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addMilePosts_+3A_pump.subset">pump.subset</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to subset from the neighborhoods defined by <code>pump.select</code>. Negative selection possible. <code>NULL</code> uses all pumps in <code>pump.select</code>.</p>
</td></tr>
<tr><td><code id="addMilePosts_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Numeric vector of pumps to define possible pump neighborhoods (i.e. the &quot;population&quot;). Negative selection is possible. NULL selects all &quot;observed&quot; pumps (i.e., pumps with at least one case).</p>
</td></tr>
<tr><td><code id="addMilePosts_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. FALSE uses the 13 from the original map.</p>
</td></tr>
<tr><td><code id="addMilePosts_+3A_unit">unit</code></td>
<td>
<p>Character. Milepost unit of measurement: &quot;distance&quot; or &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="addMilePosts_+3A_interval">interval</code></td>
<td>
<p>Numeric. Interval between mileposts: 50 meters for &quot;distance&quot;;  60 seconds for &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="addMilePosts_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="addMilePosts_+3A_type">type</code></td>
<td>
<p>Character. &quot;arrows&quot; or &quot;points&quot;.</p>
</td></tr>
<tr><td><code id="addMilePosts_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="addMilePosts_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R base graphics arrows or points.
</p>

<hr>
<h2 id='addNeighborhoodCases'>Add observed cases by neighborhood.</h2><span id='topic+addNeighborhoodCases'></span>

<h3>Description</h3>

<p>Add cases to a plot as &quot;address&quot; or &quot;fatalities&quot; and as points or IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNeighborhoodCases(pump.subset = NULL, pump.select = NULL,
  metric = "walking", type = "stack.base", token = "point",
  text.size = 0.5, pch = 16, point.size = 0.5, vestry = FALSE,
  weighted = TRUE, color = NULL, case.location = "nominal",
  alpha.level = 0.5, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNeighborhoodCases_+3A_pump.subset">pump.subset</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to subset from the neighborhoods defined by <code>pump.select</code>. Negative selection possible. <code>NULL</code> uses all pumps in <code>pump.select</code>.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Numeric vector of pump IDs that define which pump neighborhoods to consider (i.e., specify the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_metric">metric</code></td>
<td>
<p>Character. Type of neighborhood: &quot;euclidean&quot; or &quot;walking&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_type">type</code></td>
<td>
<p>Character. Type of case: &quot;stack.base&quot; (base of stack), or &quot;stack&quot; (entire stack). For observed = TRUE.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_token">token</code></td>
<td>
<p>Character. Type of token to plot: &quot;point&quot; or &quot;id&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_text.size">text.size</code></td>
<td>
<p>Numeric. Size of case ID text.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_pch">pch</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_point.size">point.size</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest walking path weighted by road length. <code>FALSE</code> computes shortest walking path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_color">color</code></td>
<td>
<p>Character. Use a single color for all paths. <code>NULL</code> uses neighborhood colors defined by <code>snowColors().</code></p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_case.location">case.location</code></td>
<td>
<p>Character. For <code>metric = "euclidean"</code>: &quot;address&quot; uses <code>ortho.proj</code>; &quot;nominal&quot; uses <code>fatalities</code>.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
snowMap(add.cases = FALSE)
addNeighborhoodCases(pump.subset = c(6, 10))

snowMap(add.cases = FALSE)
addNeighborhoodCases(pump.select = c(6, 10))

## End(Not run)
</code></pre>

<hr>
<h2 id='addNeighborhoodEuclidean'>Add expected Euclidean pump neighborhoods.</h2><span id='topic+addNeighborhoodEuclidean'></span>

<h3>Description</h3>

<p>Add expected Euclidean pump neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNeighborhoodEuclidean(pump.subset = NULL, pump.select = NULL,
  vestry = FALSE, case.location = "nominal", type = "star",
  alpha.level = 0.5, multi.core = TRUE, dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNeighborhoodEuclidean_+3A_pump.subset">pump.subset</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to subset from the neighborhoods defined by <code>pump.select</code>. Negative selection possible. <code>NULL</code> selects all pumps in <code>pump.select</code>.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_case.location">case.location</code></td>
<td>
<p>Character. &quot;address&quot; or &quot;nominal&quot;. &quot;address&quot; is the x-y coordinates of <code>sim.ortho.proj</code>. &quot;nominal&quot; is the x-y coordinates of <code>regular.cases</code>.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_type">type</code></td>
<td>
<p>Character. Type of plot: &quot;star&quot;, &quot;area.points&quot; or &quot;area.polygons&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R graphic elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
streetNameLocator("marshall street", zoom = 0.5, highlight = FALSE,
  add.subtitle = FALSE)
addNeighborhoodEuclidean()

streetNameLocator("marshall street", zoom = 0.5, highlight = FALSE,
  add.subtitle = FALSE)
addNeighborhoodEuclidean(type = "area.points")

## End(Not run)
</code></pre>

<hr>
<h2 id='addNeighborhoodWalking'>Add expected walking neighborhoods.</h2><span id='topic+addNeighborhoodWalking'></span>

<h3>Description</h3>

<p>Add expected walking neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNeighborhoodWalking(pump.subset = NULL, pump.select = NULL,
  vestry = FALSE, weighted = TRUE, path = NULL, path.color = NULL,
  path.width = 3, alpha.level = 0.25, polygon.type = "solid",
  polygon.col = NULL, polygon.lwd = 2, multi.core = TRUE,
  dev.mode = FALSE, latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNeighborhoodWalking_+3A_pump.subset">pump.subset</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to subset from the neighborhoods defined by <code>pump.select</code>. Negative selection possible. <code>NULL</code> uses all pumps in <code>pump.select</code>.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Numeric vector of pump IDs that define which pump neighborhoods to consider (i.e., specify the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path weighted by road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_path">path</code></td>
<td>
<p>Character. &quot;expected&quot; or &quot;observed&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_path.color">path.color</code></td>
<td>
<p>Character. Use a single color for all paths. <code>NULL</code> uses neighborhood colors defined by <code>snowColors()</code>.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_path.width">path.width</code></td>
<td>
<p>Numeric. Set width of paths.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_polygon.type">polygon.type</code></td>
<td>
<p>Character. &quot;perimeter&quot; or &quot;solid&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_polygon.col">polygon.col</code></td>
<td>
<p>Character.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_polygon.lwd">polygon.lwd</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
streetNameLocator("marshall street", zoom = 0.5)
addNeighborhoodWalking()

## End(Not run)
</code></pre>

<hr>
<h2 id='addPlaguePit'>Add plague pit (Marshall Street).</h2><span id='topic+addPlaguePit'></span>

<h3>Description</h3>

<p>Draws a polygon that approximates the plague pit located around Marshall Street. From Vestry Report map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPlaguePit(color = "black", line.type = "solid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPlaguePit_+3A_color">color</code></td>
<td>
<p>Character. Color of polygon.</p>
</td></tr>
<tr><td><code id="addPlaguePit_+3A_line.type">line.type</code></td>
<td>
<p>Character. Polygon line type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds a polygon to a graphics plot.
</p>


<h3>Note</h3>

<p>In progress.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap(add.landmarks = FALSE)
addPlaguePit()
</code></pre>

<hr>
<h2 id='addPump'>Add selected pump(s) to plot.</h2><span id='topic+addPump'></span>

<h3>Description</h3>

<p>Add selected pump(s) to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPump(pump.select = NULL, vestry = FALSE, col = NULL, pch = 24,
  label = TRUE, pos = 1, cex = 1, latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPump_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric or Integer. Vector of water pump numerical ID(s). With <code>vestry = TRUE</code>, whole number(s) between 1 and 14. With <code>vestry = FALSE</code>, whole number(s) between 1 and 13. See <code>pumps.vestry</code> and <code>pumps</code> for IDs and details about specific pumps. <code>NULL</code> plots all pumps. Negative selection allowed.</p>
</td></tr>
<tr><td><code id="addPump_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> for the 14 pumps from Vestry Report. <code>FALSE</code> for the original 13 pumps.</p>
</td></tr>
<tr><td><code id="addPump_+3A_col">col</code></td>
<td>
<p>Character. Color of pump points.</p>
</td></tr>
<tr><td><code id="addPump_+3A_pch">pch</code></td>
<td>
<p>Numeric. Shape of point character.</p>
</td></tr>
<tr><td><code id="addPump_+3A_label">label</code></td>
<td>
<p>Logical. TRUE adds text label.</p>
</td></tr>
<tr><td><code id="addPump_+3A_pos">pos</code></td>
<td>
<p>Numeric. Position of label.</p>
</td></tr>
<tr><td><code id="addPump_+3A_cex">cex</code></td>
<td>
<p>Numeric. point cex.</p>
</td></tr>
<tr><td><code id="addPump_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use c(&quot;lon&quot;. &quot;lat&quot;) or c(&quot;x&quot;, &quot;y&quot;).</p>
</td></tr>
</table>

<hr>
<h2 id='addRoads'>Add all streets and roads to plot.</h2><span id='topic+addRoads'></span>

<h3>Description</h3>

<p>Add all streets and roads to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addRoads(latlong = FALSE, col = "gray")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addRoads_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
<tr><td><code id="addRoads_+3A_col">col</code></td>
<td>
<p>Character. Color</p>
</td></tr>
</table>

<hr>
<h2 id='addSnow'>Adds Snow's graphical annotation of the Broad Street pump walking neighborhood.</h2><span id='topic+addSnow'></span>

<h3>Description</h3>

<p>Adds Snow's graphical annotation of the Broad Street pump walking neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSnow(type = "area", color = "dodgerblue", alpha.level = 0.25,
  line.width = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSnow_+3A_type">type</code></td>
<td>
<p>Character. Type of annotation plot: &quot;area&quot;, &quot;perimeter&quot; or &quot;street&quot;.</p>
</td></tr>
<tr><td><code id="addSnow_+3A_color">color</code></td>
<td>
<p>Character. Neighborhood color.</p>
</td></tr>
<tr><td><code id="addSnow_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="addSnow_+3A_line.width">line.width</code></td>
<td>
<p>Numeric. Line width for <code>type = "street"</code> and <code>type = "perimeter"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(neighborhoodVoronoi())
addSnow()

## End(Not run)
</code></pre>

<hr>
<h2 id='addVoronoi'>Add Voronoi cells.</h2><span id='topic+addVoronoi'></span>

<h3>Description</h3>

<p>Add Voronoi cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addVoronoi(pump.select = NULL, vestry = FALSE, case.location = "nominal",
  color = "black", line.type = "solid", line.width = 1,
  latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addVoronoi_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Default is NULL; all pumps are used. Otherwise, selection by a vector of numeric IDs: 1 to 13 for <code>pumps</code>; 1 to 14 for <code>pumps.vestry</code>. Exclusion (negative selection) is possible (e.g., -6).</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>FALSE</code> for original 13 pumps. TRUE for 14 pumps in Vestry Report.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_case.location">case.location</code></td>
<td>
<p>Character. For <code>observed = FALSE</code>: &quot;address&quot; or &quot;nominal&quot;. &quot;nominal&quot; is the x-y coordinates of <code>regular.cases</code>.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_color">color</code></td>
<td>
<p>Character. Color of cell edges.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_line.type">line.type</code></td>
<td>
<p>Character. Type of line for cell edges: lty.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_line.width">line.width</code></td>
<td>
<p>Numeric. Width of cell edges: lwd.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function uses <code>deldir::deldir()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
# addVoronoi()
</code></pre>

<hr>
<h2 id='addWalkingPath'>Add the shortest walking path between a selected cases or pumps.</h2><span id='topic+addWalkingPath'></span>

<h3>Description</h3>

<p>Add the shortest walking path between a selected cases or pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addWalkingPath(origin = 1, destination = NULL, type = "case-pump",
  observed = TRUE, weighted = TRUE, vestry = FALSE,
  distance.unit = "meter", time.unit = "second", walking.speed = 5,
  unit.posts = "distance", unit.interval = NULL, alpha.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addWalkingPath_+3A_origin">origin</code></td>
<td>
<p>Numeric or Integer. Numeric ID of case or pump.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_destination">destination</code></td>
<td>
<p>Numeric or Integer. Numeric ID(s) of case(s) or pump(s). Exclusion is possible via negative selection (e.g., -7). Default is <code>NULL</code>: this returns closest pump or &quot;anchor&quot; case. Character landmark name (case insensitive).</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_type">type</code></td>
<td>
<p>Character &quot;case-pump&quot;, &quot;cases&quot; or &quot;pumps&quot;.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_observed">observed</code></td>
<td>
<p>Logical. Use observed or &quot;simulated&quot; expected data.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path in terms of road length. <code>FALSE</code> computes shortest path in terms of nodes.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. <code>unit</code> is meaningful only when &quot;weighted&quot; is <code>TRUE</code>. See <code>vignette("roads")</code> for information on unit distances.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_unit.posts">unit.posts</code></td>
<td>
<p>Character. &quot;distance&quot; for mileposts; &quot;time&quot; for timeposts.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_unit.interval">unit.interval</code></td>
<td>
<p>Numeric. Sets interval between posts: for &quot;distance&quot;, the default is 50 meters; for &quot;time&quot;, the default is 60 seconds.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for path: a value in [0, 1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list with two elements: a character vector of path nodes and a data frame summary.
</p>


<h3>Note</h3>

<p>The function uses a case's &quot;address&quot; (i.e., a stack's &quot;anchor&quot; case) to compute distance. Time is computed using cholera::distanceTime(). Adam and Eve Court, and Falconberg Court and Falconberg Mews, are disconnected from the larger road network; they form two isolated subgraphs. This has two consequences: first, only cases on Adam and Eve Court can reach pump 2 and those cases cannot reach any other pump; second, cases on Falconberg Court and Mews cannot reach any pump. Unreachable pumps will return distances of <code>Inf</code>. Arrow points represent mileposts or timeposts to the destination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streetNameLocator("broad street", zoom = TRUE, highlight = FALSE,
  add.subtitle = FALSE)
addWalkingPath(447)
</code></pre>

<hr>
<h2 id='addWhitehead'>Add Rev. Henry Whitehead's Broad Street pump neighborhood.</h2><span id='topic+addWhitehead'></span>

<h3>Description</h3>

<p>A circle (polygon), centered around a desired pump with a radius of 210 yards. The Broad Street pump is the default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addWhitehead(pump = "Broad Street", radius = 210, distance.unit = "yard",
  color = "black", line.type = "solid", vestry = FALSE,
  add.subtitle = FALSE, walking.speed = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addWhitehead_+3A_pump">pump</code></td>
<td>
<p>Character or Numeric. Name (road name) or numerical ID of selected pump. See <code>pumps</code> or <code>pumps.vestry</code>.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_radius">radius</code></td>
<td>
<p>Numeric. Distance from a pump.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_color">color</code></td>
<td>
<p>Character. Color of circle.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_line.type">line.type</code></td>
<td>
<p>Character. Circle line type.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps and locations from Vestry report. <code>FALSE</code> uses original 13 pumps.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_add.subtitle">add.subtitle</code></td>
<td>
<p>Logical. Add subtitle with estimated &quot;walking&quot; time in seconds.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds a circle (polygon) to a graphics plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap(add.landmarks = FALSE)
addWhitehead()
</code></pre>

<hr>
<h2 id='anchor.case'>Anchor or base case of each stack of fatalities.</h2><span id='topic+anchor.case'></span>

<h3>Description</h3>

<p>Data frame that links a fatality to its stack, a stack's base case. For use with <code><a href="#topic+caseLocator">caseLocator</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anchor.case
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>case</code></dt><dd><p>numerical case ID</p>
</dd>
<dt><code>anchor</code></dt><dd><p>numerical case ID of anchor.case</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='border'>Numeric IDs of line segments that create the map's border frame.</h2><span id='topic+border'></span>

<h3>Description</h3>

<p>Vector of ordered numbers that identify the line segments that make up the frame of the map. For use with sp::Polygon().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>border
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>border</code></dt><dd><p>numerical ID</p>
</dd>
</dl>


<hr>
<h2 id='caseDistance'>Compute distance between case fatalities.</h2><span id='topic+caseDistance'></span>

<h3>Description</h3>

<p>Compute distance between case fatalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caseDistance(a = 19, b = 263, meters = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caseDistance_+3A_a">a</code></td>
<td>
<p>Numeric. Case ID.</p>
</td></tr>
<tr><td><code id="caseDistance_+3A_b">b</code></td>
<td>
<p>Numeric. Case ID.</p>
</td></tr>
<tr><td><code id="caseDistance_+3A_meters">meters</code></td>
<td>
<p>Logical. Compute metric (meters) or nominal distance.</p>
</td></tr>
</table>

<hr>
<h2 id='caseLocator'>Locate case by numerical ID.</h2><span id='topic+caseLocator'></span>

<h3>Description</h3>

<p>Highlight selected observed or simulated case and its home road segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caseLocator(case = 1, zoom = 1, observed = TRUE, add.title = TRUE,
  highlight.segment = TRUE, data = FALSE, add = FALSE, col = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caseLocator_+3A_case">case</code></td>
<td>
<p>Numeric or Integer. Whole number between 1 and 578.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric.A numeric value &gt;= 0 controls the degree of zoom. The default is 1.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_observed">observed</code></td>
<td>
<p>Logical. <code>TRUE</code> for observed. <code>FALSE</code> for simulated.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Include title.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_highlight.segment">highlight.segment</code></td>
<td>
<p>Logical. Highlight case's segment.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_data">data</code></td>
<td>
<p>Logical. Output data.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_add">add</code></td>
<td>
<p>Logical. Add to existing plot or separate plot.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_col">col</code></td>
<td>
<p>Character. Point color.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caseLocator(290)
caseLocator(290, zoom = TRUE)
caseLocator(290, observed = FALSE)
</code></pre>

<hr>
<h2 id='euclideanPath'>Compute path of the Euclidean distance between cases and/or pumps.</h2><span id='topic+euclideanPath'></span>

<h3>Description</h3>

<p>Compute path of the Euclidean distance between cases and/or pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclideanPath(origin = 1, destination = NULL, type = "case-pump",
  observed = TRUE, case.location = "nominal", landmark.cases = TRUE,
  vestry = FALSE, distance.unit = "meter", time.unit = "second",
  walking.speed = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclideanPath_+3A_origin">origin</code></td>
<td>
<p>Numeric or Character. Numeric ID of case or pump. Character landmark name.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_destination">destination</code></td>
<td>
<p>Numeric or Character. Numeric ID(s) of case(s) or pump(s). Exclusion is possible via negative selection (e.g., -7). Default is <code>NULL</code>, which returns the closest pump, &quot;anchor&quot; case or landmark.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_type">type</code></td>
<td>
<p>Character &quot;case-pump&quot;, &quot;cases&quot; or &quot;pumps&quot;.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_observed">observed</code></td>
<td>
<p>Logical. Use observed or &quot;simulated&quot; expected data.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_case.location">case.location</code></td>
<td>
<p>Character. For <code>observed = FALSE</code>: &quot;address&quot; or &quot;nominal&quot;. &quot;nominal&quot; is the x-y coordinates of <code>regular.cases</code>.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_landmark.cases">landmark.cases</code></td>
<td>
<p>Logical. <code>TRUE</code> includes landmarks as cases.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 pumps from the original map.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on unit distances.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Default is 5 km/hr.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list with 3 data frames: x-y coordinates for the origin and destination, and a summary of results.
</p>


<h3>Note</h3>

<p>The function uses a case's &quot;address&quot; (i.e., &quot;anchor&quot; case of a stack) to compute distance. Time is computed using <code>distanceTime()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># path from case 1 to nearest pump.
euclideanPath(1)

# path from pump 1 to nearest case.
euclideanPath(NULL, 1)

# path from case 1 to pump 6.
euclideanPath(1, 6)

# exclude pump 7 from consideration.
euclideanPath(1, -7)

# path from case 1 to case 6.
euclideanPath(1, 6, type = "cases")

# path from pump 1 to pump 6.
euclideanPath(1, 6, type = "pumps")

# compute multiple cases.
lapply(1:3, euclideanPath)

# plot path
plot(euclideanPath(1))
</code></pre>

<hr>
<h2 id='fatalities'>Amended Dodson and Tobler's cholera data.</h2><span id='topic+fatalities'></span>

<h3>Description</h3>

<p>An amended version of Dodson and Tobler's digitization of John Snow's map of the 1854 London cholera outbreak. It removes 3 duplicate observations and imputes the location for 3 &quot;missing&quot; observation. This information is also available in HistData::Snow.deaths2 (&gt;= ver. 0.7-8).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fatalities
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 variable that records the position and the nearest pump for the 578 bars on Snow's map.
</p>

<dl>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+fixFatalities">fixFatalities</a></code> documents the code for these data. For details, see <code>vignette</code>(&quot;duplicate.missing.cases&quot;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caseLocator">caseLocator</a></code>
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>
<p><code><a href="#topic+caseLocator">caseLocator</a></code>
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>

<hr>
<h2 id='fatalities.address'>&quot;Unstacked&quot; amended cholera data with address as unit of observation.</h2><span id='topic+fatalities.address'></span>

<h3>Description</h3>

<p>An &quot;unstacked&quot; version of the <code>fatalities</code> dataset. It changes the unit of observation from the case (bar) to the &quot;address&quot;, the x-y coordinates of the case at the base of a stack, and makes the number of fatalities an attribute of the &quot;address&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fatalities.address
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 variables for 321 addresses
</p>

<dl>
<dt><code>anchor</code></dt><dd><p>numerical case ID of address</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>case.count</code></dt><dd><p>number of fatalities at address</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data. For details, see <code>vignette</code>(&quot;unstacking.fatalities&quot;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caseLocator">caseLocator</a></code>
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>

<hr>
<h2 id='fatalities.unstacked'>&quot;Unstacked&quot; amended cholera fatalities data with fatality as unit of observation.</h2><span id='topic+fatalities.unstacked'></span>

<h3>Description</h3>

<p>An &quot;unstacked&quot; version of the <code>fatalities</code> dataset. It changes the unit of observation from the case (bar) to the &quot;address&quot;, the x-y coordinates of the case at the base of a stack, and assigns the base case's coordinates to all cases in the stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fatalities.unstacked
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 variable that records the position of the 578 bars on Snow's map.
</p>

<dl>
<dt><code>case</code></dt><dd><p>numerical case ID</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data. For details, see <code>vignette</code>(&quot;unstacking.fatalities&quot;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caseLocator">caseLocator</a></code>
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>

<hr>
<h2 id='fixFatalities'>Fix errors in Dodson and Tobler's digitization of Snow's map.</h2><span id='topic+fixFatalities'></span>

<h3>Description</h3>

<p>Fixes two apparent coding errors using three misplaced cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixFatalities()
</code></pre>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>See Also</h3>

<p><code>vignette("duplicate.missing.cases")</code>
</p>

<hr>
<h2 id='frame.data'>Map frame data c(&quot;x&quot;, &quot;y&quot;) and c(&quot;lon&quot;, &quot;lat&quot;).</h2><span id='topic+frame.data'></span>

<h3>Description</h3>

<p>Map frame data c(&quot;x&quot;, &quot;y&quot;) and c(&quot;lon&quot;, &quot;lat&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frame.data
</code></pre>


<h3>Format</h3>

<p>A data frame with 106 observations (points) and 8 variables.
</p>

<dl>
<dt><code>street</code></dt><dd><p>street number</p>
</dd>
<dt><code>n</code></dt><dd><p>street street component number</p>
</dd>
<dt><code>x</code></dt><dd><p>native x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>native y-coordinate</p>
</dd>
<dt><code>id</code></dt><dd><p>segment numeric ID</p>
</dd>
<dt><code>name</code></dt><dd><p>street name</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='frame.sample'>Partitioned map frame points (segment endpoints).</h2><span id='topic+frame.sample'></span>

<h3>Description</h3>

<p>Partitioned map frame points (segment endpoints).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frame.sample
</code></pre>


<h3>Format</h3>

<p>A list of 3 vectors length 19, 19 and 18 from cholera::roads$id.
</p>

<dl>
<dt><code>frame.sample</code></dt><dd><p>cholera::roads$id</p>
</dd>
</dl>


<hr>
<h2 id='isoLines'>Plot isochrone and isodistance regions (prototype)</h2><span id='topic+isoLines'></span>

<h3>Description</h3>

<p>Plot isochrone and isodistance regions (prototype)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isoLines(post = 50, post.type = "distance", palette = "plasma",
  alpha.level = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isoLines_+3A_post">post</code></td>
<td>
<p>Numeric. Distance or time increment.</p>
</td></tr>
<tr><td><code id="isoLines_+3A_post.type">post.type</code></td>
<td>
<p>Character. &quot;distance&quot; or &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="isoLines_+3A_palette">palette</code></td>
<td>
<p>Character.</p>
</td></tr>
<tr><td><code id="isoLines_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency</p>
</td></tr>
</table>

<hr>
<h2 id='landmark.squares'>Centers of city squares.</h2><span id='topic+landmark.squares'></span>

<h3>Description</h3>

<p>Centers of city squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmark.squares
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables that records the position of the orthogonal projection of landmarks onto the network of roads.
</p>

<dl>
<dt><code>name</code></dt><dd><p>square name</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
</dl>


<hr>
<h2 id='landmarkData'>Landmark data.</h2><span id='topic+landmarkData'></span>

<h3>Description</h3>

<p>Nominal and orthogonal coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarkData(multi.core = TRUE, dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landmarkData_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="landmarkData_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>

<hr>
<h2 id='landmarks'>Orthogonal projection of landmarks onto road network.</h2><span id='topic+landmarks'></span>

<h3>Description</h3>

<p>Orthogonal projection of landmarks onto road network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarks
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables that records the position of the orthogonal projection of landmarks onto the network of roads.
</p>

<dl>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>orthogonal x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>orthogonal y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>x</code></dt><dd><p>nominal x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>nominal y-coordinate</p>
</dd>
<dt><code>name</code></dt><dd><p>landmark name</p>
</dd>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+landmarkData">landmarkData</a></code> and <code><a href="#topic+latlongLandmarks">latlongLandmarks</a></code> document the code for these data.
</p>

<hr>
<h2 id='latlong.ortho.addr'>Orthogonal projection of observed address (latlong) cases onto road network.</h2><span id='topic+latlong.ortho.addr'></span>

<h3>Description</h3>

<p>Orthogonal projection of observed address (latlong) cases onto road network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong.ortho.addr
</code></pre>


<h3>Format</h3>

<p>A data frame with 7 variables that records the position of the orthogonal projection of the 321 cases onto the network of roads.
</p>

<dl>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='latlong.ortho.pump'>Orthogonal projection of 13 original pumps (latlong).</h2><span id='topic+latlong.ortho.pump'></span>

<h3>Description</h3>

<p>Orthogonal projection of 13 original pumps (latlong).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong.ortho.pump
</code></pre>


<h3>Format</h3>

<p>A data frame with 7 variables that records the position of the orthogonal projection of the 13 original pumps onto the network of roads.
</p>

<dl>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>pump.id</code></dt><dd><p>numeric ID</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>

<hr>
<h2 id='latlong.ortho.pump.vestry'>Orthogonal projection of the 14 pumps from the Vestry Report (latlong).</h2><span id='topic+latlong.ortho.pump.vestry'></span>

<h3>Description</h3>

<p>Orthogonal projection of the 14 pumps from the Vestry Report (latlong).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong.ortho.pump.vestry
</code></pre>


<h3>Format</h3>

<p>A data frame with 7 variables that records the position of the orthogonal projection of the 14 pumps onto the network of roads.
</p>

<dl>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>pump.id</code></dt><dd><p>numeric ID</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>

<hr>
<h2 id='latlongAddress'>Compute latitude and longitude of case &quot;addresses&quot; (prototype).</h2><span id='topic+latlongAddress'></span>

<h3>Description</h3>

<p>Compute latitude and longitude of case &quot;addresses&quot; (prototype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongAddress(path, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongAddress_+3A_path">path</code></td>
<td>
<p>Character. e.g., &quot;~/Documents/Data/&quot;</p>
</td></tr>
<tr><td><code id="latlongAddress_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Note</h3>

<p>This documents the computation of the latlong version of the fatalities.address data frame.
</p>

<hr>
<h2 id='latlongFatalities'>Compute latitude and longitude of non-address fatalities (prototype).</h2><span id='topic+latlongFatalities'></span>

<h3>Description</h3>

<p>Compute latitude and longitude of non-address fatalities (prototype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongFatalities(path, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongFatalities_+3A_path">path</code></td>
<td>
<p>Character. e.g., &quot;~/Documents/Data/&quot;</p>
</td></tr>
<tr><td><code id="latlongFatalities_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Note</h3>

<p>This documents the computation of the latlong version of the fatalities data frame.
</p>

<hr>
<h2 id='latlongLandmarks'>Compute Georeferenced Latitude and Longitude (prototype).</h2><span id='topic+latlongLandmarks'></span>

<h3>Description</h3>

<p>Compute Georeferenced Latitude and Longitude (prototype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongLandmarks(path, orthogonal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongLandmarks_+3A_path">path</code></td>
<td>
<p>Character. e.g., &quot;~/Documents/Data/&quot;</p>
</td></tr>
<tr><td><code id="latlongLandmarks_+3A_orthogonal">orthogonal</code></td>
<td>
<p>Logical. Use orthogonal projection coordinates.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This documents the computation of the latlong version of the landmarks data frame.
</p>

<hr>
<h2 id='latlongNearestPump'>Compute shortest georeferenced distances (and walking paths) to selected pumps (prototype).</h2><span id='topic+latlongNearestPump'></span>

<h3>Description</h3>

<p>Compute shortest georeferenced distances (and walking paths) to selected pumps (prototype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongNearestPump(pump.select = NULL, metric = "walking",
  vestry = FALSE, weighted = TRUE, time.unit = "second",
  walking.speed = 5, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongNearestPump_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Pump candidates to consider. Default is <code>NULL</code>: all pumps are used. Otherwise, selection by a vector of numeric IDs: 1 to 13 for <code>pumps</code>; 1 to 14 for <code>pumps.vestry</code>. Negative selection allowed.</p>
</td></tr>
<tr><td><code id="latlongNearestPump_+3A_metric">metric</code></td>
<td>
<p>Character. &quot;euclidean&quot; or &quot;walking&quot;.</p>
</td></tr>
<tr><td><code id="latlongNearestPump_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="latlongNearestPump_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path in terms of road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="latlongNearestPump_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="latlongNearestPump_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="latlongNearestPump_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame or list of 'igraph' path nodes.
</p>

<hr>
<h2 id='latlongNeighborhoodData'>Compute network graph of roads, cases and pumps.</h2><span id='topic+latlongNeighborhoodData'></span>

<h3>Description</h3>

<p>Assembles cases, pumps and road into a network graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongNeighborhoodData(vestry = FALSE, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongNeighborhoodData_+3A_vestry">vestry</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="latlongNeighborhoodData_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>

<hr>
<h2 id='latlongNeighborhoodVoronoi'>Compute Voronoi pump neighborhoods (lat-long prototype).</h2><span id='topic+latlongNeighborhoodVoronoi'></span>

<h3>Description</h3>

<p>Group cases into neighborhoods using Voronoi tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongNeighborhoodVoronoi(pump.select = NULL, vestry = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongNeighborhoodVoronoi_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="latlongNeighborhoodVoronoi_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
</table>

<hr>
<h2 id='latlongNeighborhoodWalking'>Compute walking path pump neighborhoods.</h2><span id='topic+latlongNeighborhoodWalking'></span>

<h3>Description</h3>

<p>Group cases into neighborhoods based on walking distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongNeighborhoodWalking(pump.select = NULL, vestry = FALSE,
  multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongNeighborhoodWalking_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps. Note that you can't just select the pump on Adam and Eve Court (#2) because it's technically an isolate.</p>
</td></tr>
<tr><td><code id="latlongNeighborhoodWalking_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="latlongNeighborhoodWalking_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>

<hr>
<h2 id='latlongPumps'>Compute Georeferenced Latitude and Longitude (prototype).</h2><span id='topic+latlongPumps'></span>

<h3>Description</h3>

<p>Compute Georeferenced Latitude and Longitude (prototype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongPumps(path, vestry = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongPumps_+3A_path">path</code></td>
<td>
<p>Character. e.g., &quot;~/Documents/Data/&quot;</p>
</td></tr>
<tr><td><code id="latlongPumps_+3A_vestry">vestry</code></td>
<td>
<p>Logical.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This documents the computation of the latlong version of the pumps and pumps.vestry data frames.
</p>

<hr>
<h2 id='latlongRoads'>Compute latitude and longitude for unique road segment endpoints (prototype).</h2><span id='topic+latlongRoads'></span>

<h3>Description</h3>

<p>Compute latitude and longitude for unique road segment endpoints (prototype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongRoads(path, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongRoads_+3A_path">path</code></td>
<td>
<p>Character. e.g., &quot;~/Documents/Data/&quot;</p>
</td></tr>
<tr><td><code id="latlongRoads_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Note</h3>

<p>This documents the computation of the lat-long version of the roads data frame.
</p>

<hr>
<h2 id='latlongVoronoi'>Compute Georeferenced Latitude and Longitude of vertices of Voronoi polygons.</h2><span id='topic+latlongVoronoi'></span>

<h3>Description</h3>

<p>Compute Georeferenced Latitude and Longitude of vertices of Voronoi polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongVoronoi(pump.select = NULL, vestry = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongVoronoi_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="latlongVoronoi_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap(latlong = TRUE)
cells &lt;- latlongVoronoi()
invisible(lapply(cells, function(x) polygon(x[, c("lon", "lat")])))
</code></pre>

<hr>
<h2 id='latlongWalkingPath'>Plot walking path to nearest pump (prototype).</h2><span id='topic+latlongWalkingPath'></span>

<h3>Description</h3>

<p>Plot walking path to nearest pump (prototype).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlongWalkingPath(case = 1, destination = NULL, vestry = FALSE,
  weighted = TRUE, distance.unit = "meter", time.unit = "second",
  walking.speed = 5, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlongWalkingPath_+3A_case">case</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="latlongWalkingPath_+3A_destination">destination</code></td>
<td>
<p>Numeric. Pump ID.</p>
</td></tr>
<tr><td><code id="latlongWalkingPath_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the map in the Vestry Report. <code>FALSE</code> uses the 13 pumps from the original map.</p>
</td></tr>
<tr><td><code id="latlongWalkingPath_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path in terms of road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="latlongWalkingPath_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot; or &quot;yard&quot;.</p>
</td></tr>
<tr><td><code id="latlongWalkingPath_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="latlongWalkingPath_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="latlongWalkingPath_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>

<hr>
<h2 id='mapRange'>Compute xlim and ylim of Snow's map.</h2><span id='topic+mapRange'></span>

<h3>Description</h3>

<p>Compute xlim and ylim of Snow's map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapRange(latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapRange_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>

<hr>
<h2 id='nearestPump'>Compute shortest distances or paths to selected pumps.</h2><span id='topic+nearestPump'></span>

<h3>Description</h3>

<p>Compute shortest distances or paths to selected pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestPump(pump.select = NULL, metric = "walking", vestry = FALSE,
  weighted = TRUE, case.set = "observed", distance.unit = "meter",
  time.unit = "second", walking.speed = 5, multi.core = TRUE,
  dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestPump_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Pump candidates to consider. Default is <code>NULL</code>: all pumps are used. Otherwise, selection by a vector of numeric IDs: 1 to 13 for <code>pumps</code>; 1 to 14 for <code>pumps.vestry</code>. Negative selection allowed.</p>
</td></tr>
<tr><td><code id="nearestPump_+3A_metric">metric</code></td>
<td>
<p>Character. &quot;euclidean&quot; or &quot;walking&quot;.</p>
</td></tr>
<tr><td><code id="nearestPump_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="nearestPump_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path in terms of road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="nearestPump_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot;, &quot;expected&quot;, or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="nearestPump_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. Meaningful only when &quot;weighted&quot; is <code>TRUE</code>. See <code>vignette("roads")</code> for information on unit distances.</p>
</td></tr>
<tr><td><code id="nearestPump_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="nearestPump_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="nearestPump_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="nearestPump_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame or list of 'igraph' path nodes.
</p>


<h3>Note</h3>

<p>Time is computed using <code>distanceTime()</code>.
</p>

<hr>
<h2 id='neighborhoodData'>Compute network graph of roads, cases and pumps.</h2><span id='topic+neighborhoodData'></span>

<h3>Description</h3>

<p>Assembles cases, pumps and road into a network graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhoodData(vestry = FALSE, case.set = "observed", embed = TRUE,
  embed.landmarks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborhoodData_+3A_vestry">vestry</code></td>
<td>
<p>Logical. Use Vestry Report pump data.</p>
</td></tr>
<tr><td><code id="neighborhoodData_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;, or &quot;snow&quot;. &quot;snow&quot; captures John Snow's annotation of the Broad Street pump neighborhood printed in the Vestry report version of the map.</p>
</td></tr>
<tr><td><code id="neighborhoodData_+3A_embed">embed</code></td>
<td>
<p>Logical. Embed cases and pumps into road network.</p>
</td></tr>
<tr><td><code id="neighborhoodData_+3A_embed.landmarks">embed.landmarks</code></td>
<td>
<p>Logical. Embed landmarks into road network.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list of nodes, edges and an 'igraph' network graph.
</p>

<hr>
<h2 id='neighborhoodEuclidean'>Compute Euclidean path pump neighborhoods.</h2><span id='topic+neighborhoodEuclidean'></span>

<h3>Description</h3>

<p>Plots star graph from pump to its cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhoodEuclidean(pump.select = NULL, vestry = FALSE,
  case.location = "nominal", case.set = "observed", multi.core = TRUE,
  dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborhoodEuclidean_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_case.location">case.location</code></td>
<td>
<p>Character. &quot;address&quot; or &quot;nominal&quot;. For <code>observed = TRUE</code>: &quot;address&quot; uses <code>ortho.proj</code> and &quot;nominal&quot; uses <code>fatalities</code>. For <code>observed = TRUE</code>: &quot;address&quot; uses <code>sim.ortho.proj</code> and &quot;nominal&quot; uses <code>regular.cases</code>.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neighborhoodEuclidean()
neighborhoodEuclidean(-6)
neighborhoodEuclidean(pump.select = 6:7)

## End(Not run)
</code></pre>

<hr>
<h2 id='neighborhoodVoronoi'>Compute Voronoi pump neighborhoods.</h2><span id='topic+neighborhoodVoronoi'></span>

<h3>Description</h3>

<p>Group cases into neighborhoods using Voronoi tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhoodVoronoi(pump.select = NULL, vestry = FALSE,
  case.location = "address", pump.location = "nominal",
  polygon.vertices = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborhoodVoronoi_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="neighborhoodVoronoi_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="neighborhoodVoronoi_+3A_case.location">case.location</code></td>
<td>
<p>Character. &quot;address&quot; or &quot;nominal&quot;. &quot;address&quot; uses the x-y coordinates of <code>ortho.proj</code>. &quot;nominal&quot; uses the x-y coordinates of <code>fatalities</code>.</p>
</td></tr>
<tr><td><code id="neighborhoodVoronoi_+3A_pump.location">pump.location</code></td>
<td>
<p>Character. &quot;address&quot; or &quot;nominal&quot;. &quot;address&quot; uses the x-y coordinates of <code>ortho.proj.pump</code> or <code>ortho.proj.pump.vestry</code>. &quot;nominal&quot; uses the x-y coordinates of <code>pumps</code> or <code>pumps.vestry</code>.</p>
</td></tr>
<tr><td><code id="neighborhoodVoronoi_+3A_polygon.vertices">polygon.vertices</code></td>
<td>
<p>Logical. <code>TRUE</code> returns a list of x-y coordinates of the vertices of Voronoi cells. Useful for <code>sp::point.in.polygon()</code> as used in <code>print.voronoi()</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list with 12 objects.
</p>

<ul>
<li><p><code>pump.id</code>: vector of selected pumps
</p>
</li>
<li><p><code>voronoi</code>: output from deldir::deldir().
</p>
</li>
<li><p><code>snow.colors</code>: neighborhood color based on snowColors().
</p>
</li>
<li><p><code>x.rng</code>: range of x for plot.
</p>
</li>
<li><p><code>y.rng</code>: range of y for plot.
</p>
</li>
<li><p><code>select.string</code>: description of &quot;pump.select&quot; for plot title.
</p>
</li>
<li><p><code>expected.data</code>: expected neighborhood fatality counts, based on Voronoi cell area.
</p>
</li>
<li><p><code>coordinates</code>: polygon vertices of Voronoi cells.
</p>
</li>
<li><p><code>statistic.data</code>: observed neighborhood fatality counts.
</p>
</li>
<li><p><code>pump.select</code>: &quot;pump.select&quot; from neighborhoodVoronoi().
</p>
</li>
<li><p><code>statistic</code>: &quot;statistic&quot; from neighborhoodVoronoi().
</p>
</li>
<li><p><code>vestry</code>: &quot;vestry&quot; from neighborhoodVoronoi().
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>neighborhoodVoronoi()
neighborhoodVoronoi(vestry = TRUE)
neighborhoodVoronoi(pump.select = 6:7)
neighborhoodVoronoi(pump.select = -6)
neighborhoodVoronoi(pump.select = -6, polygon.vertices = TRUE)

# coordinates for vertices also available in the returned object.
dat &lt;- neighborhoodVoronoi(pump.select = -6)
dat$coordinates
</code></pre>

<hr>
<h2 id='neighborhoodWalking'>Compute walking path pump neighborhoods.</h2><span id='topic+neighborhoodWalking'></span>

<h3>Description</h3>

<p>Group cases into neighborhoods based on walking distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhoodWalking(pump.select = NULL, vestry = FALSE, weighted = TRUE,
  case.set = "observed", multi.core = TRUE, dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborhoodWalking_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps. Note that you can't just select the pump on Adam and Eve Court (#2) because it's technically an isolate.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path weighted by road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot;, &quot;expected&quot; or &quot;snow&quot;. &quot;snow&quot; captures John Snow's annotation of the Broad Street pump neighborhood printed in the Vestry report version of the map.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list with 7 objects:
</p>

<ul>
<li><p><code>paths</code>: list of paths to nearest or selected pump(s).
</p>
</li>
<li><p><code>cases</code>: list of cases by pump.
</p>
</li>
<li><p><code>vestry</code>: &quot;vestry&quot; from neighborhoodWalking().
</p>
</li>
<li><p><code>observed</code>: &quot;observed&quot; from neighborhoodWalking().
</p>
</li>
<li><p><code>pump.select</code>: &quot;pump.select&quot; from neighborhoodWalking().
</p>
</li>
<li><p><code>cores</code>: number of cores to use for parallel implementation.
</p>
</li>
<li><p><code>metric</code>: incremental metric used to find cut point on split road segments.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neighborhoodWalking()
neighborhoodWalking(pump.select = -6)

## End(Not run)
</code></pre>

<hr>
<h2 id='ortho.proj'>Orthogonal projection of observed cases onto road network.</h2><span id='topic+ortho.proj'></span>

<h3>Description</h3>

<p>Orthogonal projection of observed cases onto road network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho.proj
</code></pre>


<h3>Format</h3>

<p>A data frame with 5 variables that records the position of the orthogonal projection of the 578 cases onto the network of roads.
</p>

<dl>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='ortho.proj.pump'>Orthogonal projection of 13 original pumps.</h2><span id='topic+ortho.proj.pump'></span>

<h3>Description</h3>

<p>Orthogonal projection of 13 original pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho.proj.pump
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables that records the position of the orthogonal projection of the 13 original pumps onto the network of roads.
</p>

<dl>
<dt><code>pump.id</code></dt><dd><p>numeric ID</p>
</dd>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>node</code></dt><dd><p>node ID</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>

<hr>
<h2 id='ortho.proj.pump.vestry'>Orthogonal projection of the 14 pumps from the Vestry Report.</h2><span id='topic+ortho.proj.pump.vestry'></span>

<h3>Description</h3>

<p>Orthogonal projection of the 14 pumps from the Vestry Report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho.proj.pump.vestry
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables that records the position of the orthogonal projection of the 14 pumps onto the network of roads.
</p>

<dl>
<dt><code>pump.id</code></dt><dd><p>numeric ID</p>
</dd>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>node</code></dt><dd><p>node ID</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>

<hr>
<h2 id='oxford.weather'>Oxford monthly weather data, January 1853 - December 2019.</h2><span id='topic+oxford.weather'></span>

<h3>Description</h3>

<p>Extract from UK Met Office (https://www.metoffice.gov.uk/pub/data/weather/uk/climate/stationdata/oxforddata.txt): Lat 51.761 Lon -1.262, 63 metres amsl. Approximate 90 km (55 miles) northwest of Soho.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oxford.weather
</code></pre>


<h3>Format</h3>

<p>A data frame with 7 variables and 95 observations.
</p>

<dl>
<dt><code>year</code></dt><dd><p>yyyy</p>
</dd>
<dt><code>mo</code></dt><dd><p>month (mm)</p>
</dd>
<dt><code>tmax</code></dt><dd><p>maximum temperature degrees Celsius</p>
</dd>
<dt><code>tmin</code></dt><dd><p>minimum temperature degrees Celsius</p>
</dd>
<dt><code>airfrost</code></dt><dd><p>days</p>
</dd>
<dt><code>rain</code></dt><dd><p>millimeters (mm)</p>
</dd>
<dt><code>sun</code></dt><dd><p>sunshine hours</p>
</dd>
</dl>



<h3>Note</h3>

<p>December 1860 excluded due to missing tmin observation.
</p>

<hr>
<h2 id='oxfordWeather'>Weather data recorded in Oxford (Met Office UK).</h2><span id='topic+oxfordWeather'></span>

<h3>Description</h3>

<p>Add and use last day of month as unit of observation to oxford.weather.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oxfordWeather()
</code></pre>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Note</h3>

<p>December 1860 observation is dropped due to missing &quot;tmin&quot; value.
</p>

<hr>
<h2 id='plague.pit'>Plague pit coordinates.</h2><span id='topic+plague.pit'></span>

<h3>Description</h3>

<p>Coordinates for polygon() or sp::Polygon(). In progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plague.pit
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations and 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
</dl>


<hr>
<h2 id='plot.euclidean'>Plot method for neighborhoodEuclidean().</h2><span id='topic+plot.euclidean'></span>

<h3>Description</h3>

<p>Plot method for neighborhoodEuclidean().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean'
plot(x, type = "star", add.observed.points = TRUE,
  add.title = TRUE, msg = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.euclidean_+3A_x">x</code></td>
<td>
<p>An object of class &quot;euclidean&quot; created by <code>neighborhoodEuclidean()</code>.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_type">type</code></td>
<td>
<p>Character. &quot;star&quot;, &quot;area.points&quot; or &quot;area.polygons&quot;. &quot;area&quot; flavors only valid when <code>case.set = "expected"</code>.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_add.observed.points">add.observed.points</code></td>
<td>
<p>Logical. Add observed fatality &quot;addresses&quot;.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Add title.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_msg">msg</code></td>
<td>
<p>Logical. Toggle in-progress messages.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>


<h3>Note</h3>

<p>This uses an approximate computation of polygons, using the 'TSP' package, that may produce non-simple and/or overlapping polygons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(neighborhoodEuclidean())
plot(neighborhoodEuclidean(-6))
plot(neighborhoodEuclidean(pump.select = 6:7))
plot(neighborhoodEuclidean(case.set = "expected"), type = "area.points")
plot(neighborhoodEuclidean(case.set = "expected"), type = "area.polygons")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.euclidean_path'>Plot the path of the Euclidean distance between cases and/or pumps.</h2><span id='topic+plot.euclidean_path'></span>

<h3>Description</h3>

<p>Plot the path of the Euclidean distance between cases and/or pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean_path'
plot(x, zoom = 0.5, unit.posts = "distance",
  unit.interval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.euclidean_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;euclidean_path&quot; created by euclideanPath().</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. A numeric value &gt;= 0 controls the degree of zoom. The default is 0.5.</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_unit.posts">unit.posts</code></td>
<td>
<p>Character. &quot;distance&quot; for mileposts; &quot;time&quot; for timeposts; <code>NULL</code> for no posts.</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_unit.interval">unit.interval</code></td>
<td>
<p>Numeric. Set interval between posts. When <code>unit.posts</code> is &quot;distance&quot;, <code>unit.interval</code> automatically defaults to 50 meters. When <code>unit.posts</code> is &quot;time&quot;, <code>unit.interval</code> automatically defaults to 60 seconds.</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(euclideanPath(15))
plot(euclideanPath(15), unit.posts = "time")
</code></pre>

<hr>
<h2 id='plot.latlong_neighborhood_data'>Plot method for latlongNeighborhoodData().</h2><span id='topic+plot.latlong_neighborhood_data'></span>

<h3>Description</h3>

<p>Visualize underlying road network (with or without cases and pumps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'latlong_neighborhood_data'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.latlong_neighborhood_data_+3A_x">x</code></td>
<td>
<p>An 'igraph' object of class &quot;latlong_neighborhood_data&quot; created by <code>latlongNeighborhoodData()</code>.</p>
</td></tr>
<tr><td><code id="plot.latlong_neighborhood_data_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph base graphics plot.
</p>

<hr>
<h2 id='plot.latlong_walking'>Plot method for latlongNeighborhoodWalking().</h2><span id='topic+plot.latlong_walking'></span>

<h3>Description</h3>

<p>Plot method for latlongNeighborhoodWalking().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'latlong_walking'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.latlong_walking_+3A_x">x</code></td>
<td>
<p>An object of class &quot;latlong_walking&quot; created by <code>latlongNeighborhoodWalking()</code>.</p>
</td></tr>
<tr><td><code id="plot.latlong_walking_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>

<hr>
<h2 id='plot.latlong_walking_path'>Plot the walking path between selected cases and/or pumps.</h2><span id='topic+plot.latlong_walking_path'></span>

<h3>Description</h3>

<p>Plot the walking path between selected cases and/or pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'latlong_walking_path'
plot(x, zoom = TRUE, mileposts = TRUE,
  milepost.unit = "distance", milepost.interval = NULL, alpha.level = 1,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.latlong_walking_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;latlong_walking_path&quot; created by latlongWalkingPath().</p>
</td></tr>
<tr><td><code id="plot.latlong_walking_path_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. A numeric value &gt;= 0 that controls the degree of zoom.</p>
</td></tr>
<tr><td><code id="plot.latlong_walking_path_+3A_mileposts">mileposts</code></td>
<td>
<p>Logical. Plot mile/time posts.</p>
</td></tr>
<tr><td><code id="plot.latlong_walking_path_+3A_milepost.unit">milepost.unit</code></td>
<td>
<p>Character. &quot;distance&quot; or &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="plot.latlong_walking_path_+3A_milepost.interval">milepost.interval</code></td>
<td>
<p>Numeric. Mile post interval unit of distance (yard or meter) or unit of time (seconds).</p>
</td></tr>
<tr><td><code id="plot.latlong_walking_path_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for path: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="plot.latlong_walking_path_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>

<hr>
<h2 id='plot.latlongNeighborhoodVoronoi'>Plot method for latlongNeighborhoodVoronoi()</h2><span id='topic+plot.latlongNeighborhoodVoronoi'></span>

<h3>Description</h3>

<p>Plot method for latlongNeighborhoodVoronoi()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'latlongNeighborhoodVoronoi'
plot(x, add.cases = TRUE,
  add.pumps = TRUE, euclidean.paths = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.latlongNeighborhoodVoronoi_+3A_x">x</code></td>
<td>
<p>Object. Currently separate classification check.</p>
</td></tr>
<tr><td><code id="plot.latlongNeighborhoodVoronoi_+3A_add.cases">add.cases</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="plot.latlongNeighborhoodVoronoi_+3A_add.pumps">add.pumps</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="plot.latlongNeighborhoodVoronoi_+3A_euclidean.paths">euclidean.paths</code></td>
<td>
<p>Logical. Currently separate classification check.</p>
</td></tr>
<tr><td><code id="plot.latlongNeighborhoodVoronoi_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.neighborhood_data'>Plot method for neighborhoodData().</h2><span id='topic+plot.neighborhood_data'></span>

<h3>Description</h3>

<p>Visualize underlying road network (with or without cases and pumps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neighborhood_data'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.neighborhood_data_+3A_x">x</code></td>
<td>
<p>An 'igraph' object of class &quot;neighborhood_data&quot; created by <code>neighborhoodData()</code>.</p>
</td></tr>
<tr><td><code id="plot.neighborhood_data_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(neighborhoodData())
plot(neighborhoodData(embed = FALSE))

</code></pre>

<hr>
<h2 id='plot.oxfordWeather'>Plot method for oxfordWeather().</h2><span id='topic+plot.oxfordWeather'></span>

<h3>Description</h3>

<p>Plot method for oxfordWeather().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'oxfordWeather'
plot(x, statistic = "temperature",
  month = "september", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.oxfordWeather_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="plot.oxfordWeather_+3A_statistic">statistic</code></td>
<td>
<p>Character.</p>
</td></tr>
<tr><td><code id="plot.oxfordWeather_+3A_month">month</code></td>
<td>
<p>Character. &quot;august&quot; or &quot;september&quot;.</p>
</td></tr>
<tr><td><code id="plot.oxfordWeather_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>

<hr>
<h2 id='plot.povertyLondon'>Plot method for povertyLondon().</h2><span id='topic+plot.povertyLondon'></span>

<h3>Description</h3>

<p>Plot method for povertyLondon().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'povertyLondon'
plot(x, district = c("City", "Westminster",
  "Marylebone", "St. Giles"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.povertyLondon_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="plot.povertyLondon_+3A_district">district</code></td>
<td>
<p>Character. Selected district(s).</p>
</td></tr>
<tr><td><code id="plot.povertyLondon_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.profile_perspective'>Plot method for profilePerspective().</h2><span id='topic+plot.profile_perspective'></span>

<h3>Description</h3>

<p>Plot method for profilePerspective().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile_perspective'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.profile_perspective_+3A_x">x</code></td>
<td>
<p>An object of class &quot;profile&quot; created by <code>profilePerspective()</code>.</p>
</td></tr>
<tr><td><code id="plot.profile_perspective_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.time_series'>Plot aggregate time series data from Vestry report.</h2><span id='topic+plot.time_series'></span>

<h3>Description</h3>

<p>Plot aggregate fatality data and indicates the date of the removal of the handle of the Broad Street pump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'time_series'
plot(x, statistic = "fatal.attacks",
  pump.handle = TRUE, main = "Removal of the Broad Street Pump Handle",
  type = "o", xlab = "Date", ylab = "Fatalities", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.time_series_+3A_x">x</code></td>
<td>
<p>An object of class &quot;time_series&quot; from timeSeries().</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_statistic">statistic</code></td>
<td>
<p>Character. Fatality measure: either &quot;fatal.attacks&quot; or &quot;deaths&quot;.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_pump.handle">pump.handle</code></td>
<td>
<p>Logical. Indicate date of removal of Broad Street pump handle.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_main">main</code></td>
<td>
<p>Character. Title of graph.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_type">type</code></td>
<td>
<p>Character. R plot type.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_xlab">xlab</code></td>
<td>
<p>Character. x-axis label.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_ylab">ylab</code></td>
<td>
<p>Character. y-axis label.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+timeSeries">timeSeries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(timeSeries())
plot(timeSeries(), statistic = "deaths")
plot(timeSeries(), bty = "n", type = "h", lwd = 4)
</code></pre>

<hr>
<h2 id='plot.voronoi'>Plot Voronoi neighborhoods.</h2><span id='topic+plot.voronoi'></span>

<h3>Description</h3>

<p>Plot Voronoi neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi'
plot(x, voronoi.cells = TRUE, delaunay.triangles = FALSE,
  euclidean.paths = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.voronoi_+3A_x">x</code></td>
<td>
<p>An object of class &quot;voronoi&quot; created by <code>neighborhoodVoronoi()</code>.</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_voronoi.cells">voronoi.cells</code></td>
<td>
<p>Logical. Plot Voronoi tessellation cells.</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_delaunay.triangles">delaunay.triangles</code></td>
<td>
<p>Logical. Plot Delaunay triangles.</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_euclidean.paths">euclidean.paths</code></td>
<td>
<p>Logical. Plot all Euclidean paths (star graph).</p>
</td></tr>
<tr><td><code id="plot.voronoi_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graph.
</p>


<h3>See Also</h3>

<p><code>neighborhoodVoronoi()</code>
</p>
<p><code>addVoronoi()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(neighborhoodVoronoi())
</code></pre>

<hr>
<h2 id='plot.walking'>Plot method for neighborhoodWalking().</h2><span id='topic+plot.walking'></span>

<h3>Description</h3>

<p>Plot method for neighborhoodWalking().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walking'
plot(x, type = "roads", msg = FALSE,
  tsp.method = "repetitive_nn", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.walking_+3A_x">x</code></td>
<td>
<p>An object of class &quot;walking&quot; created by <code>neighborhoodWalking()</code>.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_type">type</code></td>
<td>
<p>Character. &quot;roads&quot;, &quot;area.points&quot; or &quot;area.polygons&quot;. &quot;area&quot; flavors only valid when <code>case.set = "expected"</code>.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_msg">msg</code></td>
<td>
<p>Logical. Toggle in-progress messages.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_tsp.method">tsp.method</code></td>
<td>
<p>Character. Traveling salesperson problem algorithm.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>


<h3>Note</h3>

<p>When plotting area graphs with simulated data (i.e., <code>case.set = "expected"</code>), there may be discrepancies between observed cases and expected neighborhoods, particularly between neighborhoods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(neighborhoodWalking())
plot(neighborhoodWalking(case.set = "expected"))
plot(neighborhoodWalking(case.set = "expected"), type = "area.points")
plot(neighborhoodWalking(case.set = "expected"), type = "area.polygons")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.walking_path'>Plot the walking path between selected cases and/or pumps.</h2><span id='topic+plot.walking_path'></span>

<h3>Description</h3>

<p>Plot the walking path between selected cases and/or pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walking_path'
plot(x, zoom = 0.5, stacked = TRUE,
  unit.posts = "distance", unit.interval = NULL, alpha.level = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.walking_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;walking_path&quot; created by walkingPath().</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. A numeric value &gt;= 0 controls the degree of zoom. The default is 0.5.</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_stacked">stacked</code></td>
<td>
<p>Logical. Use stacked fatalities.</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_unit.posts">unit.posts</code></td>
<td>
<p>Character. &quot;distance&quot; for mileposts; &quot;time&quot; for timeposts; NULL for no posts.</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_unit.interval">unit.interval</code></td>
<td>
<p>Numeric. Set interval between posts. When <code>unit.posts = "distance"</code>, <code>unit.interval</code> defaults to 50 meters. When <code>unit.posts = "time"</code>, <code>unit.interval</code> defaults to 60 seconds.</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for path: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>


<h3>Note</h3>

<p>Arrows represent mileposts or timeposts to the destination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(walkingPath(15))
plot(walkingPath(15), unit.posts = "time")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.winterTemperatures'>Plot method for winterTemperatures().</h2><span id='topic+plot.winterTemperatures'></span>

<h3>Description</h3>

<p>Plot method for winterTemperatures().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'winterTemperatures'
plot(x, end.date = "1859-6-1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.winterTemperatures_+3A_x">x</code></td>
<td>
<p>object.</p>
</td></tr>
<tr><td><code id="plot.winterTemperatures_+3A_end.date">end.date</code></td>
<td>
<p>Date. &quot;yyyy-mm-dd&quot; or NULL.</p>
</td></tr>
<tr><td><code id="plot.winterTemperatures_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(winterTemperatures())
</code></pre>

<hr>
<h2 id='povertyLondon'>Poverty and Born in London.</h2><span id='topic+povertyLondon'></span>

<h3>Description</h3>

<p>Gareth Stedman Jones, p. 132. Census and Charles Booth Data, 1881.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>povertyLondon()
</code></pre>

<hr>
<h2 id='print.euclidean'>Print method for neighborhoodEuclidean().</h2><span id='topic+print.euclidean'></span>

<h3>Description</h3>

<p>Parameter values for neighborhoodEuclidean().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.euclidean_+3A_x">x</code></td>
<td>
<p>An object of class &quot;euclidean&quot; created by <code>neighborhoodEuclidean()</code>.</p>
</td></tr>
<tr><td><code id="print.euclidean_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neighborhoodEuclidean()
print(neighborhoodEuclidean())

## End(Not run)
</code></pre>

<hr>
<h2 id='print.euclidean_path'>Print method for euclideanPath().</h2><span id='topic+print.euclidean_path'></span>

<h3>Description</h3>

<p>Summary output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean_path'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.euclidean_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;euclidean_path&quot; created by <code>euclideanPath()</code>.</p>
</td></tr>
<tr><td><code id="print.euclidean_path_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euclideanPath(1)
print(euclideanPath(1))
</code></pre>

<hr>
<h2 id='print.iso'>Print method for isoVertices().</h2><span id='topic+print.iso'></span>

<h3>Description</h3>

<p>Print method for isoVertices().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iso'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.iso_+3A_x">x</code></td>
<td>
<p>An object of class &quot;iso&quot; created by <code>isoVertices()</code>.</p>
</td></tr>
<tr><td><code id="print.iso_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with observed counts.
</p>

<hr>
<h2 id='print.latlong_walking_path'>Print method for latlongWalkingPath().</h2><span id='topic+print.latlong_walking_path'></span>

<h3>Description</h3>

<p>Summary output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'latlong_walking_path'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.latlong_walking_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;latlong_walking_path&quot; created by latlongWalkingPath().</p>
</td></tr>
<tr><td><code id="print.latlong_walking_path_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>

<hr>
<h2 id='print.latlongNeighborhoodVoronoi'>Print method for latlongNeighborhoodVoronoi().</h2><span id='topic+print.latlongNeighborhoodVoronoi'></span>

<h3>Description</h3>

<p>Parameter values for latlongNeighborhoodVoronoi().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'latlongNeighborhoodVoronoi'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.latlongNeighborhoodVoronoi_+3A_x">x</code></td>
<td>
<p>An object of class &quot;latlongNeighborhoodVoronoi&quot; created by <code>latlongNeighborhoodVoronoi()</code>.</p>
</td></tr>
<tr><td><code id="print.latlongNeighborhoodVoronoi_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument values.
</p>

<hr>
<h2 id='print.time_series'>Print summary data for timeSeries().</h2><span id='topic+print.time_series'></span>

<h3>Description</h3>

<p>Return summary results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'time_series'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.time_series_+3A_x">x</code></td>
<td>
<p>An object of class &quot;time_series&quot; created by timeSeries().</p>
</td></tr>
<tr><td><code id="print.time_series_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeSeries()
print(timeSeries())
</code></pre>

<hr>
<h2 id='print.voronoi'>Print method for neighborhoodVoronoi().</h2><span id='topic+print.voronoi'></span>

<h3>Description</h3>

<p>Parameter values for neighborhoodVoronoi().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.voronoi_+3A_x">x</code></td>
<td>
<p>An object of class &quot;voronoi&quot; created by <code>neighborhoodVoronoi()</code>.</p>
</td></tr>
<tr><td><code id="print.voronoi_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>neighborhoodVoronoi()
print(neighborhoodVoronoi())
</code></pre>

<hr>
<h2 id='print.walking'>Print method for neighborhoodWalking().</h2><span id='topic+print.walking'></span>

<h3>Description</h3>

<p>Parameter values for neighborhoodWalking().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walking'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.walking_+3A_x">x</code></td>
<td>
<p>An object of class &quot;walking&quot; created by <code>neighborhoodWalking()</code>.</p>
</td></tr>
<tr><td><code id="print.walking_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neighborhoodWalking()
print(neighborhoodWalking())

## End(Not run)
</code></pre>

<hr>
<h2 id='print.walking_path'>Print method for walkingPath().</h2><span id='topic+print.walking_path'></span>

<h3>Description</h3>

<p>Summary output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walking_path'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.walking_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;walking_path&quot; created by walkingPath().</p>
</td></tr>
<tr><td><code id="print.walking_path_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
walkingPath()
print(walkingPath())

## End(Not run)
</code></pre>

<hr>
<h2 id='profile2D'>2D Profile .</h2><span id='topic+profile2D'></span>

<h3>Description</h3>

<p>2D Profile .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile2D(angle = 0, pump = 7, vestry = FALSE, type = "base",
  multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile2D_+3A_angle">angle</code></td>
<td>
<p>Numeric. Angle of perspective axis in degrees.</p>
</td></tr>
<tr><td><code id="profile2D_+3A_pump">pump</code></td>
<td>
<p>Numeric. Select pump as focal point.</p>
</td></tr>
<tr><td><code id="profile2D_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="profile2D_+3A_type">type</code></td>
<td>
<p>Character. Type of graphic: &quot;base&quot; or &quot;ggplot2&quot;.</p>
</td></tr>
<tr><td><code id="profile2D_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
profile2D(angle = 30)
profile2D(angle = 30, type = "ggplot2")

## End(Not run)
</code></pre>

<hr>
<h2 id='profile3D'>3D Profile.</h2><span id='topic+profile3D'></span>

<h3>Description</h3>

<p>3D Profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile3D(pump.select = NULL, pump.subset = NULL, vestry = FALSE,
  drop.neg.subset = FALSE, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile3D_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="profile3D_+3A_pump.subset">pump.subset</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to subset from the neighborhoods defined by <code>pump.select</code>. Negative selection possible. <code>NULL</code> selects all pumps in <code>pump.select</code>.</p>
</td></tr>
<tr><td><code id="profile3D_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="profile3D_+3A_drop.neg.subset">drop.neg.subset</code></td>
<td>
<p>Logical. Drop negative subset selection</p>
</td></tr>
<tr><td><code id="profile3D_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
profile3D(pump.select = 6:7)
profile3D(pump.subset = -7)
profile3D(pump.subset = -7, drop.neg.subset = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pumpCase'>Extract numeric case IDs by pump neighborhood.</h2><span id='topic+pumpCase'></span>

<h3>Description</h3>

<p>Extract numeric case IDs by pump neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumpCase(x, case)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pumpCase_+3A_x">x</code></td>
<td>
<p>An object created by <code>neighborhoodEuclidean()</code>, <code>neighborhoodVoronoi()</code> or <code>neighborhoodWalking()</code>.</p>
</td></tr>
<tr><td><code id="pumpCase_+3A_case">case</code></td>
<td>
<p>Character. &quot;address&quot; or &quot;fatality&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list of numeric ID of cases by pump neighborhoods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pumpCase(neighborhoodEuclidean())
pumpCase(neighborhoodVoronoi())
pumpCase(neighborhoodWalking())

## End(Not run)
</code></pre>

<hr>
<h2 id='pumpData'>Compute pump coordinates.</h2><span id='topic+pumpData'></span>

<h3>Description</h3>

<p>Returns either the set of x-y coordinates for the pumps themselves or for their orthogonally projected &quot;addresses&quot; on the network of roads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumpData(vestry = FALSE, orthogonal = FALSE, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pumpData_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="pumpData_+3A_orthogonal">orthogonal</code></td>
<td>
<p>Logical. <code>TRUE</code> returns pump &quot;addresses&quot;: the coordinates of the orthogonal projection from a pump's location onto the network of roads. <code>FALSE</code> returns pump location coordinates.</p>
</td></tr>
<tr><td><code id="pumpData_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. With Numeric, you specify the number logical cores (rounds with <code>as.integer()</code>). See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Note</h3>

<p>Note: The location of the fourteenth pump, at Hanover Square, and the &quot;correct&quot; location of the Broad Street pump are approximate. This function documents the code that generates <code><a href="#topic+pumps">pumps</a></code>, <code><a href="#topic+pumps.vestry">pumps.vestry</a></code>, <code><a href="#topic+ortho.proj.pump">ortho.proj.pump</a></code> and <code><a href="#topic+ortho.proj.pump.vestry">ortho.proj.pump.vestry</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pumpLocator">pumpLocator</a></code>
</p>

<hr>
<h2 id='pumpFatalities'>Compute fatalities by pump.</h2><span id='topic+pumpFatalities'></span>

<h3>Description</h3>

<p>Compute fatalities by pump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumpFatalities(pump.select = NULL, metric = "walking", vestry = FALSE,
  latlong = FALSE, multi.core = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pumpFatalities_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Pump candidates to consider. Default is <code>NULL</code>: all pumps are used. Otherwise, selection by a vector of numeric IDs: 1 to 13 for <code>pumps</code>; 1 to 14 for <code>pumps.vestry</code>. Negative selection allowed.</p>
</td></tr>
<tr><td><code id="pumpFatalities_+3A_metric">metric</code></td>
<td>
<p>Character. &quot;euclidean&quot; or &quot;walking&quot;.</p>
</td></tr>
<tr><td><code id="pumpFatalities_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="pumpFatalities_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
<tr><td><code id="pumpFatalities_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pumpFatalities(pump.select = -7)
pumpFatalities(metric = "euclidean")
pumpFatalities(metric = "euclidean", vestry = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pumpLocator'>Locate water pump by numerical ID.</h2><span id='topic+pumpLocator'></span>

<h3>Description</h3>

<p>Highlight selected water pump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumpLocator(id = 7, zoom = 1, vestry = FALSE, add.title = TRUE,
  highlight.segment = TRUE, data = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pumpLocator_+3A_id">id</code></td>
<td>
<p>Numeric or Integer. With <code>vestry = TRUE</code>, a whole number between 1 and 14. With <code>vestry = FALSE</code>, a whole number between 1 and 13. See <code>cholera::pumps.vestry</code> and <code>cholera::pumps</code> for IDs and details about specific pumps.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. A numeric value &gt;= 0 controls the degree of zoom. The default is 1.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> for the 14 pumps from Vestry Report. <code>FALSE</code> for the original 13 pumps.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Include title.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_highlight.segment">highlight.segment</code></td>
<td>
<p>Logical. Highlight case's segment.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_data">data</code></td>
<td>
<p>Logical. Output data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pumpLocator()
pumpLocator(zoom = TRUE)
pumpLocator(14, vestry = TRUE, zoom = TRUE)
</code></pre>

<hr>
<h2 id='pumps'>Dodson and Tobler's pump data with street name.</h2><span id='topic+pumps'></span>

<h3>Description</h3>

<p>Adds and amends road locations for water pumps from John Snow's map to Dodson and Tobler's street data. The latter are available at Michael Friendly's HistData::Snow.streets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumps
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations and 4 variables that describe the pumps on Snow's map.
</p>

<dl>
<dt><code>id</code></dt><dd><p>pump number between 1 and 13</p>
</dd>
<dt><code>street</code></dt><dd><p>nearest street</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pumpLocator">pumpLocator</a></code>
</p>

<hr>
<h2 id='pumps.vestry'>Vestry report pump data.</h2><span id='topic+pumps.vestry'></span>

<h3>Description</h3>

<p>These data include the fourteenth pump, at Hanover Square, and the &quot;corrected&quot; location of the Broad Street pump that Snow includes in the second version of his map in the Vestry report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumps.vestry
</code></pre>


<h3>Format</h3>

<p>A data frame with 14 observations and 4 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>pump number between 1 and 14</p>
</dd>
<dt><code>street</code></dt><dd><p>nearest street</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pumpLocator">pumpLocator</a></code>
</p>

<hr>
<h2 id='rd.sample'>Sample of road intersections (segment endpoints).</h2><span id='topic+rd.sample'></span>

<h3>Description</h3>

<p>Sample of road intersections (segment endpoints).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rd.sample
</code></pre>


<h3>Format</h3>

<p>A list with 2 variables that list randomly re-arranges unique road intersections (segment endpoints).
</p>

<dl>
<dt><code>one</code></dt><dd><p>endpoints with 1 intersection</p>
</dd>
<dt><code>three</code></dt><dd><p>endpoints with 3 intersections</p>
</dd>
</dl>


<hr>
<h2 id='rectangle.filter'>Rectangular filter data.</h2><span id='topic+rectangle.filter'></span>

<h3>Description</h3>

<p>Coordinates to filter out frame shadow using sp::point.in.polygon().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectangle.filter
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 variables and 4 observations.
</p>

<dl>
<dt><code>x</code></dt><dd><p>longitude</p>
</dd>
<dt><code>y</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='regular.cases'>&quot;Expected&quot; cases.</h2><span id='topic+regular.cases'></span>

<h3>Description</h3>

<p>The result of using sp::spsample() and sp::Polygon() to generate 19,993 regularly spaced simulated cases within the map's borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regular.cases
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 variable that records the position of 19,993 &quot;expected&quot; cases fitted by sp::spsample().
</p>

<dl>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+simulateFatalities">simulateFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='road.segments'>Dodson and Tobler's street data transformed into road segments.</h2><span id='topic+road.segments'></span>

<h3>Description</h3>

<p>This data set transforms Dodson and Tobler's street data to give each straight line segment of a &quot;road&quot; a unique ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>road.segments
</code></pre>


<h3>Format</h3>

<p>A data frame with 657 observations and 7 variables. The data describe the straight line segments used to recreate the roads on Snow's map.
</p>

<dl>
<dt><code>street</code></dt><dd><p>numeric street ID, which range between 1 and 528</p>
</dd>
<dt><code>id</code></dt><dd><p>character segment ID</p>
</dd>
<dt><code>name</code></dt><dd><p>road name</p>
</dd>
<dt><code>x1</code></dt><dd><p>x-coordinate of first endpoint</p>
</dd>
<dt><code>y1</code></dt><dd><p>y-coordinate of first endpoint</p>
</dd>
<dt><code>x2</code></dt><dd><p>x-coordinate of second endpoint</p>
</dd>
<dt><code>y2</code></dt><dd><p>y-coordinate of second endpoint</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+roadSegments">roadSegments</a></code> documents the code for these data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roads">roads</a></code>
</p>
<p><code>vignette</code>(&quot;road.names&quot;)
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>
<p><code><a href="#topic+segmentLocator">segmentLocator</a></code>
</p>

<hr>
<h2 id='roads'>Dodson and Tobler's street data with appended road names.</h2><span id='topic+roads'></span>

<h3>Description</h3>

<p>This data set adds road names from John Snow's map to Dodson and Tobler's street data. The latter are also available from HistData::Snow.streets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roads
</code></pre>


<h3>Format</h3>

<p>A data frame with 206 observations and 5 variables. The data describe the roads on Snow's map.
</p>

<dl>
<dt><code>street</code></dt><dd><p>street segment number, which range between 1 and 528</p>
</dd>
<dt><code>n</code></dt><dd><p>number of points in this street line segment</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>id</code></dt><dd><p>unique numeric ID</p>
</dd>
<dt><code>name</code></dt><dd><p>road name</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+road.segments">road.segments</a></code>
</p>
<p><code>vignette</code>(&quot;road.names&quot;)
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>
<p><code><a href="#topic+segmentLocator">segmentLocator</a></code>
</p>

<hr>
<h2 id='roadSegmentFix'>Bar orientation classification errors.</h2><span id='topic+roadSegmentFix'></span>

<h3>Description</h3>

<p>Bar orientation classification errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roadSegmentFix()
</code></pre>


<h3>Note</h3>

<p>Bars lie parallel to the road where that fatality is observed. This can lead to (classification) errors when using orthogonal projection to assign a street address: the closest road is not always the right road. This R list manually assigns those problematic bars to their &quot;correct&quot; road segment.
</p>

<hr>
<h2 id='roadSegments'>Reshape 'roads' data frame into 'road.segments' data frame.</h2><span id='topic+roadSegments'></span>

<h3>Description</h3>

<p>Used to integrate pumps and cases into road network when computing walking neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roadSegments(latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roadSegments_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Note</h3>

<p>This function documents the code that generates <code><a href="#topic+road.segments">road.segments</a></code>.
</p>

<hr>
<h2 id='segmentHighlight'>Highlight segment by ID.</h2><span id='topic+segmentHighlight'></span>

<h3>Description</h3>

<p>Highlight segment by ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentHighlight(id, highlight = TRUE, col = "red", angled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentHighlight_+3A_id">id</code></td>
<td>
<p>Character. A concatenation of a street's numeric ID, a whole number between 1 and 528, and a second number to identify the segment.</p>
</td></tr>
<tr><td><code id="segmentHighlight_+3A_highlight">highlight</code></td>
<td>
<p>Logical. Color segment.</p>
</td></tr>
<tr><td><code id="segmentHighlight_+3A_col">col</code></td>
<td>
<p>Character. Highlight color.</p>
</td></tr>
<tr><td><code id="segmentHighlight_+3A_angled">angled</code></td>
<td>
<p>Logical. Rotate segment ID label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics segment(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streetNameLocator("Soho Square", zoom = TRUE, highlight = FALSE)
ids &lt;- road.segments[road.segments$name == "Soho Square", "id"]
invisible(lapply(ids, function(x) segmentHighlight(x, highlight = FALSE)))
</code></pre>

<hr>
<h2 id='segmentLength'>Compute length of road segment.</h2><span id='topic+segmentLength'></span>

<h3>Description</h3>

<p>Compute length of road segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentLength(id = "216-1", distance.unit = "meter")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentLength_+3A_id">id</code></td>
<td>
<p>Character. A concatenation of a street's numeric ID, a whole number between 1 and 528, and a second number used to identify the sub-segments.</p>
</td></tr>
<tr><td><code id="segmentLength_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R vector of length one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>segmentLength("242-1")
segmentLength("242-1", distance.unit = "yard")
</code></pre>

<hr>
<h2 id='segmentLocator'>Locate road segment by ID.</h2><span id='topic+segmentLocator'></span>

<h3>Description</h3>

<p>Highlights the selected road segment and its cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentLocator(id = "216-1", zoom = 0.5, cases = "address",
  distance.unit = "meter", time.unit = "second", walking.speed = 5,
  add.title = TRUE, add.subtitle = TRUE, highlight = TRUE,
  cex.text = 0.67)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segmentLocator_+3A_id">id</code></td>
<td>
<p>Character. A concatenation of a street's numeric ID, a whole number between 1 and 528, and a second number to identify the segment.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. A numeric value &gt;= 0 controls the degree of zoom. The default is 0.5.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_cases">cases</code></td>
<td>
<p>Character. Plot cases: <code>NULL</code>, &quot;address&quot; or &quot;fatality&quot;.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Print title.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_add.subtitle">add.subtitle</code></td>
<td>
<p>Logical. Print subtitle.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_highlight">highlight</code></td>
<td>
<p>Logical. Highlight selected road and its cases.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_cex.text">cex.text</code></td>
<td>
<p>Numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Note</h3>

<p>With Dodson and Tobler's data, a street (e.g., Broad Street) is often comprised of multiple straight line segments. To identify each segment individually, an additional number is appended to form a text string ID (e.g., &quot;116-2&quot;).  See <code>cholera::road.segments</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>segmentLocator("190-1")
segmentLocator("216-1")
segmentLocator("216-1", distance.unit = "yard")
</code></pre>

<hr>
<h2 id='sim.ortho.proj'>Road &quot;address&quot; of simulated (i.e., &quot;expected&quot;) cases.</h2><span id='topic+sim.ortho.proj'></span>

<h3>Description</h3>

<p>Road &quot;address&quot; of simulated (i.e., &quot;expected&quot;) cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.ortho.proj
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables that records the &quot;address&quot; of 19,993 simulate cases along the network of roads.
</p>

<dl>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>dist</code></dt><dd><p>Euclidean or orthogonal distance to home road segment</p>
</dd>
<dt><code>type</code></dt><dd><p>type of projection: Euclidean (&quot;eucl&quot;) or orthogonal (&quot;ortho&quot;)</p>
</dd>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+simulateFatalities">simulateFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='sim.pump.case'>List of &quot;simulated&quot; fatalities grouped by walking-distance pump neighborhood.</h2><span id='topic+sim.pump.case'></span>

<h3>Description</h3>

<p>List of &quot;simulated&quot; fatalities grouped by walking-distance pump neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.pump.case
</code></pre>


<h3>Format</h3>

<p>A list 4972 IDs spread over 13 vectors.
</p>

<dl>
<dt><code>sim.pump.case</code></dt><dd><p>numerical ID</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+neighborhoodWalking">neighborhoodWalking</a></code> documents the code for these data. For details, see <code>vignette</code>(&quot;pump.neighborhoods&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pumpCase(neighborhoodWalking(case.set = "expected"))

## End(Not run)
</code></pre>

<hr>
<h2 id='sim.walking.distance'>Walking distance to Broad Street Pump (#7).</h2><span id='topic+sim.walking.distance'></span>

<h3>Description</h3>

<p>Walking distance to Broad Street Pump (#7).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.walking.distance
</code></pre>


<h3>Format</h3>

<p>A data frames with 5 variables.
</p>

<dl>
<dt><code>case</code></dt><dd><p>case ID</p>
</dd>
<dt><code>pump</code></dt><dd><p>pump ID</p>
</dd>
<dt><code>pump.name</code></dt><dd><p>pump name</p>
</dd>
<dt><code>distance</code></dt><dd><p>walking distance in meters</p>
</dd>
<dt><code>time</code></dt><dd><p>walking time in seconds based on 5 km/hr walking speed</p>
</dd>
</dl>


<hr>
<h2 id='simulateFatalities'>Generate simulated fatalities.</h2><span id='topic+simulateFatalities'></span>

<h3>Description</h3>

<p>Places regularly spaced &quot;simulated&quot; or &quot;expected&quot; cases across the face of the map. The function finds the &quot;addresses&quot; of cases via orthogonal projection or simple proximity. These data are used to generate &quot;expected&quot; pump neighborhoods. The function relies on <code>sp::spsample()</code> and <code>sp::Polygon()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateFatalities(compute = FALSE, multi.core = TRUE,
  simulated.obs = 20000L, dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateFatalities_+3A_compute">compute</code></td>
<td>
<p>Logical. <code>TRUE</code> computes data. <code>FALSE</code> uses pre-computed data. For replication of data used in the package,</p>
</td></tr>
<tr><td><code id="simulateFatalities_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. With Numeric, you specify the number logical cores (rounds with <code>as.integer()</code>). See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="simulateFatalities_+3A_simulated.obs">simulated.obs</code></td>
<td>
<p>Numeric. Number of sample cases.</p>
</td></tr>
<tr><td><code id="simulateFatalities_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list with two elements: <code><a href="#topic+sim.ortho.proj">sim.ortho.proj</a></code> and <code><a href="#topic+regular.cases">regular.cases</a></code>
</p>


<h3>Note</h3>

<p>This function is computationally intensive. With &quot;simulated.obs&quot; set to 20,000 simulated cases (actually generating 19,993 cases). This function documents the code that generates <code><a href="#topic+sim.ortho.proj">sim.ortho.proj</a></code> and <code><a href="#topic+regular.cases">regular.cases</a></code>. In real world terms, the distance between of these simulated cases is approximately 6 meters.
</p>

<hr>
<h2 id='simulateWalkingDistance'>Compute walking distance for simulated cases.</h2><span id='topic+simulateWalkingDistance'></span>

<h3>Description</h3>

<p>Compute walking distance for simulated cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateWalkingDistance(pump.select = 7, multi.core = TRUE,
  dev.mode = FALSE, compute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateWalkingDistance_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="simulateWalkingDistance_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores.</p>
</td></tr>
<tr><td><code id="simulateWalkingDistance_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
<tr><td><code id="simulateWalkingDistance_+3A_compute">compute</code></td>
<td>
<p>Logical.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is computationally intensive. See <code>vignette("Parallelization")</code> for details. This functions document the code that generates <code><a href="#topic+sim.walking.distance">sim.walking.distance</a></code>.
</p>

<hr>
<h2 id='snow.neighborhood'>Snow neighborhood fatalities.</h2><span id='topic+snow.neighborhood'></span>

<h3>Description</h3>

<p>Numeric IDs of fatalities from Dodson and Tobler that fall within Snow's Broad Street pump neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snow.neighborhood
</code></pre>


<h3>Format</h3>

<p>A vector with 384 observations.
</p>

<dl>
<dt><code>snow.neighborhood</code></dt><dd><p>numeric case ID</p>
</dd>
</dl>


<hr>
<h2 id='snowColors'>Create a set of colors for pump neighborhoods.</h2><span id='topic+snowColors'></span>

<h3>Description</h3>

<p>Uses <code>RColorBrewer::brewer.pal()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowColors(vestry = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowColors_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps in the Vestry Report. <code>FALSE</code> uses the original 13.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of colors.
</p>


<h3>Note</h3>

<p>Built with 'RColorBrewer' package.
</p>

<hr>
<h2 id='snowMap'>Plot John Snow's cholera map.</h2><span id='topic+snowMap'></span>

<h3>Description</h3>

<p>Plot John Snow's cholera map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowMap(vestry = FALSE, stacked = TRUE, add.cases = TRUE,
  add.landmarks = FALSE, add.pumps = TRUE, add.roads = TRUE,
  add.frame = TRUE, main = NA, case.col = "gray", case.pch = 15,
  latlong = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowMap_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the map in the Vestry Report. <code>FALSE</code> uses the 13 pumps from the original map.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_stacked">stacked</code></td>
<td>
<p>Logical. Use stacked fatalities.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.cases">add.cases</code></td>
<td>
<p>Logical. Add observed cases.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.landmarks">add.landmarks</code></td>
<td>
<p>Logical. Add landmarks.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.pumps">add.pumps</code></td>
<td>
<p>Logical. Add pumps.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.roads">add.roads</code></td>
<td>
<p>Logical. Add roads.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.frame">add.frame</code></td>
<td>
<p>Logical. Add map frame.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_main">main</code></td>
<td>
<p>Character. Title of graph.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_case.col">case.col</code></td>
<td>
<p>Character. Color of fatalities.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_case.pch">case.pch</code></td>
<td>
<p>Character. Color of fatalities.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Note</h3>

<p>Uses amended version of Dodson and Tobler's data included in this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
snowMap(vestry = TRUE, stacked = FALSE)
</code></pre>

<hr>
<h2 id='snowNeighborhood'>Plotting data for Snow's graphical annotation of the Broad Street pump neighborhood.</h2><span id='topic+snowNeighborhood'></span>

<h3>Description</h3>

<p>Computes &quot;missing&quot; and split road segments data, and area plot data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowNeighborhood()
</code></pre>


<h3>Value</h3>

<p>An R list of edge IDs and simulated case IDs.
</p>

<hr>
<h2 id='streetHighlight'>Highlight road by name.</h2><span id='topic+streetHighlight'></span>

<h3>Description</h3>

<p>Highlight road by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetHighlight(road.name, col = "red", lwd = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streetHighlight_+3A_road.name">road.name</code></td>
<td>
<p>Character vector. The functions tries to correct for case and to remove extra spaces.</p>
</td></tr>
<tr><td><code id="streetHighlight_+3A_col">col</code></td>
<td>
<p>Character. Highlight color.</p>
</td></tr>
<tr><td><code id="streetHighlight_+3A_lwd">lwd</code></td>
<td>
<p>Numeric. Line width.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics segment(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
streetHighlight("Broad Street")
</code></pre>

<hr>
<h2 id='streetLength'>Compute length of selected street.</h2><span id='topic+streetLength'></span>

<h3>Description</h3>

<p>Compute length of selected street.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetLength(road = "Oxford Street", distance.unit = "meter")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streetLength_+3A_road">road</code></td>
<td>
<p>Character or Numeric. Road name or number. For names, the function tries to correct for case and to remove extra spaces.</p>
</td></tr>
<tr><td><code id="streetLength_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R vector of length one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streetLength("Oxford Street")
streetLength("oxford street")
streetLength("oxford street", distance.unit = "yard")
</code></pre>

<hr>
<h2 id='streetNameLocator'>Locate road by name.</h2><span id='topic+streetNameLocator'></span>

<h3>Description</h3>

<p>Highlight a road and its cases. See the list of road names in <code>vignette</code>(&quot;road.names&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetNameLocator(road.name = "Broad Street", zoom = FALSE,
  cases = "address", token = "id", add.title = TRUE,
  add.subtitle = TRUE, add.pump = TRUE, vestry = FALSE,
  highlight = TRUE, distance.unit = "meter", time.unit = "minute",
  walking.speed = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streetNameLocator_+3A_road.name">road.name</code></td>
<td>
<p>Character vector. Note that <code>streetNameLocator</code>() tries to correct for case and to remove extra spaces.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. A numeric value &gt;= 0 controls the degree of zoom. The default is FALSE, which is equivalent to zero.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_cases">cases</code></td>
<td>
<p>Character. Plot cases: <code>NULL</code>, &quot;address&quot; or &quot;fatality&quot;.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_token">token</code></td>
<td>
<p>Character. &quot;id&quot; or &quot;point&quot;.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Include title.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_add.subtitle">add.subtitle</code></td>
<td>
<p>Logical. Include subtitle with road information.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_add.pump">add.pump</code></td>
<td>
<p>Logical. Include nearby pumps.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_highlight">highlight</code></td>
<td>
<p>Logical. Highlight selected road and its cases.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streetNameLocator("Oxford Street")
streetNameLocator("oxford street")
streetNameLocator("Cambridge Street", zoom = TRUE)
streetNameLocator("Cambridge Street", zoom = 0.5)
</code></pre>

<hr>
<h2 id='streetNames'>Street names (alphabetized).</h2><span id='topic+streetNames'></span>

<h3>Description</h3>

<p>Unique road names from Snow's cholera map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetNames()
</code></pre>


<h3>Value</h3>

<p>An R character vector.
</p>


<h3>Note</h3>

<p>See vignette(&quot;roads&quot;), and roads and road.segment data frames.
</p>

<hr>
<h2 id='streetNumberLocator'>Locate road by numerical ID.</h2><span id='topic+streetNumberLocator'></span>

<h3>Description</h3>

<p>Highlight a road and its cases. See <code>cholera::roads</code> for numerical IDs and <code>vignette</code>(&quot;road.names&quot;) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetNumberLocator(road.number = 216, zoom = FALSE, cases = "address",
  token = "id", add.title = TRUE, add.subtitle = TRUE, add.pump = TRUE,
  vestry = FALSE, highlight = TRUE, distance.unit = "meter",
  time.unit = "second", walking.speed = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streetNumberLocator_+3A_road.number">road.number</code></td>
<td>
<p>Numeric or integer. A whole number between 1 and 528.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. A numeric value &gt;= 0 controls the degree of zoom. The default is FALSE, which is equivalent to zero.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_cases">cases</code></td>
<td>
<p>Character. Plot cases: <code>NULL</code>, &quot;address&quot; or &quot;fatality&quot;.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_token">token</code></td>
<td>
<p>Character. &quot;id&quot; or &quot;point&quot;.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Include title.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_add.subtitle">add.subtitle</code></td>
<td>
<p>Logical. Include subtitle with road information.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_add.pump">add.pump</code></td>
<td>
<p>Logical. Include nearby pumps.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_highlight">highlight</code></td>
<td>
<p>Logical. Highlight selected road and its cases.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of measurement: &quot;meter&quot; or &quot;yard&quot;. Default is <code>NULL</code>, which returns the map's native scale.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streetNumberLocator(243)
streetNumberLocator(243, zoom = TRUE)
streetNumberLocator(243, zoom = 0.5)
</code></pre>

<hr>
<h2 id='subsetRoadsSamples'>Sample for road segment endpoints.</h2><span id='topic+subsetRoadsSamples'></span>

<h3>Description</h3>

<p>For endpoints with 1 or 3 intersections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetRoadsSamples()
</code></pre>

<hr>
<h2 id='summary.euclidean'>Summary method for neighborhoodEuclidean().</h2><span id='topic+summary.euclidean'></span>

<h3>Description</h3>

<p>Return computed counts for Euclidean neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.euclidean_+3A_object">object</code></td>
<td>
<p>Object. An object of class &quot;euclidean&quot; created by <code>neighborhoodEuclidean()</code>.</p>
</td></tr>
<tr><td><code id="summary.euclidean_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of counts by neighborhood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary(neighborhoodEuclidean())

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.voronoi'>Summary method for neighborhoodVoronoi().</h2><span id='topic+summary.voronoi'></span>

<h3>Description</h3>

<p>Return computed counts for Voronoi neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.voronoi_+3A_object">object</code></td>
<td>
<p>Object. An object of class &quot;voronoi&quot; created by <code>neighborhoodVoronoi()</code>.</p>
</td></tr>
<tr><td><code id="summary.voronoi_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of counts by neighborhood.
</p>


<h3>See Also</h3>

<p><code>addVoronoi()</code>
<code>plot.voronoi()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(neighborhoodVoronoi())
</code></pre>

<hr>
<h2 id='summary.walking'>Summary method for neighborhoodWalking().</h2><span id='topic+summary.walking'></span>

<h3>Description</h3>

<p>Return computed counts for walking neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walking'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.walking_+3A_object">object</code></td>
<td>
<p>Object. An object of class &quot;walking&quot; created by <code>neighborhoodWalking()</code>.</p>
</td></tr>
<tr><td><code id="summary.walking_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary(neighborhoodWalking())

## End(Not run)
</code></pre>

<hr>
<h2 id='timeSeries'>Aggregate time series fatality data from the Vestry report.</h2><span id='topic+timeSeries'></span>

<h3>Description</h3>

<p>Aggregate time series fatality data from the Vestry report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeSeries(vestry = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeSeries_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> returns the data from the Vestry committee (Appendix B, p. 175). <code>FALSE</code> returns John Snow's contribution to the report (p.117).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A R list with two objects: &quot;data&quot; and &quot;source&quot; (&quot;snow&quot; or &quot;vestry&quot;).
</p>

<ul>
<li><p><code>date</code>: Calendar date.
</p>
</li>
<li><p><code>day</code>: Day of the week.
</p>
</li>
<li><p><code>deaths</code>: Measure of fatality.
</p>
</li>
<li><p><code>fatal.attacks</code>: Measure of fatality.
</p>
</li></ul>



<h3>Note</h3>

<p>The &quot;snow&quot; data appears on p. 117 of the report; the &quot;vestry&quot; data appear in Appendix B on p.175.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.time_series">plot.time_series</a></code>, <code><a href="#topic+print.time_series">print.time_series</a></code>, <code>vignette("time.series")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeSeries(vestry = TRUE)
plot(timeSeries())
</code></pre>

<hr>
<h2 id='unitMeter'>Convert nominal map distance to meters or yards.</h2><span id='topic+unitMeter'></span>

<h3>Description</h3>

<p>A best guess estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitMeter(x, distance.unit = "meter")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitMeter_+3A_x">x</code></td>
<td>
<p>Numeric. Nominal map distance.</p>
</td></tr>
<tr><td><code id="unitMeter_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; uses the map's nominal scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
</table>

<hr>
<h2 id='unstackFatalities'>Unstack &quot;stacks&quot; in Snow's cholera map.</h2><span id='topic+unstackFatalities'></span>

<h3>Description</h3>

<p>Unstacks fatalities data by 1) assigning the coordinates of the base case to all cases in a stack and 2) setting the base case as an &quot;address&quot; and making the number of fatalities an attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unstackFatalities(multi.core = TRUE, compute = FALSE, dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstackFatalities_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. With Numeric, you specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="unstackFatalities_+3A_compute">compute</code></td>
<td>
<p>Logical. <code>TRUE</code> computes data. <code>FALSE</code> uses pre-computed data.</p>
</td></tr>
<tr><td><code id="unstackFatalities_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list that includes <code>anchor.case</code>, <code>fatalities.address</code>, <code>fatalities.unstacked</code> and <code>ortho.proj</code>.
</p>


<h3>Note</h3>

<p>This function is computationally intensive. This function documents the code that generates <code><a href="#topic+anchor.case">anchor.case</a></code>,  <code><a href="#topic+fatalities.address">fatalities.address</a></code>, <code><a href="#topic+fatalities.unstacked">fatalities.unstacked</a></code> and <code><a href="#topic+ortho.proj">ortho.proj</a></code>.
</p>


<h3>See Also</h3>

<p><code>vignette("unstacking.fatalities")</code>
</p>

<hr>
<h2 id='voronoi.polygons'>Coordinates of Voronoi polygon vertices for original map.</h2><span id='topic+voronoi.polygons'></span>

<h3>Description</h3>

<p>Coordinates of Voronoi polygon vertices for original map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.polygons
</code></pre>


<h3>Format</h3>

<p>A list of 13 data frames frames with 5 variables.
</p>

<dl>
<dt><code>vertex</code></dt><dd><p>vertex ID</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='voronoi.polygons.vestry'>Coordinates of Voronoi polygon vertices for Vestry Report map.</h2><span id='topic+voronoi.polygons.vestry'></span>

<h3>Description</h3>

<p>Coordinates of Voronoi polygon vertices for Vestry Report map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.polygons.vestry
</code></pre>


<h3>Format</h3>

<p>A list of 14 data frames frames with 5 variables.
</p>

<dl>
<dt><code>vertex</code></dt><dd><p>vertex ID</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='voronoiPolygons'>Extract vertices of Delaunay triangles and Dirichelet (Voronoi) tiles.</h2><span id='topic+voronoiPolygons'></span>

<h3>Description</h3>

<p>For construction and plotting of Delaunay and Voronoi polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoiPolygons(sites, rw.data = NULL, rw = NULL, type = "tiles",
  output = "vertices", latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoiPolygons_+3A_sites">sites</code></td>
<td>
<p>Object. Data frame of sites to compute Delaunay triangulation and Dirichelet (Voronoi) tessellation with variables &quot;x&quot; and &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_rw.data">rw.data</code></td>
<td>
<p>Object. Data frame of secondary source of data to set the rectangular window or bounding box: observations, cases, etc. with variables &quot;x&quot; and &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_rw">rw</code></td>
<td>
<p>Numeric. Alternative to rw.data: vector of corners to define the rectangular window or bounding box: xmin, xmax, ymin, ymax.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_type">type</code></td>
<td>
<p>Character. &quot;tiles&quot; (tessellation) or &quot;triangles&quot; (triangulation) vertices.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_output">output</code></td>
<td>
<p>Character. &quot;vertices&quot; or &quot;polygons&quot;. &quot;vertices&quot; re &quot;polygons&quot; will draw base R polygons() to an existing plot.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list of data frames or base R graphics polygon()'s'.
</p>


<h3>Note</h3>

<p>This function relies on the 'deldir' package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
voronoiPolygons(pumps, output = "polygons")

snowMap()
voronoiPolygons(pumps, roads, output = "polygons")

snowMap()
voronoiPolygons(pumps, roads, type = "triangles", output = "polygons")

vertices &lt;- voronoiPolygons(pumps, roads)
snow.colors &lt;- grDevices::adjustcolor(snowColors(), alpha.f = 1/3)
snowMap(add.cases = FALSE)
invisible(lapply(seq_along(vertices), function(i) {
  polygon(vertices[[i]], col = snow.colors[[i]])
}))
</code></pre>

<hr>
<h2 id='walkingPath'>Compute the shortest walking path between cases and/or pumps.</h2><span id='topic+walkingPath'></span>

<h3>Description</h3>

<p>Compute the shortest walking path between cases and/or pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walkingPath(origin = 1, destination = NULL, type = "case-pump",
  observed = TRUE, weighted = TRUE, vestry = FALSE,
  distance.unit = "meter", time.unit = "second", walking.speed = 5,
  null.origin.landmark = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walkingPath_+3A_origin">origin</code></td>
<td>
<p>Numeric or Character. Numeric ID of case or pump. Character landmark name.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_destination">destination</code></td>
<td>
<p>Numeric or Character. Numeric ID(s) of case(s) or pump(s). Exclusion is possible via negative selection (e.g., -7). Default is <code>NULL</code>: this returns closest pump or &quot;anchor&quot; case. Character landmark name (case insensitive).</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_type">type</code></td>
<td>
<p>Character &quot;case-pump&quot;, &quot;cases&quot; or &quot;pumps&quot;.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_observed">observed</code></td>
<td>
<p>Logical. Use observed or &quot;simulated&quot; expected data.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path in terms of road length. <code>FALSE</code> computes shortest path in terms of nodes.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. &quot;unit&quot; is meaningful only when &quot;weighted&quot; is TRUE. See <code>vignette("roads")</code> for information on unit distances.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_null.origin.landmark">null.origin.landmark</code></td>
<td>
<p>Logical. Consider landmarks when origin = NULL and type = &quot;case-pump&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list with two elements: a character vector of path nodes and a data frame summary.
</p>


<h3>Note</h3>

<p>The function uses a case's &quot;address&quot; (i.e., a stack's &quot;anchor&quot; case) to compute distance. Time is computed using <code>distanceTime()</code>. Adam and Eve Court, and Falconberg Court and Falconberg Mews, are disconnected from the larger road network; they form two isolated subgraphs. This has two consequences: first, only cases on Adam and Eve Court can reach pump 2 and those cases cannot reach any other pump; second, cases on Falconberg Court and Mews cannot reach any pump. Unreachable pumps will return distances of &quot;Inf&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# path from case 1 to nearest pump.
walkingPath(1)

# path from pump 1 to nearest case.
walkingPath(NULL, 1)

# path from case 1 to pump 6.
walkingPath(1, 6)

# exclude pump 7 from consideration.
walkingPath(1, -7)

# path from case 1 to case 6.
walkingPath(1, 6, type = "cases")

# path from pump 1 to pump 6.
walkingPath(1, 6, type = "pumps")

# for multiple cases.
lapply(1:3, walkingPath)

# path from case 1 to nearest pump.
plot(walkingPath(1))

# path from John Snow's residence to Broad Street pump.
plot(walkingPath("John Snow", 7))

## End(Not run)
</code></pre>

<hr>
<h2 id='winterTemperatures'>Average Winter Temperatures.</h2><span id='topic+winterTemperatures'></span>

<h3>Description</h3>

<p>Gareth Stedman Jones Appendix 2, Table 12, p.384.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winterTemperatures()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>plot(winterTemperatures(), "1859-6-1")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
