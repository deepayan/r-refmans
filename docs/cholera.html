<!DOCTYPE html><html lang="en-US"><head><title>Help for package cholera</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cholera}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cholera-package'><p>cholera</p></a></li>
<li><a href='#addCase'><p>Add observed case(s) to plot.</p></a></li>
<li><a href='#addDelaunay'><p>Add Delaunay triangles.</p></a></li>
<li><a href='#addEuclideanPath'><p>Add Euclidean path from case/landmark to nearest or selected pump. (prototype)</p></a></li>
<li><a href='#addIndexCase'><p>Highlight index case at 40 Broad Street.</p></a></li>
<li><a href='#addKernelDensity'><p>Add 2D kernel density contours.</p></a></li>
<li><a href='#addLandmarks'><p>Add landmarks to plot.</p></a></li>
<li><a href='#addLandmarkSquares'><p>Add Golden and Soho Squares to plot.</p></a></li>
<li><a href='#addNeighborhoodCases'><p>Add observed neighborhood cases.</p></a></li>
<li><a href='#addNeighborhoodEuclidean'><p>Add expected Euclidean pump neighborhoods.</p></a></li>
<li><a href='#addNeighborhoodSnow'><p>Adds Snow's graphical annotation of the Broad Street pump walking neighborhood.</p></a></li>
<li><a href='#addNeighborhoodWalking'><p>Add walking neighborhoods.</p></a></li>
<li><a href='#addPlaguePit'><p>Add plague pit (Marshall Street).</p></a></li>
<li><a href='#addPump'><p>Add selected pump(s) to plot.</p></a></li>
<li><a href='#addRoads'><p>Add all streets and roads to plot.</p></a></li>
<li><a href='#addVoronoi'><p>Add Voronoi cells.</p></a></li>
<li><a href='#addWalkingPath'><p>Add walking path from case/landmark to nearest or selected pump. (prototype)</p></a></li>
<li><a href='#addWhitehead'><p>Add Rev. Henry Whitehead's Broad Street pump neighborhood.</p></a></li>
<li><a href='#anchor.case'><p>Anchor or base case of each stack of fatalities.</p></a></li>
<li><a href='#border'><p>Numeric IDs of line segments that create the map's border frame.</p></a></li>
<li><a href='#caseLocator'><p>Locate case by numerical ID.</p></a></li>
<li><a href='#euclideanPath'><p>Compute Euclidean path coordinates from observed case/landmark to nearest/selected pump.</p></a></li>
<li><a href='#fatalities'><p>Amended Dodson and Tobler's cholera data.</p></a></li>
<li><a href='#fatalities.address'><p>&quot;Unstacked&quot; amended cholera data with address as unit of observation.</p></a></li>
<li><a href='#fatalities.unstacked'><p>&quot;Unstacked&quot; amended cholera fatalities data with fatality as unit of observation.</p></a></li>
<li><a href='#frame.data'><p>Map frame data c(&quot;x&quot;, &quot;y&quot;) and c(&quot;lon&quot;, &quot;lat&quot;).</p></a></li>
<li><a href='#frame.sample'><p>Partitioned map frame points (segment endpoints).</p></a></li>
<li><a href='#landmark.squares'><p>Centers of city squares.</p></a></li>
<li><a href='#landmarks'><p>Landmark coordinates.</p></a></li>
<li><a href='#latlong.ortho.addr'><p>Orthogonal projection of observed address (latlong) cases onto road network.</p></a></li>
<li><a href='#latlong.ortho.pump'><p>Orthogonal projection of 13 original pumps (latlong).</p></a></li>
<li><a href='#latlong.ortho.pump.vestry'><p>Orthogonal projection of the 14 pumps from the Vestry Report (latlong).</p></a></li>
<li><a href='#latlong.regular.cases'><p>&quot;Expected&quot; cases (latlong).</p></a></li>
<li><a href='#latlong.sim.ortho.proj'><p>Road &quot;address&quot; of simulated (i.e., &quot;expected&quot;) cases (latlong).</p></a></li>
<li><a href='#mapRange'><p>Compute xlim and ylim of Snow's map.</p></a></li>
<li><a href='#meter.to.yard'><p>Meter to yard conversion factor.</p></a></li>
<li><a href='#neighborhoodData'><p>Compute network graph of roads, cases and pumps (prototype).</p></a></li>
<li><a href='#neighborhoodEuclidean'><p>Compute Euclidean path pump neighborhoods.</p></a></li>
<li><a href='#neighborhoodSnow'><p>Compute Snow's graphical annotation of Broad Street pump neighborhood.</p></a></li>
<li><a href='#neighborhoodVoronoi'><p>Compute Voronoi pump neighborhoods.</p></a></li>
<li><a href='#neighborhoodWalking'><p>Compute walking path pump neighborhoods.</p></a></li>
<li><a href='#ortho.proj'><p>Orthogonal projection of observed cases onto road network.</p></a></li>
<li><a href='#ortho.proj.pump'><p>Orthogonal projection of 13 original pumps.</p></a></li>
<li><a href='#ortho.proj.pump.vestry'><p>Orthogonal projection of the 14 pumps from the Vestry Report.</p></a></li>
<li><a href='#pearsonResiduals'><p>Compute Pearson Residuals (prototype)</p></a></li>
<li><a href='#plague.pit'><p>Plague pit coordinates.</p></a></li>
<li><a href='#plot.euclidean'><p>Plot method for neighborhoodEuclidean().</p></a></li>
<li><a href='#plot.euclidean_path'><p>Plot the path of the Euclidean distance between cases and/or pumps.</p></a></li>
<li><a href='#plot.euclideanLatlong'><p>Plot method for euclideanLatlong()</p></a></li>
<li><a href='#plot.neighborhood_data'><p>Plot method for neighborhoodData().</p></a></li>
<li><a href='#plot.profile_perspective'><p>Plot method for profilePerspective().</p></a></li>
<li><a href='#plot.snow'><p>Plot method for neighborhoodSnow().</p></a></li>
<li><a href='#plot.time_series'><p>Plot aggregate time series data from Vestry report.</p></a></li>
<li><a href='#plot.voronoi_latlong'><p>Plot method for voronoiLatlong()</p></a></li>
<li><a href='#plot.voronoi_nominal'><p>Plot Voronoi neighborhoods.</p></a></li>
<li><a href='#plot.walking'><p>Plot method for neighborhoodWalking().</p></a></li>
<li><a href='#plot.walking_path'><p>Plot the walking path between selected cases and/or pumps.</p></a></li>
<li><a href='#print.euclidean'><p>Print method for neighborhoodEuclidean().</p></a></li>
<li><a href='#print.euclidean_path'><p>Print method for euclideanPath().</p></a></li>
<li><a href='#print.euclideanLatlong'><p>Print method for neighborhoodEuclidean(latlong = TRUE).</p></a></li>
<li><a href='#print.time_series'><p>Print summary data for timeSeries().</p></a></li>
<li><a href='#print.voronoi_latlong'><p>Print method for voronoiLatlong().</p></a></li>
<li><a href='#print.voronoi_nominal'><p>Print method for voronoiNominal().</p></a></li>
<li><a href='#print.walking'><p>Print method for neighborhoodWalking().</p></a></li>
<li><a href='#print.walking_path'><p>Print method for walkingPath().</p></a></li>
<li><a href='#profile2D'><p>2D Profile .</p></a></li>
<li><a href='#profile3D'><p>3D Profile.</p></a></li>
<li><a href='#pumpCase'><p>Extract numeric case IDs by pump neighborhood.</p></a></li>
<li><a href='#pumpData'><p>Compute pump coordinates.</p></a></li>
<li><a href='#pumpFatalities'><p>Compute fatalities by pump.</p></a></li>
<li><a href='#pumpLocator'><p>Locate water pump by numerical ID.</p></a></li>
<li><a href='#pumps'><p>Dodson and Tobler's pump data with street name.</p></a></li>
<li><a href='#pumps.vestry'><p>Vestry report pump data.</p></a></li>
<li><a href='#rd.sample'><p>Sample of road intersections (segment endpoints).</p></a></li>
<li><a href='#rectangle.filter'><p>Rectangular filter data.</p></a></li>
<li><a href='#regular.cases'><p>&quot;Expected&quot; cases.</p></a></li>
<li><a href='#road.segments'><p>Dodson and Tobler's street data transformed into road segments.</p></a></li>
<li><a href='#roads'><p>Dodson and Tobler's street data with appended road names.</p></a></li>
<li><a href='#roadSegments'><p>Reshape 'roads' data frame into 'road.segments' data frame.</p></a></li>
<li><a href='#segmentHighlight'><p>Highlight segment by ID.</p></a></li>
<li><a href='#segmentLocator'><p>Plot/Locate road segment by ID.</p></a></li>
<li><a href='#sim.ortho.proj'><p>Road &quot;address&quot; of simulated (i.e., &quot;expected&quot;) cases.</p></a></li>
<li><a href='#sim.pump.case'><p>List of &quot;simulated&quot; fatalities grouped by walking-distance pump neighborhood.</p></a></li>
<li><a href='#sim.walking.distance'><p>Walking distance to Broad Street Pump (#7).</p></a></li>
<li><a href='#simulateFatalities'><p>Project simulated fatalities onto road network</p></a></li>
<li><a href='#snow.neighborhood'><p>Snow neighborhood fatalities.</p></a></li>
<li><a href='#snowColors'><p>Create a set of colors for pump neighborhoods.</p></a></li>
<li><a href='#snowMap'><p>Plot John Snow's cholera map.</p></a></li>
<li><a href='#streetHighlight'><p>Highlight road by name.</p></a></li>
<li><a href='#streetLength'><p>Compute length of selected street.</p></a></li>
<li><a href='#streetNameLocator'><p>Locate street(s) by name(s).</p></a></li>
<li><a href='#streetNames'><p>Street names (alphabetized).</p></a></li>
<li><a href='#streetNumberLocator'><p>Locate street by its numerical ID.</p></a></li>
<li><a href='#summary.euclidean'><p>Summary method for neighborhoodEuclidean().</p></a></li>
<li><a href='#summary.voronoi_nominal'><p>Summary method for voronoiNominal().</p></a></li>
<li><a href='#tanakaContourPlot'><p>Tanaka contour plot.</p></a></li>
<li><a href='#timeSeries'><p>Aggregate time series fatality data from the Vestry report.</p></a></li>
<li><a href='#unstackFatalities'><p>Unstack &quot;stacks&quot; in Snow's cholera map.</p></a></li>
<li><a href='#voronoi.polygons'><p>Coordinates of Voronoi polygon vertices for original map.</p></a></li>
<li><a href='#voronoi.polygons.vestry'><p>Coordinates of Voronoi polygon vertices for Vestry Report map.</p></a></li>
<li><a href='#voronoiPolygons'><p>Extract vertices of Delaunay triangles and Dirichelet (Voronoi) tiles.</p></a></li>
<li><a href='#walkingPath'><p>Compute walking path from case/landmark to nearest or selected pump.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Amend, Augment and Aid Analysis of John Snow's Cholera Map</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Amends errors, augments data and aids analysis of John Snow's map
  of the 1854 London cholera outbreak.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lindbrook/cholera">https://github.com/lindbrook/cholera</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lindbrook/cholera/issues">https://github.com/lindbrook/cholera/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl, deldir (&ge; 1.0-2), elevatr, geosphere, HistData (&ge;
0.7-8), igraph, KernSmooth, pracma, RColorBrewer, rlang, sp,
tanaka, terra, threejs, TSP, viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-14 00:24:39 UTC; peter</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Li [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Li &lt;lindbrook@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 00:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cholera-package'>cholera</h2><span id='topic+cholera'></span><span id='topic+cholera-package'></span>

<h3>Description</h3>

<p>Amend errors, augment data and aid analysis of John Snow's map of the 1854 London cholera outbreak.
</p>


<h3>Details</h3>


<ul>
<li><p> Fixes two sets of errors in Dodson and Tobler's 1992 digitization of Snow's map: 1) three misplaced cases/fatalities and 2) one missing road segment (part of Clifford Street).
</p>
</li>
<li><p> &quot;Unstacks&quot; the data in two ways to make analysis and visualization easier and more meaningful.
</p>
</li>
<li><p> Computes and visualizes &quot;pump neighborhoods&quot; based on Voronoi tessellation, Euclidean distance, and walking distance.
</p>
</li>
<li><p> Overlay graphical elements and features like kernel density estimates, Voronoi diagrams, Snow's Broad Street neighborhood, and notable landmarks (John Snow's residence, the Lion Brewery, etc.) via 'add*()' functions.
</p>
</li>
<li><p> Includes a variety of functions to highlight specific cases, roads, pumps and paths.
</p>
</li>
<li><p> Appends actual street names to roads data.
</p>
</li>
<li><p> Includes the revised pump data used in the second version of Snow's map from the Vestry report, which includes the &quot;correct&quot; location of the Broad Street pump.
</p>
</li>
<li><p> Adds two different aggregate time series fatalities data sets, taken from the Vestry report.
</p>
</li>
<li><p> Support for parallel computation on Linux and macOS; limited support for Windows.
</p>
</li>
<li><p> Version &gt;= 0.9.0, offers provisional support for (georeferenced) longitude and latitude for practically all data and functions.
</p>
</li></ul>

<p>To learn more, see the vignettes:
</p>
<p><code>vignette("duplicate.missing.cases")</code>
</p>
<p><code>vignette("kernel.density")</code>
</p>
<p><code>vignette("parallelization")</code>
</p>
<p><code>vignette("pump.neighborhoods")</code>
</p>
<p><code>vignette("roads")</code>
</p>
<p><code>vignette("tiles.polygons")</code>
</p>
<p><code>vignette("time.series")</code>
</p>
<p><code>vignette("unstacking.bars")</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Peter Li <a href="mailto:lindbrook@gmail.com">lindbrook@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/lindbrook/cholera">https://github.com/lindbrook/cholera</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/lindbrook/cholera/issues">https://github.com/lindbrook/cholera/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addCase'>Add observed case(s) to plot.</h2><span id='topic+addCase'></span>

<h3>Description</h3>

<p>Add case(s), as &quot;anchor&quot;, &quot;fatality&quot; or &quot;orthogonal&quot; as points or IDs, to a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCase(case = 1, latlong = FALSE, type = "observed", token = "both",
  text.size = 0.5, pch = 1, cex = 1, point.lwd = 2, col = "black",
  pos = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addCase_+3A_case">case</code></td>
<td>
<p>Numeric or Character. Vector of case ID(s). &quot;anchor&quot; plots anchor cases; &quot;fatality&quot; plots all cases; &quot;orthogonal&quot; plot projected addresses.</p>
</td></tr>
<tr><td><code id="addCase_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="addCase_+3A_type">type</code></td>
<td>
<p>Character. Type of case: &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="addCase_+3A_token">token</code></td>
<td>
<p>Character. Type of token to plot: &quot;point&quot;, &quot;id&quot; or &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="addCase_+3A_text.size">text.size</code></td>
<td>
<p>Numeric. Size of case ID text.</p>
</td></tr>
<tr><td><code id="addCase_+3A_pch">pch</code></td>
<td>
<p>Numeric. pch.</p>
</td></tr>
<tr><td><code id="addCase_+3A_cex">cex</code></td>
<td>
<p>Numeric. cex.</p>
</td></tr>
<tr><td><code id="addCase_+3A_point.lwd">point.lwd</code></td>
<td>
<p>Numeric. Point lwd.</p>
</td></tr>
<tr><td><code id="addCase_+3A_col">col</code></td>
<td>
<p>Character. Color.</p>
</td></tr>
<tr><td><code id="addCase_+3A_pos">pos</code></td>
<td>
<p>Numeric. Text position.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>type, token, text.size, pch, cex, point.lwd and pos relevant only when case is numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap(add.cases = FALSE)
addCase(1)

snowMap(add.cases = FALSE)
addCase(100)
</code></pre>

<hr>
<h2 id='addDelaunay'>Add Delaunay triangles.</h2><span id='topic+addDelaunay'></span>

<h3>Description</h3>

<p>Add Delaunay triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addDelaunay(pump.select = NULL, vestry = FALSE, color = "black",
  line.type = "solid", line.width = 1, latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addDelaunay_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Default is NULL; all pumps are used. Otherwise, selection by a vector of numeric IDs: 1 to 13 for <code>pumps</code>; 1 to 14 for <code>pumps.vestry</code>. Exclusion (negative selection) is possible (e.g., -6).</p>
</td></tr>
<tr><td><code id="addDelaunay_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>FALSE</code> for original 13 pumps. TRUE for 14 pumps in Vestry Report.</p>
</td></tr>
<tr><td><code id="addDelaunay_+3A_color">color</code></td>
<td>
<p>Character. Color of triangle edges.</p>
</td></tr>
<tr><td><code id="addDelaunay_+3A_line.type">line.type</code></td>
<td>
<p>Character. Type of line for triangle edges.</p>
</td></tr>
<tr><td><code id="addDelaunay_+3A_line.width">line.width</code></td>
<td>
<p>Numeric. Width of cell edges: lwd.</p>
</td></tr>
<tr><td><code id="addDelaunay_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function uses <code>deldir::deldir()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
addDelaunay()
</code></pre>

<hr>
<h2 id='addEuclideanPath'>Add Euclidean path from case/landmark to nearest or selected pump. (prototype)</h2><span id='topic+addEuclideanPath'></span>

<h3>Description</h3>

<p>Add Euclidean path from case/landmark to nearest or selected pump. (prototype)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addEuclideanPath(origin = 1, destination = NULL, type = "case-pump",
  vestry = FALSE, latlong = FALSE, case.set = "observed",
  location = "nominal", weighted = TRUE, distance.unit = "meter",
  time.unit = "second", walking.speed = 5, include.landmarks = TRUE,
  long.title = FALSE, mileposts = TRUE, milepost.unit = "distance",
  milepost.interval = NULL, alpha.level = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addEuclideanPath_+3A_origin">origin</code></td>
<td>
<p>Numeric. Vector of origin(s) (numeric ID or character name landmark/pump ).</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_destination">destination</code></td>
<td>
<p>Numeric. Vector of destination(s) (numeric or landmark/pump name).</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_type">type</code></td>
<td>
<p>Character. Path case to pump. FALSE is all other combinations of cases, landmarks and pumps.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the map in the Vestry Report. <code>FALSE</code> uses the 13 pumps from the original map.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_location">location</code></td>
<td>
<p>Character. For cases and pumps. &quot;nominal&quot;, &quot;anchor&quot; or &quot;orthogonal&quot;.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path in terms of road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot; or &quot;yard&quot;.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_include.landmarks">include.landmarks</code></td>
<td>
<p>Logical. Include landmarks as cases.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_long.title">long.title</code></td>
<td>
<p>Logical. Tile with names.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_mileposts">mileposts</code></td>
<td>
<p>Logical. Plot mile/time posts.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_milepost.unit">milepost.unit</code></td>
<td>
<p>Character. &quot;distance&quot; or &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_milepost.interval">milepost.interval</code></td>
<td>
<p>Numeric. Mile post interval unit of distance (yard or meter) or unit of time (seconds).</p>
</td></tr>
<tr><td><code id="addEuclideanPath_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for path: a value in [0, 1].</p>
</td></tr>
</table>

<hr>
<h2 id='addIndexCase'>Highlight index case at 40 Broad Street.</h2><span id='topic+addIndexCase'></span>

<h3>Description</h3>

<p>Highlight index case at 40 Broad Street.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addIndexCase(latlong = FALSE, cex = 2, col = "red", pch = 1,
  add.label = FALSE, text.size = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addIndexCase_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="addIndexCase_+3A_cex">cex</code></td>
<td>
<p>Numeric. Size of point.</p>
</td></tr>
<tr><td><code id="addIndexCase_+3A_col">col</code></td>
<td>
<p>Character. Color of point.</p>
</td></tr>
<tr><td><code id="addIndexCase_+3A_pch">pch</code></td>
<td>
<p>Numeric. Type of of point.</p>
</td></tr>
<tr><td><code id="addIndexCase_+3A_add.label">add.label</code></td>
<td>
<p>Logical. Add text annotation: &quot;40 Broad Street&quot;</p>
</td></tr>
<tr><td><code id="addIndexCase_+3A_text.size">text.size</code></td>
<td>
<p>Numeric. Size of text label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Add base R point and (optionally) text to a graphics plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>segmentLocator("216-1")
addIndexCase()
</code></pre>

<hr>
<h2 id='addKernelDensity'>Add 2D kernel density contours.</h2><span id='topic+addKernelDensity'></span>

<h3>Description</h3>

<p>Add 2D kernel density contours based on selected sets of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addKernelDensity(pump.subset = "pooled", pump.select = NULL,
  neighborhood.type = "walking", data = "unstacked", bandwidth = 0.5,
  color = "black", line.type = "solid", multi.core = FALSE,
  latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addKernelDensity_+3A_pump.subset">pump.subset</code></td>
<td>
<p>Character or Numeric: &quot;pooled&quot;, &quot;individual&quot;, or numeric vector. &quot;pooled&quot; treats all observations as a single set. &quot;individual&quot; is a shortcut for all individual pump neighborhoods. Use of vector of numeric pump IDs to subset from the neighborhoods defined by <code>pump.select</code>. Negative selection possible. <code>NULL</code> selects all pumps in <code>pump.select</code>.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_neighborhood.type">neighborhood.type</code></td>
<td>
<p>Character. &quot;voronoi&quot; or &quot;walking&quot;</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_data">data</code></td>
<td>
<p>Character. Unit of observation: &quot;unstacked&quot; uses <code>fatalities.unstacked</code>; &quot;address&quot; uses <code>fatalities.address</code>; &quot;fatality&quot; uses <code>fatalities</code>.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Numeric. Bandwidth for kernel density estimation.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_color">color</code></td>
<td>
<p>Character. Color of contour lines.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_line.type">line.type</code></td>
<td>
<p>Character. Line type for contour lines.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="addKernelDensity_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Add contours to a graphics plot.
</p>


<h3>Note</h3>

<p>This function uses <code>KernSmooth::bkde2D()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
snowMap()
addKernelDensity()

snowMap()
addKernelDensity("individual")

snowMap()
addKernelDensity(c(6, 8))

snowMap()
addKernelDensity(pump.select = c(6, 8))

## End(Not run)
</code></pre>

<hr>
<h2 id='addLandmarks'>Add landmarks to plot.</h2><span id='topic+addLandmarks'></span>

<h3>Description</h3>

<p>Add landmarks to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLandmarks(text.size = 0.5, text.col = "black",
  highlight.perimeter = TRUE, latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addLandmarks_+3A_text.size">text.size</code></td>
<td>
<p>Numeric. cex for text labels.</p>
</td></tr>
<tr><td><code id="addLandmarks_+3A_text.col">text.col</code></td>
<td>
<p>Character. col for text labels.</p>
</td></tr>
<tr><td><code id="addLandmarks_+3A_highlight.perimeter">highlight.perimeter</code></td>
<td>
<p>Logical. Highlight Lion Brewery and Model Housing.</p>
</td></tr>
<tr><td><code id="addLandmarks_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Base R points and text.
</p>


<h3>Note</h3>

<p>The location of 18 Sackville Street and 28 Dean Street are approximate. Falconberg Court &amp; Mews form an isolate: they are not part of the network of roads and are technically unreachable. Adam and Eve Court and its pump also form an isolate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap(add.landmarks = FALSE)
addLandmarks()
</code></pre>

<hr>
<h2 id='addLandmarkSquares'>Add Golden and Soho Squares to plot.</h2><span id='topic+addLandmarkSquares'></span>

<h3>Description</h3>

<p>Add Golden and Soho Squares to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLandmarkSquares(latlong = FALSE, text.size = 0.5, text.col = "black")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addLandmarkSquares_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
<tr><td><code id="addLandmarkSquares_+3A_text.size">text.size</code></td>
<td>
<p>Numeric. cex for text labels.</p>
</td></tr>
<tr><td><code id="addLandmarkSquares_+3A_text.col">text.col</code></td>
<td>
<p>Character. col for text labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Base R points and text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
addLandmarkSquares()
</code></pre>

<hr>
<h2 id='addNeighborhoodCases'>Add observed neighborhood cases.</h2><span id='topic+addNeighborhoodCases'></span>

<h3>Description</h3>

<p>Add cases to a plot as &quot;nominal&quot; or &quot;fatalities&quot; and as points or IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNeighborhoodCases(pump.subset = NULL, pump.select = NULL,
  metric = "walking", case.set = "observed", location = "nominal",
  token = "point", text.size = 0.5, pch = 16, point.size = 0.5,
  vestry = FALSE, weighted = TRUE, color = NULL, alpha.level = 0.5,
  latlong = FALSE, multi.core = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addNeighborhoodCases_+3A_pump.subset">pump.subset</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to subset from the neighborhoods defined by <code>pump.select</code>. Negative selection possible. <code>NULL</code> uses all pumps in <code>pump.select</code>.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Numeric vector of pump IDs that define which pump neighborhoods to consider (i.e., specify the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_metric">metric</code></td>
<td>
<p>Character. Type of neighborhood: &quot;euclidean&quot; or &quot;walking&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_location">location</code></td>
<td>
<p>Character. &quot;nominal&quot;, &quot;anchor&quot; or &quot;orthogonal&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_token">token</code></td>
<td>
<p>Character. Type of token to plot: &quot;point&quot; or &quot;id&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_text.size">text.size</code></td>
<td>
<p>Numeric. Size of case ID text.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_pch">pch</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_point.size">point.size</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest walking path weighted by road length. <code>FALSE</code> computes shortest walking path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_color">color</code></td>
<td>
<p>Character. Use a single color for all paths. <code>NULL</code> uses neighborhood colors defined by <code>snowColors().</code></p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Longitude and latitude coordinates.</p>
</td></tr>
<tr><td><code id="addNeighborhoodCases_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
snowMap(add.cases = FALSE)
addNeighborhoodCases()

snowMap(add.cases = FALSE)
addNeighborhoodCases(pump.subset = c(6, 10))

snowMap(add.cases = FALSE)
addNeighborhoodCases(pump.select = c(6, 10))

snowMap(add.cases = FALSE, latlong = TRUE)
addNeighborhoodCases(latlong = TRUE)

snowMap(add.cases = FALSE, latlong = TRUE)
addNeighborhoodCases(pump.subset = c(6, 10), latlong = TRUE)

snowMap(add.cases = FALSE, latlong = TRUE)
addNeighborhoodCases(pump.select = c(6, 10), latlong = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='addNeighborhoodEuclidean'>Add expected Euclidean pump neighborhoods.</h2><span id='topic+addNeighborhoodEuclidean'></span>

<h3>Description</h3>

<p>Plots star graph from pump to its cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNeighborhoodEuclidean(pump.select = NULL, vestry = FALSE,
  case.set = "observed", case.select = "address", latlong = FALSE,
  location = "nominal", brute.force = FALSE, type = "star",
  add.observed.points = TRUE, alpha.level = 0.25, polygon.type = "solid",
  multi.core = FALSE, dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addNeighborhoodEuclidean_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_case.select">case.select</code></td>
<td>
<p>Character. Fatalities: &quot;all&quot; or &quot;address&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Longitude and latitude coordinates</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_location">location</code></td>
<td>
<p>Character. &quot;nominal&quot;, &quot;anchor&quot; or &quot;orthogonal&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_brute.force">brute.force</code></td>
<td>
<p>Logical. For latlong = FALSE. TRUE computes nearest pump for each case. FALSE uses Voronoi cells as shortcut.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_type">type</code></td>
<td>
<p>Character. &quot;star&quot;, &quot;area.points&quot; or &quot;area.polygons&quot;. &quot;area&quot; flavors only valid when <code>case.set = "expected"</code>.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_add.observed.points">add.observed.points</code></td>
<td>
<p>Logical. Add observed fatality &quot;addresses&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_polygon.type">polygon.type</code></td>
<td>
<p>Character. &quot;border&quot; or &quot;solid&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="addNeighborhoodEuclidean_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R graphic elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
streetNameLocator("marshall street", zoom = 0.5, highlight = FALSE,
  add.subtitle = FALSE)
addNeighborhoodEuclidean()

streetNameLocator("marshall street", zoom = -50, highlight = FALSE)
addNeighborhoodEuclidean(case.set = "expected", type = "area.polygons")

## End(Not run)
</code></pre>

<hr>
<h2 id='addNeighborhoodSnow'>Adds Snow's graphical annotation of the Broad Street pump walking neighborhood.</h2><span id='topic+addNeighborhoodSnow'></span>

<h3>Description</h3>

<p>Adds Snow's graphical annotation of the Broad Street pump walking neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNeighborhoodSnow(latlong = FALSE, type = "area.polygons",
  non.snow.cases = FALSE, alpha.level = 1/3, polygon.type = "solid",
  polygon.col = NULL, polygon.lwd = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addNeighborhoodSnow_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="addNeighborhoodSnow_+3A_type">type</code></td>
<td>
<p>Character. Type of annotation plot: &quot;&quot;area.points&quot;, &quot;area.polygons&quot;, or &quot;roads&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodSnow_+3A_non.snow.cases">non.snow.cases</code></td>
<td>
<p>Logical. Plot anchor cases outside Snow neighborhood.</p>
</td></tr>
<tr><td><code id="addNeighborhoodSnow_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="addNeighborhoodSnow_+3A_polygon.type">polygon.type</code></td>
<td>
<p>Character. &quot;border&quot; or &quot;solid&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodSnow_+3A_polygon.col">polygon.col</code></td>
<td>
<p>Character.</p>
</td></tr>
<tr><td><code id="addNeighborhoodSnow_+3A_polygon.lwd">polygon.lwd</code></td>
<td>
<p>Numeric.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(neighborhoodVoronoi())
addNeighborhoodSnow()

## End(Not run)
</code></pre>

<hr>
<h2 id='addNeighborhoodWalking'>Add walking neighborhoods.</h2><span id='topic+addNeighborhoodWalking'></span>

<h3>Description</h3>

<p>Add walking neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNeighborhoodWalking(pump.select = NULL, vestry = FALSE,
  weighted = TRUE, case.set = "expected", latlong = FALSE,
  type = "area.polygons", tsp.method = "repetitive_nn", path.width = 2,
  alpha.level = 0.5, polygon.type = "solid", polygon.col = NULL,
  polygon.lwd = 2, multi.core = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addNeighborhoodWalking_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps. Note that you can't just select the pump on Adam and Eve Court (#2) because it's technically an isolate.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path weighted by road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot;, &quot;expected&quot; or &quot;snow&quot;. &quot;snow&quot; captures John Snow's annotation of the Broad Street pump neighborhood printed in the Vestry report version of the map.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_type">type</code></td>
<td>
<p>Character. &quot;roads&quot;, &quot;area.points&quot; or &quot;area.polygons&quot;. &quot;area&quot; flavors only valid when <code>case.set = "expected"</code>.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_tsp.method">tsp.method</code></td>
<td>
<p>Character. Traveling salesperson problem algorithm.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_path.width">path.width</code></td>
<td>
<p>Numeric. Set width of paths.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_polygon.type">polygon.type</code></td>
<td>
<p>Character. &quot;border&quot; or &quot;solid&quot;.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_polygon.col">polygon.col</code></td>
<td>
<p>Character.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_polygon.lwd">polygon.lwd</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="addNeighborhoodWalking_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
streetNameLocator("marshall street", zoom = 0.5)
addNeighborhoodWalking()

## End(Not run)
</code></pre>

<hr>
<h2 id='addPlaguePit'>Add plague pit (Marshall Street).</h2><span id='topic+addPlaguePit'></span>

<h3>Description</h3>

<p>Draws a polygon that approximates the plague pit located around Marshall Street. From Vestry Report map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPlaguePit(color = "black", line.type = "solid")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addPlaguePit_+3A_color">color</code></td>
<td>
<p>Character. Color of polygon.</p>
</td></tr>
<tr><td><code id="addPlaguePit_+3A_line.type">line.type</code></td>
<td>
<p>Character. Polygon line type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds a polygon to a graphics plot.
</p>


<h3>Note</h3>

<p>In progress.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap(add.landmarks = FALSE)
addPlaguePit()
</code></pre>

<hr>
<h2 id='addPump'>Add selected pump(s) to plot.</h2><span id='topic+addPump'></span>

<h3>Description</h3>

<p>Add selected pump(s) to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPump(pump.select = NULL, vestry = FALSE, col = NULL, pch = 24,
  label = TRUE, pos = 1, cex = 1, latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addPump_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric or Integer. Vector of water pump numerical ID(s). With <code>vestry = TRUE</code>, whole number(s) between 1 and 14. With <code>vestry = FALSE</code>, whole number(s) between 1 and 13. See <code>pumps.vestry</code> and <code>pumps</code> for IDs and details about specific pumps. <code>NULL</code> plots all pumps. Negative selection allowed.</p>
</td></tr>
<tr><td><code id="addPump_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> for the 14 pumps from Vestry Report. <code>FALSE</code> for the original 13 pumps.</p>
</td></tr>
<tr><td><code id="addPump_+3A_col">col</code></td>
<td>
<p>Character. Color of pump points.</p>
</td></tr>
<tr><td><code id="addPump_+3A_pch">pch</code></td>
<td>
<p>Numeric. Shape of point character.</p>
</td></tr>
<tr><td><code id="addPump_+3A_label">label</code></td>
<td>
<p>Logical. TRUE adds text label.</p>
</td></tr>
<tr><td><code id="addPump_+3A_pos">pos</code></td>
<td>
<p>Numeric. Position of label.</p>
</td></tr>
<tr><td><code id="addPump_+3A_cex">cex</code></td>
<td>
<p>Numeric. point cex.</p>
</td></tr>
<tr><td><code id="addPump_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use c(&quot;lon&quot;. &quot;lat&quot;) or c(&quot;x&quot;, &quot;y&quot;).</p>
</td></tr>
</table>

<hr>
<h2 id='addRoads'>Add all streets and roads to plot.</h2><span id='topic+addRoads'></span>

<h3>Description</h3>

<p>Add all streets and roads to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addRoads(latlong = FALSE, col = "gray")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addRoads_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
<tr><td><code id="addRoads_+3A_col">col</code></td>
<td>
<p>Character. Color</p>
</td></tr>
</table>

<hr>
<h2 id='addVoronoi'>Add Voronoi cells.</h2><span id='topic+addVoronoi'></span>

<h3>Description</h3>

<p>Add Voronoi cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addVoronoi(pump.select = NULL, vestry = FALSE, case.location = "nominal",
  color = "black", line.type = "solid", line.width = 1,
  latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addVoronoi_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Default is NULL; all pumps are used. Otherwise, selection by a vector of numeric IDs: 1 to 13 for <code>pumps</code>; 1 to 14 for <code>pumps.vestry</code>. Exclusion (negative selection) is possible (e.g., -6).</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>FALSE</code> for original 13 pumps. TRUE for 14 pumps in Vestry Report.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_case.location">case.location</code></td>
<td>
<p>Character. For <code>observed = FALSE</code>: &quot;address&quot; or &quot;nominal&quot;. &quot;nominal&quot; is the x-y coordinates of <code>regular.cases</code>.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_color">color</code></td>
<td>
<p>Character. Color of cell edges.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_line.type">line.type</code></td>
<td>
<p>Character. Type of line for cell edges: lty.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_line.width">line.width</code></td>
<td>
<p>Numeric. Width of cell edges: lwd.</p>
</td></tr>
<tr><td><code id="addVoronoi_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function uses <code>deldir::deldir()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
# addVoronoi()
</code></pre>

<hr>
<h2 id='addWalkingPath'>Add walking path from case/landmark to nearest or selected pump. (prototype)</h2><span id='topic+addWalkingPath'></span>

<h3>Description</h3>

<p>Add walking path from case/landmark to nearest or selected pump. (prototype)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addWalkingPath(origin = 1, destination = NULL, type = "case-pump",
  vestry = FALSE, latlong = FALSE, case.set = "observed",
  location = "nominal", weighted = TRUE, distance.unit = "meter",
  time.unit = "second", walking.speed = 5, include.landmarks = TRUE,
  long.title = FALSE, mileposts = TRUE, milepost.unit = "distance",
  milepost.interval = NULL, alpha.level = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addWalkingPath_+3A_origin">origin</code></td>
<td>
<p>Numeric. Vector of origin(s) (numeric or case/landmark name).</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_destination">destination</code></td>
<td>
<p>Numeric. Vector of destination(s) (numeric or landmark/pump name).</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_type">type</code></td>
<td>
<p>Character. Path case to pump. FALSE is all other combinations of cases, landmarks and pumps.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the map in the Vestry Report. <code>FALSE</code> uses the 13 pumps from the original map.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_location">location</code></td>
<td>
<p>Character. For cases and pumps. &quot;anchor, &quot;fatality&quot; or &quot;orthogonal.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path in terms of road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot; or &quot;yard&quot;.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_include.landmarks">include.landmarks</code></td>
<td>
<p>Logical. Include landmarks as cases.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_long.title">long.title</code></td>
<td>
<p>Logical. Tile with names.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_mileposts">mileposts</code></td>
<td>
<p>Logical. Plot mile/time posts.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_milepost.unit">milepost.unit</code></td>
<td>
<p>Character. &quot;distance&quot; or &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_milepost.interval">milepost.interval</code></td>
<td>
<p>Numeric. Mile post interval unit of distance (yard or meter) or unit of time (seconds).</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for path: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="addWalkingPath_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='addWhitehead'>Add Rev. Henry Whitehead's Broad Street pump neighborhood.</h2><span id='topic+addWhitehead'></span>

<h3>Description</h3>

<p>A circle (polygon), centered around a desired pump with a radius of 210 yards. The Broad Street pump is the default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addWhitehead(pump = "Broad Street", radius = 210, distance.unit = "yard",
  latlong = FALSE, color = "black", line.type = "solid",
  vestry = FALSE, add.title = FALSE, add.subtitle = FALSE,
  walking.speed = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addWhitehead_+3A_pump">pump</code></td>
<td>
<p>Character or Numeric. Name (road name) or numerical ID of selected pump. See <code>pumps</code> or <code>pumps.vestry</code>.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_radius">radius</code></td>
<td>
<p>Numeric. Distance from a pump.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Longitude-Latitude coordinates.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_color">color</code></td>
<td>
<p>Character. Color of circle.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_line.type">line.type</code></td>
<td>
<p>Character. Circle line type.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps and locations from Vestry report. <code>FALSE</code> uses original 13 pumps.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Add title.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_add.subtitle">add.subtitle</code></td>
<td>
<p>Logical. Add subtitle with estimated &quot;walking&quot; time in seconds.</p>
</td></tr>
<tr><td><code id="addWhitehead_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds a circle (polygon) to a graphics plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
addWhitehead()
</code></pre>

<hr>
<h2 id='anchor.case'>Anchor or base case of each stack of fatalities.</h2><span id='topic+anchor.case'></span>

<h3>Description</h3>

<p>Data frame that links a fatality to its stack, a stack's base case. For use with <code><a href="#topic+caseLocator">caseLocator</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anchor.case
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>case</code></dt><dd><p>numerical case ID</p>
</dd>
<dt><code>anchor</code></dt><dd><p>numerical case ID of anchor.case</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='border'>Numeric IDs of line segments that create the map's border frame.</h2><span id='topic+border'></span>

<h3>Description</h3>

<p>Vector of ordered numbers that identify the line segments that make up the frame of the map. For use with sp::Polygon().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>border
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>border</code></dt><dd><p>numerical ID</p>
</dd>
</dl>


<hr>
<h2 id='caseLocator'>Locate case by numerical ID.</h2><span id='topic+caseLocator'></span>

<h3>Description</h3>

<p>Highlight selected observed or simulated case and its home road segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caseLocator(case = 1, zoom = FALSE, observed = TRUE, latlong = FALSE,
  add.title = TRUE, highlight.segment = TRUE, data = FALSE,
  add = FALSE, col = "red", vestry = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caseLocator_+3A_case">case</code></td>
<td>
<p>Numeric or Integer. Whole number between 1 and 578.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. Positive numbers zoom in; negative numbers zoom out.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_observed">observed</code></td>
<td>
<p>Logical. <code>TRUE</code> for observed. <code>FALSE</code> for simulated.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Longitude and latitude coordinates</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Include title.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_highlight.segment">highlight.segment</code></td>
<td>
<p>Logical. Highlight case's segment.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_data">data</code></td>
<td>
<p>Logical. Output data.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_add">add</code></td>
<td>
<p>Logical. Add to existing plot or separate plot.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_col">col</code></td>
<td>
<p>Character. Point color.</p>
</td></tr>
<tr><td><code id="caseLocator_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caseLocator(290)
caseLocator(290, zoom = TRUE)
caseLocator(290, observed = FALSE)
caseLocator(290, latlong = TRUE, zoom = TRUE)
</code></pre>

<hr>
<h2 id='euclideanPath'>Compute Euclidean path coordinates from observed case/landmark to nearest/selected pump.</h2><span id='topic+euclideanPath'></span>

<h3>Description</h3>

<p>Compute Euclidean path coordinates from observed case/landmark to nearest/selected pump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclideanPath(origin = 1, destination = NULL, type = "case-pump",
  vestry = FALSE, latlong = FALSE, case.set = "observed",
  location = "nominal", weighted = TRUE, distance.unit = "meter",
  time.unit = "second", walking.speed = 5, include.landmarks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="euclideanPath_+3A_origin">origin</code></td>
<td>
<p>Numeric. Vector of origin(s) (numeric ID or character name landmark/pump ).</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_destination">destination</code></td>
<td>
<p>Numeric. Vector of destination(s) (numeric or landmark/pump name).</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_type">type</code></td>
<td>
<p>Character. Path case to pump. FALSE is all other combinations of cases, landmarks and pumps.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the map in the Vestry Report. <code>FALSE</code> uses the 13 pumps from the original map.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_location">location</code></td>
<td>
<p>Character. For cases and pumps. &quot;nominal&quot;, &quot;anchor&quot; or &quot;orthogonal&quot;.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path in terms of road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot; or &quot;yard&quot;.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="euclideanPath_+3A_include.landmarks">include.landmarks</code></td>
<td>
<p>Logical. Include landmarks as cases.</p>
</td></tr>
</table>

<hr>
<h2 id='fatalities'>Amended Dodson and Tobler's cholera data.</h2><span id='topic+fatalities'></span>

<h3>Description</h3>

<p>An amended version of Dodson and Tobler's digitization of John Snow's map of the 1854 London cholera outbreak. It removes 3 duplicate observations and imputes the location for 3 &quot;missing&quot; observation. This information is also available in HistData::Snow.deaths2 (&gt;= ver. 0.7-8).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fatalities
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 variable that records the position and the nearest pump for the 578 bars on Snow's map.
</p>

<dl>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p>fixFatalities() documents the code for these data. For details, see <code>vignette</code>(&quot;duplicate.missing.cases&quot;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caseLocator">caseLocator</a></code>
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>
<p><code><a href="#topic+caseLocator">caseLocator</a></code>
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>

<hr>
<h2 id='fatalities.address'>&quot;Unstacked&quot; amended cholera data with address as unit of observation.</h2><span id='topic+fatalities.address'></span>

<h3>Description</h3>

<p>An &quot;unstacked&quot; version of the <code>fatalities</code> dataset. It changes the unit of observation from the case (bar) to the &quot;address&quot;, the x-y coordinates of the case at the base of a stack, and makes the number of fatalities an attribute of the &quot;address&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fatalities.address
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 variables for 321 addresses
</p>

<dl>
<dt><code>anchor</code></dt><dd><p>numerical case ID of address</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>case.count</code></dt><dd><p>number of fatalities at address</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data. For details, see <code>vignette</code>(&quot;unstacking.fatalities&quot;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caseLocator">caseLocator</a></code>
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>

<hr>
<h2 id='fatalities.unstacked'>&quot;Unstacked&quot; amended cholera fatalities data with fatality as unit of observation.</h2><span id='topic+fatalities.unstacked'></span>

<h3>Description</h3>

<p>An &quot;unstacked&quot; version of the <code>fatalities</code> dataset. It changes the unit of observation from the case (bar) to the &quot;address&quot;, the x-y coordinates of the case at the base of a stack, and assigns the base case's coordinates to all cases in the stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fatalities.unstacked
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 variable that records the position of the 578 bars on Snow's map.
</p>

<dl>
<dt><code>case</code></dt><dd><p>numerical case ID</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data. For details, see <code>vignette</code>(&quot;unstacking.fatalities&quot;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+caseLocator">caseLocator</a></code>
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>

<hr>
<h2 id='frame.data'>Map frame data c(&quot;x&quot;, &quot;y&quot;) and c(&quot;lon&quot;, &quot;lat&quot;).</h2><span id='topic+frame.data'></span>

<h3>Description</h3>

<p>Map frame data c(&quot;x&quot;, &quot;y&quot;) and c(&quot;lon&quot;, &quot;lat&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frame.data
</code></pre>


<h3>Format</h3>

<p>A data frame with 106 observations (points) and 8 variables.
</p>

<dl>
<dt><code>street</code></dt><dd><p>street number</p>
</dd>
<dt><code>n</code></dt><dd><p>street street component number</p>
</dd>
<dt><code>x</code></dt><dd><p>native x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>native y-coordinate</p>
</dd>
<dt><code>id</code></dt><dd><p>segment numeric ID</p>
</dd>
<dt><code>name</code></dt><dd><p>street name</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='frame.sample'>Partitioned map frame points (segment endpoints).</h2><span id='topic+frame.sample'></span>

<h3>Description</h3>

<p>Partitioned map frame points (segment endpoints).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frame.sample
</code></pre>


<h3>Format</h3>

<p>A list of 3 vectors length 19, 19 and 18 from cholera::roads$id.
</p>

<dl>
<dt><code>frame.sample</code></dt><dd><p>cholera::roads$id</p>
</dd>
</dl>


<hr>
<h2 id='landmark.squares'>Centers of city squares.</h2><span id='topic+landmark.squares'></span>

<h3>Description</h3>

<p>Centers of city squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmark.squares
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 observations and 6 variables that records the position of landmark square labels.
</p>

<dl>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
<dt><code>name</code></dt><dd><p>square name</p>
</dd>
</dl>


<hr>
<h2 id='landmarks'>Landmark coordinates.</h2><span id='topic+landmarks'></span>

<h3>Description</h3>

<p>Landmark coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarks
</code></pre>


<h3>Format</h3>

<p>A data frame of landmark coordinates with 20 observations and 11 variables.
</p>

<dl>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x</code></dt><dd><p>nominal x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>nominal y-coordinate</p>
</dd>
<dt><code>x.lab</code></dt><dd><p>label x-coordinate</p>
</dd>
<dt><code>y.lab</code></dt><dd><p>label y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
<dt><code>lon.lab</code></dt><dd><p>label longitude</p>
</dd>
<dt><code>lat.lab</code></dt><dd><p>label latitude</p>
</dd>
<dt><code>name</code></dt><dd><p>landmark name</p>
</dd>
</dl>


<hr>
<h2 id='latlong.ortho.addr'>Orthogonal projection of observed address (latlong) cases onto road network.</h2><span id='topic+latlong.ortho.addr'></span>

<h3>Description</h3>

<p>Orthogonal projection of observed address (latlong) cases onto road network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong.ortho.addr
</code></pre>


<h3>Format</h3>

<p>A data frame with 7 variables that records the position of the orthogonal projection of the 321 cases onto the network of roads.
</p>

<dl>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='latlong.ortho.pump'>Orthogonal projection of 13 original pumps (latlong).</h2><span id='topic+latlong.ortho.pump'></span>

<h3>Description</h3>

<p>Orthogonal projection of 13 original pumps (latlong).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong.ortho.pump
</code></pre>


<h3>Format</h3>

<p>A data frame with 7 variables that records the position of the orthogonal projection of the 13 original pumps onto the network of roads.
</p>

<dl>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>id</code></dt><dd><p>numeric ID</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>

<hr>
<h2 id='latlong.ortho.pump.vestry'>Orthogonal projection of the 14 pumps from the Vestry Report (latlong).</h2><span id='topic+latlong.ortho.pump.vestry'></span>

<h3>Description</h3>

<p>Orthogonal projection of the 14 pumps from the Vestry Report (latlong).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong.ortho.pump.vestry
</code></pre>


<h3>Format</h3>

<p>A data frame with 7 variables that records the position of the orthogonal projection of the 14 pumps onto the network of roads.
</p>

<dl>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>id</code></dt><dd><p>numeric ID</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>

<hr>
<h2 id='latlong.regular.cases'>&quot;Expected&quot; cases (latlong).</h2><span id='topic+latlong.regular.cases'></span>

<h3>Description</h3>

<p>The result of using sp::spsample() and sp::Polygon() to generate 19,993 regularly spaced simulated Cartesian/geodesic cases within the map's borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong.regular.cases
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 variables that records the position of 19,993 &quot;expected&quot; cases fitted by sp::spsample().
</p>

<dl>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='latlong.sim.ortho.proj'>Road &quot;address&quot; of simulated (i.e., &quot;expected&quot;) cases (latlong).</h2><span id='topic+latlong.sim.ortho.proj'></span>

<h3>Description</h3>

<p>Road &quot;address&quot; of simulated (i.e., &quot;expected&quot;) cases (latlong).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlong.sim.ortho.proj
</code></pre>


<h3>Format</h3>

<p>A data frame with 8 variables that records the &quot;address&quot; of 19,993 regularly spaced simulated Cartesian/geodesic cases regularly spaced across map.
</p>

<dl>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>dist</code></dt><dd><p>Euclidean or orthogonal distance to home road segment</p>
</dd>
<dt><code>type</code></dt><dd><p>type of projection: Euclidean (&quot;eucl&quot;) or orthogonal (&quot;ortho&quot;)</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='mapRange'>Compute xlim and ylim of Snow's map.</h2><span id='topic+mapRange'></span>

<h3>Description</h3>

<p>Compute xlim and ylim of Snow's map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapRange(latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapRange_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>

<hr>
<h2 id='meter.to.yard'>Meter to yard conversion factor.</h2><span id='topic+meter.to.yard'></span>

<h3>Description</h3>

<p>Meter to yard conversion factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meter.to.yard
</code></pre>


<h3>Format</h3>

<p>A vector of length one.
</p>

<dl>
<dt><code>meter.to.yard</code></dt><dd><p>conversion factor = 1.093613</p>
</dd>
</dl>


<hr>
<h2 id='neighborhoodData'>Compute network graph of roads, cases and pumps (prototype).</h2><span id='topic+neighborhoodData'></span>

<h3>Description</h3>

<p>Assembles cases, pumps and road into a network graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhoodData(vestry = FALSE, case.set = "observed",
  embed.addr = TRUE, embed.landmarks = TRUE, embed.pumps = TRUE,
  latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighborhoodData_+3A_vestry">vestry</code></td>
<td>
<p>Logical. Use Vestry Report pump data.</p>
</td></tr>
<tr><td><code id="neighborhoodData_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot;, &quot;expected&quot;, or &quot;snow&quot;. &quot;snow&quot; captures John Snow's annotation of the Broad Street pump neighborhood printed in the Vestry report version of the map.</p>
</td></tr>
<tr><td><code id="neighborhoodData_+3A_embed.addr">embed.addr</code></td>
<td>
<p>Logical. Embed cases into road network.</p>
</td></tr>
<tr><td><code id="neighborhoodData_+3A_embed.landmarks">embed.landmarks</code></td>
<td>
<p>Logical. Embed landmarks into road network.</p>
</td></tr>
<tr><td><code id="neighborhoodData_+3A_embed.pumps">embed.pumps</code></td>
<td>
<p>Logical. Embed pumps into road network.</p>
</td></tr>
<tr><td><code id="neighborhoodData_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list of nodes, edges and an 'igraph' network graph.
</p>

<hr>
<h2 id='neighborhoodEuclidean'>Compute Euclidean path pump neighborhoods.</h2><span id='topic+neighborhoodEuclidean'></span>

<h3>Description</h3>

<p>Plots star graph from pump to its cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhoodEuclidean(pump.select = NULL, vestry = FALSE,
  case.set = "observed", case.select = "address", latlong = FALSE,
  location = "nominal", brute.force = FALSE, multi.core = FALSE,
  dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighborhoodEuclidean_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_case.select">case.select</code></td>
<td>
<p>Character. Fatalities: &quot;all&quot; or &quot;address&quot;.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Longitude and latitude coordinates</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_location">location</code></td>
<td>
<p>Character. &quot;nominal&quot;, &quot;anchor&quot; or &quot;orthogonal&quot;.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_brute.force">brute.force</code></td>
<td>
<p>Logical. For latlong = FALSE. TRUE computes nearest pump for each case. FALSE uses Voronoi cells as shortcut.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="neighborhoodEuclidean_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list.
</p>

<hr>
<h2 id='neighborhoodSnow'>Compute Snow's graphical annotation of Broad Street pump neighborhood.</h2><span id='topic+neighborhoodSnow'></span>

<h3>Description</h3>

<p>Computational approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhoodSnow(latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighborhoodSnow_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>

<hr>
<h2 id='neighborhoodVoronoi'>Compute Voronoi pump neighborhoods.</h2><span id='topic+neighborhoodVoronoi'></span>

<h3>Description</h3>

<p>Group cases into neighborhoods using Voronoi tessellation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhoodVoronoi(pump.select = NULL, vestry = FALSE, latlong = FALSE,
  location = "nominal", polygon.vertices = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighborhoodVoronoi_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="neighborhoodVoronoi_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="neighborhoodVoronoi_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Longitude and latitude coordinates</p>
</td></tr>
<tr><td><code id="neighborhoodVoronoi_+3A_location">location</code></td>
<td>
<p>Character. &quot;nominal&quot; or &quot;orthogonal&quot;. &quot;nominal&quot; uses the x-y coordinates of <code>fatalities.address</code>. &quot;orthogonal&quot;uses the x-y coordinates of <code>ortho.proj</code>.</p>
</td></tr>
<tr><td><code id="neighborhoodVoronoi_+3A_polygon.vertices">polygon.vertices</code></td>
<td>
<p>Logical. <code>TRUE</code> returns a list of x-y coordinates of the vertices of Voronoi cells. Useful for <code>sp::point.in.polygon()</code> as used in <code>print.voronoi()</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list with 12 objects.
</p>

<ul>
<li><p><code>pump.id</code>: vector of selected pumps
</p>
</li>
<li><p><code>voronoi</code>: output from deldir::deldir().
</p>
</li>
<li><p><code>snow.colors</code>: neighborhood color based on snowColors().
</p>
</li>
<li><p><code>x.rng</code>: range of x for plot.
</p>
</li>
<li><p><code>y.rng</code>: range of y for plot.
</p>
</li>
<li><p><code>select.string</code>: description of &quot;pump.select&quot; for plot title.
</p>
</li>
<li><p><code>expected.data</code>: expected neighborhood fatality counts, based on Voronoi cell area.
</p>
</li>
<li><p><code>coordinates</code>: polygon vertices of Voronoi cells.
</p>
</li>
<li><p><code>statistic.data</code>: observed neighborhood fatality counts.
</p>
</li>
<li><p><code>pump.select</code>: &quot;pump.select&quot; from neighborhoodVoronoi().
</p>
</li>
<li><p><code>statistic</code>: &quot;statistic&quot; from neighborhoodVoronoi().
</p>
</li>
<li><p><code>vestry</code>: &quot;vestry&quot; from neighborhoodVoronoi().
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neighborhoodVoronoi()
neighborhoodVoronoi(vestry = TRUE)
neighborhoodVoronoi(pump.select = 6:7)
neighborhoodVoronoi(pump.select = -6)
neighborhoodVoronoi(pump.select = -6, polygon.vertices = TRUE)

# coordinates for vertices also available in the returned object.
dat &lt;- neighborhoodVoronoi(pump.select = -6)
dat$coordinates

## End(Not run)
</code></pre>

<hr>
<h2 id='neighborhoodWalking'>Compute walking path pump neighborhoods.</h2><span id='topic+neighborhoodWalking'></span>

<h3>Description</h3>

<p>Group cases into neighborhoods based on walking distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhoodWalking(pump.select = NULL, vestry = FALSE, weighted = TRUE,
  case.set = "observed", latlong = FALSE, multi.core = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neighborhoodWalking_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps. Note that you can't just select the pump on Adam and Eve Court (#2) because it's technically an isolate.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path weighted by road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="neighborhoodWalking_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>

<hr>
<h2 id='ortho.proj'>Orthogonal projection of observed cases onto road network.</h2><span id='topic+ortho.proj'></span>

<h3>Description</h3>

<p>Orthogonal projection of observed cases onto road network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho.proj
</code></pre>


<h3>Format</h3>

<p>A data frame with 5 variables that records the position of the orthogonal projection of the 578 cases onto the network of roads.
</p>

<dl>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>dist</code></dt><dd><p>distance to home road segment</p>
</dd>
<dt><code>type</code></dt><dd><p>type of distance: orthogonal to road or Euclidean to endpoint</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+unstackFatalities">unstackFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='ortho.proj.pump'>Orthogonal projection of 13 original pumps.</h2><span id='topic+ortho.proj.pump'></span>

<h3>Description</h3>

<p>Orthogonal projection of 13 original pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho.proj.pump
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables that records the position of the orthogonal projection of the 13 original pumps onto the network of roads.
</p>

<dl>
<dt><code>pump.id</code></dt><dd><p>numeric ID</p>
</dd>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>node</code></dt><dd><p>node ID</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>

<hr>
<h2 id='ortho.proj.pump.vestry'>Orthogonal projection of the 14 pumps from the Vestry Report.</h2><span id='topic+ortho.proj.pump.vestry'></span>

<h3>Description</h3>

<p>Orthogonal projection of the 14 pumps from the Vestry Report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho.proj.pump.vestry
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables that records the position of the orthogonal projection of the 14 pumps onto the network of roads.
</p>

<dl>
<dt><code>pump.id</code></dt><dd><p>numeric ID</p>
</dd>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>ortho.dist</code></dt><dd><p>orthogonal distance to home road segment</p>
</dd>
<dt><code>node</code></dt><dd><p>node ID</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>

<hr>
<h2 id='pearsonResiduals'>Compute Pearson Residuals (prototype)</h2><span id='topic+pearsonResiduals'></span>

<h3>Description</h3>

<p>Compute Pearson Residuals (prototype)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pearsonResiduals(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pearsonResiduals_+3A_x">x</code></td>
<td>
<p>An object created by <code>neighborhoodEuclidean()</code>, <code>neighborhoodVoronoi()</code> or <code>neighborhoodWalking()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pearsonResiduals(neighborhoodEuclidean())
pearsonResiduals(neighborhoodVoronoi())
pearsonResiduals(neighborhoodWalking())

## End(Not run)
</code></pre>

<hr>
<h2 id='plague.pit'>Plague pit coordinates.</h2><span id='topic+plague.pit'></span>

<h3>Description</h3>

<p>Coordinates for polygon() or sp::Polygon(). In progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plague.pit
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations and 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
</dl>


<hr>
<h2 id='plot.euclidean'>Plot method for neighborhoodEuclidean().</h2><span id='topic+plot.euclidean'></span>

<h3>Description</h3>

<p>Plot method for neighborhoodEuclidean().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean'
plot(x, type = "star", add = FALSE,
  add.observed.points = TRUE, alpha.level = 0.75, polygon.type = "solid",
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.euclidean_+3A_x">x</code></td>
<td>
<p>An object of class &quot;euclidean&quot; created by <code>neighborhoodEuclidean()</code>.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_type">type</code></td>
<td>
<p>Character. &quot;star&quot;, &quot;area.points&quot; or &quot;area.polygons&quot;. &quot;area&quot; flavors only valid when <code>case.set = "expected"</code>.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_add">add</code></td>
<td>
<p>Logical. Add graphic to an existing plot.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_add.observed.points">add.observed.points</code></td>
<td>
<p>Logical. Add observed fatality &quot;addresses&quot;.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_polygon.type">polygon.type</code></td>
<td>
<p>Character. &quot;perimeter&quot; or &quot;solid&quot;.</p>
</td></tr>
<tr><td><code id="plot.euclidean_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>


<h3>Note</h3>

<p>This uses an approximate computation of polygons, using the 'TSP' package, that may produce non-simple and/or overlapping polygons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(neighborhoodEuclidean())
plot(neighborhoodEuclidean(-6))
plot(neighborhoodEuclidean(pump.select = 6:7))
plot(neighborhoodEuclidean(case.set = "expected"), type = "area.points")
plot(neighborhoodEuclidean(case.set = "expected"), type = "area.polygons")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.euclidean_path'>Plot the path of the Euclidean distance between cases and/or pumps.</h2><span id='topic+plot.euclidean_path'></span>

<h3>Description</h3>

<p>Plot the path of the Euclidean distance between cases and/or pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean_path'
plot(x, zoom = TRUE, add = FALSE,
  long.title = TRUE, mileposts = TRUE, milepost.unit = "distance",
  milepost.interval = NULL, alpha.level = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.euclidean_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;euclidean_path&quot; created by euclideanPath().</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. Positive numbers zoom in; negative numbers zoom out.</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_add">add</code></td>
<td>
<p>Logical. Add graphic to plot.</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_long.title">long.title</code></td>
<td>
<p>Logical. Tile with names.</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_mileposts">mileposts</code></td>
<td>
<p>Logical. Plot mile/time posts.</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_milepost.unit">milepost.unit</code></td>
<td>
<p>Character. &quot;distance&quot; or &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_milepost.interval">milepost.interval</code></td>
<td>
<p>Numeric. Mile post interval unit of distance (yard or meter) or unit of time (seconds).</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for path: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="plot.euclidean_path_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>

<hr>
<h2 id='plot.euclideanLatlong'>Plot method for euclideanLatlong()</h2><span id='topic+plot.euclideanLatlong'></span>

<h3>Description</h3>

<p>Plot method for euclideanLatlong()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclideanLatlong'
plot(x, type = "star", add = FALSE,
  add.observed.points = TRUE, alpha.level = 0.75, polygon.type = "solid",
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.euclideanLatlong_+3A_x">x</code></td>
<td>
<p>Object.</p>
</td></tr>
<tr><td><code id="plot.euclideanLatlong_+3A_type">type</code></td>
<td>
<p>Character. &quot;star&quot;, &quot;area.points&quot; or &quot;area.polygons&quot;. &quot;area&quot; flavors only valid when <code>case.set = "expected"</code>.</p>
</td></tr>
<tr><td><code id="plot.euclideanLatlong_+3A_add">add</code></td>
<td>
<p>Logical. Add graphic to an existing plot.</p>
</td></tr>
<tr><td><code id="plot.euclideanLatlong_+3A_add.observed.points">add.observed.points</code></td>
<td>
<p>Logical. Add observed fatality &quot;addresses&quot;.</p>
</td></tr>
<tr><td><code id="plot.euclideanLatlong_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="plot.euclideanLatlong_+3A_polygon.type">polygon.type</code></td>
<td>
<p>Character. &quot;perimeter&quot; or &quot;solid&quot;.</p>
</td></tr>
<tr><td><code id="plot.euclideanLatlong_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.neighborhood_data'>Plot method for neighborhoodData().</h2><span id='topic+plot.neighborhood_data'></span>

<h3>Description</h3>

<p>Visualize underlying road network (with or without cases and pumps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'neighborhood_data'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.neighborhood_data_+3A_x">x</code></td>
<td>
<p>An 'igraph' object of class &quot;neighborhood_data&quot; created by <code>neighborhoodData()</code>.</p>
</td></tr>
<tr><td><code id="plot.neighborhood_data_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>

<hr>
<h2 id='plot.profile_perspective'>Plot method for profilePerspective().</h2><span id='topic+plot.profile_perspective'></span>

<h3>Description</h3>

<p>Plot method for profilePerspective().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile_perspective'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.profile_perspective_+3A_x">x</code></td>
<td>
<p>An object of class &quot;profile&quot; created by <code>profilePerspective()</code>.</p>
</td></tr>
<tr><td><code id="plot.profile_perspective_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.snow'>Plot method for neighborhoodSnow().</h2><span id='topic+plot.snow'></span>

<h3>Description</h3>

<p>Plot method for neighborhoodSnow().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snow'
plot(x, type = "area.polygons", non.snow.cases = TRUE,
  alpha.level = 1/3, polygon.type = "solid", polygon.col = NULL,
  polygon.lwd = NULL, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.snow_+3A_x">x</code></td>
<td>
<p>An object of class &quot;neighborhood_snow&quot; created by <code>neighborhoodSnow()</code>.</p>
</td></tr>
<tr><td><code id="plot.snow_+3A_type">type</code></td>
<td>
<p>Character. &quot;roads&quot;, &quot;area.points&quot; or &quot;area.polygons&quot;.</p>
</td></tr>
<tr><td><code id="plot.snow_+3A_non.snow.cases">non.snow.cases</code></td>
<td>
<p>Logical. Plot anchor cases outside Snow neighborhood.</p>
</td></tr>
<tr><td><code id="plot.snow_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="plot.snow_+3A_polygon.type">polygon.type</code></td>
<td>
<p>Character. &quot;border&quot; or &quot;solid&quot;.</p>
</td></tr>
<tr><td><code id="plot.snow_+3A_polygon.col">polygon.col</code></td>
<td>
<p>Character.</p>
</td></tr>
<tr><td><code id="plot.snow_+3A_polygon.lwd">polygon.lwd</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="plot.snow_+3A_add">add</code></td>
<td>
<p>Logical. Add graphic to plot.</p>
</td></tr>
<tr><td><code id="plot.snow_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.time_series'>Plot aggregate time series data from Vestry report.</h2><span id='topic+plot.time_series'></span>

<h3>Description</h3>

<p>Plot aggregate fatality data and indicates the date of the removal of the handle of the Broad Street pump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'time_series'
plot(x, statistic = "fatal.attacks",
  pump.handle = TRUE, main = "Removal of the Broad Street Pump Handle",
  type = "o", xlab = "Date", ylab = "Fatalities", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.time_series_+3A_x">x</code></td>
<td>
<p>An object of class &quot;time_series&quot; from timeSeries().</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_statistic">statistic</code></td>
<td>
<p>Character. Fatality measure: either &quot;fatal.attacks&quot; or &quot;deaths&quot;.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_pump.handle">pump.handle</code></td>
<td>
<p>Logical. Indicate date of removal of Broad Street pump handle.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_main">main</code></td>
<td>
<p>Character. Title of graph.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_type">type</code></td>
<td>
<p>Character. R plot type.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_xlab">xlab</code></td>
<td>
<p>Character. x-axis label.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_ylab">ylab</code></td>
<td>
<p>Character. y-axis label.</p>
</td></tr>
<tr><td><code id="plot.time_series_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+timeSeries">timeSeries</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(timeSeries())
plot(timeSeries(), statistic = "deaths")
plot(timeSeries(), bty = "n", type = "h", lwd = 4)
</code></pre>

<hr>
<h2 id='plot.voronoi_latlong'>Plot method for voronoiLatlong()</h2><span id='topic+plot.voronoi_latlong'></span>

<h3>Description</h3>

<p>Plot method for voronoiLatlong()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi_latlong'
plot(x, add.pumps = TRUE,
  delaunay.voronoi = "voronoi", euclidean.paths = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.voronoi_latlong_+3A_x">x</code></td>
<td>
<p>Object.</p>
</td></tr>
<tr><td><code id="plot.voronoi_latlong_+3A_add.pumps">add.pumps</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="plot.voronoi_latlong_+3A_delaunay.voronoi">delaunay.voronoi</code></td>
<td>
<p>Character &quot;delaunay&quot;, &quot;voronoi&quot;, or &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="plot.voronoi_latlong_+3A_euclidean.paths">euclidean.paths</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="plot.voronoi_latlong_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.voronoi_nominal'>Plot Voronoi neighborhoods.</h2><span id='topic+plot.voronoi_nominal'></span>

<h3>Description</h3>

<p>Plot Voronoi neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi_nominal'
plot(x, delaunay.voronoi = "voronoi",
  euclidean.paths = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.voronoi_nominal_+3A_x">x</code></td>
<td>
<p>An object of class &quot;voronoi&quot; created by <code>voronoiNominal()</code>.</p>
</td></tr>
<tr><td><code id="plot.voronoi_nominal_+3A_delaunay.voronoi">delaunay.voronoi</code></td>
<td>
<p>Character &quot;delaunay&quot;, &quot;voronoi&quot;, or &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="plot.voronoi_nominal_+3A_euclidean.paths">euclidean.paths</code></td>
<td>
<p>Logical. Plot all Euclidean paths (star graph).</p>
</td></tr>
<tr><td><code id="plot.voronoi_nominal_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graph.
</p>


<h3>See Also</h3>

<p><code>voronoiNominal()</code>
</p>
<p><code>addVoronoi()</code>
</p>

<hr>
<h2 id='plot.walking'>Plot method for neighborhoodWalking().</h2><span id='topic+plot.walking'></span>

<h3>Description</h3>

<p>Plot method for neighborhoodWalking().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walking'
plot(x, type = "area.points", add = FALSE,
  tsp.method = "repetitive_nn", path.width = 2, alpha.level = 0.75,
  polygon.type = "solid", polygon.col = NULL, polygon.lwd = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.walking_+3A_x">x</code></td>
<td>
<p>An object of class &quot;walking&quot; created by <code>neighborhoodWalking()</code>.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_type">type</code></td>
<td>
<p>Character. Type of expected plot: &quot;roads&quot;, &quot;area.points&quot; or &quot;area.polygons&quot;. Valid only when <code>case.set = "expected"</code>.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_add">add</code></td>
<td>
<p>Logical. Add graphic to plot.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_tsp.method">tsp.method</code></td>
<td>
<p>Character. Traveling salesperson problem algorithm.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_path.width">path.width</code></td>
<td>
<p>Numeric. Set width of paths.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for area plot: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_polygon.type">polygon.type</code></td>
<td>
<p>Character. &quot;border&quot; or &quot;solid&quot;.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_polygon.col">polygon.col</code></td>
<td>
<p>Character.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_polygon.lwd">polygon.lwd</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id="plot.walking_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>


<h3>Note</h3>

<p>When plotting area graphs with simulated data (i.e., <code>case.set = "expected"</code>), there may be discrepancies between observed cases and expected neighborhoods, particularly between neighborhoods. type = &quot;roads&quot; inspired by Shiode et. al. (2015).
</p>

<hr>
<h2 id='plot.walking_path'>Plot the walking path between selected cases and/or pumps.</h2><span id='topic+plot.walking_path'></span>

<h3>Description</h3>

<p>Plot the walking path between selected cases and/or pumps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walking_path'
plot(x, zoom = TRUE, add = FALSE,
  long.title = TRUE, mileposts = TRUE, milepost.unit = "distance",
  milepost.interval = NULL, alpha.level = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.walking_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;walking_path&quot; created by walkingPath().</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. Positive numbers zoom in; negative numbers zoom out.</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_add">add</code></td>
<td>
<p>Logical. Add graphic to plot.</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_long.title">long.title</code></td>
<td>
<p>Logical. Tile with names.</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_mileposts">mileposts</code></td>
<td>
<p>Logical. Plot mile/time posts.</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_milepost.unit">milepost.unit</code></td>
<td>
<p>Character. &quot;distance&quot; or &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_milepost.interval">milepost.interval</code></td>
<td>
<p>Numeric. Mile post interval unit of distance (yard or meter) or unit of time (seconds).</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_alpha.level">alpha.level</code></td>
<td>
<p>Numeric. Alpha level transparency for path: a value in [0, 1].</p>
</td></tr>
<tr><td><code id="plot.walking_path_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R plot.
</p>

<hr>
<h2 id='print.euclidean'>Print method for neighborhoodEuclidean().</h2><span id='topic+print.euclidean'></span>

<h3>Description</h3>

<p>Parameter values for neighborhoodEuclidean().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.euclidean_+3A_x">x</code></td>
<td>
<p>An object of class &quot;euclidean&quot; created by <code>neighborhoodEuclidean()</code>.</p>
</td></tr>
<tr><td><code id="print.euclidean_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neighborhoodEuclidean()
print(neighborhoodEuclidean())

## End(Not run)
</code></pre>

<hr>
<h2 id='print.euclidean_path'>Print method for euclideanPath().</h2><span id='topic+print.euclidean_path'></span>

<h3>Description</h3>

<p>Summary output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean_path'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.euclidean_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;euclidean_path&quot; created by <code>euclideanPath()</code>.</p>
</td></tr>
<tr><td><code id="print.euclidean_path_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>

<hr>
<h2 id='print.euclideanLatlong'>Print method for neighborhoodEuclidean(latlong = TRUE).</h2><span id='topic+print.euclideanLatlong'></span>

<h3>Description</h3>

<p>Print method for neighborhoodEuclidean(latlong = TRUE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclideanLatlong'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.euclideanLatlong_+3A_x">x</code></td>
<td>
<p>An object of class &quot;euclideanLatlong&quot; created by <code>neighborhoodEuclidean(latlong = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="print.euclideanLatlong_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neighborhoodEuclidean(latlong = TRUE)
print(neighborhoodEuclidean(latlong = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='print.time_series'>Print summary data for timeSeries().</h2><span id='topic+print.time_series'></span>

<h3>Description</h3>

<p>Return summary results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'time_series'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.time_series_+3A_x">x</code></td>
<td>
<p>An object of class &quot;time_series&quot; created by timeSeries().</p>
</td></tr>
<tr><td><code id="print.time_series_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeSeries()
print(timeSeries())
</code></pre>

<hr>
<h2 id='print.voronoi_latlong'>Print method for voronoiLatlong().</h2><span id='topic+print.voronoi_latlong'></span>

<h3>Description</h3>

<p>Parameter values for voronoiLatlong().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi_latlong'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.voronoi_latlong_+3A_x">x</code></td>
<td>
<p>An object of class &quot;voronoiLatlong&quot; created by <code>voronoiLatlong()</code>.</p>
</td></tr>
<tr><td><code id="print.voronoi_latlong_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument values.
</p>

<hr>
<h2 id='print.voronoi_nominal'>Print method for voronoiNominal().</h2><span id='topic+print.voronoi_nominal'></span>

<h3>Description</h3>

<p>Parameter values for voronoiNominal().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi_nominal'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.voronoi_nominal_+3A_x">x</code></td>
<td>
<p>An object of class &quot;voronoi&quot; created by <code>voronoiNominal()</code>.</p>
</td></tr>
<tr><td><code id="print.voronoi_nominal_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument values.
</p>

<hr>
<h2 id='print.walking'>Print method for neighborhoodWalking().</h2><span id='topic+print.walking'></span>

<h3>Description</h3>

<p>Parameter values for neighborhoodWalking().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walking'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.walking_+3A_x">x</code></td>
<td>
<p>An object of class &quot;walking&quot; created by <code>neighborhoodWalking()</code>.</p>
</td></tr>
<tr><td><code id="print.walking_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
neighborhoodWalking()
print(neighborhoodWalking())

## End(Not run)
</code></pre>

<hr>
<h2 id='print.walking_path'>Print method for walkingPath().</h2><span id='topic+print.walking_path'></span>

<h3>Description</h3>

<p>Summary output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walking_path'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.walking_path_+3A_x">x</code></td>
<td>
<p>An object of class &quot;latlong_walking_path&quot; created by latlongWalkingPath().</p>
</td></tr>
<tr><td><code id="print.walking_path_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>

<hr>
<h2 id='profile2D'>2D Profile .</h2><span id='topic+profile2D'></span>

<h3>Description</h3>

<p>2D Profile .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile2D(angle = 0, pump = 7, vestry = FALSE, graphics = "base",
  multi.core = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile2D_+3A_angle">angle</code></td>
<td>
<p>Numeric. Angle of perspective axis in degrees.</p>
</td></tr>
<tr><td><code id="profile2D_+3A_pump">pump</code></td>
<td>
<p>Numeric. Select pump as focal point.</p>
</td></tr>
<tr><td><code id="profile2D_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="profile2D_+3A_graphics">graphics</code></td>
<td>
<p>Character. Type of graphic: &quot;base&quot; or &quot;ggplot2&quot;.</p>
</td></tr>
<tr><td><code id="profile2D_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
profile2D(angle = 30)
profile2D(angle = 30, graphics = "ggplot2")

## End(Not run)
</code></pre>

<hr>
<h2 id='profile3D'>3D Profile.</h2><span id='topic+profile3D'></span>

<h3>Description</h3>

<p>3D Profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile3D(pump.select = NULL, pump.subset = NULL, vestry = FALSE,
  drop.neg.subset = FALSE, multi.core = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile3D_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to define pump neighborhoods (i.e., the &quot;population&quot;). Negative selection possible. <code>NULL</code> selects all pumps.</p>
</td></tr>
<tr><td><code id="profile3D_+3A_pump.subset">pump.subset</code></td>
<td>
<p>Numeric. Vector of numeric pump IDs to subset from the neighborhoods defined by <code>pump.select</code>. Negative selection possible. <code>NULL</code> selects all pumps in <code>pump.select</code>.</p>
</td></tr>
<tr><td><code id="profile3D_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="profile3D_+3A_drop.neg.subset">drop.neg.subset</code></td>
<td>
<p>Logical. Drop negative subset selection</p>
</td></tr>
<tr><td><code id="profile3D_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
profile3D(pump.select = 6:7)
profile3D(pump.subset = -7)
profile3D(pump.subset = -7, drop.neg.subset = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pumpCase'>Extract numeric case IDs by pump neighborhood.</h2><span id='topic+pumpCase'></span>

<h3>Description</h3>

<p>Extract numeric case IDs by pump neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumpCase(x, case)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pumpCase_+3A_x">x</code></td>
<td>
<p>An object created by <code>neighborhoodEuclidean()</code>, <code>neighborhoodVoronoi()</code> or <code>neighborhoodWalking()</code>.</p>
</td></tr>
<tr><td><code id="pumpCase_+3A_case">case</code></td>
<td>
<p>Character. &quot;address&quot; or &quot;fatality&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list of numeric ID of cases by pump neighborhoods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pumpCase(neighborhoodEuclidean())
pumpCase(neighborhoodVoronoi())
pumpCase(neighborhoodWalking())

## End(Not run)
</code></pre>

<hr>
<h2 id='pumpData'>Compute pump coordinates.</h2><span id='topic+pumpData'></span>

<h3>Description</h3>

<p>Returns either the set of x-y coordinates for the pumps themselves or for their orthogonally projected &quot;addresses&quot; on the network of roads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumpData(vestry = FALSE, orthogonal = FALSE, multi.core = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pumpData_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="pumpData_+3A_orthogonal">orthogonal</code></td>
<td>
<p>Logical. <code>TRUE</code> returns pump &quot;addresses&quot;: the coordinates of the orthogonal projection from a pump's location onto the network of roads. <code>FALSE</code> returns pump location coordinates.</p>
</td></tr>
<tr><td><code id="pumpData_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. With Numeric, you specify the number logical cores (rounds with <code>as.integer()</code>). See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Note</h3>

<p>Note: The location of the fourteenth pump, at Hanover Square, and the &quot;correct&quot; location of the Broad Street pump are approximate. This function documents the code that generates <code><a href="#topic+pumps">pumps</a></code>, <code><a href="#topic+pumps.vestry">pumps.vestry</a></code>, <code><a href="#topic+ortho.proj.pump">ortho.proj.pump</a></code> and <code><a href="#topic+ortho.proj.pump.vestry">ortho.proj.pump.vestry</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pumpLocator">pumpLocator</a></code>
</p>

<hr>
<h2 id='pumpFatalities'>Compute fatalities by pump.</h2><span id='topic+pumpFatalities'></span>

<h3>Description</h3>

<p>Compute fatalities by pump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumpFatalities(pump.select = NULL, metric = "walking", vestry = FALSE,
  latlong = FALSE, multi.core = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pumpFatalities_+3A_pump.select">pump.select</code></td>
<td>
<p>Numeric. Pump candidates to consider. Default is <code>NULL</code>: all pumps are used. Otherwise, selection by a vector of numeric IDs: 1 to 13 for <code>pumps</code>; 1 to 14 for <code>pumps.vestry</code>. Negative selection allowed.</p>
</td></tr>
<tr><td><code id="pumpFatalities_+3A_metric">metric</code></td>
<td>
<p>Character. &quot;euclidean&quot; or &quot;walking&quot;.</p>
</td></tr>
<tr><td><code id="pumpFatalities_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry Report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="pumpFatalities_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
<tr><td><code id="pumpFatalities_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. You can also specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pumpFatalities(pump.select = -7)
pumpFatalities(latlong = TRUE)
pumpFatalities(metric = "euclidean", vestry = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pumpLocator'>Locate water pump by numerical ID.</h2><span id='topic+pumpLocator'></span>

<h3>Description</h3>

<p>Highlight selected water pump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumpLocator(id = 7, zoom = FALSE, vestry = FALSE, add.title = TRUE,
  highlight.segment = TRUE, latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pumpLocator_+3A_id">id</code></td>
<td>
<p>Numeric or Integer. With <code>vestry = TRUE</code>, a whole number between 1 and 14. With <code>vestry = FALSE</code>, a whole number between 1 and 13. See <code>cholera::pumps.vestry</code> and <code>cholera::pumps</code> for IDs and details about specific pumps.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. Positive numbers zoom in; negative numbers zoom out.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> for the 14 pumps from Vestry Report. <code>FALSE</code> for the original 13 pumps.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Include title.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_highlight.segment">highlight.segment</code></td>
<td>
<p>Logical. Highlight case's segment.</p>
</td></tr>
<tr><td><code id="pumpLocator_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pumpLocator()
pumpLocator(zoom = TRUE)
pumpLocator(14, vestry = TRUE, zoom = TRUE)
</code></pre>

<hr>
<h2 id='pumps'>Dodson and Tobler's pump data with street name.</h2><span id='topic+pumps'></span>

<h3>Description</h3>

<p>Adds and amends road locations for water pumps from John Snow's map to Dodson and Tobler's street data. The latter are available at Michael Friendly's HistData::Snow.streets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumps
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations and 4 variables that describe the pumps on Snow's map.
</p>

<dl>
<dt><code>id</code></dt><dd><p>pump number between 1 and 13</p>
</dd>
<dt><code>street</code></dt><dd><p>nearest street</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pumpLocator">pumpLocator</a></code>
</p>

<hr>
<h2 id='pumps.vestry'>Vestry report pump data.</h2><span id='topic+pumps.vestry'></span>

<h3>Description</h3>

<p>These data include the fourteenth pump, at Hanover Square, and the &quot;corrected&quot; location of the Broad Street pump that Snow includes in the second version of his map in the Vestry report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pumps.vestry
</code></pre>


<h3>Format</h3>

<p>A data frame with 14 observations and 4 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>pump number between 1 and 14</p>
</dd>
<dt><code>street</code></dt><dd><p>nearest street</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+pumpData">pumpData</a></code> documents the code for these data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pumpLocator">pumpLocator</a></code>
</p>

<hr>
<h2 id='rd.sample'>Sample of road intersections (segment endpoints).</h2><span id='topic+rd.sample'></span>

<h3>Description</h3>

<p>Sample of road intersections (segment endpoints).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rd.sample
</code></pre>


<h3>Format</h3>

<p>A list with 2 variables that list randomly re-arranges unique road intersections (segment endpoints).
</p>

<dl>
<dt><code>one</code></dt><dd><p>endpoints with 1 intersection</p>
</dd>
<dt><code>three</code></dt><dd><p>endpoints with 3 intersections</p>
</dd>
</dl>


<hr>
<h2 id='rectangle.filter'>Rectangular filter data.</h2><span id='topic+rectangle.filter'></span>

<h3>Description</h3>

<p>Coordinates to filter out frame shadow using sp::point.in.polygon().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectangle.filter
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 variables and 4 observations.
</p>

<dl>
<dt><code>x</code></dt><dd><p>longitude</p>
</dd>
<dt><code>y</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='regular.cases'>&quot;Expected&quot; cases.</h2><span id='topic+regular.cases'></span>

<h3>Description</h3>

<p>The result of using sp::spsample() and sp::Polygon() to generate 19,993 regularly spaced simulated cases within the map's borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regular.cases
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 variable that records the position of 19,993 &quot;expected&quot; cases fitted by sp::spsample().
</p>

<dl>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+simulateFatalities">simulateFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='road.segments'>Dodson and Tobler's street data transformed into road segments.</h2><span id='topic+road.segments'></span>

<h3>Description</h3>

<p>This data set transforms Dodson and Tobler's street data to give each straight line segment of a &quot;road&quot; a unique ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>road.segments
</code></pre>


<h3>Format</h3>

<p>A data frame with 658 observations and 7 variables. The data describe the straight line segments used to recreate the roads on Snow's map.
</p>

<dl>
<dt><code>street</code></dt><dd><p>numeric street ID, which range between 1 and 528</p>
</dd>
<dt><code>id</code></dt><dd><p>character segment ID</p>
</dd>
<dt><code>name</code></dt><dd><p>road name</p>
</dd>
<dt><code>x1</code></dt><dd><p>x-coordinate of first endpoint</p>
</dd>
<dt><code>y1</code></dt><dd><p>y-coordinate of first endpoint</p>
</dd>
<dt><code>x2</code></dt><dd><p>x-coordinate of second endpoint</p>
</dd>
<dt><code>y2</code></dt><dd><p>y-coordinate of second endpoint</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+roadSegments">roadSegments</a></code> documents the code for these data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roads">roads</a></code>
</p>
<p><code>vignette</code>(&quot;road.names&quot;)
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>
<p><code><a href="#topic+segmentLocator">segmentLocator</a></code>
</p>

<hr>
<h2 id='roads'>Dodson and Tobler's street data with appended road names.</h2><span id='topic+roads'></span>

<h3>Description</h3>

<p>This data set adds road names from John Snow's map to Dodson and Tobler's street data. The latter are also available from HistData::Snow.streets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roads
</code></pre>


<h3>Format</h3>

<p>A data frame with 1243 observations and 6 variables. The data describe the roads on Snow's map.
</p>

<dl>
<dt><code>street</code></dt><dd><p>street segment number, which range between 1 and 528</p>
</dd>
<dt><code>n</code></dt><dd><p>number of points in this street line segment</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>id</code></dt><dd><p>unique numeric ID</p>
</dd>
<dt><code>name</code></dt><dd><p>road name</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+road.segments">road.segments</a></code>
</p>
<p><code>vignette</code>(&quot;road.names&quot;)
</p>
<p><code><a href="#topic+streetNameLocator">streetNameLocator</a></code>
</p>
<p><code><a href="#topic+streetNumberLocator">streetNumberLocator</a></code>
</p>
<p><code><a href="#topic+segmentLocator">segmentLocator</a></code>
</p>

<hr>
<h2 id='roadSegments'>Reshape 'roads' data frame into 'road.segments' data frame.</h2><span id='topic+roadSegments'></span>

<h3>Description</h3>

<p>Used to integrate pumps and cases into road network when computing walking neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roadSegments(latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roadSegments_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Note</h3>

<p>This function documents the code that generates <code><a href="#topic+road.segments">road.segments</a></code>.
</p>

<hr>
<h2 id='segmentHighlight'>Highlight segment by ID.</h2><span id='topic+segmentHighlight'></span>

<h3>Description</h3>

<p>Highlight segment by ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentHighlight(id, highlight = TRUE, col = "red", rotate.label = FALSE,
  latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmentHighlight_+3A_id">id</code></td>
<td>
<p>Character. Segment ID: a concatenation of a street's numeric ID, a whole number between 1 and 528, and a second number to identify the segment.</p>
</td></tr>
<tr><td><code id="segmentHighlight_+3A_highlight">highlight</code></td>
<td>
<p>Logical. Color segment.</p>
</td></tr>
<tr><td><code id="segmentHighlight_+3A_col">col</code></td>
<td>
<p>Character. Highlight color.</p>
</td></tr>
<tr><td><code id="segmentHighlight_+3A_rotate.label">rotate.label</code></td>
<td>
<p>Logical. Rotate segment ID label.</p>
</td></tr>
<tr><td><code id="segmentHighlight_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics segment(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streetNameLocator("Soho Square", zoom = TRUE, highlight = FALSE)
ids &lt;- road.segments[road.segments$name == "Soho Square", "id"]
invisible(lapply(ids, function(x) segmentHighlight(x, highlight = FALSE)))
</code></pre>

<hr>
<h2 id='segmentLocator'>Plot/Locate road segment by ID.</h2><span id='topic+segmentLocator'></span>

<h3>Description</h3>

<p>Highlight selected road segment(s) and cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segmentLocator(segment.id = "216-1", zoom = TRUE, latlong = FALSE,
  cases = "address", token = "id", vestry = FALSE, add.pump = TRUE,
  add.title = TRUE, add.subtitle = TRUE, highlight = TRUE,
  distance.unit = "meter", time.unit = "second", walking.speed = 5,
  cex.text = 0.67)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segmentLocator_+3A_segment.id">segment.id</code></td>
<td>
<p>Character. A vector of segment IDs. See Note.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. Positive value zoom in. Negative values zoom out.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Longitude and latitude coordinates</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_cases">cases</code></td>
<td>
<p>Character. Cases to plot: <code>NULL</code>, &quot;address&quot; or &quot;fatality&quot;.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_token">token</code></td>
<td>
<p>Character. Cases as &quot;id&quot; or &quot;point&quot;.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_add.pump">add.pump</code></td>
<td>
<p>Logical. Include pumps.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Include title.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_add.subtitle">add.subtitle</code></td>
<td>
<p>Logical. Include subtitle.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_highlight">highlight</code></td>
<td>
<p>Logical. Highlight selected segment(s) and cases.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="segmentLocator_+3A_cex.text">cex.text</code></td>
<td>
<p>Numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Note</h3>

<p>With Dodson and Tobler's data, a street (e.g., Broad Street) is often comprised of multiple straight line segments. To identify each segment individually, an additional number is appended to form a text string ID (e.g., &quot;116-2&quot;). See <code>cholera::road.segments</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>segmentLocator("216-1")
segmentLocator("216-1", zoom = -10)
segmentLocator("216-1", latlong = TRUE, zoom = -10)
segmentLocator("216-1", distance.unit = "yard")
segmentLocator("216-1", zoom = FALSE)
</code></pre>

<hr>
<h2 id='sim.ortho.proj'>Road &quot;address&quot; of simulated (i.e., &quot;expected&quot;) cases.</h2><span id='topic+sim.ortho.proj'></span>

<h3>Description</h3>

<p>Road &quot;address&quot; of simulated (i.e., &quot;expected&quot;) cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.ortho.proj
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 variables that records the &quot;address&quot; of 19,993 simulate cases along the network of roads.
</p>

<dl>
<dt><code>case</code></dt><dd><p>numeric case ID</p>
</dd>
<dt><code>road.segment</code></dt><dd><p>&quot;address&quot; road segment</p>
</dd>
<dt><code>x.proj</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y.proj</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>dist</code></dt><dd><p>Euclidean or orthogonal distance to home road segment</p>
</dd>
<dt><code>type</code></dt><dd><p>type of projection: Euclidean (&quot;eucl&quot;) or orthogonal (&quot;ortho&quot;)</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+simulateFatalities">simulateFatalities</a></code> documents the code for these data.
</p>

<hr>
<h2 id='sim.pump.case'>List of &quot;simulated&quot; fatalities grouped by walking-distance pump neighborhood.</h2><span id='topic+sim.pump.case'></span>

<h3>Description</h3>

<p>List of &quot;simulated&quot; fatalities grouped by walking-distance pump neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.pump.case
</code></pre>


<h3>Format</h3>

<p>A list 4972 IDs spread over 13 vectors.
</p>

<dl>
<dt><code>sim.pump.case</code></dt><dd><p>numerical ID</p>
</dd>
</dl>



<h3>Note</h3>

<p><code><a href="#topic+neighborhoodWalking">neighborhoodWalking</a></code> documents the code for these data. For details, see <code>vignette</code>(&quot;pump.neighborhoods&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pumpCase(neighborhoodWalking(case.set = "expected"))

## End(Not run)
</code></pre>

<hr>
<h2 id='sim.walking.distance'>Walking distance to Broad Street Pump (#7).</h2><span id='topic+sim.walking.distance'></span>

<h3>Description</h3>

<p>Walking distance to Broad Street Pump (#7).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.walking.distance
</code></pre>


<h3>Format</h3>

<p>A data frames with 5 variables.
</p>

<dl>
<dt><code>case</code></dt><dd><p>case ID</p>
</dd>
<dt><code>pump</code></dt><dd><p>pump ID</p>
</dd>
<dt><code>pump.name</code></dt><dd><p>pump name</p>
</dd>
<dt><code>distance</code></dt><dd><p>walking distance in meters</p>
</dd>
<dt><code>time</code></dt><dd><p>walking time in seconds based on 5 km/hr walking speed</p>
</dd>
</dl>


<hr>
<h2 id='simulateFatalities'>Project simulated fatalities onto road network</h2><span id='topic+simulateFatalities'></span>

<h3>Description</h3>

<p>Places regularly spaced &quot;simulated&quot; or &quot;expected&quot; cases across the face of the map and then finds the &quot;addresses&quot; of those cases via orthogonal projection or simple proximity to road graph network. These data are used to generate &quot;expected&quot; pump neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateFatalities(recompute.regular.cases = FALSE, simulated.obs = 20000L,
  multi.core = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateFatalities_+3A_recompute.regular.cases">recompute.regular.cases</code></td>
<td>
<p>Logical. <code>TRUE</code> re-computes regular data. <code>FALSE</code> uses pre-computed data. For replication of data used in the package.</p>
</td></tr>
<tr><td><code id="simulateFatalities_+3A_simulated.obs">simulated.obs</code></td>
<td>
<p>Numeric. Number of regular cases. For use with <code>recompute.regular.cases = TRUE</code>.</p>
</td></tr>
<tr><td><code id="simulateFatalities_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. With Numeric, you specify the number logical cores (rounds with <code>as.integer()</code>). See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R data frame: <code><a href="#topic+sim.ortho.proj">sim.ortho.proj</a></code>.
</p>


<h3>Note</h3>

<p>This function is computationally intensive. With &quot;simulated.obs&quot; set to 20,000 (generating 19,993 cases). This function documents the code that generates <code><a href="#topic+sim.ortho.proj">sim.ortho.proj</a></code> and <code><a href="#topic+regular.cases">regular.cases</a></code>. In real world terms, the distance between simulated cases is approximately 6 meters.
</p>

<hr>
<h2 id='snow.neighborhood'>Snow neighborhood fatalities.</h2><span id='topic+snow.neighborhood'></span>

<h3>Description</h3>

<p>Numeric IDs of fatalities from Dodson and Tobler that fall within Snow's Broad Street pump neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snow.neighborhood
</code></pre>


<h3>Format</h3>

<p>A vector with 384 observations.
</p>

<dl>
<dt><code>snow.neighborhood</code></dt><dd><p>numeric case ID</p>
</dd>
</dl>


<hr>
<h2 id='snowColors'>Create a set of colors for pump neighborhoods.</h2><span id='topic+snowColors'></span>

<h3>Description</h3>

<p>Uses <code>RColorBrewer::brewer.pal()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowColors(vestry = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snowColors_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps in the Vestry Report. <code>FALSE</code> uses the original 13.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of colors.
</p>


<h3>Note</h3>

<p>Built with 'RColorBrewer' package.
</p>

<hr>
<h2 id='snowMap'>Plot John Snow's cholera map.</h2><span id='topic+snowMap'></span>

<h3>Description</h3>

<p>Plot John Snow's cholera map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowMap(vestry = FALSE, stacked = TRUE, add.axes_box = TRUE,
  add.cases = TRUE, add.landmarks = FALSE, add.pumps = TRUE,
  add.roads = TRUE, add.frame = TRUE, main = NA, case.col = "gray",
  case.pch = 15, latlong = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snowMap_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the map in the Vestry Report. <code>FALSE</code> uses the 13 pumps from the original map.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_stacked">stacked</code></td>
<td>
<p>Logical. Use stacked fatalities.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.axes_box">add.axes_box</code></td>
<td>
<p>Logical. Add plot axes and plot box.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.cases">add.cases</code></td>
<td>
<p>Logical. Add observed cases.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.landmarks">add.landmarks</code></td>
<td>
<p>Logical. Add landmarks.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.pumps">add.pumps</code></td>
<td>
<p>Logical. Add pumps.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.roads">add.roads</code></td>
<td>
<p>Logical. Add roads.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_add.frame">add.frame</code></td>
<td>
<p>Logical. Add map frame.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_main">main</code></td>
<td>
<p>Character. Title of graph.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_case.col">case.col</code></td>
<td>
<p>Character. Color of fatalities.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_case.pch">case.pch</code></td>
<td>
<p>Character. Color of fatalities.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
<tr><td><code id="snowMap_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Note</h3>

<p>Uses amended version of Dodson and Tobler's data included in this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
snowMap(vestry = TRUE, stacked = FALSE)
</code></pre>

<hr>
<h2 id='streetHighlight'>Highlight road by name.</h2><span id='topic+streetHighlight'></span>

<h3>Description</h3>

<p>Highlight road by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetHighlight(road.name, col = "red", lwd = 3, latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="streetHighlight_+3A_road.name">road.name</code></td>
<td>
<p>Character vector. The function tries to correct for case and remove extra spaces (includes &quot;Map Frame&quot;).</p>
</td></tr>
<tr><td><code id="streetHighlight_+3A_col">col</code></td>
<td>
<p>Character. Highlight color.</p>
</td></tr>
<tr><td><code id="streetHighlight_+3A_lwd">lwd</code></td>
<td>
<p>Numeric. Line width.</p>
</td></tr>
<tr><td><code id="streetHighlight_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics segment(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
streetHighlight("Broad Street")
</code></pre>

<hr>
<h2 id='streetLength'>Compute length of selected street.</h2><span id='topic+streetLength'></span>

<h3>Description</h3>

<p>Compute length of selected street.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetLength(road = "Oxford Street", distance.unit = "meter",
  latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="streetLength_+3A_road">road</code></td>
<td>
<p>Character or Numeric. Road name or number. For names, the function tries to correct for case and to remove extra spaces.</p>
</td></tr>
<tr><td><code id="streetLength_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
<tr><td><code id="streetLength_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R vector of length one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streetLength("Oxford Street")
streetLength("oxford street")
streetLength("oxford street", distance.unit = "yard")
</code></pre>

<hr>
<h2 id='streetNameLocator'>Locate street(s) by name(s).</h2><span id='topic+streetNameLocator'></span>

<h3>Description</h3>

<p>Highlight selected road(s) and cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetNameLocator(street.name = "Broad Street", zoom = TRUE,
  latlong = FALSE, cases = "address", token = "id", vestry = FALSE,
  add.pump = TRUE, add.title = TRUE, add.subtitle = TRUE,
  highlight = TRUE, distance.unit = "meter", time.unit = "second",
  walking.speed = 5, cex.text = 0.67)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="streetNameLocator_+3A_street.name">street.name</code></td>
<td>
<p>Character. A street name or vector of street names (e.g., &quot;Broad Street&quot;, &quot;Poland Street&quot;).</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. Positive numbers zoom in; negative numbers zoom out.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Longitude and latitude coordinates</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_cases">cases</code></td>
<td>
<p>Character. Cases to plot: <code>NULL</code>, &quot;address&quot; or &quot;fatality&quot;.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_token">token</code></td>
<td>
<p>Character. Cases as &quot;id&quot; or &quot;point&quot;.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_add.pump">add.pump</code></td>
<td>
<p>Logical. Include pumps.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Include title.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_add.subtitle">add.subtitle</code></td>
<td>
<p>Logical. Include subtitle.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_highlight">highlight</code></td>
<td>
<p>Logical. Highlight selected segment(s) and cases.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="streetNameLocator_+3A_cex.text">cex.text</code></td>
<td>
<p>Numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Note</h3>

<p>See <code>streetNames()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streetNameLocator("broad street")
streetNameLocator("Broad Street", zoom = -10)
streetNameLocator("Broad Street", latlong = TRUE, zoom = -10)
streetNameLocator("Broad Street", distance.unit = "yard")
streetNameLocator("Broad Street", zoom = FALSE)
</code></pre>

<hr>
<h2 id='streetNames'>Street names (alphabetized).</h2><span id='topic+streetNames'></span>

<h3>Description</h3>

<p>Unique road names from Snow's cholera map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetNames()
</code></pre>


<h3>Value</h3>

<p>An R character vector.
</p>


<h3>Note</h3>

<p>See vignette(&quot;roads&quot;), and roads and road.segment data frames.
</p>

<hr>
<h2 id='streetNumberLocator'>Locate street by its numerical ID.</h2><span id='topic+streetNumberLocator'></span>

<h3>Description</h3>

<p>Highlight selected road segment(s) and cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streetNumberLocator(street.number = 216, zoom = TRUE, latlong = FALSE,
  cases = "address", token = "id", vestry = FALSE, add.pump = TRUE,
  add.title = TRUE, add.subtitle = TRUE, highlight = TRUE,
  distance.unit = "meter", time.unit = "second", walking.speed = 5,
  cex.text = 0.67)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="streetNumberLocator_+3A_street.number">street.number</code></td>
<td>
<p>Character. A vector of segment IDs. See Note.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_zoom">zoom</code></td>
<td>
<p>Logical or Numeric. Positive numbers zoom in; negative numbers zoom out.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Longitude and latitude coordinates</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_cases">cases</code></td>
<td>
<p>Character. Cases to plot: <code>NULL</code>, &quot;address&quot; or &quot;fatality&quot;.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_token">token</code></td>
<td>
<p>Character. Cases as &quot;id&quot; or &quot;point&quot;.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the Vestry report. <code>FALSE</code> uses the 13 in the original map.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_add.pump">add.pump</code></td>
<td>
<p>Logical. Include pumps.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_add.title">add.title</code></td>
<td>
<p>Logical. Include title.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_add.subtitle">add.subtitle</code></td>
<td>
<p>Logical. Include subtitle.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_highlight">highlight</code></td>
<td>
<p>Logical. Highlight selected segment(s) and cases.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot;, &quot;yard&quot; or &quot;native&quot;. &quot;native&quot; returns the map's native scale. See <code>vignette("roads")</code> for information on conversion.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="streetNumberLocator_+3A_cex.text">cex.text</code></td>
<td>
<p>Numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base R graphics plot.
</p>


<h3>Note</h3>

<p>See <code>cholera::roads</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streetNumberLocator(216)
streetNumberLocator(216, zoom = -10)
streetNumberLocator(216, latlong = TRUE, zoom = -10)
streetNumberLocator(216, distance.unit = "yard")
streetNumberLocator(216, zoom = FALSE)
</code></pre>

<hr>
<h2 id='summary.euclidean'>Summary method for neighborhoodEuclidean().</h2><span id='topic+summary.euclidean'></span>

<h3>Description</h3>

<p>Return computed counts for Euclidean neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'euclidean'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.euclidean_+3A_object">object</code></td>
<td>
<p>Object. An object of class &quot;euclidean&quot; created by <code>neighborhoodEuclidean()</code>.</p>
</td></tr>
<tr><td><code id="summary.euclidean_+3A_...">...</code></td>
<td>
<p>Additional parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of counts by neighborhood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary(neighborhoodEuclidean())

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.voronoi_nominal'>Summary method for voronoiNominal().</h2><span id='topic+summary.voronoi_nominal'></span>

<h3>Description</h3>

<p>Return computed counts for Voronoi neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'voronoi_nominal'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.voronoi_nominal_+3A_object">object</code></td>
<td>
<p>Object. An object of class &quot;voronoi&quot; created by <code>voronoiNominal()</code>.</p>
</td></tr>
<tr><td><code id="summary.voronoi_nominal_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of counts by neighborhood.
</p>


<h3>See Also</h3>

<p><code>addVoronoi()</code>
<code>plot.voronoi()</code>
</p>

<hr>
<h2 id='tanakaContourPlot'>Tanaka contour plot.</h2><span id='topic+tanakaContourPlot'></span>

<h3>Description</h3>

<p>Soho elevation data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tanakaContourPlot(add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tanakaContourPlot_+3A_add">add</code></td>
<td>
<p>Logical. Add to existing plot.</p>
</td></tr>
</table>

<hr>
<h2 id='timeSeries'>Aggregate time series fatality data from the Vestry report.</h2><span id='topic+timeSeries'></span>

<h3>Description</h3>

<p>Aggregate time series fatality data from the Vestry report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeSeries(vestry = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeSeries_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> returns the data from the Vestry committee (Appendix B, p. 175). <code>FALSE</code> returns John Snow's contribution to the report (p.117).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A R list with two objects: &quot;data&quot; and &quot;source&quot; (&quot;snow&quot; or &quot;vestry&quot;).
</p>

<ul>
<li><p><code>date</code>: Calendar date.
</p>
</li>
<li><p><code>day</code>: Day of the week.
</p>
</li>
<li><p><code>deaths</code>: Measure of fatality.
</p>
</li>
<li><p><code>fatal.attacks</code>: Measure of fatality.
</p>
</li></ul>



<h3>Note</h3>

<p>The &quot;snow&quot; data appears on p. 117 of the report; the &quot;vestry&quot; data appear in Appendix B on p.175.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.time_series">plot.time_series</a></code>, <code><a href="#topic+print.time_series">print.time_series</a></code>, <code>vignette("time.series")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeSeries(vestry = TRUE)
plot(timeSeries())
</code></pre>

<hr>
<h2 id='unstackFatalities'>Unstack &quot;stacks&quot; in Snow's cholera map.</h2><span id='topic+unstackFatalities'></span>

<h3>Description</h3>

<p>Unstacks fatalities data by 1) assigning the coordinates of the base case to all cases in a stack and 2) setting the base case as an &quot;address&quot; and making the number of fatalities an attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unstackFatalities(multi.core = FALSE, dev.mode = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unstackFatalities_+3A_multi.core">multi.core</code></td>
<td>
<p>Logical or Numeric. <code>TRUE</code> uses <code>parallel::detectCores()</code>. <code>FALSE</code> uses one, single core. With Numeric, you specify the number logical cores. See <code>vignette("Parallelization")</code> for details.</p>
</td></tr>
<tr><td><code id="unstackFatalities_+3A_dev.mode">dev.mode</code></td>
<td>
<p>Logical. Development mode uses parallel::parLapply().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list.
</p>


<h3>Note</h3>

<p>This function documents the code that generates <code><a href="#topic+anchor.case">anchor.case</a></code>,  <code><a href="#topic+fatalities.address">fatalities.address</a></code>, <code><a href="#topic+fatalities.unstacked">fatalities.unstacked</a></code> and <code><a href="#topic+ortho.proj">ortho.proj</a></code>.
</p>


<h3>See Also</h3>

<p><code>vignette("unstacking.fatalities")</code>
</p>

<hr>
<h2 id='voronoi.polygons'>Coordinates of Voronoi polygon vertices for original map.</h2><span id='topic+voronoi.polygons'></span>

<h3>Description</h3>

<p>Coordinates of Voronoi polygon vertices for original map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.polygons
</code></pre>


<h3>Format</h3>

<p>A list of 13 data frames frames with 5 variables.
</p>

<dl>
<dt><code>vertex</code></dt><dd><p>vertex ID</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='voronoi.polygons.vestry'>Coordinates of Voronoi polygon vertices for Vestry Report map.</h2><span id='topic+voronoi.polygons.vestry'></span>

<h3>Description</h3>

<p>Coordinates of Voronoi polygon vertices for Vestry Report map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi.polygons.vestry
</code></pre>


<h3>Format</h3>

<p>A list of 14 data frames frames with 5 variables.
</p>

<dl>
<dt><code>vertex</code></dt><dd><p>vertex ID</p>
</dd>
<dt><code>x</code></dt><dd><p>x-coordinate</p>
</dd>
<dt><code>y</code></dt><dd><p>y-coordinate</p>
</dd>
<dt><code>lon</code></dt><dd><p>longitude</p>
</dd>
<dt><code>lat</code></dt><dd><p>latitude</p>
</dd>
</dl>


<hr>
<h2 id='voronoiPolygons'>Extract vertices of Delaunay triangles and Dirichelet (Voronoi) tiles.</h2><span id='topic+voronoiPolygons'></span>

<h3>Description</h3>

<p>For construction and plotting of Delaunay and Voronoi polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoiPolygons(sites, rw.data = NULL, rw = NULL, type = "tiles",
  output = "vertices", latlong = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voronoiPolygons_+3A_sites">sites</code></td>
<td>
<p>Object. Data frame of sites to compute Delaunay triangulation and Dirichelet (Voronoi) tessellation with variables &quot;x&quot; and &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_rw.data">rw.data</code></td>
<td>
<p>Object. Data frame of secondary source of data to set the rectangular window or bounding box: observations, cases, etc. with variables &quot;x&quot; and &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_rw">rw</code></td>
<td>
<p>Numeric. Alternative to rw.data: vector of corners to define the rectangular window or bounding box: xmin, xmax, ymin, ymax.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_type">type</code></td>
<td>
<p>Character. &quot;tiles&quot; (tessellation) or &quot;triangles&quot; (triangulation) vertices.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_output">output</code></td>
<td>
<p>Character. &quot;vertices&quot; or &quot;polygons&quot;. &quot;vertices&quot; re &quot;polygons&quot; will draw base R polygons() to an existing plot.</p>
</td></tr>
<tr><td><code id="voronoiPolygons_+3A_latlong">latlong</code></td>
<td>
<p>Logical. Use estimated longitude and latitude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list of data frames or base R graphics polygon()'s'.
</p>


<h3>Note</h3>

<p>This function relies on the 'deldir' package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snowMap()
voronoiPolygons(pumps, output = "polygons")

snowMap()
voronoiPolygons(pumps, roads, output = "polygons")

snowMap()
voronoiPolygons(pumps, roads, type = "triangles", output = "polygons")

vertices &lt;- voronoiPolygons(pumps, roads)
snow.colors &lt;- grDevices::adjustcolor(snowColors(), alpha.f = 1/3)
snowMap(add.cases = FALSE)
invisible(lapply(seq_along(vertices), function(i) {
  polygon(vertices[[i]], col = snow.colors[[i]])
}))
</code></pre>

<hr>
<h2 id='walkingPath'>Compute walking path from case/landmark to nearest or selected pump.</h2><span id='topic+walkingPath'></span>

<h3>Description</h3>

<p>Compute walking path from case/landmark to nearest or selected pump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walkingPath(origin = 1, destination = NULL, type = "case-pump",
  vestry = FALSE, latlong = FALSE, case.set = "observed",
  location = "nominal", weighted = TRUE, distance.unit = "meter",
  time.unit = "second", walking.speed = 5, include.landmarks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="walkingPath_+3A_origin">origin</code></td>
<td>
<p>Numeric. Vector of origin(s) (numeric or case/landmark name).</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_destination">destination</code></td>
<td>
<p>Numeric. Vector of destination(s) (numeric or landmark/pump name).</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_type">type</code></td>
<td>
<p>Character. Path case to pump. FALSE is all other combinations of cases, landmarks and pumps.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_vestry">vestry</code></td>
<td>
<p>Logical. <code>TRUE</code> uses the 14 pumps from the map in the Vestry Report. <code>FALSE</code> uses the 13 pumps from the original map.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_latlong">latlong</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_case.set">case.set</code></td>
<td>
<p>Character. &quot;observed&quot; or &quot;expected&quot;.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_location">location</code></td>
<td>
<p>Character. For cases and pumps. &quot;anchor, &quot;fatality&quot; or &quot;orthogonal.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_weighted">weighted</code></td>
<td>
<p>Logical. <code>TRUE</code> computes shortest path in terms of road length. <code>FALSE</code> computes shortest path in terms of the number of nodes.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_distance.unit">distance.unit</code></td>
<td>
<p>Character. Unit of distance: &quot;meter&quot; or &quot;yard&quot;.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_time.unit">time.unit</code></td>
<td>
<p>Character. &quot;hour&quot;, &quot;minute&quot;, or &quot;second&quot;.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_walking.speed">walking.speed</code></td>
<td>
<p>Numeric. Walking speed in km/hr.</p>
</td></tr>
<tr><td><code id="walkingPath_+3A_include.landmarks">include.landmarks</code></td>
<td>
<p>Logical. Include landmarks as cases.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
