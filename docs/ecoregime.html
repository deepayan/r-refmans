<!DOCTYPE html><html><head><title>Help for package ecoregime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ecoregime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ecoregime-package'><p>ecoregime: Analysis of Ecological Dynamic Regimes</p></a></li>
<li><a href='#define_retra'><p>Define representative trajectories from trajectory features</p></a></li>
<li><a href='#dist_edr'><p>Dissimilarities between Ecological Dynamic Regimes</p></a></li>
<li><a href='#EDR_data'><p>Ecological Dynamic Regime data</p></a></li>
<li><a href='#EDR_metrics'><p>Metrics of Ecological Dynamic Regimes</p></a></li>
<li><a href='#plot.RETRA'><p>Plot representative trajectories of Ecological Dynamic Regimes</p></a></li>
<li><a href='#retra_edr'><p>Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR)</p></a></li>
<li><a href='#summary.RETRA'><p>Summarize representative trajectories</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis of Ecological Dynamic Regimes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for implementing the Ecological Dynamic Regime framework 
    (Sánchez-Pinillos et al., 2023 &lt;<a href="https://doi.org/10.1002%2Fecm.1589">doi:10.1002/ecm.1589</a>&gt;) to 
    characterize and compare groups of ecological trajectories in multidimensional 
    spaces defined by state variables. The package includes the RETRA-EDR algorithm 
    to identify representative trajectories, functions to generate, summarize, 
    and visualize representative trajectories, and several metrics to quantify 
    the distribution and heterogeneity of trajectories in an ecological dynamic 
    regime and quantify the dissimilarity between two or more ecological dynamic 
    regimes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mspinillos.github.io/ecoregime/">https://mspinillos.github.io/ecoregime/</a>,
<a href="https://github.com/MSPinillos/ecoregime">https://github.com/MSPinillos/ecoregime</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MSPinillos/ecoregime/issues">https://github.com/MSPinillos/ecoregime/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, data.table, ecotraj, GDAtools, graphics, methods, shape,
smacof, stats, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, primer, RColorBrewer, rmarkdown, testthat (&ge; 3.0.0),
vegan</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-10 16:50:23 UTC; martina.sanchez</td>
</tr>
<tr>
<td>Author:</td>
<td>Martina Sánchez-Pinillos
    <a href="https://orcid.org/0000-0002-1499-4507"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martina Sánchez-Pinillos &lt;martina.sanchez.pinillos@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-10 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ecoregime-package'>ecoregime: Analysis of Ecological Dynamic Regimes</h2><span id='topic+ecoregime'></span><span id='topic+ecoregime-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A toolbox for implementing the Ecological Dynamic Regime framework (Sánchez-Pinillos et al., 2023 <a href="https://doi.org/10.1002/ecm.1589">doi:10.1002/ecm.1589</a>) to characterize and compare groups of ecological trajectories in multidimensional spaces defined by state variables. The package includes the RETRA-EDR algorithm to identify representative trajectories, functions to generate, summarize, and visualize representative trajectories, and several metrics to quantify the distribution and heterogeneity of trajectories in an ecological dynamic regime and quantify the dissimilarity between two or more ecological dynamic regimes.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martina Sánchez-Pinillos <a href="mailto:martina.sanchez.pinillos@gmail.com">martina.sanchez.pinillos@gmail.com</a> (<a href="https://orcid.org/0000-0002-1499-4507">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mspinillos.github.io/ecoregime/">https://mspinillos.github.io/ecoregime/</a>
</p>
</li>
<li> <p><a href="https://github.com/MSPinillos/ecoregime">https://github.com/MSPinillos/ecoregime</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/MSPinillos/ecoregime/issues">https://github.com/MSPinillos/ecoregime/issues</a>
</p>
</li></ul>


<hr>
<h2 id='define_retra'>Define representative trajectories from trajectory features</h2><span id='topic+define_retra'></span>

<h3>Description</h3>

<p>Generate an object of class <code>RETRA</code> from a data frame containing trajectory
states to define representative trajectories in Ecological Dynamic Regimes (EDR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_retra(data, d = NULL, trajectories = NULL, states = NULL, retra = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_retra_+3A_data">data</code></td>
<td>
<p>A data frame of four columns indicating identifiers for the new
representative trajectories, the individual trajectories or sites to which the
states belong, the order of the states in the individual trajectories, and the
identifier of the representative trajectory to which the states belong (only
if <code>!is.null(retra)</code>). Alternatively, 'data' can be a vector or a list of
character vectors including the sequence of segments forming the new
representative trajectory. See Details for further clarifications to define
<code>data</code>.</p>
</td></tr>
<tr><td><code id="define_retra_+3A_d">d</code></td>
<td>
<p>Either a symmetric matrix or an object of class <code><a href="stats.html#topic+dist">dist</a></code> containing the
dissimilarities between each pair of states of all trajectories in the EDR.
If <code>NULL</code> (default), the length (<code>Length</code>) of the new representative trajectories
and the distances between states of different trajectories or sites (<code>Link_distance</code>)
are not calculated.</p>
</td></tr>
<tr><td><code id="define_retra_+3A_trajectories">trajectories</code></td>
<td>
<p>Only needed if <code>!is.null(d)</code>. Vector indicating the
trajectory or site to which each state in <code>d</code> belongs.</p>
</td></tr>
<tr><td><code id="define_retra_+3A_states">states</code></td>
<td>
<p>Only needed if <code>!is.null(d)</code>. Vector of integers indicating the
order of the states in <code>d</code> for each trajectory.</p>
</td></tr>
<tr><td><code id="define_retra_+3A_retra">retra</code></td>
<td>
<p>Object of class <code>RETRA</code> returned from <code><a href="#topic+retra_edr">retra_edr()</a></code>. If <code>NULL</code>
(default), <code>minSegs</code> and <code>Seg_density</code> are not provided for the new representative
trajectories.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each representative trajectory returned by the function <code><a href="#topic+retra_edr">retra_edr()</a></code> corresponds
to the longest sequence of representative segments that can be linked according
to the criteria defined in the RETRA-EDR algorithm (Sánchez-Pinillos et al.,
2023). One could be interested in splitting the obtained trajectories, considering
only a fraction of the returned trajectories, or defining representative
trajectories following different criteria than those in RETRA-EDR.
The function <code>define_retra()</code> allows generating an object of class <code>RETRA</code> that
can be used in other functions of <code>ecoregime</code> (e.g., <code><a href="base.html#topic+plot">plot()</a></code>).
</p>
<p>For that, it is necessary to provide information about the set of segments or
trajectory states that form the new representative trajectory through the
argument <code>data</code>:
</p>

<ul>
<li> <p><code>data</code> can be defined as a <strong>data frame</strong> with as many rows as the number of
states in all representative trajectories and the following columns:
</p>

<dl>
<dt><code>RT</code></dt><dd><p>A string indicating the identifier of the new representative trajectories.
Each identifier needs to appear as many times as the number of states forming
each representative trajectory.</p>
</dd>
<dt><code>RT_traj</code></dt><dd><p>A vector indicating the individual trajectories in the EDR to which
each state of the new representative trajectory belongs.</p>
</dd>
<dt><code>RT_states</code></dt><dd><p>A vector of integers indicating the identifier of the states
forming the new representative trajectories. Each integer must refer to the order
of the states in the individual trajectories of the EDR to which they belong.</p>
</dd>
<dt><code>RT_retra</code></dt><dd><p>Only if the new trajectories are defined from representative
trajectories returned by <code><a href="#topic+retra_edr">retra_edr()</a></code> (when <code>!is.null(retra)</code>). A vector of strings
indicating the representative trajectory in <code>retra</code> to which each state belongs.</p>
</dd>
</dl>

</li>
<li><p> Alternatively, <code>data</code> can be defined as either a <strong>vector</strong> (if there is one
representative trajectory) or a <strong>list of character vectors</strong> (with as many
elements as the number of representative trajectories desired) containing the
sequence of segments of the representative trajectories. In any case, each
segment needs to be specified in the form <code>traj[st1-st2]</code>, where <code>traj</code> is the
identifier of the original trajectory to which the segment belongs and <code>st1</code>
and <code>st2</code> are identifiers of the initial and final states defining the segment.
If only one state of an individual trajectory is considered to form the
representative trajectory, the corresponding segment needs to be defined as
<code>traj[st-st]</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>RETRA</code>, which is a list of length equal to the number of
representative trajectories defined. For each trajectory, the following
information is returned:
</p>

<dl>
<dt><code>minSegs</code></dt><dd><p>Value of the <code>minSegs</code> parameter used in <code><a href="#topic+retra_edr">retra_edr()</a></code>. If <code>retra</code>
is <code>NULL</code>, <code>minSegs</code> = <code>NA</code>.</p>
</dd>
<dt><code>Segments</code></dt><dd><p>Vector of strings including the sequence of segments forming the
representative trajectory. Each segment is identified by a string of the form
<code>traj[st1-st2]</code>, where <code>traj</code> is the identifier of the original trajectory to
which the segment belongs and <code>st1</code> and <code>st2</code> are identifiers of the initial
and final states defining the segment. The same format <code>traj[st1-st2]</code> is
maintained when only one state of an individual trajectory is considered
(<code>st1</code> = <code>st2</code>). <code>traj</code>, <code>st1</code>, and <code>st2</code> are recycled from <code>data</code>.</p>
</dd>
<dt><code>Size</code></dt><dd><p>Integer indicating the number of states forming the representative
trajectory.</p>
</dd>
<dt><code>Length</code></dt><dd><p>Numeric value indicating the length of the representative trajectory,
calculated as the sum of the dissimilarities in <code>d</code> between every pair of
consecutive states. If <code>d</code> is <code>NULL</code>, <code>Length</code> = <code>NA</code>.</p>
</dd>
<dt><code>Link_distance</code></dt><dd><p>Data frame of two columns indicating artificial links between
two segments (<code>Link</code>) and the dissimilarity between the connected states
(<code>Distance</code>). When two representative segments are linked by a common state or
by two consecutive states of the same trajectory, the link distance is zero or
equal to the length of a real segment, respectively. In both cases, the link
is not considered in the returned data frame. If <code>d</code> is <code>NULL</code>, <code>Link_distance</code>
= <code>NA</code>.</p>
</dd>
<dt><code>Seg_density</code></dt><dd><p>Data frame of two columns and one row for each representative
segment. <code>Density</code> contains the number of segments in the EDR that is represented
by each segment of the representative trajectory. <code>kdTree_depth</code> contains the
depth of the k-d tree for each leaf represented by the corresponding segment.
That is, the number of partitions of the ordination space until finding a region
with <code>minSegs</code> segments or less. If <code>retra</code> is <code>NULL</code>, <code>Seg_density</code> = <code>NA</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martina Sánchez-Pinillos
</p>


<h3>See Also</h3>

<p><code><a href="#topic+retra_edr">retra_edr()</a></code> for identifying representative trajectories in EDRs through
RETRA-EDR.
</p>
<p><code><a href="base.html#topic+summary">summary()</a></code> for summarizing the characteristics of the representative
trajectories.
</p>
<p><code><a href="base.html#topic+plot">plot()</a></code> for plotting representative trajectories in an ordination space
representing the state space of the EDR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 -----------------------------------------------------------------
# Define representative trajectories from the outputs of retra_edr().

# Identify representative trajectories using retra_edr()
d &lt;- EDR_data$EDR1$state_dissim
trajectories &lt;- EDR_data$EDR1$abundance$traj
states &lt;- EDR_data$EDR1$abundance$state
old_retra &lt;- retra_edr(d = d, trajectories = trajectories, states = states,
                       minSegs = 5)

# retra_edr() returns three representative trajectories
old_retra

# Keep the last five segments of trajectories "T2" and "T3"
selected_segs &lt;- old_retra$T2$Segments[4:length(old_retra$T2$Segments)]

# Identify the individual trajectories for each state...
selected_segs
selected_traj &lt;- rep(c(15, 4, 4, 1, 14), each = 2)

# ...and the states (in the same order as the representative trajectory).
selected_states &lt;- c(1, 2, 2, 3, 3, 4, 1, 2, 2, 3)

# Generate the data frame with the format indicated in the documentation
df &lt;- data.frame(RT = rep("A", length(selected_states)),
                 RT_traj = selected_traj,
                 RT_states = as.integer(selected_states),
                 RT_retra = rep("T2", length(selected_states)))

# Remove duplicates (trajectory 4, state 3)
df &lt;- unique(df)

# Generate a RETRA object using define_retra()
new_retra &lt;- define_retra(data = df,
                          d = d,
                          trajectories = trajectories,
                          states = states,
                          retra = old_retra)

# Example 2 -----------------------------------------------------------------
# Define representative trajectories from sequences of segments

# Select all segments in T1, split T2 into two new trajectories, and include
# a trajectory composed of states belonging to trajectories "5", "6", and "7"
data &lt;- list(old_retra$T1$Segments,
             old_retra$T2$Segments[1:3],
             old_retra$T2$Segments[4:8],
             c("5[1-2]", "5[2-3]", "7[4-4]", "6[4-5]"))

# Generate a RETRA object using define_retra()
new_retra &lt;- define_retra(data = data,
                          d = d,
                          trajectories = trajectories,
                          states = states,
                          retra = old_retra)

# Example 3 -----------------------------------------------------------------
# Define two representative trajectories from individual trajectories in EDR1.

# Define trajectory "A" from states in trajectories 3 and 4
data_A &lt;- data.frame(RT = rep("A", 4),
                     RT_traj = c(3, 3, 4, 4),
                     RT_states = c(1:2, 4:5))

# Define trajectory "B" from states in trajectories 5, 6, and 7
data_B &lt;- data.frame(RT = rep("B", 5),
                     RT_traj = c(5, 5, 7, 6, 6),
                     RT_states = c(1, 2, 4, 4, 5))

# Compile data for both trajectories in a data frame
df &lt;- rbind(data_A, data_B)
df$RT_states &lt;- as.integer(df$RT_states)

# Generate a RETRA object using define_retra()
new_retra &lt;- define_retra(data = df, d = EDR_data$EDR1$state_dissim,
                          trajectories = EDR_data$EDR1$abundance$traj,
                          states = EDR_data$EDR1$abundance$state)


</code></pre>

<hr>
<h2 id='dist_edr'>Dissimilarities between Ecological Dynamic Regimes</h2><span id='topic+dist_edr'></span>

<h3>Description</h3>

<p>Generate a matrix containing dissimilarities between one or more pairs of
Ecological Dynamic Regimes (EDR). <code>dist_edr()</code> computes different dissimilarity
indices, all of them based on the dissimilarities between the trajectories of
two EDRs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_edr(
  d,
  d.type,
  trajectories = NULL,
  states = NULL,
  edr,
  metric = "dDR",
  symmetrize = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_edr_+3A_d">d</code></td>
<td>
<p>Symmetric matrix or object of class <code><a href="stats.html#topic+dist">dist</a></code> containing the
dissimilarities between each pair of states of all trajectories in the EDR or
the dissimilarities between each pair of trajectories.</p>
</td></tr>
<tr><td><code id="dist_edr_+3A_d.type">d.type</code></td>
<td>
<p>One of <code>"dStates"</code> (if <code>d</code> contains state dissimilarities) or
<code>"dTraj"</code> (if <code>d</code> contains trajectory dissimilarities).</p>
</td></tr>
<tr><td><code id="dist_edr_+3A_trajectories">trajectories</code></td>
<td>
<p>Only if <code>d.type</code> = <code>"dStates"</code>. Vector indicating the
trajectory or site corresponding to each entry in <code>d</code>.</p>
</td></tr>
<tr><td><code id="dist_edr_+3A_states">states</code></td>
<td>
<p>Only if <code>d.type</code> = <code>"dStates"</code>. Vector of integers indicating the
order of the states in <code>d</code> for each trajectory.</p>
</td></tr>
<tr><td><code id="dist_edr_+3A_edr">edr</code></td>
<td>
<p>Vector indicating the EDR to which each trajectory/state in <code>d</code> belongs.</p>
</td></tr>
<tr><td><code id="dist_edr_+3A_metric">metric</code></td>
<td>
<p>A string indicating the dissimilarity index to be used: <code>"dDR"</code>
(default), <code>"minDist"</code>, <code>"maxDist"</code>.</p>
</td></tr>
<tr><td><code id="dist_edr_+3A_symmetrize">symmetrize</code></td>
<td>
<p>String naming the function to be called to symmetrize the
resulting dissimilarity matrix (<code>"mean"</code>, <code>"min"</code>, <code style="white-space: pre;">&#8288;"max&#8288;</code>, <code>"lower"</code>, <code>"upper"</code>).
If <code>NULL</code> (default), the matrix is not symmetrized.</p>
</td></tr>
<tr><td><code id="dist_edr_+3A_...">...</code></td>
<td>
<p>Only if <code>d.type</code> = <code>"dStates"</code>. Further arguments to calculate
trajectory dissimilarities. See <code><a href="ecotraj.html#topic+trajectorymetrics">ecotraj::trajectoryDistances()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented metrics are:
</p>

<dl>
<dt><code>"dDR"</code></dt><dd>
<p><code class="reqn">
d_{DR}(R_1, R_2) = \frac{1}{n} \sum_{i=1}^{n} d_{TR}(T_{1i}, R_2)
</code>
</p>
</dd>
<dt><code>"minDist"</code></dt><dd>
<p><code class="reqn">
d_{DRmin}(R_1, R_2) = \min_{i=1}^{n} \{ d_{TR}(T_{1i}, R_2) \}
</code>
</p>
</dd>
<dt><code>"maxDist"</code></dt><dd>
<p><code class="reqn">
d_{DRmax}(R_1, R_2) = \max_{i=1}^{n} \{ d_{TR}(T_{1i}, R_2) \}
</code>
</p>
</dd>
</dl>

<p>where <code class="reqn">R_1</code> and <code class="reqn">R_2</code> are two EDRs composed of <code class="reqn">n</code> and <code class="reqn">m</code>
ecological trajectories, respectively, and <code class="reqn">d_{TR}(T_{1i}, R_2)</code> is the
dissimilarity between the trajectory <code class="reqn">T_{1i}</code> of <code class="reqn">R_1</code> and the closest
trajectory of <code class="reqn">R_2</code>:
</p>
<p><code class="reqn">
d_{TR}(T_{1i}, R_2) = \min\{d_T(T_{1i}, T_{21}), ... , d_T(T_{1i}, T_{2m})\}
</code>
</p>
<p>The metrics calculated are not necessarily symmetric. That is, <code class="reqn">d_{DR}(R_1, R_2)</code>
is not necessarily equal to <code class="reqn">d_{DR}(R_2, R_1)</code>. It is possible to symmetrize
the returned matrix by indicating the name of the function to be used in <code>symmetrize</code>:
</p>

<dl>
<dt><code>"mean"</code></dt><dd>
<p><code class="reqn">
d_{DRsym} = \frac{d_{DR}(R_1, R_2) + d_{DR}(R_2, R_1)}{2}
</code>
</p>
</dd>
<dt><code>"min"</code></dt><dd>
<p><code class="reqn">
d_{DRsym} = \min\{d_{DR}(R_1, R_2), d_{DR}(R_2, R_1)\}
</code>
</p>
</dd>
<dt><code>"max"</code></dt><dd>
<p><code class="reqn">
d_{DRsym} = \max\{d_{DR}(R_1, R_2), d_{DR}(R_2, R_1)\}
</code>
</p>
</dd>
<dt><code>"lower"</code></dt><dd>
<p>The lower triangular part of the dissimilarity matrix is used.
</p>
</dd>
<dt><code>"upper"</code></dt><dd>
<p>The upper triangular part of the dissimilarity matrix is used.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>Matrix including the dissimilarities between every pair of EDRs.
</p>


<h3>Author(s)</h3>

<p>Martina Sánchez-Pinillos
</p>


<h3>References</h3>

<p>Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic
Regimes: Identification, characterization, and comparison. <em>Ecological Monographs</em>.
<a href="doi:10.1002/ecm.1589">doi:10.1002/ecm.1589</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load species abundances and compile in a data frame
abun1 &lt;- EDR_data$EDR1$abundance
abun2 &lt;- EDR_data$EDR2$abundance
abun3 &lt;- EDR_data$EDR3$abundance
abun &lt;- data.frame(rbind(abun1, abun2, abun3))

# Define row names in abun to keep the reference of the EDR, trajectory, and
# state
row.names(abun) &lt;- paste0(abun$EDR, "_", abun$traj, "_", abun$state)

# Calculate dissimilarities between every pair of states
# For example, Bray-Curtis index
dStates &lt;- vegan::vegdist(abun[, -c(1, 2, 3)], method = "bray")

# Use the labels in dStates to define the trajectories to which each state
# belongs
id_traj &lt;- vapply(strsplit(labels(dStates), "_"), function(x){
                    paste0(x[1], "_", x[2])
                }, character(1))
id_state &lt;- vapply(strsplit(labels(dStates), "_"), function(x){
                    as.integer(x[3])
                }, integer(1))
id_edr &lt;- vapply(strsplit(labels(dStates), "_"), function(x){
                    paste0("EDR", x[1])
                }, character(1))

# Calculate dissimilarities between every pair of trajectories
dTraj &lt;- ecotraj::trajectoryDistances(d = dStates, sites = id_traj,
                                      surveys = id_state,
                                      distance.type = "DSPD")

# Use labels in dTraj to identify EDRs
id_edr_traj &lt;- vapply(strsplit(labels(dTraj), "_"), function(x){
                    paste0("EDR", x[1])
                }, character(1))

# Compute dissimilarities between EDRs:
# 1.1) without symmetrizing the matrix and using state dissimilarities
dEDR &lt;- dist_edr(d = dStates, d.type = "dStates",
                 trajectories = id_traj, states = id_state, edr = id_edr,
                 metric = "dDR", symmetrize = NULL)

# 1.2) without symmetrizing the matrix and using trajectory dissimilarities
dEDR &lt;- dist_edr(d = dTraj, d.type = "dTraj", edr = id_edr_traj,
                 metric = "dDR", symmetrize = NULL)

# 2) symmetrizing by averaging elements on and below the diagonal
dEDR &lt;- dist_edr(d = dTraj, d.type = "dTraj", edr = id_edr_traj,
                 metric = "dDR", symmetrize = "mean")

</code></pre>

<hr>
<h2 id='EDR_data'>Ecological Dynamic Regime data</h2><span id='topic+EDR_data'></span>

<h3>Description</h3>

<p>Example datasets to characterize and compare EDRs, including abundance data,
state, segment, and trajectory dissimilarity matrices for 90 artificial communities
belonging to three different EDRs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EDR_data
</code></pre>


<h3>Format</h3>

<p>List of three nested sublists (<code>"EDR1"</code>, <code>"EDR2"</code>, and <code>"EDR3"</code>), each
associated with one EDR, including the following elements:
</p>

<ul>
<li> <p><code>abundance</code>: Data table with 15 columns and one row for each community state:
</p>

<ul>
<li> <p><code>EDR</code>: Integer indicating the identifier of the EDR.
</p>
</li>
<li> <p><code>traj</code>: Integer containing the identifier of the trajectory for each
artificial community in the corresponding EDR. Each trajectory represents
a different sampling unit.
</p>
</li>
<li> <p><code>state</code>: Integer indicating the observations or states of each community.
The sequence of states of a given community forms a trajectory.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;sp1, ..., sp12&#8288;</code>: Vectors containing species abundances for each community
state.
</p>
</li></ul>

</li>
<li> <p><code>state_dissim</code>: Object of class <code>dist</code> containing Bray-Curtis dissimilarities
between every pair of states in <code>abundance</code> (see Details).
</p>
</li>
<li> <p><code>segment_dissim</code>: Object of class <code>dist</code> containing the dissimilarities
between every pair of trajectory segments in <code>abundance</code> (see Details).
</p>
</li>
<li> <p><code>traj_dissim</code>: Object of class <code>dist</code> containing the dissimilarities
between every pair of community trajectories in <code>abundance</code> (see Details).
</p>
</li></ul>



<h3>Details</h3>

<p>Artificial data was generated following the procedure explained in Box 1 in
Sánchez-Pinillos et al. (2023) In particular, the initial state of each community was
defined using a hypothetical environmental space with optimal locations for
12 species. Community dynamics were simulated using a general Lotka-Volterra model.
</p>
<p>State dissimilarities were calculated using the Bray-Curtis metric. Segment and
trajectory dissimilarities were calculated using the package 'ecotraj'.
</p>


<h3>References</h3>

<p>Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic
Regimes: Identification, characterization, and comparison. <em>Ecological Monographs</em>.
<a href="doi:10.1002/ecm.1589">doi:10.1002/ecm.1589</a>
</p>

<hr>
<h2 id='EDR_metrics'>Metrics of Ecological Dynamic Regimes</h2><span id='topic+EDR_metrics'></span><span id='topic+dDis'></span><span id='topic+dBD'></span><span id='topic+dEve'></span>

<h3>Description</h3>

<p>Set of metrics to analyze the distribution and variability of trajectories
in Ecological Dynamic Regimes (EDR), including dynamic dispersion (dDis), dynamic
beta diversity (dBD), and dynamic evenness (dEve).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDis(
  d,
  d.type,
  trajectories,
  states = NULL,
  reference,
  w.type = "none",
  w.values,
  ...
)

dBD(d, d.type, trajectories, states = NULL, ...)

dEve(d, d.type, trajectories, states = NULL, w.type = "none", w.values, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EDR_metrics_+3A_d">d</code></td>
<td>
<p>Symmetric matrix or object of class <code><a href="stats.html#topic+dist">dist</a></code> containing the
dissimilarities between each pair of states of all trajectories in the EDR or
the dissimilarities between each pair of trajectories. To compute dDis, <code>d</code>
needs to include the dissimilarities between all states/trajectories and the
states/trajectory of reference.</p>
</td></tr>
<tr><td><code id="EDR_metrics_+3A_d.type">d.type</code></td>
<td>
<p>One of <code>"dStates"</code> (if <code>d</code> contains state dissimilarities) or
<code>"dTraj"</code> (if <code>d</code> contains trajectory dissimilarities).</p>
</td></tr>
<tr><td><code id="EDR_metrics_+3A_trajectories">trajectories</code></td>
<td>
<p>Vector indicating the trajectory or site corresponding to
each entry in <code>d</code>.</p>
</td></tr>
<tr><td><code id="EDR_metrics_+3A_states">states</code></td>
<td>
<p>Only if <code>d.type</code> = <code>"dStates"</code>. Vector of integers indicating the
order of the states in <code>d</code> for each trajectory.</p>
</td></tr>
<tr><td><code id="EDR_metrics_+3A_reference">reference</code></td>
<td>
<p>Vector of the same class as <code>trajectories</code> and length equal
to one, indicating the reference trajectory to compute dDis.</p>
</td></tr>
<tr><td><code id="EDR_metrics_+3A_w.type">w.type</code></td>
<td>
<p>Method used to weight individual trajectories:
</p>

<ul>
<li> <p><code>"none"</code>: All trajectories are considered equally relevant (default).
</p>
</li>
<li> <p><code>"length"</code>: Trajectories are weighted by their length, calculated as the
sum of the dissimilarities between every pair of consecutive states. <code>d</code> must
contain dissimilarities between trajectory states and <code>d.type</code> = <code>"dStates"</code>.
</p>
</li>
<li> <p><code>"size"</code>: Trajectories are weighted by their size, calculated as the number
of states forming the trajectory. <code>d</code> must contain dissimilarities between
trajectory states and <code>d.type</code> = <code>"dStates"</code>.
</p>
</li>
<li> <p><code>"precomputed"</code>: Trajectories weighted according to different criteria.
</p>
</li></ul>
</td></tr>
<tr><td><code id="EDR_metrics_+3A_w.values">w.values</code></td>
<td>
<p>Only if <code>w.type</code> = <code>"precomputed"</code>. Numeric vector of length
equal to the number of trajectories containing the weight of each trajectory.</p>
</td></tr>
<tr><td><code id="EDR_metrics_+3A_...">...</code></td>
<td>
<p>Only if <code>d.type</code> = <code>"dStates"</code>. Further arguments to calculate
trajectory dissimilarities. See <code><a href="ecotraj.html#topic+trajectorymetrics">ecotraj::trajectoryDistances()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Dynamic dispersion (<code>dDis()</code>)</strong>
</p>
<p><em>dDis</em> is calculated as the average dissimilarity between each trajectory in an
EDR and a target trajectory taken as reference (Sánchez-Pinillos et al., 2023).
</p>
<p><code class="reqn">
dDis = \frac{\sum_{i=1}^{m}d_{i\alpha}}{m}
</code>
</p>
<p>where <code class="reqn">d_{i\alpha}</code> is the dissimilarity between trajectory <code class="reqn">i</code> and
the trajectory of reference <code class="reqn">\alpha</code>, and <code class="reqn">m</code> is the number of trajectories.
</p>
<p>Alternatively, it is possible to calculate a weighted mean of the dissimilarities
by assigning a weight to each trajectory.
</p>
<p><code class="reqn">
dDis = \frac{\sum_{i=1}^{m}w_{i}d_{i\alpha}}{\sum_{i=1}^{m}w_{i}}
</code>
</p>
<p>where <code class="reqn">w_{i}</code> is the weight assigned to trajectory <code class="reqn">i</code>.
</p>
<p><strong>Dynamic beta diversity (<code>dBD()</code>)</strong>
</p>
<p><em>dBD</em> quantifies the overall variation of the trajectories in an EDR and is
equivalent to the average distance to the centroid of the EDR
(De Cáceres et al., 2019).
</p>
<p><code class="reqn">
dBD = \frac{\sum_{i=1}^{m-1}\sum_{j=i+1}^{m}d_{ij}^{2}}{m(m-1)}
</code>
</p>
<p><strong>Dynamic evenness (<code>dEve()</code>)</strong>
</p>
<p><em>dEve</em> quantifies the regularity with which an EDR is filled by the individual
trajectories (Sánchez-Pinillos et al., 2023).
</p>
<p><code class="reqn">
dEve = \frac{\sum_{l=1}^{m-1}\min(\frac{d_{ij}}{\sum_{l=1}^{m-1}d_{ij}}, \frac{1}{m-1}) - \frac{1}{m-1}}{1-\frac{1}{1-1}}
</code>
</p>
<p>where <code class="reqn">d_{ij}</code> is the dissimilarity between trajectories <code class="reqn">i</code> and <code class="reqn">j</code>
linked in a minimum spanning tree by the link <code class="reqn">l</code>.
</p>
<p>Optionally, it is possible to weight the trajectories of the EDR. In that case,
<em>dEve</em> becomes analogous to the functional evenness index proposed by Villéger
et al. (2008).
</p>
<p><code class="reqn">
dEve_{w} = \frac{\sum_{l=1}^{m-1}\min(\frac{EW_{ij}}{\sum_{l=1}^{m-1}EW_{ij}}, \frac{1}{m-1}) - \frac{1}{m-1}}{1-\frac{1}{1-1}}
</code>
</p>
<p>where <code class="reqn">EW_{ij}</code> is the weighted evenness:
</p>
<p><code class="reqn">
EW_{ij} = \frac{d_{ij}}{w_i + w_j}
</code>
</p>


<h3>Value</h3>


<ul>
<li> <p><code>dDis()</code> returns the value of dynamic dispersion for a given trajectory
taken as a reference.
</p>
</li>
<li> <p><code>dBD()</code> returns the value of dynamic beta diversity.
</p>
</li>
<li> <p><code>dEve()</code> returns the value of dynamic evenness.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Martina Sánchez-Pinillos
</p>


<h3>References</h3>

<p>De Cáceres, M, Coll L, Legendre P, Allen RB, Wiser SK, Fortin MJ, Condit R &amp;
Hubbell S. (2019). Trajectory analysis in community ecology. Ecological
Monographs.
</p>
<p>Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic
Regimes: Identification, characterization, and comparison. <em>Ecological Monographs</em>.
<a href="doi:10.1002/ecm.1589">doi:10.1002/ecm.1589</a>
</p>
<p>Villéger, S., Mason, N.W.H., Mouillot, D. (2008) New multidimensional functional
diversity indices for a multifaced framework in functional ecology. Ecology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data to compute dDis, dBD, and dEve
dStates &lt;- EDR_data$EDR1$state_dissim
dTraj &lt;- EDR_data$EDR1$traj_dissim
trajectories &lt;- paste0("T", EDR_data$EDR1$abundance$traj)
states &lt;- EDR_data$EDR1$abundance$state

# Dynamic dispersion taking the first trajectory as reference
dDis(d = dTraj, d.type = "dTraj", trajectories = unique(trajectories),
         reference = "T1")

# Dynamic dispersion weighting trajectories by their length
dDis(d = dStates, d.type = "dStates", trajectories = trajectories, states = states,
         reference = "T1", w.type = "length")

# Dynamic beta diversity using trajectory dissimilarities
dBD(d = dTraj, d.type = "dTraj", trajectories = unique(trajectories))

# Dynamic evenness
dEve(d = dStates, d.type = "dStates", trajectories = trajectories, states = states)

# Dynamic evenness considering that the 10 first trajectories are three times
# more relevant than the rest
w.values &lt;- c(rep(3, 10), rep(1, length(unique(trajectories))-10))
dEve(d = dTraj, d.type = "dTraj", trajectories = unique(trajectories),
         w.type = "precomputed", w.values = w.values)

</code></pre>

<hr>
<h2 id='plot.RETRA'>Plot representative trajectories of Ecological Dynamic Regimes</h2><span id='topic+plot.RETRA'></span>

<h3>Description</h3>

<p>Plot representative trajectories of an Ecological Dynamic Regime (EDR) in the
state space distinguishing between the segments belonging to real trajectories
of the EDR and the artificial links between segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RETRA'
plot(
  x,
  d,
  trajectories,
  states,
  select_RT = NULL,
  traj.colors = NULL,
  RT.colors = NULL,
  sel.color = NULL,
  link.color = NULL,
  link.lty = 2,
  axes = c(1, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.RETRA_+3A_x">x</code></td>
<td>
<p>Object of class <code>RETRA</code>.</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_d">d</code></td>
<td>
<p>Symmetric matrix or <code>dist</code> object containing the dissimilarities
between each pair of states of all trajectories in the EDR or data frame
containing the coordinates of all trajectory states in an ordination space.</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_trajectories">trajectories</code></td>
<td>
<p>Vector indicating the trajectory or site to which each
state in <code>d</code> belongs.</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_states">states</code></td>
<td>
<p>Vector of integers indicating the order of the states in <code>d</code> for
each trajectory.</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_select_rt">select_RT</code></td>
<td>
<p>Optional string indicating the name of a representative
trajectory that must be highlighted in the plot. By default (<code>select_RT</code> = <code>NULL</code>),
all representative trajectories are represented with the same color.</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_traj.colors">traj.colors</code></td>
<td>
<p>Specification for the color of all individual trajectories
(defaults &quot;grey&quot;) or a vector with length equal to the number of trajectories
indicating the color for each individual trajectory.</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_rt.colors">RT.colors</code></td>
<td>
<p>Specification for the color of representative trajectories
(defaults &quot;black&quot;).</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_sel.color">sel.color</code></td>
<td>
<p>Specification for the color of the selected representative
trajectory (defaults &quot;red&quot;). Only if <code>!is.null(select_RT)</code>.</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_link.color">link.color</code></td>
<td>
<p>Specification for the color of the links between trajectory
segments forming representative trajectories. By default, the same color than
<code>RT.colors</code> is used.</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_link.lty">link.lty</code></td>
<td>
<p>The line type of the links between trajectory segments forming
representative trajectories. Defaults 2 = &quot;dashed&quot; (See <a href="graphics.html#topic+par">graphics::par</a>).</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_axes">axes</code></td>
<td>
<p>An integer vector indicating the pair of axes in the ordination
space to be plotted.</p>
</td></tr>
<tr><td><code id="plot.RETRA_+3A_...">...</code></td>
<td>
<p>Arguments for generic <code><a href="base.html#topic+plot">plot()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>plot()</code> plots a set of individual trajectories and the
representative trajectories in an ordination space defined through <code>d</code> or
calculated by applying metric multidimensional scaling (mMDS; Borg and Groenen,
2005) to <code>d</code>.
</p>


<h3>Author(s)</h3>

<p>Martina Sánchez-Pinillos
</p>


<h3>References</h3>

<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.).
Springer.
</p>
<p>Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic
Regimes: Identification, characterization, and comparison. <em>Ecological Monographs</em>.
<a href="doi:10.1002/ecm.1589">doi:10.1002/ecm.1589</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+retra_edr">retra_edr()</a></code> for identifying representative trajectories in EDRs applying
RETRA-EDR.
</p>
<p><code><a href="#topic+define_retra">define_retra()</a></code> for defining representative trajectories from a subset of
segments or trajectory features.
</p>
<p><code><a href="base.html#topic+summary">summary()</a></code> for summarizing representative trajectories in EDRs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 -----------------------------------------------------------------

# d contains the dissimilarities between trajectory states
d &lt;- EDR_data$EDR1$state_dissim

# trajectories and states are defined according to `d` entries.
trajectories &lt;- EDR_data$EDR1$abundance$traj
states &lt;- EDR_data$EDR1$abundance$state

# x defined from retra_edr(). We obtain three representative trajectories.
RT &lt;- retra_edr(d = d, trajectories = trajectories, states = states, minSegs = 5)
summary(RT)

# Plot individual trajectories in blue and representative trajectories in orange,
# "T2" will be displayed in green. Artificial links will be displayed with a
# dotted line.
plot(x = RT, d = d, trajectories = trajectories, states = states, select_RT = "T2",
     traj.colors = "lightblue", RT.colors = "orange", sel.color = "darkgreen",
     link.lty = 3, main = "Representative trajectories in EDR1")

# Example 2 -----------------------------------------------------------------

# d contains the coordinates in an ordination space. For example, we use
# the coordinates of the trajectory states after applying a principal component
# analysis (PCA) to an abundance matrix.
abun &lt;- EDR_data$EDR1$abundance
pca &lt;- prcomp(abun[, -c(1:3)])
coord &lt;- data.frame(pca$x)

# trajectories and states are defined according to the abundance matrix
# used in the PCA
trajectories &lt;- EDR_data$EDR1$abundance$traj
states &lt;- EDR_data$EDR1$abundance$state

# Instead of using the representative trajectories obtained from `retra_edr()`,
# we will define the set of trajectories that we want to highlight. For example,
# we can select the trajectories whose initial and final states are in the
# extremes of the first axis.
T1 &lt;- trajectories[which.max(coord[, 1])]
T2 &lt;- trajectories[which.min(coord[, 1])]
RT_traj &lt;- c(trajectories[trajectories %in% T1],
             trajectories[trajectories %in% T2])
RT_states &lt;- c(states[which(trajectories %in% T1)],
               states[which(trajectories %in% T2)])

# Create a data frame to generate a RETRA object using define_retra
RT_df &lt;- data.frame(RT = c(rep("T1", sum(trajectories %in% T1)),
                           rep("T2", sum(trajectories %in% T2))),
                 RT_traj = RT_traj,
                 RT_states = as.integer(RT_states))
RT_retra &lt;- define_retra(data = RT_df)

# Plot the defined trajectories with the default graphic values
plot(x = RT_retra, d = coord, trajectories = trajectories, states = states,
     main = "Extreme trajectories in EDR1")

</code></pre>

<hr>
<h2 id='retra_edr'>Representative trajectories in Ecological Dynamic Regimes (RETRA-EDR)</h2><span id='topic+retra_edr'></span>

<h3>Description</h3>

<p><code>retra_edr()</code> applies the algorithm RETRA-EDR (Sánchez-Pinillos et al., 2023)
to identify representative trajectories summarizing the main dynamical patterns
of an Ecological Dynamic Regime (EDR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retra_edr(
  d,
  trajectories,
  states,
  minSegs,
  dSegs = NULL,
  coordSegs = NULL,
  traj_Segs = NULL,
  state1_Segs = NULL,
  state2_Segs = NULL,
  Dim = NULL,
  eps = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retra_edr_+3A_d">d</code></td>
<td>
<p>Either a symmetric matrix or an object of class <code><a href="stats.html#topic+dist">dist</a></code> containing the
dissimilarities between each pair of states of all trajectories in the EDR.</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_trajectories">trajectories</code></td>
<td>
<p>Vector indicating the trajectory or site to which each
state in <code>d</code> belongs.</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_states">states</code></td>
<td>
<p>Vector of integers indicating the order of the states in <code>d</code> for
each trajectory.</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_minsegs">minSegs</code></td>
<td>
<p>Integer indicating the minimum number of segments in a region
of the EDR represented by a segment of the representative trajectory.</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_dsegs">dSegs</code></td>
<td>
<p>Either a symmetric matrix or an object of class <code><a href="stats.html#topic+dist">dist</a></code> containing
the dissimilarities between every pair of trajectory segments (see Details).</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_coordsegs">coordSegs</code></td>
<td>
<p>Matrix containing the coordinates of trajectory segments (rows)
in each axis (columns) of an ordination space (see Details).</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_traj_segs">traj_Segs</code></td>
<td>
<p>Vector indicating the trajectory to which each segment in <code>dSeg</code>
and/or <code>coordSegs</code> belongs. Only required if <code>dSegs</code> or <code>coordSegs</code> are not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_state1_segs">state1_Segs</code></td>
<td>
<p>Vector indicating the initial state of each segment in <code>dSegs</code>
and/or <code>coordSegs</code> according to the values given in <code>states</code>. Only required if
<code>dSegs</code> or <code>coordSegs</code> are not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_state2_segs">state2_Segs</code></td>
<td>
<p>Vector indicating the final state of each segment in <code>dSegs</code>
and/or <code>coordSegs</code> according to the values given in <code>states</code>. Only required if
<code>dSegs</code> or <code>coordSegs</code> are not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_dim">Dim</code></td>
<td>
<p>Optional integer indicating the number of axes considered to
partition the segment space and generate a k-d tree. By default (<code>Dim = NULL</code>),
all axes are considered.</p>
</td></tr>
<tr><td><code id="retra_edr_+3A_eps">eps</code></td>
<td>
<p>Numeric value indicating the minimum length in the axes of the segment
space to be partitioned when the k-d tree is generated. If <code>eps = 0</code> (default),
partitions are made regardless of the size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm RETRA-EDR is based on a partition-and-group approach by which it
identifies regions densely crossed by ecological trajectories in an EDR, selects
a representative segment in each dense region, and joins the representative
segments by a set of artificial <code>Links</code> to generate a network of representative
trajectories. For that, RETRA-EDR splits the trajectories of the EDR into
segments and uses an ordination space generated from a matrix containing the
dissimilarities between trajectory segments. Dense regions are identified by
applying a k-d tree to the ordination space.
</p>
<p>By default, RETRA-EDR calculates segment dissimilarities following the approach
by De Cáceres et al. (2019) and applies metric multidimensional scaling (mMDS,
Borg and Groenen, 2005) to generate the ordination space. It is possible to use
other dissimilarity metrics and/or ordination methods and reduce the computational
time by indicating the dissimilarity matrix and the coordinates of the segments
in the ordination space through the arguments <code>dSegs</code> and <code>coordSegs</code>, respectively.
</p>

<ul>
<li><p> If <code>!is.null(dSegs)</code> and <code>is.null(coordSegs)</code>, RETRA-EDR is computed by
applying mMDS to <code>dSegs</code>.
</p>
</li>
<li><p> If <code>!is.null(dSegs)</code> and <code>!is.null(coordSegs)</code>, RETRA-EDR is directly computed
from the coordinates provided in <code>coordSegs</code> and representative segments are
identified using <code>dSegs</code>. <code>coordSegs</code> should be calculated by the user from
<code>dSegs</code>.
</p>
</li>
<li><p> If <code>is.null(dSegs)</code> and <code>!is.null(coordSegs)</code> (not recommended), RETRA-EDR
is directly computed from the coordinates provided in <code>coordSegs</code>. As <code>dSegs</code>
is not provided, <code>retra_edr()</code> assumes that the ordination space is metric and
identifies representative segments using the Euclidean distance.
</p>
</li></ul>



<h3>Value</h3>

<p>The function <code>retra_edr()</code> returns an object of class <code>RETRA</code>, which is a list
of length equal to the number of representative trajectories identified. For
each trajectory, the following information is returned:
</p>

<dl>
<dt><code>minSegs</code></dt><dd><p>Value of the <code>minSegs</code> parameter.</p>
</dd>
<dt><code>Segments</code></dt><dd><p>Vector of strings including the sequence of segments forming the
representative trajectory. Each segment is identified by a string of the form
<code>traj[st1-st2]</code>, where <code>traj</code> is the identifier of the original trajectory to
which the segment belongs and <code>st1</code> and <code>st2</code> are identifiers of the initial
and final states defining the segment.</p>
</dd>
<dt><code>Size</code></dt><dd><p>Numeric value indicating the number of states forming the representative
trajectory.</p>
</dd>
<dt><code>Length</code></dt><dd><p>Numeric value indicating the length of the representative trajectory,
calculated as the sum of the dissimilarities in <code>d</code> between every pair of
consecutive states.</p>
</dd>
<dt><code>Link_distance</code></dt><dd><p>Data frame of two columns indicating artificial links between
representative segments (<code>Link</code>) and the dissimilarity between the connected
states (<code>Distance</code>). When two representative segments are linked by a common
state or by two consecutive states of the same trajectory, the link distance
is zero or equal to the length of a real segment, respectively. In both cases,
the link is not considered in the returned data frame.</p>
</dd>
<dt><code>Seg_density</code></dt><dd><p>Data frame of two columns and one row for each representative
segment. <code>Density</code> contains the number of segments in the EDR that is represented
by each segment of the representative trajectory. <code>kdTree_depth</code> contains the
depth of the k-d tree for each leaf represented by the corresponding segment.
That is, the number of partitions of the ordination space until finding a region
with <code>minSegs</code> segments or less.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martina Sánchez-Pinillos
</p>


<h3>References</h3>

<p>Borg, I., &amp; Groenen, P. J. F. (2005). Modern Multidimensional Scaling (2nd ed.).
Springer.
</p>
<p>De Cáceres, M, Coll L, Legendre P, Allen RB, Wiser SK, Fortin MJ,
Condit R &amp; Hubbell S. (2019). Trajectory analysis in community ecology. Ecological
Monographs.
</p>
<p>Sánchez-Pinillos, M., Kéfi, S., De Cáceres, M., Dakos, V. 2023. Ecological Dynamic
Regimes: Identification, characterization, and comparison. <em>Ecological Monographs</em>.
<a href="doi:10.1002/ecm.1589">doi:10.1002/ecm.1589</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary()</a></code> for summarizing the characteristics of the representative
trajectories.
</p>
<p><code><a href="base.html#topic+plot">plot()</a></code> for plotting representative trajectories in an ordination space
representing the state space of the EDR.
</p>
<p><code><a href="#topic+define_retra">define_retra()</a></code> for defining representative trajectories from a subset of
segments or trajectory features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 -----------------------------------------------------------------
# Identify representative trajectories from state dissimilarities

# Calculate state dissimilarities (Bray-Curtis) from species abundances
abundance &lt;- data.frame(EDR_data$EDR1$abundance)
d &lt;- vegan::vegdist(abundance[, -c(1:3)], method = "bray")

# Identify the trajectory (or site) and states in d
trajectories &lt;- abundance$traj
states &lt;- as.integer(abundance$state)

# Compute RETRA-EDR
RT1 &lt;- retra_edr(d = d, trajectories = trajectories, states = states,
                 minSegs = 5)

# Example 2 -----------------------------------------------------------------
# Identify representative trajectories from segment dissimilarities

# Calculate segment dissimilarities using the Hausdorff distance
dSegs &lt;- ecotraj::segmentDistances(d = d, sites = trajectories,
                                    surveys = states,
                                    distance.type = "Hausdorff")
dSegs &lt;- dSegs$Dseg

# Identify the trajectory (or site) and states in dSegs:
# Split the labels of dSegs (traj[st1-st2]) into traj, st1, and st2
seg_components &lt;- strsplit(gsub("\\]", "", gsub("\\[", "-", labels(dSegs))), "-")
traj_Segs &lt;- sapply(seg_components, "[", 1)
state1_Segs &lt;- as.integer(sapply(seg_components, "[", 2))
state2_Segs &lt;- as.integer(sapply(seg_components, "[", 3))

# Compute RETRA-EDR
RT2 &lt;- retra_edr(d = d, trajectories = trajectories, states = states, minSegs = 5,
                dSegs = dSegs, traj_Segs = traj_Segs,
                state1_Segs = state1_Segs, state2_Segs = state2_Segs)


</code></pre>

<hr>
<h2 id='summary.RETRA'>Summarize representative trajectories</h2><span id='topic+summary.RETRA'></span>

<h3>Description</h3>

<p>Summarize the properties of representative trajectories returned by
<code><a href="#topic+retra_edr">retra_edr()</a></code> or <code><a href="#topic+define_retra">define_retra()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RETRA'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.RETRA_+3A_object">object</code></td>
<td>
<p>An object of class <code>RETRA</code>.</p>
</td></tr>
<tr><td><code id="summary.RETRA_+3A_...">...</code></td>
<td>
<p>(not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with nine columns and one row for each representative trajectory
in <code>object</code>. The columns in the returned data frame contain the following
information:
</p>

<dl>
<dt><code>ID</code></dt><dd><p>Identifier of the representative trajectories.</p>
</dd>
<dt><code>Size</code></dt><dd><p>Number of states forming each representative trajectory.</p>
</dd>
<dt><code>Length</code></dt><dd><p>Sum of the dissimilarities in <code>d</code> between every pair of
consecutive states forming the representative trajectories.</p>
</dd>
<dt><code>Avg_link</code></dt><dd><p>Mean value of the dissimilarities between consecutive states
of the representative trajectories that do not belong to the same ecological
trajectory or site (i.e., artificial links).</p>
</dd>
<dt><code>Sum_link</code></dt><dd><p>Sum of the dissimilarities between consecutive states of the
representative trajectories that do not belong to the same ecological trajectory
or site (i.e., artificial links).</p>
</dd>
<dt><code>Avg_density</code></dt><dd><p>Mean value of the number of segments represented by each
segment of the representative trajectory (excluding artificial links).</p>
</dd>
<dt><code>Max_density</code></dt><dd><p>Maximum number of segments represented by at least one of
the segments of the representative trajectory (excluding artificial links).</p>
</dd>
<dt><code>Avg_depth</code></dt><dd><p>Mean value of the k-d tree depths, that is, the number of
partitions of the ordination space until finding a region with <code>minSegs</code> segments
or less.</p>
</dd>
<dt><code>Max_depth</code></dt><dd><p>Maximum depth in the k-d tree, that is, the number of partitions
of the ordination space until finding a region with <code>minSegs</code> segments or less.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+retra_edr">retra_edr()</a></code> for identifying representative trajectories in EDRs applying
RETRA-EDR.
</p>
<p><code><a href="#topic+define_retra">define_retra()</a></code> for generating an object of class <code>RETRA</code> from trajectory
features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Apply RETRA-EDR to identify representative trajectories
d = EDR_data$EDR1$state_dissim
trajectories = EDR_data$EDR1$abundance$traj
states = EDR_data$EDR1$abundance$state
RT &lt;- retra_edr(d = d, trajectories = trajectories, states = states, minSegs = 5)

# Summarize the properties of the representative trajectories in a data frame
summary(RT)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
