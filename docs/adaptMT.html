<!DOCTYPE html><html lang="en"><head><title>Help for package adaptMT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adaptMT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adapt'><p>Adaptive P-value Thresholding</p></a></li>
<li><a href='#adapt_gam'><p>Adaptive P-value Thresholding with Generalized Additive Models</p></a></li>
<li><a href='#adapt_glm'><p>Adaptive P-value Thresholding with Generalized Linear Models</p></a></li>
<li><a href='#adapt_glmnet'><p>Adaptive P-value Thresholding with L1/L2 Penalized Generalized Linear Models</p></a></li>
<li><a href='#corr_lfdr'><p>Quantifying Information Loss of Adaptive P-Value Thresholding</p></a></li>
<li><a href='#ctgm_lfdr'><p>Fitting Conditional Two-Groups Models on Unmasked P-Values</p></a></li>
<li><a href='#estrogen'><p>Gene/Drug response dataset</p></a></li>
<li><a href='#gen_adapt_model'><p>adapt_model Objects for M-steps</p></a></li>
<li><a href='#gen_exp_family'><p>Generate exp_family Objects for Exponential Families</p></a></li>
<li><a href='#plot_1d'><p>Plotting Functions for AdaPT with 1D Covariates</p></a></li>
<li><a href='#plot_2d'><p>Plotting Functions for AdaPT with 2D Covariates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive P-Value Thresholding for Multiple Hypothesis Testing
with Side Information</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lihua Lei &lt;lihua.lei@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of adaptive p-value thresholding (AdaPT), including both a framework that allows the user to specify any 
  algorithm to learn local false discovery rate and a pool of convenient functions that implement specific 
  algorithms. See Lei, Lihua and Fithian, William (2016) &lt;<a href="https://doi.org/10.48550/arXiv.1609.06035">doi:10.48550/arXiv.1609.06035</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://arxiv.org/abs/1609.06035">https://arxiv.org/abs/1609.06035</a>,
<a href="https://github.com/lihualei71/adaptMT">https://github.com/lihualei71/adaptMT</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lihualei71/adaptMT/issues">https://github.com/lihualei71/adaptMT/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>glmnet, HDtweedie, mgcv, splines, testthat, knitr, rmarkdown,
dplyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-31 06:40:07 UTC; Leo</td>
</tr>
<tr>
<td>Author:</td>
<td>Lihua Lei [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-31 12:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='adapt'>Adaptive P-value Thresholding</h2><span id='topic+adapt'></span>

<h3>Description</h3>

<p><code>adapt</code> is a framework allowing for arbitrary exponential families for computing E-steps and arbitrary algorithms for fitting M-steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt(x, pvals, models, dist = beta_family(), s0 = rep(0.45, length(pvals)),
  alphas = seq(0.01, 1, 0.01), params0 = list(pix = NULL, mux = NULL),
  nfits = 20, nms = 1, niter_fit = 10, tol = 1e-04, niter_ms = 20,
  cr = "BIC", verbose = list(print = TRUE, fit = FALSE, ms = TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adapt_+3A_x">x</code></td>
<td>
<p>covariates (i.e. side-information). Should be compatible to <code>models</code>. See Details</p>
</td></tr>
<tr><td><code id="adapt_+3A_pvals">pvals</code></td>
<td>
<p>a vector of values in [0, 1]. P-values</p>
</td></tr>
<tr><td><code id="adapt_+3A_models">models</code></td>
<td>
<p>an object of class &quot;<code>adapt_model</code>&quot; or a list of objects of class &quot;adapt_model&quot;. See Details</p>
</td></tr>
<tr><td><code id="adapt_+3A_dist">dist</code></td>
<td>
<p>an object of class &quot;<code><a href="#topic+gen_exp_family">gen_exp_family</a></code>&quot;. <code><a href="#topic+beta_family">beta_family</a>()</code> as default</p>
</td></tr>
<tr><td><code id="adapt_+3A_s0">s0</code></td>
<td>
<p>a vector of values in [0, 0.5). Initial threshold.</p>
</td></tr>
<tr><td><code id="adapt_+3A_alphas">alphas</code></td>
<td>
<p>a vector of values in (0, 1). Target FDR levels.</p>
</td></tr>
<tr><td><code id="adapt_+3A_params0">params0</code></td>
<td>
<p>a list in the form of list(pix = , mux = ). Initial guess of pi(x) and mu(x). NULL as default</p>
</td></tr>
<tr><td><code id="adapt_+3A_nfits">nfits</code></td>
<td>
<p>a positive integer. Number of model-fitting steps. See Details</p>
</td></tr>
<tr><td><code id="adapt_+3A_nms">nms</code></td>
<td>
<p>a non-negative integer. Number of model selection steps. See Details</p>
</td></tr>
<tr><td><code id="adapt_+3A_niter_fit">niter_fit</code></td>
<td>
<p>a positive integer. Number of EM iterations in model fitting</p>
</td></tr>
<tr><td><code id="adapt_+3A_tol">tol</code></td>
<td>
<p>a positive scalar. EM algorithm stops when pi(x) and mu(x) in consecutive steps differ by at most 'tol' for each element</p>
</td></tr>
<tr><td><code id="adapt_+3A_niter_ms">niter_ms</code></td>
<td>
<p>a positive integer. Number of EM iterations in model selection</p>
</td></tr>
<tr><td><code id="adapt_+3A_cr">cr</code></td>
<td>
<p>a string. The criterion for model selection with BIC as default. Also support AIC, AICC and HIC</p>
</td></tr>
<tr><td><code id="adapt_+3A_verbose">verbose</code></td>
<td>
<p>a list of logical values in the form of list(print = , fit = , ms = ). Each element indicates whether the relevant information is outputted to the console. See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> should have a type compatible to the fitting functions in <code>models</code>. For GLM and GAM, <code>x</code> should be a data.frame. For glmnet, <code>x</code> should be a matrix.
</p>
<p><code>models</code> could either be an <code>adapt_model</code> object, if a single model is used, or a list of <code>adapt_model</code> objects, each of which corresponding to a model. Each element should be generated by <code><a href="#topic+gen_adapt_model">gen_adapt_model</a></code>. For glm/gam/glmnet, one can use the shortcut by running <code><a href="#topic+gen_adapt_model">gen_adapt_model</a></code> with name = &quot;glm&quot; or &quot;gam&quot; or &quot;glmnet&quot; but without specifying <code>pifun</code>, <code>mufun</code>, <code>pifun_init</code> and <code>mufun_init</code>. See examples below.
</p>
<p><code>nfits</code> is the number of model fitting steps plus <code>nms</code>, the model selection steps, if <code>models</code> contains multiple <code>adapt_model</code> objects. Suppose M is the number of masked p-values at the initial step, then the model is updated at the initial step and at every time when [M/<code>nfits</code>] more p-values are revealed. If <code>nms &gt; 0</code>, model selection is performed at the initial step an at every time when [M/<code>nms</code>] more p-values are revealed. Between two consecutive model selection steps, the model selected from the last step is used for model fitting. For example, when M = 10000, nfits = 10 and nms = 2, model selection will be performed at the initial step and when 5000 p-values are revealed, while the model fitting will be performed when 1000, 2000, 3000, 4000, 6000, 7000, 8000, 9000 p-values are revealed.
</p>
<p><code>verbose</code> has three elements: <code>print</code>, <code>fit</code> and <code>ms</code>. If <code>print = TRUE</code>, the progress of the main procedure is outputted to the console, in the form of &quot;alpha = 0.05: FDPhat 0.0333, Number of Rej. 30&quot; (where the numbers are made up for illustration). If <code>fit = TRUE</code>, a progress bar for the model fitting is outputted to the console. Similarly, if <code>ms = TRUE</code>, a progress bar for the model selection is outputted to the console.
</p>
<p>For ultra-large scale problems (n &gt; 10^5), it is recommended to keep <code>alphas</code> short because the output <code>s</code> is of size n x <code>length(alphas)</code>.
is <code>length(alphas)</code>.
</p>
<p>The output <code>qvals</code> gives the q-values of each hypothesis. <code>qvals[i]</code> is defined as the minimum target FDR level such that <code>pvals[i]</code> is rejected. For hypotheses with p-values above s0, the q-values are set to be Inf because they are never rejected by AdaPT for whatever alpha.
</p>
<p>The output <code>order</code> gives the order of (the indices of) p-values being revealed, i.e. being in the region (s, 1-s). The latter hypotheses appeared in <code>order</code> have smaller q-values (i.e. are more likely to be rejected).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nrejs</code></td>
<td>
<p>a vector of integers. Number of rejections for each alpha</p>
</td></tr>
<tr><td><code>rejs</code></td>
<td>
<p>a list of vector of integers. The set of indices of rejections for each alpha</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>a matrix of size <code>length(pvals) X length(alphas)</code>. Threshold curves for each alpha</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>a list. Each element is a list in the form of <code>list(pix = , mux = , alpha = , nmasks =)</code>, recording the parameter estimates, the achieved alpha and the number of masked p-values. To avoid massive storage cost, it only contains the information when a new target FDR level is achieved. As a result, it might be  shorter than <code>nfits</code>.</p>
</td></tr>
<tr><td><code>qvals</code></td>
<td>
<p>a vector of values in [0, 1]UInf. Q-values. See Details</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>a permutation of <code>1:length(pvals)</code>. Indices of hypotheses arranged in the order of reveal. See Details</p>
</td></tr>
<tr><td><code>alphas</code></td>
<td>
<p>same as the input <code>alphas</code></p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>same as the input <code>dist</code></p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>a list of <code>adapt_model</code> objects of length <code>params</code>. The model used in each fitting step. As in <code>params</code>, it only contains the model when a new target FDR level is achieved and each element corresponds to an element of <code>params</code>.</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>a list of length <code>nfits</code>. Each element is a list recording extra information in each fitting step, e.g. degree of freedom (df) and variable importance (vi). As in <code>params</code>, it only contains the model information when a new target FDR level is achieved and each element corresponds to an element of <code>params</code>.</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>a list including the other inputs <code>nfits</code>, <code>nms</code>, <code>niter_fit</code>, <code>niter_ms</code>, <code>tol</code>, <code>cr</code></p>
</td></tr></table>
<p>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load estrogen data
data(estrogen)
pvals &lt;- as.numeric(estrogen$pvals)
x &lt;- data.frame(x = as.numeric(estrogen$ord_high))
dist &lt;- beta_family()

# Subsample the data for convenience
inds &lt;- (x$x &lt;= 5000)
pvals &lt;- pvals[inds]
x &lt;- x[inds,,drop = FALSE]

# Generate models for function adapt
library("splines")
formulas &lt;- paste0("ns(x, df = ", 6:10, ")")
models &lt;- lapply(formulas, function(formula){
    piargs &lt;- muargs &lt;- list(formula = formula)
    gen_adapt_model(name = "glm", piargs = piargs, muargs = muargs)
})

# Run adapt
res &lt;- adapt(x = x, pvals = pvals, models = models,
             dist = dist, nfits = 10)


</code></pre>

<hr>
<h2 id='adapt_gam'>Adaptive P-value Thresholding with Generalized Additive Models</h2><span id='topic+adapt_gam'></span>

<h3>Description</h3>

<p><code>adapt_gam</code> is a wrapper of <code><a href="#topic+adapt">adapt</a></code> that fits pi(x) and mu(x) by <code><a href="mgcv.html#topic+gam">gam</a></code> from <code>mgcv</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_gam(x, pvals, pi_formulas, mu_formulas, piargs = list(),
  muargs = list(), dist = beta_family(), s0 = rep(0.45, length(pvals)),
  alphas = seq(0.01, 1, 0.01), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adapt_gam_+3A_x">x</code></td>
<td>
<p>covariates (i.e. side-information). Should be compatible to <code>models</code>. See Details</p>
</td></tr>
<tr><td><code id="adapt_gam_+3A_pvals">pvals</code></td>
<td>
<p>a vector of values in [0, 1]. P-values</p>
</td></tr>
<tr><td><code id="adapt_gam_+3A_pi_formulas">pi_formulas</code></td>
<td>
<p>a vector/list of strings/formulas. Formulas for fitting pi(x) by gam. See Details</p>
</td></tr>
<tr><td><code id="adapt_gam_+3A_mu_formulas">mu_formulas</code></td>
<td>
<p>a vector/list of strings/formulas. Formulas for fitting mu(x) by gam. See Details</p>
</td></tr>
<tr><td><code id="adapt_gam_+3A_piargs">piargs</code></td>
<td>
<p>a list. Other arguments passed to gam for fitting pi(x)</p>
</td></tr>
<tr><td><code id="adapt_gam_+3A_muargs">muargs</code></td>
<td>
<p>a list. Other arguments passed to gam for fitting mu(x)</p>
</td></tr>
<tr><td><code id="adapt_gam_+3A_dist">dist</code></td>
<td>
<p>an object of class &quot;<code><a href="#topic+gen_exp_family">gen_exp_family</a></code>&quot;. <code><a href="#topic+beta_family">beta_family</a>()</code> as default</p>
</td></tr>
<tr><td><code id="adapt_gam_+3A_s0">s0</code></td>
<td>
<p>a vector of values in [0, 0.5). Initial threshold.</p>
</td></tr>
<tr><td><code id="adapt_gam_+3A_alphas">alphas</code></td>
<td>
<p>a vector of values in (0, 1). Target FDR levels.</p>
</td></tr>
<tr><td><code id="adapt_gam_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+adapt">adapt</a></code> (except <code>models</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pi_formulas</code> and <code>mu_formulas</code> can either be a list or a vector with each element being a string or a formula. For instance, suppose <code>x</code> has a single column with name <code>x1</code>, the following five options are valid for the same inputs (<code><a href="splines.html#topic+ns">ns</a></code> forms a spline basis with <code>df</code> knots and <code><a href="mgcv.html#topic+s">s</a></code> forms a spline basis with knots automatically selected by generalized cross-validation):
</p>

<ol>
<li><p>c(&quot;x1&quot;, &quot;ns(x1, df = 8)&quot;, &quot;s(x1)&quot;);
</p>
</li>
<li><p>c(&quot;~ x1&quot;, &quot;~ ns(x1, df = 8)&quot;, &quot;s(x1)&quot;);
</p>
</li>
<li><p>list(&quot;x1&quot;, &quot;ns(x1, df = 8)&quot;, &quot;s(x1)&quot;);
</p>
</li>
<li><p>list(&quot;~ x1&quot;, &quot;~ ns(x1, df = 8)&quot;, &quot;s(x1)&quot;);
</p>
</li>
<li><p>list(~ x1, ~ ns(x1, df = 8), s(x1))
</p>
</li></ol>

<p>There is no need to specify the name of the response variable, as this is handled in the function.
</p>
<p>When <code>x</code> has a few variables, it is common to use non-parametric GLM by replacing <code>x</code> by a spline basis of <code>x</code>. In this case, <code><a href="splines.html#topic+ns">ns</a></code> from <code>library(splines)</code> package or <code><a href="mgcv.html#topic+s">s</a></code> from <code>mgcv</code> package are suggested. When <code><a href="mgcv.html#topic+s">s</a></code> (from <code>mgcv</code> package) is used, it is treated as a single model because the knots will be selected automatically.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adapt">adapt</a></code>, <code><a href="#topic+adapt_glm">adapt_glm</a></code>, <code><a href="#topic+adapt_glmnet">adapt_glmnet</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="mgcv.html#topic+s">s</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a 2-dim x
n &lt;- 400
x1 &lt;- x2 &lt;- seq(-100, 100, length.out = 20)
x &lt;- expand.grid(x1, x2)
colnames(x) &lt;- c("x1", "x2")

# Generate p-values (one-sided z test)
# Set all hypotheses in the central circle with radius 30 to be
# non-nulls. For non-nulls, z~N(2,1) and for nulls, z~N(0,1).
H0 &lt;- apply(x, 1, function(coord){sum(coord^2) &lt; 900})
mu &lt;- ifelse(H0, 2, 0)
set.seed(0)
zvals &lt;- rnorm(n) + mu
pvals &lt;- 1 - pnorm(zvals)

# Run adapt_gam with a 2d spline basis
library("mgcv")
formula &lt;- "s(x1, x2)"
dist &lt;- beta_family()
res &lt;- adapt_gam(x = x, pvals = pvals, pi_formulas = formula,
                 mu_formulas = formula, dist = dist, nfits = 5)



</code></pre>

<hr>
<h2 id='adapt_glm'>Adaptive P-value Thresholding with Generalized Linear Models</h2><span id='topic+adapt_glm'></span>

<h3>Description</h3>

<p><code>adapt_glm</code> is a wrapper of <code><a href="#topic+adapt">adapt</a></code> that fits pi(x) and mu(x) by <code><a href="stats.html#topic+glm">glm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_glm(x, pvals, pi_formulas, mu_formulas, dist = beta_family(),
  s0 = rep(0.45, length(pvals)), alphas = seq(0.01, 1, 0.01),
  piargs = list(), muargs = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adapt_glm_+3A_x">x</code></td>
<td>
<p>covariates (i.e. side-information). Should be compatible to <code>models</code>. See Details</p>
</td></tr>
<tr><td><code id="adapt_glm_+3A_pvals">pvals</code></td>
<td>
<p>a vector of values in [0, 1]. P-values</p>
</td></tr>
<tr><td><code id="adapt_glm_+3A_pi_formulas">pi_formulas</code></td>
<td>
<p>a vector/list of strings/formulas. Formulas for fitting pi(x) by glm. See Details</p>
</td></tr>
<tr><td><code id="adapt_glm_+3A_mu_formulas">mu_formulas</code></td>
<td>
<p>a vector/list of strings/formulas. Formulas for fitting mu(x) by glm. See Details</p>
</td></tr>
<tr><td><code id="adapt_glm_+3A_dist">dist</code></td>
<td>
<p>an object of class &quot;<code><a href="#topic+gen_exp_family">gen_exp_family</a></code>&quot;. <code><a href="#topic+beta_family">beta_family</a>()</code> as default</p>
</td></tr>
<tr><td><code id="adapt_glm_+3A_s0">s0</code></td>
<td>
<p>a vector of values in [0, 0.5). Initial threshold.</p>
</td></tr>
<tr><td><code id="adapt_glm_+3A_alphas">alphas</code></td>
<td>
<p>a vector of values in (0, 1). Target FDR levels.</p>
</td></tr>
<tr><td><code id="adapt_glm_+3A_piargs">piargs</code></td>
<td>
<p>a list. Other arguments passed to glm for fitting pi(x)</p>
</td></tr>
<tr><td><code id="adapt_glm_+3A_muargs">muargs</code></td>
<td>
<p>a list. Other arguments passed to glm for fitting mu(x)</p>
</td></tr>
<tr><td><code id="adapt_glm_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+adapt">adapt</a></code> (except <code>models</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pi_formulas</code> and <code>mu_formulas</code> can either be a list or a vector with each element being a string or a formula. For instance, suppose <code>x</code> has a single column with name <code>x1</code>, the following five options are valid for the same inputs (<code><a href="splines.html#topic+ns">ns</a></code> forms a spline basis with <code>df</code> knots):
</p>

<ol>
<li><p>c(&quot;x1&quot;, &quot;ns(x1, df = 8)&quot;);
</p>
</li>
<li><p>c(&quot;~ x1&quot;, &quot;~ ns(x1, df = 8)&quot;);
</p>
</li>
<li><p>list(&quot;x1&quot;, &quot;ns(x1, df = 8)&quot;);
</p>
</li>
<li><p>list(&quot;~ x1&quot;, &quot;~ ns(x1, df = 8)&quot;);
</p>
</li>
<li><p>list(~ x1, ~ ns(x1, df = 8))
</p>
</li></ol>

<p>There is no need to specify the name of the response variable, as this is handled in the function.
</p>
<p>When <code>x</code> has a few variables, it is common to use non-parametric GLM by replacing <code>x</code> by a spline basis of <code>x</code>. In this case, <code><a href="splines.html#topic+ns">ns</a></code> from <code>library(splines)</code> package is suggested.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adapt">adapt</a></code>, <code><a href="#topic+adapt_gam">adapt_gam</a></code>, <code><a href="#topic+adapt_glmnet">adapt_glmnet</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="splines.html#topic+ns">ns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load estrogen data
data(estrogen)
pvals &lt;- as.numeric(estrogen$pvals)
x &lt;- data.frame(x = as.numeric(estrogen$ord_high))
dist &lt;- beta_family()

# Subsample the data for convenience
inds &lt;- (x$x &lt;= 5000)
pvals &lt;- pvals[inds]
x &lt;- x[inds,,drop = FALSE]

# Run adapt_glm
library("splines")
formulas &lt;- paste0("ns(x, df = ", 6:10, ")")
res &lt;- adapt_glm(x = x, pvals = pvals, pi_formulas = formulas,
                 mu_formulas = formulas, dist = dist, nfits = 10)

# Run adapt by manually setting models for glm
models &lt;- lapply(formulas, function(formula){
    piargs &lt;- muargs &lt;- list(formula = formula)
    gen_adapt_model(name = "glm", piargs = piargs, muargs = muargs)
})
res2 &lt;- adapt(x = x, pvals = pvals, models = models,
              dist = dist, nfits = 10)

# Check equivalence
identical(res, res2)


</code></pre>

<hr>
<h2 id='adapt_glmnet'>Adaptive P-value Thresholding with L1/L2 Penalized Generalized Linear Models</h2><span id='topic+adapt_glmnet'></span>

<h3>Description</h3>

<p><code>adapt_glmnet</code> is a wrapper of <code><a href="#topic+adapt">adapt</a></code> that fits pi(x) and mu(x) by <code><a href="glmnet.html#topic+glmnet">glmnet</a></code> from <code>glmnet</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_glmnet(x, pvals, piargs = list(), muargs = list(),
  dist = beta_family(), s0 = rep(0.45, length(pvals)), alphas = seq(0.01,
  1, 0.01), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adapt_glmnet_+3A_x">x</code></td>
<td>
<p>covariates (i.e. side-information). Should be compatible to <code>models</code>. See Details</p>
</td></tr>
<tr><td><code id="adapt_glmnet_+3A_pvals">pvals</code></td>
<td>
<p>a vector of values in [0, 1]. P-values</p>
</td></tr>
<tr><td><code id="adapt_glmnet_+3A_piargs">piargs</code></td>
<td>
<p>a list. Other arguments passed to glmnet for fitting pi(x)</p>
</td></tr>
<tr><td><code id="adapt_glmnet_+3A_muargs">muargs</code></td>
<td>
<p>a list. Other arguments passed to glmnet for fitting mu(x)</p>
</td></tr>
<tr><td><code id="adapt_glmnet_+3A_dist">dist</code></td>
<td>
<p>an object of class &quot;<code><a href="#topic+gen_exp_family">gen_exp_family</a></code>&quot;. <code><a href="#topic+beta_family">beta_family</a>()</code> as default</p>
</td></tr>
<tr><td><code id="adapt_glmnet_+3A_s0">s0</code></td>
<td>
<p>a vector of values in [0, 0.5). Initial threshold.</p>
</td></tr>
<tr><td><code id="adapt_glmnet_+3A_alphas">alphas</code></td>
<td>
<p>a vector of values in (0, 1). Target FDR levels.</p>
</td></tr>
<tr><td><code id="adapt_glmnet_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+adapt">adapt</a></code> (except <code>models</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>adapt_glmnet</code> by default implements LASSO on <code>x</code> with lambda selected by cross-validation. Specify in <code>piargs</code> and <code>muargs</code> if ridge or elastic-net penalty is needed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adapt">adapt</a></code>, <code><a href="#topic+adapt_glm">adapt_glm</a></code>, <code><a href="#topic+adapt_gam">adapt_gam</a></code>, <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a 100-dim covariate x
set.seed(0)
m &lt;- 100
n &lt;- 1000
x &lt;- matrix(runif(n * m), n, m)

# Generate the parameters from a conditional two-group
# logistic-Gamma GLM  where pi(x) and mu(x) are both
# linear in x. pi(x) has an intercept so that the average
# of pi(x) is 0.3
inv_logit &lt;- function(x) {exp(x) / (1 + exp(x))}
pi1 &lt;- 0.3
beta.pi &lt;- c(3, 3, rep(0, m-2))
beta0.pi &lt;- uniroot(function(b){
    mean(inv_logit(x %*% beta.pi + b)) - pi1
}, c(-100, 100))$root
pi &lt;- inv_logit(x %*% beta.pi + beta0.pi)
beta.mu &lt;- c(2, 2, rep(0, m-2))
beta0.mu &lt;- 0
mu &lt;- pmax(1, x %*% beta.mu + beta0.mu)

# Generate p-values
H0 &lt;- as.logical(ifelse(runif(n) &lt; pi, 1, 0))
y &lt;- ifelse(H0, rexp(n, 1/mu), rexp(n, 1))
pvals &lt;- exp(-y)

# Run adapt_glmnet
res &lt;- adapt_glmnet(x, pvals, s0 = rep(0.15, n), nfits = 5)

</code></pre>

<hr>
<h2 id='corr_lfdr'>Quantifying Information Loss of Adaptive P-Value Thresholding</h2><span id='topic+corr_lfdr'></span>

<h3>Description</h3>

<p><code>corr_lfdr</code> computes the oracle local FDR estimate, by using revealing all p-values, and computes the Pearson correlation between it and the estimate within each step of <code>adapt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_lfdr(obj, x, pvals, model = NULL, niter_oracle = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corr_lfdr_+3A_obj">obj</code></td>
<td>
<p>an 'adapt' object. Output of <code><a href="#topic+adapt">adapt</a></code> function</p>
</td></tr>
<tr><td><code id="corr_lfdr_+3A_x">x</code></td>
<td>
<p>covariates (i.e. side-information). Should be compatible to <code>models</code>.</p>
</td></tr>
<tr><td><code id="corr_lfdr_+3A_pvals">pvals</code></td>
<td>
<p>a vector of values in [0, 1]. P-values</p>
</td></tr>
<tr><td><code id="corr_lfdr_+3A_model">model</code></td>
<td>
<p>an optional argument. If <code>model = NULL</code> then the last model in <code>obj$models</code> is used for fitting the oracle model (i.e. with all p-values revealed). Otherwise it should be an 'adapt_model' object</p>
</td></tr>
<tr><td><code id="corr_lfdr_+3A_niter_oracle">niter_oracle</code></td>
<td>
<p>an positive integer. Number of iterations in EM algorithm</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>corra vector of values in [0, 1]. Pearson correlation of oracle local FDR estimate and the estimates within each step. Each value corresponds to an entry of <code>obj$params</code>
</p>
</li>
<li><p>oracle_lfdra vector of values in [0, 1]. Oracle local FDR estimate
</p>
</li>
<li><p>lfdra matrix of values in [0, 1]. Local FDR estimates within each step.
</p>
</li>
<li><p>alphasa vector of values in [0, 1]. The target FDR levels corresponding to each local FDR estimate
</p>
</li>
<li><p>nmasksa vector of integers. The number of masked p-values corresponding to each local FDR estimate
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Load estrogen data
data(estrogen)
pvals &lt;- as.numeric(estrogen$pvals)
x &lt;- data.frame(x = as.numeric(estrogen$ord_high))
dist &lt;- beta_family()

# Subsample the data for convenience
inds &lt;- (x$x &lt;= 5000)
pvals &lt;- pvals[inds]
x &lt;- x[inds,,drop = FALSE]

# Run adapt_glm
library("splines")
formulas &lt;- paste0("ns(x, df = ", 6:10, ")")
res &lt;- adapt_glm(x = x, pvals = pvals, pi_formulas = formulas,
                 mu_formulas = formulas, dist = dist, nfits = 10)

# Run corr_lfdr
obj &lt;- corr_lfdr(res, x, pvals)
obj$corr


</code></pre>

<hr>
<h2 id='ctgm_lfdr'>Fitting Conditional Two-Groups Models on Unmasked P-Values</h2><span id='topic+ctgm_lfdr'></span>

<h3>Description</h3>

<p><code>ctgm_lfdr</code> computes the oracle local FDR estimate, by using all p-values without masking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctgm_lfdr(x, pvals, models, dist = beta_family(), type = c("over", "raw"),
  params0 = list(pix = NULL, mux = NULL), niter = 50, cr = "BIC",
  verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ctgm_lfdr_+3A_x">x</code></td>
<td>
<p>covariates (i.e. side-information). Should be compatible to <code>models</code>. See Details</p>
</td></tr>
<tr><td><code id="ctgm_lfdr_+3A_pvals">pvals</code></td>
<td>
<p>a vector of values in [0, 1]. P-values</p>
</td></tr>
<tr><td><code id="ctgm_lfdr_+3A_models">models</code></td>
<td>
<p>an object of class &quot;<code>adapt_model</code>&quot; or a list of objects of class &quot;adapt_model&quot;. See Details</p>
</td></tr>
<tr><td><code id="ctgm_lfdr_+3A_dist">dist</code></td>
<td>
<p>an object of class &quot;<code><a href="#topic+gen_exp_family">gen_exp_family</a></code>&quot;. <code><a href="#topic+beta_family">beta_family</a>()</code> as default</p>
</td></tr>
<tr><td><code id="ctgm_lfdr_+3A_type">type</code></td>
<td>
<p>a character. Either &quot;over&quot; or &quot;raw&quot; indicating the type of local FDR estimates. See Details</p>
</td></tr>
<tr><td><code id="ctgm_lfdr_+3A_params0">params0</code></td>
<td>
<p>a list in the form of list(pix = , mux = ). Initial values of pi(x) and mu(x). Both can be set as NULL</p>
</td></tr>
<tr><td><code id="ctgm_lfdr_+3A_niter">niter</code></td>
<td>
<p>a positive integer. Number of EM iterations.</p>
</td></tr>
<tr><td><code id="ctgm_lfdr_+3A_cr">cr</code></td>
<td>
<p>a string. The criterion for model selection with BIC as default. Also support AIC, AICC and HIC</p>
</td></tr>
<tr><td><code id="ctgm_lfdr_+3A_verbose">verbose</code></td>
<td>
<p>a logical values in the form of list(fit = , ms = ). Indicate whether the progress of model fitting and model selection is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ctgm_lfdr</code> implements the EM algorithm to fit pi(x) and mu(x) on unmasked p-values. Although it is not related to FDR control of AdaPT, it provides useful measures for post-hoc justification and other purposes.
For instance, one can use these local FDR estimates for prioritizing the hypotheses if strict FDR control is not required.
</p>
<p>In contrast to <code>adapt</code>, <code>cytm_lfdr</code> does not guarantee FDR control unless the model is correctly specified. It is recommended to use <code>ctgm_lfdr</code> only when FDR control is not required.
</p>
<p><code>x</code> should have a type compatible to the fitting functions in <code>models</code>. For GLM and GAM, <code>x</code> should be a data.frame. For glmnet, <code>x</code> should be a matrix.
</p>
<p><code>models</code> could either be an <code>adapt_model</code> object, if a single model is used, or a list of <code>adapt_model</code> objects, each of which corresponding to a model. Each element should be generated by <code><a href="#topic+gen_adapt_model">gen_adapt_model</a></code>. For glm/gam/glmnet, one can use the shortcut by running <code><a href="#topic+gen_adapt_model">gen_adapt_model</a></code> with name = &quot;glm&quot; or &quot;gam&quot; or &quot;glmnet&quot; but without specifying <code>pifun</code>, <code>mufun</code>, <code>pifun_init</code> and <code>mufun_init</code>. See examples below.
</p>
<p>When <code>type = "over"</code>, it yields a conservative estimate of local FDR
</p>
<p style="text-align: center;"><code class="reqn">lfdr(p) = (1 - \pi_{1} + \pi_{1}f_{1}(1)) / (1 - \pi_{1} + \pi_{1}f_{1}(p)).</code>
</p>

<p>When <code>type = "raw"</code>, it yields the original local FDR.
</p>
<p style="text-align: center;"><code class="reqn">lfdr(p) = (1 - \pi_{1}) / (1 - \pi_{1} + \pi_{1}f_{1}(p)).</code>
</p>

<p>The former is shown to be more stable and reliable because the weak identifiability in conditional mixture models.
</p>


<h3>Value</h3>


<ul>
<li><p>lfdra vector of values in [0, 1]. Local FDR estimates of each hypothesis.
</p>
</li>
<li><p>modelan <code>adapt_model</code> object. The selected model if multiple models are provided.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Load estrogen data
data(estrogen)
pvals &lt;- as.numeric(estrogen$pvals)
x &lt;- data.frame(x = as.numeric(estrogen$ord_high))
dist &lt;- beta_family()

# Subsample the data for convenience
inds &lt;- (x$x &lt;= 5000)
pvals &lt;- pvals[inds]
x &lt;- x[inds,,drop = FALSE]

# Generate models for function adapt
library("splines")
formulas &lt;- paste0("ns(x, df = ", 6:10, ")")
models &lt;- lapply(formulas, function(formula){
    piargs &lt;- muargs &lt;- list(formula = formula)
    gen_adapt_model(name = "glm", piargs = piargs, muargs = muargs)
})

# Run ctgm_lfdr with two types of lfdr estimates
res_over &lt;- ctgm_lfdr(x, pvals, models, type = "over")
res_raw &lt;- ctgm_lfdr(x, pvals, models, type = "raw")

# Compare two estimates
par(mfrow = c(2, 1))
hist(res_over$lfdr)
hist(res_raw$lfdr)


</code></pre>

<hr>
<h2 id='estrogen'>Gene/Drug response dataset</h2><span id='topic+estrogen'></span>

<h3>Description</h3>

<p>P-values and ordering of genes drawn from a microarray dataset, consisting of 22283 genes on breast cancer cells in response to estrogen, from NCBI Gene Expression Omnibus (GEO) through 'GEOquery' package, with index &quot;GDS2324&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estrogen
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 22283 rows and 3 columns.</p>


<h3>Details</h3>

<p>The original dataset &quot;GDS2324&quot; consists of gene expression measurements for n = 22283 genes, in response to estrogen treatments in breast cancer cells for five groups of patients, with different dosage levels and 5 trials in each. The task is to identify the genes responding to a low dosage. The p-value for gene i is obtained by a one-sided permutation test which evaluates evidence for a change in gene expression level between the control group (placebo) and the low-dose group. The p-values are then ordered according to permutation t-statistics comparing the control and low-dose data, pooled, against data from a higher dosage (with genes that appear to have a strong response at higher dosages placed earlier in the list).
</p>
<p>Two orderings are considered: first, a stronger (more informative) ordering based on a comparison to the highest dosage; and second, a weaker (less informative) ordering based on a comparison to a medium dosage.
</p>
<p>The variables are as follows:
</p>

<ul>
<li><p> pvals. p-values
</p>
</li>
<li><p> ord_high. stronger ordering
</p>
</li>
<li><p> ord_mod. weaker ordering
</p>
</li></ul>

<p>The R code to produce the data can be found in '/extdata/estrogen_get_pvals.R'.
</p>

<hr>
<h2 id='gen_adapt_model'>adapt_model Objects for M-steps</h2><span id='topic+gen_adapt_model'></span>

<h3>Description</h3>

<p><code>adapt_model</code> objects provide the functions and their arguments in computing the M-steps.
Each object can be passed to <code><a href="#topic+adapt">adapt</a></code> as a candidate model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_adapt_model(pifun = NULL, mufun = NULL, pifun_init = NULL,
  mufun_init = NULL, piargs = list(), muargs = list(),
  piargs_init = list(), muargs_init = list(), name = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_adapt_model_+3A_pifun">pifun</code></td>
<td>
<p>a function to fit pi(x). See Details</p>
</td></tr>
<tr><td><code id="gen_adapt_model_+3A_mufun">mufun</code></td>
<td>
<p>a function to fit mu(x). See Details</p>
</td></tr>
<tr><td><code id="gen_adapt_model_+3A_pifun_init">pifun_init</code></td>
<td>
<p>a function to fit pi(x) at the initial step</p>
</td></tr>
<tr><td><code id="gen_adapt_model_+3A_mufun_init">mufun_init</code></td>
<td>
<p>a function to fit mu(x) at the initial step</p>
</td></tr>
<tr><td><code id="gen_adapt_model_+3A_piargs">piargs</code></td>
<td>
<p>a list. Arguments for &quot;pifun&quot;. An empty list as default</p>
</td></tr>
<tr><td><code id="gen_adapt_model_+3A_muargs">muargs</code></td>
<td>
<p>a list. Arguments for &quot;mufun&quot;. An empty list as default</p>
</td></tr>
<tr><td><code id="gen_adapt_model_+3A_piargs_init">piargs_init</code></td>
<td>
<p>a list. Arguments for piargs_init. An empty list as default</p>
</td></tr>
<tr><td><code id="gen_adapt_model_+3A_muargs_init">muargs_init</code></td>
<td>
<p>a list. Arguments for muargs_init. An empty list as default</p>
</td></tr>
<tr><td><code id="gen_adapt_model_+3A_name">name</code></td>
<td>
<p>a string. An optional argument for the user-specified name of the model. An empty string as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pifun</code> should be in the form of <code>pifun(formula, data, family, weights, ...)</code> or <code>pifun(x, y, family, ...)</code>.
The former includes <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="mgcv.html#topic+gam">gam</a></code> and the latter includes <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>.
The outputs should be in the form of <code>list(fitv = , info = , ...)</code> where <code>fitv</code> gives the estimate of pi(x),
as a vector with the same order of <code>x</code>, and <code>info</code> should at least contain a key <code>df</code> if model selection is used, i.e. <code>info = list(df = , ...)</code>
</p>
<p><code>mufun</code> should be in the form of <code>pifun(formula, data, family, weights, ...)</code> or <code>pifun(x, y, family, weights, ...)</code>.
Note that <code>mufun</code> must take <code>weights</code> as an input. The outputs should be in the same form as <code>pifun</code> except that <code>fitv</code> should give the estimate of mu(x).
</p>
<p>When <code>pifun</code> / <code>mufun</code> takes the form of <code>(formula, family, ...)</code>, <code>piargs</code> / <code>muargs</code> should at least contain a key <code>formula</code>; when <code>pifun</code> / <code>mufun</code> takes the form of <code>(x, y, family, ...)</code>, <code>piargs</code> / <code>muargs</code> can be empty.
</p>
<p>For glm/gam/glmnet, one can use the shortcut by running <code><a href="#topic+gen_adapt_model">gen_adapt_model</a></code> with name = &quot;glm&quot; or &quot;gam&quot; or &quot;glmnet&quot; but without specifying <code>pifun</code>, <code>mufun</code>, <code>pifun_init</code> and <code>mufun_init</code>. See examples below.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>name</code></td>
<td>
<p>same as the input <code>name</code></p>
</td></tr>
<tr><td><code>algo</code></td>
<td>
<p>a list recording <code>pifun</code>, <code>mufun</code>, <code>pifun_init</code> and <code>mufun_init</code></p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>a list recording <code>piargs</code>, <code>muargs</code>, <code>piargs_init</code> and <code>muargs_init</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Exemplary code to generate 'adapt_model' for logistic-Gamma glm  with naive initialization.
# The real implementation in the package is much more complicated.

# pifun as a logistic regression
pifun &lt;- function(formula, data, weights, ...){
  glm(formula, data, weights = weights, family = binomial(),  ...)
}
# pifun_init as a constant
pifun_init &lt;- function(x, pvals, s, ...){
  rep(0.1, length(pvals))
}
# mufun as a Gamma GLM
mufun &lt;- function(formula, data, weights, ...){
  glm(formula, data, weights = weights, family = Gamma(), ...)
}
# mufun_init as a constant
mufun_init &lt;- function(x, pvals, s, ...){
  rep(1.5, length(pvals))
}

library("splines") # for using ns() in the formula
piargs &lt;- list(formula = "ns(x, df = 8)")
muargs &lt;- list(formula = "ns(x, df = 8)")
name &lt;- "glm"

mod &lt;- gen_adapt_model(pifun, mufun, pifun_init, mufun_init,
                       piargs, muargs, name = name)
mod

# Using shortcut for GLM. See the last paragraph of Details.
mod2 &lt;- gen_adapt_model(name = "glm", piargs = piargs, muargs = muargs)
mod2


</code></pre>

<hr>
<h2 id='gen_exp_family'>Generate exp_family Objects for Exponential Families</h2><span id='topic+gen_exp_family'></span><span id='topic+beta_family'></span><span id='topic+inv_gaussian_family'></span>

<h3>Description</h3>

<p><code>exp_family</code> objects contain all required information in an exponential family to perform the E-step. The exponential function is encoded by
</p>
<p style="text-align: center;"><code class="reqn">h(p; \mu) = \exp\{(\eta(\mu) - \eta(\mu^{*})) g(p) - (A(\mu) - A(\mu^{*}))\}</code>
</p>

<p>where <code class="reqn">g(p)</code> is an arbitrary transformation, <code class="reqn">\mu</code> is the
<em>mean parameter</em>, <code class="reqn">\eta</code> is the natural parameter,
and <code class="reqn">A(\mu)</code> is the partition function. The extra redundant
parameter <code class="reqn">\mu^{*}</code> is to guarantee that <code class="reqn">U([0, 1])</code>
belongs to the class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_exp_family(g, ginv, eta, mustar, A, name = NULL, family = NULL)

beta_family()

inv_gaussian_family()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_exp_family_+3A_g">g</code></td>
<td>
<p>a function. An transformation of p-values</p>
</td></tr>
<tr><td><code id="gen_exp_family_+3A_ginv">ginv</code></td>
<td>
<p>a function. The inverse function of <code>g</code></p>
</td></tr>
<tr><td><code id="gen_exp_family_+3A_eta">eta</code></td>
<td>
<p>a function. The natural parameter as a function of the mean parameter <code>mu</code></p>
</td></tr>
<tr><td><code id="gen_exp_family_+3A_mustar">mustar</code></td>
<td>
<p>a scalar. The mean parameter that gives <code class="reqn">U([0, 1])</code></p>
</td></tr>
<tr><td><code id="gen_exp_family_+3A_a">A</code></td>
<td>
<p>a function. The partition function</p>
</td></tr>
<tr><td><code id="gen_exp_family_+3A_name">name</code></td>
<td>
<p>a string. A name for the family. NULL by default</p>
</td></tr>
<tr><td><code id="gen_exp_family_+3A_family">family</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+family">family</a></code>&quot; from <code>stats</code> package. The family used for model fitting in <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="glmnet.html#topic+glmnet">glmnet</a></code>, etc..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beta family (<code>beta_family()</code>): modeling p-values as Beta-distributed random variables, i.e. <code class="reqn">g(p) = -log(p)</code>, <code class="reqn">\eta(\mu) = -1 / \mu</code>, <code class="reqn">\mu* = 1</code>, <code class="reqn">A(\mu) = log(\mu)</code>, name = &quot;beta&quot; and family = Gamma(). Beta-family is highly recommended for general problems and used as default.
</p>
<p>Inverse-gaussian family (<code>inv_gaussian_family()</code>): modeling p-values as transformed z-scores, i.e. <code class="reqn">g(p) = \Phi^{-1}(p) (\Phi is the c.d.f. of a standard normal random variable)</code>, <code class="reqn">\eta(\mu) = \mu</code>, <code class="reqn">\mu* = 0</code>, <code class="reqn">A(\mu) = \mu^2 / 2</code>, name = &quot;inv_gaussian&quot; and family = gaussian().
</p>


<h3>Value</h3>

<p>an object of class &quot;exp_family&quot;. This includes all inputs and  <code>h</code>, the density function.
</p>

<hr>
<h2 id='plot_1d'>Plotting Functions for AdaPT with 1D Covariates</h2><span id='topic+plot_1d'></span><span id='topic+plot_1d_thresh'></span><span id='topic+plot_1d_lfdr'></span>

<h3>Description</h3>

<p>Plotting the outputs of <code>adapt</code> when <code>x</code> is 1-dimensional, including threshold curves and level curves of local FDR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_1d_thresh(obj, x, pvals, alpha, title, xlab = "x", xlim = NULL,
  disp_ymax = 0.2, num_yticks = 3, rand_seed_perturb = NA, ...)

plot_1d_lfdr(obj, x, pvals, alpha, title, xlab = "x", xlim = NULL,
  disp_ymax = 0.2, num_yticks = 3, legend_pos = "topright", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_1d_+3A_obj">obj</code></td>
<td>
<p>an 'adapt' object</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_x">x</code></td>
<td>
<p>covariates (i.e. side-information). Should be compatible to <code>models</code> and 1-dimensional.</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_pvals">pvals</code></td>
<td>
<p>a vector of values in [0, 1]. P-values</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_alpha">alpha</code></td>
<td>
<p>a positive scalar in (0, 1). Target FDR level</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_title">title</code></td>
<td>
<p>a string. Title of the figure</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_xlab">xlab</code></td>
<td>
<p>a string. Label of the x-axis</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_xlim">xlim</code></td>
<td>
<p>a vector of length 2. Limits of x-axis</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_disp_ymax">disp_ymax</code></td>
<td>
<p>a positive scalar in (0, 1]. Maximum value displayed in the y-axis</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_num_yticks">num_yticks</code></td>
<td>
<p>a positive integer. Number of ticks in the y-axis</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_rand_seed_perturb">rand_seed_perturb</code></td>
<td>
<p>random seed if jitter is added. NA if no jittering is needed</p>
</td></tr>
<tr><td><code id="plot_1d_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot_1d_+3A_legend_pos">legend_pos</code></td>
<td>
<p>a string. Position of the legend</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load estrogen data
data(estrogen)
pvals &lt;- as.numeric(estrogen$pvals)
x &lt;- data.frame(x = as.numeric(estrogen$ord_high))
dist &lt;- beta_family()

# Subsample the data for convenience
inds &lt;- (x$x &lt;= 5000)
pvals &lt;- pvals[inds]
x &lt;- x[inds,,drop = FALSE]

# Run adapt_glm
library("splines")
formulas &lt;- paste0("ns(x, df = ", 6:10, ")")
res &lt;- adapt_glm(x = x, pvals = pvals, pi_formulas = formulas,
                 mu_formulas = formulas, dist = dist, nfits = 10)

# Plots
par(mfrow = c(2, 1))
plot_1d_thresh(res, x, pvals, 0.1, "P-value Thresholds (alpha = 0.1)",
               disp_ymax = 0.5)
plot_1d_lfdr(res, x, pvals, 0.1, "Level Curves of lfdr (alpha = 0.1)",
             disp_ymax = 0.5)

</code></pre>

<hr>
<h2 id='plot_2d'>Plotting Functions for AdaPT with 2D Covariates</h2><span id='topic+plot_2d'></span><span id='topic+plot_2d_thresh'></span><span id='topic+plot_2d_lfdr'></span>

<h3>Description</h3>

<p>Plotting the outputs of <code>adapt</code> when <code>x</code> is 2-dimensional, including threshold curves and level curves of local FDR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_2d_thresh(obj, x, pvals, alpha, title, xlab = NULL, ylab = NULL,
  keyaxes = list(), ...)

plot_2d_lfdr(obj, x, pvals, alpha, title, targetp, xlab = NULL, ylab = NULL,
  keyaxes = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_2d_+3A_obj">obj</code></td>
<td>
<p>an 'adapt' object</p>
</td></tr>
<tr><td><code id="plot_2d_+3A_x">x</code></td>
<td>
<p>covariates (i.e. side-information). Should be compatible to <code>models</code> and 2-dimensional.</p>
</td></tr>
<tr><td><code id="plot_2d_+3A_pvals">pvals</code></td>
<td>
<p>a vector of values in [0, 1]. P-values</p>
</td></tr>
<tr><td><code id="plot_2d_+3A_alpha">alpha</code></td>
<td>
<p>a positive scalar in (0, 1). Target FDR level</p>
</td></tr>
<tr><td><code id="plot_2d_+3A_title">title</code></td>
<td>
<p>a string. Title of the figure</p>
</td></tr>
<tr><td><code id="plot_2d_+3A_xlab">xlab</code>, <code id="plot_2d_+3A_ylab">ylab</code></td>
<td>
<p>a string. Label of x/y-axis</p>
</td></tr>
<tr><td><code id="plot_2d_+3A_keyaxes">keyaxes</code></td>
<td>
<p>a list of arguments passed into axis. The graphical setting for the legend bar. An empty list by default</p>
</td></tr>
<tr><td><code id="plot_2d_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot_2d_+3A_targetp">targetp</code></td>
<td>
<p>a real in (0, 1). See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The breaks in the legend of <code>plot_2d_thresh</code> correspond to the maximum, the 95
</p>
<p><code>plot_2d_lfdr</code> gives the contour plot of local FDR estimates when all p-values are equal to <code>targetp</code>. It is recommended to run <code>plot_2d_lfdr</code> for multiple <code>targetp</code>'s ranging from 0.001, 0.005, 0.01, 0.05.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a 2-dim x
n &lt;- 400
x1 &lt;- x2 &lt;- seq(-100, 100, length.out = 20)
x &lt;- expand.grid(x1, x2)
colnames(x) &lt;- c("x1", "x2")

# Generate p-values (one-sided z test)
# Set all hypotheses in the central circle with radius 30 to be
# non-nulls. For non-nulls, z~N(2,1) and for nulls, z~N(0,1).
H0 &lt;- apply(x, 1, function(coord){sum(coord^2) &lt; 900})
mu &lt;- ifelse(H0, 2, 0)
set.seed(0)
zvals &lt;- rnorm(n) + mu
pvals &lt;- 1 - pnorm(zvals)

# Run adapt_gam with a 2d spline basis
library("mgcv")
formula &lt;- "s(x1, x2)"
dist &lt;- beta_family()
res &lt;- adapt_gam(x = x, pvals = pvals, pi_formulas = formula,
                 mu_formulas = formula, dist = dist, nfits = 5)

# Plots
plot_2d_thresh(res, x, pvals, 0.3, "P-value Thresholds (alpha = 0.3)")
plot_2d_lfdr(res, x, pvals, 0.3, "Local FDR Estimates (alpha = 0.3, p = 0.01)", 0.01)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
