<!DOCTYPE html><html><head><title>Help for package tidytidbits</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidytidbits}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_prop_test'><p>Add results of prop.test to data frame</p></a></li>
<li><a href='#all_or_all_na'><p>All() giving NA only if all values are NA</p></a></li>
<li><a href='#any_or_all_na'><p>Any() giving NA only if all values are NA</p></a></li>
<li><a href='#append_object'><p>Appending in a pipe, never unlisting</p></a></li>
<li><a href='#are_true'><p>Vectorised conversion to logical, treating NA as False</p></a></li>
<li><a href='#as_formatted_number'><p>Format numeric value for output</p></a></li>
<li><a href='#as_formatted_p_value'><p>Formatting p values</p></a></li>
<li><a href='#as_percentage_label'><p>Format as percentage for output</p></a></li>
<li><a href='#categorical_test_by'><p>Categorical test in a pipe</p></a></li>
<li><a href='#contingency_table_as_matrix'><p>Convert contingency table to classical R matrix</p></a></li>
<li><a href='#contingency_table_by'><p>Create data frame formed like a contingency-table</p></a></li>
<li><a href='#count_at'><p>Count by multiple variables</p></a></li>
<li><a href='#count_by'><p>Count according to grouping</p></a></li>
<li><a href='#dina'><p>The DIN A paper formats</p></a></li>
<li><a href='#equal_including_na'><p>Compare vectors, treating NA like a value</p></a></li>
<li><a href='#eval_unquoted'><p>Execute code after tidy evaluation</p></a></li>
<li><a href='#expression_list'><p>Extract symbols from an expression of symbols and operators</p></a></li>
<li><a href='#first_non_nas'><p>Row-wise first value which is not NA</p></a></li>
<li><a href='#first_non_nas_at'><p>Row-wise first value that is not NA</p></a></li>
<li><a href='#first_not'><p>First argument that does not equal a given value</p></a></li>
<li><a href='#first_not_na'><p>First argument that is not NA</p></a></li>
<li><a href='#first_which_non_na_at'><p>Row-wise first index of column that is not NA</p></a></li>
<li><a href='#first_which_not_na'><p>First which() is not na</p></a></li>
<li><a href='#format_numbers_at'><p>Format numeric columns for display</p></a></li>
<li><a href='#format_p_values_at'><p>Format numeric columns for display</p></a></li>
<li><a href='#identity_order'><p>Ordering function: identity order</p></a></li>
<li><a href='#invalid'><p>A notion of valid and invalid</p></a></li>
<li><a href='#invert_value_and_names'><p>Inverting name and value</p></a></li>
<li><a href='#local_variables'><p>&quot;Variable generating&quot; functions</p></a></li>
<li><a href='#lookup'><p>Lookup in a dictionary</p></a></li>
<li><a href='#lookup_function_from_dict'><p>Creating a lookup function from dictionary</p></a></li>
<li><a href='#lump'><p>Generic lumping</p></a></li>
<li><a href='#lump_rows'><p>Lump rows of a tibble</p></a></li>
<li><a href='#named_palette'><p>Named color palette</p></a></li>
<li><a href='#order_factor_by'><p>Reorder a factor</p></a></li>
<li><a href='#orderer_function_from_sorted_vectors'><p>Orderer function for complex sorting</p></a></li>
<li><a href='#pluck_vector'><p>Pluck with simplified return value</p></a></li>
<li><a href='#prepare_directory'><p>Directory creation</p></a></li>
<li><a href='#prepare_path'><p>Directory creation and file path concatenation</p></a></li>
<li><a href='#prepend_object'><p>Prepending in a pipe, never unlisting</p></a></li>
<li><a href='#print_deparsed'><p>Print deparsed language</p></a></li>
<li><a href='#rename_factor'><p>Rename a factor.</p></a></li>
<li><a href='#rename_reorder_factor'><p>Rename and reorder a factor.</p></a></li>
<li><a href='#replace_sequential_duplicates'><p>Replace sequential duplicates</p></a></li>
<li><a href='#save_pdf'><p>Save plot as PDF</p></a></li>
<li><a href='#save_png'><p>Save plot as PNG</p></a></li>
<li><a href='#sequential_duplicates'><p>Detect sequential duplicates</p></a></li>
<li><a href='#str_locate_match'><p>Combine str_match and str_locate</p></a></li>
<li><a href='#symbol_as_quosure'><p>Make quosure from symbol</p></a></li>
<li><a href='#syntactically_safe'><p>Syntactically safe names</p></a></li>
<li><a href='#true_or_na'><p>Test for logical true or NA</p></a></li>
<li><a href='#truthy'><p>A python / javascript-like &quot;truthy&quot; notion</p></a></li>
<li><a href='#tuple_assignment'><p>Infix operator for python-style tuple assignment</p></a></li>
<li><a href='#which_non_na'><p>Get indices of non-NA values</p></a></li>
<li><a href='#with_name'><p>Slice by name</p></a></li>
<li><a href='#with_value_containing'><p>Slice by value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Collection of Tools and Helpers Extending the Tidyverse</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcel Wiesweg [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcel Wiesweg &lt;marcel.wiesweg@uk-essen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A selection of various tools to extend a data analysis workflow based on the 'tidyverse' packages.
  This includes high-level data frame editing methods (in the style of 'mutate'/'mutate_at'), some methods in the style of
  'purrr' and 'forcats', 'lookup' methods for dict-like lists, a generic method for lumping a data frame by a given count,
  various low-level methods for special treatment of 'NA' values, 'python'-style tuple-assignment and 'truthy'/'falsy' checks,
  saving to PDF and PNG from a pipe and various small utilities.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, grDevices, methods, rlang (&ge; 0.4.0), dplyr (&ge;
1.0.0), forcats, grid, purrr, stringr, tibble, tidyr,
tidyselect, extrafont, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-16 17:52:06 UTC; marcel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-16 22:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_prop_test'>Add results of prop.test to data frame</h2><span id='topic+add_prop_test'></span>

<h3>Description</h3>

<p>Adds prop.test results as columns to data frame based on data in columns
For use with a tibble in a pipe:
Using one-group prop.test, adds confidence intervals (with given conf.level)
for the proportion of x positive results in n trials,
and the p value that the proportion is equal to p (default: 0.5)
(to add the estimated proportion itself, use <code><a href="#topic+count_by">count_by</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_prop_test(
  .df,
  x,
  n,
  p = NULL,
  CI_lower_name = "CI_lower",
  CI_upper_name = "CI_upper",
  p_name = "p",
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  correct = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_prop_test_+3A_.df">.df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="add_prop_test_+3A_x">x</code></td>
<td>
<p>The column/vector with the number of positive results</p>
</td></tr>
<tr><td><code id="add_prop_test_+3A_n">n</code></td>
<td>
<p>The column/vector/constant with the number of trials</p>
</td></tr>
<tr><td><code id="add_prop_test_+3A_p">p</code></td>
<td>
<p>Assumed proportion: Will add a p-value that the proportion is equal to p (default: 0.5)</p>
</td></tr>
<tr><td><code id="add_prop_test_+3A_ci_lower_name">CI_lower_name</code>, <code id="add_prop_test_+3A_ci_upper_name">CI_upper_name</code>, <code id="add_prop_test_+3A_p_name">p_name</code></td>
<td>
<p>Column names of the added columns</p>
</td></tr>
<tr><td><code id="add_prop_test_+3A_alternative">alternative</code>, <code id="add_prop_test_+3A_conf.level">conf.level</code>, <code id="add_prop_test_+3A_correct">correct</code></td>
<td>
<p>As for <code><a href="stats.html#topic+prop.test">prop.test</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with columns added
</p>


<h3>See Also</h3>

<p><code><a href="#topic+count_by">count_by</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
if (requireNamespace("survival", quietly = TRUE))
{
   survival::aml %&gt;%
   count_by(x) %&gt;%
   add_prop_test(n, sum(n), rel)
}
</code></pre>

<hr>
<h2 id='all_or_all_na'>All() giving NA only if all values are NA</h2><span id='topic+all_or_all_na'></span>

<h3>Description</h3>

<p>All() giving NA only if all values are NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_or_all_na(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_or_all_na_+3A_...">...</code></td>
<td>
<p>Values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA if and only if all ... are NA, else all(...), ignoring NA values
</p>

<hr>
<h2 id='any_or_all_na'>Any() giving NA only if all values are NA</h2><span id='topic+any_or_all_na'></span>

<h3>Description</h3>

<p>Any() giving NA only if all values are NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_or_all_na(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="any_or_all_na_+3A_...">...</code></td>
<td>
<p>Values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA if and only if all ... are NA, else any(...), ignoring NA values
</p>

<hr>
<h2 id='append_object'>Appending in a pipe, never unlisting</h2><span id='topic+append_object'></span>

<h3>Description</h3>

<p>Append to a given list, while considering as a single object and not unlisting as base::append does.
Argument order is reversed compared to base::append to allow a different pattern of use in a pipe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_object(x, .l, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_object_+3A_x">x</code></td>
<td>
<p>Object to append. If the object is a list, then it is appended as-is, and not unlisted.</p>
</td></tr>
<tr><td><code id="append_object_+3A_.l">.l</code></td>
<td>
<p>The list to append to.
Special case handling applies if .l does not exist: then an empty list is used.
This alleviates the need for an initial mylist &lt;- list()</p>
</td></tr>
<tr><td><code id="append_object_+3A_name">name</code></td>
<td>
<p>Will be used as name of the object in the list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list .l with x appended
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
results &lt;- list(first=c(3,4), second=list(5,6))
list(7,8) %&gt;%
  append_object(results, "third result") -&gt;
results
# results has length 1, containing one list named "first"
</code></pre>

<hr>
<h2 id='are_true'>Vectorised conversion to logical, treating NA as False</h2><span id='topic+are_true'></span>

<h3>Description</h3>

<p>Vectorised conversion to logical, treating NA as False
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_true(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_true_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of same size as x which is true where x is true (<code>rlang::<a href="rlang.html#topic+as_logical">as_logical</a></code>) and not NA
</p>

<hr>
<h2 id='as_formatted_number'>Format numeric value for output</h2><span id='topic+as_formatted_number'></span>

<h3>Description</h3>

<p>Vectorised conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_formatted_number(x, decimal_places = 1, remove_trailing_zeroes = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_formatted_number_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="as_formatted_number_+3A_decimal_places">decimal_places</code></td>
<td>
<p>Decimal places to display</p>
</td></tr>
<tr><td><code id="as_formatted_number_+3A_remove_trailing_zeroes">remove_trailing_zeroes</code></td>
<td>
<p>If the required decimal places are less than decimal places,
should resulting trailing zeros be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_formatted_number(0.74167, 2) # gives "0.74"
</code></pre>

<hr>
<h2 id='as_formatted_p_value'>Formatting p values</h2><span id='topic+as_formatted_p_value'></span>

<h3>Description</h3>

<p>Vectorised conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_formatted_p_value(
  x,
  decimal_places = 3,
  prefix = "p",
  less_than_cutoff = 0.001,
  remove_trailing_zeroes = T,
  alpha = 0.05,
  ns_replacement = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_formatted_p_value_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="as_formatted_p_value_+3A_decimal_places">decimal_places</code></td>
<td>
<p>Decimal places to display</p>
</td></tr>
<tr><td><code id="as_formatted_p_value_+3A_prefix">prefix</code></td>
<td>
<p>Prefix to prepend (default &quot;p=&quot;)</p>
</td></tr>
<tr><td><code id="as_formatted_p_value_+3A_less_than_cutoff">less_than_cutoff</code></td>
<td>
<p>Cut-off for small p values. Values smaller than this will be displayed like &quot;p&lt;...&quot;</p>
</td></tr>
<tr><td><code id="as_formatted_p_value_+3A_remove_trailing_zeroes">remove_trailing_zeroes</code></td>
<td>
<p>If the required decimal places are less than decimal places,
should resulting trailing zeros be removed?</p>
</td></tr>
<tr><td><code id="as_formatted_p_value_+3A_alpha">alpha</code></td>
<td>
<p>Cut-off for assuming significance, usually 0.05</p>
</td></tr>
<tr><td><code id="as_formatted_p_value_+3A_ns_replacement">ns_replacement</code></td>
<td>
<p>If p value is not significant (is &gt; alpha), it will be replace by this string (e.g. &quot;n.s.&quot;)
If NULL (default), no replacement is performed.
</p>
<p>Vectorised (in parallel) over x, prefix, less_than_cutoff, alpha and ns_replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_formatted_p_value(0.02) # "p=0.02"
as_formatted_p_value(0.00056) # "p&lt;0.001"
</code></pre>

<hr>
<h2 id='as_percentage_label'>Format as percentage for output</h2><span id='topic+as_percentage_label'></span>

<h3>Description</h3>

<p>Vectorised conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_percentage_label(x, decimal_places = 1, include_plus_sign = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_percentage_label_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="as_percentage_label_+3A_decimal_places">decimal_places</code></td>
<td>
<p>Decimal places to display</p>
</td></tr>
<tr><td><code id="as_percentage_label_+3A_include_plus_sign">include_plus_sign</code></td>
<td>
<p>prepend a &quot;+&quot; to the output if positive (if negative, a &quot;-&quot; must be prepended of course)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_percentage_label(0.746) # gives "74.6%"
</code></pre>

<hr>
<h2 id='categorical_test_by'>Categorical test in a pipe</h2><span id='topic+categorical_test_by'></span>

<h3>Description</h3>

<p>Performs classical categorical tests on two columns of a
data frame.
Per default, will perform <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
or <code><a href="stats.html#topic+fisher.test">fisher.test</a></code> on the
contingency table created by var1 and var2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorical_test_by(
  .tbl,
  var1,
  var2,
  na.rm = T,
  test_function_generator = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="categorical_test_by_+3A_.tbl">.tbl</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="categorical_test_by_+3A_var1">var1</code></td>
<td>
<p>First column to count by</p>
</td></tr>
<tr><td><code id="categorical_test_by_+3A_var2">var2</code></td>
<td>
<p>Second column to count by</p>
</td></tr>
<tr><td><code id="categorical_test_by_+3A_na.rm">na.rm</code></td>
<td>
<p>Shall NA values be removed prior to counting?</p>
</td></tr>
<tr><td><code id="categorical_test_by_+3A_test_function_generator">test_function_generator</code></td>
<td>
<p>A function receiving the matrix to test and
returning a named vector with the test function to use. The default uses
fisher.test if one count is 5 or lower, otherwise chisq.test.
Test functions must return a value with at least one component named &quot;p.value&quot;.</p>
</td></tr>
<tr><td><code id="categorical_test_by_+3A_...">...</code></td>
<td>
<p>Passed on to the test function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a one-line data frame as result and thus plays nicely
with for example <code><a href="purrr.html#topic+map_dfr">map_dfr</a></code>.
</p>


<h3>Value</h3>

<p>A one-row data frame with the columns:</p>

<ul>
<li><p> &quot;var1,var2&quot;: The tested variables
</p>
</li>
<li><p> &quot;test&quot;: Label of the test function (default: fisher or chisq)
</p>
</li>
<li><p> &quot;p-value&quot;: P value
</p>
</li>
<li><p> &quot;result&quot;: List column with full result object (default: htest)
</p>
</li>
<li><p> &quot;contingency_table&quot;: List column with contingency table data frame
as return by <code><a href="#topic+contingency_table_by">contingency_table_by</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
if (requireNamespace("datasets", quietly = TRUE))
{
   mtcars %&gt;% categorical_test_by(cyl &gt;= 6, gear)
}
</code></pre>

<hr>
<h2 id='contingency_table_as_matrix'>Convert contingency table to classical R matrix</h2><span id='topic+contingency_table_as_matrix'></span>

<h3>Description</h3>

<p>Converts the result of <code><a href="#topic+contingency_table_by">contingency_table_by</a></code>
to a classical matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contingency_table_as_matrix(table_frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contingency_table_as_matrix_+3A_table_frame">table_frame</code></td>
<td>
<p>Result of <code><a href="#topic+contingency_table_by">contingency_table_by</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>

<hr>
<h2 id='contingency_table_by'>Create data frame formed like a contingency-table</h2><span id='topic+contingency_table_by'></span>

<h3>Description</h3>

<p>Counts by the specified two variables and the pivots the
count data frame wider to a two-dimensional contingency table.
Please note that the resulting data frame is suitable for convenient
output or use with functions that work on matrix-like data,
but does not fulfill the tidy data criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contingency_table_by(.tbl, var1, var2, na.rm = F, add_margins = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contingency_table_by_+3A_.tbl">.tbl</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="contingency_table_by_+3A_var1">var1</code></td>
<td>
<p>First column to count by</p>
</td></tr>
<tr><td><code id="contingency_table_by_+3A_var2">var2</code></td>
<td>
<p>Second column to count by</p>
</td></tr>
<tr><td><code id="contingency_table_by_+3A_na.rm">na.rm</code></td>
<td>
<p>Shall NA values be removed prior to counting?</p>
</td></tr>
<tr><td><code id="contingency_table_by_+3A_add_margins">add_margins</code></td>
<td>
<p>Add row- and column wise margins as extra column and row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
if (requireNamespace("datasets", quietly = TRUE))
{
   mtcars %&gt;% contingency_table_by(cyl, gear)
}
</code></pre>

<hr>
<h2 id='count_at'>Count by multiple variables</h2><span id='topic+count_at'></span>

<h3>Description</h3>

<p>Count by multiple variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_at(
  .tbl,
  .vars,
  .grouping = vars(),
  label_style = "long",
  long_label_column_names = c("variable", "category"),
  column_names = c("n", "rel", "percent"),
  na_label = "missing",
  percentage_label_decimal_places = 1,
  add_grouping = T,
  na.rm = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_at_+3A_.tbl">.tbl</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="count_at_+3A_.vars">.vars</code></td>
<td>
<p>A list of variables (created using vars()) for which <code><a href="#topic+count_by">count_by</a></code> is to be called</p>
</td></tr>
<tr><td><code id="count_at_+3A_.grouping">.grouping</code></td>
<td>
<p>Additional grouping to apply prior to counting</p>
</td></tr>
<tr><td><code id="count_at_+3A_label_style">label_style</code></td>
<td>
<p>Character vector containing one of &quot;wide&quot; and &quot;long&quot; or both.</p>

<ul>
<li><p> &quot;wide&quot;: Include labels in wide format, i.e., for each variable one column named as variable
and giving the label for the corresponding count, but NA for all rows from different variables
</p>
</li>
<li><p> &quot;long&quot;: Include two meta columns, one giving the variable that is counted (value from .vars),
the second giving the label (which value/category of the variable is counted?).
</p>
</li></ul>
</td></tr>
<tr><td><code id="count_at_+3A_long_label_column_names">long_label_column_names</code></td>
<td>
<p>Character vector of size 2: If label_style contains &quot;long&quot;,
the names for the additional meta columns for variable and category</p>
</td></tr>
<tr><td><code id="count_at_+3A_column_names">column_names</code></td>
<td>
<p>vector if size 1 to 3, giving the names of (in order if unnamed, or named with n, rel, percent)
the column containing the count, the relative proportion, and the latter formatted as a percent label.
If a name is not contained, it will not be added (requires named vector).</p>
</td></tr>
<tr><td><code id="count_at_+3A_na_label">na_label</code></td>
<td>
<p>If na.rm=F, label to use for counting NA values</p>
</td></tr>
<tr><td><code id="count_at_+3A_percentage_label_decimal_places">percentage_label_decimal_places</code></td>
<td>
<p>Decimal precision of the percent label</p>
</td></tr>
<tr><td><code id="count_at_+3A_add_grouping">add_grouping</code></td>
<td>
<p>Shall a pre-existing grouping be preserved for counting (adding the newly specified grouping)?
Default is yes, which differs from group_by.</p>
</td></tr>
<tr><td><code id="count_at_+3A_na.rm">na.rm</code></td>
<td>
<p>Shall NA values be removed prior to counting?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame concatenated from individual count_by results, with labels as per label_style.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
library(datasets)
library(dplyr)
mtcars %&gt;% count_at(vars(gear, cyl))
</code></pre>

<hr>
<h2 id='count_by'>Count according to grouping</h2><span id='topic+count_by'></span>

<h3>Description</h3>

<p>Similar to <code>dplyr::<a href="covr.html#topic+count">count</a>()</code>, but also adds the relative proportion and
a percent-formatted string of the relative proportion,
and allows to specify the column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_by(
  .tbl,
  ...,
  column_names = c("n", "rel", "percent"),
  percentage_label_decimal_places = 1,
  add_grouping = T,
  na.rm = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_by_+3A_.tbl">.tbl</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="count_by_+3A_...">...</code></td>
<td>
<p>Columns / expressions by which to group / which shall be used for counting.</p>
</td></tr>
<tr><td><code id="count_by_+3A_column_names">column_names</code></td>
<td>
<p>vector if size 1 to 3, giving the names of (in order if unnamed, or named with n, rel, percent)
the column containing the count, the relative proportion, and the latter formatted as a percent label.
If a name is not contained, it will not be added (requires named vector).</p>
</td></tr>
<tr><td><code id="count_by_+3A_percentage_label_decimal_places">percentage_label_decimal_places</code></td>
<td>
<p>Decimal precision of the percent label</p>
</td></tr>
<tr><td><code id="count_by_+3A_add_grouping">add_grouping</code></td>
<td>
<p>Shall a pre-existing grouping be preserved for counting (adding the newly specified grouping)?
Default is yes, which differs from group_by.</p>
</td></tr>
<tr><td><code id="count_by_+3A_na.rm">na.rm</code></td>
<td>
<p>Shall NA values be removed prior to counting?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The counted data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
if (requireNamespace("survival", quietly = TRUE))
{
   survival::aml %&gt;%
   count_by(x)
}
</code></pre>

<hr>
<h2 id='dina'>The DIN A paper formats</h2><span id='topic+dina'></span><span id='topic+dinAFormat'></span><span id='topic+dinA_format'></span><span id='topic+dinA'></span><span id='topic+dinAWidth'></span><span id='topic+dinA_width'></span><span id='topic+dinAHeight'></span><span id='topic+dinA_height'></span>

<h3>Description</h3>

<p>The DIN A paper formats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinAFormat()

dinA_format()

dinA(n)

dinAWidth(n)

dinA_width(n)

dinAHeight(n)

dinA_height(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dina_+3A_n">n</code></td>
<td>
<p>DIN A paper format index (0-10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list (0-10) of named vectors (long, short) of unit objects with the size in inches of the DIN A paper formats
</p>
<p>named unit vector (long, short) with the size in inches of the requested DIN A paper format
</p>
<p>the long side / width in landscape as a unit object in inches
</p>
<p>the short side / height in landscape as a unit object in inches
</p>


<h3>See Also</h3>

<p><a href="grid.html#topic+unit">unit</a>
</p>

<hr>
<h2 id='equal_including_na'>Compare vectors, treating NA like a value</h2><span id='topic+equal_including_na'></span>

<h3>Description</h3>

<p>Compare vectors, treating NA like a value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equal_including_na(v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equal_including_na_+3A_v1">v1</code>, <code id="equal_including_na_+3A_v2">v2</code></td>
<td>
<p>Vectors of equal size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a logical vector of the same size as v1 and v2, TRUE wherever elements are the same.
NA is treated like a value level, i.e., NA == NA is true, NA == 1 is false.
</p>

<hr>
<h2 id='eval_unquoted'>Execute code after tidy evaluation</h2><span id='topic+eval_unquoted'></span>

<h3>Description</h3>

<p>This function takes R code as arguments and executes this code in the calling environment.
All quoted variables (using rlang's quasiquotation, !! or !!!) will be unquoted prior to evaluation.
This results in executed in code in which the variable is replaced verbatim by its value,
as if you had typed the variable's value.
This is particularly useful for functions using base R's substitute() approach, such
as functions taking formulas, and you have built the formula dynamically.
It is unnecessary for all functions based on tidy_eval (dplyr).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_unquoted(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_unquoted_+3A_...">...</code></td>
<td>
<p>R code snippets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the last evaluated expression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rlang)
# Note that evaluation takes place in the calling environment!
l &lt;- quo(l &lt;- 1) # l is a quosure in our env
eval_unquoted(!!l)
l == 1 # TRUE: l is now a vector
</code></pre>

<hr>
<h2 id='expression_list'>Extract symbols from an expression of symbols and operators</h2><span id='topic+expression_list'></span><span id='topic+quosure_list'></span><span id='topic+symbol_string_list'></span>

<h3>Description</h3>

<p>Extract symbols from an expression of symbols and operators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expression_list(expr, seps = "+")

quosure_list(expr, seps = "+", env = caller_env())

symbol_string_list(expr, seps = "+")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expression_list_+3A_expr">expr</code></td>
<td>
<p>A language expression</p>
</td></tr>
<tr><td><code id="expression_list_+3A_seps">seps</code></td>
<td>
<p>Operators to consider as separators</p>
</td></tr>
<tr><td><code id="expression_list_+3A_env">env</code></td>
<td>
<p>Environment for the created quosure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of all symbols in the expression, as symbol, quosure or text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression_list(a+b+c+d)
</code></pre>

<hr>
<h2 id='first_non_nas'>Row-wise first value which is not NA</h2><span id='topic+first_non_nas'></span>

<h3>Description</h3>

<p>This is useful in conjunction with dplyr's mutate to condense multiple columns to one,
where in each sample typically only one of n columns has a value, while the others are NA.
Returns one vector of the same length as each input vector containing the result.
Note that factors will be converted to character vectors (with a warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_non_nas(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_non_nas_+3A_...">...</code></td>
<td>
<p>multiple vectors of same type and size, regarded as columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of type and size as any of the given vectors
(vectors regarded a column, number of rows is size of each vectors)
For each &quot;row&quot;, returns the first value that is not NA, or NA iff all values in the row are NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(magrittr)
library(dplyr)
# Creates a column containing (4, 2, 2)
tibble(a=c(NA, NA, 2), b=c(4, NA, 5), c=c(1, 2, 3)) %&gt;%
  mutate(essence=first_non_nas(a, b, c))
</code></pre>

<hr>
<h2 id='first_non_nas_at'>Row-wise first value that is not NA</h2><span id='topic+first_non_nas_at'></span>

<h3>Description</h3>

<p>Row-wise first value that is not NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_non_nas_at(.tbl, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_non_nas_at_+3A_.tbl">.tbl</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="first_non_nas_at_+3A_...">...</code></td>
<td>
<p>A column selection, as for <code>dplyr::<a href="MASS.html#topic+select">select</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length nrow(.tbl) containing the first found non-na value
</p>

<hr>
<h2 id='first_not'>First argument that does not equal a given value</h2><span id='topic+first_not'></span>

<h3>Description</h3>

<p>First argument that does not equal a given value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_not(not, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_not_+3A_not">not</code></td>
<td>
<p>Value: we look for the first value not equal to this one</p>
</td></tr>
<tr><td><code id="first_not_+3A_...">...</code></td>
<td>
<p>Values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first value that does not equal &quot;not&quot;, or NA iff all equal &quot;not&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 5
first_not(1, 1,1,1,5)
</code></pre>

<hr>
<h2 id='first_not_na'>First argument that is not NA</h2><span id='topic+first_not_na'></span>

<h3>Description</h3>

<p>First argument that is not NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_not_na(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_not_na_+3A_...">...</code></td>
<td>
<p>Values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument that is not NA, or NA iff all are NA
</p>

<hr>
<h2 id='first_which_non_na_at'>Row-wise first index of column that is not NA</h2><span id='topic+first_which_non_na_at'></span>

<h3>Description</h3>

<p>Row-wise first index of column that is not NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_which_non_na_at(.tbl, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_which_non_na_at_+3A_.tbl">.tbl</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="first_which_non_na_at_+3A_...">...</code></td>
<td>
<p>A column selection, as for <code>dplyr::<a href="MASS.html#topic+select">select</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length nrow(.tbl) containing the index of the first found non-na value in the given columns.
Possible values are NA (all values in that row are NA), and 1 ... number of columns in selection
</p>

<hr>
<h2 id='first_which_not_na'>First which() is not na</h2><span id='topic+first_which_not_na'></span>

<h3>Description</h3>

<p>First which() is not na
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_which_not_na(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_which_not_na_+3A_...">...</code></td>
<td>
<p>Values; concatenated as given. Intended use is with one vector of length &gt; 1 or multiple single arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index of the first value which is not NA, or NA iff all elements are NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 4
first_which_not_na(NA, NA, NA, 56)
</code></pre>

<hr>
<h2 id='format_numbers_at'>Format numeric columns for display</h2><span id='topic+format_numbers_at'></span>

<h3>Description</h3>

<p>Combines <code><a href="dplyr.html#topic+mutate_at">mutate_at</a>()</code> and <code><a href="#topic+as_formatted_number">as_formatted_number</a>()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_numbers_at(.tbl, .vars, decimal_places = 1, remove_trailing_zeroes = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_numbers_at_+3A_.tbl">.tbl</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="format_numbers_at_+3A_.vars">.vars</code></td>
<td>
<p>A vars() list of symbolic columns</p>
</td></tr>
<tr><td><code id="format_numbers_at_+3A_decimal_places">decimal_places</code></td>
<td>
<p>Decimal places to display</p>
</td></tr>
<tr><td><code id="format_numbers_at_+3A_remove_trailing_zeroes">remove_trailing_zeroes</code></td>
<td>
<p>If the required decimal places are less than decimal places,
should resulting trailing zeros be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of mutate_at
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_p_values_at">format_p_values_at</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(magrittr)
library(dplyr)
tibble(a=c(0.1, 0.238546)) %&gt;%
    format_numbers_at(vars(a))
</code></pre>

<hr>
<h2 id='format_p_values_at'>Format numeric columns for display</h2><span id='topic+format_p_values_at'></span>

<h3>Description</h3>

<p>Combines <code><a href="dplyr.html#topic+mutate_at">mutate_at</a>()</code> and <code><a href="#topic+as_formatted_p_value">as_formatted_p_value</a>()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_p_values_at(
  .tbl,
  .vars,
  decimal_places = 3,
  prefix = "p",
  less_than_cutoff = 0.001,
  remove_trailing_zeroes = T,
  alpha = 0.05,
  ns_replacement = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_p_values_at_+3A_.tbl">.tbl</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="format_p_values_at_+3A_.vars">.vars</code></td>
<td>
<p>A vars() list of symbolic columns</p>
</td></tr>
<tr><td><code id="format_p_values_at_+3A_decimal_places">decimal_places</code></td>
<td>
<p>Decimal places to display</p>
</td></tr>
<tr><td><code id="format_p_values_at_+3A_prefix">prefix</code></td>
<td>
<p>Prefix to prepend (default &quot;p=&quot;)</p>
</td></tr>
<tr><td><code id="format_p_values_at_+3A_less_than_cutoff">less_than_cutoff</code></td>
<td>
<p>Cut-off for small p values. Values smaller than this will be displayed like &quot;p&lt;...&quot;</p>
</td></tr>
<tr><td><code id="format_p_values_at_+3A_remove_trailing_zeroes">remove_trailing_zeroes</code></td>
<td>
<p>If the required decimal places are less than decimal places,
should resulting trailing zeros be removed?</p>
</td></tr>
<tr><td><code id="format_p_values_at_+3A_alpha">alpha</code></td>
<td>
<p>Cut-off for assuming significance, usually 0.05</p>
</td></tr>
<tr><td><code id="format_p_values_at_+3A_ns_replacement">ns_replacement</code></td>
<td>
<p>If p value is not significant (is &gt; alpha), it will be replace by this string (e.g. &quot;n.s.&quot;)
If NULL (default), no replacement is performed.
</p>
<p>Vectorised (in parallel) over x, prefix, less_than_cutoff, alpha and ns_replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of mutate_at
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format_numbers_at">format_numbers_at</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(magrittr)
library(dplyr)
tibble(p=c(0.05, 0.0001)) %&gt;%
    format_numbers_at(vars(p))
</code></pre>

<hr>
<h2 id='identity_order'>Ordering function: identity order</h2><span id='topic+identity_order'></span>

<h3>Description</h3>

<p>This can be used in a place where a function with a signature like <code><a href="base.html#topic+order">order</a></code> is required.
It simply retains the original order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identity_order(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identity_order_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="identity_order_+3A_...">...</code></td>
<td>
<p>Effectively ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector
</p>

<hr>
<h2 id='invalid'>A notion of valid and invalid</h2><span id='topic+invalid'></span><span id='topic+valid'></span>

<h3>Description</h3>

<p>An object is valid if it is not null, not missing (NA), and is not an empty vector.
Note that this is per se not vectorised, because a non-empty list or vector is valid as such.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invalid(x)

valid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invalid_+3A_x">x</code></td>
<td>
<p>Any object, value or NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>valid</code>: x is not invalid
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>invalid(NULL) # TRUE
invalid(NA) # TRUE
invalid(list()) # TRUE
invalid("a") # FALSE
invalid(c(1,2,3)) # FALSE
</code></pre>

<hr>
<h2 id='invert_value_and_names'>Inverting name and value</h2><span id='topic+invert_value_and_names'></span>

<h3>Description</h3>

<p>Inverting name and value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_value_and_names(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_value_and_names_+3A_v">v</code></td>
<td>
<p>A named vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector where names(v) are the values and the values of v are the names
</p>

<hr>
<h2 id='local_variables'>&quot;Variable generating&quot; functions</h2><span id='topic+local_variables'></span><span id='topic+localVariables'></span><span id='topic+source_variables'></span><span id='topic+sourceVariables'></span>

<h3>Description</h3>

<p>A pair of functions that allows a &quot;variable generating&quot; function
and read this function's local vars into the environment of the caller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_variables(env = parent.frame())

localVariables(env = parent.frame())

source_variables(localVars)

sourceVariables(localVars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_variables_+3A_env">env</code></td>
<td>
<p>Parent environment</p>
</td></tr>
<tr><td><code id="local_variables_+3A_localvars">localVars</code></td>
<td>
<p>Result of function call exporting an environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector of created local variables
</p>
<p>The updated environment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myVariableGeneratingFunction &lt;- function()
{
  x &lt;- 1
  y &lt;- 2
  local_variables()
}
myMainFunction &lt;- function()
{
  source_variables(myVariableGeneratingFunction())
  print(c(x, y))
}
</code></pre>

<hr>
<h2 id='lookup'>Lookup in a dictionary</h2><span id='topic+lookup'></span><span id='topic+lookup_int'></span><span id='topic+lookup_chr'></span><span id='topic+lookup_lgl'></span><span id='topic+lookup_dbl'></span><span id='topic+lookup_num'></span>

<h3>Description</h3>

<p>Looks up all values as keys of the dictionary and returns the values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup(dict, ..., default = NA, dict_key_is_regex = F, key_is_regex = F)

lookup_int(dict, ..., default = NA, dict_key_is_regex = F, key_is_regex = F)

lookup_chr(dict, ..., default = NA, dict_key_is_regex = F, key_is_regex = F)

lookup_lgl(dict, ..., default = NA, dict_key_is_regex = F, key_is_regex = F)

lookup_dbl(dict, ..., default = NA, dict_key_is_regex = F, key_is_regex = F)

lookup_num(dict, ..., default = NA, dict_key_is_regex = F, key_is_regex = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_+3A_dict">dict</code></td>
<td>
<p>A dictionaryish vector (named: key -&gt; value)</p>
</td></tr>
<tr><td><code id="lookup_+3A_...">...</code></td>
<td>
<p>Keys to lookup in the dictionary</p>
</td></tr>
<tr><td><code id="lookup_+3A_default">default</code></td>
<td>
<p>Default value to return if key is not found. Can be a value or function (called with the key).
Note: default is to return NA; another very intuitive case is to return the key itself.
To achieve this, pass <code>default = identity</code>.</p>
</td></tr>
<tr><td><code id="lookup_+3A_dict_key_is_regex">dict_key_is_regex</code></td>
<td>
<p>Should the dictionary keys, the names of dict,
be regarded as regular expressions? (excludes key_is_regex)</p>
</td></tr>
<tr><td><code id="lookup_+3A_key_is_regex">key_is_regex</code></td>
<td>
<p>Should the keys to lookup be regarded as regular expressions? (excludes dict_key_is_regex)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same size as ..., containing the lookup results. For the type-specific functions,
returns a vector typed as requested, requiring all lookup results to have matching type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- list("x", "y", "z")
dict &lt;- c(x="xc", y="yv")
# returns c("xc", "yv", na_chr)
lookup_chr(dict, a)#'
# returns c("xc", "yv", "z")
lookup_chr(dict, "x", "y", "z", default=identity)
</code></pre>

<hr>
<h2 id='lookup_function_from_dict'>Creating a lookup function from dictionary</h2><span id='topic+lookup_function_from_dict'></span>

<h3>Description</h3>

<p>Creating a lookup function from dictionary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup_function_from_dict(dict, default = identity, dict_key_is_regex = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_function_from_dict_+3A_dict">dict</code></td>
<td>
<p>A dictionaryish character vector (named: key -&gt; value)</p>
</td></tr>
<tr><td><code id="lookup_function_from_dict_+3A_default">default</code></td>
<td>
<p>Value to return if key is not found, or function to evaluate with key as argument</p>
</td></tr>
<tr><td><code id="lookup_function_from_dict_+3A_dict_key_is_regex">dict_key_is_regex</code></td>
<td>
<p>If True, treats dictionary keys are regular expressions when matching</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function which can be called with keys and performs the described lookup, returning the value (string)
</p>

<hr>
<h2 id='lump'>Generic lumping</h2><span id='topic+lump'></span>

<h3>Description</h3>

<p>Takes levels (labels, factor levels) and corresponding counts
and &quot;lumps&quot; according to specified criteria (either n or prop), i.e.
preserves some rows and summarises the rest in a single &quot;Other&quot; row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lump(
  levels,
  count,
  n,
  prop,
  other_level = "Other",
  ties.method = c("min", "average", "first", "last", "random", "max")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lump_+3A_levels">levels</code></td>
<td>
<p>Vector of levels</p>
</td></tr>
<tr><td><code id="lump_+3A_count">count</code></td>
<td>
<p>Vector of corresponding counts</p>
</td></tr>
<tr><td><code id="lump_+3A_n">n</code></td>
<td>
<p>If specified, n rows shall be preserved.</p>
</td></tr>
<tr><td><code id="lump_+3A_prop">prop</code></td>
<td>
<p>If specified, rows shall be preserved if their count &gt;= prop</p>
</td></tr>
<tr><td><code id="lump_+3A_other_level">other_level</code></td>
<td>
<p>Name of the &quot;other&quot; level to be created from lumped rows</p>
</td></tr>
<tr><td><code id="lump_+3A_ties.method">ties.method</code></td>
<td>
<p>Method to apply in case of ties</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dictionary (named vector) of levels -&gt; new levels
</p>

<hr>
<h2 id='lump_rows'>Lump rows of a tibble</h2><span id='topic+lump_rows'></span>

<h3>Description</h3>

<p>A verb for a dplyr pipeline:
In the given data frame, take the .level column as a set of levels and the .count column
as corresponding counts. Return a data frame where the rows are lumped according to levels/counts
using the parameters n, prop, other_level, ties.method like for <code><a href="#topic+lump">lump</a>()</code>.
The resulting row for other_level has <code>level=other level</code>, <code>count=sum(count of all lumped rows)</code>.
For the remaining columns, either a default concatenation is used, or you can provide
custom summarising statements via the summarising_statements parameter.
Provide a list named by the column you want to summarize, giving statements wrapped in quo(),
using syntax as you would for a call to summarise().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lump_rows(
  .df,
  .level,
  .count,
  summarising_statements = quos(),
  n,
  prop,
  remaining_levels,
  other_level = "Other",
  ties.method = c("min", "average", "first", "last", "random", "max")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lump_rows_+3A_.df">.df</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="lump_rows_+3A_.level">.level</code></td>
<td>
<p>Column name (symbolic) containing a set of levels</p>
</td></tr>
<tr><td><code id="lump_rows_+3A_.count">.count</code></td>
<td>
<p>Column name (symbolic) containing counts of the levels</p>
</td></tr>
<tr><td><code id="lump_rows_+3A_summarising_statements">summarising_statements</code></td>
<td>
<p>The &quot;lumped&quot; rows need to have all their columns summarised into one row.
This parameter is a vars() list of arguments as if used in a call to <code><a href="dplyr.html#topic+summarise">summarise</a>()</code>,
name is column name, value is language.
If not provided for a column, a default summary will be used
which takes the sum if numeric, concatenates text, or uses any() if logical.</p>
</td></tr>
<tr><td><code id="lump_rows_+3A_n">n</code></td>
<td>
<p>If specified, n rows shall be preserved.</p>
</td></tr>
<tr><td><code id="lump_rows_+3A_prop">prop</code></td>
<td>
<p>If specified, rows shall be preserved if their count &gt;= prop</p>
</td></tr>
<tr><td><code id="lump_rows_+3A_remaining_levels">remaining_levels</code></td>
<td>
<p>Levels that should explicitly not be lumped</p>
</td></tr>
<tr><td><code id="lump_rows_+3A_other_level">other_level</code></td>
<td>
<p>Name of the &quot;other&quot; level to be created from lumped rows</p>
</td></tr>
<tr><td><code id="lump_rows_+3A_ties.method">ties.method</code></td>
<td>
<p>Method to apply in case of ties</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The lumped data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lump">lump</a></code>
</p>

<hr>
<h2 id='named_palette'>Named color palette</h2><span id='topic+named_palette'></span>

<h3>Description</h3>

<p>Returns the palette named by names.
This is useful to pick only a few specific colors from a larger palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named_palette(palette, names, color_order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="named_palette_+3A_palette">palette</code></td>
<td>
<p>Colors</p>
</td></tr>
<tr><td><code id="named_palette_+3A_names">names</code></td>
<td>
<p>Names</p>
</td></tr>
<tr><td><code id="named_palette_+3A_color_order">color_order</code></td>
<td>
<p>If specified, will reorder palette by this ordering vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named palette.
If the palette is longer than names, will only use the first n entries.
If names is longer than palette, will recycle colors.
</p>

<hr>
<h2 id='order_factor_by'>Reorder a factor</h2><span id='topic+order_factor_by'></span>

<h3>Description</h3>

<p>Makes f a factor ordered according to ... (which is passed to order)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_factor_by(.f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_factor_by_+3A_.f">.f</code></td>
<td>
<p>A factor</p>
</td></tr>
<tr><td><code id="order_factor_by_+3A_...">...</code></td>
<td>
<p>Passed to  <code><a href="base.html#topic+order">order</a>()</code>. Should be vectors of the same size as .f.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a thin wrapper around <code>forcats::<a href="forcats.html#topic+fct_reorder">fct_reorder</a>()</code>, which is unintuitive in conjunction with order().
</p>


<h3>Value</h3>

<p>Reordered factor
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rename_reorder_factor">rename_reorder_factor</a></code>, <code><a href="#topic+rename_factor">rename_factor</a></code>, <code>forcats::<a href="forcats.html#topic+fct_reorder">fct_reorder</a></code>
</p>

<hr>
<h2 id='orderer_function_from_sorted_vectors'>Orderer function for complex sorting</h2><span id='topic+orderer_function_from_sorted_vectors'></span>

<h3>Description</h3>

<p>If you want to order by multiple features and have sorted vectors for each feature
which describe the intended order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderer_function_from_sorted_vectors(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderer_function_from_sorted_vectors_+3A_...">...</code></td>
<td>
<p>k sorted vectors, in order of priority</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function which takes (at least) k vectors
This function will return an order for these vectors determined by the sorted vectors
</p>

<hr>
<h2 id='pluck_vector'>Pluck with simplified return value</h2><span id='topic+pluck_vector'></span>

<h3>Description</h3>

<p>Like <code>purrr::<a href="purrr.html#topic+pluck">pluck</a>()</code>, but will return simplify()'ed as a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pluck_vector(.x, ..., .default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pluck_vector_+3A_.x">.x</code></td>
<td>
<p>Container object</p>
</td></tr>
<tr><td><code id="pluck_vector_+3A_...">...</code></td>
<td>
<p>Accessor specification</p>
</td></tr>
<tr><td><code id="pluck_vector_+3A_.default">.default</code></td>
<td>
<p>Default value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of <code>purrr::<a href="purrr.html#topic+pluck">pluck</a>()</code>, transformed y <code>purrr::<a href="igraph.html#topic+simplify">simplify</a>()</code>
</p>

<hr>
<h2 id='prepare_directory'>Directory creation</h2><span id='topic+prepare_directory'></span>

<h3>Description</h3>

<p>Creates directory if it does not yet exist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_directory(folder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_directory_+3A_folder">folder</code></td>
<td>
<p>Folder path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Folder path
</p>

<hr>
<h2 id='prepare_path'>Directory creation and file path concatenation</h2><span id='topic+prepare_path'></span>

<h3>Description</h3>

<p>Given a folder, file base name and suffix, ensures the
directory exists, and returns the ready file path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_path(folder, fileBaseName, fileSuffix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_path_+3A_folder">folder</code></td>
<td>
<p>Folder path, without trailing slash</p>
</td></tr>
<tr><td><code id="prepare_path_+3A_filebasename">fileBaseName</code></td>
<td>
<p>File base name, excluding trailing dot</p>
</td></tr>
<tr><td><code id="prepare_path_+3A_filesuffix">fileSuffix</code></td>
<td>
<p>File suffix without leading dot (e.g., &quot;png&quot;, &quot;pdf&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Complete file path
</p>

<hr>
<h2 id='prepend_object'>Prepending in a pipe, never unlisting</h2><span id='topic+prepend_object'></span>

<h3>Description</h3>

<p>Prepend to a given list, while considering as a single object and not unlisting.
Argument order is reversed compared to base::append or purrr::prepend to allow a different pattern of use in a pipe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepend_object(x, .l, name = NULL, before = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepend_object_+3A_x">x</code></td>
<td>
<p>Object to prepend. If the object is a list, then it is appended as-is, and not unlisted.</p>
</td></tr>
<tr><td><code id="prepend_object_+3A_.l">.l</code></td>
<td>
<p>The list to append to.
Special case handling applies if .l does not exist: then an empty list is used.
This alleviates the need for an initial mylist &lt;- list()</p>
</td></tr>
<tr><td><code id="prepend_object_+3A_name">name</code></td>
<td>
<p>Will be used as name of the object in the list</p>
</td></tr>
<tr><td><code id="prepend_object_+3A_before">before</code></td>
<td>
<p>Prepend before this index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list .l with x prepended
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' library(tibble)
library(magrittr)
library(dplyr)
results &lt;- list(second=list(1,2), third=list(3))
list(-1, 1) %&gt;%
  prepend_object(results, "first") -&gt;
results
# results has length 3, containing three lists
</code></pre>

<hr>
<h2 id='print_deparsed'>Print deparsed language</h2><span id='topic+print_deparsed'></span>

<h3>Description</h3>

<p>Prints deparsed R language tree of given expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_deparsed(language)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_deparsed_+3A_language">language</code></td>
<td>
<p>R language</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible null
</p>

<hr>
<h2 id='rename_factor'>Rename a factor.</h2><span id='topic+rename_factor'></span>

<h3>Description</h3>

<p>Renames the levels of a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_factor(.f, ..., reorder = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_factor_+3A_.f">.f</code></td>
<td>
<p>A factor or vector (if .f is not yet a factor, it is made one)</p>
</td></tr>
<tr><td><code id="rename_factor_+3A_...">...</code></td>
<td>
<p>Dictionaryish arguments, named by old level, value is new level (&quot;old level&quot; = &quot;new level&quot;).
You can pass single named arguments, or named vectors or named lists, which will be spliced.</p>
</td></tr>
<tr><td><code id="rename_factor_+3A_reorder">reorder</code></td>
<td>
<p>Logical: If True, the levels will additionally be reordered
in the order of first appearance in the arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A renamed and reordered factor
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rename_reorder_factor">rename_reorder_factor</a></code>, <code><a href="#topic+order_factor_by">order_factor_by</a></code>,
<code>forcats::<a href="forcats.html#topic+fct_recode">fct_recode</a></code>, <code>forcats::<a href="forcats.html#topic+fct_relevel">fct_relevel</a></code>
</p>

<hr>
<h2 id='rename_reorder_factor'>Rename and reorder a factor.</h2><span id='topic+rename_reorder_factor'></span>

<h3>Description</h3>

<p>The factor will be recoded according to value_label_dict and, if requested,
also reordered by the order of this vector.
Secondly, the vector will be reordered according to reorder_vector, if given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_reorder_factor(
  .f,
  value_label_dict,
  reorder_vector,
  reorder_by_value_label_dict = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_reorder_factor_+3A_.f">.f</code></td>
<td>
<p>A factor or vector (if .f is not yet a factor, it is made one)</p>
</td></tr>
<tr><td><code id="rename_reorder_factor_+3A_value_label_dict">value_label_dict</code></td>
<td>
<p>a dictionary (named list or vector) of old-&gt;new factor levels</p>
</td></tr>
<tr><td><code id="rename_reorder_factor_+3A_reorder_vector">reorder_vector</code></td>
<td>
<p>vector of factor levels (the new levels according to value_label_dict).
It need not contain all levels, only those found will be reorderer first</p>
</td></tr>
<tr><td><code id="rename_reorder_factor_+3A_reorder_by_value_label_dict">reorder_by_value_label_dict</code></td>
<td>
<p>Should the factor also be reordered following the order of value_label_dict?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A renamed and reordered factor
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rename_factor">rename_factor</a></code>, <code><a href="#topic+order_factor_by">order_factor_by</a></code>,
<code>forcats::<a href="forcats.html#topic+fct_recode">fct_recode</a></code>, <code>forcats::<a href="forcats.html#topic+fct_relevel">fct_relevel</a></code>
</p>

<hr>
<h2 id='replace_sequential_duplicates'>Replace sequential duplicates</h2><span id='topic+replace_sequential_duplicates'></span>

<h3>Description</h3>

<p>Replace sequential duplicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_sequential_duplicates(strings, replace_with = "", ordering = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_sequential_duplicates_+3A_strings">strings</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="replace_sequential_duplicates_+3A_replace_with">replace_with</code></td>
<td>
<p>Replacement string</p>
</td></tr>
<tr><td><code id="replace_sequential_duplicates_+3A_ordering">ordering</code></td>
<td>
<p>Optional: treat strings as if ordered like strings[ordering], or,
if a function, strings[ordering(strings)]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with strings identical to the previous string replaced with replace_with
</p>


<h3>Examples</h3>

<pre><code class='language-R'># returns c("a", "", "b", "", "", "a")
replace_sequential_duplicates(c("a", "a", "b", "b", "b", "a"))
</code></pre>

<hr>
<h2 id='save_pdf'>Save plot as PDF</h2><span id='topic+save_pdf'></span>

<h3>Description</h3>

<p>Save plot as PDF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_pdf(plot, folder, fileBaseName, width, height, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_pdf_+3A_plot">plot</code></td>
<td>
<p>A plot object that can be printed, e.g. result of ggplot2, plot_grid</p>
</td></tr>
<tr><td><code id="save_pdf_+3A_folder">folder</code></td>
<td>
<p>Destination folder (will be created if it does not exist)</p>
</td></tr>
<tr><td><code id="save_pdf_+3A_filebasename">fileBaseName</code></td>
<td>
<p>File base name (suffix &quot;.pdf&quot; will be added)</p>
</td></tr>
<tr><td><code id="save_pdf_+3A_width">width</code>, <code id="save_pdf_+3A_height">height</code></td>
<td>
<p>PDF width and height in inches or as <code>grid::<a href="grid.html#topic+unit">unit</a></code>.
If missing and the plot object has a &quot;papersize&quot; attribute c(width, height), this will be used.</p>
</td></tr>
<tr><td><code id="save_pdf_+3A_...">...</code></td>
<td>
<p>Further arguments which will be passed to <code><a href="grDevices.html#topic+cairo_pdf">cairo_pdf</a></code>, e.g. family</p>
</td></tr>
</table>

<hr>
<h2 id='save_png'>Save plot as PNG</h2><span id='topic+save_png'></span>

<h3>Description</h3>

<p>Save plot as PNG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_png(
  plot,
  folder,
  fileBaseName,
  width,
  height,
  dpi = 300,
  background = c("white", "transparent"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_png_+3A_plot">plot</code></td>
<td>
<p>A plot object that can be printed, e.g. result of ggplot2, plot_grid</p>
</td></tr>
<tr><td><code id="save_png_+3A_folder">folder</code></td>
<td>
<p>Destination folder (will be created if it does not exist)</p>
</td></tr>
<tr><td><code id="save_png_+3A_filebasename">fileBaseName</code></td>
<td>
<p>File base name (suffix &quot;.png&quot; will be added)</p>
</td></tr>
<tr><td><code id="save_png_+3A_width">width</code>, <code id="save_png_+3A_height">height</code></td>
<td>
<p>PNG width and height in inches or as <code>grid::<a href="grid.html#topic+unit">unit</a></code>.
If missing and the plot object has a &quot;papersize&quot; attribute c(width, height), this will be used.</p>
</td></tr>
<tr><td><code id="save_png_+3A_dpi">dpi</code></td>
<td>
<p>Resolution (determines file size in pixels, as size is given in inches)</p>
</td></tr>
<tr><td><code id="save_png_+3A_background">background</code></td>
<td>
<p>Initial background color, &quot;white&quot; or &quot;transparent&quot;</p>
</td></tr>
<tr><td><code id="save_png_+3A_...">...</code></td>
<td>
<p>Further arguments which will be passed to <code><a href="grDevices.html#topic+png">png</a></code>, e.g. family</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible NULL
</p>

<hr>
<h2 id='sequential_duplicates'>Detect sequential duplicates</h2><span id='topic+sequential_duplicates'></span>

<h3>Description</h3>

<p>Detect sequential duplicates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequential_duplicates(strings, ordering = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequential_duplicates_+3A_strings">strings</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="sequential_duplicates_+3A_ordering">ordering</code></td>
<td>
<p>Optional: treat strings as if ordered like strings[ordering], or,
if a function, strings[ordering(strings)]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector which indicates if a string is identical to the previous string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># return c(F, T, F, T, T, F)
sequential_duplicates(c("a", "a", "b", "b", "b", "a"))
</code></pre>

<hr>
<h2 id='str_locate_match'>Combine str_match and str_locate</h2><span id='topic+str_locate_match'></span>

<h3>Description</h3>

<p>For every pattern, return the index of the first match of pattern in strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_locate_match(patterns, strings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_locate_match_+3A_patterns">patterns</code></td>
<td>
<p>Character vector of patterns</p>
</td></tr>
<tr><td><code id="str_locate_match_+3A_strings">strings</code></td>
<td>
<p>Character vector of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector of length(patterns) where entry i gives the index in strings where pattern i first matched
</p>

<hr>
<h2 id='symbol_as_quosure'>Make quosure from symbol</h2><span id='topic+symbol_as_quosure'></span>

<h3>Description</h3>

<p>Make quosure from symbol
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbol_as_quosure(x, env = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbol_as_quosure_+3A_x">x</code></td>
<td>
<p>Symbol</p>
</td></tr>
<tr><td><code id="symbol_as_quosure_+3A_env">env</code></td>
<td>
<p>Environment for the created quosure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quosure containing the symbol
</p>

<hr>
<h2 id='syntactically_safe'>Syntactically safe names</h2><span id='topic+syntactically_safe'></span>

<h3>Description</h3>

<p>Makes the names syntactically safe by wrapping them in &ldquo; if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syntactically_safe(expr_strings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syntactically_safe_+3A_expr_strings">expr_strings</code></td>
<td>
<p>Strings to convert to syntactically safe form</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Strings converted to syntactically safe form
</p>

<hr>
<h2 id='true_or_na'>Test for logical true or NA</h2><span id='topic+true_or_na'></span>

<h3>Description</h3>

<p>Test for logical true or NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>true_or_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="true_or_na_+3A_x">x</code></td>
<td>
<p>Logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True if and only if x is TRUE or x is NA, False otherwise.
</p>

<hr>
<h2 id='truthy'>A python / javascript-like &quot;truthy&quot; notion</h2><span id='topic+truthy'></span><span id='topic+falsy'></span>

<h3>Description</h3>

<p>Values are truthy that are not null, NA, empty, 0, or FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truthy(x)

falsy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truthy_+3A_x">x</code></td>
<td>
<p>Any object, value or NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this is per se not vectorised, because a non-empty list or vector is &quot;truthy&quot; as such.
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>falsy</code>: x is not truthy
</p>
</li></ul>

<hr>
<h2 id='tuple_assignment'>Infix operator for python-style tuple assignment</h2><span id='topic+tuple_assignment'></span><span id='topic++25+3D+25'></span><span id='topic+g'></span>

<h3>Description</h3>

<p>Infix operator for python-style tuple assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l %=% r

g(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tuple_assignment_+3A_l">l</code></td>
<td>
<p>left-hand side: &quot;tuple&quot; or variables created by <code>g()</code></p>
</td></tr>
<tr><td><code id="tuple_assignment_+3A_r">r</code></td>
<td>
<p>right-hand side: Vector to assign to left-hand side variable</p>
</td></tr>
<tr><td><code id="tuple_assignment_+3A_...">...</code></td>
<td>
<p>Left-hand side variables to group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Last assigned value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g(a,b) %=% c(1,2) # equivalent to a &lt;- 1; b &lt;- 2
</code></pre>

<hr>
<h2 id='which_non_na'>Get indices of non-NA values</h2><span id='topic+which_non_na'></span>

<h3>Description</h3>

<p>Get indices of non-NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_non_na(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_non_na_+3A_...">...</code></td>
<td>
<p>k vectors of the same length n, regarded as k columns with each n rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of n numerical vectors. Each numerical vector has a size between 0 and k and contains the
indices of the vectors whose elements are not na in the corresponding row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(magrittr)
library(dplyr)
# Creates a list column containing (2,3);(3);(1,2,3)
tibble(a=c(NA, NA, 2), b=c(4, NA, 5), c=c(1, 2, 3)) %&gt;%
  mutate(non_na_idc=which_non_na(a, b, c))
</code></pre>

<hr>
<h2 id='with_name'>Slice by name</h2><span id='topic+with_name'></span><span id='topic+with_name_containing'></span><span id='topic+named'></span><span id='topic+name_contains'></span>

<h3>Description</h3>

<p>Slices of a vector with elements of given name, or containing given patterns.
Analogous accessor functions for <code>purrr::<a href="purrr.html#topic+pluck">pluck</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_name(v, name)

with_name_containing(v, pattern)

named(name)

name_contains(pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_name_+3A_v">v</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="with_name_+3A_name">name</code></td>
<td>
<p>Name of entry to pluck</p>
</td></tr>
<tr><td><code id="with_name_+3A_pattern">pattern</code></td>
<td>
<p>Pattern passed to <code>stringr::<a href="stringr.html#topic+str_detect">str_detect</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A slice from v containing all elements in v with the given name,
or the name of which contains pattern
</p>

<hr>
<h2 id='with_value_containing'>Slice by value</h2><span id='topic+with_value_containing'></span><span id='topic+value_contains'></span>

<h3>Description</h3>

<p>Slices of a vector with elements containing given patterns.
Analogous accessor function for <code>purrr::<a href="purrr.html#topic+pluck">pluck</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_value_containing(v, pattern)

value_contains(pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_value_containing_+3A_v">v</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="with_value_containing_+3A_pattern">pattern</code></td>
<td>
<p>Pattern passed to <code>stringr::<a href="stringr.html#topic+str_detect">str_detect</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A slice from v containing all elements in v with the given name,
or the name of which contains pattern
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
