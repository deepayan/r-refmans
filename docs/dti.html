<!DOCTYPE html><html><head><title>Help for package dti</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dti}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdjacencyMatrix'>
<p>Create an adjacency matrix from fiber tracking results</p></a></li>
<li><a href='#awssigmc'>
<p>Estimate noise variance for multicoil MR systems</p></a></li>
<li><a href='#colqFA'><p>FA map color scheme</p></a></li>
<li><a href='#combineDWIdata'><p>Combine two objects of class &quot;dtiData&quot;)</p></a></li>
<li><a href='#dkiTensor-methods'><p>Diffusion Kurtosis Imaging (DKI)</p></a></li>
<li><a href='#dti-package'>
<p>Analysis of Diffusion Weighted Imaging (DWI) Data</p></a></li>
<li><a href='#dti.options'>
<p>Set and manipulate image orientations for plots.</p></a></li>
<li><a href='#dti.smooth-methods'><p> Methods for Function &lsquo;dti.smooth&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#dtiIndices-methods'><p> Methods for Function &lsquo;dtiIndices&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#dtiTensor-methods'><p> Methods for Function &lsquo;dtiTensor&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#dwi-class'><p>Class &quot;dwi&quot;</p></a></li>
<li><a href='#dwi.smooth-methods'><p>Smooth DWI data</p></a></li>
<li><a href='#dwiMD-methods'><p> Methods for Mean Diffusivity in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#dwiMixtensor-methods'><p> Methods for Function &lsquo;dwiMixtensor&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#dwiQball-methods'><p> Methods for Function &lsquo;dwiQball&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#dwiRiceBias-methods'><p> Correction for Rician Bias</p></a></li>
<li><a href='#dwiSqrtODF-methods'><p> Methods for positive definite EAP and ODF estimation in Package <span class="pkg">dti</span></p></a></li>
<li><a href='#extract-methods'><p> Methods for Function &lsquo;extract&rsquo; and &lsquo;[&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#getmask-methods'><p> Methods for Function &lsquo;getmask&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#getsdofsb-methods'><p> Estimate the noise standard deviation</p></a></li>
<li><a href='#medinria'><p> Read/Write Diffusion Tensor Data from/to NIFTI File</p></a></li>
<li><a href='#optgrad'><p>Optimal gradient directions</p></a></li>
<li><a href='#optgradients'><p>Optimal gradient directions for number of gradients between 6 and 162</p></a></li>
<li><a href='#plot-methods'><p> Methods for Function &lsquo;plot&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#polyeder'><p>Polyeders derived from the Icosahedron (icosa0) by</p>
sequential triangulation of surface triangles</a></li>
<li><a href='#print-methods'><p> Methods for Function &lsquo;print&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#readDWIdata'><p> Read Diffusion Weighted Data</p></a></li>
<li><a href='#sdpar-methods'><p> Methods for Function &lsquo;sdpar&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#setmask-methods'><p> Methods for Function &lsquo;setmask&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#show-methods'><p> Methods for Function &lsquo;show&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#show3d-methods'><p> Methods for Function &lsquo;show3d&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#showFAColorScale'>
<p>Writes an image with the colqFA colorscale to disk.</p></a></li>
<li><a href='#subsetg'>
<p>Create an objects of class &quot;dtiData&quot; containing only a subset of gradient directions.</p></a></li>
<li><a href='#summary-methods'><p> Methods for Function &lsquo;summary&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
<li><a href='#tracking-methods'><p> Methods for Function &lsquo;tracking&rsquo; in Package &lsquo;dti&rsquo;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-06</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Diffusion Weighted Imaging (DWI) Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Karsten Tabelow [aut, cre],
  Joerg Polzehl [aut],
  Felix Anker [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karsten Tabelow &lt;karsten.tabelow@wias-berlin.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), awsMethods (&ge; 1.1-1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gsl</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, adimpro (&ge; 0.9), aws (&ge; 2.4.1), rgl,
oro.nifti (&ge; 0.3.9), oro.dicom, gsl, quadprog</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Diffusion Weighted Imaging (DWI) is a Magnetic Resonance Imaging
             modality, that measures diffusion of water in tissues like the human
             brain. The package contains R-functions to process diffusion-weighted
             data. The functionality includes diffusion tensor imaging (DTI),
             diffusion kurtosis imaging (DKI), modeling for high angular resolution
             diffusion weighted imaging (HARDI) using Q-ball-reconstruction and
             tensor mixture models, several methods for structural adaptive
             smoothing including POAS and msPOAS, and a streamline fiber tracking
             for tensor and tensor mixture models.
             The package provides functionality to manipulate and visualize results
             in 2D and 3D.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>This package is Copyright (C) 2005-2020 Weierstrass
Institute for Applied Analysis and Stochastics.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.wias-berlin.de/research/ats/imaging/">https://www.wias-berlin.de/research/ats/imaging/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-06 14:21:02 UTC; polzehl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 15:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='AdjacencyMatrix'>
Create an adjacency matrix from fiber tracking results
</h2><span id='topic+AdjacencyMatrix'></span>

<h3>Description</h3>

<p>The function takes two objects, <code>fiberobj</code> with class 'dwiFiber' containing
fiber tracking results and an array or nifti-object containing atlas information.
For each combination of regions defined in the atlas the number of fibers connecting these
regions is calculated, resulting in a matrix of fiber counts. As default this matrix
is standardized and the diagonal elements are set to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdjacencyMatrix(fiberobj, atlas, labels = NULL,
  method = c("standardize", "counts"), diagelements = FALSE,
  symmetric=TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdjacencyMatrix_+3A_fiberobj">fiberobj</code></td>
<td>

<p>an object of class 'dwiFiber'
</p>
</td></tr>
<tr><td><code id="AdjacencyMatrix_+3A_atlas">atlas</code></td>
<td>

<p>an object of class 'array' or 'nifti' containing region indices as
intensities. The atlas needs to be registered to DWI (subject) space,
with array dimension corresponding to  <code>fiberobj@ddim</code>
</p>
</td></tr>
<tr><td><code id="AdjacencyMatrix_+3A_labels">labels</code></td>
<td>

<p>optional labels for the regions. Will be used as dimnames of the resulting matrix.
</p>
</td></tr>
<tr><td><code id="AdjacencyMatrix_+3A_method">method</code></td>
<td>

<p>either <code>"standardize"</code> or <code>"counts"</code>, determines if fiber counts
or a standardized (default) matix is returned.
</p>
</td></tr>
<tr><td><code id="AdjacencyMatrix_+3A_diagelements">diagelements</code></td>
<td>

<p>logical, if <code>FALSE</code> the diagonal elements of the standardized matrix are set to zero (default).
</p>
</td></tr>
<tr><td><code id="AdjacencyMatrix_+3A_symmetric">symmetric</code></td>
<td>

<p>logical, with <code>ni</code> the number of fibers originating if <code>FALSE</code> standardized values
<code>counts(i,j)/ni</code>,
if <code>TRUE</code> we get <code>counts(i,j)/sqrt(nj*nj)</code>.
</p>
</td></tr>
<tr><td><code id="AdjacencyMatrix_+3A_verbose">verbose</code></td>
<td>

<p>logical, if <code>TRUE</code> report pairwise fiber counts.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with dimensions equal to the number of regions defined in the atlas
and dimnames given by <code>labels</code> or by the region number. The matrix contains
fiber counts or values standardized with the number of fibers <code>ni, nj</code>
originating/ending from the pair of regions. Depending on <code>symmetric</code> standardization
is with <code>1/sqrt(ni*nj)</code> or with <code>1/ni</code>.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwiFiber-class">dwiFiber</a></code>
</p>

<hr>
<h2 id='awssigmc'>
Estimate noise variance for multicoil MR systems
</h2><span id='topic+awslsigmc'></span><span id='topic+aflsigmc'></span><span id='topic+awssigmc'></span><span id='topic+afsigmc'></span>

<h3>Description</h3>

<p>The distribution of image intensity values <code class="reqn">S_i</code> divided by the noise standard deviation in <code class="reqn">K</code>-space <code class="reqn">\sigma</code> 
in dMRI experiments is assumed
to follow a non-central chi-distribution with <code class="reqn">2L</code> degrees of freedom and noncentrality parameter <code class="reqn">\eta</code>, where <code class="reqn">L</code> refers to the number of receiver 
coils in the system and <code class="reqn">\sigma \eta</code> is the signal of interest. This is an idealization in the sense that 
each coil is assumed to have the same contribution at each location. For realistic modeling <code class="reqn">L</code> should 
be a locally smooth function in voxel space that reflects the varying local influence of the receiver coils in the
the reconstruction algorithm used. 
</p>
<p>The functions assume <code class="reqn">L</code> to be known and estimate either a local 
(function <code>awslsigmc</code>) or global ( function <code>awssigmc</code>) 
<code class="reqn">\sigma</code> employing an assumption of local homogeneity for
the noncentrality parameter <code class="reqn">\eta</code>.
</p>
<p>Function <code>afsigmc</code> implements estimates from Aja-Fernandez (2009). 
Function <code>aflsigmc</code> implements the estimate from Aja-Fernandez (2013). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awssigmc(y, steps, mask = NULL, ncoils = 1, vext = c(1, 1), lambda = 20, 
         h0 = 2, verbose = FALSE, sequence = FALSE, hadj = 1, q = 0.25, 
         qni = .8, method=c("VAR","MAD"))
awslsigmc(y, steps, mask = NULL, ncoils = 1, vext = c(1, 1), lambda = 5, minni = 2, 
         hsig = 5, sigma = NULL, family = c("NCchi"), verbose = FALSE, 
         trace=FALSE, u=NULL)
afsigmc(y, level = NULL, mask = NULL,  ncoils = 1,   vext = c( 1, 1),   
        h = 2, verbose = FALSE, hadj = 1, 
        method = c("modevn","modem1chi","bkm2chi","bkm1chi"))
aflsigmc(y, ncoils, level = NULL, mask = NULL, h=2, hadj=1,  vext = c( 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="awssigmc_+3A_y">y</code></td>
<td>

<p>3D array, usually obtained from an object of class <code>dwi</code> as
<code>obj@si[,,,i]</code> for some <code>i</code>, i.e. one 3D image from an dMRI experiment.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_steps">steps</code></td>
<td>

<p>number of steps in adapive weights smoothing, used to reveal the unerlying
mean structure.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_mask">mask</code></td>
<td>

<p>restrict computations to voxel in mask, if <code>is.null(mask)</code> all voxel are used.
In function <code>afsigmc</code> mask should refer to background for <code>method %in% c("modem1chi","bkm2chi","bkm1chi")</code> and to voxel within the head for 
<code>method=="modevn"</code>. 
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_ncoils">ncoils</code></td>
<td>

<p>number of coils, or equivalently number of effective degrees of freedom of non-central chi distribution
divided by 2.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_vext">vext</code></td>
<td>

<p>voxel extentions
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_lambda">lambda</code></td>
<td>

<p>scale parameter in adaptive weights smoothing
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_h0">h0</code></td>
<td>

<p>initial bandwidth
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_verbose">verbose</code></td>
<td>

<p>if <code>verbose==TRUE</code> density plots 
and quantiles of local estimates of <code>sigma</code> are provided.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_trace">trace</code></td>
<td>

<p>if <code>trace==TRUE</code> intermediate results for each step are
returned in component tergs for all voxel in mask.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_sequence">sequence</code></td>
<td>

<p>if <code>sequence=TRUE</code> a vector of estimates for the noise
standard deviation <code>sigma</code> for the individual steps is returned
instead of the final value only.  
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_hadj">hadj</code></td>
<td>

<p>adjustment factor for bandwidth (chosen by <code>bw.nrd</code>) in mode estimation 
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_q">q</code></td>
<td>

<p>quantile to be used for interquantile-differences. 
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_qni">qni</code></td>
<td>

<p>quantile of distribution of actual sum of weights <code class="reqn">N_i=\sum_j w_{ij}</code> in adaptive smoothing. Only voxel i with <code class="reqn">N_i &gt; q_{qni}(N_.)</code> are used for variance estimation. Should be larger than 0.5.  
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_method">method</code></td>
<td>
<p> in case of function <code>awssigmc</code> the
method for variance estimation, either &quot;VAR&quot; (variance) or &quot;MAD&quot; (mean absolute deviation). In function <code>afsigmc</code> see last column in Table 2 in Aja-Fernandez (2009). 
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_level">level</code></td>
<td>
<p> threshold for background separation. Used if <code>!is.null(level)</code>
to redefine mask</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_h">h</code></td>
<td>
<p> bandwidth for local avaeraging</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_minni">minni</code></td>
<td>
<p>Minimum sum of weights for updating values of <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_hsig">hsig</code></td>
<td>
<p>Bandwidth of the median filter.</p>
</td></tr> 
<tr><td><code id="awssigmc_+3A_sigma">sigma</code></td>
<td>
<p>Initial estimate for <code>sigma</code></p>
</td></tr>
<tr><td><code id="awssigmc_+3A_family">family</code></td>
<td>
<p>One of <code>"Gauss"</code> or <code>"NCchi"</code> (default) defining the 
probability distribution to use.</p>
</td></tr> 
<tr><td><code id="awssigmc_+3A_u">u</code></td>
<td>
<p>if <code>verbose==TRUE</code> an array of noncentrality paramters for
comparisons. Internal use for tests only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>sigma</code></td>
<td>
<p>either a scalar or a vector of estimated noise standard deviations.
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>the estimated mean structure</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>K. Tabelow, H.U. Voss, J. Polzehl, Local estimation of the noise level in MRI using structural adaptation, Medical Image Analysis, 20 (2015), pp. 76&ndash;86.
</p>

<hr>
<h2 id='colqFA'>FA map color scheme</h2><span id='topic+colqFA'></span>

<h3>Description</h3>

<p>Color map implementing the FA color scheme develop at Uniklinikum Muenster (M. Deppe)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colqFA</code></pre>


<h3>Format</h3>

<p>A vector with 256 RGB color values.</p>

<hr>
<h2 id='combineDWIdata'>Combine two objects of class &quot;dtiData&quot;)
</h2><span id='topic+combineDWIdata'></span>

<h3>Description</h3>

<p>This function creates a dtiData-object from two compatible 
dtiData-objects. Compatible means that the spatial dimensions
coincide, but gradients and b-values may be different. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineDWIdata(x1, x2, s0strategy = "first")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineDWIdata_+3A_x1">x1</code></td>
<td>
<p>Object of class <code>"dtiData"</code>
</p>
</td></tr>
<tr><td><code id="combineDWIdata_+3A_x2">x2</code></td>
<td>
<p>Object of class <code>"dtiData"</code>
</p>
</td></tr>
<tr><td><code id="combineDWIdata_+3A_s0strategy">s0strategy</code></td>
<td>
<p>Character, determines
how the unweighted S0 images are handled. Six strategies are implemented.
<code>s0strategy="first"</code> copies the S0 images from object <code>x1</code>,
<code>s0strategy="second"</code> copies the S0 images from object <code>x2</code>,
<code>s0strategy="both"</code> used the S0 images from both objects.
<code>s0strategy="rfirst"</code> creates one average S0 image from object <code>x1</code>,
<code>s0strategy="rsecond"</code> creates one average S0 image from object <code>x2</code>,
<code>s0strategy="rboth"</code> creates one average S0 image from the S0 images in both objects.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to merge two objects of class &quot;dtiData&quot; under the condition that
the information in slot <code>ddim</code> in both objects is identical. Also slots <code>voxelext</code>,
<code>orientation</code> and <code>rotation</code> should be indentical. 
</p>


<h3>Value</h3>

<p>An object of class &quot;dtiData&quot;.
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiData">dtiData</a></code>, 
<code><a href="#topic+readDWIdata">readDWIdata</a></code>, 
<code><a href="#topic+dtiData-class">dtiData</a></code>, 
<code><a href="#topic+subsetg">subsetg</a></code>
</p>

<hr>
<h2 id='dkiTensor-methods'>Diffusion Kurtosis Imaging (DKI)</h2><span id='topic+dkiTensor'></span><span id='topic+dkiTensor-methods'></span><span id='topic+dkiIndices-methods'></span><span id='topic+dkiIndices'></span><span id='topic+dkiTensor+2CANY-method'></span><span id='topic+dkiIndices+2CANY-method'></span><span id='topic+dkiTensor+2CdtiData-method'></span><span id='topic+dkiIndices+2CdkiTensor-method'></span>

<h3>Description</h3>

<p>These methods estimate, in each voxel, the diffusion kurtosis tensor (and the diffusion tensor) and some scalar indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
dkiTensor(object, method=c("CLLS-QP", "CLLS-H", "ULLS", "QL", "NLR"),
                   sigma=NULL, L=1, mask=NULL,
                   mc.cores=setCores(, reprt=FALSE), verbose=FALSE)
  ## S4 method for signature 'dkiTensor'
dkiIndices(object, mc.cores=setCores(, reprt=FALSE),
                   verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dkiTensor-methods_+3A_object">object</code></td>
<td>
<p>Object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="dkiTensor-methods_+3A_method">method</code></td>
<td>
<p>Method for tensor estimation. May be <code>"CLLS-QP"</code> for a qudratic
programm solution for the constrained optimization (requires package quadprog),
<code>"CLLS-H"</code> for a heuristic approximation described in Tabesh et al. (2011),
or <code>"ULLS"</code> for an unconstrained linear least squares estimation. <code>"QL"</code> and
<code>"NLR"</code> correspond to the use of unconstrained quasi-likelihood and nonlinear regression,
respectively. </p>
</td></tr>
<tr><td><code id="dkiTensor-methods_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of intensity distribution (unprocessed). Used with <code>method="QL"</code>
in the calculation of the expected intensity values.
</p>
</td></tr>
<tr><td><code id="dkiTensor-methods_+3A_l">L</code></td>
<td>
<p>Effective number of coils, 2*L are the degrees of freedom of the intensity
distribution (unprocessed). The default corresponds, e.g., to the case of a SENSE reconstruction.
Used with <code>method="QL"</code>
in the calculation of the expected intensity values.
</p>
</td></tr>
<tr><td><code id="dkiTensor-methods_+3A_mask">mask</code></td>
<td>
<p>argument to specify a precomputed brain mask</p>
</td></tr>
<tr><td><code id="dkiTensor-methods_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use. Defaults to number of threads specified for openMP, see documentation of package <span class="pkg">awsMethods</span>. Not yet fully implemented for
these methods.</p>
</td></tr>
<tr><td><code id="dkiTensor-methods_+3A_verbose">verbose</code></td>
<td>
<p>Verbose mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"dkiTensor"</code> or <code>"dkiIndices"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd><p>Returns a warning</p>
</dd>
<dt><code>signature(object = "dtiData")</code></dt><dd><p>The method <code>"dkiTensor"</code> estimates the diffusion kurtosis
model, i.e., the kurtosis tensor and the diffusion tensor.</p>
</dd>
<dt><code>signature(object = "dkiTensor")</code></dt><dd><p>The method <code>"dkiIndices"</code> estimates
some scalar indices from the kurtosis tensor. The method is still experimental, some
quantities may be removed in future versions, other might be included.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>A. Tabesh, J.H. Jensen, B.A. Ardekani, and J.A. Helpern,
<em>Estimation of tensors and tensor-derived measures in diffusional
kurtosis imaging</em>,
Magnetic Resonance in Medicine, 65, 823-836 (2011).
</p>
<p>E.S. Hui, M.M. Cheung, L. Qi, and E.X. Wu,
<em>Towards better MR characterization of neural tissues using directional
diffusion kurtosis analysis</em>,
Neuroimage, 42, 122-134 (2008).
</p>
<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Doi:10.1007/978-3-030-29184-6.
</p>
<p><a href="https://www.wias-berlin.de/projects/matheon_a3/">https://www.wias-berlin.de/projects/matheon_a3/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+readDWIdata">readDWIdata</a></code>,
<code><a href="#topic+dtiData-class">dtiData</a></code>,
<code><a href="#topic+dkiTensor-class">dkiTensor</a></code>
<code><a href="#topic+dkiIndices-class">dkiIndices</a></code>
</p>

<hr>
<h2 id='dti-package'>
Analysis of Diffusion Weighted Imaging (DWI) Data
</h2><span id='topic+dti-package'></span><span id='topic+dti'></span>

<h3>Description</h3>

<p>Diffusion Weighted Imaging (DWI) is a Magnetic Resonance Imaging
             modality, that measures diffusion of water in tissues like the human
             brain. The package contains R-functions to process diffusion-weighted
             data. The functionality includes diffusion tensor imaging (DTI),
             diffusion kurtosis imaging (DKI), modeling for high angular resolution
             diffusion weighted imaging (HARDI) using Q-ball-reconstruction and
             tensor mixture models, several methods for structural adaptive
             smoothing including POAS and msPOAS, and a streamline fiber tracking
             for tensor and tensor mixture models.
             The package provides functionality to manipulate and visualize results
             in 2D and 3D.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> dti</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.5.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-06</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Analysis of Diffusion Weighted Imaging (DWI) Data</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Karsten", "Tabelow", role = c("aut", "cre"),
                    email = "karsten.tabelow@wias-berlin.de"),
             person("Joerg", "Polzehl", role = c("aut"),
                    email = "joerg.polzehl@wias-berlin.de"),
             person("Felix", "Anker", role = c("ctb")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Karsten Tabelow [aut, cre],
        Joerg Polzehl [aut],
        Felix Anker [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Karsten Tabelow &lt;karsten.tabelow@wias-berlin.de&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0), awsMethods (&gt;= 1.1-1)</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirements: </td><td style="text-align: left;"> gsl</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> methods, parallel, adimpro (&gt;= 0.9), aws (&gt;= 2.4.1),
rgl, oro.nifti (&gt;= 0.3.9), oro.dicom, gsl, quadprog</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Diffusion Weighted Imaging (DWI) is a Magnetic Resonance Imaging
             modality, that measures diffusion of water in tissues like the human
             brain. The package contains R-functions to process diffusion-weighted
             data. The functionality includes diffusion tensor imaging (DTI),
             diffusion kurtosis imaging (DKI), modeling for high angular resolution
             diffusion weighted imaging (HARDI) using Q-ball-reconstruction and
             tensor mixture models, several methods for structural adaptive
             smoothing including POAS and msPOAS, and a streamline fiber tracking
             for tensor and tensor mixture models.
             The package provides functionality to manipulate and visualize results
             in 2D and 3D.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Copyright: </td><td style="text-align: left;"> This package is
Copyright (C) 2005-2020 Weierstrass Institute for
Applied Analysis and Stochastics.</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.wias-berlin.de/research/ats/imaging/</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> covr</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 6.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
AdjacencyMatrix         Create an adjacency matrix from fiber tracking
                        results
awssigmc                Estimate noise variance for multicoil MR
                        systems
colqFA                  FA map color scheme
combineDWIdata          Combine two objects of class "dtiData")
dkiTensor-methods       Diffusion Kurtosis Imaging (DKI)
dti-package             Analysis of Diffusion Weighted Imaging (DWI)
                        Data
dti.options             Set and manipulate image orientations for
                        plots.
dti.smooth-methods      Methods for Function 'dti.smooth' in Package
                        'dti'
dtiIndices-methods      Methods for Function 'dtiIndices' in Package
                        'dti'
dtiTensor-methods       Methods for Function 'dtiTensor' in Package
                        'dti'
dwi-class               Class "dwi"
dwi.smooth-methods      Smooth DWI data
dwiMD                   Methods for Mean Diffusivity in Package 'dti'
dwiMixtensor-methods    Methods for Function 'dwiMixtensor' in Package
                        'dti'
dwiQball-methods        Methods for Function 'dwiQball' in Package
                        'dti'
dwiRiceBias-methods     Correction for Rician Bias
dwiSqrtODF-methods      Methods for positive definite EAP and ODF
                        estimation in Package 'dti'
extract-methods         Methods for Function 'extract' and '[' in
                        Package 'dti'
getmask-methods         Methods for Function 'getmask' in Package 'dti'
getsdofsb-methods       Estimate the noise standard deviation
medinria                Read/Write Diffusion Tensor Data from/to NIFTI
                        File
optgrad                 Optimal gradient directions
optgradients            Optimal gradient directions for number of
                        gradients between 6 and 162
plot-methods            Methods for Function 'plot' in Package 'dti'
polyeder                Polyeders derived from the Icosahedron (icosa0)
                        by sequential triangulation of surface
                        triangles
print-methods           Methods for Function 'print' in Package 'dti'
readDWIdata             Read Diffusion Weighted Data
sdpar-methods           Methods for Function 'sdpar' in Package 'dti'
setmask-methods         Methods for Function 'setmask' in Package 'dti'
show-methods            Methods for Function 'show' in Package 'dti'
show3d-methods          Methods for Function 'show3d' in Package 'dti'
showFAColorScale        Writes an image with the colqFA colorscale to
                        disk.
subsetg                 Create an objects of class "dtiData" containing
                        only a subset of gradient directions.
summary-methods         Methods for Function 'summary' in Package 'dti'
tracking-methods        Methods for Function 'tracking' in Package
                        'dti'
</pre>


<h3>Author(s)</h3>

<p>Karsten Tabelow [aut, cre],
        Joerg Polzehl [aut],
        Felix Anker [ctb]
</p>
<p>Maintainer: Karsten Tabelow &lt;karsten.tabelow@wias-berlin.de&gt;
</p>


<h3>References</h3>

<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Doi:10.1007/978-3-030-29184-6.
</p>
<p>S. Mohammadi, K. Tabelow, L. Ruthotto, Th. Feiweier, J. Polzehl,
and N. Weiskopf, <em>High-resolution diffusion kurtosis imaging
at 3T enabled by advanced post-processing</em>, 8 (2015), 427.
</p>
<p>S. Becker, K. Tabelow, S. Mohammadi, N. Weiskopf, and J. Polzehl,
<em>Adaptive smoothing of multi-shell diffusion weighted magnetic
resonance data by msPOAS</em>, NeuroImage 95 (2014), pp. 90-105.
</p>
<p>S. Becker, K. Tabelow, H.U. Voss, A. Anwander, R.M. Heidemann and
J. Polzehl, <em>Position-orientation adaptive smoothing of
diffusion weighted magnetic resonance data (POAS)</em>, Medical Image
Analysis, 16 (2012), pp. 1142-1155.
</p>
<p>J. Polzehl and K. Tabelow,
<em>Beyond the diffusion tensor model: The package <span class="pkg">dti</span></em>,
Journal of Statistical Software, 44 no. 12 (2011) pp. 1-26.
</p>
<p>K. Tabelow, H.U. Voss and J. Polzehl,
<em>Modeling the orientation distribution function by
mixtures of angular central Gaussian distributions</em>,
Journal of Neuroscience Methods, 203 (2012), pp. 200-211.
</p>
<p>J. Polzehl and K. Tabelow,
<em>Structural adaptive smoothing in diffusion tensor imaging:
The R package dti</em>, Journal of Statistical Software, 31 (2009) pp. 1&ndash;24.
</p>
<p>K. Tabelow, J. Polzehl, V. Spokoiny and H.U. Voss.
<em>Diffusion Tensor Imaging: Structural adaptive smoothing</em>,
NeuroImage 39(4), 1763-1773 (2008).
</p>


<h3>See Also</h3>

<p><a href="https://cran.r-project.org/package=fmri">fmri</a>
<a href="https://cran.r-project.org/package=aws">aws</a>
<a href="https://cran.r-project.org/package=oro.nifti">oro.nifti</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(dti_art)
  ## Not run: demo(mixtens_art)
</code></pre>

<hr>
<h2 id='dti.options'>
Set and manipulate image orientations for plots.
</h2><span id='topic+dti.options'></span>

<h3>Description</h3>

<p>The function can be used to adjust to radiological conventions
in image displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dti.options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dti.options_+3A_...">...</code></td>
<td>

<p>The following parameters can be used to determine the
behaviour of the plot method for 3D image data in subsequent
calls:
</p>

<ul>
<li><p> swapx - swap image x axis for display
</p>
</li>
<li><p> swapy - swap image y axis for display
</p>
</li>
<li><p> swapz - swap image z axis for display
</p>
</li></ul>

<p>all default to FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns specified display orientations.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>

<hr>
<h2 id='dti.smooth-methods'> Methods for Function &lsquo;dti.smooth&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+dti.smooth'></span><span id='topic+dti.smooth-methods'></span><span id='topic+dti.smooth+2CANY-method'></span><span id='topic+dti.smooth+2CdtiData-method'></span><span id='topic+dti.smooth+2CdtiTensor-method'></span>

<h3>Description</h3>

<p>The function provides structural adaptive smoothing for diffusion weighted image data within the context of an diffusion tensor (DTI) model.  It implements smoothing of DWI data using a structural assumption of a local (anisotropic) homogeneous  diffusion tensor model (in case a <code>"dtiData"</code>-object is provided).  It also implements structural adaptive smoothing of a diffusion tensor using a Riemannian metric (in case a <code>"dtiTensor"</code>-object is given), although we strictly recommend to use the first variant due to methodological reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dtiData'
dti.smooth(object, hmax=5, hinit=NULL, lambda=20, tau=10, rho=1, 
         graph=FALSE,slice=NULL, quant=.8, minfa=NULL, hsig=2.5, 
         lseq=NULL, method="nonlinear", rician=TRUE, 
         niter=5,result="Tensor")
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dti.smooth-methods_+3A_object">object</code></td>
<td>
<p> Either an object of class <code>"dtiData"</code> or an object of class <code>"dtiTensor"</code></p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_hmax">hmax</code></td>
<td>
<p>Maximal bandwidth</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_hinit">hinit</code></td>
<td>
<p>Initial bandwidth (default 1)</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_lambda">lambda</code></td>
<td>
<p>Critical parameter (default 20)</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_tau">tau</code></td>
<td>
<p>Critical parameter for orientation scores (default 10)</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_rho">rho</code></td>
<td>
<p>Regularization parameter for anisotropic vicinities (default 1)</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_graph">graph</code></td>
<td>
<p>&quot;logical&quot;: Visualize intermediate results (default FALSE)</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_slice">slice</code></td>
<td>
<p>slice number, determines the slice used in visualization</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_quant">quant</code></td>
<td>
<p>determines <code>minfa</code> as corresponding quantile of FA if <code>is.null(minfa)</code> </p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_minfa">minfa</code></td>
<td>
<p>minimal anisotropy index (FA) to use in visualization</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_hsig">hsig</code></td>
<td>
<p>bandwidth for presmoothing of variance estimates</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_lseq">lseq</code></td>
<td>
<p> sequence of correction factors for <code>lambda</code></p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_method">method</code></td>
<td>
<p> Method for tensor estimation. May be <code>"linear"</code>, <code>"nonlinear"</code></p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_rician">rician</code></td>
<td>
<p> &quot;logical&quot;: apply a correction for Rician bias. This is still experimental and depends on spatial independence of errors.</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_niter">niter</code></td>
<td>
<p> Maximum number of iterations for tensor estimates using the nonlinear model.</p>
</td></tr>
<tr><td><code id="dti.smooth-methods_+3A_result">result</code></td>
<td>
<p> Determines the created object. Alternatives are <code>"Tensor"</code> for create a dtiTensor-object and <code>"dtiData"</code>
for a dtiData-object containing a smoothed data cube.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dtiTensor</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd><p> Returns a warning. </p>
</dd>
<dt>object = &quot;dtiData&quot;</dt><dd><p> We highly recommend to use the method <code>dti.smooth</code> on DWI data directly, i.e. on an object of class <code>"dtiData"</code>, due to methodological reasons, see Tabelow et al. (2008).  It is usually not necessary to use any other argument than <code>hmax</code>, which defines the maximum bandwidth of the iteration. 
</p>
<p>If <code>model=="linear"</code> estimates are obtained using a linearization of the tensor model. This was the estimate used in Tabelow et.al. (2008). <code>model=="nonlinear"</code> uses a nonlinear regression model with reparametrization that ensures the tensor to be  positive semidefinite, see  Koay et.al. (2006).  If <code>varmethod=="replicates"</code> the error variance is estimated from replicated gradient directions if possible, otherwise (default) an estimate is obtained from the residual sum of squares.  If <code>volseq==TRUE</code> the sum of location weights is fixed to <code class="reqn">1.25^k</code> within iteration <code class="reqn">k</code> (does not depend on the actual tensor). Otherwise the ellipsoid of positive location weights is determined by a bandwidth <code class="reqn">h_k = 1.25^(k/3)</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>               J. Polzehl and K. Tabelow, 
<em>Beyond the diffusion tensor model: The package <span class="pkg">dti</span></em>,
Journal of Statistical Software, to appear.
</p>
<p>K. Tabelow, H.U. Voss and J. Polzehl, 
<em>Modeling the orientation distribution function by 
mixtures of angular central Gaussian distributions</em>,
Journal of Neuroscience Methods, to appear.
</p>
<p>J. Polzehl and K. Tabelow, 
<em>Structural adaptive smoothing in diffusion tensor imaging: 
The R package dti</em>, Journal of Statistical Software, 31 (2009) pp. 1&ndash;24.
</p>
<p>K. Tabelow, J. Polzehl, V. Spokoiny and H.U. Voss. 
<em>Diffusion Tensor Imaging: Structural adaptive smoothing</em>, 
NeuroImage 39(4), 1763-1773 (2008).
</p>
<p><a href="https://www.wias-berlin.de/projects/matheon_a3/">https://www.wias-berlin.de/projects/matheon_a3/</a> 
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiData">dtiData</a></code>, 
<code><a href="#topic+readDWIdata">readDWIdata</a></code>, 
<code><a href="#topic+dtiTensor-methods">dtiTensor-methods</a></code>, 
<code><a href="#topic+dtiIndices-methods">dtiIndices-methods</a></code>, 
<code><a href="#topic+medinria">medinria</a></code> , 
<code><a href="#topic+dtiData-class">dtiData</a></code>, 
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>,
<code><a href="#topic+dtiIndices-class">dtiIndices</a></code>
</p>

<hr>
<h2 id='dtiIndices-methods'> Methods for Function &lsquo;dtiIndices&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+dtiIndices'></span><span id='topic+dtiIndices-methods'></span><span id='topic+dtiIndices+2CANY-method'></span><span id='topic+dtiIndices+2CdtiTensor-method'></span>

<h3>Description</h3>

<p>The method creates estimates of the fractional anisotropy (FA) and relative anisotropy (RA) indices, the main directions of anisotropy and several statistics used for visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiTensor'
dtiIndices(object, mc.cores = setCores(,reprt=FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtiIndices-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>"dtiTensor"</code> </p>
</td></tr>
<tr><td><code id="dtiIndices-methods_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use. Defaults to number of threads specified for openMP, see documentation of package <span class="pkg">awsMethods</span>.
Our experience suggests to use 4-6 cores if available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"dtiIndices"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;ANY&quot;</dt><dd><p> Returns a warning. </p>
</dd>
<dt>obj = &quot;dtiTensor&quot;</dt><dd><p> Estimate tensor indices like trace, fractional and geodesic anisotropy, main diffusion direction and shape parameters. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p> J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Doi:10.1007/978-3-030-29184-6.
</p>
<p>J. Polzehl and K. Tabelow,
<em>Beyond the diffusion tensor model: The package <span class="pkg">dti</span></em>,
Journal of Statistical Software, to appear.
</p>
<p>K. Tabelow, H.U. Voss and J. Polzehl,
<em>Modeling the orientation distribution function by
mixtures of angular central Gaussian distributions</em>,
Journal of Neuroscience Methods, to appear.
</p>
<p>J. Polzehl and K. Tabelow,
<em>Structural adaptive smoothing in diffusion tensor imaging:
The R package dti</em>, Journal of Statistical Software, 31 (2009) pp. 1&ndash;24.
</p>
<p>K. Tabelow, J. Polzehl, V. Spokoiny and H.U. Voss.
<em>Diffusion Tensor Imaging: Structural adaptive smoothing</em>,
NeuroImage 39(4), 1763-1773 (2008).
</p>
<p><a href="https://www.wias-berlin.de/projects/matheon_a3/">https://www.wias-berlin.de/projects/matheon_a3/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+medinria">medinria</a></code>,
<code><a href="#topic+dtiTensor-methods">dtiTensor-methods</a></code>,
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>,
<code><a href="#topic+dtiIndices-class">dtiIndices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(dti_art)
</code></pre>

<hr>
<h2 id='dtiTensor-methods'> Methods for Function &lsquo;dtiTensor&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+dtiTensor'></span><span id='topic+dtiTensor-methods'></span><span id='topic+dtiTensor+2CANY-method'></span><span id='topic+dtiTensor+2CdtiData-method'></span>

<h3>Description</h3>

<p>The method estimates, in each voxel, the diffusion tensor from the DWI data contained in an object of class <code>"dtiData"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
dtiTensor(object, method=c( "nonlinear", "linear", "quasi-likelihood"),
          sigma = NULL, L = 1, mask=NULL, mc.cores = setCores( , reprt = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtiTensor-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="dtiTensor-methods_+3A_method">method</code></td>
<td>
<p> Method for tensor estimation. May be <code>"linear"</code>, or <code>"nonlinear"</code>. <code>method=="quasi-likelihood"</code> solves the nonlinear regression problem with the
expected value of the signal as regression function and weighting according to the signal variance.</p>
</td></tr>
<tr><td><code id="dtiTensor-methods_+3A_sigma">sigma</code></td>
<td>
<p>(local) scale parameter of the signal's distribution.</p>
</td></tr>
<tr><td><code id="dtiTensor-methods_+3A_l">L</code></td>
<td>
<p>(local) effective degrees of freedom.</p>
</td></tr>
<tr><td><code id="dtiTensor-methods_+3A_mask">mask</code></td>
<td>
<p>argument to specify a precomputed brain mask</p>
</td></tr>
<tr><td><code id="dtiTensor-methods_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use. Defaults to number of threads specified for openMP, see documentation of package <span class="pkg">awsMethods</span>.
Our experience suggests to use 4-6 cores if available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"dtiTensor"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;ANY&quot;</dt><dd><p> Returns a warning. </p>
</dd>
<dt>obj = &quot;dtiData&quot;</dt><dd><p> Estimate diffusion tensor from data in each voxel with the different options for
the regression type and model for variance estimation.  If <code>method=="linear"</code> estimates are obtained
using a linearization of the tensor model. This was the estimate used in Tabelow et.al. (2008).
<code>method=="nonlinear"</code> uses a nonlinear regression model with reparametrization that ensures the
tensor to be  positive semidefinite, see  Koay et.al. (2006).  The imlementation is based on R's internal
C code for the
BFGS optimization. <code>method=="quasi-likelihood"</code> solves the nonlinear regression problem with the
expected value of the signal as regression function and weighting according to the signal variance.
Tis requires additional parameters <code>sigma</code> and <code>L</code> characterizing the distribution of the signal. If <code>varmethod=="replicates"</code> the error variance is estimated from replicated
gradient directions if possible, otherwise an estimate is obtained from the residual sum of squares.  If
<code>varmodel=="global"</code> a homogeneous variance is assumed and estimated as the median of the local
variance estimates.
<code>sigma</code> and <code>2*L</code> are the scale parameter and degrees of freedom of the (local) signal distribution. <code>L</code> characterizes the effective number of coils. Both parameters are either scalars or arrays of the size of the images.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p> J. Polzehl and K. Tabelow,
<em>Beyond the diffusion tensor model: The package <span class="pkg">dti</span></em>,
Journal of Statistical Software, 44(12), 1-26 (2011).
</p>
<p>K. Tabelow, H.U. Voss and J. Polzehl,
<em>Modeling the orientation distribution function by
mixtures of angular central Gaussian distributions</em>,
Journal of Neuroscience Methods, 203(1), 200-211 (2012).
</p>
<p>J. Polzehl and K. Tabelow,
<em>Structural adaptive smoothing in diffusion tensor imaging:
The R package dti</em>, Journal of Statistical Software, 31(9) 1-24 (2009).
</p>
<p>K. Tabelow, J. Polzehl, V. Spokoiny and H.U. Voss.
<em>Diffusion Tensor Imaging: Structural adaptive smoothing</em>,
NeuroImage 39(4), 1763-1773 (2008).
</p>
<p>C.G. Koay, J.D. Carew, A.L. Alexander, P.J. Basser and M.E. Meyerand.
<em> Investigation of Anomalous Estimates of Tensor-Derived Quantities
in Diffusion Tensor Imaging</em>,
Magnetic Resonance in Medicine, 2006, 55, 930-936.
</p>
<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Doi:10.1007/978-3-030-29184-6.
</p>
<p><a href="https://www.wias-berlin.de/projects/matheon_a3/">https://www.wias-berlin.de/projects/matheon_a3/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+readDWIdata">readDWIdata</a></code>,
<code><a href="#topic+dtiIndices-methods">dtiIndices-methods</a></code>,
<code><a href="#topic+medinria">medinria</a></code>,
<code><a href="#topic+dtiData-class">dtiData</a></code>,
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>
<code><a href="#topic+dwiMixtensor-class">dwiMixtensor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(dti_art)
</code></pre>

<hr>
<h2 id='dwi-class'>Class &quot;dwi&quot; </h2><span id='topic+dwi-class'></span><span id='topic+dtiData-class'></span><span id='topic+dtiTensor-class'></span><span id='topic+dkiTensor-class'></span><span id='topic+dwiMixtensor-class'></span><span id='topic+dtiIndices-class'></span><span id='topic+dkiIndices-class'></span><span id='topic+dwiQball-class'></span><span id='topic+dwiFiber-class'></span>

<h3>Description</h3>

<p> The family of <code>"dwi"</code> classes is used for Diffusion Weighted Imaging (DWI) data and, within the Diffusion Tensor Model (DTI), diffusion tenors and its indices. </p>


<h3>Objects from the Class</h3>

<p><code>"dwi"</code> is only a superclass, no instances should be created. However, objects can be created by calls of the form <code>new("dwi", ...)</code>. <code>"dtiData"</code>, <code>"dtiTensor"</code>, and <code>"dtiIndices"</code> can be created from their correspondingly named functions and methods.
</p>


<h3>Slots</h3>


<dl>
<dt> <code>.Data</code>: </dt><dd><p> Object of class <code>"list"</code>, usually empty. </p>
</dd>
<dt> <code>gradient</code>: </dt><dd><p> Object of class <code>"matrix"</code>, matrix of dimension <code>c(3,ngrad)</code> containing gradient directions. </p>
</dd>
<dt> <code>btb</code>: </dt><dd><p> Object of class <code>"matrix"</code>, matrix of dimension <code>c(6,ngrad)</code> obtained from gradient directions. </p>
</dd>
<dt> <code>bvalue</code>: </dt><dd><p> Object of class <code>"numeric"</code>, of length <code>ngrad</code> containing b-values if available.</p>
</dd>
<dt> <code>ngrad</code>: </dt><dd><p> Object of class <code>"integer"</code>, number of gradients (including zero gradients). </p>
</dd>
<dt> <code>s0ind</code>: </dt><dd><p> Object of class <code>"integer"</code>, index of zero gradients within the sequence <code>1:ngrad</code>. </p>
</dd>
<dt> <code>replind</code>: </dt><dd><p> Object of class <code>"integer"</code>, index (identifier) of unique gradient directions. Used to characterize replications in the gradient design by identical indices. length is <code>ngrad</code>. </p>
</dd>
<dt> <code>ddim</code>: </dt><dd><p> Object of class <code>"integer"</code>, dimension of subcube defined by <code>xind</code>, <code>yind</code> and <code>zind</code>. </p>
</dd>
<dt> <code>ddim0</code>: </dt><dd><p> Object of class <code>"integer"</code>, dimension of original image cubes. Vector of length 3. </p>
</dd>
<dt> <code>xind</code>, <code>yind</code>, <code>zind</code>:</dt><dd><p> Objects of class <code>"integer"</code>, index for subcube definition in x-, y- and z-direction. </p>
</dd>
<dt> <code>voxelext</code>: </dt><dd><p> Object of class <code>"numeric"</code>, voxel extensions in x-, y- and z-direction. Vector of length 3. </p>
</dd>
<dt> <code>orientation</code>: </dt><dd><p> Object of class <code>"integer"</code>, orientation of data according to AFNI convention. Vector of length 3. </p>
</dd>
<dt> <code>rotation</code>: </dt><dd><p> Object of class <code>"matrix"</code>, optional rotation matrix for gradient directions. </p>
</dd>
<dt> <code>level</code>: </dt><dd><p> Object of class <code>"numeric"</code>, minimal valid S0-level. No evaluation will be performed for voxels with S0-values less than <code>level</code>. </p>
</dd> 
<dt> <code>source</code>: </dt><dd><p> Object of class <code>"character"</code>, name of the source imgage file or source directory. </p>
</dd>
<dt> <code>call</code>: </dt><dd><p> Object of class <code>"call"</code>, call that created the object. </p>
</dd>
</dl>

<p>For class <code>"dtiData"</code>:
</p>

<dl>
<dt> <code>si</code>: </dt><dd><p> Object of class <code>"array"</code>, Diffusion Weighted Data. </p>
</dd>
<dt> <code>sdcoef</code>: </dt><dd><p> Object of class <code>"numeric"</code>, Parameters of the model for error 
standard deviation as a function of the mean. First two entries refer to intercept and slope of a linear function,
third and fourth value are the endpoints of the interval of linearity. Contains <code>rep(0,4)</code> if not set. If the function </p>
</dd>
</dl>

<p>For class <code>"dtiTensor"</code>:
</p>

<dl>
<dt> <code>D</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated tensors, dimension <code>c(6,ddim)</code>.
Tensors are stored as upper diagonal matrices.</p>
</dd> 
<dt> <code>th0</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated intensities in S0 images, dimension <code>ddim</code></p>
</dd> 
<dt> <code>sigma</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated error variances if <code>method=="linear"</code>, zero otherwise.</p>
</dd> 
<dt> <code>scorr</code>: </dt><dd><p> Object of class <code>"numeric"</code>, estimated spatial correlations in coordinate directions</p>
</dd> 
<dt> <code>bw</code>: </dt><dd><p> Object of class <code>"numeric"</code>, bandwidth for a Gaussian kernel that approximately creates the estimated spatial correlations. Needed for adjustments of critical values in the adaptive smoothing algorithm used in function <code>dti.smooth</code></p>
</dd> 
<dt> <code>mask</code>: </dt><dd><p> Object of class <code>"array"</code>, logical indicating the voxel where the tensor was estimated.</p>
</dd> 
<dt> <code>hmax</code>: </dt><dd><p> Object of class <code>"numeric"</code>, maximal bandwidth in case of adaptive smoothing, 1 otherwise.</p>
</dd> 
<dt> <code>outlier</code>: </dt><dd><p> Object of class <code>"numeric"</code>, index of voxel where physical constraints are not met, i.e. where the observed values in gradient images Si were larger than the corresponding S0 values. These are probably motion effects or registration errors. Values are replaced by the corresponding (mean) S0 values.</p>
</dd>
<dt><code>scale</code>:</dt><dd><p>Numerical value corresponding to the 95% quantile of the maximal eigenvalues of estimated tensors within the mask.
Used for scaling in function <code>show3d.dtiTensor</code></p>
</dd>
<dt> <code>method</code>: </dt><dd><p> Object of class <code>"character"</code>, either <code>"linear"</code> or <code>"nonlinear"</code> or <code>"unknown"</code>. Indicates the regression model used for estimating the tensors.</p>
</dd>
</dl>

<p>For class <code>"dtiIndices"</code>:
</p>

<dl>
<dt> <code>fa</code>: </dt><dd><p> Object of class <code>"array"</code>, Fractional anisotropy values (FA)</p>
</dd>
<dt> <code>ga</code>: </dt><dd><p> Object of class <code>"array"</code>, Geodetic anisotropy values (GA)</p>
</dd>
<dt> <code>md</code>: </dt><dd><p> Object of class <code>"array"</code>, Mean diffusivity values (MD) </p>
</dd>
<dt> <code>andir</code>: </dt><dd><p> Object of class <code>"array"</code>, Main directions of anisotropy </p>
</dd>
<dt> <code>bary</code>: </dt><dd><p> Object of class <code>"array"</code>, Shape parameters </p>
</dd>
<dt> <code>method</code>: </dt><dd><p> Object of class <code>"character"</code> either <code>"linear"</code> or <code>"nonlinear"</code> or <code>"unknown"</code>. Indicates the regression model used for estimating the tensors.</p>
</dd>
</dl>

<p>For class <code>"dkiTensor"</code>:
</p>

<dl>
<dt> <code>D</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated tensors, dimension <code>c(6,ddim)</code>.
Tensors are stored as upper diagonal matrices.</p>
</dd> 
<dt> <code>W</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated kurtosis tensors, dimension <code>c(15,ddim)</code>.</p>
</dd> 
<dt> <code>th0</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated intensities in S0 images, dimension <code>ddim</code></p>
</dd> 
<dt> <code>sigma</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated error variances if <code>method=="linear"</code>, zero otherwise.</p>
</dd> 
<dt> <code>scorr</code>: </dt><dd><p> Object of class <code>"numeric"</code>, estimated spatial correlations in coordinate directions</p>
</dd> 
<dt> <code>bw</code>: </dt><dd><p> Object of class <code>"numeric"</code>, bandwidth for a Gaussian kernel that approximately creates the estimated spatial correlations. Needed for adjustments of critical values in the adaptive smoothing algorithm used in function <code>dti.smooth</code></p>
</dd> 
<dt> <code>mask</code>: </dt><dd><p> Object of class <code>"array"</code>, logical indicating the voxel where the tensor was estimated.</p>
</dd> 
<dt> <code>hmax</code>: </dt><dd><p> Object of class <code>"numeric"</code>, maximal bandwidth in case of adaptive smoothing, 1 otherwise.</p>
</dd> 
<dt> <code>outlier</code>: </dt><dd><p> Object of class <code>"numeric"</code>, index of voxel where physical constraints are not met, i.e. where the observed values in gradient images Si were larger than the corresponding S0 values. These are probably motion effects or registration errors. Values are replaced by the corresponding (mean) S0 values.</p>
</dd>
<dt><code>scale</code>:</dt><dd><p>Numerical value corresponding to the 95% quantile of the maximal eigenvalues of estimated tensors within the mask.
Used for scaling in function <code>show3d.dtiTensor</code></p>
</dd>
<dt> <code>method</code>: </dt><dd><p> Object of class <code>"character"</code>, either <code>"linear"</code> or <code>"nonlinear"</code> or <code>"unknown"</code>. Indicates the regression model used for estimating the tensors.</p>
</dd>
</dl>

<p>For class <code>"dkiIndices"</code>:
</p>

<dl>
<dt> <code>fa</code>: </dt><dd><p> Object of class <code>"array"</code>, Fractional anisotropy values (FA)</p>
</dd>
<dt> <code>ga</code>: </dt><dd><p> Object of class <code>"array"</code>, Geodetic anisotropy values (GA)</p>
</dd>
<dt> <code>md</code>: </dt><dd><p> Object of class <code>"array"</code>, Mean diffusivity values (MD) </p>
</dd>
<dt> <code>andir</code>: </dt><dd><p> Object of class <code>"array"</code>, Main directions of anisotropy </p>
</dd>
<dt> <code>bary</code>: </dt><dd><p> Object of class <code>"array"</code>, Shape parameters </p>
</dd>
<dt> <code>k1</code>: </dt><dd><p> Object of class <code>"array"</code>, Kurtosis along DT (Hui et al. 2008) </p>
</dd>
<dt> <code>k2</code>: </dt><dd><p> Object of class <code>"array"</code>, Kurtosis along DT (Hui et al. 2008) </p>
</dd>
<dt> <code>k3</code>: </dt><dd><p> Object of class <code>"array"</code>, Kurtosis along DT (Hui et al. 2008) </p>
</dd>
<dt> <code>mk</code>: </dt><dd><p> Object of class <code>"array"</code>, Mean kurtosis (Hui et al. 2008) </p>
</dd>
<dt> <code>mk2</code>: </dt><dd><p> Object of class <code>"array"</code>, Mean Kurtosis (Tabesh et al. (2011))</p>
</dd>
<dt> <code>kaxial</code>: </dt><dd><p> Object of class <code>"array"</code>, Axial kurtosis (Hui et al. 2008) </p>
</dd>
<dt> <code>kradial</code>: </dt><dd><p> Object of class <code>"array"</code>, Radial kurtosis (Hui et al. 2008) </p>
</dd>
<dt> <code>fak</code>: </dt><dd><p> Object of class <code>"array"</code>, Kurtosis anisotropy (Hui et al. 2008) </p>
</dd>
<dt> <code>method</code>: </dt><dd><p> Object of class <code>"character"</code> either <code>"linear"</code> or <code>"nonlinear"</code> or <code>"unknown"</code>. Indicates the regression model used for estimating the tensors.</p>
</dd>
</dl>

<p>For class <code>"dwiQball"</code>:
</p>

<dl>
<dt> <code>order</code>: </dt><dd><p> Object of class <code>"integer"</code>, maximal order of Spherical Harmonics to use, needs to be even.</p>
</dd> 
<dt> <code>forder</code>: </dt><dd><p> Object of class <code>"integer"</code>, maximal order Gaussian-Laguerre functions in SPF basis (for EAP estimation)</p>
</dd> 
<dt> <code>zeta</code>: </dt><dd><p> Object of class <code>"numeric"</code>, Scale parameter used in Gaussian-Laguerre functions (for EAP estimation)</p>
</dd>
<dt> <code>lambda</code>: </dt><dd><p> Object of class <code>"numeric"</code>, nonnegative regularization parameter.</p>
</dd> 
<dt> <code>sphcoef</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated coefficients for spherical harmonics, dimension <code>c((order+1)*(order+2)/2,ddim)</code>.</p>
</dd> 
<dt> <code>sigma</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated error variances if <code>method=="linear"</code>, zero otherwise.</p>
</dd> 
<dt> <code>scorr</code>: </dt><dd><p> Object of class <code>"numeric"</code>, estimated spatial correlations in coordinate directions</p>
</dd> 
<dt> <code>bw</code>: </dt><dd><p> Object of class <code>"numeric"</code>, bandwidth for a Gaussian kernel that approximately creates the estimated spatial correlations. Needed for adjustments of critical values in the adaptive smoothing algorithm used in function <code>dti.smooth</code></p>
</dd> 
<dt> <code>mask</code>: </dt><dd><p> Object of class <code>"array"</code>, logical indicating the voxel where the tensor was estimated.</p>
</dd> 
<dt> <code>hmax</code>: </dt><dd><p> Object of class <code>"numeric"</code>, maximal bandwidth in case of adaptive smoothing, 1 otherwise.</p>
</dd> 
<dt> <code>outlier</code>: </dt><dd><p> Object of class <code>"numeric"</code>, index of voxel where physical constraints are not met, i.e. where the observed values in gradient images Si were larger than the corresponding S0 values. These are probably motion effects or registration errors. Values are replaced by the corresponding (mean) S0 values.</p>
</dd>
<dt><code>scale</code>:</dt><dd><p>Numerical value corresponding to the 95% quantile of the maximal eigenvalues of estimated tensors within the mask.
Used for scaling in function <code>show3d.dwiQball</code></p>
</dd>
<dt> <code>what</code>: </dt><dd><p> Object of class <code>"character"</code>, <code>"ODF"</code>, <code>"wODF"</code>, <code>"aODF"</code> or <code>"ADC"</code>. Indicates if the object contains coefficients of the orientation density function (ODF (Descoteaux 2007), wODF (Sapiro(2009) or aODF) or the apparent diffusion coefficient (ADC). Coefficients are computed with respect to spherical harmonics of the specified order.</p>
</dd>
</dl>

<p>For class <code>"dwiFiber"</code>:
</p>

<dl>
<dt> <code>fibers</code>: </dt><dd><p> Object of class <code>"matrix"</code>, Matrix of fibers. The first three columns contain the coordinates of the track points, the last three columns the direction vectors for each of these points.</p>
</dd> 
<dt> <code>startind</code>: </dt><dd><p>Object of class <code>"integer"</code>, indices for the first dimension of <code>fibers</code> where
coordinates for a new fiber start.</p>
</dd>
<dt> <code>roix</code>: </dt><dd><p> Object of class <code>"integer"</code>, coordinate range of region of interest in x-direction </p>
</dd> 
<dt> <code>roiy</code>: </dt><dd><p> Object of class <code>"integer"</code>, coordinate range of region of interest in x-direction </p>
</dd> 
<dt> <code>roiz</code>: </dt><dd><p> Object of class <code>"integer"</code>, coordinate range of region of interest in x-direction </p>
</dd> 
<dt> <code>method</code>: </dt><dd><p> Object of class <code>"character"</code>, fiber tracking method.</p>
</dd> 
<dt> <code>minfa</code>: </dt><dd><p> Object of class <code>"numeric"</code>, minimal fractional anisotropy index</p>
</dd> 
<dt> <code>maxangle</code>: </dt><dd><p> Object of class <code>"numeric"</code>, maximal angle between fibres.</p>
</dd> 
</dl>

<p>For class <code>"dwiMixtensor"</code>:
</p>

<dl>
<dt> <code>model</code>: </dt><dd><p> Object of class <code>"character"</code>, characterizes the type of the 
mixed tensor model. Currently the only implemented model is <code>model="homogeneous_prolate"</code>.
</p>
</dd> 
<dt> <code>ev</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated eigenvalues, dimension <code>c(2,ddim)</code></p>
</dd> 
<dt> <code>mix</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated mixture coefficients, dimension <code>c(nmix,ddim)</code>. <code>nmix</code> is the number of mixture components specified.</p>
</dd> 
<dt> <code>orient</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated tensor orientations, dimension <code>c(2,nmix,ddim)</code></p>
</dd> 
<dt> <code>th0</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated intensities in S0 images, dimension <code>ddim</code></p>
</dd> 
<dt> <code>sigma</code>: </dt><dd><p> Object of class <code>"array"</code>, estimated error variances if <code>method=="linear"</code>, zero otherwise.</p>
</dd> 
<dt> <code>scorr</code>: </dt><dd><p> Object of class <code>"numeric"</code>, estimated spatial correlations in coordinate directions</p>
</dd> 
<dt> <code>bw</code>: </dt><dd><p> Object of class <code>"numeric"</code>, bandwidth for a Gaussian kernel that approximately creates the estimated spatial correlations. Needed for adjustments of critical values in the adaptive smoothing algorithm used in function <code>dti.smooth</code></p>
</dd> 
<dt> <code>mask</code>: </dt><dd><p> Object of class <code>"array"</code>, logical indicating the voxel where the tensor was estimated.</p>
</dd> 
<dt> <code>hmax</code>: </dt><dd><p> Object of class <code>"numeric"</code>, maximal bandwidth in case of adaptive smoothing, 1 otherwise.</p>
</dd> 
<dt> <code>outlier</code>: </dt><dd><p> Object of class <code>"numeric"</code>, index of voxel where physical constraints are not met, i.e. where the observed values in gradient images Si were larger than the corresponding S0 values. These are probably motion effects or registration errors. Values are replaced by the corresponding (mean) S0 values.</p>
</dd>
<dt><code>scale</code>:</dt><dd><p>Numerical value corresponding to the 95% quantile of the maximal eigenvalues of estimated tensors within the mask.
Used for scaling in function <code>show3d.dtiTensor</code></p>
</dd>
<dt> <code>method</code>: </dt><dd><p> Object of class <code>"character"</code>, either <code>"mixtensor"</code> or <code>"Jian"</code>. Indicates the regression model used for estimating the tensors.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Methods only operate on subclasses <code>"dtiData"</code>, <code>"dtiTensor"</code>,  <code>"dtiIndices"</code>, <code>"dwiQball"</code> and <code>"dwiFiber"</code>.
</p>

<dl>
<dt>dti.smooth</dt><dd><p> Create estimates of diffusion tensors in each voxel using structural adaptive spatial smoothing. </p>
</dd>
<dt>dtiTensor</dt><dd><p><code>signature(object = "dtiData")</code>: Create estimates of diffusion tensors in each voxel. </p>
</dd>
<dt>dtiIndices</dt><dd><p><code>signature(object = "dtiTensor")</code>: Create estimates of diffusion tensors indices in each voxel. </p>
</dd>
<dt>tracking</dt><dd><p><code>signature(object = "dtiTensor")</code> or <code>signature(object = "dtiIndices")</code>: Fiber tracking. </p>
</dd>
<dt>dtiQball</dt><dd><p><code>signature(object = "dtiData")</code>: Create estimates of ADC-parameters with respect to a sherical harmonics ortho-normal system. </p>
</dd>
<dt>show3d</dt><dd><p> Method for Function &lsquo;show3d&rsquo; in Package &lsquo;dti&rsquo;. </p>
</dd>
<dt>plot</dt><dd><p> Method for Function &lsquo;plot&rsquo; in Package &lsquo;dti&rsquo;. </p>
</dd>
<dt>print</dt><dd><p> Method for Function &lsquo;print&rsquo; in Package &lsquo;dti&rsquo;. </p>
</dd>
<dt>summary</dt><dd><p> Method for Function &lsquo;summary&rsquo; in Package &lsquo;dti&rsquo;. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow, 
<em>Beyond the diffusion tensor model: The package <span class="pkg">dti</span></em>,
Journal of Statistical Software, to appear.
</p>
<p>K. Tabelow, H.U. Voss and J. Polzehl, 
<em>Modeling the orientation distribution function by 
mixtures of angular central Gaussian distributions</em>,
Journal of Neuroscience Methods, to appear.
</p>
<p>J. Polzehl and K. Tabelow, 
<em>Structural adaptive smoothing in diffusion tensor imaging: 
The R package dti</em>, Journal of Statistical Software, 31 (2009) pp. 1&ndash;24.
</p>
<p>K. Tabelow, J. Polzehl, V. Spokoiny and H.U. Voss. 
<em>Diffusion Tensor Imaging: Structural adaptive smoothing</em>, 
NeuroImage 39(4), 1763-1773 (2008).

</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+readDWIdata">readDWIdata</a></code>,
<code><a href="#topic+sdpar-methods">sdpar-methods</a></code>,
<code><a href="#topic+getsdofsb-methods">getsdofsb-methods</a></code>,
<code><a href="#topic+dwiRiceBias-methods">dwiRiceBias-methods</a></code>,
<code><a href="#topic+dtiTensor-methods">dtiTensor-methods</a></code>, 
<code><a href="#topic+dwiMixtensor-methods">dwiMixtensor-methods</a></code>, 
<code><a href="#topic+dti.smooth-methods">dti.smooth-methods</a></code>,
<code><a href="#topic+dwi.smooth-methods">dwi.smooth-methods</a></code>,
<code><a href="#topic+dtiIndices-methods">dtiIndices-methods</a></code>,
<code><a href="#topic+dwiQball-methods">dwiQball-methods</a></code>, 
<code><a href="#topic+tracking-methods">tracking-methods</a></code>,
<code><a href="#topic+show3d-methods">show3d-methods</a></code>,
<code><a href="#topic+plot-methods">plot-methods</a></code>,
<code><a href="#topic+print-methods">print-methods</a></code>,
<code><a href="#topic+summary-methods">summary-methods</a></code>,
<code><a href="#topic+extract-methods">extract-methods</a></code>
</p>

<hr>
<h2 id='dwi.smooth-methods'>Smooth DWI data</h2><span id='topic+dwi.smooth'></span><span id='topic+dwi.smooth.ms'></span><span id='topic+dwi.smooth-methods'></span><span id='topic+dwi.smooth+2CANY-method'></span><span id='topic+dwi.smooth.ms+2CANY-method'></span><span id='topic+dwi.smooth+2CdtiData-method'></span><span id='topic+dwi.smooth.ms+2CdtiData-method'></span>

<h3>Description</h3>

<p>Adaptive smoothing of DWI data. Smoothing is performed both in space and on the sphere (e.g. between images  obtained for different gradient directions) employing a natural
geometrical distance ( in SE(3)). Structural adaptation is used in space only.
Method <code>dwi.smooth</code> refers to the original POAS approach for single shell data.
Method <code>dwi.smooth.ms</code> implements an improved method that is applicable for both single and multi-shell data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
dwi.smooth(object, kstar, lambda=20, kappa0=NULL, mask=NULL, ncoils=1,
                                 sigma=NULL, level=NULL, vred=4, verbose=FALSE, dist=1, 
                                 model=c("Gapprox","Gapprox2","Chi","Chi2"))
  ## S4 method for signature 'dtiData'
dwi.smooth.ms(object, kstar, lambda=12, kappa0=.5, ncoils=1,
                                    sigma=NULL, ws0=1, level=NULL, mask = NULL, xind=NULL,
                                    yind=NULL, zind=NULL, verbose=FALSE,
                                    usemaxni=TRUE, memrelease = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwi.smooth-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_kstar">kstar</code></td>
<td>
<p> Number of steps in structural adaptation</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_lambda">lambda</code></td>
<td>
<p>Scale parameter in adaptation </p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_kappa0">kappa0</code></td>
<td>
<p>determines amount of smoothing on the sphere. Larger values correspond to stronger smoothing on the sphere. If <code>kappa0=NULL</code> a value is that corresponds to a variace reduction with factor <code>vred</code> on the sphere.</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_ncoils">ncoils</code></td>
<td>
<p>Number of coils in MR system </p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_sigma">sigma</code></td>
<td>
<p>Error standard deviation. Assumed to be known and homogeneous in the current implementation. A reasonable estimate may be defined
as the modal value of standard deviations obtained using method <code>getsdofsb</code>. </p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_level">level</code></td>
<td>
<p>Threshold for image intensities when setting mask.</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_mask">mask</code></td>
<td>
<p>Binary 3D image defining a mask</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_vred">vred</code></td>
<td>
<p>Used if <code>kappa0=NULL</code> to specify the variance reduction on the sphere when suggesting a value of kappa0</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_xind">xind</code></td>
<td>
<p>index for x-coordinate</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_yind">yind</code></td>
<td>
<p>index for y-coordinate</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_zind">zind</code></td>
<td>
<p>index for z-coordinate</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_verbose">verbose</code></td>
<td>
<p>If <code>verbose=TRUE</code> additional reports are given.</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_dist">dist</code></td>
<td>
<p>Distance in SE3. Reasonable values are 1 (default, see Becker et.al. 2012), 2 ( a slight modification of 1: with k6^2 instead of abs(k6)) and 3 (using a 'naive' distance on the sphere)</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_model">model</code></td>
<td>
<p>Determines which quantities are smoothed. Possible values are
<code>"Chi"</code> for observed values (assumed to be distributed as noncentral
Chi with <code>2*ncoils</code> degrees of freedom), <code>"Chi2"</code> for squares of
observed values (assumed to be distributed as noncentral
Chi-squared with <code>2*ncoils</code> degrees of freedom). <code>"Gapprox"</code>
and <code>"Gapprox2"</code> use a Gaussian approximation for the noncentral
Chi distribution to smooth ovserved and squared values, respectively.
</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_ws0">ws0</code></td>
<td>
<p>Factor to downweight information from S0 images, defaults
to <code>1/numer of s0 images</code>.</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_usemaxni">usemaxni</code></td>
<td>
<p>If <code>"usemaxni==TRUE"</code> a strikter penalization is used.</p>
</td></tr>
<tr><td><code id="dwi.smooth-methods_+3A_memrelease">memrelease</code></td>
<td>
<p>If <code>"memrelease==TRUE"</code> try to release allocated memory whenever possible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"dtiData"</code> with smoothed diffusion weighted images.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object) = "ANY"</code></dt><dd>
<p>Returns a warning.
</p>
</dd>
<dt><code>signature(object) = "dtiData"</code></dt><dd>
<p>Smoothing of DWI data
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+dtiData-class">dtiData</a></code>,
</p>

<hr>
<h2 id='dwiMD-methods'> Methods for Mean Diffusivity in Package &lsquo;dti&rsquo; </h2><span id='topic+dwiMD'></span><span id='topic+dwiMD+2CANY-method'></span><span id='topic+dwiMD+2CdtiData-method'></span><span id='topic+dwiMD+2CdtiTensor-method'></span>

<h3>Description</h3>

<p> Compute mean diffusivity (MD) from dtiData or dtiTensor objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
dwiMD(object, eps=.05)
  ## S4 method for signature 'dtiTensor'
dwiMD(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwiMD-methods_+3A_object">object</code></td>
<td>
<p>Object of class <code>"dtiData"</code> or <code>"dtiTensor"</code></p>
</td></tr>
<tr><td><code id="dwiMD-methods_+3A_eps">eps</code></td>
<td>
<p>tolerance in search for good gradient combinations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of mean diffusivities.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd><p>Returns a warning</p>
</dd>
<dt><code>signature(object = "dtiData")</code></dt><dd>
<p>searches for three gradients that enable best MD evaluation. Returns MD.
</p>
</dd>
<dt><code>signature(object = "dtiTensor")</code></dt><dd>
<p>calculates MD values from estimated difusion tensors
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+dtiTensor">dtiTensor</a></code>,
</p>

<hr>
<h2 id='dwiMixtensor-methods'> Methods for Function &lsquo;dwiMixtensor&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+dwiMixtensor'></span><span id='topic+dwiMixtensor-methods'></span><span id='topic+dwiMixtensor+2CANY-method'></span><span id='topic+dwiMixtensor+2CdtiData-method'></span><span id='topic+dwiMtCombine'></span><span id='topic+dwiMtCombine-methods'></span><span id='topic+dwiMtCombine+2CANY-method'></span><span id='topic+dwiMtCombine+2CdwiMixtensor+2CdwiMixtensor-method'></span>

<h3>Description</h3>

<p>The method estimates, in each voxel, a mixture of radial symmetric tensors from the DWI data contained in an object of class <code>"dtiData"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dtiData'
dwiMixtensor(object, maxcomp=3,
          model=c("MT","MTiso","MTisoFA","MTisoEV"), fa=NULL,
          lambda=NULL, mask=NULL, reltol=1e-10, maxit=5000, ngc=1000,
          nguess=100*maxcomp^2, msc=c("BIC","AIC","AICC","none"),
          mc.cores = setCores(,reprt=FALSE))
## S4 method for signature 'dwiMixtensor,dwiMixtensor'
dwiMtCombine(mtobj1, mtobj2, msc="BIC", where=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwiMixtensor-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_maxcomp">maxcomp</code></td>
<td>
<p> Maximal number of mixture components. </p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_model">model</code></td>
<td>
<p> Specifies the mixture model used. <code>"MT"</code> corresponds to a mixture
of prolate tensors, <code>"MTiso"</code> includes an isotropic compartment, <code>"MTisoFA"</code> additionally fixes FA to the value given in argument <code>fa</code> and <code>"MTisoEV"</code>
uses eigenvalues specified by <code>fa</code> and <code>lambda</code>. </p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_fa">fa</code></td>
<td>
<p>Value for FA in case of <code>model="MTisoFA"</code> or <code>model="MTisoEV"</code></p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_lambda">lambda</code></td>
<td>
<p>Value for first eigenvalue in case of <code>model="MTisoEV"</code></p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_mask">mask</code></td>
<td>
<p>Brain mask</p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_reltol">reltol</code></td>
<td>
<p> Relative tolerance for R's optim() function. </p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_maxit">maxit</code></td>
<td>
<p> Maximal number of iterations in R's optim() function. </p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_ngc">ngc</code></td>
<td>
<p> provide information on number of voxel processed, elapsed time and estimated remaining time after <code>ngc</code> voxel.</p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_nguess">nguess</code></td>
<td>
<p>number of guesses in search for initial estimates</p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_msc">msc</code></td>
<td>
<p>Criterion used to select the order of the mixture model, either
<code>BIC</code> (Bayes Information Criterion) <code>AIC</code> (Akaike Information Criterion) or <code>AICC</code> ((Bias-)Corrected Akaike Information Criterion).
<code>None</code> may be specified to only correct for under-estimation of variances.</p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_mtobj1">mtobj1</code></td>
<td>
<p>For method <code>"dwiMtCombine"</code> an <code>"dwiMixtensor"</code>-object.</p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_where">where</code></td>
<td>
<p>Mask of voxel for which  <code>"dwiMtImprove"</code> or <code>"dwiMtCombine"</code>
should be performed.</p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_mtobj2">mtobj2</code></td>
<td>
<p>For method <code>"dwiMtCombine"</code> an <code>"dwiMixtensor"</code>-object obtained from the same <code>"dwiData"</code> object. The maximum number of components in <code>mtobj2</code> should preferably  be less or equal to the maximum number of components in <code>mtobj1</code>.</p>
</td></tr>
<tr><td><code id="dwiMixtensor-methods_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use. Defaults to number of threads specified for openMP, see documentation of package <span class="pkg">awsMethods</span>.
Our experience suggests to use 4-6 cores if available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>model=="MT"</code> the function estimates, in each voxel, a mixture of radial symmetric (prolate) tensors from the DWI data contained in an object of class <code>"dtiData"</code>. The number of mixture components is selected depending on the data, with a maximum number of components specified by <code>maxcomp</code>. Optimization is performed usin R's internal BFGS code with mixture weights (volumes of compartments
corresponding to a tensor component) computed using the Lawson-Hannson NNLS code. <code>model=="MT"</code> is only available for single shell data.
In case of <code>model=="MTiso"</code> the model additionally contains an isotropic compartment. Optimization uses the internal L-BFGS-B code.
<code>model=="MTisoFA"</code> and <code>model=="MTisoEV"</code> fix FA and eigenvalues
of the prolate tensors, respectively, in the tensor mixture model with isotropic compartment.
</p>
<p>The method <code>"dwiMtCombine"</code> enables to combine results obtained for the same
dwi data set with different specifications, e.g. for maximum number of components
<code>mcomp</code> and settings that influence initial estimates. The combined result
contains in each voxel the best result from both reconstructions with respect to
the specified model selection criterion <code>msc</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"dwiMixtensor"</code>.
</p>


<h3>Author(s)</h3>

<p>   Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>Jian et al. (2007), A novel tensor distribution model for the
diffusion-weighted MR signal, <em>NeuroImage</em> <b>37</b>, 164&ndash;176.
</p>
<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Doi:10.1007/978-3-030-29184-6.
</p>


<h3>See Also</h3>

   <p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+readDWIdata">readDWIdata</a></code>,
<code><a href="#topic+medinria">medinria</a></code>,
<code><a href="#topic+dtiData-class">dtiData</a></code>,
<code><a href="#topic+dwiMixtensor-class">dwiMixtensor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(mixtens_art)
</code></pre>

<hr>
<h2 id='dwiQball-methods'> Methods for Function &lsquo;dwiQball&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+dwiQball'></span><span id='topic+dwiQball-methods'></span><span id='topic+dwiQball+2CANY-method'></span><span id='topic+dwiQball+2CdtiData-method'></span>

<h3>Description</h3>

<p>The method estimates, in each voxel, the coefficients of an expansion of the apparent diffusion cefficient (ADC) with respect to a apherical harmonics  orthonormal system  from the DWI data contained in an object of class <code>"dtiData"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
dwiQball(object, what="wODF", order=4, lambda=0, mask=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwiQball-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="dwiQball-methods_+3A_what">what</code></td>
<td>
<p> Determines quantity to estimate, coefficients ot the orientation density function (ODF) (<code>what="ODF"</code>, <code>what="wODF"</code>, <code>what="aODF"</code>)  or the apparent diffusion
coefficient (ADC) (<code>what="ADC"</code>) with respect to spherical harmonics of the up to the specified order.  </p>
</td></tr>
<tr><td><code id="dwiQball-methods_+3A_order">order</code></td>
<td>
<p> even integer: maximum order of the sperical harmonics expansion </p>
</td></tr>
<tr><td><code id="dwiQball-methods_+3A_lambda">lambda</code></td>
<td>
<p> nonnegative regularization parameter. </p>
</td></tr>
<tr><td><code id="dwiQball-methods_+3A_mask">mask</code></td>
<td>
<p> optional brain mask</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"dwiQball"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;ANY&quot;</dt><dd><p> Returns a warning. </p>
</dd>
<dt>obj = &quot;dtiData&quot;</dt><dd><p> Estimate, in each voxel, the coefficients of an expansion of the orientation density function (ODF) or the apparent diffusion coefficient (ADC) with respect to a apherical harmonics  orthonormal system.  Note that the
maxima of the ADC have no direct interpretation as fibre orientations. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p> M. Descoteaux, E. Angelino, S. Fitzgibbons and R. Deriche,
<em>Regularized, Fast and Robust Analytical Q-Ball Imaging</em>,
Magnetic Resonance Methods, 2007, 58, 497-512.
</p>
<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Doi:10.1007/978-3-030-29184-6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+readDWIdata">readDWIdata</a></code>,
<code><a href="#topic+dtiIndices-methods">dtiIndices-methods</a></code>,
<code><a href="#topic+medinria">medinria</a></code>,
<code><a href="#topic+dtiData-class">dtiData</a></code>,
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(dti_art)
</code></pre>

<hr>
<h2 id='dwiRiceBias-methods'> Correction for Rician Bias </h2><span id='topic+dwiRiceBias'></span><span id='topic+dwiRiceBias-methods'></span><span id='topic+dwiRiceBias+2CANY-method'></span><span id='topic+dwiRiceBias+2CdtiData-method'></span>

<h3>Description</h3>

<p>Correction for Rician Bias assuming known variance parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
dwiRiceBias(object, sigma=NULL, ncoils=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwiRiceBias-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="dwiRiceBias-methods_+3A_sigma">sigma</code></td>
<td>
<p> Scale parameter that relates the distribution of the signal to a
<code class="reqn">\chi_{2L}</code> distribution</p>
</td></tr>
<tr><td><code id="dwiRiceBias-methods_+3A_ncoils">ncoils</code></td>
<td>
<p> number of effective coils in parallel imaging, the related <code class="reqn">\chi</code>
distribution has <code>2*ncoils</code> degrees of freedom.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>An object of class <code>"dtiData"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd><p> Returns a warning. 
</p>
</dd>
<dt>object = &quot;dtiData&quot;</dt><dd>
<p>Returns a <code>dtiData</code> object with bias-corrected image intensities.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiData">dtiData</a></code>, 
<code><a href="#topic+dtiTensor-methods">dtiTensor-methods</a></code>, 
<code><a href="#topic+dwiMixtensor-methods">dwiMixtensor-methods</a></code>, 
<code><a href="#topic+dtiData-class">dtiData</a></code>, 
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>,
<code><a href="#topic+dwiMixtensor-class">dwiMixtensor</a></code>,
</p>

<hr>
<h2 id='dwiSqrtODF-methods'> Methods for positive definite EAP and ODF estimation in Package <span class="pkg">dti</span> </h2><span id='topic+dwiSqrtODF'></span><span id='topic+dwiSqrtODF-methods'></span><span id='topic+dwiSqrtODF+2CANY-method'></span><span id='topic+dwiSqrtODF+2CdtiData-method'></span>

<h3>Description</h3>

<p>Compute a positive definite estimate of the Ensemble Average Propagator (EAP)
and Orientation Density Function (ODF) using the approach of Cjeng et. al (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
dwiSqrtODF(object,what="sqrtODF",order=4,forder=1,lambda=0,D0=1.4e-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwiSqrtODF-methods_+3A_object">object</code></td>
<td>
<p>Object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="dwiSqrtODF-methods_+3A_what">what</code></td>
<td>
<p>Character, currently only &quot;sqrtODF&quot; is possible </p>
</td></tr>
<tr><td><code id="dwiSqrtODF-methods_+3A_order">order</code></td>
<td>
<p>Even integer, Order of spherical harmonics approximation.</p>
</td></tr>
<tr><td><code id="dwiSqrtODF-methods_+3A_forder">forder</code></td>
<td>
<p>Integer, Order of radial approximation.</p>
</td></tr>
<tr><td><code id="dwiSqrtODF-methods_+3A_lambda">lambda</code></td>
<td>
<p>Non-negative, Regularization parameter.</p>
</td></tr>
<tr><td><code id="dwiSqrtODF-methods_+3A_d0">D0</code></td>
<td>
<p>Numeric vector, grid of diffusivity parameters, typically about 1e-3.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd><p>Returns a warning.</p>
</dd>
<dt><code>signature(object = "dtiData")</code></dt><dd>
<p>Compute a positive definite estimate of the Ensemble Average Propagator (EAP)
and Orientation Density Function (ODF) using the approach of Cjeng et. al (2012).
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p> J. Cheng, T. Jiang and R. Deriche.
<em>Nonnegative Definite EAP and ODF Estimation via a Unified Multi-Shell HARDI Reconstruction</em>, MICCAI 2012. 
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiData">dtiData</a></code>, 
<code><a href="#topic+readDWIdata">readDWIdata</a></code>, 
<code><a href="#topic+dtiData-class">dtiData</a></code>, 
<code><a href="#topic+dwiQball-class">dwiQball</a></code>
</p>

<hr>
<h2 id='extract-methods'> Methods for Function &lsquo;extract&rsquo; and &lsquo;[&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+extract'></span><span id='topic+extract-methods'></span><span id='topic+extract+2CANY-method'></span><span id='topic+extract+2CdtiData-method'></span><span id='topic+extract+2CdtiIndices-method'></span><span id='topic+extract+2CdtiTensor-method'></span><span id='topic+extract+2CdwiMixtensor-method'></span><span id='topic+extract+2CdwiQball-method'></span><span id='topic++5B-methods'></span><span id='topic++5B+2CANY-method'></span><span id='topic++5B+2CdtiData-method'></span><span id='topic++5B+2CdtiIndices-method'></span><span id='topic++5B+2CdtiTensor-method'></span><span id='topic++5B+2CdkiIndices-method'></span><span id='topic++5B+2CdkiTensor-method'></span><span id='topic++5B+2CdwiMixtensor-method'></span><span id='topic++5B+2CdwiQball-method'></span>

<h3>Description</h3>

<p>The methods extract and/or compute specified statistics from object of class <code>"dtiData"</code>, <code>"dtiTensor"</code>, and <code>"dtiIndices"</code>. This can be restricted to a subset of voxel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
extract(x,
    what=c("data","gradient","btb","s0","sb","siq"),
    xind=TRUE, yind=TRUE, zind=TRUE)
  ## S4 method for signature 'dtiTensor'
extract(x, what=c("tensor", "fa", "ga", "md", "evalues",
      "andir", "s0", "mask", "bic", "aic", "outlier"),
    xind=TRUE, yind=TRUE, zind=TRUE, mc.cores = setCores(, reprt = FALSE))
  ## S4 method for signature 'dwiMixtensor'
extract(x, what=c("w0","andir", "order", "ev", "mix", "s0",
      "mask", "fa", "eorder", "bic", "aic"), xind=TRUE, yind=TRUE, zind=TRUE)
  ## S4 method for signature 'dtiIndices'
extract(x, what=c("fa", "andir", "ga", "md", "bary"),
    xind=TRUE, yind=TRUE, zind=TRUE)
  ## S4 method for signature 'dwiQball'
extract(x, what=c("sphcoef", "s0", "mask", "bic", "aic",
      "outlier"), xind=TRUE, yind=TRUE, zind=TRUE)
  ## S4 method for signature 'dtiData'
x[i, j, k, drop=FALSE]
  ## S4 method for signature 'dtiTensor'
x[i, j, k, drop=FALSE]
  ## S4 method for signature 'dtiIndices'
x[i, j, k, drop=FALSE]
  ## S4 method for signature 'dkiTensor'
x[i, j, k, drop=FALSE]
  ## S4 method for signature 'dkiIndices'
x[i, j, k, drop=FALSE]
  ## S4 method for signature 'dwiQball'
x[i, j, k, drop=FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract-methods_+3A_x">x</code></td>
<td>
<p> Object of class <code>dti</code> </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_i">i</code></td>
<td>
<p> vector of x-coordinates, defaults to whole range. </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_j">j</code></td>
<td>
<p> vector of y-coordinates, defaults to whole range. </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_k">k</code></td>
<td>
<p> vector of z-coordinates, defaults to whole range. </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_xind">xind</code></td>
<td>
<p> vector of x-coordinates, defaults to whole range. </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_yind">yind</code></td>
<td>
<p> vector of y-coordinates, defaults to whole range. </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_zind">zind</code></td>
<td>
<p> vector of z-coordinates, defaults to whole range. </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_what">what</code></td>
<td>
<p> Statistic to extract. See Methods Section for details. </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_drop">drop</code></td>
<td>
<p> unused. </p>
</td></tr>
<tr><td><code id="extract-methods_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Number of cores to use. Defaults to number of threads specified for openMP,
see documentation of package <span class="pkg">awsMethods</span>. Our experience suggests to use 4-6 cores if available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For function <code>extract</code> a list with components carrying the names of the options specified in
argument <code>what</code>.  For code&quot;[&quot; the cutted object.
</p>


<h3>Methods</h3>


<p>The generic extract function <code>"["</code> does what it is expected to do: it extracts parts of
the object specified by <code>i</code>, <code>j</code>, and <code>k</code>.
</p>
<dl>
<dt>x = &quot;ANY&quot;</dt><dd><p> Returns a warning for <code>extract</code>. Generic funtion for <code>"["</code>
returns an object of same class with data clipped to the indices specified in arguments <code>i</code>,
<code>j</code> and <code>k</code>.</p>
</dd>
<dt>x = &quot;dtiData&quot;</dt><dd><p> Extraction of squared gradient matrix <code>"btb"</code> or of S0 <code>"s0"</code>,
Sb <code>"sb"</code>, Si/mean(SO) <code>"siq"</code> or all images <code>"data"</code> restricted to the cube
defined by arguments <code>i</code>, <code>j</code> and <code>k</code>.</p>
</dd>
<dt>x = &quot;dtiIndices&quot;</dt><dd><p> Returns an array containing the specified statistics, i.e.
fractional anisotropy <code>"fa"</code>, geodesic anisotropy <code>"ga"</code>, mean diffusivity <code>"md"</code>,
main direction of anisotropy <code>"andir"</code> and/or shape parameters <code>"bary"</code>,
as specified in argument <code>what</code>. Information is extracted for voxel within the
cube defined by <code>xind</code>, <code>yind</code>, and <code>zind</code>. </p>
</dd>
<dt>x = &quot;dtiTensor&quot;</dt><dd><p> Returns a list with component names corresponding to <code>what</code>
containing the specified statistics, i.e. fractional anisotropy <code>"fa"</code>,
geodesic anisotropy <code>"ga"</code>, mean diffusivity <code>"md"</code>, eigenvalues <code>"evalues"</code>,
main direction of anisotropy <code>"andir"</code>, the tensor <code>"tensor"</code>
the estimated S0 image <code>"s0"</code>, the values of the model selection criteia
BIC <code>"bic"</code> or AIC <code>"aic"</code> and/or the mask used to restrict computations
<code>"mask"</code>, as specified in argument <code>what</code>. Information is extracted
for voxel within the  cube defined by arguments <code>xind</code>, <code>yind</code> and <code>zind</code>. </p>
</dd>
<dt>x = &quot;dwiMixtensor&quot;</dt><dd><p> Returns a list with component names corresponding to
<code>what</code> containing the specified statistics. Possible values for <code>what</code> are
<code>"w0"</code> (size of isotropic department), <code>"order"</code> (estimated number of mixture components),
<code>"eorder"</code> effective order), <code>"ev"</code> (eigenvalues), <code>"mix"</code> (mixture weights),
<code>"andir"</code> (main directions of diffusion), <code>"fa"</code> (FA index), <code>"s0"</code>
(the estimated S0 image), the values of the model selection criteia BIC <code>"bic"</code>
or AIC <code>"aic"</code> and <code>mask</code> (the mask used to restrict computations).
Information is extracted for voxel within the  cube defined by arguments <code>xind</code>,
<code>yind</code> and <code>zind</code>. </p>
</dd>
<dt>x = &quot;dwiQball&quot;</dt><dd><p> Returns an array containing the specified statistics,
the estimated coefficients with respect to the selected spherical harmonics basis
<code>"sphcoef"</code>, the estimated S0 image <code>"s0"</code>, the values of the model selection
criteia BIC <code>"bic"</code> or AIC <code>"aic"</code> and/or the mask used to restrict computations
<code>"mask"</code>, as specified in argument <code>what</code>. Information is extracted for voxel
within the  cube defined by arguments <code>xind</code>, <code>yind</code> and <code>zind</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiData-class">dtiData</a></code>,
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>,
<code><a href="#topic+dtiIndices-class">dtiIndices</a></code>
<code><a href="#topic+dwiMixtensor-class">dwiMixtensor</a></code>,
<code><a href="#topic+dwiQball-class">dwiQball</a></code>
</p>

<hr>
<h2 id='getmask-methods'> Methods for Function &lsquo;getmask&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+getmask'></span><span id='topic+getmask-methods'></span><span id='topic+getmask+2CANY-method'></span><span id='topic+getmask+2CdtiData-method'></span><span id='topic+getmask+2Carray-method'></span>

<h3>Description</h3>

<p>Create a mask containing voxel inside the head
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dtiData'
getmask(object, level = NULL, prop = 0.4, size = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getmask-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="getmask-methods_+3A_level">level</code></td>
<td>
<p>S0 intensity value to be used to discriminate between
voxel inside and outside the brain. A good value of level may be determined
using method <code>sdpar</code> in advance.</p>
</td></tr>
<tr><td><code id="getmask-methods_+3A_prop">prop</code></td>
<td>
<p>proportion of voxel in test area with s0 value larger than level
needed to decide for a voxel inside the brain</p>
</td></tr>
<tr><td><code id="getmask-methods_+3A_size">size</code></td>
<td>
<p>size of a cube defining a test area</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>dtiData</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;ANY&quot;</dt><dd><p> Returns a warning </p>
</dd>
<dt>obj = &quot;dtiData&quot;</dt><dd><p>Create a mask containing voxel inside the head </p>
</dd>
<dt>obj = &quot;array&quot;</dt><dd><p>Create a mask containing voxel inside the head </p>
</dd>
</dl>



<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+readDWIdata">readDWIdata</a></code>,
<code><a href="#topic+dti.smooth">dti.smooth</a></code>, 
<code><a href="#topic+sdpar">sdpar</a></code>
</p>

<hr>
<h2 id='getsdofsb-methods'> Estimate the noise standard deviation </h2><span id='topic+getsdofsb'></span><span id='topic+getsdofsb-methods'></span><span id='topic+getsdofsb+2CANY-method'></span><span id='topic+getsdofsb+2CdtiData-method'></span>

<h3>Description</h3>

<p>Estimate the noise standard deviation. Uses an assumption that the standard deviation
is a linear function of the expected mean for image intensities. <code>qA0</code> and <code>qA1</code> define quantiles of observed image intensities that define the range of values where this assumption is made.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
getsdofsb(object,qA0=.1,qA1=.98,nsb=NULL,level=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getsdofsb-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="getsdofsb-methods_+3A_qa0">qA0</code></td>
<td>
<p> level for lower quantile of image intensities</p>
</td></tr>
<tr><td><code id="getsdofsb-methods_+3A_qa1">qA1</code></td>
<td>
<p> level for upper quantile of image intensities</p>
</td></tr>
<tr><td><code id="getsdofsb-methods_+3A_nsb">nsb</code></td>
<td>
<p> number of diffusion weighted image to use</p>
</td></tr>
<tr><td><code id="getsdofsb-methods_+3A_level">level</code></td>
<td>
<p> level for mask</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>An object of class <code>"dtiData"</code> with results in slot <code>sdcoef</code> in components
<code>5</code>: intercept parameter, <code>6</code>: slope parameter for linear model,
<code>7</code>: lower bound (depending on <code>qA0</code>) and <code>8</code>: upper bound (depending on <code>qA1</code>).
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object) = "ANY"</code></dt><dd>
<p>Returns a warning.
</p>
</dd>
<dt><code>signature(object) = "dtiData"</code></dt><dd>
<p>Returns a <code>dtiData</code> object with estimated standard deviation parameters in 
slot <code>sdcoef</code>.
</p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiData">dtiData</a></code>, 
<code><a href="#topic+dwi.smooth-methods">dwi.smooth-methods</a></code>, 
<code><a href="#topic+dtiData-class">dtiData</a></code>, 
</p>

<hr>
<h2 id='medinria'> Read/Write Diffusion Tensor Data from/to NIFTI File </h2><span id='topic+MedINRIA'></span><span id='topic+medinria'></span><span id='topic+medinria2tensor'></span><span id='topic+tensor2medinria'></span>

<h3>Description</h3>

<p>Read/Write diffusion tensor data from/to NIfTI file. Interface functions to MedINRIA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  medinria2tensor(filename)
  tensor2medinria(obj, filename, xind = NULL, yind = NULL, zind = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medinria_+3A_filename">filename</code></td>
<td>
<p> file name for the tensor data. </p>
</td></tr>
<tr><td><code id="medinria_+3A_obj">obj</code></td>
<td>
<p> object of class <code>"dtiTensor"</code> </p>
</td></tr>
<tr><td><code id="medinria_+3A_xind">xind</code></td>
<td>
<p> index to define a subcube in x-direction. If <code>is.null(xind)</code> all voxel indices are used. </p>
</td></tr>
<tr><td><code id="medinria_+3A_yind">yind</code></td>
<td>
<p> index to define a subcube in y-direction. If <code>is.null(yind)</code> all voxel indices are used. </p>
</td></tr>
<tr><td><code id="medinria_+3A_zind">zind</code></td>
<td>
<p> index to define a subcube in z-direction. If <code>is.null(zind)</code> all voxel indices are used. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>For function <code>medinria2tensor</code>: object of class <code>"dtiTensor"</code>.
</p>


<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>  P. Fillard, J. Souplet and N. Toussaint 
<em> Medical Image Navigation and Research Tool by INRIA (MedINRIA)</em>, 
INRIA Sophia Antipolis - Research Project ASCLEPIOS 2007
</p>
<p><a href="https://www-sop.inria.fr/asclepios/software/MedINRIA/">https://www-sop.inria.fr/asclepios/software/MedINRIA/</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiTensor-class">dtiTensor</a></code>, 
<code><a href="#topic+dtiTensor-methods">dtiTensor-methods</a></code>
<code><a href="#topic+dtiIndices-methods">dtiIndices-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(dti_art)
</code></pre>

<hr>
<h2 id='optgrad'>Optimal gradient directions</h2><span id='topic+optgrad'></span>

<h3>Description</h3>

<p>List containing gradient directions minimizing Coulomb forces on the sphere following a proposal by D. Jones (1999) for number of gradients between 6 and 162.
</p>

<hr>
<h2 id='optgradients'>Optimal gradient directions for number of gradients between 6 and 162</h2><span id='topic+optgradients'></span>

<h3>Description</h3>

<p>Optimal gradient directions minimizing symmetrized 
Coulomb forces on the sphere following a proposal by Jones et al.
(1999). These directions define an optimal design in DWI for given
number of gradients. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optgrad</code></pre>


<h3>Format</h3>

<p>a list with name optgrad and component ngrad-5 containing
a matrix with ngrad gradients as columns.
</p>

<hr>
<h2 id='plot-methods'> Methods for Function &lsquo;plot&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+plot-methods'></span><span id='topic+plot+2CANY-method'></span><span id='topic+plot+2Cdwi-method'></span><span id='topic+plot+2CdtiData-method'></span><span id='topic+plot+2CdtiIndices-method'></span><span id='topic+plot+2CdkiIndices-method'></span><span id='topic+plot+2CdtiTensor-method'></span><span id='topic+plot+2CdwiMixtensor-method'></span><span id='topic+plot+2CdwiFiber-method'></span>

<h3>Description</h3>

<p>Visualization of objects of class <code>"dtiData"</code>, <code>"dtiIndices"</code>, <code>"dtiTensor"</code>and class <code>"dwiMixtensor"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dtiData'
plot(x, y, slice=1, gradient=NULL, view= "axial", show=TRUE,
   density=FALSE, xind=NULL, yind=NULL, zind=NULL, mar=par("mar"), mgp=par("mgp"), ...)
## S4 method for signature 'dtiTensor'
plot(x, y, slice=1, view="axial", quant=0, minfa=NULL, contrast.enh=1,
    what="fa", qrange=c(.01,.99), xind=NULL, yind=NULL, zind=NULL,
    mar=par("mar"), mgp=par("mgp"), ...)
## S4 method for signature 'dwiMixtensor'
plot(x, y, slice=1, view="axial", what="fa", minfa=NULL,
     identify=FALSE, xind=NULL, yind=NULL, zind=NULL, mar=par("mar"), mgp=par("mgp"), ...)
## S4 method for signature 'dtiIndices'
plot(x, y, slice=1, view= "axial", method=1, quant=0, minfa=NULL,
   show=TRUE, identify=FALSE, density=FALSE, contrast.enh=1, what="fa",
   xind=NULL, yind=NULL, zind=NULL, mar=par("mar"), mgp=par("mgp"), ...)
## S4 method for signature 'dwiFiber'
plot(x, y, ...)
## S4 method for signature 'dkiIndices'
plot(x, y, slice=1, what=c("md", "fa", "mk", "mk2",
     "k1", "k2", "k3", "kaxial", "kradial", "fak"), xind=NULL, yind=NULL,
     mar=par("mar"), mgp=par("mgp"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p> Object of class <code>"dtiIndices"</code>, <code>"dtiData"</code> or <code>"dtiTensor"</code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p> Not used </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_slice">slice</code></td>
<td>
<p> Slice number </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_view">view</code></td>
<td>
<p> Choose <code>"sagittal"</code>, <code>"coronal"</code>, or <code>"axial"</code> view here </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_gradient">gradient</code></td>
<td>
<p> Index of data cube to plot. Defaults to the first S0 image. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_method">method</code></td>
<td>
<p> Method for color coding tensor indices. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_quant">quant</code></td>
<td>
<p> If <code>is.null(minfa)</code> specify <code>minfa</code> as corresponding quantile of the fractal anisotropy (FA) index.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_minfa">minfa</code></td>
<td>
<p> Display only information for voxel with <code>(G)FA&gt;minfa</code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_show">show</code></td>
<td>
<p>Visualize information in a graphics device (for classes <code>"dtiData"</code> and <code>"dtiIndices"</code> only).  </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_identify">identify</code></td>
<td>
<p> Enable identification of coordinates by mouse actions, logical with default FALSE. Uses function <code>identify</code>. (for classes <code>"dtiIndices"</code> and <code>"dwiMixtensor"</code> only)</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_density">density</code></td>
<td>
<p>Show density of S0(Sb)-values (for class <code>"dtiData"</code>) or densities of fractal anisotropy (FA) or geodesic anisotropy (GA) ( for class <code>"dtiIndices"</code>).  </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_contrast.enh">contrast.enh</code></td>
<td>
<p> Enhance image contrast using <code>min(1,x$anindex/contrast.enh</code> instead of the anisotropy index itself. Effective values are within the interval (0,1).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_what">what</code></td>
<td>
<p> In case of class <code>"dtiIndices"</code> <code>what="ga"</code> uses geodesic anisotropy (GA) in contrast to <code>what="fa"</code> for fractional anisotropy (FA). For class <code>"dwiMixtensor"</code>
<code>what="fa"</code> for FA and <code>what="order"</code> for the number of mixture components may be chosen. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_mar">mar</code></td>
<td>
<p> Graphical parameter for <code>par</code>. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_mgp">mgp</code></td>
<td>
<p> Graphical parameter for <code>par</code>. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_qrange">qrange</code></td>
<td>
<p> Cut image intensity to these quantiles to avoid that outliers determine the dynamic range of the image. </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_xind">xind</code></td>
<td>
<p>If provided restrict display to indices specified in <code>xind</code> for x-direction.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_yind">yind</code></td>
<td>
<p>If provided restrict display to indices specified in <code>yind</code> for y-direction.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_zind">zind</code></td>
<td>
<p>If provided restrict display to indices specified in <code>zind</code> for z-direction.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p> currently not used </p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;</dt><dd><p> Generic function: see <code><a href="graphics.html#topic+plot">plot</a></code>. </p>
</dd>
<dt>x =  &quot;dwi&quot;</dt><dd><p> Returns a warning. </p>
</dd>
<dt>x = &quot;dtiData&quot;</dt><dd> <p><code>gradient</code> can be used to specify a specific data cube associated with the index of a gradient direction. For objects of class <code>"dtiData"</code> images are produces that are scaled by the maximal observed image value. This guarantees that subsequently produced images are on a comparable grey scale. The resulting image of class <code>"adimpro"</code> from package <span class="pkg">adimpro</span> is returned. </p>
</dd>
<dt>x = &quot;dtiIndices&quot;</dt><dd><p> Color coded anisotropy maps are produced depending on the specification in <code>method</code>. <code>method==1</code>, <code>method==2</code>, <code>method==4</code>  and <code>method==5</code> specify three different color schemes for directional FA-maps. <code>method==6</code> uses colored FA maps based on scheme developed at Uni Muenster (M. Deppe, Germany). <code>method==3</code> specifies visualization of dtiIndices using color coded shape parameters. If <code>identify==FALSE</code> the resulting image of class <code>"adimpro"</code> from package <span class="pkg">adimpro</span>, otherwise a matrix with coordinates of identified voxel is returned.</p>
</dd>
<dt>x = &quot;dtiTensor&quot;</dt><dd><p> The tensor itself, fractional anisotropy (FA), mean diffusivity (MD) and a color coded anisotropy map are provided. <code>NULL</code> is returned. </p>
</dd>
<dt>x = &quot;dwiMixtensor&quot;</dt><dd><p> Depending of <code>what</code> images of FA (<code>what="fa"</code>), number of mixture components (<code>what="order"</code>), effective order (<code>what="eorder"</code>) or maximum eigenvalues (<code>what="ev"</code>).  is returned. </p>
</dd>
<dt>x = &quot;dwiFiber&quot;</dt><dd><p> Creates a density plot of fiber lengths. <code>NULL</code> is returned.</p>
</dd>
<dt>x = &quot;dkiIndices&quot;</dt><dd><p>Prelimanary function to plot a slice of diffusion kurtosis indices: Mean Kurtosis <code>what="mk"</code> or <code>what="mk2"</code>, mean diffusivity <code>what="md"</code>, fractional anisotropy <code>what="fa"</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiIndices-class">dtiIndices</a></code>,
<code><a href="#topic+dtiData-class">dtiData</a></code>,
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>
<code><a href="#topic+dwiMixtensor-class">dwiMixtensor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(dti_art)
</code></pre>

<hr>
<h2 id='polyeder'>Polyeders derived from the Icosahedron (icosa0) by
sequential triangulation of surface triangles</h2><span id='topic+polyeder'></span><span id='topic+icosa0'></span><span id='topic+icosa1'></span><span id='topic+icosa2'></span><span id='topic+icosa3'></span><span id='topic+icosa4'></span>

<h3>Description</h3>

<p>icosa0 - icosa4 provide a description of regular polyeders
derived from the Icosahedron (icosa0) by
sequential triangulation of surface triangles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icosa0</code></pre>


<h3>Format</h3>

<p>a list with components
</p>

<ol>
<li><p> vertices - array of dimension <code>c(3,nv)</code>. containing cartesian coordinate of the <code>nv</code> vertices.
</p>
</li>
<li><p> indices - Indices of vertices that define surface triangles of the polyeder.
</p>
</li>
<li><p> edges - Indices of vertices that define edges of the polyeder.
</p>
</li>
<li><p> nv - number of vertices
</p>
</li>
<li><p> ne - number of edges
</p>
</li>
<li><p> ni - number of triangles
</p>
</li></ol>


<hr>
<h2 id='print-methods'> Methods for Function &lsquo;print&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+print-methods'></span><span id='topic+print+2CANY-method'></span><span id='topic+print+2Cdwi-method'></span><span id='topic+print+2CdtiData-method'></span><span id='topic+print+2CdtiTensor-method'></span><span id='topic+print+2CdkiIndices-method'></span><span id='topic+print+2CdkiTensor-method'></span><span id='topic+print+2CdwiMixtensor-method'></span><span id='topic+print+2CdtiIndices-method'></span><span id='topic+print+2CdwiQball-method'></span><span id='topic+print+2CdwiFiber-method'></span>

<h3>Description</h3>

<p>The function provides information on data dimensions, data source and existing slot-names for objects of class <code>"dti"</code>, <code>"dtiData"</code>,
<code>"dtiTensor"</code>, <code>"dtiIndices"</code>, <code>"dkiIndices"</code>, <code>"dkiTensor"</code>, <code>"dwiMixtensor"</code>,  <code>"dwiQball"</code> and <code>"dwiFiber"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dwi'
print(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print-methods_+3A_x">x</code></td>
<td>
<p> Object of class <code>"dtiIndices"</code>, <code>"dtiData"</code>, <code>"dtiTensor"</code>, <code>"dkiIndices"</code>, <code>"dkiTensor"</code>, <code>"dwiFiber"</code>, <code>"dwiMixtensor"</code> or <code>"dwiQball"</code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;</dt><dd><p> Generic function: see <code><a href="base.html#topic+print">print</a></code>. </p>
</dd>
<dt>x = &quot;dwi&quot;</dt><dd><p> The function provides information on data dimensions, data source and existing slot-names for objects of class <code>"dwi"</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiIndices-class">dtiIndices</a></code>, 
<code><a href="#topic+dtiData-class">dtiData</a></code>, 
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>
<code><a href="#topic+dwiMixtensor-class">dwiMixtensor</a></code>
<code><a href="#topic+dwiQball-class">dwiQball</a></code>
<code><a href="#topic+dwiFiber-class">dwiFiber</a></code>
</p>

<hr>
<h2 id='readDWIdata'> Read Diffusion Weighted Data </h2><span id='topic+dtiData'></span><span id='topic+readDWIdata'></span>

<h3>Description</h3>

<p>The functions create a <code>"dtiData"</code> object from Diffusion Weighted Data from medicial imaging files in a list of directories or from an imagefile, where the diffusion weighted data is given as 2-byte integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtiData(gradient, imagefile, ddim, bvalue = NULL, xind = NULL, yind = NULL, zind = NULL,
        level = 0, mins0value = 1, maxvalue = 32000, voxelext = c(1, 1, 1),
        orientation = c(0L, 2L, 5L), rotation = diag(3))
readDWIdata(gradient, dirlist, format = c("DICOM", "NIFTI", "ANALYZE", "AFNI"),
        nslice = NULL, order = NULL, bvalue = NULL,
        xind = NULL, yind = NULL, zind = NULL, level = 0, mins0value = 1,
        maxvalue = 32000, voxelext = NULL, orientation = c(0L, 2L, 5L),
        rotation = NULL, pattern = NULL, SPM2=TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDWIdata_+3A_gradient">gradient</code></td>
<td>
<p> matrix of diffusion gradients (including zero gradients for S0 images) </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_imagefile">imagefile</code></td>
<td>
<p> name of data image file (binary 2Byte integers)</p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_ddim">ddim</code></td>
<td>
<p> dimension of image cube (3D) </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_dirlist">dirlist</code></td>
<td>
<p> list of directories containing the data files or name of a single data file (e.g. 4D NIFTI)</p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_format">format</code></td>
<td>
<p> string specifying the medical imaging format, one of &rdquo;DICOM&rdquo;, &rdquo;NIFTI&rdquo;, &rdquo;ANALYZE&rdquo;, or &rdquo;AFNI&rdquo; </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_nslice">nslice</code></td>
<td>
<p> number of slices (usually z-direction) </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_order">order</code></td>
<td>
<p> vector, specifying a different order of the data files, i.e. other than alphabetic order in the directories given by <code>dirlist</code>. If not given, 1:n is used for n data files (no order change). </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_bvalue">bvalue</code></td>
<td>
<p> vector of b-values (default 0 for S0 and 1 for Si)</p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_xind">xind</code></td>
<td>
<p> subindex for x-direction </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_yind">yind</code></td>
<td>
<p> subindex for y-direction </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_zind">zind</code></td>
<td>
<p> subindex for z-direction </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_level">level</code></td>
<td>
<p> determine <code>mins0value</code> as quantile of positive S0-values </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_mins0value">mins0value</code></td>
<td>
<p> set voxel in S0-images with values less than <code>level</code> &ldquo;inactive&rdquo; </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_maxvalue">maxvalue</code></td>
<td>
<p> set voxel with values larger than <code>maxvalue</code> inactive </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_voxelext">voxelext</code></td>
<td>
<p> voxel extensions in coordinate directions </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_orientation">orientation</code></td>
<td>
<p> orientations of data as coded in AFNI </p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_rotation">rotation</code></td>
<td>
<p> optional rotation matrix for the coordinate system.</p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_pattern">pattern</code></td>
<td>
<p> pattern for file matching in the directories <code>dirlist</code>.</p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_spm2">SPM2</code></td>
<td>
<p>Enable some non-standard NIfTI files produced by SPM to be readable.</p>
</td></tr>
<tr><td><code id="readDWIdata_+3A_verbose">verbose</code></td>
<td>
<p> some progress reports if TRUE </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>dtiData</code> creates an object of class <code>"dtiData"</code> from an image file, where the diffusion weighted data is given as 2-byte integer.  This image file has to be prepared by the user.  Use <code><a href="base.html#topic+writeBin">writeBin</a></code> to write out first all S0 images and than all Si images. The <code>gradient</code> should be created according to this order. Run the demo in order to have an example, how to do this!
</p>
<p>The function <code>readDWIdata</code> reads the data files given in the directories in <code>dirlist</code> in alphabetic order. The order can be changed using the <code>order</code> argument: If <code>filelist</code> is the vector of files in alphabetic order, they are read in the order <code>filelist[order]</code>.  If order is not given <code>order &lt;- 1:n</code> is used (no change!).  The medical imaging format is given by <code>format</code> and can be one of &rdquo;DICOM&rdquo;, &rdquo;NIFTI&rdquo;, &rdquo;ANALYZE&rdquo;, or &rdquo;AFNI&rdquo;.  The number of slices of the three dimensional data cube is given by <code>nslice</code>.  The diffusion gradients are provided as matrix <code>gradient</code>.
</p>
<p><code>xind</code>, <code>yind</code>, and <code>zind</code> define a region of interest as indices.  If not given <code>1:dim[i]</code> is used. <code>level</code> determine <code>mins0value</code> as quantile of positive S0-values.  <code>mins0value</code> sets voxel in S0-images with values less than <code>level</code> &ldquo;inactive&rdquo;.  <code>maxvalue</code> sets voxel with values larger than <code>maxvalue</code> inactive.
</p>
<p><code>voxelext</code> defines the voxel extension, overwrites the values found in the imaging files.  <code>orientation</code> codes the data orientation in AFNI notation.
</p>


<h3>Value</h3>

<p>An object of class <code>"dtiData"</code>.
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Doi:10.1007/978-3-030-29184-6.
</p>
<p><a href="https://afni.nimh.nih.gov/pub/dist/src/README.attributes">https://afni.nimh.nih.gov/pub/dist/src/README.attributes</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dti.smooth">dti.smooth</a></code>,
<code><a href="#topic+dtiTensor-methods">dtiTensor-methods</a></code>,
<code><a href="#topic+dtiData-class">dtiData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(dti_art)
</code></pre>

<hr>
<h2 id='sdpar-methods'> Methods for Function &lsquo;sdpar&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+sdpar'></span><span id='topic+sdpar-methods'></span><span id='topic+sdpar+2CANY-method'></span><span id='topic+sdpar+2CdtiData-method'></span>

<h3>Description</h3>

<p>This function estimates the parameters of a piecewise linear model for 
the dependence between error standard deviation and mean. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dtiData'
sdpar(object,level=NULL,sdmethod="none",interactive=TRUE,threshfactor=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdpar-methods_+3A_object">object</code></td>
<td>
<p> An object of class <code>dtiData</code> </p>
</td></tr>
<tr><td><code id="sdpar-methods_+3A_level">level</code></td>
<td>
<p> Suggested value for slot <code>level</code>. As a default the value in <code>object@level</code> is used. The value determines the lower endpoint of the linear section in the model for error standard deviation as a function of the mean.</p>
</td></tr>
<tr><td><code id="sdpar-methods_+3A_sdmethod">sdmethod</code></td>
<td>
<p>Method for estimating voxelwise standard deviations if replicates of zero weighted images are available, can be set to <code>"sd"</code> or <code>"mad"</code>. <code>"none"</code> specifies that no variance model is fitted</p>
</td></tr>
<tr><td><code id="sdpar-methods_+3A_interactive">interactive</code></td>
<td>
<p>If <code>TRUE</code> a density of values in zero weighted images is plotted together with 
the specification of the lower endpoint of the interval of linearity. A good choice of this point should correspond, if present, to the minimum between the first two modes of the density estimate. The value can be changed or accepted. If changed a new value for slot <code>lambda</code> is set. </p>
</td></tr>
<tr><td><code id="sdpar-methods_+3A_threshfactor">threshfactor</code></td>
<td>
<p>Factor for threshold-value selected if function is run in interactive mode. May be used to correct results if automatic threshold selection fails.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>dtiData</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;ANY&quot;</dt><dd><p> Returns a warning </p>
</dd>
<dt>obj = &quot;dtiData&quot;</dt><dd><p> Estimate parameters of a model for the dependence between error standard deviation and mean.</p>
</dd>
</dl>



<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+readDWIdata">readDWIdata</a></code>,
<code><a href="#topic+dti.smooth">dti.smooth</a></code>, 
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(dti_art)
</code></pre>

<hr>
<h2 id='setmask-methods'> Methods for Function &lsquo;setmask&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+setmask'></span><span id='topic+setmask-methods'></span><span id='topic+setmask+2CANY-method'></span><span id='topic+setmask+2CdtiData-method'></span>

<h3>Description</h3>

<p>Read mask definition from NIfTI file and include it in dtiData object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dtiData'
setmask(object, maskfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setmask-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code>"dtiData"</code></p>
</td></tr>
<tr><td><code id="setmask-methods_+3A_maskfile">maskfile</code></td>
<td>
<p>NIfTI file containing mask definition. Dimension need to be 
compatible, i.e. either equal <code>object@ddim0</code> or <code>object@ddim</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>dtiData</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;ANY&quot;</dt><dd><p> Returns a warning </p>
</dd>
<dt>obj = &quot;dtiData&quot;</dt><dd><p>Set mask definition in dtiObject using information provided as NIfTI file as e.g. provided by <code>fsl_bet</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiData">dtiData</a></code>,
<code><a href="#topic+readDWIdata">readDWIdata</a></code>,
</p>

<hr>
<h2 id='show-methods'> Methods for Function &lsquo;show&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+show-methods'></span><span id='topic+show+2CANY-method'></span><span id='topic+show+2Cdti-method'></span><span id='topic+show+2CdtiData-method'></span><span id='topic+show+2CdtiTensor-method'></span><span id='topic+show+2CdkiTensor-method'></span><span id='topic+show+2CdwiMixtensor-method'></span><span id='topic+show+2CdtiIndices-method'></span><span id='topic+show+2CdkiIndices-method'></span><span id='topic+show+2CdwiFiber-method'></span>

<h3>Description</h3>

<p>The function provides information on data dimensions, data source and existing slot-names for objects of class <code>"dti"</code>, <code>"dtiData"</code>,
<code>"dtiTensor"</code>, <code>"dwiMixtensor"</code>, <code>"dtiIndices"</code>, <code>"dwiQball"</code> or <code>"dwiFiber"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dti'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>dtiIndices</code>, <code>dtiData</code>, <code>dtiTensor</code>, <code>dkiTensor</code>, <code>dkiIndices</code>, <code>dwiMixtensor</code>, <code>dwiQball</code> or <code>dwiFiber</code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>x = &quot;ANY&quot;</dt><dd><p> Generic function. </p>
</dd>
<dt>x = &quot;dti&quot;</dt><dd><p> The function provides information on data dimensions, data source and existing slot-names for objects of class <code>"dti"</code>
and classes that extent <code>"dti"</code>. </p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiIndices-class">dtiIndices</a></code>, 
<code><a href="#topic+dtiData-class">dtiData</a></code>, 
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>
<code><a href="#topic+dwiMixtensor-class">dwiMixtensor</a></code>
<code><a href="#topic+dwiQball-class">dwiQball</a></code>
<code><a href="#topic+dwiFiber-class">dwiFiber</a></code>
</p>

<hr>
<h2 id='show3d-methods'> Methods for Function &lsquo;show3d&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+show3d'></span><span id='topic+show3d-methods'></span><span id='topic+show3d+2CANY-method'></span><span id='topic+show3d+2CdtiData-method'></span><span id='topic+show3d+2CdtiIndices-method'></span><span id='topic+show3d+2CdtiTensor-method'></span><span id='topic+show3d+2CdkiTensor-method'></span><span id='topic+show3d+2CdwiMixtensor-method'></span><span id='topic+show3d+2CdwiQball-method'></span><span id='topic+show3d+2CdwiFiber-method'></span>

<h3>Description</h3>

<p>The function provides 3D visualization of <code>"dtiData"</code>, <code>"dtiTensor"</code>, <code>"dwiQball"</code> and <code>"dtiIndices"</code> objects using the <code>"rgl"</code>-package. Functionality of the rgl-package allows to rotate and zoom the displayed object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dtiData'
show3d(obj, xind=NULL, yind=NULL, zind=NULL, quant=.8,
         scale=.4,
         bgcolor="black", add=FALSE, maxobjects=729, what=c("adc","data"),
         minalpha=1, nn=1, normalize=FALSE, box=FALSE, title=FALSE, ...)
## S4 method for signature 'dtiTensor'
show3d(obj, xind=NULL, yind=NULL, zind=NULL, method=1,
         minfa=.3, mask=NULL, fibers=FALSE,
         maxangle = 30,level=0, quant=.8, scale=.4, bgcolor="black", add=FALSE,
         subdivide=2, maxobjects=729, what=c("tensor","adc","odf"), odfscale = 1,
         minalpha=.25, normalize=NULL, box=FALSE, title=FALSE,...)
## S4 method for signature 'dkiTensor'
show3d(obj, xind=NULL, yind=NULL, zind=NULL, method=1,
         minfa=.3, mask=NULL, level=0, quant=.8, scale=.4, bgcolor="black",
         add=FALSE, subdivide=2, maxobjects=729, what=c("KT", "DT"),
         minalpha=.25, normalize=NULL, box=FALSE, title=FALSE,...)
## S4 method for signature 'dtiIndices'
show3d(obj, index=c("fa","ga"), xind=NULL, yind=NULL,
         zind=NULL, method=1,
         minfa=0, bgcolor="black", add=FALSE, lwd=1, box=FALSE,
         title=FALSE, ...)
## S4 method for signature 'dwiMixtensor'
show3d(obj, xind=NULL, yind=NULL, zind=NULL, minfa=.3,
         minorder = 1, mineo=1, fibers=FALSE, maxangle=30, level=0,
         quant=.8, scale=.4, bgcolor="black", add=FALSE,
         subdivide=3, maxobjects=729, what=c("odf","axis","both"), odfscale=1,
         minalpha=1, lwd=3, box=FALSE, title=FALSE, ...)
## S4 method for signature 'dwiQball'
show3d(obj, xind=NULL, yind=NULL, zind=NULL, level=0,
         quant=.8, scale=0.4, odfscale=1, bgcolor="black", add=FALSE,
         subdivide=3, maxobjects=729, minalpha=1, box=FALSE,
         title=FALSE, ...)
## S4 method for signature 'dwiFiber'
show3d(obj, add=FALSE, bgcolor="black", box=FALSE,
         title=FALSE, lwd=1, delta=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show3d-methods_+3A_obj">obj</code></td>
<td>
<p> An object of class <code>dtiData</code>, <code>dtiTensor</code>, <code>dtiIndices</code>,<code>dwiMixTensor</code> or <code>dwiQball</code></p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_xind">xind</code></td>
<td>
<p> vector of x-coordinates, defaults to whole range. </p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_yind">yind</code></td>
<td>
<p> vector of y-coordinates, defaults to whole range. </p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_zind">zind</code></td>
<td>
<p> vector of z-coordinates, defaults to whole range. </p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_quant">quant</code></td>
<td>
<p>Quantile of maximal radii of objects used for scaling.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_scale">scale</code></td>
<td>
<p>Scale factor for the size of objects</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_bgcolor">bgcolor</code></td>
<td>
<p>Backgroundcolor for rgl-display</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_add">add</code></td>
<td>
<p>If true information is added to the current device, otherwise a new device is opened.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_maxobjects">maxobjects</code></td>
<td>
<p>Maximal size of data cube (in voxel) to display</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_minalpha">minalpha</code></td>
<td>
<p>Minimum value for transparency.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_nn">nn</code></td>
<td>
<p>Number of nearest neighbors used for interpolation onto a regular polyeder.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> normalize values (project to interval (0,1) within each voxel). For tensor objects <code>normalize=NULL</code> specifies a default depending on the content of argument what
</p>
<p>(<code>normalize &lt;- switch(what,"tensor"=FALSE,"adc"=TRUE)</code>).</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_box">box</code></td>
<td>
<p>Logical, add a bounding box.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_title">title</code></td>
<td>
<p>Either a character string specifying a title or a logical. If <code>title==TRUE</code> a default title characterizing the type of plot is generated. </p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_method">method</code></td>
<td>
<p><code>method==1</code> and <code>method==2</code> specify two different color schemes for directional FA-maps.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_minfa">minfa</code></td>
<td>
<p>Minimal FA value for dtiTensor objects and for dwiMixtensor objects.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_mask">mask</code></td>
<td>
<p>additional mask for dtiTensor objects.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_minorder">minorder</code></td>
<td>
<p>Minimal order for dwiMixtensor objects.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_mineo">mineo</code></td>
<td>
<p>Minimal effective order for dwiMixtensor objects.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_fibers">fibers</code></td>
<td>
<p>If <code>TRUE</code> show fibers starting in voxel with <code>fa&gt;=minfa</code>, <code>order&gt;=minorder</code> and <code>eorder&gt;=mineo</code>, the last two effective for dwiMixtensor objects only.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_maxangle">maxangle</code></td>
<td>
<p>argument for fibertracking</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_level">level</code></td>
<td>
<p>Radius of sphere used as support for ODF visualisation</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_subdivide">subdivide</code></td>
<td>
<p>Level of subdivisions for meshing, level <code>0:4</code> correspond to use of
<code>c(12,42,162,642,2562)</code> vertices per tensor, respectively.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_what">what</code></td>
<td>
<p>For dtiTensor-objects either <code>"tensor"</code> for visualization using ellipsoids, <code>"adc"</code> for Apparent Diffusion Coefficients or <code>"odf"</code> for the Orientation Density Function.
For dwiMixtensor-objects possible specifications are <code>"odf"</code>, <code>"axis"</code>
and <code>"both"</code>, with the latter superposing the estimated main directions on the estimated ODF. For <code>"axis"</code>(and <code>"both"</code>) the length of the axis corresponds to the mixture weights.
For dtiData-objects choices are either <code>"data"</code>  or <code>"adc"</code>.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_odfscale">odfscale</code></td>
<td>
<p>Determines visualisation of the Orientation density function (ODF). For <code>odfscale=3</code> the
ODF values are rescaled such that the volume of the displayes objects is constant. <code>odfscale=1</code> uses
the values of the ODF as radii in the corrsponding vertice direction of the specified polyhedron. This
can lead to extremely large volumes in case of one mixture component with high excentricity.
values of <code>odfscale</code> inbetween 1 and 3 are possible and allow to balance between volume based
visualization and emphazising highly structured ODF's.  </p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_lwd">lwd</code></td>
<td>
<p>Linewidth for visualization of dtiIndices objects.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_index">index</code></td>
<td>
<p>Eiter <code>"FA"</code> for fractional anisotropy index or
<code>"GA"</code> for geodesic anisotropy index.</p>
</td></tr>
<tr><td><code id="show3d-methods_+3A_delta">delta</code></td>
<td>
<p>if <code>delta&gt;0</code> Join line segments in fiber objects as long as acos of directions is smaller than <code>delta</code>.
Reduces the size of 3D object at the cost of resolution. </p>
</td></tr> 
<tr><td><code id="show3d-methods_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to function <code>rgl.par</code> from the rgl-package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the number of the current rgl-device.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;ANY&quot;</dt><dd><p> Returns a warning </p>
</dd>
<dt>obj = &quot;dtiData&quot;</dt><dd><p>Empirical ADC's are visualized at the voxel centers. Color
is determined by gradient directions, ADC values are reflected by both radial extend and
transparancy. The value of <code>maxobjects</code> limits the size of datacube and may be increased
on hardware with suitable graphics capabilities. </p>
</dd>
<dt>obj = &quot;dtiIndices&quot;</dt><dd><p> Objects are visualized as a collection of line segments with location given by the voxel center, orientation and color determined by the main direction of inisotropy and length corresponding to either fractional or geodesic anisotropy as specified in <code>index</code>.
</p>
<p>Displayed objects are restricted to voxel with an fractional (geodesic) anisotropy larger than <code>level</code>.</p>
</dd>
<dt>obj = &quot;dtiTensor&quot;</dt><dd><p>Ellipsoids/ADC's are visualized at the voxel centers. Orientation and size correspond to the tensor
values, color is determined by the main direction of anisotropy using the colorsceme specified with <code>method</code>. The fractional anisotropy value is coded as transparency. The value of <code>maxobjects</code> limits the size of datacube and may be increased
on hardware with suitable graphics capabilities. </p>
</dd>
<dt>obj = &quot;dkiTensor&quot;</dt><dd><p>Prelimenary show3d method for diffusion kurtosis tensors.</p>
</dd>
<dt>obj = &quot;dwiQball&quot;</dt><dd><p>Estimated ODF/ADC's are visualized at the voxel centers. Color
is determined by directions, ODF/ADC values are reflected by both radial extend and
transparancy. The value of <code>maxobjects</code> limits the size of datacube and may be increased
on hardware with suitable graphics capabilities. </p>
</dd>
<dt>obj = &quot;dwiFiber&quot;</dt><dd><p>Display and combine fibres generated by function tracking. </p>
</dd>
</dl>
<p>Displays can be closed using function <code>rgl.close</code>

</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiIndices-methods">dtiIndices-methods</a></code>,
<code><a href="#topic+dti.smooth">dti.smooth</a></code>,
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>,
<code><a href="#topic+dtiIndices-class">dtiIndices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: demo(dti_art)
</code></pre>

<hr>
<h2 id='showFAColorScale'>
Writes an image with the colqFA colorscale to disk.
</h2><span id='topic+showFAColorScale'></span>

<h3>Description</h3>

<p>Writes an image (type PNG) with the colqFA colorscale to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  showFAColorScale(filename = "FAcolorscale.png")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showFAColorScale_+3A_filename">filename</code></td>
<td>
<p> Name of file to write.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+colqFA">colqFA</a></code>
</p>

<hr>
<h2 id='subsetg'>
Create an objects of class &quot;dtiData&quot; containing only a subset of gradient directions.
</h2><span id='topic+subsetg'></span>

<h3>Description</h3>

<p>This function creates an object of class &quot;dtiData&quot; that containes
only a subset, defined by an index vector, of the S0 and diffusion weighted images. 
This function may e.g. be used to separate information measured on different
shells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetg(x, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetg_+3A_x">x</code></td>
<td>

<p>Object of class <code>"dtiData"</code>
</p>
</td></tr>
<tr><td><code id="subsetg_+3A_ind">ind</code></td>
<td>

<p>Indexvector containing values between <code>1</code> and <code>x@ngrad</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;dtiData&quot;.
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiData">dtiData</a></code>, 
<code><a href="#topic+readDWIdata">readDWIdata</a></code>, 
<code><a href="#topic+dtiData-class">dtiData</a></code>, 
<code><a href="#topic+combineDWIdata">combineDWIdata</a></code>
</p>

<hr>
<h2 id='summary-methods'> Methods for Function &lsquo;summary&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2Cdwi-method'></span><span id='topic+summary+2CdtiData-method'></span><span id='topic+summary+2CdtiTensor-method'></span><span id='topic+summary+2CdkiTensor-method'></span><span id='topic+summary+2CdwiMixtensor-method'></span><span id='topic+summary+2CdtiIndices-method'></span><span id='topic+summary+2CdkiIndices-method'></span><span id='topic+summary+2CdwiQball-method'></span><span id='topic+summary+2CdwiFiber-method'></span>

<h3>Description</h3>

<p>The method provides summary information for objects of class <code>"dti"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'dwi'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p> Object of class <code>"dti"</code>, <code>"dtiData"</code>, <code>"dtiTensor"</code>, <code>"dwiMixtensor"</code>, <code>"dtiIndices"</code>, <code>"dkiIndices"</code>, <code>"dkiTensor"</code>,  <code>"dwiQball"</code> or <code>"dwiFiber"</code>. </p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p> Additional arguments in <code>...</code> are passed to function <code>quantile</code>, e.g. argument <code>probs</code> may be specified here.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd><p> Generic function: see <code><a href="base.html#topic+summary">summary</a></code>. </p>
</dd>
<dt>object = &quot;dwi&quot;</dt><dd><p>  The function provides summary information for objects of class <code>"dwi"</code>, <code>"dtiData"</code>, <code>"dtiTensor"</code>, <code>"dwiMixtensor"</code>, <code>"dtiIndices"</code>, <code>"dkiIndices"</code>, <code>"dkiTensor"</code>, <code>"dwiQball"</code> 
and , <code>"dwiFiber"</code> </p>
</dd>
</dl>


<h3>Author(s)</h3>

 
<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br /> 
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+dtiIndices-class">dtiIndices</a></code>, ]
<code><a href="#topic+dtiData-class">dtiData</a></code>, 
<code><a href="#topic+dtiTensor-class">dtiTensor</a></code>
<code><a href="#topic+dwiMixtensor-class">dwiMixtensor</a></code>
<code><a href="#topic+dwiQball-class">dwiQball</a></code>
<code><a href="#topic+dwiFiber-class">dwiFiber</a></code>
</p>

<hr>
<h2 id='tracking-methods'> Methods for Function &lsquo;tracking&rsquo; in Package &lsquo;dti&rsquo; </h2><span id='topic+tracking'></span><span id='topic+selectFibers'></span><span id='topic+reduceFibers'></span><span id='topic+combineFibers'></span><span id='topic+touchingFibers'></span><span id='topic+tracking-methods'></span><span id='topic+selectFibers-methods'></span><span id='topic+combineFibers-methods'></span><span id='topic+touchingFibers-methods'></span><span id='topic+tracking+2CANY-method'></span><span id='topic+tracking+2CdtiTensor-method'></span><span id='topic+tracking+2CdtiIndices-method'></span><span id='topic+tracking+2CdwiMixtensor-method'></span><span id='topic+selectFibers+2CdwiFiber-method'></span><span id='topic+reduceFibers+2CdwiFiber-method'></span><span id='topic+combineFibers+2CdwiFiber+2CdwiFiber-method'></span><span id='topic+touchingFibers+2CdwiFiber+2CdwiFiber-method'></span>

<h3>Description</h3>

<p>The function provides fiber tracking of <code>"dtiTensor"</code>, <code>"dtiIndices"</code>, and <code>"dwiMixtensor"</code> objects and
methods for fiber manipulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dtiTensor'
tracking(obj, roix=NULL, roiy=NULL, roiz=NULL, mask=NULL,
                    method="LINEPROP", minfa=0.3, maxangle=30, subsample = 1)
## S4 method for signature 'dtiIndices'
tracking(obj, roix=NULL, roiy=NULL, roiz=NULL, mask=NULL,
                    method="LINEPROP", minfa=0.3, maxangle=30, subsample = 1)
## S4 method for signature 'dwiMixtensor'
tracking(obj, roix=NULL, roiy=NULL, roiz=NULL, mask=NULL,
                    method="LINEPROP", minfa=0.3, maxangle=30, subsample = 1,
                    mincompartsize = 0)
## S4 method for signature 'dwiFiber'
selectFibers(obj, roix=NULL, roiy=NULL, roiz=NULL, mask=NULL,
                    minlength=1)
## S4 method for signature 'dwiFiber'
reduceFibers(obj, maxdist=1, ends=TRUE)

## S4 method for signature 'dwiFiber,dwiFiber'
combineFibers(obj, obj2)

## S4 method for signature 'dwiFiber,dwiFiber'
touchingFibers(obj, obj2, maxdist=1, combine=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracking-methods_+3A_obj">obj</code></td>
<td>
<p> An object of class <code>"dtiTensor"</code>, <code>"dtiIndices"</code>, or <code>"dwiMixtensor"</code> for tracking() and <code>"dwiFiber"</code> for selectFiber(), conbineFibers().</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_obj2">obj2</code></td>
<td>
<p> An object of class <code>"dwiFiber"</code> for combineFibers().</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_roix">roix</code></td>
<td>
<p>Indices defining the ROI in x direction. Currently min/max is used to define ROIx</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_roiy">roiy</code></td>
<td>
<p>Indices defining the ROI in y direction. Currently min/max is used to define ROIy</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_roiz">roiz</code></td>
<td>
<p>Indices defining the ROI in z direction. Currently min/max is used to define ROIz</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_mask">mask</code></td>
<td>
<p>Mask defining seed points for tracking</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_method">method</code></td>
<td>
<p>Method for fibre tracking. &quot;LINEPROP&quot; is simple line propagation algorithm which is the default.</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_minfa">minfa</code></td>
<td>
<p>Minimal FA to follow the tracks. default 0.3</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_maxangle">maxangle</code></td>
<td>
<p>Maximal angle between fiber in adjacent voxels. default 30 degree.</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_subsample">subsample</code></td>
<td>
<p>Subsampling order of the data to get more dense fibre tracks. Note, that objects become very(!) large.</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_minlength">minlength</code></td>
<td>
<p>Minimal length of fibers to be selected.</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_maxdist">maxdist</code></td>
<td>
<p>Maximal supremum distance between fibers in mm</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_ends">ends</code></td>
<td>
<p>Logical: Use only endpoints of shorter fibers for distance (TRUE) or
compute distances using full fiber-length (FALSE). Default (TRUE) removes more fibers and is significantly faster. </p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_mincompartsize">mincompartsize</code></td>
<td>
<p>Minimal size of a compartment in dwiMixtensor
that will be used in fiber tracking.</p>
</td></tr>
<tr><td><code id="tracking-methods_+3A_combine">combine</code></td>
<td>
<p>If <code>combine=TRUE</code>  fibers selected from <code>obj</code>
are combined with the fibers from <code>obj2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code><a href="#topic+dwiFiber-class">dwiFiber</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>obj = &quot;dtiTensor&quot;</dt><dd><p> Fiber tracking is performed on the estimated vector field of principal diffusion direction using the method <code>method</code>. Currently only line propagation is implemented. The resulting tracks can be visualized using function <code><a href="#topic+show3d">show3d</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>obj = &quot;dtiIndices&quot;</dt><dd><p> Fiber tracking is performed on the estimated vector field of principal diffusion direction using the method <code>method</code>. Currently only line propagation is implemented. The resulting tracks can be visualized using function <code><a href="#topic+show3d">show3d</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>obj = &quot;dwiMixtensor&quot;</dt><dd><p> Fiber tracking is performed on the estimated vector fields of diffusion direction in the mixed tensor model using the method <code>method</code>. Currently only line propagation is implemented. The resulting tracks can be visualized using function <code><a href="#topic+show3d">show3d</a></code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>obj = &quot;dwiFiber&quot;</dt><dd><p><code>selectFibers</code> produces a dwiFiber-object containing all fibers that cross the region of interest and exceed a minimum length. <code>reduceFibers</code> eliminates all fibers that are within a maximum supremum distance of <code>maxdist</code> mm of a longer fiber. <code>reduceFibers</code>
allows to reduce the size of a dwiFiber-object considerably but is slow !
</p>
</dd>
<dt><code>signature(obj1 = "dwiFiber", obj2 = "dwiFiber")</code></dt><dd><p><code>combineFibers</code> produces a dwiFiber-object containing all fibers that are in one of the supplied objects.
<code>touchingFibers</code> takes all fibers from <code>obj</code> that have
a minimum distance to a fiber in <code>obj2</code> of less than <code>maxdist</code>.
If <code>combine=TRUE</code> these fibers are combined with the fibers from <code>obj2</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a>, Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl, K. Tabelow (2019). Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R. Springer, Use R! series. Doi:10.1007/978-3-030-29184-6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtiTensor-class">dtiTensor</a></code>,<code><a href="#topic+dtiIndices-class">dtiIndices</a></code>,<code><a href="#topic+dwiFiber-class">dwiFiber</a></code>,
<code><a href="#topic+show3d">show3d</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="base.html#topic+print">print</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
