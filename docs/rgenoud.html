<!DOCTYPE html><html><head><title>Help for package rgenoud</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rgenoud}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#genoud'>
<p>GENetic Optimization Using Derivatives</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>5.9-0.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-13</td>
</tr>
<tr>
<td>Title:</td>
<td>R Version of GENetic Optimization Using Derivatives</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jasjeet Singh Sekhon &lt;jas.sekhon@yale.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A genetic algorithm plus derivative optimizer.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JasjeetSekhon/rgenoud">https://github.com/JasjeetSekhon/rgenoud</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-14 23:52:35 UTC; theosaa</td>
</tr>
<tr>
<td>Author:</td>
<td>Walter R. Mebane, Jr [aut],
  Jasjeet Singh Sekhon [aut, cre],
  Theo Saarinen [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-15 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='genoud'>
GENetic Optimization Using Derivatives
</h2><span id='topic+genoud'></span>

<h3>Description</h3>

<p><code>Genoud</code> is a function that combines evolutionary search
algorithms with derivative-based (Newton or quasi-Newton) methods to
solve difficult optimization problems.  <code>Genoud</code> may also be
used for optimization problems for which derivatives do not exist.
<code>Genoud</code>, via the <code>cluster</code> option, supports the use of
multiple computers, CPUs or cores to perform parallel computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genoud(fn, nvars, max=FALSE, pop.size=1000, max.generations=100, 
       wait.generations=10, hard.generation.limit=TRUE, starting.values=NULL, 
       MemoryMatrix=TRUE, Domains=NULL, default.domains=10, 
       solution.tolerance=0.001, gr=NULL, boundary.enforcement=0, lexical=FALSE,
       gradient.check=TRUE, BFGS=TRUE, data.type.int=FALSE, hessian=FALSE, 
       unif.seed=round(runif(1, 1, 2147483647L)), 
       int.seed=round(runif(1, 1, 2147483647L)),print.level=2, share.type=0, 
       instance.number=0, output.path="stdout", output.append=FALSE, 
       project.path=NULL, P1=50, P2=50, P3=50, P4=50, P5=50, P6=50, P7=50, 
       P8=50, P9=0, P9mix=NULL, BFGSburnin=0, BFGSfn=NULL, BFGShelp=NULL, 
       control=list(), optim.method=ifelse(boundary.enforcement &lt; 2, "BFGS", 
       "L-BFGS-B"), transform=FALSE, debug=FALSE, cluster=FALSE, balance=FALSE, 
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genoud_+3A_fn">fn</code></td>
<td>

<p>The function to be minimized (or maximized if
max=<code>TRUE</code>).  The first argument of the function must be the
vector of parameters over which minimizing is to
occur.  The function must return a scalar result (unless
<code>lexical=TRUE</code>).
</p>
<p>For example, if we wish to <em>maximize</em> the <code>sin()</code>
function.  We can simply call genoud by <code>genoud(sin,
      nvars=1,max=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="genoud_+3A_nvars">nvars</code></td>
<td>
<p>The number of parameters to be selected for the function to be minimized (or
maximized).</p>
</td></tr>
<tr><td><code id="genoud_+3A_max">max</code></td>
<td>

<p>Maximization (<code>TRUE</code>) or Minimizing (<code>FALSE</code>).  Determines
if <code>genoud</code> minimizes or maximizes the objective function.</p>
</td></tr>
<tr><td><code id="genoud_+3A_pop.size">pop.size</code></td>
<td>

<p>Population Size.  This is the number of individuals <code>genoud</code> uses to
solve the optimization problem.  There are several restrictions on
what the value of this number can be.  No matter what population
size the user requests, the number is automatically adjusted to make
certain that the relevant restrictions are satisfied.  These
restrictions originate
in what is required by several of the operators.  In particular,
operators 6 (Simple Crossover) and 8 (Heuristic
Crossover) require an even number of individuals to work on&mdash;i.e., they
require two parents.  Therefore, the <code>pop.size</code> variable and the
operators sets must be such that these three operators have an even
number of individuals to work with.  If this does not occur, the
population size is automatically increased until this constraint is
satisfied.</p>
</td></tr>
<tr><td><code id="genoud_+3A_max.generations">max.generations</code></td>
<td>

<p>Maximum Generations.  This is the maximum number of generations that
<code>genoud</code> will run when attempting to optimize a function.  This is a
<em>soft</em> limit.  The maximum generation limit will be binding for
<code>genoud</code> only if <code>hard.generation.limit</code> has
been set equal to <code>TRUE</code>.  If it has not been set equal to
<code>TRUE</code>, two soft  triggers control when <code>genoud</code> stops:
<code>wait.generations</code> and <code>gradient.check</code>. <br />
</p>
<p>Although the <code>max.generations</code> variable is not, by default,
binding, it is nevertheless important because many operators use it
to adjust
their behavior.  In essence, many of the operators become less random
as the generation count gets closer to the <code>max.generations</code>
limit.  If
the limit is hit and <code>genoud</code> decides to
continue working, <code>genoud</code> automatically increases the
<code>max.generation</code>
limit.<br />
</p>
<p>Please see <code>MemoryMatrix</code> for some important interactions
with memory management.</p>
</td></tr>
<tr><td><code id="genoud_+3A_wait.generations">wait.generations</code></td>
<td>

<p>If there is no improvement in the objective function in this number
of generations, <code>genoud</code> will think that it has
found the optimum.  If the
<code>gradient.check</code> trigger has been
turned on, <code>genoud</code> will only start counting <code>wait.generations</code>
if the gradients are within
<code>solution.tolerance</code> of zero.  The
other variables controlling termination are
<code>max.generations</code> and <code>hard.generation.limit</code>.</p>
</td></tr>
<tr><td><code id="genoud_+3A_hard.generation.limit">hard.generation.limit</code></td>
<td>

<p>This logical variable determines if the <code>max.generations</code>
variable is a binding constraint for <code>genoud</code>.  If
<code>hard.generation.limit</code> is <code>FALSE</code>, then <code>genoud</code> may exceed
the <code>max.generations</code> count if either the objective function
has improved within a given number of generations (determined by
<code>wait.generations</code>) or if the gradients are not zero
(determined by <code>gradient.check</code>). <br />
</p>
<p>Please see <code>MemoryMatrix</code> for some important interactions
with memory management.</p>
</td></tr>
<tr><td><code id="genoud_+3A_starting.values">starting.values</code></td>
<td>
<p>A vector or matrix containing parameter values
which <code>genoud</code> will use at startup.  Using this option, the user
may insert one or more individuals into the starting population.  If a
matrix is provided, the columns should be the variables and the rows
the individuals. <code>genoud</code> will randomly create the other
individuals.</p>
</td></tr>
<tr><td><code id="genoud_+3A_memorymatrix">MemoryMatrix</code></td>
<td>

<p>This variable controls if <code>genoud</code> sets up a memory matrix.  Such a
matrix ensures that <code>genoud</code> will request the fitness evaluation of a
given set of parameters only once. The variable may
be <code>TRUE</code> or <code>FALSE</code>.  If it is <code>FALSE</code>, <code>genoud</code> will
be aggressive in conserving memory.  The most significant negative
implication of this variable being set to <code>FALSE</code> is that
<code>genoud</code> will no longer maintain a memory matrix of all evaluated
individuals.  Therefore, <code>genoud</code> may request evaluations which it has
already previously requested. <br />
</p>
<p>Note that when <code>nvars</code> or <code>pop.size</code> are large, the memory
matrix consumes a large amount of RAM. <code>Genoud</code>'s memory matrix will
require somewhat less memory if the user sets
<code>hard.generation.limit</code> equal to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="genoud_+3A_domains">Domains</code></td>
<td>

<p>This is a <code>nvars</code> <code class="reqn">\times 2</code>
matrix.  For each variable, in the first column is the lower bound and
in the second column the upper bound.  None of <code>genoud</code>'s
starting population will be
generated outside of the bounds.  But some of the operators may
generate children which
will be outside of the bounds unless the
<code>boundary.enforcement</code> flag is
turned on. <br />
</p>
<p>If the user does not provide any values for Domains, <code>genoud</code> will setup
default domains using <code>default.domains</code>. <br />
</p>
<p>For linear and nonlinear constraints please see the discussion in
the <code>Note</code> section.</p>
</td></tr>
<tr><td><code id="genoud_+3A_default.domains">default.domains</code></td>
<td>

<p>If the user does not want to provide a <code>Domains</code> matrix,
domains may nevertheless be set by the user with this easy to use
scalar option.  <code>Genoud</code> will create a
Domains matrix by setting the lower bound for all of the parameters
equal to -1 <code class="reqn">\times</code> <code>default.domains</code> and the upper
bound equal to <code>default.domains</code>.</p>
</td></tr>
<tr><td><code id="genoud_+3A_solution.tolerance">solution.tolerance</code></td>
<td>

<p>This is the tolerance level used by <code>genoud</code>.  Numbers within
<code>solution.tolerance</code> are considered to be equal.  This is
particularly
important when it comes to evaluating <code>wait.generations</code> and
conducting the <code>gradient.check</code>.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_gr">gr</code></td>
<td>
<p>A function to provide the gradient for the <code>BFGS</code>
optimizer.  If it is <code>NULL</code>, numerical gradients will be used
instead.</p>
</td></tr>
<tr><td><code id="genoud_+3A_boundary.enforcement">boundary.enforcement</code></td>
<td>

<p>This variable determines the degree to which <code>genoud</code> obeys the
boundary constraints.  Notwithstanding the value of the variable,
none of <code>genoud</code>'s starting population values will be outside
of the bounds.  <br />
</p>
<p><code>boundary.enforcement</code> has three possible values: 0 (anything goes), 1
(partial), and 2 (no trespassing):
</p>

<dl>
<dt><em>0: Anything Goes</em></dt><dd>
<p>This option allows any of the operators to
create out-of-bounds individuals and these individuals will be
included in the
population if their fit values are good enough.  The boundaries are only
important when generating random individuals.</p>
</dd>
<dt><em>1: partial enforcement</em></dt><dd>
<p>This allows operators (particularly those operators
which use the derivative based optimizer, BFGS) to go out-of-bounds
during the creation of an individual (i.e., out-of-bounds values
will often be evaluated).  But when the operator has decided
on an individual, it <em>must</em> be in bounds to be acceptable.</p>
</dd>
<dt><em>2: No Trespassing</em></dt><dd>
<p>No out-of-bounds evaluations will ever be requested. In this
case, boundary enforcement is also applied to the BFGS
algorithm, which prevents candidates from straying beyond the
bounds defined by <code>Domains</code>. Note that this forces the use
of the L-BFGS-B algorithm for <code><a href="stats.html#topic+optim">optim</a></code>.
This algorithm requires that all fit values and gradients be
defined and finite for all function evaluations.  If this causes
an error, it is suggested that the BFGS algorithm be used
instead by setting <code>boundary.enforcement=1</code>.</p>
</dd></dl>
</td></tr>
<tr><td><code id="genoud_+3A_lexical">lexical</code></td>
<td>
<p>This option enables lexical optimization.  This is
where there are multiple fit criteria and the parameters are chosen so
as to maximize fitness values in lexical order&mdash;i.e., the second fit
criterion is only relevant if the parameters have the same fit for the
first etc.  The fit function used with this option should return a
numeric vector of fitness values in lexical order.  This option
can take on the values of <code>FALSE</code>, <code>TRUE</code> or an integer
equal to the number of fit criteria which are returned by <code>fn</code>.
The <code>value</code> object which is returned by <code>genoud</code> will
include all of the fit criteria at the solution.  The
<code><a href="Matching.html#topic+GenMatch">GenMatch</a></code> function makes extensive use of this
option.</p>
</td></tr>
<tr><td><code id="genoud_+3A_gradient.check">gradient.check</code></td>
<td>

<p>If this variable is <code>TRUE</code>, <code>genoud</code> will not start counting
<code>wait.generations</code> unless each gradient is
<code>solution.tolerance</code> close to zero.  This
variable has no effect if the <code>max.generations</code> limit has been
hit and the <code>hard.generation.limit</code> option has been set to
<code>TRUE</code>. If <code>BFGSburnin &lt; 0</code>, then it will be ignored unless
<code>gradient.check = TRUE</code>. </p>
</td></tr>
<tr><td><code id="genoud_+3A_bfgs">BFGS</code></td>
<td>
 
<p>This variable denotes whether or not <code>genoud</code> applies a
quasi-Newton derivative optimizer (BFGS) to the best individual at
the end of each generation after the initial one. See the
<code>optim.method</code> option to change the optimizer. Setting BFGS to
<code>FALSE</code> does not mean that the BFGS will never be used.  In
particular, if you want BFGS never to be used, <code>P9</code> (the
Local-Minimum Crossover operator) must also be set to zero.</p>
</td></tr>
<tr><td><code id="genoud_+3A_data.type.int">data.type.int</code></td>
<td>

<p>This option sets the data type of the parameters of the function to
be optimized.  If the variable is <code>TRUE</code>, <code>genoud</code> will
search over integers when it optimizes the parameters.  <br />
</p>
<p>With integer parameters, <code>genoud</code> never uses derivative
information.  This implies that the BFGS quasi-Newton optimizer is
never used&mdash;i.e., the <code>BFGS</code> flag is set to <code>FALSE</code>.  It
also implies
that Operator 9 (Local-Minimum Crossover) is set to zero and that
gradient checking (as a convergence criterion) is turned off.  No
matter what other options have been set to,
<code>data.type.int</code> takes precedence&mdash;i.e., if <code>genoud</code> is told that
it is searching over an integer parameter space, gradient
information is never considered. <br />
</p>
<p>There is no option to mix integer and floating point parameters.  If
one wants to mix the two, it is suggested that the user pick integer type 
and in the objective function map a particular integer range into a
floating point number range.  For example, tell <code>genoud</code> to search
from 0 to 100 and divide by 100 to obtain a search grid of 0 to 1.0
(by .1). <br />
</p>
<p>Alternatively, the user could use floating point numbers and round
the appropriate parameters to the nearest integer inside <code>fn</code>
before the criterion (or criteria if <code>lexical = TRUE</code>) is
evaluated. In that case, the <code>transform</code> option can be used to
create the next generation from the current generation when the 
appropriate parameters are in the rounded state.
</p>
</td></tr>
<tr><td><code id="genoud_+3A_hessian">hessian</code></td>
<td>

<p>When this flag is set to <code>TRUE</code>, <code>genoud</code> will return the
hessian matrix at the solution as part of its return list.  A user
can use this matrix to calculate standard errors.</p>
</td></tr>
<tr><td><code id="genoud_+3A_unif.seed">unif.seed</code></td>
<td>
<p>An integer used to seed the random number generator for doubles
called in C++. If the user wants to have reproducibility for the output of 
genoud, they should either set both this and <code>int.seed</code> or use 
<code>set.seed()</code> before calling <code>genoud</code> in R. See the note in the Note 
section below regarding backwards compatibility after Version 5.9-0.0.</p>
</td></tr>
<tr><td><code id="genoud_+3A_int.seed">int.seed</code></td>
<td>
<p>An integer used to seed the random number generator for integers
called in C++. If the user wants to have reproducibility for the output of 
genoud, they should either set both this and <code>unif.seed</code> or use 
<code>set.seed()</code> before calling <code>genoud</code> in R. See the note in the Note 
section below regarding backwards compatibility after Version 5.9-0.0.</p>
</td></tr>
<tr><td><code id="genoud_+3A_print.level">print.level</code></td>
<td>

<p>This variable controls the level of printing that <code>genoud</code> does.  There
are four possible levels: 0 (minimal printing), 1 (normal), 2
(detailed), and 3 (debug).  If level 2 is selected, <code>genoud</code> will
print details about the population at each generation.  The
<code>print.level</code> variable also significantly affects how much
detail is placed in the project file&mdash;see <code>project.path</code>.
Note that R convention would have
us at print level 0 (minimal printing).  However, because <code>genoud</code>
runs may take a long time, it is important for the user to receive
feedback.  Hence, print level 2 has been set as the default.</p>
</td></tr>
<tr><td><code id="genoud_+3A_share.type">share.type</code></td>
<td>

<p>If <code>share.type</code> is equal to 1, then <code>genoud</code>, at
startup, checks to see if there is an existing project file (see
<code>project.path</code>).  If such a file exists, it initializes its
original population using it. This option can be used neither with
the <code>lexical</code> nor the <code>transform</code> options.<br />
</p>
<p>If the project file contains a smaller population than the current
<code>genoud</code> run, <code>genoud</code> will randomly create the necessary individuals.  If
the project file contains a larger population than the current <code>genoud</code>
run, <code>genoud</code> will kill the necessary individuals using exponential
selection. <br />
</p>
<p>If the number of variables (see <code>nvars</code>)
reported in the project file is different from the current <code>genoud</code> run,
<code>genoud</code> does not use the project file (regardless of the value of
<code>share.type</code>) and <code>genoud</code> generates the necessary starting
population at random.</p>
</td></tr>
<tr><td><code id="genoud_+3A_instance.number">instance.number</code></td>
<td>

<p>This number (starting from 0) denotes the number of recursive
instances of <code>genoud</code>.  <code>genoud</code> then sets up its random number
generators and other such structures so that the multiple instances
do not interfere with each other.  It is
up to the user to make certain that the different instances of
<code>genoud</code> are not writing to
the same output file(s): see <code>project.path</code>. <br />
</p>
<p>For the R version of <code>genoud</code> this variable is of limited
use.  It is basically there in case a <code>genoud</code> run is being
used to optimize the result of another <code>genoud</code> run (i.e., a
recursive implementation).</p>
</td></tr>  
<tr><td><code id="genoud_+3A_output.path">output.path</code></td>
<td>
<p>This option is no longer supported. It used to
allow one to redirect the output. Now please use
<code><a href="base.html#topic+sink">sink</a></code>. The option remains in order to provide
backward compatibility for the API.</p>
</td></tr>
<tr><td><code id="genoud_+3A_output.append">output.append</code></td>
<td>
<p>This option is no longer supported. Please see
<code><a href="base.html#topic+sink">sink</a></code>. The option remains in order to provide
backward compatibility for the API.</p>
</td></tr>
<tr><td><code id="genoud_+3A_project.path">project.path</code></td>
<td>
<p> This is the path of the <code>genoud</code> project
file. The project file prints one individual per line with the fit
value(s) printed first and then the parameter values. By default
<code>genoud</code> places its output in a file called &quot;genoud.pro&quot;
located in the temporary directory provided by
<code><a href="base.html#topic+tempdir">tempdir</a></code>.  The behavior of the project file depends
on the <code>print.level</code> chosen.  If the <code>print.level</code>
variable is set to 1, then the project file is rewritten after
each generation.  Therefore, only the currently fully completed
generation is included in the file.  If the <code>print.level</code>
variable is set to 2, then each new generation is simply appended
to the project file.  For <code>print.level=0</code>, the project file
is not created.  </p>
</td></tr> 
<tr><td><code id="genoud_+3A_p1">P1</code></td>
<td>
<p> This is the cloning operator.
<code>genoud</code> always clones the best individual each generation.
But this operator clones others as well.  Please see the Operators
Section for details about operators and how they are weighted.</p>
</td></tr>
<tr><td><code id="genoud_+3A_p2">P2</code></td>
<td>
<p> This is the uniform mutation operator.  One parameter
of the parent is mutated.  Please see the Operators Section for
details about operators and how they are weighted.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_p3">P3</code></td>
<td>

<p>This is the boundary mutation operator.  This operator finds a
parent and mutates one of its parameters towards the boundary.
Please see the Operators Section for details about operators and
how they are weighted.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_p4">P4</code></td>
<td>
<p> Non-Uniform Mutation.  Please
see the Operators Section for details about operators and how they
are weighted.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_p5">P5</code></td>
<td>
<p> This is the polytope crossover.  Please
see the Operators Section for details about operators and how they
are weighted.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_p6">P6</code></td>
<td>
<p> Simple Crossover.  Please see the
Operators Section for details about operators and how they are
weighted.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_p7">P7</code></td>
<td>
<p> Whole Non-Uniform Mutation.  Please see the
Operators Section for details about operators and how they are
weighted.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_p8">P8</code></td>
<td>
<p> Heuristic Crossover.  Please see the
Operators Section for details about operators and how they are
weighted.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_p9">P9</code></td>
<td>
<p> Local-Minimum Crossover: BFGS.  This is
rather CPU intensive, and should be generally used less than the
other operators.  Please see the Operators Section for details
about operators and how they are weighted.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_p9mix">P9mix</code></td>
<td>
<p>This is
a tuning parameter for the <code>P9</code> operator.  The local-minimum
crossover operator by default takes the convex combination of the
result of a BFGS optimization and the parent individual.  By
default the mixing (weight) parameter for the convex combination
is chosen by a uniform random draw between 0 and 1.  The
<code>P9mix</code> option allows the user to select this mixing
parameter.  It may be any number greater than 0 and less than or
equal to 1.  If 1, then the BFGS result is simply used.</p>
</td></tr>
<tr><td><code id="genoud_+3A_bfgsburnin">BFGSburnin</code></td>
<td>
<p>The number of generations which are run before
the BFGS is first used.  Premature use of the BFGS can lead to
convergence to a local optimum instead of the global one.  This
option allows the user to control how many generations are run
before the BFGS is started and would logically be a non-negative
integer. However, if <code>BFGSburnin &lt; 0</code>, the BFGS will be used
if and when <code>wait.generations</code> is doubled because at least
one gradient is too large, which can only occur when
<code>gradient.check = TRUE</code>. This option delays the use of both
the BFGS on the best individual and the <code>P9</code> operator. </p>
</td></tr>
<tr><td><code id="genoud_+3A_bfgsfn">BFGSfn</code></td>
<td>
<p>This is a function for the BFGS optimizer to
optimize, if one wants to make it distinct from the <code>fn</code>
function.  This is useful when doing <code>lexical</code> optimization
because otherwise a derivative based optimizer cannot be used
(since it requires a single fit value).  It is suggested that if
this functionality is being used, both the <code>fn</code> and
<code>BFGSfn</code> functions obtain all of the arguments they need
(except for the parameters being optimized) by lexical scope
instead of being passed in as arguments to the functions.
Alternatively, one may use the <code>BFGShelp</code> option to pass
arguments to <code>BFGSfn</code>. If <code>print.level &gt; 2</code>, the results
from the BFGS optimizer are printed every time it is called.</p>
</td></tr>
<tr><td><code id="genoud_+3A_bfgshelp">BFGShelp</code></td>
<td>
<p>An optional function to pass arguments to
<code>BFGSfn</code>.  This function should take an argument named
&lsquo;initial&rsquo;, an argument named &lsquo;done&rsquo; that defaults to <code>FALSE</code>,
or at least allow <code>...</code>  to be an argument. <code>BFGSfn</code>
must have an argument named &lsquo;helper&rsquo; if <code>BFGShelp</code> is used
because the call to <code><a href="stats.html#topic+optim">optim</a></code> includes the hard-coded
expression <code>helper = do.call(BFGShelp, args = list(initial =
      foo.vals), envir = environment(fn)))</code>, which evaluates the
<code>BFGShelp</code> function in the environment of <code>BFGSfn</code>
(<code>fn</code> is just a wrapper for <code>BFGSfn</code>) at <code>par =
      foo.vals</code> where <code>foo.vals</code> contains the starting values for
the BFGS algorithm. The &lsquo;done&rsquo; argument to <code>BFGSfn</code> is used
if the user requests that the Hessian be calculated at the
<code>genoud</code> solution.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_control">control</code></td>
<td>
<p>A list of control
parameters that is passed to <code><a href="stats.html#topic+optim">optim</a></code> if
<code>BFGS = TRUE</code> or <code>P9 &gt; 0</code>. Please see the
<code><a href="stats.html#topic+optim">optim</a></code> documentation for details.  </p>
</td></tr>
<tr><td><code id="genoud_+3A_optim.method">optim.method</code></td>
<td>
<p>A character string among those that are admissible for the
<code>method</code> argument to the <code><a href="stats.html#topic+optim">optim</a></code> function, namely one of
<code>"BFGS"</code>, <code>"L-BFGS-B"</code>, <code>"Nelder-Mead"</code>, <code>"CG"</code>, or <code>"SANN"</code>.
By default, <code>optim.method</code> is <code>"BFGS"</code> if <code>boundary.enforcement &lt; 2</code>
and is <code>"L-BFGS-B"</code> if <code>boundary.enforcement = 2</code>.  For discontinuous
objective functions, it may be advisable to select <code>"Nelder-Mead"</code> or <code>"SANN"</code>.
If selecting <code>"L-BFGS-B"</code> causes an error message, it may be advisable to
select another method or to adjust the <code>control</code> argument.  Note that the various 
arguments of <code>genoud</code> that involve the four letters &ldquo;BFGS&rdquo; continue to
be passed to <code><a href="stats.html#topic+optim">optim</a></code> even if <code>optim.method != "BFGS"</code>.</p>
</td></tr>
<tr><td><code id="genoud_+3A_transform">transform</code></td>
<td>
<p>A logical that defaults to <code>FALSE</code>.  If
<code>TRUE</code>, it signifies that <code>fn</code> will return a numeric
vector that contains the fit criterion (or fit criteria if
<code>lexical = TRUE</code>), followed by the parameters. If this option
is used, <code>fn</code> should have the following general form in
its body:<br />
<code>par &lt;- myTransformation(par)</code><br />
<code>criter &lt;- myObjective(par)</code><br />
<code>return( c(criter, par) )</code><br />
This option is useful when parameter transformations are necessary
because the next generation of the population will be created from
the current generation in the transformed state, rather than the
original state.  This option can be used by users to implement their
own operators. <br />
</p>
<p>There are some issues that should be kept in mind. This option cannot
be used when <code>data.type.int = TRUE</code>.  Also, this option coerces
<code>MemoryMatrix</code> to be <code>FALSE</code>, implying that the <code>cluster</code>
option cannot be used.  And, unless <code>BFGSfn</code> is specified, this option coerces
<code>gradient.check</code> to <code>FALSE</code>, <code>BFGS</code> to <code>FALSE</code>, 
and <code>P9</code> to <code>0</code>.  If <code>BFGSfn</code> is specified, that function should
perform the transformation but should only return a scalar fit criterion, 
for example:<br />
<code>par &lt;- myTransformation(par)</code><br />
<code>criter &lt;- myCriterion(par)</code><br />
<code>return(criter)</code><br />
</p>
<p>Finally, if <code>boundary.enforcement &gt; 0</code>, care must be taken to
assure that the transformed parameters are within the <code>Domains</code>,
otherwise unpredictable results could occur. In this case, the transformations are
checked for consistency with <code>Domains</code> but only in the initial generation
(to avoid an unacceptable loss in computational speed). </p>
</td></tr>
<tr><td><code id="genoud_+3A_debug">debug</code></td>
<td>
<p> This
variable turns on some debugging information.  This variable may
be <code>TRUE</code> or <code>FALSE</code>.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_cluster">cluster</code></td>
<td>
<p>This can either be an
object of the 'cluster' class returned by one of the
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> commands in the <code>parallel</code> package or a
vector of machine names so <code>genoud</code> can setup the cluster
automatically.  If it is the latter, the vector should look like:
<br /> <code>c("localhost","musil","musil","deckard")</code>.<br /> This
vector would create a cluster with four nodes: one on the
localhost another on &quot;deckard&quot; and two on the machine named
&quot;musil&quot;.  Two nodes on a given machine make sense if the machine
has two or more chips/cores.  <code>genoud</code> will setup a SOCK
cluster by a call to <code><a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a></code>.  This
will require the user to type in her password for each node as the
cluster is by default created via <code>ssh</code>.  One can add on
usernames to the machine name if it differs from the current
shell: &quot;username@musil&quot;.  Other cluster types, such as PVM and
MPI, which do not require passwords can be created by directly
calling <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>, and then passing the
returned cluster object to <code>genoud</code>. For an example of how to
manually setup up a cluster with a direct call to
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> see
<a href="https://github.com/JasjeetSekhon/rgenoud">https://github.com/JasjeetSekhon/rgenoud</a>.
For an example of how to get around a firewall by ssh tunneling
see:
<a href="https://github.com/JasjeetSekhon/rgenoud">https://github.com/JasjeetSekhon/rgenoud</a>.</p>
</td></tr>
<tr><td><code id="genoud_+3A_balance">balance</code></td>
<td>
<p>This logical flag controls if load balancing is
done across the cluster.  Load balancing can result in better
cluster utilization; however, increased communication can reduce
performance.  This option is best used if the function being
optimized takes at least several minutes to calculate or if the
nodes in the cluster vary significantly in their performance. If
cluster==FALSE, this option has no effect.</p>
</td></tr>  
<tr><td><code id="genoud_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>fn</code> and
<code>gr</code>.</p>
</td></tr>  </table>


<h3>Details</h3>

<p><code>Genoud</code> solves problems that are nonlinear or
perhaps even discontinuous in the parameters of the function to be
optimized.  When a statistical model's estimating function (for
example, a log-likelihood) is nonlinear in the model's parameters,
the function to be optimized will generally not be globally
concave and may have irregularities such as saddlepoints or
discontinuities.  Optimization methods that rely on derivatives of
the objective function may be unable to find any optimum at all.
Multiple local optima may exist, so that there is no guarantee
that a derivative-based method will converge to the global
optimum. On the other hand, algorithms that do not use derivative
information (such as pure genetic algorithms) are for many
problems needlessly poor at local hill climbing.  Most statistical
problems are regular in a neighborhood of the solution.
Therefore, for some portion of the search space, derivative
information is useful for such problems.  <code>Genoud</code> also works
well for problems that no derivative information exists. For
additional documentation and examples please see
<a href="https://github.com/JasjeetSekhon/rgenoud">https://github.com/JasjeetSekhon/rgenoud</a>.</p>


<h3>Value</h3>

<p><code>genoud</code> returns a list
with 7 objects.  8 objects are returned if the user has requested
the hessian to be calculated at the solution.  Please see the
<code>hessian</code> option.  The returned objects are:
</p>
<table>
<tr><td><code>value</code></td>
<td>

<p>This variable contains the fitness value at the solution. If
<code>lexical</code> optimization was requested, it is a vector.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>

<p>This vector contains the parameter values found at the solution.</p>
</td></tr>
<tr><td><code>gradients</code></td>
<td>

<p>This vector contains the gradients found at the solution.  If no
gradients were calculated, they are reported to be <code>NA</code>.</p>
</td></tr>
<tr><td><code>generations</code></td>
<td>

<p>This variable contains the number of generations <code>genoud</code> ran for.</p>
</td></tr>
<tr><td><code>peakgeneration</code></td>
<td>

<p>This variable contains the generation number at which <code>genoud</code> found
the solution.</p>
</td></tr>
<tr><td><code>pop.size</code></td>
<td>

<p>This variable contains the population size that <code>genoud</code> actually used.
See <code>pop.size</code> for why this value may differ from the
population size the user requested.</p>
</td></tr>
<tr><td><code>operators</code></td>
<td>

<p>This vector reports the actual number of operators (of each type)
<code>genoud</code> used.  Please see the Operators Section for details.</p>
</td></tr>    
<tr><td><code>hessian</code></td>
<td>

<p>If the user has requested the hessian
matrix to be returned (via the <code>hessian</code> flag), the hessian
at the solution will be returned.  The user may use this matrix to calculate standard
errors.</p>
</td></tr>    
</table>


<h3>Operators</h3>

<p><code>Genoud</code> has nine operators that it uses.  The integer values which are
assigned to each of these operators (P1<code class="reqn">\cdots</code>P9) are
weights.
<code>Genoud</code> calculates the sum of <code class="reqn">s = P1+P2+\cdots+P9</code>.  Each operator is
assigned a weight equal to <code class="reqn">W_{n} = \frac{s}{P_{n}}</code>. The number of
times an operator is called usually equals <code class="reqn">c_{n} = W_{n} \times
    pop.size</code>. <br />
</p>
<p>Operators 6 (Simple Crossover) and 8 (Heuristic
Crossover) require an even number of individuals to work on&mdash;i.e.,
they require two parents.  Therefore, the <code>pop.size</code> variable and
the operators sets must be such that these three operators have an
even number of individuals to work with.  If this does not occur,
<code>genoud</code> automatically upwardly adjusts the population size to make this
constraint hold. <br />
</p>
<p>Strong uniqueness checks have been built into the operators to help
ensure that the operators produce offspring different from their
parents, but this does not always happen. <br />
</p>
<p>Note that <code>genoud</code> always keeps the best individual each generation. <br />
</p>
<p><code>genoud</code>'s 9 operators are: <br />
</p>

<ol>
<li><p> Cloning
</p>
</li>
<li><p> Uniform Mutation
</p>
</li>
<li><p> Boundary Mutation
</p>
</li>
<li><p> Non-Uniform Crossover
</p>
</li>
<li><p> Polytope Crossover
</p>
</li>
<li><p> Simple Crossover
</p>
</li>
<li><p> Whole Non-Uniform Mutation
</p>
</li>
<li><p> Heuristic Crossover
</p>
</li>
<li><p> Local-Minimum Crossover: BFGS</p>
</li></ol>

<p>For more information please see Table 1 of the reference article: 
<a href="https://github.com/JasjeetSekhon/rgenoud">https://github.com/JasjeetSekhon/rgenoud</a>.</p>


<h3>Note</h3>

<p>The most important options affecting performance are those determining
population size (<code>pop.size</code>) and the
number of generations the algorithm runs
(<code>max.generations</code>, <code>wait.generations</code>,
<code>hard.generation.limit</code> and <code>gradient.check</code>).  Search
performance is expected to improve as
the population size and the number of generations the program runs for
increase.  These and the other options should be adjusted for the
problem at hand.  Please pay particular attention to the search
domains (<code>Domains</code> and <code>default.domains</code>). For more information
please see the reference article. <br />
</p>
<p>Linear and nonlinear constraints among the parameters can be
introduced by users in their fit function.  For example, if
the sum of parameters 1 and 2 must be less than 725, the following can
be placed in the fit function the user is going to have <code>genoud</code>
maximize: <code>if ( (parm1 + parm2) &gt;= 725) { return(-99999999) }</code>.
In this example, a very bad fit value is returned to <code>genoud</code> if the
linear constraint is violated.  <code>genoud</code> will then attempt to find
parameter values that satisfy the constraint. <br />
</p>
<p>Alternatively, one can use lexical optimization where the first criterion is a
binary variable that equals 1.0 iff <code> (parm1 + parm2) &lt; 725</code> and the
second criterion is the fit function, which should also be passed to 
<code>BFGSfn</code>. All candidates where <code> (parm1 + parm2) &gt;= 725</code> will be
ranked below all candidates where <code> (parm1 + parm2) &lt; 725</code> and within 
these two groups, candidates will be ranked by their fit on the second 
criterion. The optimal candidate is thus the one with the best fit on the
second criterion among candidates that satisfy this restriction.
</p>
<p>In Version 5.9-0.0 we have changed the implementation of the random number 
generator, so results from this version onward will not be backwards compatible.</p>


<h3>Author(s)</h3>

<p>Walter R. Mebane, Jr., University of Michigan,
<a href="mailto:wmebane@umich.edu">wmebane@umich.edu</a>, <a href="http://www-personal.umich.edu/~wmebane/">http://www-personal.umich.edu/~wmebane/</a> <br />
</p>
<p>Jasjeet S. Sekhon, Yale University, <a href="mailto:jas.sekhon@yale.edu">jas.sekhon@yale.edu</a>,
<a href="https://github.com/JasjeetSekhon/rgenoud">https://github.com/JasjeetSekhon/rgenoud</a> <br />
</p>
<p>Theo Saarinen, UC Berkeley, <a href="mailto:theo_s@berkeley.edu">theo_s@berkeley.edu</a></p>


<h3>References</h3>

<p>Mebane, Walter R., Jr. and Jasjeet S. Sekhon.  2011.  &quot;Genetic
Optimization Using Derivatives: The rgenoud Package for R.&quot;
<em>Journal of Statistical Software</em>, 42(11):  1-26. 
<a href="https://www.jstatsoft.org/v42/i11/">https://www.jstatsoft.org/v42/i11/</a> <br />
</p>
<p>Sekhon, Jasjeet Singh and Walter R. Mebane, Jr. 1998.  &ldquo;Genetic
Optimization Using Derivatives: Theory and Application to Nonlinear
Models.&rdquo; <em>Political Analysis</em>, 7: 187-210.
<a href="https://github.com/JasjeetSekhon/rgenoud">https://github.com/JasjeetSekhon/rgenoud</a> <br />
</p>
<p>Mebane, Walter R., Jr. and Jasjeet S. Sekhon. 2004. &ldquo;Robust
Estimation and Outlier Detection for Overdispersed Multinomial Models
of Count Data.&rdquo;  <em>American Journal of Political Science</em>, 48
(April): 391-410. <a href="https://github.com/JasjeetSekhon/rgenoud">https://github.com/JasjeetSekhon/rgenoud</a> <br />
</p>
<p>Bright, H. and R. Enison. 1979. Quasi-Random Number Sequences from a
Long-Period TLP Generator with Remarks on Application to
Cryptography. <em>Computing Surveys</em>, 11(4): 357-370.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#maximize the sin function
 sin1 &lt;- genoud(sin, nvars=1, max=TRUE)

#minimize the sin function
 sin2 &lt;- genoud(sin, nvars=1, max=FALSE)

## Not run: 
#maximize a univariate normal mixture which looks like a claw
 claw &lt;- function(xx) {
   x &lt;- xx[1]
   y &lt;- (0.46*(dnorm(x,-1.0,2.0/3.0) + dnorm(x,1.0,2.0/3.0)) +
   (1.0/300.0)*(dnorm(x,-0.5,.01) + dnorm(x,-1.0,.01) + dnorm(x,-1.5,.01)) +
   (7.0/300.0)*(dnorm(x,0.5,.07) + dnorm(x,1.0,.07) + dnorm(x,1.5,.07))) 
   return(y)
 }
 claw1   &lt;- genoud(claw, nvars=1,pop.size=3000,max=TRUE)

## End(Not run)

## Not run: 
#Plot the previous run
 xx &lt;- seq(-3,3,.05)
 plot(xx,lapply(xx,claw),type="l",xlab="Parameter",ylab="Fit",
      main="GENOUD: Maximize the Claw Density")
 points(claw1$par,claw1$value,col="red")

# Maximize a bivariate normal mixture which looks like a claw.
 biclaw &lt;- function(xx) {
  mNd2 &lt;- function(x1, x2, mu1, mu2, sigma1, sigma2, rho)
    {
      z1 &lt;- (x1-mu1)/sigma1
      z2 &lt;- (x2-mu2)/sigma2
      w &lt;- (1.0/(2.0*pi*sigma1*sigma2*sqrt(1-rho*rho))) 
      w &lt;- w*exp(-0.5*(z1*z1 - 2*rho*z1*z2 + z2*z2)/(1-rho*rho)) 
      return(w)
    }
  x1 &lt;- xx[1]+1
  x2 &lt;- xx[2]+1
  
  y &lt;- (0.5*mNd2(x1,x2,0.0,0.0,1.0,1.0,0.0) +
	    0.1*(mNd2(x1,x2,-1.0,-1.0,0.1,0.1,0.0) +
		 mNd2(x1,x2,-0.5,-0.5,0.1,0.1,0.0) +
		 mNd2(x1,x2,0.0,0.0,0.1,0.1,0.0) +
		 mNd2(x1,x2,0.5,0.5,0.1,0.1,0.0) +
		 mNd2(x1,x2,1.0,1.0,0.1,0.1,0.0)))

  return(y)
 }
 biclaw1 &lt;- genoud(biclaw, default.domains=20, nvars=2,pop.size=5000,max=TRUE)

## End(Not run)
# For more examples see: https://github.com/JasjeetSekhon/rgenoud.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
