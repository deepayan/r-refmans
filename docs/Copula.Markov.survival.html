<!DOCTYPE html><html><head><title>Help for package Copula.Markov.survival</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Copula.Markov.survival}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ClaytonClayton.Weibull.data'><p>Generate data from the Clayton copula for serial dependence and the Clayton copula for dependent censoring with the Weibull distributions</p></a></li>
<li><a href='#ClaytonClayton.Weibull.MLE'><p>Parameter estimation based on the Clayton copula for serial dependence and the Clayton copula for dependent censoring with the Weibull distributions</p></a></li>
<li><a href='#ClaytonFrank.Weibull.data'><p>Generate data from the Clayton copula for serial dependence and the Frank copula for dependent censoring with the Weibull distributions</p></a></li>
<li><a href='#ClaytonFrank.Weibull.MLE'><p>Parameter estimation based on the Clayton copula for serial dependence and the Frank copula for dependent censoring with the Weibull distributions</p></a></li>
<li><a href='#Copula.Markov.survival'><p>Copula.Markov.survival</p></a></li>
<li><a href='#FrankClayton.Weibull.data'><p>Generate data from the Frank copula for serial dependence and the Clayton copula for dependent censoring with the Weibull distributions</p></a></li>
<li><a href='#FrankClayton.Weibull.MLE'><p>Parameter estimation based on the Frank copula for serial dependence and the Clayton copula for dependent censoring with the Weibull distributions</p></a></li>
<li><a href='#FrankFrank.Weibull.data'><p>Generate data from the Frank copula for serial dependence and the Frank copula for dependent censoring with the Weibull distributions</p></a></li>
<li><a href='#FrankFrank.Weibull.MLE'><p>Parameter estimation based on the Frank copula for serial dependence and the Frank copula for dependent censoring with the Weibull distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Copula Markov Model with Dependent Censoring</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Xin-Wei Huang, Takeshi Emura</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xin-Wei Huang &lt;xinweihuang@hotmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform likelihood estimation and corresponding analysis under the copula-based Markov chain model for serially dependent event times with a dependent terminal event. Available are statistical methods in Huang, Wang and Emura (2020, JJSD accepted).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-20 05:16:34 UTC; HXW</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-20 09:12:18 UTC</td>
</tr>
</table>
<hr>
<h2 id='ClaytonClayton.Weibull.data'>Generate data from the Clayton copula for serial dependence and the Clayton copula for dependent censoring with the Weibull distributions</h2><span id='topic+ClaytonClayton.Weibull.data'></span>

<h3>Description</h3>

<p>The data generation process is based on the Clayton copula C_theta for serial dependence and the Clayton copula tilde(C)_alpha for dependent censoring with the marginal distributions Weib(scale1, shape1) and Weib(scale2, shape2). Censoring percentage can be controlled by constant b. This function is used when doing parametric bootstrap. The guide for using this function shall be explained by Huang (2019), and Huang, Wang and Emura (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClaytonClayton.Weibull.data(N, scale1, shape1, theta, scale2, shape2, alpha,  b, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClaytonClayton.Weibull.data_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.data_+3A_scale1">scale1</code></td>
<td>
<p>scale parameter for Weib(scale1, shape1), scale1 &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.data_+3A_shape1">shape1</code></td>
<td>
<p>shape parameter for Weib(scale1, shape1), shape1 &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.data_+3A_theta">theta</code></td>
<td>
<p>copula parameter for C_theta, theta &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.data_+3A_scale2">scale2</code></td>
<td>
<p>scale parameter for Weib(scale2, shape2), scale2 &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.data_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter for Weib(scale2, shape2), shape2 &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.data_+3A_alpha">alpha</code></td>
<td>
<p>copula parameter for tilde(C)_alpha, alpha &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.data_+3A_b">b</code></td>
<td>
<p>parameter of Unif(0, b) for controlling censoring percentage</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.data_+3A_l">l</code></td>
<td>
<p>length for data generation (default = 300)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Subject</code></td>
<td>
<p>a vector for numbers of subject</p>
</td></tr>
<tr><td><code>T_ij</code></td>
<td>
<p>a vector for event times</p>
</td></tr>
<tr><td><code>delta_ij</code></td>
<td>
<p>a vector for event indicator (=1 if recurrent; =0 if censoring)</p>
</td></tr>
<tr><td><code>T_i_star</code></td>
<td>
<p>a vector for death times</p>
</td></tr>
<tr><td><code>delta_i_star</code></td>
<td>
<p>a vector for death indicator (=1 if death; =0 if censoring)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xinwei Huang
</p>


<h3>References</h3>

<p>Huang XW, Wang W, Emura T (2020) A copula-based Markov chain model for serially dependent event times with a dependent terminal event. Japanese Journal of Statistics &amp; Data Science. Accepted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = ClaytonClayton.Weibull.data(N = 100, scale1 = 1, shape1 =0.5, theta = 2,
                                scale2 = 0.45, shape2 = 0.5, alpha = 2, b = 10, l = 300)

</code></pre>

<hr>
<h2 id='ClaytonClayton.Weibull.MLE'>Parameter estimation based on the Clayton copula for serial dependence and the Clayton copula for dependent censoring with the Weibull distributions</h2><span id='topic+ClaytonClayton.Weibull.MLE'></span>

<h3>Description</h3>

<p>Perform two-stage estimation based on the Clayton copula C_theta for serial dependence and the Clayton copula tilde(C)_alpha for dependent censoring with the marginal distributions Weib(scale1, shape1) and Weib(scale2, shape2). The jackknife method estimates the asymptotic covariance matrix. Parametric bootstrap is applied while doing Kolmogorov-Smirnov tests and Cramer-von Mises test. The guide for using this function shall be explained by Huang (2019), and Huang, Wang and Emura (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClaytonClayton.Weibull.MLE(subject, t.event, event, t.death, death, stageI, Weibull.plot,
                                  jackknife, plot, GOF, GOF.plot, rep.GOF, digit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_subject">subject</code></td>
<td>
<p>a vector for numbers of subject</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_t.event">t.event</code></td>
<td>
<p>a vector for event times</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_event">event</code></td>
<td>
<p>a vector for event indicator (=1 if recurrent; =0 if censoring)</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_t.death">t.death</code></td>
<td>
<p>a vector for death times</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_death">death</code></td>
<td>
<p>a vector for death indicator (=1 if death; =0 if censoring)</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_stagei">stageI</code></td>
<td>
<p>an option to select MLE or LSE method for the 1st-stage optimization</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_weibull.plot">Weibull.plot</code></td>
<td>
<p>if TRUE, show the Weibull probability plot</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_jackknife">jackknife</code></td>
<td>
<p>if TRUE, the jackknife method is used for estimate covariance matrix (default = TRUE)</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_plot">plot</code></td>
<td>
<p>if TRUE, the plots for marginal distributions are shown (default = FALSE)</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_gof">GOF</code></td>
<td>
<p>if TRUE, show the p-values for KS-test and CvM-test</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_gof.plot">GOF.plot</code></td>
<td>
<p>if TRUE, show the model diagnostic plot</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_rep.gof">rep.GOF</code></td>
<td>
<p>repetition number of parametric bootstrap</p>
</td></tr>
<tr><td><code id="ClaytonClayton.Weibull.MLE_+3A_digit">digit</code></td>
<td>
<p>accurate to some decimal places</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When jackknife=FALSE, the corresponding standard error and confidence interval values are shown as NA.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Sample_size</code></td>
<td>
<p>Sample size N</p>
</td></tr>
<tr><td><code>Case</code></td>
<td>
<p>Count for event occurences</p>
</td></tr>
<tr><td><code>scale1</code></td>
<td>
<p>Scale parameter for Weib(scale1, shape1)</p>
</td></tr>
<tr><td><code>shape1</code></td>
<td>
<p>Shape parameter for Weib(scale1, shape1)</p>
</td></tr>
<tr><td><code>scale2</code></td>
<td>
<p>Scale parameter for Weib(scale2, shape2)</p>
</td></tr>
<tr><td><code>shape2</code></td>
<td>
<p>Shape parameter for Weib(scale2, shape2)</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Copula parameter for the Clayton copula C_theta</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Copula parameter for the Clayton copula tilde(C)_alpha</p>
</td></tr>
<tr><td><code>COV</code></td>
<td>
<p>Asymptotic covariance estimated by the jackknife method</p>
</td></tr>
<tr><td><code>KS</code></td>
<td>
<p>Kolmogorov-Smirnov test statistics</p>
</td></tr>
<tr><td><code>p.KS</code></td>
<td>
<p>P-values for Kolmogorov-Smirnov tests</p>
</td></tr>
<tr><td><code>CM</code></td>
<td>
<p>Cramer-von Mises test statistics</p>
</td></tr>
<tr><td><code>p.CM</code></td>
<td>
<p>P-values for Cramer-von Mises tests</p>
</td></tr>
<tr><td><code>Convergence</code></td>
<td>
<p>Convergence results for each stage</p>
</td></tr>
<tr><td><code>Jackknife_error</code></td>
<td>
<p>Count for error in jackknife repititions</p>
</td></tr>
<tr><td><code>Log_likelihood</code></td>
<td>
<p>Log-likelihood values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xinwei Huang
</p>


<h3>References</h3>

<p>Huang XW, Wang W, Emura T (2020) A copula-based Markov chain model for serially dependent event times with a dependent terminal event. Japanese Journal of Statistics &amp; Data Science. Accepted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = ClaytonClayton.Weibull.data(N = 30, scale1 = 1, shape1 =0.5, theta = 2,
                                   scale2 = 0.45, shape2 = 0.5, alpha = 2, b = 10, l = 300)

ClaytonClayton.Weibull.MLE(subject = data$Subject,
                           t.event = data$T_ij, event = data$delta_ij,
                           t.death = data$T_i_star, death = data$delta_i_star,
                           jackknife= TRUE, plot = TRUE)


</code></pre>

<hr>
<h2 id='ClaytonFrank.Weibull.data'>Generate data from the Clayton copula for serial dependence and the Frank copula for dependent censoring with the Weibull distributions</h2><span id='topic+ClaytonFrank.Weibull.data'></span>

<h3>Description</h3>

<p>The data generation process is based on the Clayton copula C_theta for serial dependence and the Frank copula tilde(C)_alpha for dependent censoring with the marginal distributions Weib(scale1, shape1) and Weib(scale2, shape2). Censoring percentage can be controlled by constant b. This function is used when doing parametric bootstrap. The guide for using this function shall be explained by Huang (2019), and Huang, Wang and Emura (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClaytonFrank.Weibull.data(N, scale1, shape1, theta, scale2, shape2, alpha, b, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClaytonFrank.Weibull.data_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.data_+3A_scale1">scale1</code></td>
<td>
<p>scale parameter for Weib(scale1, shape1), scale1 &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.data_+3A_shape1">shape1</code></td>
<td>
<p>shape parameter for Weib(scale1, shape1), shape1 &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.data_+3A_theta">theta</code></td>
<td>
<p>copula parameter for C_theta, theta &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.data_+3A_scale2">scale2</code></td>
<td>
<p>scale parameter for Weib(scale2, shape2), scale2 &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.data_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter for Weib(scale2, shape2), shape2 &gt; 0</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.data_+3A_alpha">alpha</code></td>
<td>
<p>copula parameter for tilde(C)_alpha, alpha <code class="reqn">\neq</code> 0</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.data_+3A_b">b</code></td>
<td>
<p>parameter of Unif(0, b) for controlling censoring percentage</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.data_+3A_l">l</code></td>
<td>
<p>length for data generation (default = 300)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Subject</code></td>
<td>
<p>a vector for numbers of subject</p>
</td></tr>
<tr><td><code>T_ij</code></td>
<td>
<p>a vector for event times</p>
</td></tr>
<tr><td><code>delta_ij</code></td>
<td>
<p>a vector for event indicator (=1 if recurrent; =0 if censoring)</p>
</td></tr>
<tr><td><code>T_i_star</code></td>
<td>
<p>a vector for death times</p>
</td></tr>
<tr><td><code>delta_i_star</code></td>
<td>
<p>a vector for death indicator (=1 if death; =0 if censoring)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xinwei Huang
</p>


<h3>References</h3>

<p>Huang XW, Wang W, Emura T (2020) A copula-based Markov chain model for serially dependent event times with a dependent terminal event. Japanese Journal of Statistics &amp; Data Science. Accepted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = ClaytonFrank.Weibull.data(N = 100, scale1 = 1, shape1 =0.5, theta = 2,
                              scale2 = 0.45, shape2 = 0.5, alpha = 2, b = 10, l = 300)

</code></pre>

<hr>
<h2 id='ClaytonFrank.Weibull.MLE'>Parameter estimation based on the Clayton copula for serial dependence and the Frank copula for dependent censoring with the Weibull distributions</h2><span id='topic+ClaytonFrank.Weibull.MLE'></span>

<h3>Description</h3>

<p>Perform two-stage estimation based on the Clayton copula C_theta for serial dependence and the Frank copula tilde(C)_alpha for dependent censoring with the marginal distributions Weib(scale1, shape1) and Weib(scale2, shape2). The jackknife method estimates the asymptotic covariance matrix. Parametric bootstrap is applied while doing Kolmogorov-Smirnov tests and Cramer-von Mises test. The guide for using this function shall be explained by Huang (2019) and Huang, Wang and Emura (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClaytonFrank.Weibull.MLE(subject, t.event, event, t.death, death, stageI, Weibull.plot,
                                jackknife, plot, GOF, GOF.plot, rep.GOF, digit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_subject">subject</code></td>
<td>
<p>a vector for numbers of subject</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_t.event">t.event</code></td>
<td>
<p>a vector for event times</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_event">event</code></td>
<td>
<p>a vector for event indicator (=1 if recurrent; =0 if censoring)</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_t.death">t.death</code></td>
<td>
<p>a vector for death times</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_death">death</code></td>
<td>
<p>a vector for death indicator (=1 if death; =0 if censoring)</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_stagei">stageI</code></td>
<td>
<p>an option to select MLE or LSE method for the 1st-stage optimization</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_weibull.plot">Weibull.plot</code></td>
<td>
<p>if TRUE, show the Weibull probability plot</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_jackknife">jackknife</code></td>
<td>
<p>if TRUE, the jackknife method is used for estimate covariance matrix (default = TRUE)</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_plot">plot</code></td>
<td>
<p>if TRUE, the plots for marginal distributions are shown (default = FALSE)</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_gof">GOF</code></td>
<td>
<p>if TRUE, show the p-values for KS-test and CvM-test</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_gof.plot">GOF.plot</code></td>
<td>
<p>if TRUE, show the model diagnostic plot</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_rep.gof">rep.GOF</code></td>
<td>
<p>repetition number of parametric bootstrap</p>
</td></tr>
<tr><td><code id="ClaytonFrank.Weibull.MLE_+3A_digit">digit</code></td>
<td>
<p>accurate to some decimal places</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When jackknife=FALSE, the corresponding standard error and confidence interval values are shown as NA.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Sample_size</code></td>
<td>
<p>Sample size N</p>
</td></tr>
<tr><td><code>Case</code></td>
<td>
<p>Count for event occurences</p>
</td></tr>
<tr><td><code>scale1</code></td>
<td>
<p>Scale parameter for Weib(scale1, shape1)</p>
</td></tr>
<tr><td><code>shape1</code></td>
<td>
<p>Shape parameter for Weib(scale1, shape1)</p>
</td></tr>
<tr><td><code>scale2</code></td>
<td>
<p>Scale parameter for Weib(scale2, shape2)</p>
</td></tr>
<tr><td><code>shape2</code></td>
<td>
<p>Shape parameter for Weib(scale2, shape2)</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Copula parameter for the Clayton copula C_theta</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Copula parameter for the Frank copula tilde(C)_alpha</p>
</td></tr>
<tr><td><code>COV</code></td>
<td>
<p>Asymptotic covariance estimated by the jackknife method</p>
</td></tr>
<tr><td><code>KS</code></td>
<td>
<p>Kolmogorov-Smirnov test statistics</p>
</td></tr>
<tr><td><code>p.KS</code></td>
<td>
<p>P-values for Kolmogorov-Smirnov tests</p>
</td></tr>
<tr><td><code>CM</code></td>
<td>
<p>Cramer-von Mises test statistics</p>
</td></tr>
<tr><td><code>p.CM</code></td>
<td>
<p>P-values for Cramer-von Mises tests</p>
</td></tr>
<tr><td><code>Convergence</code></td>
<td>
<p>Convergence results for each stage</p>
</td></tr>
<tr><td><code>Jackknife_error</code></td>
<td>
<p>Count for error in jackknife repititions</p>
</td></tr>
<tr><td><code>Log_likelihood</code></td>
<td>
<p>Log-likelihood values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xinwei Huang
</p>


<h3>References</h3>

<p>Huang XW, Wang W, Emura T (2020) A copula-based Markov chain model for serially dependent event times with a dependent terminal event. Japanese Journal of Statistics &amp; Data Science. Accepted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = ClaytonFrank.Weibull.data(N = 30, scale1 = 1, shape1 =0.5, theta = 2,
                                 scale2 = 0.45, shape2 = 0.5, alpha = 2, b = 10, l = 300)

ClaytonFrank.Weibull.MLE(subject = data$Subject,
                           t.event = data$T_ij, event = data$delta_ij,
                           t.death = data$T_i_star, death = data$delta_i_star,
                           jackknife= TRUE, plot = TRUE)


</code></pre>

<hr>
<h2 id='Copula.Markov.survival'>Copula.Markov.survival</h2><span id='topic+Copula.Markov.survival'></span>

<h3>Description</h3>

<p>Perform likelihood estimation and corresponding analysis under the copula-based Markov chain model for serially dependent event times with a dependent terminal event. A two stage estimation method is applied for estimating model parameters. Two copula functions are used for measuring dependence. One is used for modeling serial dependence in recurrent event times. The other one is for modeling dependent censoring. The baseline hazard functions are modeled by the Weibull distributions. See Huang (2019) &lt;https://etd.lib.nctu.edu.tw/cgi-bin/gs32/ncugsweb.cgi?o=dncucdr&amp;s=id=
</p>


<h3>Author(s)</h3>

<p>Xinwei Huang <a href="mailto:xinweihuang@hotmail.com">xinweihuang@hotmail.com</a>
</p>


<h3>References</h3>

<p>Huang, X.-W. (2019). Likelihood-based inference for copula-based Markov chain models for continuous, discrete, and survival data. NCU library.
</p>

<hr>
<h2 id='FrankClayton.Weibull.data'>Generate data from the Frank copula for serial dependence and the Clayton copula for dependent censoring with the Weibull distributions</h2><span id='topic+FrankClayton.Weibull.data'></span>

<h3>Description</h3>

<p>The data generation process is based on the Frank copula C_theta for serial dependence and the Clayton copula tilde(C)_alpha for dependent censoring with the marginal distributions Weib(scale1, shape1) and Weib(scale2, shape2). Censoring percentage can be controlled by constant c. This function is used when doing parametric bootstrap. The guide for using this function shall be explained by Huang (2019), and Huang, Wang and Emura (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FrankClayton.Weibull.data(N, scale1, shape1, theta, scale2, shape2, alpha, b, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FrankClayton.Weibull.data_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.data_+3A_scale1">scale1</code></td>
<td>
<p>scale parameter for Weib(scale1, shape1), scale1 &gt; 0</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.data_+3A_shape1">shape1</code></td>
<td>
<p>shape parameter for Weib(scale1, shape1), shape1 &gt; 0</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.data_+3A_theta">theta</code></td>
<td>
<p>copula parameter for C_theta, theta <code class="reqn">\neq</code> 0</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.data_+3A_scale2">scale2</code></td>
<td>
<p>scale parameter for Weib(scale2, shape2), scale2 &gt; 0</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.data_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter for Weib(scale2, shape2), shape2 &gt; 0</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.data_+3A_alpha">alpha</code></td>
<td>
<p>copula parameter for tilde(C)_alpha, alpha &gt; 0</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.data_+3A_b">b</code></td>
<td>
<p>parameter of Unif(0, b) for controlling censoring percentage</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.data_+3A_l">l</code></td>
<td>
<p>length for data generation (default = 300)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Subject</code></td>
<td>
<p>a vector for numbers of subject</p>
</td></tr>
<tr><td><code>T_ij</code></td>
<td>
<p>a vector for event times</p>
</td></tr>
<tr><td><code>delta_ij</code></td>
<td>
<p>a vector for event indicator (=1 if recurrent; =0 if censoring)</p>
</td></tr>
<tr><td><code>T_i_star</code></td>
<td>
<p>a vector for death times</p>
</td></tr>
<tr><td><code>delta_i_star</code></td>
<td>
<p>a vector for death indicator (=1 if death; =0 if censoring)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xinwei Huang
</p>


<h3>References</h3>

<p>Huang XW, Wang W, Emura T (2020) A copula-based Markov chain model for serially dependent event times with a dependent terminal event. Japanese Journal of Statistics &amp; Data Science. Accepted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = FrankClayton.Weibull.data(N = 100, scale1 = 1, shape1 =0.5, theta = 2,
                              scale2 = 0.45, shape2 = 0.5, alpha = 2, b = 10, l = 300)

</code></pre>

<hr>
<h2 id='FrankClayton.Weibull.MLE'>Parameter estimation based on the Frank copula for serial dependence and the Clayton copula for dependent censoring with the Weibull distributions</h2><span id='topic+FrankClayton.Weibull.MLE'></span>

<h3>Description</h3>

<p>Perform two-stage estimation based on the Frank copula C_theta for serial dependence and the Clayton copula tilde(C)_alpha for dependent censoring with the marginal distributions Weib(scale1, shape1) and Weib(scale2, shape2). The jackknife method estimates the asymptotic covariance matrix. Parametric bootstrap is applied while doing Kolmogorov-Smirnov tests and Cramer-von Mises test. The guide for using this function shall be explained by Huang (2019), and Huang, Wang and Emura (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FrankClayton.Weibull.MLE(subject, t.event, event, t.death, death, stageI, Weibull.plot,
                               jackknife, plot, GOF, GOF.plot, rep.GOF, digit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_subject">subject</code></td>
<td>
<p>a vector for numbers of subject</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_t.event">t.event</code></td>
<td>
<p>a vector for event times</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_event">event</code></td>
<td>
<p>a vector for event indicator (=1 if recurrent; =0 if censoring)</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_t.death">t.death</code></td>
<td>
<p>a vector for death times</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_death">death</code></td>
<td>
<p>a vector for death indicator (=1 if death; =0 if censoring)</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_stagei">stageI</code></td>
<td>
<p>an option to select MLE or LSE method for the 1st-stage optimization</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_weibull.plot">Weibull.plot</code></td>
<td>
<p>if TRUE, show the Weibull probability plot</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_jackknife">jackknife</code></td>
<td>
<p>if TRUE, the jackknife method is used for estimate covariance matrix (default = TRUE)</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_plot">plot</code></td>
<td>
<p>if TRUE, the plots for marginal distributions are shown (default = FALSE)</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_gof">GOF</code></td>
<td>
<p>if TRUE, show the p-values for KS-test and CvM-test</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_gof.plot">GOF.plot</code></td>
<td>
<p>if TRUE, show the model diagnostic plot</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_rep.gof">rep.GOF</code></td>
<td>
<p>repetition number of parametric bootstrap</p>
</td></tr>
<tr><td><code id="FrankClayton.Weibull.MLE_+3A_digit">digit</code></td>
<td>
<p>accurate to some decimal places</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When jackknife=FALSE, the corresponding standard error and confidence interval values are shown as NA.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Sample_size</code></td>
<td>
<p>Sample size N</p>
</td></tr>
<tr><td><code>Case</code></td>
<td>
<p>Count for event occurences</p>
</td></tr>
<tr><td><code>scale1</code></td>
<td>
<p>Scale parameter for Weib(scale1, shape1)</p>
</td></tr>
<tr><td><code>shape1</code></td>
<td>
<p>Shape parameter for Weib(scale1, shape1)</p>
</td></tr>
<tr><td><code>scale2</code></td>
<td>
<p>Scale parameter for Weib(scale2, shape2)</p>
</td></tr>
<tr><td><code>shape2</code></td>
<td>
<p>Shape parameter for Weib(scale2, shape2)</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Copula parameter for the Frank copula C_theta</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Copula parameter for the Clayton copula tilde(C)_alpha</p>
</td></tr>
<tr><td><code>COV</code></td>
<td>
<p>Asymptotic covariance estimated by the jackknife method</p>
</td></tr>
<tr><td><code>KS</code></td>
<td>
<p>Kolmogorov-Smirnov test statistics</p>
</td></tr>
<tr><td><code>p.KS</code></td>
<td>
<p>P-values for Kolmogorov-Smirnov tests</p>
</td></tr>
<tr><td><code>CM</code></td>
<td>
<p>Cramer-von Mises test statistics</p>
</td></tr>
<tr><td><code>p.CM</code></td>
<td>
<p>P-values for Cramer-von Mises tests</p>
</td></tr>
<tr><td><code>Convergence</code></td>
<td>
<p>Convergence results for each stage</p>
</td></tr>
<tr><td><code>Jackknife_error</code></td>
<td>
<p>Count for error in jackknife repititions</p>
</td></tr>
<tr><td><code>Log_likelihood</code></td>
<td>
<p>Log-likelihood values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xinwei Huang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = FrankClayton.Weibull.data(N = 30, scale1 = 1, shape1 =0.5, theta = 2,
                                 scale2 = 0.45, shape2 = 0.5, alpha = 2, b = 10, l = 300)

 
FrankClayton.Weibull.MLE(subject = data$Subject,
                           t.event = data$T_ij, event = data$delta_ij,
                           t.death = data$T_i_star, death = data$delta_i_star,
                           jackknife= TRUE, plot = TRUE)


</code></pre>

<hr>
<h2 id='FrankFrank.Weibull.data'>Generate data from the Frank copula for serial dependence and the Frank copula for dependent censoring with the Weibull distributions</h2><span id='topic+FrankFrank.Weibull.data'></span>

<h3>Description</h3>

<p>The data generation process is based on the Frank copula C_theta for serial dependence and the Frank copula tilde(C)_alpha for dependent censoring with the marginal distributions Weib(scale1, shape1) and Weib(scale2, shape2). Censoring percentage can be controlled by constant c. This function is used when doing parametric bootstrap. The guide for using this function shall be explained by Huang (2019), and Huang, Wang and Emura (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FrankFrank.Weibull.data(N, scale1, shape1, theta, scale2, shape2, alpha, b, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FrankFrank.Weibull.data_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.data_+3A_scale1">scale1</code></td>
<td>
<p>scale parameter for Weib(scale1, shape1), scale1 &gt; 0</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.data_+3A_shape1">shape1</code></td>
<td>
<p>shape parameter for Weib(scale1, shape1), shape1 &gt; 0</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.data_+3A_theta">theta</code></td>
<td>
<p>copula parameter for C_theta, theta <code class="reqn">\neq</code> 0</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.data_+3A_scale2">scale2</code></td>
<td>
<p>scale parameter for Weib(scale2, shape2), scale2 &gt; 0</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.data_+3A_shape2">shape2</code></td>
<td>
<p>shape parameter for Weib(scale2, shape2), shape2 &gt; 0</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.data_+3A_alpha">alpha</code></td>
<td>
<p>copula parameter for tilde(C)_alpha, alpha <code class="reqn">\neq</code> 0</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.data_+3A_b">b</code></td>
<td>
<p>parameter of Unif(0, b) for controlling censoring percentage</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.data_+3A_l">l</code></td>
<td>
<p>length for data generation (default = 300)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Subject</code></td>
<td>
<p>a vector for numbers of subject</p>
</td></tr>
<tr><td><code>T_ij</code></td>
<td>
<p>a vector for event times</p>
</td></tr>
<tr><td><code>delta_ij</code></td>
<td>
<p>a vector for event indicator (=1 if recurrent; =0 if censoring)</p>
</td></tr>
<tr><td><code>T_i_star</code></td>
<td>
<p>a vector for death times</p>
</td></tr>
<tr><td><code>delta_i_star</code></td>
<td>
<p>a vector for death indicator (=1 if death; =0 if censoring)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xinwei Huang
</p>


<h3>References</h3>

<p>Huang XW, Wang W, Emura T (2020) A copula-based Markov chain model for serially dependent event times with a dependent terminal event. Japanese Journal of Statistics &amp; Data Science. Accepted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = FrankFrank.Weibull.data(N = 100, scale1 = 1, shape1 =0.5, theta = 2,
                            scale2 = 0.45, shape2 = 0.5, alpha = 2, b = 10, l = 300)

</code></pre>

<hr>
<h2 id='FrankFrank.Weibull.MLE'>Parameter estimation based on the Frank copula for serial dependence and the Frank copula for dependent censoring with the Weibull distributions</h2><span id='topic+FrankFrank.Weibull.MLE'></span>

<h3>Description</h3>

<p>Perform two-stage estimation based on the Frank copula C_theta for serial dependence and the Frank copula tilde(C)_alpha for dependent censoring with the marginal distributions Weib(scale1, shape1) and Weib(scale2, shape2). The jackknife method estimates the asymptotic covariance matrix. Parametric bootstrap is applied while doing Kolmogorov-Smirnov tests and Cramer-von Mises test. The guide for using this function shall be explained by Huang (2019), and Huang, Wang and Emura (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FrankFrank.Weibull.MLE(subject, t.event, event, t.death, death, stageI, Weibull.plot,
                              jackknife, plot, GOF, GOF.plot, rep.GOF, digit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_subject">subject</code></td>
<td>
<p>a vector for numbers of subject</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_t.event">t.event</code></td>
<td>
<p>a vector for event times</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_event">event</code></td>
<td>
<p>a vector for event indicator (=1 if recurrent; =0 if censoring)</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_t.death">t.death</code></td>
<td>
<p>a vector for death times</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_death">death</code></td>
<td>
<p>a vector for death vindicator (=1 if death; =0 if censoring)</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_stagei">stageI</code></td>
<td>
<p>an option to select MLE or LSE method for the 1st-stage optimization</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_weibull.plot">Weibull.plot</code></td>
<td>
<p>if TRUE, show the Weibull probability plot</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_jackknife">jackknife</code></td>
<td>
<p>if TRUE, the jackknife method is used for estimate covariance matrix (default = TRUE)</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_plot">plot</code></td>
<td>
<p>if TRUE, the plots for marginal distributions are shown (default = FALSE)</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_gof">GOF</code></td>
<td>
<p>if TRUE, show the p-values for KS-test and CvM-test</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_gof.plot">GOF.plot</code></td>
<td>
<p>if TRUE, show the model diagnostic plot</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_rep.gof">rep.GOF</code></td>
<td>
<p>repetition number of parametric bootstrap</p>
</td></tr>
<tr><td><code id="FrankFrank.Weibull.MLE_+3A_digit">digit</code></td>
<td>
<p>accurate to some decimal places</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When jackknife=FALSE, the corresponding standard error and confidence interval values are shown as NA.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>Sample_size</code></td>
<td>
<p>Sample size N</p>
</td></tr>
<tr><td><code>Case</code></td>
<td>
<p>Count for event occurences</p>
</td></tr>
<tr><td><code>scale1</code></td>
<td>
<p>Scale parameter for Weib(scale1, shape1)</p>
</td></tr>
<tr><td><code>shape1</code></td>
<td>
<p>Shape parameter for Weib(scale1, shape1)</p>
</td></tr>
<tr><td><code>scale2</code></td>
<td>
<p>Scale parameter for Weib(scale2, shape2)</p>
</td></tr>
<tr><td><code>shape2</code></td>
<td>
<p>Shape parameter for Weib(scale2, shape2)</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Copula parameter for the Frank copula C_theta</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Copula parameter for the Frank copula tilde(C)_alpha</p>
</td></tr>
<tr><td><code>COV</code></td>
<td>
<p>Asymptotic covariance estimated by the jackknife method</p>
</td></tr>
<tr><td><code>KS</code></td>
<td>
<p>Kolmogorov-Smirnov test statistics</p>
</td></tr>
<tr><td><code>p.KS</code></td>
<td>
<p>P-values for Kolmogorov-Smirnov tests</p>
</td></tr>
<tr><td><code>CM</code></td>
<td>
<p>Cramer-von Mises test statistics</p>
</td></tr>
<tr><td><code>p.CM</code></td>
<td>
<p>P-values for Cramer-von Mises tests</p>
</td></tr>
<tr><td><code>Convergence</code></td>
<td>
<p>Convergence results for each stage</p>
</td></tr>
<tr><td><code>Jackknife_error</code></td>
<td>
<p>Count for error in jackknife repititions</p>
</td></tr>
<tr><td><code>Log_likelihood</code></td>
<td>
<p>Log-likelihood values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xinwei Huang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = FrankFrank.Weibull.data(N = 300, scale1 = 1, shape1 =0.5, theta = 2,
                               scale2 = 0.45, shape2 = 0.5, alpha = 2, b = 10, l = 300)


FrankFrank.Weibull.MLE(subject = data$Subject,
                           t.event = data$T_ij, event = data$delta_ij,
                           t.death = data$T_i_star, death = data$delta_i_star,
                           jackknife= TRUE, plot = TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
